diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWDictionary.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWDictionary.java
deleted file mode 100644
index d71cc180ac..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWDictionary.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.filter;
-
-import java.io.IOException;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * This is the used for the LZWDecode filter. This represents the dictionary mappings
- * between codes and their values.
- *
- * @author Ben Litchfield
- */
-final class LZWDictionary
-{
-    private Map<Long,byte[]> codeToData = new HashMap<Long,byte[]>();
-    private LZWNode root = new LZWNode(0);
-
-    private byte[] buffer = new byte[8];
-    private int bufferNextWrite = 0;
-    private long nextCode = 258;
-    private int codeSize = 9;
-
-    private LZWNode previous = null;
-    private LZWNode current = root;
-
-    /*
-     * This will get the value for the code.  It will return null if the code is not defined.
-     */
-    public byte[] getData(long code)
-    {
-        byte[] result = codeToData.get(code);
-        if (result == null && code < 256) 
-        {
-            addRootNode((byte) code);
-            result = codeToData.get(code);
-        }
-        return result;
-    }
-
-    /*
-     * This will take a visit from a byte[].  This will create new code entries as necessary.
-     */
-    public void visit(byte[] data) throws IOException
-    {
-        for(int i=0; i<data.length; i++)
-        {
-            visit(data[i]);
-        }
-    }
-
-    /*
-     * This will take a visit from a byte.  This will create new code entries as necessary.
-     */
-    public void visit(byte data) throws IOException
-    {
-        if (buffer.length == bufferNextWrite) 
-        {
-            final byte[] nextBuffer = new byte[2*buffer.length];
-            System.arraycopy(buffer, 0, nextBuffer, 0, buffer.length);
-            buffer = nextBuffer;
-        }
-        buffer[bufferNextWrite++] = data;
-        previous = current;
-        current = current.getNode(data);
-        if (current == null) 
-        {
-            final long code;
-            if (previous == root) 
-            {
-                code = data & 0xFF;
-            } 
-            else 
-            {
-                code = nextCode++;
-            }
-            current = new LZWNode(code);
-            previous.setNode(data, current);
-            byte[] sav = new byte[bufferNextWrite];
-            System.arraycopy(buffer, 0, sav, 0, bufferNextWrite);
-            codeToData.put(code,  sav);
-
-            /*
-            System.out.print("Adding " + code + "='");
-            for(int i=0; i<bufferNextWrite; i++)
-            {
-                String hex = Integer.toHexString(((buffer[i]&0xFF);
-                if(hex.length() <=1)
-                {
-                    hex = "0" + hex;
-                }
-                if(i != bufferNextWrite -1)
-                {
-                    hex += " ";
-                }
-                System.out.print(hex.toUpperCase());
-            }
-            System.out.println("'");
-            **/
-            bufferNextWrite = 0;
-            current = root;
-            visit(data);
-            resetCodeSize();
-        }
-    }
-
-    /*
-     * This will get the next code that will be created.
-     * @return The next code to be created.
-     */
-    public long getNextCode()
-    {
-        return nextCode;
-    }
-
-    /*
-     * This will get the size of the code in bits, 9, 10, or 11.
-     */
-    public int getCodeSize()
-    {
-        return codeSize;
-    }
-
-    /*
-     * This will return the code size.
-     */
-    private void resetCodeSize()
-    {
-        if (nextCode < 512) 
-        {
-            codeSize = 9;
-        } 
-        else if (nextCode < 1024) 
-        {
-            codeSize = 10;
-        } 
-        else if (nextCode < 2048) 
-        {
-            codeSize = 11;
-        } 
-        else 
-        {
-            codeSize = 12;
-        }
-    }
-
-    /*
-     * This will clear the internal buffer that the dictionary uses.
-     */
-    public void clear()
-    {
-        bufferNextWrite = 0;
-        current = root;
-        previous = null;
-    }
-
-    /*
-     * This will follow the path to the data node.
-     */
-    public LZWNode getNode(byte[] data)
-    {
-        LZWNode result = root.getNode(data);
-        if (result == null && data.length == 1) 
-        {
-            result = addRootNode(data[0]);
-        }
-        return result;
-    }
-
-    private LZWNode addRootNode(byte b) 
-    {
-        long code = b & 0xFF;
-        LZWNode result = new LZWNode(code);
-        root.setNode(b, result);
-        codeToData.put(code, new byte[] { b });
-        return result;
-    }
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWFilter.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWFilter.java
index 3f1915d7f8..088d610217 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWFilter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWFilter.java
@@ -1,10 +1,9 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Copyright 2014 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
@@ -16,183 +15,259 @@
  */
 package org.apache.pdfbox.filter;
 
-import java.io.ByteArrayOutputStream;
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.PushbackInputStream;
-import java.io.StreamCorruptedException;
-
+import java.util.ArrayList;
+import java.util.Arrays;
+import javax.imageio.stream.MemoryCacheImageInputStream;
+import javax.imageio.stream.MemoryCacheImageOutputStream;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSDictionary;
 
-import org.apache.pdfbox.io.NBitInputStream;
-import org.apache.pdfbox.io.NBitOutputStream;
-
 /**
- * This is the used for the LZWDecode filter.
  *
- * @author Ben Litchfield
+ * This is the filter used for the LZWDecode filter.
+ *
+ * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
+ * @author Tilman Hausherr
  */
-final class LZWFilter extends Filter
+public class LZWFilter extends Filter
 {
+    /**
+     * Log instance.
+     */
+    private static final Log LOG = LogFactory.getLog(LZWFilter.class);
+
+    /**
+     * The LZW clear table code.
+     */
     public static final long CLEAR_TABLE = 256;
+
+    /**
+     * The LZW end of data code.
+     */
     public static final long EOD = 257;
 
+    /**
+     * The LZW code table.
+     */
+    private ArrayList<byte[]> codeTable = null;
+
+    /**
+     * {@inheritDoc}
+     */
     @Override
     protected final DecodeResult decode(InputStream encoded, OutputStream decoded,
-                                         COSDictionary parameters) throws IOException
+            COSDictionary parameters) throws IOException
     {
-        //log.debug("decode()");
-        NBitInputStream in = new NBitInputStream(encoded);
-        in.setBitsInChunk(9);
-        LZWDictionary dic = new LZWDictionary();
-        byte firstByte = 0;
-        long nextCommand;
-        while ((nextCommand = in.read()) != EOD)
-        {
-            // log.debug("decode - nextCommand=" + nextCommand + ", bitsInChunk: " + in.getBitsInChunk());
+        codeTable = null;
+        int chunk = 9;
+        MemoryCacheImageInputStream in = new MemoryCacheImageInputStream(encoded);
+        long nextCommand = 0;
+        long prevCommand = -1;
 
-            if (nextCommand == CLEAR_TABLE)
-            {
-                in.setBitsInChunk(9);
-                dic = new LZWDictionary();
-            }
-            else
+        try
+        {
+            while ((nextCommand = in.readBits(chunk)) != EOD)
             {
-                byte[] data = dic.getData(nextCommand);
-                if (data == null)
-                {
-                    dic.visit(firstByte);
-                    data = dic.getData(nextCommand);
-                    dic.clear();
-                }
-                if (data == null)
+                if (nextCommand == CLEAR_TABLE)
                 {
-                    throw new StreamCorruptedException("Error: data is null");
-                }
-                dic.visit(data);
-
-                //log.debug("decode - dic.getNextCode(): " + dic.getNextCode());
-
-                if (dic.getNextCode() >= 2047)
-                {
-                    in.setBitsInChunk(12);
-                }
-                else if (dic.getNextCode() >= 1023)
-                {
-                    in.setBitsInChunk(11);
-                }
-                else if (dic.getNextCode() >= 511)
-                {
-                    in.setBitsInChunk(10);
+                    chunk = 9;
+                    initCodeTable();
+                    prevCommand = -1;
                 }
                 else
                 {
-                    in.setBitsInChunk(9);
+                    if (nextCommand < codeTable.size())
+                    {
+                        byte[] data = codeTable.get((int) nextCommand);
+                        byte firstByte = data[0];
+                        decoded.write(data);
+                        if (prevCommand != -1)
+                        {
+                            data = codeTable.get((int) prevCommand);
+                            byte[] newData = Arrays.copyOf(data, data.length + 1);
+                            newData[data.length] = firstByte;
+                            codeTable.add(newData);
+                        }
+                    }
+                    else
+                    {
+                        byte[] data = codeTable.get((int) prevCommand);
+                        byte[] newData = Arrays.copyOf(data, data.length + 1);
+                        newData[data.length] = data[0];
+                        decoded.write(newData);
+                        codeTable.add(newData);
+                    }
+                    if (codeTable.size() >= 2047)
+                    {
+                        chunk = 12;
+                    }
+                    else if (codeTable.size() >= 1023)
+                    {
+                        chunk = 11;
+                    }
+                    else if (codeTable.size() >= 511)
+                    {
+                        chunk = 10;
+                    }
+                    else
+                    {
+                        chunk = 9;
+                    }
+                    prevCommand = nextCommand;
                 }
-                /**
-                if (in.getBitsInChunk() != dic.getCodeSize())
-                {
-                    in.unread(nextCommand);
-                    in.setBitsInChunk(dic.getCodeSize());
-                    System.out.print("Switching " + nextCommand + " to ");
-                    nextCommand = in.read();
-                    System.out.println("" +  nextCommand);
-                    data = dic.getData(nextCommand);
-                }**/
-                firstByte = data[0];
-                decoded.write(data);
             }
         }
+        catch (EOFException ex)
+        {
+            LOG.warn("Premature EOF in LZW stream, EOD code missing");
+        }
         decoded.flush();
         return new DecodeResult(parameters);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     protected final void encode(InputStream rawData, OutputStream encoded, COSDictionary parameters)
             throws IOException
     {
-        //log.debug("encode()");
-        PushbackInputStream input = new PushbackInputStream(rawData, 4096);
-        LZWDictionary dic = new LZWDictionary();
-        NBitOutputStream out = new NBitOutputStream(encoded);
-        out.setBitsInChunk(9); //initially nine
-        out.write(CLEAR_TABLE);
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        int byteRead = 0;
-        for (int i = 0; (byteRead = input.read()) != -1; i++)
-        {
-            //log.debug("byteRead = '" + (char)byteRead + "' (0x" + Integer.toHexString(byteRead) + "), i=" + i);
-            buffer.write(byteRead);
-            dic.visit((byte)byteRead);
-            out.setBitsInChunk(dic.getCodeSize());
+        initCodeTable();
+        int chunk = 9;
 
-            //log.debug("Getting node '" + new String(buffer.toByteArray()) + "', buffer.size = " + buffer.size());
-            LZWNode node = dic.getNode(buffer.toByteArray());
-            int nextByte = input.read();
-            if (nextByte != -1)
+        byte[] inputPattern = null;
+        MemoryCacheImageOutputStream out = new MemoryCacheImageOutputStream(encoded);
+        out.writeBits(CLEAR_TABLE, chunk);
+        int foundCode = -1;
+        int r;
+        while ((r = rawData.read()) != -1)
+        {
+            byte by = (byte) r;
+            if (inputPattern == null)
             {
-                //log.debug("nextByte = '" + (char)nextByte + "' (0x" + Integer.toHexString(nextByte) + ")");
-                LZWNode next = node.getNode((byte)nextByte);
-                if (next == null)
+                inputPattern = new byte[]
                 {
-                    //log.debug("encode - No next node, writing node and resetting buffer (" +
-                    //          " node.getCode: " + node.getCode() + ")" +
-                    //          " bitsInChunk: " + out.getBitsInChunk() +
-                    //          ")");
-                    out.write(node.getCode());
-                    buffer.reset();
-                }
-
-                input.unread(nextByte);
+                    by
+                };
+                foundCode = by & 0xff;
             }
             else
             {
-                //log.debug("encode - EOF on lookahead: writing node, resetting buffer, and terminating read loop (" +
-                //          " node.getCode: " + node.getCode() + ")" +
-                //          " bitsInChunk: " + out.getBitsInChunk() +
-                //          ")");
-                out.write(node.getCode());
-                buffer.reset();
-                break;
-            }
+                inputPattern = Arrays.copyOf(inputPattern, inputPattern.length + 1);
+                inputPattern[inputPattern.length - 1] = by;
+                int newFoundCode = findPatternCode(codeTable, inputPattern);
+                if (newFoundCode == -1)
+                {
+                    // use previous
+                    out.writeBits(foundCode, chunk);
+                    // create new table entry
+                    codeTable.add(inputPattern);
 
-            if (dic.getNextCode() == 4096)
+                    if (codeTable.size() == 4096)
+                    {
+                        // code table is full
+                        out.writeBits(CLEAR_TABLE, chunk);
+                        chunk = 9;
+                        initCodeTable();
+                    }
+
+                    inputPattern = new byte[]
+                    {
+                        by
+                    };
+                    foundCode = by & 0xff;
+                }
+                else
+                {
+                    foundCode = newFoundCode;
+                }
+            }
+            if (codeTable.size() - 1 >= 2047)
             {
-                //log.debug("encode - Clearing dictionary and unreading pending buffer data (" +
-                //          " bitsInChunk: " + out.getBitsInChunk() +
-                //          ")");
-                out.write(CLEAR_TABLE);
-                dic = new LZWDictionary();
-                input.unread(buffer.toByteArray());
-                buffer.reset();
+                chunk = 12;
+            }
+            else if (codeTable.size() - 1 >= 1023)
+            {
+                chunk = 11;
+            }
+            else if (codeTable.size() - 1 >= 511)
+            {
+                chunk = 10;
+            }
+            else
+            {
+                chunk = 9;
             }
         }
-
-        // Fix the code size based on the fact that we are writing the EOD
-        //
-        if (dic.getNextCode() >= 2047)
-        {
-            out.setBitsInChunk(12);
-        }
-        else if (dic.getNextCode() >= 1023)
+        if (foundCode != -1)
         {
-            out.setBitsInChunk(11);
+            out.writeBits(foundCode, chunk);
         }
-        else if (dic.getNextCode() >= 511)
+        out.writeBits(EOD, chunk);
+        out.writeBits(0, 7);
+        out.flush(); // must do or file will be empty :-(
+        codeTable.clear();
+    }
+
+    /**
+     * Find the longest matching pattern in the code table.
+     *
+     * @param codeTable The LZW code table.
+     * @param pattern The pattern to be searched for.
+     * @return The index of the longest matching pattern or -1 if nothing is
+     * found.
+     */
+    private int findPatternCode(ArrayList<byte[]> codeTable, byte[] pattern)
+    {
+        int foundCode = -1;
+        int foundLen = 0;
+        for (int i = codeTable.size() - 1; i >= 0; --i)
         {
-            out.setBitsInChunk(10);
+            if (i <= EOD)
+            {
+                // we're in the single byte area
+                if (foundCode != -1)
+                {
+                    return foundCode; // we already found pattern with size > 1
+                }
+                else if (pattern.length > 1)
+                {
+                    return -1; // we won't find anything here anyway
+                }
+            }
+            byte[] tryPattern = codeTable.get(i);
+            if (foundCode != -1 || tryPattern.length > foundLen)
+            {
+                if (Arrays.equals(tryPattern, pattern))
+                {
+                    foundCode = i;
+                    foundLen = tryPattern.length;
+                }
+            }
         }
-        else
+        return foundCode;
+    }
+
+    /**
+     * Init the code table with 1 byte entries and the EOD and CLEAR_TABLE
+     * markers.
+     */
+    private void initCodeTable()
+    {
+        codeTable = new ArrayList<byte[]>(4096);
+        for (int i = 0; i < 256; ++i)
         {
-            out.setBitsInChunk(9);
+            codeTable.add(new byte[]
+            {
+                (byte) (i & 0xFF)
+            });
         }
-
-        //log.debug("encode - Writing EOD (" +
-        //          " bitsInChunk: " + out.getBitsInChunk() +
-        //          ")");
-        out.write(EOD);
-        out.close();
-        encoded.flush();
+        codeTable.add(null); // 256 EOD
+        codeTable.add(null); // 257 CLEAR_TABLE
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWNode.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWNode.java
deleted file mode 100644
index 1e4dc14244..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/LZWNode.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.filter;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * This is the used for the LZWDecode filter.
- *
- * @author Ben Litchfield
- */
-final class LZWNode
-{
-    private final long code;
-    private final Map<Byte, LZWNode> subNodes = new HashMap<Byte, LZWNode>();
-
-    public LZWNode(long codeValue) 
-    {
-        code = codeValue;
-    }
-
-    /*
-     * This will get the number of children.
-     */
-    public int childCount()
-    {
-        return subNodes.size();
-    }
-
-    /*
-     * This will set the node for a particular byte.
-     */
-    public void setNode(byte b, LZWNode node)
-    {
-        subNodes.put(b, node);
-    }
-
-    /*
-     * This will get the node that is a direct sub node of this node.
-     */
-    public LZWNode getNode(byte data)
-    {
-        return subNodes.get(data);
-    }
-
-    /*
-     * This will traverse the tree until it gets to the sub node.
-     * This will return null if the node does not exist.
-     */
-    public LZWNode getNode(byte[] data)
-    {
-        LZWNode current = this;
-        for (int i = 0; i < data.length && current != null; i++)
-        {
-            current = current.getNode(data[i]);
-        }
-        return current;
-    }
-
-    /*
-     * Returns the property code
-     */
-    public long getCode()
-    {
-        return code;
-    }
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/NBitInputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/io/NBitInputStream.java
deleted file mode 100644
index cc6d1585fd..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/NBitInputStream.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import java.io.InputStream;
-import java.io.IOException;
-
-/**
- * This is an n-bit input stream.  This means that you can read chunks of data
- * as any number of bits, not just 8 bits like the regular input stream.  Just set the
- * number of bits that you would like to read on each call.  The default is 8.
- *
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.4 $
- */
-public class NBitInputStream
-{
-    private int bitsInChunk;
-    private InputStream in;
-
-    private int currentByte;
-    private int bitsLeftInCurrentByte;
-
-    /**
-     * Constructor.
-     *
-     * @param is The input stream to read from.
-     */
-    public NBitInputStream( InputStream is )
-    {
-        in = is;
-        bitsLeftInCurrentByte = 0;
-        bitsInChunk = 8;
-    }
-
-    /**
-     * This will unread some data.
-     *
-     * @param data The data to put back into the stream.
-     */
-    public void unread( long data )
-    {
-        data <<= bitsLeftInCurrentByte;
-        currentByte |= data;
-        bitsLeftInCurrentByte += bitsInChunk;
-    }
-
-    /**
-     * This will read the next n bits from the stream and return the unsigned
-     * value of  those bits.
-     *
-     * @return The next n bits from the stream.
-     *
-     * @throws IOException If there is an error reading from the underlying stream.
-     */
-    public long read() throws IOException
-    {
-        long retval = 0;
-        for( int i=0; i<bitsInChunk && retval != -1; i++ )
-        {
-            if( bitsLeftInCurrentByte == 0 )
-            {
-                currentByte = in.read();
-                bitsLeftInCurrentByte = 8;
-            }
-            if( currentByte == -1 )
-            {
-                retval = -1;
-            }
-            else
-            {
-                retval <<= 1;
-                retval |= ((currentByte >> (bitsLeftInCurrentByte-1))&0x1);
-                bitsLeftInCurrentByte--;
-            }
-        }
-        return retval;
-    }
-
-    /** Getter for property bitsToRead.
-     * @return Value of property bitsToRead.
-     */
-    public int getBitsInChunk()
-    {
-        return bitsInChunk;
-    }
-
-    /** Setter for property bitsToRead.
-     * @param bitsInChunkValue New value of property bitsToRead.
-     */
-    public void setBitsInChunk(int bitsInChunkValue)
-    {
-        bitsInChunk = bitsInChunkValue;
-    }
-
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/NBitOutputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/io/NBitOutputStream.java
deleted file mode 100644
index 4127c1fd77..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/NBitOutputStream.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import java.io.OutputStream;
-import java.io.IOException;
-
-/**
- * This is an n-bit output stream.  This means that you write data in n-bit chunks.
- *
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.4 $
- */
-public class NBitOutputStream
-{
-    private int bitsInChunk;
-    private OutputStream out;
-
-    private int currentByte;
-    private int positionInCurrentByte;
-
-    /**
-     * Constructor.
-     *
-     * @param os The output stream to write to.
-     */
-    public NBitOutputStream( OutputStream os )
-    {
-        out = os;
-        currentByte = 0;
-        positionInCurrentByte = 7;
-    }
-
-    /**
-     * This will write the next n-bits to the stream.
-     *
-     * @param chunk The next chunk of data to write.
-     *
-     * @throws IOException If there is an error writing the chunk.
-     */
-    public void write( long chunk ) throws IOException
-    {
-        long bitToWrite;
-        for( int i=(bitsInChunk-1); i>=0; i-- )
-        {
-            bitToWrite = (chunk >> i) & 0x1;
-            bitToWrite <<= positionInCurrentByte;
-            currentByte |= bitToWrite;
-            positionInCurrentByte--;
-            if( positionInCurrentByte < 0 )
-            {
-                out.write( currentByte );
-                currentByte = 0;
-                positionInCurrentByte = 7;
-            }
-        }
-    }
-
-    /**
-     * This will close the stream.
-     *
-     * @throws IOException if there is an error closing the stream.
-     */
-    public void close() throws IOException
-    {
-        if( positionInCurrentByte < 7 )
-        {
-            out.write( currentByte );
-        }
-    }
-
-    /** Getter for property bitsToRead.
-     * @return Value of property bitsToRead.
-     */
-    public int getBitsInChunk()
-    {
-        return bitsInChunk;
-    }
-
-    /** Setter for property bitsToRead.
-     * @param bitsInChunkValue New value of property bitsToRead.
-     */
-    public void setBitsInChunk(int bitsInChunkValue)
-    {
-        bitsInChunk = bitsInChunkValue;
-    }
-
-}
