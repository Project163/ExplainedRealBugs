diff --git a/pdfbox/src/main/java/org/apache/pdfbox/multipdf/Splitter.java b/pdfbox/src/main/java/org/apache/pdfbox/multipdf/Splitter.java
index 2263142075..dd7300469e 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/multipdf/Splitter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/multipdf/Splitter.java
@@ -18,21 +18,42 @@ package org.apache.pdfbox.multipdf;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.LogManager;
+
+import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.cos.COSObject;
 import org.apache.pdfbox.io.RandomAccessStreamCache.StreamCacheCreateFunction;
 import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.PDDocumentInformation;
 import org.apache.pdfbox.pdmodel.PDPage;
+import org.apache.pdfbox.pdmodel.PDPageTree;
+import org.apache.pdfbox.pdmodel.PDResources;
+import org.apache.pdfbox.pdmodel.PDStructureElementNameTreeNode;
+import org.apache.pdfbox.pdmodel.common.COSObjectable;
+import org.apache.pdfbox.pdmodel.common.PDNameTreeNode;
+import org.apache.pdfbox.pdmodel.common.PDNumberTreeNode;
+import org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDParentTreeValue;
+import org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureElement;
+import org.apache.pdfbox.pdmodel.documentinterchange.logicalstructure.PDStructureTreeRoot;
+import org.apache.pdfbox.pdmodel.graphics.PDXObject;
+import org.apache.pdfbox.pdmodel.graphics.form.PDFormXObject;
+import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
 import org.apache.pdfbox.pdmodel.interactive.action.PDAction;
 import org.apache.pdfbox.pdmodel.interactive.action.PDActionGoTo;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink;
+import org.apache.pdfbox.pdmodel.interactive.annotation.PDAppearanceStream;
 import org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDDestination;
 import org.apache.pdfbox.pdmodel.interactive.documentnavigation.destination.PDPageDestination;
 
@@ -53,6 +74,10 @@ public class Splitter
     private int startPage = Integer.MIN_VALUE;
     private int endPage = Integer.MAX_VALUE;
     private List<PDDocument> destinationDocuments;
+    private Map<COSDictionary, COSDictionary> pageDictMap;
+    private Map<COSDictionary, COSDictionary> structDictMap;
+    private Set<String> idSet;
+    private Set<COSName> roleSet;
 
     private int currentPageNumber;
 
@@ -94,10 +119,354 @@ public class Splitter
         currentPageNumber = 0;
         destinationDocuments = new ArrayList<>();
         sourceDocument = document;
+        pageDictMap = new HashMap<>();
+        idSet = new HashSet<>();
+        roleSet = new HashSet<>();
+
         processPages();
+
+        for (PDDocument destinationDocument : destinationDocuments)
+        {
+            cloneStructureTree(destinationDocument);
+        }
+
         return destinationDocuments;
     }
 
+    /**
+     * Clone the structure tree from the source to the current destination document.
+     *
+     * @param destinationDocument
+     * @throws IOException 
+     */
+    private void cloneStructureTree(PDDocument destinationDocument) throws IOException
+    {
+        PDStructureTreeRoot srcStructureTreeRoot = sourceDocument.getDocumentCatalog().getStructureTreeRoot();
+        if (srcStructureTreeRoot == null)
+        {
+            return;
+        }
+        structDictMap = new HashMap<>();
+        PDStructureTreeRoot dstStructureTreeRoot = new PDStructureTreeRoot();
+        PDPageTree dstPageTree = destinationDocument.getPages();
+
+        // clone /K, also fills dictMap
+        COSBase k1 = srcStructureTreeRoot.getK();
+        COSBase k2 = new KCloner(dstPageTree).createClone(k1, dstStructureTreeRoot.getCOSObject(), null);
+        dstStructureTreeRoot.setK(k2);
+
+        // transfer ParentTree using the map because the dictionaries are all found in the /K structure.
+        PDNumberTreeNode srcParentTree = srcStructureTreeRoot.getParentTree();
+        Map<Integer, COSObjectable> srcNumberTreeAsMap = PDFMergerUtility.getNumberTreeAsMap(srcParentTree);
+        Map<Integer, COSObjectable> dstNumberTreeAsMap = new LinkedHashMap<>();
+        for (int p = 0; p < dstPageTree.getCount(); ++p)
+        {
+            PDPage page = dstPageTree.get(p);
+            int sp1 = page.getStructParents();
+            if (sp1 != -1)
+            {
+                cloneTreeElement(srcNumberTreeAsMap, dstNumberTreeAsMap, sp1);
+            }
+            for (PDAnnotation ann : page.getAnnotations())
+            {
+                int sp2 = ann.getStructParent();
+                if (sp2 != -1)
+                {
+                    cloneTreeElement(srcNumberTreeAsMap, dstNumberTreeAsMap, sp2);
+                }
+                PDAppearanceStream normalAppearanceStream = ann.getNormalAppearanceStream();
+                if (normalAppearanceStream != null)
+                {
+                    processResources(normalAppearanceStream.getResources(), srcNumberTreeAsMap, dstNumberTreeAsMap, new HashSet<>());
+                }
+            }
+            processResources(page.getResources(), srcNumberTreeAsMap, dstNumberTreeAsMap, new HashSet<>());
+        }
+        PDNumberTreeNode dstNumberTreeNode = new PDNumberTreeNode(PDParentTreeValue.class);
+        dstNumberTreeNode.setNumbers(dstNumberTreeAsMap);
+        dstStructureTreeRoot.setParentTree(dstNumberTreeNode);
+
+        dstStructureTreeRoot.setParentTreeNextKey(srcStructureTreeRoot.getParentTreeNextKey());
+        dstStructureTreeRoot.setClassMap(srcStructureTreeRoot.getClassMap());
+        cloneRoleMap(srcStructureTreeRoot, dstStructureTreeRoot);
+        cloneIDTree(srcStructureTreeRoot, dstStructureTreeRoot);
+
+        destinationDocument.getDocumentCatalog().setStructureTreeRoot(dstStructureTreeRoot);
+    }
+
+    private void cloneIDTree(PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree)
+            throws IOException
+    {
+        PDNameTreeNode<PDStructureElement> srcIDTree = srcStructTree.getIDTree();
+        if (srcIDTree == null)
+        {
+            return;
+        }
+        Map<String, PDStructureElement> srcIDTreeAsMap = PDFMergerUtility.getIDTreeAsMap(srcIDTree);
+        Map<String, PDStructureElement> destNames = new HashMap<>();
+        srcIDTreeAsMap.forEach((key, val) ->
+        {
+            if (!idSet.contains(key))
+            {
+                return;
+            }
+            COSDictionary dstDict = structDictMap.get(val.getCOSObject());
+            if (dstDict != null)
+            {
+                destNames.put(key, new PDStructureElement(dstDict));
+            }
+        });
+        PDNameTreeNode<PDStructureElement> destIDTree = new PDStructureElementNameTreeNode();
+        destIDTree.setNames(destNames);
+        destStructTree.setIDTree(destIDTree);
+        // See comment at the end of PDFMergerUtility.mergeIDTree()
+    }
+
+    // needed because getRoleMap() and setRoleMap() habe different map types?!
+    private void cloneRoleMap(PDStructureTreeRoot srcStructTree, PDStructureTreeRoot destStructTree)
+    {
+        COSDictionary srcDict = srcStructTree.getCOSObject().getCOSDictionary(COSName.ROLE_MAP);
+        if (srcDict == null)
+        {
+            return;
+        }
+        COSDictionary dstDict = new COSDictionary();
+        for (Map.Entry<COSName, COSBase> entry : srcDict.entrySet())
+        {
+            if (roleSet.contains(entry.getKey()))
+            {
+                dstDict.setItem(entry.getKey(), entry.getValue());
+            }
+        }
+        destStructTree.getCOSObject().setItem(COSName.ROLE_MAP, dstDict);
+    }
+
+    // clone tree element using the map so that structure elements are replaced
+    private void cloneTreeElement(
+            Map<Integer, COSObjectable> srcNumberTreeAsMap, 
+            Map<Integer, COSObjectable> dstNumberTreeAsMap, 
+            int sp)
+    {
+        COSObjectable srcObj = srcNumberTreeAsMap.get(sp); // this is a PDParentTreeValue class
+        COSObjectable dstObj = null;
+        if (srcObj != null)
+        {
+            COSBase actualSrcObj = srcObj.getCOSObject();
+            // structure element or array
+            if (actualSrcObj instanceof COSArray)
+            {
+                // create a clone of the array
+                COSArray srcArray = (COSArray) actualSrcObj;
+                COSArray dstArray = new COSArray();
+                for (int i = 0; i < srcArray.size(); ++i)
+                {
+                    COSBase srcElement = srcArray.getObject(i);
+                    dstArray.add(structDictMap.get(srcElement)); // may be null
+                }
+                dstObj = dstArray;
+            }
+            else if (actualSrcObj instanceof COSDictionary)
+            {
+                // get the clone from the map
+                dstObj = structDictMap.get(actualSrcObj);
+                if (dstObj == null)
+                {
+                    // 164421.pdf, structure tree is weird.
+                    // also 250052.pdf, 250198.pdf, 257012.pdf, 271459.pdf (multiple), 
+                    // 670045.pdf (multiple)
+                    // In 71459.pdf annotations on page 1 have StructParent numbers
+                    // that point to structure elements in the /ParentTree that point to
+                    // a different page.
+                    LOG.warn("ParentTree index {} dictionary not found in /K", sp);
+                }
+            }
+            else
+            {
+                LOG.warn("tree element neither dictionary nor array, but " + 
+                        (actualSrcObj == null ? "(null)" : actualSrcObj.getClass().getSimpleName()));
+            }
+            if (dstObj != null)
+            {
+                dstNumberTreeAsMap.put(sp, dstObj);
+            }
+        }
+    }
+
+    /**
+     * Class to help clone the /K tree. It clones structure elements and fills the structure
+     * elements map. Pages are replaced with the help of the page map. Elements with pages that
+     * don't belong to the destination are removed from the clone.
+     */
+    private class KCloner
+    {
+        PDPageTree dstPageTree;
+
+        public KCloner(PDPageTree dstPageTree)
+        {
+            this.dstPageTree = dstPageTree;
+        }
+
+        /**
+         * Creates a clone of the source.
+         *
+         * @param src source dictionary or array.
+         * @param dstParent for the /P entry; parameter needed because arrays don't keep a parent.
+         * @param currentPageDict used to remember whether we have a page parent somewhere or not.
+         * Starts with null.
+         * @return a clone, or null if source is null or if there is no clone because it belongs to a
+         * different page or to no page.
+         */
+        COSBase createClone(COSBase src, COSBase dstParent, COSDictionary currentPageDict)
+        {
+            if (src instanceof COSArray)
+            {
+                return createArrayClone(src, dstParent, currentPageDict);
+            }
+            else if (src instanceof COSDictionary)
+            {
+                return createDictionaryClone(src, dstParent, currentPageDict);
+            }
+            else
+            {
+                return src;
+            }
+        }
+
+        private COSBase createArrayClone(COSBase src, COSBase dstParent, COSDictionary currentPageDict)
+        {
+            COSArray dst = new COSArray();
+            for (COSBase base2 : (COSArray) src)
+            {
+                COSBase rc;
+                if (base2 instanceof COSObject)
+                {
+                    rc = createClone(((COSObject) base2).getObject(), dstParent, currentPageDict);
+                }
+                else
+                {
+                    rc = createClone(base2, dstParent, currentPageDict);
+                }
+                // if this is null then they don't belong to the destination document
+                if (rc != null)
+                {
+                    dst.add(rc);
+                }
+            }
+            return dst.size() > 0 ? dst : null;
+        }
+
+        private COSBase createDictionaryClone(COSBase src, COSBase dstParent, COSDictionary currentPageDict)
+        {
+            COSDictionary srcDict = (COSDictionary) src;
+            COSDictionary dstDict = structDictMap.get(srcDict);
+            if (dstDict != null)
+            {
+                return dstDict;
+            }
+            COSDictionary dstPageDict = null;
+            if (srcDict.containsKey(COSName.PG))
+            {
+                COSDictionary srcPageDict = srcDict.getCOSDictionary(COSName.PG);
+                if (srcPageDict == null)
+                {
+                    return null;
+                }
+                dstPageDict = pageDictMap.get(srcPageDict);
+                if (dstPageDict == null)
+                {
+                    return null;
+                }
+                PDPage dstPage = new PDPage(dstPageDict);
+                if (dstPageTree.indexOf(dstPage) == -1)
+                {
+                    return null;
+                }
+            }
+            
+            // Create and fill clone
+            dstDict = new COSDictionary();
+            structDictMap.put(srcDict, dstDict);
+            for (Map.Entry<COSName,COSBase> entry : srcDict.entrySet())
+            {
+                COSName key = entry.getKey();
+                if (!COSName.K.equals(key) &&
+                        !COSName.PG.equals(key) &&
+                        !COSName.P.equals(key))
+                {
+                    dstDict.setItem(key, entry.getValue());
+                }
+            }
+            dstDict.setItem(COSName.P, dstParent);
+            dstDict.setItem(COSName.PG, dstPageDict);
+            COSBase kid = srcDict.getDictionaryObject(COSName.K);
+            
+            // stack overflow here with 207658.pdf, too complex
+            COSBase cloneKid = createClone(kid, dstDict, dstPageDict != null ? dstPageDict : currentPageDict);
+            if (cloneKid == null && kid != null)
+            {
+                return null; // kids array wasn't empty, but is empty now => ignore
+            }
+            
+            // removes orphan nodes, example:
+            // Root/StructTreeRoot/K/[7]/K/[3]/K/[5]/K/[2] in 271459.pdf
+            // decide about keeping source dictionaries with no /K and no /PG
+            if (dstPageDict == null && cloneKid == null && currentPageDict == null)
+            {
+                // if no parent page and no page here and no kids, assume this is an orphan
+                return null;
+            }
+            dstDict.setItem(COSName.K, cloneKid);
+            String id = dstDict.getString(COSName.ID);
+            if (id != null)
+            {
+                idSet.add(id);
+            }
+            COSName s = dstDict.getCOSName(COSName.S);
+            if (s != null)
+            {
+                roleSet.add(s);
+            }
+            return dstDict;
+        }
+    }
+
+    // Look for /StructParent and /StructParents and add them to the destination tree
+    private void processResources(PDResources res, 
+            Map<Integer, COSObjectable> srcNumberTreeAsMap, 
+            Map<Integer, COSObjectable> dstNumberTreeAsMap,
+            Set<COSDictionary> visited) throws IOException
+    {
+        if (res == null)
+        {
+            return;
+        }
+        if (visited.contains(res.getCOSObject()))
+        {
+            // avoid endless recursion, e.g. with 002874.pdf
+            return;
+        }
+        visited.add(res.getCOSObject());
+
+        for (COSName name : res.getXObjectNames())
+        {
+            PDXObject xObject = res.getXObject(name);
+            int sp2 = -1;
+            if (xObject instanceof PDFormXObject)
+            {
+                sp2 = ((PDFormXObject) xObject).getStructParents();
+                processResources(((PDFormXObject) xObject).getResources(), srcNumberTreeAsMap, dstNumberTreeAsMap, visited);
+            }
+            else if (xObject instanceof PDImageXObject)
+            {
+                sp2 = ((PDImageXObject) xObject).getStructParent();
+            }
+            if (sp2 != -1)
+            {
+                cloneTreeElement(srcNumberTreeAsMap, dstNumberTreeAsMap, sp2);
+            }
+        }
+    }
+
     /**
      * This will tell the splitting algorithm where to split the pages.  The default
      * is 1, so every page will become a new document.  If it was two then each document would
@@ -250,6 +619,12 @@ public class Splitter
         }
         document.getDocumentCatalog().setViewerPreferences(
                 getSourceDocument().getDocumentCatalog().getViewerPreferences());
+        document.getDocumentCatalog().setLanguage(
+                getSourceDocument().getDocumentCatalog().getLanguage());
+        document.getDocumentCatalog().setMarkInfo(
+                getSourceDocument().getDocumentCatalog().getMarkInfo());
+        document.getDocumentCatalog().setMetadata(
+                getSourceDocument().getDocumentCatalog().getMetadata());
         return document;
     }
 
@@ -272,6 +647,8 @@ public class Splitter
         }
         // remove page links to avoid copying not needed resources 
         processAnnotations(imported);
+
+        pageDictMap.put(page.getCOSObject(), imported.getCOSObject());
     }
 
     private void processAnnotations(PDPage imported) throws IOException
@@ -298,6 +675,7 @@ public class Splitter
             annotation.setPage(null);
         }
     }
+
     /**
      * The source PDF document.
      * 
