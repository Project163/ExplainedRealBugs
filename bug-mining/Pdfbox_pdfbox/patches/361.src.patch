diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/DateConverter.java b/pdfbox/src/main/java/org/apache/pdfbox/util/DateConverter.java
index afc5f2940f..6447478815 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/DateConverter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/DateConverter.java
@@ -16,11 +16,9 @@
  */
 package org.apache.pdfbox.util;
 
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-
 import java.io.IOException;
-
+import java.text.ParsePosition;
+import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
@@ -30,330 +28,790 @@ import java.util.TimeZone;
 
 import org.apache.pdfbox.cos.COSString;
 
+/**
+ * Date format is described in PDF Reference 1.7 section 3.8.2
+ * (www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf)
+ * and also in PDF 32000-1:2008 
+ * (http://www.adobe.com/devnet/acrobat/pdfs/PDF32000_2008.pdf))
+ * although the latter inexplicably omits the trailing apostrophe.
+ * 
+ * The interpretation of dates without timezones is unclear. 
+ * The code below assumes that such dates are in UTC+00 (aka GMT).
+ * This is in keeping with the PDF Reference's assertion that:
+ *      numerical fields default to zero values. 
+ * However, the Reference does go on to make the cryptic remark:
+ *      If no UT information is specified, the relationship of the specified  
+ *      time to UT is considered to be unknown. Whether or not the time 
+ *      zone is known, the rest of the date should be specified in local time.
+ * I understand this to refer to _creating_ a pdf date value. That is, 
+ * code that can get the wall clock time and cannot get the timezone 
+ * should write the wall clock time with a time zone of zero.
+ * When _parsing_ a PDF date, the statement talks about "the rest of the date"
+ * being local time, thus explicitly excluding the use of the local time
+ * for the time zone.
+*/ 
+
 /**
  * This class is used to convert dates to strings and back using the PDF
- * date standards.  Date are described in PDFReference1.4 section 3.8.2
+ * date standard in section 3.8.2 of PDF Reference 1.7.  
  *
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.14 $
+ * @author <a href="mailto:zweibieren@ahoo.com">Fred Hansen</a>
+ * 
+ * TODO Move members of this class elsewhere for shared use in pdfbox, xmpbox, and jempbox.
  */
 public class DateConverter
 {
-    //The Date format is supposed to be the PDF_DATE_FORMAT, but not all PDF documents
-    //will use that date, so I have added a couple other potential formats
-    //to try if the original one does not work.
-    private static final SimpleDateFormat[] POTENTIAL_FORMATS = new SimpleDateFormat[] {
-        new SimpleDateFormat("EEEE, dd MMM yyyy hh:mm:ss a", Locale.ENGLISH),
-        new SimpleDateFormat("EEEE, MMM dd, yyyy hh:mm:ss a", Locale.ENGLISH),
-        new SimpleDateFormat("MM/dd/yyyy hh:mm:ss", Locale.ENGLISH),
-        new SimpleDateFormat("MM/dd/yyyy", Locale.ENGLISH),
-        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.ENGLISH),
-        new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssz", Locale.ENGLISH),
-        new SimpleDateFormat("EEEE, MMM dd, yyyy", Locale.ENGLISH), // Acrobat Distiller 1.0.2 for Macintosh
-        new SimpleDateFormat("EEEE MMM dd, yyyy HH:mm:ss", Locale.ENGLISH), // ECMP5
-        new SimpleDateFormat("EEEE MMM dd HH:mm:ss z yyyy", Locale.ENGLISH), // GNU Ghostscript 7.0.7
-        new SimpleDateFormat("EEEE, MMM dd, yyyy 'at' hh:mma", Locale.ENGLISH), // Acrobat Net Distiller 1.0 for Windows
-        new SimpleDateFormat("d/MM/yyyy hh:mm:ss", Locale.ENGLISH), // PDFBOX-164
-        new SimpleDateFormat("dd/MM/yyyy hh:mm:ss", Locale.ENGLISH), // PDFBOX-170
-        new SimpleDateFormat("EEEEEEEEEE, MMMMMMMMMMMM dd, yyyy", Locale.ENGLISH),  // PDFBOX-465
-        new SimpleDateFormat("dd MMM yyyy hh:mm:ss", Locale.ENGLISH),  // for 26 May 2000 11:25:00
-        new SimpleDateFormat("dd MMM yyyy hh:mm", Locale.ENGLISH),  // for 26 May 2000 11:25
-        new SimpleDateFormat("M/dd/yyyy hh:mm:ss", Locale.ENGLISH),
-        new SimpleDateFormat("MM/d/yyyy hh:mm:ss", Locale.ENGLISH),
-        new SimpleDateFormat("M/dd/yyyy", Locale.ENGLISH),
-        new SimpleDateFormat("MM/d/yyyy", Locale.ENGLISH),
-        new SimpleDateFormat("M/d/yyyy hh:mm:ss", Locale.ENGLISH),
-        new SimpleDateFormat("M/d/yyyy", Locale.ENGLISH),
-        new SimpleDateFormat("M/d/yy hh:mm:ss", Locale.ENGLISH),
-        new SimpleDateFormat("M/d/yy", Locale.ENGLISH),
-        new SimpleDateFormat("yyyymmdd hh:mm:ss Z"), //
-        new SimpleDateFormat("yyyymmdd hh:mm:ss"),   //
-        new SimpleDateFormat("yyyymmdd'+00''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+01''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+02''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+03''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+04''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+05''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+06''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+07''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+08''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+09''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+10''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+11''00'''"), //
-        new SimpleDateFormat("yyyymmdd'+12''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-01''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-02''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-03''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-04''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-05''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-06''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-07''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-08''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-09''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-10''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-11''00'''"), //
-        new SimpleDateFormat("yyyymmdd'-12''00'''"), //
-        new SimpleDateFormat("yyyymmdd"), // for 20090401+0200
+    // milliseconds/1000 = seconds; seconds / 60 = minutes; minutes/60 = hours
+    private static final int MINUTES_PER_HOUR = 60;
+    private static final int SECONDS_PER_MINUTE = 60;
+    private static final int MILLIS_PER_MINUTE = SECONDS_PER_MINUTE*1000;
+    private static final int MILLIS_PER_HOUR = MINUTES_PER_HOUR * MILLIS_PER_MINUTE;
+    private static final int 
+            HALF_DAY = 12 * MINUTES_PER_HOUR * MILLIS_PER_MINUTE, 
+            DAY = 2*HALF_DAY;
+    
+    /**
+     * Error value if date is invalid. Parsing is done with 
+     * GregorianCalendar.setLenient(false), so every date field value
+     * must be within bounds. If an attempt is made to parse an invalid date 
+     * field, toCalendar(String, String[]) returns Jan 1 in year INVALID_YEAR.
+     */
+    public static final int INVALID_YEAR = 999;
+    
+    
+    /**
+     * The Date format is supposed to be the PDF_DATE_FORMAT, but other
+     * forms appear. These lists offer alternatives to be tried 
+     * if parseBigEndianDate fails.  
+     * 
+     * The time zone offset generally trails the date string, so it is processed
+     * separately with parseTZoffset. (This does not preclude having time
+     * zones in the elements below; one does.)
+     * 
+     * Alas, SimpleDateFormat is badly non-reentrant -- it modifies its 
+     * calendar field (PDFBox-402), so these lists are strings to create
+     * SimpleDate format as needed.
+     * 
+     * Some past entries have been elided because they duplicate existing 
+     * entries. See the API for SimpleDateFormat, which says 
+     *      "For parsing, the number of pattern letters is ignored 
+     *      unless it's needed to separate two adjacent fields."
+     * 
+     * toCalendar(String, String[]) tests to see that the entire input text
+     * has been consumed. Therefore the ordering of formats is important. 
+     * If one format begins with the entirety of another, the longer
+     * must precede the other in the list.
+     * 
+     * HH is for 0-23 hours and hh for 1-12 hours; an "a" field must follow "hh"
+     * Where year is yy, four digit years are accepted 
+     * and two digit years are converted to four digits in the range
+     *      [thisyear-79...thisyear+20]
+     */
+    private static final String[] ALPHA_START_FORMATS = 
+    {
+            "EEEE, dd MMM yy hh:mm:ss a",
+            "EEEE, MMM dd, yy hh:mm:ss a",
+            "EEEE, MMM dd, yy 'at' hh:mma", // Acrobat Net Distiller 1.0 for Windows
+            "EEEE, MMM dd, yy", // Acrobat Distiller 1.0.2 for Macintosh  && PDFBOX-465
+            "EEEE MMM dd, yy HH:mm:ss", // ECMP5
+            "EEEE MMM dd HH:mm:ss z yy", // GNU Ghostscript 7.0.7
+            "EEEE MMM dd HH:mm:ss yy", // GNU Ghostscript 7.0.7 variant
+    };
+    
+    private static final String[] DIGIT_START_FORMATS = 
+    {
+        "dd MMM yy HH:mm:ss",  // for 26 May 2000 11:25:00
+        "dd MMM yy HH:mm",  // for 26 May 2000 11:25
+        "yyyy MMM d",   // ambiguity resolved only by omitting time
+        "yyyymmddhh:mm:ss", // test case "200712172:2:3"
+        "H:m M/d/yy", // test case "9:47 5/12/2008"
+        "M/d/yy HH:mm:ss",
+        "M/d/yy HH:mm",
+        "M/d/yy",
+
+        // proposed rule that is unreachable due to "dd MMM yy HH:mm:ss" 
+        //     "yyyy MMM d HH:mm:ss", 
+
+        // rules made unreachable by "M/d/yy HH:mm:ss" "M/d/yy HH:mm"  "M/d/yy",
+        // (incoming digit strings do not mark themselves as y, m, or d!)
+            // "d/MM/yyyy HH:mm:ss", // PDFBOX-164 and PDFBOX-170 
+            // "M/dd/yyyy hh:mm:ss",
+            // "MM/d/yyyy hh:mm:ss",
+            // "M/d/yyyy HH:mm:ss",
+            // "M/dd/yyyy",
+            // "MM/d/yyyy",
+            // "M/d/yyyy",
+            // "M/d/yyyy HH:mm:ss",
+            // "M/d/yy HH:mm:ss",
+        // subsumed by big-endian parse
+            // "yyyy-MM-dd'T'HH:mm:ss",
+            // "yyyy-MM-dd'T'HH:mm:ss",
+            // "yyyymmdd hh:mm:ss", 
+            // "yyyymmdd", 
+            // "yyyymmddX''00''",  // covers 24 cases 
+            //    (orignally the above ended with '+00''00'''; 
+            //      the first apostrophe quoted the plus, 
+            //      '' mapped to a single ', and the ''' was invalid)
     };
 
+
     private DateConverter()
     {
         //utility class should not be constructed.
     }
 
+    ////////////////////////////////////////////
+    // C o n v e r t   t o   S t r i n g   Methods
+     
     /**
-     * This will convert the calendar to a string.
+     * Get all know formats.
+     * 
+     * @return an array containig all known formats
+     */
+    public static String[] getFormats() 
+    {
+        String[] val = new String[ALPHA_START_FORMATS.length+DIGIT_START_FORMATS.length];
+        System.arraycopy(ALPHA_START_FORMATS, 0, val, 0, ALPHA_START_FORMATS.length);
+        System.arraycopy(DIGIT_START_FORMATS, 0, val,ALPHA_START_FORMATS.length, DIGIT_START_FORMATS.length);
+        return val;
+    }
+
+    /**
+     * Converts a Calendar to a string formatted as:
+     *     D:yyyyMMddHHmmss#hh'mm'  where # is Z, +, or -.
+     * 
+     * @param cal The date to convert to a string. May be null.
+     * The DST_OFFSET is included when computing the output time zone.
      *
-     * @param date The date to convert to a string.
+     * @return The date as a String to be used in a PDF document, 
+     *      or null if the cal value is null
+     */
+    public static String toString(Calendar cal)
+    {
+        if (cal == null) 
+        {
+            return null;
+        }
+        String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET)
+                + cal.get(Calendar.DST_OFFSET), "'");
+        return String.format("D:"
+                + "%1$4tY%1$2tm%1$2td"   // yyyyMMdd 
+                + "%1$2tH%1$2tM%1$2tS"   // HHmmss 
+                + "%2$s"                // time zone
+                + "'",                  // trailing apostrophe
+            cal, offset);      
+    }
+
+    /**
+     * Converts the date to ISO 8601 string format:
+     *     yyyy-mm-ddThh:MM:ss#hh:mm    (where '#" is '+' or '-').
      *
-     * @return The date as a String to be used in a PDF document.
+     * @param cal The date to convert.  Must not be null.
+     * The DST_OFFSET is included in the output value.
+     * 
+     * @return The date represented as an ISO 8601 string.
      */
-    public static String toString( Calendar date )
+    public static String toISO8601(Calendar cal)
     {
-        String retval = null;
-        if( date != null )
+        String offset = formatTZoffset(cal.get(Calendar.ZONE_OFFSET)
+                + cal.get(Calendar.DST_OFFSET), ":");
+        return String.format(
+                "%1$4tY"   // yyyy
+                + "-%1$2tm"   // -mm  (%tm adds one to cal month value)
+                + "-%1$2td"  // -dd  (%tm adds one to cal month value)
+                + "T"                             // T
+                + "%1$2tH:%1$2tM:%1$2tS"   // HHmmss  
+                + "%2$s",              // time zone
+            cal, offset);      
+    }
+    
+    /**
+     * Constrain a timezone offset to the range  [-11:59 thru +11:59].
+     * @param proposedOffset A value intended to be a timezone offset.
+     * @return The corresponding value reduced to the above noted range 
+     * by adding or subtracting multiples of a full day.
+     */
+    public static int restrainTZoffset(long proposedOffset) 
+    {
+        proposedOffset = ((proposedOffset+HALF_DAY)%DAY+DAY)%DAY; 
+        // 0 <= proposedOffset < DAY
+        proposedOffset = (proposedOffset-HALF_DAY)%HALF_DAY;   
+        // -HALF_DAY < proposedOffset < HALF_DAY
+        return (int)proposedOffset;
+    }
+    
+    /** 
+     * Formats a time zone offset as #hh^mm
+     * where # is + or -, hh is hours, ^ is a separator, and mm is minutes.
+     * Any separator may be specified by the second argument;
+     * the usual values are ":" (ISO 8601), "" (RFC 822), and "'" (PDF).
+     * The returned value is constrained to the range -11:59 ... 11:59.
+     * For offset of 0 millis, the String returned is "+00^00", never "Z".
+     * To get a "general" offset in form GMT#hh:mm, write
+     *      "GMT"+DateConverter.formatTZoffset(offset, ":");
+     * <p>
+     * Take thought in choosing the source for the millis value. 
+     * It can come from calendarValue.getTimeZone() or from 
+     * calendarValue.get(Calendar.ZONE_OFFSET).  If a TimeZone was created
+     * from a valid time zone ID, then it may have a daylight savings rule.
+     * (As of July 4, 2013, the data base at http://www.iana.org/time-zones 
+     * recognized 629 time zone regions. But a TimeZone created as 
+     *      new SimpleTimeZone(millisOffset, "ID"), 
+     * will not have a daylight savings rule. (Not even if there is a
+     * known time zone with the given ID. To get the TimeZone named "xDT"
+     * with its DST rule, use an ID of EST5EDT, CST6CDT, MST7MDT, or PST8PDT.
+     * <p>
+     * When parsing PDF dates, the incoming values DOES NOT have a TIMEZONE value.
+     * At most it has an OFFSET value like -04'00'. It is generally impossible to 
+     * determine what TIMEZONE corresponds to a given OFFSET. If the date is
+     * in the summer when daylight savings is in effect, an offset of -0400
+     * might correspond to any one of the 38 regions (of 53) with standard time 
+     * offset -0400 and no daylight saving. Or it might correspond to 
+     * any one of the 31 regions (out of 43) that observe daylight savings 
+     * and have standard time offset of -0500.
+     * <p>
+     * If a Calendar has not been assigned a TimeZone with setTimeZone(), 
+     * it will have by default the local TIMEZONE, not just the OFFSET.  In the
+     * USA, this TimeZone will have a daylight savings rule.
+     * <p>
+     * The offset assigned with calVal.set(Calendar.ZONE_OFFSET) differs
+     * from the offset in the TimeZone set by Calendar.setTimeZone(). Example:
+     * Suppose my local TimeZone is America/New_York. It has an offset of -05'00'.
+     * And suppose I set a GregorianCalendar's ZONE_OFFSET to -07'00'
+     *     calVal = new GregorianCalendar();   // TimeZone is the local default
+     *     calVal.set(Calendar.ZONE_OFFSET, -7* MILLIS_PER_HOUR);
+     * Four different offsets can be computed from calVal:
+     *     calVal.get(Calendar.ZONE_OFFSET)  =>  -07:00
+     *     calVal.get(Calendar.ZONE_OFFSET) + calVal.get(Calendar.DST_OFFSET) => -06:00
+     *     calVal.getTimeZone().getRawOffset()  =>  -05:00
+     *     calVal.getTimeZone().getOffset(calVal.getTimeInMillis())  =>  -04:00
+     * <p>
+     * Which is correct??? I dunno, though setTimeZone() does seem to affect
+     * ZONE_OFFSET, and not vice versa.  One cannot even test whether TimeZone 
+     * or ZONE_OFFSET has been set; both have been set by initialization code.
+     * TimeZone is initialized to the local default time zone 
+     * and ZONE_OFFSET is set from it.
+     * 
+     * My choice in this DateConverter class has been to set the 
+     * initial TimeZone of a GregorianCalendar to GMT. Thereafter
+     * the TimeZone is modified with {@link #adjustTimeZoneNicely}. 
+     * 
+     * @param millis a time zone offset expressed in milliseconds
+     *      Any value is accepted; it is normalized to [-11:59 ... +11:59]
+     * @param sep a String to insert between hh and mm. May be empty.
+     * @return the formatted String for the offset
+     */
+    public static String formatTZoffset(long millis, String sep) 
+    {
+        SimpleDateFormat sdf = new SimpleDateFormat("Z"); // #hhmm
+        sdf.setTimeZone(new SimpleTimeZone(restrainTZoffset(millis),"unknown"));
+        String tz = sdf.format(new Date());
+        return tz.substring(0,3)+sep+tz.substring(3);
+    }
+
+    //////////////////////////////////////////////
+    // P A R S E   Methods
+
+     /**
+     * Parses an integer from a string, starting at and advancing a ParsePosition.
+     * 
+     * @param text The string being parsed. If null, the remedy value is returned.
+     * @param where The ParsePosition to start the search. This value 
+     *      will be incremented by the number of digits found, but no 
+     *      more than maxlen.  That is, the ParsePosition will 
+     *      advance across at most maxlen initial digits in text.
+     *      The error index is ignored and unchanged.
+     * @param maxlen The maximum length of the integer to parse. 
+     *      Usually 2, but 4 for year fields.
+     *      If the field of length maxlen begins with a digit, 
+     *      but contains a non-digit, no error is signaled 
+     *      and the integer value is returned.
+     * @param remedy Value to be assigned if no digit is found at the
+     *      initial parse position; that is, if the field is empty.
+     * @return The integer that was at the given parse position. Or
+     *      the remedy value if no digits were found.
+     */
+    public static int parseTimeField(String text, ParsePosition where, 
+            int maxlen, int remedy) 
+    {
+        if (text == null) 
         {
-            StringBuffer buffer = new StringBuffer();
-            TimeZone zone = date.getTimeZone();
-            long offsetInMinutes = zone.getOffset( date.getTimeInMillis() )/1000/60;
-            long hours = Math.abs( offsetInMinutes/60 );
-            long minutes = Math.abs( offsetInMinutes%60 );
-            buffer.append( "D:" );
-            // PDFBOX-402 , SimpleDateFormat is not thread safe, created it when you use it.
-            buffer.append( new SimpleDateFormat( "yyyyMMddHHmmss" , Locale.ENGLISH).format( date.getTime() ) );
-            if( offsetInMinutes == 0 )
+                    return remedy; 
+        }
+        // (it would seem that DecimalFormat.parse() would be simpler;
+        //     but that class blithely ignores setMaximumIntegerDigits)
+        int retval = 0;
+        int index = where.getIndex();
+        int limit = index + Math.min(maxlen, text.length()-index);
+        for (; index < limit; index++)
+        {
+            int cval = text.charAt(index) - '0';  // convert digit to integer
+            if (cval <0 || cval > 9)   // test to see if we got a digit
             {
-                buffer.append( "Z" );
+                break;   // no digit at index
             }
-            else if( offsetInMinutes < 0 )
-            {
-                buffer.append( "-" );
+            retval = retval*10 + cval;   // append the digit to the return value
+        }   
+        if (index == where.getIndex())
+        {
+            return remedy;
+        }
+        where.setIndex(index);
+        return retval;
+    }
+ 
+    /**
+     * Advances the ParsePosition past any and all the characters 
+     *      that match those in the optionals list.
+     *      In particular, a space will skip all spaces.
+     * @param text The text to examine
+     * @param where index to start looking. 
+     *      The value is incremented by the number of optionals found.
+     *      The error index is ignored and unchanged.
+     * @param optionals A String listing all the optional characters 
+     *      to be skipped.
+     * @return The last non-space character passed over. 
+     *      Returns a space if no non-space character was found 
+     *      (even if space is not in the optionals list.)
+     */
+    public static char skipOptionals(String text, ParsePosition where, 
+            String optionals) 
+    {
+        char retval = ' ', currch;
+        while (text != null && where.getIndex() < text.length() 
+                && optionals.indexOf(
+                        (currch=text.charAt(where.getIndex()))
+                ) >= 0) 
+        {
+            retval = (currch != ' ') ? currch : retval;
+            where.setIndex(where.getIndex() + 1);
+        }
+        return retval;
+    }
+    
+    /**
+     * If the victim string is at the given position in the text,
+     * this method advances the position past that string. 
+     * 
+     * @param text The text to examine
+     * @param victim The string to look for
+     * @param where The initial position to look at. After return, this will
+     *      have been incremented by the length of the victim if it was found.
+     *      The error index is ignored and unchanged.
+     * @return true if victim was found; otherwise false.
+     */
+    public static boolean skipString(String text, String victim, ParsePosition where) 
+    {
+        if (text.startsWith(victim, where.getIndex()))
+        {
+            where.setIndex(where.getIndex()+victim.length());
+            return true;
+        }
+        return false;
+    }
+
+    /** 
+     * Construct a new GregorianCalendar and set defaults.
+     * Locale is ENGLISH.
+     * TimeZone is "UTC" (zero offset and no DST).
+     * Parsing is NOT lenient. Milliseconds are zero.
+     * 
+     * @return a new gregorian calendar
+     */
+    public static GregorianCalendar newGreg()  
+    {
+        GregorianCalendar retCal = new GregorianCalendar(Locale.ENGLISH);
+        retCal.setTimeZone(new SimpleTimeZone(0, "UTC"));
+        retCal.setLenient(false);
+        retCal.set(Calendar.MILLISECOND, 0);
+        return retCal;
+    }
+    
+    /**
+     * Install a TimeZone on a GregorianCalendar without changing the 
+     * hours value. A plain GregorianCalendat.setTimeZone() 
+     * adjusts the Calendar.HOUR value to compensate. This is *BAD*
+     * (not to say *EVIL*) when we have already set the time.
+     * @param cal The GregorianCalendar whose TimeZone to change.
+     * @param tz The new TimeZone.
+     */
+    public static void adjustTimeZoneNicely(GregorianCalendar cal, TimeZone tz) 
+    {
+        cal.setTimeZone(tz);
+        int offset = (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET))
+                / MILLIS_PER_HOUR;
+        cal.add(Calendar.HOUR, -offset);
+    }
+    
+    /**
+     * Parses the end of a date string for a time zone and, if one is found,
+     * sets the time zone of the GregorianCalendar. Otherwise the calendar 
+     * time zone is unchanged.
+     * 
+     * The text is parsed as
+     *      (Z|GMT|UTC)? [+- ]* h [': ]? m '?
+     * where the leading String is optional, h is two digits by default, 
+     * but may be a single digit if followed by one of space, apostrophe, 
+     * colon, or the end of string. Similarly, m is one or two digits. 
+     * This scheme accepts the format of PDF, RFC 822, and ISO8601. 
+     * If none of these applies (as for a time zone name), we try
+     * TimeZone.getTimeZone().
+     * 
+     * @param text The text expected to begin with a time zone value,
+     * possibly with leading or trailing spaces.
+     * @param cal The Calendar whose TimeZone to set. 
+     * @param initialWhere where Scanning begins at where.index. After success, the returned
+     *      index is that of the next character after the recognized string.
+     *      The error index is ignored and unchanged.
+     * @return true if parsed a time zone value; otherwise the 
+     *      time zone is unchanged and the return value is false.
+     */
+    public static boolean parseTZoffset(String text, GregorianCalendar cal, 
+            ParsePosition initialWhere) 
+    {
+        ParsePosition where = new ParsePosition(initialWhere.getIndex());
+        TimeZone tz = new SimpleTimeZone(0, "GMT");
+        int tzHours, tzMin;
+        char sign = skipOptionals(text, where, "Z+- ");
+        boolean hadGMT = (sign == 'Z' || skipString(text, "GMT", where) 
+                || skipString(text, "UTC", where));
+        sign = ( ! hadGMT) ? sign : skipOptionals(text, where, "+- "); 
+        
+        tzHours = parseTimeField(text, where, 2, -999);
+        skipOptionals(text, where, "\': ");
+        tzMin = parseTimeField(text, where, 2, 0);
+        skipOptionals(text, where, "\' "); 
+        
+        if (tzHours != -999) 
+        {                    // we parsed a time zone in default format
+            int hrSign = (sign == '-' ? -1 :+1);
+            tz.setRawOffset(restrainTZoffset(hrSign*(tzHours*MILLIS_PER_HOUR + tzMin*MILLIS_PER_MINUTE))); 
+            tz.setID("unknown");
+        }
+        else if ( ! hadGMT)
+        {            // try to process as a name; "GMT" or "UTC" has already been processed
+            String tzText = text.substring(initialWhere.getIndex()).trim();
+            tz = TimeZone.getTimeZone(tzText);
+            // getTimeZone returns "GMT" for unknown ids
+            if ("GMT".equals(tz.getID()))  
+            {                // no timezone in text
+                // cal amd initialWhere are unchanged
+                return false;
             }
             else
-            {
-                buffer.append( "+" );
-            }
-            if( hours < 10 )
-            {
-                buffer.append( "0" );
+            {                // we got a tz by name; use it
+                where.setIndex(text.length());
             }
-            buffer.append( hours );
-            buffer.append( "'" );
-            if( minutes < 10 )
-            {
-                buffer.append( "0" );
-            }
-            buffer.append( minutes );
-            buffer.append( "'" );
-            retval = buffer.toString();
-
         }
-        return retval;
+        adjustTimeZoneNicely(cal, tz);
+        initialWhere.setIndex(where.getIndex());
+        return true;
     }
-
+    
     /**
-     * This will convert a string to a calendar.
-     *
-     * @param date The string representation of the calendar.
-     *
-     * @return The calendar that this string represents.
-     *
-     * @throws IOException If the date string is not in the correct format.
+     * Parses a big-endian date: year month day hour min sec.
+     * The year must be four digits. Other fields may be adjacent 
+     * and delimited by length or they may follow appropriate delimiters.
+     *     year [ -/]* month [ -/]* dayofmonth [ T]* hour [:] min [:] sec [.secFraction]
+     * If any numeric field is omitted, all following fields must also be omitted.
+     * No time zone is processed.
+     * 
+     * Ambiguous dates can produce unexpected results. For example:
+     *      1970 12 23:08 will parse as 1970 December 23 00:08:00 
+     * 
+     * @param text The string to parse.
+     * 
+     * @param initialWhere Where to begin the parse. On return the index
+     *      is advanced to just beyond the last character processed.
+     *      The error index is ignored and unchanged.
+     * 
+     * @return a GregorianCalendar representing the parsed date. 
+     *      Or null if the text did not begin with at least four digits.
      */
-    public static Calendar toCalendar( COSString date ) throws IOException
+    public static GregorianCalendar parseBigEndianDate(String text, 
+            ParsePosition initialWhere) 
     {
-        Calendar retval = null;
-        if( date != null )
+        ParsePosition where = new ParsePosition(initialWhere.getIndex());
+        int year = parseTimeField(text, where, 4, 0);
+        if (where.getIndex() != 4 + initialWhere.getIndex()) 
+        {
+            return null;
+        }
+        skipOptionals(text, where, "/- ");
+        int month = parseTimeField(text, where, 2, 1) - 1; // Calendar months are 0...11
+        skipOptionals(text, where, "/- ");
+        int day = parseTimeField(text, where, 2, 1);
+        skipOptionals(text, where, " T");
+        int hour = parseTimeField(text, where, 2, 0);
+        skipOptionals(text, where, ": ");
+        int minute = parseTimeField(text, where, 2, 0);
+        skipOptionals(text, where, ": ");
+        int second = parseTimeField(text, where, 2, 0);
+        char nextC = skipOptionals(text, where, ".");
+        if (nextC == '.')
         {
-            retval = toCalendar( date.getString() );
+            // fractions of a second: skip upto 19 digits
+            parseTimeField(text, where, 19, 0);
         }
 
-        return retval;
+        GregorianCalendar dest = newGreg();
+        try 
+        {
+            dest.set(year, month, day, hour, minute, second);
+            dest.getTimeInMillis();    // trigger limit tests
+        }
+        catch (IllegalArgumentException ill) 
+        {
+            return  null;
+        }
+        initialWhere.setIndex(where.getIndex());
+        skipOptionals(text, initialWhere, " ");
+        return dest;    // dest has at least a year value
     }
 
     /**
-     * This will convert a string to a calendar.
-     *
-     * @param date The string representation of the calendar.
-     *
-     * @return The calendar that this string represents.
-     *
-     * @throws IOException If the date string is not in the correct format.
+     * See if text can be parsed as a date according to any of a list of 
+     * formats. The time zone may be included as part of the format, or
+     * omitted in favor of later testing for a trailing time zone.
+     * 
+     * @param text The text to be parsed.
+     * 
+     * @param fmts A list of formats to be tried. The syntax is that for 
+     *      {@link #java.text.SimpleDateFormat}
+     * 
+     * @param initialWhere At start this is the position to begin
+     *      examining the text. Upon return it will have been
+     *      incremented to refer to the next non-space character after the date.
+     *      If no date was found, the value is unchanged.
+     *      The error index is ignored and unchanged.
+     * 
+     * @return null for failure to find a date, or the GregorianCalendar
+     *      for the date that was found. Unless a time zone was 
+     *      part of the format, the time zone will be GMT+0
      */
-    public static Calendar toCalendar( String date ) throws IOException
+    public static GregorianCalendar parseSimpleDate(String text, String[] fmts, 
+            ParsePosition initialWhere) 
     {
-        Calendar retval = null;
-        if( date != null && date.trim().length() > 0 )
+        for(String fmt : fmts)
         {
-            //these are the default values
-            int year = 0;
-            int month = 1;
-            int day = 1;
-            int hour = 0;
-            int minute = 0;
-            int second = 0;
-            //first string off the prefix if it exists
-            try
+            ParsePosition where = new ParsePosition(initialWhere.getIndex());
+            SimpleDateFormat sdf = new SimpleDateFormat(fmt, Locale.ENGLISH);
+            GregorianCalendar retCal = newGreg();
+            sdf.setCalendar(retCal);
+            if (sdf.parse(text, where) != null)
             {
-                SimpleTimeZone zone = null;
-                if( date.startsWith( "D:" ) )
-                {
-                    date = date.substring( 2, date.length() );
-                }
-                if( date.length() < 4 )
-                {
-                    throw new IOException( "Error: Invalid date format '" + date + "'" );
-                }
-                year = Integer.parseInt( date.substring( 0, 4 ) );
-                if( date.length() >= 6 )
-                {
-                    month = Integer.parseInt( date.substring( 4, 6 ) );
-                }
-                if( date.length() >= 8 )
-                {
-                    day = Integer.parseInt( date.substring( 6, 8 ) );
-                }
-                if( date.length() >= 10 )
-                {
-                    hour = Integer.parseInt( date.substring( 8, 10 ) );
-                }
-                if( date.length() >= 12 )
-                {
-                    minute = Integer.parseInt( date.substring( 10, 12 ) );
-                }
-                if( date.length() >= 14 )
-                {
-                    second = Integer.parseInt( date.substring( 12, 14 ) );
-                }
+                initialWhere.setIndex(where.getIndex());
+                skipOptionals(text, initialWhere, " ");
+                return retCal;
+            }
+        }
+        return null;
+    }
 
-                if( date.length() >= 15 )
-                {
-                    char sign = date.charAt( 14 );
-                    if( sign == 'Z' )
-                    {
-                        zone = new SimpleTimeZone(0,"Unknown");
-                    }
-                    else
-                    {
-                        int hours = 0;
-                        int minutes = 0;
-                        if( date.length() >= 17 )
-                        {
-                            if( sign == '+' )
-                            {
-                                //parseInt cannot handle the + sign
-                                hours = Integer.parseInt( date.substring( 15, 17 ) );
-                            }
-                            else if (sign == '-')
-                            {
-                                hours = -Integer.parseInt(date.substring(15,17));
-                            }
-                            else
-                            {
-                                hours = -Integer.parseInt( date.substring( 14, 16 ) );
-                            }
-                        }
-                        if( date.length() > 20 )
-                        {
-                            minutes = Integer.parseInt( date.substring( 18, 20 ) );
-                        }
-                        zone = new SimpleTimeZone( hours*60*60*1000 + minutes*60*1000, "Unknown" );
-                    }
-                }
-                if( zone != null )
-                {
-                    retval = new GregorianCalendar( zone );
-                }
-                else
-                {
-                    retval = new GregorianCalendar();
-                }
+    
+    /**
+     * Parses a String to see if it begins with a date, and if so, 
+     * returns that date. The date must be strictly correct--no 
+     * field may exceed the appropriate limit.
+     * (That is, the Calendar has setLenient(false).) 
+     * Skips initial spaces, but does NOT check for "D:"
+     * 
+     * The scan first tries parseBigEndianDate and parseTZoffset
+     * and then tries parseSimpleDate with appropriate formats, 
+     * again followed by parseTZoffset. If at any stage the entire 
+     * text is consumed, that date value is returned immediately. 
+     * Otherwise the date that consumes the longest initial part
+     * of the text is returned.
+     * 
+     * - PDF format dates are among those recognized by parseBigEndianDate.
+     * - The formats tried are alphaStartFormats or digitStartFormat and
+     * any listed in the value of moreFmts.
+     * 
+     * @param text The String that may begin with a date. Must not be null.
+     *      Initial spaces and "D:" are skipped over.
+     * @param moreFmts Additional formats to be tried after trying the
+     *      built-in formats.
+     * @param initialWhere where Parsing begins at the given position in text. If the
+     *      parse succeeds, the index of where is advanced to point 
+     *      to the first unrecognized character.
+     *      The error index is ignored and unchanged.
+     * @return A GregorianCalendar for the date. If no date is found, 
+     *      returns null. The time zone will be GMT+0 unless parsing 
+     *      succeeded with a format containing a time zone. (Only one
+     *      builtin format contains a time zone.)
+     * 
+     */
+    public static Calendar parseDate(String text, String[] moreFmts, 
+            ParsePosition initialWhere) 
+    {
+        // place to remember longestr date string
+        int longestLen = -999999;  // theorem: this value will never be used
+                // proof: longestLen is only used if longestDate is not null
+        GregorianCalendar longestDate = null; // null says no date found yet
+        int whereLen;   // tempcopy of where.getIndex()
+        
+        ParsePosition where = new ParsePosition(initialWhere.getIndex());
+        // check for null (throws exception) and trim off surrounding spaces
+        skipOptionals(text, where, " ");
+        int startPosition = where.getIndex();
 
-                retval.set(year, month-1, day, hour, minute, second );
-                // PDFBOX-598: PDF dates are only accurate up to a second
-                retval.set(Calendar.MILLISECOND, 0);
+        // try big-endian parse
+        GregorianCalendar retCal = parseBigEndianDate(text, where);
+        // check for success and a timezone
+        if (retCal != null &&
+                (where.getIndex() == text.length() 
+                || parseTZoffset(text, retCal, where))) 
+        {
+            // if text is fully consumed, return the date
+            // else remember it and its length
+            whereLen = where.getIndex();
+            if (whereLen == text.length()) 
+            {
+                initialWhere.setIndex(whereLen);
+                return retCal;
             }
-            catch( NumberFormatException e )
+            longestLen = whereLen;
+            longestDate = retCal;
+        }
+
+        // try one of the sets of standard formats
+        where.setIndex(startPosition);
+        String [] formats 
+                = Character.isDigit(text.charAt(startPosition))
+                ? DIGIT_START_FORMATS
+                : ALPHA_START_FORMATS;
+        retCal = parseSimpleDate(text, formats, where);
+        // check for success and a timezone
+        if (retCal != null && 
+                (where.getIndex() == text.length() 
+                || parseTZoffset(text, retCal, where)))
+        {
+            // if text is fully consumed, return the date
+            // else remember it and its length
+            whereLen = where.getIndex();
+            if (whereLen == text.length()) 
             {
-                for( int i=0; retval == null && i<POTENTIAL_FORMATS.length; i++ )
-                {
-                    try
-                    {
-                        Date utilDate = POTENTIAL_FORMATS[i].parse( date );
-                        retval = new GregorianCalendar();
-                        retval.setTime( utilDate );
-                    }
-                    catch( ParseException pe )
-                    {
-                        //ignore and move to next potential format
-                    }
-                }
-                if( retval == null )
+                initialWhere.setIndex(whereLen);
+                return retCal;
+            }
+            if (whereLen > longestLen) 
+            {
+                longestLen = whereLen;
+                longestDate = retCal;
+            }
+        }
+        
+        // try the supplied formats
+        if (moreFmts != null)
+        {
+            where.setIndex(startPosition);
+            retCal = parseSimpleDate(text, moreFmts, where);
+            if (retCal != null && 
+                (where.getIndex() == text.length() 
+                || parseTZoffset(text, retCal, where)))
+            {
+                whereLen = where.getIndex();
+                // if text is fully consumed, return the date
+                // else remember it and its length
+                if (whereLen == text.length() || 
+                        (longestDate != null && whereLen > longestLen)) 
                 {
-                    //we didn't find a valid date format so throw an exception
-                    throw new IOException( "Error converting date:" + date );
+                    initialWhere.setIndex(whereLen);
+                    return retCal;
                 }
             }
         }
-        return retval;
-    }
-
-    private static final void zeroAppend( StringBuffer out, int number )
-    {
-        if( number < 10 )
+        if (longestDate != null) 
         {
-            out.append( "0" );
+            initialWhere.setIndex(longestLen);
+            return longestDate;
         }
-        out.append( number );
+        return retCal;
     }
-
+       
     /**
-     * Convert the date to iso 8601 string format.
+     * Converts a string to a Calendar by parsing the String for a date.
+     * @see toCalendar(String).
      *
-     * @param cal The date to convert.
-     * @return The date represented as an ISO 8601 string.
+     * The returned value will have 0 for DST_OFFSET.
+     * 
+     * @param text The COSString representation of a date.
+     * @return The Calendar that the text string represents. 
+     *      Or null if text was null.
+     * @throws IOException If the date string is not in the correct format.
+     * @deprecated This method throws an IOException for failure. Replace
+     *      calls to it with {@link #toCalendar(text.getString(), null)} 
+     *      and test for failure with
+     *          (value == null || value.get(Calendar.YEAR) == INVALID_YEAR)
      */
-    public static String toISO8601( Calendar cal )
+    public static Calendar toCalendar(COSString text) throws IOException
     {
-        StringBuffer retval = new StringBuffer();
-
-        retval.append( cal.get( Calendar.YEAR ) );
-        retval.append( "-" );
-        zeroAppend( retval, cal.get( Calendar.MONTH )+1 );
-        retval.append( "-" );
-        zeroAppend( retval, cal.get( Calendar.DAY_OF_MONTH ) );
-        retval.append( "T" );
-        zeroAppend( retval, cal.get( Calendar.HOUR_OF_DAY ));
-        retval.append( ":" );
-        zeroAppend( retval, cal.get( Calendar.MINUTE ));
-        retval.append( ":" );
-        zeroAppend( retval, cal.get( Calendar.SECOND ));
-
-        int timeZone = cal.get( Calendar.ZONE_OFFSET ) + cal.get(Calendar.DST_OFFSET );
-        if( timeZone < 0 )
+        if (text == null)
         {
-            retval.append( "-" );
+            return null;    
         }
-        else
+        return toCalendar(text.getString());
+    }
+    
+    /**
+     * Converts a string date to a Calendar date value; equivalent to 
+     * {@link #toCalendar(String, null)}, 
+     * but throws an IOException for failure.
+     * 
+     * The returned value will have 0 for DST_OFFSET.
+     * 
+     * @param text The string representation of the calendar.
+     * @return The Calendar that this string represents 
+     *      or null if the incoming text is null.
+     * @throws IOException If the date string is non-null 
+     *      and not a parseable date.
+     * @deprecated This method throws an IOException for failure. Replace
+     *      calls to it with {@link #toCalendar(text, null)} 
+     *      and test for failure with
+     *          (value == null || value.get(Calendar.YEAR) == INVALID_YEAR)
+     */
+    public static Calendar toCalendar(String text) throws IOException
+    {
+        if (text == null)
         {
-            retval.append( "+" );
+            return null;    
         }
-        timeZone = Math.abs( timeZone );
-        //milliseconds/1000 = seconds = seconds / 60 = minutes = minutes/60 = hours
-        int hours = timeZone/1000/60/60;
-        int minutes = (timeZone - (hours*1000*60*60))/1000/1000;
-        if( hours < 10 )
+        Calendar val = toCalendar(text, null);
+        if (val != null && val.get(Calendar.YEAR) == INVALID_YEAR)  
         {
-            retval.append( "0" );
+            throw new IOException("Error converting date: " + text);
         }
-        retval.append( Integer.toString( hours ) );
-        retval.append( ":" );
-        if( minutes < 10 )
+        return val;
+    }
+    
+    /**
+     * Converts a string to a calendar. The entire string must be consumed.
+     * The date must be strictly correct; that is, no field may exceed
+     * the appropriate limit. Uses {@link #parseDate} to do the actual parsing.
+     * 
+     * The returned value will have 0 for DST_OFFSET.
+     * 
+     * @param text The text to parse. Initial spaces and "D:" are skipped over.
+     * @param moreFmts An Array of formats (as Strings) to try 
+     *      in addition to the standard list.
+     * @return the Calendar value corresponding to the date text. 
+     *      If text does not represent a valid date, 
+     *      the value is January 1 on year INVALID_YEAR at 0:0:0 GMT.
+     * 
+     */
+    public static Calendar toCalendar(String text, String[] moreFmts)
+    {
+        ParsePosition where = new ParsePosition(0);
+        skipOptionals(text, where, " ");
+        skipString(text, "D:", where);
+        Calendar retCal = parseDate(text, moreFmts, where);   // PARSE THE TEXT
+        if (retCal == null || where.getIndex() != text.length()) 
         {
-            retval.append( "0" );
+            // the date string is invalid for all formats we tried,
+            retCal = newGreg();
+            retCal.set(INVALID_YEAR, 0, 1, 0, 0, 0);
         }
-        retval.append( Integer.toString( minutes ) );
-
-        return retval.toString();
+        return retCal;
     }
 }
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/util/TestDateUtil.java b/pdfbox/src/test/java/org/apache/pdfbox/util/TestDateUtil.java
index 58a3bfae87..28d467bf9e 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/util/TestDateUtil.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/util/TestDateUtil.java
@@ -17,22 +17,32 @@
 package org.apache.pdfbox.util;
 
 import java.io.IOException;
+import java.text.ParsePosition;
 import java.util.Calendar;
 import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.SimpleTimeZone;
 import java.util.TimeZone;
 
 import junit.framework.Test;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
+import org.apache.pdfbox.cos.COSString;
+
 /**
  * Test the date conversion utility.
  *
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.2 $
+ * @author <a href="mailto:zweibieren@ahoo.com">Fred Hansen</a>
+ * 
  */
 public class TestDateUtil extends TestCase
 {
+    private static final int MINS = 60*1000, HRS = 60*MINS;
+    // expect parse fail
+    private static final int BAD = -666;  
+    
     /**
      * Test class constructor.
      *
@@ -45,29 +55,68 @@ public class TestDateUtil extends TestCase
         super( name );
     }
 
+    
+    ////////////////////////////////////////////////////
+    // Test body follows
+    
+    
     /**
      * Test common date formats.
      *
      * @throws Exception when there is an exception
      */
-    public void testExtract()
-        throws Exception
+    public void testExtract() throws Exception
     {
         TimeZone timezone = TimeZone.getDefault();
         TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-        try {
-            assertEquals( DateConverter.toCalendar( "D:05/12/2005" ), new GregorianCalendar( 2005, 4, 12 ) );
-            assertEquals( DateConverter.toCalendar( "5/12/2005 15:57:16" ), new GregorianCalendar( 2005, 4,12,15,57,16 ) );
-        } finally {
+        try 
+        {
+            assertCalendarEquals( new GregorianCalendar( 2005, 4, 12 ), 
+                    DateConverter.toCalendar( "D:05/12/2005" ) );
+            assertCalendarEquals( new GregorianCalendar( 2005, 4,12,15,57,16 ), 
+                    DateConverter.toCalendar( "5/12/2005 15:57:16" ) );
+        }
+        catch (IOException ex) 
+        {
+            ex.printStackTrace();
+        }
+        finally 
+        {
             TimeZone.setDefault(timezone);
         }
+        // check that new toCalendar gives NullPointer for a null arg
+        try 
+        { 
+            DateConverter.toCalendar(null, null);
+            assertNotNull(null);    // failed to have expected exception
+        } 
+        catch (NullPointerException ex) 
+        {
+            // expected outcome
+        }   
     }
-
+    
+    /**
+     * Calendar.equals test case.
+     * 
+     * @param expect the expected calendar value
+     * @param was the calendar value to be checked
+     */
+    public void assertCalendarEquals(Calendar expect, Calendar was) 
+    {
+        assertEquals( expect.getTimeInMillis(), was.getTimeInMillis() );
+        assertEquals( expect.getTimeZone().getRawOffset(), 
+                was.getTimeZone().getRawOffset() );
+    }
+    
     /**
      * Test case for
-     * <a href="https://issues.apache.org/jira/browse/PDFBOX-598">PDFBOX-598</a>
+     * <a href="https://issues.apache.org/jira/browse/PDFBOX-598">PDFBOX-598</a>.
+     * 
+     * @throws IOException if something went wrong.
      */
-    public void testDateConversion() throws Exception { 
+    public void testDateConversion() throws IOException 
+    { 
         Calendar c = DateConverter.toCalendar("D:20050526205258+01'00'"); 
         assertEquals(2005, c.get(Calendar.YEAR)); 
         assertEquals(05-1, c.get(Calendar.MONTH)); 
@@ -78,41 +127,316 @@ public class TestDateUtil extends TestCase
         assertEquals(0, c.get(Calendar.MILLISECOND)); 
     }
 
-    public void testDateConverter() throws Exception {
-        TimeZone timezone = TimeZone.getDefault();
-        TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
-        try {
-            assertDate("2010-01-01T00:00:00+00:00", "D:2010");
-            assertDate("2010-01-01T00:00:00+00:00", "2010");
-            assertDate("2010-04-23T00:00:00+00:00", "D:20100423");
-            assertDate("2010-04-23T00:00:00+00:00", "20100423");
+    /**
+     * Check toCalendar.
+     * @param yr expected year value
+     *  If an IOException is the expected result, yr should be null
+     * @param mon expected month value
+     * @param day expected dayofmonth value
+     * @param hr expected hour value
+     * @param min expected minute value
+     * @param sec expected second value
+     * @param tz represents expected timezone offset 
+     * @param orig  A date to be parsed.
+     * @throws Exception If an unexpected error occurs.
+     */
+    private static void checkParse(int yr, int mon, int day, 
+                int hr, int min, int sec, int offset,  
+                String orig) throws Exception 
+    {
+        String pdfDate = String.format("D:%04d%02d%02d%02d%02d%02d%+03d'00'", 
+                yr,mon,day,hr,min,sec,offset);
+        String iso8601Date = String.format("%04d-%02d-%02d"
+                + "T%02d:%02d:%02d%+03d:00", 
+                yr,mon,day,hr,min,sec,offset);
+        Calendar cal = null;
+        try 
+        {
+            cal = DateConverter.toCalendar(orig);
+        }
+        catch (IOException ex) 
+        {
+            assertEquals(yr, BAD);
+        }
+        if (cal != null) 
+        {
+            assertEquals(iso8601Date, DateConverter.toISO8601(cal));
+            assertEquals(pdfDate, DateConverter.toString(cal));
+        }
+        // new toCalendar()
+        cal = DateConverter.toCalendar(orig, null);
+        if (yr == BAD) 
+        {
+            assertEquals(cal.get(Calendar.YEAR), DateConverter.INVALID_YEAR);
+        }
+        else
+        {
+            assertEquals(pdfDate, DateConverter.toString(cal));
+        }
+    }
 
-            // assertDate("2007-04-30T19:36:47+????", "20070430193647+713'00'");
-            // assertDate("2007-08-21T10:35:22+00:00", "Tue Aug 21 10:35:22 2007");
-            assertDate("2008-11-04T00:00:00+00:00", "Tuesday, November 04, 2008");
-            // assertDate("2007-12-17T02:02:03+00:00", "200712172:2:3");
-            // assertDate("????", "Unknown");
-            // assertDate("2009-03-19T20:01:22+00:00", "20090319 200122");
-            //  assertDate("2008-05-12T09:47:00+00:00", "9:47 5/12/2008");
+    /**
+     * Test dates in various formats.
+     * Years differ to make it easier to find failures.
+     * @throws Exception none expected
+     */
+    public void testDateConverter() throws Exception 
+    {
+            int year = Calendar.getInstance().get(Calendar.YEAR);
+            checkParse(2010, 4,23, 0, 0, 0, 0, "D:20100423");
+            checkParse(2011, 4,23, 0, 0, 0, 0, "20110423");
+            checkParse(2012, 1, 1, 0, 0, 0, 0, "D:2012");
+            checkParse(2013, 1, 1, 0, 0, 0, 0, "2013");
 
-            // assertDate("2009-04-01T00:00:00+02:00", "20090401+0200");
-            assertDate("2008-01-11T00:00:00+00:00", "Friday, January 11, 2008");
-            // assertDate("2009-04-01T00:00:00+04:00", "20090401+04'00'");
-            // assertDate("2009-04-01T00:00:00+09:00", "20090401+09'00'");
-            // assertDate("2009-04-01T00:00:00-02:00", "20090401-02'00'");
-            // assertDate("2009-04-01T06:01:01+00:00", "20090401 01:01:01 -0500");
-            // assertDate("2000-05-26T11:25:10+00:00", "26 May 2000 11:25:10");
-            // assertDate("2000-05-26T11:25:00+00:00", "26 May 2000 11:25");
-        } finally {
-            TimeZone.setDefault(timezone);
-        }
+            // PDFBOX-1219
+            checkParse(2001, 1,31,10,33, 0, +1,  "2001-01-31T10:33+01:00  ");   
+            // PDFBOX-465
+            checkParse(2002, 5,12, 9,47, 0, 0, "9:47 5/12/2002");  
+            // PDFBOX-465
+            checkParse(2003,12,17, 2, 2, 3, 0, "200312172:2:3"); 
+            // PDFBOX-465
+            checkParse(2009, 3,19,20, 1,22, 0, "  20090319 200122");  
+
+            checkParse(2014, 4, 1, 0, 0, 0, +2, "20140401+0200");
+            // "EEEE, MMM dd, yy",
+            checkParse(2115, 1,11, 0, 0, 0, 0, "Friday, January 11, 2115");  
+            // "EEEE, MMM dd, yy",
+            checkParse(1915, 1,11, 0, 0, 0, 0, "Monday, Jan 11, 1915");  
+            // "EEEE, MMM dd, yy",
+            checkParse(2215, 1,11, 0, 0, 0, 0, "Wed, January 11, 2215");  
+            // "EEEE, MMM dd, yy",
+            checkParse(2015, 1,11, 0, 0, 0, 0, " Sun, January 11, 2015 ");  
+            checkParse(2016, 4, 1, 0, 0, 0, +4, "20160401+04'00'");
+            checkParse(2017, 4, 1, 0, 0, 0, +9, "20170401+09'00'");
+            checkParse(2018, 4, 1, 0, 0, 0, -2, "20180401-02'00'");
+            checkParse(2019, 4, 1, 6, 1, 1, -11, "20190401 6:1:1 -1100");
+            checkParse(2020, 5,26,11,25,10, 0, "26 May 2020 11:25:10");
+            checkParse(2021, 5,26,11,23, 0, 0, "26 May 2021 11:23");
+
+            // try dates invalid due to out of limit values
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "Tuesday, May 32 2000 11:27 UCT");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "32 May 2000 11:25");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "Tuesday, May 32 2000 11:25");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "19921301 11:25");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "19921232 11:25");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "19921001 11:60");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0,  "19920401 24:25");
+            
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, 
+            "20070430193647+713'00' illegal tz hr");  // PDFBOX-465
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, "nodigits");
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, "Unknown"); // PDFBOX-465
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, "333three digit year");
+            
+            checkParse(2000, 2,29, 0, 0, 0, 0, "2000 Feb 29"); // valid date
+            checkParse(2000, 2,29, 0, 0, 0,+11, " 2000 Feb 29 GMT + 11:00"); // valid date
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, "2100 Feb 29 GMT+11"); // invalid date
+            checkParse(2012, 2,29, 0, 0, 0,+11, "2012 Feb 29 GMT+11"); // valid date
+            checkParse(BAD, 0, 0, 0, 0, 0,  0, "2012 Feb 30 GMT+11"); // invalid date
+
+            checkParse(1970,12,23, 0, 8, 0,  0, "1970 12 23:08");  // test ambiguous date 
+            
+            // cannot have P for PM
+            // cannot have Sat. instead of Sat
+            // EST works, but EDT does not; EST is a special kludge in Java
+            
+            // test cases for all entries on old formats list
+            //  "E, dd MMM yyyy hh:mm:ss a"  
+            checkParse(1971, 7, 6, 17, 22, 1, 0, "Tuesday, 6 Jul 1971 5:22:1 PM"); 
+            //  "EE, MMM dd, yyyy hh:mm:ss a"
+            checkParse(1972, 7, 6, 17, 22, 1, 0, "Thu, July 6, 1972 5:22:1 pm");   
+            //  "MM/dd/yyyy hh:mm:ss"
+            checkParse(1973, 7, 6, 17, 22, 1, 0, "7/6/1973 17:22:1");   
+            //  "MM/dd/yyyy"
+            checkParse(1974, 7, 6, 0, 0, 0, 0, "7/6/1974");   
+            //  "yyyy-MM-dd'T'HH:mm:ss'Z'"
+            checkParse(1975, 7, 6, 17, 22, 1, -10, "1975-7-6T17:22:1-1000");   
+            //  "yyyy-MM-dd'T'HH:mm:ssz"
+            checkParse(1976, 7, 6, 17, 22, 1, -4, "1976-7-6T17:22:1GMT-4");   
+            //  "yyyy-MM-dd'T'HH:mm:ssz"
+            checkParse(BAD, 7, 6, 17, 22, 1, -4, "2076-7-6T17:22:1EDT");   // "EDT" is not a known tz ID
+            //  "yyyy-MM-dd'T'HH:mm:ssz"
+            checkParse(1960, 7, 6, 17, 22, 1, -5, "1960-7-6T17:22:1EST");   // "EST" does not have a DST rule
+           //  "EEEE, MMM dd, yyyy"
+            checkParse(1977, 7, 6, 0, 0, 0, 0, "Wednesday, Jul 6, 1977");   
+            //  "EEEE MMM dd, yyyy HH:mm:ss"
+            checkParse(1978, 7, 6, 17, 22, 1, 0, "Thu Jul 6, 1978 17:22:1");   
+            //  "EEEE MMM dd HH:mm:ss z yyyy"
+            checkParse(1979, 7, 6, 17, 22, 1, +8, "Friday July 6 17:22:1 GMT+08:00 1979");   
+            //  "EEEE, MMM dd, yyyy 'at' hh:mma"
+            checkParse(1980, 7, 6, 16, 23, 0, 0, "Sun, Jul 6, 1980 at 4:23pm");   
+            //  "EEEEEEEEEE, MMMMMMMMMMMM dd, yyyy"
+            checkParse(1981, 7, 6, 0, 0, 0, 0, "Monday, July 6, 1981");   
+            //  "dd MMM yyyy hh:mm:ss"
+            checkParse(1982, 7, 6, 17, 22, 1, 0, "6 Jul 1982 17:22:1");   
+            //  "M/dd/yyyy hh:mm:ss"
+            checkParse(1983, 7, 6, 17, 22, 1, 0, "7/6/1983 17:22:1");   
+            //  "MM/d/yyyy hh:mm:ss"
+            checkParse(1984, 7, 6, 17, 22, 1, 0, "7/6/1984 17:22:01");   
+            //  "M/dd/yyyy"
+            checkParse(1985, 7, 6, 0, 0, 0, 0, "7/6/1985");   
+            //  "MM/d/yyyy"
+            checkParse(1986, 7, 6, 0, 0, 0, 0, "07/06/1986");   
+            //  "M/d/yyyy hh:mm:ss"
+            checkParse(1987, 7, 6, 17, 22, 1, 0, "7/6/1987 17:22:1");   
+            //  "M/d/yyyy"
+            checkParse(1988, 7, 6, 0, 0, 0, 0, "7/6/1988");   
+
+            // test ends of range of two digit years
+            checkParse(year-79, 1, 1, 0, 0, 0, 0, "1/1/" + ((year-79)%100)
+                    + " 00:00:00");   //  "M/d/yy hh:mm:ss"
+            //  "M/d/yy"
+            checkParse(year+19, 1, 1, 0, 0, 0, 0, "1/1/" + ((year+19)%100));   
+            
+            //  "yyyyMMdd hh:mm:ss Z"  
+            checkParse(1991, 7, 6, 17, 7, 1, +6, "19910706 17:7:1 Z+0600");   
+            //  "yyyyMMdd hh:mm:ss"
+            checkParse(1992, 7, 6, 17, 7, 1, 0, "19920706 17:07:01");   
+            //  "yyyyMMdd'+00''00'''"
+            checkParse(1993, 7, 6, 0, 0, 0, 0, "19930706+00'00'");   
+            //  "yyyyMMdd'+01''00'''"
+            checkParse(1994, 7, 6, 0, 0, 0, 1, "19940706+01'00'");   
+            //  "yyyyMMdd'+02''00'''"
+            checkParse(1995, 7, 6, 0, 0, 0, 2, "19950706+02'00'");   
+            //  "yyyyMMdd'+03''00'''"
+            checkParse(1996, 7, 6, 0, 0, 0, 3, "19960706+03'00'");   
+             //   . . .
+            // "yyyyMMdd'-10''00'''"
+            checkParse(1997, 7, 6, 0, 0, 0, -10, "19970706-10'00'");   
+            // "yyyyMMdd'-11''00'''"
+            checkParse(1998, 7, 6, 0, 0, 0, -11, "19980706-11'00'");   
+            //  "yyyyMMdd"
+            checkParse(1999, 7, 6, 0, 0, 0, 0, "19990706");   
+            // ambiguous big-endian date
+            checkParse(2073,12,25, 0, 8, 0, 0, "2073 12 25:08"); 
+            
     }
 
-    private void assertDate(String expected, String date) throws Exception {
-        Calendar calendar = DateConverter.toCalendar(date);
-        assertEquals(expected, DateConverter.toISO8601(calendar));
+    private static void checkToString(int yr, int mon, int day, 
+                int hr, int min, int sec, TimeZone tz, int off) throws Exception 
+    {
+        // construct a GregoreanCalendar from args
+        GregorianCalendar cal = new GregorianCalendar(tz, Locale.ENGLISH);
+        cal.set(yr, mon-1, day, hr, min, sec);
+        // create expected strings
+        String pdfDate = String.format("D:%04d%02d%02d%02d%02d%02d%+03d'00'", 
+                yr,mon,day,hr,min,sec,off);
+        String iso8601Date = String.format("%04d-%02d-%02d"
+                + "T%02d:%02d:%02d%+03d:00", 
+                yr,mon,day,hr,min,sec,off);
+        // compare outputs from toString and toISO8601 with expected values
+        assertEquals(pdfDate, DateConverter.toString(cal));
+        assertEquals(iso8601Date, DateConverter.toISO8601(cal));
+    }
+    
+    /** 
+     * Test toString() and toISO8601() for various dates.
+     * 
+     * @throws Exception if something went wrong.
+     */
+    public void testToString() throws Exception 
+    {                                                              // std DST
+        TimeZone tzPgh = TimeZone.getTimeZone("America/New_York");   // -5 -4
+        TimeZone tzBerlin = TimeZone.getTimeZone("Europe/Berlin");   // +1 +2
+        TimeZone tzMaputo = TimeZone.getTimeZone("Africa/Maputo");   // +2 +2
+        TimeZone tzAruba = TimeZone.getTimeZone("America/Aruba");    // -4 -4
+        TimeZone tzJamaica = TimeZone.getTimeZone("America/Jamaica");// -5 -5
+        TimeZone tzMcMurdo = TimeZone.getTimeZone("Antartica/McMurdo");// +12 +13
+        
+        assertNull(DateConverter.toCalendar((COSString) null));
+        assertNull(DateConverter.toCalendar((String) null));
+        
+        checkToString(2013, 8, 28, 3, 14, 15, tzPgh, -4);
+        checkToString(2014, 2, 28, 3, 14, 15, tzPgh, -5);
+        checkToString(2015, 8, 28, 3, 14, 15, tzBerlin, +2);
+        checkToString(2016, 2, 28, 3, 14, 15, tzBerlin, +1);
+        checkToString(2017, 8, 28, 3, 14, 15, tzAruba, -4);
+        checkToString(2018, 1, 1, 1, 14, 15, tzJamaica, -5);
+        checkToString(2019, 12, 31, 12, 59, 59, tzJamaica, -5);
+        checkToString(2020, 2, 29, 0, 0, 0, tzMaputo, +2);
+        // McMurdo has a daylightsavings rule, but it seems never to apply
+        checkToString(1981, 1, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1982, 2, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1983, 3, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1984, 4, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1985, 5, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1986, 6, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1987, 7, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1988, 8, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1989, 9, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1990, 10, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1991, 11, 1, 1, 14, 15, tzMcMurdo, +0);
+        checkToString(1992, 12, 1, 1, 14, 15, tzMcMurdo, +0);
+    }
+   
+    private static void checkParseTZ(int expect, String src) 
+    {
+        GregorianCalendar dest = DateConverter.newGreg();
+        DateConverter.parseTZoffset(src, dest, new ParsePosition(0));
+        assertEquals(expect, dest.get(Calendar.ZONE_OFFSET));
     }
 
+    /**
+     * Timezone testcase.
+     */
+    public void testParseTZ() 
+    {
+        checkParseTZ(0*HRS+0*MINS, "+00:00");
+        checkParseTZ(0*HRS+0*MINS, "-0000");
+        checkParseTZ(1*HRS+0*MINS, "+1:00");
+        checkParseTZ(-(1*HRS+0*MINS), "-1:00");
+        checkParseTZ(-(1*HRS+30*MINS), "-0130");
+        checkParseTZ(11*HRS+59*MINS, "1159");
+        checkParseTZ(-(11*HRS+30*MINS), "1230");
+        checkParseTZ(11*HRS+30*MINS, "-12:30");
+        checkParseTZ(0*HRS+0*MINS, "Z");
+        checkParseTZ(-(8*HRS+0*MINS), "PST");
+        checkParseTZ(0*HRS+0*MINS, "EDT");  // EDT does not parse
+        checkParseTZ(-(3*HRS+0*MINS), "GMT-0300");
+        checkParseTZ(+(11*HRS+0*MINS), "GMT+11:00");
+        checkParseTZ(-(6*HRS+0*MINS), "America/Chicago");
+        checkParseTZ(+(4*HRS+0*MINS), "Europe/Moscow");
+        checkParseTZ((5*HRS+0*MINS), "0500");
+        checkParseTZ((5*HRS+0*MINS), "+0500");
+        checkParseTZ((11*HRS+0*MINS), "+11'00'");
+        checkParseTZ(0, "Z");
+    }
+    
+    private static void checkFormatOffset(double off, String expect) 
+    {
+        TimeZone tz = new SimpleTimeZone((int)(off*60*60*1000), "junkID");
+        String got = DateConverter.formatTZoffset(tz.getRawOffset(), ":");
+        assertEquals(expect, got);
+    }
+    
+    /**
+     * Timezone offset testcase.
+     * 
+     * @throws Exception
+     */
+    public void testFormatTZoffset()
+    {
+        checkFormatOffset(-12.1, "+11:54");
+        checkFormatOffset(12.1, "-11:54");
+        checkFormatOffset(0, "+00:00");
+        checkFormatOffset(-1, "-01:00");
+        checkFormatOffset(.5, "+00:30");
+        checkFormatOffset(-0.5, "-00:30");
+        checkFormatOffset(.1, "+00:06");
+        checkFormatOffset(-0.1, "-00:06");
+        checkFormatOffset(-12, "+00:00");
+        checkFormatOffset(12, "+00:00");
+        checkFormatOffset(-11.5, "-11:30");
+        checkFormatOffset(11.5, "+11:30");
+        checkFormatOffset(11.9, "+11:54");
+        checkFormatOffset(11.1, "+11:06");
+        checkFormatOffset(-11.9, "-11:54");
+        checkFormatOffset(-11.1, "-11:06");
+    }
+    
+    // testbody precedes
+    ////////////////////////////////////////////////////
+    
     /**
      * Set the tests in the suite for this test class.
      *
@@ -130,7 +454,10 @@ public class TestDateUtil extends TestCase
      */
     public static void main( String[] args )
     {
-        String[] arg = {TestDateUtil.class.getName() };
+        String[] arg = 
+        {
+            TestDateUtil.class.getName() 
+        };
         junit.textui.TestRunner.main( arg );
     }
 }
