diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/COSWriterCompressionPool.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/COSWriterCompressionPool.java
index e008661ab0..a9dacd06f1 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/COSWriterCompressionPool.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/COSWriterCompressionPool.java
@@ -19,8 +19,8 @@ package org.apache.pdfbox.pdfwriter.compress;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
-import java.util.Map.Entry;
 
 import org.apache.pdfbox.pdfparser.PDFXRefStream;
 import org.apache.pdfbox.pdmodel.PDDocument;
@@ -52,6 +52,8 @@ public class COSWriterCompressionPool
     private final List<COSObjectKey> topLevelObjects = new ArrayList<>();
     // A list containing all objects, that may be appended to an object stream.
     private final List<COSObjectKey> objectStreamObjects = new ArrayList<>();
+    // A list of all direct objects
+    private final List<COSBase> allDirectObjects = new ArrayList<>();
 
     /**
      * <p>
@@ -78,8 +80,8 @@ public class COSWriterCompressionPool
         COSDocument cosDocument = document.getDocument();
 
         COSDictionary trailer = cosDocument.getTrailer();
-        addStructure(new TraversedCOSElement(trailer.getItem(COSName.ROOT)));
-        addStructure(new TraversedCOSElement(trailer.getItem(COSName.INFO)));
+        addStructure(trailer.getItem(COSName.ROOT));
+        addStructure(trailer.getItem(COSName.INFO));
 
         Collections.sort(objectStreamObjects);
         Collections.sort(topLevelObjects);
@@ -91,22 +93,21 @@ public class COSWriterCompressionPool
      * of object, it shall either be appended as-is or shall be appended to a compressed {@link COSWriterObjectStream}.
      *
      * @param key The {@link COSObjectKey} that shall be used as the {@link COSBase}s ID, if possible.
-     * @param element The {@link COSBase}, that shall be registered in this pool.
+     * @param base The {@link COSBase}, that shall be registered in this pool.
      */
-    private COSBase addObjectToPool(COSObjectKey key, TraversedCOSElement element)
+    private COSBase addObjectToPool(COSObjectKey key, COSBase base)
     {
         // Drop hollow objects.
-        COSBase base = element.getCurrentObject();
-        base = base instanceof COSObject ? ((COSObject) base).getObject() : base;
+        COSBase current = base instanceof COSObject ? ((COSObject) base).getObject() : base;
         // to avoid to mixup indirect COSInteger objects holding the same value we have to check
         // if the given key is the same than the key which is stored for the "same" base object wihtin the object pool
         // the same is always true for COSFloat, COSBoolean and COSName and under certain circumstances for the remainig
         // types as well
-        if (base == null //
+        if (current == null //
                 || (key != null && objectPool.contains(key)) //
-                || (key == null && objectPool.contains(base)))
+                || (key == null && objectPool.contains(current)))
         {
-            return base;
+            return current;
         }
 
         // Check whether the object can not be appended to an object stream.
@@ -115,99 +116,77 @@ public class COSWriterCompressionPool
         // It shall never contain the document's root dictionary. (relevant for document encryption)
         // It shall never contain other streams.
         if ((key != null && key.getGeneration() != 0)
-                || base instanceof COSStream
+                || current instanceof COSStream
                 || (document.getEncryption() != null
-                        && base == document.getEncryption().getCOSObject())
-                || base == this.document.getDocument().getTrailer().getCOSDictionary(COSName.ROOT))
+                        && current == document.getEncryption().getCOSObject())
+                || current == this.document.getDocument().getTrailer()
+                        .getCOSDictionary(COSName.ROOT))
         {
-            COSObjectKey actualKey = objectPool.put(key, base);
+            COSObjectKey actualKey = objectPool.put(key, current);
             if (actualKey == null)
             {
-                return base;
+                return current;
             }
             topLevelObjects.add(actualKey);
-            return base;
+            return current;
         }
 
         // Determine the object key.
-        COSObjectKey actualKey = objectPool.put(key, base);
+        COSObjectKey actualKey = objectPool.put(key, current);
         if (actualKey == null)
         {
-            return base;
+            return current;
         }
 
         // Append it to an object stream.
         this.objectStreamObjects.add(actualKey);
-        return base;
+        return current;
     }
 
     /**
      * Attempts to find yet unregistered streams and dictionaries in the given structure.
      *
-     * @param traversedObject A Collection of all objects, that have already been traversed, to avoid cycles.
+     * @param current The object to be added for compressing.
      * @throws IOException Shall be thrown, if compressing the object failed.
      */
-    private void addStructure(TraversedCOSElement traversedObject) throws IOException
+    private void addStructure(COSBase current) throws IOException
     {
-        COSBase current = traversedObject.getCurrentObject();
         COSBase base = current;
         if (current instanceof COSStream
                 || (current instanceof COSDictionary && !current.isDirect()))
         {
-            base = addObjectToPool(base.getKey(), traversedObject);
+            base = addObjectToPool(base.getKey(), current);
         }
         else if (current instanceof COSObject)
         {
             base = ((COSObject) current).getObject();
             if (base != null)
             {
-                base = addObjectToPool(current.getKey(), traversedObject);
+                base = addObjectToPool(current.getKey(), current);
             }
         }
-
         if (base instanceof COSArray)
         {
-            addCOSArray(traversedObject, (COSArray) base);
+            addElements(current, ((COSArray) base).iterator());
         }
         else if (base instanceof COSDictionary)
         {
-            addCOSDictionary(traversedObject, (COSDictionary) base);
-        }
-    }
-
-    private void addCOSArray(TraversedCOSElement traversedObject, COSArray array) throws IOException
-    {
-        for (COSBase value : array)
-        {
-            if (value instanceof COSArray || value instanceof COSDictionary)
-            {
-                addStructure(traversedObject.appendTraversedElement(value));
-            }
-            else if (value instanceof COSObject)
-            {
-                COSObject cosObject = (COSObject) value;
-                if (cosObject.getKey() != null && objectPool.contains(cosObject.getKey()))
-                {
-                    continue;
-                }
-                if (cosObject.getObject() != null)
-                {
-                    addStructure(traversedObject.appendTraversedElement(value));
-                }
-            }
+            addElements(current, ((COSDictionary) base).getValues().iterator());
         }
     }
 
-    private void addCOSDictionary(TraversedCOSElement traversedObject, COSDictionary dictionary)
+    private void addElements(COSBase current, Iterator<COSBase> elements)
             throws IOException
     {
-        for (Entry<COSName, COSBase> entry : dictionary.entrySet())
+        while (elements.hasNext())
         {
-            COSBase value = entry.getValue();
-            if (value instanceof COSArray || (value instanceof COSDictionary
-                    && !traversedObject.getAllTraversedObjects().contains(value)))
+            COSBase value = elements.next();
+            if (value instanceof COSArray
+                    || (value instanceof COSDictionary
+                    && !allDirectObjects.contains(value)))
             {
-                addStructure(traversedObject.appendTraversedElement(value));
+                allDirectObjects.add(value);
+                addStructure(value);
             }
             else if (value instanceof COSObject)
             {
@@ -218,10 +197,9 @@ public class COSWriterCompressionPool
                 }
                 if (cosObject.getObject() != null)
                 {
-                    addStructure(traversedObject.appendTraversedElement(value));
+                    addStructure(value);
                 }
             }
-
         }
     }
 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/TraversedCOSElement.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/TraversedCOSElement.java
deleted file mode 100644
index 562d8c7a6f..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/compress/TraversedCOSElement.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.pdfwriter.compress;
-
-import org.apache.pdfbox.cos.COSBase;
-import org.apache.pdfbox.cos.COSObject;
-import org.apache.pdfbox.cos.COSStream;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * An instance of this class represents a traversed element of a COS tree. It allows to determine the position of a
- * {@link COSBase} in a hierarchical COS structure and provides the means to further traverse and evaluate it's
- * descendants.
- *
- * @author Christian Appl
- */
-public class TraversedCOSElement
-{
-
-    private final TraversedCOSElement parent;
-    private final COSBase currentObject;
-    private final List<TraversedCOSElement> traversedChildren = new ArrayList<>();
-    private boolean partOfStreamDictionary = false;
-    private final List<COSBase> allObjects;
-
-    /**
-     * Construct a fresh entrypoint for the traversal of a hierarchical COS structure, beginning with the given
-     * {@link COSBase}.
-     *
-     * @param currentObject The initial {@link COSBase}, with which the structure traversal shall begin.
-     */
-    public TraversedCOSElement(COSBase currentObject)
-    {
-        this(new ArrayList<>(), null, currentObject);
-    }
-
-    /**
-     * Construct a traversal node for the traversal of a hierarchical COS structure, located at the given
-     * {@link COSBase}, preceded by this given list of ancestors and contained in the given parent structure.
-     *
-     * @param allObjects The list of nodes, that have been traversed to reach the current object.
-     * @param parent The parent node, that does contain this node.
-     * @param currentObject The initial {@link COSBase}, with which the structure traversal shall begin.
-     */
-    private TraversedCOSElement(List<COSBase> allObjects, TraversedCOSElement parent,
-            COSBase currentObject)
-    {
-        this.parent = parent;
-        this.currentObject = currentObject;
-        this.allObjects = allObjects;
-    }
-
-    /**
-     * Construct a new traversal node for the given element and append it as a child to the current node.
-     *
-     * @param element The element, that shall be traversed.
-     * @return The resulting traversal node, that has been created.
-     */
-    public TraversedCOSElement appendTraversedElement(COSBase element)
-    {
-        if (element == null)
-        {
-            return this;
-        }
-        allObjects.add(element);
-        TraversedCOSElement traversedElement = new TraversedCOSElement(allObjects, this, element);
-        traversedElement.setPartOfStreamDictionary(
-                isPartOfStreamDictionary() || getCurrentBaseObject() instanceof COSStream);
-        this.traversedChildren.add(traversedElement);
-        return traversedElement;
-    }
-
-    /**
-     * Returns the current {@link COSBase} of this traversal node.
-     *
-     * @return The current {@link COSBase} of this traversal node.
-     */
-    public COSBase getCurrentObject()
-    {
-        return currentObject;
-    }
-
-    /**
-     * Returns the actual current {@link COSBase} of this traversal node. Meaning: If the current traversal node
-     * contains a reference to a {@link COSObject}, it's actual base object will be returned instead.
-     *
-     * @return The actual current {@link COSBase} of this traversal node.
-     */
-    public COSBase getCurrentBaseObject()
-    {
-        return currentObject instanceof COSObject ? ((COSObject) currentObject).getObject()
-                : currentObject;
-    }
-
-    /**
-     * Returns the parent node of the current traversal node.
-     *
-     * @return The parent node of the current traversal node.
-     */
-    public TraversedCOSElement getParent()
-    {
-        return this.parent;
-    }
-
-    /**
-     * Returns all known traversable/traversed children contained by the current traversal node.
-     *
-     * @return All known traversable/traversed children contained by the current traversal node.
-     */
-    public List<TraversedCOSElement> getTraversedChildren()
-    {
-        return traversedChildren;
-    }
-
-    public List<TraversedCOSElement> getTraversedElements()
-    {
-        List<TraversedCOSElement> ancestry = parent == null ? new ArrayList<>()
-                : parent.getTraversedElements();
-        ancestry.add(this);
-        return ancestry;
-    }
-
-    /**
-     * Searches all known traversed child nodes of the current traversal node for the given {@link COSBase}.
-     *
-     * @param object The {@link COSBase}, that shall be found.
-     * @return The traversal node representing the searched {@link COSBase} or null, if such a node can not be found.
-     */
-    public TraversedCOSElement findAtCurrentPosition(COSBase object)
-    {
-        for (TraversedCOSElement child : traversedChildren)
-        {
-            if (child.getCurrentObject() == object)
-            {
-                return child;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Returns a list of all objects, that have been traversed in the created traversal tree.
-     *
-     * @return A list of all objects, that have been traversed in the created traversal tree.
-     */
-    public List<COSBase> getAllTraversedObjects()
-    {
-        return allObjects;
-    }
-
-    /**
-     * Returns true, if the given traversal node has been marked as a part of a {@link COSStream}.
-     *
-     * @return True, if the given traversal node has been marked as a part of a {@link COSStream}
-     */
-    public boolean isPartOfStreamDictionary()
-    {
-        return partOfStreamDictionary;
-    }
-
-    /**
-     * Set to true, if the given traversal node shall be marked as a part of a {@link COSStream}.
-     *
-     * @param partOfStreamDictionary True, if the given traversal node shall be marked as a part of a {@link COSStream}
-     */
-    public void setPartOfStreamDictionary(boolean partOfStreamDictionary)
-    {
-        this.partOfStreamDictionary = partOfStreamDictionary;
-    }
-
-}
