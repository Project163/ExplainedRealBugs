diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
index 4f549ce1e6..3903cdc22d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
@@ -309,7 +309,7 @@ public class COSArray extends COSBase implements Iterable<COSBase>
         }
         else
         {
-            set ( index, null );
+            set( index, null );
         }
     }   
 
@@ -551,7 +551,7 @@ public class COSArray extends COSBase implements Iterable<COSBase>
      *
      *  @return the COSArray as List
      */
-    public List<COSBase> toList()
+    public List<?> toList()
     {
         ArrayList<COSBase> retList = new ArrayList<COSBase>(size());
         for (int i = 0; i < size(); i++)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
index 8e00f1baca..8ca6593a8d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
@@ -38,10 +38,10 @@ import org.apache.pdfbox.cos.COSString;
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.10 $
  */
-public class COSDictionaryMap implements Map
+public class COSDictionaryMap<K,V> implements Map<K,V>
 {
     private COSDictionary map;
-    private Map actuals;
+    private Map<K,V> actuals;
 
     /**
      * Constructor for this map.
@@ -49,7 +49,7 @@ public class COSDictionaryMap implements Map
      * @param actualsMap The map with standard java objects as values.
      * @param dicMap The map with COSBase objects as values.
      */
-    public COSDictionaryMap( Map actualsMap, COSDictionary dicMap )
+    public COSDictionaryMap( Map<K,V> actualsMap, COSDictionary dicMap )
     {
         actuals = actualsMap;
         map = dicMap;
@@ -91,7 +91,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object get(Object key)
+    public V get(Object key)
     {
         return actuals.get( key );
     }
@@ -99,7 +99,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object put(Object key, Object value)
+    public V put(K key, V value)
     {
         COSObjectable object = (COSObjectable)value;
 
@@ -110,7 +110,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object remove(Object key)
+    public V remove(Object key)
     {
         map.removeItem( COSName.getPDFName( (String)key ) );
         return actuals.remove( key );
@@ -119,7 +119,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public void putAll(Map t)
+    public void putAll(Map<? extends K, ? extends V> t)
     {
         throw new RuntimeException( "Not yet implemented" );
     }
@@ -136,7 +136,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Set keySet()
+    public Set<K> keySet()
     {
         return actuals.keySet();
     }
@@ -144,7 +144,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Collection values()
+    public Collection<V> values()
     {
         return actuals.values();
     }
@@ -152,7 +152,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Set entrySet()
+    public Set<Map.Entry<K, V>> entrySet()
     {
         return Collections.unmodifiableSet(actuals.entrySet());
     }
@@ -165,7 +165,7 @@ public class COSDictionaryMap implements Map
         boolean retval = false;
         if( o instanceof COSDictionaryMap )
         {
-            COSDictionaryMap other = (COSDictionaryMap)o;
+            COSDictionaryMap<K,V> other = (COSDictionaryMap)o;
             retval = other.map.equals( this.map );
         }
         return retval;
@@ -195,9 +195,9 @@ public class COSDictionaryMap implements Map
      *
      * @return A proper COSDictionary
      */
-    public static COSDictionary convert( Map someMap )
+    public static COSDictionary convert( Map<?,?> someMap )
     {
-        Iterator iter = someMap.keySet().iterator();
+        Iterator<?> iter = someMap.keySet().iterator();
         COSDictionary dic = new COSDictionary();
         while( iter.hasNext() )
         {
@@ -216,12 +216,12 @@ public class COSDictionaryMap implements Map
      * @return A standard java map.
      * @throws IOException If there is an error during the conversion.
      */
-    public static COSDictionaryMap convertBasicTypesToMap( COSDictionary map ) throws IOException
+    public static COSDictionaryMap<String, Object> convertBasicTypesToMap( COSDictionary map ) throws IOException
     {
-        COSDictionaryMap retval = null;
+        COSDictionaryMap<String, Object> retval = null;
         if( map != null )
         {
-            Map actualMap = new HashMap();
+            Map<String, Object> actualMap = new HashMap<String, Object>();
             for( COSName key : map.keySet() )
             {
                 COSBase cosObj = map.getDictionaryObject( key );
@@ -252,7 +252,7 @@ public class COSDictionaryMap implements Map
                 }
                 actualMap.put( key.getName(), actualObject );
             }
-            retval = new COSDictionaryMap( actualMap, map );
+            retval = new COSDictionaryMap<String, Object>( actualMap, map );
         }
 
         return retval;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
index d71653f9a5..402ef603fa 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
@@ -41,523 +41,572 @@ import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.common.filespecification.PDFileSpecification;
 
 /**
- * A PDStream represents a stream in a PDF document.  Streams are tied to a single
- * PDF document.
- *
+ * A PDStream represents a stream in a PDF document. Streams are tied to a
+ * single PDF document.
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.17 $
  */
 public class PDStream implements COSObjectable
 {
-	private COSStream stream;
-
-	/**
-	 * This will create a new PDStream object.
-	 */
-	protected PDStream()
-	{
-		//should only be called by PDMemoryStream
-	}
-
-	/**
-	 * This will create a new PDStream object.
-	 *
-	 * @param document The document that the stream will be part of.
-	 */
-	public PDStream( PDDocument document )
-	{
-		stream = new COSStream( document.getDocument().getScratchFile() );
-	}
-
-	/**
-	 * Constructor.
-	 *
-	 * @param str The stream parameter.
-	 */
-	public PDStream( COSStream str )
-	{
-		stream = str;
-	}
-
-	/**
-	 * Constructor.  Reads all data from the input stream and embeds it into the
-	 * document, this will close the InputStream.
-	 *
-	 * @param doc The document that will hold the stream.
-	 * @param str The stream parameter.
-	 * @throws IOException If there is an error creating the stream in the document.
-	 */
-	public PDStream( PDDocument doc, InputStream str ) throws IOException
-	{
-		this( doc, str, false );
-	}
-
-	/**
-	 * Constructor.  Reads all data from the input stream and embeds it into the
-	 * document, this will close the InputStream.
-	 *
-	 * @param doc The document that will hold the stream.
-	 * @param str The stream parameter.
-	 * @param filtered True if the stream already has a filter applied.
-	 * @throws IOException If there is an error creating the stream in the document.
-	 */
-	public PDStream( PDDocument doc, InputStream str, boolean filtered ) throws IOException
-	{
-		OutputStream output = null;
-		try
-		{
-			stream = new COSStream( doc.getDocument().getScratchFile() );
-			if( filtered )
-			{
-				output = stream.createFilteredStream();
-			}
-			else
-			{
-				output = stream.createUnfilteredStream();
-			}
-			byte[] buffer = new byte[ 1024 ];
-			int amountRead = -1;
-			while( (amountRead = str.read(buffer)) != -1 )
-			{
-				output.write( buffer, 0, amountRead );
-			}
-		}
-		finally
-		{
-			if( output != null )
-			{
-				output.close();
-			}
-			if( str != null )
-			{
-				str.close();
-			}
-		}
-	}
-
-	/**
-	 * If there are not compression filters on the current stream then this
-	 * will add a compression filter, flate compression for example.
-	 */
-	public void addCompression()
-	{
-		List filters = getFilters();
-		if( filters == null )
-		{
-			filters = new ArrayList();
-			filters.add( COSName.FLATE_DECODE );
-			setFilters( filters );
-		}
-	}
-
-	/**
-	 * Create a pd stream from either a regular COSStream on a COSArray of cos streams.
-	 * @param base Either a COSStream or COSArray.
-	 * @return A PDStream or null if base is null.
-	 * @throws IOException If there is an error creating the PDStream.
-	 */
-	public static PDStream createFromCOS( COSBase base ) throws IOException
-	{
-		PDStream retval = null;
-		if( base instanceof COSStream )
-		{
-			retval = new PDStream( (COSStream)base );
-		}
-		else if( base instanceof COSArray )
-		{
-			if (((COSArray)base).size() > 0) {
-				retval = new PDStream( new COSStreamArray( (COSArray)base ) );
-			}
-		}
-		else
-		{
-			if( base != null )
-			{
-				throw new IOException( "Contents are unknown type:" + base.getClass().getName() );
-			}
-		}
-		return retval;
-	}
-
-
-	/**
-	 * Convert this standard java object to a COS object.
-	 *
-	 * @return The cos object that matches this Java object.
-	 */
-	public COSBase getCOSObject()
-	{
-		return stream;
-	}
-
-	/**
-	 * This will get a stream that can be written to.
-	 *
-	 * @return An output stream to write data to.
-	 *
-	 * @throws IOException If an IO error occurs during writing.
-	 */
-	public OutputStream createOutputStream() throws IOException
-	{
-		return stream.createUnfilteredStream();
-	}
-
-	/**
-	 * This will get a stream that can be read from.
-	 *
-	 * @return An input stream that can be read from.
-	 *
-	 * @throws IOException If an IO error occurs during reading.
-	 */
-	public InputStream createInputStream() throws IOException
-	{
-		return stream.getUnfilteredStream();
-	}
-
-	/**
-	 * This will get a stream with some filters applied but not others.  This is useful
-	 * when doing images, ie filters = [flate,dct], we want to remove flate but leave dct
-	 *
-	 * @param stopFilters A list of filters to stop decoding at.
-	 * @return A stream with decoded data.
-	 * @throws IOException If there is an error processing the stream.
-	 */
-	public InputStream getPartiallyFilteredStream( List stopFilters ) throws IOException
-	{
-		FilterManager manager = stream.getFilterManager();
-		InputStream is = stream.getFilteredStream();
-		ByteArrayOutputStream os = new ByteArrayOutputStream();
-		List filters = getFilters();
-		String nextFilter = null;
-		boolean done = false;
-		for( int i=0; i<filters.size() && !done; i++ )
-		{
-			os.reset();
-			nextFilter = (String)filters.get( i );
-			if( stopFilters.contains( nextFilter ) )
-			{
-				done = true;
-			}
-			else
-			{
-				Filter filter = manager.getFilter( COSName.getPDFName(nextFilter) );
-				filter.decode( is, os, stream, i );
-				is = new ByteArrayInputStream( os.toByteArray() );
-			}
-		}
-		return is;
-	}
-
-	/**
-	 * Get the cos stream associated with this object.
-	 *
-	 * @return The cos object that matches this Java object.
-	 */
-	public COSStream getStream()
-	{
-		return stream;
-	}
-
-	/**
-	 * This will get the length of the filtered/compressed stream.  This is readonly in the
-	 * PD Model and will be managed by this class.
-	 *
-	 * @return The length of the filtered stream.
-	 */
-	public int getLength()
-	{
-		return stream.getInt( "Length", 0 );
-	}
-
-	/**
-	 * This will get the list of filters that are associated with this stream.  Or
-	 * null if there are none.
-	 * @return A list of all encoding filters to apply to this stream.
-	 */
-	public List getFilters()
-	{
-		List retval = null;
-		COSBase filters = stream.getFilters();
-		if( filters instanceof COSName )
-		{
-			COSName name = (COSName)filters;
-			retval = new COSArrayList( name.getName(), name, stream, COSName.FILTER );
-		}
-		else if( filters instanceof COSArray )
-		{
-			retval = COSArrayList.convertCOSNameCOSArrayToList( (COSArray)filters );
-		}
-		return retval;
-	}
-
-	/**
-	 * This will set the filters that are part of this stream.
-	 *
-	 * @param filters The filters that are part of this stream.
-	 */
-	public void setFilters( List filters )
-	{
-		COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray( filters );
-		stream.setItem( COSName.FILTER, obj );
-	}
-
-	/**
-	 * Get the list of decode parameters.  Each entry in the list will refer to
-	 * an entry in the filters list.
-	 *
-	 * @return The list of decode parameters.
-	 *
-	 * @throws IOException if there is an error retrieving the parameters.
-	 */
-	public List getDecodeParms() throws IOException
-	{
-		List retval = null;
-
-		COSBase dp = stream.getDictionaryObject( COSName.DECODE_PARMS );
-		if( dp == null )
-		{
-			//See PDF Ref 1.5 implementation note 7, the DP is sometimes used instead.
-			dp = stream.getDictionaryObject( COSName.DP );
-		}
-		if( dp instanceof COSDictionary )
-		{
-			Map map = COSDictionaryMap.convertBasicTypesToMap( (COSDictionary)dp );
-			retval = new COSArrayList(map, dp, stream, COSName.DECODE_PARMS );
-		}
-		else if( dp instanceof COSArray )
-		{
-			COSArray array = (COSArray)dp;
-			List actuals = new ArrayList();
-			for( int i=0; i<array.size(); i++ )
-			{
-				actuals.add(
-						COSDictionaryMap.convertBasicTypesToMap(
-								(COSDictionary)array.getObject( i ) ) );
-			}
-			retval = new COSArrayList(actuals, array);
-		}
-
-		return retval;
-	}
-
-	/**
-	 * This will set the list of decode parameterss.
-	 *
-	 * @param decodeParams The list of decode parameterss.
-	 */
-	public void setDecodeParms( List decodeParams )
-	{
-		stream.setItem(
-				COSName.DECODE_PARMS, COSArrayList.converterToCOSArray( decodeParams ) );
-	}
-
-	/**
-	 * This will get the file specification for this stream.  This is only
-	 * required for external files.
-	 *
-	 * @return The file specification.
-	 *
-	 * @throws IOException If there is an error creating the file spec.
-	 */
-	public PDFileSpecification getFile() throws IOException
-	{
-		COSBase f = stream.getDictionaryObject( COSName.F );
-		PDFileSpecification retval = PDFileSpecification.createFS( f );
-		return retval;
-	}
-
-	/**
-	 * Set the file specification.
-	 * @param f The file specification.
-	 */
-	public void setFile( PDFileSpecification f )
-	{
-		stream.setItem( COSName.F, f );
-	}
-
-	/**
-	 * This will get the list of filters that are associated with this stream.  Or
-	 * null if there are none.
-	 * @return A list of all encoding filters to apply to this stream.
-	 */
-	public List getFileFilters()
-	{
-		List retval = null;
-		COSBase filters = stream.getDictionaryObject( COSName.F_FILTER );
-		if( filters instanceof COSName )
-		{
-			COSName name = (COSName)filters;
-			retval = new COSArrayList( name.getName(), name, stream, COSName.F_FILTER );
-		}
-		else if( filters instanceof COSArray )
-		{
-			retval = COSArrayList.convertCOSNameCOSArrayToList( (COSArray)filters );
-		}
-		return retval;
-	}
-
-	/**
-	 * This will set the filters that are part of this stream.
-	 *
-	 * @param filters The filters that are part of this stream.
-	 */
-	public void setFileFilters( List filters )
-	{
-		COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray( filters );
-		stream.setItem( COSName.F_FILTER, obj );
-	}
-
-	/**
-	 * Get the list of decode parameters.  Each entry in the list will refer to
-	 * an entry in the filters list.
-	 *
-	 * @return The list of decode parameters.
-	 *
-	 * @throws IOException if there is an error retrieving the parameters.
-	 */
-	public List getFileDecodeParams() throws IOException
-	{
-		List retval = null;
-
-		COSBase dp = stream.getDictionaryObject( COSName.F_DECODE_PARMS );
-		if( dp instanceof COSDictionary )
-		{
-			Map map = COSDictionaryMap.convertBasicTypesToMap( (COSDictionary)dp );
-			retval = new COSArrayList(map, dp, stream, COSName.F_DECODE_PARMS );
-		}
-		else if( dp instanceof COSArray )
-		{
-			COSArray array = (COSArray)dp;
-			List actuals = new ArrayList();
-			for( int i=0; i<array.size(); i++ )
-			{
-				actuals.add(
-						COSDictionaryMap.convertBasicTypesToMap(
-								(COSDictionary)array.getObject( i ) ) );
-			}
-			retval = new COSArrayList(actuals, array);
-		}
-
-		return retval;
-	}
-
-	/**
-	 * This will set the list of decode params.
-	 *
-	 * @param decodeParams The list of decode params.
-	 */
-	public void setFileDecodeParams( List decodeParams )
-	{
-		stream.setItem(
-				"FDecodeParams", COSArrayList.converterToCOSArray( decodeParams ) );
-	}
-
-	/**
-	 * This will copy the stream into a byte array.
-	 *
-	 * @return The byte array of the filteredStream
-	 * @throws IOException When getFilteredStream did not work
-	 */
-	public byte[] getByteArray() throws IOException
-	{
-		ByteArrayOutputStream output = new ByteArrayOutputStream();
-		byte[] buf = new byte[1024];
-		InputStream is = null;
-		try
-		{
-			is = createInputStream();
-			int amountRead = -1;
-			while( (amountRead = is.read( buf )) != -1)
-			{
-				output.write( buf, 0, amountRead );
-			}
-		}
-		finally
-		{
-			if( is != null )
-			{
-				is.close();
-			}
-		}
-		return output.toByteArray();
-	}
-
-	/**
-	 * A convenience method to get this stream as a string.  Uses
-	 * the default system encoding.
-	 *
-	 * @return a String representation of this (input) stream.
-	 *
-	 * @throws IOException if there is an error while converting the stream
-	 *                     to a string.
-	 */
-	public String getInputStreamAsString() throws IOException
-	{
-		byte[] bStream = getByteArray();
-		return new String(bStream, "ISO-8859-1");
-	}
-
-	/**
-	 * Get the metadata that is part of the document catalog.  This will
-	 * return null if there is no meta data for this object.
-	 *
-	 * @return The metadata for this object.
-	 * @throws IllegalStateException if the value of the metadata entry is different from a stream or null
-	 */
-	public PDMetadata getMetadata ()
-	{
-		PDMetadata retval = null;
-		COSBase mdStream = stream.getDictionaryObject( COSName.METADATA );
-		if( mdStream != null )
-		{
-			if (mdStream instanceof COSStream) 
-			{
-				retval = new PDMetadata( (COSStream)mdStream );
-			}
-			else if (mdStream instanceof COSNull) 
-			{
-				// null is authorized
-			}
-			else
-			{
-				throw new IllegalStateException("Expected a COSStream but was a " + mdStream.getClass().getSimpleName());
-			}
-		}
-		return retval;
-	}
-
-	/**
-	 * Set the metadata for this object.  This can be null.
-	 *
-	 * @param meta The meta data for this object.
-	 */
-	public void setMetadata( PDMetadata meta )
-	{
-		stream.setItem( COSName.METADATA, meta );
-	}
-
-	/**
-	 * Get the decoded stream length.
-	 *
-	 * @since Apache PDFBox 1.1.0
-	 * @see <a href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
-	 * @return the decoded stream length
-	 */
-	public int getDecodedStreamLength()
-	{
-		return this.stream.getInt(COSName.DL);
-	}
-
-	/**
-	 * Set the decoded stream length.
-	 *
-	 * @since Apache PDFBox 1.1.0
-	 * @see <a href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
-	 * @param decodedStreamLength the decoded stream length
-	 */
-	public void setDecodedStreamLength(int decodedStreamLength)
-	{
-		this.stream.setInt(COSName.DL, decodedStreamLength);
-	}
+    private COSStream stream;
+
+    /**
+     * This will create a new PDStream object.
+     */
+    protected PDStream()
+    {
+        // should only be called by PDMemoryStream
+    }
+
+    /**
+     * This will create a new PDStream object.
+     * 
+     * @param document
+     *            The document that the stream will be part of.
+     */
+    public PDStream(PDDocument document)
+    {
+        stream = new COSStream(document.getDocument().getScratchFile());
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param str
+     *            The stream parameter.
+     */
+    public PDStream(COSStream str)
+    {
+        stream = str;
+    }
+
+    /**
+     * Constructor. Reads all data from the input stream and embeds it into the
+     * document, this will close the InputStream.
+     * 
+     * @param doc
+     *            The document that will hold the stream.
+     * @param str
+     *            The stream parameter.
+     * @throws IOException
+     *             If there is an error creating the stream in the document.
+     */
+    public PDStream(PDDocument doc, InputStream str) throws IOException
+    {
+        this(doc, str, false);
+    }
+
+    /**
+     * Constructor. Reads all data from the input stream and embeds it into the
+     * document, this will close the InputStream.
+     * 
+     * @param doc
+     *            The document that will hold the stream.
+     * @param str
+     *            The stream parameter.
+     * @param filtered
+     *            True if the stream already has a filter applied.
+     * @throws IOException
+     *             If there is an error creating the stream in the document.
+     */
+    public PDStream(PDDocument doc, InputStream str, boolean filtered)
+            throws IOException
+    {
+        OutputStream output = null;
+        try
+        {
+            stream = new COSStream(doc.getDocument().getScratchFile());
+            if (filtered)
+            {
+                output = stream.createFilteredStream();
+            } 
+            else
+            {
+                output = stream.createUnfilteredStream();
+            }
+            byte[] buffer = new byte[1024];
+            int amountRead = -1;
+            while ((amountRead = str.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, amountRead);
+            }
+        } 
+        finally
+        {
+            if (output != null)
+            {
+                output.close();
+            }
+            if (str != null)
+            {
+                str.close();
+            }
+        }
+    }
+
+    /**
+     * If there are not compression filters on the current stream then this will
+     * add a compression filter, flate compression for example.
+     */
+    public void addCompression()
+    {
+        List<COSName> filters = getFilters();
+        if (filters == null)
+        {
+            filters = new ArrayList<COSName>();
+            filters.add(COSName.FLATE_DECODE);
+            setFilters(filters);
+        }
+    }
+
+    /**
+     * Create a pd stream from either a regular COSStream on a COSArray of cos
+     * streams.
+     * 
+     * @param base
+     *            Either a COSStream or COSArray.
+     * @return A PDStream or null if base is null.
+     * @throws IOException
+     *             If there is an error creating the PDStream.
+     */
+    public static PDStream createFromCOS(COSBase base) throws IOException
+    {
+        PDStream retval = null;
+        if (base instanceof COSStream)
+        {
+            retval = new PDStream((COSStream) base);
+        } 
+        else if (base instanceof COSArray)
+        {
+            if (((COSArray) base).size() > 0)
+            {
+                retval = new PDStream(new COSStreamArray((COSArray) base));
+            }
+        } 
+        else
+        {
+            if (base != null)
+            {
+                throw new IOException("Contents are unknown type:"
+                        + base.getClass().getName());
+            }
+        }
+        return retval;
+    }
+
+    /**
+     * Convert this standard java object to a COS object.
+     * 
+     * @return The cos object that matches this Java object.
+     */
+    public COSBase getCOSObject()
+    {
+        return stream;
+    }
+
+    /**
+     * This will get a stream that can be written to.
+     * 
+     * @return An output stream to write data to.
+     * 
+     * @throws IOException
+     *             If an IO error occurs during writing.
+     */
+    public OutputStream createOutputStream() throws IOException
+    {
+        return stream.createUnfilteredStream();
+    }
+
+    /**
+     * This will get a stream that can be read from.
+     * 
+     * @return An input stream that can be read from.
+     * 
+     * @throws IOException
+     *             If an IO error occurs during reading.
+     */
+    public InputStream createInputStream() throws IOException
+    {
+        return stream.getUnfilteredStream();
+    }
+
+    /**
+     * This will get a stream with some filters applied but not others. This is
+     * useful when doing images, ie filters = [flate,dct], we want to remove
+     * flate but leave dct
+     * 
+     * @param stopFilters
+     *            A list of filters to stop decoding at.
+     * @return A stream with decoded data.
+     * @throws IOException
+     *             If there is an error processing the stream.
+     */
+    public InputStream getPartiallyFilteredStream(List<String> stopFilters)
+            throws IOException
+    {
+        FilterManager manager = stream.getFilterManager();
+        InputStream is = stream.getFilteredStream();
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        List<COSName> filters = getFilters();
+        COSName nextFilter = null;
+        boolean done = false;
+        for (int i = 0; i < filters.size() && !done; i++)
+        {
+            os.reset();
+            nextFilter = filters.get(i);
+            if (stopFilters.contains(nextFilter.getName()))
+            {
+                done = true;
+            } 
+            else
+            {
+                Filter filter = manager.getFilter(nextFilter);
+                filter.decode(is, os, stream, i);
+                is = new ByteArrayInputStream(os.toByteArray());
+            }
+        }
+        return is;
+    }
+
+    /**
+     * Get the cos stream associated with this object.
+     * 
+     * @return The cos object that matches this Java object.
+     */
+    public COSStream getStream()
+    {
+        return stream;
+    }
+
+    /**
+     * This will get the length of the filtered/compressed stream. This is
+     * readonly in the PD Model and will be managed by this class.
+     * 
+     * @return The length of the filtered stream.
+     */
+    public int getLength()
+    {
+        return stream.getInt(COSName.LENGTH, 0);
+    }
+
+    /**
+     * This will get the list of filters that are associated with this stream.
+     * Or null if there are none.
+     * 
+     * @return A list of all encoding filters to apply to this stream.
+     */
+    public List<COSName> getFilters()
+    {
+        List<COSName> retval = null;
+        COSBase filters = stream.getFilters();
+        if (filters instanceof COSName)
+        {
+            COSName name = (COSName) filters;
+            retval = new COSArrayList<COSName>(name, name, stream,
+                    COSName.FILTER);
+        } 
+        else if (filters instanceof COSArray)
+        {
+            retval = (List<COSName>) ((COSArray) filters).toList();
+        }
+        return retval;
+    }
+
+    /**
+     * This will set the filters that are part of this stream.
+     * 
+     * @param filters
+     *            The filters that are part of this stream.
+     */
+    public void setFilters(List<COSName> filters)
+    {
+        COSBase obj = COSArrayList.converterToCOSArray(filters);
+        stream.setItem(COSName.FILTER, obj);
+    }
+
+    /**
+     * Get the list of decode parameters. Each entry in the list will refer to
+     * an entry in the filters list.
+     * 
+     * @return The list of decode parameters.
+     * 
+     * @throws IOException
+     *             if there is an error retrieving the parameters.
+     */
+    public List<Object> getDecodeParms() throws IOException
+    {
+        List<Object> retval = null;
+
+        COSBase dp = stream.getDictionaryObject(COSName.DECODE_PARMS);
+        if (dp == null)
+        {
+            // See PDF Ref 1.5 implementation note 7, the DP is sometimes used
+            // instead.
+            dp = stream.getDictionaryObject(COSName.DP);
+        }
+        if (dp instanceof COSDictionary)
+        {
+            Map<?, ?> map = COSDictionaryMap
+                    .convertBasicTypesToMap((COSDictionary) dp);
+            retval = new COSArrayList<Object>(map, dp, stream,
+                    COSName.DECODE_PARMS);
+        } 
+        else if (dp instanceof COSArray)
+        {
+            COSArray array = (COSArray) dp;
+            List<Object> actuals = new ArrayList<Object>();
+            for (int i = 0; i < array.size(); i++)
+            {
+                actuals.add(COSDictionaryMap
+                        .convertBasicTypesToMap((COSDictionary) array
+                                .getObject(i)));
+            }
+            retval = new COSArrayList<Object>(actuals, array);
+        }
+
+        return retval;
+    }
+
+    /**
+     * This will set the list of decode parameterss.
+     * 
+     * @param decodeParams
+     *            The list of decode parameterss.
+     */
+    public void setDecodeParms(List<?> decodeParams)
+    {
+        stream.setItem(COSName.DECODE_PARMS,
+                COSArrayList.converterToCOSArray(decodeParams));
+    }
+
+    /**
+     * This will get the file specification for this stream. This is only
+     * required for external files.
+     * 
+     * @return The file specification.
+     * 
+     * @throws IOException
+     *             If there is an error creating the file spec.
+     */
+    public PDFileSpecification getFile() throws IOException
+    {
+        COSBase f = stream.getDictionaryObject(COSName.F);
+        PDFileSpecification retval = PDFileSpecification.createFS(f);
+        return retval;
+    }
+
+    /**
+     * Set the file specification.
+     * 
+     * @param f
+     *            The file specification.
+     */
+    public void setFile(PDFileSpecification f)
+    {
+        stream.setItem(COSName.F, f);
+    }
+
+    /**
+     * This will get the list of filters that are associated with this stream.
+     * Or null if there are none.
+     * 
+     * @return A list of all encoding filters to apply to this stream.
+     */
+    public List<String> getFileFilters()
+    {
+        List<String> retval = null;
+        COSBase filters = stream.getDictionaryObject(COSName.F_FILTER);
+        if (filters instanceof COSName)
+        {
+            COSName name = (COSName) filters;
+            retval = new COSArrayList<String>(name.getName(), name, stream,
+                    COSName.F_FILTER);
+        } 
+        else if (filters instanceof COSArray)
+        {
+            retval = COSArrayList
+                    .convertCOSNameCOSArrayToList((COSArray) filters);
+        }
+        return retval;
+    }
+
+    /**
+     * This will set the filters that are part of this stream.
+     * 
+     * @param filters
+     *            The filters that are part of this stream.
+     */
+    public void setFileFilters(List<String> filters)
+    {
+        COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);
+        stream.setItem(COSName.F_FILTER, obj);
+    }
+
+    /**
+     * Get the list of decode parameters. Each entry in the list will refer to
+     * an entry in the filters list.
+     * 
+     * @return The list of decode parameters.
+     * 
+     * @throws IOException
+     *             if there is an error retrieving the parameters.
+     */
+    public List<Object> getFileDecodeParams() throws IOException
+    {
+        List<Object> retval = null;
+
+        COSBase dp = stream.getDictionaryObject(COSName.F_DECODE_PARMS);
+        if (dp instanceof COSDictionary)
+        {
+            Map<?, ?> map = COSDictionaryMap
+                    .convertBasicTypesToMap((COSDictionary) dp);
+            retval = new COSArrayList<Object>(map, dp, stream,
+                    COSName.F_DECODE_PARMS);
+        } 
+        else if (dp instanceof COSArray)
+        {
+            COSArray array = (COSArray) dp;
+            List<Object> actuals = new ArrayList<Object>();
+            for (int i = 0; i < array.size(); i++)
+            {
+                actuals.add(COSDictionaryMap
+                        .convertBasicTypesToMap((COSDictionary) array
+                                .getObject(i)));
+            }
+            retval = new COSArrayList<Object>(actuals, array);
+        }
+
+        return retval;
+    }
+
+    /**
+     * This will set the list of decode params.
+     * 
+     * @param decodeParams
+     *            The list of decode params.
+     */
+    public void setFileDecodeParams(List<?> decodeParams)
+    {
+        stream.setItem("FDecodeParams",
+                COSArrayList.converterToCOSArray(decodeParams));
+    }
+
+    /**
+     * This will copy the stream into a byte array.
+     * 
+     * @return The byte array of the filteredStream
+     * @throws IOException
+     *             When getFilteredStream did not work
+     */
+    public byte[] getByteArray() throws IOException
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        byte[] buf = new byte[1024];
+        InputStream is = null;
+        try
+        {
+            is = createInputStream();
+            int amountRead = -1;
+            while ((amountRead = is.read(buf)) != -1)
+            {
+                output.write(buf, 0, amountRead);
+            }
+        } 
+        finally
+        {
+            if (is != null)
+            {
+                is.close();
+            }
+        }
+        return output.toByteArray();
+    }
+
+    /**
+     * A convenience method to get this stream as a string. Uses the default
+     * system encoding.
+     * 
+     * @return a String representation of this (input) stream.
+     * 
+     * @throws IOException
+     *             if there is an error while converting the stream to a string.
+     */
+    public String getInputStreamAsString() throws IOException
+    {
+        byte[] bStream = getByteArray();
+        return new String(bStream, "ISO-8859-1");
+    }
+
+    /**
+     * Get the metadata that is part of the document catalog. This will return
+     * null if there is no meta data for this object.
+     * 
+     * @return The metadata for this object.
+     * @throws IllegalStateException
+     *             if the value of the metadata entry is different from a stream
+     *             or null
+     */
+    public PDMetadata getMetadata()
+    {
+        PDMetadata retval = null;
+        COSBase mdStream = stream.getDictionaryObject(COSName.METADATA);
+        if (mdStream != null)
+        {
+            if (mdStream instanceof COSStream)
+            {
+                retval = new PDMetadata((COSStream) mdStream);
+            } 
+            else if (mdStream instanceof COSNull)
+            {
+                // null is authorized
+            } 
+            else
+            {
+                throw new IllegalStateException(
+                        "Expected a COSStream but was a "
+                                + mdStream.getClass().getSimpleName());
+            }
+        }
+        return retval;
+    }
+
+    /**
+     * Set the metadata for this object. This can be null.
+     * 
+     * @param meta
+     *            The meta data for this object.
+     */
+    public void setMetadata(PDMetadata meta)
+    {
+        stream.setItem(COSName.METADATA, meta);
+    }
+
+    /**
+     * Get the decoded stream length.
+     * 
+     * @since Apache PDFBox 1.1.0
+     * @see <a
+     *      href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
+     * @return the decoded stream length
+     */
+    public int getDecodedStreamLength()
+    {
+        return this.stream.getInt(COSName.DL);
+    }
+
+    /**
+     * Set the decoded stream length.
+     * 
+     * @since Apache PDFBox 1.1.0
+     * @see <a
+     *      href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
+     * @param decodedStreamLength
+     *            the decoded stream length
+     */
+    public void setDecodedStreamLength(int decodedStreamLength)
+    {
+        this.stream.setInt(COSName.DL, decodedStreamLength);
+    }
 
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
index 2b7fd644bc..c36ce0bc7b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
@@ -37,9 +37,9 @@ import org.apache.pdfbox.pdmodel.documentinterchange.markedcontent.PDMarkedConte
  */
 public class PDStructureElement extends PDStructureNode
 {
+    
     public static final String TYPE = "StructElem";
 
-
     /**
      * Constructor with required values.
      *
@@ -490,7 +490,7 @@ public class PDStructureElement extends PDStructureNode
     }
 
     /**
-     * Increments th revision number
+     * Increments th revision number.
      */
     public void incrementRevisionNumber()
     {
@@ -606,15 +606,14 @@ public class PDStructureElement extends PDStructureNode
     public String getStandardStructureType()
     {
         String type = this.getStructureType();
-        String mappedType;
-        while (true)
+        Map<String,Object> roleMap = getRoleMap();
+        if (roleMap.containsKey(type))
         {
-            mappedType = this.getRoleMap().get(type);
-            if ((mappedType == null) || type.equals(mappedType))
+            Object mappedValue = getRoleMap().get(type);
+            if (mappedValue instanceof String)
             {
-                break;
+                type = (String)mappedValue;
             }
-            type = mappedType;
         }
         return type;
     }
@@ -742,7 +741,7 @@ public class PDStructureElement extends PDStructureNode
      * 
      * @return the role map
      */
-    private Map<String, String> getRoleMap()
+    private Map<String, Object> getRoleMap()
     {
         PDStructureTreeRoot root = this.getStructureTreeRoot();
         if (root != null)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
index 6e67799e2d..762e04e019 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
@@ -100,8 +100,7 @@ public class PDStructureTreeRoot extends PDStructureNode
      * 
      * @return the role map
      */
-    @SuppressWarnings("unchecked")
-    public Map<String, String> getRoleMap()
+    public Map<String, Object> getRoleMap()
     {
         COSBase rm = this.getCOSDictionary().getDictionaryObject(COSName.ROLE_MAP);
         if (rm instanceof COSDictionary)
@@ -115,7 +114,7 @@ public class PDStructureTreeRoot extends PDStructureNode
                 e.printStackTrace();
             }
         }
-        return new Hashtable<String, String>();
+        return new Hashtable<String, Object>();
     }
 
     /**
