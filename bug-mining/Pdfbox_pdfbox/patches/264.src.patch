diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
index aab4b4c4c3..0ad0aa44c8 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
@@ -16,8 +16,10 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.xobject;
 
+import java.awt.Transparency;
 import java.awt.image.BufferedImage;
 import java.awt.image.DataBufferByte;
+import java.awt.image.IndexColorModel;
 import java.awt.image.WritableRaster;
 import java.io.IOException;
 import java.io.InputStream;
@@ -159,7 +161,26 @@ public class PDCcitt extends PDXObjectImage
             //So a safe but slower approach was taken.
             invertBitmap(bufferData);
         }
-        return image;
+        
+        /*
+         * If we have an image mask we need to add an alpha channel to the data
+         */
+        if(hasMask())
+        {
+	        byte map[] = new byte[] {(byte)0x00, (byte)0xff};
+	    	IndexColorModel  cm = new IndexColorModel(1, map.length, map, map, map, Transparency.OPAQUE);
+	    	 raster = cm.createCompatibleWritableRaster( image.getWidth(), image.getHeight() );
+	         buffer = (DataBufferByte)raster.getDataBuffer();
+	        bufferData = buffer.getData();
+	
+	        byte array[] = ((DataBufferByte)image.getData().getDataBuffer()).getData();
+	        System.arraycopy( array, 0,bufferData, 0,
+	                (array.length<bufferData.length?array.length: bufferData.length) );
+	        BufferedImage indexed = new BufferedImage(cm, raster, false, null);
+	        image = indexed;
+        }
+        
+        return applyMasks(image);
     }
 
     private void invertBitmap(byte[] bufferData)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDJpeg.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDJpeg.java
index 193f2142ca..0b50a261d8 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDJpeg.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDJpeg.java
@@ -43,7 +43,6 @@ import javax.imageio.ImageReader;
 import javax.imageio.metadata.IIOMetadata;
 import javax.imageio.stream.ImageInputStream;
 
-import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 
@@ -278,32 +277,8 @@ public class PDJpeg extends PDXObjectImage
             ByteArrayInputStream bai = new ByteArrayInputStream(newImage);
             bi = ImageIO.read(bai);
         }
-
         // If there is a 'soft mask' or 'mask' image then we use that as a transparency mask.
-        PDXObjectImage maskImage = getSMaskImage();
-        if (maskImage != null)
-        {
-            CompositeImage compositeImage = new CompositeImage(bi, maskImage.getRGBImage());
-            BufferedImage rgbImage = compositeImage.createMaskedImage(maskImage.getDecode());
-            image = rgbImage;
-        }
-        else
-        {
-            COSBase mask = getMask();
-            if (mask != null && mask instanceof COSDictionary)
-            {
-            	maskImage = (PDXObjectImage)PDXObject.createXObject(mask);
-                CompositeImage compositeImage = new CompositeImage(bi, maskImage.getRGBImage());
-                BufferedImage rgbImage = compositeImage.createStencilMaskedImage(maskImage.getDecode());
-                image = rgbImage;
-            }	
-        }
-        if (image == null)
-        {
-            // But if there is no soft mask, use the unaltered image.
-            image = bi;
-        }
-        return image;
+        return applyMasks(bi);   
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
index 2c52af6768..4dbc04d97c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
@@ -17,7 +17,6 @@
 package org.apache.pdfbox.pdmodel.graphics.xobject;
 
 import java.awt.AlphaComposite;
-import java.awt.Color;
 import java.awt.Graphics2D;
 import java.awt.Transparency;
 import java.awt.color.ColorSpace;
@@ -352,47 +351,8 @@ public class PDPixelMap extends PDXObjectImage
             System.arraycopy( array, 0,bufferData, 0,
                     (array.length<bufferData.length?array.length: bufferData.length) );
             image = new BufferedImage(cm, raster, false, null);
-
-            // If there is a 'soft mask' image then we use that as a transparency mask.
-            PDXObjectImage smask = getSMaskImage();
-            if (smask != null)
-            {
-                BufferedImage smaskBI = smask.getRGBImage();
-
-                COSArray decodeArray = smask.getDecode();
-
-                CompositeImage compositeImage = new CompositeImage(image, smaskBI);
-                BufferedImage rgbImage = compositeImage.createMaskedImage(decodeArray);
-
-                return rgbImage;
-            }
-            else if (getImageMask())
-            {
-                BufferedImage stencilMask = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
-                Graphics2D graphics = (Graphics2D)stencilMask.getGraphics();
-                if (getStencilColor() != null)
-                {
-                    graphics.setColor(getStencilColor().getJavaColor());
-                }
-                else
-                {
-                    // this might happen when using ExractImages, see PDFBOX-1145
-                    LOG.debug("no stencil color for PixelMap found, using Color.BLACK instead.");
-                    graphics.setColor(Color.BLACK);
-                }
-                
-                graphics.fillRect(0, 0, width, height);
-                // assume default values ([0,1]) for the DecodeArray
-                // TODO DecodeArray == [1,0]
-                graphics.setComposite(AlphaComposite.DstIn);
-                graphics.drawImage(image, null, 0, 0);
-                return stencilMask;
-            }
-            else
-            {
-                // if there is no mask, use the unaltered image.
-                return image;
-            }
+           
+            return applyMasks(image);  
         }
         catch (Exception exception)
         {
@@ -402,8 +362,10 @@ public class PDPixelMap extends PDXObjectImage
             return null;
         }
     }
+    
+ 
 
-    /**
+	/**
      * Writes the image as .png.
      *
      * {@inheritDoc}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java
index f903b8c758..29a9b448e6 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDXObjectImage.java
@@ -16,6 +16,9 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.xobject;
 
+import java.awt.AlphaComposite;
+import java.awt.Color;
+import java.awt.Graphics2D;
 import java.awt.image.BufferedImage;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -117,6 +120,76 @@ public abstract class PDXObjectImage extends PDXObject
             return (PDXObjectImage)PDXObject.createXObject(smask);
         }
     }
+    
+    public BufferedImage applyMasks(BufferedImage baseImage) throws IOException
+    {
+    	if (getImageMask())
+    	{
+    		return imageMask(baseImage);
+    	}
+    	if(getMask() != null)
+    	{
+    		return mask(baseImage);
+    	}
+    	PDXObjectImage smask = getSMaskImage();
+    	if(smask != null)
+    	{
+    		BufferedImage smaskBI = smask.getRGBImage();
+    		COSArray decodeArray = smask.getDecode();
+    		CompositeImage compositeImage = new CompositeImage(baseImage, smaskBI);
+    		BufferedImage rgbImage = compositeImage.createMaskedImage(decodeArray);
+        	return rgbImage;
+    	}
+    	return baseImage;
+    }
+    
+    public boolean hasMask() throws IOException
+    {
+    	return getImageMask() || getMask() != null || getSMaskImage() != null;
+    }
+    
+    
+    public BufferedImage imageMask(BufferedImage baseImage) throws IOException 
+    {
+    	BufferedImage stencilMask = new BufferedImage(baseImage.getWidth(), baseImage.getHeight(), BufferedImage.TYPE_INT_ARGB);
+        Graphics2D graphics = (Graphics2D)stencilMask.getGraphics();
+        if (getStencilColor() != null)
+        {
+            graphics.setColor(getStencilColor().getJavaColor());
+        }
+        else
+        {
+            // this might happen when using ExractImages, see PDFBOX-1145
+            LOG.debug("no stencil color for PixelMap found, using Color.BLACK instead.");
+            graphics.setColor(Color.BLACK);
+        }
+        
+        graphics.fillRect(0, 0, baseImage.getWidth(), baseImage.getHeight());
+        // assume default values ([0,1]) for the DecodeArray
+        // TODO DecodeArray == [1,0]
+        graphics.setComposite(AlphaComposite.DstIn);
+        graphics.drawImage(baseImage, null, 0, 0);
+        return stencilMask;
+    }
+    
+    public BufferedImage mask(BufferedImage baseImage) 
+    	throws IOException
+    {
+    	PDXObjectImage maskImageRef = (PDXObjectImage)PDXObject.createXObject(getMask());
+    	BufferedImage maskImage = maskImageRef.getRGBImage();
+   	 	if(maskImage == null)
+   	 	{
+	   		 LOG.warn("masking getRGBImage returned NULL");
+	   		 return baseImage;
+   	 	}
+   	 
+	   	 BufferedImage newImage = new BufferedImage( maskImage.getWidth(), maskImage.getHeight(), BufferedImage.TYPE_INT_ARGB);
+	   	 Graphics2D graphics = (Graphics2D)newImage.getGraphics();
+	   	 graphics.drawImage(baseImage, 0, 0, maskImage.getWidth(), maskImage.getHeight(), 0, 0, baseImage.getWidth(), baseImage.getHeight(), null);   
+	   	 graphics.setComposite(AlphaComposite.DstIn);
+	   	 graphics.drawImage(maskImage, null, 0, 0);
+	   	 return newImage;
+    }
 
     /**
      * Writes the Image to out.
