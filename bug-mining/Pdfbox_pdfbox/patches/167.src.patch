diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecodeFilter.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecodeFilter.java
index 379dfd402f..0665341a25 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecodeFilter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/CCITTFaxDecodeFilter.java
@@ -16,7 +16,6 @@
  */
 package org.apache.pdfbox.filter;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -27,6 +26,9 @@ import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.io.IOUtils;
+import org.apache.pdfbox.io.ccitt.CCITTFaxG31DDecodeInputStream;
+import org.apache.pdfbox.io.ccitt.FillOrderChangeInputStream;
 
 /**
  * This is a filter for the CCITTFax Decoder.
@@ -53,10 +55,10 @@ public class CCITTFaxDecodeFilter implements Filter
     /**
      * {@inheritDoc}
      */
-    public void decode(InputStream compressedData, OutputStream result, COSDictionary options, int filterIndex) 
+    public void decode(InputStream compressedData, OutputStream result, COSDictionary options, int filterIndex)
     throws IOException
     {
-        
+
         COSBase decodeP = options.getDictionaryObject(COSName.DECODE_PARMS, COSName.DP);
         COSDictionary decodeParms = null;
         if (decodeP instanceof COSDictionary)
@@ -69,64 +71,67 @@ public class CCITTFaxDecodeFilter implements Filter
         }
         int length = options.getInt(COSName.LENGTH, -1);
         byte[] compressed = null;
-        if (length != -1) 
+        if (length != -1)
         {
             compressed = new byte[length];
-            compressedData.read(compressed, 0, length);
+            long written = IOUtils.populateBuffer(compressedData, compressed);
+            if (written != compressed.length)
+            {
+                log.warn("Buffer for compressed data did not match the length"
+                        + " of the actual compressed data");
+            }
         }
         else
         {
             // inline images don't provide the length of the stream so that
             // we have to read until the end of the stream to find out the length
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            // the streams inline images are stored in are mostly small ones 
-            int tempBufferlength = 512;
-            byte[] tempBuffer = new byte[tempBufferlength]; 
-            int bytesRead = 0;
-            while ( (bytesRead = compressedData.read(tempBuffer, 0, tempBufferlength)) != -1) 
-            {
-                baos.write(tempBuffer, 0, bytesRead);
-            }
-            compressed = baos.toByteArray();
+            // the streams inline images are stored in are mostly small ones
+            compressed = IOUtils.toByteArray(compressedData);
         }
         int cols = decodeParms.getInt(COSName.COLUMNS, 1728);
         int rows = decodeParms.getInt(COSName.ROWS, 0);
-        int height = options.getInt(COSName.HEIGHT, COSName.H, 0); 
+        int height = options.getInt(COSName.HEIGHT, COSName.H, 0);
         if (rows > 0 && height > 0)
         {
             // ensure that rows doesn't contain implausible data, see PDFBOX-771
             rows = Math.min(rows, height);
         }
-        else 
+        else
         {
             // at least one of the values has to have a valid value
             rows = Math.max(rows, height);
         }
         int k = decodeParms.getInt(COSName.K, 0);
         int arraySize = (cols + 7) / 8 * rows;
-        byte[] decompressed = new byte[arraySize];
         TIFFFaxDecoder faxDecoder = new TIFFFaxDecoder(1, cols, rows);
         // TODO possible options??
         long tiffOptions = 0;
         if (k == 0)
         {
-           faxDecoder.decode1D(decompressed, compressed, 0, rows);
+            InputStream in = new CCITTFaxG31DDecodeInputStream(
+                    new java.io.ByteArrayInputStream(compressed), cols);
+            in = new FillOrderChangeInputStream(in); //Decorate to change fill order
+            IOUtils.copy(in, result);
+            in.close();
         }
         else if (k > 0)
         {
-           faxDecoder.decode2D(decompressed, compressed, 0, rows, tiffOptions);
+            byte[] decompressed = new byte[arraySize];
+            faxDecoder.decode2D(decompressed, compressed, 0, rows, tiffOptions);
+            result.write(decompressed);
         }
         else if (k < 0)
         {
-           faxDecoder.decodeT6(decompressed, compressed, 0, rows, tiffOptions);
+            byte[] decompressed = new byte[arraySize];
+            faxDecoder.decodeT6(decompressed, compressed, 0, rows, tiffOptions);
+            result.write(decompressed);
         }
-        result.write(decompressed);
     }
 
     /**
      * {@inheritDoc}
      */
-    public void encode(InputStream rawData, OutputStream result, COSDictionary options, int filterIndex ) 
+    public void encode(InputStream rawData, OutputStream result, COSDictionary options, int filterIndex )
         throws IOException
     {
         log.warn("CCITTFaxDecode.encode is not implemented yet, skipping this stream.");
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/IOUtils.java b/pdfbox/src/main/java/org/apache/pdfbox/io/IOUtils.java
new file mode 100644
index 0000000000..f8a0308e1e
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/IOUtils.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * This class contains various I/O-related methods.
+ * @version $Revision$
+ */
+public class IOUtils
+{
+
+    //TODO PDFBox should really use Apache Commons IO.
+
+    private IOUtils()
+    {
+        //Utility class. Don't instantiate.
+    }
+
+    /**
+     * Reads the input stream and returns its contents as a byte array.
+     * @param in the input stream to read from.
+     * @return the byte array
+     * @throws IOException if an I/O error occurs
+     */
+    public static byte[] toByteArray(InputStream in) throws IOException
+    {
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        copy(in, baout);
+        return baout.toByteArray();
+    }
+
+    /**
+     * Copies all the contents from the given input stream to the given output stream.
+     * @param input the input stream
+     * @param output the output stream
+     * @return the number of bytes that have been copied
+     * @throws IOException if an I/O error occurs
+     */
+    public static long copy(InputStream input, OutputStream output) throws IOException
+    {
+        byte[] buffer = new byte[4096];
+        long count = 0;
+        int n = 0;
+        while (-1 != (n = input.read(buffer)))
+        {
+            output.write(buffer, 0, n);
+            count += n;
+        }
+        return count;
+    }
+
+    /**
+     * Populates the given buffer with data read from the input stream. If the data doesn't
+     * fit the buffer, only the data that fits in the buffer is read. If the data is less than
+     * fits in the buffer, the buffer is not completely filled.
+     * @param in the input stream to read from
+     * @param buffer the buffer to fill
+     * @return the number of bytes written to the buffer
+     * @throws IOException if an I/O error occurs
+     */
+    public static long populateBuffer(InputStream in, byte[] buffer) throws IOException
+    {
+        int remaining = buffer.length;
+        while (remaining > 0)
+        {
+            int bufferWritePos = buffer.length - remaining;
+            int bytesRead = in.read(buffer, bufferWritePos, remaining);
+            if (bytesRead < 0)
+            {
+                break; //EOD
+            }
+            remaining -= bytesRead;
+        }
+        return buffer.length - remaining;
+    }
+
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxConstants.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxConstants.java
new file mode 100644
index 0000000000..cd16abda68
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxConstants.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+/**
+ * Constants for CCITT Fax Filter.
+ * @version $Revision$
+ */
+public interface CCITTFaxConstants
+{
+
+    /** A constant for group 3 1D encoding (ITU T.4). */
+    int COMPRESSION_GROUP3_1D = 0;
+    /** A constant for group 3 2D encoding (ITU T.4). */
+    int COMPRESSION_GROUP3_2D = 1;
+    /** A constant for group 4 2D encoding (ITU T.6). */
+    int COMPRESSION_GROUP4_2D = 2;
+
+    //Format: First 8 bits: length of pattern, Second 8 bits: pattern
+
+    /** The white terminating code words. */
+    public static final short[] WHITE_TERMINATING = new short[] {
+            0x0835, 0x0607, 0x0407, 0x0408, 0x040B, 0x040C, 0x040E, 0x040F,
+            0x0513, 0x0514, 0x0507, 0x0508, 0x0608, 0x0603, 0x0634, 0x0635,
+            0x062A, 0x062B, 0x0727, 0x070C, 0x0708, 0x0717, 0x0703, 0x0704,
+            0x0728, 0x072B, 0x0713, 0x0724, 0x0718, 0x0802, 0x0803, 0x081A,
+            0x081B, 0x0812, 0x0813, 0x0814, 0x0815, 0x0816, 0x0817, 0x0828,
+            0x0829, 0x082A, 0x082B, 0x082C, 0x082D, 0x0804, 0x0805, 0x080A,
+            0x080B, 0x0852, 0x0853, 0x0854, 0x0855, 0x0824, 0x0825, 0x0858,
+            0x0859, 0x085A, 0x085B, 0x084A, 0x084B, 0x0832, 0x0833, 0x0834};
+
+    /** The black terminating code words. */
+    public static final short[] BLACK_TERMINATING = new short[] {
+            0x0A37, 0x0302, 0x0203, 0x0202, 0x0303, 0x0403, 0x0402, 0x0503,
+            0x0605, 0x0604, 0x0704, 0x0705, 0x0707, 0x0804, 0x0807, 0x0918,
+            0x0A17, 0x0A18, 0x0A08, 0x0B67, 0x0B68, 0x0B6C, 0x0B37, 0x0B28,
+            0x0B17, 0x0B18, 0x0CCA, 0x0CCB, 0x0CCC, 0x0CCD, 0x0C68, 0x0C69,
+            0x0C6A, 0x0C6B, 0x0CD2, 0x0CD3, 0x0CD4, 0x0CD5, 0x0CD6, 0x0CD7,
+            0x0C6C, 0x0C6D, 0x0CDA, 0x0CDB, 0x0C54, 0x0C55, 0x0C56, 0x0C57,
+            0x0C64, 0x0C65, 0x0C52, 0x0C53, 0x0C24, 0x0C37, 0x0C38, 0x0C27,
+            0x0C28, 0x0C58, 0x0C59, 0x0C2B, 0x0C2C, 0x0C5A, 0x0C66, 0x0C67};
+
+    /** The white make-up code words. */
+    public static final short[] WHITE_MAKE_UP = new short[] {
+            0x051B, 0x0512, 0x0617, 0x0737, 0x0836, 0x0837, 0x0864, 0x0865,
+            0x0868, 0x0867, 0x09CC, 0x09CD, 0x09D2, 0x09D3, 0x09D4, 0x09D5,
+            0x09D6, 0x09D7, 0x09D8, 0x09D9, 0x09DA, 0x09DB, 0x0998, 0x0999,
+            0x099A, 0x0618, 0x099B};
+
+    /** The black make-up code words. */
+    public static final short[] BLACK_MAKE_UP = new short[] {
+            0x0A0F, 0x0CC8, 0x0CC9, 0x0C5B, 0x0C33, 0x0C34, 0x0C35, 0x0D6C,
+            0x0D6D, 0x0D4A, 0x0D4B, 0x0D4C, 0x0D4D, 0x0D72, 0x0D73, 0x0D74,
+            0x0D75, 0x0D76, 0x0D77, 0x0D52, 0x0D53, 0x0D54, 0x0D55, 0x0D5A,
+            0x0D5B, 0x0D64, 0x0D65};
+
+    /** The long make-up code words. */
+    public static final short[] LONG_MAKE_UP = new short[] {
+            0x0B08, 0x0B0C, 0x0B0D, 0x0C12, 0x0C13, 0x0C14, 0x0C15, 0x0C16,
+            0x0C17, 0x0C1C, 0x0C1D, 0x0C1E, 0x0C1F};
+
+    /** The EOL code word. */
+    public static final short EOL_CODE = 0x0C01;
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxG31DDecodeInputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxG31DDecodeInputStream.java
new file mode 100644
index 0000000000..39a965aa4e
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/CCITTFaxG31DDecodeInputStream.java
@@ -0,0 +1,452 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * This is a CCITT Group 3 1D decoder (ITU T.4).
+ * @version $Revision$
+ */
+public class CCITTFaxG31DDecodeInputStream extends InputStream implements CCITTFaxConstants
+{
+
+    private static final int CODE_WORD = 0;
+    private static final int SIGNAL_EOD = -1;
+    private static final int SIGNAL_EOL = -2;
+
+    private InputStream source;
+    private int columns;
+    private int rows;
+
+    //for reading compressed bits
+    private int bits;
+    private int bitPos = 8;
+
+    //a single decoded line (one line decoded at a time, then read byte by byte)
+    private PackedBitArray decodedLine;
+    private int decodedWritePos; //write position in bits (used by the decoder algorithm)
+    private int decodedReadPos; //read position in bytes (used by the actual InputStream reading)
+
+    //state
+    private int y = -1; //Current row/line
+    private int accumulatedRunLength; //Used for make-up codes
+
+    private static final NonLeafLookupTreeNode WHITE_LOOKUP_TREE_ROOT;
+    private static final NonLeafLookupTreeNode BLACK_LOOKUP_TREE_ROOT;
+
+    static {
+        WHITE_LOOKUP_TREE_ROOT = new NonLeafLookupTreeNode();
+        BLACK_LOOKUP_TREE_ROOT = new NonLeafLookupTreeNode();
+        buildLookupTree();
+    }
+
+    /**
+     * Creates a new decoder.
+     * @param source the input stream containing the compressed data.
+     * @param columns the number of columns
+     * @param rows the number of rows (0 if undefined)
+     */
+    public CCITTFaxG31DDecodeInputStream(InputStream source, int columns, int rows)
+    {
+        this.source = source;
+        this.columns = columns;
+        this.rows = rows;
+        this.decodedLine = new PackedBitArray(columns);
+        this.decodedReadPos = this.decodedLine.getByteCount();
+    }
+
+    /**
+     * Creates a new decoder.
+     * @param source the input stream containing the compressed data.
+     * @param columns the number of columns
+     */
+    public CCITTFaxG31DDecodeInputStream(InputStream source, int columns)
+    {
+        this(source, columns, 0);
+    }
+
+    /** {@inheritDoc} */
+    public boolean markSupported()
+    {
+        return false;
+    }
+
+    /** {@inheritDoc} */
+    public int read() throws IOException
+    {
+        if (this.decodedReadPos >= this.decodedLine.getByteCount())
+        {
+            boolean hasLine = decodeLine();
+            if (!hasLine)
+            {
+                return -1;
+            }
+        }
+        byte data = this.decodedLine.getData()[this.decodedReadPos++];
+
+        //System.out.println("Returning " + PackedBitArray.visualizeByte(data));
+        return data & 0xFF;
+    }
+
+    //TODO Implement the other two read methods
+
+    private boolean decodeLine() throws IOException
+    {
+        if (this.bits < 0)
+        {
+            return false; //Shortcut after EOD
+        }
+        this.y++;
+        //System.out.println("decodeLine " + this.y);
+        int x = 0;
+        if (this.rows > 0 && this.y >= this.rows)
+        {
+            return false; //All rows decoded, ignore further bits
+        }
+        this.decodedLine.clear();
+        this.decodedWritePos = 0;
+        int expectRTC = 6;
+        boolean white = true;
+        while (x < this.columns || this.accumulatedRunLength > 0)
+        {
+            CodeWord code;
+            LookupTreeNode root = white ? WHITE_LOOKUP_TREE_ROOT : BLACK_LOOKUP_TREE_ROOT;
+            code = root.getNextCodeWord(this);
+            if (code == null)
+            {
+                //no more code words (EOD)
+                if (x > 0)
+                {
+                    //Have last line
+                    this.decodedReadPos = 0;
+                    return true;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+            else if (code.getType() == SIGNAL_EOL)
+            {
+                expectRTC--;
+                if (expectRTC == 0)
+                {
+                    //System.out.println("Return to Control");
+                    return false; //Return to Control = End Of Data
+                }
+                if (x == 0)
+                {
+                    //System.out.println("Ignoring leading EOL");
+                    continue; //Ignore leading EOL
+                }
+            }
+            else
+            {
+                expectRTC = -1;
+                x += code.execute(this);
+                if (this.accumulatedRunLength == 0)
+                {
+                    //Only switch if not using make-up codes
+                    white = !white;
+                }
+            }
+        }
+        this.decodedReadPos = 0;
+        return true;
+    }
+
+    private void writeRun(int bit, int length)
+    {
+        this.accumulatedRunLength += length;
+
+        //System.out.println(" Run " + bit + " for " + this.accumulatedRunLength + " at " + decodedWritePos);
+        if (bit != 0)
+        {
+            this.decodedLine.setBits(this.decodedWritePos, this.accumulatedRunLength);
+        }
+        this.decodedWritePos += this.accumulatedRunLength;
+        this.accumulatedRunLength = 0;
+    }
+
+    private void writeNonTerminating(int length)
+    {
+        //System.out.println(" Make up code for " + length + " bits");
+        this.accumulatedRunLength += length;
+    }
+
+    private static final int[] BIT_POS_MASKS
+        = new int[] {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
+
+    private int readBit() throws IOException
+    {
+        if (this.bitPos >= 8)
+        {
+            readByte();
+            if (this.bits < 0)
+            {
+                return SIGNAL_EOD;
+            }
+        }
+        final int bit = (this.bits & BIT_POS_MASKS[this.bitPos++]) == 0 ? 0 : 1;
+        //System.out.print(bit);
+        return bit;
+    }
+
+    private void readByte() throws IOException
+    {
+        this.bits = this.source.read();
+        this.bitPos = 0;
+    }
+
+    private static final short EOL_STARTER = 0x0B00;
+
+    private static void buildLookupTree()
+    {
+        buildUpTerminating(WHITE_TERMINATING, WHITE_LOOKUP_TREE_ROOT, true);
+        buildUpTerminating(BLACK_TERMINATING, BLACK_LOOKUP_TREE_ROOT, false);
+        buildUpMakeUp(WHITE_MAKE_UP, WHITE_LOOKUP_TREE_ROOT);
+        buildUpMakeUp(BLACK_MAKE_UP, BLACK_LOOKUP_TREE_ROOT);
+        buildUpMakeUp(LONG_MAKE_UP, WHITE_LOOKUP_TREE_ROOT);
+        buildUpMakeUp(LONG_MAKE_UP, BLACK_LOOKUP_TREE_ROOT);
+        LookupTreeNode eolNode = new EndOfLineTreeNode();
+        addLookupTreeNode(EOL_STARTER, WHITE_LOOKUP_TREE_ROOT, eolNode);
+        addLookupTreeNode(EOL_STARTER, BLACK_LOOKUP_TREE_ROOT, eolNode);
+    }
+
+    private static void buildUpTerminating(short[] codes, NonLeafLookupTreeNode root, boolean white)
+    {
+        for (int len = 0, c = codes.length; len < c; len++)
+        {
+            LookupTreeNode leaf = new RunLengthTreeNode(white ? 0 : 1, len);
+            addLookupTreeNode(codes[len], root, leaf);
+        }
+    }
+
+    private static void buildUpMakeUp(short[] codes, NonLeafLookupTreeNode root)
+    {
+        for (int len = 0, c = codes.length; len < c; len++)
+        {
+            LookupTreeNode leaf = new MakeUpTreeNode((len + 1) * 64);
+            addLookupTreeNode(codes[len], root, leaf);
+        }
+    }
+
+    private static void addLookupTreeNode(short code, NonLeafLookupTreeNode root,
+            LookupTreeNode leaf)
+    {
+        int codeLength = code >> 8;
+        int pattern = code & 0xFF;
+        NonLeafLookupTreeNode node = root;
+        for (int p = codeLength - 1; p > 0; p--)
+        {
+            int bit = (pattern >> p) & 0x01;
+            LookupTreeNode child = node.get(bit);
+            if (child == null)
+            {
+                child = new NonLeafLookupTreeNode();
+                node.set(bit, child);
+            }
+            if (child instanceof NonLeafLookupTreeNode)
+            {
+                node = (NonLeafLookupTreeNode)child;
+            }
+            else
+            {
+                throw new IllegalStateException("NonLeafLookupTreeNode expected, was "
+                        + child.getClass().getName());
+            }
+        }
+        int bit = pattern & 0x01;
+        if (node.get(bit) != null)
+        {
+            throw new IllegalStateException("Two codes conflicting in lookup tree");
+        }
+        node.set(bit, leaf);
+    }
+
+    /** Base class for all nodes in the lookup tree for code words. */
+    private abstract static class LookupTreeNode
+    {
+
+        public abstract CodeWord getNextCodeWord(CCITTFaxG31DDecodeInputStream decoder)
+                throws IOException;
+
+    }
+
+    /** Interface for code words. */
+    private interface CodeWord
+    {
+
+        public abstract int getType();
+        public abstract int execute(CCITTFaxG31DDecodeInputStream decoder) throws IOException;
+
+    }
+
+    /** Non-leaf nodes that hold a child node for both the 0 and 1 cases for the lookup tree. */
+    private static class NonLeafLookupTreeNode extends LookupTreeNode
+    {
+
+        private LookupTreeNode zero;
+        private LookupTreeNode one;
+
+        public void set(int bit, LookupTreeNode node)
+        {
+            if (bit == 0)
+            {
+                this.zero = node;
+            }
+            else
+            {
+                this.one = node;
+            }
+        }
+
+        public LookupTreeNode get(int bit)
+        {
+            return (bit == 0) ? this.zero : this.one;
+        }
+
+        public CodeWord getNextCodeWord(CCITTFaxG31DDecodeInputStream decoder)
+                throws IOException
+                {
+            int bit = decoder.readBit();
+            if (bit < 0)
+            {
+                return null;
+            }
+            LookupTreeNode node = get(bit);
+            if (node != null)
+            {
+                return node.getNextCodeWord(decoder);
+            }
+            throw new IOException("Invalid code word encountered");
+        }
+
+    }
+
+    /** This node represents a run length of either 0 or 1. */
+    private static class RunLengthTreeNode extends LookupTreeNode implements CodeWord
+    {
+
+        private final int bit;
+        private final int length;
+
+        public RunLengthTreeNode(int bit, int length)
+        {
+            this.bit = bit;
+            this.length = length;
+        }
+
+        public CodeWord getNextCodeWord(CCITTFaxG31DDecodeInputStream decoder) throws IOException
+        {
+            return this;
+        }
+
+        public int execute(CCITTFaxG31DDecodeInputStream decoder)
+        {
+            decoder.writeRun(this.bit, this.length);
+            return length;
+        }
+
+        public int getType()
+        {
+            return CODE_WORD;
+        }
+
+        public String toString()
+        {
+            return "Run Length for " + length + " bits of " + (bit == 0 ? "white" : "black");
+        }
+
+    }
+
+    /** Represents a make-up code word. */
+    private static class MakeUpTreeNode extends LookupTreeNode implements CodeWord
+    {
+
+        private final int length;
+
+        public MakeUpTreeNode(int length)
+        {
+            this.length = length;
+        }
+
+        public CodeWord getNextCodeWord(CCITTFaxG31DDecodeInputStream decoder) throws IOException
+        {
+            return this;
+        }
+
+        public int execute(CCITTFaxG31DDecodeInputStream decoder) throws IOException
+        {
+            decoder.writeNonTerminating(length);
+            return length;
+        }
+
+        public int getType()
+        {
+            return CODE_WORD;
+        }
+
+        public String toString()
+        {
+            return "Make up code for length " + length;
+        }
+
+    }
+
+    /** Represents an EOL code word. */
+    private static class EndOfLineTreeNode extends LookupTreeNode implements CodeWord
+    {
+
+        public CodeWord getNextCodeWord(CCITTFaxG31DDecodeInputStream decoder) throws IOException
+        {
+            int bit;
+            do
+            {
+                bit = decoder.readBit();
+            } while (bit == 0); //bit 1 finishes the EOL, any number of bit 0 allowed as fillers
+            if (bit < 0)
+            {
+                return null;
+            }
+            return this;
+        }
+
+        public int execute(CCITTFaxG31DDecodeInputStream decoder) throws IOException
+        {
+            //nop
+            return 0;
+        }
+
+        public int getType()
+        {
+            return SIGNAL_EOL;
+        }
+
+        public String toString()
+        {
+            return "EOL";
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/FillOrderChangeInputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/FillOrderChangeInputStream.java
new file mode 100644
index 0000000000..448ddb1bcf
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/FillOrderChangeInputStream.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * This filtering input stream does a fill order change required for certain TIFF images.
+ * @version $Revision$
+ */
+public class FillOrderChangeInputStream extends FilterInputStream
+{
+
+    /**
+     * Main constructor.
+     * @param in the underlying input stream
+     */
+    public FillOrderChangeInputStream(InputStream in)
+    {
+        super(in);
+    }
+
+    /** {@inheritDoc} */
+    public int read(byte[] b, int off, int len) throws IOException
+    {
+        int result = super.read(b, off, len);
+        if (result > 0)
+        {
+            int endpos = off + result;
+            for (int i = off; i < endpos; i++)
+            {
+                b[i] = FLIP_TABLE[b[i] & 0xff];
+            }
+        }
+        return result;
+    }
+
+    /** {@inheritDoc} */
+    public int read() throws IOException
+    {
+        int b = super.read();
+        if (b < 0)
+        {
+            return b;
+        }
+        else
+        {
+            return FLIP_TABLE[b] & 0xff;
+        }
+    }
+
+    // Table to be used when fillOrder = 2, for flipping bytes.
+    // Copied from the TIFFFaxDecoder class
+    private static final byte[] FLIP_TABLE = {
+     0,  -128,    64,   -64,    32,   -96,    96,   -32,
+    16,  -112,    80,   -48,    48,   -80,   112,   -16,
+     8,  -120,    72,   -56,    40,   -88,   104,   -24,
+    24,  -104,    88,   -40,    56,   -72,   120,    -8,
+     4,  -124,    68,   -60,    36,   -92,   100,   -28,
+    20,  -108,    84,   -44,    52,   -76,   116,   -12,
+    12,  -116,    76,   -52,    44,   -84,   108,   -20,
+    28,  -100,    92,   -36,    60,   -68,   124,    -4,
+     2,  -126,    66,   -62,    34,   -94,    98,   -30,
+    18,  -110,    82,   -46,    50,   -78,   114,   -14,
+    10,  -118,    74,   -54,    42,   -86,   106,   -22,
+    26,  -102,    90,   -38,    58,   -70,   122,    -6,
+     6,  -122,    70,   -58,    38,   -90,   102,   -26,
+    22,  -106,    86,   -42,    54,   -74,   118,   -10,
+    14,  -114,    78,   -50,    46,   -82,   110,   -18,
+    30,   -98,    94,   -34,    62,   -66,   126,    -2,
+     1,  -127,    65,   -63,    33,   -95,    97,   -31,
+    17,  -111,    81,   -47,    49,   -79,   113,   -15,
+     9,  -119,    73,   -55,    41,   -87,   105,   -23,
+    25,  -103,    89,   -39,    57,   -71,   121,    -7,
+     5,  -123,    69,   -59,    37,   -91,   101,   -27,
+    21,  -107,    85,   -43,    53,   -75,   117,   -11,
+    13,  -115,    77,   -51,    45,   -83,   109,   -19,
+    29,   -99,    93,   -35,    61,   -67,   125,    -3,
+     3,  -125,    67,   -61,    35,   -93,    99,   -29,
+    19,  -109,    83,   -45,    51,   -77,   115,   -13,
+    11,  -117,    75,   -53,    43,   -85,   107,   -21,
+    27,  -101,    91,   -37,    59,   -69,   123,    -5,
+     7,  -121,    71,   -57,    39,   -89,   103,   -25,
+    23,  -105,    87,   -41,    55,   -73,   119,    -9,
+    15,  -113,    79,   -49,    47,   -81,   111,   -17,
+    31,   -97,    95,   -33,    63,   -65,   127,    -1,
+    };
+    // end
+}
\ No newline at end of file
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/PackedBitArray.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/PackedBitArray.java
new file mode 100644
index 0000000000..aa6c73c6d1
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/PackedBitArray.java
@@ -0,0 +1,259 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+/**
+ * Represents an array of bits packed in a byte array of fixed size.
+ * @version $Revision$
+ */
+public class PackedBitArray
+{
+
+    private int bitCount;
+    private byte[] data;
+
+    /**
+     * Constructs a new bit array.
+     * @param bitCount the number of bits to maintain
+     */
+    public PackedBitArray(int bitCount)
+    {
+        this.bitCount = bitCount;
+        int byteCount = (bitCount + 7) / 8;
+        this.data = new byte[byteCount];
+    }
+
+    private int byteOffset(int offset)
+    {
+        return offset / 8;
+    }
+
+    private int bitOffset(int offset)
+    {
+        return offset % 8;
+    }
+
+    /**
+     * Sets a bit at the given offset.
+     * @param offset the offset
+     */
+    public void set(int offset)
+    {
+        int byteOffset = byteOffset(offset);
+        this.data[byteOffset] |= 1 << bitOffset(offset);
+    }
+
+    /**
+     * Clears a bit at the given offset.
+     * @param offset the offset
+     */
+    public void clear(int offset)
+    {
+        int byteOffset = byteOffset(offset);
+        int bitOffset = bitOffset(offset);
+        this.data[byteOffset] &= ~(1 << bitOffset);
+    }
+
+    /**
+     * Sets a run of bits at the given offset to either 1 or 0.
+     * @param offset the offset
+     * @param length the number of bits to set
+     * @param bit 1 to set the bit, 0 to clear it
+     */
+    public void setBits(int offset, int length, int bit)
+    {
+        if (bit == 0)
+        {
+            clearBits(offset, length);
+        }
+        else
+        {
+            setBits(offset, length);
+        }
+    }
+
+    /**
+     * Sets a run of bits at the given offset to either 1.
+     * @param offset the offset
+     * @param length the number of bits to set
+     */
+    public void setBits(int offset, int length)
+    {
+        if (length == 0)
+        {
+            return;
+        }
+        int startBitOffset = bitOffset(offset);
+        int firstByte = byteOffset(offset);
+        int lastBitOffset = offset + length;
+        if (lastBitOffset > getBitCount())
+        {
+            throw new IndexOutOfBoundsException("offset + length > bit count");
+        }
+        int lastByte = byteOffset(lastBitOffset);
+        int endBitOffset = bitOffset(lastBitOffset);
+
+        if (firstByte == lastByte)
+        {
+            //Only one byte affected
+            int mask = (1 << endBitOffset) - (1 << startBitOffset);
+            this.data[firstByte] |= mask;
+        }
+        else
+        {
+            //Bits spanning multiple bytes
+            this.data[firstByte] |= 0xFF << startBitOffset;
+            for (int i = firstByte + 1; i < lastByte; i++)
+            {
+                this.data[i] = (byte)0xFF;
+            }
+            if (endBitOffset > 0)
+            {
+                this.data[lastByte] |= 0xFF >> (8 - endBitOffset);
+            }
+        }
+    }
+
+    /**
+     * Clears a run of bits at the given offset.
+     * @param offset the offset
+     * @param length the number of bits to clear
+     */
+    public void clearBits(int offset, int length)
+    {
+        if (length == 0)
+        {
+            return;
+        }
+        int startBitOffset = offset % 8;
+        int firstByte = byteOffset(offset);
+        int lastBitOffset = offset + length;
+        int lastByte = byteOffset(lastBitOffset);
+        int endBitOffset = lastBitOffset % 8;
+
+        if (firstByte == lastByte)
+        {
+            //Only one byte affected
+            int mask = (1 << endBitOffset) - (1 << startBitOffset);
+            this.data[firstByte] &= ~mask;
+        }
+        else
+        {
+            //Bits spanning multiple bytes
+            this.data[firstByte] &= ~(0xFF << startBitOffset);
+            for (int i = firstByte + 1; i < lastByte; i++)
+            {
+                this.data[i] = (byte)0x00;
+            }
+            if (endBitOffset > 0)
+            {
+                this.data[lastByte] &= ~(0xFF >> (8 - endBitOffset));
+            }
+        }
+    }
+
+    /**
+     * Clear all bits in the array.
+     */
+    public void clear()
+    {
+        clearBits(0, getBitCount());
+    }
+
+    /**
+     * Returns the number of bits maintained by this array.
+     * @return the number of bits
+     */
+    public int getBitCount()
+    {
+        return this.bitCount;
+    }
+
+    /**
+     * Returns the size of the byte buffer for this array.
+     * @return the size of the byte buffer
+     */
+    public int getByteCount()
+    {
+        return this.data.length;
+    }
+
+    /**
+     * Returns the underlying byte buffer.
+     * <p>
+     * Note: the actual buffer is returned. If it's manipulated
+     * the content of the bit array changes.
+     * @return the underlying data buffer
+     */
+    public byte[] getData()
+    {
+        return this.data;
+    }
+
+    /** {@inheritDoc} */
+    public String toString()
+    {
+        return toBitString(this.data).substring(0, this.bitCount);
+    }
+
+    /**
+     * Converts a byte to a "binary" String of 0s and 1s.
+     * @param data the value to convert
+     * @return the binary string
+     */
+    public static String toBitString(byte data)
+    {
+        byte[] buf = new byte[] {data};
+        return toBitString(buf);
+    }
+
+    /**
+     * Converts a series of bytes to a "binary" String of 0s and 1s.
+     * @param data the data
+     * @return the binary string
+     */
+    public static String toBitString(byte[] data)
+    {
+        return toBitString(data, 0, data.length);
+    }
+
+    /**
+     * Converts a series of bytes to a "binary" String of 0s and 1s.
+     * @param data the data
+     * @param start the start offset
+     * @param len the number of bytes to convert
+     * @return the binary string
+     */
+    public static String toBitString(byte[] data, int start, int len)
+    {
+        StringBuffer sb = new StringBuffer();
+        for (int x = start, end = start + len; x < end; x++)
+        {
+            for (int i = 0; i < 8; i++)
+            {
+                int mask = 1 << i;
+                int value = data[x] & mask;
+                sb.append(value != 0 ? '1' : '0');
+            }
+        }
+        return sb.toString();
+    }
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/package.html b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/package.html
new file mode 100644
index 0000000000..cd5971ae3e
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/ccitt/package.html
@@ -0,0 +1,26 @@
+<!--
+ ! Licensed to the Apache Software Foundation (ASF) under one or more
+ ! contributor license agreements.  See the NOTICE file distributed with
+ ! this work for additional information regarding copyright ownership.
+ ! The ASF licenses this file to You under the Apache License, Version 2.0
+ ! (the "License"); you may not use this file except in compliance with
+ ! the License.  You may obtain a copy of the License at
+ !
+ !      http://www.apache.org/licenses/LICENSE-2.0
+ !
+ ! Unless required by applicable law or agreed to in writing, software
+ ! distributed under the License is distributed on an "AS IS" BASIS,
+ ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ! See the License for the specific language governing permissions and
+ ! limitations under the License.
+ !-->
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+
+</head>
+<body>
+This package contains CCITT encoders and decoders.
+This refers to the ITU T.4 (Group 3 Fax) and T.6 (Group 4 Fax) specifications.
+</body>
+</html>
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
index 7226e4c687..50a730e4a2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
@@ -16,13 +16,9 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.xobject;
 
-import java.awt.Transparency;
 import java.awt.image.BufferedImage;
-import java.awt.image.ColorModel;
 import java.awt.image.DataBufferByte;
-import java.awt.image.IndexColorModel;
 import java.awt.image.WritableRaster;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -35,6 +31,7 @@ import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSStream;
+import org.apache.pdfbox.io.IOUtils;
 import org.apache.pdfbox.io.RandomAccess;
 import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.common.PDStream;
@@ -51,7 +48,7 @@ public class PDCcitt extends PDXObjectImage
 {
 
     private static final List<String> FAX_FILTERS = new ArrayList<String>();
-    
+
     static
     {
         FAX_FILTERS.add( COSName.CCITTFAX_DECODE.getName() );
@@ -126,41 +123,37 @@ public class PDCcitt extends PDXObjectImage
             // ensure that rows doesn't contain implausible data, see PDFBOX-771
             rows = Math.min(rows, height);
         }
-        else 
+        else
         {
             // at least one of the values has to have a valid value
             rows = Math.max(rows, height);
         }
         boolean blackIsOne = decodeParms.getBoolean(COSName.BLACK_IS_1, false);
-        
-        byte[] map;
-        if (blackIsOne)
-        {
-            map = new byte[] {(byte)0x00, (byte)0xff};
-        }
-        else
-        {
-            map = new byte[] {(byte)0xff};
-        }
-        ColorModel cm = new IndexColorModel(1, map.length, map, map, map, Transparency.OPAQUE);
-        WritableRaster raster = cm.createCompatibleWritableRaster( cols, rows );
+
+        BufferedImage image = new BufferedImage(cols, rows, BufferedImage.TYPE_BYTE_BINARY);
+        WritableRaster raster = image.getRaster();
         DataBufferByte buffer = (DataBufferByte)raster.getDataBuffer();
         byte[] bufferData = buffer.getData();
+        IOUtils.populateBuffer(stream.getUnfilteredStream(), bufferData);
+        if (!blackIsOne)
+        {
+            //Inverting the bitmap
+            //Note the previous approach with starting from an IndexColorModel didn't work
+            //reliably. In some cases the image wouldn't be painted for some reason.
+            //So a safe but slower approach was taken.
+            invertBitmap(bufferData);
+        }
+        return image;
+    }
 
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        int bytesRead;
-        byte[] data = new byte[16384];
-        InputStream unfilteredStream = stream.getUnfilteredStream();
-        while ((bytesRead = unfilteredStream.read(data, 0, data.length)) != -1) 
+    private void invertBitmap(byte[] bufferData)
+    {
+        for (int i = 0, c = bufferData.length; i < c; i++)
         {
-            baos.write(data, 0, bytesRead);
+            bufferData[i] = (byte)(~bufferData[i] & 0xFF);
         }
-        baos.flush();
-        System.arraycopy( baos.toByteArray(), 0,bufferData, 0, 
-                (baos.size() < bufferData.length ? baos.size() : bufferData.length) );
-        return new BufferedImage(cm, raster, false, null);
     }
-    
+
     /**
      * This writes a tiff to out.
      *
@@ -169,13 +162,10 @@ public class PDCcitt extends PDXObjectImage
     public void write2OutputStream(OutputStream out) throws IOException
     {
         // We should use another format than TIFF to get rid of the TiffWrapper
-        InputStream data = new TiffWrapper(getPDStream().getPartiallyFilteredStream( FAX_FILTERS ),getCOSStream());
-        byte[] buf = new byte[1024];
-        int amountRead = -1;
-        while( (amountRead = data.read( buf )) != -1 )
-        {
-            out.write( buf, 0, amountRead );
-        }
+        InputStream data = new TiffWrapper(
+                getPDStream().getPartiallyFilteredStream( FAX_FILTERS ),
+                getCOSStream());
+        IOUtils.copy(data, out);
     }
 
     /**
@@ -671,10 +661,13 @@ public class PDCcitt extends PDXObjectImage
             tiffheader[offset+9]=(byte)((additionalOffset>>8) & 0xff);
             tiffheader[offset+10]=(byte)((additionalOffset>>16) & 0xff);
             tiffheader[offset+11]=(byte)((additionalOffset>>24) & 0xff);
-            try {
+            try
+            {
                 System.arraycopy(value.getBytes("US-ASCII"), 0,
                         tiffheader, additionalOffset, value.length());
-            } catch (UnsupportedEncodingException e) {
+            }
+            catch (UnsupportedEncodingException e)
+            {
                 throw new RuntimeException("Incompatible VM without US-ASCII encoding", e);
             }
             additionalOffset += len;
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/TestAll.java b/pdfbox/src/test/java/org/apache/pdfbox/TestAll.java
index 4c5014ab7c..87e8e7fc0c 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/TestAll.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/TestAll.java
@@ -24,6 +24,9 @@ import org.apache.pdfbox.cos.TestCOSFloat;
 import org.apache.pdfbox.cos.TestCOSInteger;
 import org.apache.pdfbox.cos.TestCOSString;
 import org.apache.pdfbox.filter.TestFilters;
+import org.apache.pdfbox.io.TestIOUtils;
+import org.apache.pdfbox.io.ccitt.TestCCITTFaxG31DDecodeInputStream;
+import org.apache.pdfbox.io.ccitt.TestPackedBitArray;
 import org.apache.pdfbox.pdmodel.TestFDF;
 import org.apache.pdfbox.pdmodel.TestPDDocumentCatalog;
 import org.apache.pdfbox.pdmodel.TestPDDocumentInformation;
@@ -82,6 +85,11 @@ public class TestAll extends TestCase
         suite.addTestSuite( org.apache.pdfbox.pdmodel.graphics.optionalcontent.TestOptionalContentGroups.class );
         suite.addTestSuite( org.apache.pdfbox.util.TestLayerUtility.class );
         suite.addTestSuite( org.apache.pdfbox.TestTextToPdf.class );
+
+        suite.addTestSuite( TestIOUtils.class );
+        suite.addTestSuite( TestPackedBitArray.class );
+        suite.addTestSuite( TestCCITTFaxG31DDecodeInputStream.class );
+
         return suite;
     }
 }
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/TestIOUtils.java b/pdfbox/src/test/java/org/apache/pdfbox/io/TestIOUtils.java
new file mode 100644
index 0000000000..c880f4824c
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/TestIOUtils.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import junit.framework.TestCase;
+
+/**
+ * This is a unit test for {@link IOUtils}.
+ * @version $Revision$
+ */
+public class TestIOUtils extends TestCase
+{
+
+    /**
+     * Tests {@link IOUtils#populateBuffer(java.io.InputStream, byte[]).
+     * @throws IOException if an I/O error occursn
+     */
+    public void testPopulateBuffer() throws IOException
+    {
+        byte[] data = "Hello World!".getBytes();
+        byte[] buffer = new byte[data.length];
+        long count = IOUtils.populateBuffer(new ByteArrayInputStream(data), buffer);
+        assertEquals(12, count);
+
+        buffer = new byte[data.length - 2]; //Buffer too small
+        InputStream in = new ByteArrayInputStream(data);
+        count = IOUtils.populateBuffer(in, buffer);
+        assertEquals(10, count);
+        byte[] leftOver = IOUtils.toByteArray(in);
+        assertEquals(2, leftOver.length);
+
+        buffer = new byte[data.length + 2]; //Buffer too big
+        in = new ByteArrayInputStream(data);
+        count = IOUtils.populateBuffer(in, buffer);
+        assertEquals(12, count);
+        assertEquals(-1, in.read()); //EOD reached
+    }
+
+}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/AbstractCCITTFaxTestCase.java b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/AbstractCCITTFaxTestCase.java
new file mode 100644
index 0000000000..de90b7cc72
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/AbstractCCITTFaxTestCase.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+import junit.framework.TestCase;
+
+/**
+ * Abstract base class for testing CCITT fax encoding.
+ * @version $Revision$
+ */
+public abstract class AbstractCCITTFaxTestCase extends TestCase
+{
+
+    /**
+     * Visualizes a packed bitmap and dumps it on System.out.
+     * @param data the bitmap
+     * @param columns the number of columns
+     */
+    protected void dumpBitmap(byte[] data, int columns)
+    {
+        int lineBytes = columns / 8;
+        if (columns % 8 != 0)
+        {
+            lineBytes++;
+        }
+        int lines = data.length / lineBytes;
+        for (int y = 0; y < lines; y++)
+        {
+            int start = y * lineBytes;
+            for (int x = 0; x < columns; x++)
+            {
+                int index = start + (x / 8);
+                int mask = 1 << (7 - (x % 8));
+                int value = data[index] & mask;
+                System.out.print(value != 0 ? 'X' : '_');
+            }
+            System.out.println();
+        }
+    }
+
+    /**
+     * Converts a series of bytes to a "binary" String of 0s and 1s.
+     * @param data the data
+     * @return the binary string
+     */
+    protected String toBitString(byte[] data)
+    {
+        return PackedBitArray.toBitString(data);
+    }
+
+}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestCCITTFaxG31DDecodeInputStream.java b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestCCITTFaxG31DDecodeInputStream.java
new file mode 100644
index 0000000000..493bb141fd
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestCCITTFaxG31DDecodeInputStream.java
@@ -0,0 +1,196 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+import org.apache.pdfbox.io.IOUtils;
+
+/**
+ * Tests the CCITT Fax G3 1D decoder.
+ * @version $Revision$
+ */
+public class TestCCITTFaxG31DDecodeInputStream extends AbstractCCITTFaxTestCase
+{
+
+    private static final boolean DEBUG = false;
+
+    private static final String EOL = "000000000001";
+    private static final String RTC = EOL + EOL + EOL + EOL + EOL + EOL;
+
+    /**
+     * Tests the decoder with naked bits (no EOL, no alignment, nothing).
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderNaked() throws IOException
+    {
+        //Test data: 24x3 pixels encoded
+        byte[] data = fromBinary("10011" + "000101" + "10011"
+                    + "00110101" + "011" + "10011" + "0000111"
+                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000");
+        assertStandardDecodingResult(data);
+    }
+
+    /**
+     * Tests the decoder with EOLs.
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderWithEOL() throws IOException
+    {
+        //Test data: 24x3 pixels encoded
+        byte[] data = fromBinary("10011" + "000101" + "10011" + EOL
+                    + "00110101" + "011" + "10011" + "0000111" + EOL
+                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000" + EOL);
+        assertStandardDecodingResult(data);
+    }
+
+    /**
+     * Tests the decoder with RTC and byte alignment.
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderAlignedWithRTC() throws IOException
+    {
+        //Test data: 24x3 pixels encoded
+        byte[] data = fromBinary("1001100010110011" + EOL
+                               + "00110101011100110000111" + "0" + EOL
+                               + "001101010100001110100010111000000" + "00000" + RTC);
+        assertStandardDecodingResult(data);
+    }
+
+    /**
+     * Tests the decoder with an initial EOL.
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderInitialEOL() throws IOException
+    {
+        //Test data: 24x3 pixels encoded
+        byte[] data = fromBinary("000" + EOL + "1001100010110011" + EOL
+                               + "00110101011100110000111" + EOL
+                               + "001101010100001110100010111000000");
+        assertStandardDecodingResult(data);
+    }
+
+    private void assertStandardDecodingResult(byte[] data) throws IOException
+    {
+        int columns = 24;
+
+        byte[] decoded = decode(data, columns);
+
+        if (DEBUG)
+        {
+            dumpBitmap(decoded, columns);
+            System.out.println(PackedBitArray.toBitString(decoded));
+        }
+
+        assertEquals(9, decoded.length);
+        assertEquals("000000001111111100000000"
+                   + "111100000000111111111111"
+                   + "101000000000000000000000", toBitString(decoded));
+    }
+
+    /**
+     * Tests the decoder with a restriction in the number of rows.
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderRowsRestriction() throws IOException
+    {
+        //Test data: 24x3 pixels encoded
+        byte[] data = fromBinary("10011" + "000101" + "10011"
+                    + "00110101" + "011" + "10011" + "0000111"
+                    + "00110101" + "010" + "000111" + "010" + "0010111" + "000000");
+        int columns = 24;
+        int rows = 2; //We actually have data for three rows. Just checking the restriction.
+
+        CCITTFaxG31DDecodeInputStream decoder = new CCITTFaxG31DDecodeInputStream(
+                new ByteArrayInputStream(data), columns, rows);
+        byte[] decoded = IOUtils.toByteArray(decoder);
+        decoder.close();
+
+        if (DEBUG)
+        {
+            dumpBitmap(decoded, columns);
+            System.out.println(PackedBitArray.toBitString(decoded));
+        }
+
+        assertEquals(6, decoded.length);
+        assertEquals("000000001111111100000000"
+                   + "111100000000111111111111", toBitString(decoded));
+    }
+
+    /**
+     * Tests the decoder with white lines.
+     * @throws IOException if an I/O error occurs
+     */
+    public void testDecoderWhiteLines() throws IOException
+    {
+        //Test data: 1728x3 pixels encoded (all white)
+        byte[] data = fromBinary(EOL + "010011011" + "00110101" //EOL + w1728 (make-up) + w0
+                               + EOL + "010011011" + "00110101"
+                               + EOL + "010011011" + "00110101" + RTC);
+        int columns = 1728;
+
+        byte[] decoded = decode(data, columns);
+
+        if (DEBUG)
+        {
+            dumpBitmap(decoded, columns);
+        }
+
+        assertEquals(columns * 3 / 8, decoded.length);
+    }
+
+    /**
+     * Decodes a byte buffer.
+     * @param data the data
+     * @param columns the number of columns
+     * @return the decoded bits/pixels
+     * @throws IOException if an I/O error occurs
+     */
+    public static byte[] decode(byte[] data, int columns) throws IOException
+    {
+        CCITTFaxG31DDecodeInputStream decoder = new CCITTFaxG31DDecodeInputStream(
+                new ByteArrayInputStream(data), columns);
+        byte[] decoded = IOUtils.toByteArray(decoder);
+        decoder.close();
+        return decoded;
+    }
+
+    private byte[] fromBinary(String binary)
+    {
+        ByteArrayOutputStream baout = new ByteArrayOutputStream();
+        int pos = 0;
+        while (pos < binary.length() - 8)
+        {
+            int v = Integer.parseInt(binary.substring(pos, pos + 8), 2);
+            baout.write(v & 0xFF);
+            pos += 8;
+        }
+        int rest = binary.length() - pos;
+        if (rest > 0)
+        {
+            String f = binary.substring(pos) + "00000000".substring(rest);
+            baout.write(Integer.parseInt(f, 2));
+        }
+        return baout.toByteArray();
+    }
+
+}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestPackedBitArray.java b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestPackedBitArray.java
new file mode 100644
index 0000000000..310cb77248
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/TestPackedBitArray.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* $Id$ */
+
+package org.apache.pdfbox.io.ccitt;
+
+import junit.framework.TestCase;
+
+/**
+ * This is a unit test for {@link PackedBitArray}.
+ * @version $Revision$
+ */
+public class TestPackedBitArray extends TestCase
+{
+
+    /**
+     * Tests the {@link PackedBitArray} class.
+     */
+    public void testPackedBitArray()
+    {
+        PackedBitArray bits = new PackedBitArray(19);
+        assertEquals(19, bits.getBitCount());
+        assertEquals(3, bits.getByteCount());
+        assertEquals("0000000000000000000", bits.toString());
+
+        bits.set(1);
+        assertEquals("0100000000000000000", bits.toString());
+
+        bits.clear(1);
+        assertEquals("0000000000000000000", bits.toString());
+
+        bits.setBits(4, 4);
+        assertEquals("0000111100000000000", bits.toString());
+
+        bits.setBits(2, 1);
+        assertEquals("0010111100000000000", bits.toString());
+
+        bits.setBits(9, 9, 1);
+        assertEquals("0010111101111111110", bits.toString());
+
+        bits.clearBits(15, 2);
+        assertEquals("0010111101111110010", bits.toString());
+
+        bits.setBits(9, 9, 0);
+        assertEquals("0010111100000000000", bits.toString());
+
+        bits.clear();
+        assertEquals("0000000000000000000", bits.toString());
+
+        bits.setBits(1, 18);
+        assertEquals("0111111111111111111", bits.toString());
+
+        bits.clearBits(3, 1);
+        assertEquals("0110111111111111111", bits.toString());
+
+        try
+        {
+            bits.setBits(1, 19);
+            fail("Expecting IndexOutOfBoundsException");
+        }
+        catch (IndexOutOfBoundsException e)
+        {
+            //good
+        }
+    }
+
+}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/package.html b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/package.html
new file mode 100644
index 0000000000..975173e46e
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/ccitt/package.html
@@ -0,0 +1,25 @@
+<!--
+ ! Licensed to the Apache Software Foundation (ASF) under one or more
+ ! contributor license agreements.  See the NOTICE file distributed with
+ ! this work for additional information regarding copyright ownership.
+ ! The ASF licenses this file to You under the Apache License, Version 2.0
+ ! (the "License"); you may not use this file except in compliance with
+ ! the License.  You may obtain a copy of the License at
+ !
+ !      http://www.apache.org/licenses/LICENSE-2.0
+ !
+ ! Unless required by applicable law or agreed to in writing, software
+ ! distributed under the License is distributed on an "AS IS" BASIS,
+ ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ! See the License for the specific language governing permissions and
+ ! limitations under the License.
+ !-->
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+
+</head>
+<body>
+This package contains classes testing the CCITT encoders and decoders.
+</body>
+</html>
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/package.html b/pdfbox/src/test/java/org/apache/pdfbox/io/package.html
new file mode 100644
index 0000000000..5b58b11bda
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/io/package.html
@@ -0,0 +1,25 @@
+<!--
+ ! Licensed to the Apache Software Foundation (ASF) under one or more
+ ! contributor license agreements.  See the NOTICE file distributed with
+ ! this work for additional information regarding copyright ownership.
+ ! The ASF licenses this file to You under the Apache License, Version 2.0
+ ! (the "License"); you may not use this file except in compliance with
+ ! the License.  You may obtain a copy of the License at
+ !
+ !      http://www.apache.org/licenses/LICENSE-2.0
+ !
+ ! Unless required by applicable law or agreed to in writing, software
+ ! distributed under the License is distributed on an "AS IS" BASIS,
+ ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ! See the License for the specific language governing permissions and
+ ! limitations under the License.
+ !-->
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+
+</head>
+<body>
+This package contains test cases for I/O-related classes.
+</body>
+</html>
