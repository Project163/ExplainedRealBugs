diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
index 36869de521..fd8838e7d1 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDCcitt.java
@@ -44,10 +44,10 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
 
 /**
  * An image class for CCITT Fax.
- *
+ * 
  * @author <a href="ben@benlitchfield.com">Ben Litchfield</a>
  * @author paul king
- *
+ * 
  */
 public class PDCcitt extends PDXObjectImage
 {
@@ -56,13 +56,13 @@ public class PDCcitt extends PDXObjectImage
 
     static
     {
-        FAX_FILTERS.add( COSName.CCITTFAX_DECODE.getName() );
-        FAX_FILTERS.add( COSName.CCITTFAX_DECODE_ABBREVIATION.getName() );
+        FAX_FILTERS.add(COSName.CCITTFAX_DECODE.getName());
+        FAX_FILTERS.add(COSName.CCITTFAX_DECODE_ABBREVIATION.getName());
     }
 
     /**
      * Standard constructor.
-     *
+     * 
      * @param ccitt The PDStream that already contains all ccitt information.
      */
     public PDCcitt(PDStream ccitt)
@@ -73,37 +73,37 @@ public class PDCcitt extends PDXObjectImage
 
     /**
      * Construct from a tiff file.
-     *
+     * 
      * @param doc The document to create the image as part of.
      * @param raf The random access TIFF file which contains a suitable CCITT compressed image
      * @throws IOException If there is an error reading the tiff data.
      */
 
-    public PDCcitt( PDDocument doc, RandomAccess raf ) throws IOException
+    public PDCcitt(PDDocument doc, RandomAccess raf) throws IOException
     {
-        super( new PDStream(doc),"tiff");
+        super(new PDStream(doc), "tiff");
 
         COSDictionary decodeParms = new COSDictionary();
 
         COSDictionary dic = getCOSStream();
 
-        extractFromTiff(raf, getCOSStream().createFilteredStream(),decodeParms);
+        extractFromTiff(raf, getCOSStream().createFilteredStream(), decodeParms);
 
-        dic.setItem( COSName.FILTER, COSName.CCITTFAX_DECODE);
-        dic.setItem( COSName.SUBTYPE, COSName.IMAGE);
-        dic.setItem( COSName.TYPE, COSName.XOBJECT );
-        dic.setItem( COSName.DECODE_PARMS, decodeParms);
+        dic.setItem(COSName.FILTER, COSName.CCITTFAX_DECODE);
+        dic.setItem(COSName.SUBTYPE, COSName.IMAGE);
+        dic.setItem(COSName.TYPE, COSName.XOBJECT);
+        dic.setItem(COSName.DECODE_PARMS, decodeParms);
 
-        setBitsPerComponent( 1 );
-        setColorSpace( new PDDeviceGray() );
-        setWidth( decodeParms.getInt(COSName.COLUMNS) );
-        setHeight( decodeParms.getInt(COSName.ROWS) );
+        setBitsPerComponent(1);
+        setColorSpace(new PDDeviceGray());
+        setWidth(decodeParms.getInt(COSName.COLUMNS));
+        setHeight(decodeParms.getInt(COSName.ROWS));
 
     }
 
     /**
      * Returns an image of the CCITT Fax, or null if TIFFs are not supported. (Requires additional JAI Image filters )
-     *
+     * 
      * {@inheritDoc}
      */
     public BufferedImage getRGBImage() throws IOException
@@ -113,19 +113,19 @@ public class PDCcitt extends PDXObjectImage
         COSDictionary decodeParms = null;
         if (decodeP instanceof COSDictionary)
         {
-            decodeParms = (COSDictionary)decodeP;
+            decodeParms = (COSDictionary) decodeP;
         }
         else if (decodeP instanceof COSArray)
         {
             int index = 0;
             // determine the index for the CCITT-filter
             COSBase filters = stream.getFilters();
-            if (filters instanceof COSArray) 
+            if (filters instanceof COSArray)
             {
-                COSArray filterArray = (COSArray)filters;
+                COSArray filterArray = (COSArray) filters;
                 while (index < filterArray.size())
                 {
-                    COSName filtername = (COSName)filterArray.get(index);
+                    COSName filtername = (COSName) filterArray.get(index);
                     if (COSName.CCITTFAX_DECODE.equals(filtername))
                     {
                         break;
@@ -133,7 +133,7 @@ public class PDCcitt extends PDXObjectImage
                     index++;
                 }
             }
-            decodeParms =  (COSDictionary)((COSArray)decodeP).getObject(index);
+            decodeParms = (COSDictionary) ((COSArray) decodeP).getObject(index);
         }
         int cols = decodeParms.getInt(COSName.COLUMNS, 1728);
         int rows = decodeParms.getInt(COSName.ROWS, 0);
@@ -157,11 +157,11 @@ public class PDCcitt extends PDXObjectImage
         // in some rare cases other colorspaces maybe used such as an indexed colorspace, see PDFBOX-1638
         if (colorspace instanceof PDIndexed)
         {
-            PDIndexed csIndexed = (PDIndexed)colorspace;
+            PDIndexed csIndexed = (PDIndexed) colorspace;
             COSBase maskArray = getMask();
             if (maskArray != null && maskArray instanceof COSArray)
             {
-                colorModel = csIndexed.createColorModel(8, ((COSArray)maskArray).getInt(0));
+                colorModel = csIndexed.createColorModel(8, ((COSArray) maskArray).getInt(0));
             }
             else
             {
@@ -170,41 +170,41 @@ public class PDCcitt extends PDXObjectImage
         }
         else
         {
-            byte[] map = new byte[] {(byte)0xff, (byte)0x00};
+            byte[] map = new byte[] { (byte) 0x00, (byte) 0xff };
             colorModel = new IndexColorModel(1, map.length, map, map, map, Transparency.OPAQUE);
         }
-        WritableRaster raster = colorModel.createCompatibleWritableRaster( cols, rows );
-        DataBufferByte buffer = (DataBufferByte)raster.getDataBuffer();
+        WritableRaster raster = colorModel.createCompatibleWritableRaster(cols, rows);
+        DataBufferByte buffer = (DataBufferByte) raster.getDataBuffer();
         bufferData = buffer.getData();
         IOUtils.populateBuffer(stream.getUnfilteredStream(), bufferData);
         BufferedImage image = new BufferedImage(colorModel, raster, false, null);
 
         if (!blackIsOne)
         {
-            //Inverting the bitmap
-            //Note the previous approach with starting from an IndexColorModel didn't work
-            //reliably. In some cases the image wouldn't be painted for some reason.
-            //So a safe but slower approach was taken.
+            // Inverting the bitmap
+            // Note the previous approach with starting from an IndexColorModel didn't work
+            // reliably. In some cases the image wouldn't be painted for some reason.
+            // So a safe but slower approach was taken.
             invertBitmap(bufferData);
         }
-        
+
         /*
          * If we have an image mask we need to add an alpha channel to the data
          */
-        if(hasMask())
+        if (hasMask())
         {
-            byte[] map = new byte[] {(byte)0x00, (byte)0xff};
-            IndexColorModel  cm = new IndexColorModel(1, map.length, map, map, map, Transparency.OPAQUE);
-            raster = cm.createCompatibleWritableRaster( cols, rows );
-            bufferData = ((DataBufferByte)raster.getDataBuffer()).getData();
-
-            byte[] array = ((DataBufferByte)image.getData().getDataBuffer()).getData();
-            System.arraycopy( array, 0,bufferData, 0,
-                    (array.length<bufferData.length?array.length: bufferData.length) );
+            byte[] map = new byte[] { (byte) 0x00, (byte) 0xff };
+            IndexColorModel cm = new IndexColorModel(1, map.length, map, map, map, Transparency.OPAQUE);
+            raster = cm.createCompatibleWritableRaster(cols, rows);
+            bufferData = ((DataBufferByte) raster.getDataBuffer()).getData();
+
+            byte[] array = ((DataBufferByte) image.getData().getDataBuffer()).getData();
+            System.arraycopy(array, 0, bufferData, 0,
+                    (array.length < bufferData.length ? array.length : bufferData.length));
             BufferedImage indexed = new BufferedImage(cm, raster, false, null);
             image = indexed;
         }
-        
+
         return applyMasks(image);
     }
 
@@ -212,29 +212,27 @@ public class PDCcitt extends PDXObjectImage
     {
         for (int i = 0, c = bufferData.length; i < c; i++)
         {
-            bufferData[i] = (byte)(~bufferData[i] & 0xFF);
+            bufferData[i] = (byte) (~bufferData[i] & 0xFF);
         }
     }
 
     /**
      * This writes a tiff to out.
-     *
+     * 
      * {@inheritDoc}
      */
     public void write2OutputStream(OutputStream out) throws IOException
     {
         // We should use another format than TIFF to get rid of the TiffWrapper
-        InputStream data = new TiffWrapper(
-                getPDStream().getPartiallyFilteredStream( FAX_FILTERS ),
-                getCOSStream());
+        InputStream data = new TiffWrapper(getPDStream().getPartiallyFilteredStream(FAX_FILTERS), getCOSStream());
         IOUtils.copy(data, out);
     }
 
     /**
      * Extract the ccitt stream from the tiff file.
-     *
-     * @param raf  - TIFF File
-     * @param os   - Stream to write raw ccitt data two
+     * 
+     * @param raf - TIFF File
+     * @param os - Stream to write raw ccitt data two
      * @param parms - COSDictionary which the encoding parameters are added to
      * @throws IOException If there is an error reading/writing to/from the stream
      */
@@ -250,15 +248,15 @@ public class PDCcitt extends PDXObjectImage
             {
                 throw new IOException("Not a valid tiff file");
             }
-            //ensure that endianess is either M or I
+            // ensure that endianess is either M or I
             if (endianess != 'M' && endianess != 'I')
             {
                 throw new IOException("Not a valid tiff file");
             }
             int magicNumber = readshort(endianess, raf);
-            if( magicNumber != 42)
+            if (magicNumber != 42)
             {
-                throw new  IOException("Not a valid tiff file");
+                throw new IOException("Not a valid tiff file");
             }
 
             // Relocate to the first set of tags
@@ -266,7 +264,7 @@ public class PDCcitt extends PDXObjectImage
 
             int numtags = readshort(endianess, raf);
 
-            //    The number 50 is somewhat arbitary, it just stops us load up junk from somewhere and tramping on
+            // The number 50 is somewhat arbitary, it just stops us load up junk from somewhere and tramping on
             if (numtags > 50)
             {
                 throw new IOException("Not a valid tiff file");
@@ -277,11 +275,11 @@ public class PDCcitt extends PDXObjectImage
             // The only parm which might change as a result of other options is K, so
             // We'll deal with that as a special;
 
-            int k=-1000; // Default Non CCITT compression
-            int dataoffset=0;
-            int datalength=0;
+            int k = -1000; // Default Non CCITT compression
+            int dataoffset = 0;
+            int datalength = 0;
 
-            for (int i=0; i < numtags; i++)
+            for (int i = 0; i < numtags; i++)
             {
                 int tag = readshort(endianess, raf);
                 int type = readshort(endianess, raf);
@@ -295,102 +293,102 @@ public class PDCcitt extends PDXObjectImage
                 {
                     switch (type)
                     {
-                        case 1:
-                        {
-                            val = val >> 24;
-                            break; // byte value
-                        }
-                        case 3:
-                        {
-                            val = val >> 16;
-                            break; // short value
-                        }
-                        case 4:
-                        {
-                            break; // long value
-                        }
-                        default:
-                        {
-                            //do nothing
-                        }
+                    case 1:
+                    {
+                        val = val >> 24;
+                        break; // byte value
                     }
-                }
-                switch (tag)
-                {
-                    case 256:
+                    case 3:
                     {
-                        parms.setInt(COSName.COLUMNS,val);
-                        break;
+                        val = val >> 16;
+                        break; // short value
                     }
-                    case 257:
+                    case 4:
                     {
-                        parms.setInt(COSName.ROWS,val);
-                        break;
+                        break; // long value
                     }
-                    case 259:
+                    default:
                     {
-                        if (val == 4)
-                        {
-                            k=-1;
-                        }
-                        if (val == 3)
-                        {
-                            k=0;
-                        }
-                        break;  // T6/T4 Compression
+                        // do nothing
                     }
-                    case 262:
+                    }
+                }
+                switch (tag)
+                {
+                case 256:
+                {
+                    parms.setInt(COSName.COLUMNS, val);
+                    break;
+                }
+                case 257:
+                {
+                    parms.setInt(COSName.ROWS, val);
+                    break;
+                }
+                case 259:
+                {
+                    if (val == 4)
                     {
-                        if (val == 1)
-                        {
-                            parms.setBoolean(COSName.BLACK_IS_1, true);
-                        }
-                        break;
+                        k = -1;
                     }
-                    case 273:
+                    if (val == 3)
                     {
-                        if (count == 1)
-                        {
-                            dataoffset=val;
-                        }
-                        break;
+                        k = 0;
                     }
-                    case 279:
+                    break; // T6/T4 Compression
+                }
+                case 262:
+                {
+                    if (val == 1)
                     {
-                        if (count == 1)
-                        {
-                            datalength=val;
-                        }
-                        break;
+                        parms.setBoolean(COSName.BLACK_IS_1, true);
                     }
-                    case 292:
+                    break;
+                }
+                case 273:
+                {
+                    if (count == 1)
                     {
-                        if (val == 1)
-                        {
-                            k=50;  // T4 2D - arbitary K value
-                        }
-                        break;
+                        dataoffset = val;
                     }
-                    case 324:
+                    break;
+                }
+                case 279:
+                {
+                    if (count == 1)
                     {
-                        if (count == 1)
-                        {
-                            dataoffset=val;
-                        }
-                        break;
+                        datalength = val;
+                    }
+                    break;
+                }
+                case 292:
+                {
+                    if (val == 1)
+                    {
+                        k = 50; // T4 2D - arbitary K value
                     }
-                    case 325:
+                    break;
+                }
+                case 324:
+                {
+                    if (count == 1)
                     {
-                        if (count == 1)
-                        {
-                            datalength=val;
-                        }
-                        break;
+                        dataoffset = val;
                     }
-                    default:
+                    break;
+                }
+                case 325:
+                {
+                    if (count == 1)
                     {
-                        //do nothing
+                        datalength = val;
                     }
+                    break;
+                }
+                default:
+                {
+                    // do nothing
+                }
                 }
             }
 
@@ -403,16 +401,16 @@ public class PDCcitt extends PDXObjectImage
                 throw new IOException("First image in tiff is not a single tile/strip");
             }
 
-            parms.setInt(COSName.K,k);
+            parms.setInt(COSName.K, k);
 
             raf.seek(dataoffset);
 
             byte[] buf = new byte[8192];
             int amountRead = -1;
-            while( (amountRead = raf.read( buf,0, Math.min(8192,datalength) )) > 0 )
+            while ((amountRead = raf.read(buf, 0, Math.min(8192, datalength))) > 0)
             {
                 datalength -= amountRead;
-                os.write( buf, 0, amountRead );
+                os.write(buf, 0, amountRead);
             }
 
         }
@@ -440,25 +438,23 @@ public class PDCcitt extends PDXObjectImage
         return (raf.read() << 24) | (raf.read() << 16) | (raf.read() << 8) | raf.read();
     }
 
-
     /**
-     * Extends InputStream to wrap the data from the CCITT Fax with a suitable TIFF Header.
-     * For details see www.tiff.org, which contains useful information including pointers to the
-     * TIFF 6.0 Specification
-     *
+     * Extends InputStream to wrap the data from the CCITT Fax with a suitable TIFF Header. For details see
+     * www.tiff.org, which contains useful information including pointers to the TIFF 6.0 Specification
+     * 
      */
     private class TiffWrapper extends InputStream
     {
 
-        private int currentOffset;     // When reading, where in the tiffheader are we.
-        private byte[] tiffheader;      // Byte array to store tiff header data
+        private int currentOffset; // When reading, where in the tiffheader are we.
+        private byte[] tiffheader; // Byte array to store tiff header data
         private InputStream datastream; // Original InputStream
 
         private TiffWrapper(InputStream rawstream, COSDictionary options)
         {
-                buildHeader(options);
-                currentOffset=0;
-                datastream = rawstream;
+            buildHeader(options);
+            currentOffset = 0;
+            datastream = rawstream;
         }
 
         // Implement basic methods from InputStream
@@ -469,6 +465,7 @@ public class PDCcitt extends PDXObjectImage
         {
             return false;
         }
+
         /**
          * {@inheritDoc}
          */
@@ -479,7 +476,7 @@ public class PDCcitt extends PDXObjectImage
 
         /**
          * For simple read, take a byte from the tiffheader array or pass through.
-         *
+         * 
          * {@inheritDoc}
          */
         public int read() throws IOException
@@ -492,9 +489,9 @@ public class PDCcitt extends PDXObjectImage
         }
 
         /**
-         * For read methods only return as many bytes as we have left in the header
-         * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.
-         *
+         * For read methods only return as many bytes as we have left in the header if we've exhausted the header, pass
+         * through to the InputStream of the raw CCITT data.
+         * 
          * {@inheritDoc}
          */
         public int read(byte[] data) throws IOException
@@ -516,10 +513,10 @@ public class PDCcitt extends PDXObjectImage
         }
 
         /**
-         * For read methods only return as many bytes as we have left in the header
-         * if we've exhausted the header, pass through to the InputStream of the raw CCITT data.
-         *
-         *  {@inheritDoc}
+         * For read methods only return as many bytes as we have left in the header if we've exhausted the header, pass
+         * through to the InputStream of the raw CCITT data.
+         * 
+         * {@inheritDoc}
          */
         public int read(byte[] data, int off, int len) throws IOException
         {
@@ -535,14 +532,14 @@ public class PDCcitt extends PDXObjectImage
             }
             else
             {
-                return datastream.read(data,off,len);
+                return datastream.read(data, off, len);
             }
         }
 
         /**
-         * When skipping if any header data not yet read, only allow to skip what we've in the buffer
-         * Otherwise just pass through.
-         *
+         * When skipping if any header data not yet read, only allow to skip what we've in the buffer Otherwise just
+         * pass through.
+         * 
          * {@inheritDoc}
          */
         public long skip(long n) throws IOException
@@ -560,12 +557,10 @@ public class PDCcitt extends PDXObjectImage
         }
 
         // Static data for the beginning of the TIFF header
-        private final byte[] basicHeader = {
-                'I','I',42,0,8,0,0,0,       // File introducer and pointer to first IFD
-                0,0};                       // Number of tags start with two
-
+        private final byte[] basicHeader = { 'I', 'I', 42, 0, 8, 0, 0, 0, // File introducer and pointer to first IFD
+                0, 0 }; // Number of tags start with two
 
-        private int additionalOffset;      // Offset in header to additional data
+        private int additionalOffset; // Offset in header to additional data
 
         // Builds up the tiffheader based on the options passed through.
         private void buildHeader(COSDictionary options)
@@ -573,16 +568,16 @@ public class PDCcitt extends PDXObjectImage
 
             final int numOfTags = 10; // The maximum tags we'll fill
             final int maxAdditionalData = 24; // The maximum amount of additional data
-                                                // outside the IFDs. (bytes)
+                                              // outside the IFDs. (bytes)
 
             // The length of the header will be the length of the basic header (10)
             // plus 12 bytes for each IFD, 4 bytes as a pointer to the next IFD (will be 0)
             // plus the length of the additional data
 
-            int ifdSize = 10 + (12 * numOfTags ) + 4;
+            int ifdSize = 10 + (12 * numOfTags) + 4;
             tiffheader = new byte[ifdSize + maxAdditionalData];
-            java.util.Arrays.fill(tiffheader,(byte)0);
-            System.arraycopy(basicHeader,0,tiffheader,0,basicHeader.length);
+            java.util.Arrays.fill(tiffheader, (byte) 0);
+            System.arraycopy(basicHeader, 0, tiffheader, 0, basicHeader.length);
 
             // Additional data outside the IFD starts after the IFD's and pointer to the next IFD (0)
             additionalOffset = ifdSize;
@@ -604,26 +599,26 @@ public class PDCcitt extends PDXObjectImage
             }
             COSBase dicOrArrayParms = options.getDictionaryObject(COSName.DECODE_PARMS);
             COSDictionary decodeParms = null;
-            if( dicOrArrayParms instanceof COSDictionary )
+            if (dicOrArrayParms instanceof COSDictionary)
             {
-                decodeParms = (COSDictionary)dicOrArrayParms;
+                decodeParms = (COSDictionary) dicOrArrayParms;
             }
             else
             {
-                COSArray parmsArray = (COSArray)dicOrArrayParms;
-                if( parmsArray.size() == 1 )
+                COSArray parmsArray = (COSArray) dicOrArrayParms;
+                if (parmsArray.size() == 1)
                 {
-                    decodeParms = (COSDictionary)parmsArray.getObject( 0 );
+                    decodeParms = (COSDictionary) parmsArray.getObject(0);
                 }
                 else
                 {
-                    //else find the first dictionary with Row/Column info and use that.
-                    for( int i=0; i<parmsArray.size() && decodeParms == null; i++ )
+                    // else find the first dictionary with Row/Column info and use that.
+                    for (int i = 0; i < parmsArray.size() && decodeParms == null; i++)
                     {
-                        COSDictionary dic = (COSDictionary)parmsArray.getObject( i );
-                        if (dic != null &&
-                                ( dic.getDictionaryObject(COSName.COLUMNS) != null ||
-                                        dic.getDictionaryObject(COSName.ROWS) != null))
+                        COSDictionary dic = (COSDictionary) parmsArray.getObject(i);
+                        if (dic != null
+                                && (dic.getDictionaryObject(COSName.COLUMNS) != null || dic
+                                        .getDictionaryObject(COSName.ROWS) != null))
                         {
                             decodeParms = dic;
                         }
@@ -639,15 +634,15 @@ public class PDCcitt extends PDXObjectImage
                 {
                     blackis1 = 1;
                 }
-                int k = decodeParms.getInt(COSName.K, 0);  // Mandatory parm
+                int k = decodeParms.getInt(COSName.K, 0); // Mandatory parm
                 if (k < 0)
                 {
-                    //T6
+                    // T6
                     comptype = 4;
                 }
                 if (k > 0)
                 {
-                    //T4 2D
+                    // T4 2D
                     comptype = 3;
                     t4options = 1;
                 }
@@ -666,7 +661,7 @@ public class PDCcitt extends PDXObjectImage
 
             addTag(256, cols); // Columns
             addTag(257, rows); // Rows
-            addTag(259, comptype);    // T6
+            addTag(259, comptype); // T6
             addTag(262, blackis1); // Photometric Interpretation
             addTag(273, tiffheader.length); // Offset to start of image data - updated below
             addTag(279, options.getInt(COSName.LENGTH)); // Length of image data
@@ -681,52 +676,51 @@ public class PDCcitt extends PDXObjectImage
 
         /* Tiff types 1 = byte, 2=ascii, 3=short, 4=ulong 5=rational */
 
-        private void addTag(int tag,long value)
+        private void addTag(int tag, long value)
         {
-        // Adds a tag of type 4 (ulong)
+            // Adds a tag of type 4 (ulong)
             int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=4;  // Type Long
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(value & 0xff);
-            tiffheader[offset+9]=(byte)((value>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((value>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((value>>24) & 0xff);
+            int offset = (count - 1) * 12 + 10;
+            tiffheader[offset] = (byte) (tag & 0xff);
+            tiffheader[offset + 1] = (byte) ((tag >> 8) & 0xff);
+            tiffheader[offset + 2] = 4; // Type Long
+            tiffheader[offset + 4] = 1; // One Value
+            tiffheader[offset + 8] = (byte) (value & 0xff);
+            tiffheader[offset + 9] = (byte) ((value >> 8) & 0xff);
+            tiffheader[offset + 10] = (byte) ((value >> 16) & 0xff);
+            tiffheader[offset + 11] = (byte) ((value >> 24) & 0xff);
         }
 
         private void addTag(int tag, short value)
         {
             // Adds a tag of type 3 (short)
             int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=3;  // Type Short
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(value & 0xff);
-            tiffheader[offset+9]=(byte)((value>>8) & 0xff);
+            int offset = (count - 1) * 12 + 10;
+            tiffheader[offset] = (byte) (tag & 0xff);
+            tiffheader[offset + 1] = (byte) ((tag >> 8) & 0xff);
+            tiffheader[offset + 2] = 3; // Type Short
+            tiffheader[offset + 4] = 1; // One Value
+            tiffheader[offset + 8] = (byte) (value & 0xff);
+            tiffheader[offset + 9] = (byte) ((value >> 8) & 0xff);
         }
 
         private void addTag(int tag, String value)
         {
             // Adds a tag of type 2 (ascii)
             int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=2;  // Type Ascii
+            int offset = (count - 1) * 12 + 10;
+            tiffheader[offset] = (byte) (tag & 0xff);
+            tiffheader[offset + 1] = (byte) ((tag >> 8) & 0xff);
+            tiffheader[offset + 2] = 2; // Type Ascii
             int len = value.length() + 1;
-            tiffheader[offset+4]=(byte)(len & 0xff);
-            tiffheader[offset+8]=(byte)(additionalOffset & 0xff);
-            tiffheader[offset+9]=(byte)((additionalOffset>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((additionalOffset>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((additionalOffset>>24) & 0xff);
+            tiffheader[offset + 4] = (byte) (len & 0xff);
+            tiffheader[offset + 8] = (byte) (additionalOffset & 0xff);
+            tiffheader[offset + 9] = (byte) ((additionalOffset >> 8) & 0xff);
+            tiffheader[offset + 10] = (byte) ((additionalOffset >> 16) & 0xff);
+            tiffheader[offset + 11] = (byte) ((additionalOffset >> 24) & 0xff);
             try
             {
-                System.arraycopy(value.getBytes("US-ASCII"), 0,
-                        tiffheader, additionalOffset, value.length());
+                System.arraycopy(value.getBytes("US-ASCII"), 0, tiffheader, additionalOffset, value.length());
             }
             catch (UnsupportedEncodingException e)
             {
@@ -739,23 +733,23 @@ public class PDCcitt extends PDXObjectImage
         {
             // Adds a tag of type 5 (rational)
             int count = ++tiffheader[8];
-            int offset = (count-1)*12 + 10;
-            tiffheader[offset]=(byte)(tag & 0xff);
-            tiffheader[offset+1]=(byte)((tag>>8) & 0xff);
-            tiffheader[offset+2]=5;  // Type Rational
-            tiffheader[offset+4]=1;  // One Value
-            tiffheader[offset+8]=(byte)(additionalOffset & 0xff);
-            tiffheader[offset+9]=(byte)((additionalOffset>>8) & 0xff);
-            tiffheader[offset+10]=(byte)((additionalOffset>>16) & 0xff);
-            tiffheader[offset+11]=(byte)((additionalOffset>>24) & 0xff);
-            tiffheader[additionalOffset++]=(byte) ((numerator) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>8) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>16) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((numerator>>24) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>8) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>16) & 0xFF);
-            tiffheader[additionalOffset++]=(byte) ((denominator>>24) & 0xFF);
+            int offset = (count - 1) * 12 + 10;
+            tiffheader[offset] = (byte) (tag & 0xff);
+            tiffheader[offset + 1] = (byte) ((tag >> 8) & 0xff);
+            tiffheader[offset + 2] = 5; // Type Rational
+            tiffheader[offset + 4] = 1; // One Value
+            tiffheader[offset + 8] = (byte) (additionalOffset & 0xff);
+            tiffheader[offset + 9] = (byte) ((additionalOffset >> 8) & 0xff);
+            tiffheader[offset + 10] = (byte) ((additionalOffset >> 16) & 0xff);
+            tiffheader[offset + 11] = (byte) ((additionalOffset >> 24) & 0xff);
+            tiffheader[additionalOffset++] = (byte) ((numerator) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((numerator >> 8) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((numerator >> 16) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((numerator >> 24) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((denominator) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((denominator >> 8) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((denominator >> 16) & 0xFF);
+            tiffheader[additionalOffset++] = (byte) ((denominator >> 24) & 0xFF);
         }
     }
 }
