diff --git a/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/image/LosslessFactoryTest.java b/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/image/LosslessFactoryTest.java
index 00979e9e0f..5b5082ebc8 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/image/LosslessFactoryTest.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/pdmodel/graphics/image/LosslessFactoryTest.java
@@ -15,7 +15,6 @@
  */
 package org.apache.pdfbox.pdmodel.graphics.image;
 
-import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.Graphics2D;
@@ -154,114 +153,25 @@ public class LosslessFactoryTest extends TestCase
     }
 
     /**
-     * Tests ARGB LosslessFactoryTest#createFromImage(PDDocument document,
+     * Tests INT_ARGB LosslessFactoryTest#createFromImage(PDDocument document,
      * BufferedImage image) with BITMASK transparency
      *
      * @throws java.io.IOException
      */
-    public void testCreateLosslessFromImageBITMASK() throws IOException
+    public void testCreateLosslessFromImageBITMASK_INT_ARGB() throws IOException
     {
-        PDDocument document = new PDDocument();
-        
-        int width = 256;
-        int height = 256;
-
-        // create an ARGB image
-        BufferedImage argbImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
-        
-        // from there, create an image with Transparency.BITMASK
-        Graphics2D g = argbImage.createGraphics();
-        GraphicsConfiguration gc = g.getDeviceConfiguration();
-        argbImage = gc.createCompatibleImage(width, height, Transparency.BITMASK);
-        g.dispose();
-        // create a red rectangle
-        g = argbImage.createGraphics();
-        g.setColor(Color.red);
-        g.fillRect(0, 0, width, height);
-        g.dispose();
-
-        Random random = new Random();
-        random.setSeed(12345);
-        // create a transparency cross: only pixels in the 
-        // interval max/2 - max/8 ... max/2 + max/8 will be visible
-        int startX = width / 2 - width / 8;
-        int endX   = width / 2 + width / 8;
-        int startY = height / 2 - height / 8;
-        int endY   = height / 2 + height / 8;
-        for (int x = 0; x < width; ++x)
-        {
-            for (int y = 0; y < height; ++y)
-            {
-                // create pseudorandom alpha values, but those within the cross
-                // must be >= 128 and those outside must be < 128
-                int alpha;
-                if ((x >= startX && x <= endX) || y >= startY && y <= endY)
-                {
-                    alpha = 128 + (int) (random.nextFloat() * 127);
-                    assertTrue(alpha >= 128);
-                    argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));
-                    assertEquals(255, argbImage.getRGB(x, y) >>> 24);
-                }
-                else
-                {
-                    alpha = (int) (random.nextFloat() * 127);
-                    assertTrue(alpha < 128);
-                    argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));
-                    assertEquals(0, argbImage.getRGB(x, y) >>> 24);
-                }
-            }
-        }
-
-        PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);
-        validate(ximage, 8, width, height, "png", PDDeviceRGB.INSTANCE.getName());
-        checkIdent(argbImage, ximage.getImage());
-        checkIdentRGB(argbImage, SampledImageReader.getRGBImage(ximage, null));
-
-        assertNotNull(ximage.getSoftMask());
-        validate(ximage.getSoftMask(), 1, width, height, "png", PDDeviceGray.INSTANCE.getName());
-        assertEquals(2, colorCount(ximage.getSoftMask().getImage()));
-
-        // check whether the mask is a b/w cross
-        BufferedImage maskImage = ximage.getSoftMask().getImage();
-        assertEquals(Transparency.OPAQUE, maskImage.getTransparency());
-        for (int x = 0; x < width; ++x)
-        {
-            for (int y = 0; y < height; ++y)
-            {
-                if ((x >= startX && x <= endX) || y >= startY && y <= endY)
-                {
-                    assertEquals(0xFFFFFF, maskImage.getRGB(x, y) & 0xFFFFFF);
-                }
-                else
-                {
-                    assertEquals(0, maskImage.getRGB(x, y) & 0xFFFFFF);
-                }
-            }
-        }
-        
-        // This part isn't really needed because this test doesn't break
-        // if the mask has the wrong colorspace (PDFBOX-2057), but it is still useful
-        // if something goes wrong in the future and we want to have a PDF to open.
+        doBitmaskTransparencyTest(BufferedImage.TYPE_INT_ARGB, "bitmaskintargb.pdf");
+    }
 
-        // Create a rectangle
-        BufferedImage rectImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
-        g = rectImage.createGraphics();
-        g.setColor(Color.blue);
-        g.fillRect(0, 0, width, height);
-        g.dispose();
-        PDImageXObject ximage2 = LosslessFactory.createFromImage(document, rectImage);
-        
-        PDPage page = new PDPage();
-        document.addPage(page);
-        PDPageContentStream contentStream = new PDPageContentStream(document, page, true, false);
-        contentStream.drawXObject(ximage2, 150, 300, ximage2.getWidth(), ximage2.getHeight());
-        contentStream.drawXObject(ximage, 150, 300, ximage.getWidth(), ximage.getHeight());
-        contentStream.close();
-        File pdfFile = new File(testResultsDir, "bitmaskargb.pdf");
-        document.save(pdfFile);
-        document.close();
-        document = PDDocument.loadNonSeq(pdfFile, null);
-        document.close();
+    /**
+     * Tests 4BYTE_ABGR LosslessFactoryTest#createFromImage(PDDocument document,
+     * BufferedImage image) with BITMASK transparency
+     *
+     * @throws java.io.IOException
+     */
+    public void testCreateLosslessFromImageBITMASK4BYTE_ABGR() throws IOException
+    {
+        doBitmaskTransparencyTest(BufferedImage.TYPE_INT_ARGB, "bitmask4babgr.pdf");
     }
 
     /**
@@ -290,7 +200,7 @@ public class LosslessFactoryTest extends TestCase
                 argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | ((y / 10 * 10) << 24));
             }
         }
-        
+
         PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);
         validate(ximage, 8, w, h, "png", PDDeviceRGB.INSTANCE.getName());
         checkIdent(argbImage, ximage.getImage());
@@ -342,6 +252,7 @@ public class LosslessFactoryTest extends TestCase
             }
         }
     }
+
     /**
      * Check whether the RGB part of images are identical.
      *
@@ -369,4 +280,108 @@ public class LosslessFactoryTest extends TestCase
         }
     }
 
+    private void doBitmaskTransparencyTest(int imageType, String pdfFilename) throws IOException
+    {
+        PDDocument document = new PDDocument();
+
+        int width = 256;
+        int height = 256;
+
+        // create an ARGB image
+        BufferedImage argbImage = new BufferedImage(width, height, imageType);
+
+        // from there, create an image with Transparency.BITMASK
+        Graphics2D g = argbImage.createGraphics();
+        GraphicsConfiguration gc = g.getDeviceConfiguration();
+        argbImage = gc.createCompatibleImage(width, height, Transparency.BITMASK);
+        g.dispose();
+        // create a red rectangle
+        g = argbImage.createGraphics();
+        g.setColor(Color.red);
+        g.fillRect(0, 0, width, height);
+        g.dispose();
+
+        Random random = new Random();
+        random.setSeed(12345);
+        // create a transparency cross: only pixels in the 
+        // interval max/2 - max/8 ... max/2 + max/8 will be visible
+        int startX = width / 2 - width / 8;
+        int endX = width / 2 + width / 8;
+        int startY = height / 2 - height / 8;
+        int endY = height / 2 + height / 8;
+        for (int x = 0; x < width; ++x)
+        {
+            for (int y = 0; y < height; ++y)
+            {
+                // create pseudorandom alpha values, but those within the cross
+                // must be >= 128 and those outside must be < 128
+                int alpha;
+                if ((x >= startX && x <= endX) || y >= startY && y <= endY)
+                {
+                    alpha = 128 + (int) (random.nextFloat() * 127);
+                    assertTrue(alpha >= 128);
+                    argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));
+                    assertEquals(255, argbImage.getRGB(x, y) >>> 24);
+                }
+                else
+                {
+                    alpha = (int) (random.nextFloat() * 127);
+                    assertTrue(alpha < 128);
+                    argbImage.setRGB(x, y, (argbImage.getRGB(x, y) & 0xFFFFFF) | (alpha << 24));
+                    assertEquals(0, argbImage.getRGB(x, y) >>> 24);
+                }
+            }
+        }
+
+        PDImageXObject ximage = LosslessFactory.createFromImage(document, argbImage);
+        validate(ximage, 8, width, height, "png", PDDeviceRGB.INSTANCE.getName());
+        checkIdent(argbImage, ximage.getImage());
+        checkIdentRGB(argbImage, SampledImageReader.getRGBImage(ximage, null));
+
+        assertNotNull(ximage.getSoftMask());
+        validate(ximage.getSoftMask(), 1, width, height, "png", PDDeviceGray.INSTANCE.getName());
+        assertEquals(2, colorCount(ximage.getSoftMask().getImage()));
+
+        // check whether the mask is a b/w cross
+        BufferedImage maskImage = ximage.getSoftMask().getImage();
+        assertEquals(Transparency.OPAQUE, maskImage.getTransparency());
+        for (int x = 0; x < width; ++x)
+        {
+            for (int y = 0; y < height; ++y)
+            {
+                if ((x >= startX && x <= endX) || y >= startY && y <= endY)
+                {
+                    assertEquals(0xFFFFFF, maskImage.getRGB(x, y) & 0xFFFFFF);
+                }
+                else
+                {
+                    assertEquals(0, maskImage.getRGB(x, y) & 0xFFFFFF);
+                }
+            }
+        }
+
+        // This part isn't really needed because this test doesn't break
+        // if the mask has the wrong colorspace (PDFBOX-2057), but it is still useful
+        // if something goes wrong in the future and we want to have a PDF to open.
+        // Create a rectangle
+        BufferedImage rectImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
+        g = rectImage.createGraphics();
+        g.setColor(Color.blue);
+        g.fillRect(0, 0, width, height);
+        g.dispose();
+        PDImageXObject ximage2 = LosslessFactory.createFromImage(document, rectImage);
+
+        PDPage page = new PDPage();
+        document.addPage(page);
+        PDPageContentStream contentStream = new PDPageContentStream(document, page, true, false);
+        contentStream.drawXObject(ximage2, 150, 300, ximage2.getWidth(), ximage2.getHeight());
+        contentStream.drawXObject(ximage, 150, 300, ximage.getWidth(), ximage.getHeight());
+        contentStream.close();
+        File pdfFile = new File(testResultsDir, pdfFilename);
+        document.save(pdfFile);
+        document.close();
+        document = PDDocument.loadNonSeq(pdfFile, null);
+        document.close();
+    }
+
 }
