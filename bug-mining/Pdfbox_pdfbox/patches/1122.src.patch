diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
index 206302e688..385f6ae6d0 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSStream.java
@@ -33,6 +33,8 @@ import org.apache.pdfbox.io.RandomAccess;
 import org.apache.pdfbox.io.RandomAccessBuffer;
 import org.apache.pdfbox.io.RandomAccessFileInputStream;
 import org.apache.pdfbox.io.RandomAccessFileOutputStream;
+import org.apache.pdfbox.io.RandomAccessRead;
+import org.apache.pdfbox.io.RandomAccessReadWrapper;
 import org.apache.pdfbox.io.ScratchFile;
 
 /**
@@ -126,34 +128,63 @@ public class COSStream extends COSDictionary implements Closeable
      *
      * @return the bytes of the physical (encoded) stream
      *
-     * @throws IOException when encoding/decoding causes an exception
+     * @throws IOException when encoding causes an exception
      */
     public InputStream getFilteredStream() throws IOException
     {
+        checkFilteredBuffer();
         InputStream retval;
-        if (getFilteredBuffer() != null && getFilteredBuffer().isClosed())
+        if (filteredStream != null)
         {
-            throw new IOException("COSStream has been closed and cannot be read. " +
-                                  "Perhaps its enclosing PDDocument has been closed?");
+            long position = filteredStream.getPosition();
+            long length = filteredStream.getLengthWritten();
+            retval = new BufferedInputStream(
+                    new RandomAccessFileInputStream( getFilteredBuffer(), position, length ), BUFFER_SIZE );
         }
-
-        if( filteredStream == null )
+        else
         {
-            doEncode();
+            retval = new ByteArrayInputStream( new byte[0] );
         }
+        return retval;
+    }
+
+    /**
+     * This will get the data with all of the filters applied.
+     *
+     * @return the data of the physical (encoded) stream
+     *
+     * @throws IOException when encoding causes an exception
+     */
+    public RandomAccessRead getFilteredRandomAccess() throws IOException
+    {
+        checkFilteredBuffer();
+        RandomAccessRead retval;
         if (filteredStream != null)
         {
             long position = filteredStream.getPosition();
             long length = filteredStream.getLengthWritten();
-            retval = new BufferedInputStream(
-                    new RandomAccessFileInputStream( getFilteredBuffer(), position, length ), BUFFER_SIZE );
+            retval = new RandomAccessReadWrapper(getFilteredBuffer(), position, length );
         }
         else
         {
-            retval = new ByteArrayInputStream( new byte[0] );
+            retval = new RandomAccessBuffer();
         }
         return retval;
     }
+    
+    private void checkFilteredBuffer() throws IOException
+    {
+        if (getFilteredBuffer() != null && getFilteredBuffer().isClosed())
+        {
+            throw new IOException("COSStream has been closed and cannot be read. " +
+                                  "Perhaps its enclosing PDDocument has been closed?");
+        }
+
+        if( filteredStream == null )
+        {
+            doEncode();
+        }
+    }
 
     /**
      * This will get the length of the encoded stream.
@@ -176,36 +207,64 @@ public class COSStream extends COSDictionary implements Closeable
      *
      * @return the bytes of the logical (decoded) stream
      *
-     * @throws IOException when encoding/decoding causes an exception
+     * @throws IOException when decoding causes an exception
      */
     public InputStream getUnfilteredStream() throws IOException
     {
-        if (getUnfilteredBuffer() != null && getUnfilteredBuffer().isClosed())
+        checkUnfilteredBuffer();
+        InputStream retval;
+        if( unFilteredStream != null )
         {
-            throw new IOException("COSStream has been closed and cannot be read. " +
-                                "Perhaps its enclosing PDDocument has been closed?");
+            long position = unFilteredStream.getPosition();
+            long length = unFilteredStream.getLengthWritten();
+            retval = new BufferedInputStream(
+                    new RandomAccessFileInputStream( getUnfilteredBuffer(), position, length ), BUFFER_SIZE );
         }
-
-        InputStream retval;
-        if( unFilteredStream == null )
+        else
         {
-            doDecode();
+            retval = new ByteArrayInputStream( new byte[0] );
         }
+        return retval;
+    }
+
+    /**
+     * This will get the logical content with none of the filters.
+     *
+     * @return the bytes of the logical (decoded) stream
+     *
+     * @throws IOException when decoding causes an exception
+     */
+    public RandomAccessRead getUnfilteredRandomAccess() throws IOException
+    {
+        checkUnfilteredBuffer();
+        RandomAccessRead retval;
 
         if( unFilteredStream != null )
         {
             long position = unFilteredStream.getPosition();
             long length = unFilteredStream.getLengthWritten();
-            retval = new BufferedInputStream(
-                    new RandomAccessFileInputStream( getUnfilteredBuffer(), position, length ), BUFFER_SIZE );
+            retval = new RandomAccessReadWrapper( getUnfilteredBuffer(), position, length );
         }
         else
         {
-            retval = new ByteArrayInputStream( new byte[0] );
+            retval = new RandomAccessBuffer();
         }
         return retval;
     }
+    
+    private void checkUnfilteredBuffer() throws IOException
+    {
+        if (getUnfilteredBuffer() != null && getUnfilteredBuffer().isClosed())
+        {
+            throw new IOException("COSStream has been closed and cannot be read. " +
+                                "Perhaps its enclosing PDDocument has been closed?");
+        }
 
+        if( unFilteredStream == null )
+        {
+            doDecode();
+        }
+    }
     /**
      * Returns the repaired stream parameters dictionary.
      *
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/RandomAccessReadWrapper.java b/pdfbox/src/main/java/org/apache/pdfbox/io/RandomAccessReadWrapper.java
new file mode 100644
index 0000000000..4161dccdfe
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/io/RandomAccessReadWrapper.java
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.io;
+
+import java.io.IOException;
+
+/**
+ * A read only wrapper for a RandomAccessRead instance.
+ *
+ */
+public class RandomAccessReadWrapper implements RandomAccessRead
+{
+    private boolean isClosed;
+
+    private RandomAccessRead randomAccessInput;
+    private final long startPosition;
+    private final long inputLength;
+
+    /**
+     * Create a read only wrapper for a RandomAccessRead instance.
+     *
+     * @param input the RandomAccessRead instance to be read.
+     * @param offset offset to start reading at.
+     * @param length the total length of data to be read.
+     * @throws IOException if something went wrong while accessing the given RandomAccessRead.
+     */
+    public RandomAccessReadWrapper(RandomAccessRead input, long offset, long length) throws IOException
+    {
+        randomAccessInput = input;
+        startPosition = offset;
+        inputLength = length;
+        seek(0);
+    }
+
+    /**
+     * Ensure that the RandomAccessFile is not closed.
+     * 
+     * @throws IOException
+     */
+    private void checkClosed() throws IOException
+    {
+        if (isClosed)
+        {
+            throw new IOException("RandomAccessFile already closed");
+        }
+    }
+
+    /** Returns offset in file at which next byte would be read. */
+    @Override
+    public long getPosition() throws IOException
+    {
+        checkClosed();
+        return randomAccessInput.getPosition() + startPosition;
+    }
+
+    /**
+     * Seeks to new position. If new position is outside of current page the new page is either taken from cache or read
+     * from file and added to cache.
+     *
+     * @param newOffset the position to seek to.
+     * @throws java.io.IOException if something went wrong.
+     */
+    @Override
+    public void seek(final long newOffset) throws IOException
+    {
+        checkClosed();
+        randomAccessInput.seek(newOffset + startPosition);
+    }
+
+    @Override
+    public int read() throws IOException
+    {
+        checkClosed();
+        return randomAccessInput.read();
+    }
+
+    @Override
+    public int read(byte[] b) throws IOException
+    {
+        return read(b, 0, b.length);
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException
+    {
+        checkClosed();
+        return randomAccessInput.read(b, off, len);
+    }
+
+    @Override
+    public int available() throws IOException
+    {
+        return (int) Math.min(inputLength - getPosition(), Integer.MAX_VALUE);
+    }
+
+    @Override
+    public long length() throws IOException
+    {
+        return inputLength;
+    }
+
+    @Override
+    public void close() throws IOException
+    {
+        // don't close the underlying random access
+        isClosed = true;
+        randomAccessInput = null;
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        if (isClosed || randomAccessInput == null)
+        {
+            return true;
+        }
+        return randomAccessInput.isClosed();
+    }
+
+    @Override
+    public int peek() throws IOException
+    {
+        int result = read();
+        if (result != -1)
+        {
+            rewind(1);
+        }
+        return result;
+    }
+
+    @Override
+    public void rewind(int bytes) throws IOException
+    {
+        seek(getPosition() - bytes);
+    }
+
+    @Override
+    public byte[] readFully(int length) throws IOException
+    {
+        byte[] b = new byte[length];
+        int bytesRead = read(b);
+        while (bytesRead < length)
+        {
+            bytesRead += read(b, bytesRead, length - bytesRead);
+        }
+        return b;
+    }
+
+    @Override
+    public boolean isEOF() throws IOException
+    {
+        int peek = peek();
+        return peek == -1;
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSStreamArray.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSStreamArray.java
index b1cc8dbe42..04707a8508 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSStreamArray.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSStreamArray.java
@@ -21,7 +21,6 @@ import java.io.InputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.SequenceInputStream;
-
 import java.util.Vector;
 
 import org.apache.pdfbox.cos.COSArray;
@@ -30,6 +29,7 @@ import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.cos.ICOSVisitor;
+import org.apache.pdfbox.io.RandomAccessRead;
 
 /**
  * This will take an array of streams and sequence them together.
@@ -83,11 +83,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will get an object from this streams dictionary.
-     *
-     * @param key The key to the object.
-     *
-     * @return The dictionary object with the key or null if one does not exist.
+     * {@inheritDoc}
      */
     @Override
     public COSBase getItem( COSName key )
@@ -95,13 +91,8 @@ public class COSStreamArray extends COSStream
         return firstStream.getItem( key );
     }
 
-   /**
-     * This will get an object from this streams dictionary and dereference it
-     * if necessary.
-     *
-     * @param key The key to the object.
-     *
-     * @return The dictionary object with the key or null if one does not exist.
+    /**
+     * {@inheritDoc}
      */
     @Override
     public COSBase getDictionaryObject( COSName key )
@@ -129,11 +120,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will get the stream with all of the filters applied.
-     *
-     * @return the bytes of the physical (endoced) stream
-     *
-     * @throws IOException when encoding/decoding causes an exception
+     * {@inheritDoc}
      */
     @Override
     public InputStream getFilteredStream() throws IOException
@@ -142,11 +129,16 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will get the logical content stream with none of the filters.
-     *
-     * @return the bytes of the logical (decoded) stream
-     *
-     * @throws IOException when encoding/decoding causes an exception
+     * {@inheritDoc}
+     */
+    @Override
+    public RandomAccessRead getFilteredRandomAccess() throws IOException
+    {
+        throw new IOException( "Error: Not allowed to get filtered stream from array of streams." );
+    }
+
+    /**
+     * {@inheritDoc}
      */
     @Override
     public InputStream getUnfilteredStream() throws IOException
@@ -169,11 +161,17 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * visitor pattern double dispatch method.
-     *
-     * @param visitor The object to notify when visiting this object.
-     * @return any object, depending on the visitor implementation, or null
-     * @throws IOException if the output could not be written
+     * {@inheritDoc}
+     */
+    @Override
+    public RandomAccessRead getUnfilteredRandomAccess() throws IOException
+    {
+        // TODO
+        throw new IOException("Not yet implemented.");
+    }
+    
+    /**
+     * {@inheritDoc}
      */
     @Override
     public Object accept(ICOSVisitor visitor) throws IOException
@@ -183,13 +181,7 @@ public class COSStreamArray extends COSStream
 
 
     /**
-     * This will return the filters to apply to the byte stream
-     * the method will return.
-     * - null if no filters are to be applied
-     * - a COSName if one filter is to be applied
-     * - a COSArray containing COSNames if multiple filters are to be applied
-     *
-     * @return the COSBase object representing the filters
+     * {@inheritDoc}
      */
     @Override
     public COSBase getFilters()
@@ -198,13 +190,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will create a new stream for which filtered byte should be
-     * written to.  You probably don't want this but want to use the
-     * createUnfilteredStream, which is used to write raw bytes to.
-     *
-     * @return A stream that can be written to.
-     *
-     * @throws IOException If there is an error creating the stream.
+     * {@inheritDoc}
      */
     @Override
     public OutputStream createFilteredStream() throws IOException
@@ -213,15 +199,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will create a new stream for which filtered byte should be
-     * written to.  You probably don't want this but want to use the
-     * createUnfilteredStream, which is used to write raw bytes to.
-     *
-     * @param expectedLength An entry where a length is expected.
-     *
-     * @return A stream that can be written to.
-     *
-     * @throws IOException If there is an error creating the stream.
+     * {@inheritDoc}
      */
     @Override
     public OutputStream createFilteredStream( COSBase expectedLength ) throws IOException
@@ -230,11 +208,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * set the filters to be applied to the stream.
-     *
-     * @param filters The filters to set on this stream.
-     *
-     * @throws IOException If there is an error clearing the old filters.
+     * {@inheritDoc}
      */
     @Override
     public void setFilters(COSBase filters) throws IOException
@@ -245,11 +219,7 @@ public class COSStreamArray extends COSStream
     }
 
     /**
-     * This will create an output stream that can be written to.
-     *
-     * @return An output stream which raw data bytes should be written to.
-     *
-     * @throws IOException If there is an error creating the stream.
+     * {@inheritDoc}
      */
     @Override
     public OutputStream createUnfilteredStream() throws IOException
