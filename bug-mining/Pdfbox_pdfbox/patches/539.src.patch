diff --git a/pdfbox/pom.xml b/pdfbox/pom.xml
index 661fe8a578..b18d539c7e 100644
--- a/pdfbox/pom.xml
+++ b/pdfbox/pom.xml
@@ -83,7 +83,7 @@
             <groupId>net.java.dev.jai-imageio</groupId>
             <artifactId>jai-imageio-core-standalone</artifactId>
             <scope>test</scope>
-        </dependency>        
+        </dependency>
     </dependencies>
 
     <build>
@@ -148,6 +148,7 @@
                         <exclude>src/main/resources/org/apache/pdfbox/resources/afm/*</exclude>
                         <exclude>src/main/resources/org/apache/pdfbox/resources/cmap/*</exclude>
                         <exclude>src/main/resources/org/apache/pdfbox/resources/icc/*</exclude>
+                        <exclude>src/main/resources/META-INF/services/*</exclude>
                         <exclude>src/test/resources/input/rendering/*.ai</exclude>
                         <exclude>src/test/resources/output/*</exclude>
                         <exclude>release.properties</exclude>
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
index 06b80c25ca..0de1795e01 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
@@ -19,10 +19,11 @@ package org.apache.pdfbox.cos;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.charset.Charset;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
-import org.apache.pdfbox.encoding.PdfDocEncoding;
+import org.apache.pdfbox.encoding.PDFDocEncodingCharset;
 import org.apache.pdfbox.persistence.util.COSHEXTable;
 
 /**
@@ -89,8 +90,6 @@ public class COSString extends COSBase
      */
     private boolean forceHexForm = false;
 
-    private boolean isDictionary = false;
-
     /**
      * Constructor.
      */
@@ -103,11 +102,12 @@ public class COSString extends COSBase
      * Constructor.
      * 
      * @param isDictionaryValue determines if this string represents a dictionary
+     * @deprecated Not needed anymore. Use {@link #COSString()} instead. PDFBOX-2102
      */
+    @Deprecated
     public COSString(boolean isDictionaryValue)
     {
         this();
-        isDictionary = isDictionaryValue;
     }
 
     /**
@@ -287,51 +287,25 @@ public class COSString extends COSBase
             return this.str;
         }
         String retval;
-        String encoding = "ISO-8859-1";
+        Charset charset = PDFDocEncodingCharset.INSTANCE;
         byte[] data = getBytes();
         int start = 0;
         if (data.length > 2)
         {
             if (data[0] == (byte) 0xFF && data[1] == (byte) 0xFE)
             {
-                encoding = "UTF-16LE";
+                charset = Charset.forName("UTF-16LE");
                 start = 2;
             }
             else if (data[0] == (byte) 0xFE && data[1] == (byte) 0xFF)
             {
-                encoding = "UTF-16BE";
+                charset = Charset.forName("UTF-16BE");
                 start = 2;
             }
         }
-        try
-        {
-            if (isDictionary && encoding.equals("ISO-8859-1"))
-            {
-                byte[] tmp = getBytes();
-                PdfDocEncoding pde = new PdfDocEncoding();
-                StringBuilder sb = new StringBuilder(tmp.length);
-                for (byte b : tmp)
-                {
-                    final String character = pde.getCharacter((b + 256) % 256);
-                    if (character != null)
-                    {
-                        sb.append(character);
-                    }
-                }
-                retval = sb.toString();
-            }
-            else
-            {
-                retval = new String(getBytes(), start, data.length - start, encoding);
-            }
-        }
-        catch (IOException e)
-        {
-            // should never happen
-            LOG.error(e,e);
-            retval = new String(getBytes());
-        }
-        this.str = retval;
+
+        retval = new String(data, start, data.length - start, charset);
+        str = retval;
         return retval;
     }
 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
index 95db613854..26fd4adf12 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
@@ -281,7 +281,7 @@ public abstract class Encoding implements COSObjectable
         String name = getName(code);
         if (name != null)
         {
-            return getCharacter(getName(code));
+            return getCharacter(name);
         }
         return null;
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFBoxCharsetProvider.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFBoxCharsetProvider.java
new file mode 100644
index 0000000000..6824a65f2f
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFBoxCharsetProvider.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.encoding;
+
+import java.nio.charset.Charset;
+import java.nio.charset.spi.CharsetProvider;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * {@link CharsetProvider} implementation for publishing PDFBox's encodings.
+ * @version $Revision$
+ */
+public class PDFBoxCharsetProvider extends CharsetProvider
+{
+
+    private final Set<Charset> available = new java.util.HashSet<Charset>();
+    private final Map<String, Charset> map = new java.util.HashMap<String, Charset>();
+
+    /**
+     * Constructor.
+     */
+    public PDFBoxCharsetProvider()
+    {
+        available.add(PDFDocEncodingCharset.INSTANCE);
+        for (Charset cs : available)
+        {
+            map.put(cs.name(), cs);
+            for (String alias : cs.aliases())
+            {
+                map.put(alias, cs);
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public Iterator<Charset> charsets()
+    {
+        return Collections.unmodifiableSet(available).iterator();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public Charset charsetForName(String charsetName)
+    {
+        return map.get(charsetName);
+    }
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java
new file mode 100644
index 0000000000..d2cbdab56c
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.encoding;
+
+import java.nio.charset.Charset;
+
+/**
+ * {@link Charset} implementation for the "PDFDocEncoding" from the PDF specification.
+ * @version $Revision$
+ */
+public class PDFDocEncodingCharset extends SingleByteCharset
+{
+
+    /** Canonical name for the PDFDocEncoding. */
+    public static final String NAME = "PDFDocEncoding";
+
+    /** Singleton instance. */
+    public static final PDFDocEncodingCharset INSTANCE = new PDFDocEncodingCharset();
+
+    /**
+     * Creates a new "PDFDocEncoding" charset.
+     */
+    public PDFDocEncodingCharset()
+    {
+        super(NAME, null, createEncoding());
+    }
+
+    private static char[] createEncoding()
+    {
+        char[] encoding = new char[256];
+
+        //Initialize with basically ISO-8859-1
+        for (int i = 0; i < 255; i++)
+        {
+            encoding[i] = (char)i;
+        }
+        //...then do all deviations (based on the table in ISO 32000-1:2008)
+        //block 1
+        encoding[0x18] = '\u02D8'; //BREVE
+        encoding[0x19] = '\u02C7'; //CARON
+        encoding[0x1A] = '\u02C6'; //MODIFIER LETTER CIRCUMFLEX ACCENT
+        encoding[0x1B] = '\u02D9'; //DOT ABOVE
+        encoding[0x1C] = '\u02DD'; //DOUBLE ACUTE ACCENT
+        encoding[0x1D] = '\u02DB'; //OGONEK
+        encoding[0x1E] = '\u02DA'; //RING ABOVE
+        encoding[0x1F] = '\u02DC'; //SMALL TILDE
+        //block 2
+        encoding[0x7F] = REPLACEMENT_CHARACTER; //undefined
+        encoding[0x80] = '\u2022'; //BULLET
+        encoding[0x81] = '\u2020'; //DAGGER
+        encoding[0x82] = '\u2021'; //DOUBLE DAGGER
+        encoding[0x83] = '\u2026'; //HORIZONTAL ELLIPSIS
+        encoding[0x84] = '\u2014'; //EM DASH
+        encoding[0x85] = '\u2013'; //EN DASH
+        encoding[0x86] = '\u0192'; //LATIN SMALL LETTER SCRIPT F
+        encoding[0x87] = '\u2044'; //FRACTION SLASH (solidus)
+        encoding[0x88] = '\u2039'; //SINGLE LEFT-POINTING ANGLE QUOTATION MARK
+        encoding[0x89] = '\u203A'; //SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
+        encoding[0x8A] = '\u2212'; //MINUS SIGN
+        encoding[0x8B] = '\u2030'; //PER MILLE SIGN
+        encoding[0x8C] = '\u201E'; //DOUBLE LOW-9 QUOTATION MARK (quotedblbase)
+        encoding[0x8D] = '\u201C'; //LEFT DOUBLE QUOTATION MARK (double quote left)
+        encoding[0x8E] = '\u201D'; //RIGHT DOUBLE QUOTATION MARK (quotedblright)
+        encoding[0x8F] = '\u2018'; //LEFT SINGLE QUOTATION MARK (quoteleft)
+        encoding[0x90] = '\u2019'; //RIGHT SINGLE QUOTATION MARK (quoteright)
+        encoding[0x91] = '\u201A'; //SINGLE LOW-9 QUOTATION MARK (quotesinglbase)
+        encoding[0x92] = '\u2122'; //TRADE MARK SIGN
+        encoding[0x93] = '\uFB01'; //LATIN SMALL LIGATURE FI
+        encoding[0x94] = '\uFB02'; //LATIN SMALL LIGATURE FL
+        encoding[0x95] = '\u0141'; //LATIN CAPITAL LETTER L WITH STROKE
+        encoding[0x96] = '\u0152'; //LATIN CAPITAL LIGATURE OE
+        encoding[0x97] = '\u0160'; //LATIN CAPITAL LETTER S WITH CARON
+        encoding[0x98] = '\u0178'; //LATIN CAPITAL LETTER Y WITH DIAERESIS
+        encoding[0x99] = '\u017D'; //LATIN CAPITAL LETTER Z WITH CARON
+        encoding[0x9A] = '\u0131'; //LATIN SMALL LETTER DOTLESS I
+        encoding[0x9B] = '\u0142'; //LATIN SMALL LETTER L WITH STROKE
+        encoding[0x9C] = '\u0153'; //LATIN SMALL LIGATURE OE
+        encoding[0x9D] = '\u0161'; //LATIN SMALL LETTER S WITH CARON
+        encoding[0x9E] = '\u017E'; //LATIN SMALL LETTER Z WITH CARON
+        encoding[0x9F] = REPLACEMENT_CHARACTER; //undefined
+        encoding[0xA0] = '\u20AC'; //EURO SIGN
+        //end of deviations
+        return encoding;
+    }
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java
new file mode 100644
index 0000000000..02074295a8
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java
@@ -0,0 +1,198 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.encoding;
+
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
+
+/**
+ * {@link Charset} implementation for the single-byte encodings.
+ * @version $Revision$
+ */
+public class SingleByteCharset extends Charset
+{
+
+    /** Unicode replacement character 0xFFFD. */
+    protected static final char REPLACEMENT_CHARACTER = '\uFFFD';
+
+    private final char[] toUnicodeMap;
+    private byte[][] toByteMap;
+
+    /**
+     * Creates a new single-byte charset using an array of unicode characters.
+     * @param canonicalName the canonical name
+     * @param aliases An array of this charset's aliases, or null if it has no aliases
+     * @param toUnicodeMap the array of unicode characters (may have a maximum of 256 characters,
+     *          first character must be 0x0000)
+     */
+    protected SingleByteCharset(String canonicalName, String[] aliases, char[] toUnicodeMap)
+    {
+        super(canonicalName, aliases);
+        if (toUnicodeMap.length > 256)
+        {
+            throw new IllegalArgumentException("Single-byte encodings may have at most 256 characters.");
+        }
+        //Copy array so it cannot be changed accidentally from the outside
+        this.toUnicodeMap = new char[256];
+        System.arraycopy(toUnicodeMap, 0, this.toUnicodeMap, 0, toUnicodeMap.length);
+        //build the inverse lookup table
+        initInverseMap();
+    }
+
+    private void initInverseMap()
+    {
+        toByteMap = new byte[256][];
+        if (toUnicodeMap[0] != '\u0000')
+        {
+            throw new IllegalArgumentException("First character in map must be a NUL (0x0000) character.");
+            //because we're using 0x00 for encoding otherwise unmapped characters
+        }
+
+        //we're building a kind of sparse lookup table in which not all subranges are covered.
+        for (int i = 1, len = toUnicodeMap.length; i < len; i++)
+        {
+            char ch = toUnicodeMap[i];
+            if (ch == REPLACEMENT_CHARACTER)
+            {
+                continue; //skip
+            }
+            int upper = ch >> 8;
+            int lower = ch & 0xFF;
+            if (upper > 0xFF)
+            {
+                throw new IllegalArgumentException("Not a compatible character: "
+                        + ch + " (" + Integer.toHexString(ch) + ")");
+            }
+            byte[] map = toByteMap[upper];
+            if (map == null)
+            {
+                map = new byte[256];
+                toByteMap[upper] = map;
+            }
+            map[lower] = (byte)(i & 0xFF);
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean contains(Charset cs)
+    {
+        return (cs.getClass() == getClass());
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public CharsetDecoder newDecoder()
+    {
+        return new Decoder();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public CharsetEncoder newEncoder()
+    {
+        return new Encoder();
+    }
+
+    /** The decoder. */
+    private class Decoder extends CharsetDecoder
+    {
+
+        protected Decoder()
+        {
+            super(SingleByteCharset.this, 1, 1);
+        }
+
+        @Override
+        protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out)
+        {
+            while (in.hasRemaining())
+            {
+                byte b = in.get();
+                char ch;
+
+                if (!out.hasRemaining())
+                {
+                    in.position(in.position() - 1);
+                    return CoderResult.OVERFLOW;
+                }
+                ch = toUnicodeMap[b & 0xFF];
+                if (ch == REPLACEMENT_CHARACTER)
+                {
+                    return CoderResult.unmappableForLength(1);
+                }
+                out.put(ch);
+            }
+            return CoderResult.UNDERFLOW;
+        }
+
+    }
+
+    /** The encoder. */
+    private class Encoder extends CharsetEncoder
+    {
+
+        protected Encoder()
+        {
+            super(SingleByteCharset.this, 1, 1);
+        }
+
+        @Override
+        protected CoderResult encodeLoop(CharBuffer in, ByteBuffer out)
+        {
+            while (in.hasRemaining())
+            {
+                int ch = in.get();
+
+                if (!out.hasRemaining())
+                {
+                    in.position(in.position() - 1);
+                    return CoderResult.OVERFLOW;
+                }
+
+                int upper = ch >> 8;
+                int lower = ch & 0xFF;
+                if (upper > 0xFF)
+                {
+                    in.position(in.position() - 1);
+                    return CoderResult.unmappableForLength(1);
+                }
+                byte[] map = toByteMap[upper];
+                if (map == null)
+                {
+                    in.position(in.position() - 1);
+                    return CoderResult.unmappableForLength(1);
+                }
+                byte b = map[lower];
+                if (b == 0x00)
+                {
+                    in.position(in.position() - 1);
+                    return CoderResult.unmappableForLength(1);
+                }
+
+                out.put(b);
+            }
+            return CoderResult.UNDERFLOW;
+        }
+
+    }
+
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
index 8545b8042f..d15f4350d3 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
@@ -47,7 +47,7 @@ import org.apache.pdfbox.persistence.util.COSObjectKey;
  * PDFParser and the COSStreamParser.
  *
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * 
+ * @version $Revision$
  */
 public abstract class BaseParser
 {
@@ -550,11 +550,8 @@ public abstract class BaseParser
                         out.flush();
                         InputStream writtenStreamBytes = stream.getFilteredStream();
                         ByteArrayOutputStream bout = new ByteArrayOutputStream( length );
-                        
-                        while ( ( readCount = writtenStreamBytes.read( strmBuf ) ) >= 0 )
-                        {
-                            bout.write( strmBuf, 0, readCount );
-                        }
+
+                        IOUtils.copy(writtenStreamBytes, bout);
                         IOUtils.closeQuietly(writtenStreamBytes);
                         try
                         {
@@ -568,7 +565,7 @@ public abstract class BaseParser
                                                    PROP_PUSHBACK_SIZE, ioe );
                         }
                         // close and create new filtered stream
-                      	IOUtils.closeQuietly(out);
+                        IOUtils.closeQuietly(out);
                         out = stream.createFilteredStream( streamLength );
                         // scan until we find endstream:
                         readUntilEndStream( new EndstreamOutputStream(out) );
@@ -799,6 +796,7 @@ public abstract class BaseParser
         }
         return braces;
     }
+
     /**
      * This will parse a PDF string.
      *
@@ -806,11 +804,25 @@ public abstract class BaseParser
      * @return The parsed PDF string.
      *
      * @throws IOException If there is an error reading from the stream.
+     * @deprecated Not needed anymore. Use {@link #parseCOSString()} instead. PDFBOX-1437
      */
+    @Deprecated
     protected COSString parseCOSString(boolean isDictionary) throws IOException
+    {
+        return parseCOSString();
+    }
+
+    /**
+     * This will parse a PDF string.
+     *
+     * @return The parsed PDF string.
+     *
+     * @throws IOException If there is an error reading from the stream.
+     */
+    protected COSString parseCOSString() throws IOException
     {
         char nextChar = (char)pdfSource.read();
-        COSString retval = new COSString(isDictionary);
+        COSString retval = new COSString();
         char openBrace;
         char closeBrace;
         if( nextChar == '(' )
@@ -1088,7 +1100,7 @@ public abstract class BaseParser
             else
             {
                 //it could be a bad object in the array which is just skipped
-                LOG.warn("Corrupt object reference" );
+                LOG.warn("Corrupt object reference at offset " + pdfSource.getOffset());
 
                 // This could also be an "endobj" or "endstream" which means we can assume that
                 // the array has ended.
@@ -1260,7 +1272,7 @@ public abstract class BaseParser
             }
             else
             {
-                retval = parseCOSString(true);
+                retval = parseCOSString();
             }
             break;
         }
@@ -1270,7 +1282,7 @@ public abstract class BaseParser
             break;
         }
         case '(':
-            retval = parseCOSString(true);
+            retval = parseCOSString();
             break;
         case '/':   // name
             retval = parseCOSName();
@@ -1610,27 +1622,29 @@ public abstract class BaseParser
      * This will read a long from the Stream and throw an {@link IllegalArgumentException} if the long value
      * has more than 10 digits (i.e. : bigger than {@link #OBJECT_NUMBER_THRESHOLD})
      * @return the object number being read.
-     * @throws IOException
+     * @throws IOException if an I/O error occurs
      */
     protected long readObjectNumber() throws IOException
     {
         long retval = readLong();
-        if(retval < 0 || retval >= OBJECT_NUMBER_THRESHOLD) {
+        if(retval < 0 || retval >= OBJECT_NUMBER_THRESHOLD)
+        {
             throw new IOException("Object Number '" + retval + "' has more than 10 digits or is negative");
         }
         return retval;
     }
-    
+
     /**
      * This will read a integer from the Stream and throw an {@link IllegalArgumentException} if the integer value
      * has more than the maximum object revision (i.e. : bigger than {@link #GENERATION_NUMBER_THRESHOLD})
      * @return the generation number being read.
-     * @throws IOException
+     * @throws IOException if an I/O error occurs
      */
     protected int readGenerationNumber() throws IOException
     {
         int retval = readInt();
-        if(retval < 0 || retval > GENERATION_NUMBER_THRESHOLD) {
+        if(retval < 0 || retval > GENERATION_NUMBER_THRESHOLD)
+        {
             throw new IOException("Generation Number '" + retval + "' has more than 5 digits");
         }
         return retval;
@@ -1684,14 +1698,16 @@ public abstract class BaseParser
         catch( NumberFormatException e )
         {
             pdfSource.unread(longBuffer.toString().getBytes("ISO-8859-1"));
-            throw new IOException( "Error: Expected a long type at offset "+pdfSource.getOffset() + ", instead got '" + longBuffer + "'");
+            throw new IOException( "Error: Expected a long type at offset "
+                    + pdfSource.getOffset() + ", instead got '" + longBuffer + "'");
         }
         return retval;
     }
 
     /**
-     * This method is used to read a token by the {@linkplain #readInt()} method and the {@linkplain #readLong()} method.
-     *  
+     * This method is used to read a token by the {@linkplain #readInt()} method
+     * and the {@linkplain #readLong()} method.
+     *
      * @return the token to parse as integer or long by the calling method.
      * @throws IOException throws by the {@link #pdfSource} methods.
      */
@@ -1721,11 +1737,11 @@ public abstract class BaseParser
      */
     public void clearResources()
     {
-    	document = null;
-    	if (pdfSource != null)
-    	{
-    		IOUtils.closeQuietly(pdfSource);
-    		pdfSource = null;
-    	}
+        document = null;
+        if (pdfSource != null)
+        {
+            IOUtils.closeQuietly(pdfSource);
+            pdfSource = null;
+        }
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
index 765a958b41..be992d1a64 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
@@ -41,12 +41,12 @@ import org.apache.pdfbox.util.operator.PDFOperator;
  * This will parse a PDF byte stream and extract operands and such.
  *
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * 
+ * @version $Revision$
  */
 public class PDFStreamParser extends BaseParser
 {
     private List<Object> streamObjects = new ArrayList<Object>( 100 );
-    private RandomAccess file;
+    private final RandomAccess file;
     private final int    maxBinCharTestLength = 5;
     private final byte[] binCharTestArr = new byte[maxBinCharTestLength];
 
@@ -260,7 +260,7 @@ public class PDFStreamParser extends BaseParser
                 }
                 else
                 {
-                    retval = parseCOSString(false);
+                    retval = parseCOSString();
                 }
                 break;
             }
@@ -270,7 +270,7 @@ public class PDFStreamParser extends BaseParser
                 break;
             }
             case '(': // string
-                retval = parseCOSString(false);
+                retval = parseCOSString();
                 break;
             case '/':   // name
                 retval = parseCOSName();
@@ -360,7 +360,7 @@ public class PDFStreamParser extends BaseParser
                 retval = PDFOperator.getOperator( next );
                 if( next.equals( "BI" ) )
                 {
-                	PDFOperator beginImageOP = (PDFOperator)retval;
+                    PDFOperator beginImageOP = (PDFOperator)retval;
                     COSDictionary imageParams = new COSDictionary();
                     beginImageOP.setImageParameters( imageParams );
                     Object nextToken = null;
@@ -530,13 +530,13 @@ public class PDFStreamParser extends BaseParser
      * {@inheritDoc}
      */
     @Override
-    public void clearResources() 
+    public void clearResources()
     {
-    	super.clearResources();
-    	if (streamObjects != null)
-    	{
-    		streamObjects.clear();
-    		streamObjects = null;
-    	}
+        super.clearResources();
+        if (streamObjects != null)
+        {
+            streamObjects.clear();
+            streamObjects = null;
+        }
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
index 72a8a685a4..20c88b88df 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
@@ -1289,7 +1289,7 @@ public class COSWriter implements ICOSVisitor, Closeable
      * @throws IOException If an error occurs while generating the data.
      */
     public void write(PDDocument doc) throws IOException
-	{
+    {
         Long idTime = doc.getDocumentId() == null ? System.currentTimeMillis() : 
                                                     doc.getDocumentId();
 
diff --git a/pdfbox/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider b/pdfbox/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider
new file mode 100644
index 0000000000..a46ce0ba63
--- /dev/null
+++ b/pdfbox/src/main/resources/META-INF/services/java.nio.charset.spi.CharsetProvider
@@ -0,0 +1 @@
+org.apache.pdfbox.encoding.PDFBoxCharsetProvider
\ No newline at end of file
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java b/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
index f98e089410..9f24689fa9 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
@@ -20,11 +20,11 @@ import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 
-import org.apache.pdfbox.pdfwriter.COSWriter;
-
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
+import org.apache.pdfbox.pdfwriter.COSWriter;
+
 /**
  * This will test all of the filters in the PDFBox system.
  *
@@ -33,9 +33,9 @@ import junit.framework.TestSuite;
  */
 public class TestCOSString extends TestCOSBase
 {
-    private final static String ESC_CHAR_STRING =
+    private static final String ESC_CHAR_STRING =
             "( test#some) escaped< \\chars>!~1239857 ";
-    private final static String ESC_CHAR_STRING_PDF_FORMAT =
+    private static final String ESC_CHAR_STRING_PDF_FORMAT =
             "\\( test#some\\) escaped< \\\\chars>!~1239857 ";
 
     /**
@@ -48,6 +48,7 @@ public class TestCOSString extends TestCOSBase
         return new TestSuite(TestCOSString.class);
     }
 
+    @Override
     public void setUp()
     {
         testCOSBase = new COSString("test cos string");
@@ -229,6 +230,25 @@ public class TestCOSString extends TestCOSBase
 
             COSString escapedString = new COSString(ESC_CHAR_STRING);
             assertEquals(ESC_CHAR_STRING, escapedString.getString());
+
+            testStr = "Line1\nLine2\nLine3\n";
+            COSString lineFeedString = new COSString(testStr);
+            assertEquals(testStr, lineFeedString.getString());
+
+            //Same as previous but this time it is constructed incrementally (like in a dictionary)
+            lineFeedString = new COSString();
+            for (int i = 0; i < testStr.length(); i++)
+            {
+                lineFeedString.append(testStr.charAt(i));
+            }
+            assertEquals(testStr, lineFeedString.getString());
+
+            testStr = "Text\u2026"; //PDFBOX-1437
+            COSString pdfbox1437 = new COSString();
+            pdfbox1437.append(new byte[] {
+                    0x54, 0x65, 0x78, 0x74, (byte)(0x83 & 0xFF)
+            });
+            assertEquals(testStr, pdfbox1437.getString());
         }
         catch (IOException e)
         {
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java b/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java
new file mode 100644
index 0000000000..472f3a66ca
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.encoding;
+
+import java.io.UnsupportedEncodingException;
+
+import junit.framework.TestCase;
+
+/**
+ * This class tests {@link PDFDocEncodingCharset} and indirectly {@link SingleByteCharset}.
+ * @version $Revision$
+ */
+public class PDFDocEncodingCharsetTest extends TestCase
+{
+
+    /**
+     * Tests {@link PDFDocEncodingCharset} and indirectly {@link SingleByteCharset}.
+     * @throws UnsupportedEncodingException if an encoding cannot be found
+     */
+    public void testEncoding() throws UnsupportedEncodingException
+    {
+        //TODO Use when switching to JavaSE-1.6
+        //Charset charset = PDFDocEncodingCharset.INSTANCE;
+
+        //Check basic round-trip
+        String text = "Test \u20AC$ ;-) Gr\u00FCezi\u2026";
+        byte[] encoded = text.getBytes(PDFDocEncodingCharset.NAME);
+        int[] expected = new int[] {
+                0x54, 0x65, 0x73, 0x74, 0x20, //Test
+                0xA0, 0x24, 0xA3, 0x20, //Currency
+                0x3B, 0x2D, 0x29, 0x20, //Smiley
+                0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, //Hello in de_CH
+                0x83 //ellipsis
+        };
+        compareEncoded(encoded, expected);
+        String decoded = new String(encoded, PDFDocEncodingCharset.NAME);
+        assertEquals(text, decoded);
+
+        text = "Bad\u03C0\u2023char";
+        expected = new int[] {
+                0x42, 0x61, 0x64, 0x3F, 0x3F, 0x63, 0x68, 0x61, 0x72 //unencodable characters as '?'
+        };
+        encoded = text.getBytes(PDFDocEncodingCharset.NAME);
+        compareEncoded(encoded, expected);
+        decoded = new String(encoded, PDFDocEncodingCharset.NAME);
+        assertEquals("Bad??char", decoded);
+    }
+
+    private void compareEncoded(byte[] encoded, int[] expected)
+    {
+        assertEquals(expected.length, encoded.length);
+        for (int i = 0; i < expected.length; i++)
+        {
+            assertEquals("Bad character at pos " + i, (byte)(expected[i] & 0xFF), encoded[i]);
+        }
+    }
+
+}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/encoding/package.html b/pdfbox/src/test/java/org/apache/pdfbox/encoding/package.html
new file mode 100644
index 0000000000..ba5b4546ce
--- /dev/null
+++ b/pdfbox/src/test/java/org/apache/pdfbox/encoding/package.html
@@ -0,0 +1,25 @@
+<!--
+ ! Licensed to the Apache Software Foundation (ASF) under one or more
+ ! contributor license agreements.  See the NOTICE file distributed with
+ ! this work for additional information regarding copyright ownership.
+ ! The ASF licenses this file to You under the Apache License, Version 2.0
+ ! (the "License"); you may not use this file except in compliance with
+ ! the License.  You may obtain a copy of the License at
+ !
+ !      http://www.apache.org/licenses/LICENSE-2.0
+ !
+ ! Unless required by applicable law or agreed to in writing, software
+ ! distributed under the License is distributed on an "AS IS" BASIS,
+ ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ! See the License for the specific language governing permissions and
+ ! limitations under the License.
+ !-->
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+
+</head>
+<body>
+These classes will be used to test encoding classes.
+</body>
+</html>
