diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
index f859420186..a7b9944b30 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
@@ -116,6 +116,12 @@ public class NonSequentialPDFParser extends PDFParser
      */
     protected static final char[] OBJ_MARKER = new char[] { 'o', 'b', 'j' };
 
+    /**
+     * trailer-marker.
+     */
+    private static final char[] TRAILER_MARKER = new char[] { 't', 'r', 'a', 'i', 'l', 'e', 'r' };
+    
+    private long trailerOffset;
     private final File pdfFile;
     private long fileLen;
     private final RandomAccessBufferedFileInputStream raStream;
@@ -129,6 +135,7 @@ public class NonSequentialPDFParser extends PDFParser
      * Contains all found objects of a brute force search.
      */
     private HashMap<String, Long> bfSearchObjectOffsets = null;
+    private HashMap<COSObjectKey, Long> bfSearchCOSObjectKeyOffsets = null;
     private Vector<Long> bfSearchXRefOffsets = null;
 
     /**
@@ -376,7 +383,6 @@ public class NonSequentialPDFParser extends PDFParser
         }
     }
 
-    // ------------------------------------------------------------------------
     /**
      * The initial parse will first parse only the trailer, the xrefstart and all xref tables to have a pointer (offset)
      * to all the pdf's objects. It can handle linearized pdfs, which will have an xref at the end pointing to an xref
@@ -386,8 +392,140 @@ public class NonSequentialPDFParser extends PDFParser
      */
     protected void initialParse() throws IOException
     {
+    	COSDictionary trailer = null;
         // ---- parse startxref
-        setPdfSource(getStartxrefOffset());
+    	long startXRefOffset = getStartxrefOffset();
+    	if (startXRefOffset > 0)
+    	{
+    		trailer = parseXref(startXRefOffset);
+    	}
+    	else if (isFDFDocment || isLenient)
+    	{
+            // signal start of new XRef
+            xrefTrailerResolver.nextXrefObj( startXRefOffset, XRefType.TABLE );
+    		bfSearchForObjects();
+    		for (COSObjectKey objectKey : bfSearchCOSObjectKeyOffsets.keySet())
+    		{
+	            xrefTrailerResolver.setXRef(objectKey, bfSearchCOSObjectKeyOffsets.get(objectKey));
+    		}
+            // parse the last trailer.
+    		pdfSource.seek(trailerOffset);
+            if (!parseTrailer())
+            {
+                throw new IOException("Expected trailer object at position: "
+                        + pdfSource.getOffset());
+            }
+            xrefTrailerResolver.setStartxref(startXRefOffset);
+            trailer = xrefTrailerResolver.getCurrentTrailer();
+            document.setTrailer(trailer);
+            document.setIsXRefStream(false);
+    	}
+        // ---- prepare decryption if necessary
+    	prepareDecryption();
+
+        // PDFBOX-1557 - ensure that all COSObject are loaded in the trailer
+        // PDFBOX-1606 - after securityHandler has been instantiated
+        for (COSBase trailerEntry : trailer.getValues())
+        {
+            if (trailerEntry instanceof COSObject)
+            {
+                COSObject tmpObj = (COSObject) trailerEntry;
+                parseObjectDynamically(tmpObj, false);
+            }
+        }
+        // ---- parse catalog or root object
+        COSObject root = (COSObject) xrefTrailerResolver.getTrailer().getItem(COSName.ROOT);
+
+        if (root == null)
+        {
+            throw new IOException("Missing root object specification in trailer.");
+        }
+
+        parseObjectDynamically(root, false);
+
+        // ---- resolve all objects (including pages)
+        if (!parseMinimalCatalog)
+        {
+            COSObject catalogObj = document.getCatalog();
+            if (catalogObj != null)
+            {
+                if (catalogObj.getObject() instanceof COSDictionary)
+                {
+                    parseDictObjects((COSDictionary) catalogObj.getObject(), (COSName[]) null);
+                    allPagesParsed = true;
+                    document.setDecrypted();
+                }
+            }
+        }
+
+        // PDFBOX-1922: read the version again now that all objects have been resolved
+        readVersionInTrailer(trailer);
+
+        initialParseDone = true;
+    }
+
+    /**
+     * Prepare for decryption.
+     * 
+     * @throws IOException if something went wrong
+     */
+    private void prepareDecryption() throws IOException
+    {
+        COSBase trailerEncryptItem = document.getTrailer().getItem(COSName.ENCRYPT);
+        if (trailerEncryptItem != null && !(trailerEncryptItem instanceof COSNull))
+        {
+            if (trailerEncryptItem instanceof COSObject)
+            {
+                COSObject trailerEncryptObj = (COSObject) trailerEncryptItem;
+                parseObjectDynamically(trailerEncryptObj, true);
+            }
+            try
+            {
+                PDEncryption encryption = new PDEncryption(document.getEncryptionDictionary());
+
+                DecryptionMaterial decryptionMaterial;
+                if (keyStoreFilename != null)
+                {
+                    KeyStore ks = KeyStore.getInstance("PKCS12");
+                    ks.load(new FileInputStream(keyStoreFilename), password.toCharArray());
+
+                    decryptionMaterial = new PublicKeyDecryptionMaterial(ks, alias, password);
+                }
+                else
+                {
+                    decryptionMaterial = new StandardDecryptionMaterial(password);
+                }
+
+                securityHandler = encryption.getSecurityHandler();
+                securityHandler.prepareForDecryption(encryption, document.getDocumentID(),
+                        decryptionMaterial);
+
+                AccessPermission permission = securityHandler.getCurrentAccessPermission();
+                if (!permission.canExtractContent())
+                {
+                    LOG.warn("PDF file '" + pdfFile.getPath()
+                            + "' does not allow extracting content.");
+                }
+
+            }
+            catch (Exception e)
+            {
+                throw new IOException("Error (" + e.getClass().getSimpleName()
+                        + ") while creating security handler for decryption",e);
+            }
+        }
+    }
+    
+    /**
+     * Parses cross reference tables.
+     * 
+     * @param startXRefOffset start offset of the first table
+     * @return the trailer dictionary
+     * @throws IOException if something went wrong
+     */
+    private COSDictionary parseXref(long startXRefOffset) throws IOException
+    {
+        setPdfSource(startXRefOffset);
         parseStartXref();
 
         long startXrefOffset = document.getStartXref();
@@ -415,7 +553,7 @@ public class NonSequentialPDFParser extends PDFParser
                 // use existing parser to parse xref table
                 parseXrefTable(prev);
                 // parse the last trailer.
-                long trailerOffset = pdfSource.getOffset();
+                trailerOffset = pdfSource.getOffset();
                 // PDFBOX-1739 skip extra xref entries in RegisSTAR documents
                 while (isLenient && pdfSource.peek() != 't')
                 {
@@ -477,7 +615,6 @@ public class NonSequentialPDFParser extends PDFParser
                 }
             }
         }
-
         // ---- build valid xrefs out of the xref chain
         xrefTrailerResolver.setStartxref(startXrefOffset);
         COSDictionary trailer = xrefTrailerResolver.getTrailer();
@@ -485,94 +622,9 @@ public class NonSequentialPDFParser extends PDFParser
         document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());
         // check the offsets of all referenced objects
         checkXrefOffsets();
-
-        // ---- prepare encryption if necessary
-        COSBase trailerEncryptItem = document.getTrailer().getItem(COSName.ENCRYPT);
-        if (trailerEncryptItem != null && !(trailerEncryptItem instanceof COSNull))
-        {
-            if (trailerEncryptItem instanceof COSObject)
-            {
-                COSObject trailerEncryptObj = (COSObject) trailerEncryptItem;
-                parseObjectDynamically(trailerEncryptObj, true);
-            }
-            try
-            {
-                PDEncryption encryption = new PDEncryption(document.getEncryptionDictionary());
-
-                DecryptionMaterial decryptionMaterial;
-                if (keyStoreFilename != null)
-                {
-                    KeyStore ks = KeyStore.getInstance("PKCS12");
-                    ks.load(new FileInputStream(keyStoreFilename), password.toCharArray());
-
-                    decryptionMaterial = new PublicKeyDecryptionMaterial(ks, alias, password);
-                }
-                else
-                {
-                    decryptionMaterial = new StandardDecryptionMaterial(password);
-                }
-
-                securityHandler = encryption.getSecurityHandler();
-                securityHandler.prepareForDecryption(encryption, document.getDocumentID(),
-                        decryptionMaterial);
-
-                AccessPermission permission = securityHandler.getCurrentAccessPermission();
-                if (!permission.canExtractContent())
-                {
-                    LOG.warn("PDF file '" + pdfFile.getPath()
-                            + "' does not allow extracting content.");
-                }
-
-            }
-            catch (Exception e)
-            {
-                throw new IOException("Error (" + e.getClass().getSimpleName()
-                        + ") while creating security handler for decryption",e);
-            }
-        }
-
-        // PDFBOX-1557 - ensure that all COSObject are loaded in the trailer
-        // PDFBOX-1606 - after securityHandler has been instantiated
-        for (COSBase trailerEntry : trailer.getValues())
-        {
-            if (trailerEntry instanceof COSObject)
-            {
-                COSObject tmpObj = (COSObject) trailerEntry;
-                parseObjectDynamically(tmpObj, false);
-            }
-        }
-        // ---- parse catalog or root object
-        COSObject root = (COSObject) xrefTrailerResolver.getTrailer().getItem(COSName.ROOT);
-
-        if (root == null)
-        {
-            throw new IOException("Missing root object specification in trailer.");
-        }
-
-        parseObjectDynamically(root, false);
-
-        // ---- resolve all objects (including pages)
-        if (!parseMinimalCatalog)
-        {
-            COSObject catalogObj = document.getCatalog();
-            if (catalogObj != null)
-            {
-                if (catalogObj.getObject() instanceof COSDictionary)
-                {
-                    parseDictObjects((COSDictionary) catalogObj.getObject(), (COSName[]) null);
-                    allPagesParsed = true;
-                    document.setDecrypted();
-                }
-            }
-        }
-
-        // PDFBOX-1922: read the version again now that all objects have been resolved
-        readVersionInTrailer(trailer);
-
-        initialParseDone = true;
+        return trailer;
     }
 
-    // ------------------------------------------------------------------------
     /**
      * Parses an xref object stream starting with indirect object id.
      * 
@@ -716,7 +768,19 @@ public class NonSequentialPDFParser extends PDFParser
 
         if (bufOff < 0)
         {
-            throw new IOException("Missing 'startxref' marker.");
+        	if (isLenient) 
+        	{
+                trailerOffset = lastIndexOf(TRAILER_MARKER, buf, buf.length);
+                if (trailerOffset > 0)
+                {
+                	trailerOffset += skipBytes;
+                }
+        		return -1;
+        	}
+        	else
+        	{
+        		throw new IOException("Missing 'startxref' marker.");
+        	}
         }
         return skipBytes + bufOff;
     }
@@ -1912,6 +1976,7 @@ public class NonSequentialPDFParser extends PDFParser
         if (bfSearchObjectOffsets == null)
         {
             bfSearchObjectOffsets = new HashMap<String, Long>();
+            bfSearchCOSObjectKeyOffsets = new HashMap<COSObjectKey, Long>();
             long originOffset = pdfSource.getOffset();
             long currentOffset = MINIMUM_SEARCH_OFFSET;
             String objString = " obj";
@@ -1962,6 +2027,7 @@ public class NonSequentialPDFParser extends PDFParser
                                 {
                                     bfSearchObjectOffsets.put(
                                             createObjectString(objectID, genID), ++tempOffset);
+                                    bfSearchCOSObjectKeyOffsets.put(new COSObjectKey(objectID, genID), tempOffset);
                                 }
                             }
                         }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
index 84d5e680de..e776d1fb3f 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
@@ -59,6 +59,8 @@ public class PDFParser extends BaseParser
     private static final String PDF_HEADER = "%PDF-";
     private static final String FDF_HEADER = "%FDF-";
     
+    protected boolean isFDFDocment = false;
+    
     private static final String PDF_DEFAULT_VERSION = "1.4";
     private static final String FDF_DEFAULT_VERSION = "1.0";
     
@@ -407,6 +409,7 @@ public class PDFParser extends BaseParser
         }
         else
         {
+        	isFDFDocment = true;
             if (!header.matches(FDF_HEADER + "\\d.\\d"))
             {
                 if (header.length() < FDF_HEADER.length() + 3)
