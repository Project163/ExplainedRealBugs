diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
index 5ec1135a65..ce0a47704c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/color/PDIndexed.java
@@ -54,6 +54,11 @@ public class PDIndexed extends PDColorSpace
 
     private COSArray array;
 
+    /**
+     * The lookup data as byte array.
+     */
+    private byte[] lookupData;
+    
     /**
      * Constructor, default DeviceRGB, hival 255.
      */
@@ -220,38 +225,46 @@ public class PDIndexed extends PDColorSpace
         return (data[lookupIndex*numberOfComponents + componentNumber]+256)%256;
     }
 
-    private byte[] getLookupData() throws IOException
+    /**
+     * Get the lookup data table.
+     * 
+     * @return a byte array containing the the lookup data.
+     * @throws IOException if an error occurs.
+     */
+    public byte[] getLookupData() throws IOException
     {
-        COSBase lookupTable = array.getObject( 3 );
-        byte[] data = null;
-        if( lookupTable instanceof COSString )
-        {
-            data = ((COSString)lookupTable).getBytes();
-        }
-        else if( lookupTable instanceof COSStream )
+        if ( lookupData == null)
         {
-            //Data will be small so just load the whole thing into memory for
-            //easier processing
-            COSStream lookupStream = (COSStream)lookupTable;
-            InputStream input = lookupStream.getUnfilteredStream();
-            ByteArrayOutputStream output = new ByteArrayOutputStream(1024);
-            byte[] buffer = new byte[ 1024 ];
-            int amountRead;
-            while( (amountRead = input.read(buffer, 0, buffer.length)) != -1 )
+            COSBase lookupTable = array.getObject( 3 );
+            if( lookupTable instanceof COSString )
             {
-                output.write( buffer, 0, amountRead );
+                lookupData = ((COSString)lookupTable).getBytes();
+            }
+            else if( lookupTable instanceof COSStream )
+            {
+                //Data will be small so just load the whole thing into memory for
+                //easier processing
+                COSStream lookupStream = (COSStream)lookupTable;
+                InputStream input = lookupStream.getUnfilteredStream();
+                ByteArrayOutputStream output = new ByteArrayOutputStream(1024);
+                byte[] buffer = new byte[ 1024 ];
+                int amountRead;
+                while( (amountRead = input.read(buffer, 0, buffer.length)) != -1 )
+                {
+                    output.write( buffer, 0, amountRead );
+                }
+                lookupData = output.toByteArray();
+            }
+            else if( lookupTable == null )
+            {
+                lookupData = new byte[0];
+            }
+            else
+            {
+                throw new IOException( "Error: Unknown type for lookup table " + lookupTable );
             }
-            data = output.toByteArray();
-        }
-        else if( lookupTable == null )
-        {
-            data = new byte[0];
-        }
-        else
-        {
-            throw new IOException( "Error: Unknown type for lookup table " + lookupTable );
         }
-        return data;
+        return lookupData;
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
index 87c05a8ef6..2ef649fb46 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
@@ -17,6 +17,7 @@
 package org.apache.pdfbox.pdmodel.graphics.xobject;
 
 import java.awt.Transparency;
+import java.awt.image.DataBuffer;
 import java.awt.image.DataBufferByte;
 import java.awt.image.BufferedImage;
 import java.awt.image.ColorModel;
@@ -39,6 +40,7 @@ import org.apache.pdfbox.pdmodel.common.PDStream;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray;
 import org.apache.pdfbox.pdmodel.graphics.color.PDICCBased;
+import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
 import org.apache.pdfbox.pdmodel.graphics.predictor.PredictorAlgorithm;
 
 
@@ -193,6 +195,41 @@ public class PDPixelMap extends PDXObjectImage
                     else
                         cm = colorspace.createColorModel( bpc );
                 }
+                else if (colorspace instanceof PDIndexed)
+                {
+                    PDIndexed csIndexed = (PDIndexed)colorspace;
+                    ColorModel baseColorModel = csIndexed.getBaseColorSpace().createColorModel(bpc);
+                    int size = csIndexed.getHighValue();
+                    byte[] index = csIndexed.getLookupData();
+                    COSArray decode = getDecode();
+                    boolean isOpaque = (decode != null && decode.getInt(0) == 1) ? true : false;
+                    boolean hasAlpha = baseColorModel.hasAlpha();
+                    if( baseColorModel.getTransferType() != DataBuffer.TYPE_BYTE )
+                    {
+                        throw new IOException( "Not implemented" );
+                    }
+                    byte[] r = new byte[size+1];
+                    byte[] g = new byte[size+1];
+                    byte[] b = new byte[size+1];
+                    byte[] a = new byte[size+1];
+                    byte[] inData = new byte[baseColorModel.getNumComponents()];
+                    for( int i = 0; i <= size; i++ )
+                    {
+                        System.arraycopy(index, i * inData.length, inData, 0, inData.length);
+                        r[i] = (byte)baseColorModel.getRed(inData);
+                        g[i] = (byte)baseColorModel.getGreen(inData);
+                        b[i] = (byte)baseColorModel.getBlue(inData);
+                        if( hasAlpha )
+                        {
+                            a[i] = (byte)baseColorModel.getAlpha(inData);
+                        }
+                        else
+                        {
+                            a[i] = isOpaque ? (byte)0xFF : (byte)0x00;
+                        }
+                    }
+                    cm = new IndexColorModel(bpc, size+1, r, g, b, a);
+                }
                 else
                     cm = colorspace.createColorModel( bpc );
             }
