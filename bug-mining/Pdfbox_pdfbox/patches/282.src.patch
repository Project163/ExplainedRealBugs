diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
index 4f549ce1e6..3903cdc22d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java
@@ -309,7 +309,7 @@ public class COSArray extends COSBase implements Iterable<COSBase>
         }
         else
         {
-            set ( index, null );
+            set( index, null );
         }
     }   
 
@@ -551,7 +551,7 @@ public class COSArray extends COSBase implements Iterable<COSBase>
      *
      *  @return the COSArray as List
      */
-    public List<COSBase> toList()
+    public List<?> toList()
     {
         ArrayList<COSBase> retList = new ArrayList<COSBase>(size());
         for (int i = 0; i < size(); i++)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
index 8e00f1baca..8ca6593a8d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/COSDictionaryMap.java
@@ -38,10 +38,10 @@ import org.apache.pdfbox.cos.COSString;
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.10 $
  */
-public class COSDictionaryMap implements Map
+public class COSDictionaryMap<K,V> implements Map<K,V>
 {
     private COSDictionary map;
-    private Map actuals;
+    private Map<K,V> actuals;
 
     /**
      * Constructor for this map.
@@ -49,7 +49,7 @@ public class COSDictionaryMap implements Map
      * @param actualsMap The map with standard java objects as values.
      * @param dicMap The map with COSBase objects as values.
      */
-    public COSDictionaryMap( Map actualsMap, COSDictionary dicMap )
+    public COSDictionaryMap( Map<K,V> actualsMap, COSDictionary dicMap )
     {
         actuals = actualsMap;
         map = dicMap;
@@ -91,7 +91,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object get(Object key)
+    public V get(Object key)
     {
         return actuals.get( key );
     }
@@ -99,7 +99,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object put(Object key, Object value)
+    public V put(K key, V value)
     {
         COSObjectable object = (COSObjectable)value;
 
@@ -110,7 +110,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Object remove(Object key)
+    public V remove(Object key)
     {
         map.removeItem( COSName.getPDFName( (String)key ) );
         return actuals.remove( key );
@@ -119,7 +119,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public void putAll(Map t)
+    public void putAll(Map<? extends K, ? extends V> t)
     {
         throw new RuntimeException( "Not yet implemented" );
     }
@@ -136,7 +136,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Set keySet()
+    public Set<K> keySet()
     {
         return actuals.keySet();
     }
@@ -144,7 +144,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Collection values()
+    public Collection<V> values()
     {
         return actuals.values();
     }
@@ -152,7 +152,7 @@ public class COSDictionaryMap implements Map
     /**
      * {@inheritDoc}
      */
-    public Set entrySet()
+    public Set<Map.Entry<K, V>> entrySet()
     {
         return Collections.unmodifiableSet(actuals.entrySet());
     }
@@ -165,7 +165,7 @@ public class COSDictionaryMap implements Map
         boolean retval = false;
         if( o instanceof COSDictionaryMap )
         {
-            COSDictionaryMap other = (COSDictionaryMap)o;
+            COSDictionaryMap<K,V> other = (COSDictionaryMap)o;
             retval = other.map.equals( this.map );
         }
         return retval;
@@ -195,9 +195,9 @@ public class COSDictionaryMap implements Map
      *
      * @return A proper COSDictionary
      */
-    public static COSDictionary convert( Map someMap )
+    public static COSDictionary convert( Map<?,?> someMap )
     {
-        Iterator iter = someMap.keySet().iterator();
+        Iterator<?> iter = someMap.keySet().iterator();
         COSDictionary dic = new COSDictionary();
         while( iter.hasNext() )
         {
@@ -216,12 +216,12 @@ public class COSDictionaryMap implements Map
      * @return A standard java map.
      * @throws IOException If there is an error during the conversion.
      */
-    public static COSDictionaryMap convertBasicTypesToMap( COSDictionary map ) throws IOException
+    public static COSDictionaryMap<String, Object> convertBasicTypesToMap( COSDictionary map ) throws IOException
     {
-        COSDictionaryMap retval = null;
+        COSDictionaryMap<String, Object> retval = null;
         if( map != null )
         {
-            Map actualMap = new HashMap();
+            Map<String, Object> actualMap = new HashMap<String, Object>();
             for( COSName key : map.keySet() )
             {
                 COSBase cosObj = map.getDictionaryObject( key );
@@ -252,7 +252,7 @@ public class COSDictionaryMap implements Map
                 }
                 actualMap.put( key.getName(), actualObject );
             }
-            retval = new COSDictionaryMap( actualMap, map );
+            retval = new COSDictionaryMap<String, Object>( actualMap, map );
         }
 
         return retval;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
index d71653f9a5..402ef603fa 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/common/PDStream.java
@@ -41,523 +41,572 @@ import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.common.filespecification.PDFileSpecification;
 
 /**
- * A PDStream represents a stream in a PDF document.  Streams are tied to a single
- * PDF document.
- *
+ * A PDStream represents a stream in a PDF document. Streams are tied to a
+ * single PDF document.
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.17 $
  */
 public class PDStream implements COSObjectable
 {
-	private COSStream stream;
-
-	/**
-	 * This will create a new PDStream object.
-	 */
-	protected PDStream()
-	{
-		//should only be called by PDMemoryStream
-	}
-
-	/**
-	 * This will create a new PDStream object.
-	 *
-	 * @param document The document that the stream will be part of.
-	 */
-	public PDStream( PDDocument document )
-	{
-		stream = new COSStream( document.getDocument().getScratchFile() );
-	}
-
-	/**
-	 * Constructor.
-	 *
-	 * @param str The stream parameter.
-	 */
-	public PDStream( COSStream str )
-	{
-		stream = str;
-	}
-
-	/**
-	 * Constructor.  Reads all data from the input stream and embeds it into the
-	 * document, this will close the InputStream.
-	 *
-	 * @param doc The document that will hold the stream.
-	 * @param str The stream parameter.
-	 * @throws IOException If there is an error creating the stream in the document.
-	 */
-	public PDStream( PDDocument doc, InputStream str ) throws IOException
-	{
-		this( doc, str, false );
-	}
-
-	/**
-	 * Constructor.  Reads all data from the input stream and embeds it into the
-	 * document, this will close the InputStream.
-	 *
-	 * @param doc The document that will hold the stream.
-	 * @param str The stream parameter.
-	 * @param filtered True if the stream already has a filter applied.
-	 * @throws IOException If there is an error creating the stream in the document.
-	 */
-	public PDStream( PDDocument doc, InputStream str, boolean filtered ) throws IOException
-	{
-		OutputStream output = null;
-		try
-		{
-			stream = new COSStream( doc.getDocument().getScratchFile() );
-			if( filtered )
-			{
-				output = stream.createFilteredStream();
-			}
-			else
-			{
-				output = stream.createUnfilteredStream();
-			}
-			byte[] buffer = new byte[ 1024 ];
-			int amountRead = -1;
-			while( (amountRead = str.read(buffer)) != -1 )
-			{
-				output.write( buffer, 0, amountRead );
-			}
-		}
-		finally
-		{
-			if( output != null )
-			{
-				output.close();
-			}
-			if( str != null )
-			{
-				str.close();
-			}
-		}
-	}
-
-	/**
-	 * If there are not compression filters on the current stream then this
-	 * will add a compression filter, flate compression for example.
-	 */
-	public void addCompression()
-	{
-		List filters = getFilters();
-		if( filters == null )
-		{
-			filters = new ArrayList();
-			filters.add( COSName.FLATE_DECODE );
-			setFilters( filters );
-		}
-	}
-
-	/**
-	 * Create a pd stream from either a regular COSStream on a COSArray of cos streams.
-	 * @param base Either a COSStream or COSArray.
-	 * @return A PDStream or null if base is null.
-	 * @throws IOException If there is an error creating the PDStream.
-	 */
-	public static PDStream createFromCOS( COSBase base ) throws IOException
-	{
-		PDStream retval = null;
-		if( base instanceof COSStream )
-		{
-			retval = new PDStream( (COSStream)base );
-		}
-		else if( base instanceof COSArray )
-		{
-			if (((COSArray)base).size() > 0) {
-				retval = new PDStream( new COSStreamArray( (COSArray)base ) );
-			}
-		}
-		else
-		{
-			if( base != null )
-			{
-				throw new IOException( "Contents are unknown type:" + base.getClass().getName() );
-			}
-		}
-		return retval;
-	}
-
-
-	/**
-	 * Convert this standard java object to a COS object.
-	 *
-	 * @return The cos object that matches this Java object.
-	 */
-	public COSBase getCOSObject()
-	{
-		return stream;
-	}
-
-	/**
-	 * This will get a stream that can be written to.
-	 *
-	 * @return An output stream to write data to.
-	 *
-	 * @throws IOException If an IO error occurs during writing.
-	 */
-	public OutputStream createOutputStream() throws IOException
-	{
-		return stream.createUnfilteredStream();
-	}
-
-	/**
-	 * This will get a stream that can be read from.
-	 *
-	 * @return An input stream that can be read from.
-	 *
-	 * @throws IOException If an IO error occurs during reading.
-	 */
-	public InputStream createInputStream() throws IOException
-	{
-		return stream.getUnfilteredStream();
-	}
-
-	/**
-	 * This will get a stream with some filters applied but not others.  This is useful
-	 * when doing images, ie filters = [flate,dct], we want to remove flate but leave dct
-	 *
-	 * @param stopFilters A list of filters to stop decoding at.
-	 * @return A stream with decoded data.
-	 * @throws IOException If there is an error processing the stream.
-	 */
-	public InputStream getPartiallyFilteredStream( List stopFilters ) throws IOException
-	{
-		FilterManager manager = stream.getFilterManager();
-		InputStream is = stream.getFilteredStream();
-		ByteArrayOutputStream os = new ByteArrayOutputStream();
-		List filters = getFilters();
-		String nextFilter = null;
-		boolean done = false;
-		for( int i=0; i<filters.size() && !done; i++ )
-		{
-			os.reset();
-			nextFilter = (String)filters.get( i );
-			if( stopFilters.contains( nextFilter ) )
-			{
-				done = true;
-			}
-			else
-			{
-				Filter filter = manager.getFilter( COSName.getPDFName(nextFilter) );
-				filter.decode( is, os, stream, i );
-				is = new ByteArrayInputStream( os.toByteArray() );
-			}
-		}
-		return is;
-	}
-
-	/**
-	 * Get the cos stream associated with this object.
-	 *
-	 * @return The cos object that matches this Java object.
-	 */
-	public COSStream getStream()
-	{
-		return stream;
-	}
-
-	/**
-	 * This will get the length of the filtered/compressed stream.  This is readonly in the
-	 * PD Model and will be managed by this class.
-	 *
-	 * @return The length of the filtered stream.
-	 */
-	public int getLength()
-	{
-		return stream.getInt( "Length", 0 );
-	}
-
-	/**
-	 * This will get the list of filters that are associated with this stream.  Or
-	 * null if there are none.
-	 * @return A list of all encoding filters to apply to this stream.
-	 */
-	public List getFilters()
-	{
-		List retval = null;
-		COSBase filters = stream.getFilters();
-		if( filters instanceof COSName )
-		{
-			COSName name = (COSName)filters;
-			retval = new COSArrayList( name.getName(), name, stream, COSName.FILTER );
-		}
-		else if( filters instanceof COSArray )
-		{
-			retval = COSArrayList.convertCOSNameCOSArrayToList( (COSArray)filters );
-		}
-		return retval;
-	}
-
-	/**
-	 * This will set the filters that are part of this stream.
-	 *
-	 * @param filters The filters that are part of this stream.
-	 */
-	public void setFilters( List filters )
-	{
-		COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray( filters );
-		stream.setItem( COSName.FILTER, obj );
-	}
-
-	/**
-	 * Get the list of decode parameters.  Each entry in the list will refer to
-	 * an entry in the filters list.
-	 *
-	 * @return The list of decode parameters.
-	 *
-	 * @throws IOException if there is an error retrieving the parameters.
-	 */
-	public List getDecodeParms() throws IOException
-	{
-		List retval = null;
-
-		COSBase dp = stream.getDictionaryObject( COSName.DECODE_PARMS );
-		if( dp == null )
-		{
-			//See PDF Ref 1.5 implementation note 7, the DP is sometimes used instead.
-			dp = stream.getDictionaryObject( COSName.DP );
-		}
-		if( dp instanceof COSDictionary )
-		{
-			Map map = COSDictionaryMap.convertBasicTypesToMap( (COSDictionary)dp );
-			retval = new COSArrayList(map, dp, stream, COSName.DECODE_PARMS );
-		}
-		else if( dp instanceof COSArray )
-		{
-			COSArray array = (COSArray)dp;
-			List actuals = new ArrayList();
-			for( int i=0; i<array.size(); i++ )
-			{
-				actuals.add(
-						COSDictionaryMap.convertBasicTypesToMap(
-								(COSDictionary)array.getObject( i ) ) );
-			}
-			retval = new COSArrayList(actuals, array);
-		}
-
-		return retval;
-	}
-
-	/**
-	 * This will set the list of decode parameterss.
-	 *
-	 * @param decodeParams The list of decode parameterss.
-	 */
-	public void setDecodeParms( List decodeParams )
-	{
-		stream.setItem(
-				COSName.DECODE_PARMS, COSArrayList.converterToCOSArray( decodeParams ) );
-	}
-
-	/**
-	 * This will get the file specification for this stream.  This is only
-	 * required for external files.
-	 *
-	 * @return The file specification.
-	 *
-	 * @throws IOException If there is an error creating the file spec.
-	 */
-	public PDFileSpecification getFile() throws IOException
-	{
-		COSBase f = stream.getDictionaryObject( COSName.F );
-		PDFileSpecification retval = PDFileSpecification.createFS( f );
-		return retval;
-	}
-
-	/**
-	 * Set the file specification.
-	 * @param f The file specification.
-	 */
-	public void setFile( PDFileSpecification f )
-	{
-		stream.setItem( COSName.F, f );
-	}
-
-	/**
-	 * This will get the list of filters that are associated with this stream.  Or
-	 * null if there are none.
-	 * @return A list of all encoding filters to apply to this stream.
-	 */
-	public List getFileFilters()
-	{
-		List retval = null;
-		COSBase filters = stream.getDictionaryObject( COSName.F_FILTER );
-		if( filters instanceof COSName )
-		{
-			COSName name = (COSName)filters;
-			retval = new COSArrayList( name.getName(), name, stream, COSName.F_FILTER );
-		}
-		else if( filters instanceof COSArray )
-		{
-			retval = COSArrayList.convertCOSNameCOSArrayToList( (COSArray)filters );
-		}
-		return retval;
-	}
-
-	/**
-	 * This will set the filters that are part of this stream.
-	 *
-	 * @param filters The filters that are part of this stream.
-	 */
-	public void setFileFilters( List filters )
-	{
-		COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray( filters );
-		stream.setItem( COSName.F_FILTER, obj );
-	}
-
-	/**
-	 * Get the list of decode parameters.  Each entry in the list will refer to
-	 * an entry in the filters list.
-	 *
-	 * @return The list of decode parameters.
-	 *
-	 * @throws IOException if there is an error retrieving the parameters.
-	 */
-	public List getFileDecodeParams() throws IOException
-	{
-		List retval = null;
-
-		COSBase dp = stream.getDictionaryObject( COSName.F_DECODE_PARMS );
-		if( dp instanceof COSDictionary )
-		{
-			Map map = COSDictionaryMap.convertBasicTypesToMap( (COSDictionary)dp );
-			retval = new COSArrayList(map, dp, stream, COSName.F_DECODE_PARMS );
-		}
-		else if( dp instanceof COSArray )
-		{
-			COSArray array = (COSArray)dp;
-			List actuals = new ArrayList();
-			for( int i=0; i<array.size(); i++ )
-			{
-				actuals.add(
-						COSDictionaryMap.convertBasicTypesToMap(
-								(COSDictionary)array.getObject( i ) ) );
-			}
-			retval = new COSArrayList(actuals, array);
-		}
-
-		return retval;
-	}
-
-	/**
-	 * This will set the list of decode params.
-	 *
-	 * @param decodeParams The list of decode params.
-	 */
-	public void setFileDecodeParams( List decodeParams )
-	{
-		stream.setItem(
-				"FDecodeParams", COSArrayList.converterToCOSArray( decodeParams ) );
-	}
-
-	/**
-	 * This will copy the stream into a byte array.
-	 *
-	 * @return The byte array of the filteredStream
-	 * @throws IOException When getFilteredStream did not work
-	 */
-	public byte[] getByteArray() throws IOException
-	{
-		ByteArrayOutputStream output = new ByteArrayOutputStream();
-		byte[] buf = new byte[1024];
-		InputStream is = null;
-		try
-		{
-			is = createInputStream();
-			int amountRead = -1;
-			while( (amountRead = is.read( buf )) != -1)
-			{
-				output.write( buf, 0, amountRead );
-			}
-		}
-		finally
-		{
-			if( is != null )
-			{
-				is.close();
-			}
-		}
-		return output.toByteArray();
-	}
-
-	/**
-	 * A convenience method to get this stream as a string.  Uses
-	 * the default system encoding.
-	 *
-	 * @return a String representation of this (input) stream.
-	 *
-	 * @throws IOException if there is an error while converting the stream
-	 *                     to a string.
-	 */
-	public String getInputStreamAsString() throws IOException
-	{
-		byte[] bStream = getByteArray();
-		return new String(bStream, "ISO-8859-1");
-	}
-
-	/**
-	 * Get the metadata that is part of the document catalog.  This will
-	 * return null if there is no meta data for this object.
-	 *
-	 * @return The metadata for this object.
-	 * @throws IllegalStateException if the value of the metadata entry is different from a stream or null
-	 */
-	public PDMetadata getMetadata ()
-	{
-		PDMetadata retval = null;
-		COSBase mdStream = stream.getDictionaryObject( COSName.METADATA );
-		if( mdStream != null )
-		{
-			if (mdStream instanceof COSStream) 
-			{
-				retval = new PDMetadata( (COSStream)mdStream );
-			}
-			else if (mdStream instanceof COSNull) 
-			{
-				// null is authorized
-			}
-			else
-			{
-				throw new IllegalStateException("Expected a COSStream but was a " + mdStream.getClass().getSimpleName());
-			}
-		}
-		return retval;
-	}
-
-	/**
-	 * Set the metadata for this object.  This can be null.
-	 *
-	 * @param meta The meta data for this object.
-	 */
-	public void setMetadata( PDMetadata meta )
-	{
-		stream.setItem( COSName.METADATA, meta );
-	}
-
-	/**
-	 * Get the decoded stream length.
-	 *
-	 * @since Apache PDFBox 1.1.0
-	 * @see <a href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
-	 * @return the decoded stream length
-	 */
-	public int getDecodedStreamLength()
-	{
-		return this.stream.getInt(COSName.DL);
-	}
-
-	/**
-	 * Set the decoded stream length.
-	 *
-	 * @since Apache PDFBox 1.1.0
-	 * @see <a href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
-	 * @param decodedStreamLength the decoded stream length
-	 */
-	public void setDecodedStreamLength(int decodedStreamLength)
-	{
-		this.stream.setInt(COSName.DL, decodedStreamLength);
-	}
+    private COSStream stream;
+
+    /**
+     * This will create a new PDStream object.
+     */
+    protected PDStream()
+    {
+        // should only be called by PDMemoryStream
+    }
+
+    /**
+     * This will create a new PDStream object.
+     * 
+     * @param document
+     *            The document that the stream will be part of.
+     */
+    public PDStream(PDDocument document)
+    {
+        stream = new COSStream(document.getDocument().getScratchFile());
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param str
+     *            The stream parameter.
+     */
+    public PDStream(COSStream str)
+    {
+        stream = str;
+    }
+
+    /**
+     * Constructor. Reads all data from the input stream and embeds it into the
+     * document, this will close the InputStream.
+     * 
+     * @param doc
+     *            The document that will hold the stream.
+     * @param str
+     *            The stream parameter.
+     * @throws IOException
+     *             If there is an error creating the stream in the document.
+     */
+    public PDStream(PDDocument doc, InputStream str) throws IOException
+    {
+        this(doc, str, false);
+    }
+
+    /**
+     * Constructor. Reads all data from the input stream and embeds it into the
+     * document, this will close the InputStream.
+     * 
+     * @param doc
+     *            The document that will hold the stream.
+     * @param str
+     *            The stream parameter.
+     * @param filtered
+     *            True if the stream already has a filter applied.
+     * @throws IOException
+     *             If there is an error creating the stream in the document.
+     */
+    public PDStream(PDDocument doc, InputStream str, boolean filtered)
+            throws IOException
+    {
+        OutputStream output = null;
+        try
+        {
+            stream = new COSStream(doc.getDocument().getScratchFile());
+            if (filtered)
+            {
+                output = stream.createFilteredStream();
+            } 
+            else
+            {
+                output = stream.createUnfilteredStream();
+            }
+            byte[] buffer = new byte[1024];
+            int amountRead = -1;
+            while ((amountRead = str.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, amountRead);
+            }
+        } 
+        finally
+        {
+            if (output != null)
+            {
+                output.close();
+            }
+            if (str != null)
+            {
+                str.close();
+            }
+        }
+    }
+
+    /**
+     * If there are not compression filters on the current stream then this will
+     * add a compression filter, flate compression for example.
+     */
+    public void addCompression()
+    {
+        List<COSName> filters = getFilters();
+        if (filters == null)
+        {
+            filters = new ArrayList<COSName>();
+            filters.add(COSName.FLATE_DECODE);
+            setFilters(filters);
+        }
+    }
+
+    /**
+     * Create a pd stream from either a regular COSStream on a COSArray of cos
+     * streams.
+     * 
+     * @param base
+     *            Either a COSStream or COSArray.
+     * @return A PDStream or null if base is null.
+     * @throws IOException
+     *             If there is an error creating the PDStream.
+     */
+    public static PDStream createFromCOS(COSBase base) throws IOException
+    {
+        PDStream retval = null;
+        if (base instanceof COSStream)
+        {
+            retval = new PDStream((COSStream) base);
+        } 
+        else if (base instanceof COSArray)
+        {
+            if (((COSArray) base).size() > 0)
+            {
+                retval = new PDStream(new COSStreamArray((COSArray) base));
+            }
+        } 
+        else
+        {
+            if (base != null)
+            {
+                throw new IOException("Contents are unknown type:"
+                        + base.getClass().getName());
+            }
+        }
+        return retval;
+    }
+
+    /**
+     * Convert this standard java object to a COS object.
+     * 
+     * @return The cos object that matches this Java object.
+     */
+    public COSBase getCOSObject()
+    {
+        return stream;
+    }
+
+    /**
+     * This will get a stream that can be written to.
+     * 
+     * @return An output stream to write data to.
+     * 
+     * @throws IOException
+     *             If an IO error occurs during writing.
+     */
+    public OutputStream createOutputStream() throws IOException
+    {
+        return stream.createUnfilteredStream();
+    }
+
+    /**
+     * This will get a stream that can be read from.
+     * 
+     * @return An input stream that can be read from.
+     * 
+     * @throws IOException
+     *             If an IO error occurs during reading.
+     */
+    public InputStream createInputStream() throws IOException
+    {
+        return stream.getUnfilteredStream();
+    }
+
+    /**
+     * This will get a stream with some filters applied but not others. This is
+     * useful when doing images, ie filters = [flate,dct], we want to remove
+     * flate but leave dct
+     * 
+     * @param stopFilters
+     *            A list of filters to stop decoding at.
+     * @return A stream with decoded data.
+     * @throws IOException
+     *             If there is an error processing the stream.
+     */
+    public InputStream getPartiallyFilteredStream(List<String> stopFilters)
+            throws IOException
+    {
+        FilterManager manager = stream.getFilterManager();
+        InputStream is = stream.getFilteredStream();
+        ByteArrayOutputStream os = new ByteArrayOutputStream();
+        List<COSName> filters = getFilters();
+        COSName nextFilter = null;
+        boolean done = false;
+        for (int i = 0; i < filters.size() && !done; i++)
+        {
+            os.reset();
+            nextFilter = filters.get(i);
+            if (stopFilters.contains(nextFilter.getName()))
+            {
+                done = true;
+            } 
+            else
+            {
+                Filter filter = manager.getFilter(nextFilter);
+                filter.decode(is, os, stream, i);
+                is = new ByteArrayInputStream(os.toByteArray());
+            }
+        }
+        return is;
+    }
+
+    /**
+     * Get the cos stream associated with this object.
+     * 
+     * @return The cos object that matches this Java object.
+     */
+    public COSStream getStream()
+    {
+        return stream;
+    }
+
+    /**
+     * This will get the length of the filtered/compressed stream. This is
+     * readonly in the PD Model and will be managed by this class.
+     * 
+     * @return The length of the filtered stream.
+     */
+    public int getLength()
+    {
+        return stream.getInt(COSName.LENGTH, 0);
+    }
+
+    /**
+     * This will get the list of filters that are associated with this stream.
+     * Or null if there are none.
+     * 
+     * @return A list of all encoding filters to apply to this stream.
+     */
+    public List<COSName> getFilters()
+    {
+        List<COSName> retval = null;
+        COSBase filters = stream.getFilters();
+        if (filters instanceof COSName)
+        {
+            COSName name = (COSName) filters;
+            retval = new COSArrayList<COSName>(name, name, stream,
+                    COSName.FILTER);
+        } 
+        else if (filters instanceof COSArray)
+        {
+            retval = (List<COSName>) ((COSArray) filters).toList();
+        }
+        return retval;
+    }
+
+    /**
+     * This will set the filters that are part of this stream.
+     * 
+     * @param filters
+     *            The filters that are part of this stream.
+     */
+    public void setFilters(List<COSName> filters)
+    {
+        COSBase obj = COSArrayList.converterToCOSArray(filters);
+        stream.setItem(COSName.FILTER, obj);
+    }
+
+    /**
+     * Get the list of decode parameters. Each entry in the list will refer to
+     * an entry in the filters list.
+     * 
+     * @return The list of decode parameters.
+     * 
+     * @throws IOException
+     *             if there is an error retrieving the parameters.
+     */
+    public List<Object> getDecodeParms() throws IOException
+    {
+        List<Object> retval = null;
+
+        COSBase dp = stream.getDictionaryObject(COSName.DECODE_PARMS);
+        if (dp == null)
+        {
+            // See PDF Ref 1.5 implementation note 7, the DP is sometimes used
+            // instead.
+            dp = stream.getDictionaryObject(COSName.DP);
+        }
+        if (dp instanceof COSDictionary)
+        {
+            Map<?, ?> map = COSDictionaryMap
+                    .convertBasicTypesToMap((COSDictionary) dp);
+            retval = new COSArrayList<Object>(map, dp, stream,
+                    COSName.DECODE_PARMS);
+        } 
+        else if (dp instanceof COSArray)
+        {
+            COSArray array = (COSArray) dp;
+            List<Object> actuals = new ArrayList<Object>();
+            for (int i = 0; i < array.size(); i++)
+            {
+                actuals.add(COSDictionaryMap
+                        .convertBasicTypesToMap((COSDictionary) array
+                                .getObject(i)));
+            }
+            retval = new COSArrayList<Object>(actuals, array);
+        }
+
+        return retval;
+    }
+
+    /**
+     * This will set the list of decode parameterss.
+     * 
+     * @param decodeParams
+     *            The list of decode parameterss.
+     */
+    public void setDecodeParms(List<?> decodeParams)
+    {
+        stream.setItem(COSName.DECODE_PARMS,
+                COSArrayList.converterToCOSArray(decodeParams));
+    }
+
+    /**
+     * This will get the file specification for this stream. This is only
+     * required for external files.
+     * 
+     * @return The file specification.
+     * 
+     * @throws IOException
+     *             If there is an error creating the file spec.
+     */
+    public PDFileSpecification getFile() throws IOException
+    {
+        COSBase f = stream.getDictionaryObject(COSName.F);
+        PDFileSpecification retval = PDFileSpecification.createFS(f);
+        return retval;
+    }
+
+    /**
+     * Set the file specification.
+     * 
+     * @param f
+     *            The file specification.
+     */
+    public void setFile(PDFileSpecification f)
+    {
+        stream.setItem(COSName.F, f);
+    }
+
+    /**
+     * This will get the list of filters that are associated with this stream.
+     * Or null if there are none.
+     * 
+     * @return A list of all encoding filters to apply to this stream.
+     */
+    public List<String> getFileFilters()
+    {
+        List<String> retval = null;
+        COSBase filters = stream.getDictionaryObject(COSName.F_FILTER);
+        if (filters instanceof COSName)
+        {
+            COSName name = (COSName) filters;
+            retval = new COSArrayList<String>(name.getName(), name, stream,
+                    COSName.F_FILTER);
+        } 
+        else if (filters instanceof COSArray)
+        {
+            retval = COSArrayList
+                    .convertCOSNameCOSArrayToList((COSArray) filters);
+        }
+        return retval;
+    }
+
+    /**
+     * This will set the filters that are part of this stream.
+     * 
+     * @param filters
+     *            The filters that are part of this stream.
+     */
+    public void setFileFilters(List<String> filters)
+    {
+        COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);
+        stream.setItem(COSName.F_FILTER, obj);
+    }
+
+    /**
+     * Get the list of decode parameters. Each entry in the list will refer to
+     * an entry in the filters list.
+     * 
+     * @return The list of decode parameters.
+     * 
+     * @throws IOException
+     *             if there is an error retrieving the parameters.
+     */
+    public List<Object> getFileDecodeParams() throws IOException
+    {
+        List<Object> retval = null;
+
+        COSBase dp = stream.getDictionaryObject(COSName.F_DECODE_PARMS);
+        if (dp instanceof COSDictionary)
+        {
+            Map<?, ?> map = COSDictionaryMap
+                    .convertBasicTypesToMap((COSDictionary) dp);
+            retval = new COSArrayList<Object>(map, dp, stream,
+                    COSName.F_DECODE_PARMS);
+        } 
+        else if (dp instanceof COSArray)
+        {
+            COSArray array = (COSArray) dp;
+            List<Object> actuals = new ArrayList<Object>();
+            for (int i = 0; i < array.size(); i++)
+            {
+                actuals.add(COSDictionaryMap
+                        .convertBasicTypesToMap((COSDictionary) array
+                                .getObject(i)));
+            }
+            retval = new COSArrayList<Object>(actuals, array);
+        }
+
+        return retval;
+    }
+
+    /**
+     * This will set the list of decode params.
+     * 
+     * @param decodeParams
+     *            The list of decode params.
+     */
+    public void setFileDecodeParams(List<?> decodeParams)
+    {
+        stream.setItem("FDecodeParams",
+                COSArrayList.converterToCOSArray(decodeParams));
+    }
+
+    /**
+     * This will copy the stream into a byte array.
+     * 
+     * @return The byte array of the filteredStream
+     * @throws IOException
+     *             When getFilteredStream did not work
+     */
+    public byte[] getByteArray() throws IOException
+    {
+        ByteArrayOutputStream output = new ByteArrayOutputStream();
+        byte[] buf = new byte[1024];
+        InputStream is = null;
+        try
+        {
+            is = createInputStream();
+            int amountRead = -1;
+            while ((amountRead = is.read(buf)) != -1)
+            {
+                output.write(buf, 0, amountRead);
+            }
+        } 
+        finally
+        {
+            if (is != null)
+            {
+                is.close();
+            }
+        }
+        return output.toByteArray();
+    }
+
+    /**
+     * A convenience method to get this stream as a string. Uses the default
+     * system encoding.
+     * 
+     * @return a String representation of this (input) stream.
+     * 
+     * @throws IOException
+     *             if there is an error while converting the stream to a string.
+     */
+    public String getInputStreamAsString() throws IOException
+    {
+        byte[] bStream = getByteArray();
+        return new String(bStream, "ISO-8859-1");
+    }
+
+    /**
+     * Get the metadata that is part of the document catalog. This will return
+     * null if there is no meta data for this object.
+     * 
+     * @return The metadata for this object.
+     * @throws IllegalStateException
+     *             if the value of the metadata entry is different from a stream
+     *             or null
+     */
+    public PDMetadata getMetadata()
+    {
+        PDMetadata retval = null;
+        COSBase mdStream = stream.getDictionaryObject(COSName.METADATA);
+        if (mdStream != null)
+        {
+            if (mdStream instanceof COSStream)
+            {
+                retval = new PDMetadata((COSStream) mdStream);
+            } 
+            else if (mdStream instanceof COSNull)
+            {
+                // null is authorized
+            } 
+            else
+            {
+                throw new IllegalStateException(
+                        "Expected a COSStream but was a "
+                                + mdStream.getClass().getSimpleName());
+            }
+        }
+        return retval;
+    }
+
+    /**
+     * Set the metadata for this object. This can be null.
+     * 
+     * @param meta
+     *            The meta data for this object.
+     */
+    public void setMetadata(PDMetadata meta)
+    {
+        stream.setItem(COSName.METADATA, meta);
+    }
+
+    /**
+     * Get the decoded stream length.
+     * 
+     * @since Apache PDFBox 1.1.0
+     * @see <a
+     *      href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
+     * @return the decoded stream length
+     */
+    public int getDecodedStreamLength()
+    {
+        return this.stream.getInt(COSName.DL);
+    }
+
+    /**
+     * Set the decoded stream length.
+     * 
+     * @since Apache PDFBox 1.1.0
+     * @see <a
+     *      href="https://issues.apache.org/jira/browse/PDFBOX-636">PDFBOX-636</a>
+     * @param decodedStreamLength
+     *            the decoded stream length
+     */
+    public void setDecodedStreamLength(int decodedStreamLength)
+    {
+        this.stream.setInt(COSName.DL, decodedStreamLength);
+    }
 
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
index 2b7fd644bc..c36ce0bc7b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureElement.java
@@ -37,9 +37,9 @@ import org.apache.pdfbox.pdmodel.documentinterchange.markedcontent.PDMarkedConte
  */
 public class PDStructureElement extends PDStructureNode
 {
+    
     public static final String TYPE = "StructElem";
 
-
     /**
      * Constructor with required values.
      *
@@ -490,7 +490,7 @@ public class PDStructureElement extends PDStructureNode
     }
 
     /**
-     * Increments th revision number
+     * Increments th revision number.
      */
     public void incrementRevisionNumber()
     {
@@ -606,15 +606,14 @@ public class PDStructureElement extends PDStructureNode
     public String getStandardStructureType()
     {
         String type = this.getStructureType();
-        String mappedType;
-        while (true)
+        Map<String,Object> roleMap = getRoleMap();
+        if (roleMap.containsKey(type))
         {
-            mappedType = this.getRoleMap().get(type);
-            if ((mappedType == null) || type.equals(mappedType))
+            Object mappedValue = getRoleMap().get(type);
+            if (mappedValue instanceof String)
             {
-                break;
+                type = (String)mappedValue;
             }
-            type = mappedType;
         }
         return type;
     }
@@ -742,7 +741,7 @@ public class PDStructureElement extends PDStructureNode
      * 
      * @return the role map
      */
-    private Map<String, String> getRoleMap()
+    private Map<String, Object> getRoleMap()
     {
         PDStructureTreeRoot root = this.getStructureTreeRoot();
         if (root != null)
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
index 6e67799e2d..762e04e019 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/documentinterchange/logicalstructure/PDStructureTreeRoot.java
@@ -100,8 +100,7 @@ public class PDStructureTreeRoot extends PDStructureNode
      * 
      * @return the role map
      */
-    @SuppressWarnings("unchecked")
-    public Map<String, String> getRoleMap()
+    public Map<String, Object> getRoleMap()
     {
         COSBase rm = this.getCOSDictionary().getDictionaryObject(COSName.ROLE_MAP);
         if (rm instanceof COSDictionary)
@@ -115,7 +114,7 @@ public class PDStructureTreeRoot extends PDStructureNode
                 e.printStackTrace();
             }
         }
-        return new Hashtable<String, String>();
+        return new Hashtable<String, Object>();
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
index 467fb0aaba..3497f563ac 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/AxialShadingPaint.java
@@ -24,6 +24,7 @@ import java.awt.geom.AffineTransform;
 import java.awt.geom.Rectangle2D;
 import java.awt.image.ColorModel;
 
+import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.util.Matrix;
 
 /**
@@ -38,6 +39,7 @@ public class AxialShadingPaint implements Paint
 
     private PDShadingType2 shading;
     private Matrix currentTransformationMatrix;
+    private Matrix shadingMatrix;
     private int pageHeight;
     
     /**
@@ -47,12 +49,14 @@ public class AxialShadingPaint implements Paint
      * @param ctm current transformation matrix
      * @param pageSizeValue size of the current page
      */
-    public AxialShadingPaint(PDShadingType2 shadingType2, Matrix ctm, int pageHeightValue) 
+    public AxialShadingPaint(PDShadingType2 shadingType2, Matrix ctm, int pageHeightValue, Matrix shMatrix) 
     {
         shading = shadingType2;
         currentTransformationMatrix = ctm;
+        shadingMatrix = shMatrix;
         pageHeight = pageHeightValue;
     }
+
     /**
      * {@inheritDoc}
      */
@@ -67,7 +71,7 @@ public class AxialShadingPaint implements Paint
     public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
             Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) 
     {
-        return new AxialShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight);
+        return new AxialShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight, shadingMatrix);
     }
 
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingResources.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingResources.java
index 5af6619b99..b931ac78d2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingResources.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/PDShadingResources.java
@@ -25,6 +25,7 @@ import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.pdmodel.common.COSObjectable;
+import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpaceFactory;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
index b5420d22fe..c5c8c567a2 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingContext.java
@@ -17,8 +17,11 @@
 package org.apache.pdfbox.pdmodel.graphics.shading;
 
 import java.awt.PaintContext;
+import java.awt.Point;
 import java.awt.color.ColorSpace;
 import java.awt.geom.AffineTransform;
+import java.awt.geom.NoninvertibleTransformException;
+import java.awt.geom.Point2D;
 import java.awt.image.ColorModel;
 import java.awt.image.Raster;
 import java.awt.image.WritableRaster;
@@ -50,15 +53,20 @@ public class RadialShadingContext implements PaintContext
     private ColorSpace shadingColorSpace;
     private PDFunction shadingTinttransform;
 
-    private float[] coords;
+    private AffineTransform transformAT = null;
+    private Matrix currentCTM = null;
+    private int currentPageHeight;
+    private float maximumHeight;
+    private float clippingHeight;
+
     private float[] domain;
     private boolean[] extend;
-    private double x1x0; 
-    private double y1y0;
-    private double r1r0;
-    private double x1x0pow2;
-    private double y1y0pow2;
-    private double r0pow2;
+    private float x0;
+    private float x1;
+    private float y0;
+    private float y1;
+    private float r0;
+    private float r1;
 
     private float d1d0;
     private double denom;
@@ -79,32 +87,53 @@ public class RadialShadingContext implements PaintContext
      * 
      */
     public RadialShadingContext(PDShadingType3 shadingType3, ColorModel colorModelValue, 
-            AffineTransform xform, Matrix ctm, int pageHeight) 
+            AffineTransform xform, Matrix ctm, int pageHeight, Matrix shMatrix, float clipHeight) 
     {
-        coords = shadingType3.getCoords().toFloatArray();
-        if (ctm != null)
+        float[] coords = shadingType3.getCoords().toFloatArray();
+        x0 = coords[0];
+        y0 = coords[1];
+        r0 = coords[2];
+        x1 = coords[3];
+        y1 = coords[4];
+        r1 = coords[5];
+        if (clipHeight > 0)
         {
-            // the shading is used in combination with the sh-operator
-            float[] coordsTemp = new float[coords.length]; 
-            // transform the coords from shading to user space
-            ctm.createAffineTransform().transform(coords, 0, coordsTemp, 0, 1);
-            ctm.createAffineTransform().transform(coords, 3, coordsTemp, 3, 1);
-            // move the 0,0-reference
-            coordsTemp[1] = pageHeight - coordsTemp[1];
-            coordsTemp[4] = pageHeight - coordsTemp[4];
-            // transform the coords from user to device space
-            xform.transform(coordsTemp, 0, coords, 0, 1);
-            xform.transform(coordsTemp, 3, coords, 3, 1);
+            maximumHeight = 0;
+            clippingHeight = clipHeight;
         }
         else
         {
-            // the shading is used as pattern colorspace in combination
-            // with a fill-, stroke- or showText-operator
-            float translateY = (float)xform.getTranslateY();
-            // move the 0,0-reference including the y-translation from user to device space
-            coords[1] = pageHeight + translateY - coords[1];
-            coords[4] = pageHeight + translateY - coords[4];
+            maximumHeight = Math.max((y1+r1),(y0+r0)) - Math.min((y1-r1), (y0-r0));
+            clippingHeight = 0;
+        }
+        // transformation
+//        if (shMatrix != null)
+//        {
+//            transformAT = xform;
+//            transformAT.translate(0, -maximumHeight);
+//            transformAT.concatenate(shMatrix.createAffineTransform());
+//        }
+//        else if (currentCTM != null)
+//        {
+//            transformAT = ctm.createAffineTransform();
+//            transformAT.translate(0, -clippingHeight);
+//            transformAT.concatenate(xform);
+//        }
+//        else
+//        {
+//            transformAT = xform;
+//            transformAT.translate(0, -clipHeight);
+//        }
+        try
+        {
+            transformAT = xform.createInverse();
+        } 
+        catch (NoninvertibleTransformException e)
+        {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
         }
+        currentPageHeight = pageHeight;
         // colorSpace 
         try 
         {
@@ -177,13 +206,7 @@ public class RadialShadingContext implements PaintContext
             extend = new boolean[]{false,false};
         }
         // calculate some constants to be used in getRaster
-        x1x0 = coords[3] - coords[0]; 
-        y1y0 = coords[4] - coords[1];
-        r1r0 = coords[5] - coords[2];
-        x1x0pow2 = Math.pow(x1x0,2);
-        y1y0pow2 = Math.pow(y1y0,2);
-        r0pow2 = Math.pow(coords[2],2);
-        denom = x1x0pow2 + y1y0pow2 - Math.pow(r1r0, 2);
+        denom = Math.pow(r1-r0,2) - Math.pow(x1-x0,2) - Math.pow(y1-y0,2);
         d1d0 = domain[1]-domain[0];
         // TODO take a possible Background value into account
         
@@ -197,6 +220,7 @@ public class RadialShadingContext implements PaintContext
         function = null;
         shadingColorSpace = null;
         shadingTinttransform = null;
+        currentCTM = null;
     }
 
     /**
@@ -212,16 +236,14 @@ public class RadialShadingContext implements PaintContext
      */
     public Raster getRaster(int x, int y, int w, int h) 
     {
-        // create writable raster
-        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
         float[] input = new float[1];
-        float inputValue;
+        float inputValue = 0;
         int[] data = new int[w * h * 3];
         for (int j = 0; j < h; j++) 
         {
             for (int i = 0; i < w; i++) 
             {
-                float[] inputValues = calculateInputValues(x + i, y + j);
+                float[] inputValues = calculateInputValues( x+i, y+j);
                 // choose 1 of the 2 values
                 if (inputValues[0] >= domain[0] && inputValues[0] <= domain[1])
                 {
@@ -243,37 +265,46 @@ public class RadialShadingContext implements PaintContext
                     {
                         inputValue = inputValues[1];
                     }
-                    // TODO
-                    // both are not in the domain -> choose the first as I don't know it better
+                    // both are not in the domain
                     else
                     {
-                        inputValue = inputValues[0];
-                    }
-                }
-                // input value is out of range
-                if (inputValue < domain[0])
-                {
-                    // the shading has to be extended if extend[0] == true
-                    if (extend[0])
-                    {
-                        inputValue = domain[0];
-                    }
-                    else 
-                    {
-                        continue;
-                    }
-                }
-                // input value is out of range
-                else if (inputValue > domain[1])
-                {
-                    // the shading has to be extended if extend[1] == true
-                    if (extend[1])
-                    {
-                        inputValue = domain[1];
-                    }
-                    else 
-                    {
-                        continue;
+                        if (!extend[0] && !extend[1])
+                        {
+                            // TODO background
+                            continue;
+                        }
+                        boolean extended = false;
+                        // extend
+                        if (extend[0])
+                        {
+                            if((r0 + inputValues[0]*(r1-r0)) >= 0 && inputValues[0] < 0)
+                            {
+                                inputValue = domain[0];
+                                extended = true;
+                            }
+                            else if ((r0 + inputValues[1]*(r1-r0)) >= 0 && inputValues[1] < 0)
+                            {
+                                inputValue = domain[0];
+                                extended = true;
+                            }
+                        }
+                        if (!extended && extend[1])
+                        {
+                            if((r0 + inputValues[0]*(r1-r0)) >= 0 && inputValues[0] > 0)
+                            {
+                                inputValue = domain[1];
+                                extended = true;
+                            }
+                            else if((r0 + inputValues[1]*(r1-r0)) >= 0 && inputValues[1] > 0)
+                            {
+                                inputValue = domain[1];
+                                extended = true;
+                            }
+                        }
+                        if (!extended)
+                        {
+                            continue;
+                        }
                     }
                 }
                 input[0] = (float)(domain[0] + (d1d0*inputValue));
@@ -301,6 +332,8 @@ public class RadialShadingContext implements PaintContext
                 data[index+2] = (int)(values[2]*255);
             }
         }
+        // create writable raster
+        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
         raster.setPixels(0, 0, w, h, data);
         return raster;
     }
@@ -331,12 +364,23 @@ public class RadialShadingContext implements PaintContext
          *  The following code calculates the 2 possible values of s
          */
         
-        float[] values = new float[2];
-        double p = (-0.25)*((x - coords[0])*x1x0 + (y - coords[1])*y1y0 - r1r0) / denom;
-        double q = (Math.pow(x - coords[0],2) + Math.pow(y - coords[1],2) - r0pow2) / denom;
-        double root = Math.sqrt(Math.pow(p , 2) - q);
-        values[0] = (float)((-1)*p + root);
-        values[1] = (float)((-1)*p - root);
-        return values;
+//        float[] srcPoint = new float[] {x, currentPageHeight + maximumHeight + clippingHeight - y };
+      float[] srcPoint = new float[] {x, currentPageHeight - y };
+//        float[] srcPoint = new float[] {x,y};
+        float[] dstPoint = new float[2];
+        transformAT.transform(srcPoint, 0, dstPoint, 0, 1);
+        // -p/2
+        float p = r0*(r1-r0) + (dstPoint[0]-x0)*(x1-x0) + (dstPoint[1]-y0)*(y1-y0);
+        p /= -denom;
+        // q
+        float q = (float)(Math.pow(r0,2) - Math.pow((dstPoint[0]-x0),2) -Math.pow((dstPoint[1]-y0),2)); 
+        q /= denom;
+        // root
+        float root = (float)Math.sqrt(Math.pow(p , 2) - q);
+        // results
+        if (denom > 0)
+            return new float[]{(p - root), (p + root)};
+        else
+            return new float[]{(p + root), (p - root)};
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
index aa9867f6d9..8d4c1f79da 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/RadialShadingPaint.java
@@ -24,6 +24,7 @@ import java.awt.geom.AffineTransform;
 import java.awt.geom.Rectangle2D;
 import java.awt.image.ColorModel;
 
+import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.util.Matrix;
 
 /**
@@ -38,7 +39,9 @@ public class RadialShadingPaint implements Paint
 
     private PDShadingType3 shading;
     private Matrix currentTransformationMatrix;
+    private Matrix shadingMatrix;
     private int pageHeight;
+    private float clippingHeight;
     
     /**
      * Constructor.
@@ -47,12 +50,28 @@ public class RadialShadingPaint implements Paint
      * @param ctm current transformation matrix
      * @param pageSizeValue size of the current page
      */
-    public RadialShadingPaint(PDShadingType3 shadingType3, Matrix ctm, int pageHeightValue) 
+    public RadialShadingPaint(PDShadingType3 shadingType3, Matrix ctm, int pageHeightValue, Matrix shMatrix) 
     {
         shading = shadingType3;
         currentTransformationMatrix = ctm;
         pageHeight = pageHeightValue;
+        shadingMatrix = shMatrix;
     }
+    /**
+     * Constructor.
+     * 
+     * @param shadingType3 the shading resources
+     * @param ctm current transformation matrix
+     * @param pageSizeValue size of the current page
+     */
+    public RadialShadingPaint(PDShadingType3 shadingType3, Matrix ctm, int pageHeightValue, float clipHeight) 
+    {
+        shading = shadingType3;
+        currentTransformationMatrix = ctm;
+        pageHeight = pageHeightValue;
+        clippingHeight = clipHeight;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -67,7 +86,7 @@ public class RadialShadingPaint implements Paint
     public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,
             Rectangle2D userBounds, AffineTransform xform, RenderingHints hints) 
     {
-        return new RadialShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight);
+        return new RadialShadingContext(shading, cm, xform, currentTransformationMatrix, pageHeight, shadingMatrix, clippingHeight);
     }
 
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TempRadialShadingContext.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TempRadialShadingContext.java
new file mode 100644
index 0000000000..f8b82c0f05
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/shading/TempRadialShadingContext.java
@@ -0,0 +1,404 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pdfbox.pdmodel.graphics.shading;
+
+import java.awt.PaintContext;
+import java.awt.Point;
+import java.awt.color.ColorSpace;
+import java.awt.geom.AffineTransform;
+import java.awt.geom.NoninvertibleTransformException;
+import java.awt.image.ColorModel;
+import java.awt.image.Raster;
+import java.awt.image.WritableRaster;
+import java.io.IOException;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.pdfbox.cos.COSArray;
+import org.apache.pdfbox.cos.COSBoolean;
+import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.cos.COSNumber;
+import org.apache.pdfbox.pdmodel.common.PDMatrix;
+import org.apache.pdfbox.pdmodel.common.function.PDFunction;
+import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
+import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceN;
+import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceRGB;
+import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
+import org.apache.pdfbox.util.Matrix;
+
+/**
+ * This class represents the PaintContext of an radial shading.
+ * 
+ * @author lehmi
+ * @version $Revision: $
+ * 
+ */
+public class TempRadialShadingContext implements PaintContext 
+{
+
+    private ColorModel colorModel;
+    private PDFunction function;
+    private ColorSpace shadingColorSpace;
+    private PDFunction shadingTinttransform;
+
+//    private float[] coords;
+    private float[] domain;
+    private boolean[] extend;
+    private float x0;
+    private float x1;
+    private float y0;
+    private float y1;
+    private float r0;
+    private float r1;
+//    private double x1x0; 
+//    private double y1y0;
+//    private double r1r0;
+//    private double x1x0pow2;
+//    private double y1y0pow2;
+//    private double r1r0pow2;
+//    private double x0pow2;
+//    private double y0pow2;
+//    private double r0pow2;
+
+    private float d1d0;
+    private double denom;
+//    private AffineTransform currentXForm = null;
+//    private AffineTransform matrix = null;
+    private AffineTransform transformAT = null;
+    private Matrix currentCTM = null;
+    private int currentPageHeight;
+    private float maximumHeight;
+    
+    /**
+     * Log instance.
+     */
+    private static final Log LOG = LogFactory.getLog(RadialShadingContext.class);
+
+    /**
+     * Constructor creates an instance to be used for fill operations.
+     * 
+     * @param shadingType3 the shading type to be used
+     * @param colorModelValue the color model to be used
+     * @param xform transformation for user to device space
+     * @param ctm current transformation matrix
+     * @param pageHeight height of the current page
+     * 
+     */
+    public TempRadialShadingContext(PDShadingType3 shadingType3, ColorModel colorModelValue, 
+            AffineTransform xform, Matrix ctm, int pageHeight, Matrix shadingMatrix) 
+    {
+        float[] coords = shadingType3.getCoords().toFloatArray();
+//        if (ctm != null)
+//        {
+//            // the shading is used in combination with the sh-operator
+//            float[] coordsTemp = new float[coords.length]; 
+//            // transform the coords from shading to user space
+//            ctm.createAffineTransform().transform(coords, 0, coordsTemp, 0, 1);
+//            ctm.createAffineTransform().transform(coords, 3, coordsTemp, 3, 1);
+//            // move the 0,0-reference
+//            coordsTemp[1] = pageHeight - coordsTemp[1];
+//            coordsTemp[4] = pageHeight - coordsTemp[4];
+//            // transform the coords from user to device space
+//            xform.transform(coordsTemp, 0, coords, 0, 1);
+//            xform.transform(coordsTemp, 3, coords, 3, 1);
+//        }
+//        else
+//        {
+//            // the shading is used as pattern colorspace in combination
+//            // with a fill-, stroke- or showText-operator
+//            float translateY = (float)xform.getTranslateY();
+//            // move the 0,0-reference including the y-translation from user to device space
+////            coords[1] = pageHeight + translateY - coords[1];
+////            coords[4] = pageHeight + translateY - coords[4];
+//        }
+        // matrix
+//        if (shadingMatrix != null)
+//        {
+//            matrix = ctm.createAffineTransform();
+//        }
+//        currentCTM = ctm;
+//        currentXForm = xform;
+        transformAT = xform;
+        transformAT.concatenate(ctm.createAffineTransform());
+        currentPageHeight = pageHeight;
+        // colorSpace 
+        try 
+        {
+            PDColorSpace cs = shadingType3.getColorSpace();
+            if (!(cs instanceof PDDeviceRGB))
+            {
+                // we have to create an instance of the shading colorspace if it isn't RGB
+                shadingColorSpace = cs.getJavaColorSpace();
+                if (cs instanceof PDDeviceN)
+                {
+                    shadingTinttransform = ((PDDeviceN)cs).getTintTransform();
+                }
+                else if (cs instanceof PDSeparation)
+                {
+                    shadingTinttransform = ((PDSeparation)cs).getTintTransform();
+                }
+            }
+        } 
+        catch (IOException exception) 
+        {
+            LOG.error("error while creating colorSpace", exception);
+        }
+        // colorModel
+        if (colorModelValue != null)
+        {
+            colorModel = colorModelValue;
+        }
+        else
+        {
+            try
+            {
+                // TODO bpc != 8 ??  
+                colorModel = shadingType3.getColorSpace().createColorModel(8);
+            }
+            catch(IOException exception)
+            {
+                LOG.error("error while creating colorModel", exception);
+            }
+        }
+        // shading function
+        try
+        {
+            function = shadingType3.getFunction();
+        }
+        catch(IOException exception)
+        {
+            LOG.error("error while creating a function", exception);
+        }
+        // domain values
+        if (shadingType3.getDomain() != null)
+        {
+            domain = shadingType3.getDomain().toFloatArray();
+        }
+        else 
+        {
+            // set default values
+            domain = new float[]{0,1};
+        }
+        // extend values
+        COSArray extendValues = shadingType3.getExtend();
+        if (shadingType3.getExtend() != null)
+        {
+            extend = new boolean[2];
+            extend[0] = ((COSBoolean)extendValues.get(0)).getValue();
+            extend[1] = ((COSBoolean)extendValues.get(1)).getValue();
+        }
+        else
+        {
+            // set default values
+            extend = new boolean[]{false,false};
+        }
+        // calculate some constants to be used in getRaster
+        x0 = coords[0];
+        y0 = coords[1];
+        r0 = coords[2];
+        x1 = coords[3];
+        y1 = coords[4];
+        r1 = coords[5];
+        maximumHeight = Math.max((y1+r1),(y0+r0)) - Math.min((y1-r1), (y0-r0));
+        denom = Math.pow(r1-r0,2) - Math.pow(x1-x0,2) - Math.pow(y1-y0,2);
+        d1d0 = domain[1]-domain[0];
+        // TODO take a possible Background value into account
+        
+    }
+    /**
+     * {@inheritDoc}
+     */
+    public void dispose() 
+    {
+        colorModel = null;
+        function = null;
+        shadingColorSpace = null;
+        shadingTinttransform = null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public ColorModel getColorModel() 
+    {
+        return colorModel;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Raster getRaster(int x, int y, int w, int h) 
+    {
+        System.out.println("x="+x+",y="+y+",w="+w+",h="+h);
+        System.out.println("x0="+x0+",x1="+x1);
+        System.out.println("y0="+y0+",y1="+y1);
+        System.out.println("r0="+r0+",r1="+r1);
+//        System.out.println("matrix="+matrix);
+//        System.out.println("ctm="+currentCTM);
+//        System.out.println("xform="+currentXForm);
+        System.out.println("==================================================");
+        // create writable raster
+        WritableRaster raster = getColorModel().createCompatibleWritableRaster(w, h);
+        float[] input = new float[1];
+        float inputValue;
+        int[] data = new int[w * h * 3];
+        for (int j = 0; j < h; j++) 
+        {
+            for (int i = 0; i < w; i++) 
+            {
+                float[] inputValues = calculateInputValues(x + i, y + j);
+                // choose 1 of the 2 values
+                if (inputValues[0] >= domain[0] && inputValues[0] <= domain[1])
+                {
+                    // both values are in the domain -> choose the larger one 
+                    if(inputValues[1] >= domain[0] && inputValues[1] <= domain[1])
+                    {
+                        inputValue = Math.max(inputValues[0], inputValues[1]);
+                    } 
+                    // first value is in the domain, the second not -> choose first value
+                    else
+                    {
+                        inputValue = inputValues[0];
+                    }
+                }
+                else
+                {
+                    // first value is not in the domain, but the second -> choose second value
+                    if(inputValues[1] >= domain[0] && inputValues[1] <= domain[1])
+                    {
+                        inputValue = inputValues[1];
+                    }
+                    // TODO
+                    // both are not in the domain -> choose the first as I don't know it better
+                    else
+                    {
+                        inputValue = inputValues[0];
+                    }
+                }
+                // input value is out of range
+                if (inputValue < domain[0])
+                {
+                    // the shading has to be extended if extend[0] == true
+                    if (extend[0])
+                    {
+                        inputValue = domain[0];
+                    }
+                    else 
+                    {
+                        continue;
+                    }
+                }
+                // input value is out of range
+                else if (inputValue > domain[1])
+                {
+                    // the shading has to be extended if extend[1] == true
+                    if (extend[1])
+                    {
+                        inputValue = domain[1];
+                    }
+                    else 
+                    {
+                        continue;
+                    }
+                }
+                input[0] = (float)(domain[0] + (d1d0*inputValue));
+                float[] values = null;
+                int index = (j * w + i) * 3;
+                try 
+                {
+                    values = function.eval(input);
+                    // convert color values from shading colorspace to RGB 
+                    if (shadingColorSpace != null)
+                    {
+                        if (shadingTinttransform != null)
+                        {
+                            values = shadingTinttransform.eval(values);
+                        }
+                        values = shadingColorSpace.toRGB(values);
+                    }
+                }
+                catch (IOException exception) 
+                {
+                    LOG.error("error while processing a function", exception);
+                }
+                data[index] = (int)(values[0]*255);
+                data[index+1] = (int)(values[1]*255);
+                data[index+2] = (int)(values[2]*255);
+            }
+        }
+        raster.setPixels(0, 0, w, h, data);
+        return raster;
+    }
+
+    private float[] calculateInputValues(int x, int y) 
+    {
+        
+        /** 
+         *  According to Adobes Technical Note #5600 we have to do the following 
+         *  
+         *  x0, y0, r0 defines the start circle
+         *  x1, y1, r1 defines the end circle
+         *  
+         *  The parametric equations for the center and radius of the gradient fill
+         *  circle moving between the start circle and the end circle as a function 
+         *  of s are as follows:
+         *  
+         *  xc(s) = x0 + s * (x1 - x0)
+         *  yc(s) = y0 + s * (y1 - y0)
+         *  r(s)  = r0 + s * (r1 - r0)
+         * 
+         *  Given a geometric coordinate position (x, y) in or along the gradient fill, 
+         *  the corresponding value of s can be determined by solving the quadratic 
+         *  constraint equation:
+         *  
+         *  [x - xc(s)]^2 + [y - yc(s)]^2 = [r(s)]^2
+         *  
+         *  The following code calculates the 2 possible values of s
+         */
+        
+        Point srcPoint = new Point(x,(int)(currentPageHeight + maximumHeight - y));
+        Point dstPoint = new Point();
+        try
+        {
+//            matrix.inverseTransform(srcPoint, dstPoint);
+//            currentXForm.inverseTransform(dstPoint,srcPoint);
+            transformAT.inverseTransform(srcPoint, dstPoint);
+        } catch (NoninvertibleTransformException e)
+        {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        double xDouble = dstPoint.getX();
+        double yDouble = dstPoint.getY();
+        float[] values = new float[2];
+        // p/2
+        float p = r0*(r1-r0);
+        p += (xDouble-x0)*(x1-x0);
+        p += (yDouble-y0)*(y1-y0);
+        p /= denom;
+        // q
+        double q = (Math.pow(r0,2) - Math.pow((xDouble-x0),2) -Math.pow((yDouble-y0),2)); 
+        q /=denom;
+        // root
+        double root = Math.sqrt(Math.pow(p , 2) - q);
+        // results
+        values[0] = (float)((-1)*p + root);
+        values[1] = (float)((-1)*p - root);
+        System.out.println("x="+xDouble+",y="+yDouble+" -> v0="+values[0]+",v1="+values[1]);
+        return values;
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/testSplit.java b/pdfbox/src/main/java/org/apache/pdfbox/testSplit.java
new file mode 100644
index 0000000000..60f4e9640a
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/testSplit.java
@@ -0,0 +1,42 @@
+package org.apache.pdfbox;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.pdfbox.exceptions.COSVisitorException;
+import org.apache.pdfbox.pdfwriter.COSWriter;
+import org.apache.pdfbox.pdmodel.PDDocument;
+import org.apache.pdfbox.util.Splitter;
+
+public class testSplit
+{
+
+    /**
+     * @param args
+     */
+    public static void main(String[] args) throws IOException, COSVisitorException
+    {
+        String pdfFile = "/home/lehmi/workspace/pdfs/splitter/HugePagesWhenSplit.pdf";
+        PDDocument document = PDDocument.load(pdfFile);
+        List<PDDocument> documents =  new Splitter().split( document );
+        for( int i=0; i<documents.size(); i++ )
+        {
+            PDDocument doc = documents.get( i );
+            String fileName = pdfFile.substring(0, pdfFile.length()-4 ) + "-" + i + ".pdf";
+            writeDocument( doc, fileName );
+            System.out.println(fileName);
+            doc.close();
+        }
+
+    }
+
+    private static void writeDocument(PDDocument doc, String onePage) throws IOException, COSVisitorException
+    {
+        final FileOutputStream output = new FileOutputStream(onePage);
+        final COSWriter writer = new COSWriter(output);
+        writer.write(doc);
+        output.close();
+        writer.close();
+    }
+}
