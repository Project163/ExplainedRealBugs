diff --git a/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java b/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
index e520ac4a45..af7efdd9ac 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/rendering/PageDrawer.java
@@ -69,6 +69,7 @@ import org.apache.pdfbox.pdmodel.graphics.state.PDSoftMask;
 import org.apache.pdfbox.pdmodel.graphics.state.RenderingMode;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink;
+import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationMarkup;
 import org.apache.pdfbox.pdmodel.interactive.annotation.PDBorderStyleDictionary;
 import org.apache.pdfbox.util.Matrix;
 import org.apache.pdfbox.util.Vector;
@@ -849,68 +850,86 @@ public class PageDrawer extends PDFGraphicsStreamEngine
             return;
         }
         super.showAnnotation(annotation);
-        
-        if (annotation instanceof PDAnnotationLink)
+
+        if (annotation.getAppearance() == null)
         {
-            showAnnotationLinkBorder((PDAnnotationLink) annotation);
+            if (annotation instanceof PDAnnotationLink)
+            {
+                drawAnnotationLinkBorder((PDAnnotationLink) annotation);
+            }
+
+            if (annotation instanceof PDAnnotationMarkup && annotation.getSubtype().equals(PDAnnotationMarkup.SUB_TYPE_INK))
+            {
+                drawAnnotationInk((PDAnnotationMarkup) annotation);
+            }
         }
     }
 
-    private void showAnnotationLinkBorder(PDAnnotationLink link) throws IOException
+    private class AnnotationBorder
     {
-        if (link.getAppearance() != null)
-        {
-            return;
-        }
-        COSArray border = link.getBorder();
-        PDBorderStyleDictionary borderStyle = link.getBorderStyle();
-        float width = 0;
         float[] dashArray = null;
         boolean underline = false;
+        float width = 0;
+        PDColor color;
+    }
+    
+    // return border info. BorderStyle must be provided as parameter because
+    // method is not available in the base class
+    private AnnotationBorder getAnnotationBorder(PDAnnotation annotation, 
+            PDBorderStyleDictionary borderStyle)
+    {
+        AnnotationBorder ab = new AnnotationBorder();
+        COSArray border = annotation.getBorder();
         if (borderStyle == null)
         {
             if (border.get(2) instanceof COSNumber)
             {
-                width = ((COSNumber) border.getObject(2)).floatValue();
+                ab.width = ((COSNumber) border.getObject(2)).floatValue();
             }
             if (border.size() > 3)
             {
                 COSBase base3 = border.getObject(3);
                 if (base3 instanceof COSArray)
                 {
-                    dashArray = ((COSArray) base3).toFloatArray();
+                    ab.dashArray = ((COSArray) base3).toFloatArray();
                 }
             }
         }
         else
         {
-            width = borderStyle.getWidth();
+            ab.width = borderStyle.getWidth();
             if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_DASHED))
             {
-                dashArray = borderStyle.getDashStyle().getDashArray();
+                ab.dashArray = borderStyle.getDashStyle().getDashArray();
             }
             if (borderStyle.getStyle().equals(PDBorderStyleDictionary.STYLE_UNDERLINE))
             {
-                underline = true;
+                ab.underline = true;
             }
         }
-        if (width == 0)
+        ab.color = annotation.getColor();
+        if (ab.color == null)
         {
-            return;
+            // spec is unclear, but black seems to be the right thing to do
+            ab.color = new PDColor(new float[] { 0 }, PDDeviceGray.INSTANCE);
         }
-        PDColor color = link.getColor();
-        if (color == null)
+        return ab;
+    }
+
+    private void drawAnnotationLinkBorder(PDAnnotationLink link) throws IOException
+    {
+        AnnotationBorder ab = getAnnotationBorder(link, link.getBorderStyle());
+        if (ab.width == 0)
         {
-            // spec is unclear, but black seems to be the right thing to do
-            color = new PDColor(new float[] { 0 }, PDDeviceGray.INSTANCE);
+            return;
         }
         PDRectangle rectangle = link.getRectangle();
         Stroke oldStroke = graphics.getStroke();
-        graphics.setPaint(getPaint(color));
-        BasicStroke stroke = new BasicStroke(width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10, dashArray, 0);
+        graphics.setPaint(getPaint(ab.color));
+        BasicStroke stroke = new BasicStroke(ab.width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10, ab.dashArray, 0);
         graphics.setStroke(stroke);
         graphics.setClip(null);
-        if (underline)
+        if (ab.underline)
         {
             graphics.drawLine((int) rectangle.getLowerLeftX(), (int) rectangle.getLowerLeftY(),
                     (int) (rectangle.getLowerLeftX() + rectangle.getWidth()), (int) rectangle.getLowerLeftY());
@@ -923,6 +942,66 @@ public class PageDrawer extends PDFGraphicsStreamEngine
         graphics.setStroke(oldStroke);
     }
 
+    private void drawAnnotationInk(PDAnnotationMarkup inkAnnotation) throws IOException
+    {
+        if (!inkAnnotation.getCOSObject().containsKey(COSName.INKLIST))
+        {
+            return;
+        }
+        //TODO there should be an InkAnnotation class with a getInkList method
+        COSBase base = inkAnnotation.getCOSObject().getDictionaryObject(COSName.INKLIST);
+        if (!(base instanceof COSArray))
+        {
+            return;
+        }
+        // PDF spec does not mention /Border for ink annotations, but it is used if /BS is not available
+        AnnotationBorder ab = getAnnotationBorder(inkAnnotation, inkAnnotation.getBorderStyle());
+        if (ab.width == 0)
+        {
+            return;
+        }
+        graphics.setPaint(getPaint(ab.color));
+        Stroke oldStroke = graphics.getStroke();
+        BasicStroke stroke = 
+                new BasicStroke(ab.width, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10, ab.dashArray, 0);
+        graphics.setStroke(stroke);
+        graphics.setClip(null);
+        COSArray pathsArray = (COSArray) base;
+        for (COSBase baseElement : (Iterable<? extends COSBase>) pathsArray.toList())
+        {
+            if (!(baseElement instanceof COSArray))
+            {
+                continue;
+            }
+            COSArray pathArray = (COSArray) baseElement;
+            int nPoints = pathArray.size() / 2;
+            
+            // "When drawn, the points shall be connected by straight lines or curves 
+            // in an implementation-dependent way" - we do lines.
+            GeneralPath path = new GeneralPath();
+            for (int i = 0; i < nPoints; ++i)
+            {
+                COSBase bx = pathArray.getObject(i * 2);
+                COSBase by = pathArray.getObject(i * 2 + 1);
+                if (bx instanceof COSNumber && by instanceof COSNumber)
+                {
+                    float x = ((COSNumber) bx).floatValue();
+                    float y = ((COSNumber) by).floatValue();
+                    if (i == 0)
+                    {
+                        path.moveTo(x, y);
+                    }
+                    else
+                    {
+                        path.lineTo(x, y);
+                    }
+                }
+            }
+            graphics.draw(path);
+        }
+        graphics.setStroke(oldStroke);
+    }
+
     @Override
     public void showTransparencyGroup(PDTransparencyGroup form) throws IOException
     {
