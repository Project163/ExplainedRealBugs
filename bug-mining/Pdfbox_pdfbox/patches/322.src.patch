diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
index 04155d8c1b..b07b014f01 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
@@ -375,10 +375,6 @@ public class PDFStreamParser extends BaseParser
             }
             case 'I':
             {
-                //ImageParameters imageParams = lastBIToken.getImageParameters();
-
-                //int expectedBytes = (int)Math.ceil(imageParams.getHeight() * imageParams.getWidth() *
-                //                    (imageParams.getBitsPerComponent()/8) );
                 //Special case for ID operator
                 String id = "" + (char)pdfSource.read() + (char)pdfSource.read();
                 if( !id.equals( "ID" ) )
@@ -395,7 +391,6 @@ public class PDFStreamParser extends BaseParser
                 int twoBytesAgo = 0;
                 int lastByte = pdfSource.read();
                 int currentByte = pdfSource.read();
-                int count = 0;
                 //PDF spec is kinda unclear about this.  Should a whitespace
                 //always appear before EI? Not sure, I found a PDF
                 //(UnderstandingWebSphereClassLoaders.pdf) which has EI as part
@@ -416,7 +411,6 @@ public class PDFStreamParser extends BaseParser
                     twoBytesAgo = lastByte;
                     lastByte = currentByte;
                     currentByte = pdfSource.read();
-                    count++;
                 }
                 pdfSource.unread( 'I' ); //unread the EI operator
                 pdfSource.unread( 'E' );
@@ -494,7 +488,7 @@ public class PDFStreamParser extends BaseParser
     
     private boolean isSpaceOrReturn( int c )
     {
-        return c == 13 || c == 32;
+        return c == 10 || c == 13 || c == 32;
     }
 
     private boolean isSpaceOrReturn() throws IOException
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
index 3b79134959..c203831540 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
@@ -20,26 +20,36 @@ import java.awt.BasicStroke;
 import java.awt.Color;
 import java.awt.Composite;
 import java.awt.Dimension;
+import java.awt.Font;
 import java.awt.Graphics;
 import java.awt.Graphics2D;
+import java.awt.Image;
 import java.awt.Paint;
-import java.awt.geom.Area;
 import java.awt.RenderingHints;
+import java.awt.font.FontRenderContext;
+import java.awt.font.GlyphVector;
 import java.awt.geom.AffineTransform;
+import java.awt.geom.Area;
 import java.awt.geom.GeneralPath;
+import java.awt.geom.NoninvertibleTransformException;
 import java.awt.geom.Point2D;
-import java.awt.Image;
 import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.pdmodel.PDPage;
 import org.apache.pdfbox.pdmodel.PDResources;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
+import org.apache.pdfbox.pdmodel.font.PDCIDFontType2Font;
 import org.apache.pdfbox.pdmodel.font.PDFont;
+import org.apache.pdfbox.pdmodel.font.PDSimpleFont;
+import org.apache.pdfbox.pdmodel.font.PDType0Font;
+import org.apache.pdfbox.pdmodel.font.PDType3Font;
 import org.apache.pdfbox.pdmodel.graphics.PDGraphicsState;
 import org.apache.pdfbox.pdmodel.graphics.PDShading;
 import org.apache.pdfbox.pdmodel.graphics.shading.AxialShadingPaint;
@@ -55,12 +65,10 @@ import org.apache.pdfbox.util.Matrix;
 import org.apache.pdfbox.util.PDFStreamEngine;
 import org.apache.pdfbox.util.ResourceLoader;
 import org.apache.pdfbox.util.TextPosition;
-import org.apache.pdfbox.cos.COSName;
-
 
 /**
  * This will paint a page in a PDF document to a graphics context.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
  * @version $Revision: 1.22 $
  */
@@ -73,7 +81,7 @@ public class PageDrawer extends PDFStreamEngine
     private static final Log LOG = LogFactory.getLog(PageDrawer.class);
 
     private Graphics2D graphics;
-    
+
     /**
      * clipping winding rule used for the clipping path.
      */
@@ -92,69 +100,72 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Default constructor, loads properties from file.
-     *
-     * @throws IOException If there is an error loading properties from the file.
+     * 
+     * @throws IOException
+     *             If there is an error loading properties from the file.
      */
     public PageDrawer() throws IOException
     {
-        super( ResourceLoader.loadProperties(
-                "org/apache/pdfbox/resources/PageDrawer.properties", true ) );
+        super(ResourceLoader.loadProperties("org/apache/pdfbox/resources/PageDrawer.properties", true));
     }
 
     /**
      * This will draw the page to the requested context.
-     *
-     * @param g The graphics context to draw onto.
-     * @param p The page to draw.
-     * @param pageDimension The size of the page to draw.
-     *
-     * @throws IOException If there is an IO error while drawing the page.
-     */
-    public void drawPage( Graphics g, PDPage p, Dimension pageDimension ) throws IOException
+     * 
+     * @param g
+     *            The graphics context to draw onto.
+     * @param p
+     *            The page to draw.
+     * @param pageDimension
+     *            The size of the page to draw.
+     * 
+     * @throws IOException
+     *             If there is an IO error while drawing the page.
+     */
+    public void drawPage(Graphics g, PDPage p, Dimension pageDimension) throws IOException
     {
-        graphics = (Graphics2D)g;
+        graphics = (Graphics2D) g;
         page = p;
         pageSize = pageDimension;
-        graphics.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
-        graphics.setRenderingHint( RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON );
-        // Only if there is some content, we have to process it. 
+        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
+        // Only if there is some content, we have to process it.
         // Otherwise we are done here and we will produce an empty page
-        if ( page.getContents() != null) 
+        if (page.getContents() != null)
         {
             PDResources resources = page.findResources();
-            processStream( page, resources, page.getContents().getStream() );
+            processStream(page, resources, page.getContents().getStream());
         }
         List<PDAnnotation> annotations = page.getAnnotations();
-        for( int i=0; i<annotations.size(); i++ )
+        for (int i = 0; i < annotations.size(); i++)
         {
-            PDAnnotation annot = (PDAnnotation)annotations.get( i );
+            PDAnnotation annot = (PDAnnotation) annotations.get(i);
             PDRectangle rect = annot.getRectangle();
             String appearanceName = annot.getAppearanceStream();
             PDAppearanceDictionary appearDictionary = annot.getAppearance();
-            if( appearDictionary != null )
+            if (appearDictionary != null)
             {
-                if( appearanceName == null )
+                if (appearanceName == null)
                 {
                     appearanceName = "default";
                 }
                 Map<String, PDAppearanceStream> appearanceMap = appearDictionary.getNormalAppearance();
-                if (appearanceMap != null) 
-                { 
-                    PDAppearanceStream appearance = 
-                        (PDAppearanceStream)appearanceMap.get( appearanceName ); 
-                    if( appearance != null ) 
-                    { 
+                if (appearanceMap != null)
+                {
+                    PDAppearanceStream appearance = (PDAppearanceStream) appearanceMap.get(appearanceName);
+                    if (appearance != null)
+                    {
                         Point2D point = new Point2D.Float(rect.getLowerLeftX(), rect.getLowerLeftY());
                         Matrix matrix = appearance.getMatrix();
-                        if (matrix != null) 
+                        if (matrix != null)
                         {
-                            // transform the rectangle using the given matrix 
+                            // transform the rectangle using the given matrix
                             AffineTransform at = matrix.createAffineTransform();
                             at.transform(point, point);
                         }
-                        g.translate( (int)point.getX(), -(int)point.getY() );
-                        processSubStream( page, appearance.getResources(), appearance.getStream() ); 
-                        g.translate( -(int)point.getX(), (int)point.getY() ); 
+                        g.translate((int) point.getX(), -(int) point.getY());
+                        processSubStream(page, appearance.getResources(), appearance.getStream());
+                        g.translate(-(int) point.getX(), (int) point.getY());
                     }
                 }
             }
@@ -163,86 +174,229 @@ public class PageDrawer extends PDFStreamEngine
     }
 
     /**
-     * You should override this method if you want to perform an action when a
-     * text is being processed.
-     *
-     * @param text The text to process
+     * You should override this method if you want to perform an action when a text is being processed.
+     * 
+     * @param text
+     *            The text to process
      */
-    protected void processTextPosition( TextPosition text )
+    protected void processTextPosition(TextPosition text)
     {
         try
         {
             PDGraphicsState graphicsState = getGraphicsState();
             Composite composite;
             Paint paint;
-            switch(graphicsState.getTextState().getRenderingMode()) 
+            switch (graphicsState.getTextState().getRenderingMode())
             {
-                case PDTextState.RENDERING_MODE_FILL_TEXT:
-                    composite = graphicsState.getNonStrokeJavaComposite();
-                    paint = graphicsState.getNonStrokingColor().getJavaColor();
-                    if (paint == null)
-                    {
-                        paint = graphicsState.getNonStrokingColor().getPaint(pageSize.height);
-                    }
-                    break;
-                case PDTextState.RENDERING_MODE_STROKE_TEXT:
-                    composite = graphicsState.getStrokeJavaComposite();
-                    paint = graphicsState.getStrokingColor().getJavaColor();
-                    if (paint == null)
-                    {
-                        paint = graphicsState.getStrokingColor().getPaint(pageSize.height);
-                    }
-                    break;
-                case PDTextState.RENDERING_MODE_NEITHER_FILL_NOR_STROKE_TEXT:
-                    //basic support for text rendering mode "invisible"
-                    Color nsc = graphicsState.getStrokingColor().getJavaColor();
-                    float[] components = {Color.black.getRed(),Color.black.getGreen(),Color.black.getBlue()};
-                    paint = new Color(nsc.getColorSpace(),components,0f);
-                    composite = graphicsState.getStrokeJavaComposite();
-                    break;
-                default:
-                    // TODO : need to implement....
-                    LOG.debug("Unsupported RenderingMode "
-                            + this.getGraphicsState().getTextState().getRenderingMode()
-                            + " in PageDrawer.processTextPosition()."
-                            + " Using RenderingMode "
-                            + PDTextState.RENDERING_MODE_FILL_TEXT
-                            + " instead");
-                    composite = graphicsState.getNonStrokeJavaComposite();
-                    paint = graphicsState.getNonStrokingColor().getJavaColor();
+            case PDTextState.RENDERING_MODE_FILL_TEXT:
+                composite = graphicsState.getNonStrokeJavaComposite();
+                paint = graphicsState.getNonStrokingColor().getJavaColor();
+                if (paint == null)
+                {
+                    paint = graphicsState.getNonStrokingColor().getPaint(pageSize.height);
+                }
+                break;
+            case PDTextState.RENDERING_MODE_STROKE_TEXT:
+                composite = graphicsState.getStrokeJavaComposite();
+                paint = graphicsState.getStrokingColor().getJavaColor();
+                if (paint == null)
+                {
+                    paint = graphicsState.getStrokingColor().getPaint(pageSize.height);
+                }
+                break;
+            case PDTextState.RENDERING_MODE_NEITHER_FILL_NOR_STROKE_TEXT:
+                // basic support for text rendering mode "invisible"
+                Color nsc = graphicsState.getStrokingColor().getJavaColor();
+                float[] components = { Color.black.getRed(), Color.black.getGreen(), Color.black.getBlue() };
+                paint = new Color(nsc.getColorSpace(), components, 0f);
+                composite = graphicsState.getStrokeJavaComposite();
+                break;
+            default:
+                // TODO : need to implement....
+                LOG.debug("Unsupported RenderingMode " + this.getGraphicsState().getTextState().getRenderingMode()
+                        + " in PageDrawer.processTextPosition()." + " Using RenderingMode "
+                        + PDTextState.RENDERING_MODE_FILL_TEXT + " instead");
+                composite = graphicsState.getNonStrokeJavaComposite();
+                paint = graphicsState.getNonStrokingColor().getJavaColor();
             }
             graphics.setComposite(composite);
             graphics.setPaint(paint);
-            
+
             PDFont font = text.getFont();
             Matrix textPos = text.getTextPos().copy();
             float x = textPos.getXPosition();
             // the 0,0-reference has to be moved from the lower left (PDF) to the upper left (AWT-graphics)
             float y = pageSize.height - textPos.getYPosition();
-            // Set translation to 0,0. We only need the scaling and shearing
-            textPos.setValue(2, 0, 0);
-            textPos.setValue(2, 1, 0);
+
+            // Set translation to 0,0. We only need the scaling and shearing except for type 3 fonts
+            if (!font.isType3Font())
+            {
+                textPos.setValue(2, 0, 0);
+                textPos.setValue(2, 1, 0);
+            }
             // because of the moved 0,0-reference, we have to shear in the opposite direction
-            textPos.setValue(0, 1, (-1)*textPos.getValue(0, 1));
-            textPos.setValue(1, 0, (-1)*textPos.getValue(1, 0));
+            textPos.setValue(0, 1, (-1) * textPos.getValue(0, 1));
+            textPos.setValue(1, 0, (-1) * textPos.getValue(1, 0));
             AffineTransform at = textPos.createAffineTransform();
             PDMatrix fontMatrix = font.getFontMatrix();
-            at.scale(fontMatrix.getValue(0, 0) * 1000f, fontMatrix.getValue(1, 1) * 1000f);
-            //TODO setClip() is a massive performance hot spot. Investigate optimization possibilities
+            // Type3 fonts don't use the same units within the font matrix as all the other fonts
+            if (font.isType3Font())
+            {
+                at.scale(fontMatrix.getValue(0, 0), fontMatrix.getValue(1, 1));
+            }
+            else
+            {
+                at.scale(fontMatrix.getValue(0, 0) * 1000f, fontMatrix.getValue(1, 1) * 1000f);
+            }
+            // TODO setClip() is a massive performance hot spot. Investigate optimization possibilities
             graphics.setClip(graphicsState.getCurrentClippingPath());
-            // the fontSize is no longer needed as it is already part of the transformation
-            // we should remove it from the parameter list in the long run
-            font.drawString( text.getCharacter(), text.getCodePoints(), graphics, 1, at, x, y );
+
+            // use different methods to draw the string
+            if (font.isType3Font())
+            {
+                drawType3String((PDType3Font) font, text.getCharacter(), text.getCodePoints(), at);
+            }
+            else
+            {
+                drawString((PDSimpleFont) font, text.getCharacter(), text.getCodePoints(), graphics, at, x, y);
+            }
         }
-        catch( IOException io )
+        catch (IOException io)
         {
             io.printStackTrace();
         }
     }
 
+    private void drawType3String(PDType3Font font, String string, int[] codePoints, AffineTransform at)
+            throws IOException
+    {
+        int stringLength = string.length();
+        for (int i = 0; i < stringLength; i++)
+        {
+            COSStream stream = font.getCharStream(string.charAt(i));
+            if (stream != null)
+            {
+                // save the current graphics state
+                getGraphicsStack().push((PDGraphicsState) getGraphicsState().clone());
+
+                Matrix ctm = new Matrix();
+                ctm.setFromAffineTransform(at);
+                getGraphicsState().setCurrentTransformationMatrix(ctm);
+                processSubStream(page, font.getType3Resources(), stream);
+
+                // restore the saved graphics state
+                setGraphicsState((PDGraphicsState) getGraphicsStack().pop());
+            }
+            else
+            {
+                LOG.debug("drawType3String: stream for character " + string.charAt(i) + " not found");
+            }
+        }
+    }
+
+    /**
+     * This will draw a string on a canvas using the font.
+     * 
+     * @param font
+     *            the font to be used to draw the string
+     * @param string
+     *            The string to draw.
+     * @param codePoints
+     *            The codePoints of the given string.
+     * @param g
+     *            The graphics to draw onto.
+     * @param at
+     *            The transformation matrix with all information for scaling and shearing of the font.
+     * @param x
+     *            The x coordinate to draw at.
+     * @param y
+     *            The y coordinate to draw at.
+     * 
+     * @throws IOException
+     *             If there is an error drawing the specific string.
+     */
+    private void drawString(PDSimpleFont font, String string, int[] codePoints, Graphics g, AffineTransform at,
+            float x, float y) throws IOException
+    {
+        Font awtFont = font.getawtFont();
+        FontRenderContext frc = new FontRenderContext(new AffineTransform(), true, true);
+        GlyphVector glyphs = null;
+        boolean useCodepoints = codePoints != null && font.isType0Font();
+        PDFont descendantFont = useCodepoints ? ((PDType0Font) font).getDescendantFont() : null;
+        // symbolic fonts may trigger the same fontmanager.so/dll error as described below
+        if (useCodepoints && !descendantFont.getFontDescriptor().isSymbolic())
+        {
+            PDCIDFontType2Font cid2Font = null;
+            if (descendantFont instanceof PDCIDFontType2Font)
+            {
+                cid2Font = (PDCIDFontType2Font) descendantFont;
+            }
+            if ((cid2Font != null && cid2Font.hasCIDToGIDMap()) || ((PDSimpleFont) font).isFontSubstituted())
+            {
+                // we still have to use the string if a CIDToGIDMap is used
+                glyphs = awtFont.createGlyphVector(frc, string);
+            }
+            else
+            {
+                glyphs = awtFont.createGlyphVector(frc, codePoints);
+            }
+        }
+        else
+        {
+            // mdavis - fix fontmanager.so/dll on sun.font.FileFont.getGlyphImage
+            // for font with bad cmaps?
+            // Type1 fonts are not affected as they don't have cmaps
+            if (!font.isType1Font() && awtFont.canDisplayUpTo(string) != -1)
+            {
+                LOG.warn("Changing font on <" + string + "> from <" + awtFont.getName() + "> to the default font");
+                awtFont = Font.decode(null).deriveFont(1f);
+            }
+            glyphs = awtFont.createGlyphVector(frc, string);
+            if (font.isType1Font())
+            {
+                glyphs = font.remapGlyphs(glyphs, string);
+            }
+        }
+        Graphics2D g2d = (Graphics2D) g;
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        writeFont(g2d, at, x, y, glyphs);
+    }
+
+    private void writeFont(final Graphics2D g2d, final AffineTransform at, final float x, final float y,
+            final GlyphVector glyphs)
+    {
+        // check if we have a rotation
+        if (!at.isIdentity())
+        {
+            try
+            {
+                AffineTransform atInv = at.createInverse();
+                // do only apply the size of the transform, rotation will be realized by rotating the graphics,
+                // otherwise the hp printers will not render the font
+                // apply the transformation to the graphics, which should be the same as applying the
+                // transformation itself to the text
+                g2d.transform(at);
+                // translate the coordinates
+                Point2D.Float newXy = new Point2D.Float(x, y);
+                atInv.transform(new Point2D.Float(x, y), newXy);
+                g2d.drawGlyphVector(glyphs, (float) newXy.getX(), (float) newXy.getY());
+                // restore the original transformation
+                g2d.transform(atInv);
+            }
+            catch (NoninvertibleTransformException e)
+            {
+                LOG.error("Error in " + getClass().getName() + ".writeFont", e);
+            }
+        }
+        else
+        {
+            g2d.drawGlyphVector(glyphs, x, y);
+        }
+    }
+
     /**
      * Get the graphics that we are currently drawing on.
-     *
+     * 
      * @return The graphics we are drawing on.
      */
     public Graphics2D getGraphics()
@@ -252,7 +406,7 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Get the page that is currently being drawn.
-     *
+     * 
      * @return The page that is being drawn.
      */
     public PDPage getPage()
@@ -262,7 +416,7 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Get the size of the page that is currently being drawn.
-     *
+     * 
      * @return The size of the page that is being drawn.
      */
     public Dimension getPageSize()
@@ -272,18 +426,19 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Fix the y coordinate.
-     *
-     * @param y The y coordinate.
+     * 
+     * @param y
+     *            The y coordinate.
      * @return The updated y coordinate.
      */
-    public double fixY( double y )
+    public double fixY(double y)
     {
         return pageSize.getHeight() - y;
     }
 
     /**
      * Get the current line path to be drawn.
-     *
+     * 
      * @return The current line path to be drawn.
      */
     public GeneralPath getLinePath()
@@ -293,8 +448,9 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Set the line path to draw.
-     *
-     * @param newLinePath Set the line path to draw.
+     * 
+     * @param newLinePath
+     *            Set the line path to draw.
      */
     public void setLinePath(GeneralPath newLinePath)
     {
@@ -308,117 +464,126 @@ public class PageDrawer extends PDFStreamEngine
         }
     }
 
-
     /**
      * Fill the path.
-     *
-     * @param windingRule The winding rule this path will use.
      * 
-     * @throws IOException If there is an IO error while filling the path.
+     * @param windingRule
+     *            The winding rule this path will use.
+     * 
+     * @throws IOException
+     *             If there is an IO error while filling the path.
      */
     public void fillPath(int windingRule) throws IOException
     {
         graphics.setComposite(getGraphicsState().getNonStrokeJavaComposite());
         Paint nonStrokingPaint = getGraphicsState().getNonStrokingColor().getJavaColor();
-        if ( nonStrokingPaint == null )
+        if (nonStrokingPaint == null)
         {
             nonStrokingPaint = getGraphicsState().getNonStrokingColor().getPaint(pageSize.height);
         }
-        if ( nonStrokingPaint == null )
+        if (nonStrokingPaint == null)
         {
-            LOG.info("ColorSpace "+getGraphicsState().getNonStrokingColor().getColorSpace().getName()
-                    +" doesn't provide a non-stroking color, using white instead!");
+            LOG.info("ColorSpace " + getGraphicsState().getNonStrokingColor().getColorSpace().getName()
+                    + " doesn't provide a non-stroking color, using white instead!");
             nonStrokingPaint = Color.WHITE;
         }
-        graphics.setPaint( nonStrokingPaint );
+        graphics.setPaint(nonStrokingPaint);
         getLinePath().setWindingRule(windingRule);
-        graphics.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF );
+        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
         graphics.setClip(getGraphicsState().getCurrentClippingPath());
-        graphics.fill( getLinePath() );
+        graphics.fill(getLinePath());
         getLinePath().reset();
     }
 
-
     /**
      * This will set the current stroke.
-     *
-     * @param newStroke The current stroke.
+     * 
+     * @param newStroke
+     *            The current stroke.
      * 
      */
     public void setStroke(BasicStroke newStroke)
     {
-        getGraphics().setStroke( newStroke );
+        getGraphics().setStroke(newStroke);
     }
 
     /**
      * This will return the current stroke.
-     *
+     * 
      * @return The current stroke.
      * 
      */
     public BasicStroke getStroke()
     {
-        return (BasicStroke)getGraphics().getStroke();
+        return (BasicStroke) getGraphics().getStroke();
     }
-    
+
     /**
      * Stroke the path.
-     *
-     * @throws IOException If there is an IO error while stroking the path.
+     * 
+     * @throws IOException
+     *             If there is an IO error while stroking the path.
      */
     public void strokePath() throws IOException
     {
         graphics.setComposite(getGraphicsState().getStrokeJavaComposite());
         Paint strokingPaint = getGraphicsState().getStrokingColor().getJavaColor();
-        if ( strokingPaint == null )
+        if (strokingPaint == null)
         {
             strokingPaint = getGraphicsState().getStrokingColor().getPaint(pageSize.height);
         }
-        if ( strokingPaint == null )
+        if (strokingPaint == null)
         {
-            LOG.info("ColorSpace "+getGraphicsState().getStrokingColor().getColorSpace().getName()
-                    +" doesn't provide a stroking color, using white instead!");
+            LOG.info("ColorSpace " + getGraphicsState().getStrokingColor().getColorSpace().getName()
+                    + " doesn't provide a stroking color, using white instead!");
             strokingPaint = Color.WHITE;
         }
         graphics.setPaint(strokingPaint);
-        graphics.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF );
+        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
         graphics.setClip(getGraphicsState().getCurrentClippingPath());
         GeneralPath path = getLinePath();
-        graphics.draw( path );
+        graphics.draw(path);
         path.reset();
     }
 
     /**
      * Called when the color changed.
-     * @param bStroking true for the stroking color, false for the non-stroking color
-     * @throws IOException if an I/O error occurs
+     * 
+     * @param bStroking
+     *            true for the stroking color, false for the non-stroking color
+     * @throws IOException
+     *             if an I/O error occurs
      */
     @Deprecated
     public void colorChanged(boolean bStroking) throws IOException
     {
-        //logger().info("changing " + (bStroking ? "" : "non") + "stroking color");
+        // logger().info("changing " + (bStroking ? "" : "non") + "stroking color");
     }
 
-    //This code generalizes the code Jim Lynch wrote for AppendRectangleToPath
+    // This code generalizes the code Jim Lynch wrote for AppendRectangleToPath
     /**
      * use the current transformation matrix to transform a single point.
-     * @param x x-coordinate of the point to be transform
-     * @param y y-coordinate of the point to be transform
+     * 
+     * @param x
+     *            x-coordinate of the point to be transform
+     * @param y
+     *            y-coordinate of the point to be transform
      * @return the transformed coordinates as Point2D.Double
      */
     public java.awt.geom.Point2D.Double transformedPoint(double x, double y)
     {
-        double[] position = {x,y}; 
-        getGraphicsState().getCurrentTransformationMatrix().createAffineTransform().transform(
-                position, 0, position, 0, 1);
+        double[] position = { x, y };
+        getGraphicsState().getCurrentTransformationMatrix().createAffineTransform()
+                .transform(position, 0, position, 0, 1);
         position[1] = fixY(position[1]);
-        return new Point2D.Double(position[0],position[1]);
+        return new Point2D.Double(position[0], position[1]);
     }
 
     /**
      * Set the clipping Path.
-     *
-     * @param windingRule The winding rule this path will use.
+     * 
+     * @param windingRule
+     *            The winding rule this path will use.
      * 
      * @deprecated use {@link #setClippingWindingRule(int)} instead
      * 
@@ -427,11 +592,12 @@ public class PageDrawer extends PDFStreamEngine
     {
         setClippingWindingRule(windingRule);
     }
-    
+
     /**
      * Set the clipping winding rule.
-     *
-     * @param windingRule The winding rule which will be used for clipping.
+     * 
+     * @param windingRule
+     *            The winding rule which will be used for clipping.
      * 
      */
     public void setClippingWindingRule(int windingRule)
@@ -441,24 +607,24 @@ public class PageDrawer extends PDFStreamEngine
 
     /**
      * Set the clipping Path.
-     *
+     * 
      */
     public void endPath()
     {
         if (clippingWindingRule > -1)
         {
             PDGraphicsState graphicsState = getGraphicsState();
-            GeneralPath clippingPath = (GeneralPath)getLinePath().clone();
+            GeneralPath clippingPath = (GeneralPath) getLinePath().clone();
             clippingPath.setWindingRule(clippingWindingRule);
             // If there is already set a clipping path, we have to intersect the new with the existing one
-            if (graphicsState.getCurrentClippingPath() != null) 
+            if (graphicsState.getCurrentClippingPath() != null)
             {
                 Area currentArea = new Area(getGraphicsState().getCurrentClippingPath());
                 Area newArea = new Area(clippingPath);
                 currentArea.intersect(newArea);
                 graphicsState.setCurrentClippingPath(currentArea);
             }
-            else 
+            else
             {
                 graphicsState.setCurrentClippingPath(clippingPath);
             }
@@ -466,27 +632,32 @@ public class PageDrawer extends PDFStreamEngine
         }
         getLinePath().reset();
     }
+
     /**
-     * Draw the AWT image. Called by Invoke.
-     * Moved into PageDrawer so that Invoke doesn't have to reach in here for Graphics as that breaks extensibility.
-     *
-     * @param awtImage The image to draw.
-     * @param at The transformation to use when drawing.
+     * Draw the AWT image. Called by Invoke. Moved into PageDrawer so that Invoke doesn't have to reach in here for
+     * Graphics as that breaks extensibility.
+     * 
+     * @param awtImage
+     *            The image to draw.
+     * @param at
+     *            The transformation to use when drawing.
      * 
      */
     public void drawImage(Image awtImage, AffineTransform at)
     {
         graphics.setComposite(getGraphicsState().getStrokeJavaComposite());
         graphics.setClip(getGraphicsState().getCurrentClippingPath());
-        graphics.drawImage( awtImage, at, null );
+        graphics.drawImage(awtImage, at, null);
     }
-    
+
     /**
-     * Fill with Shading.  Called by SHFill operator.
-     *
-     * @param ShadingName  The name of the Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with Shading. Called by SHFill operator.
+     * 
+     * @param ShadingName
+     *            The name of the Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      * 
      * @deprecated use {@link #shFill(COSName)) instead.
      */
@@ -494,13 +665,15 @@ public class PageDrawer extends PDFStreamEngine
     {
         shFill(ShadingName);
     }
-    
+
     /**
-     * Fill with Shading.  Called by SHFill operator.
-     *
-     * @param shadingName  The name of the Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the clipping area.
+     * Fill with Shading. Called by SHFill operator.
+     * 
+     * @param shadingName
+     *            The name of the Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the clipping area.
      */
     public void shFill(COSName shadingName) throws IOException
     {
@@ -511,38 +684,41 @@ public class PageDrawer extends PDFStreamEngine
         Paint paint = null;
         switch (shadingType)
         {
-            case 1:
-                // TODO
-                LOG.debug("Function based shading not yet supported");
+        case 1:
+            // TODO
+            LOG.debug("Function based shading not yet supported");
             break;
-            case 2:
-                paint = new AxialShadingPaint((PDShadingType2)shading, ctm, pageSize.height);
-                break;
-            case 3:
-                paint = new RadialShadingPaint((PDShadingType3)shading, ctm, pageSize.height);
-                break;
-            case 4:
-            case 5:
-            case 6:
-            case 7:
-                // TODO
-                LOG.debug("Shading type "+shadingType+" not yet supported");
-                break;
-            default:
-                throw new IOException("Invalid ShadingType " + shadingType + " for Shading " + shadingName);
+        case 2:
+            paint = new AxialShadingPaint((PDShadingType2) shading, ctm, pageSize.height);
+            break;
+        case 3:
+            paint = new RadialShadingPaint((PDShadingType3) shading, ctm, pageSize.height);
+            break;
+        case 4:
+        case 5:
+        case 6:
+        case 7:
+            // TODO
+            LOG.debug("Shading type " + shadingType + " not yet supported");
+            break;
+        default:
+            throw new IOException("Invalid ShadingType " + shadingType + " for Shading " + shadingName);
         }
         graphics.setComposite(getGraphicsState().getNonStrokeJavaComposite());
         graphics.setPaint(paint);
-        graphics.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF );
-        graphics.fill( getGraphicsState().getCurrentClippingPath() );
+        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
+        graphics.fill(getGraphicsState().getCurrentClippingPath());
     }
+
     /**
-     * Fill with a Function-based gradient / shading.  
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with a Function-based gradient / shading. If extending the class, override this and its siblings, not the
+     * public SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Function(PDShading Shading) throws IOException
     {
@@ -550,78 +726,89 @@ public class PageDrawer extends PDFStreamEngine
     }
 
     /**
-     * Fill with an Axial Shading.  
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with an Axial Shading. If extending the class, override this and its siblings, not the public SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Axial(PDShading Shading) throws IOException
     {
         throw new IOException("Not Implemented");
-        
+
     }
 
     /**
-     * Fill with a Radial gradient / shading.  
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with a Radial gradient / shading. If extending the class, override this and its siblings, not the public
+     * SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_Radial(PDShading Shading) throws IOException
     {
         throw new IOException("Not Implemented");
     }
-    
+
     /**
-     * Fill with a Free-form Gourad-shaded triangle mesh.
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with a Free-form Gourad-shaded triangle mesh. If extending the class, override this and its siblings, not
+     * the public SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_FreeGourad(PDShading Shading) throws IOException
     {
         throw new IOException("Not Implemented");
     }
-    
+
     /**
-     * Fill with a Lattice-form Gourad-shaded triangle mesh.
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with a Lattice-form Gourad-shaded triangle mesh. If extending the class, override this and its siblings, not
+     * the public SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_LatticeGourad(PDShading Shading) throws IOException
     {
         throw new IOException("Not Implemented");
     }
-    
+
     /**
-     * Fill with a Coons patch mesh
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+     * Fill with a Coons patch mesh If extending the class, override this and its siblings, not the public SHFill
+     * method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_CoonsPatch(PDShading Shading) throws IOException
     {
         throw new IOException("Not Implemented");
     }
-    
-    /**
-     * Fill with a Tensor-product patch mesh.
-     * If extending the class, override this and its siblings, not the public SHFill method.
-     *
-     * @param Shading  The Shading Dictionary to use for this fill instruction.
-     *
-     * @throws IOException If there is an IO error while shade-filling the path/clipping area.
+
+    /**
+     * Fill with a Tensor-product patch mesh. If extending the class, override this and its siblings, not the public
+     * SHFill method.
+     * 
+     * @param Shading
+     *            The Shading Dictionary to use for this fill instruction.
+     * 
+     * @throws IOException
+     *             If there is an IO error while shade-filling the path/clipping area.
      */
     protected void SHFill_TensorPatch(PDShading Shading) throws IOException
     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
index 7b42e2d813..762a091c59 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
@@ -38,9 +38,6 @@ import org.apache.pdfbox.pdmodel.common.PDRectangle;
 
 import org.apache.pdfbox.util.ResourceLoader;
 
-import java.awt.Graphics;
-import java.awt.geom.AffineTransform;
-
 import java.io.InputStream;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
@@ -307,41 +304,6 @@ public abstract class PDFont implements COSObjectable
      */
     public abstract float getAverageFontWidth() throws IOException;
 
-    /**
-     * This will draw a string on a canvas using the font.
-     *
-     * @param string The string to draw.
-     * @param g The graphics to draw onto.
-     * @param fontSize The size of the font to draw.
-     * @param at The transformation matrix with all information for scaling and shearing of the font.
-     * @param x The x coordinate to draw at.
-     * @param y The y coordinate to draw at.
-     *
-     * @throws IOException If there is an error drawing the specific string.
-     * @deprecated use {@link PDFont#drawString(String, int[], Graphics, float, AffineTransform, float, float)} instead
-     */
-    public void drawString( String string, Graphics g, float fontSize, AffineTransform at, float x, float y ) 
-    throws IOException
-    {
-        drawString(string, null, g, fontSize, at, x, y);
-    }
-
-    /**
-     * This will draw a string on a canvas using the font.
-     *
-     * @param string The string to draw.
-     * @param codePoints The codePoints of the given string.
-     * @param g The graphics to draw onto.
-     * @param fontSize The size of the font to draw.
-     * @param at The transformation matrix with all information for scaling and shearing of the font.
-     * @param x The x coordinate to draw at.
-     * @param y The y coordinate to draw at.
-     *
-     * @throws IOException If there is an error drawing the specific string.
-     */
-    public abstract void drawString( String string, int[] codePoints, Graphics g, float fontSize,
-        AffineTransform at, float x, float y ) throws IOException;
-    
     /**
      * Used for multibyte encodings.
      *
@@ -645,8 +607,8 @@ public abstract class PDFont implements COSObjectable
     // Memorized values to avoid repeated dictionary lookups
     private String subtype = null;
     private boolean type1Font;
+    private boolean type3Font;
     private boolean trueTypeFont;
-    private boolean typeFont;
     private boolean type0Font;
 
     /**
@@ -662,7 +624,7 @@ public abstract class PDFont implements COSObjectable
             type1Font = "Type1".equals(subtype);
             trueTypeFont = "TrueType".equals(subtype);
             type0Font = "Type0".equals(subtype);
-            typeFont = type1Font || "Type0".equals(subtype) || trueTypeFont;
+            type3Font = "Type3".equals(subtype);
         }
         return subtype;
     }
@@ -671,34 +633,42 @@ public abstract class PDFont implements COSObjectable
      * Determines if the font is a type 1 font.
      * @return returns true if the font is a type 1 font
      */
-    protected boolean isType1Font()
+    public boolean isType1Font()
     {
         getSubType();
         return type1Font;
     }
 
+    /**
+     * Determines if the font is a type 3 font.
+     * @return returns true if the font is a type 3 font
+     */
+    public boolean isType3Font()
+    {
+        getSubType();
+        return type3Font;
+    }
+    
     /**
      * Determines if the font is a type 0 font.
      * @return returns true if the font is a type 0 font
      */
-    protected boolean isType0Font()
+    public boolean isType0Font()
     {
         getSubType();
         return type0Font;
     }
 
-    private boolean isTrueTypeFont()
+    /**
+     * Determines if the font is a true type font.
+     * @return returns true if the font is a true type font
+     */
+    public boolean isTrueTypeFont()
     {
         getSubType();
         return trueTypeFont;
     }
 
-    private boolean isTypeFont()
-    {
-        getSubType();
-        return typeFont;
-    }
-
     /**
      * The PostScript name of the font.
      *
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
index 07d5922960..8cb4337298 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
@@ -17,14 +17,7 @@
 package org.apache.pdfbox.pdmodel.font;
 
 import java.awt.Font;
-import java.awt.Graphics;
-import java.awt.Graphics2D;
-import java.awt.RenderingHints;
-import java.awt.font.FontRenderContext;
 import java.awt.font.GlyphVector;
-import java.awt.geom.AffineTransform;
-import java.awt.geom.Point2D;
-import java.awt.geom.NoninvertibleTransformException;
 import java.io.IOException;
 
 import java.util.HashMap;
@@ -100,57 +93,6 @@ public abstract class PDSimpleFont extends PDFont
         return null;
     }
     
-    /**
-     * {@inheritDoc}
-     */
-    public void drawString( String string, int[] codePoints, Graphics g, float fontSize, 
-            AffineTransform at, float x, float y ) throws IOException
-    {
-        Font awtFont = getawtFont();
-        FontRenderContext frc = new FontRenderContext(new AffineTransform(), true, true);
-        GlyphVector glyphs = null;
-        boolean useCodepoints = codePoints != null && isType0Font();
-        PDFont descendantFont = useCodepoints ? ((PDType0Font)this).getDescendantFont() : null;
-        // symbolic fonts may trigger the same fontmanager.so/dll error as described below
-        if (useCodepoints && !descendantFont.getFontDescriptor().isSymbolic())
-        {
-            PDCIDFontType2Font cid2Font = null;
-            if (descendantFont instanceof PDCIDFontType2Font)
-            {
-                cid2Font = (PDCIDFontType2Font)descendantFont;
-            }
-            if((cid2Font != null && cid2Font.hasCIDToGIDMap()) || isFontSubstituted)
-            {
-                // we still have to use the string if a CIDToGIDMap is used 
-                glyphs = awtFont.createGlyphVector(frc, string);
-            }
-            else
-            {
-                glyphs = awtFont.createGlyphVector(frc, codePoints);
-            }
-        }
-        else 
-        {
-            // mdavis - fix fontmanager.so/dll on sun.font.FileFont.getGlyphImage
-            // for font with bad cmaps?
-            // Type1 fonts are not affected as they don't have cmaps
-            if (!isType1Font() && awtFont.canDisplayUpTo(string) != -1) 
-            {
-                LOG.warn("Changing font on <" + string + "> from <"
-                        + awtFont.getName() + "> to the default font");
-                awtFont = Font.decode(null).deriveFont(1f);
-            }
-            glyphs = awtFont.createGlyphVector(frc, string);
-            if (isType1Font()) 
-            {
-                glyphs = remapGlyphs(glyphs, string);
-            }
-        }
-        Graphics2D g2d = (Graphics2D)g;
-        g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
-        writeFont(g2d, at, x, y, glyphs);
-    }
-
     /**
      * This will get the font height for a character.
      *
@@ -322,48 +264,6 @@ public abstract class PDSimpleFont extends PDFont
         return getFontDescriptor().getFontBoundingBox();
     }
 
-    /**
-     * This will draw a string on a canvas using the font.
-     *
-     * @param g2d The graphics to draw onto.
-     * @param at The transformation matrix with all information for scaling and shearing of the font.
-     * @param x The x coordinate to draw at.
-     * @param y The y coordinate to draw at.
-     * @param glyphs The GlyphVector containing the glyphs to be drawn.
-     *
-     */
-    protected void writeFont(final Graphics2D g2d, final AffineTransform at, 
-            final float x, final float y, final GlyphVector glyphs) 
-    {
-        // check if we have a rotation
-        if (!at.isIdentity()) 
-        {
-            try 
-            {
-                AffineTransform atInv = at.createInverse();
-                // do only apply the size of the transform, rotation will be realized by rotating the graphics,
-                // otherwise the hp printers will not render the font
-                // apply the transformation to the graphics, which should be the same as applying the
-                // transformation itself to the text
-                g2d.transform(at);
-                // translate the coordinates
-                Point2D.Float newXy = new  Point2D.Float(x,y);
-                atInv.transform(new Point2D.Float( x, y), newXy);
-                g2d.drawGlyphVector(glyphs, (float)newXy.getX(), (float)newXy.getY() );
-                // restore the original transformation
-                g2d.transform(atInv);
-            }
-            catch (NoninvertibleTransformException e) 
-            {
-                LOG.error("Error in "+getClass().getName()+".writeFont",e);
-            }
-        }
-        else 
-        {
-            g2d.drawGlyphVector(glyphs, x, y);
-        }
-    }
-
     /**
      * {@inheritDoc}
      */
@@ -499,7 +399,7 @@ public abstract class PDSimpleFont extends PDFont
      * 
      * @return true if the font was substituted
      */
-    protected boolean isFontSubstituted()
+    public boolean isFontSubstituted()
     {
         return isFontSubstituted;
     }
@@ -558,7 +458,7 @@ public abstract class PDSimpleFont extends PDFont
      * @param string the represented string
      * @return the remapped glyph vector
      */
-    protected GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
+    public GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
     {
         return glyphVector;
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
index 72842f9b8f..578191687c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
@@ -207,7 +207,7 @@ public class PDType0Font extends PDSimpleFont
      * @return the descendant font.
      *
      */
-    protected PDFont getDescendantFont()
+    public PDFont getDescendantFont()
     {
         return descendantFont;
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
index e597e63e63..71b472d4ef 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
@@ -514,7 +514,7 @@ public class PDType1Font extends PDSimpleFont
      * {@inheritDoc}
      */
     @Override
-    protected GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
+    public GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
     {
         // this is used to fix an apparent bug with the sun jdk where the mapping of
         // character code to glyph index done by native code is wrong; this does not happen with openjdk
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType3Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType3Font.java
index 96af93a071..b7bcf6d1c4 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType3Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType3Font.java
@@ -16,31 +16,29 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
+import java.io.IOException;
+
+import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSStream;
+import org.apache.pdfbox.pdmodel.PDResources;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
-
-import java.awt.Graphics;
-import java.awt.Image;
-import java.awt.geom.AffineTransform;
-
-import java.io.IOException;
-
-import java.util.HashMap;
-import java.util.Map;
+import org.apache.pdfbox.pdmodel.common.PDRectangle;
 
 /**
  * This is implementation of the Type3 Font.
  *
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.8 $
+ * 
  */
 public class PDType3Font extends PDSimpleFont
 {
-    //A map of character code to java.awt.Image for the glyph
-    private Map<Character, Image> images = new HashMap<Character, Image>();
 
+	private PDResources type3Resources = null;
+    
+    private COSDictionary charProcs = null;
+    
     /**
      * Constructor.
      */
@@ -61,66 +59,81 @@ public class PDType3Font extends PDSimpleFont
     }
 
     /**
-     * Type3 fonts have their glyphs defined as a content stream.  This
-     * will create the image that represents that character
+     * Set the font matrix for this type3 font.
      *
-     * @throws IOException If there is an error creating the image.
+     * @param matrix The font matrix for this type3 font.
      */
-    private Image createImageIfNecessary( char character ) throws IOException
+    public void setFontMatrix( PDMatrix matrix )
     {
-        Character c = new Character( character );
-        Image retval = (Image)images.get( c );
-        if( retval == null )
-        {
-            COSDictionary charProcs = (COSDictionary)font.getDictionaryObject( COSName.CHAR_PROCS );
-            COSStream stream = (COSStream)charProcs.getDictionaryObject( COSName.getPDFName( "" + character ) );
-            if( stream != null )
-            {
-                Type3StreamParser parser = new Type3StreamParser();
-                retval = parser.createImage( stream );
-                images.put( c, retval );
-            }
-            else
-            {
-                //stream should not be null!!
-            }
-        }
-        return retval;
-
+        font.setItem( COSName.FONT_MATRIX, matrix );
     }
 
+
     /**
-     * {@inheritDoc}
+     * Returns the optional resources of the type3 stream.
+     * 
+     * @return the resources bound to be used when parsing the type3 stream 
      */
-    public void drawString( String string, int[] codePoints, Graphics g, float fontSize, AffineTransform at, float x, float y ) 
-        throws IOException
+    public PDResources getType3Resources( )
     {
-        for(int i=0; i<string.length(); i++)
+        if (type3Resources == null)
         {
-            //todo need to use image observers and such
-            char c = string.charAt( i );
-            Image image = createImageIfNecessary( c );
-            if( image != null )
+            COSDictionary resources = (COSDictionary)font.getDictionaryObject( COSName.RESOURCES );
+            if (resources != null)
             {
-                int newWidth = (int)(.12*image.getWidth(null));
-                int newHeight = (int)(.12*image.getHeight(null));
-                if( newWidth > 0 && newHeight > 0 )
-                {
-                    image = image.getScaledInstance( newWidth, newHeight, Image.SCALE_SMOOTH );
-                    g.drawImage( image, (int)x, (int)y, null );
-                    x+=newWidth;
-                }
+            	type3Resources = new PDResources( resources );
             }
         }
+        return type3Resources;
     }
 
     /**
-     * Set the font matrix for this type3 font.
+     * This will get the fonts bounding box.
      *
-     * @param matrix The font matrix for this type3 font.
+     * @return The fonts bounding box.
+     *
+     * @throws IOException If there is an error getting the bounding box.
      */
-    public void setFontMatrix( PDMatrix matrix )
+    public PDRectangle getFontBoundingBox() throws IOException
     {
-        font.setItem( COSName.FONT_MATRIX, matrix );
+        COSArray rect = (COSArray)font.getDictionaryObject( COSName.FONT_BBOX );
+        PDRectangle retval = null;
+        if( rect != null )
+        {
+            retval = new PDRectangle( rect );
+        }
+        return retval;
+    }
+    
+    /**
+     * Returns the dictionary containing all streams to be used to render the glyphs.
+     * 
+     * @return the dictionary containing all glyph streams.
+     */
+    public COSDictionary getCharProcs()
+    {
+        if (charProcs == null)
+        {
+        	charProcs = (COSDictionary)font.getDictionaryObject( COSName.CHAR_PROCS );
+        }
+        return charProcs;
+    }
+    
+    /**
+     * Returns the stream of the glyph representing by the given character
+     * 
+     * @param character the represented character
+     * @return the stream to be used to render the glyph
+     * @throws IOException If something went wrong when getting the stream.
+     */
+    public COSStream getCharStream(Character character) throws IOException
+    {
+    	COSStream stream = null;
+        String cMapsTo = getFontEncoding().getName(character);
+        if (cMapsTo != null)
+        {
+        	stream = (COSStream)getCharProcs().getDictionaryObject( COSName.getPDFName( cMapsTo ) );
+        }
+        return stream;
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/Type3StreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/Type3StreamParser.java
deleted file mode 100644
index 489fffeeb8..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/Type3StreamParser.java
+++ /dev/null
@@ -1,594 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.pdmodel.font;
-
-import java.awt.Image;
-
-import java.io.IOException;
-
-import java.util.List;
-
-import org.apache.fontbox.util.BoundingBox;
-
-import org.apache.pdfbox.cos.COSNumber;
-import org.apache.pdfbox.cos.COSStream;
-
-import org.apache.pdfbox.pdmodel.graphics.xobject.PDInlinedImage;
-
-import org.apache.pdfbox.util.ImageParameters;
-import org.apache.pdfbox.util.PDFOperator;
-import org.apache.pdfbox.util.PDFStreamEngine;
-
-/**
- * This class will handle creating an image for a type 3 glyph.
- *
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.10 $
- */
-public class Type3StreamParser extends PDFStreamEngine
-{
-    private PDInlinedImage image = null;
-    private BoundingBox box = null;
-
-
-    /**
-     * This will parse a type3 stream and create an image from it.
-     *
-     * @param type3Stream The stream containing the operators to draw the image.
-     *
-     * @return The image that was created.
-     *
-     * @throws IOException If there is an error processing the stream.
-     */
-    public Image createImage( COSStream type3Stream ) throws IOException
-    {
-        processStream( null, null, type3Stream );
-        return image.createImage();
-    }
-
-    /**
-     * This is used to handle an operation.
-     *
-     * @param operator The operation to perform.
-     * @param arguments The list of arguments.
-     *
-     * @throws IOException If there is an error processing the operation.
-     */
-    protected void processOperator( PDFOperator operator, List arguments ) throws IOException
-    {
-        super.processOperator( operator, arguments );
-        String operation = operator.getOperation();
-        /**
-        if( operation.equals( "b" ) )
-        {
-            //Close, fill, and stroke path using nonzero winding number rule
-        }
-        else if( operation.equals( "B" ) )
-        {
-            //Fill and stroke path using nonzero winding number rule
-        }
-        else if( operation.equals( "b*" ) )
-        {
-            //Close, fill, and stroke path using even-odd rule
-        }
-        else if( operation.equals( "B*" ) )
-        {
-            //Fill and stroke path using even-odd rule
-        }
-        else if( operation.equals( "BDC" ) )
-        {
-            //(PDF 1.2) Begin marked-content sequence with property list
-        }
-        else **/if( operation.equals( "BI" ) )
-        {
-            ImageParameters params = operator.getImageParameters();
-            image = new PDInlinedImage();
-            image.setImageParameters( params );
-            image.setImageData( operator.getImageData() );
-            //begin inline image object
-        }/**
-        else if( operation.equals( "BMC" ) )
-        {
-            //(PDF 1.2) Begin marked-content sequence
-        }
-        else if( operation.equals( "BT" ) )
-        {
-            log.debug( "<BT>" );
-            textMatrix = new Matrix();
-            textLineMatrix = new Matrix();
-        }
-        else if( operation.equals( "BX" ) )
-        {
-            //(PDF 1.1) Begin compatibility section
-        }
-        else if( operation.equals( "c" ) )
-        {
-            //Append curved segment to path (three control points)
-        }
-        else if( operation.equals( "cm" ) )
-        {
-        }
-        else if( operation.equals( "cs" ) )
-        {
-        }
-        else if( operation.equals( "CS" ) )
-        {
-        }
-        else if( operation.equals( "d" ) )
-        {
-            //Set the line dash pattern in the graphics state
-        }
-        else */if( operation.equals( "d0" ) )
-        {
-            //set glyph with for a type3 font
-            //COSNumber horizontalWidth = (COSNumber)arguments.get( 0 );
-            //COSNumber verticalWidth = (COSNumber)arguments.get( 1 );
-            //width = horizontalWidth.intValue();
-            //height = verticalWidth.intValue();
-        }
-        else if( operation.equals( "d1" ) )
-        {
-            //set glyph with and bounding box for type 3 font
-            //COSNumber horizontalWidth = (COSNumber)arguments.get( 0 );
-            //COSNumber verticalWidth = (COSNumber)arguments.get( 1 );
-            COSNumber llx = (COSNumber)arguments.get( 2 );
-            COSNumber lly = (COSNumber)arguments.get( 3 );
-            COSNumber urx = (COSNumber)arguments.get( 4 );
-            COSNumber ury = (COSNumber)arguments.get( 5 );
-
-            //width = horizontalWidth.intValue();
-            //height = verticalWidth.intValue();
-            box = new BoundingBox();
-            box.setLowerLeftX( llx.floatValue() );
-            box.setLowerLeftY( lly.floatValue() );
-            box.setUpperRightX( urx.floatValue() );
-            box.setUpperRightY( ury.floatValue() );
-        }/*
-        else if( operation.equals( "Do" ) )
-        {
-            //invoke named object.
-        }
-        else if( operation.equals( "DP" ) )
-        {
-            //(PDF 1.2) De.ne marked-content point with property list
-        }
-        else if( operation.equals( "EI" ) )
-        {
-            //end inline image object
-        }
-        else if( operation.equals( "EMC" ) )
-        {
-            //End inline image object
-        }
-        else if( operation.equals( "ET" ) )
-        {
-            log.debug( "<ET>" );
-            textMatrix = null;
-            textLineMatrix = null;
-        }
-        else if( operation.equals( "EX" ) )
-        {
-            //(PDF 1.1) End compatibility section
-        }
-        else if( operation.equals( "f" ) )
-        {
-            //Fill the path, using the nonzero winding number rule to determine the region to .ll
-        }
-        else if( operation.equals( "F" ) )
-        {
-        }
-        else if( operation.equals( "f*" ) )
-        {
-            //Fill path using even-odd rule
-        }
-        else if( operation.equals( "g" ) )
-        {
-        }
-        else if( operation.equals( "G" ) )
-        {
-        }
-        else if( operation.equals( "gs" ) )
-        {
-        }
-        else if( operation.equals( "h" ) )
-        {
-            //close subpath
-        }
-        else if( operation.equals( "i" ) )
-        {
-            //set flatness tolerance, not sure what this does
-        }
-        else if( operation.equals( "ID" ) )
-        {
-            //begin inline image data
-        }
-        else if( operation.equals( "j" ) )
-        {
-            //Set the line join style in the graphics state
-            //System.out.println( "<j>" );
-        }
-        else if( operation.equals( "J" ) )
-        {
-            //Set the line cap style in the graphics state
-            //System.out.println( "<J>" );
-        }
-        else if( operation.equals( "k" ) )
-        {
-            //Set CMYK color for nonstroking operations
-        }
-        else if( operation.equals( "K" ) )
-        {
-            //Set CMYK color for stroking operations
-        }
-        else if( operation.equals( "l" ) )
-        {
-            //append straight line segment from the current point to the point.
-            COSNumber x = (COSNumber)arguments.get( 0 );
-            COSNumber y = (COSNumber)arguments.get( 1 );
-            linePath.lineTo( x.floatValue(), pageSize.getHeight()-y.floatValue() );
-        }
-        else if( operation.equals( "m" ) )
-        {
-            COSNumber x = (COSNumber)arguments.get( 0 );
-            COSNumber y = (COSNumber)arguments.get( 1 );
-            linePath.reset();
-            linePath.moveTo( x.floatValue(), pageSize.getHeight()-y.floatValue() );
-            //System.out.println( "<m x=\"" + x.getValue() + "\" y=\"" + y.getValue() + "\" >" );
-        }
-        else if( operation.equals( "M" ) )
-        {
-            //System.out.println( "<M>" );
-        }
-        else if( operation.equals( "MP" ) )
-        {
-            //(PDF 1.2) Define marked-content point
-        }
-        else if( operation.equals( "n" ) )
-        {
-            //End path without .lling or stroking
-            //System.out.println( "<n>" );
-        }
-        else if( operation.equals( "q" ) )
-        {
-            //save graphics state
-            if( log.isDebugEnabled() )
-            {
-                log.debug( "<" + operation + "> - save state" );
-            }
-            graphicsStack.push(graphicsState.clone());
-        }
-        else if( operation.equals( "Q" ) )
-        {
-            //restore graphics state
-            if( log.isDebugEnabled() )
-            {
-                log.debug( "<" + operation + "> - restore state" );
-            }
-            graphicsState = (PDGraphicsState)graphicsStack.pop();
-        }
-        else if( operation.equals( "re" ) )
-        {
-        }
-        else if( operation.equals( "rg" ) )
-        {
-            //Set RGB color for nonstroking operations
-        }
-        else if( operation.equals( "RG" ) )
-        {
-            //Set RGB color for stroking operations
-        }
-        else if( operation.equals( "ri" ) )
-        {
-            //Set color rendering intent
-        }
-        else if( operation.equals( "s" ) )
-        {
-            //Close and stroke path
-        }
-        else if( operation.equals( "S" ) )
-        {
-            graphics.draw( linePath );
-        }
-        else if( operation.equals( "sc" ) )
-        {
-            //set color for nonstroking operations
-            //System.out.println( "<sc>" );
-        }
-        else if( operation.equals( "SC" ) )
-        {
-            //set color for stroking operations
-            //System.out.println( "<SC>" );
-        }
-        else if( operation.equals( "scn" ) )
-        {
-            //set color for nonstroking operations special
-        }
-        else if( operation.equals( "SCN" ) )
-        {
-            //set color for stroking operations special
-        }
-        else if( operation.equals( "sh" ) )
-        {
-            //(PDF 1.3) Paint area de.ned by shading pattern
-        }
-        else if( operation.equals( "T*" ) )
-        {
-            if (log.isDebugEnabled())
-            {
-                log.debug("<T* graphicsState.getTextState().getLeading()=\"" +
-                    graphicsState.getTextState().getLeading() + "\">");
-            }
-            //move to start of next text line
-            if( graphicsState.getTextState().getLeading() == 0 )
-            {
-                graphicsState.getTextState().setLeading( -.01f );
-            }
-            Matrix td = new Matrix();
-            td.setValue( 2, 1, -1 * graphicsState.getTextState().getLeading() * textMatrix.getValue(1,1));
-            textLineMatrix = textLineMatrix.multiply( td );
-            textMatrix = textLineMatrix.copy();
-        }
-        else if( operation.equals( "Tc" ) )
-        {
-            //set character spacing
-            COSNumber characterSpacing = (COSNumber)arguments.get( 0 );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Tc characterSpacing=\"" + characterSpacing.floatValue() + "\" />");
-            }
-            graphicsState.getTextState().setCharacterSpacing( characterSpacing.floatValue() );
-        }
-        else if( operation.equals( "Td" ) )
-        {
-            COSNumber x = (COSNumber)arguments.get( 0 );
-            COSNumber y = (COSNumber)arguments.get( 1 );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Td x=\"" + x.floatValue() + "\" y=\"" + y.floatValue() + "\">");
-            }
-            Matrix td = new Matrix();
-            td.setValue( 2, 0, x.floatValue() * textMatrix.getValue(0,0) );
-            td.setValue( 2, 1, y.floatValue() * textMatrix.getValue(1,1) );
-            //log.debug( "textLineMatrix before " + textLineMatrix );
-            textLineMatrix = textLineMatrix.multiply( td );
-            //log.debug( "textLineMatrix after " + textLineMatrix );
-            textMatrix = textLineMatrix.copy();
-        }
-        else if( operation.equals( "TD" ) )
-        {
-            //move text position and set leading
-            COSNumber x = (COSNumber)arguments.get( 0 );
-            COSNumber y = (COSNumber)arguments.get( 1 );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<TD x=\"" + x.floatValue() + "\" y=\"" + y.floatValue() + "\">");
-            }
-            graphicsState.getTextState().setLeading( -1 * y.floatValue() );
-            Matrix td = new Matrix();
-            td.setValue( 2, 0, x.floatValue() * textMatrix.getValue(0,0) );
-            td.setValue( 2, 1, y.floatValue() * textMatrix.getValue(1,1) );
-            //log.debug( "textLineMatrix before " + textLineMatrix );
-            textLineMatrix = textLineMatrix.multiply( td );
-            //log.debug( "textLineMatrix after " + textLineMatrix );
-            textMatrix = textLineMatrix.copy();
-        }
-        else if( operation.equals( "Tf" ) )
-        {
-            //set font and size
-            COSName fontName = (COSName)arguments.get( 0 );
-            graphicsState.getTextState().setFontSize( ((COSNumber)arguments.get( 1 ) ).floatValue() );
-
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Tf font=\"" + fontName.getName() + "\" size=\"" +
-                    graphicsState.getTextState().getFontSize() + "\">");
-            }
-
-            //old way
-            //graphicsState.getTextState().getFont() = (COSObject)stream.getDictionaryObject( fontName );
-            //if( graphicsState.getTextState().getFont() == null )
-            //{
-            //    graphicsState.getTextState().getFont() = (COSObject)graphicsState.getTextState().getFont()
-            //                                           Dictionary.getItem( fontName );
-            //}
-            graphicsState.getTextState().setFont( (PDFont)fonts.get( fontName.getName() ) );
-            if( graphicsState.getTextState().getFont() == null )
-            {
-                throw new IOException( "Error: Could not find font(" + fontName + ") in map=" + fonts );
-            }
-            //log.debug( "Font Resource=" + fontResource );
-            //log.debug( "Current Font=" + graphicsState.getTextState().getFont() );
-            //log.debug( "graphicsState.getTextState().getFontSize()=" + graphicsState.getTextState().getFontSize() );
-        }
-        else if( operation.equals( "Tj" ) )
-        {
-            COSString string = (COSString)arguments.get( 0 );
-            TextPosition pos = showString( string.getBytes() );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Tj string=\"" + string.getString() + "\">");
-            }
-        }
-        else if( operation.equals( "TJ" ) )
-        {
-            Matrix td = new Matrix();
-
-            COSArray array = (COSArray)arguments.get( 0 );
-            for( int i=0; i<array.size(); i++ )
-            {
-                COSBase next = array.get( i );
-                if( next instanceof COSNumber )
-                {
-                    float value = -1*
-                                  (((COSNumber)next).floatValue()/1000) *
-                                  graphicsState.getTextState().getFontSize() *
-                                  textMatrix.getValue(1,1);
-
-                    if (log.isDebugEnabled())
-                    {
-                        log.debug( "<TJ(" + i + ") value=\"" + value +
-                                   "\", param=\"" + ((COSNumber)next).floatValue() +
-                                   "\", fontsize=\"" + graphicsState.getTextState().getFontSize() + "\">" );
-                    }
-                    td.setValue( 2, 0, value );
-                    textMatrix = textMatrix.multiply( td );
-                }
-                else if( next instanceof COSString )
-                {
-                    TextPosition pos = showString( ((COSString)next).getBytes() );
-                    if (log.isDebugEnabled())
-                    {
-                        log.debug("<TJ(" + i + ") string=\"" + pos.getString() + "\">");
-                    }
-                }
-                else
-                {
-                    throw new IOException( "Unknown type in array for TJ operation:" + next );
-                }
-            }
-        }
-        else if( operation.equals( "TL" ) )
-        {
-            COSNumber leading = (COSNumber)arguments.get( 0 );
-            graphicsState.getTextState().setLeading( leading.floatValue() );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<TL leading=\"" + leading.floatValue() + "\" >");
-            }
-        }
-        else if( operation.equals( "Tm" ) )
-        {
-            //Set text matrix and text line matrix
-            COSNumber a = (COSNumber)arguments.get( 0 );
-            COSNumber b = (COSNumber)arguments.get( 1 );
-            COSNumber c = (COSNumber)arguments.get( 2 );
-            COSNumber d = (COSNumber)arguments.get( 3 );
-            COSNumber e = (COSNumber)arguments.get( 4 );
-            COSNumber f = (COSNumber)arguments.get( 5 );
-
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Tm " +
-                          "a=\"" + a.floatValue() + "\" " +
-                          "b=\"" + b.floatValue() + "\" " +
-                          "c=\"" + c.floatValue() + "\" " +
-                          "d=\"" + d.floatValue() + "\" " +
-                          "e=\"" + e.floatValue() + "\" " +
-                          "f=\"" + f.floatValue() + "\" >");
-            }
-
-            textMatrix = new Matrix();
-            textMatrix.setValue( 0, 0, a.floatValue() );
-            textMatrix.setValue( 0, 1, b.floatValue() );
-            textMatrix.setValue( 1, 0, c.floatValue() );
-            textMatrix.setValue( 1, 1, d.floatValue() );
-            textMatrix.setValue( 2, 0, e.floatValue() );
-            textMatrix.setValue( 2, 1, f.floatValue() );
-            textLineMatrix = textMatrix.copy();
-        }
-        else if( operation.equals( "Tr" ) )
-        {
-            //Set text rendering mode
-            //System.out.println( "<Tr>" );
-        }
-        else if( operation.equals( "Ts" ) )
-        {
-            //Set text rise
-            //System.out.println( "<Ts>" );
-        }
-        else if( operation.equals( "Tw" ) )
-        {
-            //set word spacing
-            COSNumber wordSpacing = (COSNumber)arguments.get( 0 );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<Tw wordSpacing=\"" + wordSpacing.floatValue() + "\" />");
-            }
-            graphicsState.getTextState().setWordSpacing( wordSpacing.floatValue() );
-        }
-        else if( operation.equals( "Tz" ) )
-        {
-            //Set horizontal text scaling
-        }
-        else if( operation.equals( "v" ) )
-        {
-            //Append curved segment to path (initial point replicated)
-        }
-        else if( operation.equals( "w" ) )
-        {
-            //Set the line width in the graphics state
-            //System.out.println( "<w>" );
-        }
-        else if( operation.equals( "W" ) )
-        {
-            //Set clipping path using nonzero winding number rule
-            //System.out.println( "<W>" );
-        }
-        else if( operation.equals( "W*" ) )
-        {
-            //Set clipping path using even-odd rule
-        }
-        else if( operation.equals( "y" ) )
-        {
-            //Append curved segment to path (final point replicated)
-        }
-        else if( operation.equals( "'" ) )
-        {
-            // Move to start of next text line, and show text
-            //
-            COSString string = (COSString)arguments.get( 0 );
-            if (log.isDebugEnabled())
-            {
-                log.debug("<' string=\"" + string.getString() + "\">");
-            }
-
-            Matrix td = new Matrix();
-            td.setValue( 2, 1, -1 * graphicsState.getTextState().getLeading() * textMatrix.getValue(1,1));
-            textLineMatrix = textLineMatrix.multiply( td );
-            textMatrix = textLineMatrix.copy();
-
-            showString( string.getBytes() );
-        }
-        else if( operation.equals( "\"" ) )
-        {
-            //Set word and character spacing, move to next line, and show text
-            //
-            COSNumber wordSpacing = (COSNumber)arguments.get( 0 );
-            COSNumber characterSpacing = (COSNumber)arguments.get( 1 );
-            COSString string = (COSString)arguments.get( 2 );
-
-            if (log.isDebugEnabled())
-            {
-                log.debug("<\" wordSpacing=\"" + wordSpacing +
-                          "\", characterSpacing=\"" + characterSpacing +
-                          "\", string=\"" + string.getString() + "\">");
-            }
-
-            graphicsState.getTextState().setCharacterSpacing( characterSpacing.floatValue() );
-            graphicsState.getTextState().setWordSpacing( wordSpacing.floatValue() );
-
-            Matrix td = new Matrix();
-            td.setValue( 2, 1, -1 * graphicsState.getTextState().getLeading() * textMatrix.getValue(1,1));
-            textLineMatrix = textLineMatrix.multiply( td );
-            textMatrix = textLineMatrix.copy();
-
-            showString( string.getBytes() );
-        }*/
-    }
-
-
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDInlinedImage.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDInlinedImage.java
index 95fb2f3c3a..430a5c7402 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDInlinedImage.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDInlinedImage.java
@@ -29,6 +29,7 @@ import java.io.IOException;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.filter.Filter;
 import org.apache.pdfbox.filter.FilterManager;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
@@ -36,9 +37,9 @@ import org.apache.pdfbox.util.ImageParameters;
 
 /**
  * This class represents an inlined image.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.6 $
+ * 
  */
 public class PDInlinedImage
 {
@@ -47,7 +48,7 @@ public class PDInlinedImage
 
     /**
      * This will get the image parameters.
-     *
+     * 
      * @return The image parameters.
      */
     public ImageParameters getImageParameters()
@@ -57,17 +58,18 @@ public class PDInlinedImage
 
     /**
      * This will set the image parameters for this image.
-     *
-     * @param imageParams The imageParams.
+     * 
+     * @param imageParams
+     *            The imageParams.
      */
-    public void setImageParameters( ImageParameters imageParams )
+    public void setImageParameters(ImageParameters imageParams)
     {
         params = imageParams;
     }
 
     /**
      * Get the bytes for the image.
-     *
+     * 
      * @return The image data.
      */
     public byte[] getImageData()
@@ -77,8 +79,9 @@ public class PDInlinedImage
 
     /**
      * Set the bytes that make up the image.
-     *
-     * @param value The image data.
+     * 
+     * @param value
+     *            The image data.
      */
     public void setImageData(byte[] value)
     {
@@ -86,118 +89,93 @@ public class PDInlinedImage
     }
 
     /**
-     * This will take the inlined image information and create a java.awt.Image from
-     * it.
-     *
+     * This will take the inlined image information and create a java.awt.Image from it.
+     * 
      * @return The image that this object represents.
-     *
-     * @throws IOException If there is an error creating the image.
+     * 
+     * @throws IOException
+     *             If there is an error creating the image.
      */
     public BufferedImage createImage() throws IOException
     {
-        return createImage( null );
+        return createImage(null);
     }
 
     /**
-     * This will take the inlined image information and create a java.awt.Image from
-     * it.
+     * This will take the inlined image information and create a java.awt.Image from it.
+     * 
+     * @param colorSpaces
+     *            The ColorSpace dictionary from the current resources, if any.
      * 
-     * @param colorSpaces The ColorSpace dictionary from the current resources, if any.
-     *
      * @return The image that this object represents.
-     *
-     * @throws IOException If there is an error creating the image.
+     * 
+     * @throws IOException
+     *             If there is an error creating the image.
      */
-    public BufferedImage createImage( Map colorSpaces ) throws IOException
+    public BufferedImage createImage(Map<String, PDColorSpace> colorSpaces) throws IOException
     {
-        /*
-         * This was the previous implementation, not sure which is better right now.
-         *         byte[] transparentColors = new byte[]{(byte)0xFF,(byte)0xFF};
-        byte[] colors=new byte[]{0, (byte)0xFF};
-        IndexColorModel colorModel = new IndexColorModel( 1, 2, colors, colors, colors, transparentColors );
-        BufferedImage image = new BufferedImage(
-            params.getWidth(),
-            params.getHeight(),
-            BufferedImage.TYPE_BYTE_BINARY,
-            colorModel );
-        DataBufferByte buffer = new DataBufferByte( getImageData(), 1 );
-        WritableRaster raster =
-            Raster.createPackedRaster(
-                buffer,
-                params.getWidth(),
-                params.getHeight(),
-                params.getBitsPerComponent(),
-                new Point(0,0) );
-        image.setData( raster );
-        return image;
-         */
-
-
-        //verify again pci32.pdf before changing below
-        PDColorSpace pcs = params.getColorSpace( colorSpaces );
+        PDColorSpace pcs = params.getColorSpace(colorSpaces);
         ColorModel colorModel = null;
-        if(pcs != null)
+        if (pcs != null)
         {
-            colorModel =
-                pcs.createColorModel(
-                        params.getBitsPerComponent() );
+            colorModel = pcs.createColorModel(params.getBitsPerComponent());
         }
         else
         {
-            byte[] transparentColors = new
-            byte[]{(byte)0xFF,(byte)0xFF};
-            byte[] colors=new byte[]{0, (byte)0xFF};
-            colorModel = new IndexColorModel( 1, 2,
-                    colors, colors, colors, transparentColors );
+            byte[] transparentColors = new byte[] { (byte) 0xFF, (byte) 0xFF };
+            byte[] colors = null;
+
+            COSArray decode = params.getDecodeValues();
+            if (decode != null && decode.getInt(0) == 1)
+            {
+                colors = new byte[] { (byte) 0xFF, 0 };
+            }
+            else
+            {
+                colors = new byte[] { 0, (byte) 0xFF };
+            }
+            colorModel = new IndexColorModel(1, 2, colors, colors, colors, transparentColors);
         }
-        List filters = params.getFilters();
+        List<String> filters = params.getFilters();
         byte[] finalData = null;
-        if( filters == null )
+        if (filters == null)
         {
             finalData = getImageData();
         }
         else
         {
-            ByteArrayInputStream in = new ByteArrayInputStream( getImageData() );
+            ByteArrayInputStream in = new ByteArrayInputStream(getImageData());
             ByteArrayOutputStream out = new ByteArrayOutputStream(getImageData().length);
             FilterManager filterManager = new FilterManager();
-            for( int i=0; i<filters.size(); i++ )
+            for (int i = 0; i < filters.size(); i++)
             {
                 out.reset();
-                Filter filter = filterManager.getFilter( (String)filters.get( i ) );
-                filter.decode( in, out, params.getDictionary(), i );
-                in = new ByteArrayInputStream( out.toByteArray() );
+                Filter filter = filterManager.getFilter((String) filters.get(i));
+                filter.decode(in, out, params.getDictionary(), i);
+                in = new ByteArrayInputStream(out.toByteArray());
             }
             finalData = out.toByteArray();
         }
 
-        WritableRaster raster = colorModel.createCompatibleWritableRaster( params.getWidth(), params.getHeight() );
-        /*    Raster.createPackedRaster(
-                buffer,
-                params.getWidth(),
-                params.getHeight(),
-                params.getBitsPerComponent(),
-                new Point(0,0) );
-                */
+        WritableRaster raster = colorModel.createCompatibleWritableRaster(params.getWidth(), params.getHeight());
         DataBuffer rasterBuffer = raster.getDataBuffer();
-        if( rasterBuffer instanceof DataBufferByte )
+        if (rasterBuffer instanceof DataBufferByte)
         {
-            DataBufferByte byteBuffer = (DataBufferByte)rasterBuffer;
+            DataBufferByte byteBuffer = (DataBufferByte) rasterBuffer;
             byte[] data = byteBuffer.getData();
-            System.arraycopy( finalData, 0, data, 0, data.length );
+            System.arraycopy(finalData, 0, data, 0, data.length);
         }
-        else if( rasterBuffer instanceof DataBufferInt )
+        else if (rasterBuffer instanceof DataBufferInt)
         {
-            DataBufferInt byteBuffer = (DataBufferInt)rasterBuffer;
+            DataBufferInt byteBuffer = (DataBufferInt) rasterBuffer;
             int[] data = byteBuffer.getData();
-            for( int i=0; i<finalData.length; i++ )
+            for (int i = 0; i < finalData.length; i++)
             {
-                data[i] = (finalData[i]+256)%256;
+                data[i] = (finalData[i] + 256) % 256;
             }
         }
-        BufferedImage image = new BufferedImage(
-                colorModel, raster, false, null );
-        image.setData( raster );
+        BufferedImage image = new BufferedImage(colorModel, raster, false, null);
+        image.setData(raster);
         return image;
     }
-}
\ No newline at end of file
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/ImageParameters.java b/pdfbox/src/main/java/org/apache/pdfbox/util/ImageParameters.java
index 5ae6f32909..afc2f10806 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/ImageParameters.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/ImageParameters.java
@@ -16,26 +16,24 @@
  */
 package org.apache.pdfbox.util;
 
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
-import org.apache.pdfbox.cos.COSInteger;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSNumber;
-
 import org.apache.pdfbox.pdmodel.common.COSArrayList;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpaceFactory;
 
-import java.io.IOException;
-import java.util.List;
-import java.util.Map;
-
 /**
  * This contains all of the image parameters for in inlined image.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.4 $
+ * 
  */
 public class ImageParameters
 {
@@ -51,17 +49,18 @@ public class ImageParameters
 
     /**
      * Constructor.
-     *
-     * @param params The image parameters.
+     * 
+     * @param params
+     *            The image parameters.
      */
-    public ImageParameters( COSDictionary params )
+    public ImageParameters(COSDictionary params)
     {
         dictionary = params;
     }
 
     /**
      * This will get the dictionary that stores the image parameters.
-     *
+     * 
      * @return The COS dictionary that stores the image parameters.
      */
     public COSDictionary getDictionary()
@@ -69,21 +68,21 @@ public class ImageParameters
         return dictionary;
     }
 
-    private COSBase getCOSObject( COSName abbreviatedName, COSName name )
+    private COSBase getCOSObject(COSName abbreviatedName, COSName name)
     {
-        COSBase retval = dictionary.getDictionaryObject( abbreviatedName );
-        if( retval == null )
+        COSBase retval = dictionary.getDictionaryObject(abbreviatedName);
+        if (retval == null)
         {
-            retval = dictionary.getDictionaryObject( name );
+            retval = dictionary.getDictionaryObject(name);
         }
         return retval;
     }
 
-    private int getNumberOrNegativeOne( COSName abbreviatedName, COSName name )
+    private int getNumberOrNegativeOne(COSName abbreviatedName, COSName name)
     {
         int retval = -1;
-        COSNumber number = (COSNumber)getCOSObject( abbreviatedName, name );
-        if( number != null )
+        COSNumber number = (COSNumber) getCOSObject(abbreviatedName, name);
+        if (number != null)
         {
             retval = number.intValue();
         }
@@ -91,145 +90,172 @@ public class ImageParameters
     }
 
     /**
-     * The bits per component of this image.  This will return -1 if one has not
-     * been set.
-     *
+     * The bits per component of this image. This will return -1 if one has not been set.
+     * 
      * @return The number of bits per component.
      */
     public int getBitsPerComponent()
     {
-        return getNumberOrNegativeOne( COSName.BPC, COSName.BITS_PER_COMPONENT );
+        return getNumberOrNegativeOne(COSName.BPC, COSName.BITS_PER_COMPONENT);
     }
 
     /**
      * Set the number of bits per component.
-     *
-     * @param bpc The number of bits per component.
+     * 
+     * @param bpc
+     *            The number of bits per component.
      */
-    public void setBitsPerComponent( int bpc )
+    public void setBitsPerComponent(int bpc)
     {
-        dictionary.setInt( COSName.BPC, bpc );
+        dictionary.setInt(COSName.BPC, bpc);
     }
 
-
     /**
      * This will get the color space or null if none exists.
-     *
+     * 
      * @return The color space for this image.
-     *
-     * @throws IOException If there is an error getting the colorspace.
+     * 
+     * @throws IOException
+     *             If there is an error getting the colorspace.
      */
     public PDColorSpace getColorSpace() throws IOException
     {
-        return getColorSpace( null );
+        return getColorSpace(null);
     }
-    
+
     /**
      * This will get the color space or null if none exists.
-     *
-     * @param colorSpaces The ColorSpace dictionary from the current resources, if any.
-     *
+     * 
+     * @param colorSpaces
+     *            The ColorSpace dictionary from the current resources, if any.
+     * 
      * @return The color space for this image.
-     *
-     * @throws IOException If there is an error getting the colorspace.
+     * 
+     * @throws IOException
+     *             If there is an error getting the colorspace.
      */
-    public PDColorSpace getColorSpace( Map colorSpaces ) throws IOException
+    public PDColorSpace getColorSpace(Map<String, PDColorSpace> colorSpaces) throws IOException
     {
-        COSBase cs = getCOSObject( COSName.CS, COSName.COLORSPACE );
+        COSBase cs = getCOSObject(COSName.CS, COSName.COLORSPACE);
         PDColorSpace retval = null;
-        if( cs != null )
+        if (cs != null)
         {
-            retval = PDColorSpaceFactory.createColorSpace( cs, colorSpaces );
+            retval = PDColorSpaceFactory.createColorSpace(cs, colorSpaces);
         }
         return retval;
     }
 
     /**
      * This will set the color space for this image.
-     *
-     * @param cs The color space for this image.
+     * 
+     * @param cs
+     *            The color space for this image.
      */
-    public void setColorSpace( PDColorSpace cs )
+    public void setColorSpace(PDColorSpace cs)
     {
         COSBase base = null;
-        if( cs != null )
+        if (cs != null)
         {
             base = cs.getCOSObject();
         }
-        dictionary.setItem( COSName.CS, base );
+        dictionary.setItem(COSName.CS, base);
     }
 
     /**
-     * The height of this image.  This will return -1 if one has not
-     * been set.
-     *
+     * The height of this image. This will return -1 if one has not been set.
+     * 
      * @return The height.
      */
     public int getHeight()
     {
-        return getNumberOrNegativeOne( COSName.H, COSName.HEIGHT );
+        return getNumberOrNegativeOne(COSName.H, COSName.HEIGHT);
     }
 
     /**
      * Set the height of the image.
-     *
-     * @param h The height of the image.
+     * 
+     * @param h
+     *            The height of the image.
      */
-    public void setHeight( int h )
+    public void setHeight(int h)
     {
-        dictionary.setInt( COSName.H, h );
+        dictionary.setInt(COSName.H, h);
     }
 
     /**
-     * The width of this image.  This will return -1 if one has not
-     * been set.
-     *
+     * The width of this image. This will return -1 if one has not been set.
+     * 
      * @return The width.
      */
     public int getWidth()
     {
-        return getNumberOrNegativeOne( COSName.W, COSName.WIDTH );
+        return getNumberOrNegativeOne(COSName.W, COSName.WIDTH);
     }
 
     /**
      * Set the width of the image.
-     *
-     * @param w The width of the image.
+     * 
+     * @param w
+     *            The width of the image.
      */
-    public void setWidth( int w )
+    public void setWidth(int w)
     {
-        dictionary.setInt( COSName.W, w );
+        dictionary.setInt(COSName.W, w);
     }
 
     /**
-     * This will get the list of filters that are associated with this stream.  Or
-     * null if there are none.
+     * This will get the list of filters that are associated with this stream. Or null if there are none.
+     * 
      * @return A list of all encoding filters to apply to this stream.
      */
-    public List getFilters()
+    public List<String> getFilters()
     {
-        List retval = null;
-        COSBase filters = dictionary.getDictionaryObject( new String[] {"Filter", "F"} );
-        if( filters instanceof COSName )
+        List<String> retval = null;
+        COSBase filters = dictionary.getDictionaryObject(COSName.F, COSName.FILTER);
+        if (filters instanceof COSName)
         {
-            COSName name = (COSName)filters;
-            retval = new COSArrayList( name.getName(), name, dictionary, COSName.FILTER );
+            COSName name = (COSName) filters;
+            retval = new COSArrayList<String>(name.getName(), name, dictionary, COSName.FILTER);
         }
-        else if( filters instanceof COSArray )
+        else if (filters instanceof COSArray)
         {
-            retval = COSArrayList.convertCOSNameCOSArrayToList( (COSArray)filters );
+            retval = COSArrayList.convertCOSNameCOSArrayToList((COSArray) filters);
         }
         return retval;
     }
 
     /**
      * This will set the filters that are part of this stream.
-     *
-     * @param filters The filters that are part of this stream.
+     * 
+     * @param filters
+     *            The filters that are part of this stream.
      */
-    public void setFilters( List filters )
+    public void setFilters(List<String> filters)
     {
-        COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray( filters );
-        dictionary.setItem( "Filter", obj );
+        COSBase obj = COSArrayList.convertStringListToCOSNameCOSArray(filters);
+        dictionary.setItem(COSName.F, obj);
     }
-}
\ No newline at end of file
+
+    /**
+     * This will set the decode values.
+     * 
+     * @param decodeValues
+     *            the new decode values.
+     */
+    public void setDecodeValues(COSArray decodeValues)
+    {
+        getDictionary().setItem(COSName.D, decodeValues);
+    }
+
+    /**
+     * Returns all decode values as COSArray.
+     * 
+     * @return the decode array.
+     */
+    public COSArray getDecodeValues()
+    {
+        COSArray decode = (COSArray) getDictionary().getDictionaryObject(COSName.D, COSName.DECODE);
+        return decode;
+    }
+
+}
diff --git a/pdfbox/src/main/resources/org/apache/pdfbox/resources/additional_glyphlist.properties b/pdfbox/src/main/resources/org/apache/pdfbox/resources/additional_glyphlist.properties
index 919f0f90f4..aafdbcc9e8 100644
--- a/pdfbox/src/main/resources/org/apache/pdfbox/resources/additional_glyphlist.properties
+++ b/pdfbox/src/main/resources/org/apache/pdfbox/resources/additional_glyphlist.properties
@@ -143,18 +143,3 @@ unionsqtext=2294
 uniontext=22C3
 vextenddouble=2225
 vextendsingle=2223
-#
-# TeX-related mappings using hexadecimal or decimal values
-#
-x1b=FB00
-x1c=FB01
-x1d=FB02
-x1e=FB03
-x8a=0141
-xff=00DF
-a27=FB00
-a28=FB01
-a29=FB02
-a30=FB03
-a138=0141
-a255=00DF
\ No newline at end of file
