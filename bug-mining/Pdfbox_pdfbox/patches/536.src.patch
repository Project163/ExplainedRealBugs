diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
index 6002dada93..8545b8042f 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
@@ -491,7 +491,7 @@ public abstract class BaseParser
             {
                 // Couldn't determine length from dict: just
                 // scan until we find endstream:
-                readUntilEndStream( out );
+                readUntilEndStream( new EndstreamOutputStream(out) );
             }
             else
             {
@@ -571,7 +571,7 @@ public abstract class BaseParser
                       	IOUtils.closeQuietly(out);
                         out = stream.createFilteredStream( streamLength );
                         // scan until we find endstream:
-                        readUntilEndStream( out );
+                        readUntilEndStream( new EndstreamOutputStream(out) );
                     }
                 }
             }
@@ -609,7 +609,7 @@ public abstract class BaseParser
                      * If for some reason we get something else here, Read until we find the next
                      * "endstream"
                      */
-                    readUntilEndStream( out );
+                    readUntilEndStream( new EndstreamOutputStream(out) );
                     endStream = readString();
                     if( !endStream.equals( ENDSTREAM_STRING ) )
                     {
@@ -735,6 +735,8 @@ public abstract class BaseParser
             }
             
         }  // while
+
+        out.flush(); // this writes a lonely CR or drops trailing CR LF and LF
     }
     
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/EndstreamOutputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/EndstreamOutputStream.java
new file mode 100644
index 0000000000..a53ee4996b
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/EndstreamOutputStream.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2014 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pdfbox.pdfparser;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class is only for the readUntilEndStream methods, to prevent a
+ * final CR LF or LF (but not a final CR!) from being written to the output.
+ * Because of that, only the 3-param write() method is implemented. This solves
+ * PDFBOX-2079 and avoids making readUntilEndStream() even more complex than it
+ * already is.
+ *
+ * @author Tilman Hausherr
+ */
+class EndstreamOutputStream extends BufferedOutputStream
+{
+    //TODO: replace this class with a PullBackOutputStream class if there ever is one
+    
+    private boolean hasCR = false;
+    private boolean hasLF = false;
+    
+    public EndstreamOutputStream(OutputStream out)
+    {
+        super(out);
+    }
+
+    /**
+     * Write CR and/or LF that were kept, then writes len bytes from the 
+     * specified byte array starting at offset off to this output stream,
+     * except trailing CR, CR LF, or LF.
+     * @param b byte array.
+     * @param off offset.
+     * @param len length of segment to write.
+     * @throws IOException 
+     */
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException
+    {
+        // first write what we kept last time
+        if (hasCR)
+        {
+            if (!hasLF && len == 1 && b[off] == '\n')
+            {
+                // previous buffer ended with CR
+                // actual buffer contains only LF so it will be the last one
+                // => we're done
+                hasCR = false; // to avoid this getting written in the flush
+                return;                    
+            }
+            super.write('\r');
+            hasCR = false;
+        }
+        if (hasLF)
+        {
+            super.write('\n');
+            hasLF = false;
+        } 
+        // don't write CR, LF, or CR LF if at the end of the buffer
+        if (len > 0)
+        {
+            if (b[off + len - 1] == '\r')
+            {
+                hasCR = true;
+                --len;
+            }
+            else if (b[off + len - 1] == '\n')
+            {
+                hasLF = true;
+                --len;
+                if (len > 0 && b[off + len - 1] == '\r')
+                {
+                    hasCR = true;
+                    --len;
+                }
+            }
+        }        
+        super.write(b, off, len);
+    } 
+
+    /**
+     * write out a single CR if one was kept. Don't write kept CR LF or LF, 
+     * and then call the base method to flush.
+     * 
+     * @throws IOException 
+     */
+    @Override
+    public void flush() throws IOException
+    {
+        // if there is only a CR and no LF, write it
+        if (hasCR && !hasLF)
+        {
+            super.write('\r');
+        }
+        hasCR = false;
+        hasLF = false;
+        super.flush();
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
index 9610da30b4..00ee46d835 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
@@ -1550,7 +1550,7 @@ public class NonSequentialPDFParser extends PDFParser
             if (useReadUntilEnd)
             {
                 out = stream.createFilteredStream(streamLengthObj);
-                readUntilEndStream(out);
+                readUntilEndStream(new EndstreamOutputStream(out));
             }
             String endStream = readString();
             if (!endStream.equals("endstream"))
@@ -1592,9 +1592,9 @@ public class NonSequentialPDFParser extends PDFParser
     	}
     	return streamLengthIsValid;
     }
+
     private void readUntilEndStream(final OutputStream out) throws IOException
     {
-
         int bufSize;
         int charMatchCount = 0;
         byte[] keyw = ENDSTREAM;
@@ -1606,7 +1606,7 @@ public class NonSequentialPDFParser extends PDFParser
         // beginning of buffer
         while ((bufSize = pdfSource.read(streamCopyBuf, charMatchCount, streamCopyBufLen - charMatchCount)) > 0)
         {
-        	// number of already matching chars
+            // number of already matching chars
             int startingMatchCount = charMatchCount;
             int bIdx = charMatchCount;
             int quickTestIdx;
@@ -1619,7 +1619,7 @@ public class NonSequentialPDFParser extends PDFParser
                 // match if current one matches; if it is not a character from
                 // keywords
                 // we can move behind the test character;
-                // this shortcut is inspired by Boyerâ€“Moore string search
+                // this shortcut is inspired by Boyer-Moore string search
                 // algorithm
                 // and can reduce parsing time by approx. 20%
                 if ((charMatchCount == 0) && ((quickTestIdx = bIdx + quickTestOffset) < maxQuicktestIdx))
@@ -1639,7 +1639,6 @@ public class NonSequentialPDFParser extends PDFParser
 
                 final byte ch = streamCopyBuf[bIdx]; // could be negative - but
                                                      // we only compare to ASCII
-
                 if (ch == keyw[charMatchCount])
                 {
                     if (++charMatchCount == keyw.length)
@@ -1656,7 +1655,6 @@ public class NonSequentialPDFParser extends PDFParser
                         // maybe ENDSTREAM is missing but we could have ENDOBJ
                         keyw = ENDOBJ;
                         charMatchCount++;
-
                     }
                     else
                     {
@@ -1688,17 +1686,17 @@ public class NonSequentialPDFParser extends PDFParser
             {
                 // keyword matched; 
             	// unread matched keyword (endstream/endobj) and following buffered content
-           		pdfSource.unread(streamCopyBuf, contentBytes, bufSize - contentBytes - keyw.length + startingMatchCount);
+           	pdfSource.unread(streamCopyBuf, contentBytes, bufSize - contentBytes - keyw.length + startingMatchCount);
                 break;
-
             }
             else
             {
                 // copy matched chars at start of buffer
                 System.arraycopy(keyw, 0, streamCopyBuf, 0, charMatchCount);
             }
-
         } // while
+        
+        out.flush(); // this writes a lonely CR or drops trailing CR LF and LF
     }
     
     /**
