diff --git a/pdfbox/src/main/java/org/apache/pdfbox/contentstream/PDFStreamEngine.java b/pdfbox/src/main/java/org/apache/pdfbox/contentstream/PDFStreamEngine.java
index ea765baea1..5f7899dde5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/contentstream/PDFStreamEngine.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/contentstream/PDFStreamEngine.java
@@ -79,9 +79,6 @@ public class PDFStreamEngine
     private boolean isProcessingPage;
     private Matrix initialMatrix;
 
-    // skip malformed or otherwise unparseable input where possible
-    private boolean forceParsing;
-
     /**
      * Creates a new PDFStreamEngine.
      */
@@ -89,26 +86,6 @@ public class PDFStreamEngine
     {
     }
 
-    /**
-     * Indicates if force parsing is activated.
-     * 
-     * @return true if force parsing is active
-     */
-    public boolean isForceParsing()
-    {
-        return forceParsing;
-    }
-
-    /**
-     * Enable/Disable force parsing.
-     * 
-     * @param forceParsingValue true activates force parsing
-     */
-    public void setForceParsing(boolean forceParsingValue)
-    {
-        forceParsing = forceParsingValue;
-    }
-
     /**
      * Register a custom operator processor with the engine.
      * 
@@ -473,7 +450,7 @@ public class PDFStreamEngine
     private void processStreamOperators(PDContentStream contentStream) throws IOException
     {
         List<COSBase> arguments = new ArrayList<COSBase>();
-        PDFStreamParser parser = new PDFStreamParser(contentStream.getContentStream(), forceParsing);
+        PDFStreamParser parser = new PDFStreamParser(contentStream.getContentStream());
         try
         {
             Iterator<Object> iter = parser.getTokenIterator();
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSDocument.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSDocument.java
index 2611c1670d..560446aba8 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSDocument.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSDocument.java
@@ -91,34 +91,16 @@ public class COSDocument extends COSBase implements Closeable
     private final File scratchDirectory;
     
     private final boolean useScratchFile;
-    
-    /**
-     * Flag to skip malformed or otherwise unparseable input where possible.
-     */
-    private final boolean forceParsing;
-
-    /**
-     * Constructor.
-     *
-     * @param forceParsingValue flag to skip malformed or otherwise unparseable
-     *                     document content where possible
-     */
-    public COSDocument(boolean forceParsingValue) 
-    {
-        this(null, forceParsingValue, false);
-    }
 
     /**
      * Constructor.
      *
-     * @param forceParsingValue flag to skip malformed or otherwise unparseable
-     *                     document content where possible
      * @param useScratchFiles enables the usage of a scratch file if set to true
      *                     
      */
-    public COSDocument(boolean forceParsingValue, boolean useScratchFiles) 
+    public COSDocument(boolean useScratchFiles)
     {
-        this(null, forceParsingValue, useScratchFiles);
+        this(null, useScratchFiles);
     }
 
     /**
@@ -128,14 +110,11 @@ public class COSDocument extends COSBase implements Closeable
      *
      * @param scratchDir directory for the temporary file,
      *                   or <code>null</code> to use the system default
-     * @param forceParsingValue flag to skip malformed or otherwise unparseable
-     *                     document content where possible
      * @param useScratchFiles enables the usage of a scratch file if set to true
      * 
      */
-    public COSDocument(File scratchDir, boolean forceParsingValue, boolean useScratchFiles) 
+    public COSDocument(File scratchDir, boolean useScratchFiles)
     {
-        forceParsing = forceParsingValue;
         scratchDirectory = scratchDir;
         useScratchFile = useScratchFiles;
     }
@@ -145,7 +124,7 @@ public class COSDocument extends COSBase implements Closeable
      */
     public COSDocument()
     {
-        this(false, false);
+        this(false);
     }
 
     /**
@@ -620,8 +599,7 @@ public class COSDocument extends COSBase implements Closeable
         for( COSObject objStream : getObjectsByType( COSName.OBJ_STM ) )
         {
             COSStream stream = (COSStream)objStream.getObject();
-            PDFObjectStreamParser parser =
-                new PDFObjectStreamParser(stream, this, forceParsing);
+            PDFObjectStreamParser parser = new PDFObjectStreamParser(stream, this);
             parser.parse();
             for( COSObject next : parser.getObjects() )
             {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
index 309284b777..c2c6a88751 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
@@ -21,11 +21,12 @@ import java.io.OutputStream;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
+import org.apache.pdfbox.util.Charsets;
 
-import org.apache.pdfbox.persistence.util.COSHEXTable;
 
 /**
- * A PDF named object.
+ * A PDF Name object.
+ *
  * @author Ben Litchfield
  */
 public final class COSName extends COSBase implements Comparable<COSName>
@@ -37,12 +38,6 @@ public final class COSName extends COSBase implements Comparable<COSName>
     // hey are already defined as static constants and don't need to be synchronized
     private static Map<String, COSName> commonNameMap = new HashMap<String, COSName>();
 
-    /** The prefix to a PDF name. */
-    public static final byte[] NAME_PREFIX = new byte[] { 47 }; // The / character
-
-    /** The escape character for a name. */
-    public static final byte[] NAME_ESCAPE = new byte[] { 35 }; // The # character
-
     //
     // IMPORTANT: this list is *alphabetized* and does not need any JavaDoc
     //
@@ -578,15 +573,9 @@ public final class COSName extends COSBase implements Comparable<COSName>
     }
 
     @Override
-    public boolean equals(Object o)
+    public boolean equals(Object object)
     {
-        boolean retval = this == o;
-        if (!retval && o instanceof COSName)
-        {
-            COSName other = (COSName) o;
-            retval = name == other.name || name.equals(other.name);
-        }
-        return retval;
+        return object instanceof COSName && name.equals(((COSName) object).name);
     }
 
     @Override
@@ -624,39 +613,37 @@ public final class COSName extends COSBase implements Comparable<COSName>
      */
     public void writePDF(OutputStream output) throws IOException
     {
-        output.write(NAME_PREFIX);
-        byte[] bytes = getName().getBytes("ISO-8859-1");
-        for (int i = 0; i < bytes.length; i++)
+        output.write('/');
+        byte[] bytes = getName().getBytes(Charsets.US_ASCII);
+        for (byte b : bytes)
         {
-            int current = (bytes[i] + 256) % 256;
+            int current = (b + 256) % 256;
 
-            // Be more restrictive than the PDF spec, "Name Objects"
-            // see PDFBOX-2073
-            if ((current >= 'A' && current <= 'Z')
-                    || (current >= 'a' && current <= 'z')
-                    || (current >= '0' && current <= '9')
-                    || current == '+'
-                    || current == '-'
-                    || current == '_'
-                    || current == '@'
-                    || current == '*'
-                    || current == '$'
-                    || current == ';'
-                    || current == '.')
+            // be more restrictive than the PDF spec, "Name Objects", see PDFBOX-2073
+            if (current >= 'A' && current <= 'Z' ||
+                    current >= 'a' && current <= 'z' ||
+                    current >= '0' && current <= '9' ||
+                    current == '+' ||
+                    current == '-' ||
+                    current == '_' ||
+                    current == '@' ||
+                    current == '*' ||
+                    current == '$' ||
+                    current == ';' ||
+                    current == '.')
             {
                 output.write(current);
             }
             else
             {
-                output.write(NAME_ESCAPE);
-                output.write(COSHEXTable.TABLE[current]);
+                output.write('#');
+                output.write(String.format("%02X", current).getBytes(Charsets.US_ASCII));
             }
         }
     }
 
     /**
-     * Not usually needed except if resources need to be reclaimed in a long running process. Patch provided by
-     * flester@GMail.com incorporated 5/23/08, Danielwilson@users.SourceForge.net
+     * Not usually needed except if resources need to be reclaimed in a long running process.
      */
     public static synchronized void clearResources()
     {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
index 7d81aa99a8..84ecbd3601 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSString.java
@@ -18,221 +18,70 @@ package org.apache.pdfbox.cos;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.charset.Charset;
 
+import java.util.Arrays;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.pdfbox.encoding.PDFDocEncodingCharset;
-import org.apache.pdfbox.persistence.util.COSHEXTable;
+import org.apache.pdfbox.util.Charsets;
+import org.apache.pdfbox.util.Hex;
 
 /**
- * This represents a string object in a PDF document.
+ * A string object, which may be a text string, a PDFDocEncoded string, ASCII string, or byte string.
+ *
+ * <p>Text strings are used for character strings that contain information intended to be
+ * human-readable, such as text annotations, bookmark names, article names, document information,
+ * and so forth.
+ *
+ * <p>PDFDocEncoded strings are used for characters that are represented in a single byte.
+ *
+ * <p>ASCII strings are used for characters that are represented in a single byte using ASCII
+ * encoding.
+ *
+ * <p>Byte strings are used for binary data represented as a series of bytes, but the encoding is
+ * not known. The bytes of the string need not represent characters.
  * 
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.30 $
+ * @author Ben Litchfield
+ * @author John Hewson
  */
-public class COSString extends COSBase
+public final class COSString extends COSBase
 {
-
-    /**
-     * Log instance.
-     */
     private static final Log LOG = LogFactory.getLog(COSString.class);
 
-    /**
-     * One of the open string tokens.
-     */
-    public static final byte[] STRING_OPEN = new byte[] { 40 }; // "(".getBytes();
-    /**
-     * One of the close string tokens.
-     */
-    public static final byte[] STRING_CLOSE = new byte[] { 41 }; // ")".getBytes( "ISO-8859-1" );
-    /**
-     * One of the open string tokens.
-     */
-    public static final byte[] HEX_STRING_OPEN = new byte[] { 60 }; // "<".getBytes( "ISO-8859-1" );
-    /**
-     * One of the close string tokens.
-     */
-    public static final byte[] HEX_STRING_CLOSE = new byte[] { 62 }; // ">".getBytes( "ISO-8859-1" );
-    /**
-     * the escape character in strings.
-     */
-    public static final byte[] ESCAPE = new byte[] { 92 }; // "\\".getBytes( "ISO-8859-1" );
-
-    /**
-     * CR escape characters.
-     */
-    public static final byte[] CR_ESCAPE = new byte[] { 92, 114 }; // "\\r".getBytes( "ISO-8859-1" );
-    /**
-     * LF escape characters.
-     */
-    public static final byte[] LF_ESCAPE = new byte[] { 92, 110 }; // "\\n".getBytes( "ISO-8859-1" );
-    /**
-     * HT escape characters.
-     */
-    public static final byte[] HT_ESCAPE = new byte[] { 92, 116 }; // "\\t".getBytes( "ISO-8859-1" );
-    /**
-     * BS escape characters.
-     */
-    public static final byte[] BS_ESCAPE = new byte[] { 92, 98 }; // "\\b".getBytes( "ISO-8859-1" );
-    /**
-     * FF escape characters.
-     */
-    public static final byte[] FF_ESCAPE = new byte[] { 92, 102 }; // "\\f".getBytes( "ISO-8859-1" );
-
-    private ByteArrayOutputStream out = null;
-    private String str = null;
-
-    /**
-     * Forces the string to be serialized in hex form but not literal form, the default is to stream in literal form.
-     */
-    private boolean forceHexForm = false;
-
-    /**
-     * Constructor.
-     */
-    public COSString()
-    {
-        out = new ByteArrayOutputStream();
-    }
-
-    /**
-     * Explicit constructor for ease of manual PDF construction.
-     * 
-     * @param value
-     *            The string value of the object.
-     */
-    public COSString(String value)
-    {
-        try
-        {
-            boolean unicode16 = false;
-            char[] chars = value.toCharArray();
-            int length = chars.length;
-            for (int i = 0; i < length; i++)
-            {
-                if (chars[i] > 255)
-                {
-                    unicode16 = true;
-                    break;
-                }
-            }
-            if (unicode16)
-            {
-                byte[] data = value.getBytes("UTF-16BE");
-                out = new ByteArrayOutputStream(data.length + 2);
-                out.write(0xFE);
-                out.write(0xFF);
-                out.write(data);
-            }
-            else
-            {
-                byte[] data = value.getBytes("ISO-8859-1");
-                out = new ByteArrayOutputStream(data.length);
-                out.write(data);
-            }
-        }
-        catch (IOException ignore)
-        {
-            LOG.error(ignore,ignore);
-            // should never happen
-        }
-    }
-
-    /**
-     * Explicit constructor for ease of manual PDF construction.
-     * 
-     * @param value
-     *            The string value of the object.
-     */
-    public COSString(byte[] value)
-    {
-        try
-        {
-            out = new ByteArrayOutputStream(value.length);
-            out.write(value);
-        }
-        catch (IOException ignore)
-        {
-            LOG.error(ignore,ignore);
-            // should never happen
-        }
-    }
-
-    /**
-     * Forces the string to be written in literal form instead of hexadecimal form.
-     * 
-     * @param v
-     *            if v is true the string will be written in literal form, otherwise it will be written in hexa if
-     *            necessary.
-     */
-
-    public void setForceLiteralForm(boolean v)
-    {
-        forceHexForm = !v;
-    }
-
-    /**
-     * Forces the string to be written in hexadecimal form instead of literal form.
-     * 
-     * @param v
-     *            if v is true the string will be written in hexadecimal form otherwise it will be written in literal if
-     *            necessary.
-     */
-
-    public void setForceHexForm(boolean v)
-    {
-        forceHexForm = v;
-    }
+    // legacy behaviour for old PDFParser
+    public static final boolean FORCE_PARSING =
+            Boolean.getBoolean("org.apache.pdfbox.forceParsing");
 
     /**
      * This will create a COS string from a string of hex characters.
-     * 
-     * @param hex
-     *            A hex string.
-     * @return A cos string with the hex characters converted to their actual bytes.
-     * @throws IOException
-     *             If there is an error with the hex string.
-     */
-    public static COSString createFromHexString(String hex) throws IOException
-    {
-        return createFromHexString(hex, false);
-    }
-
-    /**
-     * Creates a COS string from a string of hex characters, optionally ignoring malformed input.
-     * 
-     * @param hex
-     *            A hex string.
-     * @param force
-     *            flag to ignore malformed input
+     *
+     * @param hex A hex string.
      * @return A cos string with the hex characters converted to their actual bytes.
-     * @throws IOException
-     *             If there is an error with the hex string.
+     * @throws IOException If there is an error with the hex string.
      */
-    public static COSString createFromHexString(String hex, boolean force) throws IOException
+    public static COSString parseHex(String hex) throws IOException
     {
-        COSString retval = new COSString();
+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
         StringBuilder hexBuffer = new StringBuilder(hex.trim());
+
         // if odd number then the last hex digit is assumed to be 0
         if (hexBuffer.length() % 2 != 0)
         {
             hexBuffer.append('0');
         }
+
         int length = hexBuffer.length();
         for (int i = 0; i < length; i += 2)
         {
             try
             {
-                retval.append(Integer.parseInt(hexBuffer.substring(i, i + 2), 16));
+                bytes.write(Integer.parseInt(hexBuffer.substring(i, i + 2), 16));
             }
             catch (NumberFormatException e)
             {
-                if (force)
+                if (FORCE_PARSING)
                 {
-                    retval.append('?');
+                    LOG.warn("Encountered a malformed hex string");
+                    bytes.write('?'); // todo: what does Acrobat do? Any example PDFs?
                 }
                 else
                 {
@@ -240,201 +89,154 @@ public class COSString extends COSBase
                 }
             }
         }
-        return retval;
+
+        return new COSString(bytes.toByteArray());
     }
 
+    private byte[] bytes;
+    private boolean forceHexForm;
+
     /**
-     * This will take this string and create a hex representation of the bytes that make the string.
-     * 
-     * @return A hex string representing the bytes in this string.
+     * Creates a new PDF string from a byte array. This method can be used to read a string from
+     * an existing PDF file, or to create a new byte string.
+     *
+     * @param bytes The raw bytes of the PDF text string or byte string.
      */
-    public String getHexString()
+    public COSString(byte[] bytes)
     {
-        StringBuilder retval = new StringBuilder(out.size() * 2);
-        byte[] data = getBytes();
-        int length = data.length;
-        for (int i = 0; i < length; i++)
-        {
-            retval.append(COSHEXTable.HEX_TABLE[(data[i] + 256) % 256]);
-        }
-
-        return retval.toString();
+        setValue(bytes);
     }
 
     /**
-     * This will get the string that this object wraps.
-     * 
-     * @return The wrapped string.
+     * Creates a new <i>text string</i> from a Java String.
+     *
+     * @param text The string value of the object.
      */
-    public String getString()
+    public COSString(String text)
     {
-        if (this.str != null)
+        // check whether the string uses only characters available in PDFDocEncoding
+        boolean isOnlyPDFDocEncoding = true;
+        for (char c : text.toCharArray())
         {
-            return this.str;
+            if (!PDFDocEncoding.containsChar(c))
+            {
+                isOnlyPDFDocEncoding = false;
+                break;
+            }
+        }
+
+        if (isOnlyPDFDocEncoding)
+        {
+            // PDFDocEncoded string
+            bytes = PDFDocEncoding.getBytes(text);
         }
-        String retval;
-        Charset charset = PDFDocEncodingCharset.INSTANCE;
-        byte[] data = getBytes();
-        int start = 0;
-        if (data.length > 2)
+        else
         {
-            if (data[0] == (byte) 0xFF && data[1] == (byte) 0xFE)
+            // UTF-16BE encoded string with a leading byte order marker
+            byte[] data = text.getBytes(Charsets.UTF_16BE);
+            ByteArrayOutputStream out = new ByteArrayOutputStream(data.length + 2);
+            out.write(0xFE); // BOM
+            out.write(0xFF); // BOM
+            try
             {
-                charset = Charset.forName("UTF-16LE");
-                start = 2;
+                out.write(data);
             }
-            else if (data[0] == (byte) 0xFE && data[1] == (byte) 0xFF)
+            catch (IOException e)
             {
-                charset = Charset.forName("UTF-16BE");
-                start = 2;
+                // should never happen
+                throw new RuntimeException(e);
             }
+            bytes = out.toByteArray();
         }
+    }
 
-        retval = new String(data, start, data.length - start, charset);
-        str = retval;
-        return retval;
+    /**
+     * Sets the raw value of this string.
+     *
+     * @param value The raw bytes of the PDF text string or byte string.
+     */
+    public void setValue(byte[] value)
+    {
+        bytes = value.clone();
     }
 
     /**
-     * This will append a byte[] to the string.
-     * 
-     * @param data
-     *            The byte[] to add to this string.
-     * 
-     * @throws IOException
-     *             If an IO error occurs while writing the byte.
+     * Sets whether or not to force the string is to be written in hex form.
+     * This is needed when signing PDF files.
+     *
+     * @param value True to force hex.
      */
-    public void append(byte[] data) throws IOException
+    public void setForceHexForm(boolean value)
     {
-        out.write(data);
-        this.str = null;
+        this.forceHexForm = value;
     }
 
     /**
-     * This will append a byte to the string.
-     * 
-     * @param in
-     *            The byte to add to this string.
-     * 
-     * @throws IOException
-     *             If an IO error occurs while writing the byte.
+     * Returns true if the string is to be written in hex form.
      */
-    public void append(int in) throws IOException
+    public boolean getForceHexForm()
     {
-        out.write(in);
-        this.str = null;
+        return forceHexForm;
     }
 
     /**
-     * This will reset the internal buffer.
+     * Returns the content of this string as a PDF <i>text string</i>.
      */
-    public void reset()
+    public String getString()
     {
-        out.reset();
-        this.str = null;
+        // text string - BOM indicates Unicode
+        if (bytes.length > 2)
+        {
+            if ((bytes[0] & 0xff) == 0xFE && (bytes[1] & 0xff) == 0xFF)
+            {
+                // UTF-16BE
+                return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16BE);
+            }
+            else if ((bytes[0] & 0xff) == 0xFF && (bytes[1] & 0xff) == 0xFE)
+            {
+                // UTF-16LE - not in the PDF spec!
+                return new String(bytes, 2, bytes.length - 2, Charsets.UTF_16LE);
+            }
+        }
+
+        // otherwise use PDFDocEncoding
+        return PDFDocEncoding.toString(bytes);
     }
 
     /**
-     * This will get the bytes of the string.
-     * 
-     * @return A byte array that represents the string.
+     * Returns the content of this string as a PDF <i>ASCII string</i>.
      */
-    public byte[] getBytes()
+    public String getASCII()
     {
-        return out.toByteArray();
+        // ASCII string
+        return new String(bytes, Charsets.US_ASCII);
     }
 
     /**
-     * {@inheritDoc}
+     * Returns the raw bytes of the string. Best used with a PDF <i>byte string</i>.
      */
-    @Override
-    public String toString()
+    public byte[] getBytes()
     {
-        return "COSString{" + this.getString() + "}";
+        return bytes;
     }
 
     /**
-     * This will output this string as a PDF object.
-     * 
-     * @param output
-     *            The stream to write to.
-     * @throws IOException
-     *             If there is an error writing to the stream.
+     * This will take this string and create a hex representation of the bytes that make the string.
+     *
+     * @return A hex string representing the bytes in this string.
      */
-    public void writePDF(OutputStream output) throws IOException
+    public String toHexString()
     {
-        boolean outsideASCII = false;
-        // Lets first check if we need to escape this string.
-        byte[] bytes = getBytes();
-        int length = bytes.length;
-        for (int i = 0; i < length && !outsideASCII; i++)
-        {
-            // if the byte is negative then it is an eight bit byte and is
-            // outside the ASCII range.
-            outsideASCII = bytes[i] < 0;
-        }
-        if (!outsideASCII && !forceHexForm)
-        {
-            output.write(STRING_OPEN);
-            for (int i = 0; i < length; i++)
-            {
-                int b = (bytes[i] + 256) % 256;
-                switch (b)
-                {
-                case '(':
-                case ')':
-                case '\\':
-                {
-                    output.write(ESCAPE);
-                    output.write((byte) b);
-                    break;
-                }
-                case 10: // LF
-                {
-                    output.write(LF_ESCAPE);
-                    break;
-                }
-                case 13: // CR
-                {
-                    output.write(CR_ESCAPE);
-                    break;
-                }
-                case '\t':
-                {
-                    output.write(HT_ESCAPE);
-                    break;
-                }
-                case '\b':
-                {
-                    output.write(BS_ESCAPE);
-                    break;
-                }
-                case '\f':
-                {
-                    output.write(FF_ESCAPE);
-                    break;
-                }
-                default:
-                {
-                    output.write((byte) b);
-                }
-                }
-            }
-            output.write(STRING_CLOSE);
-        }
-        else
+        StringBuilder sb = new StringBuilder(bytes.length * 2);
+        for (byte b : bytes)
         {
-            output.write(HEX_STRING_OPEN);
-            for (int i = 0; i < length; i++)
-            {
-                output.write(COSHEXTable.TABLE[(bytes[i] + 256) % 256]);
-            }
-            output.write(HEX_STRING_CLOSE);
+            sb.append(Hex.getString(b));
         }
+        return sb.toString();
     }
 
     /**
-     * visitor pattern double dispatch method.
+     * Visitor pattern double dispatch method.
      * 
      * @param visitor The object to notify when visiting this object.
      * @return any object, depending on the visitor implementation, or null
@@ -446,27 +248,22 @@ public class COSString extends COSBase
         return visitor.visitFromString(this);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public boolean equals(Object obj)
     {
         if (obj instanceof COSString)
         {
             COSString strObj = (COSString) obj;
-            return this.getString().equals(strObj.getString()) && this.forceHexForm == strObj.forceHexForm;
+            return getString().equals(strObj.getString()) &&
+                   forceHexForm == strObj.forceHexForm;
         }
         return false;
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public int hashCode()
     {
-        int result = getString().hashCode();
-        return result += forceHexForm ? 17 : 0;
+        int result = Arrays.hashCode(bytes);
+        return result + (forceHexForm ? 17 : 0);
     }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/PDFDocEncoding.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/PDFDocEncoding.java
new file mode 100644
index 0000000000..a045fb8426
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/PDFDocEncoding.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pdfbox.cos;
+
+import java.io.ByteArrayOutputStream;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * The "PDFDocEncoding" encoding. Note that this is *not* a Type 1 font encoding, it is used only
+ * within PDF "text strings".
+ */
+class PDFDocEncoding
+{
+    private static final char REPLACEMENT_CHARACTER = '\uFFFD';
+
+    private static final int[] codeToUni;
+    private static final Map<Character, Integer> uniToCode;
+
+    static
+    {
+        codeToUni = new int[256];
+        uniToCode = new HashMap<Character, Integer>(256);
+
+        // initialize with basically ISO-8859-1
+        for (int i = 0; i < 256; i++)
+        {
+            set(i, (char)i);
+        }
+
+        // then do all deviations (based on the table in ISO 32000-1:2008)
+        // block 1
+        set(0x18, '\u02D8'); // BREVE
+        set(0x19, '\u02C7'); // CARON
+        set(0x1A, '\u02C6'); // MODIFIER LETTER CIRCUMFLEX ACCENT
+        set(0x1B, '\u02D9'); // DOT ABOVE
+        set(0x1C, '\u02DD'); // DOUBLE ACUTE ACCENT
+        set(0x1D, '\u02DB'); // OGONEK
+        set(0x1E, '\u02DA'); // RING ABOVE
+        set(0x1F, '\u02DC'); // SMALL TILDE
+        // block 2
+        set(0x7F, REPLACEMENT_CHARACTER); // undefined
+        set(0x80, '\u2022'); // BULLET
+        set(0x81, '\u2020'); // DAGGER
+        set(0x82, '\u2021'); // DOUBLE DAGGER
+        set(0x83, '\u2026'); // HORIZONTAL ELLIPSIS
+        set(0x84, '\u2014'); // EM DASH
+        set(0x85, '\u2013'); // EN DASH
+        set(0x86, '\u0192'); // LATIN SMALL LETTER SCRIPT F
+        set(0x87, '\u2044'); // FRACTION SLASH (solidus)
+        set(0x88, '\u2039'); // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
+        set(0x89, '\u203A'); // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
+        set(0x8A, '\u2212'); // MINUS SIGN
+        set(0x8B, '\u2030'); // PER MILLE SIGN
+        set(0x8C, '\u201E'); // DOUBLE LOW-9 QUOTATION MARK (quotedblbase)
+        set(0x8D, '\u201C'); // LEFT DOUBLE QUOTATION MARK (quotedblleft)
+        set(0x8E, '\u201D'); // RIGHT DOUBLE QUOTATION MARK (quotedblright)
+        set(0x8F, '\u2018'); // LEFT SINGLE QUOTATION MARK (quoteleft)
+        set(0x90, '\u2019'); // RIGHT SINGLE QUOTATION MARK (quoteright)
+        set(0x91, '\u201A'); // SINGLE LOW-9 QUOTATION MARK (quotesinglbase)
+        set(0x92, '\u2122'); // TRADE MARK SIGN
+        set(0x93, '\uFB01'); // LATIN SMALL LIGATURE FI
+        set(0x94, '\uFB02'); // LATIN SMALL LIGATURE FL
+        set(0x95, '\u0141'); // LATIN CAPITAL LETTER L WITH STROKE
+        set(0x96, '\u0152'); // LATIN CAPITAL LIGATURE OE
+        set(0x97, '\u0160'); // LATIN CAPITAL LETTER S WITH CARON
+        set(0x98, '\u0178'); // LATIN CAPITAL LETTER Y WITH DIAERESIS
+        set(0x99, '\u017D'); // LATIN CAPITAL LETTER Z WITH CARON
+        set(0x9A, '\u0131'); // LATIN SMALL LETTER DOTLESS I
+        set(0x9B, '\u0142'); // LATIN SMALL LETTER L WITH STROKE
+        set(0x9C, '\u0153'); // LATIN SMALL LIGATURE OE
+        set(0x9D, '\u0161'); // LATIN SMALL LETTER S WITH CARON
+        set(0x9E, '\u017E'); // LATIN SMALL LETTER Z WITH CARON
+        set(0x9F, REPLACEMENT_CHARACTER); // undefined
+        set(0xA0, '\u20AC'); // EURO SIGN
+        // end of deviations
+    }
+
+    private static void set(int code, char unicode)
+    {
+        codeToUni[code] = unicode;
+        uniToCode.put(unicode, code);
+    }
+
+    /**
+     * Returns the string representation of the given PDFDocEncoded bytes.
+     */
+    public static String toString(byte[] bytes)
+    {
+        StringBuilder sb = new StringBuilder();
+        for (byte b : bytes)
+        {
+            if ((b & 0xff) >= codeToUni.length)
+            {
+                sb.append('?');
+            }
+            else
+            {
+                sb.append((char)codeToUni[b & 0xff]);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Returns the given string encoded with PDFDocEncoding.
+     */
+    public static byte[] getBytes(String text)
+    {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        for (char c : text.toCharArray())
+        {
+            Integer code = uniToCode.get(c);
+            if (code == null)
+            {
+                out.write(0);
+            }
+            else
+            {
+                out.write(c);
+            }
+        }
+        return out.toByteArray();
+    }
+
+    /**
+     * Returns true if the given character is available in PDFDocEncoding.
+     *
+     * @param character UTF-16 character
+     */
+    public static boolean containsChar(char character)
+    {
+        return uniToCode.containsKey(character);
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java
deleted file mode 100644
index 5bae4a7dd8..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/encoding/PDFDocEncodingCharset.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.encoding;
-
-import java.nio.charset.Charset;
-
-/**
- * {@link Charset} implementation for the "PDFDocEncoding" from the PDF specification.
- * @version $Revision$
- */
-public class PDFDocEncodingCharset extends SingleByteCharset
-{
-    /** Singleton instance. */
-    public static final PDFDocEncodingCharset INSTANCE = new PDFDocEncodingCharset();
-
-    /**
-     * Creates a new "PDFDocEncoding" charset.
-     */
-    public PDFDocEncodingCharset()
-    {
-        super("PDFDocEncoding", null, createEncoding());
-    }
-
-    private static char[] createEncoding()
-    {
-        char[] encoding = new char[256];
-
-        //Initialize with basically ISO-8859-1
-        for (int i = 0; i < 256; i++)
-        {
-            encoding[i] = (char)i;
-        }
-        //...then do all deviations (based on the table in ISO 32000-1:2008)
-        //block 1
-        encoding[0x18] = '\u02D8'; //BREVE
-        encoding[0x19] = '\u02C7'; //CARON
-        encoding[0x1A] = '\u02C6'; //MODIFIER LETTER CIRCUMFLEX ACCENT
-        encoding[0x1B] = '\u02D9'; //DOT ABOVE
-        encoding[0x1C] = '\u02DD'; //DOUBLE ACUTE ACCENT
-        encoding[0x1D] = '\u02DB'; //OGONEK
-        encoding[0x1E] = '\u02DA'; //RING ABOVE
-        encoding[0x1F] = '\u02DC'; //SMALL TILDE
-        //block 2
-        encoding[0x7F] = REPLACEMENT_CHARACTER; //undefined
-        encoding[0x80] = '\u2022'; //BULLET
-        encoding[0x81] = '\u2020'; //DAGGER
-        encoding[0x82] = '\u2021'; //DOUBLE DAGGER
-        encoding[0x83] = '\u2026'; //HORIZONTAL ELLIPSIS
-        encoding[0x84] = '\u2014'; //EM DASH
-        encoding[0x85] = '\u2013'; //EN DASH
-        encoding[0x86] = '\u0192'; //LATIN SMALL LETTER SCRIPT F
-        encoding[0x87] = '\u2044'; //FRACTION SLASH (solidus)
-        encoding[0x88] = '\u2039'; //SINGLE LEFT-POINTING ANGLE QUOTATION MARK
-        encoding[0x89] = '\u203A'; //SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
-        encoding[0x8A] = '\u2212'; //MINUS SIGN
-        encoding[0x8B] = '\u2030'; //PER MILLE SIGN
-        encoding[0x8C] = '\u201E'; //DOUBLE LOW-9 QUOTATION MARK (quotedblbase)
-        encoding[0x8D] = '\u201C'; //LEFT DOUBLE QUOTATION MARK (double quote left)
-        encoding[0x8E] = '\u201D'; //RIGHT DOUBLE QUOTATION MARK (quotedblright)
-        encoding[0x8F] = '\u2018'; //LEFT SINGLE QUOTATION MARK (quoteleft)
-        encoding[0x90] = '\u2019'; //RIGHT SINGLE QUOTATION MARK (quoteright)
-        encoding[0x91] = '\u201A'; //SINGLE LOW-9 QUOTATION MARK (quotesinglbase)
-        encoding[0x92] = '\u2122'; //TRADE MARK SIGN
-        encoding[0x93] = '\uFB01'; //LATIN SMALL LIGATURE FI
-        encoding[0x94] = '\uFB02'; //LATIN SMALL LIGATURE FL
-        encoding[0x95] = '\u0141'; //LATIN CAPITAL LETTER L WITH STROKE
-        encoding[0x96] = '\u0152'; //LATIN CAPITAL LIGATURE OE
-        encoding[0x97] = '\u0160'; //LATIN CAPITAL LETTER S WITH CARON
-        encoding[0x98] = '\u0178'; //LATIN CAPITAL LETTER Y WITH DIAERESIS
-        encoding[0x99] = '\u017D'; //LATIN CAPITAL LETTER Z WITH CARON
-        encoding[0x9A] = '\u0131'; //LATIN SMALL LETTER DOTLESS I
-        encoding[0x9B] = '\u0142'; //LATIN SMALL LETTER L WITH STROKE
-        encoding[0x9C] = '\u0153'; //LATIN SMALL LIGATURE OE
-        encoding[0x9D] = '\u0161'; //LATIN SMALL LETTER S WITH CARON
-        encoding[0x9E] = '\u017E'; //LATIN SMALL LETTER Z WITH CARON
-        encoding[0x9F] = REPLACEMENT_CHARACTER; //undefined
-        encoding[0xA0] = '\u20AC'; //EURO SIGN
-        //end of deviations
-        return encoding;
-    }
-
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java
deleted file mode 100644
index 1323ef506c..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/encoding/SingleByteCharset.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.encoding;
-
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CoderResult;
-
-/**
- * {@link Charset} implementation for the single-byte encodings.
- * @version $Revision$
- */
-public class SingleByteCharset extends Charset
-{
-
-    /** Unicode replacement character 0xFFFD. */
-    protected static final char REPLACEMENT_CHARACTER = '\uFFFD';
-
-    private final char[] toUnicodeMap;
-    private byte[][] toByteMap;
-
-    /**
-     * Creates a new single-byte charset using an array of unicode characters.
-     * @param canonicalName the canonical name
-     * @param aliases An array of this charset's aliases, or null if it has no aliases
-     * @param toUnicodeMap the array of unicode characters (may have a maximum of 256 characters,
-     *          first character must be 0x0000)
-     */
-    protected SingleByteCharset(String canonicalName, String[] aliases, char[] toUnicodeMap)
-    {
-        super(canonicalName, aliases);
-        if (toUnicodeMap.length > 256)
-        {
-            throw new IllegalArgumentException("Single-byte encodings may have at most 256 characters.");
-        }
-        //Copy array so it cannot be changed accidentally from the outside
-        this.toUnicodeMap = new char[256];
-        System.arraycopy(toUnicodeMap, 0, this.toUnicodeMap, 0, toUnicodeMap.length);
-        //build the inverse lookup table
-        initInverseMap();
-    }
-
-    private void initInverseMap()
-    {
-        toByteMap = new byte[256][];
-        if (toUnicodeMap[0] != '\u0000')
-        {
-            throw new IllegalArgumentException("First character in map must be a NUL (0x0000) character.");
-            //because we're using 0x00 for encoding otherwise unmapped characters
-        }
-
-        //we're building a kind of sparse lookup table in which not all subranges are covered.
-        for (int i = 1, len = toUnicodeMap.length; i < len; i++)
-        {
-            char ch = toUnicodeMap[i];
-            if (ch == REPLACEMENT_CHARACTER)
-            {
-                continue; //skip
-            }
-            int upper = ch >> 8;
-            int lower = ch & 0xFF;
-            if (upper > 0xFF)
-            {
-                throw new IllegalArgumentException("Not a compatible character: "
-                        + ch + " (" + Integer.toHexString(ch) + ")");
-            }
-            byte[] map = toByteMap[upper];
-            if (map == null)
-            {
-                map = new byte[256];
-                toByteMap[upper] = map;
-            }
-            map[lower] = (byte)(i & 0xFF);
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public boolean contains(Charset cs)
-    {
-        return (cs.getClass() == getClass());
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public CharsetDecoder newDecoder()
-    {
-        return new Decoder();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    public CharsetEncoder newEncoder()
-    {
-        return new Encoder();
-    }
-
-    /** The decoder. */
-    private class Decoder extends CharsetDecoder
-    {
-
-        protected Decoder()
-        {
-            super(SingleByteCharset.this, 1, 1);
-        }
-
-        @Override
-        protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out)
-        {
-            while (in.hasRemaining())
-            {
-                byte b = in.get();
-                char ch;
-
-                if (!out.hasRemaining())
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.OVERFLOW;
-                }
-                ch = toUnicodeMap[b & 0xFF];
-                if (ch == REPLACEMENT_CHARACTER)
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.unmappableForLength(1);
-                }
-                out.put(ch);
-            }
-            return CoderResult.UNDERFLOW;
-        }
-
-    }
-
-    /** The encoder. */
-    private class Encoder extends CharsetEncoder
-    {
-
-        protected Encoder()
-        {
-            super(SingleByteCharset.this, 1, 1);
-        }
-
-        @Override
-        protected CoderResult encodeLoop(CharBuffer in, ByteBuffer out)
-        {
-            while (in.hasRemaining())
-            {
-                int ch = in.get();
-
-                if (!out.hasRemaining())
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.OVERFLOW;
-                }
-
-                int upper = ch >> 8;
-                int lower = ch & 0xFF;
-                if (upper > 0xFF)
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.unmappableForLength(1);
-                }
-                byte[] map = toByteMap[upper];
-                if (map == null)
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.unmappableForLength(1);
-                }
-                byte b = map[lower];
-                if (b == 0x00)
-                {
-                    in.position(in.position() - 1);
-                    return CoderResult.unmappableForLength(1);
-                }
-
-                out.put(b);
-            }
-            return CoderResult.UNDERFLOW;
-        }
-
-    }
-
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/package.html b/pdfbox/src/main/java/org/apache/pdfbox/encoding/package.html
deleted file mode 100644
index 493554b679..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/encoding/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!--
- ! Licensed to the Apache Software Foundation (ASF) under one or more
- ! contributor license agreements.  See the NOTICE file distributed with
- ! this work for additional information regarding copyright ownership.
- ! The ASF licenses this file to You under the Apache License, Version 2.0
- ! (the "License"); you may not use this file except in compliance with
- ! the License.  You may obtain a copy of the License at
- !
- !      http://www.apache.org/licenses/LICENSE-2.0
- !
- ! Unless required by applicable law or agreed to in writing, software
- ! distributed under the License is distributed on an "AS IS" BASIS,
- ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ! See the License for the specific language governing permissions and
- ! limitations under the License.
- !-->
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-
-</head>
-<body>
-This package contains the implementations for all of the encodings that are used in PDF documents.
-</body>
-</html>
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/ASCIIHexFilter.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/ASCIIHexFilter.java
index cc9c43f3be..e7fb30c787 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/ASCIIHexFilter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/ASCIIHexFilter.java
@@ -23,11 +23,11 @@ import java.io.OutputStream;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSDictionary;
-
-import org.apache.pdfbox.persistence.util.COSHEXTable;
+import org.apache.pdfbox.util.Hex;
 
 /**
  * Decodes data encoded in an ASCII hexadecimal form, reproducing the original binary data.
+ *
  * @author Ben Litchfield
  */
 final class ASCIIHexFilter extends Filter
@@ -106,7 +106,7 @@ final class ASCIIHexFilter extends Filter
 
     private boolean isEOD(int c)
     {
-        return (c == 62); // '>' - EOD
+        return c == '>';
     }
 
     @Override
@@ -116,8 +116,7 @@ final class ASCIIHexFilter extends Filter
         int byteRead;
         while ((byteRead = input.read()) != -1)
         {
-            int value = (byteRead + 256) % 256;
-            encoded.write(COSHEXTable.TABLE[value]);
+            encoded.write(Hex.getBytes((byte)byteRead));
         }
         encoded.flush();
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
index e527b5e8b9..06ed957392 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/BaseParser.java
@@ -123,12 +123,6 @@ public abstract class BaseParser
      */
     private static final String NULL = "null";
 
-    /**
-     * Default value of the {@link #forceParsing} flag.
-     */
-    public static final boolean FORCE_PARSING =
-        Boolean.getBoolean("org.apache.pdfbox.forceParsing");
-
     /**
      * This is the stream that will be read from.
      */
@@ -139,30 +133,20 @@ public abstract class BaseParser
      */
     protected COSDocument document;
 
-    /**
-     * Flag to skip malformed or otherwise unparseable input where possible.
-     */
-    protected final boolean forceParsing;
-
     /**
      * Default constructor.
      */
     public BaseParser()
     {
-        this.forceParsing = FORCE_PARSING;
     }
 
     /**
      * Constructor.
      *
-     * @since Apache PDFBox 1.3.0
      * @param input The input stream to read the data from.
-     * @param forceParsingValue flag to skip malformed or otherwise unparseable
-     *                     input where possible
      * @throws IOException If there is an error reading the input stream.
      */
-    public BaseParser(InputStream input, boolean forceParsingValue)
-            throws IOException
+    public BaseParser(InputStream input) throws IOException
     {
         int pushbacksize = 65536;
         try
@@ -177,18 +161,6 @@ public abstract class BaseParser
         }
         this.pdfSource = new PushBackInputStream(
                 new BufferedInputStream(input, 16384), pushbacksize);
-        this.forceParsing = forceParsingValue;
-    }
-
-    /**
-     * Constructor.
-     *
-     * @param input The input stream to read the data from.
-     * @throws IOException If there is an error reading the input stream.
-     */
-    public BaseParser(InputStream input) throws IOException 
-    {
-        this(input, FORCE_PARSING);
     }
 
     /**
@@ -471,19 +443,19 @@ public abstract class BaseParser
             {
                 length = ( (COSNumber) streamLength).intValue();
             }
-// commented out next chunk since for the sequentially working PDFParser
-// we do not know if length object is redefined later on and the currently
-// read indirect object might be obsolete (e.g. not referenced in xref table);
-// this would result in reading wrong number of bytes;
-// Thus the only reliable information is a direct length. 
-// This exclusion shouldn't harm much since in case of indirect objects they will
-// typically be defined after the stream object, thus keeping the directly
-// provided length will fix most cases
-//            else if ( ( streamLength instanceof COSObject ) &&
-//                      ( ( (COSObject) streamLength ).getObject() instanceof COSNumber ) )
-//            {
-//                length = ( (COSNumber) ( (COSObject) streamLength ).getObject() ).intValue();
-//            } 
+            // commented out next chunk since for the sequentially working PDFParser
+            // we do not know if length object is redefined later on and the currently
+            // read indirect object might be obsolete (e.g. not referenced in xref table);
+            // this would result in reading wrong number of bytes;
+            // Thus the only reliable information is a direct length.
+            // This exclusion shouldn't harm much since in case of indirect objects they will
+            // typically be defined after the stream object, thus keeping the directly
+            // provided length will fix most cases
+            // else if ( ( streamLength instanceof COSObject ) &&
+            //           ( ( (COSObject) streamLength ).getObject() instanceof COSNumber ) )
+            // {
+            //     length = ( (COSNumber) ( (COSObject) streamLength ).getObject() ).intValue();
+            // }
             
             if ( length == -1 )
             {
@@ -820,7 +792,7 @@ public abstract class BaseParser
     protected COSString parseCOSString() throws IOException
     {
         char nextChar = (char)pdfSource.read();
-        COSString retval = new COSString();
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
         char openBrace;
         char closeBrace;
         if( nextChar == '(' )
@@ -854,13 +826,13 @@ public abstract class BaseParser
                 braces = checkForMissingCloseParen(braces);
                 if( braces != 0 )
                 {
-                    retval.append( ch );
+                    out.write(ch);
                 }
             }
             else if( ch == openBrace )
             {
                 braces++;
-                retval.append( ch );
+                out.write(ch);
             }
             else if( ch == '\\' )
             {
@@ -869,35 +841,35 @@ public abstract class BaseParser
                 switch(next)
                 {
                     case 'n':
-                        retval.append( '\n' );
+                        out.write('\n');
                         break;
                     case 'r':
-                        retval.append( '\r' );
+                        out.write('\r');
                         break;
                     case 't':
-                        retval.append( '\t' );
+                        out.write('\t');
                         break;
                     case 'b':
-                        retval.append( '\b' );
+                        out.write('\b');
                         break;
                     case 'f':
-                        retval.append( '\f' );
+                        out.write('\f');
                         break;
                     case ')':
                         // PDFBox 276 /Title (c:\)
                         braces = checkForMissingCloseParen(braces);
                         if( braces != 0 )
                         {
-                            retval.append( next );
+                            out.write(next);
                         }
                         else
                         {
-                            retval.append('\\');
+                            out.write('\\');
                         }
                         break;
                     case '(':
                     case '\\':
-                        retval.append( next );
+                        out.write(next);
                         break;
                     case 10:
                     case 13:
@@ -950,20 +922,20 @@ public abstract class BaseParser
                         {
                             throw new IOException( "Error: Expected octal character, actual='" + octal + "'" );
                         }
-                        retval.append( character );
+                        out.write(character);
                         break;
                     }
                     default:
                     {
                         // dropping the backslash
                         // see 7.3.4.2 Literal Strings for further information
-                        retval.append( next );
+                        out.write(next);
                     }
                 }
             }
             else
             {
-                retval.append( ch );
+                out.write(ch);
             }
             if (nextc != -2)
             {
@@ -978,7 +950,7 @@ public abstract class BaseParser
         {
             pdfSource.unread(c);
         }
-        return retval;
+        return new COSString(out.toByteArray());
     }
 
     /**
@@ -1044,7 +1016,7 @@ public abstract class BaseParser
                 break;
             }
         }
-        return COSString.createFromHexString( sBuf.toString(), forceParsing );
+        return COSString.parseHex(sBuf.toString());
     }
     
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/ConformingPDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/ConformingPDFParser.java
index 51a6630dc8..96255e3161 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/ConformingPDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/ConformingPDFParser.java
@@ -32,7 +32,6 @@ import org.apache.pdfbox.cos.COSInteger;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSNumber;
 import org.apache.pdfbox.cos.COSObject;
-import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.cos.COSString;
 import org.apache.pdfbox.cos.COSUnread;
 import org.apache.pdfbox.io.RandomAccess;
@@ -297,7 +296,7 @@ public class ConformingPDFParser extends BaseParser {
     protected COSBase processCosObject(String string) throws IOException {
         if(string != null && string.endsWith(">")) {
             // string of hex codes
-            return COSString.createFromHexString(string.replaceAll("^<", "").replaceAll(">$", ""));
+            return COSString.parseHex(string.replaceAll("^<", "").replaceAll(">$", ""));
         }
         return null;
     }
@@ -322,12 +321,12 @@ public class ConformingPDFParser extends BaseParser {
             lastSection = lastSection.replaceAll("]$", "");
             while(!lastSection.startsWith("[")) {
                 if(lastSection.matches("^\\s*<.*>\\s*$")) // it's a hex string
-                    array.add(COSString.createFromHexString(lastSection.replaceAll("^\\s*<", "").replaceAll(">\\s*$", "")));
+                    array.add(COSString.parseHex(lastSection.replaceAll("^\\s*<", "").replaceAll(">\\s*$", "")));
                 lastSection = readBackwardUntilWhitespace();
             }
             lastSection = lastSection.replaceAll("^\\[", "");
             if(lastSection.matches("^\\s*<.*>\\s*$")) // it's a hex string
-                array.add(COSString.createFromHexString(lastSection.replaceAll("^\\s*<", "").replaceAll(">\\s*$", "")));
+                array.add(COSString.parseHex(lastSection.replaceAll("^\\s*<", "").replaceAll(">\\s*$", "")));
             obj = array;
         } else if(lastSection != null && lastSection.endsWith(">")) {
             // string of hex codes
@@ -516,7 +515,7 @@ public class ConformingPDFParser extends BaseParser {
                 sb.append((char)singleByte);
                 singleByte = readByte();
             }
-            return new COSString(sb.toString());
+            return new COSString(sb.toString()); // fixme: should be calling COSString(byte[])
         } else {
             throw new RuntimeException("Not yet implemented: " + string
                     + " loation=" + this.currentOffset);
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
index 99b2d57ff3..97514bd8ab 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/NonSequentialPDFParser.java
@@ -311,7 +311,7 @@ public class NonSequentialPDFParser extends PDFParser
                         + " does not contain an integer value, but: '" + eofLookupRangeStr + "'");
             }
         }
-        setDocument(new COSDocument(false, useScratchFiles));
+        setDocument(new COSDocument(useScratchFiles));
         pdfSource = new PushBackInputStream(raStream, 4096);
     }
 
@@ -1582,7 +1582,7 @@ public class NonSequentialPDFParser extends PDFParser
                 {
                     // parse object stream
                     PDFObjectStreamParser parser = new PDFObjectStreamParser(
-                            (COSStream) objstmBaseObj, document, forceParsing);
+                            (COSStream) objstmBaseObj, document);
                     parser.parse();
 
                     // get set of object numbers referenced for this object
@@ -1611,7 +1611,7 @@ public class NonSequentialPDFParser extends PDFParser
     /**
      * 
      * @param dict the dictionary to be decrypted
-     * @param the object number
+     * @param objNr the object number
      * @param objGenNr the object generation number
      * @throws IOException ff something went wrong
      */
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
index ab5683cc7a..d4ecab580b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFObjectStreamParser.java
@@ -50,36 +50,17 @@ public class PDFObjectStreamParser extends BaseParser
     /**
      * Constructor.
      *
-     * @since Apache PDFBox 1.3.0
      * @param strm The stream to parse.
      * @param doc The document for the current parsing.
-     * @param forceParsing flag to skip malformed or otherwise unparseable
-     *                     input where possible
      * @throws IOException If there is an error initializing the stream.
      */
-    public PDFObjectStreamParser(
-            COSStream strm, COSDocument doc, boolean forceParsing)
-            throws IOException 
+    public PDFObjectStreamParser(COSStream strm, COSDocument doc) throws IOException
     {
-        super(strm.getUnfilteredStream(), forceParsing);
+        super(strm.getUnfilteredStream());
         setDocument(doc);
         stream = strm;
     }
 
-    /**
-     * Constructor.
-     *
-     * @param strm The stream to parse.
-     * @param doc The document for the current parsing.
-     *
-     * @throws IOException If there is an error initializing the stream.
-     */
-    public PDFObjectStreamParser(COSStream strm, COSDocument doc)
-            throws IOException 
-    {
-        this(strm, doc, FORCE_PARSING);
-    }
-
     /**
      * This will parse the tokens in the stream.  This will close the
      * stream when it is finished parsing.
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
index 30855013e2..bdbb927c9b 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFParser.java
@@ -63,7 +63,14 @@ public class PDFParser extends BaseParser
     
     private static final String PDF_DEFAULT_VERSION = "1.4";
     private static final String FDF_DEFAULT_VERSION = "1.0";
-    
+
+    // deprecated functionality from BaseParser:
+    /**
+     * Default value of the {@link #forceParsing} flag.
+     */
+    public static final boolean FORCE_PARSING =
+            Boolean.getBoolean("org.apache.pdfbox.forceParsing");
+
     /**
      * A list of duplicate objects found when Parsing the PDF
      * File.
@@ -84,9 +91,13 @@ public class PDFParser extends BaseParser
      * Temp file directory.
      */
     private File tempDirectory = null;
-
     private final boolean useScratchFile;
 
+    /**
+     * Flag to skip malformed or otherwise unparseable input where possible.
+     */
+    protected final boolean forceParsing;
+
     /**
      * Constructor.
      *
@@ -94,7 +105,7 @@ public class PDFParser extends BaseParser
      *
      * @throws IOException If there is an error initializing the stream.
      */
-    public PDFParser( InputStream input ) throws IOException 
+    public PDFParser( InputStream input ) throws IOException
     {
         this(input, FORCE_PARSING);
     }
@@ -108,7 +119,7 @@ public class PDFParser extends BaseParser
      *
      * @throws IOException If there is an error initializing the stream.
      */
-    public PDFParser(InputStream input, boolean force) throws IOException 
+    public PDFParser(InputStream input, boolean force) throws IOException
     {
         this(input, force, false);
     }
@@ -123,9 +134,10 @@ public class PDFParser extends BaseParser
      *
      * @throws IOException If there is an error initializing the stream.
      */
-    public PDFParser(InputStream input, boolean force, boolean useScratchFiles) throws IOException 
+    public PDFParser(InputStream input, boolean force, boolean useScratchFiles) throws IOException
     {
-        super(input, force);
+        super(input);
+        forceParsing = force;
         useScratchFile = useScratchFiles;
     }
 
@@ -168,11 +180,11 @@ public class PDFParser extends BaseParser
         {
             if( tempDirectory != null )
             {
-                document = new COSDocument( tempDirectory, forceParsing, true );
+                document = new COSDocument( tempDirectory, true );
             }
             else if(useScratchFile)
             {
-                document = new COSDocument( null, forceParsing, true );
+                document = new COSDocument( null, true );
             }
             else
             {
@@ -369,7 +381,7 @@ public class PDFParser extends BaseParser
             throw new IOException( "Error: Header doesn't contain versioninfo" );
         }
 
-        //sometimes there are some garbage bytes in the header before the header
+        //sometimes there are some garbage getBytes in the header before the header
         //actually starts, so lets try to find the header first.
         int headerStart = header.indexOf( PDF_HEADER );
         if (headerStart == -1)
@@ -965,7 +977,7 @@ public class PDFParser extends BaseParser
             xrefTrailerResolver.setTrailer( stream );
         }        
         PDFXrefStreamParser parser =
-                new PDFXrefStreamParser( stream, document, forceParsing, xrefTrailerResolver );
+                new PDFXrefStreamParser( stream, document, xrefTrailerResolver );
         parser.parse();
     }
 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
index 9e84dfd539..4db800bfc5 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFStreamParser.java
@@ -57,29 +57,12 @@ public class PDFStreamParser extends BaseParser
     /**
      * Constructor that takes a stream to parse.
      *
-     * @since Apache PDFBox 1.3.0
      * @param stream The stream to read data from.
-     * @param forceParsing flag to skip malformed or otherwise unparseable
-     *                     input where possible
      * @throws IOException If there is an error reading from the stream.
      */
-    public PDFStreamParser(InputStream stream, boolean forceParsing)
-            throws IOException 
+    public PDFStreamParser(InputStream stream) throws IOException
     {
-        super(stream, forceParsing);
-    }
-
-    /**
-     * Constructor that takes a stream to parse.
-     *
-     * @param stream The stream to read data from.
-     *
-     * @throws IOException If there is an error reading from the stream.
-     */
-    public PDFStreamParser(InputStream stream)
-            throws IOException 
-    {
-        this(stream, FORCE_PARSING);
+        super(stream);
     }
 
     /**
@@ -94,21 +77,6 @@ public class PDFStreamParser extends BaseParser
        this( stream.createInputStream() );
     }
 
-    /**
-     * Constructor.
-     *
-     * @since Apache PDFBox 1.3.0
-     * @param stream The stream to parse.
-     * @param forceParsing flag to skip malformed or otherwise unparseable
-     *                     input where possible
-     * @throws IOException If there is an error initializing the stream.
-     */
-    public PDFStreamParser(COSStream stream, boolean forceParsing)
-            throws IOException 
-    {
-       this(stream.getUnfilteredStream(), forceParsing);
-    }
-
     /**
      * Constructor.
      *
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java
index dafeb7d0a9..f33fc0aecc 100755
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfparser/PDFXrefStreamParser.java
@@ -44,21 +44,16 @@ public class PDFXrefStreamParser extends BaseParser
     /**
      * Constructor.
      *
-     * @since 1.3.0
      * @param strm The stream to parse.
      * @param doc The document for the current parsing.
-     * @param forceParsing flag to skip malformed or otherwise unparseable
-     *                     input where possible
      * @param resolver resolver to read the xref/trailer information
      *
      * @throws IOException If there is an error initializing the stream.
      */
-    public PDFXrefStreamParser(
-            COSStream strm, COSDocument doc, boolean forceParsing,
-            XrefTrailerResolver resolver )
+    public PDFXrefStreamParser(COSStream strm, COSDocument doc, XrefTrailerResolver resolver )
             throws IOException
     {
-        super(strm.getUnfilteredStream(), forceParsing);
+        super(strm.getUnfilteredStream());
         setDocument(doc);
         stream = strm;
         this.xrefTrailerResolver = resolver;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSStandardOutputStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSStandardOutputStream.java
index c5945ecab8..3bc44f5328 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSStandardOutputStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSStandardOutputStream.java
@@ -20,8 +20,6 @@ import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 
-import org.apache.pdfbox.util.StringUtil;
-
 /**
  * simple output stream with some minor features for generating "pretty" PDF files.
  *
@@ -32,17 +30,17 @@ public class COSStandardOutputStream extends FilterOutputStream
     /**
      * To be used when 2 byte sequence is enforced.
      */
-    public static final byte[] CRLF = StringUtil.getBytes("\r\n");
+    public static final byte[] CRLF = { '\r', '\n' };
 
     /**
      * Line feed character.
      */
-    public static final byte[] LF = StringUtil.getBytes("\n");
+    public static final byte[] LF = { '\n' };
 
     /**
      * standard line separator.
      */
-    public static final byte[] EOL = StringUtil.getBytes("\n");
+    public static final byte[] EOL = { '\n' };
 
     // current byte position in the output stream
     private long position = 0;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
index 75615d4752..102ee7f309 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/COSWriter.java
@@ -60,48 +60,40 @@ import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.encryption.SecurityHandler;
 import org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface;
 import org.apache.pdfbox.persistence.util.COSObjectKey;
-import org.apache.pdfbox.util.StringUtil;
+import org.apache.pdfbox.util.Charsets;
+import org.apache.pdfbox.util.Hex;
 
 /**
- * this class acts on a in-memory representation of a pdf document.
- *
- * todo no support for incremental updates
- * todo single xref section only
- * todo no linearization
+ * This class acts on a in-memory representation of a PDF document.
  *
  * @author Michael Traut
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * 
+ * @author Ben Litchfield
  */
 public class COSWriter implements ICOSVisitor, Closeable
 {
-
-    /**
-     * Log instance.
-     */
     private static final Log LOG = LogFactory.getLog(COSWriter.class);
 
     /**
      * The dictionary open token.
      */
-    public static final byte[] DICT_OPEN = StringUtil.getBytes("<<");
+    public static final byte[] DICT_OPEN = "<<".getBytes(Charsets.US_ASCII);
     /**
      * The dictionary close token.
      */
-    public static final byte[] DICT_CLOSE = StringUtil.getBytes(">>");
+    public static final byte[] DICT_CLOSE = ">>".getBytes(Charsets.US_ASCII);
     /**
      * space character.
      */
-    public static final byte[] SPACE = StringUtil.getBytes(" ");
+    public static final byte[] SPACE = { ' ' };
     /**
      * The start to a PDF comment.
      */
-    public static final byte[] COMMENT = StringUtil.getBytes("%");
+    public static final byte[] COMMENT = { '%' };
 
     /**
      * The output version of the PDF.
      */
-    public static final byte[] VERSION = StringUtil.getBytes("PDF-1.4");
+    public static final byte[] VERSION = "PDF-1.4".getBytes(Charsets.US_ASCII);
     /**
      * Garbage bytes used to create the PDF header.
      */
@@ -109,57 +101,57 @@ public class COSWriter implements ICOSVisitor, Closeable
     /**
      * The EOF constant.
      */
-    public static final byte[] EOF = StringUtil.getBytes("%%EOF");
+    public static final byte[] EOF = "%%EOF".getBytes(Charsets.US_ASCII);
     // pdf tokens
 
     /**
      * The reference token.
      */
-    public static final byte[] REFERENCE = StringUtil.getBytes("R");
+    public static final byte[] REFERENCE = "R".getBytes(Charsets.US_ASCII);
     /**
      * The XREF token.
      */
-    public static final byte[] XREF = StringUtil.getBytes("xref");
+    public static final byte[] XREF = "xref".getBytes(Charsets.US_ASCII);
     /**
      * The xref free token.
      */
-    public static final byte[] XREF_FREE = StringUtil.getBytes("f");
+    public static final byte[] XREF_FREE = "f".getBytes(Charsets.US_ASCII);
     /**
      * The xref used token.
      */
-    public static final byte[] XREF_USED = StringUtil.getBytes("n");
+    public static final byte[] XREF_USED = "n".getBytes(Charsets.US_ASCII);
     /**
      * The trailer token.
      */
-    public static final byte[] TRAILER = StringUtil.getBytes("trailer");
+    public static final byte[] TRAILER = "trailer".getBytes(Charsets.US_ASCII);
     /**
      * The start xref token.
      */
-    public static final byte[] STARTXREF = StringUtil.getBytes("startxref");
+    public static final byte[] STARTXREF = "startxref".getBytes(Charsets.US_ASCII);
     /**
      * The starting object token.
      */
-    public static final byte[] OBJ = StringUtil.getBytes("obj");
+    public static final byte[] OBJ = "obj".getBytes(Charsets.US_ASCII);
     /**
      * The end object token.
      */
-    public static final byte[] ENDOBJ = StringUtil.getBytes("endobj");
+    public static final byte[] ENDOBJ = "endobj".getBytes(Charsets.US_ASCII);
     /**
      * The array open token.
      */
-    public static final byte[] ARRAY_OPEN = StringUtil.getBytes("[");
+    public static final byte[] ARRAY_OPEN = "[".getBytes(Charsets.US_ASCII);
     /**
      * The array close token.
      */
-    public static final byte[] ARRAY_CLOSE = StringUtil.getBytes("]");
+    public static final byte[] ARRAY_CLOSE = "]".getBytes(Charsets.US_ASCII);
     /**
      * The open stream token.
      */
-    public static final byte[] STREAM = StringUtil.getBytes("stream");
+    public static final byte[] STREAM = "stream".getBytes(Charsets.US_ASCII);
     /**
      * The close stream token.
      */
-    public static final byte[] ENDSTREAM = StringUtil.getBytes("endstream");
+    public static final byte[] ENDSTREAM = "endstream".getBytes(Charsets.US_ASCII);
 
     private NumberFormat formatXrefOffset = new DecimalFormat("0000000000");
 
@@ -594,11 +586,8 @@ public class COSWriter implements ICOSVisitor, Closeable
     }
 
     /**
-     * write the x ref section for the pdf file
-     *
-     * currently, the pdf is reconstructed from the scratch, so we write a single section
-     *
-     * todo support for incremental writing?
+     * Write the x ref section for the pdf file.
+     * Currently, the pdf is reconstructed from the scratch, so we write a single section.
      *
      * @param doc The document to write the xref from.
      *
@@ -798,7 +787,7 @@ public class COSWriter implements ICOSVisitor, Closeable
         // sign the bytes
         SignatureInterface signatureInterface = doc.getSignatureInterface();
         byte[] sign = signatureInterface.sign(signStream);
-        String signature = new COSString(sign).getHexString();
+        String signature = new COSString(sign).toHexString();
         // substract 2 bytes because of the enclosing "<>"
         if (signature.length() > signatureLength - 2)
         {
@@ -961,12 +950,6 @@ public class COSWriter implements ICOSVisitor, Closeable
             {
                 COSNull.NULL.accept( this );
             }
-            else if( current instanceof COSString )
-            {
-                COSString copy = new COSString();
-                copy.append(((COSString)current).getBytes());
-                copy.accept(this);
-            }
             else
             {
                 current.accept(this);
@@ -1260,7 +1243,7 @@ public class COSWriter implements ICOSVisitor, Closeable
     @Override
     public Object visitFromString(COSString obj) throws IOException
     {
-        if(willEncrypt)
+        if (willEncrypt)
         {
             document.getEncryption().getSecurityHandler().encryptString(
                     obj,
@@ -1268,7 +1251,7 @@ public class COSWriter implements ICOSVisitor, Closeable
                     currentObjectKey.getGeneration());
         }
 
-        obj.writePDF( getStandardOutput() );
+        COSWriter.writeString(obj, getStandardOutput());
         return null;
     }
 
@@ -1378,4 +1361,99 @@ public class COSWriter implements ICOSVisitor, Closeable
         }
         cosDoc.accept(this);
     }
+
+    /**
+     * This will output the given byte getString as a PDF object.
+     *
+     * @param output The stream to write to.
+     * @throws IOException If there is an error writing to the stream.
+     */
+    public static void writeString(COSString string, OutputStream output) throws IOException
+    {
+        writeString(string.getBytes(), string.getForceHexForm(), output);
+    }
+
+    /**
+     * This will output the given text/byte getString as a PDF object.
+     *
+     * @param output The stream to write to.
+     * @throws IOException If there is an error writing to the stream.
+     */
+    public static void writeString(byte[] bytes, OutputStream output) throws IOException
+    {
+        writeString(bytes, false, output);
+    }
+
+    /**
+     * This will output the given text/byte string as a PDF object.
+     *
+     * @param output The stream to write to.
+     * @throws IOException If there is an error writing to the stream.
+     */
+    private static void writeString(byte[] bytes, boolean forceHex, OutputStream output)
+            throws IOException
+    {
+        // check for non-ASCII characters
+        boolean isASCII = true;
+        for (byte b : bytes)
+        {
+            // if the byte is negative then it is an eight bit byte and is outside the ASCII range
+            if (b < 0)
+            {
+                isASCII = false;
+                break;
+            }
+        }
+
+        if (isASCII && !forceHex)
+        {
+            // write ASCII string
+            output.write('(');
+            for (byte b : bytes)
+            {
+                switch (b)
+                {
+                    case '(':
+                    case ')':
+                    case '\\':
+                        output.write('\\');
+                        output.write(b);
+                        break;
+                    case '\r':
+                        output.write('\\');
+                        output.write('\r');
+                        break;
+                    case '\n':
+                        output.write('\\');
+                        output.write('\n');
+                        break;
+                    case '\t':
+                        output.write('\\');
+                        output.write('\t');
+                        break;
+                    case '\b':
+                        output.write('\\');
+                        output.write('\b');
+                        break;
+                    case '\f':
+                        output.write('\\');
+                        output.write('\f');
+                        break;
+                    default:
+                        output.write(b);
+                }
+            }
+            output.write(')');
+        }
+        else
+        {
+            // write hex string
+            output.write('<');
+            for (byte b : bytes)
+            {
+                output.write(Hex.getBytes(b));
+            }
+            output.write('>');
+        }
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/ContentStreamWriter.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/ContentStreamWriter.java
index 34c0d65258..8f98a6dd1c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/ContentStreamWriter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfwriter/ContentStreamWriter.java
@@ -86,7 +86,7 @@ public class ContentStreamWriter
     {
         if( o instanceof COSString )
         {
-            ((COSString)o).writePDF( output );
+            COSWriter.writeString((COSString)o, output);
         }
         else if( o instanceof COSFloat )
         {
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/edit/PDPageContentStream.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/edit/PDPageContentStream.java
index 80ef556ca9..2ddb875694 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/edit/PDPageContentStream.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/edit/PDPageContentStream.java
@@ -20,11 +20,10 @@ import java.awt.Color;
 import java.awt.color.ColorSpace;
 import java.awt.geom.AffineTransform;
 import java.awt.geom.PathIterator;
-import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.List;
@@ -37,7 +36,7 @@ import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSInteger;
 import org.apache.pdfbox.cos.COSName;
-import org.apache.pdfbox.cos.COSString;
+import org.apache.pdfbox.pdfwriter.COSWriter;
 import org.apache.pdfbox.pdmodel.PDDocument;
 import org.apache.pdfbox.pdmodel.PDPage;
 import org.apache.pdfbox.pdmodel.PDResources;
@@ -54,100 +53,91 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDSeparation;
 import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
 import org.apache.pdfbox.pdmodel.graphics.PDXObject;
 import org.apache.pdfbox.pdmodel.graphics.image.PDInlineImage;
+import org.apache.pdfbox.util.Charsets;
 
 /**
- * This class is a convenience for creating page content streams.  You MUST
- * call close() when you are finished with this object.
+ * This class is a convenience for creating page content streams. You MUST call close() when you
+ * are finished with this object.
  *
- * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
+ * @author Ben Litchfield
  * 
  */
 public class PDPageContentStream implements Closeable
 {
-    /**
-     * Log instance.
-     */
     private static final Log LOG = LogFactory.getLog(PDPageContentStream.class);
 
+    private static byte[] toAscii(final String text)
+    {
+        return text.getBytes(Charsets.US_ASCII);
+    }
+
+    private static final byte[] BEGIN_TEXT = toAscii("BT\n");
+    private static final byte[] END_TEXT = toAscii("ET\n");
+    private static final byte[] SET_FONT = toAscii("Tf\n");
+    private static final byte[] MOVE_TEXT_POSITION = toAscii("Td\n");
+    private static final byte[] SET_TEXT_MATRIX = toAscii("Tm\n");
+    private static final byte[] SHOW_TEXT = toAscii("Tj\n");
+
+    private static final byte[] SAVE_GRAPHICS_STATE = toAscii("q\n");
+    private static final byte[] RESTORE_GRAPHICS_STATE = toAscii("Q\n");
+    private static final byte[] CONCATENATE_MATRIX = toAscii("cm\n");
+    private static final byte[] XOBJECT_DO = toAscii("Do\n");
+    private static final byte[] RG_STROKING = toAscii("RG\n");
+    private static final byte[] RG_NON_STROKING = toAscii("rg\n");
+    private static final byte[] K_STROKING = toAscii("K\n");
+    private static final byte[] K_NON_STROKING = toAscii("k\n");
+    private static final byte[] G_STROKING = toAscii("G\n");
+    private static final byte[] G_NON_STROKING = toAscii("g\n");
+    private static final byte[] RECTANGLE = toAscii("re\n");
+    private static final byte[] FILL_NON_ZERO = toAscii("f\n");
+    private static final byte[] FILL_EVEN_ODD = toAscii("f*\n");
+    private static final byte[] LINE_TO = toAscii("l\n");
+    private static final byte[] MOVE_TO = toAscii("m\n");
+    private static final byte[] CLOSE_STROKE = toAscii("s\n");
+    private static final byte[] STROKE = toAscii("S\n");
+    private static final byte[] LINE_WIDTH = toAscii("w\n");
+    private static final byte[] LINE_JOIN_STYLE = toAscii("j\n");
+    private static final byte[] LINE_CAP_STYLE = toAscii("J\n");
+    private static final byte[] LINE_DASH_PATTERN = toAscii("d\n");
+    private static final byte[] CLOSE_SUBPATH = toAscii("h\n");
+    private static final byte[] CLIP_PATH_NON_ZERO = toAscii("W\n");
+    private static final byte[] CLIP_PATH_EVEN_ODD = toAscii("W*\n");
+    private static final byte[] NOP = toAscii("n\n");
+    private static final byte[] BEZIER_312 = toAscii("c\n");
+    private static final byte[] BEZIER_32 = toAscii("v\n");
+    private static final byte[] BEZIER_313 = toAscii("y\n");
+
+    private static final byte[] BMC = toAscii("BMC\n");
+    private static final byte[] BDC = toAscii("BDC\n");
+    private static final byte[] EMC = toAscii("EMC\n");
+
+    private static final byte[] SET_STROKING_COLORSPACE = toAscii("CS\n");
+    private static final byte[] SET_NON_STROKING_COLORSPACE = toAscii("cs\n");
+
+    private static final byte[] SET_STROKING_COLOR_SIMPLE = toAscii("SC\n");
+    private static final byte[] SET_STROKING_COLOR_COMPLEX = toAscii("SCN\n");
+    private static final byte[] SET_NON_STROKING_COLOR_SIMPLE = toAscii("sc\n");
+    private static final byte[] SET_NON_STROKING_COLOR_COMPLEX = toAscii("scn\n");
+
+    private static final byte[] OPENING_BRACKET = toAscii("[");
+    private static final byte[] CLOSING_BRACKET = toAscii("]");
+    private static final byte[] NEWLINE = toAscii("\n");
+
+    private static final int SPACE = 32;
+
+    // instance variables
     private OutputStream output;
-    private boolean inTextMode = false;
     private PDResources resources;
+    private boolean inTextMode = false;
 
     private PDColorSpace currentStrokingColorSpace = PDDeviceGray.INSTANCE;
     private PDColorSpace currentNonStrokingColorSpace = PDDeviceGray.INSTANCE;
 
     // cached storage component for getting color values
-    private float[] colorComponents = new float[4];
-
-    private NumberFormat formatDecimal = NumberFormat.getNumberInstance(Locale.US);
-
-    private static final String ISO8859 = "ISO-8859-1";
-
-    private static byte[] getISOBytes(final String s)
-    {
-        try
-        {
-            return s.getBytes(ISO8859);
-        }
-        catch (final UnsupportedEncodingException ex)
-        {
-            throw new IllegalStateException(ex);
-        }
-    }
-
-    private static final byte[] BEGIN_TEXT = getISOBytes("BT\n");
-    private static final byte[] END_TEXT = getISOBytes("ET\n");
-    private static final byte[] SET_FONT = getISOBytes("Tf\n");
-    private static final byte[] MOVE_TEXT_POSITION = getISOBytes("Td\n");
-    private static final byte[] SET_TEXT_MATRIX = getISOBytes("Tm\n");
-    private static final byte[] SHOW_TEXT = getISOBytes("Tj\n");
-
-    private static final byte[] SAVE_GRAPHICS_STATE = getISOBytes("q\n");
-    private static final byte[] RESTORE_GRAPHICS_STATE = getISOBytes("Q\n");
-    private static final byte[] CONCATENATE_MATRIX = getISOBytes("cm\n");
-    private static final byte[] XOBJECT_DO = getISOBytes("Do\n");
-    private static final byte[] RG_STROKING = getISOBytes("RG\n");
-    private static final byte[] RG_NON_STROKING = getISOBytes("rg\n");
-    private static final byte[] K_STROKING = getISOBytes("K\n");
-    private static final byte[] K_NON_STROKING = getISOBytes("k\n");
-    private static final byte[] G_STROKING = getISOBytes("G\n");
-    private static final byte[] G_NON_STROKING = getISOBytes("g\n");
-    private static final byte[] RECTANGLE = getISOBytes("re\n");
-    private static final byte[] FILL_NON_ZERO = getISOBytes("f\n");
-    private static final byte[] FILL_EVEN_ODD = getISOBytes("f*\n");
-    private static final byte[] LINE_TO = getISOBytes("l\n");
-    private static final byte[] MOVE_TO = getISOBytes("m\n");
-    private static final byte[] CLOSE_STROKE = getISOBytes("s\n");
-    private static final byte[] STROKE = getISOBytes("S\n");
-    private static final byte[] LINE_WIDTH = getISOBytes("w\n");
-    private static final byte[] LINE_JOIN_STYLE = getISOBytes("j\n");
-    private static final byte[] LINE_CAP_STYLE = getISOBytes("J\n");
-    private static final byte[] LINE_DASH_PATTERN = getISOBytes("d\n");
-    private static final byte[] CLOSE_SUBPATH = getISOBytes("h\n");
-    private static final byte[] CLIP_PATH_NON_ZERO = getISOBytes("W\n");
-    private static final byte[] CLIP_PATH_EVEN_ODD = getISOBytes("W*\n");
-    private static final byte[] NOP = getISOBytes("n\n");
-    private static final byte[] BEZIER_312 = getISOBytes("c\n");
-    private static final byte[] BEZIER_32 = getISOBytes("v\n");
-    private static final byte[] BEZIER_313 = getISOBytes("y\n");
-
-    private static final byte[] BMC = getISOBytes("BMC\n");
-    private static final byte[] BDC = getISOBytes("BDC\n");
-    private static final byte[] EMC = getISOBytes("EMC\n");
-
-    private static final byte[] SET_STROKING_COLORSPACE = getISOBytes("CS\n");
-    private static final byte[] SET_NON_STROKING_COLORSPACE = getISOBytes("cs\n");
-
-    private static final byte[] SET_STROKING_COLOR_SIMPLE = getISOBytes("SC\n");
-    private static final byte[] SET_STROKING_COLOR_COMPLEX = getISOBytes("SCN\n");
-    private static final byte[] SET_NON_STROKING_COLOR_SIMPLE = getISOBytes("sc\n");
-    private static final byte[] SET_NON_STROKING_COLOR_COMPLEX = getISOBytes("scn\n");
-
-    private static final byte[] OPENING_BRACKET = getISOBytes("[");
-    private static final byte[] CLOSING_BRACKET = getISOBytes("]");
-    private static final byte[] NEWLINE = getISOBytes("\n");
+    private final float[] colorComponents = new float[4];
 
-    private static final int SPACE = 32;
+    // number format
+    private final NumberFormat formatDecimal = NumberFormat.getNumberInstance(Locale.US);
 
     /**
      * Create a new PDPage content stream.
@@ -631,10 +621,7 @@ public class PDPageContentStream implements Closeable
         {
             throw new IOException("Error: must call beginText() before drawString");
         }
-        COSString string = new COSString(text);
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        string.writePDF(buffer);
-        appendRawCommands(buffer.toByteArray());
+        COSWriter.writeString(text.getBytes(Charset.forName("ISO-8859-1")), output); // todo: use font's encoding
         appendRawCommands(SPACE);
         appendRawCommands(SHOW_TEXT);
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/PDEncryption.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/PDEncryption.java
index e940ec4e20..f64510fee0 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/PDEncryption.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/PDEncryption.java
@@ -258,9 +258,7 @@ public class PDEncryption
      */
     public void setOwnerKey(byte[] o) throws IOException
     {
-        COSString owner = new COSString();
-        owner.append( o );
-        dictionary.setItem(COSName.O, owner);
+        dictionary.setItem(COSName.O, new COSString(o));
     }
 
     /**
@@ -290,9 +288,7 @@ public class PDEncryption
      */
     public void setUserKey(byte[] u) throws IOException
     {
-        COSString user = new COSString();
-        user.append( u );
-        dictionary.setItem(COSName.U, user);
+        dictionary.setItem(COSName.U, new COSString(u));
     }
 
     /**
@@ -322,9 +318,7 @@ public class PDEncryption
      */
     public void setOwnerEncryptionKey(byte[] oe) throws IOException
     {
-        COSString ownerEncryptionKey = new COSString();
-        ownerEncryptionKey.append(oe);
-        dictionary.setItem( COSName.OE, ownerEncryptionKey );
+        dictionary.setItem( COSName.OE, new COSString(oe) );
     }
 
     /**
@@ -354,9 +348,7 @@ public class PDEncryption
      */
     public void setUserEncryptionKey(byte[] ue) throws IOException
     {
-        COSString userEncryptionKey = new COSString();
-        userEncryptionKey.append(ue);
-        dictionary.setItem( COSName.UE, userEncryptionKey );
+        dictionary.setItem( COSName.UE, new COSString(ue) );
     }
 
     /**
@@ -427,9 +419,7 @@ public class PDEncryption
         COSArray array = new COSArray();
         for (byte[] recipient : recipients)
         {
-            COSString recip = new COSString();
-            recip.append(recipient);
-            recip.setForceLiteralForm(true);
+            COSString recip = new COSString(recipient);
             array.add(recip);
         }
         dictionary.setItem(COSName.RECIPIENTS, array);
@@ -579,9 +569,7 @@ public class PDEncryption
      */
     public void setPerms(byte[] perms) throws IOException
     {
-        COSString user = new COSString();
-        user.append( perms );
-        dictionary.setItem( COSName.PERMS, user );
+        dictionary.setItem( COSName.PERMS, new COSString(perms) );
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/SecurityHandler.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/SecurityHandler.java
index 915af3d62a..75c7c11a24 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/SecurityHandler.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/SecurityHandler.java
@@ -501,8 +501,7 @@ public abstract class SecurityHandler
         ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());
         ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         encryptData(objNum, genNum, data, buffer, true /* decrypt */);
-        string.reset();
-        string.append(buffer.toByteArray());
+        string.setValue(buffer.toByteArray());
     }
 
     /**
@@ -519,8 +518,7 @@ public abstract class SecurityHandler
         ByteArrayInputStream data = new ByteArrayInputStream(string.getBytes());
         ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         encryptData(objNum, genNum, data, buffer, false /* decrypt */);
-        string.reset();
-        string.append(buffer.toByteArray());
+        string.setValue(buffer.toByteArray());
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java
index 3540600540..1cec36454c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java
@@ -474,8 +474,7 @@ public final class StandardSecurityHandler extends SecurityHandler
                 md.update( document.getDocument().toString().getBytes() );
 
                 byte[] id = md.digest( this.toString().getBytes("ISO-8859-1") );
-                COSString idString = new COSString();
-                idString.append( id );
+                COSString idString = new COSString(id);
 
                 idArray = new COSArray();
                 idArray.add( idString );
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/fdf/FDFDictionary.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/fdf/FDFDictionary.java
index 3e47a21e4e..08d0a23bf3 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/fdf/FDFDictionary.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/fdf/FDFDictionary.java
@@ -91,8 +91,8 @@ public class FDFDictionary implements COSObjectable
                     COSArray ids = new COSArray();
                     String original = child.getAttribute( "original" );
                     String modified = child.getAttribute( "modified" );
-                    ids.add( COSString.createFromHexString( original ) );
-                    ids.add( COSString.createFromHexString( modified ) );
+                    ids.add( COSString.parseHex( original ) );
+                    ids.add( COSString.parseHex( modified ) );
                     setID( ids );
                 }
                 else if( child.getTagName().equals( "fields" ) )
@@ -157,8 +157,8 @@ public class FDFDictionary implements COSObjectable
         {
             COSString original = (COSString)ids.getObject( 0 );
             COSString modified = (COSString)ids.getObject( 1 );
-            output.write( "<ids original=\"" + original.getHexString() + "\" " );
-            output.write( "modified=\"" + modified.getHexString() + "\" />\n");
+            output.write( "<ids original=\"" + original.toHexString() + "\" " );
+            output.write( "modified=\"" + modified.toHexString() + "\" />\n");
         }
         List<FDFField> fields = getFields();
         if( fields != null && fields.size() > 0 )
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature.java
index de50029380..59429c0930 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/digitalsignature/PDSignature.java
@@ -358,7 +358,7 @@ public class PDSignature implements COSObjectable
         }
         fis.close();
 
-        return COSString.createFromHexString(byteOS.toString()).getBytes();
+        return COSString.parseHex(byteOS.toString()).getBytes();
     }
 
     /**
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/documentnavigation/destination/PDNamedDestination.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/documentnavigation/destination/PDNamedDestination.java
index c6b1633a3e..f2c141d591 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/documentnavigation/destination/PDNamedDestination.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/documentnavigation/destination/PDNamedDestination.java
@@ -109,13 +109,7 @@ public class PDNamedDestination extends PDDestination
      */
     public void setNamedDestination( String dest ) throws IOException
     {
-        if( namedDestination instanceof COSString )
-        {
-            COSString string = ((COSString)namedDestination);
-            string.reset();
-            string.append( dest.getBytes("ISO-8859-1") );
-        }
-        else if( dest == null )
+        if (dest == null)
         {
             namedDestination = null;
         }
@@ -124,5 +118,4 @@ public class PDNamedDestination extends PDDestination
             namedDestination = new COSString( dest );
         }
     }
-
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/form/PDAppearanceString.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/form/PDAppearanceString.java
index b2d5ba041e..97f92b6ba8 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/form/PDAppearanceString.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/interactive/form/PDAppearanceString.java
@@ -21,6 +21,7 @@ import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.io.PrintWriter;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -35,6 +36,7 @@ import org.apache.pdfbox.cos.COSNumber;
 import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.cos.COSString;
 import org.apache.pdfbox.pdfparser.PDFStreamParser;
+import org.apache.pdfbox.pdfwriter.COSWriter;
 import org.apache.pdfbox.pdfwriter.ContentStreamWriter;
 import org.apache.pdfbox.pdmodel.PDResources;
 import org.apache.pdfbox.pdmodel.common.COSObjectable;
@@ -58,7 +60,6 @@ import org.apache.pdfbox.contentstream.operator.Operator;
  */
 public final class PDAppearanceString
 {
-
     private static final Log LOG = LogFactory.getLog(PDAppearanceString.class);
 
     private final PDVariableText parent;
@@ -311,7 +312,7 @@ public final class PDAppearanceString
     }
 
     private void insertGeneratedAppearance(PDAnnotationWidget fieldWidget, OutputStream output,
-            PDFont pdFont, List<Object> tokens, PDAppearanceStream appearanceStream)
+            PDFont font, List<Object> tokens, PDAppearanceStream appearanceStream)
             throws IOException
     {
         PrintWriter printWriter = new PrintWriter(output, true);
@@ -329,7 +330,7 @@ public final class PDAppearanceString
                     daString.getBytes("ISO-8859-1")));
             daParser.parse();
             List<Object> daTokens = daParser.getTokens();
-            fontSize = calculateFontSize(pdFont, boundingBox, tokens, daTokens);
+            fontSize = calculateFontSize(font, boundingBox, tokens, daTokens);
             int fontIndex = daTokens.indexOf(Operator.getOperator("Tf"));
             if (fontIndex != -1)
             {
@@ -347,7 +348,7 @@ public final class PDAppearanceString
         float paddingLeft = Math.max(2, Math.round(4 * borderEdge.getLowerLeftX()));
         float paddingRight = Math.max(2,
                 Math.round(4 * (boundingBox.getUpperRightX() - borderEdge.getUpperRightX())));
-        float verticalOffset = getVerticalOffset(boundingBox, pdFont, fontSize, tokens);
+        float verticalOffset = getVerticalOffset(boundingBox, font, fontSize, tokens);
 
         // Acrobat shifts the value so it aligns to the bottom if
         // the font's caps are larger than the height of the borderEdge
@@ -359,14 +360,14 @@ public final class PDAppearanceString
 
         if (fontHeight + 2 * borderEdge.getLowerLeftX() > borderEdge.getHeight())
         {
-            verticalOffset = pdFont.getBoundingBox().getHeight() / 1000 * fontSize
+            verticalOffset = font.getBoundingBox().getHeight() / 1000 * fontSize
                     - borderEdge.getHeight();
         }
 
         float leftOffset = 0f;
 
         // Acrobat aligns left regardless of the quadding if the text is wider than the remaining width
-        float stringWidth = (pdFont.getStringWidth(value) / 1000) * fontSize;
+        float stringWidth = (font.getStringWidth(value) / 1000) * fontSize;
         int q = getQ();
         if (q == PDTextField.QUADDING_LEFT
                 || stringWidth > borderEdge.getWidth() - paddingLeft - paddingRight)
@@ -390,20 +391,25 @@ public final class PDAppearanceString
 
         printWriter.println(leftOffset + " " + verticalOffset + " Td");
 
-        // add the value as hex string to deal with non ISO-8859-1 data values
+        // show the text
         if (!isMultiLineValue(value) || stringWidth > borderEdge.getWidth() - paddingLeft -
                 paddingRight)
         {
-            printWriter.println("<" + new COSString(value).getHexString() + "> Tj");
+            printWriter.print("<");
+            printWriter.flush();
+            COSWriter.writeString(value.getBytes(Charset.forName("ISO-8859-1")), output); // todo: use font's encoding
+            printWriter.println("> Tj");
         }
         else
         {
             String[] paragraphs = value.split("\n");
             for (int i = 0; i < paragraphs.length; i++)
             {
-                boolean lastLine = i == (paragraphs.length - 1);
-                String endingTag = lastLine ? "> Tj\n" : "> Tj 0 -13 Td";
-                printWriter.print("<" + new COSString(paragraphs[i]).getHexString() + endingTag);
+                boolean lastLine = i == paragraphs.length - 1;
+                printWriter.print("<");
+                printWriter.flush();
+                COSWriter.writeString(value.getBytes(Charset.forName("ISO-8859-1")), output); // todo: use font's encoding
+                printWriter.println(lastLine ? "> Tj\n" : "> Tj 0 -13 Td");
             }
         }
         printWriter.println("ET");
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/persistence/util/COSHEXTable.java b/pdfbox/src/main/java/org/apache/pdfbox/persistence/util/COSHEXTable.java
deleted file mode 100644
index 49f40dc5ea..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/persistence/util/COSHEXTable.java
+++ /dev/null
@@ -1,557 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.persistence.util;
-
-import org.apache.pdfbox.util.StringUtil;
-
-/**
- * helper type for faster mapping of bytes to their hex equivalent.
- *
- * @author Michael Traut
- * @version $Revision: 1.4 $
- */
-public final class COSHEXTable
-{
-    private COSHEXTable()
-    {
-    }
-    /**
-     * ASCII byte values for the hex strings.
-     */
-    public static final byte[][] TABLE =
-        {
-            StringUtil.getBytes("00"),
-            StringUtil.getBytes("01"),
-            StringUtil.getBytes("02"),
-            StringUtil.getBytes("03"),
-            StringUtil.getBytes("04"),
-            StringUtil.getBytes("05"),
-            StringUtil.getBytes("06"),
-            StringUtil.getBytes("07"),
-            StringUtil.getBytes("08"),
-            StringUtil.getBytes("09"),
-            StringUtil.getBytes("0A"),
-            StringUtil.getBytes("0B"),
-            StringUtil.getBytes("0C"),
-            StringUtil.getBytes("0D"),
-            StringUtil.getBytes("0E"),
-            StringUtil.getBytes("0F"),
-            StringUtil.getBytes("10"),
-            StringUtil.getBytes("11"),
-            StringUtil.getBytes("12"),
-            StringUtil.getBytes("13"),
-            StringUtil.getBytes("14"),
-            StringUtil.getBytes("15"),
-            StringUtil.getBytes("16"),
-            StringUtil.getBytes("17"),
-            StringUtil.getBytes("18"),
-            StringUtil.getBytes("19"),
-            StringUtil.getBytes("1A"),
-            StringUtil.getBytes("1B"),
-            StringUtil.getBytes("1C"),
-            StringUtil.getBytes("1D"),
-            StringUtil.getBytes("1E"),
-            StringUtil.getBytes("1F"),
-            StringUtil.getBytes("20"),
-            StringUtil.getBytes("21"),
-            StringUtil.getBytes("22"),
-            StringUtil.getBytes("23"),
-            StringUtil.getBytes("24"),
-            StringUtil.getBytes("25"),
-            StringUtil.getBytes("26"),
-            StringUtil.getBytes("27"),
-            StringUtil.getBytes("28"),
-            StringUtil.getBytes("29"),
-            StringUtil.getBytes("2A"),
-            StringUtil.getBytes("2B"),
-            StringUtil.getBytes("2C"),
-            StringUtil.getBytes("2D"),
-            StringUtil.getBytes("2E"),
-            StringUtil.getBytes("2F"),
-            StringUtil.getBytes("30"),
-            StringUtil.getBytes("31"),
-            StringUtil.getBytes("32"),
-            StringUtil.getBytes("33"),
-            StringUtil.getBytes("34"),
-            StringUtil.getBytes("35"),
-            StringUtil.getBytes("36"),
-            StringUtil.getBytes("37"),
-            StringUtil.getBytes("38"),
-            StringUtil.getBytes("39"),
-            StringUtil.getBytes("3A"),
-            StringUtil.getBytes("3B"),
-            StringUtil.getBytes("3C"),
-            StringUtil.getBytes("3D"),
-            StringUtil.getBytes("3E"),
-            StringUtil.getBytes("3F"),
-            StringUtil.getBytes("40"),
-            StringUtil.getBytes("41"),
-            StringUtil.getBytes("42"),
-            StringUtil.getBytes("43"),
-            StringUtil.getBytes("44"),
-            StringUtil.getBytes("45"),
-            StringUtil.getBytes("46"),
-            StringUtil.getBytes("47"),
-            StringUtil.getBytes("48"),
-            StringUtil.getBytes("49"),
-            StringUtil.getBytes("4A"),
-            StringUtil.getBytes("4B"),
-            StringUtil.getBytes("4C"),
-            StringUtil.getBytes("4D"),
-            StringUtil.getBytes("4E"),
-            StringUtil.getBytes("4F"),
-            StringUtil.getBytes("50"),
-            StringUtil.getBytes("51"),
-            StringUtil.getBytes("52"),
-            StringUtil.getBytes("53"),
-            StringUtil.getBytes("54"),
-            StringUtil.getBytes("55"),
-            StringUtil.getBytes("56"),
-            StringUtil.getBytes("57"),
-            StringUtil.getBytes("58"),
-            StringUtil.getBytes("59"),
-            StringUtil.getBytes("5A"),
-            StringUtil.getBytes("5B"),
-            StringUtil.getBytes("5C"),
-            StringUtil.getBytes("5D"),
-            StringUtil.getBytes("5E"),
-            StringUtil.getBytes("5F"),
-            StringUtil.getBytes("60"),
-            StringUtil.getBytes("61"),
-            StringUtil.getBytes("62"),
-            StringUtil.getBytes("63"),
-            StringUtil.getBytes("64"),
-            StringUtil.getBytes("65"),
-            StringUtil.getBytes("66"),
-            StringUtil.getBytes("67"),
-            StringUtil.getBytes("68"),
-            StringUtil.getBytes("69"),
-            StringUtil.getBytes("6A"),
-            StringUtil.getBytes("6B"),
-            StringUtil.getBytes("6C"),
-            StringUtil.getBytes("6D"),
-            StringUtil.getBytes("6E"),
-            StringUtil.getBytes("6F"),
-            StringUtil.getBytes("70"),
-            StringUtil.getBytes("71"),
-            StringUtil.getBytes("72"),
-            StringUtil.getBytes("73"),
-            StringUtil.getBytes("74"),
-            StringUtil.getBytes("75"),
-            StringUtil.getBytes("76"),
-            StringUtil.getBytes("77"),
-            StringUtil.getBytes("78"),
-            StringUtil.getBytes("79"),
-            StringUtil.getBytes("7A"),
-            StringUtil.getBytes("7B"),
-            StringUtil.getBytes("7C"),
-            StringUtil.getBytes("7D"),
-            StringUtil.getBytes("7E"),
-            StringUtil.getBytes("7F"),
-            StringUtil.getBytes("80"),
-            StringUtil.getBytes("81"),
-            StringUtil.getBytes("82"),
-            StringUtil.getBytes("83"),
-            StringUtil.getBytes("84"),
-            StringUtil.getBytes("85"),
-            StringUtil.getBytes("86"),
-            StringUtil.getBytes("87"),
-            StringUtil.getBytes("88"),
-            StringUtil.getBytes("89"),
-            StringUtil.getBytes("8A"),
-            StringUtil.getBytes("8B"),
-            StringUtil.getBytes("8C"),
-            StringUtil.getBytes("8D"),
-            StringUtil.getBytes("8E"),
-            StringUtil.getBytes("8F"),
-            StringUtil.getBytes("90"),
-            StringUtil.getBytes("91"),
-            StringUtil.getBytes("92"),
-            StringUtil.getBytes("93"),
-            StringUtil.getBytes("94"),
-            StringUtil.getBytes("95"),
-            StringUtil.getBytes("96"),
-            StringUtil.getBytes("97"),
-            StringUtil.getBytes("98"),
-            StringUtil.getBytes("99"),
-            StringUtil.getBytes("9A"),
-            StringUtil.getBytes("9B"),
-            StringUtil.getBytes("9C"),
-            StringUtil.getBytes("9D"),
-            StringUtil.getBytes("9E"),
-            StringUtil.getBytes("9F"),
-            StringUtil.getBytes("A0"),
-            StringUtil.getBytes("A1"),
-            StringUtil.getBytes("A2"),
-            StringUtil.getBytes("A3"),
-            StringUtil.getBytes("A4"),
-            StringUtil.getBytes("A5"),
-            StringUtil.getBytes("A6"),
-            StringUtil.getBytes("A7"),
-            StringUtil.getBytes("A8"),
-            StringUtil.getBytes("A9"),
-            StringUtil.getBytes("AA"),
-            StringUtil.getBytes("AB"),
-            StringUtil.getBytes("AC"),
-            StringUtil.getBytes("AD"),
-            StringUtil.getBytes("AE"),
-            StringUtil.getBytes("AF"),
-            StringUtil.getBytes("B0"),
-            StringUtil.getBytes("B1"),
-            StringUtil.getBytes("B2"),
-            StringUtil.getBytes("B3"),
-            StringUtil.getBytes("B4"),
-            StringUtil.getBytes("B5"),
-            StringUtil.getBytes("B6"),
-            StringUtil.getBytes("B7"),
-            StringUtil.getBytes("B8"),
-            StringUtil.getBytes("B9"),
-            StringUtil.getBytes("BA"),
-            StringUtil.getBytes("BB"),
-            StringUtil.getBytes("BC"),
-            StringUtil.getBytes("BD"),
-            StringUtil.getBytes("BE"),
-            StringUtil.getBytes("BF"),
-            StringUtil.getBytes("C0"),
-            StringUtil.getBytes("C1"),
-            StringUtil.getBytes("C2"),
-            StringUtil.getBytes("C3"),
-            StringUtil.getBytes("C4"),
-            StringUtil.getBytes("C5"),
-            StringUtil.getBytes("C6"),
-            StringUtil.getBytes("C7"),
-            StringUtil.getBytes("C8"),
-            StringUtil.getBytes("C9"),
-            StringUtil.getBytes("CA"),
-            StringUtil.getBytes("CB"),
-            StringUtil.getBytes("CC"),
-            StringUtil.getBytes("CD"),
-            StringUtil.getBytes("CE"),
-            StringUtil.getBytes("CF"),
-            StringUtil.getBytes("D0"),
-            StringUtil.getBytes("D1"),
-            StringUtil.getBytes("D2"),
-            StringUtil.getBytes("D3"),
-            StringUtil.getBytes("D4"),
-            StringUtil.getBytes("D5"),
-            StringUtil.getBytes("D6"),
-            StringUtil.getBytes("D7"),
-            StringUtil.getBytes("D8"),
-            StringUtil.getBytes("D9"),
-            StringUtil.getBytes("DA"),
-            StringUtil.getBytes("DB"),
-            StringUtil.getBytes("DC"),
-            StringUtil.getBytes("DD"),
-            StringUtil.getBytes("DE"),
-            StringUtil.getBytes("DF"),
-            StringUtil.getBytes("E0"),
-            StringUtil.getBytes("E1"),
-            StringUtil.getBytes("E2"),
-            StringUtil.getBytes("E3"),
-            StringUtil.getBytes("E4"),
-            StringUtil.getBytes("E5"),
-            StringUtil.getBytes("E6"),
-            StringUtil.getBytes("E7"),
-            StringUtil.getBytes("E8"),
-            StringUtil.getBytes("E9"),
-            StringUtil.getBytes("EA"),
-            StringUtil.getBytes("EB"),
-            StringUtil.getBytes("EC"),
-            StringUtil.getBytes("ED"),
-            StringUtil.getBytes("EE"),
-            StringUtil.getBytes("EF"),
-            StringUtil.getBytes("F0"),
-            StringUtil.getBytes("F1"),
-            StringUtil.getBytes("F2"),
-            StringUtil.getBytes("F3"),
-            StringUtil.getBytes("F4"),
-            StringUtil.getBytes("F5"),
-            StringUtil.getBytes("F6"),
-            StringUtil.getBytes("F7"),
-            StringUtil.getBytes("F8"),
-            StringUtil.getBytes("F9"),
-            StringUtil.getBytes("FA"),
-            StringUtil.getBytes("FB"),
-            StringUtil.getBytes("FC"),
-            StringUtil.getBytes("FD"),
-            StringUtil.getBytes("FE"),
-            StringUtil.getBytes("FF")
-            };
-
-    /**
-     * ASCII byte values for the hex strings.
-     */
-    public static final String[] HEX_TABLE =
-        {
-            "00",
-            "01",
-            "02",
-            "03",
-            "04",
-            "05",
-            "06",
-            "07",
-            "08",
-            "09",
-            "0A",
-            "0B",
-            "0C",
-            "0D",
-            "0E",
-            "0F",
-            "10",
-            "11",
-            "12",
-            "13",
-            "14",
-            "15",
-            "16",
-            "17",
-            "18",
-            "19",
-            "1A",
-            "1B",
-            "1C",
-            "1D",
-            "1E",
-            "1F",
-            "20",
-            "21",
-            "22",
-            "23",
-            "24",
-            "25",
-            "26",
-            "27",
-            "28",
-            "29",
-            "2A",
-            "2B",
-            "2C",
-            "2D",
-            "2E",
-            "2F",
-            "30",
-            "31",
-            "32",
-            "33",
-            "34",
-            "35",
-            "36",
-            "37",
-            "38",
-            "39",
-            "3A",
-            "3B",
-            "3C",
-            "3D",
-            "3E",
-            "3F",
-            "40",
-            "41",
-            "42",
-            "43",
-            "44",
-            "45",
-            "46",
-            "47",
-            "48",
-            "49",
-            "4A",
-            "4B",
-            "4C",
-            "4D",
-            "4E",
-            "4F",
-            "50",
-            "51",
-            "52",
-            "53",
-            "54",
-            "55",
-            "56",
-            "57",
-            "58",
-            "59",
-            "5A",
-            "5B",
-            "5C",
-            "5D",
-            "5E",
-            "5F",
-            "60",
-            "61",
-            "62",
-            "63",
-            "64",
-            "65",
-            "66",
-            "67",
-            "68",
-            "69",
-            "6A",
-            "6B",
-            "6C",
-            "6D",
-            "6E",
-            "6F",
-            "70",
-            "71",
-            "72",
-            "73",
-            "74",
-            "75",
-            "76",
-            "77",
-            "78",
-            "79",
-            "7A",
-            "7B",
-            "7C",
-            "7D",
-            "7E",
-            "7F",
-            "80",
-            "81",
-            "82",
-            "83",
-            "84",
-            "85",
-            "86",
-            "87",
-            "88",
-            "89",
-            "8A",
-            "8B",
-            "8C",
-            "8D",
-            "8E",
-            "8F",
-            "90",
-            "91",
-            "92",
-            "93",
-            "94",
-            "95",
-            "96",
-            "97",
-            "98",
-            "99",
-            "9A",
-            "9B",
-            "9C",
-            "9D",
-            "9E",
-            "9F",
-            "A0",
-            "A1",
-            "A2",
-            "A3",
-            "A4",
-            "A5",
-            "A6",
-            "A7",
-            "A8",
-            "A9",
-            "AA",
-            "AB",
-            "AC",
-            "AD",
-            "AE",
-            "AF",
-            "B0",
-            "B1",
-            "B2",
-            "B3",
-            "B4",
-            "B5",
-            "B6",
-            "B7",
-            "B8",
-            "B9",
-            "BA",
-            "BB",
-            "BC",
-            "BD",
-            "BE",
-            "BF",
-            "C0",
-            "C1",
-            "C2",
-            "C3",
-            "C4",
-            "C5",
-            "C6",
-            "C7",
-            "C8",
-            "C9",
-            "CA",
-            "CB",
-            "CC",
-            "CD",
-            "CE",
-            "CF",
-            "D0",
-            "D1",
-            "D2",
-            "D3",
-            "D4",
-            "D5",
-            "D6",
-            "D7",
-            "D8",
-            "D9",
-            "DA",
-            "DB",
-            "DC",
-            "DD",
-            "DE",
-            "DF",
-            "E0",
-            "E1",
-            "E2",
-            "E3",
-            "E4",
-            "E5",
-            "E6",
-            "E7",
-            "E8",
-            "E9",
-            "EA",
-            "EB",
-            "EC",
-            "ED",
-            "EE",
-            "EF",
-            "F0",
-            "F1",
-            "F2",
-            "F3",
-            "F4",
-            "F5",
-            "F6",
-            "F7",
-            "F8",
-            "F9",
-            "FA",
-            "FB",
-            "FC",
-            "FD",
-            "FE",
-            "FF"
-            };
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/Charsets.java b/pdfbox/src/main/java/org/apache/pdfbox/util/Charsets.java
new file mode 100644
index 0000000000..18b239484e
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/Charsets.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pdfbox.util;
+
+import java.nio.charset.Charset;
+
+/**
+ * Utility class providing common Charsets used in PDF.
+ *
+ * @author John Hewson
+ */
+public class Charsets
+{
+    private Charsets() {}
+
+    /*** ASCII charset */
+    public static final Charset US_ASCII = Charset.forName("US-ASCII");
+
+    /*** UTF-16BE charset */
+    public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
+
+    /*** UTF-16LE charset */
+    public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/util/StringUtil.java b/pdfbox/src/main/java/org/apache/pdfbox/util/Hex.java
similarity index 63%
rename from pdfbox/src/main/java/org/apache/pdfbox/util/StringUtil.java
rename to pdfbox/src/main/java/org/apache/pdfbox/util/Hex.java
index a781c56caa..020f26d074 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/util/StringUtil.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/util/Hex.java
@@ -14,26 +14,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.pdfbox.util;
 
-import java.io.UnsupportedEncodingException;
+package org.apache.pdfbox.util;
 
-public class StringUtil
+/**
+ * Utility functions for hex encoding.
+ *
+ * @author John Hewson
+ */
+public class Hex
 {
+    private Hex() {}
+
+    /**
+     * Returns a hex string of the given byte.
+     */
+    public static String getString(byte b)
+    {
+        return Integer.toHexString(0x100 | b & 0xff).substring(1).toUpperCase();
+    }
+
     /**
-     * Converts a string to it ISO-8859-1 byte sequence
-     *
-     * It is an workaround for variable initialisations outside of functions.
-     */ 
-    public static byte[] getBytes(String s)
+     * Returns the bytes corresponding to the ASCII hex encoding of the given byte.
+     */
+    public static byte[] getBytes(byte b)
     {
-        try
-            {
-                return s.getBytes("ISO-8859-1");
-            }
-        catch(UnsupportedEncodingException e)
-            {
-                throw new RuntimeException("Unsupported Encoding", e);
-            }
+        return getString(b).getBytes(Charsets.US_ASCII);
     }
 }
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java b/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
index 0e02b944bd..a9374c2bfe 100644
--- a/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
+++ b/pdfbox/src/test/java/org/apache/pdfbox/cos/TestCOSString.java
@@ -65,44 +65,6 @@ public class TestCOSString extends TestCOSBase
         junit.textui.TestRunner.main(arg);
     }
 
-    /**
-     * Tests the public static members within the class that are purely PDF format string objects 
-     * like open/closing strings, escape characters etc...
-     */
-    public void testStaticMembers()
-    {
-        stringByteArrayComparison("(", COSString.STRING_OPEN);
-        stringByteArrayComparison(")", COSString.STRING_CLOSE);
-        stringByteArrayComparison("<", COSString.HEX_STRING_OPEN);
-        stringByteArrayComparison(">", COSString.HEX_STRING_CLOSE);
-        stringByteArrayComparison("\\", COSString.ESCAPE);
-        stringByteArrayComparison("\\r", COSString.CR_ESCAPE);
-        stringByteArrayComparison("\\n", COSString.LF_ESCAPE);
-        stringByteArrayComparison("\\t", COSString.HT_ESCAPE);
-        stringByteArrayComparison("\\b", COSString.BS_ESCAPE);
-        stringByteArrayComparison("\\f", COSString.FF_ESCAPE);
-    }
-
-    /**
-     * Helper method for comparing a string to it's PDF byte array.
-     * 
-     * @param expected the String expected
-     * @param member the byte array being tested
-     */
-    private void stringByteArrayComparison(String expected, byte[] member)
-    {
-        byte[] expectedBytes = null;
-        try
-        {
-            expectedBytes = expected.getBytes("ISO-8859-1");
-        }
-        catch (UnsupportedEncodingException e)
-        {
-            fail("ISO-8859-1 encoding threw an exception: " + e.getMessage());
-        }
-        testByteArrays(expectedBytes, member);
-    }
-
     /**
      * Test setForceHexForm() and setForceLiteralForm() - tests these two methods do enforce the
      * different String output forms within PDF. 
@@ -110,15 +72,10 @@ public class TestCOSString extends TestCOSBase
     public void testSetForceHexLiteralForm()
     {
         String inputString = "Test with a text and a few numbers 1, 2 and 3";
-        String pdfLiteral = "(" + inputString + ")";
         String pdfHex = "<" + createHex(inputString) + ">";
         COSString cosStr = new COSString(inputString);
-        cosStr.setForceLiteralForm(true);
-        writePDFTests(pdfLiteral, cosStr);
         cosStr.setForceHexForm(true);
         writePDFTests(pdfHex, cosStr);
-        cosStr.setForceLiteralForm(true);
-        writePDFTests(pdfLiteral, cosStr);
 
         COSString escStr = new COSString(ESC_CHAR_STRING);
         writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", escStr);
@@ -138,7 +95,7 @@ public class TestCOSString extends TestCOSBase
         ByteArrayOutputStream outStream = new ByteArrayOutputStream();
         try
         {
-            testSubj.writePDF(outStream);
+            COSWriter.writeString(testSubj, outStream);
         }
         catch (IOException e)
         {
@@ -148,20 +105,18 @@ public class TestCOSString extends TestCOSBase
     }
 
     /**
-     * Test createFromHexString() - tests that the proper String is created from a hex string input.
+     * Test parseHex() - tests that the proper String is created from a hex string input.
      */
-    public void testCreateFromHexString()
+    public void testFromHex()
     {
         String expected = "Quick and simple test";
         String hexForm = createHex(expected);
         try
         {
-            COSString test1 = COSString.createFromHexString(hexForm);
+            COSString test1 = COSString.parseHex(hexForm);
             writePDFTests("(" + expected + ")", test1);
-            COSString test2 = COSString.createFromHexString(createHex(ESC_CHAR_STRING));
+            COSString test2 = COSString.parseHex(createHex(ESC_CHAR_STRING));
             writePDFTests("(" + ESC_CHAR_STRING_PDF_FORMAT + ")", test2);
-            COSString test3 = COSString.createFromHexString(hexForm + "xx", true);
-            writePDFTests("(" + expected + "?)", test3);
         }
         catch (IOException e)
         {
@@ -169,7 +124,7 @@ public class TestCOSString extends TestCOSBase
         }
         try
         {
-            COSString.createFromHexString(hexForm + "xx", false);
+            COSString.parseHex(hexForm + "xx");
             fail("Should have thrown an IOException here");
         }
         catch (IOException e)
@@ -196,36 +151,25 @@ public class TestCOSString extends TestCOSBase
         String expected = "Test subject for testing getHex";
         COSString test1 = new COSString(expected);
         String hexForm = createHex(expected);
-        assertEquals(hexForm, test1.getHexString());
-        test1.setForceLiteralForm(true);
-        assertEquals(hexForm, test1.getHexString());
+        assertEquals(hexForm, test1.toHexString());
         COSString escCS = new COSString(ESC_CHAR_STRING);
         // Not sure whether the escaped characters should be escaped or not, presumably since 
         // writePDF() gives you the proper formatted text, getHex() should ONLY convert to hex. 
-        assertEquals(createHex(ESC_CHAR_STRING), escCS.getHexString());
+        assertEquals(createHex(ESC_CHAR_STRING), escCS.toHexString());
     }
 
     /**
-     * Test getString() - ensure string are returned in the correct format.
+     * Test testGetString() - ensure getString() are returned in the correct format.
      */
     public void testGetString()
     {
-        COSString nullStr = new COSString();
-        assertEquals("", nullStr.getString());
         try
         {
             String testStr = "Test subject for getString()";
             COSString test1 = new COSString(testStr);
             assertEquals(testStr, test1.getString());
 
-            String appendedStr = "appended text";
-            test1.append(appendedStr.getBytes());
-            assertEquals(testStr + appendedStr, test1.getString());
-
-            test1.append(ESC_CHAR_STRING.getBytes());
-            assertEquals(testStr + appendedStr + ESC_CHAR_STRING, test1.getString());
-
-            COSString hexStr = COSString.createFromHexString(createHex(testStr));
+            COSString hexStr = COSString.parseHex(createHex(testStr));
             assertEquals(testStr, hexStr.getString());
 
             COSString escapedString = new COSString(ESC_CHAR_STRING);
@@ -234,56 +178,6 @@ public class TestCOSString extends TestCOSBase
             testStr = "Line1\nLine2\nLine3\n";
             COSString lineFeedString = new COSString(testStr);
             assertEquals(testStr, lineFeedString.getString());
-
-            //Same as previous but this time it is constructed incrementally (like in a dictionary)
-            lineFeedString = new COSString();
-            for (int i = 0; i < testStr.length(); i++)
-            {
-                lineFeedString.append(testStr.charAt(i));
-            }
-            assertEquals(testStr, lineFeedString.getString());
-
-            testStr = "Text\u2026"; //PDFBOX-1437
-            COSString pdfbox1437 = new COSString();
-            pdfbox1437.append(new byte[] {
-                    0x54, 0x65, 0x78, 0x74, (byte)(0x83 & 0xFF)
-            });
-            assertEquals(testStr, pdfbox1437.getString());
-        }
-        catch (IOException e)
-        {
-            fail("IOException thrown: " + e.getMessage());
-        }
-    }
-
-    /**
-     * Test append(int) and append(byte[]) - test both code paths. 
-     */
-    public void testAppend()
-    {
-        try
-        {
-            // Mostly tested in testGetString()
-            COSString testSubj = new COSString();
-            StringBuilder sb = new StringBuilder();
-            assertEquals(sb.toString(), testSubj.getString());
-            // Arbitrary int but makes it easy to test
-            testSubj.append('a');
-            sb.append("a");
-            assertEquals(sb.toString(), testSubj.getString());
-            testSubj.append(ESC_CHAR_STRING.getBytes());
-            sb.append(ESC_CHAR_STRING);
-            assertEquals(sb.toString(), testSubj.getString());
-            try
-            {
-                testSubj.append(null);
-                assertEquals(sb.toString(), testSubj.getString());
-                fail("NullPointerException not thrown.");
-            }
-            catch (NullPointerException e)
-            {
-                // PASS
-            }
         }
         catch (IOException e)
         {
@@ -291,18 +185,6 @@ public class TestCOSString extends TestCOSBase
         }
     }
 
-    /**
-     * Test reset() - tests that the internal buffer is reset. Not a great deal to test here...
-     */
-    public void testReset()
-    {
-        String str = "This string is going to be reset";
-        COSString testSubj = new COSString(str);
-        assertEquals(str, testSubj.getString());
-        testSubj.reset();
-        assertEquals("", testSubj.getString());
-    }
-
     /**
      * Test getBytes() - again not much to test, just ensure the proper byte array is returned.
      */
@@ -365,11 +247,11 @@ public class TestCOSString extends TestCOSBase
         
         // Test the writePDF method to ensure that the Strings are correct when written into PDF.
         ByteArrayOutputStream out = new ByteArrayOutputStream();
-        stringAscii.writePDF(out);
-        assertEquals("("+textAscii+")", new String(out.toByteArray(), "ASCII"));
+        COSWriter.writeString(stringAscii, out);
+        assertEquals("(" + textAscii + ")", new String(out.toByteArray(), "ASCII"));
         
         out.reset();
-        string8Bit.writePDF(out);
+        COSWriter.writeString(string8Bit, out);
         StringBuffer hex = new StringBuffer();
         for(char c : text8Bit.toCharArray()) {
            hex.append( Integer.toHexString(c).toUpperCase() );
@@ -377,7 +259,7 @@ public class TestCOSString extends TestCOSBase
         assertEquals("<"+hex.toString()+">", new String(out.toByteArray(), "ASCII"));
         
         out.reset();
-        stringHighBits.writePDF(out);
+        COSWriter.writeString(stringHighBits, out);
         hex = new StringBuffer();
         hex.append("FEFF"); // Byte Order Mark
         for(char c : textHighBits.toCharArray()) {
@@ -437,12 +319,6 @@ public class TestCOSString extends TestCOSBase
             assertFalse(y1 == null);
             assertFalse(z1 == null);
             assertFalse(x2 == null);
-
-            // Also check other state
-            COSString y2 = new COSString("Test");
-            y2.setForceLiteralForm(true);
-            assertFalse(y2.equals(x2));
-            assertTrue(y2.equals(x1));
         }
     }
 
@@ -458,8 +334,6 @@ public class TestCOSString extends TestCOSBase
         assertTrue(str1.hashCode() == str3.hashCode());
         str3.setForceHexForm(true);
         assertFalse(str1.hashCode() == str3.hashCode());
-        str3.setForceLiteralForm(true);
-        assertTrue(str1.hashCode() == str3.hashCode());
     }
 
     /**
@@ -468,11 +342,11 @@ public class TestCOSString extends TestCOSBase
      */
     public void testCompareFromHexString() throws IOException
     {
-        COSString test1 = COSString.createFromHexString("000000FF000000");
-        COSString test2 = COSString.createFromHexString("000000FF00FFFF");
+        COSString test1 = COSString.parseHex("000000FF000000");
+        COSString test2 = COSString.parseHex("000000FF00FFFF");
         assertEquals(test1, test1);
         assertEquals(test2, test2);
-        assertFalse(test1.getHexString().equals(test2.getHexString()));
+        assertFalse(test1.toHexString().equals(test2.toHexString()));
         assertFalse(Arrays.equals(test1.getBytes(), test2.getBytes()));
         assertFalse(test1.equals(test2));
         assertFalse(test2.equals(test1));
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java b/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java
deleted file mode 100644
index 6d1ab74178..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/encoding/PDFDocEncodingCharsetTest.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.encoding;
-
-import java.io.UnsupportedEncodingException;
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-
-import junit.framework.TestCase;
-
-/**
- * This class tests {@link PDFDocEncodingCharset} and indirectly {@link SingleByteCharset}.
- * @version $Revision$
- */
-public class PDFDocEncodingCharsetTest extends TestCase
-{
-
-    /**
-     * Tests {@link PDFDocEncodingCharset} and indirectly {@link SingleByteCharset}.
-     * @throws UnsupportedEncodingException if an encoding cannot be found
-     */
-    public void testEncoding() throws UnsupportedEncodingException
-    {
-        //Check basic round-trip
-        String text = "Test \u20AC$ ;-) Gr\u00FCezi\u2026";
-        byte[] encoded = text.getBytes(PDFDocEncodingCharset.INSTANCE);
-        int[] expected = new int[] {
-                0x54, 0x65, 0x73, 0x74, 0x20, //Test
-                0xA0, 0x24, 0xA3, 0x20, //Currency
-                0x3B, 0x2D, 0x29, 0x20, //Smiley
-                0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, //Hello in de_CH
-                0x83 //ellipsis
-        };
-        compareEncoded(encoded, expected);
-        String decoded = new String(encoded, PDFDocEncodingCharset.INSTANCE);
-        assertEquals(text, decoded);
-
-        text = "Bad\u03C0\u2023char";
-        expected = new int[] {
-                0x42, 0x61, 0x64, 0x3F, 0x3F, 0x63, 0x68, 0x61, 0x72 //unencodable characters as '?'
-        };
-        encoded = text.getBytes(PDFDocEncodingCharset.INSTANCE);
-        compareEncoded(encoded, expected);
-        decoded = new String(encoded, PDFDocEncodingCharset.INSTANCE);
-        assertEquals("Bad??char", decoded);
-    }
-
-    /**
-     * Checking for behaviour with undefined character at the end of the buffer.
-     * This used to cause an IllegalArgumentException.
-     */
-    public void testUnencodedAtEnd()
-    {
-        byte[] encoded = new byte[] {0x00, 0x01, 0x02, 0x7F}; //0x7F is undefined
-        String decoded = toString(encoded, 0, encoded.length, PDFDocEncodingCharset.INSTANCE);
-        assertEquals("\u0000\u0001\u0002\uFFFD", decoded);
-    }
-    
-    private static String toString(byte[] data, int offset, int length, Charset charset)
-    {
-        CharBuffer charBuffer = charset.decode(ByteBuffer.wrap(data, offset, length));
-        return charBuffer.toString();
-    }
-    
-    private void compareEncoded(byte[] encoded, int[] expected)
-    {
-        assertEquals(expected.length, encoded.length);
-        for (int i = 0; i < expected.length; i++)
-        {
-            assertEquals("Bad character at pos " + i, (byte)(expected[i] & 0xFF), encoded[i]);
-        }
-    }
-
-}
