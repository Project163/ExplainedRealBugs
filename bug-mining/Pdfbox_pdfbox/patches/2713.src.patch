diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/MemoryUsageSetting.java b/pdfbox/src/main/java/org/apache/pdfbox/io/MemoryUsageSetting.java
deleted file mode 100644
index c96920f9e2..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/MemoryUsageSetting.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import java.io.File;
-
-/**
- * Controls how memory/temporary files are used for
- * buffering streams etc.
- */
-public final class MemoryUsageSetting
-{
-    private final boolean useMainMemory;
-    private final boolean useTempFile;
-    
-    /** maximum number of main-memory bytes allowed to be used;
-     *  <code>-1</code> means 'unrestricted' */
-    private final long maxMainMemoryBytes;
-    
-    /** maximum number of bytes allowed for storage at all (main-memory+file);
-     *  <code>-1</code> means 'unrestricted' */
-    private final long maxStorageBytes;
-    
-    /** directory to be used for scratch file */
-    private File tempDir;
-    
-    /**
-     * Private constructor for setup buffering memory usage called by one of the setup methods.
-     * 
-     * @param useMainMemory if <code>true</code> main memory usage is enabled; in case of
-     *                      <code>false</code> and <code>useTempFile</code> is <code>false</code> too
-     *                      we set this to <code>true</code>
-     * @param useTempFile if <code>true</code> using of temporary file(s) is enabled
-     * @param maxMainMemoryBytes maximum number of main-memory to be used;
-     *                           if <code>-1</code> means 'unrestricted';
-     *                           if <code>0</code> we only use temporary file if <code>useTempFile</code>
-     *                           is <code>true</code> otherwise main-memory usage will have restriction
-     *                           defined by maxStorageBytes
-     * @param maxStorageBytes maximum size the main-memory and temporary file(s) may have all together;
-     *                        <code>0</code>  or less will be ignored; if it is less than
-     *                        maxMainMemoryBytes we use maxMainMemoryBytes value instead 
-     */
-    private MemoryUsageSetting(boolean useMainMemory, boolean useTempFile,
-                        long maxMainMemoryBytes, long maxStorageBytes)
-    {
-        // do some checks; adjust values as needed to get consistent setting
-        boolean locUseMainMemory = !useTempFile || useMainMemory;
-        long    locMaxMainMemoryBytes = useMainMemory ? maxMainMemoryBytes : -1;
-        long    locMaxStorageBytes = maxStorageBytes > 0 ? maxStorageBytes : -1;
-        
-        if (locMaxMainMemoryBytes < -1)
-        {
-            locMaxMainMemoryBytes = -1;
-        }
-        
-        if (locUseMainMemory && (locMaxMainMemoryBytes == 0))
-        {
-            if (useTempFile) {
-                locUseMainMemory = false;
-            }
-            else
-            {
-                locMaxMainMemoryBytes = locMaxStorageBytes;
-            }
-        }
-        
-        if (locUseMainMemory && (locMaxStorageBytes > -1) &&
-            ((locMaxMainMemoryBytes == -1) || (locMaxMainMemoryBytes > locMaxStorageBytes)))
-        {
-            locMaxStorageBytes = locMaxMainMemoryBytes;
-        }
-            
-        
-        this.useMainMemory = locUseMainMemory;
-        this.useTempFile = useTempFile;
-        this.maxMainMemoryBytes = locMaxMainMemoryBytes;
-        this.maxStorageBytes = locMaxStorageBytes;
-    }
-    
-    /**
-     * Setups buffering memory usage to only use main-memory (no temporary file)
-     * which is not restricted in size.
-     */
-    public static MemoryUsageSetting setupMainMemoryOnly()
-    {
-        return setupMainMemoryOnly(-1);
-    }
-
-    /**
-     * Setups buffering memory usage to only use main-memory with the defined maximum.
-     * 
-     * @param maxMainMemoryBytes maximum number of main-memory to be used;
-     *                           <code>-1</code> for no restriction;
-     *                           <code>0</code> will also be interpreted here as no restriction
-     */
-    public static MemoryUsageSetting setupMainMemoryOnly(long maxMainMemoryBytes)
-    {
-        return new MemoryUsageSetting(true, false, maxMainMemoryBytes, maxMainMemoryBytes);
-    }
-
-    /**
-     * Setups buffering memory usage to only use temporary file(s) (no main-memory)
-     * with not restricted size.
-     */
-    public static MemoryUsageSetting setupTempFileOnly()
-    {
-        return setupTempFileOnly(-1);
-    }
-    
-    /**
-     * Setups buffering memory usage to only use temporary file(s) (no main-memory)
-     * with the specified maximum size.
-     * 
-     * @param maxStorageBytes maximum size the temporary file(s) may have all together;
-     *                        <code>-1</code> for no restriction;
-     *                        <code>0</code> will also be interpreted here as no restriction
-     */
-    public static MemoryUsageSetting setupTempFileOnly(long maxStorageBytes)
-    {
-        return new MemoryUsageSetting(false, true, 0, maxStorageBytes);
-    }
-    
-    /**
-     * Setups buffering memory usage to use a portion of main-memory and additionally
-     * temporary file(s) in case the specified portion is exceeded.
-     * 
-     * @param maxMainMemoryBytes maximum number of main-memory to be used;
-     *                           if <code>-1</code> this is the same as {@link #setupMainMemoryOnly()};
-     *                           if <code>0</code> this is the same as {@link #setupTempFileOnly()}
-     */
-    public static MemoryUsageSetting setupMixed(long maxMainMemoryBytes)
-    {
-        return setupMixed(maxMainMemoryBytes, -1);
-    }
-    
-    /**
-     * Setups buffering memory usage to use a portion of main-memory and additionally
-     * temporary file(s) in case the specified portion is exceeded.
-     * 
-     * @param maxMainMemoryBytes maximum number of main-memory to be used;
-     *                           if <code>-1</code> this is the same as {@link #setupMainMemoryOnly()};
-     *                           if <code>0</code> this is the same as {@link #setupTempFileOnly()}
-     * @param maxStorageBytes maximum size the main-memory and temporary file(s) may have all together;
-     *                        <code>0</code>  or less will be ignored; if it is less than
-     *                        maxMainMemoryBytes we use maxMainMemoryBytes value instead 
-     */
-    public static MemoryUsageSetting setupMixed(long maxMainMemoryBytes, long maxStorageBytes)
-    {
-        return new MemoryUsageSetting(true, true, maxMainMemoryBytes, maxStorageBytes);
-    }
-
-    /**
-     * Returns a copy of this instance with the maximum memory/storage restriction
-     * divided by the provided number of parallel uses.
-     * 
-     * @param parallelUseCount specifies the number of parallel usages for the setting to
-     *                         be returned
-     *                         
-     * @return a copy from this instance with the maximum memory/storage restrictions
-     *         adjusted to the multiple usage
-     */
-    public MemoryUsageSetting getPartitionedCopy(int parallelUseCount)
-    {
-        long newMaxMainMemoryBytes = maxMainMemoryBytes <= 0 ? maxMainMemoryBytes : 
-                                                               maxMainMemoryBytes / parallelUseCount;
-        long newMaxStorageBytes = maxStorageBytes <= 0 ? maxStorageBytes :
-                                                         maxStorageBytes / parallelUseCount;
-                
-        MemoryUsageSetting copy = new MemoryUsageSetting( useMainMemory, useTempFile,
-                                                          newMaxMainMemoryBytes, newMaxStorageBytes );
-        copy.tempDir = tempDir;
-        
-        return copy;
-    }
-    
-    /**
-     * Sets directory to be used for temporary files.
-     * 
-     * @param tempDir directory for temporary files
-     * 
-     * @return this instance
-     */
-    public MemoryUsageSetting setTempDir(File tempDir)
-    {
-        this.tempDir = tempDir;
-        return this;
-    }
-    
-    /**
-     * Returns <code>true</code> if main-memory is to be used.
-     * 
-     * <p>If this returns <code>false</code> it is ensured {@link #useTempFile()}
-     * returns <code>true</code>.</p>
-     */
-    public boolean useMainMemory()
-    {
-        return useMainMemory;
-    }
-    
-    /**
-     * Returns <code>true</code> if temporary file is to be used.
-     * 
-     * <p>If this returns <code>false</code> it is ensured {@link #useMainMemory}
-     * returns <code>true</code>.</p>
-     */
-    public boolean useTempFile()
-    {
-        return useTempFile;
-    }
-    
-    /**
-     * Returns <code>true</code> if maximum main memory is restricted to a specific
-     * number of bytes.
-     */
-    public boolean isMainMemoryRestricted()
-    {
-        return maxMainMemoryBytes >= 0;
-    }
-    
-    /**
-     * Returns <code>true</code> if maximum amount of storage is restricted to a specific
-     * number of bytes.
-     */
-    public boolean isStorageRestricted()
-    {
-        return maxStorageBytes > 0;
-    }
-    
-    /**
-     * Returns maximum size of main-memory in bytes to be used.
-     */
-    public long getMaxMainMemoryBytes()
-    {
-        return maxMainMemoryBytes;
-    }
-    
-    /**
-     * Returns maximum size of storage bytes to be used
-     * (main-memory in temporary files all together).
-     */
-    public long getMaxStorageBytes()
-    {
-        return maxStorageBytes;
-    }
-    
-    /**
-     * Returns directory to be used for temporary files or <code>null</code>
-     * if it was not set.
-     */
-    public File getTempDir()
-    {
-        return tempDir;
-    }
-    
-    @Override
-    public String toString()
-    {
-        return useMainMemory ?
-                   (useTempFile ? "Mixed mode with max. of " + maxMainMemoryBytes + " main memory bytes" +
-                                  (isStorageRestricted() ? " and max. of " + maxStorageBytes + " storage bytes" :
-                                                           " and unrestricted scratch file size") :
-                                  (isMainMemoryRestricted() ? "Main memory only with max. of " + maxMainMemoryBytes + " bytes" :
-                                                              "Main memory only with no size restriction")):
-                   (isStorageRestricted() ? "Scratch file only with max. of " + maxStorageBytes + " bytes" :
-                                            "Scratch file only with no size restriction");
-    }
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFile.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFile.java
deleted file mode 100644
index 2c724f1f53..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFile.java
+++ /dev/null
@@ -1,531 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.BitSet;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * Implements a memory page handling mechanism as base for creating (multiple)
- * {@link RandomAccess} buffers each having its set of pages (implemented by
- * {@link ScratchFileBuffer}). A buffer is created calling {@link #createBuffer()}.
- * 
- * <p>Pages can be stored in main memory or in a temporary file. A mixed mode
- * is supported storing a certain amount of pages in memory and only the
- * additional ones in temporary file (defined by maximum main memory to
- * be used).</p>
- * 
- * <p>Pages can be marked as 'free' in order to re-use them. For in-memory pages
- * this will release the used memory while for pages in temporary file this
- * simply marks the area as free to re-use.</p>
- * 
- * <p>If a temporary file was created (done with the first page to be stored
- * in temporary file) it is deleted when {@link ScratchFile#close()} is called.</p>
- * 
- * <p>Using this class for {@link RandomAccess} buffers allows for a direct control
- * on the maximum memory usage and allows processing large files for which we
- * otherwise would get an {@link OutOfMemoryError} in case of using {@link RandomAccessReadBuffer}.</p>
- * 
- * <p>This base class for providing pages is thread safe (the buffer implementations are not).</p>
- */
-public class ScratchFile implements Closeable
-{
-    private static final Log LOG = LogFactory.getLog(ScratchFile.class);
-
-    /** number of pages by which we enlarge the scratch file (reduce I/O-operations) */
-    private static final int ENLARGE_PAGE_COUNT = 16;
-    /** in case of unrestricted main memory usage this is the initial number of pages
-     *  {@link #inMemoryPages} is setup for */
-    private static final int INIT_UNRESTRICTED_MAINMEM_PAGECOUNT = 100000;
-    private static final int PAGE_SIZE = 4096;
-    
-    private final Object ioLock = new Object();
-    private final File scratchFileDirectory;
-    /** scratch file; only to be accessed under synchronization of {@link #ioLock} */
-    private File file;
-    /** random access to scratch file; only to be accessed under synchronization of {@link #ioLock} */
-    private java.io.RandomAccessFile raf;
-    private volatile int pageCount = 0;
-    private final BitSet freePages = new BitSet();
-    /** holds pointers to in-memory page content; will be initialized once in case of restricted
-     *  main memory, otherwise it is enlarged as needed and first initialized to a size of
-     *  {@link #INIT_UNRESTRICTED_MAINMEM_PAGECOUNT} */
-    private volatile byte[][] inMemoryPages;
-    private final int inMemoryMaxPageCount;
-    private final int maxPageCount;
-    private final boolean useScratchFile;
-    private final boolean maxMainMemoryIsRestricted;
-
-    private volatile boolean isClosed = false;
-    
-    /**
-     * Initializes page handler. If a <code>scratchFileDirectory</code> is supplied,
-     * then the scratch file will be created in that directory.
-     * 
-     * <p>All pages will be stored in the scratch file.</p>
-     * 
-     * @param scratchFileDirectory The directory in which to create the scratch file
-     *                             or <code>null</code> to created it in the default temporary directory.
-     * 
-     * @throws IOException If scratch file directory was given but don't exist.
-     */
-    public ScratchFile(File scratchFileDirectory) throws IOException
-    {
-        this(MemoryUsageSetting.setupTempFileOnly().setTempDir(scratchFileDirectory));
-    }
-    
-    /**
-     * Initializes page handler. If a <code>scratchFileDirectory</code> is supplied,
-     * then the scratch file will be created in that directory.
-     * 
-     * <p>Depending on the size of allowed memory usage a number of pages (memorySize/{@link #PAGE_SIZE})
-     * will be stored in-memory and only additional pages will be written to/read from scratch file.</p>
-     * 
-     * @param memUsageSetting set how memory/temporary files are used for buffering streams etc. 
-     * 
-     * @throws IOException If scratch file directory was given but don't exist.
-     */
-    public ScratchFile(MemoryUsageSetting memUsageSetting) throws IOException
-    {
-        maxMainMemoryIsRestricted = (!memUsageSetting.useMainMemory()) || memUsageSetting.isMainMemoryRestricted();
-        useScratchFile = maxMainMemoryIsRestricted && memUsageSetting.useTempFile();
-        scratchFileDirectory = useScratchFile ? memUsageSetting.getTempDir() : null;
-
-        if ((scratchFileDirectory != null) && (!scratchFileDirectory.isDirectory()))
-        {
-            throw new IOException("Scratch file directory does not exist: " + this.scratchFileDirectory);
-        }
-        
-        maxPageCount = memUsageSetting.isStorageRestricted() ?
-                           (int) Math.min(Integer.MAX_VALUE, memUsageSetting.getMaxStorageBytes() / PAGE_SIZE) :
-                           Integer.MAX_VALUE;
-                
-        inMemoryMaxPageCount = memUsageSetting.useMainMemory() ? 
-                                   (memUsageSetting.isMainMemoryRestricted() ?
-                                       (int) Math.min(Integer.MAX_VALUE, memUsageSetting.getMaxMainMemoryBytes() / PAGE_SIZE) :
-                                       Integer.MAX_VALUE) :
-                                   0;
-        inMemoryPages = new byte[maxMainMemoryIsRestricted ? inMemoryMaxPageCount : INIT_UNRESTRICTED_MAINMEM_PAGECOUNT][];
-        
-        freePages.set(0, inMemoryPages.length);
-    }
-
-    /**
-     * Getter for an instance using only unrestricted main memory for buffering
-     * (same as <code>new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly())</code>).
-     * 
-     * @return instance configured to only use main memory with no size restriction
-     */
-    public static ScratchFile getMainMemoryOnlyInstance()
-    {
-        try
-        {
-            return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly());
-        }
-        catch (IOException ioe)
-        {
-            // cannot happen for main memory setup
-            LOG.error("Unexpected exception occurred creating main memory scratch file instance: " + ioe.getMessage(), ioe);
-            return null;
-        }
-    }
-
-    /**
-     * Getter for an instance to only use main-memory with the defined maximum.
-     * 
-     * @param maxMainMemoryBytes maximum number of main-memory to be used;
-     *                           <code>-1</code> for no restriction;
-     *                           <code>0</code> will also be interpreted here as no restriction
-     * 
-     * @return instance configured to only use main memory with no size restriction
-     */
-    public static ScratchFile getMainMemoryOnlyInstance(long maxMainMemoryBytes)
-    {
-        try
-        {
-            return new ScratchFile(MemoryUsageSetting.setupMainMemoryOnly(maxMainMemoryBytes));
-        }
-        catch (IOException ioe)
-        {
-            // cannot happen for main memory setup
-            LOG.error("Unexpected exception occurred creating main memory scratch file instance: " + ioe.getMessage(), ioe);
-            return null;
-        }
-    }
-    
-    /**
-     * Returns a new free page, either from free page pool
-     * or by enlarging scratch file (may be created).
-     * 
-     * @return index of new page
-     */
-    int getNewPage() throws IOException
-    {
-        synchronized (freePages)
-        {
-            int idx = freePages.nextSetBit( 0 );
-            
-            if (idx < 0)
-            {
-                enlarge();
-                
-                idx = freePages.nextSetBit( 0 );
-                if (idx < 0)
-                {
-                    throw new IOException("Maximum allowed scratch file memory exceeded.");
-                }
-            }
-            
-            freePages.clear(idx);
-            
-            if (idx >= pageCount)
-            {
-                pageCount = idx + 1;
-            }
-            
-            return idx;
-        }
-    }
-
-    /**
-     * This will provide new free pages by either enlarging the scratch file 
-     * by a number of pages defined by {@link #ENLARGE_PAGE_COUNT} - in case
-     * scratch file usage is allowed - or increase the {@link #inMemoryPages}
-     * array in case main memory was not restricted. If neither of both is
-     * allowed/the case than free pages count won't be changed. The same is true
-     * if no new pages could be added because we reached the maximum of
-     * {@link Integer#MAX_VALUE} pages.
-     * 
-     * <p>If scratch file usage is allowed and scratch file does not exist already
-     * it will be created.</p>
-     * 
-     * <p>Only to be called under synchronization on {@link #freePages}.</p>
-     */
-    private void enlarge() throws IOException
-    {
-        synchronized (ioLock)
-        {
-            checkClosed();
-     
-            if (pageCount >= maxPageCount)
-            {
-                return;
-            }
-
-            if (useScratchFile)
-            {
-                // create scratch file is needed
-                if ( raf == null )
-                {
-                    file = File.createTempFile("PDFBox", ".tmp", scratchFileDirectory);
-                    try
-                    {
-                        raf = new java.io.RandomAccessFile(file, "rw");
-                    }
-                    catch (IOException e)
-                    {
-                        if (!file.delete())
-                        {
-                            LOG.warn("Error deleting scratch file: " + file.getAbsolutePath());
-                        }
-                        throw e;
-                    }
-                }
-                
-                long fileLen = raf.length();
-                long expectedFileLen = ((long)pageCount - inMemoryMaxPageCount) * PAGE_SIZE;
-                
-                if (expectedFileLen != fileLen)
-                {
-                    throw new IOException("Expected scratch file size of " + expectedFileLen + " but found " + fileLen);
-                }
-                    
-                // enlarge if we do not overflow
-                if (pageCount + ENLARGE_PAGE_COUNT > pageCount)
-                {
-                    fileLen += ENLARGE_PAGE_COUNT * PAGE_SIZE;
-        
-                    raf.setLength(fileLen);
-        
-                    freePages.set(pageCount, pageCount + ENLARGE_PAGE_COUNT);
-                }
-            }
-            else if (!maxMainMemoryIsRestricted)
-            {
-                // increase number of in-memory pages
-                int oldSize = inMemoryPages.length;
-                int newSize = (int) Math.min( ((long)oldSize) * 2, Integer.MAX_VALUE);  // this handles integer overflow
-                if (newSize > oldSize)
-                {
-                    byte[][] newInMemoryPages = new byte[newSize][];
-                    System.arraycopy(inMemoryPages, 0, newInMemoryPages, 0, oldSize);
-                    inMemoryPages = newInMemoryPages;
-                    
-                    freePages.set(oldSize, newSize);
-                }
-            }
-        }
-    }
-    
-    /**
-     * Returns byte size of a page.
-     * 
-     * @return byte size of a page
-     */
-    int getPageSize()
-    {
-        return PAGE_SIZE;
-    }
-    
-    /**
-     * Reads the page with specified index.
-     * 
-     * @param pageIdx index of page to read
-     * 
-     * @return byte array of size {@link #PAGE_SIZE} filled with page data read from file 
-     * 
-     * @throws IOException
-     */
-    byte[] readPage(int pageIdx) throws IOException
-    {
-        if ((pageIdx < 0) || (pageIdx >= pageCount))
-        {
-            checkClosed();
-            throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1) );
-        }
-        
-        // check if we have the page in memory
-        if (pageIdx < inMemoryMaxPageCount)
-        {
-            byte[] page = inMemoryPages[pageIdx];
-            
-            // handle case that we are closed
-            if (page == null)
-            {
-                checkClosed();
-                throw new IOException("Requested page with index " + pageIdx + " was not written before.");
-            }
-            
-            return page;
-        }
-        
-        synchronized (ioLock)
-        {
-            if (raf == null)
-            {
-                checkClosed();
-                throw new IOException("Missing scratch file to read page with index " + pageIdx + " from.");
-            }
-            
-            byte[] page = new byte[PAGE_SIZE];
-            raf.seek(((long)pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);
-            raf.readFully(page);
-            
-            return page;
-        }
-    }
-    
-    /**
-     * Writes updated page. Page is either kept in-memory if pageIdx &lt; {@link #inMemoryMaxPageCount}
-     * or is written to scratch file.
-     * 
-     * <p>Provided page byte array must not be re-used for other pages since we
-     * store it as is in case of in-memory handling.</p>
-     * 
-     * @param pageIdx index of page to write
-     * @param page page to write (length has to be {@value #PAGE_SIZE})
-     * 
-     * @throws IOException in case page index is out of range or page has wrong length
-     *                     or writing to file failed
-     */
-    void writePage(int pageIdx, byte[] page) throws IOException
-    {
-        if ((pageIdx<0) || (pageIdx>=pageCount))
-        {
-            checkClosed();
-            throw new IOException("Page index out of range: " + pageIdx + ". Max value: " + (pageCount - 1) );
-        }
-        
-        if (page.length != PAGE_SIZE)
-        {
-            throw new IOException("Wrong page size to write: " + page.length + ". Expected: " + PAGE_SIZE );
-        }
-        
-        if (pageIdx < inMemoryMaxPageCount)
-        {
-            if (maxMainMemoryIsRestricted)
-            {
-                inMemoryPages[pageIdx] = page;
-            }
-            else
-            {
-                // need synchronization since inMemoryPages may change
-                synchronized (ioLock)
-                {
-                    inMemoryPages[pageIdx] = page;
-                }
-            }
-            
-            // in case we were closed in between throw exception
-            checkClosed();
-        }
-        else
-        {
-            synchronized (ioLock)
-            {
-                checkClosed();
-                raf.seek(((long)pageIdx - inMemoryMaxPageCount) * PAGE_SIZE);
-                raf.write(page);
-            }
-        }
-    }
-    
-    /**
-     * Checks if this page handler has already been closed. If so,
-     * an {@link IOException} is thrown.
-     * 
-     * @throws IOException If {@link #close()} has already been called.
-     */
-    void checkClosed() throws IOException
-    {
-        if (isClosed)
-        {
-            throw new IOException("Scratch file already closed");
-        }
-    }
-
-    /**
-     * Creates a new buffer using this page handler.
-     * 
-     * @return A new buffer.
-     * 
-     * @throws IOException If an error occurred.
-     */
-    public RandomAccess createBuffer() throws IOException
-    {
-        return new ScratchFileBuffer(this);
-    }
-
-    /**
-     * Creates a new buffer using this page handler and initializes it with the
-     * data read from provided input stream (input stream is copied to buffer).
-     * The buffer data pointer is reset to point to first byte.
-     * 
-     * @param input The input stream that is to be copied into the buffer.
-     * @return A new buffer containing data read from input stream.
-     * 
-     * @throws IOException If an error occurred.
-     */
-    public RandomAccess createBuffer(InputStream input) throws IOException
-    {
-        ScratchFileBuffer buf = new ScratchFileBuffer(this);
-        
-        byte[] byteBuffer = new byte[8192];
-        int bytesRead;
-        while ((bytesRead = input.read(byteBuffer)) > -1)
-        {
-            buf.write(byteBuffer, 0, bytesRead);
-        }
-        buf.seek(0);
-
-        return buf;
-    }
-
-    /**
-     * Allows a buffer which is cleared/closed to release its pages to be re-used.
-     * 
-     * @param pageIndexes pages indexes of pages to release
-     * @param count number of page indexes contained in provided array 
-     */
-    void markPagesAsFree(int[] pageIndexes, int off, int count) {
-        
-        synchronized (freePages)
-        {
-            for (int aIdx = off; aIdx < count; aIdx++)
-            {
-                int pageIdx = pageIndexes[aIdx];
-                if ((pageIdx>=0) && (pageIdx<pageCount) && (!freePages.get(pageIdx)))
-                {
-                    freePages.set(pageIdx);
-                    if (pageIdx < inMemoryMaxPageCount)
-                    {
-                        inMemoryPages[pageIdx] = null;  // remark: not in ioLock synchronization since behavior won't
-                                                        // change even in case of parallel called 'enlarge' method
-                    }
-                }
-                    
-            }
-        }
-    }
-    
-    /**
-     * Closes and deletes the temporary file. No further interaction with
-     * the scratch file or associated buffers can happen after this method is called.
-     * It also releases in-memory pages.
-     * 
-     * @throws IOException If there was a problem closing or deleting the temporary file.
-     */
-    @Override
-    public void close() throws IOException
-    {
-        IOException ioexc = null;
-        
-        synchronized (ioLock)
-        {
-            if (isClosed)
-            {
-                return;
-            }
-        
-            isClosed = true;
-
-            if (raf != null)
-            {
-                try
-                {
-                    raf.close();
-                }
-                catch (IOException ioe)
-                {
-                    ioexc = ioe;
-                }
-            }
-            
-            if (file != null && !file.delete() && file.exists() && ioexc == null)
-            {
-                ioexc = new IOException("Error deleting scratch file: " + file.getAbsolutePath());
-            }
-        }
-        
-        synchronized (freePages)
-        {
-            freePages.clear();
-            pageCount = 0;
-        }
-        
-        if (ioexc != null)
-        {
-            throw ioexc;
-        }
-    }
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFileBuffer.java b/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFileBuffer.java
deleted file mode 100644
index 178bfc01d5..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/ScratchFileBuffer.java
+++ /dev/null
@@ -1,471 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import java.io.EOFException;
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-/**
- * Implementation of {@link RandomAccess} as sequence of multiple fixed size pages handled
- * by {@link ScratchFile}.
- */
-class ScratchFileBuffer implements RandomAccess
-{
-    private final int pageSize;
-    /**
-     * The underlying page handler.
-     */
-    private ScratchFile pageHandler;
-    /**
-     * The number of bytes of content in this buffer.
-     */
-    private long size = 0;
-    /**
-     * Index of current page in {@link #pageIndexes} (the nth page within this buffer).
-     */
-    private int currentPagePositionInPageIndexes;
-    /**
-     * The offset of the current page within this buffer.
-     */
-    private long currentPageOffset;
-    /**
-     * The current page data.
-     */
-    private byte[] currentPage;
-    /**
-     * The current position (for next read/write) of the buffer as an offset in the current page.
-     */
-    private int positionInPage;
-    /** 
-     * <code>true</code> if current page was changed by a write method
-     */
-    private boolean currentPageContentChanged = false;
-
-    /** contains ordered list of pages with the index the page is known by page handler ({@link ScratchFile}) */
-    private int[] pageIndexes = new int[16];
-    /** number of pages held by this buffer */
-    private int pageCount = 0;
-    
-    private static final Log LOG = LogFactory.getLog(ScratchFileBuffer.class);
-    
-    /**
-     * Creates a new buffer using pages handled by provided {@link ScratchFile}.
-     * 
-     * @param pageHandler The {@link ScratchFile} managing the pages to be used by this buffer.
-     * 
-     * @throws IOException If getting first page failed.
-     */
-    ScratchFileBuffer(ScratchFile pageHandler) throws IOException
-    {
-        pageHandler.checkClosed();
-
-        this.pageHandler = pageHandler;
-        
-        pageSize = this.pageHandler.getPageSize();
-        
-        addPage();
-    }
-
-    /**
-     * Checks if this buffer, or the underlying {@link ScratchFile} have been closed,
-     * throwing {@link IOException} if so.
-     * 
-     * @throws IOException If either this buffer, or the underlying {@link ScratchFile} have been closed.
-     */
-    private void checkClosed() throws IOException
-    {
-        if (pageHandler == null)
-        {
-            throw new IOException("Buffer already closed");
-        }
-        pageHandler.checkClosed();
-    }
-
-    /**
-     * Adds a new page and positions all pointers to start of new page.
-     * 
-     * @throws IOException if requesting a new page fails
-     */
-    private void addPage() throws IOException
-    {
-        if (pageCount+1 >= pageIndexes.length)
-        {
-            int newSize = pageIndexes.length*2;
-            // check overflow
-            if (newSize<pageIndexes.length)
-            {
-                if (pageIndexes.length == Integer.MAX_VALUE)
-                {
-                    throw new IOException("Maximum buffer size reached.");
-                }
-                newSize = Integer.MAX_VALUE;
-            }
-            int[] newPageIndexes = new int[newSize];
-            System.arraycopy(pageIndexes, 0, newPageIndexes, 0, pageCount);
-            pageIndexes = newPageIndexes;
-        }
-        
-        int newPageIdx = pageHandler.getNewPage();
-        
-        pageIndexes[pageCount] = newPageIdx;
-        currentPagePositionInPageIndexes = pageCount;
-        currentPageOffset = ((long)pageCount) * pageSize; 
-        pageCount++;
-        currentPage = new byte[pageSize];
-        positionInPage = 0;
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long length() throws IOException
-    {
-        return size;
-    }
-
-    /**
-     * Ensures the current page has at least one byte left
-     * ({@link #positionInPage} in &lt; {@link #pageSize}).
-     * 
-     * <p>If this is not the case we go to next page (writing
-     * current one if changed). If current buffer has no more
-     * pages we add a new one.</p>
-     * 
-     * @param addNewPageIfNeeded if <code>true</code> it is allowed to add a new page in case
-     *                           we are currently at end of last buffer page
-     * 
-     * @return <code>true</code> if we were successful positioning pointer before end of page;
-     *         we might return <code>false</code> if it is not allowed to add another page
-     *         and current pointer points at end of last page
-     * 
-     * @throws IOException
-     */
-    private boolean ensureAvailableBytesInPage(boolean addNewPageIfNeeded) throws IOException
-    {
-        if (positionInPage >= pageSize)
-        {
-            // page full
-            if (currentPageContentChanged)
-            {
-                // write page
-                pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);
-                currentPageContentChanged = false;
-            }
-            // get new page
-            if (currentPagePositionInPageIndexes+1 < pageCount)
-            {
-                // we already have more pages assigned (there was a backward seek before)
-                currentPage = pageHandler.readPage(pageIndexes[++currentPagePositionInPageIndexes]);
-                currentPageOffset = ((long)currentPagePositionInPageIndexes) * pageSize;
-                positionInPage = 0;
-            }
-            else if (addNewPageIfNeeded)
-            {
-                // need new page
-                addPage();
-            }
-            else
-            {
-                // we are at last page and are not allowed to add new page
-                return false;
-            }
-        }
-        return true;
-    }
-    
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void write(int b) throws IOException
-    {
-        checkClosed();
-        
-        ensureAvailableBytesInPage(true);
-        
-        currentPage[positionInPage++] = (byte) b;
-        currentPageContentChanged = true;
-        
-        if(currentPageOffset + positionInPage > size)
-        {
-            size = currentPageOffset + positionInPage;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void write(byte[] b) throws IOException
-    {
-        write(b, 0, b.length);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void write(byte[] b, int off, int len) throws IOException
-    {
-        checkClosed();
-
-        int remain = len;
-        int bOff   = off;
-        
-        while (remain > 0)
-        {
-            ensureAvailableBytesInPage(true);
-
-            int bytesToWrite = Math.min(remain, pageSize-positionInPage);
-            
-            System.arraycopy(b, bOff, currentPage, positionInPage, bytesToWrite);
-            
-            positionInPage += bytesToWrite;
-            currentPageContentChanged = true;
-            
-            bOff   += bytesToWrite;
-            remain -= bytesToWrite;
-        }
-        
-        if(currentPageOffset + positionInPage > size)
-        {
-            size = currentPageOffset + positionInPage;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final void clear() throws IOException
-    {
-        checkClosed();
-        
-        // keep only the first page, discard all other pages
-        pageHandler.markPagesAsFree(pageIndexes, 1, pageCount - 1);
-        pageCount = 1;
-        
-        // change to first page if we are not already there
-        if (currentPagePositionInPageIndexes > 0)
-        {
-            currentPage = pageHandler.readPage(pageIndexes[0]);
-            currentPagePositionInPageIndexes = 0;
-            currentPageOffset = 0;
-        }
-        positionInPage = 0;
-        size = 0;
-        currentPageContentChanged = false;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public long getPosition() throws IOException
-    {
-        checkClosed();
-        return currentPageOffset + positionInPage;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void seek(long seekToPosition) throws IOException
-    {
-        checkClosed();
-
-        /*
-         * for now we won't allow to seek past end of buffer; this can be changed by adding new pages as needed
-         */
-        if (seekToPosition > size)
-        {
-            throw new EOFException();
-        }
-        
-        if (seekToPosition < 0)
-        {
-            throw new IOException("Negative seek offset: " + seekToPosition);
-        }
-        
-        if ((seekToPosition >= currentPageOffset) && (seekToPosition <= currentPageOffset + pageSize))
-        {
-            // within same page
-            positionInPage = (int) (seekToPosition - currentPageOffset);
-        }
-        else
-        {
-            // have to go to another page
-            
-            // check if current page needs to be written to file
-            if (currentPageContentChanged)
-            {
-                pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);
-                currentPageContentChanged = false;
-            }
-            
-            int newPagePosition = (int) (seekToPosition / pageSize);
-            if (seekToPosition % pageSize == 0 && seekToPosition == size)
-            {
-                newPagePosition--; // PDFBOX-4756: Prevent seeking a non-yet-existent page...
-            }
-            
-            currentPage = pageHandler.readPage(pageIndexes[newPagePosition]);
-            currentPagePositionInPageIndexes = newPagePosition;
-            currentPageOffset = ((long)currentPagePositionInPageIndexes) * pageSize;
-            positionInPage = (int) (seekToPosition - currentPageOffset);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isClosed()
-    {
-        return pageHandler == null;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean isEOF() throws IOException
-    {
-        checkClosed();
-        return currentPageOffset + positionInPage >= size;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int read() throws IOException
-    {
-        checkClosed();
-
-        if (currentPageOffset + positionInPage >= size)
-        {
-            return -1;
-        }
-
-        if (! ensureAvailableBytesInPage(false))
-        {
-            // should not happen, we checked it before
-            throw new IOException("Unexpectedly no bytes available for read in buffer.");
-        }
-        
-        return currentPage[positionInPage++] & 0xff;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int read(byte[] b, int off, int len) throws IOException
-    {
-        checkClosed();
-
-        if (currentPageOffset + positionInPage >= size)
-        {
-            return -1;
-        }
-
-        int remain = (int) Math.min(len, size - (currentPageOffset + positionInPage));
-
-        int totalBytesRead = 0;
-        int bOff           = off;
-
-        while (remain > 0)
-        {
-            if (! ensureAvailableBytesInPage(false))
-            {
-                // should not happen, we checked it before
-                throw new IOException("Unexpectedly no bytes available for read in buffer.");
-            }
-            
-            int readBytes = Math.min(remain, pageSize - positionInPage);
-
-            System.arraycopy(currentPage, positionInPage, b, bOff, readBytes);
-
-            positionInPage += readBytes;
-            totalBytesRead += readBytes;
-            bOff += readBytes;
-            remain -= readBytes;
-        }
-
-        return totalBytesRead;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void close() throws IOException
-    {
-        if (pageHandler != null) {
-
-            pageHandler.markPagesAsFree(pageIndexes, 0, pageCount);
-            pageHandler = null;
-            
-            pageIndexes = null;
-            currentPage = null;
-            currentPageOffset = 0;
-            currentPagePositionInPageIndexes = -1;
-            positionInPage = 0;
-            size = 0;
-        }
-    }
-    
-    /**
-     * While calling finalize is normally discouraged we will have to
-     * use it here as long as closing a scratch file buffer is not 
-     * done in every case. Currently {@link COSStream} creates new
-     * buffers without closing the old one - which might still be
-     * used.
-     * 
-     * <p>Enabling debugging one will see if there are still cases
-     * where the buffer is not closed.</p>
-     */
-    @Override
-    protected void finalize() throws Throwable
-    {
-        try
-        {
-            if ((pageHandler != null) && LOG.isDebugEnabled())
-            {
-                LOG.debug("ScratchFileBuffer not closed!");
-            }
-            close();
-        }
-        finally
-        {
-            super.finalize();
-        }
-    }
-
-    @Override
-    public RandomAccessReadView createView(long startPosition, long streamLength) throws IOException
-    {
-        return new RandomAccessReadView(this, startPosition, streamLength);
-    }
-
-}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/io/package.html b/pdfbox/src/main/java/org/apache/pdfbox/io/package.html
deleted file mode 100644
index 7baf9b09af..0000000000
--- a/pdfbox/src/main/java/org/apache/pdfbox/io/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!--
- ! Licensed to the Apache Software Foundation (ASF) under one or more
- ! contributor license agreements.  See the NOTICE file distributed with
- ! this work for additional information regarding copyright ownership.
- ! The ASF licenses this file to You under the Apache License, Version 2.0
- ! (the "License"); you may not use this file except in compliance with
- ! the License.  You may obtain a copy of the License at
- !
- !      http://www.apache.org/licenses/LICENSE-2.0
- !
- ! Unless required by applicable law or agreed to in writing, software
- ! distributed under the License is distributed on an "AS IS" BASIS,
- ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ! See the License for the specific language governing permissions and
- ! limitations under the License.
- !-->
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html lang="en">
-<head><title></title>
-
-</head>
-<body>
-This package contains IO streams.
-</body>
-</html>
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/ScratchFileBufferTest.java b/pdfbox/src/test/java/org/apache/pdfbox/io/ScratchFileBufferTest.java
deleted file mode 100644
index 2ea9b64293..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/io/ScratchFileBufferTest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pdfbox.io;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import java.io.IOException;
-
-import org.junit.jupiter.api.Test;
-
-/**
- * Regression test to check the known bugs in {@link ScratchFileBuffer}.
- *
- * @author KÃ¼hn &amp; Weyh Software GmbH
- */
-class ScratchFileBufferTest
-{
-
-    private static final int PAGE_SIZE = 4096;
-    private static final int NUM_ITERATIONS = 3;
-
-    /**
-     * PDFBOX-4756: test positions are correct when seeking and that no EOFException is thrown in
-     * ScratchFileBuffer.seek() beyond last page.
-     *
-     * @throws IOException
-     */
-    @Test
-    void testEOFBugInSeek() throws IOException
-    {
-        try (ScratchFile scratchFile = new ScratchFile(MemoryUsageSetting.setupTempFileOnly()))
-        {
-            ScratchFileBuffer scratchFileBuffer = new ScratchFileBuffer(scratchFile);
-            byte[] bytes = new byte[PAGE_SIZE];
-            for (int i = 0; i < NUM_ITERATIONS; i++)
-            {
-                long p0 = scratchFileBuffer.getPosition();
-                scratchFileBuffer.write(bytes);
-                long p1 = scratchFileBuffer.getPosition();
-                assertEquals(PAGE_SIZE, p1 - p0);
-                scratchFileBuffer.write(bytes);
-                long p2 = scratchFileBuffer.getPosition();
-                assertEquals(PAGE_SIZE, p2 - p1);
-                scratchFileBuffer.seek(0);
-                scratchFileBuffer.seek(i * 2 * PAGE_SIZE);
-            }
-        }
-    }
-}
diff --git a/pdfbox/src/test/java/org/apache/pdfbox/io/package.html b/pdfbox/src/test/java/org/apache/pdfbox/io/package.html
deleted file mode 100644
index e9e67526a2..0000000000
--- a/pdfbox/src/test/java/org/apache/pdfbox/io/package.html
+++ /dev/null
@@ -1,25 +0,0 @@
-<!--
- ! Licensed to the Apache Software Foundation (ASF) under one or more
- ! contributor license agreements.  See the NOTICE file distributed with
- ! this work for additional information regarding copyright ownership.
- ! The ASF licenses this file to You under the Apache License, Version 2.0
- ! (the "License"); you may not use this file except in compliance with
- ! the License.  You may obtain a copy of the License at
- !
- !      http://www.apache.org/licenses/LICENSE-2.0
- !
- ! Unless required by applicable law or agreed to in writing, software
- ! distributed under the License is distributed on an "AS IS" BASIS,
- ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ! See the License for the specific language governing permissions and
- ! limitations under the License.
- !-->
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html lang="en">
-<head><title></title>
-
-</head>
-<body>
-This package contains test cases for I/O-related classes.
-</body>
-</html>
