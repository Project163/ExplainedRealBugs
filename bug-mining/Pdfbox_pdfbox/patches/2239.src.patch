diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
index aa29c28f54..988c40c52a 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
@@ -583,42 +583,39 @@ public class PDType1Font extends PDSimpleFont implements PDVectorFont
         {
             return name;
         }
-        else
+
+        // try alternative name
+        String altName = ALT_NAMES.get(name);
+        if (altName != null && !name.equals(".notdef") && genericFont.hasGlyph(altName))
         {
-            // try alternative name
-            String altName = ALT_NAMES.get(name);
-            if (altName != null && !name.equals(".notdef") && genericFont.hasGlyph(altName))
+            return altName;
+        }
+
+        // try unicode name
+        String unicodes = getGlyphList().toUnicode(name);
+        if (unicodes != null && unicodes.length() == 1)
+        {
+            String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));
+            if (genericFont.hasGlyph(uniName))
             {
-                return altName;
+                return uniName;
             }
-            else
+            // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN
+            // names are not found. What works is using the PDF code plus 0xF000
+            // while disregarding encoding from the PDF (because of file from PDFBOX-1606,
+            // makes sense because this segment is about finding the name in a standard font)
+            //TODO bring up better solution than this
+            if ("SymbolMT".equals(genericFont.getName()))
             {
-                // try unicode name
-                String unicodes = getGlyphList().toUnicode(name);
-                if (unicodes != null && unicodes.length() == 1)
+                int code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);
+                uniName = getUniNameOfCodePoint(code + 0xF000);
+                if (genericFont.hasGlyph(uniName))
                 {
-                    String uniName = getUniNameOfCodePoint(unicodes.codePointAt(0));
-                    if (genericFont.hasGlyph(uniName))
-                    {
-                        return uniName;
-                    }
-                    // PDFBOX-4017: no postscript table on Windows 10, and the low uni00NN
-                    // names are not found. What works is using the PDF code plus 0xF000
-                    // while disregarding encoding from the PDF (because of file from PDFBOX-1606;
-                    // makes sense because this segment is about finding the name in a standard font)
-                    //TODO bring up better solution than this
-                    if ("SymbolMT".equals(genericFont.getName()))
-                    {
-                        int code = SymbolEncoding.INSTANCE.getNameToCodeMap().get(name);
-                        uniName = getUniNameOfCodePoint(code + 0xF000);
-                        if (genericFont.hasGlyph(uniName))
-                        {
-                            return uniName;
-                        }
-                    }
+                    return uniName;
                 }
             }
         }
+
         return ".notdef";
     }
 
