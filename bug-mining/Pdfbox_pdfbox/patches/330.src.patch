diff --git a/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java b/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
index cf28579851..d59bd9954d 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/encoding/Encoding.java
@@ -210,7 +210,7 @@ public abstract class Encoding implements COSObjectable
      * 
      * @throws IOException If there is no name for the character.
      */
-    public String getNameFromCharacter(char c) throws IOException
+    public String getNameForCharacter(char c) throws IOException
     {
         String name = CHARACTER_TO_NAME.get(Character.toString(c));
         if (name == null)
@@ -220,6 +220,24 @@ public abstract class Encoding implements COSObjectable
         return name;
     }
 
+    /**
+     * This will take a name and get the character code for that name.
+     * 
+     * @param name The name.
+     * 
+     * @return The name of the character.
+     * 
+     */
+    public static String getCharacterForName(String name)
+    {
+        if (NAME_TO_CHARACTER.containsKey(name))
+        {
+            LOG.debug("No character for name " + name);
+            return NAME_TO_CHARACTER.get(name);
+        }
+        return null;
+    }
+
     /**
      * This will get the character from the code.
      * 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
index 16a38ec424..f733ed2474 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/PageDrawer.java
@@ -21,6 +21,7 @@ import java.awt.Color;
 import java.awt.Composite;
 import java.awt.Dimension;
 import java.awt.Font;
+import java.awt.FontFormatException;
 import java.awt.Graphics;
 import java.awt.Graphics2D;
 import java.awt.Image;
@@ -41,21 +42,29 @@ import java.util.Map;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.cff.CFFFont;
 import org.apache.fontbox.cmap.CMap;
 import org.apache.fontbox.ttf.TrueTypeFont;
 import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.cos.COSStream;
+import org.apache.pdfbox.pdfviewer.font.CFFGlyph2D;
 import org.apache.pdfbox.pdfviewer.font.Glyph2D;
 import org.apache.pdfbox.pdfviewer.font.TTFGlyph2D;
 import org.apache.pdfbox.pdmodel.PDPage;
 import org.apache.pdfbox.pdmodel.PDResources;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
+import org.apache.pdfbox.pdmodel.font.FontManager;
+import org.apache.pdfbox.pdmodel.font.PDCIDFontType0Font;
 import org.apache.pdfbox.pdmodel.font.PDCIDFontType2Font;
 import org.apache.pdfbox.pdmodel.font.PDFont;
+import org.apache.pdfbox.pdmodel.font.PDFontDescriptor;
+import org.apache.pdfbox.pdmodel.font.PDFontDescriptorDictionary;
 import org.apache.pdfbox.pdmodel.font.PDSimpleFont;
 import org.apache.pdfbox.pdmodel.font.PDTrueTypeFont;
 import org.apache.pdfbox.pdmodel.font.PDType0Font;
+import org.apache.pdfbox.pdmodel.font.PDType1CFont;
+import org.apache.pdfbox.pdmodel.font.PDType1Font;
 import org.apache.pdfbox.pdmodel.font.PDType3Font;
 import org.apache.pdfbox.pdmodel.graphics.PDGraphicsState;
 import org.apache.pdfbox.pdmodel.graphics.PDShading;
@@ -106,6 +115,7 @@ public class PageDrawer extends PDFStreamEngine
     private GeneralPath linePath = new GeneralPath();
 
     private HashMap<PDFont, Glyph2D> fontGlyph2D = new HashMap<PDFont, Glyph2D>();
+    private HashMap<PDFont, Font> awtFonts = new HashMap<PDFont, Font>();
 
     /**
      * Default constructor, loads properties from file.
@@ -191,6 +201,10 @@ public class PageDrawer extends PDFStreamEngine
             fontGlyph2D.clear();
             fontGlyph2D = null;
         }
+        if (awtFonts != null)
+        {
+            awtFonts.clear();
+        }
         graphics = null;
         linePath = null;
         page = null;
@@ -290,7 +304,8 @@ public class PageDrawer extends PDFStreamEngine
                 }
                 else
                 {
-                    // Use AWT to render the font
+                    // Use AWT to render the font (Type1 fonts, standard14 fonts, if the embedded font is substituted)
+                    // TODO to be removed in the long run?
                     drawString((PDSimpleFont) font, text.getCharacter(), text.getCodePoints(), graphics, at, x, y);
                 }
             }
@@ -409,45 +424,10 @@ public class PageDrawer extends PDFStreamEngine
     private void drawString(PDSimpleFont font, String string, int[] codePoints, Graphics g, AffineTransform at,
             float x, float y) throws IOException
     {
-        Font awtFont = font.getawtFont();
+        Font awtFont = createAWTFont(font);
         FontRenderContext frc = new FontRenderContext(new AffineTransform(), true, true);
-        GlyphVector glyphs = null;
-        boolean useCodepoints = codePoints != null && font.isType0Font();
-        PDFont descendantFont = useCodepoints ? ((PDType0Font) font).getDescendantFont() : null;
-        // symbolic fonts may trigger the same fontmanager.so/dll error as described below
-        if (useCodepoints && !descendantFont.getFontDescriptor().isSymbolic())
-        {
-            PDCIDFontType2Font cid2Font = null;
-            if (descendantFont instanceof PDCIDFontType2Font)
-            {
-                cid2Font = (PDCIDFontType2Font) descendantFont;
-            }
-            if ((cid2Font != null && cid2Font.hasCIDToGIDMap()) || ((PDSimpleFont) font).isFontSubstituted())
-            {
-                // we still have to use the string if a CIDToGIDMap is used
-                glyphs = awtFont.createGlyphVector(frc, string);
-            }
-            else
-            {
-                glyphs = awtFont.createGlyphVector(frc, codePoints);
-            }
-        }
-        else
-        {
-            // mdavis - fix fontmanager.so/dll on sun.font.FileFont.getGlyphImage
-            // for font with bad cmaps?
-            // Type1 fonts are not affected as they don't have cmaps
-            if (!font.isType1Font() && awtFont.canDisplayUpTo(string) != -1)
-            {
-                LOG.warn("Changing font on <" + string + "> from <" + awtFont.getName() + "> to the default font");
-                awtFont = Font.decode(null).deriveFont(1f);
-            }
-            glyphs = awtFont.createGlyphVector(frc, string);
-            if (font.isType1Font())
-            {
-                glyphs = font.remapGlyphs(glyphs, string);
-            }
-        }
+        GlyphVector glyphs = awtFont.createGlyphVector(frc, string);
+
         Graphics2D g2d = (Graphics2D) g;
         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         writeFont(g2d, at, x, y, glyphs);
@@ -485,6 +465,87 @@ public class PageDrawer extends PDFStreamEngine
         }
     }
 
+    /**
+     * Provides an AWT font for the given PDFont.
+     * 
+     * @param font the font which needs an AWT font
+     * @return the corresponding AWT font
+     * @throws IOException if something went wrong
+     */
+
+    private Font createAWTFont(PDSimpleFont font) throws IOException
+    {
+        Font awtFont = null;
+        // Is there already a AWTFont for the given font?
+        if (awtFonts.containsKey(font))
+        {
+            awtFont = awtFonts.get(font);
+        }
+        else
+        {
+            if (font instanceof PDType1Font)
+            {
+                PDType1Font type1Font = (PDType1Font) font;
+                PDFontDescriptor fd = type1Font.getFontDescriptor();
+                if (fd != null && fd instanceof PDFontDescriptorDictionary)
+                {
+                    PDFontDescriptorDictionary fdDictionary = (PDFontDescriptorDictionary) fd;
+                    if (fdDictionary.getFontFile() != null)
+                    {
+                        try
+                        {
+                            // create a type1 font with the embedded data
+                            awtFont = Font.createFont(Font.TYPE1_FONT, fdDictionary.getFontFile().createInputStream());
+                        }
+                        catch (FontFormatException e)
+                        {
+                            LOG.info("Can't read the embedded type1 font " + fd.getFontName());
+                        }
+                    }
+                    if (awtFont == null)
+                    {
+                        // check if the font is part of our environment
+                        awtFont = FontManager.getAwtFont(fd.getFontName());
+                        if (awtFont != null)
+                        {
+                            type1Font.setIsFontSubstituted(true);
+                        }
+                        else
+                        {
+                            LOG.info("Can't find the specified font " + fd.getFontName());
+                        }
+                    }
+                }
+                else
+                {
+                    // check if the font is part of our environment
+                    String baseFont = type1Font.getBaseFont();
+                    awtFont = FontManager.getAwtFont(baseFont);
+                    if (awtFont == null)
+                    {
+                        LOG.info("Can't find the specified basefont " + baseFont);
+                    }
+                }
+            }
+            else
+            {
+                LOG.info("Unsupported type of font " + font.getClass().getName());
+            }
+            if (awtFont == null)
+            {
+                // Fallback: we can't find anything, so we have to use the standard font
+                awtFont = FontManager.getStandardFont();
+                LOG.info("Using font " + awtFont.getName() + " instead");
+                font.setIsFontSubstituted(true);
+            }
+            if (awtFont != null)
+            {
+                awtFonts.put(font, awtFont);
+            }
+        }
+        return awtFont;
+    }
+
     /**
      * Provide a Glyh2d for the given font if supported.
      * 
@@ -503,8 +564,6 @@ public class PageDrawer extends PDFStreamEngine
         else
         {
             // check if the given font is supported
-
-            // TTF fonts are supported
             if (font instanceof PDTrueTypeFont)
             {
                 PDTrueTypeFont ttfFont = (PDTrueTypeFont) font;
@@ -520,10 +579,19 @@ public class PageDrawer extends PDFStreamEngine
                 {
                     glyph2D = new TTFGlyph2D(ttf, font.getBaseFont(), ttfFont.isSymbolicFont(), toUnicodeCMap);
                 }
-                // cache the Glyph2D instance
-                if (glyph2D != null)
+            }
+            else if (font instanceof PDType1Font)
+            {
+                PDType1Font type1Font = (PDType1Font) font;
+                PDType1CFont type1CFont = type1Font.getType1CFont();
+                if (type1CFont != null)
                 {
-                    fontGlyph2D.put(font, glyph2D);
+                    // get the cffFont raw data
+                    CFFFont cffFont = type1CFont.getCFFFont();
+                    if (cffFont != null)
+                    {
+                        glyph2D = new CFFGlyph2D(cffFont, type1CFont.getFontEncoding());
+                    }
                 }
             }
             else if (font instanceof PDType0Font)
@@ -553,14 +621,28 @@ public class PageDrawer extends PDFStreamEngine
                                     toUnicodeCMap);
                         }
                     }
-                    // cache the Glyph2D instance
-                    if (glyph2D != null)
+                }
+                else if (type0Font.getDescendantFont() instanceof PDCIDFontType0Font)
+                {
+                    // a CIDFontType2Font contains TTF font
+                    PDCIDFontType0Font cidType2Font = (PDCIDFontType0Font) type0Font.getDescendantFont();
+                    PDType1CFont type1CFont = cidType2Font.getType1CFont();
+                    if (type1CFont != null)
                     {
-                        fontGlyph2D.put(font, glyph2D);
+                        // get the cffFont raw data
+                        CFFFont cffFont = type1CFont.getCFFFont();
+                        if (cffFont != null)
+                        {
+                            glyph2D = new CFFGlyph2D(cffFont, type1CFont.getFontEncoding());
+                        }
                     }
-
                 }
             }
+            // cache the Glyph2D instance
+            if (glyph2D != null)
+            {
+                fontGlyph2D.put(font, glyph2D);
+            }
         }
         return glyph2D;
     }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/CFFGlyph2D.java b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/CFFGlyph2D.java
new file mode 100644
index 0000000000..77cab29139
--- /dev/null
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdfviewer/font/CFFGlyph2D.java
@@ -0,0 +1,203 @@
+/*
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+package org.apache.pdfbox.pdfviewer.font;
+
+import java.awt.geom.AffineTransform;
+import java.awt.geom.GeneralPath;
+import java.awt.geom.Path2D;
+import java.awt.geom.PathIterator;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.cff.CFFFont;
+import org.apache.fontbox.cff.CharStringRenderer;
+import org.apache.pdfbox.encoding.Encoding;
+
+/**
+ * This class provides a glyph to GeneralPath conversion for CFF fonts.
+ * 
+ */
+public class CFFGlyph2D implements Glyph2D
+{
+
+    /**
+     * Log instance.
+     */
+    private static final Log LOG = LogFactory.getLog(CFFGlyph2D.class);
+
+    private float scale = 0.001f;
+    private HashMap<Integer, GeneralPath> glyphs = new HashMap<Integer, GeneralPath>();
+    private HashMap<Integer, Integer> codeToGlyph = new HashMap<Integer, Integer>();
+    private String fontname = null;
+
+    /**
+     * Constructor.
+     * 
+     */
+    public CFFGlyph2D(CFFFont cffFont, Encoding encoding)
+    {
+        fontname = cffFont.getName();
+        Map<String, Integer> nameToCode = encoding != null ? encoding.getNameToCodeMap() : null;
+        Collection<CFFFont.Mapping> mappings = cffFont.getMappings();
+        Map<Integer, String> codeToNameMap = new LinkedHashMap<Integer, String>();
+        for (CFFFont.Mapping mapping : mappings)
+        {
+            codeToNameMap.put(mapping.getCode(), mapping.getName());
+        }
+
+        CharStringRenderer renderer = cffFont.createRenderer();
+        int glyphId = 0;
+        for (CFFFont.Mapping mapping : mappings)
+        {
+            GeneralPath glyph = null;
+            try
+            {
+                glyph = renderer.render(mapping.toType1Sequence());
+            }
+            catch (IOException exception)
+            {
+                LOG.error("CFF glyph rendering fails!", exception);
+            }
+            if (glyph != null)
+            {
+                AffineTransform atPath = AffineTransform.getScaleInstance(scale, scale);
+                glyph.transform(atPath);
+                glyphs.put(glyphId, transformGlyph(glyph));
+                int code = mapping.getSID();
+                String name = mapping.getName();
+                if (nameToCode != null && nameToCode.containsKey(name))
+                {
+                    code = nameToCode.get(name);
+                }
+                codeToGlyph.put(code, glyphId);
+                glyphId++;
+            }
+        }
+    }
+
+    private GeneralPath transformGlyph(GeneralPath glyph)
+    {
+        // we have to invert all y-coordinates due to the moved 0,0-reference
+        PathIterator iter = glyph.getPathIterator(null);
+        float[] currentSegment = new float[6];
+        Path2D.Float path = new Path2D.Float(iter.getWindingRule());
+        boolean glyphTransformed = false;
+        while (!iter.isDone())
+        {
+            glyphTransformed = true;
+            int type = iter.currentSegment(currentSegment);
+            switch (type)
+            {
+            case PathIterator.SEG_MOVETO:
+                path.moveTo(currentSegment[0], -currentSegment[1]);
+                break;
+            case PathIterator.SEG_LINETO:
+                path.lineTo(currentSegment[0], -currentSegment[1]);
+                break;
+            case PathIterator.SEG_QUADTO:
+                path.quadTo(currentSegment[0], -currentSegment[1], currentSegment[2], -currentSegment[3]);
+                break;
+            case PathIterator.SEG_CUBICTO:
+                path.curveTo(currentSegment[0], -currentSegment[1], currentSegment[2], -currentSegment[3],
+                        currentSegment[4], -currentSegment[5]);
+                break;
+            case PathIterator.SEG_CLOSE:
+                path.closePath();
+                break;
+            }
+            iter.next();
+        }
+        if (glyphTransformed)
+        {
+            return new GeneralPath(path);
+        }
+        else
+        {
+            return glyph;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GeneralPath getPathForGlyphId(int glyphId)
+    {
+        if (glyphs.containsKey(glyphId))
+        {
+            return glyphs.get(glyphId);
+        }
+        else
+        {
+            LOG.debug(fontname + ": glyph " + glyphId + " not found!");
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public GeneralPath getPathForCharactercode(int code)
+    {
+        if (codeToGlyph.containsKey(code))
+        {
+            return getPathForGlyphId(codeToGlyph.get(code));
+        }
+        else
+        {
+            LOG.debug(fontname + ": glyphmapping for " + code + " not found!");
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getNumberOfGlyphs()
+    {
+        if (glyphs != null)
+        {
+            return glyphs.size();
+        }
+        return 0;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void dispose()
+    {
+        if (glyphs != null)
+        {
+            glyphs.clear();
+        }
+        if (codeToGlyph != null)
+        {
+            codeToGlyph.clear();
+        }
+    }
+}
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType0Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType0Font.java
index 0dc1f1dac2..f0044a87b4 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType0Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDCIDFontType0Font.java
@@ -16,20 +16,27 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
 import java.io.IOException;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSName;
 
 /**
  * This is implementation of the CIDFontType0 Font.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.6 $
+ * 
  */
 public class PDCIDFontType0Font extends PDCIDFont
 {
+    /**
+     * Log instance.
+     */
+    private static final Log LOG = LogFactory.getLog(PDCIDFontType0Font.class);
+
+    private PDType1CFont type1CFont = null;
 
     /**
      * Constructor.
@@ -37,46 +44,42 @@ public class PDCIDFontType0Font extends PDCIDFont
     public PDCIDFontType0Font()
     {
         super();
-        font.setItem( COSName.SUBTYPE, COSName.CID_FONT_TYPE0 );
+        font.setItem(COSName.SUBTYPE, COSName.CID_FONT_TYPE0);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDCIDFontType0Font( COSDictionary fontDictionary )
-    {
-        super( fontDictionary );
-    }
-
-    /**
-     * Returns the AWT font that corresponds with this CIDFontType0 font.
-     * By default we try to look up a system font with the same name. If that
-     * fails and the font file is embedded in the PDF document, we try to
-     * generate the AWT font using the {@link PDType1CFont} class. Ideally
-     * the embedded font would be used always if available, but since the
-     * code doesn't work correctly for all fonts yet we opt to use the
-     * system font by default.
-     *
-     * @return AWT font, or <code>null</code> if not available
-     */
-    public Font getawtFont() throws IOException
+    public PDCIDFontType0Font(COSDictionary fontDictionary)
     {
+        super(fontDictionary);
         PDFontDescriptor fd = getFontDescriptor();
-        Font awtFont = FontManager.getAwtFont(fd.getFontName());
-
-        if (awtFont == null && fd instanceof PDFontDescriptorDictionary) {
+        if (fd instanceof PDFontDescriptorDictionary)
+        {
             PDFontDescriptorDictionary fdd = (PDFontDescriptorDictionary) fd;
-            if (fdd.getFontFile3() != null) {
-                // Create a font with the embedded data
-                // TODO: This still doesn't work right for
-                // some embedded fonts
-                awtFont = new PDType1CFont(font).getawtFont();
+            if (fdd.getFontFile3() != null)
+            {
+                try
+                {
+                    type1CFont = new PDType1CFont(font);
+                }
+                catch (IOException exception)
+                {
+                    LOG.error("Can't create the embedded CFF-font", exception);
+                }
             }
         }
-
-        return awtFont;
     }
 
+    /**
+     * Returns the embedded Type1CFont.
+     * 
+     * @return the Type1C font
+     */
+    public PDType1CFont getType1CFont()
+    {
+        return type1CFont;
+    }
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
index 440664b4a0..54fd354d67 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDFont.java
@@ -24,7 +24,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.apache.fontbox.afm.AFMParser;
 import org.apache.fontbox.afm.FontMetric;
 import org.apache.fontbox.cmap.CMap;
 import org.apache.fontbox.cmap.CMapParser;
@@ -34,13 +33,11 @@ import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSFloat;
 import org.apache.pdfbox.cos.COSInteger;
 import org.apache.pdfbox.cos.COSName;
-import org.apache.pdfbox.cos.COSString;
 import org.apache.pdfbox.encoding.Encoding;
 import org.apache.pdfbox.pdmodel.common.COSArrayList;
 import org.apache.pdfbox.pdmodel.common.COSObjectable;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
-import org.apache.pdfbox.util.ResourceLoader;
 
 /**
  * This is the base class for all PDF fonts.
@@ -90,61 +87,7 @@ public abstract class PDFont implements COSObjectable
      */
     private List<Integer> widths = null;
 
-    /**
-     * The static map of the default Adobe font metrics.
-     */
-    private static final Map<String, FontMetric> afmObjects = Collections.unmodifiableMap(getAdobeFontMetrics());
-
-    // TODO move the Map to PDType1Font as these are the 14 Standard fonts
-    // which are definitely Type 1 fonts
-    private static Map<String, FontMetric> getAdobeFontMetrics()
-    {
-        Map<String, FontMetric> metrics = new HashMap<String, FontMetric>();
-        addAdobeFontMetric(metrics, "Courier-Bold");
-        addAdobeFontMetric(metrics, "Courier-BoldOblique");
-        addAdobeFontMetric(metrics, "Courier");
-        addAdobeFontMetric(metrics, "Courier-Oblique");
-        addAdobeFontMetric(metrics, "Helvetica");
-        addAdobeFontMetric(metrics, "Helvetica-Bold");
-        addAdobeFontMetric(metrics, "Helvetica-BoldOblique");
-        addAdobeFontMetric(metrics, "Helvetica-Oblique");
-        addAdobeFontMetric(metrics, "Symbol");
-        addAdobeFontMetric(metrics, "Times-Bold");
-        addAdobeFontMetric(metrics, "Times-BoldItalic");
-        addAdobeFontMetric(metrics, "Times-Italic");
-        addAdobeFontMetric(metrics, "Times-Roman");
-        addAdobeFontMetric(metrics, "ZapfDingbats");
-        return metrics;
-    }
-
     protected static final String resourceRootCMAP = "org/apache/pdfbox/resources/cmap/";
-    private static final String resourceRootAFM = "org/apache/pdfbox/resources/afm/";
-
-    private static void addAdobeFontMetric(Map<String, FontMetric> metrics, String name)
-    {
-        try
-        {
-            String resource = resourceRootAFM + name + ".afm";
-            InputStream afmStream = ResourceLoader.loadResource(resource);
-            if (afmStream != null)
-            {
-                try
-                {
-                    AFMParser parser = new AFMParser(afmStream);
-                    parser.parse();
-                    metrics.put(name, parser.getResult());
-                }
-                finally
-                {
-                    afmStream.close();
-                }
-            }
-        }
-        catch (Exception e)
-        {
-            // ignore
-        }
-    }
 
     /**
      * This will clear AFM resources that are stored statically. This is usually not a problem unless you want to
@@ -197,7 +140,7 @@ public abstract class PDFont implements COSObjectable
             }
             else
             {
-                getAFM();
+                FontMetric afm = getAFM();
                 if (afm != null)
                 {
                     fontDescriptor = new PDFontDescriptorAFM(afm);
@@ -359,34 +302,9 @@ public abstract class PDFont implements COSObjectable
      */
     protected FontMetric getAFM()
     {
-        if (isType1Font() && afm == null)
-        {
-            COSBase baseFont = font.getDictionaryObject(COSName.BASE_FONT);
-            String name = null;
-            if (baseFont instanceof COSName)
-            {
-                name = ((COSName) baseFont).getName();
-                if (name.indexOf("+") > -1)
-                {
-                    name = name.substring(name.indexOf("+") + 1);
-                }
-
-            }
-            else if (baseFont instanceof COSString)
-            {
-                COSString string = (COSString) baseFont;
-                name = string.getString();
-            }
-            if (name != null)
-            {
-                afm = afmObjects.get(name);
-            }
-        }
-        return afm;
+        return null;
     }
 
-    private FontMetric afm = null;
-
     private COSBase encoding = null;
 
     /**
@@ -546,6 +464,13 @@ public abstract class PDFont implements COSObjectable
         return retval;
     }
 
+    /**
+     * Parse the given CMap.
+     * 
+     * @param cmapRoot the root path pointing to the provided CMaps
+     * @param cmapStream the CMap to be read
+     * @return the parsed CMap
+     */
     protected CMap parseCmap(String cmapRoot, InputStream cmapStream)
     {
         CMap targetCmap = null;
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
index 8cb4337298..4ca71ab904 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDSimpleFont.java
@@ -16,17 +16,12 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
-import java.awt.font.GlyphVector;
 import java.io.IOException;
-
 import java.util.HashMap;
 
-import org.apache.fontbox.afm.FontMetric;
-
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
+import org.apache.fontbox.afm.FontMetric;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
@@ -36,33 +31,30 @@ import org.apache.pdfbox.cos.COSStream;
 import org.apache.pdfbox.encoding.DictionaryEncoding;
 import org.apache.pdfbox.encoding.Encoding;
 import org.apache.pdfbox.encoding.EncodingManager;
-
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
 import org.apache.pdfbox.util.ResourceLoader;
 
 /**
  * This class contains implementation details of the simple pdf fonts.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.18 $
+ * 
  */
 public abstract class PDSimpleFont extends PDFont
 {
-    private final HashMap<Integer, Float> mFontSizes =
-        new HashMap<Integer, Float>(128);
+    private final HashMap<Integer, Float> mFontSizes = new HashMap<Integer, Float>(128);
 
     private float avgFontWidth = 0.0f;
     private float avgFontHeight = 0.0f;
-    private float fontWidthOfSpace = -1f; 
-
-    private static final byte[] SPACE_BYTES = { (byte)32 };
+    private float fontWidthOfSpace = -1f;
 
+    private static final byte[] SPACE_BYTES = { (byte) 32 };
 
     /**
      * Log instance.
      */
     private static final Log LOG = LogFactory.getLog(PDSimpleFont.class);
-    
+
     /**
      * Constructor.
      */
@@ -73,38 +65,26 @@ public abstract class PDSimpleFont extends PDFont
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDSimpleFont( COSDictionary fontDictionary )
+    public PDSimpleFont(COSDictionary fontDictionary)
     {
-        super( fontDictionary );
+        super(fontDictionary);
     }
 
-    /**
-    * Looks up, creates, returns  the AWT Font.
-    * 
-    * @return returns the awt font to bes used for rendering 
-    * @throws IOException if something went wrong.
-    */
-    public Font getawtFont() throws IOException
-    {
-        LOG.error("Not yet implemented:" + getClass().getName() );
-        return null;
-    }
-    
     /**
      * This will get the font height for a character.
-     *
+     * 
      * @param c The character code to get the width for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public float getFontHeight( byte[] c, int offset, int length ) throws IOException
+    public float getFontHeight(byte[] c, int offset, int length) throws IOException
     {
         // maybe there is already a precalculated value
         if (avgFontHeight > 0)
@@ -113,17 +93,17 @@ public abstract class PDSimpleFont extends PDFont
         }
         float retval = 0;
         FontMetric metric = getAFM();
-        if( metric != null )
+        if (metric != null)
         {
-            int code = getCodeFromArray( c, offset, length );
+            int code = getCodeFromArray(c, offset, length);
             Encoding encoding = getFontEncoding();
-            String characterName = encoding.getName( code );
-            retval = metric.getCharacterHeight( characterName );
+            String characterName = encoding.getName(code);
+            retval = metric.getCharacterHeight(characterName);
         }
         else
         {
             PDFontDescriptor desc = getFontDescriptor();
-            if( desc != null )
+            if (desc != null)
             {
                 // the following values are all more or less accurate
                 // at least all are average values. Maybe we'll find
@@ -134,15 +114,15 @@ public abstract class PDSimpleFont extends PDFont
                 {
                     retval = fontBBox.getHeight() / 2;
                 }
-                if( retval == 0 )
+                if (retval == 0)
                 {
                     retval = desc.getCapHeight();
                 }
-                if( retval == 0 )
+                if (retval == 0)
                 {
                     retval = desc.getAscent();
                 }
-                if( retval == 0 )
+                if (retval == 0)
                 {
                     retval = desc.getXHeight();
                     if (retval > 0)
@@ -158,26 +138,26 @@ public abstract class PDSimpleFont extends PDFont
 
     /**
      * This will get the font width for a character.
-     *
+     * 
      * @param c The character code to get the width for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public float getFontWidth( byte[] c, int offset, int length ) throws IOException
+    public float getFontWidth(byte[] c, int offset, int length) throws IOException
     {
-        int code = getCodeFromArray( c, offset, length );
+        int code = getCodeFromArray(c, offset, length);
         Float fontWidth = mFontSizes.get(code);
         if (fontWidth == null)
         {
             fontWidth = getFontWidth(code);
             if (fontWidth <= 0)
             {
-                //hmm should this be in PDType1Font??
-                fontWidth = getFontWidthFromAFMFile( code );
+                // TODO should this be in PDType1Font??
+                fontWidth = getFontWidthFromAFMFile(code);
             }
             mFontSizes.put(code, fontWidth);
         }
@@ -186,16 +166,15 @@ public abstract class PDSimpleFont extends PDFont
 
     /**
      * This will get the average font width for all characters.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
     public float getAverageFontWidth() throws IOException
     {
         float average = 0.0f;
 
-        //AJW
         if (avgFontWidth != 0.0f)
         {
             average = avgFontWidth;
@@ -204,13 +183,13 @@ public abstract class PDSimpleFont extends PDFont
         {
             float totalWidth = 0.0f;
             float characterCount = 0.0f;
-            COSArray widths = (COSArray)font.getDictionaryObject( COSName.WIDTHS );
-            if( widths != null )
+            COSArray widths = (COSArray) font.getDictionaryObject(COSName.WIDTHS);
+            if (widths != null)
             {
-                for( int i=0; i<widths.size(); i++ )
+                for (int i = 0; i < widths.size(); i++)
                 {
-                    COSNumber fontWidth = (COSNumber)widths.getObject( i );
-                    if( fontWidth.floatValue() > 0 )
+                    COSNumber fontWidth = (COSNumber) widths.getObject(i);
+                    if (fontWidth.floatValue() > 0)
                     {
                         totalWidth += fontWidth.floatValue();
                         characterCount += 1;
@@ -218,7 +197,7 @@ public abstract class PDSimpleFont extends PDFont
                 }
             }
 
-            if( totalWidth > 0 )
+            if (totalWidth > 0)
             {
                 average = totalWidth / characterCount;
             }
@@ -231,32 +210,31 @@ public abstract class PDSimpleFont extends PDFont
         return average;
     }
 
-    
     /**
      * This will get the ToUnicode object.
-     *
+     * 
      * @return The ToUnicode object.
      */
     public COSBase getToUnicode()
     {
-        return font.getDictionaryObject( COSName.TO_UNICODE );
+        return font.getDictionaryObject(COSName.TO_UNICODE);
     }
 
     /**
      * This will set the ToUnicode object.
-     *
+     * 
      * @param unicode The unicode object.
      */
-    public void setToUnicode( COSBase unicode )
+    public void setToUnicode(COSBase unicode)
     {
-        font.setItem( COSName.TO_UNICODE, unicode );
+        font.setItem(COSName.TO_UNICODE, unicode);
     }
 
     /**
      * This will get the fonts bounding box.
-     *
+     * 
      * @return The fonts bouding box.
-     *
+     * 
      * @throws IOException If there is an error getting the bounding box.
      */
     public PDRectangle getFontBoundingBox() throws IOException
@@ -271,78 +249,77 @@ public abstract class PDSimpleFont extends PDFont
     {
         String cmapName = null;
         COSName encodingName = null;
-        COSBase encoding = getEncoding(); 
+        COSBase encoding = getEncoding();
         Encoding fontEncoding = null;
-        if (encoding != null) 
+        if (encoding != null)
         {
-            if (encoding instanceof COSName) 
+            if (encoding instanceof COSName)
             {
                 if (cmap == null)
                 {
-                    encodingName = (COSName)encoding;
-                    cmap = cmapObjects.get( encodingName.getName() );
-                    if (cmap == null) 
+                    encodingName = (COSName) encoding;
+                    cmap = cmapObjects.get(encodingName.getName());
+                    if (cmap == null)
                     {
                         cmapName = encodingName.getName();
                     }
                 }
                 if (cmap == null && cmapName != null)
                 {
-                    try 
+                    try
                     {
-                        fontEncoding =
-                            EncodingManager.INSTANCE.getEncoding(encodingName);
+                        fontEncoding = EncodingManager.INSTANCE.getEncoding(encodingName);
                     }
-                    catch(IOException exception) 
+                    catch (IOException exception)
                     {
-                        LOG.debug("Debug: Could not find encoding for " + encodingName );
+                        LOG.debug("Debug: Could not find encoding for " + encodingName);
                     }
                 }
             }
-            else if(encoding instanceof COSStream )
+            else if (encoding instanceof COSStream)
             {
                 if (cmap == null)
                 {
-                    COSStream encodingStream = (COSStream)encoding;
-                    try 
+                    COSStream encodingStream = (COSStream) encoding;
+                    try
                     {
-                        cmap = parseCmap( null, encodingStream.getUnfilteredStream() );
+                        cmap = parseCmap(null, encodingStream.getUnfilteredStream());
                     }
-                    catch(IOException exception) 
+                    catch (IOException exception)
                     {
-                        LOG.error("Error: Could not parse the embedded CMAP" );
+                        LOG.error("Error: Could not parse the embedded CMAP");
                     }
                 }
             }
-            else if (encoding instanceof COSDictionary) 
+            else if (encoding instanceof COSDictionary)
             {
-                try 
+                try
                 {
-                    fontEncoding = new DictionaryEncoding((COSDictionary)encoding);
+                    fontEncoding = new DictionaryEncoding((COSDictionary) encoding);
                 }
-                catch(IOException exception) 
+                catch (IOException exception)
                 {
-                    LOG.error("Error: Could not create the DictionaryEncoding" );
+                    LOG.error("Error: Could not create the DictionaryEncoding");
                 }
             }
         }
         setFontEncoding(fontEncoding);
         extractToUnicodeEncoding();
 
-        if (cmap == null && cmapName != null) 
+        if (cmap == null && cmapName != null)
         {
             String resourceName = resourceRootCMAP + cmapName;
-            try 
+            try
             {
-                cmap = parseCmap( resourceRootCMAP, ResourceLoader.loadResource( resourceName ) );
-                if( cmap == null && encodingName == null)
+                cmap = parseCmap(resourceRootCMAP, ResourceLoader.loadResource(resourceName));
+                if (cmap == null && encodingName == null)
                 {
-                    LOG.error("Error: Could not parse predefined CMAP file for '" + cmapName + "'" );
+                    LOG.error("Error: Could not parse predefined CMAP file for '" + cmapName + "'");
                 }
             }
-            catch(IOException exception) 
+            catch (IOException exception)
             {
-                LOG.error("Error: Could not find predefined CMAP file for '" + cmapName + "'" );
+                LOG.error("Error: Could not find predefined CMAP file for '" + cmapName + "'");
             }
         }
     }
@@ -352,50 +329,50 @@ public abstract class PDSimpleFont extends PDFont
         COSName encodingName = null;
         String cmapName = null;
         COSBase toUnicode = getToUnicode();
-        if( toUnicode != null )
+        if (toUnicode != null)
         {
             setHasToUnicode(true);
-            if ( toUnicode instanceof COSStream )
+            if (toUnicode instanceof COSStream)
             {
-                try 
+                try
                 {
-                    toUnicodeCmap = parseCmap( resourceRootCMAP, ((COSStream)toUnicode).getUnfilteredStream());
+                    toUnicodeCmap = parseCmap(resourceRootCMAP, ((COSStream) toUnicode).getUnfilteredStream());
                 }
-                catch(IOException exception) 
+                catch (IOException exception)
                 {
-                    LOG.error("Error: Could not load embedded ToUnicode CMap" );
+                    LOG.error("Error: Could not load embedded ToUnicode CMap");
                 }
             }
-            else if ( toUnicode instanceof COSName)
+            else if (toUnicode instanceof COSName)
             {
-                encodingName = (COSName)toUnicode;
-                toUnicodeCmap = cmapObjects.get( encodingName.getName() );
-                if (toUnicodeCmap == null) 
+                encodingName = (COSName) toUnicode;
+                toUnicodeCmap = cmapObjects.get(encodingName.getName());
+                if (toUnicodeCmap == null)
                 {
                     cmapName = encodingName.getName();
                     String resourceName = resourceRootCMAP + cmapName;
-                    try 
+                    try
                     {
-                        toUnicodeCmap = parseCmap( resourceRootCMAP, ResourceLoader.loadResource( resourceName ));
+                        toUnicodeCmap = parseCmap(resourceRootCMAP, ResourceLoader.loadResource(resourceName));
                     }
-                    catch(IOException exception) 
+                    catch (IOException exception)
                     {
-                        LOG.error("Error: Could not find predefined ToUnicode CMap file for '" + cmapName + "'" );
+                        LOG.error("Error: Could not find predefined ToUnicode CMap file for '" + cmapName + "'");
                     }
-                    if( toUnicodeCmap == null)
+                    if (toUnicodeCmap == null)
                     {
-                        LOG.error("Error: Could not parse predefined ToUnicode CMap file for '" + cmapName + "'" );
+                        LOG.error("Error: Could not parse predefined ToUnicode CMap file for '" + cmapName + "'");
                     }
                 }
             }
         }
     }
-    
+
     private boolean isFontSubstituted = false;
-    
+
     /**
-     * This will get the value for isFontSubstituted, which indicates
-     * if the font was substituted due to a problem with the embedded one.
+     * This will get the value for isFontSubstituted, which indicates if the font was substituted due to a problem with
+     * the embedded one.
      * 
      * @return true if the font was substituted
      */
@@ -403,13 +380,13 @@ public abstract class PDSimpleFont extends PDFont
     {
         return isFontSubstituted;
     }
-    
+
     /**
-     * This will set  the value for isFontSubstituted.
+     * This will set the value for isFontSubstituted.
      * 
      * @param isSubstituted true if the font was substituted
      */
-    protected void setIsFontSubstituted(boolean isSubstituted)
+    public void setIsFontSubstituted(boolean isSubstituted)
     {
         isFontSubstituted = isSubstituted;
     }
@@ -422,9 +399,9 @@ public abstract class PDSimpleFont extends PDFont
         if (fontWidthOfSpace == -1f)
         {
             COSBase toUnicode = getToUnicode();
-            try 
+            try
             {
-                if (toUnicode != null) 
+                if (toUnicode != null)
                 {
                     int spaceMapping = toUnicodeCmap.getSpaceMapping();
                     if (spaceMapping > -1)
@@ -434,7 +411,7 @@ public abstract class PDSimpleFont extends PDFont
                 }
                 else
                 {
-                    fontWidthOfSpace = getFontWidth( SPACE_BYTES, 0, 1 );
+                    fontWidthOfSpace = getFontWidth(SPACE_BYTES, 0, 1);
                 }
                 // use the average font width as fall back
                 if (fontWidthOfSpace <= 0)
@@ -442,7 +419,7 @@ public abstract class PDSimpleFont extends PDFont
                     fontWidthOfSpace = getAverageFontWidth();
                 }
             }
-            catch (Exception e) 
+            catch (Exception e)
             {
                 LOG.error("Can't determine the width of the space character using 250 as default", e);
                 fontWidthOfSpace = 250f;
@@ -450,16 +427,5 @@ public abstract class PDSimpleFont extends PDFont
         }
         return fontWidthOfSpace;
     }
-    
-    /**
-     * Remap glyphs.
-     * 
-     * @param glyphVector glyph vector to be remapped
-     * @param string the represented string
-     * @return the remapped glyph vector
-     */
-    public GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
-    {
-        return glyphVector;
-    }
+
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
index cdf6c0b4c5..c56dee4e97 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDTrueTypeFont.java
@@ -16,7 +16,6 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -29,8 +28,6 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Properties;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.fontbox.ttf.CMAPEncodingEntry;
 import org.apache.fontbox.ttf.CMAPTable;
 import org.apache.fontbox.ttf.GlyphData;
@@ -62,18 +59,11 @@ import org.apache.pdfbox.util.ResourceLoader;
 public class PDTrueTypeFont extends PDSimpleFont
 {
 
-    /**
-     * Log instance.
-     */
-    private static final Log LOG = LogFactory.getLog(PDTrueTypeFont.class);
-
     /**
      * This is the key to a property in the PDFBox_External_Fonts.properties file to load a Font when a mapping does not
      * exist for the current font.
      */
-    public static final String UNKNOWN_FONT = "UNKNOWN_FONT";
-
-    private Font awtFont = null;
+    private static final String UNKNOWN_FONT = "UNKNOWN_FONT";
 
     private static Properties externalFonts = new Properties();
     private static Map<String, TrueTypeFont> loadedExternalFonts = new HashMap<String, TrueTypeFont>();
@@ -405,19 +395,6 @@ public class PDTrueTypeFont extends PDSimpleFont
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public Font getawtFont() throws IOException
-    {
-        // TODO remove if no longer needed
-        // fallback if getTTFFont doesn't provides a suitable font
-        awtFont = FontManager.getStandardFont();
-        LOG.info("Using font " + awtFont.getName() + " instead");
-        setIsFontSubstituted(true);
-        return awtFont;
-    }
-
     /**
      * Permit to load an external TTF Font program file
      * 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
index 578191687c..1d2a302606 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType0Font.java
@@ -16,7 +16,6 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
 import java.io.IOException;
 
 import org.apache.commons.logging.Log;
@@ -27,12 +26,10 @@ import org.apache.pdfbox.cos.COSName;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
 
 /**
- * This is implementation of the Type0 Font.
- * See <a href="https://issues.apache.org/jira/browse/PDFBOX-605">PDFBOX-605</a>
- * for the related improvement issue.
- *
+ * This is implementation of the Type0 Font. See <a
+ * href="https://issues.apache.org/jira/browse/PDFBOX-605">PDFBOX-605</a> for the related improvement issue.
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.9 $
  */
 public class PDType0Font extends PDSimpleFont
 {
@@ -45,30 +42,30 @@ public class PDType0Font extends PDSimpleFont
     private COSArray descendantFontArray;
     private PDFont descendantFont;
     private COSDictionary descendantFontDictionary;
-    private Font awtFont;
+
     /**
      * Constructor.
      */
     public PDType0Font()
     {
         super();
-        font.setItem( COSName.SUBTYPE, COSName.TYPE0 );
+        font.setItem(COSName.SUBTYPE, COSName.TYPE0);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDType0Font( COSDictionary fontDictionary )
+    public PDType0Font(COSDictionary fontDictionary)
     {
-        super( fontDictionary );
-        descendantFontDictionary = (COSDictionary)getDescendantFonts().getObject( 0 );
+        super(fontDictionary);
+        descendantFontDictionary = (COSDictionary) getDescendantFonts().getObject(0);
         if (descendantFontDictionary != null)
         {
             try
             {
-                descendantFont = PDFontFactory.createFont( descendantFontDictionary );
+                descendantFont = PDFontFactory.createFont(descendantFontDictionary);
             }
             catch (IOException exception)
             {
@@ -77,86 +74,55 @@ public class PDType0Font extends PDSimpleFont
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    public Font getawtFont() throws IOException
-    {
-        if (awtFont == null)
-        {
-            if (descendantFont != null)
-            {
-                awtFont = ((PDSimpleFont)descendantFont).getawtFont();
-                if (awtFont != null)
-                {
-                    setIsFontSubstituted(((PDSimpleFont)descendantFont).isFontSubstituted());
-                    /*
-                     * Fix Oracle JVM Crashes.
-                     * Tested with Oracle JRE 6.0_45-b06 and 7.0_21-b11
-                     */
-                    awtFont.canDisplay(1);
-                }
-            }
-            if (awtFont == null)
-            {
-                awtFont = FontManager.getStandardFont();
-                LOG.info("Using font "+awtFont.getName()
-                        + " instead of "+descendantFont.getFontDescriptor().getFontName());
-                setIsFontSubstituted(true);
-            }
-        }
-        return awtFont;
-    }
-
     /**
      * This will get the fonts bounding box.
-     *
+     * 
      * @return The fonts bounding box.
-     *
+     * 
      * @throws IOException If there is an error getting the bounding box.
      */
     public PDRectangle getFontBoundingBox() throws IOException
     {
-        throw new RuntimeException( "Not yet implemented" );
+        throw new RuntimeException("Not yet implemented");
     }
 
     /**
      * This will get the font width for a character.
-     *
+     * 
      * @param c The character code to get the width for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public float getFontWidth( byte[] c, int offset, int length ) throws IOException
+    public float getFontWidth(byte[] c, int offset, int length) throws IOException
     {
-        return descendantFont.getFontWidth( c, offset, length );
+        return descendantFont.getFontWidth(c, offset, length);
     }
 
     /**
      * This will get the font height for a character.
-     *
+     * 
      * @param c The character code to get the height for.
      * @param offset The offset into the array.
      * @param length The length of the data.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
-    public float getFontHeight( byte[] c, int offset, int length ) throws IOException
+    public float getFontHeight(byte[] c, int offset, int length) throws IOException
     {
-        return descendantFont.getFontHeight( c, offset, length );
+        return descendantFont.getFontHeight(c, offset, length);
     }
 
     /**
      * This will get the average font width for all characters.
-     *
+     * 
      * @return The width is in 1000 unit of text space, ie 333 or 777
-     *
+     * 
      * @throws IOException If an error occurs while parsing.
      */
     public float getAverageFontWidth() throws IOException
@@ -168,7 +134,7 @@ public class PDType0Font extends PDSimpleFont
     {
         if (descendantFontArray == null)
         {
-            descendantFontArray = (COSArray)font.getDictionaryObject( COSName.DESCENDANT_FONTS );
+            descendantFontArray = (COSArray) font.getDictionaryObject(COSName.DESCENDANT_FONTS);
         }
         return descendantFontArray;
     }
@@ -176,7 +142,7 @@ public class PDType0Font extends PDSimpleFont
     /**
      * {@inheritDoc}
      */
-    public float getFontWidth( int charCode )
+    public float getFontWidth(int charCode)
     {
         return descendantFont.getFontWidth(charCode);
     }
@@ -184,7 +150,7 @@ public class PDType0Font extends PDSimpleFont
     @Override
     public String encode(byte[] c, int offset, int length) throws IOException
     {
-    	String retval = null;
+        String retval = null;
         if (hasToUnicode())
         {
             retval = super.encode(c, offset, length);
@@ -202,13 +168,15 @@ public class PDType0Font extends PDSimpleFont
     }
 
     /**
-     *
+     * 
      * Provides the descendant font.
+     * 
      * @return the descendant font.
-     *
+     * 
      */
     public PDFont getDescendantFont()
     {
         return descendantFont;
     }
+
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1CFont.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1CFont.java
index 4255656a98..60163159ba 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1CFont.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1CFont.java
@@ -17,57 +17,45 @@
 
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
-import java.awt.FontFormatException;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Iterator;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-
 import org.apache.fontbox.afm.AFMParser;
 import org.apache.fontbox.afm.FontMetric;
 import org.apache.fontbox.cff.AFMFormatter;
-import org.apache.fontbox.cff.charset.CFFCharset;
-import org.apache.fontbox.cff.encoding.CFFEncoding;
 import org.apache.fontbox.cff.CFFFont;
 import org.apache.fontbox.cff.CFFParser;
-import org.apache.fontbox.cff.Type1FontFormatter;
 import org.apache.fontbox.util.BoundingBox;
-
 import org.apache.pdfbox.cos.COSArray;
-import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSFloat;
-import org.apache.pdfbox.cos.COSName;
-import org.apache.pdfbox.cos.COSNumber;
 import org.apache.pdfbox.encoding.Encoding;
-import org.apache.pdfbox.encoding.EncodingManager;
-import org.apache.pdfbox.exceptions.WrappedIOException;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDRectangle;
 import org.apache.pdfbox.pdmodel.common.PDStream;
 
 /**
  * This class represents a CFF/Type2 Font (aka Type1C Font).
+ * 
  * @author Villu Ruusmann
- * @version $Revision: 10.0$
+ * 
  */
 public class PDType1CFont extends PDSimpleFont
 {
     private CFFFont cffFont = null;
 
+    private String fontname = null;
+
     private Map<Integer, String> codeToName = new HashMap<Integer, String>();
 
     private Map<Integer, String> codeToCharacter = new HashMap<Integer, String>();
@@ -76,8 +64,6 @@ public class PDType1CFont extends PDSimpleFont
 
     private FontMetric fontMetric = null;
 
-    private Font awtFont = null;
-
     private Map<String, Float> glyphWidths = new HashMap<String, Float>();
 
     private Map<String, Float> glyphHeights = new HashMap<String, Float>();
@@ -88,86 +74,82 @@ public class PDType1CFont extends PDSimpleFont
 
     private static final Log LOG = LogFactory.getLog(PDType1CFont.class);
 
-    private static final byte[] SPACE_BYTES = {(byte)32};
+    private static final byte[] SPACE_BYTES = { (byte) 32 };
 
-    private COSDictionary fontDict = null;
-    
     private Map<Integer, Integer> codeToGlyph = new HashMap<Integer, Integer>();
-    
+
     /**
      * Constructor.
      * 
      * @param fontDictionary the corresponding dictionary
-     * @throws IOException it somethin went wrong
+     * @throws IOException it something went wrong
      */
-    public PDType1CFont( COSDictionary fontDictionary ) throws IOException
+    public PDType1CFont(COSDictionary fontDictionary) throws IOException
     {
-        super( fontDictionary );
-        fontDict = fontDictionary;
+        super(fontDictionary);
         load();
     }
 
     /**
      * {@inheritDoc}
      */
-    public String encode( byte[] bytes, int offset, int length ) throws IOException
+    public String encode(byte[] bytes, int offset, int length) throws IOException
     {
         String character = getCharacter(bytes, offset, length);
-        if( character == null )
+        if (character == null)
         {
-            LOG.debug("No character for code " + (bytes[offset] & 0xff) + " in " + this.cffFont.getName());
+            LOG.debug("No character for code " + (bytes[offset] & 0xff) + " in " + fontname);
             return null;
         }
 
         return character;
     }
-    
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public int encodeToCID( byte[] bytes, int offset, int length )
+    public int encodeToCID(byte[] bytes, int offset, int length)
     {
-      if (length > 2)
-      {
-          return -1;
-      }
-      int code = bytes[offset] & 0xff;
-      if (length == 2)
-      {
-          code = code * 256 + bytes[offset+1] & 0xff;
-      }
-      return code;
+        if (length > 2)
+        {
+            return -1;
+        }
+        int code = bytes[offset] & 0xff;
+        if (length == 2)
+        {
+            code = code * 256 + bytes[offset + 1] & 0xff;
+        }
+        return code;
     }
-    
-    private String getCharacter( byte[] bytes, int offset, int length )
+
+    private String getCharacter(byte[] bytes, int offset, int length)
     {
         int code = encodeToCID(bytes, offset, length);
-        if (code == -1) 
+        if (code == -1)
         {
             return null;
         }
-        return (String)this.codeToCharacter.get(code);
+        return (String) codeToCharacter.get(code);
     }
 
     /**
      * {@inheritDoc}
      */
-    public float getFontWidth( byte[] bytes, int offset, int length ) throws IOException
+    public float getFontWidth(byte[] bytes, int offset, int length) throws IOException
     {
         String name = getName(bytes, offset, length);
-        if( name == null && !Arrays.equals(SPACE_BYTES, bytes) )
+        if (name == null && !Arrays.equals(SPACE_BYTES, bytes))
         {
-            LOG.debug("No name for code " + (bytes[offset] & 0xff) + " in " + this.cffFont.getName());
-
+            LOG.debug("No name for code " + (bytes[offset] & 0xff) + " in " + fontname);
             return 0;
         }
 
-        Float width = (Float)this.glyphWidths.get(name);
-        if( width == null )
+        Float width = (Float) glyphWidths.get(name);
+        if (width == null)
         {
             width = Float.valueOf(getFontMetric().getCharacterWidth(name));
-            this.glyphWidths.put(name, width);
+            glyphWidths.put(name, width);
         }
 
         return width.floatValue();
@@ -176,70 +158,69 @@ public class PDType1CFont extends PDSimpleFont
     /**
      * {@inheritDoc}
      */
-    public float getFontHeight( byte[] bytes, int offset, int length ) throws IOException
+    public float getFontHeight(byte[] bytes, int offset, int length) throws IOException
     {
         String name = getName(bytes, offset, length);
-        if( name == null )
+        if (name == null)
         {
-            LOG.debug("No name for code " + (bytes[offset] & 0xff) + " in " + this.cffFont.getName());
+            LOG.debug("No name for code " + (bytes[offset] & 0xff) + " in " + fontname);
 
             return 0;
         }
 
-        Float height = (Float)this.glyphHeights.get(name);
-        if( height == null )
+        float height = 0;
+        if (!glyphHeights.containsKey(name))
         {
-            height = Float.valueOf(getFontMetric().getCharacterHeight(name));
-            this.glyphHeights.put(name, height);
+            height = getFontMetric().getCharacterHeight(name);
+            glyphHeights.put(name, height);
         }
-
-        return height.floatValue();
+        return height;
     }
 
-    private String getName( byte[] bytes, int offset, int length )
+    private String getName(byte[] bytes, int offset, int length)
     {
         if (length > 2)
         {
             return null;
         }
-        
+
         int code = bytes[offset] & 0xff;
         if (length == 2)
         {
-            code = code * 256 + bytes[offset+1] & 0xff;
+            code = code * 256 + bytes[offset + 1] & 0xff;
         }
 
-        return (String)this.codeToName.get(code);
+        return codeToName.get(code);
     }
 
     /**
      * {@inheritDoc}
      */
-    public float getStringWidth( String string ) throws IOException
+    public float getStringWidth(String string) throws IOException
     {
         float width = 0;
 
-        for( int i = 0; i < string.length(); i++ )
+        for (int i = 0; i < string.length(); i++)
         {
             String character = string.substring(i, i + 1);
 
             Integer code = getCode(character);
-            if( code == null )
+            if (code == null)
             {
                 LOG.debug("No code for character " + character);
 
                 return 0;
             }
 
-            width += getFontWidth(new byte[]{(byte)code.intValue()}, 0, 1);
+            width += getFontWidth(new byte[] { (byte) code.intValue() }, 0, 1);
         }
 
         return width;
     }
 
-    private Integer getCode( String character )
+    private Integer getCode(String character)
     {
-        return (Integer)this.characterToCode.get(character);
+        return characterToCode.get(character);
     }
 
     /**
@@ -248,7 +229,7 @@ public class PDType1CFont extends PDSimpleFont
      * @param code the character code
      * @return the glyph index
      */
-    protected Integer getGlyphIndex(int code) 
+    protected Integer getGlyphIndex(int code)
     {
         return codeToGlyph.get(code);
     }
@@ -258,12 +239,12 @@ public class PDType1CFont extends PDSimpleFont
      */
     public float getAverageFontWidth() throws IOException
     {
-        if( this.avgWidth == null )
+        if (avgWidth == null)
         {
-            this.avgWidth = Float.valueOf(getFontMetric().getAverageCharacterWidth());
+            avgWidth = getFontMetric().getAverageCharacterWidth();
         }
 
-        return this.avgWidth.floatValue();
+        return avgWidth.floatValue();
     }
 
     /**
@@ -271,12 +252,12 @@ public class PDType1CFont extends PDSimpleFont
      */
     public PDRectangle getFontBoundingBox() throws IOException
     {
-        if( this.fontBBox == null )
+        if (fontBBox == null)
         {
-            this.fontBBox = new PDRectangle(getFontMetric().getFontBBox());
+            fontBBox = new PDRectangle(getFontMetric().getFontBBox());
         }
 
-        return this.fontBBox;
+        return fontBBox;
     }
 
     /**
@@ -284,13 +265,13 @@ public class PDType1CFont extends PDSimpleFont
      */
     public PDMatrix getFontMatrix()
     {
-        if( fontMatrix == null )
+        if (fontMatrix == null)
         {
-            List<Number> numbers = (List<Number>)this.cffFont.getProperty("FontMatrix");
-            if( numbers != null && numbers.size() == 6 )
+            List<Number> numbers = (List<Number>) cffFont.getProperty("FontMatrix");
+            if (numbers != null && numbers.size() == 6)
             {
                 COSArray array = new COSArray();
-                for(Number number : numbers)
+                for (Number number : numbers)
                 {
                     array.add(new COSFloat(number.floatValue()));
                 }
@@ -304,19 +285,7 @@ public class PDType1CFont extends PDSimpleFont
         return fontMatrix;
     }
 
-    /**
-     * {@inheritDoc}
-     */    
-    public Font getawtFont() throws IOException
-    {
-        if (awtFont == null)
-        {
-            this.awtFont = prepareAwtFont(this.cffFont);
-        }
-        return awtFont;
-    }
-    
-    private FontMetric getFontMetric() 
+    private FontMetric getFontMetric()
     {
         if (fontMetric == null)
         {
@@ -342,95 +311,69 @@ public class PDType1CFont extends PDSimpleFont
         String baseFontName = getBaseFont();
         if (fonts.size() > 1 && baseFontName != null)
         {
-            for (CFFFont font: fonts) 
+            for (CFFFont font : fonts)
             {
-                if (baseFontName.equals(font.getName())) 
+                if (baseFontName.equals(font.getName()))
                 {
-                    this.cffFont = font;
+                    cffFont = font;
                     break;
                 }
             }
         }
-        if (this.cffFont == null) 
+        if (cffFont == null)
         {
-            this.cffFont = (CFFFont)fonts.get(0);
+            cffFont = (CFFFont) fonts.get(0);
         }
+        // chache the font name
+        fontname = cffFont.getName();
 
-        PDFEncoding pdfEncoding = new PDFEncoding();
-
-        PDFCharset pdfCharset = new PDFCharset();
+        // TODO is this really needed?
+        Number defaultWidthX = (Number) this.cffFont.getProperty("defaultWidthX");
+        glyphWidths.put(null, Float.valueOf(defaultWidthX.floatValue()));
 
-        Map<String,byte[]> charStringsDict = this.cffFont.getCharStringsDict();
-        Map<String,byte[]> pdfCharStringsDict = new LinkedHashMap<String,byte[]>();
-        pdfCharStringsDict.put(".notdef", charStringsDict.get(".notdef"));
-
-        Map<Integer,String> codeToNameMap = new LinkedHashMap<Integer,String>();
-
-        Collection<CFFFont.Mapping> mappings = this.cffFont.getMappings();
-        for( Iterator<CFFFont.Mapping> it = mappings.iterator(); it.hasNext();)
+        // calculate some mappings to be used for rendering and text extraction
+        Encoding encoding = getFontEncoding();
+        Map<String, Integer> nameToCode = encoding != null ? encoding.getNameToCodeMap() : null;
+        Collection<CFFFont.Mapping> mappings = cffFont.getMappings();
+        Map<Integer, String> codeToNameMap = new LinkedHashMap<Integer, String>();
+        for (CFFFont.Mapping mapping : mappings)
         {
-            CFFFont.Mapping mapping = it.next();
-            Integer code = Integer.valueOf(mapping.getCode());
-            String name = mapping.getName();
-            codeToNameMap.put(code, name);
+            codeToNameMap.put(mapping.getCode(), mapping.getName());
         }
-
-        Set<String> knownNames = new HashSet<String>(codeToNameMap.values());
-
-        Map<Integer,String> codeToNameOverride = loadOverride();
-        for( Iterator<Map.Entry<Integer, String>> it = (codeToNameOverride.entrySet()).iterator(); it.hasNext();)
+        int glyphId = 0;
+        for (CFFFont.Mapping mapping : mappings)
         {
-            Map.Entry<Integer, String> entry = it.next();
-            Integer code = (Integer)entry.getKey();
-            String name = (String)entry.getValue();
-            if(knownNames.contains(name))
+            int code = mapping.getSID();
+            String name = mapping.getName();
+            String character = null;
+            if (nameToCode != null && nameToCode.containsKey(name))
             {
-                Iterator<Map.Entry<Integer, String>> iter = codeToNameMap.entrySet().iterator();
-                while (iter.hasNext()) 
-                {
-                    Map.Entry<Integer, String> existingEntry = iter.next();
-                    if (existingEntry.getValue().equals(name)) 
-                    {
-                        iter.remove();
-                        break;
-                    }
-                }
-                codeToNameMap.put(code, name);
+                code = nameToCode.get(name);
+                character = encoding.getCharacter(name);
             }
-        }
-
-        int glyphIndex = 0;
-        for( Iterator<Map.Entry<Integer,String>> it = (codeToNameMap.entrySet()).iterator(); it.hasNext();)
-        {
-            Map.Entry<Integer,String> entry = it.next();
-            Integer code = (Integer)entry.getKey();
-            String name = (String)entry.getValue();
-            String uniName = "uni" + hexString(code.intValue(), 4);
-            String character = String.valueOf((char) code.intValue());
-            pdfEncoding.register(code.intValue(), code.intValue());
-            pdfCharset.register(code.intValue(), uniName);
-            codeToName.put(code, uniName);
+            if (character == null)
+            {
+                character = Encoding.getCharacterForName(name);
+            }
+            if (character == null)
+            {
+                name = "uni" + hexString(code, 4);
+                character = String.valueOf(Character.toChars(code));
+            }
+            codeToGlyph.put(code, glyphId++);
+            codeToName.put(code, name);
             codeToCharacter.put(code, character);
             characterToCode.put(character, code);
-            codeToGlyph.put(code, glyphIndex++);
-            pdfCharStringsDict.put(uniName, charStringsDict.get(name));
         }
-
-        this.cffFont.setEncoding(pdfEncoding);
-        this.cffFont.setCharset(pdfCharset);
-        charStringsDict.clear();
-        charStringsDict.putAll(pdfCharStringsDict);
-        Number defaultWidthX = (Number)this.cffFont.getProperty("defaultWidthX");
-        this.glyphWidths.put(null, Float.valueOf(defaultWidthX.floatValue()));
     }
 
     private byte[] loadBytes() throws IOException
     {
         PDFontDescriptor fd = getFontDescriptor();
-        if( fd != null && fd instanceof PDFontDescriptorDictionary)
+        if (fd != null && fd instanceof PDFontDescriptorDictionary)
         {
-            PDStream ff3Stream = ((PDFontDescriptorDictionary)fd).getFontFile3();
-            if( ff3Stream != null )
+            PDStream ff3Stream = ((PDFontDescriptorDictionary) fd).getFontFile3();
+            if (ff3Stream != null)
             {
                 ByteArrayOutputStream os = new ByteArrayOutputStream();
 
@@ -438,10 +381,10 @@ public class PDType1CFont extends PDSimpleFont
                 try
                 {
                     byte[] buf = new byte[512];
-                    while(true)
+                    while (true)
                     {
                         int count = is.read(buf);
-                        if( count < 0 )
+                        if (count < 0)
                         {
                             break;
                         }
@@ -456,117 +399,20 @@ public class PDType1CFont extends PDSimpleFont
                 return os.toByteArray();
             }
         }
-
-        throw new IOException();
+        return null;
     }
 
-    private Map<Integer,String> loadOverride() throws IOException
-    {
-        Map<Integer,String> result = new LinkedHashMap<Integer,String>();
-        COSBase encoding = fontDict.getDictionaryObject(COSName.ENCODING);
-        if( encoding instanceof COSName )
-        {
-            COSName name = (COSName)encoding;
-            result.putAll(loadEncoding(name));
-        }
-        else if( encoding instanceof COSDictionary )
-        {
-            COSDictionary encodingDic = (COSDictionary)encoding;
-            COSName baseName = (COSName)encodingDic.getDictionaryObject(COSName.BASE_ENCODING);
-            if( baseName != null )
-            {
-                result.putAll(loadEncoding(baseName));
-            }
-            COSArray differences = (COSArray)encodingDic.getDictionaryObject(COSName.DIFFERENCES);
-            if( differences != null )
-            {
-                Map<Integer, String> diffs = loadDifferences(differences);
-                if (baseName == null) 
-                {
-                    result.putAll(diffs);
-                } 
-                else 
-                {
-                    Set<String> knownNames = new HashSet<String>(result.values());
-                    Iterator<Map.Entry<Integer, String>> it = (diffs.entrySet()).iterator();
-                    while (it.hasNext()) 
-                    {
-                        Map.Entry<Integer, String> entry = it.next();
-                        Integer code = (Integer) entry.getKey();
-                        String name = (String) entry.getValue();
-                        if (knownNames.contains(name)) 
-                        {
-                            Iterator<Map.Entry<Integer, String>> iter = result.entrySet().iterator();
-                            while( iter.hasNext()) 
-                            {
-                                Map.Entry<Integer, String> existingEntry = iter.next();
-                                if (existingEntry.getValue().equals(name)) 
-                                {
-                                    iter.remove();
-                                    break;
-                                }
-                            }
-                        }
-                        result.put(code, name);
-                    }
-                }
-            }
-        }
-        return result;
-    }
-
-    private Map<Integer,String> loadEncoding(COSName name) throws IOException
-    {
-        Map<Integer,String> result = new LinkedHashMap<Integer,String>();
-        Encoding encoding = EncodingManager.INSTANCE.getEncoding(name);
-        for( Iterator<Map.Entry<Integer,String>> it = (encoding.getCodeToNameMap().entrySet()).iterator();
-                    it.hasNext();)
-        {
-            Map.Entry<Integer,String> entry = it.next();
-            result.put(entry.getKey(), (entry.getValue()));
-        }
-
-        return result;
-    }
-
-    private Map<Integer,String> loadDifferences(COSArray differences)
-    {
-        Map<Integer,String> result = new LinkedHashMap<Integer,String>();
-        Integer code = null;
-        for( int i = 0; i < differences.size(); i++)
-        {
-            COSBase element = differences.get(i);
-            if( element instanceof COSNumber )
-            {
-                COSNumber number = (COSNumber)element;
-                code = Integer.valueOf(number.intValue());
-            } 
-            else 
-            {
-                if( element instanceof COSName )
-                {
-                    COSName name = (COSName)element;
-                    result.put(code, name.getName());
-                    code = Integer.valueOf(code.intValue() + 1);
-                }
-            }
-        }
-        return result;
-    }
-
-    
-    private static String hexString( int code, int length )
+    private static String hexString(int code, int length)
     {
         String string = Integer.toHexString(code).toUpperCase();
-        while(string.length() < length)
+        while (string.length() < length)
         {
             string = ("0" + string);
         }
-
         return string;
     }
 
-    private FontMetric prepareFontMetric( CFFFont font ) throws IOException
+    private FontMetric prepareFontMetric(CFFFont font) throws IOException
     {
         byte[] afmBytes = AFMFormatter.format(font);
 
@@ -580,12 +426,9 @@ public class PDType1CFont extends PDSimpleFont
 
             // Replace default FontBBox value with a newly computed one
             BoundingBox bounds = result.getFontBBox();
-            List<Integer> numbers = Arrays.asList(
-                    Integer.valueOf((int)bounds.getLowerLeftX()),
-                    Integer.valueOf((int)bounds.getLowerLeftY()),
-                    Integer.valueOf((int)bounds.getUpperRightX()),
-                    Integer.valueOf((int)bounds.getUpperRightY())
-                );
+            List<Integer> numbers = Arrays.asList(Integer.valueOf((int) bounds.getLowerLeftX()),
+                    Integer.valueOf((int) bounds.getLowerLeftY()), Integer.valueOf((int) bounds.getUpperRightX()),
+                    Integer.valueOf((int) bounds.getUpperRightY()));
             font.addValueToTopDict("FontBBox", numbers);
 
             return result;
@@ -596,58 +439,14 @@ public class PDType1CFont extends PDSimpleFont
         }
     }
 
-    private static Font prepareAwtFont( CFFFont font ) throws IOException
-    {
-        byte[] type1Bytes = Type1FontFormatter.format(font);
-
-        InputStream is = new ByteArrayInputStream(type1Bytes);
-        try
-        {
-            return Font.createFont(Font.TYPE1_FONT, is);
-        }
-        catch( FontFormatException ffe )
-        {
-            throw new WrappedIOException(ffe);
-        }
-        finally
-        {
-            is.close();
-        }
-    }
-
-    /**
-     * This class represents a PDFEncoding.
-     *
-     */
-    private static class PDFEncoding extends CFFEncoding
-    {
-
-        private PDFEncoding()
-        {
-        }
-
-        public boolean isFontSpecific()
-        {
-            return true;
-        }
-
-    }
-
     /**
-     * This class represents a PDFCharset.
-     *
+     * Returns the raw data of the font as CFFFont.
+     * 
+     * @return the cffFont
+     * @throws IOException if something went wrong
      */
-    private static class PDFCharset extends CFFCharset
+    public CFFFont getCFFFont() throws IOException
     {
-        private PDFCharset()
-        {
-        }
-
-        public boolean isFontSpecific()
-        {
-            return true;
-        }
-
+        return cffFont;
     }
-
 }
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
index 71b472d4ef..de4f903f1c 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/font/PDType1Font.java
@@ -16,24 +16,25 @@
  */
 package org.apache.pdfbox.pdmodel.font;
 
-import java.awt.Font;
-import java.awt.FontFormatException;
-import java.awt.font.GlyphVector;
 import java.io.BufferedReader;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.lang.reflect.Field;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.StringTokenizer;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.fontbox.afm.AFMParser;
 import org.apache.fontbox.afm.FontMetric;
 import org.apache.pdfbox.cos.COSArray;
+import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
 import org.apache.pdfbox.cos.COSFloat;
 import org.apache.pdfbox.cos.COSName;
+import org.apache.pdfbox.cos.COSString;
 import org.apache.pdfbox.encoding.AFMEncoding;
 import org.apache.pdfbox.encoding.Encoding;
 import org.apache.pdfbox.encoding.EncodingManager;
@@ -41,12 +42,13 @@ import org.apache.pdfbox.encoding.Type1Encoding;
 import org.apache.pdfbox.encoding.WinAnsiEncoding;
 import org.apache.pdfbox.pdmodel.common.PDMatrix;
 import org.apache.pdfbox.pdmodel.common.PDStream;
+import org.apache.pdfbox.util.ResourceLoader;
 
 /**
  * This is implementation of the Type1 Font.
- *
+ * 
  * @author <a href="mailto:ben@benlitchfield.com">Ben Litchfield</a>
- * @version $Revision: 1.11 $
+ * 
  */
 public class PDType1Font extends PDSimpleFont
 {
@@ -60,80 +62,133 @@ public class PDType1Font extends PDSimpleFont
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font TIMES_ROMAN = new PDType1Font( "Times-Roman" );
+    public static final PDType1Font TIMES_ROMAN = new PDType1Font("Times-Roman");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font TIMES_BOLD = new PDType1Font( "Times-Bold" );
+    public static final PDType1Font TIMES_BOLD = new PDType1Font("Times-Bold");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font TIMES_ITALIC = new PDType1Font( "Times-Italic" );
+    public static final PDType1Font TIMES_ITALIC = new PDType1Font("Times-Italic");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font TIMES_BOLD_ITALIC = new PDType1Font( "Times-BoldItalic" );
+    public static final PDType1Font TIMES_BOLD_ITALIC = new PDType1Font("Times-BoldItalic");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font HELVETICA = new PDType1Font( "Helvetica" );
+    public static final PDType1Font HELVETICA = new PDType1Font("Helvetica");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font HELVETICA_BOLD = new PDType1Font( "Helvetica-Bold" );
+    public static final PDType1Font HELVETICA_BOLD = new PDType1Font("Helvetica-Bold");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font HELVETICA_OBLIQUE = new PDType1Font( "Helvetica-Oblique" );
+    public static final PDType1Font HELVETICA_OBLIQUE = new PDType1Font("Helvetica-Oblique");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font HELVETICA_BOLD_OBLIQUE = new PDType1Font( "Helvetica-BoldOblique" );
+    public static final PDType1Font HELVETICA_BOLD_OBLIQUE = new PDType1Font("Helvetica-BoldOblique");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font COURIER = new PDType1Font( "Courier" );
+    public static final PDType1Font COURIER = new PDType1Font("Courier");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font COURIER_BOLD = new PDType1Font( "Courier-Bold" );
+    public static final PDType1Font COURIER_BOLD = new PDType1Font("Courier-Bold");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font COURIER_OBLIQUE = new PDType1Font( "Courier-Oblique" );
+    public static final PDType1Font COURIER_OBLIQUE = new PDType1Font("Courier-Oblique");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font COURIER_BOLD_OBLIQUE = new PDType1Font( "Courier-BoldOblique" );
+    public static final PDType1Font COURIER_BOLD_OBLIQUE = new PDType1Font("Courier-BoldOblique");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font SYMBOL = new PDType1Font( "Symbol" );
+    public static final PDType1Font SYMBOL = new PDType1Font("Symbol");
     /**
      * Standard Base 14 Font.
      */
-    public static final PDType1Font ZAPF_DINGBATS = new PDType1Font( "ZapfDingbats" );
+    public static final PDType1Font ZAPF_DINGBATS = new PDType1Font("ZapfDingbats");
 
     private static final Map<String, PDType1Font> STANDARD_14 = new HashMap<String, PDType1Font>();
     static
     {
-        STANDARD_14.put( TIMES_ROMAN.getBaseFont(), TIMES_ROMAN );
-        STANDARD_14.put( TIMES_BOLD.getBaseFont(), TIMES_BOLD );
-        STANDARD_14.put( TIMES_ITALIC.getBaseFont(), TIMES_ITALIC );
-        STANDARD_14.put( TIMES_BOLD_ITALIC.getBaseFont(), TIMES_BOLD_ITALIC );
-        STANDARD_14.put( HELVETICA.getBaseFont(), HELVETICA );
-        STANDARD_14.put( HELVETICA_BOLD.getBaseFont(), HELVETICA_BOLD );
-        STANDARD_14.put( HELVETICA_OBLIQUE.getBaseFont(), HELVETICA_OBLIQUE );
-        STANDARD_14.put( HELVETICA_BOLD_OBLIQUE.getBaseFont(), HELVETICA_BOLD_OBLIQUE );
-        STANDARD_14.put( COURIER.getBaseFont(), COURIER );
-        STANDARD_14.put( COURIER_BOLD.getBaseFont(), COURIER_BOLD );
-        STANDARD_14.put( COURIER_OBLIQUE.getBaseFont(), COURIER_OBLIQUE );
-        STANDARD_14.put( COURIER_BOLD_OBLIQUE.getBaseFont(), COURIER_BOLD_OBLIQUE );
-        STANDARD_14.put( SYMBOL.getBaseFont(), SYMBOL );
-        STANDARD_14.put( ZAPF_DINGBATS.getBaseFont(), ZAPF_DINGBATS );
+        STANDARD_14.put(TIMES_ROMAN.getBaseFont(), TIMES_ROMAN);
+        STANDARD_14.put(TIMES_BOLD.getBaseFont(), TIMES_BOLD);
+        STANDARD_14.put(TIMES_ITALIC.getBaseFont(), TIMES_ITALIC);
+        STANDARD_14.put(TIMES_BOLD_ITALIC.getBaseFont(), TIMES_BOLD_ITALIC);
+        STANDARD_14.put(HELVETICA.getBaseFont(), HELVETICA);
+        STANDARD_14.put(HELVETICA_BOLD.getBaseFont(), HELVETICA_BOLD);
+        STANDARD_14.put(HELVETICA_OBLIQUE.getBaseFont(), HELVETICA_OBLIQUE);
+        STANDARD_14.put(HELVETICA_BOLD_OBLIQUE.getBaseFont(), HELVETICA_BOLD_OBLIQUE);
+        STANDARD_14.put(COURIER.getBaseFont(), COURIER);
+        STANDARD_14.put(COURIER_BOLD.getBaseFont(), COURIER_BOLD);
+        STANDARD_14.put(COURIER_OBLIQUE.getBaseFont(), COURIER_OBLIQUE);
+        STANDARD_14.put(COURIER_BOLD_OBLIQUE.getBaseFont(), COURIER_BOLD_OBLIQUE);
+        STANDARD_14.put(SYMBOL.getBaseFont(), SYMBOL);
+        STANDARD_14.put(ZAPF_DINGBATS.getBaseFont(), ZAPF_DINGBATS);
+    }
+
+    /**
+     * The static map of the default Adobe font metrics.
+     */
+    private static final Map<String, FontMetric> afmObjects = Collections.unmodifiableMap(getAdobeFontMetrics());
+
+    private FontMetric afm = null;
+
+    private static Map<String, FontMetric> getAdobeFontMetrics()
+    {
+        Map<String, FontMetric> metrics = new HashMap<String, FontMetric>();
+        addAdobeFontMetric(metrics, "Courier-Bold");
+        addAdobeFontMetric(metrics, "Courier-BoldOblique");
+        addAdobeFontMetric(metrics, "Courier");
+        addAdobeFontMetric(metrics, "Courier-Oblique");
+        addAdobeFontMetric(metrics, "Helvetica");
+        addAdobeFontMetric(metrics, "Helvetica-Bold");
+        addAdobeFontMetric(metrics, "Helvetica-BoldOblique");
+        addAdobeFontMetric(metrics, "Helvetica-Oblique");
+        addAdobeFontMetric(metrics, "Symbol");
+        addAdobeFontMetric(metrics, "Times-Bold");
+        addAdobeFontMetric(metrics, "Times-BoldItalic");
+        addAdobeFontMetric(metrics, "Times-Italic");
+        addAdobeFontMetric(metrics, "Times-Roman");
+        addAdobeFontMetric(metrics, "ZapfDingbats");
+        return metrics;
     }
 
-    private Font awtFont = null;
+    private static final String resourceRootAFM = "org/apache/pdfbox/resources/afm/";
+
+    private static void addAdobeFontMetric(Map<String, FontMetric> metrics, String name)
+    {
+        try
+        {
+            String resource = resourceRootAFM + name + ".afm";
+            InputStream afmStream = ResourceLoader.loadResource(resource);
+            if (afmStream != null)
+            {
+                try
+                {
+                    AFMParser parser = new AFMParser(afmStream);
+                    parser.parse();
+                    metrics.put(name, parser.getResult());
+                }
+                finally
+                {
+                    afmStream.close();
+                }
+            }
+        }
+        catch (Exception e)
+        {
+            LOG.error("Something went wrong when reading the adobe afm files", e);
+        }
+    }
 
     /**
      * Constructor.
@@ -141,31 +196,31 @@ public class PDType1Font extends PDSimpleFont
     public PDType1Font()
     {
         super();
-        font.setItem( COSName.SUBTYPE, COSName.TYPE1 );
+        font.setItem(COSName.SUBTYPE, COSName.TYPE1);
     }
 
     /**
      * Constructor.
-     *
+     * 
      * @param fontDictionary The font dictionary according to the PDF specification.
      */
-    public PDType1Font( COSDictionary fontDictionary )
+    public PDType1Font(COSDictionary fontDictionary)
     {
-        super( fontDictionary );
+        super(fontDictionary);
         PDFontDescriptor fd = getFontDescriptor();
         if (fd != null && fd instanceof PDFontDescriptorDictionary)
         {
             // a Type1 font may contain a Type1C font
-            PDStream fontFile3 = ((PDFontDescriptorDictionary)fd).getFontFile3();
+            PDStream fontFile3 = ((PDFontDescriptorDictionary) fd).getFontFile3();
             if (fontFile3 != null)
             {
-                try 
+                try
                 {
-                    type1CFont = new PDType1CFont( super.font );
+                    type1CFont = new PDType1CFont(super.font);
                 }
-                catch (IOException exception) 
+                catch (IOException exception)
                 {
-                    LOG.info("Can't read the embedded type1C font " + fd.getFontName() );
+                    LOG.info("Can't read the embedded type1C font " + fd.getFontName());
                 }
             }
         }
@@ -173,98 +228,65 @@ public class PDType1Font extends PDSimpleFont
 
     /**
      * Constructor.
-     *
+     * 
      * @param baseFont The base font for this font.
      */
-    public PDType1Font( String baseFont )
+    public PDType1Font(String baseFont)
     {
         this();
-        setBaseFont( baseFont );
+        setBaseFont(baseFont);
         setFontEncoding(new WinAnsiEncoding());
         setEncoding(COSName.WIN_ANSI_ENCODING);
     }
 
+    protected FontMetric getAFM()
+    {
+        if (afm == null)
+        {
+            COSBase baseFont = font.getDictionaryObject(COSName.BASE_FONT);
+            String name = null;
+            if (baseFont instanceof COSName)
+            {
+                name = ((COSName) baseFont).getName();
+                if (name.indexOf("+") > -1)
+                {
+                    name = name.substring(name.indexOf("+") + 1);
+                }
+
+            }
+            else if (baseFont instanceof COSString)
+            {
+                COSString string = (COSString) baseFont;
+                name = string.getString();
+            }
+            if (name != null)
+            {
+                afm = afmObjects.get(name);
+            }
+        }
+        return afm;
+    }
+
     /**
      * A convenience method to get one of the standard 14 font from name.
-     *
+     * 
      * @param name The name of the font to get.
-     *
+     * 
      * @return The font that matches the name or null if it does not exist.
      */
-    public static PDType1Font getStandardFont( String name )
+    public static PDType1Font getStandardFont(String name)
     {
-        return (PDType1Font)STANDARD_14.get( name );
+        return (PDType1Font) STANDARD_14.get(name);
     }
 
     /**
      * This will get the names of the standard 14 fonts.
-     *
+     * 
      * @return An array of the names of the standard 14 fonts.
      */
     public static String[] getStandard14Names()
     {
-        return (String[])STANDARD_14.keySet().toArray( new String[14] );
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Font getawtFont() throws IOException
-    {
-        if( awtFont == null )
-        {
-            if (type1CFont != null)
-            {
-                awtFont = type1CFont.getawtFont();
-            }
-            else
-            {
-                String baseFont = getBaseFont();
-                PDFontDescriptor fd = getFontDescriptor();
-                if (fd != null && fd instanceof PDFontDescriptorDictionary)
-                {
-                    PDFontDescriptorDictionary fdDictionary = (PDFontDescriptorDictionary)fd;
-                    if( fdDictionary.getFontFile() != null )
-                    {
-                        try 
-                        {
-                            // create a type1 font with the embedded data
-                            awtFont = Font.createFont( Font.TYPE1_FONT,
-                                    fdDictionary.getFontFile().createInputStream() );
-                        } 
-                        catch (FontFormatException e) 
-                        {
-                            LOG.info("Can't read the embedded type1 font " + fd.getFontName() );
-                        }
-                    }
-                    if (awtFont == null)
-                    {
-                        // check if the font is part of our environment
-                        awtFont = FontManager.getAwtFont(fd.getFontName());
-                        if (awtFont == null)
-                        {
-                            LOG.info("Can't find the specified font " + fd.getFontName() );
-                        }
-                    }
-                }
-                else
-                {
-                    // check if the font is part of our environment
-                    awtFont = FontManager.getAwtFont(baseFont);
-                    if (awtFont == null) 
-                    {
-                        LOG.info("Can't find the specified basefont " + baseFont );
-                    }
-                }
-            }
-            if (awtFont == null)
-            {
-                // we can't find anything, so we have to use the standard font
-                awtFont = FontManager.getStandardFont();
-                LOG.info("Using font "+awtFont.getName()+ " instead");
-            }
-        }
-        return awtFont;
+        return (String[]) STANDARD_14.keySet().toArray(new String[14]);
     }
 
     /**
@@ -275,47 +297,47 @@ public class PDType1Font extends PDSimpleFont
     {
         super.determineEncoding();
         Encoding fontEncoding = getFontEncoding();
-        if(fontEncoding == null)
+        if (fontEncoding == null)
         {
             FontMetric metric = getAFM();
             if (metric != null)
             {
-                fontEncoding = new AFMEncoding( metric );
+                fontEncoding = new AFMEncoding(metric);
             }
             setFontEncoding(fontEncoding);
         }
         getEncodingFromFont(getFontEncoding() == null);
     }
-    
+
     /**
      * Tries to get the encoding for the type1 font.
-     *
+     * 
      */
     private void getEncodingFromFont(boolean extractEncoding)
     {
         // This whole section of code needs to be replaced with an actual type1 font parser!!
         // Get the font program from the embedded type font.
         PDFontDescriptor fontDescriptor = getFontDescriptor();
-        if( fontDescriptor != null && fontDescriptor instanceof PDFontDescriptorDictionary)
+        if (fontDescriptor != null && fontDescriptor instanceof PDFontDescriptorDictionary)
         {
-            PDStream fontFile = ((PDFontDescriptorDictionary)fontDescriptor).getFontFile();
-            if( fontFile != null )
+            PDStream fontFile = ((PDFontDescriptorDictionary) fontDescriptor).getFontFile();
+            if (fontFile != null)
             {
                 BufferedReader in = null;
-                try 
+                try
                 {
                     in = new BufferedReader(new InputStreamReader(fontFile.createInputStream()));
-                    
+
                     // this section parses the font program stream searching for a /Encoding entry
                     // if it contains an array of values a Type1Encoding will be returned
                     // if it encoding contains an encoding name the corresponding Encoding will be returned
                     String line = "";
                     Type1Encoding encoding = null;
-                    while( (line = in.readLine()) != null)
+                    while ((line = in.readLine()) != null)
                     {
-                        if (extractEncoding) 
+                        if (extractEncoding)
                         {
-                            if (line.startsWith("currentdict end")) 
+                            if (line.startsWith("currentdict end"))
                             {
                                 if (encoding != null)
                                 {
@@ -323,9 +345,9 @@ public class PDType1Font extends PDSimpleFont
                                 }
                                 break;
                             }
-                            if (line.startsWith("/Encoding")) 
+                            if (line.startsWith("/Encoding"))
                             {
-                                if(line.contains("array")) 
+                                if (line.contains("array"))
                                 {
                                     StringTokenizer st = new StringTokenizer(line);
                                     // ignore the first token
@@ -341,37 +363,36 @@ public class PDType1Font extends PDSimpleFont
                                     // ignore the first token
                                     st.nextElement();
                                     String type1Encoding = st.nextToken();
-                                    setFontEncoding(
-                                        EncodingManager.INSTANCE.getEncoding(
-                                                COSName.getPDFName(type1Encoding)));
+                                    setFontEncoding(EncodingManager.INSTANCE.getEncoding(COSName
+                                            .getPDFName(type1Encoding)));
                                     break;
                                 }
                             }
-                            else if (line.startsWith("dup")) 
+                            else if (line.startsWith("dup"))
                             {
-                                StringTokenizer st = new StringTokenizer(line.replaceAll("/"," /"));
+                                StringTokenizer st = new StringTokenizer(line.replaceAll("/", " /"));
                                 // ignore the first token
                                 st.nextElement();
                                 try
                                 {
                                     int index = Integer.parseInt(st.nextToken());
                                     String name = st.nextToken();
-                                    if(encoding == null)
+                                    if (encoding == null)
                                     {
-                                        LOG.warn("Unable to get character encoding. " +
-                                                "Encoding definition found without /Encoding line.");
+                                        LOG.warn("Unable to get character encoding. "
+                                                + "Encoding definition found without /Encoding line.");
                                     }
                                     else
                                     {
                                         encoding.addCharacterEncoding(index, name.replace("/", ""));
                                     }
                                 }
-                                catch(NumberFormatException exception)
+                                catch (NumberFormatException exception)
                                 {
-                                    // there are (tex?)-some fonts containing postscript code like the following, 
+                                    // there are (tex?)-some fonts containing postscript code like the following,
                                     // which has to be ignored, see PDFBOX-1481
                                     // dup dup 161 10 getinterval 0 exch putinterval ....
-                                    LOG.debug("Malformed encoding definition ignored (line="+line+")");
+                                    LOG.debug("Malformed encoding definition ignored (line=" + line + ")");
                                 }
                                 continue;
                             }
@@ -384,14 +405,14 @@ public class PDType1Font extends PDSimpleFont
                             // most likely all matrix values are in the same line than the keyword
                             if (line.indexOf("[") > -1)
                             {
-                                String matrixValues = line.substring(line.indexOf("[")+1,line.lastIndexOf("]"));
+                                String matrixValues = line.substring(line.indexOf("[") + 1, line.lastIndexOf("]"));
                                 StringTokenizer st = new StringTokenizer(matrixValues);
                                 COSArray array = new COSArray();
                                 if (st.countTokens() >= 6)
                                 {
-                                    try 
+                                    try
                                     {
-                                        for (int i=0;i<6;i++)
+                                        for (int i = 0; i < 6; i++)
                                         {
                                             COSFloat floatValue = new COSFloat(Float.parseFloat(st.nextToken()));
                                             array.add(floatValue);
@@ -408,7 +429,7 @@ public class PDType1Font extends PDSimpleFont
                             {
                                 // there are fonts where all values are on a separate line, see PDFBOX-1611
                                 COSArray array = new COSArray();
-                                while((line = in.readLine()) != null)
+                                while ((line = in.readLine()) != null)
                                 {
                                     if (line.startsWith("["))
                                     {
@@ -440,7 +461,7 @@ public class PDType1Font extends PDSimpleFont
                         }
                     }
                 }
-                catch(IOException exception) 
+                catch (IOException exception)
                 {
                     LOG.error("Error: Could not extract the encoding from the embedded type1 font.");
                 }
@@ -452,7 +473,7 @@ public class PDType1Font extends PDSimpleFont
                         {
                             in.close();
                         }
-                        catch(IOException exception) 
+                        catch (IOException exception)
                         {
                             LOG.error("An error occurs while closing the stream used to read the embedded type1 font.");
                         }
@@ -468,7 +489,7 @@ public class PDType1Font extends PDSimpleFont
     @Override
     public String encode(byte[] c, int offset, int length) throws IOException
     {
-        if (type1CFont != null)
+        if (type1CFont != null && getFontEncoding() == null)
         {
             return type1CFont.encode(c, offset, length);
         }
@@ -477,23 +498,23 @@ public class PDType1Font extends PDSimpleFont
             return super.encode(c, offset, length);
         }
     }
-    
+
     /**
      * {@inheritDoc}
      */
     @Override
-    public int encodeToCID( byte[] c, int offset, int length ) throws IOException 
+    public int encodeToCID(byte[] c, int offset, int length) throws IOException
     {
-      if (type1CFont != null && getFontEncoding() == null)
-      {
-          return type1CFont.encodeToCID(c, offset, length);
-      }
-      else
-      {
-          return super.encodeToCID(c, offset, length);
-      }
+        if (type1CFont != null && getFontEncoding() == null)
+        {
+            return type1CFont.encodeToCID(c, offset, length);
+        }
+        else
+        {
+            return super.encodeToCID(c, offset, length);
+        }
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -509,45 +530,14 @@ public class PDType1Font extends PDSimpleFont
             return super.getFontMatrix();
         }
     }
-    
+
     /**
-     * {@inheritDoc}
+     * Returns the embedded Type1C font if available.
+     * 
+     * @return the type1C font
      */
-    @Override
-    public GlyphVector remapGlyphs(GlyphVector glyphVector, String string) 
+    public PDType1CFont getType1CFont()
     {
-        // this is used to fix an apparent bug with the sun jdk where the mapping of
-        // character code to glyph index done by native code is wrong; this does not happen with openjdk
-        try 
-        {
-            Field fGlyphs = glyphVector.getClass().getDeclaredField("glyphs");
-            fGlyphs.setAccessible(true);
-            int[] glyphs = (int[]) fGlyphs.get(glyphVector);
-            if (glyphs.length == 1 && glyphs[0] != 65535) 
-            {
-                return glyphVector;
-            }
-            if (type1CFont != null) 
-            {
-                Field fuserGlyphs = glyphVector.getClass().getDeclaredField("userGlyphs");
-                fuserGlyphs.setAccessible(true);
-                int[] userGlyphs = (int[]) fuserGlyphs.get(glyphVector);
-                for (int j = 0; j < glyphs.length; j++) 
-                {
-                    if (glyphs[j] == 65535) 
-                    {
-                        int c = (int) string.charAt(j);
-                        glyphs[j] = type1CFont.getGlyphIndex(c);
-                        userGlyphs[j] = type1CFont.getGlyphIndex(c);
-                    }
-                }
-            }
-        } 
-        catch (Exception e) 
-        {
-            e.printStackTrace();
-        }
-        return glyphVector;
+        return type1CFont;
     }
-
 }
