diff --git a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
index d4ba025dd1..dc7ad4061a 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/cos/COSName.java
@@ -262,6 +262,10 @@ public final class COSName extends COSBase implements Comparable<COSName>
      * A common COSName value.
      */
     public static final COSName COLORANTS = new COSName( "Colorants" );
+    /**
+     * A common COSName value.
+     */
+    public static final COSName COLORS = new COSName( "Colors" );
     /**
      * A common COSName value.
      */
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/filter/FlateFilter.java b/pdfbox/src/main/java/org/apache/pdfbox/filter/FlateFilter.java
index 0c1ec41bb7..7648f20a49 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/filter/FlateFilter.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/filter/FlateFilter.java
@@ -31,6 +31,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
 import org.apache.pdfbox.cos.COSDictionary;
+import org.apache.pdfbox.cos.COSName;
 
 /**
  * This is the used for the FlateDecode filter.
@@ -55,7 +56,7 @@ public class FlateFilter implements Filter
     public void decode(InputStream compressedData, OutputStream result, COSDictionary options, int filterIndex ) 
     throws IOException
     {
-        COSBase baseObj = options.getDictionaryObject(new String[] {"DecodeParms","DP"});
+        COSBase baseObj = options.getDictionaryObject(COSName.DECODE_PARMS, COSName.DP);
         COSDictionary dict = null;
         if( baseObj instanceof COSDictionary )
         {
@@ -89,12 +90,12 @@ public class FlateFilter implements Filter
         ByteArrayOutputStream baos = null;
         if (dict!=null)
         {
-            predictor = dict.getInt("Predictor");
+            predictor = dict.getInt(COSName.PREDICTOR);
             if(predictor > 1)
             {
-                colors = dict.getInt("Colors");
-                bitsPerPixel = options.getInt("BitsPerComponent");
-                columns = dict.getInt("Columns");
+                colors = dict.getInt(COSName.COLORS);
+                bitsPerPixel = options.getInt(COSName.BITS_PER_COMPONENT);
+                columns = dict.getInt(COSName.COLUMNS);
             }
         }
 
@@ -204,7 +205,6 @@ public class FlateFilter implements Filter
     {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         byte[] buffer = new byte[2048];
-
         if (predictor == 1 )
         {
             // No prediction
@@ -217,12 +217,12 @@ public class FlateFilter implements Filter
         else
         {
             // calculate sizes
-            int bpp = (colors * bitsPerComponent + 7) / 8;
-            int rowlength = (columns * colors * bitsPerComponent + 7) / 8 + bpp;
+            int bpp = colors * (bitsPerComponent % 8 +1);
+            int rowlength = columns * bpp;
             byte[] actline = new byte[rowlength];
-            byte[] lastline = new byte[rowlength];// Initialize lastline with
-                                                    // Zeros according to
-                                                    // PNG-specification
+            // Initialize lastline with Zeros according to PNG-specification
+            byte[] lastline = new byte[rowlength];
+
             boolean done = false;
             int linepredictor = predictor;
 
@@ -246,7 +246,7 @@ public class FlateFilter implements Filter
 
                 // read line
                 int i = 0;
-                int offset = bpp;
+                int offset = 0;
                 while (offset < rowlength && ((i = data.read(actline, offset, rowlength - offset)) != -1))
                 {
                     offset += i;
@@ -264,10 +264,10 @@ public class FlateFilter implements Filter
                     	  	throw new IOException("TIFF-Predictor with " + bitsPerComponent + " bits per component not supported");
                         }
                         // for 8 bits per component it is the same algorithm as PRED SUB of PNG format
-                      	for (int p = bpp; p < rowlength; p++)
+                      	for (int p = 0; p < rowlength; p++)
 	                      {
 	                          int sub = actline[p] & 0xff;
-	                          int left = actline[p - bpp] & 0xff;
+	                          int left = p - bpp >= 0 ? actline[p - bpp] & 0xff : 0;
 	                          actline[p] = (byte) (sub + left);
 	                      }
 	                      break;
@@ -275,37 +275,37 @@ public class FlateFilter implements Filter
                     	// do nothing
                       break;
                     case 11:// PRED SUB
-                        for (int p = bpp; p < rowlength; p++)
+                        for (int p = 0; p < rowlength; p++)
                         {
-                            int sub = actline[p] & 0xff;
-                            int left = actline[p - bpp] & 0xff;
+                            int sub = actline[p];
+                            int left = p - bpp >= 0 ? actline[p - bpp]: 0;
                             actline[p] = (byte) (sub + left);
                         }
                         break;
                     case 12:// PRED UP
-                        for (int p = bpp; p < rowlength; p++)
+                        for (int p = 0; p < rowlength; p++)
                         {
                             int up = actline[p] & 0xff;
                             int prior = lastline[p] & 0xff;
-                            actline[p] = (byte) (up + prior);
+                            actline[p] = (byte) ((up + prior) & 0xff);
                         }
                         break;
                     case 13:// PRED AVG
-                        for (int p = bpp; p < rowlength; p++)
+                        for (int p = 0; p < rowlength; p++)
                         {
                             int avg = actline[p] & 0xff;
-                            int left = actline[p - bpp] & 0xff;
+                            int left = p - bpp >= 0 ? actline[p - bpp] & 0xff: 0;
                             int up = lastline[p] & 0xff;
-                            actline[p] = (byte) (avg + ((left + up) / 2));
+                            actline[p] = (byte) ((avg +  (int)Math.floor( (left + up)/2 ) ) & 0xff);
                         }
                         break;
                     case 14:// PRED PAETH
-                        for (int p = bpp; p < rowlength; p++)
+                        for (int p = 0; p < rowlength; p++)
                         {
                             int paeth = actline[p] & 0xff;
-                            int a = actline[p - bpp] & 0xff;// left
+                            int a = p - bpp >= 0 ? actline[p - bpp] & 0xff : 0;// left
                             int b = lastline[p] & 0xff;// upper
-                            int c = lastline[p - bpp] & 0xff;// upperleft
+                            int c = p - bpp >= 0 ? lastline[p - bpp] & 0xff : 0;// upperleft
                             int value = a + b - c;
                             int absa = Math.abs(value - a);
                             int absb = Math.abs(value - b);
@@ -313,27 +313,25 @@ public class FlateFilter implements Filter
 
                             if (absa <= absb && absa <= absc)
                             {
-                                actline[p] = (byte) (paeth + absa);
+                                actline[p] = (byte) ((paeth + a) & 0xff);
                             }
                             else if (absb <= absc)
                             {
-                                actline[p] += (byte) (paeth + absb);
+                                actline[p] = (byte) ((paeth + b) & 0xff);
                             }
                             else
                             {
-                                actline[p] += (byte) (paeth + absc);
+                                actline[p] = (byte) ((paeth + c) & 0xff);
                             }
                         }
                         break;
                     default:
                         break;
                 }
-
                 lastline = (byte[])actline.clone();
-                baos.write(actline, bpp, actline.length - bpp);
+                baos.write(actline, 0, actline.length);
             }
         }
-
         return baos.toByteArray();
     }
 
diff --git a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
index e56a0e9c85..3b391a302e 100644
--- a/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
+++ b/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/graphics/xobject/PDPixelMap.java
@@ -25,7 +25,6 @@ import java.awt.image.IndexColorModel;
 import java.awt.image.WritableRaster;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.util.List;
 
 import javax.imageio.ImageIO;
 
@@ -41,7 +40,6 @@ import org.apache.pdfbox.pdmodel.graphics.color.PDColorSpace;
 import org.apache.pdfbox.pdmodel.graphics.color.PDDeviceGray;
 import org.apache.pdfbox.pdmodel.graphics.color.PDICCBased;
 import org.apache.pdfbox.pdmodel.graphics.color.PDIndexed;
-import org.apache.pdfbox.pdmodel.graphics.predictor.PredictorAlgorithm;
 
 
 
@@ -135,8 +133,6 @@ public class PDPixelMap extends PDXObjectImage
             int width = getWidth();
             int height = getHeight();
             int bpc = getBitsPerComponent();
-            int predictor = getPredictor();
-            List filters = getPDStream().getFilters();
             
             byte[] array = getPDStream().getByteArray();
     
@@ -247,27 +243,6 @@ public class PDPixelMap extends PDXObjectImage
             DataBufferByte buffer = (DataBufferByte)raster.getDataBuffer();
             byte[] bufferData = buffer.getData();
         
-            /**
-             * PDF Spec 1.6 3.3.3 LZW and Flate predictor function
-             *
-             * Basically if predictor > 10 and LZW or Flate is being used then the
-             * predictor is not used.
-             *
-             * "For LZWDecode and FlateDecode, a Predictor value greater than or equal to 10
-             * merely indicates that a PNG predictor is in use; the specific predictor function
-             * used is explicitly encoded in the incoming data. The value of Predictor supplied
-             * by the decoding filter need not match the value used when the data was encoded
-             * if they are both greater than or equal to 10."
-             */
-            if( predictor < 10 ||
-                filters == null || !(filters.contains( COSName.LZW_DECODE.getName()) ||
-                         filters.contains( COSName.FLATE_DECODE.getName()) ) )
-            {
-                PredictorAlgorithm filter = PredictorAlgorithm.getFilter(predictor);
-                filter.setWidth(width);
-                filter.setHeight(height);
-                filter.setBpp((bpc * 3) / 8);
-            }
             System.arraycopy( array, 0,bufferData, 0, 
                     (array.length<bufferData.length?array.length: bufferData.length) );
             image = new BufferedImage(cm, raster, false, null);
