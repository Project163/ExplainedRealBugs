diff --git a/src/ORM/Association/BelongsToMany.php b/src/ORM/Association/BelongsToMany.php
index 8ffc172e72..1b305f93f0 100644
--- a/src/ORM/Association/BelongsToMany.php
+++ b/src/ORM/Association/BelongsToMany.php
@@ -1193,20 +1193,17 @@ class BelongsToMany extends Association
                     $keys[$key] = $junction->aliasField($key);
                 }
 
-                // Find existing rows so that we can diff with new entities.
-                // Only hydrate primary/foreign key columns to save time.
-                // Attach joins first to ensure where conditions have correct
-                // column types set.
-                $existing = $this->_appendJunctionJoin($this->find())
-                    ->select($keys)
+                // Find junction records. We join with the association target so that junction
+                // conditions from `targetConditions()` or the finder work.
+                $existing = $junction->find()
+                    ->innerJoinWith($target->getAlias())
+                    ->where($this->targetConditions())
+                    ->where($this->junctionConditions())
                     ->where(array_combine($prefixedForeignKey, $primaryValue));
-
-                // Because we're aliasing key fields to look like they are not
-                // from joined table we need to overwrite the type map as the junction
-                // table can have a surrogate primary key that doesn't share a type
-                // with the target table.
-                $junctionTypes = array_intersect_key($junction->getSchema()->typeMap(), $keys);
-                $existing->getSelectTypeMap()->setTypes($junctionTypes);
+                $finder = $this->getFinder();
+                if ($finder) {
+                    $existing = $target->callFinder($finder, $existing);
+                }
 
                 $jointEntities = $this->_collectJointEntities($sourceEntity, $targetEntities);
                 $inserts = $this->_diffLinks($existing, $jointEntities, $targetEntities, $options);
diff --git a/tests/TestCase/ORM/Association/BelongsToManyTest.php b/tests/TestCase/ORM/Association/BelongsToManyTest.php
index c523d2564c..d35e43e6d3 100644
--- a/tests/TestCase/ORM/Association/BelongsToManyTest.php
+++ b/tests/TestCase/ORM/Association/BelongsToManyTest.php
@@ -33,6 +33,7 @@ use Cake\ORM\Table;
 use Cake\TestSuite\TestCase;
 use InvalidArgumentException;
 use RuntimeException;
+use TestApp\Model\Entity\ArticlesTag;
 
 /**
  * Tests BelongsToMany class
@@ -911,6 +912,35 @@ class BelongsToManyTest extends TestCase
         $this->assertSame(1, $other[0]->article_id);
     }
 
+    /**
+     * Test that replaceLinks() loads junction records with the correct entity class
+     */
+    public function testReplaceLinksFetchCorrectJunctionEntity(): void
+    {
+        $joint = $this->getTableLocator()->get('ArticlesTags');
+        $articles = $this->getTableLocator()->get('Articles');
+        $tags = $this->getTableLocator()->get('Tags');
+
+        $assoc = $articles->belongsToMany('Tags', [
+            'sourceTable' => $articles,
+            'targetTable' => $tags,
+            'through' => $joint,
+            'joinTable' => 'articles_tags',
+        ]);
+        $joint->setEntityClass(ArticlesTag::class);
+
+        $joint->getEventManager()->on('Model.afterDelete', function ($event, $entity) {
+            $this->assertInstanceOf(ArticlesTag::class, $entity);
+            $this->assertNotEmpty($entity->tag_id);
+            $this->assertNotEmpty($entity->article_id);
+        });
+
+        $entity = $articles->get(1, ['contain' => 'Tags']);
+        $this->assertCount(2, $entity->tags);
+
+        $assoc->replaceLinks($entity, []);
+    }
+
     /**
      * Tests replaceLinks with failing domain rules and new link targets.
      */
