diff --git a/src/Database/Expression/QueryExpression.php b/src/Database/Expression/QueryExpression.php
index a1acdf5a3a..65daab3ac6 100644
--- a/src/Database/Expression/QueryExpression.php
+++ b/src/Database/Expression/QueryExpression.php
@@ -722,7 +722,7 @@ class QueryExpression implements ExpressionInterface, Countable
      * generating the placeholders and replacing the values by them, while storing
      * the value elsewhere for future binding.
      *
-     * @param string $field The value from with the actual field and operator will
+     * @param string $field The value from which the actual field and operator will
      * be extracted.
      * @param mixed $value The value to be bound to a placeholder for the field
      * @return string|\Cake\Database\ExpressionInterface
@@ -730,16 +730,26 @@ class QueryExpression implements ExpressionInterface, Countable
      */
     protected function _parseCondition(string $field, $value)
     {
+        $field = trim($field);
         $operator = '=';
         $expression = $field;
-        $parts = explode(' ', trim($field), 2);
 
-        if (count($parts) > 1) {
+        $spaces = substr_count($field, ' ');
+        if ($spaces > 1) {
+            $parts = explode(' ', $field);
+            if (preg_match('/(is not|not in)$/i', $field)) {
+                $last = array_pop($parts);
+                $second = array_pop($parts);
+                array_push($parts, strtolower("{$second} {$last}"));
+            }
+            $operator = array_pop($parts);
+            $expression = implode(' ', $parts);
+        } elseif ($spaces == 1) {
+            $parts = explode(' ', $field, 2);
             [$expression, $operator] = $parts;
+            $operator = strtolower(trim($operator));
         }
-
-        $type = $this->getTypeMap()->type($expression);
-        $operator = strtolower(trim($operator));
+        $type = $this->getTypeMap() ->type($expression);
 
         $typeMultiple = (is_string($type) && strpos($type, '[]') !== false);
         if (in_array($operator, ['in', 'not in']) || $typeMultiple) {
diff --git a/tests/TestCase/Database/QueryTest.php b/tests/TestCase/Database/QueryTest.php
index a1bf387adc..329769832c 100644
--- a/tests/TestCase/Database/QueryTest.php
+++ b/tests/TestCase/Database/QueryTest.php
@@ -2302,6 +2302,33 @@ class QueryTest extends TestCase
         $this->assertEquals($expected, $result->fetchAll('assoc'));
     }
 
+    /**
+     * Test having casing with string expressions
+     *
+     * @return void
+     */
+    public function testHavingAliasCasingStringExpression()
+    {
+        $this->loadFixtures('Authors');
+        $query = new Query($this->connection);
+        $query
+            ->select(['id'])
+            ->from(['Authors' => 'authors'])
+            ->where([
+                'FUNC( Authors.id) =' => 1,
+                'FUNC( Authors.id) IS NOT' => null,
+            ])
+            ->having(['COUNT(DISTINCT Authors.id) =' => 1]);
+
+        $this->assertQuotedQuery(
+            'SELECT <id> FROM <authors> <Authors> WHERE ' .
+            '\(FUNC\( <Authors>\.<id>\) = :c0 AND \(FUNC\( <Authors>\.<id>\)\) IS NOT NULL\) ' .
+            'HAVING COUNT\(DISTINCT <Authors>\.<id>\) = :c1',
+            $query->sql(),
+            !$this->autoQuote
+        );
+    }
+
     /**
      * Tests selecting rows using a limit clause
      *
