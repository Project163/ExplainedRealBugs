diff --git a/src/java/org/apache/commons/jxpath/util/JXPath11CompatibleTypeConverter.java b/src/java/org/apache/commons/jxpath/util/JXPath11CompatibleTypeConverter.java
new file mode 100755
index 00000000..cdd32f08
--- /dev/null
+++ b/src/java/org/apache/commons/jxpath/util/JXPath11CompatibleTypeConverter.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.jxpath.util;
+
+import org.apache.commons.jxpath.NodeSet;
+
+/**
+ * TypeConverter implementation to circumvent automagic NodeSet decoding. Suggested by JIRA issue JXPATH-10.
+ *
+ * @since JXPath 1.3
+ * @author Matt Benson
+ * @version $Revision$ $Date$
+ */
+public class JXPath11CompatibleTypeConverter extends BasicTypeConverter {
+    /**
+     * {@inheritDoc}
+     */
+    public boolean canConvert(Object object, Class toType) {
+        return object instanceof NodeSet ? toType.isInstance(object) : super.canConvert(object, toType);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Object convert(Object object, Class toType) {
+        return object instanceof NodeSet && toType.isInstance(object) ? object : super.convert(object, toType);
+    }
+}
diff --git a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java
index 41814879..c0e6dea2 100644
--- a/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java
+++ b/src/test/org/apache/commons/jxpath/ri/compiler/ExtensionFunctionTest.java
@@ -30,11 +30,15 @@ import org.apache.commons.jxpath.FunctionLibrary;
 import org.apache.commons.jxpath.Functions;
 import org.apache.commons.jxpath.JXPathContext;
 import org.apache.commons.jxpath.JXPathTestCase;
+import org.apache.commons.jxpath.NodeSet;
 import org.apache.commons.jxpath.PackageFunctions;
 import org.apache.commons.jxpath.Pointer;
 import org.apache.commons.jxpath.TestBean;
 import org.apache.commons.jxpath.Variables;
 import org.apache.commons.jxpath.ri.model.NodePointer;
+import org.apache.commons.jxpath.util.JXPath11CompatibleTypeConverter;
+import org.apache.commons.jxpath.util.TypeConverter;
+import org.apache.commons.jxpath.util.TypeUtils;
 
 /**
  * Test extension functions.
@@ -47,6 +51,7 @@ public class ExtensionFunctionTest extends JXPathTestCase {
     private Functions functions;
     private JXPathContext context;
     private TestBean testBean;
+    private TypeConverter typeConverter;
 
     public static void main(String[] args) {
         TestRunner.run(ExtensionFunctionTest.class);
@@ -78,8 +83,15 @@ public class ExtensionFunctionTest extends JXPathTestCase {
                     "jxpathtest"));
             lib.addFunctions(new PackageFunctions("", null));
             context.setFunctions(lib);
+            context.getVariables().declareVariable("List.class", List.class);
+            context.getVariables().declareVariable("NodeSet.class", NodeSet.class);
         }
         functions = new ClassFunctions(TestFunctions.class, "test");
+        typeConverter = TypeUtils.getTypeConverter();
+    }
+
+    public void tearDown() {
+        TypeUtils.setTypeConverter(typeConverter);
     }
 
     public void testConstructorLookup() {
@@ -362,6 +374,29 @@ public class ExtensionFunctionTest extends JXPathTestCase {
             "/beans[1]/@name");
     }
 
+    public void testEstablishNodeSetBaseline() {
+        assertXPathValue(
+            context,
+            "test:isInstance(//strings, $List.class)",
+            Boolean.TRUE);
+        assertXPathValue(
+            context,
+            "test:isInstance(//strings, $NodeSet.class)",
+            Boolean.FALSE);
+    }
+
+    public void testBCNodeSetHack() {
+        TypeUtils.setTypeConverter(new JXPath11CompatibleTypeConverter());
+        assertXPathValue(
+            context,
+            "test:isInstance(//strings, $List.class)",
+            Boolean.FALSE);
+        assertXPathValue(
+            context,
+            "test:isInstance(//strings, $NodeSet.class)",
+            Boolean.TRUE);
+    }
+
     private static class Context implements ExpressionContext {
         private Object object;
 
@@ -386,4 +421,4 @@ public class ExtensionFunctionTest extends JXPathTestCase {
             return 0;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java
index 6ae4a129..c5d5f002 100644
--- a/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java
+++ b/src/test/org/apache/commons/jxpath/ri/compiler/TestFunctions.java
@@ -149,4 +149,9 @@ public class TestFunctions {
     public static Collection items(Collection arg) {
         return arg;
     }
+
+    public static Boolean isInstance(Object o, Class c) {
+        return c.isInstance(o) ? Boolean.TRUE : Boolean.FALSE;
+    }
+
 }
\ No newline at end of file
