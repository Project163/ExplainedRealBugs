diff --git a/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs b/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
index 2d2d9797..973b49dd 100644
--- a/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
+++ b/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
@@ -9618,6 +9618,23 @@ public void MailMessageConverterTest()
                 "Cannot populate list type System.Net.Mime.HeaderCollection. Path 'Headers', line 26, position 14.");
         }
 
+        [Test]
+        public void DeserializeDictionaryOfHashSetsWithTypeNameHandlingAll()
+        {
+            var dictionary = new Dictionary<int, HashSet<string>>
+            {
+                { 1, new HashSet<string>(new[] { "test" }) },
+            };
+
+            var jsonSerializerSettings = new JsonSerializerSettings { TypeNameHandling = TypeNameHandling.All };
+
+            var obtainedJson = JsonConvert.SerializeObject(dictionary, jsonSerializerSettings);
+
+            var obtainedDictionary = (Dictionary<int, HashSet<string>>)JsonConvert.DeserializeObject(obtainedJson, jsonSerializerSettings);
+
+            Assert.IsNotNull(obtainedDictionary);
+        }
+
         public class MailAddressReadConverter : JsonConverter
         {
             public override bool CanConvert(Type objectType)
diff --git a/Src/Newtonsoft.Json/Serialization/DefaultSerializationBinder.cs b/Src/Newtonsoft.Json/Serialization/DefaultSerializationBinder.cs
index 5df55dc2..2dfd7bdb 100644
--- a/Src/Newtonsoft.Json/Serialization/DefaultSerializationBinder.cs
+++ b/Src/Newtonsoft.Json/Serialization/DefaultSerializationBinder.cs
@@ -28,6 +28,7 @@
 using System.Reflection;
 using System.Globalization;
 using Newtonsoft.Json.Utilities;
+using System.Collections.Generic;
 
 namespace Newtonsoft.Json.Serialization
 {
@@ -38,9 +39,17 @@ public class DefaultSerializationBinder : SerializationBinder
     {
         internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();
 
-        private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache = new ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);
+        private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache;
 
-        private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
+        /// <summary>
+        /// Initializes a new instance of the <see cref="DefaultSerializationBinder"/> class.
+        /// </summary>
+        public DefaultSerializationBinder()
+        {
+            _typeCache = new ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);
+        }
+
+        private Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
         {
             string assemblyName = typeNameKey.AssemblyName;
             string typeName = typeNameKey.TypeName;
@@ -68,7 +77,8 @@ private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
                     Assembly[] loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
                     foreach (Assembly a in loadedAssemblies)
                     {
-                        if (a.FullName == assemblyName)
+                        // check for both full name or partial name match
+                        if (a.FullName == assemblyName || a.GetName().Name == assemblyName)
                         {
                             assembly = a;
                             break;
@@ -85,7 +95,24 @@ private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
                 Type type = assembly.GetType(typeName);
                 if (type == null)
                 {
-                    throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));
+                    // if generic type, try manually parsing the type arguments for the case of dynamically loaded assemblies
+                    // example generic typeName format: System.Collections.Generic.Dictionary`2[[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.String, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]
+                    if (typeName.IndexOf('`') >= 0)
+                    {
+                        try
+                        {
+                            type = GetGenericTypeFromTypeName(typeName, assembly);
+                        }
+                        catch (Exception ex)
+                        {
+                            throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName), ex);
+                        }
+                    }
+
+                    if (type == null)
+                    {
+                        throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));
+                    }
                 }
 
                 return type;
@@ -96,6 +123,52 @@ private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
             }
         }
 
+        private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly)
+        {
+            Type type = null;
+            var openBracketIndex = typeName.IndexOf('[');
+            if (openBracketIndex >= 0)
+            {
+                var genericTypeDefName = typeName.Substring(0, openBracketIndex);
+                var genericTypeDef = assembly.GetType(genericTypeDefName);
+                if (genericTypeDef != null)
+                {
+                    var typeArgs = new List<Type>();
+                    var scope = 0;
+                    var typeArgStartIndex = 0;
+                    var endIndex = typeName.Length - 1;
+                    for (var i = openBracketIndex + 1; i < endIndex; ++i)
+                    {
+                        var current = typeName[i];
+                        switch (current)
+                        {
+                            case '[':
+                                if (scope == 0)
+                                {
+                                    typeArgStartIndex = i + 1;
+                                }
+                                ++scope;
+                                break;
+                            case ']':
+                                --scope;
+                                if (scope == 0)
+                                {
+                                    var typeArgAssemblyQualifiedName = typeName.Substring(typeArgStartIndex, i - typeArgStartIndex);
+                                    string typeArgTypeName;
+                                    string typeArgAssemblyName;
+                                    ReflectionUtils.SplitFullyQualifiedTypeName(typeArgAssemblyQualifiedName, out typeArgTypeName, out typeArgAssemblyName);
+                                    var typeArg = BindToType(typeArgAssemblyName, typeArgTypeName);
+                                    typeArgs.Add(typeArg);
+                                }
+                                break;
+                        }
+                    }
+                    type = genericTypeDef.MakeGenericType(typeArgs.ToArray());
+                }
+            }
+            return type;
+        }
+
         internal struct TypeNameKey : IEquatable<TypeNameKey>
         {
             internal readonly string AssemblyName;
