diff --git a/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs b/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
index 5a654f6d..23309c6a 100644
--- a/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
+++ b/Src/Newtonsoft.Json.Tests/Serialization/JsonSerializerTest.cs
@@ -92,6 +92,29 @@ namespace Newtonsoft.Json.Tests.Serialization
     [TestFixture]
     public class JsonSerializerTest : TestFixtureBase
     {
+
+        [Test]
+        public void ExtensionDataWithNull()
+        {
+            string json = @"{
+            'TaxRate': 0.125,
+            'a':null
+            }";
+
+            var invoice = JsonConvert.DeserializeObject<ExtendedObject>(json);
+
+            string result = JsonConvert.SerializeObject(invoice);
+
+            Assert.AreEqual(@"{""TaxRate"":0.125,""a"":null}", result);
+        }
+
+
+        class ExtendedObject
+        {
+            [JsonExtensionData]
+            private IDictionary<string, JToken> _additionalData;
+        }
+
         public class GenericItem<T>
         {
             public T Value { get; set; }
diff --git a/Src/Newtonsoft.Json/Serialization/DefaultContractResolver.cs b/Src/Newtonsoft.Json/Serialization/DefaultContractResolver.cs
index 74c30563..031376dc 100644
--- a/Src/Newtonsoft.Json/Serialization/DefaultContractResolver.cs
+++ b/Src/Newtonsoft.Json/Serialization/DefaultContractResolver.cs
@@ -482,7 +482,7 @@ private static void SetExtensionDataDelegates(JsonObjectContract contract, Membe
 
                 // convert object value to JToken so it is compatible with dictionary
                 // could happen because of primitive types, type name handling and references
-                if (isJTokenValueType && !(value is JToken))
+                if (isJTokenValueType && !(value is JToken) && value!=null)
                     value = JToken.FromObject(value);
 
                 setExtensionDataDictionaryValue(dictionary, key, value);
