diff --git a/docs/Hooks.md b/docs/Hooks.md
index 4c13c34c..ca8af073 100644
--- a/docs/Hooks.md
+++ b/docs/Hooks.md
@@ -210,7 +210,23 @@ fastify.addHook('preHandler', (request, reply, done) => {
 *The error will be handled by [`Reply`](https://github.com/fastify/fastify/blob/master/docs/Reply.md#errors).*
 
 ### Respond to a request from a hook
-If needed, you can respond to a request before you reach the route handler, for example when implementing an authentication hook. If you are using `onRequest` or `preHandler` use `reply.send`; if you are using a middleware, use `res.end`.
+
+If needed, you can respond to a request before you reach the route handler,
+for example when implementing an authentication hook.
+Replying from an hook implies that the hook chain is __stopped__ and
+the rest of hooks and the handlers are not executed. If the hook is
+using the callback approach, i.e. it is not an `async` function or it
+returns a `Promise`, it is as simple as calling `reply.send()` and avoiding
+calling the callback. If the hook is `async`, `reply.send()` __must__ be
+called _before_ the function returns or the promise resolves, otherwise the
+request will proceed. When `reply.send()` is called outside of the
+promise chain, it is important to `return reply` otherwise the request
+will be executed twice.
+
+It is important to __not mix callbacks and `async`/`Promise`__, otherwise
+the hook chain will be executed twice.
+
+If you are using `onRequest` or `preHandler` use `reply.send`; if you are using a middleware, use `res.end`.
 
 ```js
 fastify.addHook('onRequest', (request, reply, done) => {
@@ -219,7 +235,9 @@ fastify.addHook('onRequest', (request, reply, done) => {
 
 // Works with async functions too
 fastify.addHook('preHandler', async (request, reply) => {
+  await something()
   reply.send({ hello: 'world' })
+  return reply // optional in this case, but it is a good practice
 })
 ```
 
@@ -232,6 +250,26 @@ fastify.addHook('onRequest', (request, reply, done) => {
 })
 ```
 
+If you are sending a response without `await` on it, make sure to always
+`return reply`:
+
+```js
+fastify.addHook('preHandler', async (request, reply) => {
+  setImmediate(() => { reply.send('hello') })
+
+  // This is needed to signal the handler to wait for a response
+  // to be sent outside of the promise chain
+  return reply
+})
+
+fastify.addHook('preHandler', async (request, reply) => {
+  // the fastify-static plugin will send a file asynchronously,
+  // so we should return reply
+  reply.sendFile('myfile')
+  return reply
+})
+```
+
 ## Application Hooks
 
 You can hook into the application-lifecycle as well. It's important to note that these hooks aren't fully encapsulated. The `this` inside the hooks are encapsulated but the handlers can respond to an event outside the encapsulation boundaries.
diff --git a/test/hooks-async.js b/test/hooks-async.js
index 0ce00e79..623bd807 100644
--- a/test/hooks-async.js
+++ b/test/hooks-async.js
@@ -547,6 +547,25 @@ function asyncHookTest (t) {
 
     t.end()
   })
+
+  t.test('early termination, onRequest async', async t => {
+    t.plan(2)
+
+    const app = Fastify()
+
+    app.addHook('onRequest', async (req, reply) => {
+      setImmediate(() => reply.send('hello world'))
+      return reply
+    })
+
+    app.get('/', (req, reply) => {
+      t.fail('should not happen')
+    })
+
+    const res = await app.inject('/')
+    t.is(res.statusCode, 200)
+    t.is(res.body.toString(), 'hello world')
+  })
 }
 
 module.exports = asyncHookTest
diff --git a/test/hooks.test.js b/test/hooks.test.js
index d5785e2e..78b33afa 100644
--- a/test/hooks.test.js
+++ b/test/hooks.test.js
@@ -2727,6 +2727,27 @@ test('onRegister hook should be called / 4', t => {
   })
 })
 
+test('early termination, onRequest', t => {
+  t.plan(3)
+
+  const app = Fastify()
+
+  app.addHook('onRequest', (req, reply) => {
+    setImmediate(() => reply.send('hello world'))
+    return reply
+  })
+
+  app.get('/', (req, reply) => {
+    t.fail('should not happen')
+  })
+
+  app.inject('/', function (err, res) {
+    t.error(err)
+    t.is(res.statusCode, 200)
+    t.is(res.body.toString(), 'hello world')
+  })
+})
+
 test('reply.send should throw if undefined error is thrown', t => {
   /* eslint prefer-promise-reject-errors: ["error", {"allowEmptyReject": true}] */
 
