diff --git a/lib/validation.js b/lib/validation.js
index 047d1c8a..a7ac2aea 100644
--- a/lib/validation.js
+++ b/lib/validation.js
@@ -117,7 +117,15 @@ function compileSchemasForValidation (context, compile, isCustom) {
 
 function validateParam (validatorFunction, request, paramName) {
   const isUndefined = request[paramName] === undefined
-  const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName])
+  let ret
+
+  try {
+    ret = validatorFunction?.(isUndefined ? null : request[paramName])
+  } catch (err) {
+    // If validator throws synchronously, ensure it propagates as an internal error
+    err.statusCode = 500
+    return err
+  }
 
   if (ret && typeof ret.then === 'function') {
     return ret
diff --git a/test/validation-error-handling.test.js b/test/validation-error-handling.test.js
index 6177332d..f8933f3e 100644
--- a/test/validation-error-handling.test.js
+++ b/test/validation-error-handling.test.js
@@ -1,6 +1,6 @@
 'use strict'
 
-const { test } = require('node:test')
+const { describe, test } = require('node:test')
 const Joi = require('joi')
 const Fastify = require('..')
 
@@ -831,3 +831,70 @@ test('plugin override', async (t) => {
   })
   t.assert.strictEqual(response5.statusCode, 400)
 })
+
+describe('sync and async must work in the same way', () => {
+  // Route with custom validator that throws
+  const throwingRouteValidator = {
+    schema: {
+      body: {
+        type: 'object',
+        properties: { name: { type: 'string' } }
+      }
+    },
+    validatorCompiler: () => {
+      return function (inputData) {
+        // This custom validator throws a sync error instead of returning `{ error }`
+        throw new Error('Custom validation failed')
+      }
+    },
+    handler (request, reply) { reply.send({ success: true }) }
+  }
+
+  test('async preValidation with custom validator should trigger error handler when validator throws', async (t) => {
+    t.plan(4)
+
+    const fastify = Fastify()
+    fastify.setErrorHandler((error, request, reply) => {
+      t.assert.ok(error instanceof Error, 'error should be an Error instance')
+      t.assert.strictEqual(error.message, 'Custom validation failed')
+      reply.status(500).send({ error: error.message })
+    })
+
+    // Add async preValidation hook
+    fastify.addHook('preValidation', async (request, reply) => {
+      await Promise.resolve('ok')
+    })
+    fastify.post('/async', throwingRouteValidator)
+
+    const response = await fastify.inject({
+      method: 'POST',
+      url: '/async',
+      payload: { name: 'test' }
+    })
+    t.assert.strictEqual(response.statusCode, 500)
+    t.assert.deepStrictEqual(response.json(), { error: 'Custom validation failed' })
+  })
+
+  test('sync preValidation with custom validator should trigger error handler when validator throws', async (t) => {
+    t.plan(4)
+
+    const fastify = Fastify()
+    fastify.setErrorHandler((error, request, reply) => {
+      t.assert.ok(error instanceof Error, 'error should be an Error instance')
+      t.assert.strictEqual(error.message, 'Custom validation failed')
+      reply.status(500).send({ error: error.message })
+    })
+
+    // Add sync preValidation hook
+    fastify.addHook('preValidation', (request, reply, next) => { next() })
+    fastify.post('/sync', throwingRouteValidator)
+
+    const response = await fastify.inject({
+      method: 'POST',
+      url: '/sync',
+      payload: { name: 'test' }
+    })
+    t.assert.strictEqual(response.statusCode, 500)
+    t.assert.deepStrictEqual(response.json(), { error: 'Custom validation failed' })
+  })
+})
