diff --git a/docs/ContentTypeParser.md b/docs/ContentTypeParser.md
index f1d4961d..8787e923 100644
--- a/docs/ContentTypeParser.md
+++ b/docs/ContentTypeParser.md
@@ -1,7 +1,7 @@
 <h1 align="center">Fastify</h1>
 
 ## Content Type Parser
-Natively, Fastify only supports the `'application/json'` content type. The default charset is `utf-8`. If you need to support different content types, you can use the `addContentTypeParser` API. *The default JSON parser can be changed.*
+Natively, Fastify only supports `'application/json'` and `'text/plain'` content types. The default charset is `utf-8`. If you need to support different content types, you can use the `addContentTypeParser` API. *The default JSON and/or plain text parser can be changed.*
 
 As with the other APIs, `addContentTypeParser` is encapsulated in the scope in which it is declared. This means that if you declare it in the root scope it will be available everywhere, while if you declare it inside a register it will be available only in that scope and its children.
 
diff --git a/lib/contentTypeParser.js b/lib/contentTypeParser.js
index f1acc6ce..a71372d8 100644
--- a/lib/contentTypeParser.js
+++ b/lib/contentTypeParser.js
@@ -18,7 +18,8 @@ const {
 function ContentTypeParser (bodyLimit) {
   this.customParsers = {}
   this.customParsers['application/json'] = new Parser(true, false, bodyLimit, defaultJsonParser)
-  this.parserList = ['application/json']
+  this.customParsers['text/plain'] = new Parser(true, false, bodyLimit, defaultPlainTextParser)
+  this.parserList = ['application/json', 'text/plain']
   this.cache = lru(100)
 }
 
@@ -59,6 +60,9 @@ ContentTypeParser.prototype.hasParser = function (contentType) {
   if (contentType === 'application/json') {
     return this.customParsers['application/json'].fn !== defaultJsonParser
   }
+  if (contentType === 'text/plain') {
+    return this.customParsers['text/plain'].fn !== defaultPlainTextParser
+  }
   return contentType in this.customParsers
 }
 
@@ -191,6 +195,10 @@ function defaultJsonParser (req, body, done) {
   done(null, json)
 }
 
+function defaultPlainTextParser (req, body, done) {
+  done(null, body)
+}
+
 function buildContentTypeParser (c) {
   const contentTypeParser = new ContentTypeParser()
   Object.assign(contentTypeParser.customParsers, c.customParsers)
diff --git a/test/custom-parser.test.js b/test/custom-parser.test.js
index 63075d23..e6ee7e42 100644
--- a/test/custom-parser.test.js
+++ b/test/custom-parser.test.js
@@ -8,6 +8,24 @@ const sget = require('simple-get').concat
 const Fastify = require('..')
 
 const jsonParser = require('fast-json-body')
+
+function plainTextParser (request, callback) {
+  var body = ''
+  request.setEncoding('utf8')
+  request.on('error', onError)
+  request.on('data', onData)
+  request.on('end', onEnd)
+  function onError (err) {
+    callback(err, null)
+  }
+  function onData (chunk) {
+    body += chunk
+  }
+  function onEnd () {
+    callback(null, body)
+  }
+}
+
 if (semver.gt(process.versions.node, '8.0.0')) {
   require('./custom-parser-async')
 }
@@ -538,6 +556,40 @@ test('Can override the default json parser', t => {
   })
 })
 
+test('Can override the default plain text parser', t => {
+  t.plan(5)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.addContentTypeParser('text/plain', function (req, done) {
+    t.ok('called')
+    plainTextParser(req, function (err, body) {
+      done(err, body)
+    })
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: 'hello world',
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(body.toString(), 'hello world')
+      fastify.close()
+    })
+  })
+})
+
 test('Can\'t override the json parser multiple times', t => {
   t.plan(1)
   const fastify = Fastify()
@@ -560,6 +612,28 @@ test('Can\'t override the json parser multiple times', t => {
   }
 })
 
+test('Can\'t override the plain text parser multiple times', t => {
+  t.plan(1)
+  const fastify = Fastify()
+
+  fastify.addContentTypeParser('text/plain', function (req, done) {
+    plainTextParser(req, function (err, body) {
+      done(err, body)
+    })
+  })
+
+  try {
+    fastify.addContentTypeParser('text/plain', function (req, done) {
+      t.ok('called')
+      plainTextParser(req, function (err, body) {
+        done(err, body)
+      })
+    })
+  } catch (err) {
+    t.is(err.message, 'FST_ERR_CTP_ALREADY_PRESENT: Content type parser \'text/plain\' already present.')
+  }
+})
+
 test('Should get the body as string', t => {
   t.plan(6)
   const fastify = Fastify()
@@ -599,6 +673,152 @@ test('Should get the body as string', t => {
   })
 })
 
+test('Should return defined body with no custom parser defined and content type = \'text/plain\'', t => {
+  t.plan(4)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: 'hello world',
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(body.toString(), 'hello world')
+      fastify.close()
+    })
+  })
+})
+
+test('Should have typeof body object with no custom parser defined, no body defined and content type = \'text/plain\'', t => {
+  t.plan(4)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(typeof body, 'object')
+      fastify.close()
+    })
+  })
+})
+
+test('Should have typeof body object with no custom parser defined, null body and content type = \'text/plain\'', t => {
+  t.plan(4)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: null,
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(typeof body, 'object')
+      fastify.close()
+    })
+  })
+})
+
+test('Should have typeof body object with no custom parser defined, undefined body and content type = \'text/plain\'', t => {
+  t.plan(4)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: undefined,
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(typeof body, 'object')
+      fastify.close()
+    })
+  })
+})
+
+test('Should get the body as string', t => {
+  t.plan(6)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.addContentTypeParser('text/plain', { parseAs: 'string' }, function (req, body, done) {
+    t.ok('called')
+    t.ok(typeof body === 'string')
+    try {
+      var plainText = body
+      done(null, plainText)
+    } catch (err) {
+      err.statusCode = 400
+      done(err, undefined)
+    }
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: 'hello world',
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(body.toString(), 'hello world')
+      fastify.close()
+    })
+  })
+})
+
 test('Should get the body as buffer', t => {
   t.plan(6)
   const fastify = Fastify()
@@ -638,6 +858,45 @@ test('Should get the body as buffer', t => {
   })
 })
 
+test('Should get the body as buffer', t => {
+  t.plan(6)
+  const fastify = Fastify()
+
+  fastify.post('/', (req, reply) => {
+    reply.send(req.body)
+  })
+
+  fastify.addContentTypeParser('text/plain', { parseAs: 'buffer' }, function (req, body, done) {
+    t.ok('called')
+    t.ok(body instanceof Buffer)
+    try {
+      var plainText = body
+      done(null, plainText)
+    } catch (err) {
+      err.statusCode = 400
+      done(err, undefined)
+    }
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      body: 'hello world',
+      headers: {
+        'Content-Type': 'text/plain'
+      }
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(body.toString(), 'hello world')
+      fastify.close()
+    })
+  })
+})
+
 test('Should parse empty bodies as a string', t => {
   t.plan(9)
   const fastify = Fastify()
diff --git a/test/helper.js b/test/helper.js
index a9aa6424..bfad5875 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -222,14 +222,14 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
     })
 
     if (loMethod === 'options') {
-      test(`OPTIONS returns 415 - should return 415 if Content-Type is not json`, t => {
+      test(`OPTIONS returns 415 - should return 415 if Content-Type is not json or plain text`, t => {
         t.plan(2)
         sget({
           method: upMethod,
           url: 'http://localhost:' + fastify.server.address().port + '/missing',
           body: 'hello world',
           headers: {
-            'Content-Type': 'text/plain'
+            'Content-Type': 'text/xml'
           },
           timeout: 500
         }, (err, response, body) => {
