diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 00000000..38d66854
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,48 @@
+name: ci
+
+on: [push, pull_request]
+
+jobs:
+  test:
+    runs-on: ${{ matrix.os }}
+
+    strategy:
+      matrix:
+        node-version: [8.x, 10.x, 12.x, 13.x]
+        os: [ubuntu-latest, windows-latest, macOS-latest]
+
+    steps:
+      - uses: actions/checkout@v1
+
+      - name: Use Node.js
+        uses: actions/setup-node@v1
+        with:
+          node-version: ${{ matrix.node-version }}
+
+      - name: Install
+        run: |
+          npm install
+
+      - name: Check licenses
+        run: |
+          npm run license-checker
+
+      - name: Run tests
+        run: |
+          npm run test:ci
+
+      - name: Coveralls Parallel
+        uses: coverallsapp/github-action@master
+        with:
+          github-token: ${{ secrets.github_token }}
+          parallel: true
+
+  coverage:
+    needs: test
+    runs-on: ubuntu-latest
+    steps:
+      - name: Coveralls Finished
+        uses: coverallsapp/github-action@master
+        with:
+          github-token: ${{ secrets.GITHUB_TOKEN }}
+          parallel-finished: true
diff --git a/.github/workflows/package-manager-ci.yml b/.github/workflows/package-manager-ci.yml
new file mode 100644
index 00000000..f33cb418
--- /dev/null
+++ b/.github/workflows/package-manager-ci.yml
@@ -0,0 +1,59 @@
+name: package-manager-ci
+
+on:
+  push:
+    branches:
+      - master
+
+jobs:
+  pnpm:
+    runs-on: ${{ matrix.os }}
+
+    strategy:
+      matrix:
+        # Maintenance and active LTS
+        node-version: [8.x, 10.x]
+        os: [ubuntu-16.04]
+
+    steps:
+      - uses: actions/checkout@v1
+
+      - name: Use Node.js
+        uses: actions/setup-node@v1
+        with:
+          node-version: ${{ matrix.node-version }}
+
+      - name: Install with pnpm
+        run: |
+          curl -L https://unpkg.com/@pnpm/self-installer | node
+          pnpm install
+
+      - name: Run tests
+        run: |
+          pnpm run test
+
+  yarn:
+    runs-on: ${{ matrix.os }}
+
+    strategy:
+      matrix:
+        # Maintenance and active LTS
+        node-version: [8.x, 10.x]
+        os: [ubuntu-16.04]
+
+    steps:
+      - uses: actions/checkout@v1
+
+      - name: Use Node.js
+        uses: actions/setup-node@v1
+        with:
+          node-version: ${{ matrix.node-version }}
+
+      - name: Install with yarn
+        run: |
+          curl -o- -L https://yarnpkg.com/install.sh | bash
+          yarn install
+
+      - name: Run tests
+        run: |
+          yarn run test
diff --git a/.github/workflows/website.yml b/.github/workflows/website.yml
new file mode 100644
index 00000000..16cad6af
--- /dev/null
+++ b/.github/workflows/website.yml
@@ -0,0 +1,16 @@
+name: website
+
+on:
+  push:
+    branches:
+      - master
+    paths:
+      - 'docs/*'
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Build website
+        run: |
+          curl -X POST --header 'Content-Type: application/json' "https://circleci.com/api/v1.1/project/github/fastify/website?circle-token=${{ secrets.circleci_token }}"
diff --git a/.npmignore b/.npmignore
index daf76433..68f824ef 100644
--- a/.npmignore
+++ b/.npmignore
@@ -1,5 +1,7 @@
 .editorconfig
 .gitattributes
+.git
+.DS_Store
 .gitignore
 .github
 .nyc_output
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 5af089f6..18e99094 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -26,6 +26,17 @@ Code for Fastify's **v1.x** is in [branch 1.x](https://github.com/fastify/fastif
 
 Declaring formal releases remains the prerogative of the lead maintainers. Do not bump version numbers in pull requests.
 
+## Plugins
+
+The contributors to the Fastify's plugins must attend the same rules of the Fastify repository with few adjustements:
+
+1. A release can be published by any member.
+1. The plugin version must follow the [semver](http://semver.org/) specification.
+1. The Node.js compatibility must match with the Fastify's master branch.
+1. The new release must have the changelog information stored in the GitHub release.
+     For this scope we suggest to adopt a tool like [`releasify`](https://github.com/fastify/releasify) to archive this.
+1. PR opened by bots (like Greenkeeper) can be merged if the CI is green and the Node.js versions supported are the same of the plugin.
+
 ## Changes to this arrangement
 
 This is an experiment and feedback is welcome! This document may also be subject to pull-requests or changes by contributors where you believe you have something valuable to add or change.
@@ -53,8 +64,22 @@ Welcome to the team! We are happy to have you. Before you start, please complete
 2. Choose which team to join *(more than one is ok!)* based on how you want to help.
 3. Open a pull request to [`fastify/fastify:master`](https://github.com/fastify/fastify/pulls) that adds your name, username, and email to the team you have choosen in the [README.md](./README.md) and [package.json](./package.json) *(if you are part of the core team)* files. The members lists are sorted alphabetically; make sure to add your name in the proper order.
 4. Open a pull request to [`fastify/website:master`](https://github.com/fastify/website/pulls) adding yourself to the [team.yml](https://github.com/fastify/website/blob/master/src/website/data/team.yml) file. This list is also sorted alphabetically so make sure to add your name in the proper order. Use your GitHub profile icon for the `picture:` field.
-5. The person that does the onboarding must add you to the  [npm org](https://www.npmjs.com/org/fastify), so that you can help maintaining the official plugins.
-
+5. The person that does the onboarding must add you to the [npm org](https://www.npmjs.com/org/fastify), so that you can help maintaining the official plugins.
+
+### Offboarding Collaborators
+
+We are thankful to you and we are really glad to have worked with you.
+We'll be really happy to see you here again if you want to come back, but for now the person that did the onboarding must:
+1. Ask the collaborator if they want to stay or not.
+1. If the collaborator can't work with us anymore, they should:
+  1. Open a pull request to [`fastify/fastify:master`](https://github.com/fastify/fastify/pulls) and move themselves in the *Past Collaborators* section.
+  2. Open a pull request to [`fastify/website:master`](https://github.com/fastify/website/pulls) and move themselves in the *Past Collaborators* section in the [team.yml](https://github.com/fastify/website/blob/master/src/website/data/team.yml) file.
+
+The person that did the onboarding must:
+1. If the collaborator doesn't reply to the ping in reasonable time, open the pull requests described above.
+2. Remove the collaborator from the Fastify teams on GitHub.
+3. Remove the collaborator from the [npm org](https://www.npmjs.com/org/fastify).
+4. Remove the collaborator from the Azure team.
 -----------------------------------------
 
 <a id="developers-certificate-of-origin"></a>
diff --git a/README.md b/README.md
index 13fd69ec..8cfc7789 100644
--- a/README.md
+++ b/README.md
@@ -4,8 +4,11 @@
 
 <div align="center">
 
-
-[![Build Status](https://dev.azure.com/fastify/fastify/_apis/build/status/fastify.fastify)](https://dev.azure.com/fastify/fastify/_build/latest?definitionId=1) [![Known Vulnerabilities](https://snyk.io/test/github/fastify/fastify/badge.svg)](https://snyk.io/test/github/fastify/fastify)
+![](https://github.com/fastify/fastify/workflows/ci/badge.svg)
+![](https://github.com/fastify/fastify/workflows/package-manager-ci/badge.svg)
+![](https://github.com/fastify/fastify/workflows/website/badge.svg)
+[![Build Status](https://dev.azure.com/fastify/fastify/_apis/build/status/fastify.fastify)](https://dev.azure.com/fastify/fastify/_build/latest?definitionId=1)
+[![Known Vulnerabilities](https://snyk.io/test/github/fastify/fastify/badge.svg)](https://snyk.io/test/github/fastify/fastify)
 [![Coverage Status](https://coveralls.io/repos/github/fastify/fastify/badge.svg?branch=master)](https://coveralls.io/github/fastify/fastify?branch=master)
 [![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)
 
@@ -150,10 +153,11 @@ matters to you.
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Server.md"><code><b>Server</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Routes.md"><code><b>Routes</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Logging.md"><code><b>Logging</b></code></a>
-* <a href="https://github.com/fastify/fastify/blob/master/docs/Middlewares.md"><code><b>Middlewares</b></code></a>
+* <a href="https://github.com/fastify/fastify/blob/master/docs/Middleware.md"><code><b>Middleware</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Hooks.md"><code><b>Hooks</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Decorators.md"><code><b>Decorators</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md"><code><b>Validation and Serialization</b></code></a>
+* <a href="https://github.com/fastify/fastify/blob/master/docs/Fluent-Schema.md"><code><b>Fluent Schema</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md"><code><b>Lifecycle</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Reply.md"><code><b>Reply</b></code></a>
 * <a href="https://github.com/fastify/fastify/blob/master/docs/Request.md"><code><b>Request</b></code></a>
@@ -174,6 +178,7 @@ matters to you.
 ## Ecosystem
 - [Core](https://github.com/fastify/fastify/blob/master/docs/Ecosystem.md#core) - Core plugins maintained by the _Fastify_ [team](#team).
 - [Community](https://github.com/fastify/fastify/blob/master/docs/Ecosystem.md#community) - Community supported plugins.
+- [Live Examples](https://github.com/fastify/example) - Multirepo with a broad set of real working examples.
 
 ## Support
 - [Fastify help](https://github.com/fastify/help)
@@ -194,11 +199,11 @@ Team members are listed in alphabetical order.
 * [__Matteo Collina__](https://github.com/mcollina), <https://twitter.com/matteocollina>, <https://www.npmjs.com/~matteo.collina>
 * [__Tomas Della Vedova__](https://github.com/delvedor), <https://twitter.com/delvedor>, <https://www.npmjs.com/~delvedor>
 * [__Dustin Deus__](https://github.com/StarpTech), <https://twitter.com/dustindeus>, <https://www.npmjs.com/~starptech>
+* [__Denis Fäcke__](https://github.com/SerayaEryn), <https://twitter.com/serayaeryn>, <https://www.npmjs.com/~serayaeryn>
 * [__Luciano Mammino__](https://github.com/lmammino), <https://twitter.com/loige>, <https://www.npmjs.com/~lmammino>
 * [__Cemre Mengu__](https://github.com/cemremengu), <https://twitter.com/cemremengu>, <https://www.npmjs.com/~cemremengu>
 * [__Manuel Spigolon__](https://github.com/eomm), <https://twitter.com/manueomm>, <https://www.npmjs.com/~eomm>
 * [__James Sumners__](https://github.com/jsumners), <https://twitter.com/jsumners79>, <https://www.npmjs.com/~jsumners>
-* [__Nathan Woltman__](https://github.com/nwoltman), <https://twitter.com/NathanWoltman>, <https://www.npmjs.com/~nwoltman>
 
 ### Fastify Plugins team
 * [__Matteo Collina__](https://github.com/mcollina), <https://twitter.com/matteocollina>, <https://www.npmjs.com/~matteo.collina>
@@ -208,12 +213,19 @@ Team members are listed in alphabetical order.
 ### Collaborators
 Great contributors on a specific area in the Fastify ecosystem will be invited to join this group by Lead Maintainers.
 
-* [__Trivikram Kamat__](https://github.com/trivikr), <https://twitter.com/trivikram>, <https://www.npmjs.com/~trivikr>
 * [__Luciano Mammino__](https://github.com/lmammino), <https://twitter.com/loige>, <https://www.npmjs.com/~lmammino>
 * [__Evan Shortiss__](https://github.com/evanshortiss), <https://twitter.com/evanshortiss>, <https://www.npmjs.com/~evanshortiss>
 
 **Past Collaborators**
 * [__Çağatay Çalı__](https://github.com/cagataycali), <https://twitter.com/cagataycali>, <https://www.npmjs.com/~cagataycali>
+* [__Trivikram Kamat__](https://github.com/trivikr), <https://twitter.com/trivikram>, <https://www.npmjs.com/~trivikr>
+* [__Nathan Woltman__](https://github.com/nwoltman), <https://twitter.com/NathanWoltman>, <https://www.npmjs.com/~nwoltman>
+
+## Hosted by
+
+[<img src="https://github.com/openjs-foundation/cross-project-council/blob/master/logos/openjsf-color.png?raw=true" width="250px;"/>](https://openjsf.org/projects/#incubating)
+
+We are currently an [incubated project](https://openjsf.org/blog/2019/11/20/web-framework-fastify-joins-openjs-foundation-as-an-incubating-project/) at the OpenJS Foundation.
 
 ## Acknowledgements
 
diff --git a/SECURITY.md b/SECURITY.md
new file mode 100644
index 00000000..e31f0f03
--- /dev/null
+++ b/SECURITY.md
@@ -0,0 +1,33 @@
+# Security Policy
+
+This document describes the management of vulnerabilities for the Fastify project and it's officials' plugins.
+
+
+## Reporting vulnerabilities
+
+Individuals who find potential vulnerabilities in Fastify are invited to complete a vulnerability report via the dedicated HackerOne tool for Node.js modules: [https://hackerone.com/nodejs-ecosystem](https://hackerone.com/nodejs-ecosystem).
+
+### How to report a vulnerabiliy
+
+It is of the utmost importance that you read carefully [**HOW TO REPORT A VULNERABILIY**](https://github.com/nodejs/security-wg/blob/master/processes/third_party_vuln_process.md) written by the Security Working Group of Node.js.
+
+
+## Handling vulnerability reports
+
+When a potential vulnerability is reported and confirmed the Fastify Core Team will intervene in the
+`follow-up` stage of the process following the workflow and the timings described in the Security WG's document.
+
+### Vulnerabilities found outside this process
+
+⚠ The Fastify project does not support any reporting outside the HackerOne process.
+
+
+## The Fastify Core team
+
+The core team is responsible for the management of [this](https://github.com/nodejs/security-wg/blob/master/processes/third_party_vuln_process.md#handling-vulnerability-reports) process.
+
+Members of this team are expected to keep all information that they have privileged access to by being
+on the team completely private to the team. This includes agreeing to not notify anyone outside the
+team of issues that have not yet been disclosed publicly, including the existence of issues,
+expectations of upcoming releases, and patching of any issues other than in the process of their work
+as a member of the Fastify Core team.
diff --git a/azure-pipelines.yml b/azure-pipelines.yml
index 8f192cde..61a2e839 100644
--- a/azure-pipelines.yml
+++ b/azure-pipelines.yml
@@ -24,7 +24,7 @@ jobs:
 
 - template: build/azure-pipelines-yarn-template.yml
   parameters:
-    name: Windows_yarm
+    name: Windows_yarn
     vmImage: vs2017-win2016
 
 - template: build/azure-pipelines-yarn-template.yml
diff --git a/build/azure-pipelines-npm-template.yml b/build/azure-pipelines-npm-template.yml
index 41f25e2b..f313e431 100644
--- a/build/azure-pipelines-npm-template.yml
+++ b/build/azure-pipelines-npm-template.yml
@@ -5,6 +5,8 @@ jobs:
 
   strategy:
     matrix:
+      node_13_x:
+        node_version: 13.x
       node_12_x:
         node_version: 12.x
       node_10_x:
diff --git a/build/azure-pipelines-yarn-template.yml b/build/azure-pipelines-yarn-template.yml
index 92b76d81..52f8c675 100644
--- a/build/azure-pipelines-yarn-template.yml
+++ b/build/azure-pipelines-yarn-template.yml
@@ -5,6 +5,8 @@ jobs:
 
   strategy:
     matrix:
+      node_13_x:
+        node_version: 13.x
       node_12_x:
         node_version: 12.x
       node_10_x:
diff --git a/build/build-validation.js b/build/build-validation.js
index 01eebf40..852c6ce7 100644
--- a/build/build-validation.js
+++ b/build/build-validation.js
@@ -15,9 +15,12 @@ const ajv = new Ajv({
 const defaultInitOptions = {
   bodyLimit: 1024 * 1024, // 1 MiB
   caseSensitive: true,
+  disableRequestLogging: false,
   ignoreTrailingSlash: false,
   maxParamLength: 100,
   onProtoPoisoning: 'error',
+  // TODO v3: default should be 'error'
+  onConstructorPoisoning: 'ignore',
   pluginTimeout: 10000,
   requestIdHeader: 'request-id',
   requestIdLogLabel: 'reqId'
@@ -62,8 +65,13 @@ const schema = {
       then: { setDefaultValue: true }
     },
     ignoreTrailingSlash: { type: 'boolean', default: defaultInitOptions.ignoreTrailingSlash },
+    disableRequestLogging: {
+      type: 'boolean',
+      default: false
+    },
     maxParamLength: { type: 'integer', default: defaultInitOptions.maxParamLength },
     onProtoPoisoning: { type: 'string', default: defaultInitOptions.onProtoPoisoning },
+    onConstructorPoisoning: { type: 'string', default: defaultInitOptions.onConstructorPoisoning },
     pluginTimeout: { type: 'integer', default: defaultInitOptions.pluginTimeout },
     requestIdHeader: { type: 'string', default: defaultInitOptions.requestIdHeader },
     requestIdLogLabel: { type: 'string', default: defaultInitOptions.requestIdLogLabel }
@@ -72,7 +80,7 @@ const schema = {
 
 const validate = ajv.compile(schema)
 
-let moduleCode = `// This file is autogenerated by ${__filename.replace(__dirname, 'build')}, do not edit
+const moduleCode = `// This file is autogenerated by ${__filename.replace(__dirname, 'build')}, do not edit
 /* istanbul ignore file */
 // constant needed for customRule0 to work
 const self = {}
diff --git a/docs/Benchmarking.md b/docs/Benchmarking.md
index f5888506..cf372670 100644
--- a/docs/Benchmarking.md
+++ b/docs/Benchmarking.md
@@ -1,13 +1,13 @@
 <h1 align="center">Fastify</h1>
 
 ## Benchmarking
-Benchmarking is important if you want to measure how a change can impact your application performance. We provide a simple way to benchmark your application from the point of view of a user and contributor. The setup allows you to automate benchmarks in different branches on different Node.js versions.
+Benchmarking is important if you want to measure how a change can impact the performance of your application. We provide a simple way to benchmark your application from the point of view of a user and contributor. The setup allows you to automate benchmarks in different branches and on different Node.js versions.
 
 The modules we'll use:
 - [Autocannon](https://github.com/mcollina/autocannon): A HTTP/1.1 benchmarking tool written in node.
 - [Branch-comparer](https://github.com/StarpTech/branch-comparer): Checkout multiple git branches, execute scripts and log the results.
 - [Concurrently](https://github.com/kimmobrunfeldt/concurrently): Run commands concurrently.
-- [Npx](https://github.com/zkat/npx) NPM package runner - We using it to run scripts against different Node.js Versions and execute local binaries. Shipped with npm@5.2.0.
+- [Npx](https://github.com/zkat/npx) NPM package runner - We are using it to run scripts against different Node.js Versions and to execute local binaries. Shipped with npm@5.2.0.
 
 ## Simple
 
diff --git a/docs/ContentTypeParser.md b/docs/ContentTypeParser.md
index 3780891f..96885dae 100644
--- a/docs/ContentTypeParser.md
+++ b/docs/ContentTypeParser.md
@@ -1,11 +1,11 @@
 <h1 align="center">Fastify</h1>
 
-## Content Type Parser
+## `Content-Type` Parser
 Natively, Fastify only supports `'application/json'` and `'text/plain'` content types. The default charset is `utf-8`. If you need to support different content types, you can use the `addContentTypeParser` API. *The default JSON and/or plain text parser can be changed.*
 
-As with the other APIs, `addContentTypeParser` is encapsulated in the scope in which it is declared. This means that if you declare it in the root scope it will be available everywhere, while if you declare it inside a register it will be available only in that scope and its children.
+As with the other APIs, `addContentTypeParser` is encapsulated in the scope in which it is declared. This means that if you declare it in the root scope it will be available everywhere, while if you declare it inside a plugin it will be available only in that scope and its children.
 
-Fastify adds automatically the parsed request payload to the [Fastify request](https://github.com/fastify/fastify/blob/master/docs/Request.md) object, you can reach it with `request.body`.
+Fastify automatically adds the parsed request payload to the [Fastify request](https://github.com/fastify/fastify/blob/master/docs/Request.md) object which you can access with `request.body`.
 
 ### Usage
 ```js
@@ -14,13 +14,15 @@ fastify.addContentTypeParser('application/jsoff', function (req, done) {
     done(err, body)
   })
 })
-// handle multiple content types as the same
+
+// Handle multiple content types with the same function
 fastify.addContentTypeParser(['text/xml', 'application/xml'], function (req, done) {
   xmlParser(req, function (err, body) {
     done(err, body)
   })
 })
-// async supported in Node versions >= 8.x
+
+// Async is also supported in Node versions >= 8.0.0
 fastify.addContentTypeParser('application/jsoff', async function (req) {
   var res = await new Promise((resolve, reject) => resolve(req))
   return res
@@ -32,13 +34,13 @@ You can also use the `hasContentTypeParser` API to find if a specific content ty
 ```js
 if (!fastify.hasContentTypeParser('application/jsoff')){
   fastify.addContentTypeParser('application/jsoff', function (req, done) {
-    // code to parse request body / payload for given content type
+    // Code to parse request body/payload for the given content type
   })
 }
 ```
 
 #### Body Parser
-You can parse the body of the request in two ways. The first one is shown above: you add a custom content type parser and handle the request stream. In the second one you should pass a `parseAs` option to the `addContentTypeParser` API, where you declare how you want to get the body, it could be `'string'` or `'buffer'`. If you use the `parseAs` option Fastify will internally handle the stream and perform some checks, such as the [maximum size](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-body-limit) of the body and the content length. If the limit is exceeded the custom parser will not be invoked.
+You can parse the body of a request in two ways. The first one is shown above: you add a custom content type parser and handle the request stream. In the second one, you should pass a `parseAs` option to the `addContentTypeParser` API, where you declare how you want to get the body. It could be of type `'string'` or `'buffer'`. If you use the `parseAs` option, Fastify will internally handle the stream and perform some checks, such as the [maximum size](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-body-limit) of the body and the content length. If the limit is exceeded the custom parser will not be invoked.
 ```js
 fastify.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {
   try {
@@ -58,8 +60,8 @@ See [`example/parser.js`](https://github.com/fastify/fastify/blob/master/example
 + `parseAs` (string): Either `'string'` or `'buffer'` to designate how the incoming data should be collected. Default: `'buffer'`.
 + `bodyLimit` (number): The maximum payload size, in bytes, that the custom parser will accept. Defaults to the global body limit passed to the [`Fastify factory function`](https://github.com/fastify/fastify/blob/master/docs/Server.md#bodylimit).
 
-#### Catch All
-There are some cases where you need to catch all requests regardless of their content type. With Fastify, you just need to add the `'*'` content type.
+#### Catch-All
+There are some cases where you need to catch all requests regardless of their content type. With Fastify, you can just use the `'*'` content type.
 ```js
 fastify.addContentTypeParser('*', function (req, done) {
   var data = ''
@@ -70,7 +72,7 @@ fastify.addContentTypeParser('*', function (req, done) {
 })
 ```
 
-In this way, all of the requests that do not have a corresponding content type parser will be handled by the specified function.
+Using this, all requests that do not have a corresponding content type parser will be handled by the specified function.
 
 This is also useful for piping the request stream. You can define a content parser like:
 
diff --git a/docs/Decorators.md b/docs/Decorators.md
index 2a6a1b66..21904784 100644
--- a/docs/Decorators.md
+++ b/docs/Decorators.md
@@ -2,9 +2,9 @@
 
 ## Decorators
 
-If you need to add functionality to the Fastify instance, the `decorate` API is what you need.
+If you need to add functionality to the Fastify instance, the `decorate` API is what you want.
 
-The API allows you to add new properties to the Fastify instance. A value is not restricted to a function and could also be an object or a string, for example.
+The API allows you to add new properties to the Fastify instance. Possible values are not restricted by type and could be functions, objects or strings, for example.
 
 <a name="usage"></a>
 ### Usage
@@ -13,11 +13,11 @@ The API allows you to add new properties to the Fastify instance. A value is not
 Just call the `decorate` API and pass the name of the new property and its value.
 ```js
 fastify.decorate('utility', () => {
-  // something very useful
+  // Something very useful
 })
 ```
 
-As said above, you can also decorate the instance with non-function values:
+As mentioned above, you can also decorate the instance with non-function values:
 ```js
 fastify.decorate('conf', {
   db: 'some.db',
@@ -25,7 +25,7 @@ fastify.decorate('conf', {
 })
 ```
 
-Once you decorate the instance, you can access the value by using the name you passed as a parameter:
+Once the instance was decorated, you can access the new value by using the name you passed as a parameter:
 ```js
 fastify.utility()
 
@@ -34,14 +34,14 @@ console.log(fastify.conf.db)
 
 <a name="decorate-reply"></a>
 **decorateReply**
-As the name suggests, this API is needed if you want to add new methods to the `Reply` core object. Just call the `decorateReply` API and pass the name of the new property and its value:
+As the name suggests, this API can be used to add new methods to the `Reply` core object. Just call the `decorateReply` API and pass the name of the new property and its value:
 ```js
 fastify.decorateReply('utility', function () {
-  // something very useful
+  // Something very useful
 })
 ```
 
-Note: using an arrow function will break the binding of `this` to the Fastify `reply` instance.
+Note: using an arrow function will break the binding of `this` to the Fastify `Reply` instance.
 
 <a name="decorate-request"></a>
 **decorateRequest**
@@ -52,12 +52,12 @@ fastify.decorateRequest('utility', function () {
 })
 ```
 
-Note: using an arrow function will break the binding of `this` to the Fastify `request` instance.
+Note: using an arrow function will break the binding of `this` to the Fastify `Request` instance.
 
 <a name="decorators-encapsulation"></a>
-#### Decorators and encapsulation
+#### Decorators and Encapsulation
 
-If you define a decorator (using decorate, decorateRequest or decorateReply) with the same name more than once in the same **encapsulated** plugin, fastify will throw an exception.
+If you define a decorator (using `decorate`, `decorateRequest` or `decorateReply`) with the same name more than once in the same **encapsulated** plugin, Fastify will throw an exception.
 
 As an example, the following will throw:
 
@@ -65,7 +65,7 @@ As an example, the following will throw:
 const server = require('fastify')()
 
 server.decorateReply('view', function (template, args) {
-  // Amazing view rendering engine.
+  // Amazing view rendering engine
 })
 
 server.get('/', (req, reply) => {
@@ -75,7 +75,7 @@ server.get('/', (req, reply) => {
 // Somewhere else in our codebase, we define another
 // view decorator. This throws.
 server.decorateReply('view', function (template, args) {
-  // another rendering engine
+  // Another rendering engine
 })
 
 server.listen(3000)
@@ -96,7 +96,7 @@ server.register(async function (server, opts) {
   // plugin. This will not throw as outside of this encapsulated
   // plugin view is the old one, while inside it is the new one.
   server.decorateReply('view', function (template, args) {
-    // another rendering engine
+    // Another rendering engine
   })
 
   server.get('/', (req, reply) => {
@@ -137,9 +137,9 @@ As an example let's add a user property to the `Request` object:
 fastify.decorateRequest('user', '')
 
 // Update our property
-fastify.addHook('preHandler', (req, reply, next) => {
+fastify.addHook('preHandler', (req, reply, done) => {
   req.user = 'Bob Dylan'
-  next()
+  done()
 })
 // And finally access it
 fastify.get('/', (req, reply) => {
diff --git a/docs/Ecosystem.md b/docs/Ecosystem.md
index fda4d057..e75b6942 100644
--- a/docs/Ecosystem.md
+++ b/docs/Ecosystem.md
@@ -47,8 +47,12 @@ Plugins maintained by the fastify team are listed under [Core](#core) while plug
 
 - [`apollo-server-fastify`](https://github.com/apollographql/apollo-server/tree/master/packages/apollo-server-fastify) Run an [Apollo Server](https://github.com/apollographql/apollo-server) to serve GraphQL with Fastify.
 - [`arecibo`](https://github.com/nucleode/arecibo) Fastify ping responder for Kubernetes Liveness and Readiness Probes.
+- [`cls-rtracer`](https://github.com/puzpuzpuz/cls-rtracer) Fastify middleware for CLS-based request id generation. An out-of-the-box solution for adding request ids into your logs.
 - [`fastify-405`](https://github.com/Eomm/fastify-405) Fastify plugin that adds 405 HTTP status to your routes
+- [`fastify-amqp`](https://github.com/RafaelGSS/fastify-amqp) Fastify AMQP connection plugin, to use with RabbitMQ or another connector. Just a wrapper to [`amqplib`](https://github.com/squaremo/amqp.node).
 - [`fastify-angular-universal`](https://github.com/exequiel09/fastify-angular-universal) Angular server-side rendering support using [`@angular/platform-server`](https://github.com/angular/angular/tree/master/packages/platform-server) for Fastify
+- [`fastify-auth0-verify`](https://github.com/nearform/fastify-auth0-verify): Auth0 verification plugin for Fastify, internally uses [fastify-jwt](https://npm.im/fastify-jwt) and [jsonwebtoken](https://npm.im/jsonwebtoken).
+- [`fastify-autocrud`](https://github.com/paranoiasystem/fastify-autocrud) Plugin for autogenerate CRUD routes as fast as possible.
 - [`fastify-babel`](https://github.com/cfware/fastify-babel) Fastify plugin for development servers which require babel transformations of JavaScript sources.
 - [`fastify-blipp`](https://github.com/PavelPolyakov/fastify-blipp) Prints your routes to the console, so you definitely know which endpoints are available.
 - [`fastify-bookshelf`](https://github.com/butlerx/fastify-bookshelfjs) Fastify plugin to add [bookshelf.js](http://bookshelfjs.org/) orm support.
@@ -58,8 +62,10 @@ Plugins maintained by the fastify team are listed under [Core](#core) while plug
 - [`fastify-couchdb`](https://github.com/nigelhanlon/fastify-couchdb) Fastify plugin to add CouchDB support via [nano](https://github.com/apache/nano).
 - [`fastify-csrf`](https://github.com/Tarang11/fastify-csrf) A csrf plugin for Fastify.
 - [`fastify-datastore`](https://github.com/now-ims/now-fastify-datastore) Fastify plugin for [Google Cloud Datastore](https://cloud.google.com/nodejs/docs/reference/datastore/1.4.x/).
+- [`fastify-decorators`](https://github.com/L2jLiga/fastify-decorators) Fastify plugin that provides the set of TypeScript decorators.
 - [`fastify-dynamodb`](https://github.com/matrus2/fastify-dynamodb) AWS DynamoDB plugin for Fastify. It exposes [AWS.DynamoDB.DocumentClient()](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html) object.
 - [`fastify-error-page`](https://github.com/hemerajs/fastify-error-page) Fastify plugin to print errors in structured HTML to the browser.
+- [`fastify-errors-properties`](https://github.com/ShogunPanda/fastify-errors-properties) A error handling plugin for Fastify that enables additional properties in errors.
 - [`fastify-favicon`](https://github.com/smartiniOnGitHub/fastify-favicon) Fastify plugin to serve default favicon.
 - [`fastify-feature-flags`](https://gitlab.com/m03geek/fastify-feature-flags) Fastify feature flags plugin with multiple providers support (e.g. env, [config](http://lorenwest.github.io/node-config/), [unleash](https://unleash.github.io/)).
 - [`fastify-file-upload`](https://github.com/huangang/fastify-file-upload) Fastify plugin for uploading files.
@@ -71,6 +77,7 @@ Plugins maintained by the fastify team are listed under [Core](#core) while plug
 - [`fastify-healthcheck`](https://github.com/smartiniOnGitHub/fastify-healthcheck) Fastify plugin to serve an health check route and a probe script.
 - [`fastify-hemera`](https://github.com/hemerajs/fastify-hemera) Fastify Hemera plugin, for writing reliable & fault-tolerant microservices with [nats.io](https://nats.io/).
 - [`fastify-http2https`](https://github.com/lolo32/fastify-http2https) Redirect HTTP requests to HTTPS, both using the same port number, or different response on HTTP and HTTPS.
+- [`fastify-https-redirect`](https://github.com/tomsvogel/fastify-https-redirect) Fastify plugin for auto redirect from http to https
 - [`fastify-http-client`](https://github.com/kenuyx/fastify-http-client) Plugin to send HTTP(s) requests. Built upon [urllib](https://github.com/node-modules/urllib).
 - [`fastify-influxdb`](https://github.com/alex-ppg/fastify-influxdb) Fastify InfluxDB plugin connecting to an InfluxDB instance via the Influx default package.
 - [`fastify-jwt-authz`](https://github.com/Ethan-Arrowood/fastify-jwt-authz) JWT user scope verifier.
@@ -84,19 +91,23 @@ Plugins maintained by the fastify team are listed under [Core](#core) while plug
 - [`fastify-markdown`](https://github.com/freezestudio/fastify-markdown) Plugin to markdown support.
 - [`fastify-metrics`](https://gitlab.com/m03geek/fastify-metrics) Plugin for exporting [Prometheus](https://prometheus.io) metrics.
 - [`fastify-mongo-memory`](https://github.com/chapuletta/fastify-mongo-memory) Fastify MongoDB in Memory Plugin for testing support.
+- [`fastify-mongoose-api`](https://github.com/jeka-kiselyov/fastify-mongoose-api) Fastify plugin to create REST API methods based on Mongoose MongoDB models.
 - [`fastify-mongoose-driver`](https://github.com/alex-ppg/fastify-mongoose) Fastify Mongoose plugin that connects to a MongoDB via the Mongoose plugin with support for Models.
-- [`fastify-multer`](https://github.com/fox1t/multer) Multer is a plugin for handling multipart/form-data, which is primarily used for uploading files.
+- [`fastify-multer`](https://github.com/fox1t/fastify-multer) Multer is a plugin for handling multipart/form-data, which is primarily used for uploading files.
 - [`fastify-nats`](https://github.com/mahmed8003/fastify-nats) Plugin to share [NATS](http://nats.io) client across Fastify.
+- [`fastify-no-additional-properties`](https://github.com/greguz/fastify-no-additional-properties) Add `additionalProperties: false` by default to your JSON Schemas.
 - [`fastify-no-icon`](https://github.com/jsumners/fastify-no-icon) Plugin to eliminate thrown errors for `/favicon.ico` requests.
 - [`fastify-nodemailer`](https://github.com/lependu/fastify-nodemailer) Plugin to share [nodemailer](http://nodemailer.com) transporter across Fastify.
 - [`fastify-normalize-request-reply`](https://github.com/ericrglass/fastify-normalize-request-reply) Plugin to normalize the request and reply to the Express version 4.x request and response, which allows use of middleware, like swagger-stats, that was originally written for Express.
-- [`fastify-nuxt`](https://github.com/lyquocnam/fastify-nuxt) VueJS server side rendering support for Fastify with [`NuxtJS`](https://nuxtjs.org/)
 - [`fastify-oas`](https://gitlab.com/m03geek/fastify-oas) Generates OpenAPI 3.0+ documentation from routes schemas for Fastify.
 - [`fastify-openapi-glue`](https://github.com/seriousme/fastify-openapi-glue) Glue for Open Api specifications in Fastify, autogenerates routes based on an Open Api Specification
 - [`fastify-oracle`](https://github.com/cemremengu/fastify-oracle) Attaches an [`oracledb`](https://github.com/oracle/node-oracledb) connection pool to a Fastify server instance.
 - [`fastify-orientdb`](https://github.com/mahmed8003/fastify-orientdb) Fastify OrientDB connection plugin, with which you can share the OrientDB connection across every part of your server.
+- [`fastify-qs`](https://github.com/webdevium/fastify-qs) A plugin for Fastify that adds support for parsing URL query parameters with [qs](https://github.com/ljharb/qs).
+- [`fastify-rbac`](https://gitlab.com/m03geek/fastify-rbac) Fastify role-based access control plugin.
 - [`fastify-register-routes`](https://github.com/israeleriston/fastify-register-routes) Plugin to automatically load routes from a specified path and optionally limit loaded file names by a regular expression.
 - [`fastify-response-time`](https://github.com/lolo32/fastify-response-time) Add `X-Response-Time` header at each request for Fastify, in milliseconds.
+- [`fastify-reverse-routes`](https://github.com/dimonnwc3/fastify-reverse-routes) Fastify reverse routes plugin, allows to defined named routes and build path using name and parameters.
 - [`fastify-rob-config`](https://github.com/jeromemacias/fastify-rob-config) Fastify Rob-Config integration.
 - [`fastify-schema-constraint`](https://github.com/Eomm/fastify-schema-constraint) Choose the JSON schema to use based on request parameters.
 - [`fastify-sentry`](https://github.com/alex-ppg/fastify-sentry) Fastify plugin to add the Sentry SDK error handler to requests.
diff --git a/docs/Errors.md b/docs/Errors.md
index 4d4d701b..a95ea67b 100644
--- a/docs/Errors.md
+++ b/docs/Errors.md
@@ -6,12 +6,12 @@
 <a name="error-handling"></a>
 ### Error Handling
 
-Uncaught errors are likely to cause memory leaks, file descriptor leaks and other major production issues. [Domains](https://nodejs.org/en/docs/guides/domain-postmortem/) were introduced to try fixing this issue, but they did not. Given the fact that it is not possible to process all uncaught errors in a sensible way, the best way to deal with them at the moment is to [crash](https://nodejs.org/api/process.html#process_warning_using_uncaughtexception_correctly). In case of promises, make sure to [handle](https://nodejs.org/dist/latest-v8.x/docs/api/deprecations.html#deprecations_dep0018_unhandled_promise_rejections) errors [correctly](https://github.com/mcollina/make-promises-safe).
+Uncaught errors are likely to cause memory leaks, file descriptor leaks and other major production issues. [Domains](https://nodejs.org/en/docs/guides/domain-postmortem/) were introduced to try fixing this issue, but they did not. Given the fact that it is not possible to process all uncaught errors sensibly, the best way to deal with them at the moment is to [crash](https://nodejs.org/api/process.html#process_warning_using_uncaughtexception_correctly). In case of promises, make sure to [handle](https://nodejs.org/dist/latest-v8.x/docs/api/deprecations.html#deprecations_dep0018_unhandled_promise_rejections) errors [correctly](https://github.com/mcollina/make-promises-safe).
 
 Fastify follows an all-or-nothing approach and aims to be lean and optimal as much as possible. Thus, the developer is responsible for making sure that the errors are handled properly. Most of the errors are usually a result of unexpected input data, so we recommend specifying a [JSON.schema validation](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md) for your input data.
 
-Note that Fastify doesn't catch uncaught errors within callback based routes for you, so any uncaught errors will result in a crash.
-If routes are declared as `async` though - the error will safely be caught by the promise and routed to the default error handler of Fastify for a generic `Internal Server Error` response. For customizing this behavior, you should use [setErrorHandler](https://github.com/fastify/fastify/blob/master/docs/Server.md#seterrorhandler).
+Note that Fastify doesn't catch uncaught errors within callback-based routes for you, so any uncaught errors will result in a crash.
+If routes are declared as `async` though - the error will safely be caught by the promise and routed to the default error handler of Fastify for a generic `Internal Server Error` response. For customizing this behaviour, you should use [setErrorHandler](https://github.com/fastify/fastify/blob/master/docs/Server.md#seterrorhandler).
 
 <a name="fastify-error-codes"></a>
 ### Fastify Error Codes
@@ -24,7 +24,7 @@ The parser for this content type was already registered.
 <a name="FST_ERR_CTP_INVALID_TYPE"></a>
 #### FST_ERR_CTP_INVALID_TYPE
 
-The content type should be a string.
+The `Content-Type` should be a string.
 
 <a name="FST_ERR_CTP_EMPTY_TYPE"></a>
 #### FST_ERR_CTP_EMPTY_TYPE
@@ -44,12 +44,12 @@ The provided parse type is not supported. Accepted values are `string` or `buffe
 <a name="FST_ERR_CTP_BODY_TOO_LARGE"></a>
 #### FST_ERR_CTP_BODY_TOO_LARGE
 
-Request body is larger than the provided limit.
+The request body is larger than the provided limit.
 
 <a name="FST_ERR_CTP_INVALID_MEDIA_TYPE"></a>
 #### FST_ERR_CTP_INVALID_MEDIA_TYPE
 
-Received media type is not supported (i.e. there is no suitable content-type parser for it).
+The received media type is not supported (i.e. there is no suitable `Content-Type` parser for it).
 
 <a name="FST_ERR_CTP_INVALID_CONTENT_LENGTH"></a>
 #### FST_ERR_CTP_INVALID_CONTENT_LENGTH
@@ -79,7 +79,7 @@ The hook callback must be a function.
 <a name="FST_ERR_LOG_INVALID_DESTINATION"></a>
 #### FST_ERR_LOG_INVALID_DESTINATION
 
-Logger acceptes either a `'stream'` or a `'file'` as the destination.
+The logger accepts either a `'stream'` or a `'file'` as the destination.
 
 <a id="FST_ERR_REP_ALREADY_SENT"></a>
 ### FST_ERR_REP_ALREADY_SENT
@@ -111,7 +111,12 @@ A schema with the same `$id` already exists.
 
 No schema with the provided `$id` exists.
 
+<a name="FST_ERR_SCH_BUILD"></a>
+#### FST_ERR_SCH_BUILD
+
+The JSON schema provided to one route is not valid.
+
 <a name="FST_ERR_PROMISE_NOT_FULLFILLED"></a>
 #### FST_ERR_PROMISE_NOT_FULLFILLED
 
-Promise may not be fulfilled with 'undefined' when statusCode is not 204.
+A promise may not be fulfilled with 'undefined' when statusCode is not 204.
diff --git a/docs/Fluent-Schema.md b/docs/Fluent-Schema.md
index 6a4fd4b0..415cd520 100644
--- a/docs/Fluent-Schema.md
+++ b/docs/Fluent-Schema.md
@@ -2,19 +2,16 @@
 
 ## Fluent Schema
 
-The [Validation and Serialization](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md)
-has explained all the parameter accepted by Fastify to set a JSON Schema Validation, to validates
-the input, and a JSON Schema Serialization to optimize the output.
+The [Validation and Serialization](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md) documentation outlines all parameters accepted by Fastify to set up JSON Schema Validation in order to validate the input, and JSON Schema Serialization in order to optimize the output.
 
-To set up the JSON schemas of our Fastify application, we can use [`fluent-schema`][fluent-schema-repo]
-to simplify this task and reuse constants values.
+[`fluent-schema`](fluent-schema-repo) can be used to simplify this task while allowing the reuse of constants.
 
 ### Basic settings
 
 ```js
 const S = require('fluent-schema')
 
-// You can have an object like this, or query a db to get the values
+// You can have an object like this, or query a DB to get the values
 const MY_KEY = {
   KEY1: 'ONE',
   KEY2: 'TWO'
@@ -41,11 +38,12 @@ const paramsJsonSchema = S.object()
 const headersJsonSchema = S.object()
   .prop('x-foo', S.string().required())
 
+// Note that there is no need to call `.valueOf()`!
 const schema = {
-  body: bodyJsonSchema.valueOf(),
-  querystring: queryStringJsonSchema.valueOf(),
-  params: paramsJsonSchema.valueOf(),
-  headers: headersJsonSchema.valueOf()
+  body: bodyJsonSchema,
+  querystring: queryStringJsonSchema, // (or) query: queryStringJsonSchema
+  params: paramsJsonSchema,
+  headers: headersJsonSchema
 }
 
 fastify.post('/the/url', { schema }, handler)
@@ -55,11 +53,11 @@ fastify.post('/the/url', { schema }, handler)
 
 With `fluent-schema` you can manipulate your schemas in an easier and programmatic way and then reuse them
 thanks to the `addSchema()` method. You can refer to the schema in two different manners that are detailed
-in [Validation-and-Serialization.md](./Validation-and-Serialization.md#adding-a-shared-schema) document.
+in the [Validation-and-Serialization.md](./Validation-and-Serialization.md#adding-a-shared-schema) documentation.
 
-Here some example usage:
+Here are some usage examples:
 
-**`$ref-way`**: refer to external schema.
+**`$ref-way`**: refer to an external schema.
 
 ```js
 const addressSchema = S.object()
@@ -69,20 +67,17 @@ const addressSchema = S.object()
   .prop('country').required()
   .prop('city').required()
   .prop('zipcode').required()
-  .valueOf()
 
 const commonSchemas = S.object()
   .id('https://fastify/demo')
   .definition('addressSchema', addressSchema)
-  .definition('otherSchema', otherSchema) // you can add any schemas you need
-  .valueOf()
+  .definition('otherSchema', otherSchema) // You can add any schemas you need
 
 fastify.addSchema(commonSchemas)
 
 const bodyJsonSchema = S.object()
   .prop('residence', S.ref('https://fastify/demo#address')).required()
   .prop('office', S.ref('https://fastify/demo#/definitions/addressSchema')).required()
-  .valueOf()
 
 const schema = { body: bodyJsonSchema }
 
@@ -119,6 +114,6 @@ const schema = { body: bodyJsonSchema }
 fastify.post('/the/url', { schema }, handler)
 ```
 
-NB: you can mix up the usage `$ref-way` and the `replace-way` with `fastify.addSchema`.
+NB: you can mix up the `$ref-way` and the `replace-way` when using `fastify.addSchema`.
 
 [fluent-schema-repo]: https://github.com/fastify/fluent-schema
diff --git a/docs/Getting-Started.md b/docs/Getting-Started.md
index 7f6d843f..59e706d0 100644
--- a/docs/Getting-Started.md
+++ b/docs/Getting-Started.md
@@ -2,7 +2,7 @@
 
 ## Getting Started
 Hello! Thank you for checking out Fastify!<br>
-This document aims to be a gentle introduction to the framework and its features. It is an elementary introduction with examples and links to other parts of the documentation.<br>
+This document aims to be a gentle introduction to the framework and its features. It is an elementary preface with examples and links to other parts of the documentation.<br>
 Let's start!
 
 <a name="install"></a>
@@ -41,7 +41,7 @@ fastify.listen(3000, function (err, address) {
 ```
 
 Do you prefer to use `async/await`? Fastify supports it out-of-the-box.<br>
-*(we also suggest using [make-promises-safe](https://github.com/mcollina/make-promises-safe) to avoid file descriptor and memory leaks)*
+*(We also suggest using [make-promises-safe](https://github.com/mcollina/make-promises-safe) to avoid file descriptor and memory leaks.)*
 ```js
 const fastify = require('fastify')()
 
@@ -61,8 +61,8 @@ start()
 ```
 
 Awesome, that was easy.<br>
-Unfortunately, writing a complex application requires significantly more code than this example. A classic problem when you are building a new application is how handle multiple files, asynchronous bootstrapping and the architecture of your code.<br>
-Fastify offers an easy platform that helps solve all of problems, and more.
+Unfortunately, writing a complex application requires significantly more code than this example. A classic problem when you are building a new application is how to handle multiple files, asynchronous bootstrapping and the architecture of your code.<br>
+Fastify offers an easy platform that helps to solve all of the problems outlined above, and more!
 
 > ## Note
 > The above examples, and subsequent examples in this document, default to listening *only* on the localhost `127.0.0.1` interface. To listen on all available IPv4 interfaces the example should be modified to listen on `0.0.0.0` like so:
@@ -83,9 +83,9 @@ Fastify offers an easy platform that helps solve all of problems, and more.
 
 <a name="first-plugin"></a>
 ### Your first plugin
-As with JavaScript everything is an object, with Fastify everything is a plugin.<br>
+As with JavaScript, where everything is an object, with Fastify everything is a plugin.<br>
 Before digging into it, let's see how it works!<br>
-Let's declare our basic server, but instead of declaring the route inside the entry point, we'll declare it in an external file (checkout the [route declaration](https://github.com/fastify/fastify/blob/master/docs/Routes.md) docs).
+Let's declare our basic server, but instead of declaring the route inside the entry point, we'll declare it in an external file (check out the [route declaration](https://github.com/fastify/fastify/blob/master/docs/Routes.md) docs).
 ```js
 const fastify = require('fastify')({
   logger: true
@@ -113,16 +113,22 @@ async function routes (fastify, options) {
 
 module.exports = routes
 ```
-In this example we used the `register` API. This API is the core of the Fastify framework, and is the only way to register routes, plugins and so on.
+In this example, we used the `register` API, which is the core of the Fastify framework. It is the only way to add routes, plugins, et cetera.
 
-At the beginning of this guide we noted that Fastify provides a foundation that assists with the asynchronous bootstrapping of your application. Why this is important?
-Consider the scenario where a database connection is needed to handle data storage. Obviously the database connection needs to be available prior to the server accepting connections. How do we address this problem?<br>
-A typical solution is to use a complex callback, or promises, system that will mix the framework API with other libraries and the application code.<br>
+At the beginning of this guide, we noted that Fastify provides a foundation that assists with asynchronous bootstrapping of your application. Why is this important?
+Consider the scenario where a database connection is needed to handle data storage. Obviously, the database connection needs to be available before the server is accepting connections. How do we address this problem?<br>
+A typical solution is to use a complex callback, or promises - a system that will mix the framework API with other libraries and the application code.<br>
 Fastify handles this internally, with minimum effort!
 
 Let's rewrite the above example with a database connection.<br>
 *(we will use a simple example, for a robust solution consider using [`fastify-mongo`](https://github.com/fastify/fastify-mongodb) or another in the Fastify [ecosystem](https://github.com/fastify/fastify/blob/master/docs/Ecosystem.md))*
 
+First, install `fastify-plugin`:
+
+```
+npm install --save fastify-plugin
+```
+
 **server.js**
 ```js
 const fastify = require('fastify')({
@@ -185,18 +191,17 @@ module.exports = routes
 
 Wow, that was fast!<br>
 Let's recap what we have done here since we've introduced some new concepts.<br>
-As you can see, we used `register` both for the database connector and the routes registration.
-This is one of the best features of Fastify, it will load your plugins in the same order you declare them, and it will load the next plugin only once the current one has been loaded. In this way we can register the database connector in the first plugin and use it in the second *(read [here](https://github.com/fastify/fastify/blob/master/docs/Plugins.md#handle-the-scope) to understand how to handle the scope of a plugin)*.
+As you can see, we used `register` both for the database connector and the registration of the routes.
+This is one of the best features of Fastify, it will load your plugins in the same order you declare them, and it will load the next plugin only once the current one has been loaded. In this way, we can register the database connector in the first plugin and use it in the second *(read [here](https://github.com/fastify/fastify/blob/master/docs/Plugins.md#handle-the-scope) to understand how to handle the scope of a plugin)*.
 Plugin loading starts when you call `fastify.listen()`, `fastify.inject()` or `fastify.ready()`
 
-We have used the `decorate` API. Let's take a moment to understand what it is and how it works. A scenario is to use the same code/library in different parts of an application. A solution is to require the code/library that it is needed. This works, but is annoying because of duplicated code repeated and, if needed, long refactors.<br>
-To solve this Fastify offers the `decorate` API, which adds custom objects to the Fastify namespace, so that they can be used everywhere.
+We have also used the `decorate` API to add custom objects to the Fastify namespace, making them available for use everywhere. Use of this API is encouraged to faciliate easy code reuse and to decrease code or logic duplication.
 
 To dig deeper into how Fastify plugins work, how to develop new plugins, and for details on how to use the whole Fastify API to deal with the complexity of asynchronously bootstrapping an application, read [the hitchhiker's guide to plugins](https://github.com/fastify/fastify/blob/master/docs/Plugins-Guide.md).
 
 <a name="plugin-loading-order"></a>
 ### Loading order of your plugins
-To guarantee a consistent and predictable behavior of your application, we highly recommend to always load your code as shown below:
+To guarantee a consistent and predictable behaviour of your application, we highly recommend to always load your code as shown below:
 ```
 └── plugins (from the Fastify ecosystem)
 └── your plugins (your custom plugins)
@@ -204,8 +209,8 @@ To guarantee a consistent and predictable behavior of your application, we highl
 └── hooks and middlewares
 └── your services
 ```
-In this way you will always have access to all of the properties declared in the current scope.<br/>
-As discussed previously, Fastify offers a solid encapsulation model, to help you build your application as single and independent services. If you want to register a plugin only for a subset of routes, you have just to replicate the above structure.
+In this way, you will always have access to all of the properties declared in the current scope.<br/>
+As discussed previously, Fastify offers a solid encapsulation model, to help you build your application as single and independent services. If you want to register a plugin only for a subset of routes, you just have to replicate the above structure.
 ```
 └── plugins (from the Fastify ecosystem)
 └── your plugins (your custom plugins)
@@ -230,7 +235,7 @@ As discussed previously, Fastify offers a solid encapsulation model, to help you
 
 <a name="validate-data"></a>
 ### Validate your data
-Data validation is extremely important and is a core concept of the framework.<br>
+Data validation is extremely important and a core concept of the framework.<br>
 To validate incoming requests, Fastify uses [JSON Schema](http://json-schema.org/).
 Let's look at an example demonstrating validation for routes:
 ```js
@@ -255,8 +260,8 @@ Read [Validation and Serialization](https://github.com/fastify/fastify/blob/mast
 
 <a name="serialize-data"></a>
 ### Serialize your data
-Fastify has first class support for JSON. It is extremely optimized to parse a JSON body and to serialize JSON output.<br>
-To speed up JSON serialization (yes, it is slow!) use the `response` key of the schema option like so:
+Fastify has first class support for JSON. It is extremely optimized to parse JSON bodies and to serialize JSON output.<br>
+To speed up JSON serialization (yes, it is slow!) use the `response` key of the schema option as shown in the following example:
 ```js
 const opts = {
   schema: {
@@ -275,23 +280,22 @@ fastify.get('/', opts, async (request, reply) => {
   return { hello: 'world' }
 })
 ```
-Simply by specifying a schema as shown, a speed up your of serialization by 2x or even 3x can be achieved. This also helps protect against leaking of sensitive data, since Fastify will serialize only the data present in the response schema.
+Simply by specifying a schema as shown, you can speed up serialization by a factor of 2-3. This also helps to protect against leakage of potentially sensitive data, since Fastify will serialize only the data present in the response schema.
 Read [Validation and Serialization](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md) to learn more.
 
 <a name="extend-server"></a>
 ### Extend your server
-Fastify is built to be extremely extensible and very minimal, We believe that a bare minimum framework is all that is necessary to make great applications possible.<br>
+Fastify is built to be extremely extensible and minimal, we believe that a bare bones framework is all that is necessary to make great applications possible.<br>
 In other words, Fastify is not a "batteries included" framework, and relies on an amazing [ecosystem](https://github.com/fastify/fastify/blob/master/docs/Ecosystem.md)!
 
 <a name="test-server"></a>
 ### Test your server
-Fastify does not offer a testing framework, but we do recommend a way to write your tests that uses the features and the architecture of Fastify.<br>
+Fastify does not offer a testing framework, but we do recommend a way to write your tests that uses the features and architecture of Fastify.<br>
 Read the [testing](https://github.com/fastify/fastify/blob/master/docs/Testing.md) documentation to learn more!
 
 <a name="cli"></a>
 ### Run your server from CLI
-Fastify also has CLI integration thanks to
-[fastify-cli](https://github.com/fastify/fastify-cli).
+Fastify also has CLI integration thanks to [fastify-cli](https://github.com/fastify/fastify-cli).
 
 First, install `fastify-cli`:
 
diff --git a/docs/HTTP2.md b/docs/HTTP2.md
index 724b98f4..e0ce0602 100644
--- a/docs/HTTP2.md
+++ b/docs/HTTP2.md
@@ -35,7 +35,7 @@ fastify.get('/', function (request, reply) {
 fastify.listen(3000)
 ```
 
-ALPN negotiation allows to support both HTTPS and HTTP/2 over the same socket.
+ALPN negotiation allows support for both HTTPS and HTTP/2 over the same socket.
 Node core `req` and `res` objects can be either [HTTP/1](https://nodejs.org/api/http.html)
 or [HTTP/2](https://nodejs.org/api/http2.html).
 _Fastify_ supports this out of the box:
diff --git a/docs/Hooks.md b/docs/Hooks.md
index 57f3ffe3..c6e73589 100644
--- a/docs/Hooks.md
+++ b/docs/Hooks.md
@@ -2,222 +2,170 @@
 
 ## Hooks
 
-Hooks are registered with the `fastify.addHook` method and allow you to listen to specific events in the application or request/response lifecycle. You have to register a hook before the event is triggered otherwise the event is lost.
+Hooks are registered with the `fastify.addHook` method and allow you to listen to specific events in the application or request/response lifecycle. You have to register a hook before the event is triggered, otherwise the event is lost.
 
-## Request/Response Hooks
+By using hooks you can interact directly with the lifecycle of Fastify. There are Request/Reply hooks and application hooks:
 
-By using the hooks you can interact directly inside the lifecycle of Fastify. There are seven different Hooks that you can use *(in order of execution)*:
-- `'onRequest'`
-- `'preParsing'`
-- `'preValidation'`
-- `'preHandler'`
-- `'preSerialization'`
-- `'onError'`
-- `'onSend'`
-- `'onResponse'`
+- [Request/Reply Hooks](#requestreply-hooks)
+  - [onRequest](#onrequest)
+  - [preParsing](#preparsing)
+  - [preValidation](#prevalidation)
+  - [preHandler](#prehandler)
+  - [preSerialization](#preserialization)
+  - [onError](#onerror)
+  - [onSend](#onsend)
+  - [onResponse](#onresponse)
+- [Application Hooks](#application-hooks)
+  - [onClose](#onclose)
+  - [onRoute](#onroute)
+  - [onRegister](#onregister)
 
-Example:
-```js
-fastify.addHook('onRequest', (request, reply, next) => {
-  // some code
-  next()
-})
-
-fastify.addHook('preParsing', (request, reply, next) => {
-  // some code
-  next()
-})
+**Notice:** the `done` callback is not available when using `async`/`await` or returning a `Promise`. If you do invoke a `done` callback in this situation unexpected behaviour may occur, e.g. duplicate invocation of handlers.
 
-fastify.addHook('preValidation', (request, reply, next) => {
-  // some code
-  next()
-})
-
-fastify.addHook('preHandler', (request, reply, next) => {
-  // some code
-  next()
-})
+## Request/Reply Hooks
 
-fastify.addHook('preSerialization', (request, reply, payload, next) => {
-  // some code
-  next()
-})
+[Request](https://github.com/fastify/fastify/blob/master/docs/Request.md) and [Reply](https://github.com/fastify/fastify/blob/master/docs/Reply.md) are the core Fastify objects.<br/>
+`done` is the function to continue with the [lifecycle](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md).
 
-fastify.addHook('onError', (request, reply, error, next) => {
-  // some code
-  next()
-})
+It is pretty easy to understand where each hook is executed by looking at the [lifecycle page](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md).<br>
+Hooks are affected by Fastify's encapsulation, and can thus be applied to selected routes. See the [Scopes](#scope) section for more information.
 
-fastify.addHook('onSend', (request, reply, payload, next) => {
-  // some code
-  next()
-})
+There are eight different hooks that you can use in Request/Reply *(in order of execution)*:
 
-fastify.addHook('onResponse', (request, reply, next) => {
-  // some code
-  next()
+### onRequest
+```js
+fastify.addHook('onRequest', (request, reply, done) => {
+  // Some code
+  done()
 })
 ```
-Or `async/await`
+Or `async/await`:
 ```js
 fastify.addHook('onRequest', async (request, reply) => {
-  // some code
+  // Some code
   await asyncMethod()
-  // error occurred
+  // Error occurred
   if (err) {
-    throw new Error('some errors occurred.')
+    throw new Error('Some errors occurred.')
   }
   return
 })
+```
 
-fastify.addHook('preParsing', async (request, reply) => {
-  // some code
-  await asyncMethod()
-  // error occurred
-  if (err) {
-    throw new Error('some errors occurred.')
-  }
-  return
-})
+**Notice:** in the [onRequest](#onRequest) hook, `request.body` will always be `null`, because the body parsing happens before the [preHandler](#preHandler) hook.
 
-fastify.addHook('preValidation', async (request, reply) => {
-  // some code
-  await asyncMethod()
-  // error occurred
-  if (err) {
-    throw new Error('some errors occurred.')
-  }
-  return
+### preParsing
+```js
+fastify.addHook('preParsing', (request, reply, done) => {
+  // Some code
+  done()
 })
-
-fastify.addHook('preHandler', async (request, reply) => {
-  // some code
+```
+Or `async/await`:
+```js
+fastify.addHook('preParsing', async (request, reply) => {
+  // Some code
   await asyncMethod()
-  // error occurred
+  // Error occurred
   if (err) {
-    throw new Error('some errors occurred.')
+    throw new Error('Some errors occurred.')
   }
   return
 })
-
-fastify.addHook('preSerialization', async (request, reply, payload) => {
-  // some code
-  await asyncMethod()
-  // error occurred
-  if (err) {
-    throw new Error('some errors occurred.')
-  }
-  return payload
-})
-
-fastify.addHook('onError', async (request, reply, error) => {
-  // useful for custom error logging
-  // you should not use this hook to update the error
+```
+### preValidation
+```js
+fastify.addHook('preValidation', (request, reply, done) => {
+  // Some code
+  done()
 })
-
-fastify.addHook('onSend', async (request, reply, payload) => {
-  // some code
+```
+Or `async/await`:
+```js
+fastify.addHook('preValidation', async (request, reply) => {
+  // Some code
   await asyncMethod()
-  // error occurred
+  // Error occurred
   if (err) {
-    throw new Error('some errors occurred.')
+    throw new Error('Some errors occurred.')
   }
   return
 })
+```
+**Notice:** in the [preValidation](#preValidation) hook, `request.body` will always be `null`, because the body parsing happens before the [preHandler](#preHandler) hook.
 
-fastify.addHook('onResponse', async (request, reply) => {
+### preHandler
+```js
+fastify.addHook('preHandler', (request, reply, done) => {
   // some code
+  done()
+})
+```
+Or `async/await`:
+```js
+fastify.addHook('preHandler', async (request, reply) => {
+  // Some code
   await asyncMethod()
-  // error occurred
+  // Error occurred
   if (err) {
-    throw new Error('some errors occurred.')
+    throw new Error('Some errors occurred.')
   }
   return
 })
 ```
+### preSerialization
 
-**Notice:** the `next` callback is not available when using `async`/`await` or returning a `Promise`. If you do invoke a `next` callback in this situation unexpected behavior may occur, e.g. duplicate invocation of handlers.
-
-**Notice:** in the `onRequest` and `preValidation` hooks, `request.body` will always be `null`, because the body parsing happens before the `preHandler` hook.
-
-[Request](https://github.com/fastify/fastify/blob/master/docs/Request.md) and [Reply](https://github.com/fastify/fastify/blob/master/docs/Reply.md) are the core Fastify objects.<br/>
-`next` is the function to continue with the [lifecycle](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md).
-
-It is pretty easy to understand where each hook is executed by looking at the [lifecycle page](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md).<br>
-Hooks are affected by Fastify's encapsulation, and can thus be applied to selected routes. See the [Scopes](#scope) section for more information.
-
-If you get an error during the execution of your hook, just pass it to `next()` and Fastify will automatically close the request and send the appropriate error code to the user.
+If you are using the `preSerialization` hook, you can change (or replace) the payload before it is serialized. For example:
 
 ```js
-fastify.addHook('onRequest', (request, reply, next) => {
-  next(new Error('some error'))
+fastify.addHook('preSerialization', (request, reply, payload, done) => {
+  const err = null;
+  const newPayload = { wrapped: payload }
+  done(err, newPayload)
 })
 ```
-
-If you want to pass a custom error code to the user, just use `reply.code()`:
+Or `async/await`
 ```js
-fastify.addHook('preHandler', (request, reply, next) => {
-  reply.code(400)
-  next(new Error('some error'))
+fastify.addHook('preSerialization', async (request, reply, payload) => {
+  return { wrapped: payload }
 })
 ```
 
-*The error will be handled by [`Reply`](https://github.com/fastify/fastify/blob/master/docs/Reply.md#errors).*
-
-#### The `onError` Hook
-
-This hook is useful if you need to do some custom error logging or add some specific header in case of error.<br/>
-It is not intended for changing the error, and calling `reply.send` will throw an exception.<br/>
-This hook will be executed only after the `customErrorHandler` has been executed, and only if the `customErrorHandler` sends back an error to the user *(Note that the default `customErrorHandler` always send back the error to the user)*.<br/>
-**Notice:** unlike the other hooks, pass an error to the `next` function is not supported.
+Note: the hook is NOT called if the payload is a `string`, a `Buffer`, a `stream` or `null`.
 
+### onError
 ```js
-fastify.addHook('onError', (request, reply, error, next) => {
-  // apm stands for Application Performance Monitoring
-  apm.sendError(error)
-  next()
-})
-
-// Or async
-fastify.addHook('onError', async (request, reply, error) => {
-  // apm stands for Application Performance Monitoring
-  apm.sendError(error)
+fastify.addHook('onError', (request, reply, error, done) => {
+  // Some code
+  done()
 })
 ```
-
-#### The `preSerialization` Hook
-
-If you are using the `preSerialization` hook, you can change (or replace) the payload before it is serialized. For example:
-
+Or `async/await`:
 ```js
-fastify.addHook('preSerialization', (request, reply, payload, next) => {
-  var err = null;
-  var newPayload = {wrapped: payload }
-  next(err, newPayload)
-})
-
-// Or async
-fastify.addHook('preSerialization', async (request, reply, payload) => {
-  return {wrapped: payload }
+fastify.addHook('onError', async (request, reply, error) => {
+  // Useful for custom error logging
+  // You should not use this hook to update the error
 })
 ```
+This hook is useful if you need to do some custom error logging or add some specific header in case of error.<br/>
+It is not intended for changing the error, and calling `reply.send` will throw an exception.<br/>
+This hook will be executed only after the `customErrorHandler` has been executed, and only if the `customErrorHandler` sends an error back to the user *(Note that the default `customErrorHandler` always sends the error back to the user)*.<br/>
+**Notice:** unlike the other hooks, pass an error to the `done` function is not supported.
 
-Note: the hook is NOT called if the payload is  a `string`, a `Buffer`, a `stream`, or `null`.
-
-#### The `onSend` Hook
-
+### onSend
 If you are using the `onSend` hook, you can change the payload. For example:
 
 ```js
-fastify.addHook('onSend', (request, reply, payload, next) => {
-  var err = null;
-  var newPayload = payload.replace('some-text', 'some-new-text')
-  next(err, newPayload)
+fastify.addHook('onSend', (request, reply, payload, done) => {
+  const err = null;
+  const newPayload = payload.replace('some-text', 'some-new-text')
+  done(err, newPayload)
 })
-
-// Or async
+```
+Or `async/await`:
+```js
 fastify.addHook('onSend', async (request, reply, payload) => {
-  var newPayload = payload.replace('some-text', 'some-new-text')
+  const newPayload = payload.replace('some-text', 'some-new-text')
   return newPayload
 })
 ```
@@ -225,10 +173,10 @@ fastify.addHook('onSend', async (request, reply, payload) => {
 You can also clear the payload to send a response with an empty body by replacing the payload with `null`:
 
 ```js
-fastify.addHook('onSend', (request, reply, payload, next) => {
+fastify.addHook('onSend', (request, reply, payload, done) => {
   reply.code(304)
   const newPayload = null
-  next(null, newPayload)
+  done(null, newPayload)
 })
 ```
 
@@ -236,15 +184,55 @@ fastify.addHook('onSend', (request, reply, payload, next) => {
 
 Note: If you change the payload, you may only change it to a `string`, a `Buffer`, a `stream`, or `null`.
 
-#### The `onResponse` Hook
-The `onResponse` hook is executed when a response has been sent, so you will not be able to send more data to the client, however you can use this hook to send some data to an external service or elaborate some statistics.
+
+### onResponse
+```js
+
+fastify.addHook('onResponse', (request, reply, done) => {
+  // Some code
+  done()
+})
+```
+Or `async/await`:
+```js
+fastify.addHook('onResponse', async (request, reply) => {
+  // Some code
+  await asyncMethod()
+  // Error occurred
+  if (err) {
+    throw new Error('Some errors occurred.')
+  }
+  return
+})
+```
+
+The `onResponse` hook is executed when a response has been sent, so you will not be able to send more data to the client. It can however be useful for sending data to external services, for example to gather statistics.
+
+### Manage Errors from a hook
+If you get an error during the execution of your hook, just pass it to `done()` and Fastify will automatically close the request and send the appropriate error code to the user.
+
+```js
+fastify.addHook('onRequest', (request, reply, done) => {
+  done(new Error('Some error'))
+})
+```
+
+If you want to pass a custom error code to the user, just use `reply.code()`:
+```js
+fastify.addHook('preHandler', (request, reply, done) => {
+  reply.code(400)
+  done(new Error('Some error'))
+})
+```
+
+*The error will be handled by [`Reply`](https://github.com/fastify/fastify/blob/master/docs/Reply.md#errors).*
 
 ### Respond to a request from a hook
-If needed, you can respond to a request before you reach the route handler. An example could be an authentication hook. If you are using `onRequest` or `preHandler` use `reply.send`; if you are using a middleware, `res.end`.
+If needed, you can respond to a request before you reach the route handler, for example when implementing an authentication hook. If you are using `onRequest` or `preHandler` use `reply.send`; if you are using a middleware, use `res.end`.
 
 ```js
-fastify.addHook('onRequest', (request, reply, next) => {
-  reply.send('early response')
+fastify.addHook('onRequest', (request, reply, done) => {
+  reply.send('Early response')
 })
 
 // Works with async functions too
@@ -256,7 +244,7 @@ fastify.addHook('preHandler', async (request, reply) => {
 If you want to respond with a stream, you should avoid using an `async` function for the hook. If you must use an `async` function, your code will need to follow the pattern in [test/hooks-async.js](https://github.com/fastify/fastify/blob/94ea67ef2d8dce8a955d510cd9081aabd036fa85/test/hooks-async.js#L269-L275).
 
 ```js
-fastify.addHook('onRequest', (request, reply, next) => {
+fastify.addHook('onRequest', (request, reply, done) => {
   const stream = fs.createReadStream('some-file', 'utf8')
   reply.send(stream)
 })
@@ -264,39 +252,55 @@ fastify.addHook('onRequest', (request, reply, next) => {
 
 ## Application Hooks
 
-You are able to hook into the application-lifecycle as well. It's important to note that these hooks aren't fully encapsulated. The `this` inside the hooks are encapsulated but the handlers can respond to an event outside the encapsulation boundaries.
+You can hook into the application-lifecycle as well. It's important to note that these hooks aren't fully encapsulated. The `this` inside the hooks are encapsulated but the handlers can respond to an event outside the encapsulation boundaries.
 
-- `'onClose'`
-- `'onRoute'`
-- `'onRegister'`
+- [onClose](#onclose)
+- [onRoute](#onroute)
+- [onRegister](#onregister)
 
 <a name="on-close"></a>
-**'onClose'**<br>
-Triggered when `fastify.close()` is invoked to stop the server. It is useful when [plugins](https://github.com/fastify/fastify/blob/master/docs/Plugins.md) need a "shutdown" event, such as a connection to a database.<br>
+
+### onClose
+Triggered when `fastify.close()` is invoked to stop the server. It is useful when [plugins](https://github.com/fastify/fastify/blob/master/docs/Plugins.md) need a "shutdown" event, for example to close an open connection to a database.<br>
 The first argument is the Fastify instance, the second one the `done` callback.
 ```js
 fastify.addHook('onClose', (instance, done) => {
-  // some code
+  // Some code
   done()
 })
 ```
 <a name="on-route"></a>
-**'onRoute'**<br>
+### onRoute
 Triggered when a new route is registered. Listeners are passed a `routeOptions` object as the sole parameter. The interface is synchronous, and, as such, the listeners do not get passed a callback.
 ```js
 fastify.addHook('onRoute', (routeOptions) => {
-  // some code
+  //Some code
   routeOptions.method
   routeOptions.schema
   routeOptions.url
   routeOptions.bodyLimit
   routeOptions.logLevel
+  routeOptions.logSerializers
   routeOptions.prefix
 })
 ```
+
+If you are authoring a plugin and you need to customize application routes, like modifying the options or adding new route hooks, this is the right place.
+
+```js
+fastify.addHook('onRoute', (routeOptions) => {
+  function onPreSerialization(request, reply, payload, done) {
+    // Your code
+    done(null, payload)
+  }
+  // preSerialization can be an array or undefined
+  routeOptions.preSerialization = [...(routeOptions.preSerialization || []), onPreSerialization]
+})
+```
+
 <a name="on-register"></a>
-**'onRegister'**<br>
-Triggered when a new plugin function is registered, and a new encapsulation context is created, the hook will be executed **before** the plugin code.<br/>
+### onRegister
+Triggered when a new plugin is registered and a new encapsulation context is created. The hook will be executed **before** the registered code.<br/>
 This hook can be useful if you are developing a plugin that needs to know when a plugin context is formed, and you want to operate in that specific context.<br/>
 **Note:** This hook will not be called if a plugin is wrapped inside [`fastify-plugin`](https://github.com/fastify/fastify-plugin).
 ```js
@@ -317,7 +321,7 @@ fastify.register(async (instance, opts) => {
 })
 
 fastify.addHook('onRegister', (instance) => {
-  // create a new array from the old one
+  // Create a new array from the old one
   // but without keeping the reference
   // allowing the user to have encapsulated
   // instances of the `data` property
@@ -330,46 +334,50 @@ fastify.addHook('onRegister', (instance) => {
 Except for [Application Hooks](#application-hooks), all hooks are encapsulated. This means that you can decide where your hooks should run by using `register` as explained in the [plugins guide](https://github.com/fastify/fastify/blob/master/docs/Plugins-Guide.md). If you pass a function, that function is bound to the right Fastify context and from there you have full access to the Fastify API.
 
 ```js
-fastify.addHook('onRequest', function (request, reply, next) {
+fastify.addHook('onRequest', function (request, reply, done) {
   const self = this // Fastify context
-  next()
+  done()
 })
 ```
 Note: using an arrow function will break the binding of this to the Fastify instance.
 
 <a name="route-hooks"></a>
+
 ## Route level hooks
-You can declare one or more custom `onRequest`, `preParsing`, `preValidation`, `preHandler` and `preSerialization` hook(s) that will be unique for the route.
-If you do so, those hooks always be executed as last hook in their category. <br/>
-This can be useful if you need to run the authentication, and the `preParsing` or `preValidation` hooks are exactly what you need for doing that.
+You can declare one or more custom [onRequest](#onRequest), [onReponse](#onResponse), [preParsing](#preParsing), [preValidation](#preValidation), [preHandler](#preHandler) and [preSerialization](#preSerialization) hook(s) that will be **unique** for the route.
+If you do so, those hooks are always executed as the last hook in their category. <br/>
+This can be useful if you need to implement authentication, where the [preParsing](#preParsing) or [preValidation](#preValidation) hooks are exactly what you need.
 Multiple route-level hooks can also be specified as an array.
 
-Let's make an example:
-
 ```js
 fastify.addHook('onRequest', (request, reply, done) => {
+  // Your code
+  done()
+})
+
+fastify.addHook('onResponse', (request, reply, done) => {
   // your code
   done()
 })
 
 fastify.addHook('preParsing', (request, reply, done) => {
-  // your code
+  // Your code
   done()
 })
 
 fastify.addHook('preValidation', (request, reply, done) => {
-  // your code
+  // Your code
   done()
 })
 
 fastify.addHook('preHandler', (request, reply, done) => {
-  // your code
+  // Your code
   done()
 })
 
-fastify.addHook('preSerialization', (request, reply, done) => {
-  // your code
-  done()
+fastify.addHook('preSerialization', (request, reply, payload, done) => {
+  // Your code
+  done(null, payload)
 })
 
 fastify.route({
@@ -377,30 +385,34 @@ fastify.route({
   url: '/',
   schema: { ... },
   onRequest: function (request, reply, done) {
-    // this hook will always be executed after the shared `onRequest` hooks
+    // This hook will always be executed after the shared `onRequest` hooks
+    done()
+  },
+  onResponse: function (request, reply, done) {
+    // this hook will always be executed after the shared `onResponse` hooks
     done()
   },
   preParsing: function (request, reply, done) {
-    // this hook will always be executed after the shared `preParsing` hooks
+    // This hook will always be executed after the shared `preParsing` hooks
     done()
   },
   preValidation: function (request, reply, done) {
-    // this hook will always be executed after the shared `preValidation` hooks
+    // This hook will always be executed after the shared `preValidation` hooks
     done()
   },
   preHandler: function (request, reply, done) {
-    // this hook will always be executed after the shared `preHandler` hooks
+    // This hook will always be executed after the shared `preHandler` hooks
     done()
   },
   // // Example with an array. All hooks support this syntax.
   //
   // preHandler: [function (request, reply, done) {
-  //   // this hook will always be executed after the shared `preHandler` hooks
+  //   // This hook will always be executed after the shared `preHandler` hooks
   //   done()
   // }],
-  preSerialization: (request, reply, payload, next) => {
-    // manipulate the payload
-    next(null, payload)
+  preSerialization: (request, reply, payload, done) => {
+    // This hook will always be executed after the shared `preSerialization` hooks
+    done(null, payload)
   },
   handler: function (request, reply) {
     reply.send({ hello: 'world' })
diff --git a/docs/LTS.md b/docs/LTS.md
index df70e66f..00fe2571 100644
--- a/docs/LTS.md
+++ b/docs/LTS.md
@@ -41,8 +41,9 @@ A "month" is to be a period of 30 consecutive days.
 
 ### CI tested operating systems
 
-| CI              | OS      | Version        | Package Manager | Node.js       |
-| :-------------- | :------ | :------------- | :-------------- | :------------ |
-| Azure pipelines | Linux   | Ubuntu 16.04   | npm, yarn       | 8, 10, 12     |
-| Azure pipelines | Windows | vs2017-win2016 | npm, yarn       | 8, 10, 12     |
-| Azure pipelines | Mac     | macOS 10.14    | npm, yarn       | 8, 10, 12     |
+| CI             | OS      | Version                | Package Manager           | Node.js   |
+|----------------|---------|------------------------|---------------------------|-----------|
+| Github Actions | Linux   | Ubuntu 16.04           | npm                       | 8,10,12 |
+| Github Actions | Linux   | Ubuntu 16.04           | yarn,pnpm                 | 8,10      |
+| Github Actions | Windows | Windows Server 2016 R2 | npm                       | 8,10,12 |
+| Github Actions | MacOS   | macOS X Mojave 10.14   | npm                       | 8,10,12 |
diff --git a/docs/Logging.md b/docs/Logging.md
index 661a534d..63ca3851 100644
--- a/docs/Logging.md
+++ b/docs/Logging.md
@@ -4,12 +4,12 @@
 
 Logging is disabled by default, and you can enable it by passing
 `{ logger: true }` or `{ logger: { level: 'info' } }` when you create
-the fastify instance. Note that if the logger is disabled, it is impossible to
+a fastify instance. Note that if the logger is disabled, it is impossible to
 enable it at runtime. We use
 [abstract-logging](https://www.npmjs.com/package/abstract-logging) for
 this purpose.
 
-Since Fastify is really focused on performances, it uses [pino](https://github.com/pinojs/pino) as its logger, with the default log level, when enabled, set to `'info'`.
+Since Fastify is focused on performance, it uses [pino](https://github.com/pinojs/pino) as its logger, with the default log level, when enabled, set to `'info'`.
 
 Enabling the logger is extremely easy:
 
@@ -24,14 +24,14 @@ fastify.get('/', options, function (request, reply) {
 })
 ```
 
-If you want to pass some options to the logger, just pass the logger option to Fastify.
-You can find all the options in the [Pino documentation](https://github.com/pinojs/pino/blob/master/docs/api.md#pinooptions-stream). If you want to specify a file destination, use:
+If you want to pass some options to the logger, just pass them to Fastify.
+You can find all available options in the [Pino documentation](https://github.com/pinojs/pino/blob/master/docs/api.md#pinooptions-stream). If you want to specify a file destination, use:
 
 ```js
 const fastify = require('fastify')({
   logger: {
     level: 'info',
-    file: '/path/to/file' // will use pino.destination()
+    file: '/path/to/file' // Will use pino.destination()
   }
 })
 
@@ -41,7 +41,7 @@ fastify.get('/', options, function (request, reply) {
 })
 ```
 
-If you want to pass a custom stream to the Pino instance, just add the stream field to the logger object.
+If you want to pass a custom stream to the Pino instance, just add a stream field to the logger object.
 
 ```js
 const split = require('split2')
@@ -57,9 +57,9 @@ const fastify = require('fastify')({
 
 <a name="logging-request-id"></a>
 
-By default fastify adds an id to every request for easier tracking. If the "request-id" header is present its value is used, otherwise a new incremental id is generated. See Fastify Factory [`requestIdHeader`](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-request-id-header) and Fastify Factory [`genReqId`](https://github.com/fastify/fastify/blob/master/docs/Server.md#gen-request-id) for customization options.
+By default, fastify adds an id to every request for easier tracking. If the "request-id" header is present its value is used, otherwise a new incremental id is generated. See Fastify Factory [`requestIdHeader`](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-request-id-header) and Fastify Factory [`genReqId`](https://github.com/fastify/fastify/blob/master/docs/Server.md#gen-request-id) for customization options.
 
-The default logger is configured with a set of standard serializers that serialize objects with `req`, `res`, and `err` properties. This behavior can be customized by specifying custom serializers.
+The default logger is configured with a set of standard serializers that serialize objects with `req`, `res`, and `err` properties. This behaviour can be customized by specifying custom serializers.
 ```js
 const fastify = require('fastify')({
   logger: {
@@ -71,7 +71,7 @@ const fastify = require('fastify')({
   }
 })
 ```
-For example, the response payload and headers could be logged using the approach below (even if it is *not* recommended*):
+For example, the response payload and headers could be logged using the approach below (even if it is *not recommended*):
 
 ```js
 const fastify = require('fastify')({
@@ -79,7 +79,7 @@ const fastify = require('fastify')({
     prettyPrint: true,
     serializers: {
       res(res) {
-        // the default
+        // The default
         return {
           statusCode: res.statusCode
         }
@@ -90,11 +90,10 @@ const fastify = require('fastify')({
           url: req.url,
           path: req.path,
           parameters: req.parameters,
-          // Including the body and headers in the log could be in violation 
+          // Including the headers in the log could be in violation 
           // of privacy laws, e.g. GDPR. You should use the "redact" option to
           // remove sensitive fields. It could also leak authentication data in
           // the logs.
-          body: req.body,
           headers: req.headers
         };
       }
@@ -102,6 +101,19 @@ const fastify = require('fastify')({
   }
 });
 ```
+**Note**: The body not can serialize inside `req` method, because the request is serialized when we create the child logger. At that time, the body is not parsed yet.
+
+See an approach to log `req.body`
+
+```js
+app.addHook('preHandler', function (req, reply, done) {
+  if (req.body) {
+    req.log.info({ body: req.body }, 'parsed body')
+  }
+  done()
+})
+```
+
 
 *This option will be ignored by any logger other than Pino.*
 
diff --git a/docs/Middleware.md b/docs/Middleware.md
new file mode 100644
index 00000000..24ba8073
--- /dev/null
+++ b/docs/Middleware.md
@@ -0,0 +1,59 @@
+<h1 align="center">Fastify</h1>
+
+## Middleware
+
+Fastify provides an asynchronous [middleware engine](https://github.com/fastify/middie) out-of-the-box, which is compatible with [Express](https://expressjs.com/) and [Restify](http://restify.com/) middleware.
+
+*For help with understanding when middleware is executed, take a look at the [lifecycle](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md) page.*
+
+Fastify middleware don't support the full syntax `middleware(err, req, res, next)`, because error handling is done inside Fastify.
+Furthermore, methods added by Express and Restify to the enhanced versions of `req` and `res` are not supported in Fastify middlewares.
+
+Also, if you are using middleware that bundles different, smaller middleware, such as [*helmet*](https://helmetjs.github.io/), we recommend using the single modules for better performance.
+
+```js
+fastify.use(require('cors')())
+fastify.use(require('dns-prefetch-control')())
+fastify.use(require('frameguard')())
+fastify.use(require('hide-powered-by')())
+fastify.use(require('hsts')())
+fastify.use(require('ienoopen')())
+fastify.use(require('x-xss-protection')())
+```
+
+or, in the specific case of *helmet*, you can use the [*fastify-helmet*](https://github.com/fastify/fastify-helmet) [plugin](Plugins.md), which is an optimized helmet integration for fastify:
+
+```js
+const fastify = require('fastify')()
+const helmet = require('fastify-helmet')
+
+fastify.register(helmet)
+```
+
+Remember that middleware can be encapsulated, this means that you can decide where your middleware should run by using `register` as explained in the [plugins guide](https://github.com/fastify/fastify/blob/master/docs/Plugins-Guide.md).
+
+Fastify middleware also do not expose the `send` method or other methods specific to the Fastify [Reply]('./Reply.md' "Reply") instance. This is because Fastify wraps the incoming `req` and `res` Node instances using the [Request](./Request.md "Request") and [Reply](./Reply.md "Reply") objects internally, but this is done after the middleware phase. If you need to create middleware, you have to use the Node `req` and `res` instances. Otherwise, you can use the `preHandler` hook which already has the [Request](./Request.md "Request") and [Reply](./Reply.md "Reply") Fastify instances. For more information, see [Hooks](./Hooks.md "Hooks").
+
+<a name="restrict-usage"></a>
+#### Restrict middleware execution to a certain path(s)
+If you need to run a middleware only under certain path(s), just pass the path as first parameter to `use` and you are done!
+
+*Note that this does not support routes with parameters, (eg: `/user/:id/comments`) and wildcards are not supported in multiple paths.*
+
+```js
+const path = require('path')
+const serveStatic = require('serve-static')
+
+// Single path
+fastify.use('/css', serveStatic(path.join(__dirname, '/assets')))
+
+// Wildcard path
+fastify.use('/css/*', serveStatic(path.join(__dirname, '/assets')))
+
+// Multiple paths
+fastify.use(['/css', '/js'], serveStatic(path.join(__dirname, '/assets')))
+```
+
+<a name="express-middleware"></a>
+#### Express middleware compatibility
+Express modifies the prototype of the node core Request and Response objects heavily so Fastify cannot guarantee full middleware compatibility. Express specific functionality such as `res.sendFile()`, `res.send()` or `express.Router()` instances will not work with Fastify. For example, [cors](https://github.com/expressjs/cors) is compatible while [passport](https://github.com/jaredhanson/passport) is not.
diff --git a/docs/Middlewares.md b/docs/Middlewares.md
deleted file mode 100644
index dfe3d206..00000000
--- a/docs/Middlewares.md
+++ /dev/null
@@ -1,59 +0,0 @@
-<h1 align="center">Fastify</h1>
-
-## Middlewares
-
-Fastify out of the box provides an asynchronous [middleware engine](https://github.com/fastify/middie) compatible with [Express](https://expressjs.com/) and [Restify](http://restify.com/) middlewares.
-
-*If you need a visual feedback to understand when the middlewares are executed take a look to the [lifecycle](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md) page.*
-
-Fastify middlewares don't support the full syntax `middleware(err, req, res, next)`, because error handling is done inside Fastify.
-Furthermore methods added by Express and Restify to the enhanced versions of `req` and `res` are not supported in Fastify middlewares.
-
-Also, if you are using a middleware that bundles different, smaller middlewares, such as [*helmet*](https://helmetjs.github.io/), we recommend to use the single modules to get better performances.
-
-```js
-fastify.use(require('cors')())
-fastify.use(require('dns-prefetch-control')())
-fastify.use(require('frameguard')())
-fastify.use(require('hide-powered-by')())
-fastify.use(require('hsts')())
-fastify.use(require('ienoopen')())
-fastify.use(require('x-xss-protection')())
-```
-
-or, in the specific case of *helmet*, you can use the [*fastify-helmet*](https://github.com/fastify/fastify-helmet) [plugin](Plugins.md), which is an optimized helmet integration for fastify:
-
-```js
-const fastify = require('fastify')()
-const helmet = require('fastify-helmet')
-
-fastify.register(helmet)
-```
-
-Remember that middlewares can be encapsulated, this means that you can decide where your middlewares should run by using `register` as explained in the [plugins guide](https://github.com/fastify/fastify/blob/master/docs/Plugins-Guide.md).
-
-Fastify middlewares also do not expose the `send` method or other methods specific to the Fastify [Reply]('./Reply.md' "Reply") instance. This is because Fastify wraps the incoming `req` and `res` Node instances using the [Request](./Request.md "Request") and [Reply](./Reply.md "Reply") objects internally, but this is done after the middlewares phase. If you need to create a middleware you have to use the Node `req` and `res` instances. Otherwise, you can use the `preHandler` hook that has the [Request](./Request.md "Request") and [Reply](./Reply.md "Reply") Fastify instances. For more information, see [Hooks](./Hooks.md "Hooks").
-
-<a name="restrict-usage"></a>
-#### Restrict middleware execution to a certain path(s)
-If you need to run a middleware only under certain path(s), just pass the path as first parameter to `use` and you are done!
-
-*Note that this does not support routes with parameters, (eg: `/user/:id/comments`) and wildcard is not supported in multiple paths.*
-
-```js
-const path = require('path')
-const serveStatic = require('serve-static')
-
-// Single path
-fastify.use('/css', serveStatic(path.join(__dirname, '/assets')))
-
-// Wildcard path
-fastify.use('/css/*', serveStatic(path.join(__dirname, '/assets')))
-
-// Multiple paths
-fastify.use(['/css', '/js'], serveStatic(path.join(__dirname, '/assets')))
-```
-
-<a name="express-middleware"></a>
-#### Express middleware compatibility
-Express modifies the prototype of the node core Request and Response objects heavily so Fastify cannot guarantee full middleware compatibility. Express specific functionality such as `res.sendFile()`, `res.send()` or `express.Router()` instances will not work with Fastify. For example, [cors](https://github.com/expressjs/cors) is compatible while [passport](https://github.com/jaredhanson/passport) is not.
diff --git a/docs/Plugins-Guide.md b/docs/Plugins-Guide.md
index ed81f37e..1f3ebc8b 100644
--- a/docs/Plugins-Guide.md
+++ b/docs/Plugins-Guide.md
@@ -16,47 +16,46 @@ Fastify was built from the beginning to be an extremely modular system. We built
 
 <a name="register"></a>
 ## Register
-As in JavaScript everything is an object, in Fastify everything is a plugin.<br>
-Your routes, your utilities and so on are all plugins. To add a new plugin, whatever its functionality is, in Fastify you have a nice and unique api to use: [`register`](https://github.com/fastify/fastify/blob/master/docs/Plugins.md).
+As with JavaScript, where everything is an object, in Fastify everything is a plugin.<br>
+Your routes, your utilities and so on are all plugins. To add a new plugin, whatever its functionality may be, in Fastify you have a nice and unique API: [`register`](https://github.com/fastify/fastify/blob/master/docs/Plugins.md).
 ```js
 fastify.register(
   require('./my-plugin'),
   { options }
 )
 ```
-`register` creates a new Fastify context, this means that if you do any change to the Fastify instance, those changes will not be reflected in the context's ancestors. In other words, encapsulation!
-
+`register` creates a new Fastify context, which means that if you perform any changes on the Fastify instance, those changes will not be reflected in the context's ancestors. In other words, encapsulation!
 
 *Why is encapsulation important?*<br>
-Well, let's say you are creating a new disruptive startup, what do you do? You create an api server with all your stuff, everything in the same place, a monolith!<br>
-Ok, you are growing very fast and you want to change your architecture and try microservices. Usually this implies a huge amount of work, because of cross dependencies and the lack of separation of concerns.<br>
-Fastify helps you a lot in this direction, because thanks to the encapsulation model it will completely avoid cross dependencies, and will help you structure your code in cohesive blocks.
+Well, let's say you are creating a new disruptive startup, what do you do? You create an API server with all your stuff, everything in the same place, a monolith!<br>
+Ok, you are growing very fast and you want to change your architecture and try microservices. Usually, this implies a huge amount of work, because of cross dependencies and a lack of separation of concerns in the codebase.<br>
+Fastify helps you in that regard. Thanks to the encapsulation model it will completely avoid cross dependencies, and will help you structure your code into cohesive blocks.
 
 *Let's return to how to correctly use `register`.*<br>
 As you probably know, the required plugins must expose a single function with the following signature
 ```js
-module.exports = function (fastify, options, next) {}
+module.exports = function (fastify, options, done) {}
 ```
-Where `fastify` is (pretty obvious) the encapsulated Fastify instance, `options` is the options object and `next` is the function you **must** call when your plugin is ready.
+Where `fastify` is the encapsulated Fastify instance, `options` is the options object and `done` is the function you **must** call when your plugin is ready.
 
-Fastify's plugin model is fully reentrant and graph-based, it handles without any kind of problem asynchronous code and it guarantees the load order of the plugins, even the close order! *How?* Glad you asked, checkout [`avvio`](https://github.com/mcollina/avvio)! Fastify starts loading the plugin __after__ `.listen()`, `.inject()` or `.ready()` are called.
+Fastify's plugin model is fully reentrant and graph-based, it handles asynchronous code without any problems and it enforces both the load and close order of plugins. *How?* Glad you asked, check out [`avvio`](https://github.com/mcollina/avvio)! Fastify starts loading the plugin __after__ `.listen()`, `.inject()` or `.ready()` are called.
 
-Inside a plugin you can do whatever you want, register routes, utilities (we'll see this in a moment) and do nested registers, just remember to call `next` when everything is set up!
+Inside a plugin you can do whatever you want, register routes, utilities (we'll see this in a moment) and do nested registers, just remember to call `done` when everything is set up!
 ```js
-module.exports = function (fastify, options, next) {
+module.exports = function (fastify, options, done) {
   fastify.get('/plugin', (request, reply) => {
     reply.send({ hello: 'world' })
   })
 
-  next()
+  done()
 }
 ```
 
-Well, now you know how to use the `register` api and how it works, but how do we add new functionality to Fastify and even better, share them with other developers?
+Well, now you know how to use the `register` API and how it works, but how do we add new functionality to Fastify and even better, share them with other developers?
 
 <a name="decorators"></a>
 ## Decorators
-Okay, let's say that you wrote an utility that is so good that you decided to make it available along all your code. How would you do it? Probably something like the following:
+Okay, let's say that you wrote a utility that is so good that you decided to make it available along with all your code. How would you do it? Probably something like the following:
 ```js
 // your-awesome-utility.js
 module.exports = function (a, b) {
@@ -65,55 +64,57 @@ module.exports = function (a, b) {
 ```
 ```js
 const util = require('./your-awesome-utility')
-console.log(util('that is ', ' awesome'))
+console.log(util('that is ', 'awesome'))
 ```
-And now you will import your utility in every file you need it. (And don't forget that you will probably also need it in your test).
+And now you will import your utility in every file you need it in. (And don't forget that you will probably also need it in your tests).
 
-Fastify offers you a way nicer and elegant way to do this, *decorators*.
-Create a decorator is extremely easy, just use the [`decorate`](https://github.com/fastify/fastify/blob/master/docs/Decorators.md) api:
+Fastify offers you a more elegant and comfortable way to do this, *decorators*.
+Creating a decorator is extremely easy, just use the [`decorate`](https://github.com/fastify/fastify/blob/master/docs/Decorators.md) API:
 ```js
 fastify.decorate('util', (a, b) => a + b)
 ```
-Now you can access your utility just by doing `fastify.util` whenever you need it, even inside your test.<br>
-And here's starts the magic; do you remember that few lines above we talked about encapsulation? Well, using `register` and `decorate` in conjunction enable exactly that, let me show you an example to clarify this:
+Now you can access your utility just by calling `fastify.util` whenever you need it - even inside your test.<br>
+And here starts the magic; do you remember how just now we were talking about encapsulation? Well, using `register` and `decorate` in conjunction enable exactly that, let me show you an example to clarify this:
 ```js
-fastify.register((instance, opts, next) => {
+fastify.register((instance, opts, done) => {
   instance.decorate('util', (a, b) => a + b)
-  console.log(instance.util('that is ', ' awesome'))
+  console.log(instance.util('that is ', 'awesome'))
 
-  next()
+  done()
 })
 
-fastify.register((instance, opts, next) => {
-  console.log(instance.util('that is ', ' awesome')) // this will throw an error
+fastify.register((instance, opts, done) => {
+  console.log(instance.util('that is ', 'awesome')) // This will throw an error
 
-  next()
+  done()
 })
 ```
 Inside the second register call `instance.util` will throw an error, because `util` exists only inside the first register context.<br>
-Let's step back for a moment and get deeper on this: when using the `register` api you will create a new context every time and this avoids situations like the one mentioned few line above. But pay attention, the encapsulation works only for the ancestors and the brothers, but not for the sons.
+Let's step back for a moment and dig deeper into this: every time you use the `register` API, a new context is created which avoids the negative situations mentioned above.
+
+Do note that encapsulation applies to the ancestors and siblings, but not the children. 
 ```js
-fastify.register((instance, opts, next) => {
+fastify.register((instance, opts, done) => {
   instance.decorate('util', (a, b) => a + b)
-  console.log(instance.util('that is ', ' awesome'))
+  console.log(instance.util('that is ', 'awesome'))
 
-  fastify.register((instance, opts, next) => {
-    console.log(instance.util('that is ', ' awesome')) // this will not throw an error
-    next()
+  fastify.register((instance, opts, done) => {
+    console.log(instance.util('that is ', 'awesome')) // This will not throw an error
+    done()
   })
 
-  next()
+  done()
 })
 
-fastify.register((instance, opts, next) => {
-  console.log(instance.util('that is ', ' awesome')) // this will throw an error
+fastify.register((instance, opts, done) => {
+  console.log(instance.util('that is ', 'awesome')) // This will throw an error
 
-  next()
+  done()
 })
 ```
-*Take home message: if you need that an utility is available in every part of your application, pay attention that is declared at the root scope of your application. Otherwise you can use `fastify-plugin` utility as described [here](#distribution).*
+*Take home message: if you need an utility which is available in every part of your application, take care that it's declared in the root scope of your application. If that's not an option you can use the `fastify-plugin` utility as described [here](#distribution).*
 
-`decorate` is not the unique api that you can use to extend the server functionalities, you can also use `decorateRequest` and `decorateReply`.
+`decorate` is not the only API that you can use to extend the server functionality, you can also use `decorateRequest` and `decorateReply`.
 
 *`decorateRequest` and `decorateReply`? Why do we need them if we already have `decorate`?*<br>
 Good question, we added them to make Fastify more developer-friendly. Let's see an example:
@@ -128,10 +129,10 @@ fastify.get('/html', (request, reply) => {
     .send(fastify.html({ hello: 'world' }))
 })
 ```
-It works, but it can be way better!
+It works, but it could be way better!
 ```js
 fastify.decorateReply('html', function (payload) {
-  this.type('text/html') // this is the 'Reply' object
+  this.type('text/html') // This is the 'Reply' object
   this.send(generateHtml(payload))
 })
 
@@ -161,7 +162,7 @@ fastify.decorateRequest('setHeader', function (header) {
   this.isHappy = this.headers[header]
 })
 
-fastify.decorateRequest('isHappy', false) // this will be added to the Request object prototype, yay speed!
+fastify.decorateRequest('isHappy', false) // This will be added to the Request object prototype, yay speed!
 
 fastify.addHook('preHandler', (request, reply, done) => {
   request.setHeader('happy')
@@ -173,7 +174,7 @@ fastify.get('/happiness', (request, reply) => {
 })
 ```
 
-We've seen how to extend server functionality and how handle the encapsulation system, but what if you need to add a function that must be executed every time that the server "[emits](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md)" an event?
+We've seen how to extend server functionality and how to handle the encapsulation system, but what if you need to add a function that must be executed every time when the server "[emits](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md)" an event?
 
 <a name="hooks"></a>
 ## Hooks
@@ -191,9 +192,9 @@ fastify.get('/plugin2', (request, reply) => {
   reply.send(request)
 })
 ```
-I think we all agree that this is terrible. Code repeat, awful readability and it cannot scale.
+I think we all agree that this is terrible. Repeated code, awful readability and it cannot scale.
 
-So what can you do to avoid this annoying issue? Yes, you are right, use an [hook](https://github.com/fastify/fastify/blob/master/docs/Hooks.md)!<br>
+So what can you do to avoid this annoying issue? Yes, you are right, use a [hook](https://github.com/fastify/fastify/blob/master/docs/Hooks.md)!<br>
 ```js
 fastify.decorate('util', (request, key, value) => { request[key] = value })
 
@@ -210,11 +211,11 @@ fastify.get('/plugin2', (request, reply) => {
   reply.send(request)
 })
 ```
-Now for every request you will run your utility, it is obvious that you can register as many hooks as you need.<br>
-It can happen that you want a hook that must be executed just for a subset of routes, how can you do that?  Yep, encapsulation!
+Now for every request, you will run your utility. Obviously you can register as many hooks as you need.<br>
+Sometimes you want a hook that should be executed for just a subset of routes, how can you do that? Yep, encapsulation!
 
 ```js
-fastify.register((instance, opts, next) => {
+fastify.register((instance, opts, done) => {
   instance.decorate('util', (request, key, value) => { request[key] = value })
 
   instance.addHook('preHandler', (request, reply, done) => {
@@ -226,7 +227,7 @@ fastify.register((instance, opts, next) => {
     reply.send(request)
   })
 
-  next()
+  done()
 })
 
 fastify.get('/plugin2', (request, reply) => {
@@ -235,13 +236,13 @@ fastify.get('/plugin2', (request, reply) => {
 ```
 Now your hook will run just for the first route!
 
-As you probably noticed at this time, `request` and `reply` are not the standard Nodejs *request* and *response* objects, but Fastify's objects.<br>
+As you probably noticed by now, `request` and `reply` are not the standard Nodejs *request* and *response* objects, but Fastify's objects.<br>
 
-<a name="middlewares"></a>
-## Middlewares
-Fastify [supports](https://github.com/fastify/fastify/blob/master/docs/Middlewares.md) out of the box Express/Restify/Connect middlewares, this means that you can just drop-in your old code and it will work! *(faster, by the way)*<br>
-Let's say that you are arriving from Express, and you already have some Middleware that does exactly what you need, and you don't want to redo all the work.
-How we can do that? Checkout our middlewares engine, [middie](https://github.com/fastify/middie).
+<a name="middleware"></a>
+## Middleware
+Fastify [supports](https://github.com/fastify/fastify/blob/master/docs/Middleware.md) Express/Restify/Connect middleware out-of-the-box, which means that you can just drop-in your old code and it will work! *(faster, by the way)*<br>
+Let's say that you are arriving from Express, and you already have some Middleware which does exactly what you need, and you don't want to redo all the work.
+How we can do that? Check out our middleware engine, [middie](https://github.com/fastify/middie).
 ```js
 const yourMiddleware = require('your-middleware')
 fastify.use(yourMiddleware)
@@ -249,27 +250,26 @@ fastify.use(yourMiddleware)
 
 <a name="distribution"></a>
 ## How to handle encapsulation and distribution
-Perfect, now you know (almost) all the tools that you can use to extend Fastify. But probably there is something you noted when trying out your code.<br>
-How can you distribute your code?
+Perfect, now you know (almost) all of the tools that you can use to extend Fastify. But chances are that you came across one big issue: how is distribution handled?
 
-The preferred way to distribute a utility is to wrap all your code inside a `register`, in this way your plugin can support an asynchronous bootstrap *(since `decorate` is a synchronous api)*, in the case of a database connection for example.
+The preferred way to distribute a utility is to wrap all your code inside a `register`, in this way your plugin can support asynchronous bootstrapping *(since `decorate` is a synchronous API)*, in the case of a database connection for example.
 
-*Wait, what? Didn't you tell me that `register` creates an encapsulation and that what I create inside there will not be available outside?*<br>
-Yes, I said that. But what I didn't tell you, is that you can tell to Fastify to avoid this behavior, with the [`fastify-plugin`](https://github.com/fastify/fastify-plugin) module.
+*Wait, what? Didn't you tell me that `register` creates an encapsulation and that the stuff I create inside will not be available outside?*<br>
+Yes, I said that. But what I didn't tell you, is that you can tell to Fastify to avoid this behaviour, with the [`fastify-plugin`](https://github.com/fastify/fastify-plugin) module.
 ```js
 const fp = require('fastify-plugin')
 const dbClient = require('db-client')
 
-function dbPlugin (fastify, opts, next) {
+function dbPlugin (fastify, opts, done) {
   dbClient.connect(opts.url, (err, conn) => {
     fastify.decorate('db', conn)
-    next()
+    done()
   })
 }
 
 module.exports = fp(dbPlugin)
 ```
-You can also tell to `fastify-plugin` to check the installed version of Fastify, in case of you need a specific api.
+You can also tell `fastify-plugin` to check the installed version of Fastify, in case you need a specific API.
 
 As we mentioned earlier, Fastify starts loading its plugins __after__ `.listen()`, `.inject()` or `.ready()` are called and as such, __after__ they have been declared. This means that, even though the plugin may inject variables to the external fastify instance via [`decorate`](https://github.com/fastify/fastify/blob/master/docs/Decorators.md), the decorated variables will not be accessible before calling `.listen()`, `.inject()` or `.ready()`.
 
@@ -279,10 +279,10 @@ const fastify = require('fastify')()
 const fp = require('fastify-plugin')
 const dbClient = require('db-client')
 
-function dbPlugin (fastify, opts, next) {
+function dbPlugin (fastify, opts, done) {
   dbClient.connect(opts.url, (err, conn) => {
     fastify.decorate('db', conn)
-    next()
+    done()
   })
 }
 
@@ -295,14 +295,14 @@ In the above example, the `parent` variable of the function passed in as the sec
 
 <a name="handle-errors"></a>
 ## Handle errors
-It can happen that one of your plugins could fail during the startup. Maybe you expect it and you have a custom logic that will be triggered in that case. How can you do this?
-The `after` api is what you need. `after` simply registers a callback that will be executed just after a register, and it can take up to three parameters.<br>
-The callback changes based on the parameters your are giving:
+It can happen that one of your plugins fails during startup. Maybe you expect it and you have a custom logic that will be triggered in that case. How can you implement this?
+The `after` API is what you need. `after` simply registers a callback that will be executed just after a register, and it can take up to three parameters.<br>
+The callback changes based on the parameters you are giving:
 
 1. If no parameter is given to the callback and there is an error, that error will be passed to the next error handler.
 1. If one parameter is given to the callback, that parameter will be the error object.
 1. If two parameters are given to the callback, the first will be the error object, the second will be the done callback.
-1. If three parameters are given to the callback, the first will be the error object, the second will be the top level context unless you have specified both server and override, in that case the context will be what the override returns, and the third the done callback.
+1. If three parameters are given to the callback, the first will be the error object, the second will be the top-level context unless you have specified both server and override, in that case, the context will be what the override returns, and the third the done callback.
 
 Let's see how to use it:
 ```js
@@ -317,14 +317,14 @@ fastify
 ## Let's start!
 Awesome, now you know everything you need to know about Fastify and its plugin system to start building your first plugin, and please if you do, tell us! We will add it to the [*ecosystem*](https://github.com/fastify/fastify#ecosystem) section of our documentation!
 
-If you want to see some real world example, checkout:
+If you want to see some real-world example, check out:
 - [`point-of-view`](https://github.com/fastify/point-of-view)
 Templates rendering (*ejs, pug, handlebars, marko*) plugin support for Fastify.
 - [`fastify-mongodb`](https://github.com/fastify/fastify-mongodb)
-Fastify MongoDB connection plugin, with this you can share the same MongoDb connection pool in every part of your server.
+Fastify MongoDB connection plugin, with this you can share the same MongoDB connection pool in every part of your server.
 - [`fastify-multipart`](https://github.com/fastify/fastify-multipart)
 Multipart support for Fastify
 - [`fastify-helmet`](https://github.com/fastify/fastify-helmet) Important security headers for Fastify
 
 
-*Do you feel it's missing something here? Let us know! :)*
+*Do you feel like something is missing here? Let us know! :)*
diff --git a/docs/Plugins.md b/docs/Plugins.md
index dc90037e..921e22e4 100644
--- a/docs/Plugins.md
+++ b/docs/Plugins.md
@@ -16,8 +16,11 @@ fastify.register(plugin, [options])
 The optional `options` parameter for `fastify.register` supports a predefined set of options that Fastify itself will use, except when the plugin has been wrapped with [fastify-plugin](https://github.com/fastify/fastify-plugin). This options object will also be passed to the plugin upon invocation, regardless of whether or not the plugin has been wrapped. The currently supported list of Fastify specific options is:
 
 + [`logLevel`](https://github.com/fastify/fastify/blob/master/docs/Routes.md#custom-log-level)
++ [`logSerializers`](https://github.com/fastify/fastify/blob/master/docs/Routes.md#custom-log-serializer)
 + [`prefix`](https://github.com/fastify/fastify/blob/master/docs/Plugins.md#route-prefixing-options)
 
+**Note: Those options will be ignored when used with fastify-plugin**
+
 It is possible that Fastify will directly support other options in the future. Thus, to avoid collisions, a plugin should consider namespacing its options. For example, a plugin `foo` might be registered like so:
 
 ```js
@@ -45,10 +48,10 @@ The `options` parameter can also be a `Function` which will be evaluated at the
 ```js
 const fp = require('fastify-plugin')
 
-fastify.register(fp((fastify, opts, next) => {
+fastify.register(fp((fastify, opts, done) => {
   fastify.decorate('foo_bar', { hello: 'world' })
 
-  next()
+  done()
 }))
 
 // The opts argument of fastify-foo will be { hello: 'world' }
@@ -97,27 +100,27 @@ await fastify.listen(3000)
 ```
 <a name="create-plugin"></a>
 ### Create a plugin
-Creating a plugin is very easy, you just need to create a function that takes three parameters, the `fastify` instance, an options object and the next callback.<br>
+Creating a plugin is very easy, you just need to create a function that takes three parameters, the `fastify` instance, an `options` object and the `done` callback.<br>
 Example:
 ```js
-module.exports = function (fastify, opts, next) {
+module.exports = function (fastify, opts, done) {
   fastify.decorate('utility', () => {})
 
   fastify.get('/', handler)
 
-  next()
+  done()
 }
 ```
 You can also use `register` inside another `register`:
 ```js
-module.exports = function (fastify, opts, next) {
+module.exports = function (fastify, opts, done) {
   fastify.decorate('utility', () => {})
 
   fastify.get('/', handler)
 
   fastify.register(require('./other-plugin'))
 
-  next()
+  done()
 }
 ```
 Sometimes, you will need to know when the server is about to close, for example because you must close a connection to a database. To know when this is going to happen, you can use the [`'onClose'`](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#on-close) hook.
@@ -136,18 +139,18 @@ We recommend to using the `fastify-plugin` module, because it solves this proble
 ```js
 const fp = require('fastify-plugin')
 
-module.exports = fp(function (fastify, opts, next) {
+module.exports = fp(function (fastify, opts, done) {
   fastify.decorate('utility', () => {})
-  next()
+  done()
 }, '0.x')
 ```
 Check the [`fastify-plugin`](https://github.com/fastify/fastify-plugin) documentation to know more about how use this module.
 
 If you don't use the `fastify-plugin` module, you can use the `'skip-override'` hidden property, but we do not recommend it. If in the future the Fastify API changes it will be a your responsibility update the module, while if you use `fastify-plugin`, you can be sure about backwards compatibility.
 ```js
-function yourPlugin (fastify, opts, next) {
+function yourPlugin (fastify, opts, done) {
   fastify.decorate('utility', () => {})
-  next()
+  done()
 }
 yourPlugin[Symbol.for('skip-override')] = true
 module.exports = yourPlugin
diff --git a/docs/Reply.md b/docs/Reply.md
index 2cf8d61d..d68c12b9 100644
--- a/docs/Reply.md
+++ b/docs/Reply.md
@@ -4,12 +4,15 @@
 - [Reply](#reply)
   - [Introduction](#introduction)
   - [.code(statusCode)](#codestatuscode)
+  - [.statusCode](#statusCode)
   - [.header(key, value)](#headerkey-value)
+  - [.headers(object)](#headersobject)
   - [.getHeader(key)](#getheaderkey)
   - [.removeHeader(key)](#removeheaderkey)
   - [.hasHeader(key)](#hasheaderkey)
   - [.redirect(dest)](#redirectdest)
   - [.callNotFound()](#callnotfound)
+  - [.getResponseTime()](#getresponsetime)
   - [.type(contentType)](#typecontenttype)
   - [.serializer(func)](#serializerfunc)
   - [.sent](#sent)
@@ -21,7 +24,8 @@
     - [Errors](#errors)
     - [Type of the final payload](#type-of-the-final-payload)
     - [Async-Await and Promises](#async-await-and-promises)
-  
+  - [.then](#then)
+
 <a name="introduction"></a>
 ### Introduction
 The second parameter of the handler function is `Reply`.
@@ -30,7 +34,9 @@ and properties:
 
 - `.code(statusCode)` - Sets the status code.
 - `.status(statusCode)` - An alias for `.code(statusCode)`.
+- `.statusCode` - Read and set the HTTP status code.
 - `.header(name, value)` - Sets a response header.
+- `.headers(object)` - Sets all the keys of the object as a response headers.
 - `.getHeader(name)` - Retrieve value of already set header.
 - `.removeHeader(key)` - Remove the value of a previously set header.
 - `.hasHeader(name)` - Determine if a header has been set.
@@ -42,7 +48,8 @@ and properties:
 - `.send(payload)` - Sends the payload to the user, could be a plain text, a buffer, JSON, stream, or an Error object.
 - `.sent` - A boolean value that you can use if you need to know if `send` has already been called.
 - `.res` - The [`http.ServerResponse`](https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_serverresponse) from Node core.
-- `.log` - the logger instance of the incoming request
+- `.log` - The logger instance of the incoming request.
+- `.request` - The incoming request.
 
 ```js
 fastify.get('/', options, function (request, reply) {
@@ -66,6 +73,15 @@ fastify.get('/', {config: {foo: 'bar'}}, function (request, reply) {
 ### .code(statusCode)
 If not set via `reply.code`, the resulting `statusCode` will be `200`.
 
+<a name="statusCode"></a>
+### .statusCode
+This property reads and sets the HTTP status code. It is an alias for `reply.code()` when used as a setter.
+```js
+if (reply.statusCode >= 299) {
+  reply.statusCode = 500
+}
+```
+
 <a name="header"></a>
 ### .header(key, value)
 Sets a response header. If the value is omitted or undefined it is coerced
@@ -73,11 +89,21 @@ to `''`.
 
 For more information, see [`http.ServerResponse#setHeader`](https://nodejs.org/dist/latest/docs/api/http.html#http_response_setheader_name_value).
 
+<a name="headers"></a>
+### .headers(object)
+Sets all the keys of the object as response headers. [`.header`](#headerkey-value) will be called under the hood.
+```js
+reply.headers({
+  'x-foo': 'foo',
+  'x-bar': 'bar'
+})
+```
+
 <a name="getHeader"></a>
 ### .getHeader(key)
 Retrieves the value of a previously set header.
 ```js
-reply.header('x-foo', 'foo')
+reply.header('x-foo', 'foo') // setHeader: key, value
 reply.getHeader('x-foo') // 'foo'
 ```
 
@@ -109,6 +135,14 @@ Invokes the custom not found handler.
 reply.callNotFound()
 ```
 
+<a name="getResponseTime"></a>
+### .getResponseTime()
+Invokes the custom response time getter to calculate the amount of time passed since the request was started.
+
+```js
+const milliseconds = reply.getResponseTime()
+```
+
 <a name="type"></a>
 ### .type(contentType)
 Sets the content type for the response.
@@ -215,11 +249,12 @@ If you pass to *send* an object that is an instance of *Error*, Fastify will aut
 ```js
 {
   error: String        // the http error message
+  code: String         // the Fastify error code
   message: String      // the user error message
   statusCode: Number   // the http status code
 }
 ```
-You can add some custom property to the Error object, such as `statusCode` and `headers`, that will be used to enhance the http response.<br>
+You can add some custom property to the Error object, such as `headers`, that will be used to enhance the http response.<br>
 *Note: If you are passing an error to `send` and the statusCode is less than 400, Fastify will automatically set it at 500.*
 
 Tip: you can simplify errors by using the [`http-errors`](https://npm.im/http-errors) module or [`fastify-sensible`](https://github.com/fastify/fastify-sensible) plugin to generate errors:
@@ -274,17 +309,15 @@ The type of the sent payload (after serialization and going through any [`onSend
 Fastify natively handles promises and supports async-await.<br>
 *Note that in the following examples we are not using reply.send.*
 ```js
+const delay = promisify(setTimeout)
+
 fastify.get('/promises', options, function (request, reply) {
-  return new Promise(function (resolve) {
-    setTimeout(resolve, 200, { hello: 'world' })
-  })
+ return delay(200).then(() => { return { hello: 'world' }})
 })
 
 fastify.get('/async-await', options, async function (request, reply) {
-  var res = await new Promise(function (resolve) {
-    setTimeout(resolve, 200, { hello: 'world' })
-  })
-  return res
+  await delay(200)
+  return { hello: 'world' }
 })
 ```
 
@@ -300,3 +333,21 @@ fastify.get('/teapot', async function (request, reply) => {
 ```
 
 If you want to know more please review [Routes#async-await](https://github.com/fastify/fastify/blob/master/docs/Routes.md#async-await).
+
+<a name="then"></a>
+### .then(fullfilled, rejected)
+
+As the name suggests, a `Reply` object can be awaited upon, i.e. `await reply` will wait until the reply is sent.
+The `await` syntax calls the `reply.then()`.
+
+`reply.then(fullfilled, rejected)` accepts two parameters:
+
+- `fullfilled` will be called when a response has been fully sent,
+- `rejected` will be called if the underlying stream had an error, e.g.
+the socket has been destroyed.
+
+For more details, see:
+
+- https://github.com/fastify/fastify/issues/1864 for the discussion about this feature
+- https://promisesaplus.com/ for the definition of thenables
+- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature
diff --git a/docs/Routes.md b/docs/Routes.md
index 4afeb31c..8848b281 100644
--- a/docs/Routes.md
+++ b/docs/Routes.md
@@ -1,14 +1,34 @@
 <h1 align="center">Fastify</h1>
 
 ## Routes
-You have two ways to declare a route with Fastify, the shorthand method and the full declaration. Let's start with the second one:
+
+The routes methods will configure the endpoints of your application. 
+You have two ways to declare a route with Fastify, the shorthand method and the full declaration.
+
+- [Full Declaration](#full-declaration)
+- [Route Options](#options)
+- [Shorthand Declaration](#shorthand-declaration)
+- [URL Parameters](#url-building)
+- [Use `async`/`await`](#async-await)
+- [Promise resolution](#promise-resolution)
+- [Route Prefixing](#route-prefixing)
+- Logs
+  - [Custom Log Level](#custom-log-level)
+  - [Custom Log Serializer](#custom-log-serializer)
+- [Route handler configuration](#routes-config)
+- [Route's Versioning](#version)
+
 <a name="full-declaration"></a>
 ### Full declaration
+
 ```js
 fastify.route(options)
 ```
-* `method`: currently it supports `'DELETE'`, `'GET'`, `'HEAD'`, `'PATCH'`, `'POST'`, `'PUT'` and `'OPTIONS'`. It could also be an array of methods.
 
+<a name="options"></a>
+### Routes option
+
+* `method`: currently it supports `'DELETE'`, `'GET'`, `'HEAD'`, `'PATCH'`, `'POST'`, `'PUT'` and `'OPTIONS'`. It could also be an array of methods.
 * `url`: the path of the url to match this route (alias: `path`).
 * `schema`: an object containing the schemas for the request and response.
 They need to be in
@@ -16,21 +36,24 @@ They need to be in
 
   * `body`: validates the body of the request if it is a POST or a
     PUT.
-  * `querystring`: validates the querystring. This can be a complete JSON
+  * `querystring` or `query`: validates the querystring. This can be a complete JSON
   Schema object, with the property `type` of `object` and `properties` object of parameters, or
   simply the values of what would be contained in the `properties` object as shown below.
   * `params`: validates the params.
   * `response`: filter and generate a schema for the response, setting a
     schema allows us to have 10-20% more throughput.
 * `attachValidation`: attach `validationError` to request, if there is a schema validation error, instead of sending the error to the error handler.
-* `onRequest(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#route-hooks) as soon that a request is received, it could also be an array of functions.
-* `preValidation(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#route-hooks) called after the shared `preValidation` hooks, useful if you need to perform authentication at route level for example, it could also be an array of functions.
-* `preHandler(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#route-hooks) called just before the request handler, it could also be an array of functions.
-* `preSerialization(request, reply, payload, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#route-hooks) called just before the serialization, it could also be an array of functions.
+* `onRequest(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#onrequest) as soon that a request is received, it could also be an array of functions.
+* `preParsing(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#preparsing) called before parsing the request, it could also be an array of functions.
+* `preValidation(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#prevalidation) called after the shared `preValidation` hooks, useful if you need to perform authentication at route level for example, it could also be an array of functions.
+* `preHandler(request, reply, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#prehandler) called just before the request handler, it could also be an array of functions.
+* `preSerialization(request, reply, payload, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#preserialization) called just before the serialization, it could also be an array of functions.
+* `onResponse(request, reply, payload, done)`: a [function](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#onresponse) called when a response has been sent, so you will not be able to send more data to the client. It could also be an array of functions.
 * `handler(request, reply)`: the function that will handle this request.
 * `schemaCompiler(schema)`: the function that build the schema for the validations. See [here](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md#schema-compiler)
 * `bodyLimit`: prevents the default JSON body parser from parsing request bodies larger than this number of bytes. Must be an integer. You may also set this option globally when first creating the Fastify instance with `fastify(options)`. Defaults to `1048576` (1 MiB).
 * `logLevel`: set log level for this route. See below.
+* `logSerializers`: set serializers to log for this route.
 * `config`: object used to store custom configuration.
 * `version`: a [semver](http://semver.org/) compatible string that defined the version of the endpoint. [Example](https://github.com/fastify/fastify/blob/master/docs/Routes.md#version).
 * `prefixTrailingSlash`: string used to determine how to handle passing `/` as a route with a prefix.
@@ -168,7 +191,6 @@ fastify.get('/', options, async function (request, reply) {
   return processed
 })
 ```
-**Warning:** You can't return `undefined`. For more details read [promise-resolution](#promise-resolution).
 
 As you can see we are not calling `reply.send` to send back the data to the user. You just need to return the body and you are done!
 
@@ -180,8 +202,32 @@ fastify.get('/', options, async function (request, reply) {
   reply.send(processed)
 })
 ```
+
+If the route is wrapping a callback-based API that will call
+`reply.send()` outside of the promise chain, it is possible to `await reply`:
+
+```js
+fastify.get('/', options, async function (request, reply) {
+  setImmediate(() => {
+    reply.send({ hello: 'world' })
+  })
+  await reply
+})
+```
+
+Returning reply also works:
+
+```js
+fastify.get('/', options, async function (request, reply) {
+  setImmediate(() => {
+    reply.send({ hello: 'world' })
+  })
+  return reply
+})
+```
+
 **Warning:**
-* If you use `return` and `reply.send` at the same time, the first one that happens takes precedence, the second value will be discarded, a *warn* log will also be emitted because you tried to send a response twice.
+* When using both `return value` and `reply.send(value)` at the same time, the first one that happens takes precedence, the second value will be discarded, and a *warn* log will also be emitted because you tried to send a response twice.
 * You can't return `undefined`. For more details read [promise-resolution](#promise-resolution).
 
 <a name="promise-resolution"></a>
@@ -214,18 +260,20 @@ fastify.register(require('./routes/v2/users'), { prefix: '/v2' })
 
 fastify.listen(3000)
 ```
+
 ```js
 // routes/v1/users.js
-module.exports = function (fastify, opts, next) {
+module.exports = function (fastify, opts, done) {
   fastify.get('/user', handler_v1)
-  next()
+  done()
 }
 ```
+
 ```js
 // routes/v2/users.js
-module.exports = function (fastify, opts, next) {
+module.exports = function (fastify, opts, done) {
   fastify.get('/user', handler_v2)
-  next()
+  done()
 }
 ```
 Fastify will not complain because you are using the same name for two different routes, because at compilation time it will handle the prefix automatically *(this also means that the performance will not be affected at all!)*.
@@ -249,7 +297,7 @@ See the `prefixTrailingSlash` route option above to change this behaviour.
 
 <a name="custom-log-level"></a>
 ### Custom Log Level
-It could happen that you need different log levels in your routes, with Fastify achieve this is very straightforward.<br/>
+It could happen that you need different log levels in your routes, Fastify achieves this in a very straightforward way.<br/>
 You just need to pass the option `logLevel` to the plugin option or the route option with the [value](https://github.com/pinojs/pino/blob/master/docs/API.md#discussion-3) that you need.
 
 Be aware that if you set the `logLevel` at plugin level, also the [`setNotFoundHandler`](https://github.com/fastify/fastify/blob/master/docs/Server.md#setnotfoundhandler) and [`setErrorHandler`](https://github.com/fastify/fastify/blob/master/docs/Server.md#seterrorhandler) will be affected.
@@ -263,6 +311,7 @@ fastify.register(require('./routes/events'), { logLevel: 'debug' })
 
 fastify.listen(3000)
 ```
+
 Or you can directly pass it to a route:
 ```js
 fastify.get('/', { logLevel: 'warn' }, (request, reply) => {
@@ -271,6 +320,64 @@ fastify.get('/', { logLevel: 'warn' }, (request, reply) => {
 ```
 *Remember that the custom log level is applied only to the routes, and not to the global Fastify Logger, accessible with `fastify.log`*
 
+<a name="custom-log-serializer"></a>
+### Custom Log Serializer
+
+In some context, you may need to log a large object but it could be a waste of resources for some routes. In this case, you can define some [`serializer`](https://github.com/pinojs/pino/blob/master/docs/api.md#bindingsserializers-object) and attach them in the right context!
+
+```js
+const fastify = require('fastify')({ logger: true })
+
+fastify.register(require('./routes/user'), { 
+  logSerializers: {
+    user: (value) => `My serializer one - ${value.name}`
+  } 
+})
+fastify.register(require('./routes/events'), {
+  logSerializers: {
+    user: (value) => `My serializer two - ${value.name} ${value.surname}`
+  }
+})
+
+fastify.listen(3000)
+```
+
+You can inherit serializers by context:
+
+```js
+const fastify = Fastify({ 
+  logger: {
+    level: 'info',
+    serializers: {
+      user (req) {
+        return {
+          method: req.method,
+          url: req.url,
+          headers: req.headers,
+          hostname: req.hostname,
+          remoteAddress: req.ip,
+          remotePort: req.connection.remotePort
+        }
+      }
+    }
+  } 
+})
+
+fastify.register(context1, { 
+  logSerializers: {
+    user: value => `My serializer father - ${value}`
+  } 
+})
+
+async function context1 (fastify, opts) {
+  fastify.get('/', (req, reply) => {
+    req.log.info({ user: 'call father serializer', key: 'another key' }) // shows: { user: 'My serializer father - call father  serializer', key: 'another key' }
+    reply.send({})
+  })
+}
+
+fastify.listen(3000)
+```
 
 <a name="routes-config"></a>
 ### Config
@@ -292,10 +399,12 @@ fastify.listen(3000)
 
 <a name="version"></a>
 ### Version
+
 #### Default
 If needed you can provide a version option, which will allow you to declare multiple versions of the same route. The versioning should follow the [semver](http://semver.org/) specification.<br/>
 Fastify will automatically detect the `Accept-Version` header and route the request accordingly (advanced ranges and pre-releases currently are not supported).<br/>
 *Be aware that using this feature will cause a degradation of the overall performances of the router.*
+
 ```js
 fastify.route({
   method: 'GET',
@@ -316,7 +425,9 @@ fastify.inject({
   // { hello: 'world' }
 })
 ```
+
 If you declare multiple versions with the same major or minor, Fastify will always choose the highest compatible with the `Accept-Version` header value.<br/>
 If the request will not have the `Accept-Version` header, a 404 error will be returned.
+
 #### Custom
 It's possible to define a custom versioning logic. This can be done through the [`versioning`](https://github.com/fastify/fastify/blob/master/docs/Server.md#versioning) configuration, when creating a fastify server instance.
diff --git a/docs/Server.md b/docs/Server.md
index dcd0c565..58973bdf 100644
--- a/docs/Server.md
+++ b/docs/Server.md
@@ -75,7 +75,7 @@ Defines the maximum payload, in bytes, the server is allowed to accept.
 
 Defines what action the framework must take when parsing a JSON object
 with `__proto__`. This functionality is provided by
-[bourne](https://github.com/hapijs/bourne).
+[secure-json-parse](https://github.com/fastify/secure-json-parse).
 See https://hueniverse.com/a-tale-of-prototype-poisoning-2610fa170061
 for more details about prototype poisoning attacks.
 
@@ -83,6 +83,19 @@ Possible values are `'error'`, `'remove'` and `'ignore'`.
 
 + Default: `'error'`
 
+<a name="factory-on-constructor-poisoning"></a>
+### `onConstructorPoisoning`
+
+Defines what action the framework must take when parsing a JSON object
+with `constructor`. This functionality is provided by
+[secure-json-parse](https://github.com/fastify/secure-json-parse).
+See https://hueniverse.com/a-tale-of-prototype-poisoning-2610fa170061
+for more details about prototype poisoning attacks.
+
+Possible values are `'error'`, `'remove'` and `'ignore'`.
+
++ Default: `'ignore'`
+
 <a name="factory-logger"></a>
 ### `logger`
 
@@ -104,7 +117,7 @@ are not present on the object, they will be added accordingly:
     for incoming requests. The default function generates sequential identifiers.
     * `level`: the minimum logging level. If not set, it will be set to `'info'`.
     * `serializers`: a hash of serialization functions. By default, serializers
-      are added for `req` (incoming request objects), `res` (outgoing repsonse
+      are added for `req` (incoming request objects), `res` (outgoing response
       objets), and `err` (standard `Error` objects). When a log method receives
       an object with any of these properties then the respective serializer will
       be used for that property. For example:
@@ -150,14 +163,14 @@ custom `onRequest` and `onResponse` hooks.
 
 ```js
 // Examples of hooks to replicate the disabled functionality.
-fastify.addHook('onRequest', (req, reply, next) => {
+fastify.addHook('onRequest', (req, reply, done) => {
   req.log.info({ url: req.req.url, id: req.id }, 'received request')
-  next()
+  done()
 })
 
-fastify.addHook('onResponse', (req, reply, next) => {
+fastify.addHook('onResponse', (req, reply, done) => {
   req.log.info({ url: req.req.originalUrl, statusCode: res.res.statusCode }, 'request completed')
-  next()
+  done()
 })
 ```
 
@@ -230,7 +243,7 @@ Especially in distributed systems, you may want to override the default id gener
 ```js
 let i = 0
 const fastify = require('fastify')({
-  genReqId: function (req) { return req.headers['request-id'] || i++ }
+  genReqId: function (req) { return i++ }
 })
 ```
 
@@ -352,6 +365,50 @@ fastify.get('/', (request, reply) => {
 })
 ```
 
+<a name="factory-return-503-on-closing"></a>
+### `return503OnClosing`
+
+Returns 503 after calling `close` server method.
+If `false`, the server routes the incoming request as usual.
+
++ Default: `true`
+
+<a name="factory-ajv"></a>
+### `ajv`
+
+Configure the ajv instance used by Fastify without providing a custom one.
+
++ Default:
+
+```js
+{
+  customOptions: {
+    removeAdditional: true,
+    useDefaults: true,
+    coerceTypes: true,
+    allErrors: true,
+    nullable: true
+  },
+  plugins: []
+}
+```
+
+```js
+const fastify = require('fastify')({
+  ajv: {
+    customOptions: {
+      nullable: false // Refer to [ajv options](https://ajv.js.org/#options)
+    },
+    plugins: [
+      require('ajv-merge-patch')
+      [require('ajv-keywords'), 'instanceof'];
+      // Usage: [plugin, pluginOptions] - Plugin with options
+      // Usage: plugin - Plugin without options
+    ]
+  }
+})
+```
+
 ## Instance
 
 ### Server Methods
@@ -368,16 +425,16 @@ It is always executed before the method `fastify.ready`.
 
 ```js
 fastify
-  .register((instance, opts, next) => {
+  .register((instance, opts, done) => {
     console.log('Current plugin')
-    next()
+    done()
   })
   .after(err => {
     console.log('After current plugin')
   })
-  .register((instance, opts, next) => {
+  .register((instance, opts, done) => {
     console.log('Next plugin')
-    next()
+    done()
   })
   .ready(err => {
     console.log('Everything has been loaded')
@@ -516,6 +573,7 @@ Method to add routes to the server, it also has shorthand functions, check [here
 #### close
 `fastify.close(callback)`: call this function to close the server instance and run the [`'onClose'`](https://github.com/fastify/fastify/blob/master/docs/Hooks.md#on-close) hook.<br>
 Calling `close` will also cause the server to respond to every new incoming request with a `503` error and destroy that request.
+See [`return503OnClosing` flags](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-return-503-on-closing) for changing this behaviour.
 
 If it is called without any arguments, it will return a Promise:
 
@@ -538,7 +596,7 @@ A plugin can be a set of routes, a server decorator or whatever, check [here](ht
 
 <a name="use"></a>
 #### use
-Function to add middlewares to Fastify, check [here](https://github.com/fastify/fastify/blob/master/docs/Middlewares.md).
+Function to add middlewares to Fastify, check [here](https://github.com/fastify/fastify/blob/master/docs/Middleware.md).
 
 <a name="addHook"></a>
 #### addHook
@@ -551,27 +609,39 @@ The full path that will be prefixed to a route.
 Example:
 
 ```js
-fastify.register(function (instance, opts, next) {
+fastify.register(function (instance, opts, done) {
   instance.get('/foo', function (request, reply) {
     // Will log "prefix: /v1"
     request.log.info('prefix: %s', instance.prefix)
     reply.send({ prefix: instance.prefix })
   })
 
-  instance.register(function (instance, opts, next) {
+  instance.register(function (instance, opts, done) {
     instance.get('/bar', function (request, reply) {
       // Will log "prefix: /v1/v2"
       request.log.info('prefix: %s', instance.prefix)
       reply.send({ prefix: instance.prefix })
     })
 
-    next()
+    done()
   }, { prefix: '/v2' })
 
-  next()
+  done()
 }, { prefix: '/v1' })
 ```
 
+<a name="pluginName"></a>
+#### pluginName
+Name of the current plugin. There are three ways to define a name (in order).
+
+1. If you use [fastify-plugin](https://github.com/fastify/fastify-plugin) the metadata `name` is used.
+2. If you `module.exports` a plugin the filename is used.
+3. If you use a regular [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#Defining_functions) the function name is used.
+
+*Fallback*: The first two lines of your plugin will represent the plugin name. Newlines are replaced by ` -- `. This will help to indentify the root cause when you deal with many plugins.
+
+Important: If you have to deal with nested plugins the name differs with the usage of the [fastify-plugin](https://github.com/fastify/fastify-plugin) because no new scope is created and therefore we have no place to attach contextual data. In that case the plugin name will represent the boot order of all involved plugins in the format of `plugin-A -> plugin-B`.
+
 <a name="log"></a>
 #### log
 The logger instance, check [here](https://github.com/fastify/fastify/blob/master/docs/Logging.md).
@@ -585,10 +655,27 @@ Fake http injection (for testing purposes) [here](https://github.com/fastify/fas
 `fastify.addSchema(schemaObj)`, adds a shared schema to the Fastify instance. This allows you to reuse it everywhere in your application just by writing the schema id that you need.<br/>
 To learn more, see [shared schema example](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md#shared-schema) in the [Validation and Serialization](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md) documentation.
 
+<a name="set-reply-serializer"></a>
+#### setReplySerializer
+Set the reply serializer for all the routes. This will used as default if a [Reply.serializer(func)](https://github.com/fastify/fastify/blob/master/docs/Reply.md#serializerfunc) has not been set. The handler is fully encapsulated, so different plugins can set different error handlers.
+Note: the function parameter is called only for status `2xx`. Checkout the [`setErrorHandler`](https://github.com/fastify/fastify/blob/master/docs/Server.md#seterrorhandler) for errors.
+
+```js
+fastify.setReplySerializer(function (payload, statusCode){
+  // serialize the payload with a sync function
+  return `my serialized ${statusCode} content: ${payload}`
+})
+```
+
 <a name="set-schema-compiler"></a>
 #### setSchemaCompiler
 Set the schema compiler for all routes [here](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md#schema-compiler).
 
+<a name="set-schema-resolver"></a>
+#### setSchemaResolver
+Set the schema `$ref` resolver for all routes [here](https://github.com/fastify/fastify/blob/master/docs/Validation-and-Serialization.md#schema-resolver).
+
+
 <a name="schema-compiler"></a>
 #### schemaCompiler
 This property can be used to set the schema compiler, it is a shortcut for the `setSchemaCompiler` method, and get the schema compiler back for all routes.
@@ -602,24 +689,24 @@ You can also register a [`preValidation`](https://www.fastify.io/docs/latest/Hoo
 
 ```js
 fastify.setNotFoundHandler({
-  preValidation: (req, reply, next) => {
+  preValidation: (req, reply, done) => {
     // your code
-    next()
+    done()
   },
-  preHandler: (req, reply, next) => {
+  preHandler: (req, reply, done) => {
     // your code
-    next()
+    done()
   }
 }, function (request, reply) {
     // Default not found handler with preValidation and preHandler hooks
 })
 
-fastify.register(function (instance, options, next) {
+fastify.register(function (instance, options, done) {
   instance.setNotFoundHandler(function (request, reply) {
     // Handle not found request without preValidation and preHandler hooks
     // to URLs that begin with '/v1'
   })
-  next()
+  done()
 }, { prefix: '/v1' })
 ```
 
diff --git a/docs/Serverless.md b/docs/Serverless.md
index 67f94e51..8f96ea63 100644
--- a/docs/Serverless.md
+++ b/docs/Serverless.md
@@ -2,6 +2,12 @@
 
 Run serverless applications and REST APIs using your existing Fastify application.
 
+### Contents
+
+- [AWS Lambda](#aws-lambda)
+- [Google Cloud Run](#google-cloud-run)
+- [Zeit Now](#zeit-now)
+
 ### Attention Readers:
 > Fastify is not designed to run on serverless environments.
 The Fastify framework is designed to make implementing a traditional HTTP/S server easy.
@@ -12,26 +18,25 @@ it is possible to use Fastify in a serverless environment.
 Again, keep in mind that this is not Fastify's intended use case and
 we do not test for such integration scenarios.
 
-
 ## AWS Lambda
 
 The sample provided allows you to easily build serverless web applications/services
 and RESTful APIs using Fastify on top of AWS Lambda and Amazon API Gateway.
 
-*Note: This is just one possible way.*
+*Note: Using [aws-lambda-fastify](https://github.com/fastify/aws-lambda-fastify) is just one possible way.*
 
 ### app.js
 
 ```js
 const fastify = require('fastify');
 
-function init(serverFactory) {
-  const app = fastify({ serverFactory });
+function init() {
+  const app = fastify();
   app.get('/', (request, reply) => reply.send({ hello: 'world' }));
   return app;
 }
 
-if (require.main !== module) {
+if (require.main === module) {
   // called directly i.e. "node app"
   init().listen(3000, (err) => {
     if (err) console.error(err);
@@ -43,11 +48,9 @@ if (require.main !== module) {
 }
 ```
 
-You can simply wrap your initialization code by offering to inject an optional [serverFactory](https://www.fastify.io/docs/latest/Server/#serverfactory).
-
 When executed in your lambda function we don't need to listen to a specific port,
 so we just export the wrapper function `init` in this case.
-The [`lambda.js`](https://www.fastify.io/docs/latest/Server/#lambda.js) file will use this export.
+The [`lambda.js`](https://www.fastify.io/docs/latest/Serverless/#lambda-js) file will use this export.
 
 When you execute your Fastify application like always,
 i.e. `node app.js` *(the detection for this could be `require.main === module`)*,
@@ -56,31 +59,28 @@ you can normally listen to your port, so you can still run your Fastify function
 ### lambda.js
 
 ```js
-const awsServerlessExpress = require('aws-serverless-express');
+const awsLambdaFastify = require('aws-lambda-fastify')
 const init = require('./app');
 
-let server;
-const serverFactory = (handler) => {
-  server = awsServerlessExpress.createServer(handler);
-  return server;
-}
-const app = init(serverFactory);
+const proxy = awsLambdaFastify(init())
+// or
+// const proxy = awsLambdaFastify(init(), { binaryMimeTypes: ['application/octet-stream'] })
 
-exports.handler = (event, context, callback) => {
-  context.callbackWaitsForEmptyEventLoop = false;
-  app.ready((e) => {
-    if (e) return console.error(e.stack || e);
-    awsServerlessExpress.proxy(server, event, context, 'CALLBACK', callback);
-  });
-};
+exports.handler = proxy;
+// or
+// exports.handler = (event, context, callback) => proxy(event, context, callback);
+// or
+// exports.handler = (event, context) => proxy(event, context);
+// or
+// exports.handler = async (event, context) => proxy(event, context);
 ```
 
-We define a custom `serverFactory` function, in which we create a new server with the help of [`aws-serverless-express`](https://github.com/awslabs/aws-serverless-express)
-(make sure you install the dependency `npm i --save aws-serverless-express`).
-Then we call the `init` function (imported from [`app.js`](https://www.fastify.io/docs/latest/Server/#app.js)) with the `serverFactory` function as the only parameter.
-Finally inside the lambda `handler` function we wait for the Fastify app to be `ready`
-and proxy all the incoming events (API Gateway requests) to the `proxy` function from [`aws-serverless-express`](https://github.com/awslabs/aws-serverless-express).
-
+We just require [aws-lambda-fastify](https://github.com/fastify/aws-lambda-fastify)
+(make sure you install the dependency `npm i --save aws-lambda-fastify`) and our
+[`app.js`](https://www.fastify.io/docs/latest/Serverless/#app-js) file and call the
+exported `awsLambdaFastify` function with the `app` as the only parameter.
+The resulting `proxy` function has the correct signature to be used as lambda `handler` function. 
+This way all the incoming events (API Gateway requests) are passed to the `proxy` function of [aws-lambda-fastify](https://github.com/fastify/aws-lambda-fastify).
 
 ### Example
 
@@ -91,3 +91,174 @@ An example deployable with [claudia.js](https://claudiajs.com/tutorials/serverle
 
 - API Gateway doesn't support streams yet, so you're not able to handle [streams](https://www.fastify.io/docs/latest/Reply/#streams). 
 - API Gateway has a timeout of 29 seconds, so it's important to provide a reply during this time.
+
+## Google Cloud Run
+
+Unlike AWS Lambda or Google Cloud Functions, Google Cloud Run is a serverless **container** environment. It's primary purpose is to provide an infrastructure-abstracted environment to run arbitrary containers. As a result, Fastify can be deployed to Google Cloud Run with little-to-no code changes from the way you would write your Fastify app normally.
+
+*Follow the steps below to deploy to Google Cloud Run if you are already familiar with gcloud or just follow their [quickstart](https://cloud.google.com/run/docs/quickstarts/build-and-deploy)*.
+
+### Adjust Fastfiy server
+
+In order for Fastify to properly listen for requests within the container, be sure to set the correct port and address:
+
+```js
+function build() {
+  const fastify = Fastify({ trustProxy: true })
+  return fastify
+}
+
+async function start() {
+  // Google Cloud Run will set this environment variable for you, so
+  // you can also use it to detect if you are running in Cloud Run
+  const IS_GOOGLE_CLOUD_RUN = process.env.K_SERVICE !== undefined
+
+  // You must listen on the port Cloud Run provides
+  const port = process.env.PORT || 3000
+
+  // You must listen on all IPV4 addresses in Cloud Run
+  const address = IS_GOOGLE_CLOUD_RUN ? "0.0.0.0" : undefined
+
+  try {
+    const server = build()
+    const address = await server.listen(port, address)
+    console.log(`Listening on ${address}`)
+  } catch (err) {
+    console.error(err)
+    process.exit(1)
+  }
+}
+
+module.exports = build
+
+if (require.main === module) {
+  start()
+}
+```
+
+### Add a Dockerfile
+
+You can add any valid `Dockerfile` that packages and runs a Node app. A basic `Dockerfile` can be found in the official [gcloud docs](https://github.com/knative/docs/blob/2d654d1fd6311750cc57187a86253c52f273d924/docs/serving/samples/hello-world/helloworld-nodejs/Dockerfile).
+
+```Dockerfile
+# Use the official Node.js 10 image.
+# https://hub.docker.com/_/node
+FROM node:10
+
+# Create and change to the app directory.
+WORKDIR /usr/src/app
+
+# Copy application dependency manifests to the container image.
+# A wildcard is used to ensure both package.json AND package-lock.json are copied.
+# Copying this separately prevents re-running npm install on every code change.
+COPY package*.json ./
+
+# Install production dependencies.
+RUN npm install --only=production
+
+# Copy local code to the container image.
+COPY . .
+
+# Run the web service on container startup.
+CMD [ "npm", "start" ]
+```
+
+### Add a .dockerignore
+
+To keep build artifacts out of your container (which keeps it small and improves build times), add a `.dockerignore` file like the one below:
+
+```.dockerignore
+Dockerfile
+README.md
+node_modules
+npm-debug.log
+```
+
+### Submit build
+
+Next, submit your app to be built into a Docker image by running the following command (replacing `PROJECT-ID` and `APP-NAME` with your GCP project id and an app name):
+
+```bash
+gcloud builds submit --tag gcr.io/PROJECT-ID/APP-NAME
+```
+
+### Deploy Image
+
+After your image has built, you can deploy it with the following command:
+
+```bash
+gcloud beta run deploy --image gcr.io/PROJECT-ID/APP-NAME --platform managed
+```
+
+Your app will be accessible from the URL GCP provides.
+
+## Zeit Now
+
+[now](https://zeit.co/home) provides zero configuration deployment for
+Node.js applications. In order to use now, it is as simple as
+configuring your `now.json` file like the following:
+
+```json
+{
+  "version": 2,
+  "builds": [
+    {
+      "src": "api/serverless.js",
+      "use": "@now/node",
+      "config": {
+        "helpers": false
+      }
+    }
+  ],
+  "routes": [
+    { "src": "/.*", "dest": "/api/serverless.js"}
+  ]
+}
+```
+
+Then, write a `api/serverless.js` like so:
+
+```js
+'use strict'
+
+const build = require('./index')
+
+const app = build()
+
+module.exports = async function (req, res) {
+  await app.ready()
+  app.server.emit('request', req, res)
+}
+```
+
+And a `api/index.js` file:
+
+```js
+'use strict'
+
+const fastify = require('fastify')
+
+function build () {
+  const app = fastify({
+    logger: true
+  })
+
+  app.get('/', async (req, res) => {
+    const { name = 'World' } = req.query
+    req.log.info({ name }, 'hello world!')
+    return `Hello ${name}!`
+  })
+
+  return app
+}
+
+module.exports = build
+```
+
+Note that you'll need to use Node 10 by setting it in `package.json`:
+
+```js
+  "engines": {
+    "node": "10.x"
+  },
+```
diff --git a/docs/TypeScript.md b/docs/TypeScript.md
index e88130cb..5fdd457e 100644
--- a/docs/TypeScript.md
+++ b/docs/TypeScript.md
@@ -2,12 +2,12 @@
 
 <a id="typescript"></a>
 ## TypeScript
-Fastify is shipped with a typings file, but it still require to install `@types/node`, depending on the Node.js version that you are using.
+Fastify is shipped with a typings file, but you may need to install `@types/node`, depending on the Node.js version you are using.
 
 ## Types support
-We do care about the TypeScript community, but the framework is written in plain JavaScript and currently no one of the core team is a TypeScript user while only one of the collaborators is.
-We do our best to have the typing updated with the latest version of the API, but *it can happen* that the typings are not in sync.<br/>
-Luckly this is Open Source and you can contribute to fix them, we will be very happy to accept the fix and release it as soon as possible as a patch release. Checkout the [contributing](#contributing) rules!
+We do care about the TypeScript community, and one of our core team members is currently reworking all types.
+We do our best to have the typings updated with the latest version of the API, but *it can happen* that the typings are not in sync.<br/>
+Luckily this is Open Source and you can contribute to fix them, we will be very happy to accept the fix and release it as soon as possible as a patch release. Checkout the [contributing](#contributing) rules!
 
 Plugins may or may not include typings. See [Plugin Types](#plugin-types) for more information.
 
@@ -106,7 +106,7 @@ const opts: fastify.RouteShorthandOptions = {
   }
 }
 
-server.get<Query, Params, Body, Headers>('/ping/:bar', opts, (request, reply) => {
+server.get<Query, Params, Headers, Body>('/ping/:bar', opts, (request, reply) => {
   console.log(request.query) // this is of type Query!
   console.log(request.params) // this is of type Params!
   console.log(request.body) // this is of type Body!
@@ -204,7 +204,7 @@ When updating core types you should make a PR to this repository. Ensure you:
 <a id="plugin-types"></a>
 ### Plugin Types
 
-Plugins maintained by and orginized under the fastify organization on GitHub should ship with typings just like fastify itself does.
+Plugins maintained by and organized under the fastify organization on GitHub should ship with typings just like fastify itself does.
 Some plugins already include typings but many do not. We are happy to accept contributions to those plugins without any typings, see [fastify-cors](https://github.com/fastify/fastify-cors) for an example of a plugin that comes with it's own typings.
 
 Typings for third-party-plugins may either be included with the plugin or hosted on DefinitelyTyped. Remember, if you author a plugin to either include typings or publish them on DefinitelyTyped! Information  of how to install typings from DefinitelyTyped can be found [here](https://github.com/DefinitelyTyped/DefinitelyTyped#npm).
diff --git a/docs/Validation-and-Serialization.md b/docs/Validation-and-Serialization.md
index 5753e12b..618d54ed 100644
--- a/docs/Validation-and-Serialization.md
+++ b/docs/Validation-and-Serialization.md
@@ -4,9 +4,10 @@
 Fastify uses a schema-based approach, and even if it is not mandatory we recommend using [JSON Schema](http://json-schema.org/) to validate your routes and serialize your outputs. Internally, Fastify compiles the schema into a highly performant function.
 
 > ## ⚠  Security Notice
+> Treat the schema definition as application code.
 > As both validation and serialization features dynamically evaluate
-> code with `new Function()`, it is not safe to use them with
-> user-provided data. See [Ajv](http://npm.im/ajv) and
+> code with `new Function()`, it is not safe to use
+> user-provided schemas. See [Ajv](http://npm.im/ajv) and
 > [fast-json-stringify](http://npm.im/fast-json-stringify) for more
 > details.
 
@@ -14,7 +15,7 @@ Fastify uses a schema-based approach, and even if it is not mandatory we recomme
 ### Validation
 The route validation internally relies upon [Ajv](https://www.npmjs.com/package/ajv), which is a high-performance JSON schema validator. Validating the input is very easy: just add the fields that you need inside the route schema, and you are done! The supported validations are:
 - `body`: validates the body of the request if it is a POST or a PUT.
-- `querystring`: validates the query string. This can be a complete JSON Schema object (with a `type` property of `'object'` and a `'properties'` object containing parameters) or a simpler variation in which the `type` and `properties` attributes are forgone and the query parameters are listed at the top level (see the example below).
+- `querystring` or `query`: validates the query string. This can be a complete JSON Schema object (with a `type` property of `'object'` and a `'properties'` object containing parameters) or a simpler variation in which the `type` and `properties` attributes are forgone and the query parameters are listed at the top level (see the example below).
 - `params`: validates the route params.
 - `headers`: validates the request headers.
 
@@ -31,7 +32,7 @@ const bodyJsonSchema = {
       maxItems: 3,
       items: { type: 'integer' }
     },
-    nullableKey: { type: ['number', 'null'] },
+    nullableKey: { type: ['number', 'null'] }, // or { type: 'number', nullable: true }
     multipleTypesKey: { type: ['boolean', 'number'] },
     multipleRestrictedTypesKey: {
       oneOf: [
@@ -155,7 +156,7 @@ fastify.route({
   handler: () => {}
 })
 
-fastify.register((instance, opts, next) => {
+fastify.register((instance, opts, done) => {
 
   /**
    * In children's scope can use schemas defined in upper scope like 'greetings'.
@@ -179,7 +180,7 @@ fastify.register((instance, opts, next) => {
     handler: () => {}
   })
 
-  next()
+  done()
 })
 ```
 
@@ -219,16 +220,16 @@ The function `getSchemas` returns the shared schemas available in the selected s
 fastify.addSchema({ $id: 'one', my: 'hello' })
 fastify.get('/', (request, reply) => { reply.send(fastify.getSchemas()) })
 
-fastify.register((instance, opts, next) => {
+fastify.register((instance, opts, done) => {
   instance.addSchema({ $id: 'two', my: 'ciao' })
   instance.get('/sub', (request, reply) => { reply.send(instance.getSchemas()) })
 
-  instance.register((subinstance, opts, next) => {
+  instance.register((subinstance, opts, done) => {
     subinstance.addSchema({ $id: 'three', my: 'hola' })
     subinstance.get('/deep', (request, reply) => { reply.send(subinstance.getSchemas()) })
-    next()
+    done()
   })
-  next()
+  done()
 })
 ```
 This example will returns:
@@ -239,6 +240,77 @@ This example will returns:
 | /sub  | one, two        |
 | /deep | one, two, three |
 
+<a name="ajv-plugins"></a>
+#### Ajv Plugins
+
+You can provide a list of plugins you want to use with Ajv:
+
+> Refer to [`ajv options`](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-ajv) to check plugins format
+
+```js
+const fastify = require('fastify')({
+  ajv: {
+    plugins: [
+      require('ajv-merge-patch')
+    ]
+  }
+})
+
+fastify.route({
+  method: 'POST',
+  url: '/',
+  schema: {
+    body: {
+      $patch: {
+        source: {
+          type: 'object',
+          properties: {
+            q: {
+              type: 'string'
+            }
+          }
+        },
+        with: [
+          {
+            op: 'add',
+            path: '/properties/q',
+            value: { type: 'number' }
+          }
+        ]
+      }
+    }
+  },
+  handler (req, reply) {
+    reply.send({ ok: 1 })
+  }
+})
+
+fastify.route({
+  method: 'POST',
+  url: '/',
+  schema: {
+    body: {
+      $merge: {
+        source: {
+          type: 'object',
+          properties: {
+            q: {
+              type: 'string'
+            }
+          }
+        },
+        with: {
+          required: ['q']
+        }
+      }
+    }
+  },
+  handler (req, reply) {
+    reply.send({ ok: 1 })
+  }
+})
+```
+
 <a name="schema-compiler"></a>
 #### Schema Compiler
 
@@ -251,11 +323,14 @@ Fastify's [baseline ajv configuration](https://github.com/epoberezkin/ajv#option
   removeAdditional: true, // remove additional properties
   useDefaults: true, // replace missing properties and items with the values from corresponding default keyword
   coerceTypes: true, // change data type of data to match type keyword
-  allErrors: true    // check for all errors
+  allErrors: true,   // check for all errors
+  nullable: true     // support keyword "nullable" from Open API 3 specification.
 }
 ```
 
-This baseline configuration cannot be modified. If you want to change or set additional config options, you will need to create your own instance and override the existing one like:
+This baseline configuration can be modified by providing [`ajv.customOptions`](https://github.com/fastify/fastify/blob/master/docs/Server.md#factory-ajv) to your Fastify factory.
+
+If you want to change or set additional config options, you will need to create your own instance and override the existing one like:
 
 ```js
 const fastify = require('fastify')()
@@ -265,7 +340,8 @@ const ajv = new Ajv({
   removeAdditional: true,
   useDefaults: true,
   coerceTypes: true,
-  allErrors: true
+  allErrors: true,
+  nullable: true,
   // any other options
   // ...
 })
@@ -277,6 +353,7 @@ fastify.setSchemaCompiler(function (schema) {
 // Alternatively, you can set the schema compiler using the setter property:
 fastify.schemaCompiler = function (schema) { return ajv.compile(schema) })
 ```
+_**Note:** If you use a custom instance of any validator (even Ajv), you have to add schemas to the validator instead of fastify, since fastify's default validator is no longer used, and fastify's `addSchema` method has no idea what validator you are using._
 
 But maybe you want to change the validation library. Perhaps you like `Joi`. In this case, you can use it to validate the url parameters, body, and query string!
 
@@ -297,6 +374,68 @@ In that case the function returned by `schemaCompiler` returns an object like:
 * `error`: filled with an instance of `Error` or a string that describes the validation error
 * `value`: the coerced value that passed the validation
 
+<a name="schema-resolver"></a>
+#### Schema Resolver
+
+The `schemaResolver` is a function that works together with the `schemaCompiler`: you can't use it
+with the default schema compiler. This feature is useful when you use complex schemas with `$ref` keyword
+in your routes and a custom validator.
+
+This is needed because all the schemas you add to your custom compiler are unknown to Fastify but it
+need to resolve the `$ref` paths.
+
+```js
+const fastify = require('fastify')()
+const Ajv = require('ajv')
+const ajv = new Ajv()
+
+ajv.addSchema({
+  $id: 'urn:schema:foo',
+  definitions: {
+    foo: { type: 'string' }
+  },
+  type: 'object',
+  properties: {
+    foo: { $ref: '#/definitions/foo' }
+  }
+})
+ajv.addSchema({
+  $id: 'urn:schema:response',
+  type: 'object',
+  required: ['foo'],
+  properties: {
+    foo: { $ref: 'urn:schema:foo#/definitions/foo' }
+  }
+})
+ajv.addSchema({
+  $id: 'urn:schema:request',
+  type: 'object',
+  required: ['foo'],
+  properties: {
+    foo: { $ref: 'urn:schema:foo#/definitions/foo' }
+  }
+})
+
+fastify.setSchemaCompiler(schema => ajv.compile(schema))
+fastify.setSchemaResolver((ref) => {
+  return ajv.getSchema(ref).schema
+})
+
+fastify.route({
+  method: 'POST',
+  url: '/',
+  schema: {
+    body: ajv.getSchema('urn:schema:request').schema,
+    response: {
+      '2xx': ajv.getSchema('urn:schema:response').schema
+    }
+  },
+  handler (req, reply) {
+    reply.send({ foo: 'bar' })
+  }
+})
+```
+
 <a name="serialization"></a>
 ### Serialization
 Usually you will send your data to the clients via JSON, and Fastify has a powerful tool to help you, [fast-json-stringify](https://www.npmjs.com/package/fast-json-stringify), which is used if you have provided an output schema in the route options. We encourage you to use an output schema, as it will increase your throughput by 100-400% depending on your payload and will prevent accidental disclosure of sensitive information.
diff --git a/examples/typescript-server.ts b/examples/typescript-server.ts
index aa9fad3f..b0324815 100644
--- a/examples/typescript-server.ts
+++ b/examples/typescript-server.ts
@@ -3,7 +3,7 @@
  * Most type annotations in this file are not strictly necessary but are
  * included for this example.
  *
- * To run this example exectute the following commands to install typescript,
+ * To run this example execute the following commands to install typescript,
  * transpile the code, and start the server:
  *
  * npm i -g typescript
diff --git a/fastify.js b/fastify.js
index 95f34980..2681b601 100644
--- a/fastify.js
+++ b/fastify.js
@@ -1,21 +1,21 @@
 'use strict'
 
-const FindMyWay = require('find-my-way')
 const Avvio = require('avvio')
 const http = require('http')
 const querystring = require('querystring')
-const Middie = require('middie')
 let lightMyRequest
-const proxyAddr = require('proxy-addr')
 
 const {
   kChildren,
   kBodyLimit,
   kRoutePrefix,
   kLogLevel,
+  kLogSerializers,
   kHooks,
   kSchemas,
   kSchemaCompiler,
+  kSchemaResolver,
+  kReplySerializerDefault,
   kContentTypeParser,
   kReply,
   kRequest,
@@ -24,25 +24,21 @@ const {
   kState,
   kOptions,
   kGlobalHooks,
-  kDisableRequestLogging
+  kPluginNameChain
 } = require('./lib/symbols.js')
 
 const { createServer } = require('./lib/server')
 const Reply = require('./lib/reply')
 const Request = require('./lib/request')
-const Context = require('./lib/context')
 const supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS']
-const buildSchema = require('./lib/validation').build
-const handleRequest = require('./lib/handleRequest')
-const validation = require('./lib/validation')
-const buildSchemaCompiler = validation.buildSchemaCompiler
 const decorator = require('./lib/decorate')
 const ContentTypeParser = require('./lib/contentTypeParser')
-const { Hooks, hookRunner, hookIterator, buildHooks } = require('./lib/hooks')
+const { Hooks, buildHooks } = require('./lib/hooks')
 const { Schemas, buildSchemas } = require('./lib/schemas')
 const { createLogger } = require('./lib/logger')
 const pluginUtils = require('./lib/pluginUtils')
 const reqIdGenFactory = require('./lib/reqIdGenFactory')
+const { buildRouting, validateBodyLimitOption } = require('./lib/route')
 const build404 = require('./lib/fourOhFour')
 const getSecuredInitialConfig = require('./lib/initialConfigValidation')
 const { defaultInitOptions } = getSecuredInitialConfig
@@ -61,7 +57,6 @@ function fastify (options) {
 
   validateBodyLimitOption(options.bodyLimit)
 
-  const trustProxy = options.trustProxy
   const modifyCoreObjects = options.modifyCoreObjects !== false
   const requestIdHeader = options.requestIdHeader || defaultInitOptions.requestIdHeader
   const querystringParser = options.querystringParser || querystring.parse
@@ -69,6 +64,21 @@ function fastify (options) {
   const requestIdLogLabel = options.requestIdLogLabel || 'reqId'
   const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit
   const disableRequestLogging = options.disableRequestLogging || false
+  const ajvOptions = Object.assign({
+    customOptions: {},
+    plugins: []
+  }, options.ajv)
+
+  // Ajv options
+  if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== '[object Object]') {
+    throw new Error(`ajv.customOptions option should be an object, instead got '${typeof ajvOptions.customOptions}'`)
+  }
+  if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
+    throw new Error(`ajv.plugins option should be an array, instead got '${typeof ajvOptions.customOptions}'`)
+  }
+  ajvOptions.plugins = ajvOptions.plugins.map(plugin => {
+    return Array.isArray(plugin) ? plugin : [plugin]
+  })
 
   // Instance Fastify components
   const { logger, hasLogger } = createLogger(options)
@@ -77,27 +87,35 @@ function fastify (options) {
   options.logger = logger
   options.modifyCoreObjects = modifyCoreObjects
   options.genReqId = genReqId
+  options.requestIdHeader = requestIdHeader
+  options.querystringParser = querystringParser
+  options.requestIdLogLabel = requestIdLogLabel
+  options.modifyCoreObjects = modifyCoreObjects
+  options.disableRequestLogging = disableRequestLogging
+  options.ajv = ajvOptions
 
   // Default router
-  const router = FindMyWay({
-    defaultRoute: defaultRoute,
-    ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
-    maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
-    caseSensitive: options.caseSensitive,
-    versioning: options.versioning
+  const router = buildRouting({
+    config: {
+      defaultRoute: defaultRoute,
+      onBadUrl: onBadUrl,
+      ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
+      maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
+      caseSensitive: options.caseSensitive,
+      versioning: options.versioning
+    }
   })
   // 404 router, used for handling encapsulated 404 handlers
   const fourOhFour = build404(options)
 
   // HTTP server and its handler
-  const httpHandler = router.lookup.bind(router)
+  const httpHandler = router.routing
   const { server, listen } = createServer(options, httpHandler)
   if (Number(process.version.match(/v(\d+)/)[1]) >= 6) {
     server.on('clientError', handleClientError)
   }
 
   const setupResponseListeners = Reply.setupResponseListeners
-  const proxyFn = getTrustProxyFn(options)
   const schemas = new Schemas()
 
   // Public API
@@ -113,10 +131,17 @@ function fastify (options) {
     [kBodyLimit]: bodyLimit,
     [kRoutePrefix]: '',
     [kLogLevel]: '',
+    [kLogSerializers]: null,
     [kHooks]: new Hooks(),
     [kSchemas]: schemas,
     [kSchemaCompiler]: null,
-    [kContentTypeParser]: new ContentTypeParser(bodyLimit, (options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning)),
+    [kSchemaResolver]: null,
+    [kReplySerializerDefault]: null,
+    [kContentTypeParser]: new ContentTypeParser(
+      bodyLimit,
+      (options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning),
+      (options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning)
+    ),
     [kReply]: Reply.buildReply(Reply),
     [kRequest]: Request.buildRequest(Request),
     [kMiddlewares]: [],
@@ -126,33 +151,38 @@ function fastify (options) {
       onRegister: []
     },
     [pluginUtils.registeredPlugins]: [],
+    [kPluginNameChain]: [],
     // routes shorthand methods
     delete: function _delete (url, opts, handler) {
-      return prepareRoute.call(this, 'DELETE', url, opts, handler)
+      return router.prepareRoute.call(this, 'DELETE', url, opts, handler)
     },
     get: function _get (url, opts, handler) {
-      return prepareRoute.call(this, 'GET', url, opts, handler)
+      return router.prepareRoute.call(this, 'GET', url, opts, handler)
     },
     head: function _head (url, opts, handler) {
-      return prepareRoute.call(this, 'HEAD', url, opts, handler)
+      return router.prepareRoute.call(this, 'HEAD', url, opts, handler)
     },
     patch: function _patch (url, opts, handler) {
-      return prepareRoute.call(this, 'PATCH', url, opts, handler)
+      return router.prepareRoute.call(this, 'PATCH', url, opts, handler)
     },
     post: function _post (url, opts, handler) {
-      return prepareRoute.call(this, 'POST', url, opts, handler)
+      return router.prepareRoute.call(this, 'POST', url, opts, handler)
     },
     put: function _put (url, opts, handler) {
-      return prepareRoute.call(this, 'PUT', url, opts, handler)
+      return router.prepareRoute.call(this, 'PUT', url, opts, handler)
     },
     options: function _options (url, opts, handler) {
-      return prepareRoute.call(this, 'OPTIONS', url, opts, handler)
+      return router.prepareRoute.call(this, 'OPTIONS', url, opts, handler)
     },
     all: function _all (url, opts, handler) {
-      return prepareRoute.call(this, supportedMethods, url, opts, handler)
+      return router.prepareRoute.call(this, supportedMethods, url, opts, handler)
     },
     // extended route
-    route: route,
+    route: function _route (opts) {
+      // we need the fastify object that we are producing so we apply a lazy loading of the function,
+      // otherwise we should bind it after the declaration
+      return router.route.call(this, opts)
+    },
     // expose logger instance
     log: logger,
     // hooks
@@ -161,6 +191,8 @@ function fastify (options) {
     addSchema: addSchema,
     getSchemas: schemas.getSchemas.bind(schemas),
     setSchemaCompiler: setSchemaCompiler,
+    setSchemaResolver: setSchemaResolver,
+    setReplySerializer: setReplySerializer,
     // custom parsers
     addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
     hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
@@ -185,7 +217,7 @@ function fastify (options) {
     // fake http injection
     inject: inject,
     // pretty print of the registered routes
-    printRoutes: router.prettyPrint.bind(router),
+    printRoutes: router.printRoutes,
     // custom error handling
     setNotFoundHandler: setNotFoundHandler,
     setErrorHandler: setErrorHandler,
@@ -208,6 +240,15 @@ function fastify (options) {
     }
   })
 
+  Object.defineProperty(fastify, 'pluginName', {
+    get: function () {
+      if (this[kPluginNameChain].length > 1) {
+        return this[kPluginNameChain].join(' -> ')
+      }
+      return this[kPluginNameChain][0]
+    }
+  })
+
   // Install and configure Avvio
   // Avvio will update the following Fastify methods:
   // - register
@@ -224,12 +265,12 @@ function fastify (options) {
   avvio.override = override
   avvio.on('start', () => (fastify[kState].started = true))
   // cache the closing value, since we are checking it in an hot path
-  var closing = false
   avvio.once('preReady', () => {
     fastify.onClose((instance, done) => {
       fastify[kState].closing = true
-      closing = true
+      router.closeRoutes()
       if (fastify[kState].listening) {
+        // No new TCP connections are accepted
         instance.server.close(done)
       } else {
         done(null)
@@ -241,290 +282,21 @@ function fastify (options) {
   fastify.setNotFoundHandler()
   fourOhFour.arrange404(fastify)
 
-  const schemaCache = new Map()
-  schemaCache.put = schemaCache.set
+  router.setup(options, {
+    avvio,
+    fourOhFour,
+    logger,
+    hasLogger,
+    setupResponseListeners,
+    throwIfAlreadyStarted
+  })
 
   return fastify
 
-  // HTTP request entry point, the routing has already been executed
-  function routeHandler (req, res, params, context) {
-    if (closing === true) {
-      const headers = {
-        'Content-Type': 'application/json',
-        'Content-Length': '80'
-      }
-      if (req.httpVersionMajor !== 2) {
-        headers.Connection = 'close'
-      }
-      res.writeHead(503, headers)
-      res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}')
-      if (req.httpVersionMajor !== 2) {
-        // This is not needed in HTTP/2
-        setImmediate(() => req.destroy())
-      }
-      return
-    }
-
-    req.id = req.headers[requestIdHeader] || genReqId(req)
-    req.originalUrl = req.url
-    var hostname = req.headers['host']
-    var ip = req.connection.remoteAddress
-    var ips
-
-    if (trustProxy) {
-      ip = proxyAddr(req, proxyFn)
-      ips = proxyAddr.all(req, proxyFn)
-      if (ip !== undefined && req.headers['x-forwarded-host']) {
-        hostname = req.headers['x-forwarded-host']
-      }
-    }
-
-    var childLogger = logger.child({ [requestIdLogLabel]: req.id, level: context.logLevel })
-    childLogger[kDisableRequestLogging] = disableRequestLogging
-
-    // added hostname, ip, and ips back to the Node req object to maintain backward compatibility
-    if (modifyCoreObjects) {
-      req.hostname = hostname
-      req.ip = ip
-      req.ips = ips
-
-      req.log = res.log = childLogger
-    }
-
-    if (disableRequestLogging === false) {
-      childLogger.info({ req }, 'incoming request')
-    }
-
-    var queryPrefix = req.url.indexOf('?')
-    var query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : '')
-    var request = new context.Request(params, req, query, req.headers, childLogger, ip, ips, hostname)
-    var reply = new context.Reply(res, context, request, childLogger)
-
-    if (hasLogger === true || context.onResponse !== null) {
-      setupResponseListeners(reply)
-    }
-
-    if (context.onRequest !== null) {
-      hookRunner(
-        context.onRequest,
-        hookIterator,
-        request,
-        reply,
-        middlewareCallback
-      )
-    } else {
-      middlewareCallback(null, request, reply)
-    }
-  }
-
-  function middlewareCallback (err, request, reply) {
-    if (reply.sent === true) return
-    if (err != null) {
-      reply.send(err)
-      return
-    }
-
-    if (reply.context._middie !== null) {
-      reply.context._middie.run(request.raw, reply.res, reply)
-    } else {
-      onRunMiddlewares(null, null, null, reply)
-    }
-  }
-
-  function onRunMiddlewares (err, req, res, reply) {
-    if (err != null) {
-      reply.send(err)
-      return
-    }
-
-    if (reply.context.preParsing !== null) {
-      hookRunner(
-        reply.context.preParsing,
-        hookIterator,
-        reply.request,
-        reply,
-        handleRequest
-      )
-    } else {
-      handleRequest(null, reply.request, reply)
-    }
-  }
-
   function throwIfAlreadyStarted (msg) {
     if (fastify[kState].started) throw new Error(msg)
   }
 
-  // Convert shorthand to extended route declaration
-  function prepareRoute (method, url, options, handler) {
-    if (!handler && typeof options === 'function') {
-      handler = options
-      options = {}
-    } else if (handler && typeof handler === 'function') {
-      if (Object.prototype.toString.call(options) !== '[object Object]') {
-        throw new Error(`Options for ${method}:${url} route must be an object`)
-      } else if (options.handler) {
-        if (typeof options.handler === 'function') {
-          throw new Error(`Duplicate handler for ${method}:${url} route is not allowed!`)
-        } else {
-          throw new Error(`Handler for ${method}:${url} route must be a function`)
-        }
-      }
-    }
-
-    options = Object.assign({}, options, {
-      method,
-      url,
-      handler: handler || (options && options.handler)
-    })
-
-    return route.call(this, options)
-  }
-
-  // Route management
-  function route (opts) {
-    throwIfAlreadyStarted('Cannot add route when fastify instance is already started!')
-
-    if (Array.isArray(opts.method)) {
-      for (var i = 0; i < opts.method.length; i++) {
-        if (supportedMethods.indexOf(opts.method[i]) === -1) {
-          throw new Error(`${opts.method[i]} method is not supported!`)
-        }
-      }
-    } else {
-      if (supportedMethods.indexOf(opts.method) === -1) {
-        throw new Error(`${opts.method} method is not supported!`)
-      }
-    }
-
-    if (!opts.handler) {
-      throw new Error(`Missing handler function for ${opts.method}:${opts.url} route.`)
-    }
-
-    validateBodyLimitOption(opts.bodyLimit)
-
-    const prefix = this[kRoutePrefix]
-
-    this.after((notHandledErr, done) => {
-      var path = opts.url || opts.path
-      if (path === '/' && prefix.length > 0) {
-        switch (opts.prefixTrailingSlash) {
-          case 'slash':
-            afterRouteAdded.call(this, path, notHandledErr, done)
-            break
-          case 'no-slash':
-            afterRouteAdded.call(this, '', notHandledErr, done)
-            break
-          case 'both':
-          default:
-            afterRouteAdded.call(this, '', notHandledErr, done)
-            afterRouteAdded.call(this, path, notHandledErr, done)
-        }
-      } else if (path[0] === '/' && prefix.endsWith('/')) {
-        // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
-        afterRouteAdded.call(this, path.slice(1), notHandledErr, done)
-      } else {
-        afterRouteAdded.call(this, path, notHandledErr, done)
-      }
-    })
-
-    // chainable api
-    return this
-
-    function afterRouteAdded (path, notHandledErr, done) {
-      const url = prefix + path
-
-      opts.url = url
-      opts.path = url
-      opts.prefix = prefix
-      opts.logLevel = opts.logLevel || this[kLogLevel]
-
-      if (opts.attachValidation == null) {
-        opts.attachValidation = false
-      }
-
-      // run 'onRoute' hooks
-      for (const hook of this[kGlobalHooks].onRoute) hook.call(this, opts)
-
-      const config = opts.config || {}
-      config.url = url
-
-      const context = new Context(
-        opts.schema,
-        opts.handler.bind(this),
-        this[kReply],
-        this[kRequest],
-        this[kContentTypeParser],
-        config,
-        this._errorHandler,
-        opts.bodyLimit,
-        opts.logLevel,
-        opts.attachValidation
-      )
-
-      // TODO this needs to be refactored so that buildSchemaCompiler is
-      // not called for every single route. Creating a new one for every route
-      // is going to be very expensive.
-      if (opts.schema) {
-        try {
-          if (opts.schemaCompiler == null && this[kSchemaCompiler] == null) {
-            const externalSchemas = this[kSchemas].getJsonSchemas({ onlyAbsoluteUri: true })
-            this.setSchemaCompiler(buildSchemaCompiler(externalSchemas, schemaCache))
-          }
-
-          buildSchema(context, opts.schemaCompiler || this[kSchemaCompiler], this[kSchemas])
-        } catch (error) {
-          done(error)
-          return
-        }
-      }
-
-      const hooks = ['preParsing', 'preValidation', 'onRequest', 'preHandler', 'preSerialization']
-
-      for (let hook of hooks) {
-        if (opts[hook]) {
-          if (Array.isArray(opts[hook])) {
-            opts[hook] = opts[hook].map(fn => fn.bind(this))
-          } else {
-            opts[hook] = opts[hook].bind(this)
-          }
-        }
-      }
-
-      try {
-        router.on(opts.method, url, { version: opts.version }, routeHandler, context)
-      } catch (err) {
-        done(err)
-        return
-      }
-
-      // It can happen that a user register a plugin with some hooks/middlewares *after*
-      // the route registration. To be sure to load also that hooks/middlewares,
-      // we must listen for the avvio's preReady event, and update the context object accordingly.
-      avvio.once('preReady', () => {
-        const onResponse = this[kHooks].onResponse
-        const onSend = this[kHooks].onSend
-        const onError = this[kHooks].onError
-
-        context.onSend = onSend.length ? onSend : null
-        context.onError = onError.length ? onError : null
-        context.onResponse = onResponse.length ? onResponse : null
-
-        for (let hook of hooks) {
-          const toSet = this[kHooks][hook].concat(opts[hook] || [])
-          context[hook] = toSet.length ? toSet : null
-        }
-
-        context._middie = buildMiddie(this[kMiddlewares])
-
-        // Must store the 404 Context in 'preReady' because it is only guaranteed to
-        // be available after all of the plugins and routes have been loaded.
-        fourOhFour.setContext(this, context)
-      })
-
-      done(notHandledErr)
-    }
-  }
-
   // HTTP injection handling
   // If the server is not ready yet, this
   // utility will automatically force it.
@@ -536,6 +308,16 @@ function fastify (options) {
     }
 
     if (fastify[kState].started) {
+      if (fastify[kState].closing) {
+        // Force to return an error
+        const error = new Error('Server is closed')
+        if (cb) {
+          cb(error)
+          return
+        } else {
+          return Promise.reject(error)
+        }
+      }
       return lightMyRequest(httpHandler, opts, cb)
     }
 
@@ -572,13 +354,13 @@ function fastify (options) {
   function addHook (name, fn) {
     throwIfAlreadyStarted('Cannot call "addHook" when fastify instance is already started!')
 
-    if (name === 'onSend' || name === 'preSerialization') {
+    if (name === 'onSend' || name === 'preSerialization' || name === 'onError') {
       if (fn.constructor.name === 'AsyncFunction' && fn.length === 4) {
-        throw new Error(`Async function has too many arguments. Async hooks should not use the 'done' argument.`)
+        throw new Error('Async function has too many arguments. Async hooks should not use the \'done\' argument.')
       }
     } else {
       if (fn.constructor.name === 'AsyncFunction' && fn.length === 3) {
-        throw new Error(`Async function has too many arguments. Async hooks should not use the 'done' argument.`)
+        throw new Error('Async function has too many arguments. Async hooks should not use the \'done\' argument.')
       }
     }
 
@@ -632,10 +414,19 @@ function fastify (options) {
     fourOhFour.router.lookup(req, res)
   }
 
+  function onBadUrl (path, req, res) {
+    const body = `{"error":"Bad Request","message":"'${path}' is not a valid url component","statusCode":400}`
+    res.writeHead(400, {
+      'Content-Type': 'application/json',
+      'Content-Length': body.length
+    })
+    res.end(body)
+  }
+
   function setNotFoundHandler (opts, handler) {
     throwIfAlreadyStarted('Cannot call "setNotFoundHandler" when fastify instance is already started!')
 
-    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, routeHandler, buildMiddie)
+    fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler)
   }
 
   // wrapper that we expose to the user for schemas compiler handling
@@ -646,53 +437,26 @@ function fastify (options) {
     return this
   }
 
-  // wrapper that we expose to the user for configure the custom error handler
-  function setErrorHandler (func) {
-    throwIfAlreadyStarted('Cannot call "setErrorHandler" when fastify instance is already started!')
+  function setSchemaResolver (schemaRefResolver) {
+    throwIfAlreadyStarted('Cannot call "setSchemaResolver" when fastify instance is already started!')
 
-    this._errorHandler = func
+    this[kSchemaResolver] = schemaRefResolver
     return this
   }
 
-  function buildMiddie (middlewares) {
-    if (!middlewares.length) {
-      return null
-    }
-
-    const middie = Middie(onRunMiddlewares)
-    for (var i = 0; i < middlewares.length; i++) {
-      middie.use.apply(middie, middlewares[i])
-    }
+  function setReplySerializer (replySerializer) {
+    throwIfAlreadyStarted('Cannot call "setReplySerializer" when fastify instance is already started!')
 
-    return middie
+    this[kReplySerializerDefault] = replySerializer
+    return this
   }
-}
 
-function getTrustProxyFn (options) {
-  const tp = options.trustProxy
-  if (typeof tp === 'function') {
-    return tp
-  }
-  if (tp === true) {
-    // Support plain true/false
-    return function () { return true }
-  }
-  if (typeof tp === 'number') {
-    // Support trusting hop count
-    return function (a, i) { return i < tp }
-  }
-  if (typeof tp === 'string') {
-    // Support comma-separated tps
-    const vals = tp.split(',').map(it => it.trim())
-    return proxyAddr.compile(vals)
-  }
-  return proxyAddr.compile(tp || [])
-}
+  // wrapper that we expose to the user for configure the custom error handler
+  function setErrorHandler (func) {
+    throwIfAlreadyStarted('Cannot call "setErrorHandler" when fastify instance is already started!')
 
-function validateBodyLimitOption (bodyLimit) {
-  if (bodyLimit === undefined) return
-  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
-    throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${bodyLimit}'`)
+    this._errorHandler = func
+    return this
   }
 }
 
@@ -700,7 +464,10 @@ function validateBodyLimitOption (bodyLimit) {
 // Everything that need to be encapsulated must be handled in this function.
 function override (old, fn, opts) {
   const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn)
+
   if (shouldSkipOverride) {
+    // after every plugin registration we will enter a new name
+    old[kPluginNameChain].push(pluginUtils.getDisplayName(fn))
     return old
   }
 
@@ -717,6 +484,11 @@ function override (old, fn, opts) {
   instance[kSchemas] = buildSchemas(old[kSchemas])
   instance.getSchemas = instance[kSchemas].getSchemas.bind(instance[kSchemas])
   instance[pluginUtils.registeredPlugins] = Object.create(instance[pluginUtils.registeredPlugins])
+  instance[kPluginNameChain] = [pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn)]
+
+  if (instance[kLogSerializers] || opts.logSerializers) {
+    instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers)
+  }
 
   if (opts.prefix) {
     instance[kFourOhFour].arrange404(instance)
diff --git a/lib/configValidator.js b/lib/configValidator.js
index 7315c614..89f3cf2b 100644
--- a/lib/configValidator.js
+++ b/lib/configValidator.js
@@ -14,10 +14,11 @@ var validate = (function() {
     if ((data && typeof data === "object" && !Array.isArray(data))) {
       if (data.bodyLimit === undefined) data.bodyLimit = 1048576;
       if (data.caseSensitive === undefined) data.caseSensitive = true;
-      if (data.disableRequestLogging === undefined) data.disableRequestLogging = false;
       if (data.ignoreTrailingSlash === undefined) data.ignoreTrailingSlash = false;
+      if (data.disableRequestLogging === undefined) data.disableRequestLogging = false;
       if (data.maxParamLength === undefined) data.maxParamLength = 100;
       if (data.onProtoPoisoning === undefined) data.onProtoPoisoning = "error";
+      if (data.onConstructorPoisoning === undefined) data.onConstructorPoisoning = "ignore";
       if (data.pluginTimeout === undefined) data.pluginTimeout = 10000;
       if (data.requestIdHeader === undefined) data.requestIdHeader = "request-id";
       if (data.requestIdLogLabel === undefined) data.requestIdLogLabel = "reqId";
@@ -321,80 +322,81 @@ var validate = (function() {
                 }
                 var valid1 = errors === errs_1;
                 if (valid1) {
-                  var data1 = data.maxParamLength;
+                  var data1 = data.disableRequestLogging;
                   var errs_1 = errors;
-                  if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
+                  if (typeof data1 !== "boolean") {
                     var dataType1 = typeof data1;
                     var coerced1 = undefined;
-                    if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;
+                    if (data1 === 'false' || data1 === 0 || data1 === null) coerced1 = false;
+                    else if (data1 === 'true' || data1 === 1) coerced1 = true;
                     if (coerced1 === undefined) {
                       validate.errors = [{
                         keyword: 'type',
-                        dataPath: (dataPath || '') + '.maxParamLength',
-                        schemaPath: '#/properties/maxParamLength/type',
+                        dataPath: (dataPath || '') + '.disableRequestLogging',
+                        schemaPath: '#/properties/disableRequestLogging/type',
                         params: {
-                          type: 'integer'
+                          type: 'boolean'
                         },
-                        message: 'should be integer'
+                        message: 'should be boolean'
                       }];
                       return false;
                     } else {
                       data1 = coerced1;
-                      data['maxParamLength'] = coerced1;
+                      data['disableRequestLogging'] = coerced1;
                     }
                   }
                   var valid1 = errors === errs_1;
                   if (valid1) {
-                    var data1 = data.onProtoPoisoning;
+                    var data1 = data.maxParamLength;
                     var errs_1 = errors;
-                    if (typeof data1 !== "string") {
+                    if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
                       var dataType1 = typeof data1;
                       var coerced1 = undefined;
-                      if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
-                      else if (data1 === null) coerced1 = '';
+                      if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;
                       if (coerced1 === undefined) {
                         validate.errors = [{
                           keyword: 'type',
-                          dataPath: (dataPath || '') + '.onProtoPoisoning',
-                          schemaPath: '#/properties/onProtoPoisoning/type',
+                          dataPath: (dataPath || '') + '.maxParamLength',
+                          schemaPath: '#/properties/maxParamLength/type',
                           params: {
-                            type: 'string'
+                            type: 'integer'
                           },
-                          message: 'should be string'
+                          message: 'should be integer'
                         }];
                         return false;
                       } else {
                         data1 = coerced1;
-                        data['onProtoPoisoning'] = coerced1;
+                        data['maxParamLength'] = coerced1;
                       }
                     }
                     var valid1 = errors === errs_1;
                     if (valid1) {
-                      var data1 = data.pluginTimeout;
+                      var data1 = data.onProtoPoisoning;
                       var errs_1 = errors;
-                      if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
+                      if (typeof data1 !== "string") {
                         var dataType1 = typeof data1;
                         var coerced1 = undefined;
-                        if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;
+                        if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
+                        else if (data1 === null) coerced1 = '';
                         if (coerced1 === undefined) {
                           validate.errors = [{
                             keyword: 'type',
-                            dataPath: (dataPath || '') + '.pluginTimeout',
-                            schemaPath: '#/properties/pluginTimeout/type',
+                            dataPath: (dataPath || '') + '.onProtoPoisoning',
+                            schemaPath: '#/properties/onProtoPoisoning/type',
                             params: {
-                              type: 'integer'
+                              type: 'string'
                             },
-                            message: 'should be integer'
+                            message: 'should be string'
                           }];
                           return false;
                         } else {
                           data1 = coerced1;
-                          data['pluginTimeout'] = coerced1;
+                          data['onProtoPoisoning'] = coerced1;
                         }
                       }
                       var valid1 = errors === errs_1;
                       if (valid1) {
-                        var data1 = data.requestIdHeader;
+                        var data1 = data.onConstructorPoisoning;
                         var errs_1 = errors;
                         if (typeof data1 !== "string") {
                           var dataType1 = typeof data1;
@@ -404,8 +406,8 @@ var validate = (function() {
                           if (coerced1 === undefined) {
                             validate.errors = [{
                               keyword: 'type',
-                              dataPath: (dataPath || '') + '.requestIdHeader',
-                              schemaPath: '#/properties/requestIdHeader/type',
+                              dataPath: (dataPath || '') + '.onConstructorPoisoning',
+                              schemaPath: '#/properties/onConstructorPoisoning/type',
                               params: {
                                 type: 'string'
                               },
@@ -414,35 +416,86 @@ var validate = (function() {
                             return false;
                           } else {
                             data1 = coerced1;
-                            data['requestIdHeader'] = coerced1;
+                            data['onConstructorPoisoning'] = coerced1;
                           }
                         }
                         var valid1 = errors === errs_1;
                         if (valid1) {
-                          var data1 = data.requestIdLogLabel;
+                          var data1 = data.pluginTimeout;
                           var errs_1 = errors;
-                          if (typeof data1 !== "string") {
+                          if ((typeof data1 !== "number" || (data1 % 1) || data1 !== data1)) {
                             var dataType1 = typeof data1;
                             var coerced1 = undefined;
-                            if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
-                            else if (data1 === null) coerced1 = '';
+                            if (dataType1 == 'boolean' || data1 === null || (dataType1 == 'string' && data1 && data1 == +data1 && !(data1 % 1))) coerced1 = +data1;
                             if (coerced1 === undefined) {
                               validate.errors = [{
                                 keyword: 'type',
-                                dataPath: (dataPath || '') + '.requestIdLogLabel',
-                                schemaPath: '#/properties/requestIdLogLabel/type',
+                                dataPath: (dataPath || '') + '.pluginTimeout',
+                                schemaPath: '#/properties/pluginTimeout/type',
                                 params: {
-                                  type: 'string'
+                                  type: 'integer'
                                 },
-                                message: 'should be string'
+                                message: 'should be integer'
                               }];
                               return false;
                             } else {
                               data1 = coerced1;
-                              data['requestIdLogLabel'] = coerced1;
+                              data['pluginTimeout'] = coerced1;
                             }
                           }
                           var valid1 = errors === errs_1;
+                          if (valid1) {
+                            var data1 = data.requestIdHeader;
+                            var errs_1 = errors;
+                            if (typeof data1 !== "string") {
+                              var dataType1 = typeof data1;
+                              var coerced1 = undefined;
+                              if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
+                              else if (data1 === null) coerced1 = '';
+                              if (coerced1 === undefined) {
+                                validate.errors = [{
+                                  keyword: 'type',
+                                  dataPath: (dataPath || '') + '.requestIdHeader',
+                                  schemaPath: '#/properties/requestIdHeader/type',
+                                  params: {
+                                    type: 'string'
+                                  },
+                                  message: 'should be string'
+                                }];
+                                return false;
+                              } else {
+                                data1 = coerced1;
+                                data['requestIdHeader'] = coerced1;
+                              }
+                            }
+                            var valid1 = errors === errs_1;
+                            if (valid1) {
+                              var data1 = data.requestIdLogLabel;
+                              var errs_1 = errors;
+                              if (typeof data1 !== "string") {
+                                var dataType1 = typeof data1;
+                                var coerced1 = undefined;
+                                if (dataType1 == 'number' || dataType1 == 'boolean') coerced1 = '' + data1;
+                                else if (data1 === null) coerced1 = '';
+                                if (coerced1 === undefined) {
+                                  validate.errors = [{
+                                    keyword: 'type',
+                                    dataPath: (dataPath || '') + '.requestIdLogLabel',
+                                    schemaPath: '#/properties/requestIdLogLabel/type',
+                                    params: {
+                                      type: 'string'
+                                    },
+                                    message: 'should be string'
+                                  }];
+                                  return false;
+                                } else {
+                                  data1 = coerced1;
+                                  data['requestIdLogLabel'] = coerced1;
+                                }
+                              }
+                              var valid1 = errors === errs_1;
+                            }
+                          }
                         }
                       }
                     }
@@ -507,11 +560,11 @@ validate.schema = {
         "setDefaultValue": true
       }
     },
-    "disableRequestLogging": {
+    "ignoreTrailingSlash": {
       "type": "boolean",
       "default": false
     },
-    "ignoreTrailingSlash": {
+    "disableRequestLogging": {
       "type": "boolean",
       "default": false
     },
@@ -523,6 +576,10 @@ validate.schema = {
       "type": "string",
       "default": "error"
     },
+    "onConstructorPoisoning": {
+      "type": "string",
+      "default": "ignore"
+    },
     "pluginTimeout": {
       "type": "integer",
       "default": 10000
@@ -545,14 +602,4 @@ function customRule0 (schemaParamValue, validatedParamValue, validationSchemaObj
   return true
 }
 
-module.exports.defaultInitOptions = {
-  "bodyLimit":1048576,
-  "caseSensitive":true,
-  "disableRequestLogging": false,
-  "ignoreTrailingSlash":false,
-  "maxParamLength":100,
-  "onProtoPoisoning":"error",
-  "pluginTimeout":10000,
-  "requestIdHeader":"request-id",
-  "requestIdLogLabel":"reqId"
-}
+module.exports.defaultInitOptions = {"bodyLimit":1048576,"caseSensitive":true,"disableRequestLogging":false,"ignoreTrailingSlash":false,"maxParamLength":100,"onProtoPoisoning":"error","onConstructorPoisoning":"ignore","pluginTimeout":10000,"requestIdHeader":"request-id","requestIdLogLabel":"reqId"}
diff --git a/lib/contentTypeParser.js b/lib/contentTypeParser.js
index 4fab37f1..7ad4320f 100644
--- a/lib/contentTypeParser.js
+++ b/lib/contentTypeParser.js
@@ -22,8 +22,8 @@ const {
   }
 } = require('./errors')
 
-function ContentTypeParser (bodyLimit, onProtoPoisoning) {
-  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning)
+function ContentTypeParser (bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
+  this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning)
   this.customParsers = {}
   this.customParsers['application/json'] = new Parser(true, false, bodyLimit, this[kDefaultJsonParse])
   this.customParsers['text/plain'] = new Parser(true, false, bodyLimit, defaultPlainTextParser)
@@ -189,7 +189,7 @@ function rawBody (request, reply, options, parser, done) {
   }
 }
 
-function getDefaultJsonParser (onProtoPoisoning) {
+function getDefaultJsonParser (onProtoPoisoning, onConstructorPoisoning) {
   return defaultJsonParser
 
   function defaultJsonParser (req, body, done) {
@@ -198,7 +198,7 @@ function getDefaultJsonParser (onProtoPoisoning) {
     }
 
     try {
-      var json = secureJson.parse(body, { protoAction: onProtoPoisoning })
+      var json = secureJson.parse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning })
     } catch (err) {
       err.statusCode = 400
       return done(err, undefined)
diff --git a/lib/context.js b/lib/context.js
index 49e73f79..6d2e199f 100644
--- a/lib/context.js
+++ b/lib/context.js
@@ -1,10 +1,10 @@
 'use strict'
 
-const { kFourOhFourContext } = require('./symbols.js')
+const { kFourOhFourContext, kReplySerializerDefault } = require('./symbols.js')
 
 // Objects that holds the context of every request
 // Every route holds an instance of this object.
-function Context (schema, handler, Reply, Request, contentTypeParser, config, errorHandler, bodyLimit, logLevel, attachValidation) {
+function Context (schema, handler, Reply, Request, contentTypeParser, config, errorHandler, bodyLimit, logLevel, logSerializers, attachValidation, replySerializer) {
   this.schema = schema
   this.handler = handler
   this.Reply = Reply
@@ -20,16 +20,18 @@ function Context (schema, handler, Reply, Request, contentTypeParser, config, er
   this._middie = null
   this._parserOptions = { limit: bodyLimit || null }
   this.logLevel = logLevel
+  this.logSerializers = logSerializers
   this[kFourOhFourContext] = null
   this.attachValidation = attachValidation
+  this[kReplySerializerDefault] = replySerializer
 }
 
 function defaultErrorHandler (error, request, reply) {
   var res = reply.res
   if (res.statusCode >= 500) {
-    res.log.error({ req: reply.request.raw, res: res, err: error }, error && error.message)
+    reply.log.error({ req: reply.request.raw, res: res, err: error }, error && error.message)
   } else if (res.statusCode >= 400) {
-    res.log.info({ res: res, err: error }, error && error.message)
+    reply.log.info({ res: res, err: error }, error && error.message)
   }
   reply.send(error)
 }
diff --git a/lib/decorate.js b/lib/decorate.js
index 191a5e0f..e2ca39de 100644
--- a/lib/decorate.js
+++ b/lib/decorate.js
@@ -1,5 +1,7 @@
 'use strict'
 
+/* eslint no-prototype-builtins: 0 */
+
 const {
   kReply,
   kRequest
diff --git a/lib/errors.js b/lib/errors.js
index c18c0af5..46b7075c 100644
--- a/lib/errors.js
+++ b/lib/errors.js
@@ -7,42 +7,42 @@ const codes = {}
  * Basic
  */
 
-createError('FST_ERR_NOT_FOUND', `Not Found`, 404)
+createError('FST_ERR_NOT_FOUND', 'Not Found', 404)
 
 /**
  * ContentTypeParser
 */
-createError('FST_ERR_CTP_ALREADY_PRESENT', `Content type parser '%s' already present.`)
+createError('FST_ERR_CTP_ALREADY_PRESENT', "Content type parser '%s' already present.")
 createError('FST_ERR_CTP_INVALID_TYPE', 'The content type should be a string', 500, TypeError)
 createError('FST_ERR_CTP_EMPTY_TYPE', 'The content type cannot be an empty string', 500, TypeError)
 createError('FST_ERR_CTP_INVALID_HANDLER', 'The content type handler should be a function', 500, TypeError)
-createError('FST_ERR_CTP_INVALID_PARSE_TYPE', `The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.`, 500, TypeError)
+createError('FST_ERR_CTP_INVALID_PARSE_TYPE', "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.", 500, TypeError)
 createError('FST_ERR_CTP_BODY_TOO_LARGE', 'Request body is too large', 413, RangeError)
-createError('FST_ERR_CTP_INVALID_MEDIA_TYPE', `Unsupported Media Type: %s`, 415)
+createError('FST_ERR_CTP_INVALID_MEDIA_TYPE', 'Unsupported Media Type: %s', 415)
 createError('FST_ERR_CTP_INVALID_CONTENT_LENGTH', 'Request body size did not match Content-Length', 400, RangeError)
-createError('FST_ERR_CTP_EMPTY_JSON_BODY', `Body cannot be empty when content-type is set to 'application/json'`, 400)
+createError('FST_ERR_CTP_EMPTY_JSON_BODY', "Body cannot be empty when content-type is set to 'application/json'", 400)
 
 /**
  * decorate
 */
-createError('FST_ERR_DEC_ALREADY_PRESENT', `The decorator '%s' has already been added!`)
-createError('FST_ERR_DEC_MISSING_DEPENDENCY', `The decorator is missing dependency '%s'.`)
+createError('FST_ERR_DEC_ALREADY_PRESENT', "The decorator '%s' has already been added!")
+createError('FST_ERR_DEC_MISSING_DEPENDENCY', "The decorator is missing dependency '%s'.")
 
 /**
  * hooks
 */
-createError('FST_ERR_HOOK_INVALID_TYPE', `The hook name must be a string`, 500, TypeError)
-createError('FST_ERR_HOOK_INVALID_HANDLER', `The hook callback must be a function`, 500, TypeError)
+createError('FST_ERR_HOOK_INVALID_TYPE', 'The hook name must be a string', 500, TypeError)
+createError('FST_ERR_HOOK_INVALID_HANDLER', 'The hook callback must be a function', 500, TypeError)
 
 /**
  * logger
 */
-createError('FST_ERR_LOG_INVALID_DESTINATION', `Cannot specify both logger.stream and logger.file options`)
+createError('FST_ERR_LOG_INVALID_DESTINATION', 'Cannot specify both logger.stream and logger.file options')
 
 /**
  * reply
 */
-createError('FST_ERR_REP_INVALID_PAYLOAD_TYPE', `Attempted to send payload of invalid type '%s'. Expected a string or Buffer.`, 500, TypeError)
+createError('FST_ERR_REP_INVALID_PAYLOAD_TYPE', "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.", 500, TypeError)
 createError('FST_ERR_REP_ALREADY_SENT', 'Reply was already sent.')
 createError('FST_ERR_REP_SENT_VALUE', 'The only possible value for reply.sent is true.')
 createError('FST_ERR_SEND_INSIDE_ONERR', 'You cannot use `send` inside the `onError` hook')
@@ -50,24 +50,27 @@ createError('FST_ERR_SEND_INSIDE_ONERR', 'You cannot use `send` inside the `onEr
 /**
  * schemas
 */
-createError('FST_ERR_SCH_MISSING_ID', `Missing schema $id property`)
-createError('FST_ERR_SCH_ALREADY_PRESENT', `Schema with id '%s' already declared!`)
-createError('FST_ERR_SCH_NOT_PRESENT', `Schema with id '%s' does not exist!`)
+createError('FST_ERR_SCH_MISSING_ID', 'Missing schema $id property')
+createError('FST_ERR_SCH_ALREADY_PRESENT', "Schema with id '%s' already declared!")
+createError('FST_ERR_SCH_NOT_PRESENT', "Schema with id '%s' does not exist!")
+createError('FST_ERR_SCH_DUPLICATE', "Schema with '%s' already present!")
+createError('FST_ERR_SCH_BUILD', 'Failed building the schema for %s: %s, due error %s')
+createError('FST_ERR_SCH_MISSING_COMPILER', 'You must provide a schemaCompiler to route %s %s to use the schemaResolver')
 
 /**
  * wrapThenable
  */
-createError('FST_ERR_PROMISE_NOT_FULLFILLED', `Promise may not be fulfilled with 'undefined' when statusCode is not 204`)
+createError('FST_ERR_PROMISE_NOT_FULLFILLED', "Promise may not be fulfilled with 'undefined' when statusCode is not 204")
 
 /**
  * http2
  */
-createError('FST_ERR_HTTP2_INVALID_VERSION', `HTTP2 is available only from node >= 8.8.1`)
+createError('FST_ERR_HTTP2_INVALID_VERSION', 'HTTP2 is available only from node >= 8.8.1')
 
 /**
  * initialConfig
  */
-createError('FST_ERR_INIT_OPTS_INVALID', `Invalid initialization options: '%s'`)
+createError('FST_ERR_INIT_OPTS_INVALID', "Invalid initialization options: '%s'")
 
 function createError (code, message, statusCode = 500, Base = Error) {
   if (!code) throw new Error('Fastify error code must not be empty')
@@ -77,7 +80,7 @@ function createError (code, message, statusCode = 500, Base = Error) {
 
   function FastifyError (a, b, c) {
     Error.captureStackTrace(this, FastifyError)
-    this.name = `FastifyError`
+    this.name = 'FastifyError'
     this.code = code
 
     // more performant than spread (...) operator
@@ -93,6 +96,7 @@ function createError (code, message, statusCode = 500, Base = Error) {
 
     this.statusCode = statusCode || undefined
   }
+  FastifyError.prototype[Symbol.toStringTag] = 'Error'
 
   FastifyError.prototype.toString = function () {
     return `${this.name} [${this.code}]: ${this.message}`
diff --git a/lib/fourOhFour.js b/lib/fourOhFour.js
index c8216c5e..9a04232b 100644
--- a/lib/fourOhFour.js
+++ b/lib/fourOhFour.js
@@ -18,6 +18,7 @@ const {
   kMiddlewares,
   kHooks
 } = require('./symbols.js')
+const { buildMiddie } = require('./middleware')
 
 /**
  * Each fastify instance have a:
@@ -32,14 +33,7 @@ function fourOhFour (options) {
   // 404 router, used for handling encapsulated 404 handlers
   const router = FindMyWay({ defaultRoute: fourOhFourFallBack })
 
-  const fof = {
-    router,
-    setNotFoundHandler: setNotFoundHandler,
-    setContext: setContext,
-    arrange404: arrange404
-  }
-
-  return fof
+  return { router, setNotFoundHandler, setContext, arrange404 }
 
   function arrange404 (instance) {
     // Change the pointer of the fastify instance to itself, so register + prefix can add new 404 handler
@@ -47,8 +41,15 @@ function fourOhFour (options) {
     instance[kCanSetNotFoundHandler] = true
   }
 
-  function basic404 (req, reply) {
-    reply.code(404).send(new Error('Not Found'))
+  function basic404 (request, reply) {
+    const { url, method } = request.raw
+    const message = `Route ${method}:${url} not found`
+    request.log.info(message)
+    reply.code(404).send({
+      message,
+      error: 'Not Found',
+      statusCode: 404
+    })
   }
 
   function setContext (instance, context) {
@@ -57,7 +58,7 @@ function fourOhFour (options) {
     context[kFourOhFourContext] = _404Context
   }
 
-  function setNotFoundHandler (opts, handler, avvio, routeHandler, buildMiddie) {
+  function setNotFoundHandler (opts, handler, avvio, routeHandler) {
     // First initialization of the fastify root instance
     if (this[kCanSetNotFoundHandler] === undefined) {
       this[kCanSetNotFoundHandler] = true
@@ -105,12 +106,12 @@ function fourOhFour (options) {
     }
 
     this.after((notHandledErr, done) => {
-      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler, buildMiddie)
+      _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler)
       done(notHandledErr)
     })
   }
 
-  function _setNotFoundHandler (prefix, opts, handler, avvio, routeHandler, buildMiddie) {
+  function _setNotFoundHandler (prefix, opts, handler, avvio, routeHandler) {
     const context = new Context(
       opts.schema,
       handler,
diff --git a/lib/handleRequest.js b/lib/handleRequest.js
index 078f386d..d2d99f5f 100644
--- a/lib/handleRequest.js
+++ b/lib/handleRequest.js
@@ -1,7 +1,6 @@
 'use strict'
 
-const validation = require('./validation')
-const validateSchema = validation.validate
+const { validate: validateSchema } = require('./validation')
 const { hookRunner, hookIterator } = require('./hooks')
 const wrapThenable = require('./wrapThenable')
 
@@ -72,7 +71,7 @@ function handler (request, reply) {
 }
 
 function preValidationCallback (err, request, reply) {
-  if (reply.res.finished === true) return
+  if (reply.sent === true || reply.res.finished === true) return
   if (err != null) {
     reply.send(err)
     return
@@ -103,7 +102,7 @@ function preValidationCallback (err, request, reply) {
 }
 
 function preHandlerCallback (err, request, reply) {
-  if (reply.res.finished === true) return
+  if (reply.sent || reply.res.finished === true) return
   if (err != null) {
     reply.send(err)
     return
diff --git a/lib/logger.js b/lib/logger.js
index 1c27eeca..077e24c5 100644
--- a/lib/logger.js
+++ b/lib/logger.js
@@ -6,7 +6,7 @@
  * License: MIT (https://raw.githubusercontent.com/pinojs/pino-http/master/LICENSE)
  */
 
-const abstractLogging = require('abstract-logging')
+const nullLogger = require('abstract-logging')
 const pino = require('pino')
 const { serializersSym } = pino.symbols
 const { isValidLogger } = require('./validation')
@@ -82,7 +82,7 @@ function createLogger (options) {
     })
     return { logger, hasLogger: true }
   } else if (!options.logger) {
-    const logger = Object.create(abstractLogging)
+    const logger = nullLogger
     logger.child = () => logger
     return { logger, hasLogger: false }
   } else {
diff --git a/lib/middleware.js b/lib/middleware.js
new file mode 100644
index 00000000..6e66ccaa
--- /dev/null
+++ b/lib/middleware.js
@@ -0,0 +1,38 @@
+'use strict'
+
+const Middie = require('middie')
+const handleRequest = require('./handleRequest')
+const { hookRunner, hookIterator } = require('./hooks')
+
+function onRunMiddlewares (err, req, res, reply) {
+  if (err != null) {
+    reply.send(err)
+    return
+  }
+
+  if (reply.context.preParsing !== null) {
+    hookRunner(
+      reply.context.preParsing,
+      hookIterator,
+      reply.request,
+      reply,
+      handleRequest
+    )
+  } else {
+    handleRequest(null, reply.request, reply)
+  }
+}
+module.exports.onRunMiddlewares = onRunMiddlewares
+
+module.exports.buildMiddie = function buildMiddie (middlewares) {
+  if (!middlewares.length) {
+    return null
+  }
+
+  const middie = Middie(onRunMiddlewares)
+  for (var i = 0; i < middlewares.length; i++) {
+    middie.use.apply(middie, middlewares[i])
+  }
+
+  return middie
+}
diff --git a/lib/pluginUtils.js b/lib/pluginUtils.js
index 1f154979..319aec02 100644
--- a/lib/pluginUtils.js
+++ b/lib/pluginUtils.js
@@ -11,6 +11,35 @@ function getMeta (fn) {
   return fn[Symbol.for('plugin-meta')]
 }
 
+function getPluginName (func) {
+  // let's see if this is a file, and in that case use that
+  // this is common for plugins
+  const cache = require.cache
+  const keys = Object.keys(cache)
+
+  for (var i = 0; i < keys.length; i++) {
+    if (cache[keys[i]].exports === func) {
+      return keys[i]
+    }
+  }
+
+  // if not maybe it's a named function, so use that
+  if (func.name) {
+    return func.name
+  }
+
+  return null
+}
+
+function getFuncPreview (func) {
+  // takes the first two lines of the function if nothing else works
+  return func.toString().split('\n').slice(0, 2).map(s => s.trim()).join(' -- ')
+}
+
+function getDisplayName (fn) {
+  return fn[Symbol.for('fastify.display-name')]
+}
+
 function shouldSkipOverride (fn) {
   return !!fn[Symbol.for('skip-override')]
 }
@@ -71,7 +100,10 @@ function registerPlugin (fn) {
 }
 
 module.exports = {
+  getPluginName,
+  getFuncPreview,
   registeredPlugins,
+  getDisplayName,
   registerPlugin
 }
 
diff --git a/lib/reply.js b/lib/reply.js
index a5890bd5..7ad03e9e 100644
--- a/lib/reply.js
+++ b/lib/reply.js
@@ -11,6 +11,7 @@ const {
   kReplySentOverwritten,
   kReplyStartTime,
   kReplySerializer,
+  kReplySerializerDefault,
   kReplyIsError,
   kReplyHeaders,
   kReplyHasStatusCode,
@@ -83,6 +84,15 @@ Object.defineProperty(Reply.prototype, 'sent', {
   }
 })
 
+Object.defineProperty(Reply.prototype, 'statusCode', {
+  get () {
+    return this.res.statusCode
+  },
+  set (value) {
+    this.code(value)
+  }
+})
+
 Reply.prototype.send = function (payload) {
   if (this[kReplyIsRunningOnErrorHook] === true) {
     throw new FST_ERR_SEND_INSIDE_ONERR()
@@ -90,17 +100,17 @@ Reply.prototype.send = function (payload) {
 
   if (this[kReplySent]) {
     this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT() }, 'Reply already sent')
-    return
+    return this
   }
 
   if (payload instanceof Error || this[kReplyIsError] === true) {
     onErrorHook(this, payload, onSendHook)
-    return
+    return this
   }
 
   if (payload === undefined) {
     onSendHook(this, payload)
-    return
+    return this
   }
 
   var contentType = this.getHeader('content-type')
@@ -112,13 +122,13 @@ Reply.prototype.send = function (payload) {
         this[kReplyHeaders]['content-type'] = CONTENT_TYPE.OCTET
       }
       onSendHook(this, payload)
-      return
+      return this
     }
 
     if (hasContentType === false && typeof payload === 'string') {
       this[kReplyHeaders]['content-type'] = CONTENT_TYPE.PLAIN
       onSendHook(this, payload)
-      return
+      return this
     }
   }
 
@@ -130,10 +140,12 @@ Reply.prototype.send = function (payload) {
     }
 
     preserializeHook(this, payload)
-    return
+    return this
   }
 
   onSendHook(this, payload)
+
+  return this
 }
 
 Reply.prototype.getHeader = function (key) {
@@ -199,7 +211,11 @@ Reply.prototype.serialize = function (payload) {
   if (this[kReplySerializer] !== null) {
     return this[kReplySerializer](payload)
   } else {
-    return serialize(this.context, payload, this.res.statusCode)
+    if (this.context && this.context[kReplySerializerDefault]) {
+      return this.context[kReplySerializerDefault](payload, this.res.statusCode)
+    } else {
+      return serialize(this.context, payload, this.res.statusCode)
+    }
   }
 }
 
@@ -226,6 +242,40 @@ Reply.prototype.callNotFound = function () {
   notFound(this)
 }
 
+Reply.prototype.getResponseTime = function () {
+  var responseTime = 0
+
+  if (this[kReplyStartTime] !== undefined) {
+    responseTime = now() - this[kReplyStartTime]
+  }
+
+  return responseTime
+}
+
+// Make reply a thenable, so it could be used with async/await.
+// See
+// - https://github.com/fastify/fastify/issues/1864 for the discussions
+// - https://promisesaplus.com/ for the definition of thenable
+// - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then for the signature
+Reply.prototype.then = function (fullfilled, rejected) {
+  if (this.sent) {
+    fullfilled()
+    return
+  }
+
+  eos(this.res, function (err) {
+    // We must not treat ERR_STREAM_PREMATURE_CLOSE as
+    // an error because it is created by eos, not by the stream.
+    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
+      if (rejected) {
+        rejected(err)
+      }
+    } else {
+      fullfilled()
+    }
+  })
+}
+
 function preserializeHook (reply, payload) {
   if (reply.context.preSerialization !== null) {
     onSendHookRunner(
@@ -246,7 +296,12 @@ function preserializeHookEnd (err, request, reply, payload) {
     return
   }
 
-  payload = serialize(reply.context, payload, reply.res.statusCode)
+  if (reply.context && reply.context[kReplySerializerDefault]) {
+    payload = reply.context[kReplySerializerDefault](payload, reply.res.statusCode)
+  } else {
+    payload = serialize(reply.context, payload, reply.res.statusCode)
+  }
+
   flatstr(payload)
 
   onSendHook(reply, payload)
@@ -464,11 +519,8 @@ function onResponseCallback (err, request, reply) {
   if (reply.log[kDisableRequestLogging]) {
     return
   }
-  var responseTime = 0
 
-  if (reply[kReplyStartTime] !== undefined) {
-    responseTime = now() - reply[kReplyStartTime]
-  }
+  var responseTime = reply.getResponseTime()
 
   if (err != null) {
     reply.log.error({
diff --git a/lib/request.js b/lib/request.js
index d99061c0..69d1aa71 100644
--- a/lib/request.js
+++ b/lib/request.js
@@ -30,12 +30,12 @@ function buildRequest (R) {
 }
 
 Object.defineProperties(Request.prototype, {
-  'req': {
+  req: {
     get: function () {
       return this.raw
     }
   },
-  'id': {
+  id: {
     get: function () {
       return this.raw.id
     }
diff --git a/lib/route.js b/lib/route.js
new file mode 100644
index 00000000..30cd7471
--- /dev/null
+++ b/lib/route.js
@@ -0,0 +1,405 @@
+'use strict'
+
+const FindMyWay = require('find-my-way')
+const proxyAddr = require('proxy-addr')
+const Context = require('./context')
+const { buildMiddie, onRunMiddlewares } = require('./middleware')
+const { hookRunner, hookIterator } = require('./hooks')
+const supportedMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'OPTIONS']
+const supportedHooks = ['preParsing', 'preValidation', 'onRequest', 'preHandler', 'preSerialization', 'onResponse']
+const validation = require('./validation')
+const buildSchema = validation.build
+const { buildSchemaCompiler } = validation
+
+const {
+  codes: {
+    FST_ERR_SCH_BUILD,
+    FST_ERR_SCH_MISSING_COMPILER
+  }
+} = require('./errors')
+
+const {
+  kRoutePrefix,
+  kLogLevel,
+  kLogSerializers,
+  kHooks,
+  kSchemas,
+  kOptions,
+  kSchemaCompiler,
+  kSchemaResolver,
+  kContentTypeParser,
+  kReply,
+  kReplySerializerDefault,
+  kRequest,
+  kMiddlewares,
+  kGlobalHooks,
+  kDisableRequestLogging
+} = require('./symbols.js')
+
+function buildRouting (options) {
+  const router = FindMyWay(options.config)
+
+  const schemaCache = new Map()
+  schemaCache.put = schemaCache.set
+
+  let avvio
+  let fourOhFour
+  let trustProxy
+  let requestIdHeader
+  let querystringParser
+  let requestIdLogLabel
+  let logger
+  let hasLogger
+  let setupResponseListeners
+  let throwIfAlreadyStarted
+  let proxyFn
+  let modifyCoreObjects
+  let genReqId
+  let disableRequestLogging
+  let ignoreTrailingSlash
+  let return503OnClosing
+
+  let closing = false
+
+  return {
+    setup (options, fastifyArgs) {
+      avvio = fastifyArgs.avvio
+      fourOhFour = fastifyArgs.fourOhFour
+      logger = fastifyArgs.logger
+      hasLogger = fastifyArgs.hasLogger
+      setupResponseListeners = fastifyArgs.setupResponseListeners
+      throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted
+
+      proxyFn = getTrustProxyFn(options)
+      trustProxy = options.trustProxy
+      requestIdHeader = options.requestIdHeader
+      querystringParser = options.querystringParser
+      requestIdLogLabel = options.requestIdLogLabel
+      modifyCoreObjects = options.modifyCoreObjects
+      genReqId = options.genReqId
+      disableRequestLogging = options.disableRequestLogging
+      ignoreTrailingSlash = options.ignoreTrailingSlash
+      return503OnClosing = Object.prototype.hasOwnProperty.call(options, 'return503OnClosing') ? options.return503OnClosing : true
+    },
+    routing: router.lookup.bind(router), // router func to find the right handler to call
+    route, // configure a route in the fastify instance
+    prepareRoute,
+    routeHandler,
+    closeRoutes: () => { closing = true },
+    printRoutes: router.prettyPrint.bind(router)
+  }
+
+  // Convert shorthand to extended route declaration
+  function prepareRoute (method, url, options, handler) {
+    if (!handler && typeof options === 'function') {
+      handler = options
+      options = {}
+    } else if (handler && typeof handler === 'function') {
+      if (Object.prototype.toString.call(options) !== '[object Object]') {
+        throw new Error(`Options for ${method}:${url} route must be an object`)
+      } else if (options.handler) {
+        if (typeof options.handler === 'function') {
+          throw new Error(`Duplicate handler for ${method}:${url} route is not allowed!`)
+        } else {
+          throw new Error(`Handler for ${method}:${url} route must be a function`)
+        }
+      }
+    }
+
+    options = Object.assign({}, options, {
+      method,
+      url,
+      handler: handler || (options && options.handler)
+    })
+
+    return route.call(this, options)
+  }
+
+  // Route management
+  function route (opts) {
+    throwIfAlreadyStarted('Cannot add route when fastify instance is already started!')
+
+    if (Array.isArray(opts.method)) {
+      for (var i = 0; i < opts.method.length; i++) {
+        if (supportedMethods.indexOf(opts.method[i]) === -1) {
+          throw new Error(`${opts.method[i]} method is not supported!`)
+        }
+      }
+    } else {
+      if (supportedMethods.indexOf(opts.method) === -1) {
+        throw new Error(`${opts.method} method is not supported!`)
+      }
+    }
+
+    if (!opts.handler) {
+      throw new Error(`Missing handler function for ${opts.method}:${opts.url} route.`)
+    }
+
+    validateBodyLimitOption(opts.bodyLimit)
+
+    const prefix = this[kRoutePrefix]
+
+    this.after((notHandledErr, done) => {
+      var path = opts.url || opts.path
+      if (path === '/' && prefix.length > 0) {
+        switch (opts.prefixTrailingSlash) {
+          case 'slash':
+            afterRouteAdded.call(this, path, notHandledErr, done)
+            break
+          case 'no-slash':
+            afterRouteAdded.call(this, '', notHandledErr, done)
+            break
+          case 'both':
+          default:
+            afterRouteAdded.call(this, '', notHandledErr, done)
+            // If ignoreTrailingSlash is set to true we need to add only the '' route to prevent adding an incomplete one.
+            if (ignoreTrailingSlash !== true) {
+              afterRouteAdded.call(this, path, notHandledErr, done)
+            }
+        }
+      } else if (path[0] === '/' && prefix.endsWith('/')) {
+        // Ensure that '/prefix/' + '/route' gets registered as '/prefix/route'
+        afterRouteAdded.call(this, path.slice(1), notHandledErr, done)
+      } else {
+        afterRouteAdded.call(this, path, notHandledErr, done)
+      }
+    })
+
+    // chainable api
+    return this
+
+    function afterRouteAdded (path, notHandledErr, done) {
+      const url = prefix + path
+
+      opts.url = url
+      opts.path = url
+      opts.prefix = prefix
+      opts.logLevel = opts.logLevel || this[kLogLevel]
+
+      if (this[kLogSerializers] || opts.logSerializers) {
+        opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers)
+      }
+
+      if (opts.attachValidation == null) {
+        opts.attachValidation = false
+      }
+
+      // run 'onRoute' hooks
+      for (const hook of this[kGlobalHooks].onRoute) {
+        try {
+          hook.call(this, opts)
+        } catch (error) {
+          done(error)
+          return
+        }
+      }
+
+      const config = opts.config || {}
+      config.url = url
+
+      const context = new Context(
+        opts.schema,
+        opts.handler.bind(this),
+        this[kReply],
+        this[kRequest],
+        this[kContentTypeParser],
+        config,
+        this._errorHandler,
+        opts.bodyLimit,
+        opts.logLevel,
+        opts.logSerializers,
+        opts.attachValidation,
+        this[kReplySerializerDefault]
+      )
+
+      // TODO this needs to be refactored so that buildSchemaCompiler is
+      // not called for every single route. Creating a new one for every route
+      // is going to be very expensive.
+      if (opts.schema) {
+        if (this[kSchemaCompiler] == null && this[kSchemaResolver]) {
+          done(new FST_ERR_SCH_MISSING_COMPILER(opts.method, url))
+          return
+        }
+
+        try {
+          if (opts.schemaCompiler == null && this[kSchemaCompiler] == null) {
+            const externalSchemas = this[kSchemas].getJsonSchemas({ onlyAbsoluteUri: true })
+            this.setSchemaCompiler(buildSchemaCompiler(externalSchemas, this[kOptions].ajv, schemaCache))
+          }
+
+          buildSchema(context, opts.schemaCompiler || this[kSchemaCompiler], this[kSchemas], this[kSchemaResolver])
+        } catch (error) {
+          // bubble up the FastifyError instance
+          done(error.code ? error : new FST_ERR_SCH_BUILD(opts.method, url, error.message))
+          return
+        }
+      }
+
+      for (const hook of supportedHooks) {
+        if (opts[hook]) {
+          if (Array.isArray(opts[hook])) {
+            opts[hook] = opts[hook].map(fn => fn.bind(this))
+          } else {
+            opts[hook] = opts[hook].bind(this)
+          }
+        }
+      }
+
+      try {
+        router.on(opts.method, url, { version: opts.version }, routeHandler, context)
+      } catch (err) {
+        done(err)
+        return
+      }
+
+      // It can happen that a user register a plugin with some hooks/middlewares *after*
+      // the route registration. To be sure to load also that hooks/middlewares,
+      // we must listen for the avvio's preReady event, and update the context object accordingly.
+      avvio.once('preReady', () => {
+        const onResponse = this[kHooks].onResponse
+        const onSend = this[kHooks].onSend
+        const onError = this[kHooks].onError
+
+        context.onSend = onSend.length ? onSend : null
+        context.onError = onError.length ? onError : null
+        context.onResponse = onResponse.length ? onResponse : null
+
+        for (const hook of supportedHooks) {
+          const toSet = this[kHooks][hook].concat(opts[hook] || [])
+          context[hook] = toSet.length ? toSet : null
+        }
+
+        context._middie = buildMiddie(this[kMiddlewares])
+
+        // Must store the 404 Context in 'preReady' because it is only guaranteed to
+        // be available after all of the plugins and routes have been loaded.
+        fourOhFour.setContext(this, context)
+      })
+
+      done(notHandledErr)
+    }
+  }
+
+  // HTTP request entry point, the routing has already been executed
+  function routeHandler (req, res, params, context) {
+    if (closing === true) {
+      if (req.httpVersionMajor !== 2) {
+        res.once('finish', () => req.destroy())
+        res.setHeader('Connection', 'close')
+      }
+
+      if (return503OnClosing) {
+        const headers = {
+          'Content-Type': 'application/json',
+          'Content-Length': '80'
+        }
+        res.writeHead(503, headers)
+        res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}')
+        return
+      }
+    }
+
+    req.id = req.headers[requestIdHeader] || genReqId(req)
+    req.originalUrl = req.url
+    var hostname = req.headers.host
+    var ip = req.connection.remoteAddress
+    var ips
+
+    if (trustProxy) {
+      ip = proxyAddr(req, proxyFn)
+      ips = proxyAddr.all(req, proxyFn)
+      if (ip !== undefined && req.headers['x-forwarded-host']) {
+        hostname = req.headers['x-forwarded-host']
+      }
+    }
+
+    var loggerOpts = {
+      [requestIdLogLabel]: req.id,
+      level: context.logLevel
+    }
+
+    if (context.logSerializers) {
+      loggerOpts.serializers = context.logSerializers
+    }
+    var childLogger = logger.child(loggerOpts)
+    childLogger[kDisableRequestLogging] = disableRequestLogging
+
+    // added hostname, ip, and ips back to the Node req object to maintain backward compatibility
+    if (modifyCoreObjects) {
+      req.hostname = hostname
+      req.ip = ip
+      req.ips = ips
+
+      req.log = res.log = childLogger
+    }
+
+    if (disableRequestLogging === false) {
+      childLogger.info({ req }, 'incoming request')
+    }
+
+    var queryPrefix = req.url.indexOf('?')
+    var query = querystringParser(queryPrefix > -1 ? req.url.slice(queryPrefix + 1) : '')
+    var request = new context.Request(params, req, query, req.headers, childLogger, ip, ips, hostname)
+    var reply = new context.Reply(res, context, request, childLogger)
+
+    if (hasLogger === true || context.onResponse !== null) {
+      setupResponseListeners(reply)
+    }
+
+    if (context.onRequest !== null) {
+      hookRunner(
+        context.onRequest,
+        hookIterator,
+        request,
+        reply,
+        middlewareCallback
+      )
+    } else {
+      middlewareCallback(null, request, reply)
+    }
+  }
+}
+
+function validateBodyLimitOption (bodyLimit) {
+  if (bodyLimit === undefined) return
+  if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
+    throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${bodyLimit}'`)
+  }
+}
+
+function middlewareCallback (err, request, reply) {
+  if (reply.sent === true) return
+  if (err != null) {
+    reply.send(err)
+    return
+  }
+
+  if (reply.context._middie !== null) {
+    reply.context._middie.run(request.raw, reply.res, reply)
+  } else {
+    onRunMiddlewares(null, null, null, reply)
+  }
+}
+
+function getTrustProxyFn (options) {
+  const tp = options.trustProxy
+  if (typeof tp === 'function') {
+    return tp
+  }
+  if (tp === true) {
+    // Support plain true/false
+    return function () { return true }
+  }
+  if (typeof tp === 'number') {
+    // Support trusting hop count
+    return function (a, i) { return i < tp }
+  }
+  if (typeof tp === 'string') {
+    // Support comma-separated tps
+    const vals = tp.split(',').map(it => it.trim())
+    return proxyAddr.compile(vals)
+  }
+  return proxyAddr.compile(tp || [])
+}
+
+module.exports = { buildRouting, validateBodyLimitOption }
diff --git a/lib/schemas.js b/lib/schemas.js
index a892ceb0..d76ae4e0 100644
--- a/lib/schemas.js
+++ b/lib/schemas.js
@@ -1,12 +1,14 @@
 'use strict'
 
 const fastClone = require('rfdc')({ circles: false, proto: true })
+const kFluentSchema = Symbol.for('fluent-schema-object')
 
 const {
   codes: {
     FST_ERR_SCH_MISSING_ID,
     FST_ERR_SCH_ALREADY_PRESENT,
-    FST_ERR_SCH_NOT_PRESENT
+    FST_ERR_SCH_NOT_PRESENT,
+    FST_ERR_SCH_DUPLICATE
   }
 } = require('./errors')
 
@@ -16,9 +18,12 @@ function Schemas () {
   this.store = {}
 }
 
-Schemas.prototype.add = function (inputSchema) {
-  const schema = fastClone(inputSchema)
-  const id = schema['$id']
+Schemas.prototype.add = function (inputSchema, refResolver) {
+  var schema = fastClone((inputSchema.isFluentSchema || inputSchema[kFluentSchema])
+    ? inputSchema.valueOf()
+    : inputSchema
+  )
+  const id = schema.$id
   if (id === undefined) {
     throw new FST_ERR_SCH_MISSING_ID()
   }
@@ -27,17 +32,26 @@ Schemas.prototype.add = function (inputSchema) {
     throw new FST_ERR_SCH_ALREADY_PRESENT(id)
   }
 
-  this.store[id] = this.resolveRefs(schema, true)
+  this.store[id] = this.resolveRefs(schema, true, refResolver)
 }
 
 Schemas.prototype.resolve = function (id) {
   if (this.store[id] === undefined) {
     throw new FST_ERR_SCH_NOT_PRESENT(id)
   }
-  return this.store[id]
+  return Object.assign({}, this.store[id])
 }
 
-Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId) {
+Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId, refResolver) {
+  // alias query to querystring schema
+  if (routeSchemas.query) {
+    // check if our schema has both querystring and query
+    if (routeSchemas.querystring) {
+      throw new FST_ERR_SCH_DUPLICATE('querystring')
+    }
+    routeSchemas.querystring = routeSchemas.query
+  }
+
   // let's check if our schemas have a custom prototype
   for (const key of ['headers', 'querystring', 'params', 'body']) {
     if (typeof routeSchemas[key] === 'object' && Object.getPrototypeOf(routeSchemas[key]) !== Object.prototype) {
@@ -45,10 +59,13 @@ Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId) {
     }
   }
 
+  // See issue https://github.com/fastify/fastify/issues/1767
+  const cachedSchema = Object.assign({}, routeSchemas)
+
   try {
     // this will work only for standard json schemas
     // other compilers such as Joi will fail
-    this.traverse(routeSchemas)
+    this.traverse(routeSchemas, refResolver)
 
     // when a plugin uses the 'skip-override' and call addSchema
     // the same JSON will be pass throug all the avvio tree. In this case
@@ -58,9 +75,13 @@ Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId) {
       this.cleanId(routeSchemas)
     }
   } catch (err) {
-    // if we have failed because `resolve has thrown
+    // if we have failed because `resolve` has thrown
     // let's rethrow the error and let avvio handle it
     if (/FST_ERR_SCH_*/.test(err.code)) throw err
+
+    // otherwise, the schema must not be a JSON schema
+    // so we let the user configured schemaCompiler handle it
+    return cachedSchema
   }
 
   if (routeSchemas.headers) {
@@ -78,15 +99,26 @@ Schemas.prototype.resolveRefs = function (routeSchemas, dontClearId) {
   return routeSchemas
 }
 
-Schemas.prototype.traverse = function (schema) {
+Schemas.prototype.traverse = function (schema, refResolver) {
   for (var key in schema) {
     // resolve the `sharedSchemaId#' only if is not a standard $ref JSON Pointer
     if (typeof schema[key] === 'string' && key !== '$schema' && key !== '$ref' && schema[key].slice(-1) === '#') {
       schema[key] = this.resolve(schema[key].slice(0, -1))
+    } else if (key === '$ref' && refResolver) {
+      const refValue = schema[key]
+
+      const framePos = refValue.indexOf('#')
+      const refId = framePos >= 0 ? refValue.slice(0, framePos) : refValue
+      if (refId.length > 0 && !this.store[refId]) {
+        const resolvedSchema = refResolver(refId)
+        if (resolvedSchema) {
+          this.add(resolvedSchema, refResolver)
+        }
+      }
     }
 
     if (schema[key] !== null && typeof schema[key] === 'object') {
-      this.traverse(schema[key])
+      this.traverse(schema[key], refResolver)
     }
   }
 }
@@ -103,7 +135,7 @@ Schemas.prototype.cleanId = function (schema) {
 }
 
 Schemas.prototype.getSchemaAnyway = function (schema) {
-  if (schema.oneOf || schema.allOf || schema.anyOf) return schema
+  if (schema.oneOf || schema.allOf || schema.anyOf || schema.$merge || schema.$patch) return schema
   if (!schema.type || !schema.properties) {
     return {
       type: 'object',
@@ -121,8 +153,8 @@ Schemas.prototype.getJsonSchemas = function (options) {
   const store = this.getSchemas()
   const schemasArray = Object.keys(store).map(schemaKey => {
     // if the shared-schema "replace-way" has been used, the $id field has been removed
-    if (store[schemaKey]['$id'] === undefined) {
-      store[schemaKey]['$id'] = schemaKey
+    if (store[schemaKey].$id === undefined) {
+      store[schemaKey].$id = schemaKey
     }
     return store[schemaKey]
   })
diff --git a/lib/symbols.js b/lib/symbols.js
index 73a12364..2b27b7de 100644
--- a/lib/symbols.js
+++ b/lib/symbols.js
@@ -5,9 +5,12 @@ const keys = {
   kBodyLimit: Symbol('fastify.bodyLimit'),
   kRoutePrefix: Symbol('fastify.routePrefix'),
   kLogLevel: Symbol('fastify.logLevel'),
+  kLogSerializers: Symbol('fastify.logSerializers'),
   kHooks: Symbol('fastify.hooks'),
   kSchemas: Symbol('fastify.schemas'),
   kSchemaCompiler: Symbol('fastify.schemaCompiler'),
+  kSchemaResolver: Symbol('fastify.schemaRefResolver'),
+  kReplySerializerDefault: Symbol('fastify.replySerializerDefault'),
   kContentTypeParser: Symbol('fastify.contentTypeParser'),
   kReply: Symbol('fastify.Reply'),
   kRequest: Symbol('fastify.Request'),
@@ -29,7 +32,8 @@ const keys = {
   kState: Symbol('fastify.state'),
   kOptions: Symbol('fastify.options'),
   kGlobalHooks: Symbol('fastify.globalHooks'),
-  kDisableRequestLogging: Symbol('fastify.disableRequestLogging')
+  kDisableRequestLogging: Symbol('fastify.disableRequestLogging'),
+  kPluginNameChain: Symbol('fastify.pluginNameChain')
 }
 
 module.exports = keys
diff --git a/lib/validation.js b/lib/validation.js
index bd45ffed..66823d92 100644
--- a/lib/validation.js
+++ b/lib/validation.js
@@ -8,6 +8,7 @@ const querystringSchema = Symbol('querystring-schema')
 const paramsSchema = Symbol('params-schema')
 const responseSchema = Symbol('response-schema')
 const headersSchema = Symbol('headers-schema')
+const kFluentSchema = Symbol.for('fluent-schema-object')
 
 function getValidatorForStatusCodeSchema (statusCodeDefinition, externalSchema) {
   return fastJsonStringify(statusCodeDefinition, { schema: externalSchema })
@@ -21,12 +22,13 @@ function getResponseSchema (responseSchemaDefinition, sharedSchemas) {
   }, {})
 }
 
-function build (context, compile, schemas) {
+function build (context, compile, schemas, schemaResolver) {
   if (!context.schema) {
     return
   }
 
-  context.schema = schemas.resolveRefs(context.schema)
+  generateFluentSchema(context.schema)
+  context.schema = schemas.resolveRefs(context.schema, false, schemaResolver)
 
   const headers = context.schema.headers
 
@@ -42,6 +44,7 @@ function build (context, compile, schemas) {
       headersSchemaLowerCase.required = headersSchemaLowerCase.required.map(h => h.toLowerCase())
     }
     if (headers.properties) {
+      headersSchemaLowerCase.properties = {}
       Object.keys(headers.properties).forEach(k => {
         headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k]
       })
@@ -66,6 +69,22 @@ function build (context, compile, schemas) {
   }
 }
 
+function generateFluentSchema (schema) {
+  ;['params', 'body', 'querystring', 'query', 'headers'].forEach(key => {
+    if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
+      schema[key] = schema[key].valueOf()
+    }
+  })
+
+  if (schema.response) {
+    Object.keys(schema.response).forEach(code => {
+      if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
+        schema.response[code] = schema.response[code].valueOf()
+      }
+    })
+  }
+}
+
 function validateParam (validatorFunction, request, paramName) {
   var ret = validatorFunction && validatorFunction(request[paramName])
   if (ret === false) return validatorFunction.errors
@@ -144,16 +163,22 @@ function schemaErrorsText (errors, dataVar) {
   return text.slice(0, -separator.length)
 }
 
-function buildSchemaCompiler (externalSchemas, cache) {
+function buildSchemaCompiler (externalSchemas, options, cache) {
   // This instance of Ajv is private
   // it should not be customized or used
-  const ajv = new Ajv({
+  const ajv = new Ajv(Object.assign({
     coerceTypes: true,
     useDefaults: true,
     removeAdditional: true,
     allErrors: true,
-    cache
-  })
+    nullable: true
+  }, options.customOptions, { cache }))
+
+  if (options.plugins && options.plugins.length > 0) {
+    for (const plugin of options.plugins) {
+      plugin[0](ajv, plugin[1])
+    }
+  }
 
   if (Array.isArray(externalSchemas)) {
     externalSchemas.forEach(s => ajv.addSchema(s))
diff --git a/lib/wrapThenable.js b/lib/wrapThenable.js
index 42cbb82d..0cd05f19 100644
--- a/lib/wrapThenable.js
+++ b/lib/wrapThenable.js
@@ -31,7 +31,7 @@ function wrapThenable (thenable, reply) {
         reply.send(err)
       }
     } else if (reply[kReplySent] === false) {
-      reply.log.error({ err: new FST_ERR_PROMISE_NOT_FULLFILLED() }, `Promise may not be fulfilled with 'undefined' when statusCode is not 204`)
+      reply.log.error({ err: new FST_ERR_PROMISE_NOT_FULLFILLED() }, "Promise may not be fulfilled with 'undefined' when statusCode is not 204")
     }
   }, function (err) {
     if (reply[kReplySentOverwritten] === true) {
diff --git a/package.json b/package.json
index 1f088829..643851de 100644
--- a/package.json
+++ b/package.json
@@ -1,24 +1,24 @@
 {
   "name": "fastify",
-  "version": "2.3.0",
+  "version": "2.10.0",
   "description": "Fast and low overhead web framework, for Node.js",
   "main": "fastify.js",
   "types": "fastify.d.ts",
   "scripts": {
     "lint": "npm run lint:standard && npm run lint:typescript",
     "lint:standard": "standard --verbose | snazzy",
-    "lint:typescript": "eslint -c types/.eslintrc.json types/**/*.d.ts test/types/**/*.test-d.ts",
-    "unit": "tap -J test/*.test.js test/*/*.test.js",
-    "unit:report": "tap -J test/*.test.js test/*/*.test.js --cov --coverage-report=html --coverage-report=cobertura | tee out.tap",
+    "lint:typescript": "standard --parser @typescript-eslint/parser --plugin @typescript-eslint/eslint-plugin test/types/*.ts fastify.d.ts",
+    "unit": "tap --no-esm -J test/*.test.js test/*/*.test.js",
+    "unit:report": "tap --no-esm -J test/*.test.js test/*/*.test.js --cov --coverage-report=html --coverage-report=cobertura | tee out.tap",
     "unit:junit": "tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml",
     "test:typescript": "tsd",
     "test:report": "npm run lint && npm run unit:report && npm run test:typescript",
     "test": "npm run lint && npm run unit && npm run test:typescript",
     "coverage": "npm run unit -- --cov --coverage-report=html",
-    "coveralls": "npm run unit -- --cov",
+    "test:ci": "npm run lint && npm run unit -- --cov --coverage-report=lcovonly && npm run test:typescript",
     "bench": "branchcmp -r 2 -g -s \"npm run benchmark\"",
     "benchmark": "npx concurrently -k -s first \"node ./examples/simple.js\" \"npx autocannon -c 100 -d 5 -p 10 localhost:3000/\"",
-    "license-checker": "license-checker --production --onlyAllow='MIT;ISC;BSD-3-Clause;BSD-2-Clause'"
+    "license-checker": "license-checker --production --onlyAllow=\"MIT;ISC;BSD-3-Clause;BSD-2-Clause\""
   },
   "repository": {
     "type": "git",
@@ -77,6 +77,10 @@
     {
       "name": "James Sumners",
       "url": "https://james.sumners.info"
+    },
+    {
+      "name": "Denis Fäcke",
+      "url": "https://github.com/SerayaEryn"
     }
   ],
   "license": "MIT",
@@ -90,17 +94,18 @@
   "devDependencies": {
     "@hapi/joi": "^15.1.0",
     "@types/node": "^12.0.10",
-    "@typescript-eslint/eslint-plugin": "^1.13.0",
-    "@typescript-eslint/parser": "^1.13.0",
+    "@typescript-eslint/eslint-plugin": "^2.3.0",
+    "@typescript-eslint/parser": "^2.3.0",
     "JSONStream": "^1.3.5",
+    "ajv-merge-patch": "^4.1.0",
     "ajv-pack": "^0.3.1",
     "autocannon": "^4.0.0",
     "branch-comparer": "^0.4.0",
-    "concurrently": "^4.1.1",
+    "concurrently": "^5.0.0",
     "cors": "^2.8.5",
-    "coveralls": "^3.0.4",
+    "coveralls": "^3.0.6",
     "dns-prefetch-control": "^0.2.0",
-    "eslint": "^6.2.2",
+    "eslint": "^6.4.0",
     "eslint-config-standard": "^14.0.1",
     "eslint-import-resolver-node": "^0.3.2",
     "eslint-plugin-import": "^2.18.2",
@@ -109,49 +114,49 @@
     "eslint-plugin-standard": "^4.0.1",
     "fast-json-body": "^1.1.0",
     "fastify-plugin": "^1.6.0",
-    "fluent-schema": "^0.7.3",
-    "form-data": "^2.4.0",
+    "fluent-schema": "^0.8.0",
+    "form-data": "^3.0.0",
     "frameguard": "^3.1.0",
-    "h2url": "^0.1.2",
-    "helmet": "^3.18.0",
+    "h2url": "^0.2.0",
+    "helmet": "^3.20.0",
     "hide-powered-by": "^1.1.0",
     "hsts": "^2.2.0",
-    "http-errors": "^1.7.3",
+    "http-errors": "^1.7.1",
     "ienoopen": "^1.1.0",
     "license-checker": "^25.0.1",
-    "lolex": "^4.1.0",
+    "lolex": "^4.2.0",
     "pre-commit": "^1.2.2",
-    "proxyquire": "^2.1.0",
+    "proxyquire": "^2.1.3",
     "pump": "^3.0.0",
-    "semver": "^6.2.0",
+    "semver": "^6.3.0",
     "send": "^0.17.1",
     "serve-static": "^1.14.1",
     "simple-get": "^3.0.3",
     "snazzy": "^8.0.0",
     "split2": "^3.1.1",
-    "standard": "^12.0.1",
+    "standard": "^14.0.0",
     "tap": "^14.4.1",
     "tap-mocha-reporter": "^4.0.1",
     "then-sleep": "^1.0.1",
     "tsd": "^0.11.0",
-    "typescript": "^3.5.2",
+    "typescript": "^3.6.3",
     "x-xss-protection": "^1.2.0"
   },
   "dependencies": {
-    "abstract-logging": "^1.0.0",
-    "ajv": "^6.10.0",
-    "avvio": "^6.2.1",
-    "fast-json-stringify": "^1.15.3",
-    "find-my-way": "^2.1.0",
+    "abstract-logging": "^2.0.0",
+    "ajv": "^6.10.2",
+    "avvio": "^6.2.2",
+    "fast-json-stringify": "^1.15.5",
+    "find-my-way": "^2.2.0",
     "flatstr": "^1.0.12",
     "light-my-request": "^3.4.1",
     "middie": "^4.0.1",
-    "pino": "^5.12.6",
+    "pino": "^5.13.2",
     "proxy-addr": "^2.0.5",
     "readable-stream": "^3.4.0",
     "rfdc": "^1.1.4",
-    "secure-json-parse": "^1.0.0",
-    "tiny-lru": "^6.0.1"
+    "secure-json-parse": "^2.0.0",
+    "tiny-lru": "^7.0.0"
   },
   "greenkeeper": {
     "ignore": [
diff --git a/test/404s.test.js b/test/404s.test.js
index 3a304e92..7fa716c1 100644
--- a/test/404s.test.js
+++ b/test/404s.test.js
@@ -979,7 +979,7 @@ test('log debug for 404', t => {
 
       const INFO_LEVEL = 30
       t.strictEqual(JSON.parse(logStream.logs[0]).msg, 'incoming request')
-      t.strictEqual(JSON.parse(logStream.logs[1]).msg, 'Not Found')
+      t.strictEqual(JSON.parse(logStream.logs[1]).msg, 'Route GET:/not-found not found')
       t.strictEqual(JSON.parse(logStream.logs[1]).level, INFO_LEVEL)
       t.strictEqual(JSON.parse(logStream.logs[2]).msg, 'request completed')
       t.strictEqual(logStream.logs.length, 3)
@@ -1733,3 +1733,43 @@ test('Should fail to invoke callNotFound inside a 404 handler', t => {
     t.is(res.payload, '404 Not Found')
   })
 })
+
+test('400 in case of bad url (pre find-my-way v2.2.0 was a 404)', t => {
+  t.test('Dyamic route', t => {
+    t.plan(3)
+    const fastify = Fastify()
+    fastify.get('/hello/:id', () => t.fail('we should not be here'))
+    fastify.inject({
+      url: '/hello/%world',
+      method: 'GET'
+    }, (err, response) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 400)
+      t.deepEqual(JSON.parse(response.payload), {
+        error: 'Bad Request',
+        message: "'%world' is not a valid url component",
+        statusCode: 400
+      })
+    })
+  })
+
+  t.test('Wildcard', t => {
+    t.plan(3)
+    const fastify = Fastify()
+    fastify.get('*', () => t.fail('we should not be here'))
+    fastify.inject({
+      url: '/hello/%world',
+      method: 'GET'
+    }, (err, response) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 400)
+      t.deepEqual(JSON.parse(response.payload), {
+        error: 'Bad Request',
+        message: "'/hello/%world' is not a valid url component",
+        statusCode: 400
+      })
+    })
+  })
+
+  t.end()
+})
diff --git a/test/async-await.test.js b/test/async-await.test.js
index babc97c5..0d493798 100644
--- a/test/async-await.test.js
+++ b/test/async-await.test.js
@@ -418,7 +418,7 @@ test('error is not logged because promise was fulfilled with undefined but respo
 
   var fastify = null
   var stream = split(JSON.parse)
-  var payload = { 'hello': 'world' }
+  var payload = { hello: 'world' }
   try {
     fastify = Fastify({
       logger: {
diff --git a/test/close-pipelining.test.js b/test/close-pipelining.test.js
index ed0e722a..2881ef1e 100644
--- a/test/close-pipelining.test.js
+++ b/test/close-pipelining.test.js
@@ -28,8 +28,49 @@ test('Should return 503 while closing - pipelining', t => {
       t.strictEqual(statusCode, codes.shift())
     })
 
-    instance.on('done', () => t.end('Done'))
-    instance.on('reqError', () => t.deepEqual(codes.shift(), null))
+    instance.on('done', () => {
+      t.strictEqual(codes.length, 0)
+      t.end('Done')
+    })
+    instance.on('reqError', () => {
+      t.strictEqual(codes.shift(), undefined)
+    })
+    instance.on('error', err => t.fail(err))
+  })
+})
+
+test('Should not return 503 while closing - pipelining - return503OnClosing', t => {
+  const fastify = Fastify({
+    return503OnClosing: false
+  })
+
+  fastify.get('/', (req, reply) => {
+    fastify.close()
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    const instance = autocannon({
+      url: 'http://localhost:' + fastify.server.address().port,
+      pipelining: 1,
+      connections: 1,
+      amount: 10
+    })
+
+    const codes = [200, 200]
+    instance.on('response', (client, statusCode) => {
+      t.strictEqual(statusCode, codes.shift())
+    })
+
+    instance.on('done', () => {
+      t.strictEqual(codes.length, 0)
+      t.end('Done')
+    })
+    instance.on('reqError', () => {
+      t.strictEqual(codes.shift(), undefined)
+    })
     instance.on('error', err => t.fail(err))
   })
 })
diff --git a/test/close.test.js b/test/close.test.js
index 49d13e52..e7f76780 100644
--- a/test/close.test.js
+++ b/test/close.test.js
@@ -1,5 +1,6 @@
 'use strict'
 
+const net = require('net')
 const t = require('tap')
 const test = t.test
 const Fastify = require('..')
@@ -114,8 +115,8 @@ test('onClose should keep the context', t => {
   })
 })
 
-test('Should return 503 while closing - injection', t => {
-  t.plan(8)
+test('Should return error while closing - injection', t => {
+  t.plan(4)
   const fastify = Fastify()
 
   fastify.addHook('onClose', (instance, done) => {
@@ -139,17 +140,73 @@ test('Should return 503 while closing - injection', t => {
         method: 'GET',
         url: '/'
       }, (err, res) => {
-        t.error(err)
-        t.strictEqual(res.statusCode, 503)
-        t.strictEqual(res.headers['content-type'], 'application/json')
-        t.strictEqual(res.headers['content-length'], '80')
-        t.strictEqual(res.headers['connection'], 'close')
-        t.deepEqual(JSON.parse(res.payload), {
-          error: 'Service Unavailable',
-          message: 'Service Unavailable',
-          statusCode: 503
-        })
+        t.ok(err)
+        t.equal(err.message, 'Server is closed')
       })
     }, 100)
   })
 })
+
+t.test('Current opened connection should continue to work after closing and return "connection: close" header - return503OnClosing: false', t => {
+  const fastify = Fastify({
+    return503OnClosing: false
+  })
+
+  fastify.get('/', (req, reply) => {
+    fastify.close()
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    const port = fastify.server.address().port
+    const client = net.createConnection({ port: port }, () => {
+      client.write('GET / HTTP/1.1\r\n\r\n')
+
+      client.once('data', data => {
+        t.match(data.toString(), /Connection:\s*keep-alive/i)
+        t.match(data.toString(), /200 OK/i)
+
+        client.write('GET / HTTP/1.1\r\n\r\n')
+
+        client.once('data', data => {
+          t.match(data.toString(), /Connection:\s*close/i)
+          t.match(data.toString(), /200 OK/i)
+
+          // Test that fastify closes the TCP connection
+          client.once('close', () => {
+            t.end()
+          })
+        })
+      })
+    })
+  })
+})
+
+t.test('Current opened connection should not accept new incoming connections', t => {
+  const fastify = Fastify()
+
+  fastify.get('/', (req, reply) => {
+    fastify.close()
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+
+    const port = fastify.server.address().port
+    const client = net.createConnection({ port: port }, () => {
+      client.write('GET / HTTP/1.1\r\n\r\n')
+
+      const newConnection = net.createConnection({ port: port })
+      newConnection.on('error', err => {
+        t.ok(err)
+        t.ok(['ECONNREFUSED', 'ECONNRESET'].includes(err.code))
+
+        client.end()
+        t.end()
+      })
+    })
+  })
+})
diff --git a/test/content-length.test.js b/test/content-length.test.js
index 95c57318..eb48eb4e 100644
--- a/test/content-length.test.js
+++ b/test/content-length.test.js
@@ -34,7 +34,7 @@ test('default 413 with bodyLimit option', t => {
   })
 })
 
-test('default 413 with wrong content-length', t => {
+test('default 400 with wrong content-length', t => {
   t.plan(4)
 
   const fastify = Fastify()
@@ -102,7 +102,7 @@ test('custom 413 with bodyLimit option', t => {
   })
 })
 
-test('custom 413 with wrong content-length', t => {
+test('custom 400 with wrong content-length', t => {
   t.plan(4)
 
   const fastify = Fastify()
diff --git a/test/custom-parser.test.js b/test/custom-parser.test.js
index a43f1415..74878b4e 100644
--- a/test/custom-parser.test.js
+++ b/test/custom-parser.test.js
@@ -1066,7 +1066,7 @@ test('Wrong parseAs parameter', t => {
     t.fail('should throw')
   } catch (err) {
     t.is(err.code, 'FST_ERR_CTP_INVALID_PARSE_TYPE')
-    t.is(err.message, `The body parser can only parse your data as 'string' or 'buffer', you asked 'fireworks' which is not supported.`)
+    t.is(err.message, "The body parser can only parse your data as 'string' or 'buffer', you asked 'fireworks' which is not supported.")
   }
 })
 
diff --git a/test/custom-querystring-parser.test.js b/test/custom-querystring-parser.test.js
index a10e1822..9cf21ed5 100644
--- a/test/custom-querystring-parser.test.js
+++ b/test/custom-querystring-parser.test.js
@@ -131,7 +131,7 @@ test('Custom querystring parser should be a function', t => {
   } catch (err) {
     t.strictEqual(
       err.message,
-      `querystringParser option should be a function, instead got 'number'`
+      "querystringParser option should be a function, instead got 'number'"
     )
   }
 })
diff --git a/test/decorator.test.js b/test/decorator.test.js
index fddb2975..2c56d69b 100644
--- a/test/decorator.test.js
+++ b/test/decorator.test.js
@@ -1,5 +1,7 @@
 'use strict'
 
+/* eslint no-prototype-builtins: 0 */
+
 const t = require('tap')
 const test = t.test
 const Fastify = require('..')
@@ -659,3 +661,51 @@ test('a decorator should addSchema to all the encapsulated tree', t => {
 
   fastify.ready(t.error)
 })
+
+test('after can access to a decorated instance and previous plugin decoration', t => {
+  t.plan(11)
+  const TEST_VALUE = {}
+  const OTHER_TEST_VALUE = {}
+  const NEW_TEST_VALUE = {}
+
+  const fastify = Fastify()
+
+  fastify.register(fp(function (instance, options, next) {
+    instance.decorate('test', TEST_VALUE)
+
+    next()
+  })).after(function (err, instance, done) {
+    t.error(err)
+    t.equal(instance.test, TEST_VALUE)
+
+    instance.decorate('test2', OTHER_TEST_VALUE)
+    done()
+  })
+
+  fastify.register(fp(function (instance, options, next) {
+    t.equal(instance.test, TEST_VALUE)
+    t.equal(instance.test2, OTHER_TEST_VALUE)
+
+    instance.decorate('test3', NEW_TEST_VALUE)
+
+    next()
+  })).after(function (err, instance, done) {
+    t.error(err)
+    t.equal(instance.test, TEST_VALUE)
+    t.equal(instance.test2, OTHER_TEST_VALUE)
+    t.equal(instance.test3, NEW_TEST_VALUE)
+
+    done()
+  })
+
+  fastify.get('/', function (req, res) {
+    t.equal(this.test, TEST_VALUE)
+    t.equal(this.test2, OTHER_TEST_VALUE)
+    res.send({})
+  })
+
+  fastify.inject('/')
+    .then(response => {
+      t.equal(response.statusCode, 200)
+    })
+})
diff --git a/test/fastify-instance.test.js b/test/fastify-instance.test.js
index 25193a71..6fe314e2 100644
--- a/test/fastify-instance.test.js
+++ b/test/fastify-instance.test.js
@@ -3,8 +3,37 @@
 const t = require('tap')
 const test = t.test
 const Fastify = require('..')
+const {
+  kOptions
+} = require('../lib/symbols')
 
 test('root fastify instance is an object', t => {
   t.plan(1)
   t.type(Fastify(), 'object')
 })
+
+test('fastify instance should contains ajv options', t => {
+  t.plan(1)
+  const fastify = Fastify({
+    ajv: {
+      customOptions: {
+        nullable: false
+      }
+    }
+  })
+  t.same(fastify[kOptions].ajv, {
+    customOptions: {
+      nullable: false
+    },
+    plugins: []
+  })
+})
+
+test('fastify instance get invalid ajv options', t => {
+  t.plan(1)
+  t.throw(() => Fastify({
+    ajv: {
+      customOptions: 8
+    }
+  }))
+})
diff --git a/test/helper.js b/test/helper.js
index a0600458..4765772d 100644
--- a/test/helper.js
+++ b/test/helper.js
@@ -221,7 +221,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
     })
 
     if (loMethod === 'options') {
-      test(`OPTIONS returns 415 - should return 415 if Content-Type is not json or plain text`, t => {
+      test('OPTIONS returns 415 - should return 415 if Content-Type is not json or plain text', t => {
         t.plan(2)
         sget({
           method: upMethod,
@@ -328,7 +328,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(res.payload), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
@@ -344,7 +344,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(body.toString()), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
@@ -361,7 +361,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(res.payload), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
@@ -378,7 +378,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(body.toString()), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
@@ -395,7 +395,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(res.payload), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
@@ -412,7 +412,7 @@ module.exports.payloadMethod = function (method, t, isSetErrorHandler = false) {
         t.strictDeepEqual(JSON.parse(body.toString()), {
           error: 'Bad Request',
           code: 'FST_ERR_CTP_EMPTY_JSON_BODY',
-          message: `Body cannot be empty when content-type is set to 'application/json'`,
+          message: 'Body cannot be empty when content-type is set to \'application/json\'',
           statusCode: 400
         })
       })
diff --git a/test/hooks-async.test.js b/test/hooks-async.test.js
index 2416d56f..0089dbe1 100644
--- a/test/hooks-async.test.js
+++ b/test/hooks-async.test.js
@@ -438,7 +438,7 @@ test('Should log a warning if is an async function with `done`', t => {
     try {
       fastify.addHook('onRequest', async (req, reply, done) => {})
     } catch (e) {
-      t.true(e.message === `Async function has too many arguments. Async hooks should not use the 'done' argument.`)
+      t.true(e.message === 'Async function has too many arguments. Async hooks should not use the \'done\' argument.')
     }
   })
 
@@ -449,12 +449,12 @@ test('Should log a warning if is an async function with `done`', t => {
     try {
       fastify.addHook('onSend', async (req, reply, payload, done) => {})
     } catch (e) {
-      t.true(e.message === `Async function has too many arguments. Async hooks should not use the 'done' argument.`)
+      t.true(e.message === 'Async function has too many arguments. Async hooks should not use the \'done\' argument.')
     }
     try {
       fastify.addHook('preSerialization', async (req, reply, payload, done) => {})
     } catch (e) {
-      t.true(e.message === `Async function has too many arguments. Async hooks should not use the 'done' argument.`)
+      t.true(e.message === 'Async function has too many arguments. Async hooks should not use the \'done\' argument.')
     }
   })
 
diff --git a/test/hooks.test.js b/test/hooks.test.js
index 0c3c2de2..24aae971 100644
--- a/test/hooks.test.js
+++ b/test/hooks.test.js
@@ -13,7 +13,7 @@ const symbols = require('../lib/symbols.js')
 const payload = { hello: 'world' }
 
 test('hooks', t => {
-  t.plan(37)
+  t.plan(38)
   const fastify = Fastify()
 
   try {
@@ -98,6 +98,9 @@ test('hooks', t => {
       t.is(reply.test, 'the reply has come')
       reply.code(200).send(payload)
     },
+    onResponse: function (req, reply, done) {
+      t.ok('onResponse inside hook')
+    },
     response: {
       200: {
         type: 'object'
@@ -484,7 +487,7 @@ test('onRoute hook should pass correct route with custom prefix', t => {
 })
 
 test('onRoute hook should pass correct route with custom options', t => {
-  t.plan(5)
+  t.plan(6)
   const fastify = Fastify()
   fastify.register((instance, opts, done) => {
     instance.addHook('onRoute', function (route) {
@@ -492,8 +495,15 @@ test('onRoute hook should pass correct route with custom options', t => {
       t.strictEqual(route.url, '/foo')
       t.strictEqual(route.logLevel, 'info')
       t.strictEqual(route.bodyLimit, 100)
+      t.type(route.logSerializers.test, 'function')
     })
-    instance.get('/foo', { logLevel: 'info', bodyLimit: 100 }, function (req, reply) {
+    instance.get('/foo', {
+      logLevel: 'info',
+      bodyLimit: 100,
+      logSerializers: {
+        test: value => value
+      }
+    }, function (req, reply) {
       reply.send()
     })
     done()
@@ -563,6 +573,25 @@ test('onRoute hook should preserve handler function in options of shorthand rout
   })
 })
 
+test('onRoute hook that throws should be caught ', t => {
+  t.plan(1)
+  const fastify = Fastify()
+
+  fastify.register((instance, opts, next) => {
+    instance.addHook('onRoute', () => {
+      throw new Error('snap')
+    })
+    instance.get('/', opts, function (req, reply) {
+      reply.send()
+    })
+    next()
+  })
+
+  fastify.ready(err => {
+    t.ok(err)
+  })
+})
+
 test('onResponse hook should log request error', t => {
   t.plan(4)
 
@@ -1915,7 +1944,7 @@ test('request in onRequest, preParsing, preValidation and onResponse', t => {
     t.deepEqual(request.headers, {
       'content-length': '17',
       'content-type': 'application/json',
-      'host': 'localhost:80',
+      host: 'localhost:80',
       'user-agent': 'lightMyRequest',
       'x-custom': 'hello'
     })
@@ -1929,7 +1958,7 @@ test('request in onRequest, preParsing, preValidation and onResponse', t => {
     t.deepEqual(request.headers, {
       'content-length': '17',
       'content-type': 'application/json',
-      'host': 'localhost:80',
+      host: 'localhost:80',
       'user-agent': 'lightMyRequest',
       'x-custom': 'hello'
     })
@@ -1943,7 +1972,7 @@ test('request in onRequest, preParsing, preValidation and onResponse', t => {
     t.deepEqual(request.headers, {
       'content-length': '17',
       'content-type': 'application/json',
-      'host': 'localhost:80',
+      host: 'localhost:80',
       'user-agent': 'lightMyRequest',
       'x-custom': 'hello'
     })
@@ -1957,7 +1986,7 @@ test('request in onRequest, preParsing, preValidation and onResponse', t => {
     t.deepEqual(request.headers, {
       'content-length': '17',
       'content-type': 'application/json',
-      'host': 'localhost:80',
+      host: 'localhost:80',
       'user-agent': 'lightMyRequest',
       'x-custom': 'hello'
     })
diff --git a/test/http2/closing.test.js b/test/http2/closing.test.js
index c69529cd..576b1bad 100644
--- a/test/http2/closing.test.js
+++ b/test/http2/closing.test.js
@@ -1,48 +1,101 @@
 'use strict'
 
 const t = require('tap')
-const test = t.test
 const Fastify = require('../..')
 const http2 = require('http2')
 const semver = require('semver')
 
-let fastify
-try {
-  fastify = Fastify({
-    http2: true
-  })
-  t.pass('http2 successfully loaded')
-} catch (e) {
-  t.fail('http2 loading failed', e)
-}
-
-fastify.listen(0, err => {
-  t.error(err)
-  fastify.server.unref()
-
-  // Skipped because there is likely a bug on Node 8.
-  test('http/2 request while fastify closing', { skip: semver.lt(process.versions.node, '10.15.0') }, t => {
-    const url = `http://127.0.0.1:${fastify.server.address().port}`
-    const session = http2.connect(url, function () {
-      this.request({
-        ':method': 'GET',
-        ':path': '/'
-      }).on('response', headers => {
-        t.strictEqual(headers[':status'], 503)
-        t.end()
-        this.destroy()
-      }).on('error', () => {
+t.test('http/2 request while fastify closing', t => {
+  let fastify
+  try {
+    fastify = Fastify({
+      http2: true
+    })
+    t.pass('http2 successfully loaded')
+  } catch (e) {
+    t.fail('http2 loading failed', e)
+  }
+
+  fastify.get('/', () => Promise.resolve({}))
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.server.unref()
+
+    // Skipped because there is likely a bug on Node 8.
+    t.test('return 200', { skip: semver.lt(process.versions.node, '10.15.0') }, t => {
+      const url = `http://127.0.0.1:${fastify.server.address().port}`
+      const session = http2.connect(url, function () {
+        this.request({
+          ':method': 'GET',
+          ':path': '/'
+        }).on('response', headers => {
+          t.strictEqual(headers[':status'], 503)
+          t.end()
+          this.destroy()
+        }).on('error', () => {
+          // Nothing to do here,
+          // we are not interested in this error that might
+          // happen or not
+        })
+        fastify.close()
+      })
+      session.on('error', () => {
         // Nothing to do here,
         // we are not interested in this error that might
         // happen or not
+        t.end()
       })
-      fastify.close()
     })
-    session.on('error', () => {
-      // Nothing to do here,
-      // we are not interested in this error that might
-      // happen or not
-      t.end()
+
+    t.end()
+  })
+})
+
+t.test('http/2 request while fastify closing - return503OnClosing: false', t => {
+  let fastify
+  try {
+    fastify = Fastify({
+      http2: true,
+      return503OnClosing: false
     })
+    t.pass('http2 successfully loaded')
+  } catch (e) {
+    t.fail('http2 loading failed', e)
+  }
+
+  fastify.get('/', () => Promise.resolve({}))
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.server.unref()
+
+    // Skipped because there is likely a bug on Node 8.
+    t.test('return 200', { skip: semver.lt(process.versions.node, '10.15.0') }, t => {
+      const url = `http://127.0.0.1:${fastify.server.address().port}`
+      const session = http2.connect(url, function () {
+        this.request({
+          ':method': 'GET',
+          ':path': '/'
+        }).on('response', headers => {
+          t.strictEqual(headers[':status'], 200)
+          t.end()
+          this.destroy()
+        }).on('error', () => {
+          // Nothing to do here,
+          // we are not interested in this error that might
+          // happen or not
+        })
+        fastify.close()
+      })
+      session.on('error', () => {
+        // Nothing to do here,
+        // we are not interested in this error that might
+        // happen or not
+        t.end()
+      })
+    })
+
+    t.end()
   })
 })
diff --git a/test/input-validation.test.js b/test/input-validation.test.js
index 45011b53..075928df 100644
--- a/test/input-validation.test.js
+++ b/test/input-validation.test.js
@@ -3,6 +3,7 @@
 const t = require('tap')
 const test = t.test
 const Fastify = require('..')
+const ajvMergePatch = require('ajv-merge-patch')
 
 test('case insensitive header validation', t => {
   t.plan(2)
@@ -27,7 +28,7 @@ test('case insensitive header validation', t => {
     method: 'GET',
     url: '/',
     headers: {
-      'FooBar': 'Baz'
+      FooBar: 'Baz'
     }
   }, (err, res) => {
     t.error(err)
@@ -67,3 +68,128 @@ test('not evaluate json-schema $schema keyword', t => {
     t.equal(res.payload, 'world')
   })
 })
+
+test('Should handle $merge keywords in body', t => {
+  t.plan(5)
+  const fastify = Fastify({
+    ajv: {
+      plugins: [
+        ajvMergePatch
+      ]
+    }
+  })
+
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {
+      body: {
+        $merge: {
+          source: {
+            type: 'object',
+            properties: {
+              q: {
+                type: 'string'
+              }
+            }
+          },
+          with: {
+            required: ['q']
+          }
+        }
+      }
+    },
+    handler (req, reply) {
+      reply.send({ ok: 1 })
+    }
+  })
+
+  fastify.ready(err => {
+    t.error(err)
+
+    fastify.inject({
+      method: 'POST',
+      url: '/'
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      body: {
+        q: 'foo'
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+    })
+  })
+})
+
+test('Should handle $patch keywords in body', t => {
+  t.plan(5)
+  const fastify = Fastify({
+    ajv: {
+      plugins: [
+        ajvMergePatch
+      ]
+    }
+  })
+
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {
+      body: {
+        $patch: {
+          source: {
+            type: 'object',
+            properties: {
+              q: {
+                type: 'string'
+              }
+            }
+          },
+          with: [
+            {
+              op: 'add',
+              path: '/properties/q',
+              value: { type: 'number' }
+            }
+          ]
+        }
+      }
+    },
+    handler (req, reply) {
+      reply.send({ ok: 1 })
+    }
+  })
+
+  fastify.ready(err => {
+    t.error(err)
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      body: {
+        q: 'foo'
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      body: {
+        q: 10
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+    })
+  })
+})
diff --git a/test/internals/decorator.test.js b/test/internals/decorator.test.js
index e9aee9d4..20401f81 100644
--- a/test/internals/decorator.test.js
+++ b/test/internals/decorator.test.js
@@ -1,5 +1,7 @@
 'use strict'
 
+/* eslint no-prototype-builtins: 0 */
+
 const t = require('tap')
 const test = t.test
 const decorator = require('../../lib/decorate')
diff --git a/test/internals/errors.test.js b/test/internals/errors.test.js
index 15c39b55..df4a63cd 100644
--- a/test/internals/errors.test.js
+++ b/test/internals/errors.test.js
@@ -78,7 +78,7 @@ test('Should throw when error code has no message', t => {
   try {
     createError('code')
   } catch (err) {
-    t.equal(err.message, `Fastify error message must not be empty`)
+    t.equal(err.message, 'Fastify error message must not be empty')
   }
 })
 
diff --git a/test/internals/initialConfig.test.js b/test/internals/initialConfig.test.js
index 8feacb43..964da362 100644
--- a/test/internals/initialConfig.test.js
+++ b/test/internals/initialConfig.test.js
@@ -25,6 +25,7 @@ test('without options passed to Fastify, initialConfig should expose default val
     ignoreTrailingSlash: false,
     maxParamLength: 100,
     onProtoPoisoning: 'error',
+    onConstructorPoisoning: 'ignore',
     pluginTimeout: 10000,
     requestIdHeader: 'request-id',
     requestIdLogLabel: 'reqId'
@@ -55,12 +56,12 @@ test('Fastify.initialConfig should expose all options', t => {
       }
     },
     deriveVersion: (req, ctx) => {
-      return req.headers['accept']
+      return req.headers.accept
     }
   }
 
   let reqId = 0
-  let options = {
+  const options = {
     http2: true,
     https: {
       key: fs.readFileSync(path.join(__dirname, '..', 'https', 'fastify.key')),
@@ -153,7 +154,7 @@ test('Return an error if options do not match the validation schema', t => {
   } catch (error) {
     t.type(error, Error)
     t.equal(error.name, 'FastifyError')
-    t.equal(error.message, `Invalid initialization options: '["should be boolean"]'`)
+    t.equal(error.message, 'Invalid initialization options: \'["should be boolean"]\'')
     t.equal(error.code, 'FST_ERR_INIT_OPTS_INVALID')
     t.ok(error.stack)
     t.pass()
@@ -228,6 +229,7 @@ test('Should not have issues when passing stream options to Pino.js', t => {
       ignoreTrailingSlash: true,
       maxParamLength: 100,
       onProtoPoisoning: 'error',
+      onConstructorPoisoning: 'ignore',
       pluginTimeout: 10000,
       requestIdHeader: 'request-id',
       requestIdLogLabel: 'reqId'
diff --git a/test/internals/plugin.test.js b/test/internals/plugin.test.js
index 02a7a944..1c7012f9 100644
--- a/test/internals/plugin.test.js
+++ b/test/internals/plugin.test.js
@@ -7,7 +7,7 @@ const pluginUtilsPublic = require('../../lib/pluginUtils.js')
 const pluginUtils = require('../../lib/pluginUtils')[Symbol.for('internals')]
 const symbols = require('../../lib/symbols.js')
 
-test(`shouldSkipOverride should check the 'skip-override' symbol`, t => {
+test("shouldSkipOverride should check the 'skip-override' symbol", t => {
   t.plan(2)
 
   yes[Symbol.for('skip-override')] = true
@@ -19,7 +19,7 @@ test(`shouldSkipOverride should check the 'skip-override' symbol`, t => {
   function no () {}
 })
 
-test(`getMeta should return the object stored with the 'plugin-meta' symbol`, t => {
+test("getMeta should return the object stored with the 'plugin-meta' symbol", t => {
   t.plan(1)
 
   const meta = { hello: 'world' }
@@ -76,7 +76,7 @@ test('checkDecorators should check if the given decorator is present in the inst
     pluginUtils.checkDecorators.call(context, fn)
     t.fail('should throw')
   } catch (err) {
-    t.is(err.message, `The decorator 'plugin' is not present in Request`)
+    t.is(err.message, "The decorator 'plugin' is not present in Request")
   }
 
   function fn () {}
@@ -117,7 +117,7 @@ test('checkDependencies should check if the given dependency is present in the i
     pluginUtils.checkDependencies.call(context, fn)
     t.fail('should throw')
   } catch (err) {
-    t.is(err.message, `The dependency 'plugin' of plugin 'test-plugin' is not registered`)
+    t.is(err.message, "The dependency 'plugin' of plugin 'test-plugin' is not registered")
   }
 
   function fn () {}
diff --git a/test/internals/reply.test.js b/test/internals/reply.test.js
index a1b08fa0..d4b5f3b8 100644
--- a/test/internals/reply.test.js
+++ b/test/internals/reply.test.js
@@ -6,6 +6,7 @@ const sget = require('simple-get').concat
 const http = require('http')
 const NotFound = require('http-errors').NotFound
 const Reply = require('../../lib/reply')
+const { Writable } = require('readable-stream')
 const {
   kReplyErrorHandlerCalled,
   kReplyHeaders,
@@ -14,7 +15,7 @@ const {
 } = require('../../lib/symbols')
 
 test('Once called, Reply should return an object with methods', t => {
-  t.plan(12)
+  t.plan(13)
   const response = { res: 'res' }
   function context () {}
   function request () {}
@@ -27,6 +28,7 @@ test('Once called, Reply should return an object with methods', t => {
   t.is(typeof reply.status, 'function')
   t.is(typeof reply.header, 'function')
   t.is(typeof reply.serialize, 'function')
+  t.is(typeof reply.getResponseTime, 'function')
   t.is(typeof reply[kReplyHeaders], 'object')
   t.strictEqual(reply.res, response)
   t.strictEqual(reply.context, context)
@@ -35,14 +37,32 @@ test('Once called, Reply should return an object with methods', t => {
 
 test('reply.send throw with circular JSON', t => {
   t.plan(1)
-  const request = {}
-  const response = { setHeader: () => {} }
-  const reply = new Reply(request, response, null)
+  const response = {
+    setHeader: () => {},
+    hasHeader: () => false,
+    getHeader: () => undefined,
+    writeHead: () => {},
+    end: () => {}
+  }
+  const reply = new Reply(response, { onSend: [] }, null)
   t.throws(() => {
     var obj = {}
     obj.obj = obj
     reply.send(JSON.stringify(obj))
-  })
+  }, 'Converting circular structure to JSON')
+})
+
+test('reply.send returns itself', t => {
+  t.plan(1)
+  const response = {
+    setHeader: () => {},
+    hasHeader: () => false,
+    getHeader: () => undefined,
+    writeHead: () => {},
+    end: () => {}
+  }
+  const reply = new Reply(response, { onSend: [] }, null)
+  t.equal(reply.send('hello'), reply)
 })
 
 test('reply.serializer should set a custom serializer', t => {
@@ -261,7 +281,7 @@ test('within an instance', t => {
       http.get(url, (response) => {
         t.strictEqual(response.headers['x-onsend'], 'yes')
         t.strictEqual(response.headers['content-length'], '0')
-        t.strictEqual(response.headers['location'], '/')
+        t.strictEqual(response.headers.location, '/')
       })
     })
 
@@ -418,7 +438,7 @@ test('stream using reply.res.writeHead should return customize headers', t => {
       url: 'http://localhost:' + fastify.server.address().port
     }, (err, response, body) => {
       t.error(err)
-      t.strictEqual(response.headers['location'], '/')
+      t.strictEqual(response.headers.location, '/')
       t.strictEqual(response.headers['Content-Type'], undefined)
       t.deepEqual(body, buf)
     })
@@ -904,6 +924,23 @@ test('.status() is an alias for .code()', t => {
   })
 })
 
+test('.statusCode is getter and setter', t => {
+  t.plan(4)
+  const fastify = require('../..')()
+
+  fastify.get('/', function (req, reply) {
+    t.ok(reply.statusCode, 200, 'default status value')
+    reply.statusCode = 418
+    t.ok(reply.statusCode, 418)
+    reply.send()
+  })
+
+  fastify.inject('/', (err, res) => {
+    t.error(err)
+    t.is(res.statusCode, 418)
+  })
+})
+
 test('reply.header setting multiple cookies as multiple Set-Cookie headers', t => {
   t.plan(7)
 
@@ -979,3 +1016,313 @@ test('should throw error when attempting to set reply.sent more than once', t =>
     t.pass()
   })
 })
+
+test('reply.getResponseTime() should return 0 before the timer is initialised on the reply by setting up response listeners', t => {
+  t.plan(1)
+  const response = { statusCode: 200 }
+  const context = {}
+  const reply = new Reply(response, context, null)
+  t.equal(reply.getResponseTime(), 0)
+})
+
+test('reply.getResponseTime() should return a number greater than 0 after the timer is initialised on the reply by setting up response listeners', t => {
+  t.plan(1)
+  const fastify = require('../..')()
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    handler: (req, reply) => {
+      reply.send('hello world')
+    }
+  })
+
+  fastify.addHook('onResponse', (req, reply) => {
+    t.true(reply.getResponseTime() > 0)
+    t.end()
+  })
+
+  fastify.inject({ method: 'GET', url: '/' })
+})
+
+test('reply should use the custom serializer', t => {
+  t.plan(4)
+  const fastify = require('../..')()
+  fastify.setReplySerializer((payload, statusCode) => {
+    t.deepEqual(payload, { foo: 'bar' })
+    t.equal(statusCode, 200)
+    payload.foo = 'bar bar'
+    return JSON.stringify(payload)
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    handler: (req, reply) => {
+      reply.send({ foo: 'bar' })
+    }
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"foo":"bar bar"}')
+  })
+})
+
+test('reply should use the right serializer in encapsulated context', t => {
+  t.plan(9)
+
+  const fastify = require('../..')()
+  fastify.setReplySerializer((payload) => {
+    t.deepEqual(payload, { foo: 'bar' })
+    payload.foo = 'bar bar'
+    return JSON.stringify(payload)
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    handler: (req, reply) => { reply.send({ foo: 'bar' }) }
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.route({
+      method: 'GET',
+      url: '/sub',
+      handler: (req, reply) => { reply.send({ john: 'doo' }) }
+    })
+    instance.setReplySerializer((payload) => {
+      t.deepEqual(payload, { john: 'doo' })
+      payload.john = 'too too'
+      return JSON.stringify(payload)
+    })
+    next()
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.route({
+      method: 'GET',
+      url: '/sub',
+      handler: (req, reply) => { reply.send({ sweet: 'potato' }) }
+    })
+    instance.setReplySerializer((payload) => {
+      t.deepEqual(payload, { sweet: 'potato' })
+      payload.sweet = 'potato potato'
+      return JSON.stringify(payload)
+    })
+    next()
+  }, { prefix: 'sub' })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"foo":"bar bar"}')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/sub'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"john":"too too"}')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/sub/sub'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"sweet":"potato potato"}')
+  })
+})
+
+test('reply should use the right serializer in deep encapsulated context', t => {
+  t.plan(8)
+
+  const fastify = require('../..')()
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    handler: (req, reply) => { reply.send({ foo: 'bar' }) }
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.route({
+      method: 'GET',
+      url: '/sub',
+      handler: (req, reply) => { reply.send({ john: 'doo' }) }
+    })
+    instance.setReplySerializer((payload) => {
+      t.deepEqual(payload, { john: 'doo' })
+      payload.john = 'too too'
+      return JSON.stringify(payload)
+    })
+
+    instance.register(function (subInstance, opts, next) {
+      subInstance.route({
+        method: 'GET',
+        url: '/deep',
+        handler: (req, reply) => { reply.send({ john: 'deep' }) }
+      })
+      subInstance.setReplySerializer((payload) => {
+        t.deepEqual(payload, { john: 'deep' })
+        payload.john = 'deep deep'
+        return JSON.stringify(payload)
+      })
+      next()
+    })
+    next()
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"foo":"bar"}')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/sub'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"john":"too too"}')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/deep'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"john":"deep deep"}')
+  })
+})
+
+test('reply should use the route serializer', t => {
+  t.plan(3)
+
+  const fastify = require('../..')()
+  fastify.setReplySerializer(() => {
+    t.fail('this serializer should not be executed')
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    handler: (req, reply) => {
+      reply
+        .serializer((payload) => {
+          t.deepEqual(payload, { john: 'doo' })
+          payload.john = 'too too'
+          return JSON.stringify(payload)
+        })
+        .send({ john: 'doo' })
+    }
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.payload, '{"john":"too too"}')
+  })
+})
+
+test('cannot set the replySerializer when the server is running', t => {
+  t.plan(2)
+
+  const fastify = require('../..')()
+  t.teardown(fastify.close.bind(fastify))
+
+  fastify.listen(err => {
+    t.error(err)
+    try {
+      fastify.setReplySerializer(() => {})
+      t.fail('this serializer should not be setup')
+    } catch (e) {
+      t.is(e.message, 'Cannot call "setReplySerializer" when fastify instance is already started!')
+    }
+  })
+})
+
+test('reply should not call the custom serializer for errors and not found', t => {
+  t.plan(9)
+
+  const fastify = require('../..')()
+  fastify.setReplySerializer((payload, statusCode) => {
+    t.deepEqual(payload, { foo: 'bar' })
+    t.equal(statusCode, 200)
+    return JSON.stringify(payload)
+  })
+
+  fastify.get('/', (req, reply) => { reply.send({ foo: 'bar' }) })
+  fastify.get('/err', (req, reply) => { reply.send(new Error('an error')) })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.strictEqual(res.payload, '{"foo":"bar"}')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/err'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 500)
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/not-existing'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 404)
+  })
+})
+
+test('reply.then', t => {
+  t.plan(2)
+
+  function context () {}
+  function request () {}
+
+  t.test('without an error', t => {
+    t.plan(1)
+
+    const response = new Writable()
+    const reply = new Reply(response, context, request)
+
+    reply.then(function () {
+      t.pass('fullfilled called')
+    })
+
+    response.destroy()
+  })
+
+  t.test('with an error', t => {
+    t.plan(1)
+
+    const response = new Writable()
+    const reply = new Reply(response, context, request)
+    const _err = new Error('kaboom')
+
+    reply.then(function () {
+      t.fail('fullfilled called')
+    }, function (err) {
+      t.equal(err, _err)
+    })
+
+    response.destroy(_err)
+  })
+})
diff --git a/test/internals/schemas.test.js b/test/internals/schemas.test.js
new file mode 100644
index 00000000..990294da
--- /dev/null
+++ b/test/internals/schemas.test.js
@@ -0,0 +1,30 @@
+'use strict'
+
+const test = require('tap').test
+const { Schemas } = require('../../lib/schemas')
+
+test('Should not change resolved schema', t => {
+  t.plan(4)
+
+  const schemas = new Schemas()
+  schemas.add({
+    $id: 'A',
+    field: 'value'
+  })
+  const schema = {
+    a: 'A#'
+  }
+  const resolvedSchema = schemas.resolveRefs(schema)
+
+  t.same(resolvedSchema.a, {
+    field: 'value'
+  })
+  t.same(resolvedSchema.$id, undefined)
+
+  schemas.getJsonSchemas()
+
+  t.same(resolvedSchema.a, {
+    field: 'value'
+  })
+  t.same(resolvedSchema.$id, undefined)
+})
diff --git a/test/internals/validation.test.js b/test/internals/validation.test.js
index f33f0b14..1cbe5c6a 100644
--- a/test/internals/validation.test.js
+++ b/test/internals/validation.test.js
@@ -74,6 +74,37 @@ test('build schema - payload schema', t => {
   t.is(typeof opts[symbols.bodySchema], 'function')
 })
 
+test('build schema - query schema', t => {
+  t.plan(2)
+  const opts = {
+    schema: {
+      query: {
+        type: 'object',
+        properties: {
+          hello: { type: 'string' }
+        }
+      }
+    }
+  }
+  validation.build(opts, schema => ajv.compile(schema), new Schemas())
+  t.type(opts[symbols.querystringSchema].schema.type, 'string')
+  t.is(typeof opts[symbols.querystringSchema], 'function')
+})
+
+test('build schema - query schema abbreviated', t => {
+  t.plan(2)
+  const opts = {
+    schema: {
+      query: {
+        hello: { type: 'string' }
+      }
+    }
+  }
+  validation.build(opts, schema => ajv.compile(schema), new Schemas())
+  t.type(opts[symbols.querystringSchema].schema.type, 'string')
+  t.is(typeof opts[symbols.querystringSchema], 'function')
+})
+
 test('build schema - querystring schema', t => {
   t.plan(2)
   const opts = {
@@ -105,6 +136,32 @@ test('build schema - querystring schema abbreviated', t => {
   t.is(typeof opts[symbols.querystringSchema], 'function')
 })
 
+test('build schema - must throw if querystring and query schema exist', t => {
+  t.plan(2)
+  try {
+    const opts = {
+      schema: {
+        query: {
+          type: 'object',
+          properties: {
+            hello: { type: 'string' }
+          }
+        },
+        querystring: {
+          type: 'object',
+          properties: {
+            hello: { type: 'string' }
+          }
+        }
+      }
+    }
+    validation.build(opts, schema => ajv.compile(schema), new Schemas())
+  } catch (err) {
+    t.is(err.code, 'FST_ERR_SCH_DUPLICATE')
+    t.is(err.message, 'Schema with \'querystring\' already present!')
+  }
+})
+
 test('build schema - params schema', t => {
   t.plan(1)
   const opts = {
@@ -169,3 +226,21 @@ test('build schema - headers are not lowercased in case of custom object', t =>
     return () => {}
   }, new Schemas())
 })
+
+test('build schema - uppercased headers are not included', t => {
+  t.plan(1)
+  const opts = {
+    schema: {
+      headers: {
+        type: 'object',
+        properties: {
+          'Content-Type': { type: 'string' }
+        }
+      }
+    }
+  }
+  validation.build(opts, schema => {
+    t.notOk('Content-Type' in schema.properties, 'uppercase does not exist')
+    return () => {}
+  }, new Schemas())
+})
diff --git a/test/listen.test.js b/test/listen.test.js
index e8d01c98..89925ae9 100644
--- a/test/listen.test.js
+++ b/test/listen.test.js
@@ -190,7 +190,7 @@ if (os.platform() !== 'win32') {
     const fastify = Fastify()
     t.tearDown(fastify.close.bind(fastify))
 
-    const sockFile = path.join(os.tmpdir(), 'server.sock')
+    const sockFile = path.join(os.tmpdir(), `${(Math.random().toString(16) + '0000000').substr(2, 8)}-server.sock`)
     try {
       fs.unlinkSync(sockFile)
     } catch (e) { }
diff --git a/test/logger.test.js b/test/logger.test.js
index b3367060..0590eb36 100644
--- a/test/logger.test.js
+++ b/test/logger.test.js
@@ -567,6 +567,40 @@ test('Should set a custom logLevel for a plugin', t => {
   })
 })
 
+test('Should set a custom logSerializers for a plugin', t => {
+  t.plan(3)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, 'XHello')
+    }
+  })
+
+  const logger = pino({ level: 'error' }, splitStream)
+
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.get('/plugin', (req, reply) => {
+      req.log.info({ test: 'Hello' }) // we should see this log
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }, { logLevel: 'info', logSerializers: { test: value => 'X' + value } })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/plugin'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
 test('Should set a custom logLevel for every plugin', t => {
   const lines = ['incoming request', 'request completed', 'info', 'debug']
   t.plan(18)
@@ -634,6 +668,281 @@ test('Should set a custom logLevel for every plugin', t => {
   })
 })
 
+test('Should set a custom logSerializers for every plugin', t => {
+  const lines = ['Hello', 'XHello', 'ZHello']
+  t.plan(9)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, lines.shift())
+    }
+  })
+
+  const logger = pino({ level: 'info' }, splitStream)
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.get('/', (req, reply) => {
+    req.log.warn({ test: 'Hello' })
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.get('/test1', (req, reply) => {
+      req.log.info({ test: 'Hello' })
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }, { logSerializers: { test: value => 'X' + value } })
+
+  fastify.register(function (instance, opts, next) {
+    instance.get('/test2', (req, reply) => {
+      req.log.info({ test: 'Hello' })
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }, { logSerializers: { test: value => 'Z' + value } })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/test1'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/test2'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
+test('Should override serializers from route', t => {
+  t.plan(3)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, 'ZHello')
+    }
+  })
+
+  const logger = pino({ level: 'info' }, splitStream)
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.get('/', {
+      logSerializers: {
+        test: value => 'Z' + value // should override
+      }
+    }, (req, reply) => {
+      req.log.info({ test: 'Hello' })
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }, { logSerializers: { test: value => 'X' + value } })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
+test('Should override serializers from plugin', t => {
+  t.plan(3)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, 'ZHello')
+    }
+  })
+
+  const logger = pino({ level: 'info' }, splitStream)
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.register(function (instance, opts, next) {
+    instance.register(context1, {
+      logSerializers: {
+        test: value => 'Z' + value // should override
+      }
+    })
+    next()
+  }, { logSerializers: { test: value => 'X' + value } })
+
+  function context1 (instance, opts, next) {
+    instance.get('/', (req, reply) => {
+      req.log.info({ test: 'Hello' })
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
+test('Should use serializers from plugin and route', t => {
+  t.plan(4)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, 'XHello')
+    }
+    if (line.test2) {
+      t.is(line.test2, 'ZHello')
+    }
+  })
+
+  const logger = pino({ level: 'info' }, splitStream)
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.register(context1, {
+    logSerializers: { test: value => 'X' + value }
+  })
+
+  function context1 (instance, opts, next) {
+    instance.get('/', {
+      logSerializers: {
+        test2: value => 'Z' + value
+      }
+    }, (req, reply) => {
+      req.log.info({ test: 'Hello', test2: 'Hello' }) // { test: 'XHello', test2: 'ZHello' }
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
+test('Should use serializers from instance fastify and route', t => {
+  t.plan(4)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test) {
+      t.is(line.test, 'XHello')
+    }
+    if (line.test2) {
+      t.is(line.test2, 'ZHello')
+    }
+  })
+
+  const logger = pino({
+    level: 'info',
+    serializers: {
+      test: value => 'X' + value,
+      test2: value => 'This should be override - ' + value
+    }
+  }, splitStream)
+  const fastify = Fastify({
+    logger
+  })
+
+  fastify.get('/', {
+    logSerializers: {
+      test2: value => 'Z' + value
+    }
+  }, (req, reply) => {
+    req.log.info({ test: 'Hello', test2: 'Hello' }) // { test: 'XHello', test2: 'ZHello' }
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
+test('Should use serializers inherit from contexts', t => {
+  t.plan(5)
+
+  const splitStream = split(JSON.parse)
+  splitStream.on('data', (line) => {
+    if (line.test && line.test2 && line.test3) {
+      t.is(line.test, 'XHello')
+      t.is(line.test2, 'YHello')
+      t.is(line.test3, 'ZHello')
+    }
+  })
+
+  const logger = pino({
+    level: 'info',
+    serializers: {
+      test: value => 'X' + value
+    }
+  }, splitStream)
+
+  const fastify = Fastify({ logger })
+  fastify.register(context1, { logSerializers: { test2: value => 'Y' + value } })
+
+  function context1 (instance, opts, next) {
+    instance.get('/', {
+      logSerializers: {
+        test3: value => 'Z' + value
+      }
+    }, (req, reply) => {
+      req.log.info({ test: 'Hello', test2: 'Hello', test3: 'Hello' }) // { test: 'XHello', test2: 'YHello', test3: 'ZHello' }
+      reply.send({ hello: 'world' })
+    })
+    next()
+  }
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    const payload = JSON.parse(res.payload)
+    t.deepEqual(payload, { hello: 'world' })
+  })
+})
+
 test('Should increase the log level for a specific plugin', t => {
   t.plan(4)
 
@@ -783,7 +1092,11 @@ test('Should set a custom log level for a specific route', t => {
 test('The default 404 handler logs the incoming request', t => {
   t.plan(5)
 
-  const expectedMessages = ['incoming request', 'Not Found', 'request completed']
+  const expectedMessages = [
+    'incoming request',
+    'Route GET:/not-found not found',
+    'request completed'
+  ]
 
   const splitStream = split(JSON.parse)
   splitStream.on('data', (line) => {
@@ -1072,6 +1385,38 @@ test('should not log the error if error handler is defined', t => {
   })
 })
 
+test('should not rely on raw request to log errors', t => {
+  t.plan(7)
+  const stream = split(JSON.parse)
+  const fastify = Fastify({
+    modifyCoreObjects: false,
+    logger: {
+      stream: stream,
+      level: 'info'
+    }
+  })
+  fastify.get('/error', function (req, reply) {
+    t.ok(req.log)
+    reply.status(415).send(new Error('something happened'))
+  })
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.server.unref()
+    http.get('http://localhost:' + fastify.server.address().port + '/error')
+    stream.once('data', listenAtLogLine => {
+      t.ok(listenAtLogLine, 'listen at log message is ok')
+      stream.once('data', line => {
+        t.equal(line.msg, 'incoming request', 'message is set')
+        stream.once('data', line => {
+          t.equal(line.level, 30, 'level is correct')
+          t.equal(line.msg, 'something happened', 'message is set')
+          t.deepEqual(line.res, { statusCode: 415 }, 'status code is set')
+        })
+      })
+    })
+  })
+})
+
 test('should redact the authorization header if so specified', t => {
   t.plan(7)
   const stream = split(JSON.parse)
@@ -1111,7 +1456,7 @@ test('should redact the authorization header if so specified', t => {
       method: 'GET',
       url: 'http://localhost:' + fastify.server.address().port,
       headers: {
-        'authorization': 'Bearer abcde'
+        authorization: 'Bearer abcde'
       }
     }, (err, response, body) => {
       t.error(err)
diff --git a/test/nullable-validation.test.js b/test/nullable-validation.test.js
new file mode 100644
index 00000000..0283adc3
--- /dev/null
+++ b/test/nullable-validation.test.js
@@ -0,0 +1,52 @@
+'use strict'
+
+const t = require('tap')
+const test = t.test
+const Fastify = require('..')
+
+test('nullable string', t => {
+  t.plan(3)
+  const fastify = Fastify()
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    handler: (req, reply) => {
+      t.same(req.body.hello, null)
+      reply.code(200).send(req.body)
+    },
+    schema: {
+      body: {
+        type: 'object',
+        properties: {
+          hello: {
+            type: 'string',
+            format: 'email',
+            nullable: true
+          }
+        }
+      },
+      response: {
+        200: {
+          type: 'object',
+          properties: {
+            hello: {
+              type: 'string',
+              format: 'email',
+              nullable: true
+            }
+          }
+        }
+      }
+    }
+  })
+  fastify.inject({
+    method: 'POST',
+    url: '/',
+    body: {
+      hello: null
+    }
+  }, (err, res) => {
+    t.error(err)
+    t.same(res.payload.hello, null)
+  })
+})
diff --git a/test/plugin.test.js b/test/plugin.test.js
index dfce241f..4ffcf39a 100644
--- a/test/plugin.test.js
+++ b/test/plugin.test.js
@@ -1,5 +1,7 @@
 'use strict'
 
+/* eslint no-prototype-builtins: 0 */
+
 const t = require('tap')
 const test = t.test
 const Fastify = require('..')
@@ -16,6 +18,29 @@ test('require a plugin', t => {
   })
 })
 
+test('plugin metadata - ignore prefix', t => {
+  t.plan(2)
+  const fastify = Fastify()
+
+  plugin[Symbol.for('skip-override')] = true
+  fastify.register(plugin, { prefix: 'foo' })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, function (err, res) {
+    t.error(err)
+    t.equals(res.payload, 'hello')
+  })
+
+  function plugin (instance, opts, next) {
+    instance.get('/', function (request, reply) {
+      reply.send('hello')
+    })
+    next()
+  }
+})
+
 test('fastify.register with fastify-plugin should not incapsulate his code', t => {
   t.plan(10)
   const fastify = Fastify()
@@ -310,6 +335,154 @@ test('check dependencies - should throw', t => {
   })
 })
 
+test('set the plugin name based on the plugin displayName symbol', t => {
+  t.plan(5)
+  const fastify = Fastify()
+
+  fastify.register(fp((fastify, opts, next) => {
+    t.strictEqual(fastify.pluginName, 'plugin-A')
+    fastify.register(fp((fastify, opts, next) => {
+      t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB')
+      next()
+    }, { name: 'plugin-AB' }))
+    fastify.register(fp((fastify, opts, next) => {
+      t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB -> plugin-AC')
+      next()
+    }, { name: 'plugin-AC' }))
+    next()
+  }, { name: 'plugin-A' }))
+
+  fastify.register(fp((fastify, opts, next) => {
+    t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB -> plugin-AC -> plugin-B')
+    next()
+  }, { name: 'plugin-B' }))
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
+test('plugin name will change when using no encapsulation', t => {
+  t.plan(5)
+  const fastify = Fastify()
+
+  fastify.register(fp((fastify, opts, next) => {
+    // store it in a different variable will hold the correct name
+    const pluginName = fastify.pluginName
+    fastify.register(fp((fastify, opts, next) => {
+      t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB')
+      next()
+    }, { name: 'plugin-AB' }))
+    fastify.register(fp((fastify, opts, next) => {
+      t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB -> plugin-AC')
+      next()
+    }, { name: 'plugin-AC' }))
+    setImmediate(() => {
+      // normally we would expect the name plugin-A
+      // but we operate on the same instance in each plugin
+      t.strictEqual(fastify.pluginName, 'plugin-A -> plugin-AB -> plugin-AC')
+      t.strictEqual(pluginName, 'plugin-A')
+    })
+    next()
+  }, { name: 'plugin-A' }))
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
+test('plugin name is undefined when accessing in no plugin context', t => {
+  t.plan(2)
+  const fastify = Fastify()
+
+  t.strictEqual(fastify.pluginName, undefined)
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
+test('set the plugin name based on the plugin function name', t => {
+  t.plan(5)
+  const fastify = Fastify()
+
+  fastify.register(function myPluginA (fastify, opts, next) {
+    t.strictEqual(fastify.pluginName, 'myPluginA')
+    fastify.register(function myPluginAB (fastify, opts, next) {
+      t.strictEqual(fastify.pluginName, 'myPluginAB')
+      next()
+    })
+    setImmediate(() => {
+      // exact name due to encapsulation
+      t.strictEqual(fastify.pluginName, 'myPluginA')
+    })
+    next()
+  })
+
+  fastify.register(function myPluginB (fastify, opts, next) {
+    t.strictEqual(fastify.pluginName, 'myPluginB')
+    next()
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
+test('approximate a plugin name when no meta data is available', t => {
+  t.plan(7)
+  const fastify = Fastify()
+
+  fastify.register((fastify, opts, next) => {
+    // A
+    t.is(fastify.pluginName.startsWith('(fastify, opts, next)'), true)
+    t.is(fastify.pluginName.includes('// A'), true)
+    fastify.register((fastify, opts, next) => {
+      // B
+      t.is(fastify.pluginName.startsWith('(fastify, opts, next)'), true)
+      t.is(fastify.pluginName.includes('// B'), true)
+      next()
+    })
+    setImmediate(() => {
+      t.is(fastify.pluginName.startsWith('(fastify, opts, next)'), true)
+      t.is(fastify.pluginName.includes('// A'), true)
+    })
+    next()
+  })
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
+test('approximate a plugin name also when fastify-plugin has no meta data', t => {
+  t.plan(4)
+  const fastify = Fastify()
+
+  fastify.register(fp((fastify, opts, next) => {
+    t.is(fastify.pluginName, 'plugin.test')
+    fastify.register(fp(function B (fastify, opts, next) {
+      // function has name
+      t.is(fastify.pluginName, 'plugin.test -> B')
+      next()
+    }))
+    setImmediate(() => {
+      t.is(fastify.pluginName, 'plugin.test -> B')
+    })
+    next()
+  }))
+
+  fastify.listen(0, err => {
+    t.error(err)
+    fastify.close()
+  })
+})
+
 test('plugin incapsulation', t => {
   t.plan(10)
   const fastify = Fastify()
diff --git a/test/promises.test.js b/test/promises.test.js
index 27ad3b61..29c21c50 100644
--- a/test/promises.test.js
+++ b/test/promises.test.js
@@ -42,6 +42,24 @@ fastify.get('/double', function (req, reply) {
   return Promise.resolve({ hello: '42' })
 })
 
+fastify.get('/thenable', opts, function (req, reply) {
+  setImmediate(function () {
+    reply.send({ hello: 'world' })
+  })
+  return reply
+})
+
+fastify.get('/thenable-error', opts, function (req, reply) {
+  setImmediate(function () {
+    reply.send(new Error('kaboom'))
+  })
+  return reply
+})
+
+fastify.get('/return-reply', opts, function (req, reply) {
+  return reply.send({ hello: 'world' })
+})
+
 fastify.listen(0, err => {
   t.error(err)
   fastify.server.unref()
@@ -82,4 +100,41 @@ fastify.listen(0, err => {
       t.deepEqual(JSON.parse(body), { hello: '42' })
     })
   })
+
+  test('thenable', t => {
+    t.plan(4)
+    sget({
+      method: 'GET',
+      url: 'http://localhost:' + fastify.server.address().port + '/thenable'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(response.headers['content-length'], '' + body.length)
+      t.deepEqual(JSON.parse(body), { hello: 'world' })
+    })
+  })
+
+  test('thenable (error)', t => {
+    t.plan(2)
+    sget({
+      method: 'GET',
+      url: 'http://localhost:' + fastify.server.address().port + '/thenable-error'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 500)
+    })
+  })
+
+  test('return-reply', t => {
+    t.plan(4)
+    sget({
+      method: 'GET',
+      url: 'http://localhost:' + fastify.server.address().port + '/return-reply'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+      t.strictEqual(response.headers['content-length'], '' + body.length)
+      t.deepEqual(JSON.parse(body), { hello: 'world' })
+    })
+  })
 })
diff --git a/test/proto-poisoning.test.js b/test/proto-poisoning.test.js
index 2498ee69..425972e2 100644
--- a/test/proto-poisoning.test.js
+++ b/test/proto-poisoning.test.js
@@ -81,3 +81,79 @@ test('proto-poisoning ignore', t => {
     })
   })
 })
+
+test('constructor-poisoning ignore (default in v2)', t => {
+  t.plan(3)
+
+  const fastify = Fastify()
+  t.tearDown(fastify.close.bind(fastify))
+
+  fastify.post('/', (request, reply) => {
+    reply.send('ok')
+  })
+
+  fastify.listen(0, function (err) {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      headers: { 'Content-Type': 'application/json' },
+      body: '{ "constructor": { "prototype": { "foo": "bar" } } }'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+    })
+  })
+})
+
+test('constructor-poisoning error', t => {
+  t.plan(3)
+
+  const fastify = Fastify({ onConstructorPoisoning: 'error' })
+  t.tearDown(fastify.close.bind(fastify))
+
+  fastify.post('/', (request, reply) => {
+    t.fail('handler should not be called')
+  })
+
+  fastify.listen(0, function (err) {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      headers: { 'Content-Type': 'application/json' },
+      body: '{ "constructor": { "prototype": { "foo": "bar" } } }'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 400)
+    })
+  })
+})
+
+test('constructor-poisoning remove', t => {
+  t.plan(4)
+
+  const fastify = Fastify({ onProtoPoisoning: 'remove' })
+  t.tearDown(fastify.close.bind(fastify))
+
+  fastify.post('/', (request, reply) => {
+    t.equal(undefined, Object.assign({}, request.body).foo)
+    reply.send({ ok: true })
+  })
+
+  fastify.listen(0, function (err) {
+    t.error(err)
+
+    sget({
+      method: 'POST',
+      url: 'http://localhost:' + fastify.server.address().port,
+      headers: { 'Content-Type': 'application/json' },
+      body: '{ "constructor": { "prototype": { "foo": "bar" } } }'
+    }, (err, response, body) => {
+      t.error(err)
+      t.strictEqual(response.statusCode, 200)
+    })
+  })
+})
diff --git a/test/register.test.js b/test/register.test.js
index 6c5550ea..f03f6869 100644
--- a/test/register.test.js
+++ b/test/register.test.js
@@ -1,5 +1,7 @@
 'use strict'
 
+/* eslint no-prototype-builtins: 0 */
+
 const t = require('tap')
 const test = t.test
 const sget = require('simple-get').concat
diff --git a/test/route-hooks.test.js b/test/route-hooks.test.js
index 8c538cea..619a2a0d 100644
--- a/test/route-hooks.test.js
+++ b/test/route-hooks.test.js
@@ -3,7 +3,7 @@
 const test = require('tap').test
 const Fastify = require('../')
 
-function testHook (hook) {
+function testExecutionHook (hook) {
   test(`${hook}`, t => {
     t.plan(3)
     const fastify = Fastify()
@@ -29,22 +29,24 @@ function testHook (hook) {
   })
 
   test(`${hook} option should be called after ${hook} hook`, t => {
-    t.plan(2)
+    t.plan(3)
     const fastify = Fastify()
-    let check = ''
+    const checker = Object.defineProperty({ calledTimes: 0 }, 'check', {
+      get: function () { return ++this.calledTimes }
+    })
 
     fastify.addHook(hook, (req, reply, next) => {
-      check = 'a'
+      t.equal(checker.check, 1)
       next()
     })
 
     fastify.post('/', {
       [hook]: (req, reply, done) => {
-        check += 'b'
+        t.equal(checker.check, 2)
         done()
       }
     }, (req, reply) => {
-      reply.send({ check })
+      reply.send({})
     })
 
     fastify.inject({
@@ -53,11 +55,86 @@ function testHook (hook) {
       payload: { hello: 'world' }
     }, (err, res) => {
       t.error(err)
-      var payload = JSON.parse(res.payload)
-      t.deepEqual(payload, { check: 'ab' })
     })
   })
 
+  test(`${hook} option could accept an array of functions`, t => {
+    t.plan(3)
+    const fastify = Fastify()
+    const checker = Object.defineProperty({ calledTimes: 0 }, 'check', {
+      get: function () { return ++this.calledTimes }
+    })
+
+    fastify.post('/', {
+      [hook]: [
+        (req, reply, done) => {
+          t.equal(checker.check, 1)
+          done()
+        },
+        (req, reply, done) => {
+          t.equal(checker.check, 2)
+          done()
+        }
+      ]
+    }, (req, reply) => {
+      reply.send({})
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      payload: { hello: 'world' }
+    }, (err, res) => {
+      t.error(err)
+    })
+  })
+
+  test(`${hook} option does not interfere with ${hook} hook`, t => {
+    t.plan(7)
+    const fastify = Fastify()
+    const checker = Object.defineProperty({ calledTimes: 0 }, 'check', {
+      get: function () { return ++this.calledTimes }
+    })
+
+    fastify.addHook(hook, (req, reply, next) => {
+      t.equal(checker.check, 1)
+      next()
+    })
+
+    fastify.post('/', {
+      [hook]: (req, reply, done) => {
+        t.equal(checker.check, 2)
+        done()
+      }
+    }, handler)
+
+    fastify.post('/no', handler)
+
+    function handler (req, reply) {
+      reply.send({})
+    }
+
+    fastify.inject({
+      method: 'post',
+      url: '/'
+    }, (err, res) => {
+      t.error(err)
+      t.equal(checker.calledTimes, 2)
+
+      checker.calledTimes = 0
+
+      fastify.inject({
+        method: 'post',
+        url: '/no'
+      }, (err, res) => {
+        t.error(err)
+        t.equal(checker.calledTimes, 1)
+      })
+    })
+  })
+}
+
+function testBeforeHandlerHook (hook) {
   test(`${hook} option should be unique per route`, t => {
     t.plan(4)
     const fastify = Fastify()
@@ -153,79 +230,6 @@ function testHook (hook) {
     })
   })
 
-  test(`${hook} option could accept an array of functions`, t => {
-    t.plan(2)
-    const fastify = Fastify()
-
-    fastify.post('/', {
-      [hook]: [
-        (req, reply, done) => {
-          req.aa = 'a'
-          done()
-        },
-        (req, reply, done) => {
-          req.aa += 'b'
-          done()
-        }
-      ]
-    }, (req, reply) => {
-      reply.send({ aa: req.aa })
-    })
-
-    fastify.inject({
-      method: 'POST',
-      url: '/',
-      payload: { hello: 'world' }
-    }, (err, res) => {
-      t.error(err)
-      var payload = JSON.parse(res.payload)
-      t.deepEqual(payload, { aa: 'ab' })
-    })
-  })
-
-  test(`${hook} option does not interfere with ${hook} hook`, t => {
-    t.plan(4)
-    const fastify = Fastify()
-
-    fastify.addHook(hook, (req, reply, next) => {
-      req.check = 'a'
-      next()
-    })
-
-    fastify.post('/', {
-      [hook]: (req, reply, done) => {
-        req.check += 'b'
-        done()
-      }
-    }, handler)
-
-    fastify.post('/no', handler)
-
-    function handler (req, reply) {
-      reply.send({ check: req.check })
-    }
-
-    fastify.inject({
-      method: 'post',
-      url: '/',
-      payload: { hello: 'world' }
-    }, (err, res) => {
-      t.error(err)
-      var payload = JSON.parse(res.payload)
-      t.deepEqual(payload, { check: 'ab' })
-    })
-
-    fastify.inject({
-      method: 'post',
-      url: '/no',
-      payload: { hello: 'world' }
-    }, (err, res) => {
-      t.error(err)
-      var payload = JSON.parse(res.payload)
-      t.deepEqual(payload, { check: 'a' })
-    })
-  })
-
   test(`${hook} option should keep the context`, t => {
     t.plan(3)
     const fastify = Fastify()
@@ -281,11 +285,16 @@ function testHook (hook) {
   })
 }
 
+testExecutionHook('preHandler')
+testExecutionHook('onRequest')
+testExecutionHook('onResponse')
+testExecutionHook('preValidation')
+testExecutionHook('preParsing')
 // hooks that comes before the handler
-testHook('preHandler')
-testHook('onRequest')
-testHook('preValidation')
-testHook('preParsing')
+testBeforeHandlerHook('preHandler')
+testBeforeHandlerHook('onRequest')
+testBeforeHandlerHook('preValidation')
+testBeforeHandlerHook('preParsing')
 
 test('preValidation option should be called before preHandler hook', t => {
   t.plan(3)
diff --git a/test/route-prefix.test.js b/test/route-prefix.test.js
index 7a0de1e3..fb7d0c54 100644
--- a/test/route-prefix.test.js
+++ b/test/route-prefix.test.js
@@ -459,6 +459,37 @@ test('matches both /prefix and /prefix/  with a / route - prefixTrailingSlash: "
   })
 })
 
+test('returns 404 status code with /prefix/ and / route - prefixTrailingSlash: "both" (default), ignoreTrailingSlash: true', t => {
+  t.plan(2)
+  const fastify = Fastify({
+    ignoreTrailingSlash: true
+  })
+
+  fastify.register(function (fastify, opts, next) {
+    fastify.route({
+      method: 'GET',
+      url: '/',
+      handler: (req, reply) => {
+        reply.send({ hello: 'world' })
+      }
+    })
+
+    next()
+  }, { prefix: '/prefix/' })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/prefix//'
+  }, (err, res) => {
+    t.error(err)
+    t.same(JSON.parse(res.payload), {
+      error: 'Not Found',
+      message: 'Route GET:/prefix// not found',
+      statusCode: 404
+    })
+  })
+})
+
 test('matches only /prefix  with a / route - prefixTrailingSlash: "no-slash", ignoreTrailingSlash: false', t => {
   t.plan(4)
   const fastify = Fastify({
diff --git a/test/route.test.js b/test/route.test.js
index 57d65ac3..40e572ee 100644
--- a/test/route.test.js
+++ b/test/route.test.js
@@ -3,6 +3,7 @@
 const t = require('tap')
 const test = t.test
 const sget = require('simple-get').concat
+const joi = require('@hapi/joi')
 const Fastify = require('..')
 
 test('route', t => {
@@ -255,3 +256,37 @@ test('handler function in options of shorthand route should works correctly', t
     t.deepEqual(JSON.parse(res.payload), { hello: 'world' })
   })
 })
+
+test('does not mutate joi schemas', t => {
+  t.plan(4)
+
+  const fastify = Fastify()
+  function schemaCompiler (schema) {
+    return function (data, opts) {
+      return joi.validate(data, schema)
+    }
+  }
+
+  fastify.setSchemaCompiler(schemaCompiler)
+
+  fastify.route({
+    path: '/foo/:an_id',
+    method: 'GET',
+    schema: {
+      params: { an_id: joi.number() }
+    },
+    handler (req, res) {
+      t.deepEqual(req.params, { an_id: 42 })
+      res.send({ hello: 'world' })
+    }
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/foo/42'
+  }, (err, result) => {
+    t.error(err)
+    t.strictEqual(result.statusCode, 200)
+    t.deepEqual(JSON.parse(result.payload), { hello: 'world' })
+  })
+})
diff --git a/test/schemas.test.js b/test/schemas.test.js
new file mode 100644
index 00000000..ea498f7a
--- /dev/null
+++ b/test/schemas.test.js
@@ -0,0 +1,450 @@
+'use strict'
+
+const t = require('tap')
+const test = t.test
+const Fastify = require('..')
+
+const ajvMergePatch = require('ajv-merge-patch')
+const AJV = require('ajv')
+const fastClone = require('rfdc')({ circles: false, proto: true })
+
+const schemaUsed = {
+  $id: 'urn:schema:foo',
+  definitions: {
+    foo: { type: 'string' }
+  },
+  type: 'object',
+  properties: {
+    foo: { $ref: '#/definitions/foo' }
+  }
+}
+const schemaParent = {
+  $id: 'urn:schema:response',
+  type: 'object',
+  required: ['foo'],
+  properties: {
+    foo: { $ref: 'urn:schema:foo#/definitions/foo' }
+  }
+}
+
+const schemaRequest = {
+  $id: 'urn:schema:request',
+  type: 'object',
+  required: ['foo'],
+  properties: {
+    foo: { $ref: 'urn:schema:response#/properties/foo' }
+  }
+}
+
+test('Should use the ref resolver - response', t => {
+  t.plan(2)
+  const fastify = Fastify()
+  const ajv = new AJV()
+  ajv.addSchema(fastClone(schemaParent))
+  ajv.addSchema(fastClone(schemaUsed))
+
+  fastify.setSchemaCompiler(schema => ajv.compile(schema))
+  fastify.setSchemaResolver((ref) => {
+    t.equals(ref, 'urn:schema:foo')
+    return ajv.getSchema(ref).schema
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    schema: {
+      response: {
+        '2xx': ajv.getSchema('urn:schema:response').schema
+      }
+    },
+    handler (req, reply) {
+      reply.send({ foo: 'bar' })
+    }
+  })
+
+  fastify.ready(t.error)
+})
+
+test('Should use the ref resolver - body', t => {
+  t.plan(3)
+  const fastify = Fastify()
+  const ajv = new AJV()
+  ajv.addSchema(fastClone(schemaParent))
+  ajv.addSchema(fastClone(schemaUsed))
+
+  fastify.setSchemaCompiler(schema => ajv.compile(schema))
+  fastify.setSchemaResolver((ref) => {
+    t.equals(ref, 'urn:schema:foo')
+    return ajv.getSchema(ref).schema
+  })
+
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {
+      body: ajv.getSchema('urn:schema:response').schema
+    },
+    handler (req, reply) {
+      reply.send({ foo: 'bar' })
+    }
+  })
+
+  fastify.inject({
+    method: 'POST',
+    url: '/',
+    payload: { foo: 'bar' }
+  }, (err, res) => {
+    t.error(err)
+    t.deepEquals(JSON.parse(res.payload), { foo: 'bar' })
+  })
+})
+
+test('Encapsulation', t => {
+  t.plan(14)
+  const fastify = Fastify()
+  const ajv = new AJV()
+  ajv.addSchema(fastClone(schemaParent))
+  ajv.addSchema(fastClone(schemaUsed))
+
+  fastify.register((instance, opts, next) => {
+    instance.setSchemaCompiler(schema => ajv.compile(schema))
+    instance.setSchemaResolver((ref) => {
+      return ajv.getSchema(ref).schema
+    })
+    instance.route({
+      method: 'POST',
+      url: '/',
+      schema: {
+        body: ajv.getSchema('urn:schema:response').schema
+      },
+      handler (req, reply) {
+        reply.send({ foo: 'bar' })
+      }
+    })
+
+    instance.register((instance, opts, next) => {
+      instance.route({
+        method: 'POST',
+        url: '/two',
+        schema: {
+          body: ajv.getSchema('urn:schema:response').schema
+        },
+        handler (req, reply) {
+          reply.send({ foo: 'bar' })
+        }
+      })
+      next()
+    })
+    next()
+  })
+
+  fastify.register((instance, opts, next) => {
+    instance.route({
+      method: 'POST',
+      url: '/clean',
+      handler (req, reply) {
+        reply.send({ foo: 'bar' })
+      }
+    })
+    next()
+  })
+
+  fastify.ready(err => {
+    t.error(err)
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      payload: { foo: 'bar' }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+      t.deepEquals(JSON.parse(res.payload), { foo: 'bar' })
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/',
+      payload: { wrongFoo: 'bar' }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/two',
+      payload: { foo: 'bar' }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+      t.deepEquals(JSON.parse(res.payload), { foo: 'bar' })
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/two',
+      payload: { wrongFoo: 'bar' }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'POST',
+      url: '/clean',
+      payload: { wrongFoo: 'bar' }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+      t.deepEquals(JSON.parse(res.payload), { foo: 'bar' })
+    })
+  })
+})
+
+test('Schema resolver without schema compiler', t => {
+  t.plan(2)
+  const fastify = Fastify()
+
+  fastify.setSchemaResolver(() => { t.fail('the schema resolver will never be called') })
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {},
+    handler (req, reply) {
+      reply.send({ foo: 'bar' })
+    }
+  })
+
+  fastify.ready(err => {
+    t.is(err.code, 'FST_ERR_SCH_MISSING_COMPILER')
+    t.isLike(err.message, /You must provide a schemaCompiler to route POST \/ to use the schemaResolver/)
+  })
+})
+
+test('Triple $ref deep', t => {
+  t.plan(6)
+
+  const fastify = Fastify()
+  const ajv = new AJV()
+  ajv.addSchema(fastClone(schemaParent))
+  ajv.addSchema(fastClone(schemaUsed))
+  ajv.addSchema(fastClone(schemaRequest))
+
+  fastify.setSchemaCompiler(schema => ajv.compile(schema))
+  fastify.setSchemaResolver((ref) => {
+    return ajv.getSchema(ref).schema
+  })
+
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {
+      body: ajv.getSchema('urn:schema:request').schema,
+      response: {
+        '2xx': ajv.getSchema('urn:schema:response').schema
+      }
+    },
+    handler (req, reply) {
+      reply.send({ foo: 'bar' })
+    }
+  })
+
+  fastify.inject({
+    method: 'POST',
+    url: '/',
+    payload: { foo: 'bar' }
+  }, (err, res) => {
+    t.error(err)
+    t.equals(res.statusCode, 200)
+    t.deepEquals(JSON.parse(res.payload), { foo: 'bar' })
+  })
+
+  fastify.inject({
+    method: 'POST',
+    url: '/',
+    payload: { fool: 'bar' }
+  }, (err, res) => {
+    t.error(err)
+    t.equals(res.statusCode, 400)
+    t.deepEquals(JSON.parse(res.payload).message, "body should have required property 'foo'")
+  })
+})
+
+test('$ref with a simple $id', t => {
+  t.plan(4)
+  const fastify = Fastify()
+  const ajv = new AJV()
+  ajv.addSchema(fastClone(schemaUsed))
+  ajv.addSchema({
+    $id: 'urn:schema:response',
+    type: 'object',
+    required: ['foo'],
+    properties: {
+      foo: { $ref: 'urn:schema:foo' }
+    }
+  })
+  ajv.addSchema({
+    $id: 'urn:schema:request',
+    type: 'object',
+    required: ['foo'],
+    properties: {
+      foo: { $ref: 'urn:schema:foo' }
+    }
+  })
+
+  fastify.setSchemaCompiler(schema => ajv.compile(schema))
+  fastify.setSchemaResolver((ref) => {
+    t.equals(ref, 'urn:schema:foo')
+    return ajv.getSchema(ref).schema
+  })
+
+  fastify.route({
+    method: 'POST',
+    url: '/',
+    schema: {
+      body: ajv.getSchema('urn:schema:request').schema,
+      response: {
+        '2xx': ajv.getSchema('urn:schema:response').schema
+      }
+    },
+    handler (req, reply) {
+      reply.send({ foo: { foo: 'bar', bar: 'foo' } })
+    }
+  })
+
+  fastify.inject({
+    method: 'POST',
+    url: '/',
+    payload: { foo: { foo: 'bar' } }
+  }, (err, res) => {
+    t.error(err)
+    t.equals(res.statusCode, 200)
+    t.deepEquals(JSON.parse(res.payload), { foo: { foo: 'bar' } })
+  })
+})
+
+test('Should handle root $merge keywords in header', t => {
+  t.plan(5)
+  const fastify = Fastify({
+    ajv: {
+      plugins: [
+        ajvMergePatch
+      ]
+    }
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    schema: {
+      headers: {
+        $merge: {
+          source: {
+            type: 'object',
+            properties: {
+              q: {
+                type: 'string'
+              }
+            }
+          },
+          with: {
+            required: ['q']
+          }
+        }
+      }
+    },
+    handler (req, reply) {
+      reply.send({ ok: 1 })
+    }
+  })
+
+  fastify.ready(err => {
+    t.error(err)
+
+    fastify.inject({
+      method: 'GET',
+      url: '/'
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'GET',
+      url: '/',
+      headers: {
+        q: 'foo'
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+    })
+  })
+})
+
+test('Should handle root $patch keywords in header', t => {
+  t.plan(5)
+  const fastify = Fastify({
+    ajv: {
+      plugins: [
+        ajvMergePatch
+      ]
+    }
+  })
+
+  fastify.route({
+    method: 'GET',
+    url: '/',
+    schema: {
+      headers: {
+        $patch: {
+          source: {
+            type: 'object',
+            properties: {
+              q: {
+                type: 'string'
+              }
+            }
+          },
+          with: [
+            {
+              op: 'add',
+              path: '/properties/q',
+              value: { type: 'number' }
+            }
+          ]
+        }
+      }
+    },
+    handler (req, reply) {
+      reply.send({ ok: 1 })
+    }
+  })
+
+  fastify.ready(err => {
+    t.error(err)
+
+    fastify.inject({
+      method: 'GET',
+      url: '/',
+      headers: {
+        q: 'foo'
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 400)
+    })
+
+    fastify.inject({
+      method: 'GET',
+      url: '/',
+      headers: {
+        q: 10
+      }
+    }, (err, res) => {
+      t.error(err)
+      t.equals(res.statusCode, 200)
+    })
+  })
+})
diff --git a/test/shared-schemas.test.js b/test/shared-schemas.test.js
index d6ecf000..e354b11e 100644
--- a/test/shared-schemas.test.js
+++ b/test/shared-schemas.test.js
@@ -565,7 +565,7 @@ test('Use shared schema and $ref with $id ($ref to $id)', t => {
         $id: '#address',
         type: 'object',
         properties: {
-          city: { 'type': 'string' }
+          city: { type: 'string' }
         }
       }
     },
@@ -624,7 +624,7 @@ test('Use shared schema and $ref with $id in response ($ref to $id)', t => {
         $id: '#address',
         type: 'object',
         properties: {
-          city: { 'type': 'string' }
+          city: { type: 'string' }
         }
       }
     },
@@ -701,7 +701,7 @@ test('The schema resolver should clean the $id key before passing it to the comp
     url: '/',
     method: 'GET',
     schema: {
-      description: `get`,
+      description: 'get',
       body: 'second#',
       response: {
         200: 'second#'
@@ -716,7 +716,7 @@ test('The schema resolver should clean the $id key before passing it to the comp
     url: '/',
     method: 'PATCH',
     schema: {
-      description: `patch`,
+      description: 'patch',
       body: 'first#',
       response: {
         200: 'first#'
@@ -1089,7 +1089,7 @@ test('Use shared schema and $ref to /definitions', t => {
         $id: '#otherId',
         type: 'object',
         properties: {
-          city: { 'type': 'string' }
+          city: { type: 'string' }
         }
       }
     },
diff --git a/test/stream.test.js b/test/stream.test.js
index 17365e11..1574e5ab 100644
--- a/test/stream.test.js
+++ b/test/stream.test.js
@@ -140,7 +140,7 @@ test('onSend hook stream', t => {
 })
 
 test('Destroying streams prematurely', t => {
-  t.plan(5)
+  t.plan(6)
 
   let fastify = null
   const logStream = split(JSON.parse)
@@ -190,7 +190,9 @@ test('Destroying streams prematurely', t => {
       response.on('readable', function () {
         response.destroy()
       })
-      response.on('close', function () {
+
+      // Node bug? Node never emits 'close' here.
+      response.on('aborted', function () {
         t.pass('Response closed')
       })
     })
@@ -198,7 +200,7 @@ test('Destroying streams prematurely', t => {
 })
 
 test('Destroying streams prematurely should call close method', t => {
-  t.plan(6)
+  t.plan(7)
 
   let fastify = null
   const logStream = split(JSON.parse)
@@ -249,7 +251,8 @@ test('Destroying streams prematurely should call close method', t => {
       response.on('readable', function () {
         response.destroy()
       })
-      response.on('close', function () {
+      // Node bug? Node never emits 'close' here.
+      response.on('aborted', function () {
         t.pass('Response closed')
       })
     })
@@ -257,7 +260,7 @@ test('Destroying streams prematurely should call close method', t => {
 })
 
 test('Destroying streams prematurely should call abort method', t => {
-  t.plan(6)
+  t.plan(7)
 
   let fastify = null
   const logStream = split(JSON.parse)
@@ -309,7 +312,8 @@ test('Destroying streams prematurely should call abort method', t => {
       response.on('readable', function () {
         response.destroy()
       })
-      response.on('close', function () {
+      // Node bug? Node never emits 'close' here.
+      response.on('aborted', function () {
         t.pass('Response closed')
       })
     })
diff --git a/test/throw.test.js b/test/throw.test.js
index 6d80233f..5b294c24 100644
--- a/test/throw.test.js
+++ b/test/throw.test.js
@@ -25,6 +25,52 @@ test('Fastify should throw on multiple assignment to the same route', t => {
   })
 })
 
+test('Fastify should throw for an invalid schema, printing the error route - headers', t => {
+  t.plan(2)
+
+  const badSchema = {
+    type: 'object',
+    properties: {
+      bad: {
+        type: 'bad-type'
+      }
+    }
+  }
+
+  const fastify = Fastify()
+  fastify.get('/', { schema: { headers: badSchema } }, () => {})
+  fastify.get('/not-loaded', { schema: { headers: badSchema } }, () => {})
+
+  fastify.ready(err => {
+    t.is(err.code, 'FST_ERR_SCH_BUILD')
+    t.isLike(err.message, /Failed building the schema for GET: \//)
+  })
+})
+
+test('Fastify should throw for an invalid schema, printing the error route - body', t => {
+  t.plan(2)
+
+  const badSchema = {
+    type: 'object',
+    properties: {
+      bad: {
+        type: 'bad-type'
+      }
+    }
+  }
+
+  const fastify = Fastify()
+  fastify.register((instance, opts, next) => {
+    instance.post('/form', { schema: { body: badSchema } }, () => {})
+    next()
+  }, { prefix: 'hello' })
+
+  fastify.ready(err => {
+    t.is(err.code, 'FST_ERR_SCH_BUILD')
+    t.isLike(err.message, /Failed building the schema for POST: \/hello\/form/)
+  })
+})
+
 test('Should throw on unsupported method', t => {
   t.plan(1)
   const fastify = Fastify()
@@ -131,7 +177,7 @@ test('Should throw on duplicate request decorator', t => {
     t.fail()
   } catch (e) {
     t.is(e.code, 'FST_ERR_DEC_ALREADY_PRESENT')
-    t.is(e.message, `The decorator 'foo' has already been added!`)
+    t.is(e.message, 'The decorator \'foo\' has already been added!')
   }
 })
 
@@ -146,7 +192,7 @@ test('Should throw if request decorator dependencies are not met', t => {
     t.fail()
   } catch (e) {
     t.is(e.code, 'FST_ERR_DEC_MISSING_DEPENDENCY')
-    t.is(e.message, `The decorator is missing dependency 'world'.`)
+    t.is(e.message, 'The decorator is missing dependency \'world\'.')
   }
 })
 
diff --git a/test/validation-error-handling.test.js b/test/validation-error-handling.test.js
index a89dc2fe..29f0b7e3 100644
--- a/test/validation-error-handling.test.js
+++ b/test/validation-error-handling.test.js
@@ -278,7 +278,7 @@ test('should return a defined output message parsing AJV errors', t => {
     url: '/'
   }, (err, res) => {
     t.error(err)
-    t.strictEqual(res.payload, `{"statusCode":400,"error":"Bad Request","message":"body should have required property 'name', body should have required property 'work'"}`)
+    t.strictEqual(res.payload, '{"statusCode":400,"error":"Bad Request","message":"body should have required property \'name\', body should have required property \'work\'"}')
   })
 })
 
@@ -306,7 +306,7 @@ test('should return a defined output message parsing JOI errors', t => {
     url: '/'
   }, (err, res) => {
     t.error(err)
-    t.strictEqual(res.payload, `{"statusCode":400,"error":"Bad Request","message":"child \\"name\\" fails because [\\"name\\" is required]"}`)
+    t.strictEqual(res.payload, '{"statusCode":400,"error":"Bad Request","message":"child \\"name\\" fails because [\\"name\\" is required]"}')
   })
 })
 
@@ -337,6 +337,6 @@ test('should return a defined output message parsing JOI error details', t => {
     url: '/'
   }, (err, res) => {
     t.error(err)
-    t.strictEqual(res.payload, `{"statusCode":400,"error":"Bad Request","message":"body \\"name\\" is required"}`)
+    t.strictEqual(res.payload, '{"statusCode":400,"error":"Bad Request","message":"body \\"name\\" is required"}')
   })
 })
diff --git a/test/versioned-routes.test.js b/test/versioned-routes.test.js
index b155c08f..6a3f5628 100644
--- a/test/versioned-routes.test.js
+++ b/test/versioned-routes.test.js
@@ -417,7 +417,7 @@ test('Should register a versioned route with custome versioning strategy', t =>
       }
     },
     deriveVersion: (req, ctx) => {
-      return req.headers['accept']
+      return req.headers.accept
     }
   }
 
@@ -445,7 +445,7 @@ test('Should register a versioned route with custome versioning strategy', t =>
     method: 'GET',
     url: '/',
     headers: {
-      'Accept': 'application/vnd.example.api+json;version=2'
+      Accept: 'application/vnd.example.api+json;version=2'
     }
   }, (err, res) => {
     t.error(err)
@@ -457,7 +457,7 @@ test('Should register a versioned route with custome versioning strategy', t =>
     method: 'GET',
     url: '/',
     headers: {
-      'Accept': 'application/vnd.example.api+json;version=3'
+      Accept: 'application/vnd.example.api+json;version=3'
     }
   }, (err, res) => {
     t.error(err)
@@ -469,7 +469,7 @@ test('Should register a versioned route with custome versioning strategy', t =>
     method: 'GET',
     url: '/',
     headers: {
-      'Accept': 'application/vnd.example.api+json;version=4'
+      Accept: 'application/vnd.example.api+json;version=4'
     }
   }, (err, res) => {
     t.error(err)
