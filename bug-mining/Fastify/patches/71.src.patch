diff --git a/docs/Reference/Decorators.md b/docs/Reference/Decorators.md
index ee2e2f2b..4324658d 100644
--- a/docs/Reference/Decorators.md
+++ b/docs/Reference/Decorators.md
@@ -366,201 +366,68 @@ Will define the `foo` property on the Fastify instance:
 console.log(fastify.foo) // 'a getter'
 ```
 
-### `getDecorator<T>` API
+#### `getDecorator(name)`
+<a id="get-decorator"></a>
 
-Fastify's `getDecorator<T>` API retrieves an existing decorator from the
-Fastify instance, `Request`, or `Reply`. If the decorator is not defined, an
-`FST_ERR_DEC_UNDECLARED` error is thrown.
+Used to retrieve an existing decorator from the Fastify instance, `Request`, or `Reply`.
+If the decorator is not defined, an `FST_ERR_DEC_UNDECLARED` error is thrown.
 
-#### Use cases
+```js
+// Get a decorator from the Fastify instance
+const utility = fastify.getDecorator('utility')
 
-**Early Plugin Dependency Validation**
+// Get a decorator from the request object
+const user = request.getDecorator('user')
 
-`getDecorator<T>` on Fastify instance verifies that required decorators are
-available at registration time. 
+// Get a decorator from the reply object
+const helper = reply.getDecorator('helper')
+```
 
-For example:
+The `getDecorator` method is useful for dependency validation - it can be used to
+check for required decorators at registration time. If any are missing, it fails
+at boot, ensuring dependencies are available during the request lifecycle.
 
 ```js
 fastify.register(async function (fastify) {
+  // Verify the decorator exists before using it
   const usersRepository = fastify.getDecorator('usersRepository')
 
   fastify.get('/users', async function (request, reply) {
-    // We are sure `usersRepository` exists at runtime
     return usersRepository.findAll()
   })
 })
 ```
 
-**Handling Missing Decorators**
-
-Directly accessing a decorator may lead to unexpected behavior if it is not declared:
-
-```ts
-const user = request.user;
-if (user && user.isAdmin) {
-  // Execute admin tasks.
-}
-```
-
-If `request.user` doesn't exist, then `user` will be set to `undefined`. 
-This makes it unclear whether the user is unauthenticated or the decorator is missing.
-
-Using `getDecorator` enforces runtime safety:
-
-```ts
-// If the decorator is missing, an explicit `FST_ERR_DEC_UNDECLARED` 
-// error is thrown immediately.
-const user = request.getDecorator('user');
-if (user && user.isAdmin) {
-  // Execute admin tasks.
-}
-```
-
-**Alternative to Module Augmentation**
-
-Decorators are typically typed via module augmentation:
-
-```ts
-declare module 'fastify' {
-  interface FastifyInstance {
-    usersRepository: IUsersRepository
-  }
-  interface FastifyRequest {
-    session: ISession
-  }
-  interface FastifyReply {
-    sendSuccess: SendSuccessFn
-  }
-}
-```
-
-This approach modifies the Fastify instance globally, which may lead to
-conflicts and inconsistent behavior in multi-server setups or with plugin
-encapsulation.
-
-Using `getDecorator<T>` allows to limit types scope:
-
-```ts
-serverOne.register(async function (fastify) {
-  const usersRepository = fastify.getDecorator<PostgreUsersRepository>(
-    'usersRepository'
-  )
-
-  fastify.decorateRequest('session', null)
-  fastify.addHook('onRequest', async (req, reply) => {
-    // Yes, the request object has a setDecorator method. 
-    // More information will be provided soon.
-    req.setDecorator('session', { user: 'Jean' })
-  })
-
-  fastify.get('/me', (request, reply) => {
-    const session = request.getDecorator<ISession>('session')
-    reply.send(session)
-  })
-})
-
-serverTwo.register(async function (fastify) {
-  const usersRepository = fastify.getDecorator<SqlLiteUsersRepository>(
-    'usersRepository'
-  )
-
-  fastify.decorateReply('sendSuccess', function (data) {
-    return this.send({ success: true })
-  })
-
-  fastify.get('/success', async (request, reply) => {
-    const sendSuccess = reply.getDecorator<SendSuccessFn>('sendSuccess')
-    await sendSuccess()
-  })
-})
-```
+> ℹ️ Note: For TypeScript users, `getDecorator` supports generic type parameters.
+> See the [TypeScript documentation](/docs/latest/Reference/TypeScript/) for
+> advanced typing examples.
 
-#### Bound functions inference
+#### `setDecorator(name, value)`
+<a id="set-decorator"></a>
 
-To save time, it's common to infer function types instead of 
-writing them manually:
+Used to safely update the value of a `Request` decorator.
+If the decorator does not exist, a `FST_ERR_DEC_UNDECLARED` error is thrown.
 
-```ts
-function sendSuccess (this: FastifyReply) {
-  return this.send({ success: true })
-}
-
-export type SendSuccess = typeof sendSuccess
-```
-
-However, `getDecorator` returns functions with the `this` 
-context already **bound**, meaning the `this` parameter disappears 
-from the function signature.
-
-To correctly type it, you should use `OmitThisParameter` utility:
-
-```ts
-function sendSuccess (this: FastifyReply) {
-  return this.send({ success: true })
-}
-
-type BoundSendSuccess = OmitThisParameter<typeof sendSuccess>
-
-fastify.decorateReply('sendSuccess', sendSuccess)
-fastify.get('/success', async (request, reply) => {
-  const sendSuccess = reply.getDecorator<BoundSendSuccess>('sendSuccess')
-  await sendSuccess()
-})
-```
-
-### `Request.setDecorator<T>` Method
-
-The `setDecorator<T>` method provides a safe and convenient way to 
-update the value of a `Request` decorator.  
-If the decorator does not exist, a `FST_ERR_DEC_UNDECLARED` error 
-is thrown.
-
-#### Use Cases
-
-**Runtime Safety**
-
-A typical way to set a `Request` decorator looks like this:
-
-```ts
-fastify.decorateRequest('user', '')
-fastify.addHook('preHandler', async (req, reply) => {
-  req.user = 'Bob Dylan'
-})
-```
-
-However, there is no guarantee that the decorator actually exists 
-unless you manually check beforehand.  
-Additionally, typos are common, e.g. `account`, `acount`, or `accout`.
-
-By using `setDecorator`, you are always sure that the decorator exists:
+```js
+fastify.decorateRequest('user', null)
 
-```ts
-fastify.decorateRequest('user', '')
 fastify.addHook('preHandler', async (req, reply) => {
-  // Throws FST_ERR_DEC_UNDECLARED if the decorator does not exist
-  req.setDecorator('user-with-typo', 'Bob Dylan')
+  // Safely set the decorator value
+  req.setDecorator('user', 'Bob Dylan')
 })
 ```
 
----
-
-**Type Safety**
+The `setDecorator` method provides runtime safety by ensuring the decorator exists
+before setting its value, preventing errors from typos in decorator names.
 
-If the `FastifyRequest` interface does not declare the decorator, you 
-would typically need to use type assertions:
-
-```ts
+```js
+fastify.decorateRequest('account', null)
 fastify.addHook('preHandler', async (req, reply) => {
-  (req as typeof req & { user: string }).user = 'Bob Dylan'
+  // This will throw FST_ERR_DEC_UNDECLARED due to typo in decorator name
+  req.setDecorator('acount', { id: 123 })
 })
 ```
 
-The `setDecorator<T>` method eliminates the need for explicit type 
-assertions while allowing type safety:
-
-```ts
-fastify.addHook('preHandler', async (req, reply) => {
-  req.setDecorator<string>('user', 'Bob Dylan')
-})
-```
+> ℹ️ Note: For TypeScript users, see the
+> [TypeScript documentation](/docs/latest/Reference/TypeScript/) for advanced
+> typing examples using `setDecorator<T>`.
diff --git a/docs/Reference/TypeScript.md b/docs/Reference/TypeScript.md
index 96409fcf..e647a860 100644
--- a/docs/Reference/TypeScript.md
+++ b/docs/Reference/TypeScript.md
@@ -687,6 +687,142 @@ Or even explicit config on tsconfig
 }
 ```
 
+#### `getDecorator<T>`
+
+Fastify's `getDecorator<T>` method retrieves decorators with enhanced type safety.
+
+The `getDecorator<T>` method supports generic type parameters for enhanced type safety:
+
+```typescript
+// Type-safe decorator retrieval
+const usersRepository = fastify.getDecorator<IUsersRepository>('usersRepository')
+const session = request.getDecorator<ISession>('session')
+const sendSuccess = reply.getDecorator<SendSuccessFn>('sendSuccess')
+```
+
+**Alternative to Module Augmentation**
+
+Decorators are typically typed via module augmentation:
+
+```typescript
+declare module 'fastify' {
+  interface FastifyInstance {
+    usersRepository: IUsersRepository
+  }
+  interface FastifyRequest {
+    session: ISession
+  }
+  interface FastifyReply {
+    sendSuccess: SendSuccessFn
+  }
+}
+```
+
+This approach modifies the Fastify instance globally, which may lead to conflicts
+and inconsistent behavior in multi-server setups or with plugin encapsulation.
+
+Using `getDecorator<T>` allows limiting types scope:
+
+```typescript
+serverOne.register(async function (fastify) {
+  const usersRepository = fastify.getDecorator<PostgreUsersRepository>(
+    'usersRepository'
+  )
+
+  fastify.decorateRequest('session', null)
+  fastify.addHook('onRequest', async (req, reply) => {
+    req.setDecorator('session', { user: 'Jean' })
+  })
+
+  fastify.get('/me', (request, reply) => {
+    const session = request.getDecorator<ISession>('session')
+    reply.send(session)
+  })
+})
+
+serverTwo.register(async function (fastify) {
+  const usersRepository = fastify.getDecorator<SqlLiteUsersRepository>(
+    'usersRepository'
+  )
+
+  fastify.decorateReply('sendSuccess', function (data) {
+    return this.send({ success: true })
+  })
+
+  fastify.get('/success', async (request, reply) => {
+    const sendSuccess = reply.getDecorator<SendSuccessFn>('sendSuccess')
+    await sendSuccess()
+  })
+})
+```
+
+**Bound Functions Inference**
+
+To save time, it is common to infer function types instead of writing them manually:
+
+```typescript
+function sendSuccess (this: FastifyReply) {
+  return this.send({ success: true })
+}
+
+export type SendSuccess = typeof sendSuccess
+```
+
+However, `getDecorator` returns functions with the `this` context already **bound**,
+meaning the `this` parameter disappears from the function signature.
+
+To correctly type it, use the `OmitThisParameter` utility:
+
+```typescript
+function sendSuccess (this: FastifyReply) {
+  return this.send({ success: true })
+}
+
+type BoundSendSuccess = OmitThisParameter<typeof sendSuccess>
+
+fastify.decorateReply('sendSuccess', sendSuccess)
+fastify.get('/success', async (request, reply) => {
+  const sendSuccess = reply.getDecorator<BoundSendSuccess>('sendSuccess')
+  await sendSuccess()
+})
+```
+
+#### `setDecorator<T>`
+
+Fastify's `setDecorator<T>` method provides enhanced type safety for updating request
+decorators.
+
+The `setDecorator<T>` method provides enhanced type safety for updating request
+decorators:
+
+```typescript
+fastify.decorateRequest('user', '')
+fastify.addHook('preHandler', async (req, reply) => {
+  // Type-safe decorator setting
+  req.setDecorator<string>('user', 'Bob Dylan')
+})
+```
+
+**Type Safety Benefits**
+
+If the `FastifyRequest` interface does not declare the decorator, type assertions
+are typically needed:
+
+```typescript
+fastify.addHook('preHandler', async (req, reply) => {
+  (req as typeof req & { user: string }).user = 'Bob Dylan'
+})
+```
+
+The `setDecorator<T>` method eliminates the need for explicit type assertions
+while providing type safety:
+
+```typescript
+fastify.addHook('preHandler', async (req, reply) => {
+  req.setDecorator<string>('user', 'Bob Dylan')
+})
+```
+
 ## Code Completion In Vanilla JavaScript
 
 Vanilla JavaScript can use the published types to provide code completion (e.g.
