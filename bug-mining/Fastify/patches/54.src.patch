diff --git a/lib/reply.js b/lib/reply.js
index e1c05b24..dcb1a4d3 100644
--- a/lib/reply.js
+++ b/lib/reply.js
@@ -92,7 +92,8 @@ Object.defineProperties(Reply.prototype, {
         throw new FST_ERR_REP_SENT_VALUE()
       }
 
-      if (this.sent) {
+      // We throw only if sent was overwritten from Fastify
+      if (this.sent && this[kReplySentOverwritten]) {
         throw new FST_ERR_REP_ALREADY_SENT()
       }
 
diff --git a/test/internals/reply.test.js b/test/internals/reply.test.js
index 231f68e5..789502d2 100644
--- a/test/internals/reply.test.js
+++ b/test/internals/reply.test.js
@@ -1329,6 +1329,7 @@ test('should throw error when attempting to set reply.sent more than once', t =>
     reply.sent = true
     try {
       reply.sent = true
+      t.fail('must throw')
     } catch (err) {
       t.equal(err.code, 'FST_ERR_REP_ALREADY_SENT')
       t.equal(err.message, 'Reply was already sent.')
@@ -1342,6 +1343,23 @@ test('should throw error when attempting to set reply.sent more than once', t =>
   })
 })
 
+test('should not throw error when attempting to set reply.sent if the underlining request was sent', t => {
+  t.plan(3)
+  const fastify = require('../..')()
+
+  fastify.get('/', function (req, reply) {
+    reply.raw.end()
+    t.doesNotThrow(() => {
+      reply.sent = true
+    })
+  })
+
+  fastify.inject('/', (err, res) => {
+    t.error(err)
+    t.pass()
+  })
+})
+
 test('reply.getResponseTime() should return 0 before the timer is initialised on the reply by setting up response listeners', t => {
   t.plan(1)
   const response = { statusCode: 200 }
