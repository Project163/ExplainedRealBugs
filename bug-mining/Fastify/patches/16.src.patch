diff --git a/docs/Hooks.md b/docs/Hooks.md
index cfad1b56..932aedcb 100644
--- a/docs/Hooks.md
+++ b/docs/Hooks.md
@@ -83,6 +83,7 @@ fastify.addHook('onResponse', async (res) => {
 | res | Node.js [ServerResponse](https://nodejs.org/api/http.html#http_class_http_serverresponse) |
 | request | Fastify [Request](https://github.com/fastify/fastify/blob/master/docs/Request.md) interface |
 | reply | Fastify [Reply](https://github.com/fastify/fastify/blob/master/docs/Reply.md) interface |
+| payload | The serialized payload |
 | next | Function to continue with the [lifecycle](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md) |
 
 It is pretty easy to understand where each hook is executed by looking at the [lifecycle page](https://github.com/fastify/fastify/blob/master/docs/Lifecycle.md).<br>
@@ -108,23 +109,38 @@ fastify.addHook('preHandler', (request, reply, next) => {
 
 Note that in the `'preHandler'` and `'onSend'` hook the request and reply objects are different from `'onRequest'`, because the two arguments are [`request`](https://github.com/fastify/fastify/blob/master/docs/Request.md) and [`reply`](https://github.com/fastify/fastify/blob/master/docs/Reply.md) core Fastify objects.
 
-If you are using the `onSend` hook you can update the payload, for example:
-```js
+#### The `onSend` Hook
 
-fastify.addHook('onSend', (request, reply, payload, next) => {
-  var err = null;
-  payload.hello = 'world'
-  next(err, payload)
-})
+If you are using the `onSend` hook, you can change the payload. For example:
 
-// Or
+```js
 fastify.addHook('onSend', (request, reply, payload, next) => {
   var err = null;
   var newPayload = payload.replace('some-text', 'some-new-text')
   next(err, newPayload)
 })
+
+// Or async
+fastify.addHook('onSend', async (request, reply, payload) => {
+  var newPayload = payload.replace('some-text', 'some-new-text')
+  return newPayload
+})
 ```
 
+You can also clear the payload to send a response with an empty body by replacing the payload with `null`:
+
+```js
+fastify.addHook('onSend', (request, reply, payload, next) => {
+  reply.code(304)
+  const newPayload = null
+  next(null, newPayload)
+})
+```
+
+> You can also send an empty body by replacing the payload with the empty string `''`, but be aware that this will cause the `Content-Length` header to be set to `0`, whereas the `Content-Length` header will not be set if the payload is `null`.
+
+Note: If you change the payload, you may only change it to a `string`, a `Buffer`, a `stream`, or `null`.
+
 ## Application Hooks
 
 You are able to hook into the application-lifecycle as well. It's important to note that these hooks aren't fully encapsulated. The `this` inside the hooks are encapsulated but the handlers can respond to an event outside the encapsulation boundaries.
diff --git a/lib/reply.js b/lib/reply.js
index b9d2c585..ab98d16e 100644
--- a/lib/reply.js
+++ b/lib/reply.js
@@ -41,8 +41,39 @@ Reply.prototype.send = function (payload) {
     return
   }
 
+  if (payload === undefined) {
+    onSendHook(this, payload)
+    return
+  }
+
+  const contentType = this.res.getHeader('Content-Type')
+  const contentTypeNotSet = contentType === undefined
+
+  if (payload !== null) {
+    if (Buffer.isBuffer(payload) || typeof payload.pipe === 'function') {
+      if (contentTypeNotSet) {
+        this.res.setHeader('Content-Type', 'application/octet-stream')
+      }
+      onSendHook(this, payload)
+      return
+    }
+
+    if (contentTypeNotSet && typeof payload === 'string') {
+      this.res.setHeader('Content-Type', 'text/plain')
+      onSendHook(this, payload)
+      return
+    }
+  }
+
+  if (this._serializer) {
+    payload = this._serializer(payload)
+  } else if (contentTypeNotSet || contentType === 'application/json') {
+    this.res.setHeader('Content-Type', 'application/json')
+    payload = serialize(this.context, payload, this.res.statusCode)
+    flatstr(payload)
+  }
+
   onSendHook(this, payload)
-  return
 }
 
 Reply.prototype.header = function (key, value) {
@@ -122,40 +153,19 @@ function wrapOnSendEnd (err, payload) {
 }
 
 function onSendEnd (reply, payload) {
-  if (payload === undefined) {
+  if (payload === undefined || payload === null) {
     reply.sent = true
     reply.res.end()
     return
   }
 
-  var contentType = reply.res.getHeader('Content-Type')
-  if (payload !== null && typeof payload.pipe === 'function') {
-    if (!contentType) {
-      reply.res.setHeader('Content-Type', 'application/octet-stream')
-    }
+  if (typeof payload.pipe === 'function') {
     pump(payload, reply.res, pumpCallback(reply))
     return
   }
 
-  var isPayloadString = typeof payload === 'string'
-
-  if (!contentType && isPayloadString) {
-    reply.res.setHeader('Content-Type', 'text/plain')
-  } else if (Buffer.isBuffer(payload)) {
-    if (!contentType) {
-      reply.res.setHeader('Content-Type', 'application/octet-stream')
-    }
-  } else if (reply._serializer) {
-    payload = reply._serializer(payload)
-    if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
-      throw new TypeError(`Serializer for Content-Type '${contentType}' returned invalid payload of type '${typeof payload}'. Expected a string or Buffer.`)
-    }
-  } else if (!contentType || contentType === 'application/json') {
-    reply.res.setHeader('Content-Type', 'application/json')
-    payload = serialize(reply.context, payload, reply.res.statusCode)
-    flatstr(payload)
-  } else if (!isPayloadString && !Buffer.isBuffer(payload)) {
-    throw new TypeError(`Attempted to send payload of invalid type '${typeof payload}' without serialization. Expected a string or Buffer.`)
+  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {
+    throw new TypeError(`Attempted to send payload of invalid type '${typeof payload}'. Expected a string or Buffer.`)
   }
 
   if (!reply.res.getHeader('Content-Length')) {
@@ -214,11 +224,12 @@ function handleError (reply, error, cb) {
     return
   }
 
-  var payload = {
+  var payload = serializeError({
     error: statusCodes[statusCode + ''],
     message: error ? error.message : '',
     statusCode: statusCode
-  }
+  })
+  flatstr(payload)
   reply.res.setHeader('Content-Type', 'application/json')
 
   if (cb) {
@@ -226,9 +237,6 @@ function handleError (reply, error, cb) {
     return
   }
 
-  payload = serializeError(payload)
-  flatstr(payload)
-
   reply.res.setHeader('Content-Length', '' + Buffer.byteLength(payload))
   reply.sent = true
   reply.res.end(payload)
diff --git a/test/hooks-async.js b/test/hooks-async.js
index 6f004788..b37a9a31 100644
--- a/test/hooks-async.js
+++ b/test/hooks-async.js
@@ -91,25 +91,23 @@ function asyncHookTest (t) {
     const fastify = Fastify()
     const payload = { hello: 'world' }
     const modifiedPayload = { hello: 'modified' }
-    const anotherPayload = { winter: 'is coming' }
+    const anotherPayload = '"winter is coming"'
 
     fastify.addHook('onSend', async function (request, reply, thePayload) {
       t.ok('onSend called')
-      t.deepEqual(thePayload, payload)
-      // onSend allows only to modify Object keys and not the full object's reference
-      thePayload.hello = 'modified'
-      return thePayload
+      t.deepEqual(JSON.parse(thePayload), payload)
+      return thePayload.replace('world', 'modified')
     })
 
     fastify.addHook('onSend', async function (request, reply, thePayload) {
       t.ok('onSend called')
-      t.deepEqual(thePayload, modifiedPayload)
+      t.deepEqual(JSON.parse(thePayload), modifiedPayload)
       return anotherPayload
     })
 
     fastify.addHook('onSend', async function (request, reply, thePayload) {
       t.ok('onSend called')
-      t.deepEqual(thePayload, anotherPayload)
+      t.strictEqual(thePayload, anotherPayload)
     })
 
     fastify.get('/', (req, reply) => {
@@ -121,9 +119,9 @@ function asyncHookTest (t) {
       url: '/'
     }, (err, res) => {
       t.error(err)
-      t.deepEqual(anotherPayload, JSON.parse(res.payload))
+      t.strictEqual(res.payload, anotherPayload)
       t.strictEqual(res.statusCode, 200)
-      t.strictEqual(res.headers['content-length'], '22')
+      t.strictEqual(res.headers['content-length'], '18')
     })
   })
 }
diff --git a/test/hooks.test.js b/test/hooks.test.js
index 0f1a4af6..57e39670 100644
--- a/test/hooks.test.js
+++ b/test/hooks.test.js
@@ -3,6 +3,7 @@
 const t = require('tap')
 const test = t.test
 const sget = require('simple-get').concat
+const stream = require('stream')
 const Fastify = require('..')
 
 const payload = { hello: 'world' }
@@ -646,30 +647,171 @@ test('onSend hook should support encapsulation / 2', t => {
   })
 })
 
+test('onSend hook is called after payload is serialized and headers are set', t => {
+  t.plan(30)
+  const fastify = Fastify()
+
+  fastify.register((instance, opts, next) => {
+    const thePayload = { hello: 'world' }
+
+    instance.addHook('onSend', function (request, reply, payload, next) {
+      t.deepEqual(JSON.parse(payload), thePayload)
+      t.strictEqual(reply.res.getHeader('Content-Type'), 'application/json')
+      next()
+    })
+
+    instance.get('/json', (request, reply) => {
+      reply.send(thePayload)
+    })
+
+    next()
+  })
+
+  fastify.register((instance, opts, next) => {
+    instance.addHook('onSend', function (request, reply, payload, next) {
+      t.strictEqual(payload, 'some text')
+      t.strictEqual(reply.res.getHeader('Content-Type'), 'text/plain')
+      next()
+    })
+
+    instance.get('/text', (request, reply) => {
+      reply.send('some text')
+    })
+
+    next()
+  })
+
+  fastify.register((instance, opts, next) => {
+    const thePayload = Buffer.from('buffer payload')
+
+    instance.addHook('onSend', function (request, reply, payload, next) {
+      t.strictEqual(payload, thePayload)
+      t.strictEqual(reply.res.getHeader('Content-Type'), 'application/octet-stream')
+      next()
+    })
+
+    instance.get('/buffer', (request, reply) => {
+      reply.send(thePayload)
+    })
+
+    next()
+  })
+
+  fastify.register((instance, opts, next) => {
+    var chunk = 'stream payload'
+    const thePayload = new stream.Readable({
+      read () {
+        this.push(chunk)
+        chunk = null
+      }
+    })
+
+    instance.addHook('onSend', function (request, reply, payload, next) {
+      t.strictEqual(payload, thePayload)
+      t.strictEqual(reply.res.getHeader('Content-Type'), 'application/octet-stream')
+      next()
+    })
+
+    instance.get('/stream', (request, reply) => {
+      reply.send(thePayload)
+    })
+
+    next()
+  })
+
+  fastify.register((instance, opts, next) => {
+    const serializedPayload = 'serialized'
+
+    instance.addHook('onSend', function (request, reply, payload, next) {
+      t.strictEqual(payload, serializedPayload)
+      t.strictEqual(reply.res.getHeader('Content-Type'), 'text/custom')
+      next()
+    })
+
+    instance.get('/custom-serializer', (request, reply) => {
+      reply
+        .serializer(() => serializedPayload)
+        .type('text/custom')
+        .send('needs to be serialized')
+    })
+
+    next()
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/json'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.deepEqual(JSON.parse(res.payload), { hello: 'world' })
+    t.strictEqual(res.headers['content-length'], '17')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/text'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.deepEqual(res.payload, 'some text')
+    t.strictEqual(res.headers['content-length'], '9')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/buffer'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.deepEqual(res.payload, 'buffer payload')
+    t.strictEqual(res.headers['content-length'], '14')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/stream'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.deepEqual(res.payload, 'stream payload')
+    t.strictEqual(res.headers['transfer-encoding'], 'chunked')
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/custom-serializer'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 200)
+    t.deepEqual(res.payload, 'serialized')
+    t.strictEqual(res.headers['content-type'], 'text/custom')
+  })
+})
+
 test('modify payload', t => {
   t.plan(10)
   const fastify = Fastify()
   const payload = { hello: 'world' }
   const modifiedPayload = { hello: 'modified' }
-  const anotherPayload = { winter: 'is coming' }
+  const anotherPayload = '"winter is coming"'
 
   fastify.addHook('onSend', function (request, reply, thePayload, next) {
     t.ok('onSend called')
-    t.deepEqual(thePayload, payload)
-    // onSend allows only to modify Object keys and not the full object's reference
-    thePayload.hello = 'modified'
+    t.deepEqual(JSON.parse(thePayload), payload)
+    thePayload = thePayload.replace('world', 'modified')
     next(null, thePayload)
   })
 
   fastify.addHook('onSend', function (request, reply, thePayload, next) {
     t.ok('onSend called')
-    t.deepEqual(thePayload, modifiedPayload)
+    t.deepEqual(JSON.parse(thePayload), modifiedPayload)
     next(null, anotherPayload)
   })
 
   fastify.addHook('onSend', function (request, reply, thePayload, next) {
     t.ok('onSend called')
-    t.deepEqual(thePayload, anotherPayload)
+    t.strictEqual(thePayload, anotherPayload)
     next()
   })
 
@@ -682,9 +824,35 @@ test('modify payload', t => {
     url: '/'
   }, (err, res) => {
     t.error(err)
-    t.deepEqual(anotherPayload, JSON.parse(res.payload))
+    t.strictEqual(res.payload, anotherPayload)
     t.strictEqual(res.statusCode, 200)
-    t.strictEqual(res.headers['content-length'], '22')
+    t.strictEqual(res.headers['content-length'], '18')
+  })
+})
+
+test('clear payload', t => {
+  t.plan(6)
+  const fastify = Fastify()
+
+  fastify.addHook('onSend', function (request, reply, payload, next) {
+    t.ok('onSend called')
+    reply.code(304)
+    next(null, null)
+  })
+
+  fastify.get('/', (req, reply) => {
+    reply.send({ hello: 'world' })
+  })
+
+  fastify.inject({
+    method: 'GET',
+    url: '/'
+  }, (err, res) => {
+    t.error(err)
+    t.strictEqual(res.statusCode, 304)
+    t.strictEqual(res.payload, '')
+    t.strictEqual(res.headers['content-length'], undefined)
+    t.strictEqual(res.headers['content-type'], 'application/json')
   })
 })
 
diff --git a/test/internals/handleRequest.test.js b/test/internals/handleRequest.test.js
index dd1cc004..db696ab0 100644
--- a/test/internals/handleRequest.test.js
+++ b/test/internals/handleRequest.test.js
@@ -220,7 +220,7 @@ test('request should respond with an error if an unserialized payload is sent in
     t.strictEqual(res.statusCode, 500)
     t.deepEqual(JSON.parse(res.payload), {
       error: 'Internal Server Error',
-      message: 'Attempted to send payload of invalid type \'object\' without serialization. Expected a string or Buffer.',
+      message: 'Attempted to send payload of invalid type \'object\'. Expected a string or Buffer.',
       statusCode: 500
     })
   })
diff --git a/test/internals/reply.test.js b/test/internals/reply.test.js
index 81cfc98d..db7d3fa0 100644
--- a/test/internals/reply.test.js
+++ b/test/internals/reply.test.js
@@ -4,7 +4,6 @@ const t = require('tap')
 const test = t.test
 const sget = require('simple-get').concat
 const http = require('http')
-const zlib = require('zlib')
 
 const Reply = require('../../lib/reply')
 
@@ -203,36 +202,6 @@ test('within an instance', t => {
   })
 })
 
-test('use reply.serialize in onSend hook', t => {
-  t.plan(4)
-
-  const fastify = require('../..')()
-  fastify.addHook('onSend', (request, reply, payload, next) => {
-    function _serialize () {
-      const _payload = reply.serialize(payload)
-      return zlib.gzipSync(_payload)
-    }
-    reply.serializer(_serialize)
-    reply.header('Content-Encoding', 'gzip')
-    next()
-  })
-  fastify.get('/', (request, reply) => {
-    reply.send({ hello: 'world' })
-  })
-  fastify.listen(0, err => {
-    t.error(err)
-    fastify.server.unref()
-    sget({
-      method: 'GET',
-      url: 'http://localhost:' + fastify.server.address().port
-    }, (err, response, body) => {
-      t.error(err)
-      t.strictEqual(response.statusCode, 200)
-      t.deepEqual(JSON.parse(body), { hello: 'world' })
-    })
-  })
-})
-
 test('buffer without content type should send a application/octet-stream and raw buffer', t => {
   t.plan(4)
 
@@ -478,7 +447,11 @@ test('reply.notFound() should invoke the 404 handler', t => {
       t.error(err)
       t.strictEqual(response.statusCode, 404)
       t.strictEqual(response.headers['content-type'], 'application/json')
-      t.deepEqual(body.toString(), '{"error":"Not Found","message":"Not found","statusCode":404}')
+      t.deepEqual(JSON.parse(body.toString()), {
+        statusCode: 404,
+        error: 'Not Found',
+        message: 'Not found'
+      })
     })
 
     sget({
diff --git a/test/reply-error.test.js b/test/reply-error.test.js
index 3a9a3872..104964c7 100644
--- a/test/reply-error.test.js
+++ b/test/reply-error.test.js
@@ -358,7 +358,7 @@ test('\'*\' should throw an error due to serializer can not handle the payload t
       reply.send({})
     } catch (err) {
       t.type(err, TypeError)
-      t.strictEqual(err.message, "Attempted to send payload of invalid type 'object' without serialization. Expected a string or Buffer.")
+      t.strictEqual(err.message, "Attempted to send payload of invalid type 'object'. Expected a string or Buffer.")
     }
   })
 
@@ -370,7 +370,7 @@ test('\'*\' should throw an error due to serializer can not handle the payload t
   })
 })
 
-test('should throw an error due to custom serializer can not handle the payload type', t => {
+test('should throw an error if the custom serializer does not serialize the payload to a valid type', t => {
   t.plan(2)
   const fastify = Fastify()
 
@@ -382,7 +382,7 @@ test('should throw an error due to custom serializer can not handle the payload
       .send({})
     } catch (err) {
       t.type(err, TypeError)
-      t.strictEqual(err.message, "Serializer for Content-Type 'text/html' returned invalid payload of type 'object'. Expected a string or Buffer.")
+      t.strictEqual(err.message, "Attempted to send payload of invalid type 'object'. Expected a string or Buffer.")
     }
   })
 
