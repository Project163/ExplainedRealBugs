diff --git a/sqlx-core/src/mssql/types/str.rs b/sqlx-core/src/mssql/types/str.rs
index 4902d783..048dd84c 100644
--- a/sqlx-core/src/mssql/types/str.rs
+++ b/sqlx-core/src/mssql/types/str.rs
@@ -5,6 +5,7 @@ use crate::mssql::io::MssqlBufMutExt;
 use crate::mssql::protocol::type_info::{Collation, CollationFlags, DataType, TypeInfo};
 use crate::mssql::{Mssql, MssqlTypeInfo, MssqlValueRef};
 use crate::types::Type;
+use std::borrow::Cow;
 
 impl Type<Mssql> for str {
     fn type_info() -> MssqlTypeInfo {
@@ -81,3 +82,33 @@ impl Decode<'_, Mssql> for String {
             .into_owned())
     }
 }
+
+impl Encode<'_, Mssql> for Cow<'_, str> {
+    fn produces(&self) -> Option<MssqlTypeInfo> {
+        match self {
+            Cow::Borrowed(str) => <&str as Encode<Mssql>>::produces(str),
+            Cow::Owned(str) => <&str as Encode<Mssql>>::produces(&(str.as_ref())),
+        }
+    }
+
+    fn encode_by_ref(&self, buf: &mut Vec<u8>) -> IsNull {
+        match self {
+            Cow::Borrowed(str) => <&str as Encode<Mssql>>::encode_by_ref(str, buf),
+            Cow::Owned(str) => <&str as Encode<Mssql>>::encode_by_ref(&(str.as_ref()), buf),
+        }
+    }
+}
+
+impl<'r> Decode<'r, Mssql> for Cow<'r, str> {
+    fn decode(value: MssqlValueRef<'r>) -> Result<Self, BoxDynError> {
+        Ok(Cow::Owned(
+            value
+                .type_info
+                .0
+                .encoding()?
+                .decode_without_bom_handling(value.as_bytes()?)
+                .0
+                .into_owned(),
+        ))
+    }
+}
diff --git a/sqlx-core/src/mysql/types/str.rs b/sqlx-core/src/mysql/types/str.rs
index 19e3de62..07685890 100644
--- a/sqlx-core/src/mysql/types/str.rs
+++ b/sqlx-core/src/mysql/types/str.rs
@@ -5,6 +5,7 @@ use crate::mysql::io::MySqlBufMutExt;
 use crate::mysql::protocol::text::{ColumnFlags, ColumnType};
 use crate::mysql::{MySql, MySqlTypeInfo, MySqlValueRef};
 use crate::types::Type;
+use std::borrow::Cow;
 
 const COLLATE_UTF8_GENERAL_CI: u16 = 33;
 const COLLATE_UTF8_UNICODE_CI: u16 = 192;
@@ -80,3 +81,18 @@ impl Decode<'_, MySql> for String {
         <&str as Decode<MySql>>::decode(value).map(ToOwned::to_owned)
     }
 }
+
+impl Encode<'_, MySql> for Cow<'_, str> {
+    fn encode_by_ref(&self, buf: &mut Vec<u8>) -> IsNull {
+        match self {
+            Cow::Borrowed(str) => <&str as Encode<MySql>>::encode(*str, buf),
+            Cow::Owned(str) => <&str as Encode<MySql>>::encode(&**str, buf),
+        }
+    }
+}
+
+impl<'r> Decode<'r, MySql> for Cow<'r, str> {
+    fn decode(value: MySqlValueRef<'r>) -> Result<Self, BoxDynError> {
+        value.as_str().map(Cow::Borrowed)
+    }
+}
diff --git a/sqlx-core/src/postgres/types/str.rs b/sqlx-core/src/postgres/types/str.rs
index 3607a4b8..7a721569 100644
--- a/sqlx-core/src/postgres/types/str.rs
+++ b/sqlx-core/src/postgres/types/str.rs
@@ -4,6 +4,7 @@ use crate::error::BoxDynError;
 use crate::postgres::types::array_compatible;
 use crate::postgres::{PgArgumentBuffer, PgTypeInfo, PgValueRef, Postgres};
 use crate::types::Type;
+use std::borrow::Cow;
 
 impl Type<Postgres> for str {
     fn type_info() -> PgTypeInfo {
@@ -22,6 +23,16 @@ impl Type<Postgres> for str {
     }
 }
 
+impl Type<Postgres> for Cow<'_, str> {
+    fn type_info() -> PgTypeInfo {
+        <&str as Type<Postgres>>::type_info()
+    }
+
+    fn compatible(ty: &PgTypeInfo) -> bool {
+        <&str as Type<Postgres>>::compatible(ty)
+    }
+}
+
 impl Type<Postgres> for [&'_ str] {
     fn type_info() -> PgTypeInfo {
         PgTypeInfo::TEXT_ARRAY
@@ -50,6 +61,15 @@ impl Encode<'_, Postgres> for &'_ str {
     }
 }
 
+impl Encode<'_, Postgres> for Cow<'_, str> {
+    fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> IsNull {
+        match self {
+            Cow::Borrowed(str) => <&str as Encode<Postgres>>::encode(*str, buf),
+            Cow::Owned(str) => <&str as Encode<Postgres>>::encode(&**str, buf),
+        }
+    }
+}
+
 impl Encode<'_, Postgres> for String {
     fn encode_by_ref(&self, buf: &mut PgArgumentBuffer) -> IsNull {
         <&str as Encode<Postgres>>::encode(&**self, buf)
@@ -62,6 +82,12 @@ impl<'r> Decode<'r, Postgres> for &'r str {
     }
 }
 
+impl<'r> Decode<'r, Postgres> for Cow<'r, str> {
+    fn decode(value: PgValueRef<'r>) -> Result<Self, BoxDynError> {
+        Ok(Cow::Borrowed(value.as_str()?))
+    }
+}
+
 impl Type<Postgres> for String {
     fn type_info() -> PgTypeInfo {
         <&str as Type<Postgres>>::type_info()
diff --git a/sqlx-core/src/sqlite/types/str.rs b/sqlx-core/src/sqlite/types/str.rs
index 6a3ed533..086597ef 100644
--- a/sqlx-core/src/sqlite/types/str.rs
+++ b/sqlx-core/src/sqlite/types/str.rs
@@ -52,3 +52,23 @@ impl<'r> Decode<'r, Sqlite> for String {
         value.text().map(ToOwned::to_owned)
     }
 }
+
+impl<'q> Encode<'q, Sqlite> for Cow<'q, str> {
+    fn encode(self, args: &mut Vec<SqliteArgumentValue<'q>>) -> IsNull {
+        args.push(SqliteArgumentValue::Text(self));
+
+        IsNull::No
+    }
+
+    fn encode_by_ref(&self, args: &mut Vec<SqliteArgumentValue<'q>>) -> IsNull {
+        args.push(SqliteArgumentValue::Text(self.clone()));
+
+        IsNull::No
+    }
+}
+
+impl<'r> Decode<'r, Sqlite> for Cow<'r, str> {
+    fn decode(value: SqliteValueRef<'r>) -> Result<Self, BoxDynError> {
+        value.text().map(Cow::Borrowed)
+    }
+}
