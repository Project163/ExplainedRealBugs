diff --git a/Cargo.lock b/Cargo.lock
index 69fe3ba1..640d9b97 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1029,12 +1029,6 @@ version = "1.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "62aca2aba2d62b4a7f5b33f3712cb1b0692779a56fb510499d5c0aa594daeaf3"
 
-[[package]]
-name = "hashbrown"
-version = "0.9.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04"
-
 [[package]]
 name = "hashbrown"
 version = "0.11.2"
@@ -1050,7 +1044,7 @@ version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7249a3129cbc1ffccd74857f81464a323a152173cdb134e0fd81bc803b29facf"
 dependencies = [
- "hashbrown 0.11.2",
+ "hashbrown",
 ]
 
 [[package]]
@@ -1115,12 +1109,12 @@ dependencies = [
 
 [[package]]
 name = "indexmap"
-version = "1.6.2"
+version = "1.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "824845a0bf897a9042383849b02c1bc219c2383772efcd5c6f9766fa4b81aef3"
+checksum = "bc633605454125dec4b66843673f01c7df2b89479b32e0ed634e43a91cff62a5"
 dependencies = [
  "autocfg 1.0.1",
- "hashbrown 0.9.1",
+ "hashbrown",
 ]
 
 [[package]]
@@ -2424,6 +2418,7 @@ dependencies = [
  "hashlink",
  "hex",
  "hmac",
+ "indexmap",
  "ipnetwork",
  "itoa",
  "libc",
diff --git a/sqlx-core/src/sqlite/connection/executor.rs b/sqlx-core/src/sqlite/connection/executor.rs
index 09bbc6cf..5ff7557d 100644
--- a/sqlx-core/src/sqlite/connection/executor.rs
+++ b/sqlx-core/src/sqlite/connection/executor.rs
@@ -152,7 +152,7 @@ impl<'c> Executor<'c> for &'c mut SqliteConnection {
 
                         Either::Right(()) => {
                             let (row, weak_values_ref) = SqliteRow::current(
-                                &stmt,
+                                stmt.to_ref(conn.to_ref()),
                                 columns,
                                 column_names
                             );
@@ -216,8 +216,11 @@ impl<'c> Executor<'c> for &'c mut SqliteConnection {
                     Either::Left(_) => (),
 
                     Either::Right(()) => {
-                        let (row, weak_values_ref) =
-                            SqliteRow::current(stmt, columns, column_names);
+                        let (row, weak_values_ref) = SqliteRow::current(
+                            stmt.to_ref(self.handle.to_ref()),
+                            columns,
+                            column_names,
+                        );
 
                         *last_row_values = Some(weak_values_ref);
 
diff --git a/sqlx-core/src/sqlite/connection/handle.rs b/sqlx-core/src/sqlite/connection/handle.rs
index bf59d41f..c714fcc5 100644
--- a/sqlx-core/src/sqlite/connection/handle.rs
+++ b/sqlx-core/src/sqlite/connection/handle.rs
@@ -15,6 +15,7 @@ pub(crate) struct ConnectionHandle(Arc<HandleInner>);
 /// or `sqlite3_reset()`.
 ///
 /// Note that this does *not* actually give access to the database handle!
+#[derive(Clone, Debug)]
 pub(crate) struct ConnectionHandleRef(Arc<HandleInner>);
 
 // Wrapper for `*mut sqlite3` which finalizes the handle on-drop.
diff --git a/sqlx-core/src/sqlite/connection/mod.rs b/sqlx-core/src/sqlite/connection/mod.rs
index c18add85..4edb9d93 100644
--- a/sqlx-core/src/sqlite/connection/mod.rs
+++ b/sqlx-core/src/sqlite/connection/mod.rs
@@ -104,8 +104,7 @@ impl Connection for SqliteConnection {
 
 impl Drop for SqliteConnection {
     fn drop(&mut self) {
-        // before the connection handle is dropped,
-        // we must explicitly drop the statements as the drop-order in a struct is undefined
+        // explicitly drop statements before the connection handle is dropped
         self.statements.clear();
         self.statement.take();
     }
diff --git a/sqlx-core/src/sqlite/row.rs b/sqlx-core/src/sqlite/row.rs
index f1e15f59..4199915f 100644
--- a/sqlx-core/src/sqlite/row.rs
+++ b/sqlx-core/src/sqlite/row.rs
@@ -11,7 +11,7 @@ use crate::column::ColumnIndex;
 use crate::error::Error;
 use crate::ext::ustr::UStr;
 use crate::row::Row;
-use crate::sqlite::statement::StatementHandle;
+use crate::sqlite::statement::{StatementHandle, StatementHandleRef};
 use crate::sqlite::{Sqlite, SqliteColumn, SqliteValue, SqliteValueRef};
 
 /// Implementation of [`Row`] for SQLite.
@@ -23,7 +23,7 @@ pub struct SqliteRow {
     // IF the user drops the Row before iterating the stream (so
     // nearly all of our internal stream iterators), the executor moves on; otherwise,
     // it actually inflates this row with a list of owned sqlite3 values.
-    pub(crate) statement: Arc<StatementHandle>,
+    pub(crate) statement: StatementHandleRef,
 
     pub(crate) values: Arc<AtomicPtr<SqliteValue>>,
     pub(crate) num_values: usize,
@@ -48,7 +48,7 @@ impl SqliteRow {
     // returns a weak reference to an atomic list where the executor should inflate if its going
     // to increment the statement with [step]
     pub(crate) fn current(
-        statement: &Arc<StatementHandle>,
+        statement: StatementHandleRef,
         columns: &Arc<Vec<SqliteColumn>>,
         column_names: &Arc<HashMap<UStr, usize>>,
     ) -> (Self, Weak<AtomicPtr<SqliteValue>>) {
@@ -57,7 +57,7 @@ impl SqliteRow {
         let size = statement.column_count();
 
         let row = Self {
-            statement: Arc::clone(statement),
+            statement,
             values,
             num_values: size,
             columns: Arc::clone(columns),
diff --git a/sqlx-core/src/sqlite/statement/handle.rs b/sqlx-core/src/sqlite/statement/handle.rs
index 78f2ff2a..27e7b590 100644
--- a/sqlx-core/src/sqlite/statement/handle.rs
+++ b/sqlx-core/src/sqlite/statement/handle.rs
@@ -20,12 +20,25 @@ use libsqlite3_sys::{
 };
 
 use crate::error::{BoxDynError, Error};
+use crate::sqlite::connection::ConnectionHandleRef;
 use crate::sqlite::type_info::DataType;
 use crate::sqlite::{SqliteError, SqliteTypeInfo};
+use std::ops::Deref;
+use std::sync::Arc;
 
 #[derive(Debug)]
 pub(crate) struct StatementHandle(NonNull<sqlite3_stmt>);
 
+// wrapper for `Arc<StatementHandle>` which also holds a reference to the `ConnectionHandle`
+#[derive(Clone, Debug)]
+pub(crate) struct StatementHandleRef {
+    // NOTE: the ordering of fields here determines the drop order:
+    // https://doc.rust-lang.org/reference/destructors.html#destructors
+    // the statement *must* be dropped before the connection
+    statement: Arc<StatementHandle>,
+    connection: ConnectionHandleRef,
+}
+
 // access to SQLite3 statement handles are safe to send and share between threads
 // as long as the `sqlite3_step` call is serialized.
 
@@ -292,7 +305,18 @@ impl StatementHandle {
     pub(crate) fn clear_bindings(&self) {
         unsafe { sqlite3_clear_bindings(self.0.as_ptr()) };
     }
+
+    pub(crate) fn to_ref(
+        self: &Arc<StatementHandle>,
+        conn: ConnectionHandleRef,
+    ) -> StatementHandleRef {
+        StatementHandleRef {
+            statement: Arc::clone(self),
+            connection: conn,
+        }
+    }
 }
+
 impl Drop for StatementHandle {
     fn drop(&mut self) {
         // SAFETY: we have exclusive access to the `StatementHandle` here
@@ -311,3 +335,11 @@ impl Drop for StatementHandle {
         }
     }
 }
+
+impl Deref for StatementHandleRef {
+    type Target = StatementHandle;
+
+    fn deref(&self) -> &Self::Target {
+        &self.statement
+    }
+}
diff --git a/sqlx-core/src/sqlite/statement/mod.rs b/sqlx-core/src/sqlite/statement/mod.rs
index dec11dcc..97ca9f86 100644
--- a/sqlx-core/src/sqlite/statement/mod.rs
+++ b/sqlx-core/src/sqlite/statement/mod.rs
@@ -12,7 +12,7 @@ mod handle;
 mod r#virtual;
 mod worker;
 
-pub(crate) use handle::StatementHandle;
+pub(crate) use handle::{StatementHandle, StatementHandleRef};
 pub(crate) use r#virtual::VirtualStatement;
 pub(crate) use worker::StatementWorker;
 
diff --git a/tests/sqlite/sqlite.rs b/tests/sqlite/sqlite.rs
index e794f49a..ea983540 100644
--- a/tests/sqlite/sqlite.rs
+++ b/tests/sqlite/sqlite.rs
@@ -567,3 +567,26 @@ async fn concurrent_resets_dont_segfault() {
 
     sqlx_rt::sleep(Duration::from_millis(1)).await;
 }
+
+// https://github.com/launchbadge/sqlx/issues/1419
+// note: this passes before and after the fix; you need to run it with `--nocapture`
+// to see the panic from the worker thread, which doesn't happen after the fix
+#[sqlx_macros::test]
+async fn row_dropped_after_connection_doesnt_panic() {
+    let mut conn = SqliteConnection::connect(":memory:").await.unwrap();
+
+    let books = sqlx::query("SELECT 'hello' AS title")
+        .fetch_all(&mut conn)
+        .await
+        .unwrap();
+
+    for book in &books {
+        // force the row to be inflated
+        let _title: String = book.get("title");
+    }
+
+    // hold `books` past the lifetime of `conn`
+    drop(conn);
+    sqlx_rt::sleep(std::time::Duration::from_secs(1)).await;
+    drop(books);
+}
