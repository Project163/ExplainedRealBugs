diff --git a/CHANGELOG.md b/CHANGELOG.md
index 16291374..2b3ddabd 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -715,7 +715,7 @@ Fix docs.rs build by enabling a runtime feature in the docs.rs metadata in `Carg
 
 ### Added
 
--   [[#174]] Inroduce a builder to construct connections to bypass the URI parsing
+-   [[#174]] Inroduce a builder to construct connections to bypass the URL parsing
 
     ```rust
     // MSSQL
diff --git a/README.md b/README.md
index 7ed95b0e..2a36885c 100644
--- a/README.md
+++ b/README.md
@@ -108,7 +108,7 @@ with C, those interactions are `unsafe`.
 
 -   Nested transactions with support for save points.
 
--   `Any` database driver for changing the database driver at runtime. An `AnyPool` connects to the driver indicated by the URI scheme.
+-   `Any` database driver for changing the database driver at runtime. An `AnyPool` connects to the driver indicated by the URL scheme.
 
 ## Install
 
diff --git a/sqlx-core/src/any/database.rs b/sqlx-core/src/any/database.rs
index 72239e65..6e79c400 100644
--- a/sqlx-core/src/any/database.rs
+++ b/sqlx-core/src/any/database.rs
@@ -5,7 +5,7 @@ use crate::any::{
 use crate::database::{Database, HasArguments, HasStatement, HasStatementCache, HasValueRef};
 
 /// Opaque database driver. Capable of being used in place of any SQLx database driver. The actual
-/// driver used will be selected at runtime, from the connection uri.
+/// driver used will be selected at runtime, from the connection url.
 #[derive(Debug)]
 pub struct Any;
 
diff --git a/sqlx-core/src/any/kind.rs b/sqlx-core/src/any/kind.rs
index e29781d3..b8e7b3fb 100644
--- a/sqlx-core/src/any/kind.rs
+++ b/sqlx-core/src/any/kind.rs
@@ -19,49 +19,49 @@ pub enum AnyKind {
 impl FromStr for AnyKind {
     type Err = Error;
 
-    fn from_str(uri: &str) -> Result<Self, Self::Err> {
-        match uri {
+    fn from_str(url: &str) -> Result<Self, Self::Err> {
+        match url {
             #[cfg(feature = "postgres")]
-            _ if uri.starts_with("postgres:") || uri.starts_with("postgresql:") => {
+            _ if url.starts_with("postgres:") || url.starts_with("postgresql:") => {
                 Ok(AnyKind::Postgres)
             }
 
             #[cfg(not(feature = "postgres"))]
-            _ if uri.starts_with("postgres:") || uri.starts_with("postgresql:") => {
+            _ if url.starts_with("postgres:") || url.starts_with("postgresql:") => {
                 Err(Error::Configuration("database URL has the scheme of a PostgreSQL database but the `postgres` feature is not enabled".into()))
             }
 
             #[cfg(feature = "mysql")]
-            _ if uri.starts_with("mysql:") || uri.starts_with("mariadb:") => {
+            _ if url.starts_with("mysql:") || url.starts_with("mariadb:") => {
                 Ok(AnyKind::MySql)
             }
 
             #[cfg(not(feature = "mysql"))]
-            _ if uri.starts_with("mysql:") || uri.starts_with("mariadb:") => {
+            _ if url.starts_with("mysql:") || url.starts_with("mariadb:") => {
                 Err(Error::Configuration("database URL has the scheme of a MySQL database but the `mysql` feature is not enabled".into()))
             }
 
             #[cfg(feature = "sqlite")]
-            _ if uri.starts_with("sqlite:") => {
+            _ if url.starts_with("sqlite:") => {
                 Ok(AnyKind::Sqlite)
             }
 
             #[cfg(not(feature = "sqlite"))]
-            _ if uri.starts_with("sqlite:") => {
+            _ if url.starts_with("sqlite:") => {
                 Err(Error::Configuration("database URL has the scheme of a SQLite database but the `sqlite` feature is not enabled".into()))
             }
 
             #[cfg(feature = "mssql")]
-            _ if uri.starts_with("mssql:") || uri.starts_with("sqlserver:") => {
+            _ if url.starts_with("mssql:") || url.starts_with("sqlserver:") => {
                 Ok(AnyKind::Mssql)
             }
 
             #[cfg(not(feature = "mssql"))]
-            _ if uri.starts_with("mssql:") || uri.starts_with("sqlserver:") => {
+            _ if url.starts_with("mssql:") || url.starts_with("sqlserver:") => {
                 Err(Error::Configuration("database URL has the scheme of a MSSQL database but the `mssql` feature is not enabled".into()))
             }
 
-            _ => Err(Error::Configuration(format!("unrecognized database url: {:?}", uri).into()))
+            _ => Err(Error::Configuration(format!("unrecognized database url: {:?}", url).into()))
         }
     }
 }
diff --git a/sqlx-core/src/any/migrate.rs b/sqlx-core/src/any/migrate.rs
index 04fa659b..ba73be92 100644
--- a/sqlx-core/src/any/migrate.rs
+++ b/sqlx-core/src/any/migrate.rs
@@ -8,17 +8,17 @@ use std::str::FromStr;
 use std::time::Duration;
 
 impl MigrateDatabase for Any {
-    fn create_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn create_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            match AnyKind::from_str(uri)? {
+            match AnyKind::from_str(url)? {
                 #[cfg(feature = "postgres")]
-                AnyKind::Postgres => crate::postgres::Postgres::create_database(uri).await,
+                AnyKind::Postgres => crate::postgres::Postgres::create_database(url).await,
 
                 #[cfg(feature = "sqlite")]
-                AnyKind::Sqlite => crate::sqlite::Sqlite::create_database(uri).await,
+                AnyKind::Sqlite => crate::sqlite::Sqlite::create_database(url).await,
 
                 #[cfg(feature = "mysql")]
-                AnyKind::MySql => crate::mysql::MySql::create_database(uri).await,
+                AnyKind::MySql => crate::mysql::MySql::create_database(url).await,
 
                 #[cfg(feature = "mssql")]
                 AnyKind::Mssql => unimplemented!(),
@@ -26,17 +26,17 @@ impl MigrateDatabase for Any {
         })
     }
 
-    fn database_exists(uri: &str) -> BoxFuture<'_, Result<bool, Error>> {
+    fn database_exists(url: &str) -> BoxFuture<'_, Result<bool, Error>> {
         Box::pin(async move {
-            match AnyKind::from_str(uri)? {
+            match AnyKind::from_str(url)? {
                 #[cfg(feature = "postgres")]
-                AnyKind::Postgres => crate::postgres::Postgres::database_exists(uri).await,
+                AnyKind::Postgres => crate::postgres::Postgres::database_exists(url).await,
 
                 #[cfg(feature = "sqlite")]
-                AnyKind::Sqlite => crate::sqlite::Sqlite::database_exists(uri).await,
+                AnyKind::Sqlite => crate::sqlite::Sqlite::database_exists(url).await,
 
                 #[cfg(feature = "mysql")]
-                AnyKind::MySql => crate::mysql::MySql::database_exists(uri).await,
+                AnyKind::MySql => crate::mysql::MySql::database_exists(url).await,
 
                 #[cfg(feature = "mssql")]
                 AnyKind::Mssql => unimplemented!(),
@@ -44,17 +44,17 @@ impl MigrateDatabase for Any {
         })
     }
 
-    fn drop_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn drop_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            match AnyKind::from_str(uri)? {
+            match AnyKind::from_str(url)? {
                 #[cfg(feature = "postgres")]
-                AnyKind::Postgres => crate::postgres::Postgres::drop_database(uri).await,
+                AnyKind::Postgres => crate::postgres::Postgres::drop_database(url).await,
 
                 #[cfg(feature = "sqlite")]
-                AnyKind::Sqlite => crate::sqlite::Sqlite::drop_database(uri).await,
+                AnyKind::Sqlite => crate::sqlite::Sqlite::drop_database(url).await,
 
                 #[cfg(feature = "mysql")]
-                AnyKind::MySql => crate::mysql::MySql::drop_database(uri).await,
+                AnyKind::MySql => crate::mysql::MySql::drop_database(url).await,
 
                 #[cfg(feature = "mssql")]
                 AnyKind::Mssql => unimplemented!(),
diff --git a/sqlx-core/src/any/options.rs b/sqlx-core/src/any/options.rs
index f832df98..3e81198b 100644
--- a/sqlx-core/src/any/options.rs
+++ b/sqlx-core/src/any/options.rs
@@ -20,7 +20,7 @@ use crate::any::kind::AnyKind;
 use crate::mssql::MssqlConnectOptions;
 
 /// Opaque options for connecting to a database. These may only be constructed by parsing from
-/// a connection uri.
+/// a connection url.
 ///
 /// ```text
 /// postgres://postgres:password@localhost/database
diff --git a/sqlx-core/src/database.rs b/sqlx-core/src/database.rs
index e1788597..4484f331 100644
--- a/sqlx-core/src/database.rs
+++ b/sqlx-core/src/database.rs
@@ -49,7 +49,7 @@
 //! let conn = AnyConnection::connect("sqlite://file.db").await?;
 //!
 //! // connect to Postgres, no code change
-//! // required, decided by the scheme of the URI
+//! // required, decided by the scheme of the URL
 //! let conn = AnyConnection::connect("postgres://localhost/sqlx").await?;
 //! ```
 
diff --git a/sqlx-core/src/migrate/migrate.rs b/sqlx-core/src/migrate/migrate.rs
index 3c3f4c36..6f43e97d 100644
--- a/sqlx-core/src/migrate/migrate.rs
+++ b/sqlx-core/src/migrate/migrate.rs
@@ -4,17 +4,17 @@ use futures_core::future::BoxFuture;
 use std::time::Duration;
 
 pub trait MigrateDatabase {
-    // create database in uri
+    // create database in url
     // uses a maintenance database depending on driver
-    fn create_database(uri: &str) -> BoxFuture<'_, Result<(), Error>>;
+    fn create_database(url: &str) -> BoxFuture<'_, Result<(), Error>>;
 
-    // check if the database in uri exists
+    // check if the database in url exists
     // uses a maintenance database depending on driver
-    fn database_exists(uri: &str) -> BoxFuture<'_, Result<bool, Error>>;
+    fn database_exists(url: &str) -> BoxFuture<'_, Result<bool, Error>>;
 
-    // drop database in uri
+    // drop database in url
     // uses a maintenance database depending on driver
-    fn drop_database(uri: &str) -> BoxFuture<'_, Result<(), Error>>;
+    fn drop_database(url: &str) -> BoxFuture<'_, Result<(), Error>>;
 }
 
 // 'e = Executor
diff --git a/sqlx-core/src/mssql/options/parse.rs b/sqlx-core/src/mssql/options/parse.rs
index e91e3a73..65c8d2a4 100644
--- a/sqlx-core/src/mssql/options/parse.rs
+++ b/sqlx-core/src/mssql/options/parse.rs
@@ -47,16 +47,16 @@ impl FromStr for MssqlConnectOptions {
 
 #[test]
 fn it_parses_username_with_at_sign_correctly() {
-    let uri = "mysql://user@hostname:password@hostname:5432/database";
-    let opts = MssqlConnectOptions::from_str(uri).unwrap();
+    let url = "mysql://user@hostname:password@hostname:5432/database";
+    let opts = MssqlConnectOptions::from_str(url).unwrap();
 
     assert_eq!("user@hostname", &opts.username);
 }
 
 #[test]
 fn it_parses_password_with_non_ascii_chars_correctly() {
-    let uri = "mysql://username:p@ssw0rd@hostname:5432/database";
-    let opts = MssqlConnectOptions::from_str(uri).unwrap();
+    let url = "mysql://username:p@ssw0rd@hostname:5432/database";
+    let opts = MssqlConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("p@ssw0rd".into()), opts.password);
 }
diff --git a/sqlx-core/src/mysql/migrate.rs b/sqlx-core/src/mysql/migrate.rs
index c3898e9f..800d7408 100644
--- a/sqlx-core/src/mysql/migrate.rs
+++ b/sqlx-core/src/mysql/migrate.rs
@@ -13,8 +13,8 @@ use std::str::FromStr;
 use std::time::Duration;
 use std::time::Instant;
 
-fn parse_for_maintenance(uri: &str) -> Result<(MySqlConnectOptions, String), Error> {
-    let mut options = MySqlConnectOptions::from_str(uri)?;
+fn parse_for_maintenance(url: &str) -> Result<(MySqlConnectOptions, String), Error> {
+    let mut options = MySqlConnectOptions::from_str(url)?;
 
     let database = if let Some(database) = &options.database {
         database.to_owned()
@@ -31,9 +31,9 @@ fn parse_for_maintenance(uri: &str) -> Result<(MySqlConnectOptions, String), Err
 }
 
 impl MigrateDatabase for MySql {
-    fn create_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn create_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let _ = conn
@@ -44,9 +44,9 @@ impl MigrateDatabase for MySql {
         })
     }
 
-    fn database_exists(uri: &str) -> BoxFuture<'_, Result<bool, Error>> {
+    fn database_exists(url: &str) -> BoxFuture<'_, Result<bool, Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let exists: bool = query_scalar(
@@ -60,9 +60,9 @@ impl MigrateDatabase for MySql {
         })
     }
 
-    fn drop_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn drop_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let _ = conn
diff --git a/sqlx-core/src/mysql/options/mod.rs b/sqlx-core/src/mysql/options/mod.rs
index ad7a1db5..a8f91c34 100644
--- a/sqlx-core/src/mysql/options/mod.rs
+++ b/sqlx-core/src/mysql/options/mod.rs
@@ -9,7 +9,7 @@ pub use ssl_mode::MySqlSslMode;
 
 /// Options and flags which can be used to configure a MySQL connection.
 ///
-/// A value of `MySqlConnectOptions` can be parsed from a connection URI,
+/// A value of `MySqlConnectOptions` can be parsed from a connection URL,
 /// as described by [MySQL](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html).
 ///
 /// The generic format of the connection URL:
@@ -37,7 +37,7 @@ pub use ssl_mode::MySqlSslMode;
 /// # fn main() {
 /// # #[cfg(feature = "_rt-async-std")]
 /// # sqlx_rt::async_std::task::block_on::<_, Result<(), Error>>(async move {
-/// // URI connection string
+/// // URL connection string
 /// let conn = MySqlConnection::connect("mysql://root:password@localhost/db").await?;
 ///
 /// // Manually-constructed options
diff --git a/sqlx-core/src/mysql/options/parse.rs b/sqlx-core/src/mysql/options/parse.rs
index 20aa0fa4..0ce32b5d 100644
--- a/sqlx-core/src/mysql/options/parse.rs
+++ b/sqlx-core/src/mysql/options/parse.rs
@@ -78,16 +78,16 @@ impl FromStr for MySqlConnectOptions {
 
 #[test]
 fn it_parses_username_with_at_sign_correctly() {
-    let uri = "mysql://user@hostname:password@hostname:5432/database";
-    let opts = MySqlConnectOptions::from_str(uri).unwrap();
+    let url = "mysql://user@hostname:password@hostname:5432/database";
+    let opts = MySqlConnectOptions::from_str(url).unwrap();
 
     assert_eq!("user@hostname", &opts.username);
 }
 
 #[test]
 fn it_parses_password_with_non_ascii_chars_correctly() {
-    let uri = "mysql://username:p@ssw0rd@hostname:5432/database";
-    let opts = MySqlConnectOptions::from_str(uri).unwrap();
+    let url = "mysql://username:p@ssw0rd@hostname:5432/database";
+    let opts = MySqlConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("p@ssw0rd".into()), opts.password);
 }
diff --git a/sqlx-core/src/postgres/listener.rs b/sqlx-core/src/postgres/listener.rs
index c6cd5026..03bb34de 100644
--- a/sqlx-core/src/postgres/listener.rs
+++ b/sqlx-core/src/postgres/listener.rs
@@ -34,14 +34,14 @@ pub struct PgListener {
 pub struct PgNotification(Notification);
 
 impl PgListener {
-    pub async fn connect(uri: &str) -> Result<Self, Error> {
+    pub async fn connect(url: &str) -> Result<Self, Error> {
         // Create a pool of 1 without timeouts (as they don't apply here)
         // We only use the pool to handle re-connections
         let pool = PoolOptions::<Postgres>::new()
             .max_connections(1)
             .max_lifetime(None)
             .idle_timeout(None)
-            .connect(uri)
+            .connect(url)
             .await?;
 
         let mut this = Self::connect_with(&pool).await?;
diff --git a/sqlx-core/src/postgres/migrate.rs b/sqlx-core/src/postgres/migrate.rs
index 13bd2e36..71084e72 100644
--- a/sqlx-core/src/postgres/migrate.rs
+++ b/sqlx-core/src/postgres/migrate.rs
@@ -13,8 +13,8 @@ use std::str::FromStr;
 use std::time::Duration;
 use std::time::Instant;
 
-fn parse_for_maintenance(uri: &str) -> Result<(PgConnectOptions, String), Error> {
-    let mut options = PgConnectOptions::from_str(uri)?;
+fn parse_for_maintenance(url: &str) -> Result<(PgConnectOptions, String), Error> {
+    let mut options = PgConnectOptions::from_str(url)?;
 
     // pull out the name of the database to create
     let database = options
@@ -36,9 +36,9 @@ fn parse_for_maintenance(uri: &str) -> Result<(PgConnectOptions, String), Error>
 }
 
 impl MigrateDatabase for Postgres {
-    fn create_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn create_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let _ = conn
@@ -52,9 +52,9 @@ impl MigrateDatabase for Postgres {
         })
     }
 
-    fn database_exists(uri: &str) -> BoxFuture<'_, Result<bool, Error>> {
+    fn database_exists(url: &str) -> BoxFuture<'_, Result<bool, Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let exists: bool =
@@ -67,9 +67,9 @@ impl MigrateDatabase for Postgres {
         })
     }
 
-    fn drop_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn drop_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            let (options, database) = parse_for_maintenance(uri)?;
+            let (options, database) = parse_for_maintenance(url)?;
             let mut conn = options.connect().await?;
 
             let _ = conn
diff --git a/sqlx-core/src/postgres/options/mod.rs b/sqlx-core/src/postgres/options/mod.rs
index bedeb6bd..e870da09 100644
--- a/sqlx-core/src/postgres/options/mod.rs
+++ b/sqlx-core/src/postgres/options/mod.rs
@@ -12,10 +12,10 @@ pub use ssl_mode::PgSslMode;
 
 /// Options and flags which can be used to configure a PostgreSQL connection.
 ///
-/// A value of `PgConnectOptions` can be parsed from a connection URI,
+/// A value of `PgConnectOptions` can be parsed from a connection URL,
 /// as described by [libpq](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
 ///
-/// The general form for a connection URI is:
+/// The general form for a connection URL is:
 ///
 /// ```text
 /// postgresql://[user[:password]@][host][:port][/dbname][?param1=value1&...]
@@ -37,8 +37,8 @@ pub use ssl_mode::PgSslMode;
 /// | `dbname` | `None` | The database name. |
 /// | `options` | `None` | The runtime parameters to send to the server at connection start. |
 ///
-/// The URI scheme designator can be either `postgresql://` or `postgres://`.
-/// Each of the URI parts is optional.
+/// The URL scheme designator can be either `postgresql://` or `postgres://`.
+/// Each of the URL parts is optional.
 ///
 /// ```text
 /// postgresql://
@@ -60,7 +60,7 @@ pub use ssl_mode::PgSslMode;
 /// # fn main() {
 /// # #[cfg(feature = "_rt-async-std")]
 /// # sqlx_rt::async_std::task::block_on::<_, Result<(), Error>>(async move {
-/// // URI connection string
+/// // URL connection string
 /// let conn = PgConnection::connect("postgres://localhost/mydb").await?;
 ///
 /// // Manually-constructed options
diff --git a/sqlx-core/src/postgres/options/parse.rs b/sqlx-core/src/postgres/options/parse.rs
index dc099b83..65d2baeb 100644
--- a/sqlx-core/src/postgres/options/parse.rs
+++ b/sqlx-core/src/postgres/options/parse.rs
@@ -112,16 +112,16 @@ impl FromStr for PgConnectOptions {
 
 #[test]
 fn it_parses_socket_correctly_from_parameter() {
-    let uri = "postgres:///?host=/var/run/postgres/";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?host=/var/run/postgres/";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("/var/run/postgres/".into()), opts.socket);
 }
 
 #[test]
 fn it_parses_host_correctly_from_parameter() {
-    let uri = "postgres:///?host=google.database.com";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?host=google.database.com";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!("google.database.com", &opts.host);
@@ -129,8 +129,8 @@ fn it_parses_host_correctly_from_parameter() {
 
 #[test]
 fn it_parses_hostaddr_correctly_from_parameter() {
-    let uri = "postgres:///?hostaddr=8.8.8.8";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?hostaddr=8.8.8.8";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!("8.8.8.8", &opts.host);
@@ -138,8 +138,8 @@ fn it_parses_hostaddr_correctly_from_parameter() {
 
 #[test]
 fn it_parses_port_correctly_from_parameter() {
-    let uri = "postgres:///?port=1234";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?port=1234";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!(1234, opts.port);
@@ -147,8 +147,8 @@ fn it_parses_port_correctly_from_parameter() {
 
 #[test]
 fn it_parses_dbname_correctly_from_parameter() {
-    let uri = "postgres:///?dbname=some_db";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?dbname=some_db";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!(Some("some_db"), opts.database.as_deref());
@@ -156,8 +156,8 @@ fn it_parses_dbname_correctly_from_parameter() {
 
 #[test]
 fn it_parses_user_correctly_from_parameter() {
-    let uri = "postgres:///?user=some_user";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?user=some_user";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!("some_user", opts.username);
@@ -165,8 +165,8 @@ fn it_parses_user_correctly_from_parameter() {
 
 #[test]
 fn it_parses_password_correctly_from_parameter() {
-    let uri = "postgres:///?password=some_pass";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?password=some_pass";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(None, opts.socket);
     assert_eq!(Some("some_pass"), opts.password.as_deref());
@@ -174,39 +174,39 @@ fn it_parses_password_correctly_from_parameter() {
 
 #[test]
 fn it_parses_application_name_correctly_from_parameter() {
-    let uri = "postgres:///?application_name=some_name";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?application_name=some_name";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("some_name"), opts.application_name.as_deref());
 }
 
 #[test]
 fn it_parses_username_with_at_sign_correctly() {
-    let uri = "postgres://user@hostname:password@hostname:5432/database";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres://user@hostname:password@hostname:5432/database";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!("user@hostname", &opts.username);
 }
 
 #[test]
 fn it_parses_password_with_non_ascii_chars_correctly() {
-    let uri = "postgres://username:p@ssw0rd@hostname:5432/database";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres://username:p@ssw0rd@hostname:5432/database";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("p@ssw0rd".into()), opts.password);
 }
 
 #[test]
 fn it_parses_socket_correctly_percent_encoded() {
-    let uri = "postgres://%2Fvar%2Flib%2Fpostgres/database";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres://%2Fvar%2Flib%2Fpostgres/database";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(Some("/var/lib/postgres/".into()), opts.socket);
 }
 #[test]
 fn it_parses_socket_correctly_with_username_percent_encoded() {
-    let uri = "postgres://some_user@%2Fvar%2Flib%2Fpostgres/database";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres://some_user@%2Fvar%2Flib%2Fpostgres/database";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!("some_user", opts.username);
     assert_eq!(Some("/var/lib/postgres/".into()), opts.socket);
@@ -214,8 +214,8 @@ fn it_parses_socket_correctly_with_username_percent_encoded() {
 }
 #[test]
 fn it_parses_libpq_options_correctly() {
-    let uri = "postgres:///?options=-c%20synchronous_commit%3Doff%20--search_path%3Dpostgres";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?options=-c%20synchronous_commit%3Doff%20--search_path%3Dpostgres";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(
         Some("-c synchronous_commit=off --search_path=postgres".into()),
@@ -224,8 +224,8 @@ fn it_parses_libpq_options_correctly() {
 }
 #[test]
 fn it_parses_sqlx_options_correctly() {
-    let uri = "postgres:///?options[synchronous_commit]=off&options[search_path]=postgres";
-    let opts = PgConnectOptions::from_str(uri).unwrap();
+    let url = "postgres:///?options[synchronous_commit]=off&options[search_path]=postgres";
+    let opts = PgConnectOptions::from_str(url).unwrap();
 
     assert_eq!(
         Some("-c synchronous_commit=off -c search_path=postgres".into()),
diff --git a/sqlx-core/src/sqlite/migrate.rs b/sqlx-core/src/sqlite/migrate.rs
index 6f9320d3..02d0841e 100644
--- a/sqlx-core/src/sqlite/migrate.rs
+++ b/sqlx-core/src/sqlite/migrate.rs
@@ -15,10 +15,10 @@ use std::time::Duration;
 use std::time::Instant;
 
 impl MigrateDatabase for Sqlite {
-    fn create_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn create_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
             // Opening a connection to sqlite creates the database
-            let _ = SqliteConnectOptions::from_str(uri)?
+            let _ = SqliteConnectOptions::from_str(url)?
                 .create_if_missing(true)
                 .connect()
                 .await?;
@@ -27,9 +27,9 @@ impl MigrateDatabase for Sqlite {
         })
     }
 
-    fn database_exists(uri: &str) -> BoxFuture<'_, Result<bool, Error>> {
+    fn database_exists(url: &str) -> BoxFuture<'_, Result<bool, Error>> {
         Box::pin(async move {
-            let options = SqliteConnectOptions::from_str(uri)?;
+            let options = SqliteConnectOptions::from_str(url)?;
 
             if options.in_memory {
                 Ok(true)
@@ -39,9 +39,9 @@ impl MigrateDatabase for Sqlite {
         })
     }
 
-    fn drop_database(uri: &str) -> BoxFuture<'_, Result<(), Error>> {
+    fn drop_database(url: &str) -> BoxFuture<'_, Result<(), Error>> {
         Box::pin(async move {
-            let options = SqliteConnectOptions::from_str(uri)?;
+            let options = SqliteConnectOptions::from_str(url)?;
 
             if !options.in_memory {
                 fs::remove_file(&*options.filename).await?;
diff --git a/sqlx-core/src/sqlite/options/mod.rs b/sqlx-core/src/sqlite/options/mod.rs
index f9312d34..a0f418e4 100644
--- a/sqlx-core/src/sqlite/options/mod.rs
+++ b/sqlx-core/src/sqlite/options/mod.rs
@@ -22,10 +22,10 @@ use indexmap::IndexMap;
 
 /// Options and flags which can be used to configure a SQLite connection.
 ///
-/// A value of `SqliteConnectOptions` can be parsed from a connection URI,
+/// A value of `SqliteConnectOptions` can be parsed from a connection URL,
 /// as described by [SQLite](https://www.sqlite.org/uri.html).
 ///
-/// | URI | Description |
+/// | URL | Description |
 /// | -- | -- |
 /// `sqlite::memory:` | Open an in-memory database. |
 /// `sqlite:data.db` | Open the file `data.db` in the current directory. |
diff --git a/sqlx-core/src/sqlite/options/parse.rs b/sqlx-core/src/sqlite/options/parse.rs
index f677df62..7f80dfd7 100644
--- a/sqlx-core/src/sqlite/options/parse.rs
+++ b/sqlx-core/src/sqlite/options/parse.rs
@@ -13,15 +13,15 @@ static IN_MEMORY_DB_SEQ: AtomicUsize = AtomicUsize::new(0);
 impl FromStr for SqliteConnectOptions {
     type Err = Error;
 
-    fn from_str(mut uri: &str) -> Result<Self, Self::Err> {
+    fn from_str(mut url: &str) -> Result<Self, Self::Err> {
         let mut options = Self::new();
 
-        // remove scheme from the URI
-        uri = uri
+        // remove scheme from the URL
+        url = url
             .trim_start_matches("sqlite://")
             .trim_start_matches("sqlite:");
 
-        let mut database_and_params = uri.splitn(2, '?');
+        let mut database_and_params = url.splitn(2, '?');
 
         let database = database_and_params.next().unwrap_or_default();
 
@@ -111,7 +111,7 @@ impl FromStr for SqliteConnectOptions {
                     _ => {
                         return Err(Error::Configuration(
                             format!(
-                                "unknown query parameter `{}` while parsing connection URI",
+                                "unknown query parameter `{}` while parsing connection URL",
                                 key
                             )
                             .into(),
