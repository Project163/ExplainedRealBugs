diff --git a/sqlx-macros/src/derives/type.rs b/sqlx-macros/src/derives/type.rs
index b1874142..065a5be4 100644
--- a/sqlx-macros/src/derives/type.rs
+++ b/sqlx-macros/src/derives/type.rs
@@ -60,6 +60,8 @@ fn expand_derive_has_sql_type_transparent(
 
     if attr.transparent {
         let mut generics = generics.clone();
+        let mut array_generics = generics.clone();
+
         generics
             .params
             .insert(0, parse_quote!(DB: ::sqlx::Database));
@@ -67,9 +69,14 @@ fn expand_derive_has_sql_type_transparent(
             .make_where_clause()
             .predicates
             .push(parse_quote!(#ty: ::sqlx::Type<DB>));
-
         let (impl_generics, _, where_clause) = generics.split_for_impl();
 
+        array_generics
+            .make_where_clause()
+            .predicates
+            .push(parse_quote!(#ty: ::sqlx::postgres::PgHasArrayType));
+        let (array_impl_generics, _, array_where_clause) = array_generics.split_for_impl();
+
         return Ok(quote!(
             #[automatically_derived]
             impl #impl_generics ::sqlx::Type< DB > for #ident #ty_generics #where_clause {
@@ -81,6 +88,14 @@ fn expand_derive_has_sql_type_transparent(
                     <#ty as ::sqlx::Type<DB>>::compatible(ty)
                 }
             }
+            #[automatically_derived]
+            #[cfg(feature = "postgres")]
+            impl #array_impl_generics ::sqlx::postgres::PgHasArrayType for #ident #ty_generics
+            #array_where_clause {
+                fn array_type_info() -> ::sqlx::postgres::PgTypeInfo {
+                    <#ty as ::sqlx::postgres::PgHasArrayType>::array_type_info()
+                }
+            }
         ));
     }
 
diff --git a/tests/postgres/derives.rs b/tests/postgres/derives.rs
index 8abdf5c7..23ac4187 100644
--- a/tests/postgres/derives.rs
+++ b/tests/postgres/derives.rs
@@ -10,6 +10,20 @@ use std::ops::Bound;
 #[sqlx(transparent)]
 struct Transparent(i32);
 
+#[sqlx_macros::test]
+async fn test_transparent_slice_to_array() -> anyhow::Result<()> {
+    let mut conn = new::<Postgres>().await?;
+
+    let values = vec![Transparent(1), Transparent(2), Transparent(3)];
+
+    sqlx::query("SELECT 2 = ANY($1);")
+        .bind(&values)
+        .fetch_one(&mut conn)
+        .await?;
+
+    Ok(())
+}
+
 // "Weak" enums map to an integer type indicated by #[repr]
 #[derive(PartialEq, Copy, Clone, Debug, sqlx::Type)]
 #[repr(i32)]
