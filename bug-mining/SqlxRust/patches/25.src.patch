diff --git a/sqlx-core/src/any/row.rs b/sqlx-core/src/any/row.rs
index e876723f..20b40c44 100644
--- a/sqlx-core/src/any/row.rs
+++ b/sqlx-core/src/any/row.rs
@@ -78,3 +78,249 @@ impl Row for AnyRow {
         .map(AnyValueRef)
     }
 }
+
+impl<'i> ColumnIndex<AnyRow> for &'i str
+where
+    &'i str: AnyColumnIndex,
+{
+    fn index(&self, row: &AnyRow) -> Result<usize, Error> {
+        match &row.0 {
+            #[cfg(feature = "postgres")]
+            AnyRowKind::Postgres(row) => self.index(row),
+
+            #[cfg(feature = "mysql")]
+            AnyRowKind::MySql(row) => self.index(row),
+
+            #[cfg(feature = "sqlite")]
+            AnyRowKind::Sqlite(row) => self.index(row),
+
+            #[cfg(feature = "mssql")]
+            AnyRowKind::Mssql(row) => self.index(row),
+        }
+    }
+}
+
+// FIXME: Find a nice way to auto-generate the below or petition Rust to add support for #[cfg]
+//        to trait bounds
+
+// all 4
+
+#[cfg(all(
+    feature = "postgres",
+    feature = "mysql",
+    feature = "mssql",
+    feature = "sqlite"
+))]
+pub trait AnyColumnIndex:
+    ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+#[cfg(all(
+    feature = "postgres",
+    feature = "mysql",
+    feature = "mssql",
+    feature = "sqlite"
+))]
+impl<T: ?Sized> AnyColumnIndex for T where
+    T: ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+// only 3 (4)
+
+#[cfg(all(
+    not(feature = "mssql"),
+    all(feature = "postgres", feature = "mysql", feature = "sqlite")
+))]
+pub trait AnyColumnIndex:
+    ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "mssql"),
+    all(feature = "postgres", feature = "mysql", feature = "sqlite")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where
+    T: ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "mysql"),
+    all(feature = "postgres", feature = "mssql", feature = "sqlite")
+))]
+pub trait AnyColumnIndex:
+    ColumnIndex<PgRow> + ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "mysql"),
+    all(feature = "postgres", feature = "mssql", feature = "sqlite")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where
+    T: ColumnIndex<PgRow> + ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "sqlite"),
+    all(feature = "postgres", feature = "mysql", feature = "mssql")
+))]
+pub trait AnyColumnIndex:
+    ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "sqlite"),
+    all(feature = "postgres", feature = "mysql", feature = "mssql")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where
+    T: ColumnIndex<PgRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "postgres"),
+    all(feature = "sqlite", feature = "mysql", feature = "mssql")
+))]
+pub trait AnyColumnIndex:
+    ColumnIndex<SqliteRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow>
+{
+}
+
+#[cfg(all(
+    not(feature = "postgres"),
+    all(feature = "sqlite", feature = "mysql", feature = "mssql")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where
+    T: ColumnIndex<SqliteRow> + ColumnIndex<MySqlRow> + ColumnIndex<MssqlRow>
+{
+}
+
+// only 2 (6)
+
+#[cfg(all(
+    not(any(feature = "mssql", feature = "sqlite")),
+    all(feature = "postgres", feature = "mysql")
+))]
+pub trait AnyColumnIndex: ColumnIndex<PgRow> + ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mssql", feature = "sqlite")),
+    all(feature = "postgres", feature = "mysql")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<PgRow> + ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "sqlite")),
+    all(feature = "postgres", feature = "mssql")
+))]
+pub trait AnyColumnIndex: ColumnIndex<PgRow> + ColumnIndex<MssqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "sqlite")),
+    all(feature = "postgres", feature = "mssql")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<PgRow> + ColumnIndex<MssqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql")),
+    all(feature = "postgres", feature = "sqlite")
+))]
+pub trait AnyColumnIndex: ColumnIndex<PgRow> + ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql")),
+    all(feature = "postgres", feature = "sqlite")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<PgRow> + ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "sqlite")),
+    all(feature = "mssql", feature = "mysql")
+))]
+pub trait AnyColumnIndex: ColumnIndex<MssqlRow> + ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "sqlite")),
+    all(feature = "mssql", feature = "mysql")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<MssqlRow> + ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mysql")),
+    all(feature = "mssql", feature = "sqlite")
+))]
+pub trait AnyColumnIndex: ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mysql")),
+    all(feature = "mssql", feature = "sqlite")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<MssqlRow> + ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mssql")),
+    all(feature = "mysql", feature = "sqlite")
+))]
+pub trait AnyColumnIndex: ColumnIndex<MySqlRow> + ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mssql")),
+    all(feature = "mysql", feature = "sqlite")
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<MySqlRow> + ColumnIndex<SqliteRow> {}
+
+// only 1 (4)
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql", feature = "sqlite")),
+    feature = "postgres"
+))]
+pub trait AnyColumnIndex: ColumnIndex<PgRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql", feature = "sqlite")),
+    feature = "postgres"
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<PgRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mssql", feature = "sqlite")),
+    feature = "mysql"
+))]
+pub trait AnyColumnIndex: ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "postgres", feature = "mssql", feature = "sqlite")),
+    feature = "mysql"
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<MySqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "postgres", feature = "sqlite")),
+    feature = "mssql"
+))]
+pub trait AnyColumnIndex: ColumnIndex<MssqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "postgres", feature = "sqlite")),
+    feature = "mssql"
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<MssqlRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql", feature = "postgres")),
+    feature = "sqlite"
+))]
+pub trait AnyColumnIndex: ColumnIndex<SqliteRow> {}
+
+#[cfg(all(
+    not(any(feature = "mysql", feature = "mssql", feature = "postgres")),
+    feature = "sqlite"
+))]
+impl<T: ?Sized> AnyColumnIndex for T where T: ColumnIndex<SqliteRow> {}
diff --git a/sqlx-core/src/sqlite/connection/mod.rs b/sqlx-core/src/sqlite/connection/mod.rs
index 1b5e0d90..25bf9bbb 100644
--- a/sqlx-core/src/sqlite/connection/mod.rs
+++ b/sqlx-core/src/sqlite/connection/mod.rs
@@ -9,8 +9,8 @@ use libsqlite3_sys::sqlite3;
 use crate::common::StatementCache;
 use crate::connection::{Connect, Connection};
 use crate::error::Error;
-use crate::ext::ustr::UStr;
 use crate::executor::Executor;
+use crate::ext::ustr::UStr;
 use crate::sqlite::connection::establish::establish;
 use crate::sqlite::statement::{SqliteStatement, StatementWorker};
 use crate::sqlite::{Sqlite, SqliteConnectOptions};
diff --git a/tests/any/any.rs b/tests/any/any.rs
index e32b338b..8624413e 100644
--- a/tests/any/any.rs
+++ b/tests/any/any.rs
@@ -38,6 +38,18 @@ async fn it_executes_with_pool() -> anyhow::Result<()> {
     Ok(())
 }
 
+#[sqlx_macros::test]
+async fn it_gets_by_name() -> anyhow::Result<()> {
+    let mut conn = new::<Any>().await?;
+
+    let row = conn.fetch_one("SELECT 1 as _1").await?;
+    let val: i32 = row.get("_1");
+
+    assert_eq!(val, 1);
+
+    Ok(())
+}
+
 #[sqlx_macros::test]
 async fn it_can_fail_and_recover() -> anyhow::Result<()> {
     let mut conn = new::<Any>().await?;
