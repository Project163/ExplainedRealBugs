{"url":"https://api.github.com/repos/launchbadge/sqlx/issues/616","repository_url":"https://api.github.com/repos/launchbadge/sqlx","labels_url":"https://api.github.com/repos/launchbadge/sqlx/issues/616/labels{/name}","comments_url":"https://api.github.com/repos/launchbadge/sqlx/issues/616/comments","events_url":"https://api.github.com/repos/launchbadge/sqlx/issues/616/events","html_url":"https://github.com/launchbadge/sqlx/issues/616","id":675151209,"node_id":"MDU6SXNzdWU2NzUxNTEyMDk=","number":616,"title":"SQLite's StatementWorker consumes 100% CPU inside its busy loop","user":{"login":"Patryk27","id":3395477,"node_id":"MDQ6VXNlcjMzOTU0Nzc=","avatar_url":"https://avatars.githubusercontent.com/u/3395477?v=4","gravatar_id":"","url":"https://api.github.com/users/Patryk27","html_url":"https://github.com/Patryk27","followers_url":"https://api.github.com/users/Patryk27/followers","following_url":"https://api.github.com/users/Patryk27/following{/other_user}","gists_url":"https://api.github.com/users/Patryk27/gists{/gist_id}","starred_url":"https://api.github.com/users/Patryk27/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Patryk27/subscriptions","organizations_url":"https://api.github.com/users/Patryk27/orgs","repos_url":"https://api.github.com/users/Patryk27/repos","events_url":"https://api.github.com/users/Patryk27/events{/privacy}","received_events_url":"https://api.github.com/users/Patryk27/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2020-08-07T17:02:16Z","updated_at":"2020-10-13T16:54:52Z","closed_at":"2020-10-13T16:54:52Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Hi :-) \r\n\r\nFirst of all, _the code_:\r\n```toml\r\n[dependencies]\r\nsqlx = { version = \"0.4.0-beta.1\", default-features = false, features = [\"runtime-tokio\", \"sqlite\"] }\r\ntokio = { version = \"0.2\", features = [\"full\"] }\r\n```\r\n\r\n```rust\r\nuse sqlx::Connection;\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    let mut db = sqlx::SqliteConnection::connect(\":memory:\")\r\n        .await\r\n        .unwrap();\r\n\r\n    let value: Option<(i64,)> = sqlx::query_as(\"SELECT 1\")\r\n        .fetch_optional(&mut db)\r\n        .await\r\n        .unwrap();\r\n\r\n    // Keep the application alive\r\n    loop {\r\n        tokio::time::delay_for(tokio::time::Duration::from_secs(1)).await;\r\n    }\r\n}\r\n```\r\nThis code makes the application instantaneously use 100% CPU.\r\n\r\nCurious about it, I've conducted an investigation that led me here first:\r\n```rust\r\nimpl<'c> Executor<'c> for &'c mut SqliteConnection {\r\n    /* ... */\r\n\r\n    // sqlx-core/src/sqlite/connection/executor.rs:157\r\n    fn fetch_optional<'e, 'q: 'e, E: 'q>(\r\n        self,\r\n        query: E,\r\n    ) -> BoxFuture<'e, Result<Option<SqliteRow>, Error>>\r\n    where\r\n        'c: 'e,\r\n        E: Execute<'q, Self::Database>,\r\n    {\r\n        let mut s = self.fetch_many(query);\r\n\r\n        Box::pin(async move {\r\n            while let Some(v) = s.try_next().await? {\r\n                if let Either::Right(r) = v {\r\n                    return Ok(Some(r));\r\n                }\r\n            }\r\n\r\n            Ok(None)\r\n        })\r\n    }\r\n\r\n    /* ... */\r\n}\r\n```\r\n... and later there:\r\n```rust\r\nimpl StatementWorker {\r\n    pub(crate) fn new() -> Self {\r\n        /* ... */\r\n\r\n        let handle = spawn({\r\n            /* ... */\r\n\r\n            move || {\r\n                /* ... */\r\n\r\n                // sqlx-core/src/sqlite/statement/worker.rs:49\r\n                'run: while status.load(Ordering::Acquire) >= 0 {\r\n                    'statement: loop {\r\n                        match status.load(Ordering::Acquire) {\r\n                            STATE_CLOSE => {\r\n                                /* ... */\r\n                            }\r\n\r\n                            STATE_READY => {\r\n                                /* ... */\r\n                            }\r\n\r\n                            _ => {\r\n                                // waits for the receiving end to be ready to receive the rows\r\n                                // this should take less than 1 microsecond under most conditions\r\n                                spin_loop_hint();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        /* ... */\r\n    }\r\n\r\n    /* ... */\r\n}\r\n```\r\nThe issue is that the current implementation of `fetch_optional()` retrieves only the first row from the stream and then _silently discards the stream_, without letting `StatementWorker` know about it. The worker then starts entering `spin_loop_hint()` millions times per second, waiting for response from a stream that doesn't exist anymore.\r\n\r\nThis forever-busy-loop can be reproduced even without referring to `fetch_optional()`, like so:\r\n```rust\r\nasync fn main() {\r\n    /* ... */\r\n\r\n    let mut stream = sqlx::query_as::<_, (Option<i64>,)>(\"SELECT 1\")\r\n        .fetch_many(&mut db);\r\n\r\n    // Retrieve just the first row and then discard rest of the stream\r\n    while let Some(v) = s.try_next().await.unwrap() {\r\n        break;\r\n    }\r\n\r\n    // Keep the application alive\r\n    loop {\r\n        tokio::time::delay_for(tokio::time::Duration::from_secs(1)).await;\r\n    }\r\n}\r\n```\r\n\r\nAs for a possible solution, I'd suggest introducing a new type, called `ExecutionToken`:\r\n```rust\r\npub(crate) struct ExecutionToken {\r\n    status: Arc<AtomicI32>,\r\n}\r\n\r\nimpl Drop for ExecutionToken {\r\n    fn drop(&mut self) {\r\n        self.status.store(STATE_READY, Ordering::Release);\r\n    }\r\n}\r\n\r\n/* ... */\r\n\r\nimpl StatementWorker {\r\n    pub(crate) fn execute(&self, statement: &StatementHandle) -> ExecutionToken {\r\n        let token = ExecutionToken {\r\n            status: Arc::clone(&self.status),\r\n        };\r\n\r\n        self.statement\r\n            .store(statement.0.as_ptr(), Ordering::Release);\r\n\r\n        token\r\n    }\r\n}\r\n\r\n/* ... */\r\n\r\n// and then later just:\r\n// let _token = worker.execute(handle);\r\n```\r\n\r\nSince I'm proficient in neither sqlx's nor SQLite's internals, I'm not sure if that's _the_ correct approach (although it works on my machine â„¢); if you think that's alright, I could prepare a merge request :-)\r\n\r\nThank you for your great work on this library,\r\nCheers.","closed_by":{"login":"mehcode","id":753919,"node_id":"MDQ6VXNlcjc1MzkxOQ==","avatar_url":"https://avatars.githubusercontent.com/u/753919?v=4","gravatar_id":"","url":"https://api.github.com/users/mehcode","html_url":"https://github.com/mehcode","followers_url":"https://api.github.com/users/mehcode/followers","following_url":"https://api.github.com/users/mehcode/following{/other_user}","gists_url":"https://api.github.com/users/mehcode/gists{/gist_id}","starred_url":"https://api.github.com/users/mehcode/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mehcode/subscriptions","organizations_url":"https://api.github.com/users/mehcode/orgs","repos_url":"https://api.github.com/users/mehcode/repos","events_url":"https://api.github.com/users/mehcode/events{/privacy}","received_events_url":"https://api.github.com/users/mehcode/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/launchbadge/sqlx/issues/616/reactions","total_count":4,"+1":4,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/launchbadge/sqlx/issues/616/timeline","performed_via_github_app":null,"state_reason":"completed"}