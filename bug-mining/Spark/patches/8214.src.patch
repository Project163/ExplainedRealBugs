diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/basicLogicalOperators.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/basicLogicalOperators.scala
index 7b4c2bc1c61..b5cf742af9d 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/basicLogicalOperators.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/basicLogicalOperators.scala
@@ -383,8 +383,16 @@ case class Join(
   override def maxRows: Option[Long] = {
     joinType match {
       case Inner | Cross | FullOuter | LeftOuter | RightOuter
-        if left.maxRows.isDefined && right.maxRows.isDefined =>
-        val maxRows = BigInt(left.maxRows.get) * BigInt(right.maxRows.get)
+          if left.maxRows.isDefined && right.maxRows.isDefined =>
+        val leftMaxRows = BigInt(left.maxRows.get)
+        val rightMaxRows = BigInt(right.maxRows.get)
+        val minRows = joinType match {
+          case LeftOuter => leftMaxRows
+          case RightOuter => rightMaxRows
+          case FullOuter => leftMaxRows + rightMaxRows
+          case _ => BigInt(0)
+        }
+        val maxRows = (leftMaxRows * rightMaxRows).max(minRows)
         if (maxRows.isValidLong) {
           Some(maxRows.toLong)
         } else {
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/CombiningLimitsSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/CombiningLimitsSuite.scala
index 423ff81aaeb..46e9dea730e 100644
--- a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/CombiningLimitsSuite.scala
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/CombiningLimitsSuite.scala
@@ -51,6 +51,7 @@ class CombiningLimitsSuite extends PlanTest {
   )
   val testRelation3 = RelationWithoutMaxRows(Seq("i".attr.int))
   val testRelation4 = LongMaxRelation(Seq("j".attr.int))
+  val testRelation5 = EmptyRelation(Seq("k".attr.int))
 
   test("limits: combines two limits") {
     val originalQuery =
@@ -235,6 +236,44 @@ class CombiningLimitsSuite extends PlanTest {
     comparePlans(optimized, testRelation)
   }
 
+  test("SPARK-37064: Fix outer join return the wrong max rows if other side is empty") {
+    Seq(LeftOuter, FullOuter).foreach { joinType =>
+      checkPlanAndMaxRow(
+        testRelation.join(testRelation5, joinType).limit(9),
+        testRelation.join(testRelation5, joinType).limit(9),
+        9
+      )
+
+      checkPlanAndMaxRow(
+        testRelation.join(testRelation5, joinType).limit(10),
+        testRelation.join(testRelation5, joinType),
+        10
+      )
+    }
+
+    Seq(RightOuter, FullOuter).foreach { joinType =>
+      checkPlanAndMaxRow(
+        testRelation5.join(testRelation, joinType).limit(9),
+        testRelation5.join(testRelation, joinType).limit(9),
+        9
+      )
+
+      checkPlanAndMaxRow(
+        testRelation5.join(testRelation, joinType).limit(10),
+        testRelation5.join(testRelation, joinType),
+        10
+      )
+    }
+
+    Seq(Inner, Cross).foreach { joinType =>
+      checkPlanAndMaxRow(
+        testRelation.join(testRelation5, joinType).limit(9),
+        testRelation.join(testRelation5, joinType),
+        0
+      )
+    }
+  }
+
   private def checkPlanAndMaxRow(
       optimized: LogicalPlan, expected: LogicalPlan, expectedMaxRow: Long): Unit = {
     comparePlans(Optimize.execute(optimized.analyze), expected.analyze)
@@ -249,3 +288,7 @@ case class RelationWithoutMaxRows(output: Seq[Attribute]) extends LeafNode {
 case class LongMaxRelation(output: Seq[Attribute]) extends LeafNode {
   override def maxRows: Option[Long] = Some(Long.MaxValue)
 }
+
+case class EmptyRelation(output: Seq[Attribute]) extends LeafNode {
+  override def maxRows: Option[Long] = Some(0)
+}
