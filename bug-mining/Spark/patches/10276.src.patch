diff --git a/sql/connect/common/src/main/scala/org/apache/spark/sql/connect/KeyValueGroupedDataset.scala b/sql/connect/common/src/main/scala/org/apache/spark/sql/connect/KeyValueGroupedDataset.scala
index af036218455..49298a5b39f 100644
--- a/sql/connect/common/src/main/scala/org/apache/spark/sql/connect/KeyValueGroupedDataset.scala
+++ b/sql/connect/common/src/main/scala/org/apache/spark/sql/connect/KeyValueGroupedDataset.scala
@@ -24,6 +24,7 @@ import org.apache.spark.api.java.function._
 import org.apache.spark.connect.proto
 import org.apache.spark.sql
 import org.apache.spark.sql.{Column, Encoder, TypedColumn}
+import org.apache.spark.sql.catalyst.ScalaReflection
 import org.apache.spark.sql.catalyst.encoders.AgnosticEncoder
 import org.apache.spark.sql.catalyst.encoders.AgnosticEncoders.{agnosticEncoderFor, ProductEncoder, StructEncoder}
 import org.apache.spark.sql.connect.ColumnNodeToProtoConverter.{toExpr, toExprWithTransformation, toTypedExpr}
@@ -658,8 +659,14 @@ private class KeyValueGroupedDatasetImpl[K, V, IK, IV](
       initialState: Option[sql.KeyValueGroupedDataset[K, S]] = None,
       eventTimeColumnName: String = ""): Dataset[U] = {
     val outputEncoder = agnosticEncoderFor[U]
-    val stateEncoder = agnosticEncoderFor[S]
-    val inputEncoders: Seq[AgnosticEncoder[_]] = Seq(kEncoder, stateEncoder, ivEncoder)
+    val initialStateEncoder = if (initialState.isDefined) {
+      agnosticEncoderFor[S]
+    } else {
+      // Cannot use `agnosticEncoderFor[S]` here because it points to incorrect encoder
+      // when the initial state is not provided. Using an empty state encoder instead.
+      ScalaReflection.encoderFor[EmptyInitialStateStruct]
+    }
+    val inputEncoders: Seq[AgnosticEncoder[_]] = Seq(kEncoder, initialStateEncoder, ivEncoder)
 
     // SparkUserDefinedFunction is creating a udfPacket where the input function are
     // being java serialized into bytes; we pass in `statefulProcessor` as function so it can be
@@ -780,3 +787,14 @@ private object KeyValueGroupedDatasetImpl {
     case _ => false
   }
 }
+
+/**
+ * A marker case class used as a placeholder type for initial state encoders when no actual
+ * initial state is provided to stateful streaming operations.
+ *
+ * In the `transformWithStateHelper` method, when `initialState` is not provided, we cannot use
+ * `agnosticEncoderFor[S]` for the initial state encoder because it would incorrectly point to the
+ * other encoders. Instead, we use `EmptyStruct` as a sentinel type to create a proper encoder
+ * that represents the absence of initial state data.
+ */
+case class EmptyInitialStateStruct()
