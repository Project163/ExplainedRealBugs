diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/SchemaPruning.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/SchemaPruning.scala
index 9aa2766dd3e..2a182b6424d 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/SchemaPruning.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/SchemaPruning.scala
@@ -17,6 +17,10 @@
 
 package org.apache.spark.sql.catalyst.expressions
 
+import java.util.Locale
+
+import scala.collection.immutable.HashMap
+
 import org.apache.spark.sql.catalyst.SQLConfHelper
 import org.apache.spark.sql.types._
 
@@ -54,6 +58,7 @@ object SchemaPruning extends SQLConfHelper {
    */
   private def sortLeftFieldsByRight(left: DataType, right: DataType): DataType =
     (left, right) match {
+      case _ if left == right => left
       case (ArrayType(leftElementType, containsNull), ArrayType(rightElementType, _)) =>
         ArrayType(
           sortLeftFieldsByRight(leftElementType, rightElementType),
@@ -65,16 +70,23 @@ object SchemaPruning extends SQLConfHelper {
           sortLeftFieldsByRight(leftValueType, rightValueType),
           containsNull)
       case (leftStruct: StructType, rightStruct: StructType) =>
-        val resolver = conf.resolver
-        val filteredRightFieldNames = rightStruct.fieldNames
-          .filter(name => leftStruct.fieldNames.exists(resolver(_, name)))
-        val sortedLeftFields = filteredRightFieldNames.map { fieldName =>
-          val resolvedLeftStruct = leftStruct.find(p => resolver(p.name, fieldName)).get
-          val leftFieldType = resolvedLeftStruct.dataType
-          val rightFieldType = rightStruct(fieldName).dataType
-          val sortedLeftFieldType = sortLeftFieldsByRight(leftFieldType, rightFieldType)
-          StructField(fieldName, sortedLeftFieldType, nullable = resolvedLeftStruct.nullable,
-            metadata = resolvedLeftStruct.metadata)
+        val formatFieldName: String => String =
+          if (conf.caseSensitiveAnalysis) identity else _.toLowerCase(Locale.ROOT)
+
+        val leftStructHashMap =
+          HashMap(leftStruct.map(f => formatFieldName(f.name)).zip(leftStruct): _*)
+        val sortedLeftFields = rightStruct.fieldNames.flatMap { fieldName =>
+          val formattedFieldName = formatFieldName(fieldName)
+          if (leftStructHashMap.contains(formattedFieldName)) {
+            val resolvedLeftStruct = leftStructHashMap(formattedFieldName)
+            val leftFieldType = resolvedLeftStruct.dataType
+            val rightFieldType = rightStruct(fieldName).dataType
+            val sortedLeftFieldType = sortLeftFieldsByRight(leftFieldType, rightFieldType)
+            Some(StructField(fieldName, sortedLeftFieldType, nullable = resolvedLeftStruct.nullable,
+              metadata = resolvedLeftStruct.metadata))
+          } else {
+            None
+          }
         }
         StructType(sortedLeftFields)
       case _ => left
