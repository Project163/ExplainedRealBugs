diff --git a/core/src/main/scala/org/apache/spark/deploy/worker/Worker.scala b/core/src/main/scala/org/apache/spark/deploy/worker/Worker.scala
index 738caf92324..aa8c46fc683 100755
--- a/core/src/main/scala/org/apache/spark/deploy/worker/Worker.scala
+++ b/core/src/main/scala/org/apache/spark/deploy/worker/Worker.scala
@@ -69,7 +69,8 @@ private[deploy] class Worker(
   // If worker decommissioning is enabled register a handler on PWR to shutdown.
   if (conf.get(WORKER_DECOMMISSION_ENABLED)) {
     logInfo("Registering SIGPWR handler to trigger decommissioning.")
-    SignalUtils.register("PWR")(decommissionSelf)
+    SignalUtils.register("PWR", "Failed to register SIGPWR handler - " +
+      "disabling worker decommission feature.")(decommissionSelf)
   } else {
     logInfo("Worker decommissioning not enabled, SIGPWR will result in exiting.")
   }
diff --git a/core/src/main/scala/org/apache/spark/executor/CoarseGrainedExecutorBackend.scala b/core/src/main/scala/org/apache/spark/executor/CoarseGrainedExecutorBackend.scala
index faf03a64ae8..6625457749f 100644
--- a/core/src/main/scala/org/apache/spark/executor/CoarseGrainedExecutorBackend.scala
+++ b/core/src/main/scala/org/apache/spark/executor/CoarseGrainedExecutorBackend.scala
@@ -82,7 +82,8 @@ private[spark] class CoarseGrainedExecutorBackend(
 
   override def onStart(): Unit = {
     logInfo("Registering PWR handler.")
-    SignalUtils.register("PWR")(decommissionSelf)
+    SignalUtils.register("PWR", "Failed to register SIGPWR handler - " +
+      "disabling decommission feature.")(decommissionSelf)
 
     logInfo("Connecting to driver: " + driverUrl)
     try {
diff --git a/core/src/main/scala/org/apache/spark/util/SignalUtils.scala b/core/src/main/scala/org/apache/spark/util/SignalUtils.scala
index 230195da2a1..36ecb42352d 100644
--- a/core/src/main/scala/org/apache/spark/util/SignalUtils.scala
+++ b/core/src/main/scala/org/apache/spark/util/SignalUtils.scala
@@ -56,17 +56,40 @@ private[spark] object SignalUtils extends Logging {
    *
    * All actions for a given signal are run in a separate thread.
    */
-  def register(signal: String)(action: => Boolean): Unit = synchronized {
+  def register(signal: String)(action: => Boolean): Unit = {
     if (SystemUtils.IS_OS_UNIX) {
-      try {
-        val handler = handlers.getOrElseUpdate(signal, {
-          logInfo("Registering signal handler for " + signal)
-          new ActionHandler(new Signal(signal))
-        })
-        handler.register(action)
-      } catch {
-        case ex: Exception => logWarning(s"Failed to register signal handler for " + signal, ex)
-      }
+      register(signal, s"Failed to register signal handler for $signal",
+        logStackTrace = true)(action)
+    }
+  }
+
+  /**
+   * Adds an action to be run when a given signal is received by this process.
+   *
+   * This method receives failMessage as additional parameter, which would be logged when it fails
+   * to register the signal. Here the failures include the cases 1) OS doesn't support signal at
+   * all 2) OS doesn't support given signal (Could be possible with non-POSIX signals)
+   *
+   * All actions for a given signal are run in a separate thread.
+   */
+  def register(
+      signal: String,
+      failMessage: String,
+      logStackTrace: Boolean = true)(
+      action: => Boolean): Unit = synchronized {
+    try {
+      val handler = handlers.getOrElseUpdate(signal, {
+        logInfo(s"Registering signal handler for $signal")
+        new ActionHandler(new Signal(signal))
+      })
+      handler.register(action)
+    } catch {
+      case ex: Exception =>
+        if (logStackTrace) {
+          logWarning(failMessage, ex)
+        } else {
+          logWarning(failMessage)
+        }
     }
   }
 
