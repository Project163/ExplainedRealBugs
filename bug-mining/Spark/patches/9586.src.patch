diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/executeImmediate.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/executeImmediate.scala
index 7cc49661612..6c88980b1bc 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/executeImmediate.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/executeImmediate.scala
@@ -122,11 +122,14 @@ class SubstituteExecuteImmediate(val catalogManager: CatalogManager)
               resolveArguments(expressions))
           } else {
             val aliases = expressions.collect {
-              case (e: Alias) => e
+              case e: Alias => e
+              case u: UnresolvedAttribute => Alias(u, u.nameParts.last)()
             }
-            val nonAliases = expressions.filter(!_.isInstanceOf[Alias])
 
-            if (nonAliases.nonEmpty) {
+            if (aliases.size != expressions.size) {
+              val nonAliases = expressions.filter(attr =>
+                !attr.isInstanceOf[Alias] && !attr.isInstanceOf[UnresolvedAttribute])
+
               throw QueryCompilationErrors.invalidQueryAllParametersMustBeNamed(nonAliases)
             }
 
diff --git a/sql/core/src/test/resources/sql-tests/analyzer-results/execute-immediate.sql.out b/sql/core/src/test/resources/sql-tests/analyzer-results/execute-immediate.sql.out
index cf1e71c91fb..49eb9a0ffd2 100644
--- a/sql/core/src/test/resources/sql-tests/analyzer-results/execute-immediate.sql.out
+++ b/sql/core/src/test/resources/sql-tests/analyzer-results/execute-immediate.sql.out
@@ -749,6 +749,39 @@ org.apache.spark.sql.catalyst.parser.ParseException
 }
 
 
+-- !query
+DECLARE p = 10
+-- !query analysis
+CreateVariable defaultvalueexpression(10, 10), false
++- ResolvedIdentifier org.apache.spark.sql.catalyst.analysis.FakeSystemCatalog$@xxxxxxxx, session.p
+
+
+-- !query
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p
+-- !query analysis
+Project [id#x]
++- Filter (id#x = variablereference(system.session.p=10))
+   +- SubqueryAlias tbl_view
+      +- View (`tbl_view`, [id#x, name#x, data#x])
+         +- Project [cast(id#x as int) AS id#x, cast(name#x as string) AS name#x, cast(data#x as struct<f1:int,s2:struct<f2:int,f3:string>>) AS data#x]
+            +- Project [id#x, name#x, data#x]
+               +- SubqueryAlias tbl_view
+                  +- LocalRelation [id#x, name#x, data#x]
+
+
+-- !query
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p, 'p'
+-- !query analysis
+org.apache.spark.sql.AnalysisException
+{
+  "errorClass" : "ALL_PARAMETERS_MUST_BE_NAMED",
+  "sqlState" : "07001",
+  "messageParameters" : {
+    "exprs" : "\"p\""
+  }
+}
+
+
 -- !query
 EXECUTE IMMEDIATE 'SELECT id, data.f1 FROM tbl_view WHERE id = 10' INTO res_id, res_id
 -- !query analysis
diff --git a/sql/core/src/test/resources/sql-tests/inputs/execute-immediate.sql b/sql/core/src/test/resources/sql-tests/inputs/execute-immediate.sql
index 421d7dafcaa..363d5936240 100644
--- a/sql/core/src/test/resources/sql-tests/inputs/execute-immediate.sql
+++ b/sql/core/src/test/resources/sql-tests/inputs/execute-immediate.sql
@@ -25,7 +25,7 @@ EXECUTE IMMEDIATE 'REFRESH TABLE IDENTIFIER(:tblName)' USING 'x' as tblName;
 EXECUTE IMMEDIATE sql_string;
 EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = \'name1\'';
 
--- test positional paramete
+-- test positional parameters
 SET VAR sql_string = 'SELECT * from tbl_view where name = ? or name = ?';
 DECLARE a STRING;
 SET VAR a = 'name1';
@@ -34,7 +34,7 @@ EXECUTE IMMEDIATE sql_string USING a, 'name2';
 EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING 'name1', 'name3';
 EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING a, 'name2';
 EXECUTE IMMEDIATE 'SELECT * from tbl_view where name = ? or name = ?' USING (a, 'name2');
--- test positonal command
+-- test positional command
 EXECUTE IMMEDIATE 'INSERT INTO x VALUES(?)' USING 1;
 SELECT * from x;
 
@@ -129,6 +129,13 @@ EXECUTE IMMEDIATE 'SELECT id FROM tbl_view' INTO res_id, b;
 -- duplicate aliases
 EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :first' USING 10 as first, 20 as first;
 
+-- no alias
+DECLARE p = 10;
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p;
+
+-- mixing literals and named parameters
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p, 'p';
+
 -- duplicate into entry
 EXECUTE IMMEDIATE 'SELECT id, data.f1 FROM tbl_view WHERE id = 10' INTO res_id, res_id;
 
diff --git a/sql/core/src/test/resources/sql-tests/results/execute-immediate.sql.out b/sql/core/src/test/resources/sql-tests/results/execute-immediate.sql.out
index 8e4dcb5161d..4d376a70e43 100644
--- a/sql/core/src/test/resources/sql-tests/results/execute-immediate.sql.out
+++ b/sql/core/src/test/resources/sql-tests/results/execute-immediate.sql.out
@@ -700,6 +700,37 @@ org.apache.spark.sql.catalyst.parser.ParseException
 }
 
 
+-- !query
+DECLARE p = 10
+-- !query schema
+struct<>
+-- !query output
+
+
+
+-- !query
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p
+-- !query schema
+struct<id:int>
+-- !query output
+10
+
+
+-- !query
+EXECUTE IMMEDIATE 'SELECT id FROM tbl_view WHERE id = :p' USING p, 'p'
+-- !query schema
+struct<>
+-- !query output
+org.apache.spark.sql.AnalysisException
+{
+  "errorClass" : "ALL_PARAMETERS_MUST_BE_NAMED",
+  "sqlState" : "07001",
+  "messageParameters" : {
+    "exprs" : "\"p\""
+  }
+}
+
+
 -- !query
 EXECUTE IMMEDIATE 'SELECT id, data.f1 FROM tbl_view WHERE id = 10' INTO res_id, res_id
 -- !query schema
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/execution/ExecuteImmediateEndToEndSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/execution/ExecuteImmediateEndToEndSuite.scala
new file mode 100644
index 00000000000..41ddcef89b7
--- /dev/null
+++ b/sql/core/src/test/scala/org/apache/spark/sql/execution/ExecuteImmediateEndToEndSuite.scala
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.spark.sql.execution
+
+import org.apache.spark.sql.QueryTest
+import org.apache.spark.sql.test.SharedSparkSession
+
+class ExecuteImmediateEndToEndSuite extends QueryTest with SharedSparkSession {
+
+  test("SPARK-47033: EXECUTE IMMEDIATE USING does not recognize session variable names") {
+    try {
+      spark.sql("DECLARE parm = 'Hello';")
+
+      val originalQuery = spark.sql(
+        "EXECUTE IMMEDIATE 'SELECT :parm' USING system.session.parm AS parm;")
+      val newQuery = spark.sql("EXECUTE IMMEDIATE 'SELECT :parm' USING system.session.parm;")
+
+      assert(originalQuery.columns sameElements newQuery.columns)
+
+      checkAnswer(originalQuery, newQuery.collect().toIndexedSeq)
+    } finally {
+      spark.sql("DROP TEMPORARY VARIABLE IF EXISTS parm;")
+    }
+  }
+}
