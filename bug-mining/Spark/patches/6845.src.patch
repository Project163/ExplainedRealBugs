diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveCatalogs.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveCatalogs.scala
index 896b2830d52..8183aa36a5b 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveCatalogs.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveCatalogs.scala
@@ -33,96 +33,98 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
 
   override def apply(plan: LogicalPlan): LogicalPlan = plan resolveOperators {
     case AlterTableAddColumnsStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), cols) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), cols) =>
       val changes = cols.map { col =>
         TableChange.addColumn(col.name.toArray, col.dataType, true, col.comment.orNull)
       }
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     case AlterTableAlterColumnStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), colName, dataType, comment) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), colName, dataType, comment) =>
       val typeChange = dataType.map { newDataType =>
         TableChange.updateColumnType(colName.toArray, newDataType, true)
       }
       val commentChange = comment.map { newComment =>
         TableChange.updateColumnComment(colName.toArray, newComment)
       }
-      createAlterTable(nameParts, catalog, tableName, typeChange.toSeq ++ commentChange)
+      createAlterTable(nameParts, catalog, tbl, typeChange.toSeq ++ commentChange)
 
     case AlterTableRenameColumnStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), col, newName) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), col, newName) =>
       val changes = Seq(TableChange.renameColumn(col.toArray, newName))
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     case AlterTableDropColumnsStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), cols) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), cols) =>
       val changes = cols.map(col => TableChange.deleteColumn(col.toArray))
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     case AlterTableSetPropertiesStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), props) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), props) =>
       val changes = props.map { case (key, value) =>
         TableChange.setProperty(key, value)
       }.toSeq
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     // TODO: v2 `UNSET TBLPROPERTIES` should respect the ifExists flag.
     case AlterTableUnsetPropertiesStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), keys, _) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), keys, _) =>
       val changes = keys.map(key => TableChange.removeProperty(key))
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     case AlterTableSetLocationStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), partitionSpec, newLoc) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), partitionSpec, newLoc) =>
       if (partitionSpec.nonEmpty) {
         throw new AnalysisException(
           "ALTER TABLE SET LOCATION does not support partition for v2 tables.")
       }
       val changes = Seq(TableChange.setProperty(TableCatalog.PROP_LOCATION, newLoc))
-      createAlterTable(nameParts, catalog, tableName, changes)
+      createAlterTable(nameParts, catalog, tbl, changes)
 
     case AlterViewSetPropertiesStatement(
-         NonSessionCatalog(catalog, tableName), props) =>
+         NonSessionCatalogAndTable(catalog, tbl), props) =>
       throw new AnalysisException(
-        s"Can not specify catalog `${catalog.name}` for view ${tableName.quoted} " +
+        s"Can not specify catalog `${catalog.name}` for view ${tbl.quoted} " +
           s"because view support in catalog has not been implemented yet")
 
     case AlterViewUnsetPropertiesStatement(
-         NonSessionCatalog(catalog, tableName), keys, ifExists) =>
+         NonSessionCatalogAndTable(catalog, tbl), keys, ifExists) =>
       throw new AnalysisException(
-        s"Can not specify catalog `${catalog.name}` for view ${tableName.quoted} " +
+        s"Can not specify catalog `${catalog.name}` for view ${tbl.quoted} " +
           s"because view support in catalog has not been implemented yet")
 
-    case AlterNamespaceSetPropertiesStatement(NonSessionCatalog(catalog, nameParts), properties) =>
-      AlterNamespaceSetProperties(catalog.asNamespaceCatalog, nameParts, properties)
+    case AlterNamespaceSetPropertiesStatement(
+        NonSessionCatalogAndNamespace(catalog, ns), properties) =>
+      AlterNamespaceSetProperties(catalog.asNamespaceCatalog, ns, properties)
 
-    case AlterNamespaceSetLocationStatement(NonSessionCatalog(catalog, nameParts), location) =>
-      AlterNamespaceSetProperties(catalog.asNamespaceCatalog, nameParts,
+    case AlterNamespaceSetLocationStatement(
+        NonSessionCatalogAndNamespace(catalog, ns), location) =>
+      AlterNamespaceSetProperties(catalog.asNamespaceCatalog, ns,
         Map(SupportsNamespaces.PROP_LOCATION -> location))
 
-    case RenameTableStatement(NonSessionCatalog(catalog, oldName), newNameParts, isView) =>
+    case RenameTableStatement(NonSessionCatalogAndTable(catalog, oldName), newNameParts, isView) =>
       if (isView) {
         throw new AnalysisException("Renaming view is not supported in v2 catalogs.")
       }
       RenameTable(catalog.asTableCatalog, oldName.asIdentifier, newNameParts.asIdentifier)
 
     case DescribeTableStatement(
-         nameParts @ NonSessionCatalog(catalog, tableName), partitionSpec, isExtended) =>
+         nameParts @ NonSessionCatalogAndTable(catalog, tbl), partitionSpec, isExtended) =>
       if (partitionSpec.nonEmpty) {
         throw new AnalysisException("DESCRIBE TABLE does not support partition for v2 tables.")
       }
-      val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tableName.asIdentifier)
+      val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tbl.asIdentifier)
       DescribeTable(r, isExtended)
 
     case DescribeColumnStatement(
-         NonSessionCatalog(catalog, tableName), colNameParts, isExtended) =>
+         NonSessionCatalogAndTable(catalog, tbl), colNameParts, isExtended) =>
       throw new AnalysisException("Describing columns is not supported for v2 tables.")
 
     case c @ CreateTableStatement(
-         NonSessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         NonSessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       CreateV2Table(
         catalog.asTableCatalog,
-        tableName.asIdentifier,
+        tbl.asIdentifier,
         c.tableSchema,
         // convert the bucket spec and add it as a transform
         c.partitioning ++ c.bucketSpec.map(_.asTransform),
@@ -130,10 +132,10 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
         ignoreIfExists = c.ifNotExists)
 
     case c @ CreateTableAsSelectStatement(
-         NonSessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         NonSessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       CreateTableAsSelect(
         catalog.asTableCatalog,
-        tableName.asIdentifier,
+        tbl.asIdentifier,
         // convert the bucket spec and add it as a transform
         c.partitioning ++ c.bucketSpec.map(_.asTransform),
         c.asSelect,
@@ -141,14 +143,14 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
         writeOptions = c.options.filterKeys(_ != "path"),
         ignoreIfExists = c.ifNotExists)
 
-    case RefreshTableStatement(NonSessionCatalog(catalog, tableName)) =>
-      RefreshTable(catalog.asTableCatalog, tableName.asIdentifier)
+    case RefreshTableStatement(NonSessionCatalogAndTable(catalog, tbl)) =>
+      RefreshTable(catalog.asTableCatalog, tbl.asIdentifier)
 
     case c @ ReplaceTableStatement(
-         NonSessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         NonSessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       ReplaceTable(
         catalog.asTableCatalog,
-        tableName.asIdentifier,
+        tbl.asIdentifier,
         c.tableSchema,
         // convert the bucket spec and add it as a transform
         c.partitioning ++ c.bucketSpec.map(_.asTransform),
@@ -156,10 +158,10 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
         orCreate = c.orCreate)
 
     case c @ ReplaceTableAsSelectStatement(
-         NonSessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         NonSessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       ReplaceTableAsSelect(
         catalog.asTableCatalog,
-        tableName.asIdentifier,
+        tbl.asIdentifier,
         // convert the bucket spec and add it as a transform
         c.partitioning ++ c.bucketSpec.map(_.asTransform),
         c.asSelect,
@@ -167,35 +169,32 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
         writeOptions = c.options.filterKeys(_ != "path"),
         orCreate = c.orCreate)
 
-    case DropTableStatement(NonSessionCatalog(catalog, tableName), ifExists, _) =>
-      DropTable(catalog.asTableCatalog, tableName.asIdentifier, ifExists)
+    case DropTableStatement(NonSessionCatalogAndTable(catalog, tbl), ifExists, _) =>
+      DropTable(catalog.asTableCatalog, tbl.asIdentifier, ifExists)
 
-    case DropViewStatement(NonSessionCatalog(catalog, viewName), _) =>
+    case DropViewStatement(NonSessionCatalogAndTable(catalog, viewName), _) =>
       throw new AnalysisException(
         s"Can not specify catalog `${catalog.name}` for view ${viewName.quoted} " +
           s"because view support in catalog has not been implemented yet")
 
-    case c @ CreateNamespaceStatement(NonSessionCatalog(catalog, nameParts), _, _) =>
-      CreateNamespace(
-        catalog.asNamespaceCatalog,
-        nameParts,
-        c.ifNotExists,
-        c.properties)
+    case c @ CreateNamespaceStatement(NonSessionCatalogAndNamespace(catalog, ns), _, _) =>
+      CreateNamespace(catalog.asNamespaceCatalog, ns, c.ifNotExists, c.properties)
 
-    case DropNamespaceStatement(NonSessionCatalog(catalog, nameParts), ifExists, cascade) =>
-      DropNamespace(catalog, nameParts, ifExists, cascade)
+    case DropNamespaceStatement(NonSessionCatalogAndNamespace(catalog, ns), ifExists, cascade) =>
+      DropNamespace(catalog, ns, ifExists, cascade)
 
-    case DescribeNamespaceStatement(NonSessionCatalog(catalog, nameParts), extended) =>
-      DescribeNamespace(catalog.asNamespaceCatalog, nameParts, extended)
+    case DescribeNamespaceStatement(NonSessionCatalogAndNamespace(catalog, ns), extended) =>
+      DescribeNamespace(catalog.asNamespaceCatalog, ns, extended)
 
-    case ShowNamespacesStatement(Some(CatalogAndNamespace(catalog, namespace)), pattern) =>
+    case ShowNamespacesStatement(Some(CatalogAndNamespace(catalog, ns)), pattern) =>
+      val namespace = if (ns.nonEmpty) Some(ns) else None
       ShowNamespaces(catalog.asNamespaceCatalog, namespace, pattern)
 
     case ShowNamespacesStatement(None, pattern) =>
       ShowNamespaces(currentCatalog.asNamespaceCatalog, None, pattern)
 
-    case ShowTablesStatement(Some(NonSessionCatalog(catalog, nameParts)), pattern) =>
-      ShowTables(catalog.asTableCatalog, nameParts, pattern)
+    case ShowTablesStatement(Some(NonSessionCatalogAndNamespace(catalog, ns)), pattern) =>
+      ShowTables(catalog.asTableCatalog, ns, pattern)
 
     case ShowTablesStatement(None, pattern) if !isSessionCatalog(currentCatalog) =>
       ShowTables(currentCatalog.asTableCatalog, catalogManager.currentNamespace, pattern)
@@ -204,7 +203,8 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
       if (isNamespaceSet) {
         SetCatalogAndNamespace(catalogManager, None, Some(nameParts))
       } else {
-        val CatalogAndNamespace(catalog, namespace) = nameParts
+        val CatalogAndNamespace(catalog, ns) = nameParts
+        val namespace = if (ns.nonEmpty) Some(ns) else None
         SetCatalogAndNamespace(catalogManager, Some(catalog.name()), namespace)
       }
 
@@ -212,15 +212,23 @@ class ResolveCatalogs(val catalogManager: CatalogManager)
       ShowCurrentNamespace(catalogManager)
 
     case ShowTablePropertiesStatement(
-      nameParts @ NonSessionCatalog(catalog, tableName), propertyKey) =>
-      val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tableName.asIdentifier)
+      nameParts @ NonSessionCatalogAndTable(catalog, tbl), propertyKey) =>
+      val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tbl.asIdentifier)
       ShowTableProperties(r, propertyKey)
   }
 
-  object NonSessionCatalog {
+  object NonSessionCatalogAndTable {
     def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Seq[String])] = nameParts match {
-      case CatalogAndIdentifierParts(catalog, parts) if !isSessionCatalog(catalog) =>
-        Some(catalog -> parts)
+      case CatalogAndIdentifier(catalog, ident) if !isSessionCatalog(catalog) =>
+        Some(catalog -> ident.asMultipartIdentifier)
+      case _ => None
+    }
+  }
+
+  object NonSessionCatalogAndNamespace {
+    def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Seq[String])] = nameParts match {
+      case CatalogAndNamespace(catalog, ns) if !isSessionCatalog(catalog) =>
+        Some(catalog -> ns)
       case _ => None
     }
   }
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/CatalogV2Implicits.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/CatalogV2Implicits.scala
index aa4bab4080f..882e968f34b 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/CatalogV2Implicits.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/CatalogV2Implicits.scala
@@ -96,6 +96,8 @@ private[sql] object CatalogV2Implicits {
         quote(ident.name)
       }
     }
+
+    def asMultipartIdentifier: Seq[String] = ident.namespace :+ ident.name
   }
 
   implicit class MultipartIdentifierHelper(parts: Seq[String]) {
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/LookupCatalog.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/LookupCatalog.scala
index a37d37fd27a..4d3aff22741 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/LookupCatalog.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/connector/catalog/LookupCatalog.scala
@@ -38,7 +38,7 @@ private[sql] trait LookupCatalog extends Logging {
    *
    * This does not substitute the default catalog if no catalog is set in the identifier.
    */
-  private object CatalogAndIdentifier {
+  private object CatalogAndMultipartIdentifier {
     def unapply(parts: Seq[String]): Some[(Option[CatalogPlugin], Seq[String])] = parts match {
       case Seq(_) =>
         Some((None, parts))
@@ -57,7 +57,7 @@ private[sql] trait LookupCatalog extends Logging {
    */
   object CatalogObjectIdentifier {
     def unapply(parts: Seq[String]): Some[(CatalogPlugin, Identifier)] = parts match {
-      case CatalogAndIdentifier(maybeCatalog, nameParts) =>
+      case CatalogAndMultipartIdentifier(maybeCatalog, nameParts) =>
         Some((
             maybeCatalog.getOrElse(currentCatalog),
             Identifier.of(nameParts.init.toArray, nameParts.last)
@@ -88,19 +88,51 @@ private[sql] trait LookupCatalog extends Logging {
   }
 
   /**
-   * Extract catalog and namespace from a multi-part identifier with the current catalog if needed.
+   * Extract catalog and namespace from a multi-part name with the current catalog if needed.
    * Catalog name takes precedence over namespaces.
    */
   object CatalogAndNamespace {
-    def unapply(parts: Seq[String]): Some[(CatalogPlugin, Option[Seq[String]])] = parts match {
-      case Seq(catalogName, tail @ _*) =>
+    def unapply(nameParts: Seq[String]): Some[(CatalogPlugin, Seq[String])] = {
+      assert(nameParts.nonEmpty)
+      try {
+        Some((catalogManager.catalog(nameParts.head), nameParts.tail))
+      } catch {
+        case _: CatalogNotFoundException =>
+          Some((currentCatalog, nameParts))
+      }
+    }
+  }
+
+  /**
+   * Extract catalog and identifier from a multi-part name with the current catalog if needed.
+   * Catalog name takes precedence over identifier, but for a single-part name, identifier takes
+   * precedence over catalog name.
+   */
+  object CatalogAndIdentifier {
+    import org.apache.spark.sql.connector.catalog.CatalogV2Implicits.MultipartIdentifierHelper
+
+    private val globalTempDB = SQLConf.get.getConf(StaticSQLConf.GLOBAL_TEMP_DATABASE)
+
+    def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Identifier)] = {
+      assert(nameParts.nonEmpty)
+      if (nameParts.length == 1) {
+        Some((currentCatalog, Identifier.of(Array(), nameParts.head)))
+      } else if (nameParts.length == 2 && nameParts.head.equalsIgnoreCase(globalTempDB)) {
+        // Conceptually global temp views are in a special reserved catalog. However, the v2 catalog
+        // API does not support view yet, and we have to use v1 commands to deal with global temp
+        // views. To simplify the implementation, we put global temp views in a special namespace
+        // in the session catalog. The special namespace has higher priority during name resolution.
+        // For example, if the name of a custom catalog is the same with `GLOBAL_TEMP_DATABASE`,
+        // this custom catalog can't be accessed.
+        Some((catalogManager.v2SessionCatalog, nameParts.asIdentifier))
+      } else {
         try {
-          Some(
-            (catalogManager.catalog(catalogName), if (tail.isEmpty) { None } else { Some(tail) }))
+          Some((catalogManager.catalog(nameParts.head), nameParts.tail.asIdentifier))
         } catch {
           case _: CatalogNotFoundException =>
-            Some((currentCatalog, Some(parts)))
+            Some((currentCatalog, nameParts.asIdentifier))
         }
+      }
     }
   }
 
@@ -111,7 +143,8 @@ private[sql] trait LookupCatalog extends Logging {
    */
   object AsTableIdentifier {
     def unapply(parts: Seq[String]): Option[TableIdentifier] = parts match {
-      case CatalogAndIdentifier(None, names) if CatalogV2Util.isSessionCatalog(currentCatalog) =>
+      case CatalogAndMultipartIdentifier(None, names)
+          if CatalogV2Util.isSessionCatalog(currentCatalog) =>
         names match {
           case Seq(name) =>
             Some(TableIdentifier(name))
@@ -130,39 +163,12 @@ private[sql] trait LookupCatalog extends Logging {
    */
   object AsTemporaryViewIdentifier {
     def unapply(parts: Seq[String]): Option[TableIdentifier] = parts match {
-      case CatalogAndIdentifier(None, Seq(table)) =>
+      case CatalogAndMultipartIdentifier(None, Seq(table)) =>
         Some(TableIdentifier(table))
-      case CatalogAndIdentifier(None, Seq(database, table)) =>
+      case CatalogAndMultipartIdentifier(None, Seq(database, table)) =>
         Some(TableIdentifier(table, Some(database)))
       case _ =>
         None
     }
   }
-
-  /**
-   * Extract catalog and the rest name parts from a multi-part identifier.
-   */
-  object CatalogAndIdentifierParts {
-    private val globalTempDB = SQLConf.get.getConf(StaticSQLConf.GLOBAL_TEMP_DATABASE)
-
-    def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Seq[String])] = {
-      assert(nameParts.nonEmpty)
-      try {
-        // Conceptually global temp views are in a special reserved catalog. However, the v2 catalog
-        // API does not support view yet, and we have to use v1 commands to deal with global temp
-        // views. To simplify the implementation, we put global temp views in a special namespace
-        // in the session catalog. The special namespace has higher priority during name resolution.
-        // For example, if the name of a custom catalog is the same with `GLOBAL_TEMP_DATABASE`,
-        // this custom catalog can't be accessed.
-        if (nameParts.head.equalsIgnoreCase(globalTempDB)) {
-          Some((catalogManager.v2SessionCatalog, nameParts))
-        } else {
-          Some((catalogManager.catalog(nameParts.head), nameParts.tail))
-        }
-      } catch {
-        case _: CatalogNotFoundException =>
-          Some((currentCatalog, nameParts))
-      }
-    }
-  }
 }
diff --git a/sql/core/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveSessionCatalog.scala b/sql/core/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveSessionCatalog.scala
index c7ef878cb8c..53eb7dae2ca 100644
--- a/sql/core/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveSessionCatalog.scala
+++ b/sql/core/src/main/scala/org/apache/spark/sql/catalyst/analysis/ResolveSessionCatalog.scala
@@ -48,21 +48,21 @@ class ResolveSessionCatalog(
 
   override def apply(plan: LogicalPlan): LogicalPlan = plan.resolveOperatorsUp {
     case AlterTableAddColumnsStatement(
-         nameParts @ SessionCatalog(catalog, tableName), cols) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), cols) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
           cols.foreach(c => assertTopLevelColumn(c.name, "AlterTableAddColumnsCommand"))
-          AlterTableAddColumnsCommand(tableName.asTableIdentifier, cols.map(convertToStructField))
+          AlterTableAddColumnsCommand(tbl.asTableIdentifier, cols.map(convertToStructField))
       }.getOrElse {
         val changes = cols.map { col =>
           TableChange.addColumn(col.name.toArray, col.dataType, true, col.comment.orNull)
         }
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     case AlterTableAlterColumnStatement(
-         nameParts @ SessionCatalog(catalog, tableName), colName, dataType, comment) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), colName, dataType, comment) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
           if (colName.length > 1) {
             throw new AnalysisException(
@@ -85,7 +85,7 @@ class ResolveSessionCatalog(
             cleanedDataType,
             nullable = true,
             builder.build())
-          AlterTableChangeColumnCommand(tableName.asTableIdentifier, colName(0), newColumn)
+          AlterTableChangeColumnCommand(tbl.asTableIdentifier, colName(0), newColumn)
       }.getOrElse {
         val typeChange = dataType.map { newDataType =>
           TableChange.updateColumnType(colName.toArray, newDataType, true)
@@ -93,122 +93,124 @@ class ResolveSessionCatalog(
         val commentChange = comment.map { newComment =>
           TableChange.updateColumnComment(colName.toArray, newComment)
         }
-        createAlterTable(nameParts, catalog, tableName, typeChange.toSeq ++ commentChange)
+        createAlterTable(nameParts, catalog, tbl, typeChange.toSeq ++ commentChange)
       }
 
     case AlterTableRenameColumnStatement(
-         nameParts @ SessionCatalog(catalog, tableName), col, newName) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), col, newName) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
           throw new AnalysisException("RENAME COLUMN is only supported with v2 tables.")
       }.getOrElse {
         val changes = Seq(TableChange.renameColumn(col.toArray, newName))
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     case AlterTableDropColumnsStatement(
-         nameParts @ SessionCatalog(catalog, tableName), cols) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), cols) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
           throw new AnalysisException("DROP COLUMN is only supported with v2 tables.")
       }.getOrElse {
         val changes = cols.map(col => TableChange.deleteColumn(col.toArray))
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     case AlterTableSetPropertiesStatement(
-         nameParts @ SessionCatalog(catalog, tableName), props) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), props) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
-          AlterTableSetPropertiesCommand(tableName.asTableIdentifier, props, isView = false)
+          AlterTableSetPropertiesCommand(tbl.asTableIdentifier, props, isView = false)
       }.getOrElse {
         val changes = props.map { case (key, value) =>
           TableChange.setProperty(key, value)
         }.toSeq
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     case AlterTableUnsetPropertiesStatement(
-         nameParts @ SessionCatalog(catalog, tableName), keys, ifExists) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), keys, ifExists) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
           AlterTableUnsetPropertiesCommand(
-            tableName.asTableIdentifier, keys, ifExists, isView = false)
+            tbl.asTableIdentifier, keys, ifExists, isView = false)
       }.getOrElse {
         val changes = keys.map(key => TableChange.removeProperty(key))
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     case AlterTableSetLocationStatement(
-         nameParts @ SessionCatalog(catalog, tableName), partitionSpec, newLoc) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), partitionSpec, newLoc) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
-          AlterTableSetLocationCommand(tableName.asTableIdentifier, partitionSpec, newLoc)
+          AlterTableSetLocationCommand(tbl.asTableIdentifier, partitionSpec, newLoc)
       }.getOrElse {
         if (partitionSpec.nonEmpty) {
           throw new AnalysisException(
             "ALTER TABLE SET LOCATION does not support partition for v2 tables.")
         }
         val changes = Seq(TableChange.setProperty(TableCatalog.PROP_LOCATION, newLoc))
-        createAlterTable(nameParts, catalog, tableName, changes)
+        createAlterTable(nameParts, catalog, tbl, changes)
       }
 
     // ALTER VIEW should always use v1 command if the resolved catalog is session catalog.
-    case AlterViewSetPropertiesStatement(SessionCatalog(catalog, tableName), props) =>
-      AlterTableSetPropertiesCommand(tableName.asTableIdentifier, props, isView = true)
+    case AlterViewSetPropertiesStatement(SessionCatalogAndTable(_, tbl), props) =>
+      AlterTableSetPropertiesCommand(tbl.asTableIdentifier, props, isView = true)
 
-    case AlterViewUnsetPropertiesStatement(SessionCatalog(catalog, tableName), keys, ifExists) =>
-      AlterTableUnsetPropertiesCommand(tableName.asTableIdentifier, keys, ifExists, isView = true)
+    case AlterViewUnsetPropertiesStatement(SessionCatalogAndTable(_, tbl), keys, ifExists) =>
+      AlterTableUnsetPropertiesCommand(tbl.asTableIdentifier, keys, ifExists, isView = true)
 
-    case d @ DescribeNamespaceStatement(SessionCatalog(_, nameParts), _) =>
-      if (nameParts.length != 1) {
+    case d @ DescribeNamespaceStatement(SessionCatalogAndNamespace(_, ns), _) =>
+      if (ns.length != 1) {
         throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+          s"The database name is not valid: ${ns.quoted}")
       }
-      DescribeDatabaseCommand(nameParts.head, d.extended)
+      DescribeDatabaseCommand(ns.head, d.extended)
 
-    case AlterNamespaceSetPropertiesStatement(SessionCatalog(_, nameParts), properties) =>
-      if (nameParts.length != 1) {
+    case AlterNamespaceSetPropertiesStatement(
+        SessionCatalogAndNamespace(_, ns), properties) =>
+      if (ns.length != 1) {
         throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+          s"The database name is not valid: ${ns.quoted}")
       }
-      AlterDatabasePropertiesCommand(nameParts.head, properties)
+      AlterDatabasePropertiesCommand(ns.head, properties)
 
-    case AlterNamespaceSetLocationStatement(SessionCatalog(_, nameParts), location) =>
-      if (nameParts.length != 1) {
+    case AlterNamespaceSetLocationStatement(SessionCatalogAndNamespace(_, ns), location) =>
+      if (ns.length != 1) {
         throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+          s"The database name is not valid: ${ns.quoted}")
       }
-      AlterDatabaseSetLocationCommand(nameParts.head, location)
+      AlterDatabaseSetLocationCommand(ns.head, location)
 
-    case RenameTableStatement(SessionCatalog(_, oldName), newNameParts, isView) =>
+    case RenameTableStatement(SessionCatalogAndTable(_, oldName), newNameParts, isView) =>
       AlterTableRenameCommand(oldName.asTableIdentifier, newNameParts.asTableIdentifier, isView)
 
     case DescribeTableStatement(
-         nameParts @ SessionCatalog(catalog, tableName), partitionSpec, isExtended) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+         nameParts @ SessionCatalogAndTable(catalog, tbl), partitionSpec, isExtended) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
-          DescribeTableCommand(tableName.asTableIdentifier, partitionSpec, isExtended)
+          DescribeTableCommand(tbl.asTableIdentifier, partitionSpec, isExtended)
       }.getOrElse {
         // The v1 `DescribeTableCommand` can describe view as well.
-        if (isView(tableName)) {
-          DescribeTableCommand(tableName.asTableIdentifier, partitionSpec, isExtended)
+        if (isView(tbl)) {
+          DescribeTableCommand(tbl.asTableIdentifier, partitionSpec, isExtended)
         } else {
           if (partitionSpec.nonEmpty) {
             throw new AnalysisException("DESCRIBE TABLE does not support partition for v2 tables.")
           }
-          val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tableName.asIdentifier)
+          val r = UnresolvedV2Relation(nameParts, catalog.asTableCatalog, tbl.asIdentifier)
           DescribeTable(r, isExtended)
         }
       }
 
-    case DescribeColumnStatement(SessionCatalog(catalog, tableName), colNameParts, isExtended) =>
-      loadTable(catalog, tableName.asIdentifier).collect {
+    case DescribeColumnStatement(
+        SessionCatalogAndTable(catalog, tbl), colNameParts, isExtended) =>
+      loadTable(catalog, tbl.asIdentifier).collect {
         case v1Table: V1Table =>
-          DescribeColumnCommand(tableName.asTableIdentifier, colNameParts, isExtended)
+          DescribeColumnCommand(tbl.asTableIdentifier, colNameParts, isExtended)
       }.getOrElse {
-        if (isView(tableName)) {
-          DescribeColumnCommand(tableName.asTableIdentifier, colNameParts, isExtended)
+        if (isView(tbl)) {
+          DescribeColumnCommand(tbl.asTableIdentifier, colNameParts, isExtended)
         } else {
           throw new AnalysisException("Describing columns is not supported for v2 tables.")
         }
@@ -217,7 +219,7 @@ class ResolveSessionCatalog(
     // For CREATE TABLE [AS SELECT], we should use the v1 command if the catalog is resolved to the
     // session catalog and the table provider is not v2.
     case c @ CreateTableStatement(
-         SessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         SessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       if (!isV2Provider(c.provider)) {
         val tableDesc = buildCatalogTable(c.tableName.asTableIdentifier, c.tableSchema,
           c.partitioning, c.bucketSpec, c.properties, c.provider, c.options, c.location,
@@ -227,7 +229,7 @@ class ResolveSessionCatalog(
       } else {
         CreateV2Table(
           catalog.asTableCatalog,
-          tableName.asIdentifier,
+          tbl.asIdentifier,
           c.tableSchema,
           // convert the bucket spec and add it as a transform
           c.partitioning ++ c.bucketSpec.map(_.asTransform),
@@ -236,7 +238,7 @@ class ResolveSessionCatalog(
       }
 
     case c @ CreateTableAsSelectStatement(
-         SessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         SessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       if (!isV2Provider(c.provider)) {
         val tableDesc = buildCatalogTable(c.tableName.asTableIdentifier, new StructType,
           c.partitioning, c.bucketSpec, c.properties, c.provider, c.options, c.location,
@@ -246,7 +248,7 @@ class ResolveSessionCatalog(
       } else {
         CreateTableAsSelect(
           catalog.asTableCatalog,
-          tableName.asIdentifier,
+          tbl.asIdentifier,
           // convert the bucket spec and add it as a transform
           c.partitioning ++ c.bucketSpec.map(_.asTransform),
           c.asSelect,
@@ -255,19 +257,19 @@ class ResolveSessionCatalog(
           ignoreIfExists = c.ifNotExists)
       }
 
-    case RefreshTableStatement(SessionCatalog(_, tableName)) =>
-      RefreshTable(tableName.asTableIdentifier)
+    case RefreshTableStatement(SessionCatalogAndTable(_, tbl)) =>
+      RefreshTable(tbl.asTableIdentifier)
 
     // For REPLACE TABLE [AS SELECT], we should fail if the catalog is resolved to the
     // session catalog and the table provider is not v2.
     case c @ ReplaceTableStatement(
-         SessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         SessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       if (!isV2Provider(c.provider)) {
         throw new AnalysisException("REPLACE TABLE is only supported with v2 tables.")
       } else {
         ReplaceTable(
           catalog.asTableCatalog,
-          tableName.asIdentifier,
+          tbl.asIdentifier,
           c.tableSchema,
           // convert the bucket spec and add it as a transform
           c.partitioning ++ c.bucketSpec.map(_.asTransform),
@@ -276,13 +278,13 @@ class ResolveSessionCatalog(
       }
 
     case c @ ReplaceTableAsSelectStatement(
-         SessionCatalog(catalog, tableName), _, _, _, _, _, _, _, _, _) =>
+         SessionCatalogAndTable(catalog, tbl), _, _, _, _, _, _, _, _, _) =>
       if (!isV2Provider(c.provider)) {
         throw new AnalysisException("REPLACE TABLE AS SELECT is only supported with v2 tables.")
       } else {
         ReplaceTableAsSelect(
           catalog.asTableCatalog,
-          tableName.asIdentifier,
+          tbl.asIdentifier,
           // convert the bucket spec and add it as a transform
           c.partitioning ++ c.bucketSpec.map(_.asTransform),
           c.asSelect,
@@ -291,69 +293,70 @@ class ResolveSessionCatalog(
           orCreate = c.orCreate)
       }
 
-    case d @ DropTableStatement(SessionCatalog(catalog, tableName), ifExists, purge) =>
+    case d @ DropTableStatement(SessionCatalogAndTable(catalog, tbl), ifExists, purge) =>
       DropTableCommand(d.tableName.asTableIdentifier, ifExists, isView = false, purge = purge)
 
-    case DropViewStatement(SessionCatalog(catalog, viewName), ifExists) =>
+    case DropViewStatement(SessionCatalogAndTable(catalog, viewName), ifExists) =>
       DropTableCommand(viewName.asTableIdentifier, ifExists, isView = true, purge = false)
 
-    case c @ CreateNamespaceStatement(SessionCatalog(catalog, nameParts), _, _) =>
-      if (nameParts.length != 1) {
+    case c @ CreateNamespaceStatement(SessionCatalogAndNamespace(_, ns), _, _) =>
+      if (ns.length != 1) {
         throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+          s"The database name is not valid: ${ns.quoted}")
       }
 
       val comment = c.properties.get(SupportsNamespaces.PROP_COMMENT)
       val location = c.properties.get(SupportsNamespaces.PROP_LOCATION)
       val newProperties = c.properties -- SupportsNamespaces.RESERVED_PROPERTIES.asScala
-      CreateDatabaseCommand(nameParts.head, c.ifNotExists, location, comment, newProperties)
+      CreateDatabaseCommand(ns.head, c.ifNotExists, location, comment, newProperties)
 
-    case d @ DropNamespaceStatement(SessionCatalog(_, nameParts), _, _) =>
-      if (nameParts.length != 1) {
+    case d @ DropNamespaceStatement(SessionCatalogAndNamespace(_, ns), _, _) =>
+      if (ns.length != 1) {
         throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+          s"The database name is not valid: ${ns.quoted}")
       }
-      DropDatabaseCommand(nameParts.head, d.ifExists, d.cascade)
+      DropDatabaseCommand(ns.head, d.ifExists, d.cascade)
 
-    case ShowTablesStatement(Some(SessionCatalog(catalog, nameParts)), pattern) =>
-      if (nameParts.length != 1) {
-        throw new AnalysisException(
-          s"The database name is not valid: ${nameParts.quoted}")
+    case ShowTablesStatement(Some(CatalogAndNamespace(catalog, ns)), pattern)
+        if isSessionCatalog(catalog) =>
+      if (ns.length != 1) {
+          throw new AnalysisException(
+            s"The database name is not valid: ${ns.quoted}")
       }
-      ShowTablesCommand(Some(nameParts.head), pattern)
+      ShowTablesCommand(Some(ns.head), pattern)
 
     case ShowTablesStatement(None, pattern) if isSessionCatalog(currentCatalog) =>
       ShowTablesCommand(None, pattern)
 
-    case ShowTableStatement(namespace, pattern, partitionsSpec) =>
-      val db = namespace match {
-        case Some(namespace) if namespace.length != 1 =>
+    case ShowTableStatement(ns, pattern, partitionsSpec) =>
+      val db = ns match {
+        case Some(ns) if ns.length != 1 =>
           throw new AnalysisException(
-            s"The database name is not valid: ${namespace.quoted}")
-        case _ => namespace.map(_.head)
+            s"The database name is not valid: ${ns.quoted}")
+        case _ => ns.map(_.head)
       }
       ShowTablesCommand(db, Some(pattern), true, partitionsSpec)
 
-    case AnalyzeTableStatement(tableName, partitionSpec, noScan) =>
-      val v1TableName = parseV1Table(tableName, "ANALYZE TABLE")
+    case AnalyzeTableStatement(tbl, partitionSpec, noScan) =>
+      val v1TableName = parseV1Table(tbl, "ANALYZE TABLE")
       if (partitionSpec.isEmpty) {
         AnalyzeTableCommand(v1TableName.asTableIdentifier, noScan)
       } else {
         AnalyzePartitionCommand(v1TableName.asTableIdentifier, partitionSpec, noScan)
       }
 
-    case AnalyzeColumnStatement(tableName, columnNames, allColumns) =>
-      val v1TableName = parseV1Table(tableName, "ANALYZE TABLE")
+    case AnalyzeColumnStatement(tbl, columnNames, allColumns) =>
+      val v1TableName = parseV1Table(tbl, "ANALYZE TABLE")
       AnalyzeColumnCommand(v1TableName.asTableIdentifier, columnNames, allColumns)
 
-    case RepairTableStatement(tableName) =>
-      val v1TableName = parseV1Table(tableName, "MSCK REPAIR TABLE")
+    case RepairTableStatement(tbl) =>
+      val v1TableName = parseV1Table(tbl, "MSCK REPAIR TABLE")
       AlterTableRecoverPartitionsCommand(
         v1TableName.asTableIdentifier,
         "MSCK REPAIR TABLE")
 
-    case LoadDataStatement(tableName, path, isLocal, isOverwrite, partition) =>
-      val v1TableName = parseV1Table(tableName, "LOAD DATA")
+    case LoadDataStatement(tbl, path, isLocal, isOverwrite, partition) =>
+      val v1TableName = parseV1Table(tbl, "LOAD DATA")
       LoadDataCommand(
         v1TableName.asTableIdentifier,
         path,
@@ -361,73 +364,73 @@ class ResolveSessionCatalog(
         isOverwrite,
         partition)
 
-    case ShowCreateTableStatement(tableName) =>
-      val v1TableName = parseV1Table(tableName, "SHOW CREATE TABLE")
+    case ShowCreateTableStatement(tbl) =>
+      val v1TableName = parseV1Table(tbl, "SHOW CREATE TABLE")
       ShowCreateTableCommand(v1TableName.asTableIdentifier)
 
-    case CacheTableStatement(tableName, plan, isLazy, options) =>
-      val v1TableName = parseV1Table(tableName, "CACHE TABLE")
+    case CacheTableStatement(tbl, plan, isLazy, options) =>
+      val v1TableName = parseV1Table(tbl, "CACHE TABLE")
       CacheTableCommand(v1TableName.asTableIdentifier, plan, isLazy, options)
 
-    case UncacheTableStatement(tableName, ifExists) =>
-      val v1TableName = parseV1Table(tableName, "UNCACHE TABLE")
+    case UncacheTableStatement(tbl, ifExists) =>
+      val v1TableName = parseV1Table(tbl, "UNCACHE TABLE")
       UncacheTableCommand(v1TableName.asTableIdentifier, ifExists)
 
-    case TruncateTableStatement(tableName, partitionSpec) =>
-      val v1TableName = parseV1Table(tableName, "TRUNCATE TABLE")
+    case TruncateTableStatement(tbl, partitionSpec) =>
+      val v1TableName = parseV1Table(tbl, "TRUNCATE TABLE")
       TruncateTableCommand(
         v1TableName.asTableIdentifier,
         partitionSpec)
 
-    case ShowPartitionsStatement(tableName, partitionSpec) =>
-      val v1TableName = parseV1Table(tableName, "SHOW PARTITIONS")
+    case ShowPartitionsStatement(tbl, partitionSpec) =>
+      val v1TableName = parseV1Table(tbl, "SHOW PARTITIONS")
       ShowPartitionsCommand(
         v1TableName.asTableIdentifier,
         partitionSpec)
 
-    case ShowColumnsStatement(table, namespace) =>
+    case ShowColumnsStatement(tbl, ns) =>
       val sql = "SHOW COLUMNS"
-      val v1TableName = parseV1Table(table, sql).asTableIdentifier
+      val v1TableName = parseV1Table(tbl, sql).asTableIdentifier
       val resolver = conf.resolver
-      val db = namespace match {
+      val db = ns match {
         case Some(db) if (v1TableName.database.exists(!resolver(_, db.head))) =>
           throw new AnalysisException(
             s"SHOW COLUMNS with conflicting databases: " +
               s"'${db.head}' != '${v1TableName.database.get}'")
-        case _ => namespace.map(_.head)
+        case _ => ns.map(_.head)
       }
-      if (namespace.isDefined && namespace.get.length > 1) {
+      if (ns.isDefined && ns.get.length > 1) {
         throw new AnalysisException(
-          s"Namespace name should have only one part if specified: ${namespace.get.quoted}")
+          s"Namespace name should have only one part if specified: ${ns.get.quoted}")
       }
-      if (table.length > 2) {
+      if (tbl.length > 2) {
         throw new AnalysisException(
-          s"Table name should have at most two parts: ${table.quoted}")
+          s"Table name should have at most two parts: ${tbl.quoted}")
       }
       ShowColumnsCommand(db, v1TableName)
 
-    case AlterTableRecoverPartitionsStatement(tableName) =>
-      val v1TableName = parseV1Table(tableName, "ALTER TABLE RECOVER PARTITIONS")
+    case AlterTableRecoverPartitionsStatement(tbl) =>
+      val v1TableName = parseV1Table(tbl, "ALTER TABLE RECOVER PARTITIONS")
       AlterTableRecoverPartitionsCommand(
         v1TableName.asTableIdentifier,
         "ALTER TABLE RECOVER PARTITIONS")
 
-    case AlterTableAddPartitionStatement(tableName, partitionSpecsAndLocs, ifNotExists) =>
-      val v1TableName = parseV1Table(tableName, "ALTER TABLE ADD PARTITION")
+    case AlterTableAddPartitionStatement(tbl, partitionSpecsAndLocs, ifNotExists) =>
+      val v1TableName = parseV1Table(tbl, "ALTER TABLE ADD PARTITION")
       AlterTableAddPartitionCommand(
         v1TableName.asTableIdentifier,
         partitionSpecsAndLocs,
         ifNotExists)
 
-    case AlterTableRenamePartitionStatement(tableName, from, to) =>
-      val v1TableName = parseV1Table(tableName, "ALTER TABLE RENAME PARTITION")
+    case AlterTableRenamePartitionStatement(tbl, from, to) =>
+      val v1TableName = parseV1Table(tbl, "ALTER TABLE RENAME PARTITION")
       AlterTableRenamePartitionCommand(
         v1TableName.asTableIdentifier,
         from,
         to)
 
-    case AlterTableDropPartitionStatement(tableName, specs, ifExists, purge, retainData) =>
-      val v1TableName = parseV1Table(tableName, "ALTER TABLE DROP PARTITION")
+    case AlterTableDropPartitionStatement(tbl, specs, ifExists, purge, retainData) =>
+      val v1TableName = parseV1Table(tbl, "ALTER TABLE DROP PARTITION")
       AlterTableDropPartitionCommand(
         v1TableName.asTableIdentifier,
         specs,
@@ -435,27 +438,26 @@ class ResolveSessionCatalog(
         purge,
         retainData)
 
-    case AlterTableSerDePropertiesStatement(
-      tableName, serdeClassName, serdeProperties, partitionSpec) =>
-      val v1TableName = parseV1Table(tableName, "ALTER TABLE SerDe Properties")
+    case AlterTableSerDePropertiesStatement(tbl, serdeClassName, serdeProperties, partitionSpec) =>
+      val v1TableName = parseV1Table(tbl, "ALTER TABLE SerDe Properties")
       AlterTableSerDePropertiesCommand(
         v1TableName.asTableIdentifier,
         serdeClassName,
         serdeProperties,
         partitionSpec)
 
-    case AlterViewAsStatement(tableName, originalText, query) =>
-      val v1TableName = parseV1Table(tableName, "ALTER VIEW QUERY")
+    case AlterViewAsStatement(tbl, originalText, query) =>
+      val v1TableName = parseV1Table(tbl, "ALTER VIEW QUERY")
       AlterViewAsCommand(
         v1TableName.asTableIdentifier,
         originalText,
         query)
 
     case CreateViewStatement(
-      tableName, userSpecifiedColumns, comment, properties,
+      tbl, userSpecifiedColumns, comment, properties,
       originalText, child, allowExisting, replace, viewType) =>
 
-      val v1TableName = parseV1Table(tableName, "CREATE VIEW")
+      val v1TableName = parseV1Table(tbl, "CREATE VIEW")
       CreateViewCommand(
         v1TableName.asTableIdentifier,
         userSpecifiedColumns,
@@ -467,20 +469,20 @@ class ResolveSessionCatalog(
         replace,
         viewType)
 
-    case ShowTablePropertiesStatement(SessionCatalog(_, tableName), propertyKey) =>
+    case ShowTablePropertiesStatement(SessionCatalogAndTable(_, tbl), propertyKey) =>
       ShowTablePropertiesCommand(
-        tableName.asTableIdentifier,
+        tbl.asTableIdentifier,
         propertyKey)
 
     case ShowFunctionsStatement(userScope, systemScope, pattern, fun) =>
       val (database, function) = fun match {
-        case Some(CatalogAndIdentifierParts(catalog, functionName)) =>
+        case Some(CatalogAndIdentifier(catalog, functionIdent)) =>
           if (isSessionCatalog(catalog)) {
-            functionName match {
+            functionIdent.asMultipartIdentifier match {
               case Seq(db, fn) => (Some(db), Some(fn))
               case Seq(fn) => (None, Some(fn))
               case _ =>
-                throw new AnalysisException(s"Unsupported function name '${functionName.quoted}'")
+                throw new AnalysisException(s"Unsupported function name '${functionIdent.quoted}'")
             }
           } else {
             throw new AnalysisException ("SHOW FUNCTIONS is only supported in v1 catalog")
@@ -491,11 +493,11 @@ class ResolveSessionCatalog(
   }
 
   private def parseV1Table(tableName: Seq[String], sql: String): Seq[String] = {
-    val CatalogAndIdentifierParts(catalog, parts) = tableName
+    val CatalogAndIdentifier(catalog, ident) = tableName
     if (!isSessionCatalog(catalog)) {
       throw new AnalysisException(s"$sql is only supported with v1 tables.")
     }
-    parts
+    ident.asMultipartIdentifier
   }
 
   private def buildCatalogTable(
@@ -536,10 +538,18 @@ class ResolveSessionCatalog(
       comment = comment)
   }
 
-  object SessionCatalog {
+  object SessionCatalogAndTable {
+    def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Seq[String])] = nameParts match {
+      case CatalogAndIdentifier(catalog, ident) if isSessionCatalog(catalog) =>
+        Some(catalog -> ident.asMultipartIdentifier)
+      case _ => None
+    }
+  }
+
+  object SessionCatalogAndNamespace {
     def unapply(nameParts: Seq[String]): Option[(CatalogPlugin, Seq[String])] = nameParts match {
-      case CatalogAndIdentifierParts(catalog, parts) if isSessionCatalog(catalog) =>
-        Some(catalog -> parts)
+      case CatalogAndNamespace(catalog, ns) if isSessionCatalog(catalog) =>
+        Some(catalog -> ns)
       case _ => None
     }
   }
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/connector/DataSourceV2SQLSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/connector/DataSourceV2SQLSuite.scala
index ebaf753696f..6675636c0e6 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/connector/DataSourceV2SQLSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/connector/DataSourceV2SQLSuite.scala
@@ -1822,6 +1822,26 @@ class DataSourceV2SQLSuite
     }
   }
 
+  test("SPARK-30104: global temp db is used as a table name under v2 catalog") {
+    val globalTempDB = spark.sessionState.conf.getConf(StaticSQLConf.GLOBAL_TEMP_DATABASE)
+    val t = s"testcat.$globalTempDB"
+    withTable(t) {
+      sql(s"CREATE TABLE $t (id bigint, data string) USING foo")
+      sql("USE testcat")
+      // The following should not throw AnalysisException, but should use `testcat.$globalTempDB`.
+      sql(s"DESCRIBE TABLE $globalTempDB")
+    }
+  }
+
+  test("table name same as catalog can be used") {
+    withTable("testcat.testcat") {
+      sql(s"CREATE TABLE testcat.testcat (id bigint, data string) USING foo")
+      sql("USE testcat")
+      // The following should not throw AnalysisException.
+      sql(s"DESCRIBE TABLE testcat")
+    }
+  }
+
   test("SPARK-30001: session catalog name can be specified in SQL statements") {
     // unset this config to use the default v2 session catalog.
     spark.conf.unset(V2_SESSION_CATALOG_IMPLEMENTATION.key)
