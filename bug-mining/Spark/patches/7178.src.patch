diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/RandomDataGenerator.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/RandomDataGenerator.scala
index a7c20c34d78..5a4d23debce 100644
--- a/sql/catalyst/src/test/scala/org/apache/spark/sql/RandomDataGenerator.scala
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/RandomDataGenerator.scala
@@ -18,9 +18,10 @@
 package org.apache.spark.sql
 
 import java.math.MathContext
+import java.sql.{Date, Timestamp}
 
 import scala.collection.mutable
-import scala.util.Random
+import scala.util.{Random, Try}
 
 import org.apache.spark.sql.catalyst.CatalystTypeConverters
 import org.apache.spark.sql.catalyst.util.DateTimeConstants.MILLIS_PER_DAY
@@ -172,7 +173,15 @@ object RandomDataGenerator {
               // January 1, 1970, 00:00:00 GMT for "9999-12-31 23:59:59.999999".
               milliseconds = rand.nextLong() % 253402329599999L
             }
-            DateTimeUtils.toJavaDate((milliseconds / MILLIS_PER_DAY).toInt)
+            val date = DateTimeUtils.toJavaDate((milliseconds / MILLIS_PER_DAY).toInt)
+            // The generated `date` is based on the hybrid calendar Julian + Gregorian since
+            // 1582-10-15 but it should be valid in Proleptic Gregorian calendar too which is used
+            // by Spark SQL since version 3.0 (see SPARK-26651). We try to convert `date` to
+            // a local date in Proleptic Gregorian calendar to satisfy this requirement.
+            // Some years are leap years in Julian calendar but not in Proleptic Gregorian calendar.
+            // As the consequence of that, 29 February of such years might not exist in Proleptic
+            // Gregorian calendar. When this happens, we shift the date by one day.
+            Try { date.toLocalDate; date }.getOrElse(new Date(date.getTime + MILLIS_PER_DAY))
           }
         Some(generator)
       case TimestampType =>
@@ -188,7 +197,15 @@ object RandomDataGenerator {
               milliseconds = rand.nextLong() % 253402329599999L
             }
             // DateTimeUtils.toJavaTimestamp takes microsecond.
-            DateTimeUtils.toJavaTimestamp(milliseconds * 1000)
+            val ts = DateTimeUtils.toJavaTimestamp(milliseconds * 1000)
+            // The generated `ts` is based on the hybrid calendar Julian + Gregorian since
+            // 1582-10-15 but it should be valid in Proleptic Gregorian calendar too which is used
+            // by Spark SQL since version 3.0 (see SPARK-26651). We try to convert `ts` to
+            // a local timestamp in Proleptic Gregorian calendar to satisfy this requirement.
+            // Some years are leap years in Julian calendar but not in Proleptic Gregorian calendar.
+            // As the consequence of that, 29 February of such years might not exist in Proleptic
+            // Gregorian calendar. When this happens, we shift the timestamp `ts` by one day.
+            Try { ts.toLocalDateTime; ts }.getOrElse(new Timestamp(ts.getTime + MILLIS_PER_DAY))
           }
         Some(generator)
       case CalendarIntervalType => Some(() => {
