diff --git a/sql/core/src/main/scala/org/apache/spark/sql/internal/SharedState.scala b/sql/core/src/main/scala/org/apache/spark/sql/internal/SharedState.scala
index 3f676bec9ff..36a6c3081b2 100644
--- a/sql/core/src/main/scala/org/apache/spark/sql/internal/SharedState.scala
+++ b/sql/core/src/main/scala/org/apache/spark/sql/internal/SharedState.scala
@@ -75,7 +75,13 @@ private[sql] class SharedState(
         logDebug(s"Applying other initial session options to HadoopConf: $k -> $v")
         hadoopConfClone.set(k, v)
     }
-    val qualified = SharedState.qualifyWarehousePath(hadoopConfClone, warehousePath)
+    val qualified = try {
+      SharedState.qualifyWarehousePath(hadoopConfClone, warehousePath)
+    } catch {
+      case NonFatal(e) =>
+        logWarning("Cannot qualify the warehouse path, leaving it unqualified.", e)
+        warehousePath
+    }
     // Set warehouse path in the SparkConf and Hadoop conf, so that it's application wide reachable
     // from `SparkContext`.
     SharedState.setWarehousePathConf(sparkContext.conf, sparkContext.hadoopConfiguration, qualified)
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/SparkSessionBuilderSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/SparkSessionBuilderSuite.scala
index f12f866073d..8c622bad15d 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/SparkSessionBuilderSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/SparkSessionBuilderSuite.scala
@@ -472,4 +472,19 @@ class SparkSessionBuilderSuite extends SparkFunSuite with BeforeAndAfterEach wit
         expected)
     }
   }
+
+  test("SPARK-33944: Create a working SparkSession with a broken FileSystem") {
+    val msg = "Cannot qualify the warehouse path, leaving it unqualified"
+    val logAppender = new LogAppender(msg)
+    withLogAppender(logAppender) {
+      val session =
+        SparkSession.builder()
+          .master("local")
+          .config(WAREHOUSE_PATH.key, "my_dir")
+          .config("fs.file.impl", "non.existing.class")
+          .getOrCreate()
+      session.sql("SELECT 1").collect()
+    }
+    assert(logAppender.loggingEvents.exists(_.getRenderedMessage.contains(msg)))
+  }
 }
