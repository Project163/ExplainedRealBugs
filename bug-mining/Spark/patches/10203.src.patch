diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala
index 090ee0bfcfe..78ae9c8afe4 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/analysis/Analyzer.scala
@@ -2939,12 +2939,14 @@ class Analyzer(override val catalogManager: CatalogManager) extends RuleExecutor
       // Avoid adding an extra aggregate expression if it's already present in
       // `agg.aggregateExpressions`. Trim inner aliases from aggregate expressions because of
       // expressions like `spark_grouping_id` that can have inner aliases.
-      val index = agg.aggregateExpressions.indexWhere {
-        case Alias(child, _) => trimAliases(child) semanticEquals expr
-        case other => other semanticEquals expr
-      }
-      if (index >= 0) {
-        agg.aggregateExpressions(index).toAttribute
+      val replacement: Option[NamedExpression] =
+        agg.aggregateExpressions.foldLeft(Option.empty[NamedExpression]) {
+          case (None, alias: Alias) if expr.semanticEquals(trimAliases(alias.child)) => Some(alias)
+          case (None | Some(_: Alias), aggExpr) if expr.semanticEquals(aggExpr) => Some(aggExpr)
+          case (current, _) => current
+        }
+      if (replacement.isDefined) {
+        replacement.get.toAttribute
       } else {
         expr match {
           case ae: AggregateExpression =>
diff --git a/sql/core/src/test/resources/sql-tests/analyzer-results/replacing-missing-expression-with-alias.sql.out b/sql/core/src/test/resources/sql-tests/analyzer-results/replacing-missing-expression-with-alias.sql.out
new file mode 100644
index 00000000000..a353c9e8ed0
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/analyzer-results/replacing-missing-expression-with-alias.sql.out
@@ -0,0 +1,204 @@
+-- Automatically generated by SQLQueryTestSuite
+-- !query
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a ORDER BY col1 + 1
+-- !query analysis
+Sort [a#x ASC NULLS FIRST], true
++- Aggregate [(col1#x + 1)], [(col1#x + 1) AS a#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a ORDER BY col1 + 1
+-- !query analysis
+Sort [a#x ASC NULLS FIRST], true
++- Project [a#x, a#x AS b#x]
+   +- Project [(col1 + 1)#x, (col1 + 1)#x AS a#x]
+      +- Aggregate [(col1#x + 1)], [(col1#x + 1) AS (col1 + 1)#x]
+         +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0
+-- !query analysis
+Filter (a#x > 0)
++- Aggregate [(col1#x + 1)], [(col1#x + 1) AS a#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0
+-- !query analysis
+Filter (a#x > 0)
++- Project [a#x, a#x AS b#x]
+   +- Project [(col1 + 1)#x, (col1 + 1)#x AS a#x]
+      +- Aggregate [(col1#x + 1)], [(col1#x + 1) AS (col1 + 1)#x]
+         +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) ORDER BY GROUPING(col1)
+-- !query analysis
+Sort [grouping(col1)#x ASC NULLS FIRST], true
++- Aggregate [col1#x, col2#x, spark_grouping_id#xL], [col1#x, col2#x, cast((shiftright(spark_grouping_id#xL, 1) & 1) as tinyint) AS grouping(col1)#x]
+   +- Expand [[col1#x, col2#x, col1#x, col2#x, 0], [col1#x, col2#x, col1#x, null, 1], [col1#x, col2#x, null, col2#x, 2], [col1#x, col2#x, null, null, 3]], [col1#x, col2#x, col1#x, col2#x, spark_grouping_id#xL]
+      +- Project [col1#x, col2#x, col1#x AS col1#x, col2#x AS col2#x]
+         +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) HAVING GROUPING(col1) != NULL
+-- !query analysis
+Filter NOT (grouping(col1)#x = cast(null as tinyint))
++- Aggregate [col1#x, col2#x, spark_grouping_id#xL], [col1#x, col2#x, cast((shiftright(spark_grouping_id#xL, 1) & 1) as tinyint) AS grouping(col1)#x]
+   +- Expand [[col1#x, col2#x, col1#x, col2#x, 0], [col1#x, col2#x, col1#x, null, 1], [col1#x, col2#x, null, col2#x, 2], [col1#x, col2#x, null, null, 3]], [col1#x, col2#x, col1#x, col2#x, spark_grouping_id#xL]
+      +- Project [col1#x, col2#x, col1#x AS col1#x, col2#x AS col2#x]
+         +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3)
+-- !query analysis
+Sort [a#x ASC NULLS FIRST], true
++- Aggregate [make_date(col1#x, col2#x, col3#x, true)], [make_date(col1#x, col2#x, col3#x, true) AS a#x]
+   +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3)
+-- !query analysis
+Sort [a#x ASC NULLS FIRST], true
++- Project [a#x, a#x AS b#x]
+   +- Project [make_date(col1, col2, col3)#x, make_date(col1, col2, col3)#x AS a#x]
+      +- Aggregate [make_date(col1#x, col2#x, col3#x, true)], [make_date(col1#x, col2#x, col3#x, true) AS make_date(col1, col2, col3)#x]
+         +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01'
+-- !query analysis
+Filter (a#x > cast(2025-01-01 as date))
++- Aggregate [make_date(col1#x, col2#x, col3#x, true)], [make_date(col1#x, col2#x, col3#x, true) AS a#x]
+   +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01'
+-- !query analysis
+Filter (a#x > cast(2025-01-01 as date))
++- Project [a#x, a#x AS b#x]
+   +- Project [make_date(col1, col2, col3)#x, make_date(col1, col2, col3)#x AS a#x]
+      +- Aggregate [make_date(col1#x, col2#x, col3#x, true)], [make_date(col1#x, col2#x, col3#x, true) AS make_date(col1, col2, col3)#x]
+         +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3)
+-- !query analysis
+Project [a#x]
++- Sort [make_date(col1#x, col2#x, col3#x, true) ASC NULLS FIRST], true
+   +- Project [make_date(col1#x, col2#x, col3#x, true) AS a#x, col1#x, col2#x, col3#x]
+      +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3)
+-- !query analysis
+Project [a#x, b#x]
++- Sort [make_date(col1#x, col2#x, col3#x, true) ASC NULLS FIRST], true
+   +- Project [a#x, a#x AS b#x, col1#x, col2#x, col3#x]
+      +- Project [col1#x, col2#x, col3#x, make_date(col1#x, col2#x, col3#x, true) AS a#x]
+         +- LocalRelation [col1#x, col2#x, col3#x]
+
+
+-- !query
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC
+-- !query analysis
+Sort [col1#x ASC NULLS FIRST], true
++- Aggregate [col1#x], [col1#x, col1#x AS a#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC
+-- !query analysis
+Sort [col1#x ASC NULLS FIRST], true
++- Aggregate [col1#x], [col1#x AS a#x, col1#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 HAVING col1 > 0
+-- !query analysis
+Filter (col1#x > 0)
++- Aggregate [col1#x], [col1#x, col1#x AS a#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 HAVING col1 > 0
+-- !query analysis
+Filter (col1#x > 0)
++- Aggregate [col1#x], [col1#x AS a#x, col1#x]
+   +- LocalRelation [col1#x]
+
+
+-- !query
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL
+-- !query analysis
+Sort [b#x ASC NULLS FIRST, col2#x ASC NULLS FIRST], true
++- Aggregate [col2#x, col2#x], [col2#x AS b#x, col2#x]
+   +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL
+-- !query analysis
+Sort [b#x ASC NULLS FIRST, col2#x ASC NULLS FIRST], true
++- Filter (col2#x > 0)
+   +- Aggregate [col2#x, col2#x], [col2#x AS b#x, col2#x]
+      +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL
+-- !query analysis
+Sort [b#x ASC NULLS FIRST, col2#x ASC NULLS FIRST, c#x ASC NULLS FIRST], true
++- Project [b#x, col2#x, b#x AS c#x]
+   +- Project [col2#x, col2#x AS b#x]
+      +- Aggregate [col2#x, col2#x], [col2#x]
+         +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL
+-- !query analysis
+Sort [b#x ASC NULLS FIRST, col2#x ASC NULLS FIRST, c#x ASC NULLS FIRST], true
++- Filter (col2#x > 0)
+   +- Project [b#x, col2#x, b#x AS c#x]
+      +- Project [col2#x, col2#x AS b#x]
+         +- Aggregate [col2#x, col2#x], [col2#x]
+            +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col1 AS a FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1
+-- !query analysis
+Project [a#x]
++- Sort [col1#x ASC NULLS FIRST], true
+   +- Project [a#x, col1#x]
+      +- Filter (col2#x > 1)
+         +- Aggregate [col1#x, col2#x], [col1#x AS a#x, col2#x, col1#x]
+            +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+SELECT col1 AS a, a AS b FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1
+-- !query analysis
+Project [a#x, b#x]
++- Sort [col1#x ASC NULLS FIRST], true
+   +- Project [a#x, b#x, col1#x]
+      +- Filter (col2#x > 1)
+         +- Project [a#x, a#x AS b#x, col2#x, col1#x]
+            +- Project [col1#x, col2#x, col1#x AS a#x]
+               +- Aggregate [col1#x, col2#x], [col1#x, col2#x]
+                  +- LocalRelation [col1#x, col2#x]
diff --git a/sql/core/src/test/resources/sql-tests/inputs/replacing-missing-expression-with-alias.sql b/sql/core/src/test/resources/sql-tests/inputs/replacing-missing-expression-with-alias.sql
new file mode 100644
index 00000000000..0f238033fad
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/inputs/replacing-missing-expression-with-alias.sql
@@ -0,0 +1,33 @@
+-- Replace expression with alias that has semantically equal child if expression is not in output
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a ORDER BY col1 + 1;
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a ORDER BY col1 + 1;
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0;
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0;
+
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) ORDER BY GROUPING(col1);
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) HAVING GROUPING(col1) != NULL;
+
+
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3);
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3);
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01';
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01';
+
+-- Don't replace expression with alias that has semantically equal child if expression is not grouping
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3);
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3);
+
+-- Don't replace expression with alias that has semantically equal child if expression is in output
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC;
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC;
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 HAVING col1 > 0;
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 HAVING col1 > 0;
+
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL;
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL;
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL;
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL;
+
+-- Fixed point doesn't know to correctly replace `col1` with `a` because HAVING adds an artificial Project node
+SELECT col1 AS a FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1;
+SELECT col1 AS a, a AS b FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1;
diff --git a/sql/core/src/test/resources/sql-tests/results/replacing-missing-expression-with-alias.sql.out b/sql/core/src/test/resources/sql-tests/results/replacing-missing-expression-with-alias.sql.out
new file mode 100644
index 00000000000..f3a6b0424b6
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/results/replacing-missing-expression-with-alias.sql.out
@@ -0,0 +1,178 @@
+-- Automatically generated by SQLQueryTestSuite
+-- !query
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a ORDER BY col1 + 1
+-- !query schema
+struct<a:int>
+-- !query output
+2
+
+
+-- !query
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a ORDER BY col1 + 1
+-- !query schema
+struct<a:int,b:int>
+-- !query output
+2	2
+
+
+-- !query
+SELECT col1 + 1 AS a FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0
+-- !query schema
+struct<a:int>
+-- !query output
+2
+
+
+-- !query
+SELECT col1 + 1 AS a, a AS b FROM VALUES(1) GROUP BY a HAVING col1 + 1 > 0
+-- !query schema
+struct<a:int,b:int>
+-- !query output
+2	2
+
+
+-- !query
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) ORDER BY GROUPING(col1)
+-- !query schema
+struct<col1:string,col2:int,grouping(col1):tinyint>
+-- !query output
+abc	1	0
+abc	NULL	0
+NULL	1	1
+NULL	NULL	1
+
+
+-- !query
+SELECT col1, col2, GROUPING(col1) FROM VALUES("abc", 1) GROUP BY CUBE(col1, col2) HAVING GROUPING(col1) != NULL
+-- !query schema
+struct<col1:string,col2:int,grouping(col1):tinyint>
+-- !query output
+
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3)
+-- !query schema
+struct<a:date>
+-- !query output
+0001-02-03
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) ORDER BY make_date(col1, col2, col3)
+-- !query schema
+struct<a:date,b:date>
+-- !query output
+0001-02-03	0001-02-03
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01'
+-- !query schema
+struct<a:date>
+-- !query output
+
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) GROUP BY make_date(col1, col2, col3) HAVING make_date(col1, col2, col3) > '2025-01-01'
+-- !query schema
+struct<a:date,b:date>
+-- !query output
+
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3)
+-- !query schema
+struct<a:date>
+-- !query output
+0001-02-03
+
+
+-- !query
+SELECT make_date(col1, col2, col3) AS a, a AS b FROM VALUES(1,2,3) ORDER BY make_date(col1, col2, col3)
+-- !query schema
+struct<a:date,b:date>
+-- !query output
+0001-02-03	0001-02-03
+
+
+-- !query
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC
+-- !query schema
+struct<col1:int,a:int>
+-- !query output
+1	1
+
+
+-- !query
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 ORDER BY col1 ASC
+-- !query schema
+struct<a:int,col1:int>
+-- !query output
+1	1
+
+
+-- !query
+SELECT col1, col1 AS a FROM VALUES(1) GROUP BY col1 HAVING col1 > 0
+-- !query schema
+struct<col1:int,a:int>
+-- !query output
+1	1
+
+
+-- !query
+SELECT col1 AS a, col1 FROM VALUES(1) GROUP BY col1 HAVING col1 > 0
+-- !query schema
+struct<a:int,col1:int>
+-- !query output
+1	1
+
+
+-- !query
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL
+-- !query schema
+struct<b:int,col2:int>
+-- !query output
+2	2
+
+
+-- !query
+SELECT col2 AS b, col2 FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL
+-- !query schema
+struct<b:int,col2:int>
+-- !query output
+2	2
+
+
+-- !query
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 ORDER BY ALL
+-- !query schema
+struct<b:int,col2:int,c:int>
+-- !query output
+2	2	2
+
+
+-- !query
+SELECT col2 AS b, col2, b as c FROM VALUES(1,2) GROUP BY 1,2 HAVING col2 > 0 ORDER BY ALL
+-- !query schema
+struct<b:int,col2:int,c:int>
+-- !query output
+2	2	2
+
+
+-- !query
+SELECT col1 AS a FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1
+-- !query schema
+struct<a:int>
+-- !query output
+1
+
+
+-- !query
+SELECT col1 AS a, a AS b FROM VALUES(1,2) GROUP BY col1, col2 HAVING col2 > 1 ORDER BY col1
+-- !query schema
+struct<a:int,b:int>
+-- !query output
+1	1
