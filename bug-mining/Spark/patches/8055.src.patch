diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparison.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparison.scala
index d5ff0fc349b..08c4cbfe77d 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparison.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparison.scala
@@ -141,8 +141,9 @@ object UnwrapCastInBinaryComparison extends Rule[LogicalPlan] {
     // values.
     // 2. this rule only handles the case when both `fromExp` and value in `in.list` are of numeric
     // type.
+    // 3. this rule doesn't optimize In when `in.list` contains an expression that is not literal.
     case in @ In(Cast(fromExp, toType: NumericType, _, _), list @ Seq(firstLit, _*))
-      if canImplicitlyCast(fromExp, toType, firstLit.dataType) =>
+      if canImplicitlyCast(fromExp, toType, firstLit.dataType) && in.inSetConvertible =>
 
       // There are 3 kinds of literals in the list:
       // 1. null literals
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparisonSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparisonSuite.scala
index e5df1abf00b..31f62cf28e9 100644
--- a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparisonSuite.scala
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/UnwrapCastInBinaryComparisonSuite.scala
@@ -283,6 +283,25 @@ class UnwrapCastInBinaryComparisonSuite extends PlanTest with ExpressionEvalHelp
     )
   }
 
+  test("SPARK-36130: unwrap In should skip when in.list contains an expression that " +
+    "is not literal") {
+    val add = Cast(f2, DoubleType) + 1.0d
+    val doubleLit = Literal.create(null, DoubleType)
+    assertEquivalent(In(Cast(f2, DoubleType), Seq(add)), In(Cast(f2, DoubleType), Seq(add)))
+    assertEquivalent(
+      In(Cast(f2, DoubleType), Seq(doubleLit, add)),
+      In(Cast(f2, DoubleType), Seq(doubleLit, add)))
+    assertEquivalent(
+      In(Cast(f2, DoubleType), Seq(doubleLit, 1.0d, add)),
+      In(Cast(f2, DoubleType), Seq(doubleLit, 1.0d, add)))
+    assertEquivalent(
+      In(Cast(f2, DoubleType), Seq(1.0d, add)),
+      In(Cast(f2, DoubleType), Seq(1.0d, add)))
+    assertEquivalent(
+      In(Cast(f2, DoubleType), Seq(0.0d, 1.0d, add)),
+      In(Cast(f2, DoubleType), Seq(0.0d, 1.0d, add)))
+  }
+
   private def castInt(e: Expression): Expression = Cast(e, IntegerType)
   private def castDouble(e: Expression): Expression = Cast(e, DoubleType)
   private def castDecimal2(e: Expression): Expression = Cast(e, DecimalType(10, 4))
