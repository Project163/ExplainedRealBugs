diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/expressions.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/expressions.scala
index 3c4b284b307..468a950fb10 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/expressions.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/expressions.scala
@@ -276,31 +276,37 @@ object BooleanSimplification extends Rule[LogicalPlan] with PredicateHelper {
       case a And b if a.semanticEquals(b) => a
       case a Or b if a.semanticEquals(b) => a
 
-      // The following optimization is applicable only when the operands are not nullable,
+      // The following optimizations are applicable only when the operands are not nullable,
       // since the three-value logic of AND and OR are different in NULL handling.
       // See the chart:
       // +---------+---------+---------+---------+
-      // |    p    |    q    | p OR q  | p AND q |
+      // | operand | operand |   OR    |   AND   |
       // +---------+---------+---------+---------+
       // | TRUE    | TRUE    | TRUE    | TRUE    |
       // | TRUE    | FALSE   | TRUE    | FALSE   |
-      // | TRUE    | UNKNOWN | TRUE    | UNKNOWN |
-      // | FALSE   | TRUE    | TRUE    | FALSE   |
       // | FALSE   | FALSE   | FALSE   | FALSE   |
-      // | FALSE   | UNKNOWN | UNKNOWN | FALSE   |
       // | UNKNOWN | TRUE    | TRUE    | UNKNOWN |
       // | UNKNOWN | FALSE   | UNKNOWN | FALSE   |
       // | UNKNOWN | UNKNOWN | UNKNOWN | UNKNOWN |
       // +---------+---------+---------+---------+
+
+      // (NULL And (NULL Or FALSE)) = NULL, but (NULL And FALSE) = FALSE. Thus, a can't be nullable.
       case a And (b Or c) if !a.nullable && Not(a).semanticEquals(b) => And(a, c)
+      // (NULL And (FALSE Or NULL)) = NULL, but (NULL And FALSE) = FALSE. Thus, a can't be nullable.
       case a And (b Or c) if !a.nullable && Not(a).semanticEquals(c) => And(a, b)
-      case (a Or b) And c if !a.nullable && a.semanticEquals(Not(c)) => And(b, c)
-      case (a Or b) And c if !b.nullable && b.semanticEquals(Not(c)) => And(a, c)
+      // ((NULL Or FALSE) And NULL) = NULL, but (FALSE And NULL) = FALSE. Thus, c can't be nullable.
+      case (a Or b) And c if !c.nullable && a.semanticEquals(Not(c)) => And(b, c)
+      // ((FALSE Or NULL) And NULL) = NULL, but (FALSE And NULL) = FALSE. Thus, c can't be nullable.
+      case (a Or b) And c if !c.nullable && b.semanticEquals(Not(c)) => And(a, c)
 
+      // (NULL Or (NULL And TRUE)) = NULL, but (NULL Or TRUE) = TRUE. Thus, a can't be nullable.
       case a Or (b And c) if !a.nullable && Not(a).semanticEquals(b) => Or(a, c)
+      // (NULL Or (TRUE And NULL)) = NULL, but (NULL Or TRUE) = TRUE. Thus, a can't be nullable.
       case a Or (b And c) if !a.nullable && Not(a).semanticEquals(c) => Or(a, b)
-      case (a And b) Or c if !a.nullable && a.semanticEquals(Not(c)) => Or(b, c)
-      case (a And b) Or c if !b.nullable && b.semanticEquals(Not(c)) => Or(a, c)
+      // ((NULL And TRUE) Or NULL) = NULL, but (TRUE Or NULL) = TRUE. Thus, c can't be nullable.
+      case (a And b) Or c if !c.nullable && a.semanticEquals(Not(c)) => Or(b, c)
+      // ((TRUE And NULL) Or NULL) = NULL, but (TRUE Or NULL) = TRUE. Thus, c can't be nullable.
+      case (a And b) Or c if !c.nullable && b.semanticEquals(Not(c)) => Or(a, c)
 
       // Common factor elimination for conjunction
       case and @ (left And right) =>
