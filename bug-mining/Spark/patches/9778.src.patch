diff --git a/common/utils/src/main/resources/error/error-conditions.json b/common/utils/src/main/resources/error/error-conditions.json
index b8ada7c6ed0..84681ab8c22 100644
--- a/common/utils/src/main/resources/error/error-conditions.json
+++ b/common/utils/src/main/resources/error/error-conditions.json
@@ -514,7 +514,7 @@
     "subClass" : {
       "EXPLICIT" : {
         "message" : [
-          "Error occurred due to the mismatch between explicit collations: <explicitTypes>. Decide on a single explicit collation and remove others."
+          "Error occurred due to the mismatch between explicit collations: [<explicitTypes>]. Decide on a single explicit collation and remove others."
         ]
       },
       "IMPLICIT" : {
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/errors/QueryCompilationErrors.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/errors/QueryCompilationErrors.scala
index 73a98f9fe4b..b489387c786 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/errors/QueryCompilationErrors.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/errors/QueryCompilationErrors.scala
@@ -3675,7 +3675,7 @@ private[sql] object QueryCompilationErrors extends QueryErrorsBase with Compilat
     new AnalysisException(
       errorClass = "COLLATION_MISMATCH.EXPLICIT",
       messageParameters = Map(
-        "explicitTypes" -> toSQLId(explicitTypes)
+        "explicitTypes" -> explicitTypes.map(toSQLId).mkString(", ")
       )
     )
   }
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLExpressionsSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLExpressionsSuite.scala
index 7994c496cb6..300f23c317e 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLExpressionsSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLExpressionsSuite.scala
@@ -680,11 +680,14 @@ class CollationSQLExpressionsSuite
     val number = "xx"
     val query = s"SELECT to_number('$number', '999');"
     withSQLConf(SqlApiConf.DEFAULT_COLLATION -> "UNICODE") {
-      val e = intercept[SparkIllegalArgumentException] {
-        val testQuery = sql(query)
-        testQuery.collect()
-      }
-      assert(e.getErrorClass === "INVALID_FORMAT.MISMATCH_INPUT")
+      checkError(
+        exception = intercept[SparkIllegalArgumentException] {
+          val testQuery = sql(query)
+          testQuery.collect()
+        },
+        errorClass = "INVALID_FORMAT.MISMATCH_INPUT",
+        parameters = Map("inputType" -> "\"STRING\"", "input" -> "xx", "format" -> "999")
+      )
     }
   }
 
@@ -996,11 +999,13 @@ class CollationSQLExpressionsSuite
       withSQLConf(SqlApiConf.DEFAULT_COLLATION -> t.collationName) {
         val query = s"SELECT raise_error('${t.errorMessage}')"
         // Result & data type
-        val userException = intercept[SparkRuntimeException] {
-          sql(query).collect()
-        }
-        assert(userException.getErrorClass === "USER_RAISED_EXCEPTION")
-        assert(userException.getMessage.contains(t.errorMessage))
+        checkError(
+          exception = intercept[SparkRuntimeException] {
+            sql(query).collect()
+          },
+          errorClass = "USER_RAISED_EXCEPTION",
+          parameters = Map("errorMessage" -> t.errorMessage)
+        )
       }
     })
   }
@@ -1172,10 +1177,13 @@ class CollationSQLExpressionsSuite
       }
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT mask(collate('ab-CD-12-@$','UNICODE'),collate('X','UNICODE_CI'),'x','0','#')")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT mask(collate('ab-CD-12-@$','UNICODE'),collate('X','UNICODE_CI'),'x','0','#')")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map("explicitTypes" -> "`string collate UNICODE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support XmlToStructs xml expression with collation") {
@@ -1360,11 +1368,14 @@ class CollationSQLExpressionsSuite
     val json = "{\"a\":1,"
     val query = s"SELECT parse_json('$json');"
     withSQLConf(SqlApiConf.DEFAULT_COLLATION -> "UNICODE") {
-      val e = intercept[SparkException] {
-        val testQuery = sql(query)
-        testQuery.collect()
-      }
-      assert(e.getErrorClass === "MALFORMED_RECORD_IN_PARSING.WITHOUT_SUGGESTION")
+      checkError(
+        exception = intercept[SparkException] {
+          val testQuery = sql(query)
+          testQuery.collect()
+        },
+        errorClass = "MALFORMED_RECORD_IN_PARSING.WITHOUT_SUGGESTION",
+        parameters = Map("badRecord" -> "{\"a\":1,", "failFastMode" -> "FAILFAST")
+      )
     }
   }
 
@@ -1461,11 +1472,14 @@ class CollationSQLExpressionsSuite
     val json = "[1, \"Spark\"]"
     val query = s"SELECT variant_get(parse_json('$json'), '$$[1]', 'int');"
     withSQLConf(SqlApiConf.DEFAULT_COLLATION -> "UNICODE") {
-      val e = intercept[SparkRuntimeException] {
-        val testQuery = sql(query)
-        testQuery.collect()
-      }
-      assert(e.getErrorClass === "INVALID_VARIANT_CAST")
+      checkError(
+        exception = intercept[SparkRuntimeException] {
+          val testQuery = sql(query)
+          testQuery.collect()
+        },
+        errorClass = "INVALID_VARIANT_CAST",
+        parameters = Map("value" -> "\"Spark\"", "dataType" -> "\"INT\"")
+      )
     }
   }
 
@@ -2289,10 +2303,20 @@ class CollationSQLExpressionsSuite
       s"""
          |SELECT REFLECT('java.lang.Integer', 'toHexString',"2");
          |""".stripMargin
-    val typeException = intercept[ExtendedAnalysisException] {
-      sql(queryFail).collect()
-    }
-    assert(typeException.getErrorClass === "DATATYPE_MISMATCH.UNEXPECTED_STATIC_METHOD")
+    checkError(
+      exception = intercept[ExtendedAnalysisException] {
+        sql(queryFail).collect()
+      },
+      errorClass = "DATATYPE_MISMATCH.UNEXPECTED_STATIC_METHOD",
+      parameters = Map(
+        "methodName" -> "toHexString",
+        "className" -> "java.lang.Integer",
+        "sqlExpr" -> "\"reflect(java.lang.Integer, toHexString, 2)\""),
+      context = ExpectedContext(
+        fragment = """REFLECT('java.lang.Integer', 'toHexString',"2")""",
+        start = 8,
+        stop = 54)
+    )
   }
 
   // TODO: Add more tests for other SQL expressions
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLRegexpSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLRegexpSuite.scala
index 8ff7bed60bb..40cc6f19550 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLRegexpSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/CollationSQLRegexpSuite.scala
@@ -430,7 +430,7 @@ class CollationSQLRegexpSuite
         sql(s"SELECT regexp_replace(collate('ABCDE','$c1'), '.c.', collate('FFF','$c2'))")
       },
       errorClass = "COLLATION_MISMATCH.EXPLICIT",
-      parameters = Map("explicitTypes" -> "`string`.`string collate UTF8_LCASE`")
+      parameters = Map("explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
     )
     // Unsupported collations
     case class RegExpReplaceTestFail(l: String, r: String, c: String)
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/CollationStringExpressionsSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/CollationStringExpressionsSuite.scala
index 815a8bc5952..296a6a7f56c 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/CollationStringExpressionsSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/CollationStringExpressionsSuite.scala
@@ -17,8 +17,6 @@
 
 package org.apache.spark.sql
 
-import scala.jdk.CollectionConverters.MapHasAsScala
-
 import org.apache.spark.{SparkConf, SparkIllegalArgumentException}
 import org.apache.spark.sql.catalyst.expressions.{ExpressionEvalHelper, Literal, StringTrim, StringTrimLeft, StringTrimRight}
 import org.apache.spark.sql.catalyst.util.CollationFactory
@@ -57,10 +55,13 @@ class CollationStringExpressionsSuite
       assert(sql(query).schema.fields.head.dataType.sameType(StringType(t.c)))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT concat_ws(' ',collate('Spark', 'UTF8_LCASE'),collate('SQL', 'UNICODE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT concat_ws(' ', collate('Spark', 'UTF8_LCASE'), collate('SQL', 'UNICODE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map("explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE`")
+    )
   }
 
   test("Support Elt string expression with collation") {
@@ -87,10 +88,13 @@ class CollationStringExpressionsSuite
       assert(sql(query).schema.fields.head.dataType.sameType(StringType(t.c)))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT elt(0 ,collate('Spark', 'UTF8_LCASE'), collate('SQL', 'UNICODE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT elt(0, collate('Spark', 'UTF8_LCASE'), collate('SQL', 'UNICODE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map("explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE`")
+    )
   }
 
   test("Support SplitPart string expression with collation") {
@@ -129,10 +133,14 @@ class CollationStringExpressionsSuite
       checkAnswer(sql(s"SELECT contains('${t.l}',collate('${t.r}','${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT contains(collate('abcde','UTF8_LCASE'),collate('C','UNICODE_CI'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT contains(collate('abcde', 'UTF8_LCASE'), collate('C', 'UNICODE_CI'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support SubstringIndex expression with collation") {
@@ -159,11 +167,14 @@ class CollationStringExpressionsSuite
         s"${t.count})"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT substring_index(collate('abcde','UTF8_LCASE')," +
-        "collate('C','UNICODE_CI'),1)")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT substring_index(collate('abcde', 'UTF8_LCASE'), collate('C', 'UNICODE_CI'),1)")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support StringInStr string expression with collation") {
@@ -191,10 +202,14 @@ class CollationStringExpressionsSuite
         s"collate('${t.substring}','${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql(s"SELECT instr(collate('aaads','UTF8_BINARY'), collate('Aa','UTF8_LCASE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql(s"SELECT instr(collate('aaads', 'UTF8_BINARY'), collate('Aa', 'UTF8_LCASE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
+    )
   }
 
   test("Support FindInSet string expression with collation") {
@@ -221,11 +236,15 @@ class CollationStringExpressionsSuite
         s"collate('${t.set}', '${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql(s"SELECT find_in_set(collate('AB','UTF8_BINARY')," +
-        s"collate('ab,xyz,fgh','UTF8_LCASE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql(s"SELECT find_in_set(collate('AB', 'UTF8_BINARY'), " +
+          s"collate('ab,xyz,fgh', 'UTF8_LCASE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
+    )
   }
 
   test("Support StartsWith string expression with collation") {
@@ -247,10 +266,14 @@ class CollationStringExpressionsSuite
       checkAnswer(sql(s"SELECT startswith('${t.l}', collate('${t.r}', '${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT startswith(collate('abcde', 'UTF8_LCASE'),collate('C', 'UNICODE_CI'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT startswith(collate('abcde', 'UTF8_LCASE'), collate('C', 'UNICODE_CI'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support StringTranslate string expression with collation") {
@@ -281,11 +304,15 @@ class CollationStringExpressionsSuite
         s"collate('${t.replaceExpression}', '${t.collation}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql(s"SELECT translate(collate('Translate', 'UTF8_LCASE')," +
-        s"collate('Rnlt', 'UNICODE'), '1234')")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql(s"SELECT translate(collate('Translate', 'UTF8_LCASE'), " +
+          s"collate('Rnlt', 'UNICODE'), '1234')")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE`")
+    )
   }
 
   test("Support Replace string expression with collation") {
@@ -317,10 +344,14 @@ class CollationStringExpressionsSuite
         s"collate('${t.replace}','${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT startswith(collate('abcde', 'UTF8_LCASE'),collate('C', 'UNICODE_CI'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT startswith(collate('abcde', 'UTF8_LCASE'), collate('C', 'UNICODE_CI'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support EndsWith string expression with collation") {
@@ -342,10 +373,14 @@ class CollationStringExpressionsSuite
       checkAnswer(sql(s"SELECT endswith('${t.l}', collate('${t.r}', '${t.c}'))"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT endswith(collate('abcde', 'UTF8_LCASE'),collate('C', 'UNICODE_CI'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT endswith(collate('abcde', 'UTF8_LCASE'), collate('C', 'UNICODE_CI'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UTF8_LCASE`, `string collate UNICODE_CI`")
+    )
   }
 
   test("Support StringRepeat string expression with collation") {
@@ -525,10 +560,13 @@ class CollationStringExpressionsSuite
            |""".stripMargin), Row(t.result))
     })
     // Collation mismatch
-    assert(
-      intercept[AnalysisException] {
+    checkError(
+      exception = intercept[AnalysisException] {
         sql("SELECT overlay('a' collate UNICODE PLACING 'b' collate UNICODE_CI FROM 1)")
-      }.getErrorClass == "COLLATION_MISMATCH.EXPLICIT"
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UNICODE`, `string collate UNICODE_CI`")
     )
   }
 
@@ -683,11 +721,13 @@ class CollationStringExpressionsSuite
         val query = s"SELECT validate_utf8(${testCase.input})"
         if (testCase.result == None) {
           // Exception thrown
-          val e = intercept[SparkIllegalArgumentException] {
-            sql(query).collect()
-          }
-          assert(e.getErrorClass == "INVALID_UTF8_STRING")
-          assert(e.getMessageParameters.asScala == Map("str" -> "\\xFF"))
+          checkError(
+            exception = intercept[SparkIllegalArgumentException] {
+              sql(query).collect()
+            },
+            errorClass = "INVALID_UTF8_STRING",
+            parameters = Map("str" -> "\\xFF")
+          )
         } else {
           // Result & data type
           checkAnswer(sql(query), Row(testCase.result))
@@ -794,10 +834,14 @@ class CollationStringExpressionsSuite
         Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT rpad(collate('abcde', 'UNICODE_CI'),1,collate('C', 'UTF8_LCASE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT rpad(collate('abcde', 'UNICODE_CI'), 1, collate('C', 'UTF8_LCASE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UNICODE_CI`, `string collate UTF8_LCASE`")
+    )
   }
 
   test("Support StringLPad string expressions with collation") {
@@ -828,10 +872,14 @@ class CollationStringExpressionsSuite
         Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT lpad(collate('abcde', 'UNICODE_CI'),1,collate('C', 'UTF8_LCASE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT lpad(collate('abcde', 'UNICODE_CI'), 1, collate('C', 'UTF8_LCASE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string collate UNICODE_CI`, `string collate UTF8_LCASE`")
+    )
   }
 
   test("Support StringLPad string expressions with explicit collation on second parameter") {
@@ -868,10 +916,14 @@ class CollationStringExpressionsSuite
         s"'${t.c}'),${t.start})"), Row(t.result))
     })
     // Collation mismatch
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT locate(collate('aBc', 'UTF8_BINARY'),collate('abcabc', 'UTF8_LCASE'),4)")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT locate(collate('aBc', 'UTF8_BINARY'), collate('abcabc', 'UTF8_LCASE'), 4)")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
+    )
   }
 
   test("StringTrim* functions - unit tests for both paths (codegen and eval)") {
@@ -1037,17 +1089,23 @@ class CollationStringExpressionsSuite
 
   test("StringTrim* functions - collation type mismatch") {
     List("TRIM", "LTRIM", "RTRIM").foreach(func => {
-      val collationMismatch = intercept[AnalysisException] {
-        sql("SELECT " + func + "(COLLATE('x', 'UTF8_LCASE'), "
-          + "COLLATE('xxaaaxx', 'UTF8_BINARY'))")
-      }
-      assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+      checkError(
+        exception = intercept[AnalysisException] {
+          sql("SELECT " + func + "(COLLATE('x', 'UTF8_LCASE'), COLLATE('xxaaaxx', 'UTF8_BINARY'))")
+        },
+        errorClass = "COLLATION_MISMATCH.EXPLICIT",
+        parameters = Map(
+          "explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
+      )
     })
-
-    val collationMismatch = intercept[AnalysisException] {
-      sql("SELECT BTRIM(COLLATE('xxaaaxx', 'UTF8_BINARY'), COLLATE('x', 'UTF8_LCASE'))")
-    }
-    assert(collationMismatch.getErrorClass === "COLLATION_MISMATCH.EXPLICIT")
+    checkError(
+      exception = intercept[AnalysisException] {
+        sql("SELECT BTRIM(COLLATE('xxaaaxx', 'UTF8_BINARY'), COLLATE('x', 'UTF8_LCASE'))")
+      },
+      errorClass = "COLLATION_MISMATCH.EXPLICIT",
+      parameters = Map(
+        "explicitTypes" -> "`string`, `string collate UTF8_LCASE`")
+    )
   }
 
   // TODO: Add more tests for other string expressions
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/CollationSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/CollationSuite.scala
index af3169932bf..e9e3432195a 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/CollationSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/CollationSuite.scala
@@ -250,7 +250,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
       sqlState = "42P21",
       parameters = Map(
         "explicitTypes" ->
-          s"`string collate $leftCollationName`.`string collate $rightCollationName`"
+          s"`string collate $leftCollationName`, `string collate $rightCollationName`"
       )
     )
     // startsWith
@@ -264,7 +264,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
       sqlState = "42P21",
       parameters = Map(
         "explicitTypes" ->
-          s"`string collate $leftCollationName`.`string collate $rightCollationName`"
+          s"`string collate $leftCollationName`, `string collate $rightCollationName`"
       )
     )
     // endsWith
@@ -278,7 +278,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
       sqlState = "42P21",
       parameters = Map(
         "explicitTypes" ->
-          s"`string collate $leftCollationName`.`string collate $rightCollationName`"
+          s"`string collate $leftCollationName`, `string collate $rightCollationName`"
       )
     )
   }
@@ -506,7 +506,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
         },
         errorClass = "COLLATION_MISMATCH.EXPLICIT",
         parameters = Map(
-          "explicitTypes" -> "`string`.`string collate UNICODE`"
+          "explicitTypes" -> "`string`, `string collate UNICODE`"
         )
       )
 
@@ -518,7 +518,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
         },
         errorClass = "COLLATION_MISMATCH.EXPLICIT",
         parameters = Map(
-          "explicitTypes" -> "`string`.`string collate UNICODE`"
+          "explicitTypes" -> "`string`, `string collate UNICODE`"
         )
       )
       checkError(
@@ -528,7 +528,7 @@ class CollationSuite extends DatasourceV2SQLBase with AdaptiveSparkPlanHelper {
         },
         errorClass = "COLLATION_MISMATCH.EXPLICIT",
         parameters = Map(
-          "explicitTypes" -> "`string collate UNICODE`.`string`"
+          "explicitTypes" -> "`string collate UNICODE`, `string`"
         )
       )
 
