diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/dsl/package.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/dsl/package.scala
index bc0891410a6..ac439203cb7 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/dsl/package.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/dsl/package.scala
@@ -190,7 +190,7 @@ package object dsl {
       // Note that if we make ExpressionConversions an object rather than a trait, we can
       // then make this a value class to avoid the small penalty of runtime instantiation.
       def $(args: Any*): analysis.UnresolvedAttribute = {
-        analysis.UnresolvedAttribute(Seq(sc.s(args : _*)))
+        analysis.UnresolvedAttribute(sc.s(args : _*))
       }
     }
 
@@ -269,19 +269,16 @@ package object dsl {
     // TODO more implicit class for literal?
     implicit class DslString(val s: String) extends ImplicitOperators {
       override def expr: Expression = Literal(s)
-      def attr: UnresolvedAttribute = analysis.UnresolvedAttribute(Seq(s))
+      def attr: UnresolvedAttribute = analysis.UnresolvedAttribute(s)
     }
-    implicit class DslAttr(override val attr: UnresolvedAttribute) extends ImplicitAttribute {
-      def s: String = {
-        assert(attr.nameParts.length == 1, "attribute must have single name part")
-        attr.nameParts.head
-      }
+    implicit class DslAttr(attr: UnresolvedAttribute) extends ImplicitAttribute {
+      def s: String = attr.name
     }
 
     abstract class ImplicitAttribute extends ImplicitOperators {
       def s: String
       def expr: UnresolvedAttribute = attr
-      def attr: UnresolvedAttribute = analysis.UnresolvedAttribute(Seq(s))
+      def attr: UnresolvedAttribute = analysis.UnresolvedAttribute(s)
 
       /** Creates a new AttributeReference of type boolean */
       def boolean: AttributeReference = AttributeReference(s, BooleanType, nullable = true)()
