diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/ComplexTypes.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/ComplexTypes.scala
index 1c33a2c7c31..2aba4bae397 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/ComplexTypes.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/ComplexTypes.scala
@@ -47,7 +47,8 @@ object SimplifyExtractValueOps extends Rule[LogicalPlan] {
           // For example, if a user submits a query like this:
           // `$"struct_col".withField("b", lit(1)).withField("b", lit(2)).getField("b")`
           // we want to return `lit(2)` (and not `lit(1)`).
-          matches.last._2
+          val expr = matches.last._2
+          If(IsNull(struct), Literal(null, expr.dataType), expr)
         } else {
           GetStructField(struct, ordinal, maybeName)
         }
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/complexTypesSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/complexTypesSuite.scala
index c71e7dbe7d6..00aed6a10cd 100644
--- a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/complexTypesSuite.scala
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/complexTypesSuite.scala
@@ -453,46 +453,77 @@ class ComplexTypesSuite extends PlanTest with ExpressionEvalHelper {
     checkEvaluation(GetMapValue(mb0, Literal(Array[Byte](3, 4))), null)
   }
 
-  private val structAttr = 'struct1.struct('a.int)
+  private val structAttr = 'struct1.struct('a.int).withNullability(false)
   private val testStructRelation = LocalRelation(structAttr)
 
+  private val nullableStructAttr = 'struct1.struct('a.int)
+  private val testNullableStructRelation = LocalRelation(nullableStructAttr)
+
   test("simplify GetStructField on WithFields that is not changing the attribute being extracted") {
-    val query = testStructRelation.select(
-      GetStructField(WithFields('struct1, Seq("b"), Seq(Literal(1))), 0, Some("a")) as "outerAtt")
-    val expected = testStructRelation.select(GetStructField('struct1, 0, Some("a")) as "outerAtt")
-    checkRule(query, expected)
+    def query(relation: LocalRelation): LogicalPlan = relation.select(
+      GetStructField(WithFields('struct1, Seq("b"), Seq(Literal(1))), 0, Some("a")) as "outerAttr")
+
+    checkRule(
+      query(testStructRelation),
+      testStructRelation.select(GetStructField('struct1, 0, Some("a")) as "outerAttr"))
+
+    checkRule(
+      query(testNullableStructRelation),
+      testNullableStructRelation.select(GetStructField('struct1, 0, Some("a")) as "outerAttr"))
   }
 
   test("simplify GetStructField on WithFields that is changing the attribute being extracted") {
-    val query = testStructRelation.select(
-      GetStructField(WithFields('struct1, Seq("b"), Seq(Literal(1))), 1, Some("b")) as "outerAtt")
-    val expected = testStructRelation.select(Literal(1) as "outerAtt")
-    checkRule(query, expected)
+    def query(relation: LocalRelation): LogicalPlan = relation.select(
+      GetStructField(WithFields('struct1, Seq("b"), Seq(Literal(1))), 1, Some("b")) as "res")
+
+    checkRule(
+      query(testStructRelation),
+      testStructRelation.select(Literal(1) as "res"))
+
+    checkRule(
+      query(testNullableStructRelation),
+      testNullableStructRelation.select(
+        If(IsNull('struct1), Literal(null, IntegerType), Literal(1)) as "res"))
   }
 
   test(
     "simplify GetStructField on WithFields that is changing the attribute being extracted twice") {
-    val query = testStructRelation
-      .select(GetStructField(WithFields('struct1, Seq("b", "b"), Seq(Literal(1), Literal(2))), 1,
-        Some("b")) as "outerAtt")
-    val expected = testStructRelation.select(Literal(2) as "outerAtt")
-    checkRule(query, expected)
+    def query(relation: LocalRelation): LogicalPlan = relation.select(
+      GetStructField(WithFields('struct1, Seq("b", "b"), Seq(Literal(1), Literal(2))), 1, Some("b"))
+        as "outerAtt")
+
+    checkRule(
+      query(testStructRelation),
+      testStructRelation.select(Literal(2) as "outerAtt"))
+
+    checkRule(
+      query(testNullableStructRelation),
+      testNullableStructRelation.select(
+        If(IsNull('struct1), Literal(null, IntegerType), Literal(2)) as "outerAtt"))
   }
 
   test("collapse multiple GetStructField on the same WithFields") {
-    val query = testStructRelation
+    def query(relation: LocalRelation): LogicalPlan = relation
       .select(WithFields('struct1, Seq("b"), Seq(Literal(2))) as "struct2")
       .select(
         GetStructField('struct2, 0, Some("a")) as "struct1A",
         GetStructField('struct2, 1, Some("b")) as "struct1B")
-    val expected = testStructRelation.select(
-      GetStructField('struct1, 0, Some("a")) as "struct1A",
-      Literal(2) as "struct1B")
-    checkRule(query, expected)
+
+    checkRule(
+      query(testStructRelation),
+      testStructRelation.select(
+        GetStructField('struct1, 0, Some("a")) as "struct1A",
+        Literal(2) as "struct1B"))
+
+    checkRule(
+      query(testNullableStructRelation),
+      testNullableStructRelation.select(
+        GetStructField('struct1, 0, Some("a")) as "struct1A",
+        If(IsNull('struct1), Literal(null, IntegerType), Literal(2)) as "struct1B"))
   }
 
   test("collapse multiple GetStructField on different WithFields") {
-    val query = testStructRelation
+    def query(relation: LocalRelation): LogicalPlan = relation
       .select(
         WithFields('struct1, Seq("b"), Seq(Literal(2))) as "struct2",
         WithFields('struct1, Seq("b"), Seq(Literal(3))) as "struct3")
@@ -501,12 +532,23 @@ class ComplexTypesSuite extends PlanTest with ExpressionEvalHelper {
         GetStructField('struct2, 1, Some("b")) as "struct2B",
         GetStructField('struct3, 0, Some("a")) as "struct3A",
         GetStructField('struct3, 1, Some("b")) as "struct3B")
-    val expected = testStructRelation
-      .select(
-        GetStructField('struct1, 0, Some("a")) as "struct2A",
-        Literal(2) as "struct2B",
-        GetStructField('struct1, 0, Some("a")) as "struct3A",
-        Literal(3) as "struct3B")
-    checkRule(query, expected)
+
+    checkRule(
+      query(testStructRelation),
+      testStructRelation
+        .select(
+          GetStructField('struct1, 0, Some("a")) as "struct2A",
+          Literal(2) as "struct2B",
+          GetStructField('struct1, 0, Some("a")) as "struct3A",
+          Literal(3) as "struct3B"))
+
+    checkRule(
+      query(testNullableStructRelation),
+      testNullableStructRelation
+        .select(
+          GetStructField('struct1, 0, Some("a")) as "struct2A",
+          If(IsNull('struct1), Literal(null, IntegerType), Literal(2)) as "struct2B",
+          GetStructField('struct1, 0, Some("a")) as "struct3A",
+          If(IsNull('struct1), Literal(null, IntegerType), Literal(3)) as "struct3B"))
   }
 }
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/ColumnExpressionSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/ColumnExpressionSuite.scala
index 36c10874cc1..24419968c04 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/ColumnExpressionSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/ColumnExpressionSuite.scala
@@ -1452,4 +1452,89 @@ class ColumnExpressionSuite extends QueryTest with SharedSparkSession {
         .select($"struct_col".withField("a.c", lit(3)))
     }.getMessage should include("Ambiguous reference to fields")
   }
+
+  test("SPARK-32641: extracting field from non-null struct column after withField should return " +
+    "field value") {
+    // extract newly added field
+    checkAnswerAndSchema(
+      structLevel1.withColumn("a", $"a".withField("d", lit(4)).getField("d")),
+      Row(4) :: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = false))))
+
+    // extract newly replaced field
+    checkAnswerAndSchema(
+      structLevel1.withColumn("a", $"a".withField("a", lit(4)).getField("a")),
+      Row(4) :: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = false))))
+
+    // add new field, extract another field from original struct
+    checkAnswerAndSchema(
+      structLevel1.withColumn("a", $"a".withField("d", lit(4)).getField("c")),
+      Row(3):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = false))))
+
+    // replace field, extract another field from original struct
+    checkAnswerAndSchema(
+      structLevel1.withColumn("a", $"a".withField("a", lit(4)).getField("c")),
+      Row(3):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = false))))
+  }
+
+  test("SPARK-32641: extracting field from null struct column after withField should return " +
+    "null if the original struct was null") {
+    // extract newly added field
+    checkAnswerAndSchema(
+      nullStructLevel1.withColumn("a", $"a".withField("d", lit(4)).getField("d")),
+      Row(null) :: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // extract newly replaced field
+    checkAnswerAndSchema(
+      nullStructLevel1.withColumn("a", $"a".withField("a", lit(4)).getField("a")),
+      Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // add new field, extract another field from original struct
+    checkAnswerAndSchema(
+      nullStructLevel1.withColumn("a", $"a".withField("d", lit(4)).getField("c")),
+      Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // replace field, extract another field from original struct
+    checkAnswerAndSchema(
+      nullStructLevel1.withColumn("a", $"a".withField("a", lit(4)).getField("c")),
+      Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+  }
+
+  test("SPARK-32641: extracting field from nullable struct column which contains both null and " +
+    "non-null values after withField should return null if the original struct was null") {
+    val df = spark.createDataFrame(
+      sparkContext.parallelize(Row(Row(1, null, 3)) :: Row(null) :: Nil),
+      StructType(Seq(StructField("a", structType, nullable = true))))
+
+    // extract newly added field
+    checkAnswerAndSchema(
+      df.withColumn("a", $"a".withField("d", lit(4)).getField("d")),
+      Row(4) :: Row(null) :: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // extract newly replaced field
+    checkAnswerAndSchema(
+      df.withColumn("a", $"a".withField("a", lit(4)).getField("a")),
+      Row(4) :: Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // add new field, extract another field from original struct
+    checkAnswerAndSchema(
+      df.withColumn("a", $"a".withField("d", lit(4)).getField("c")),
+      Row(3) :: Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+
+    // replace field, extract another field from original struct
+    checkAnswerAndSchema(
+      df.withColumn("a", $"a".withField("a", lit(4)).getField("c")),
+      Row(3) :: Row(null):: Nil,
+      StructType(Seq(StructField("a", IntegerType, nullable = true))))
+  }
 }
