diff --git a/sql/hive-thriftserver/src/test/scala/org/apache/spark/sql/hive/thriftserver/HiveThriftServer2Suites.scala b/sql/hive-thriftserver/src/test/scala/org/apache/spark/sql/hive/thriftserver/HiveThriftServer2Suites.scala
index 21256ad02c1..4e6d4e10402 100644
--- a/sql/hive-thriftserver/src/test/scala/org/apache/spark/sql/hive/thriftserver/HiveThriftServer2Suites.scala
+++ b/sql/hive-thriftserver/src/test/scala/org/apache/spark/sql/hive/thriftserver/HiveThriftServer2Suites.scala
@@ -813,31 +813,27 @@ class HiveThriftBinaryServerSuite extends HiveThriftJdbcTest {
   }
 
   test("SPARK-31859 Thriftserver works with spark.sql.datetime.java8API.enabled=true") {
-    withJdbcStatement() { statement =>
-      withJdbcStatement() { st =>
-        st.execute("set spark.sql.datetime.java8API.enabled=true")
-        val rs = st.executeQuery("select date '2020-05-28', timestamp '2020-05-28 00:00:00'")
-        rs.next()
-        assert(rs.getDate(1).toString() == "2020-05-28")
-        assert(rs.getTimestamp(2).toString() == "2020-05-28 00:00:00.0")
-      }
+    withJdbcStatement() { st =>
+      st.execute("set spark.sql.datetime.java8API.enabled=true")
+      val rs = st.executeQuery("select date '2020-05-28', timestamp '2020-05-28 00:00:00'")
+      rs.next()
+      assert(rs.getDate(1).toString() == "2020-05-28")
+      assert(rs.getTimestamp(2).toString() == "2020-05-28 00:00:00.0")
     }
   }
 
   test("SPARK-31861 Thriftserver respects spark.sql.session.timeZone") {
-    withJdbcStatement() { statement =>
-      withJdbcStatement() { st =>
-        st.execute("set spark.sql.session.timeZone=+03:15") // different than Thriftserver's JVM tz
+    withJdbcStatement() { st =>
+      st.execute("set spark.sql.session.timeZone=+03:15") // different than Thriftserver's JVM tz
       val rs = st.executeQuery("select timestamp '2020-05-28 10:00:00'")
-        rs.next()
-        // The timestamp as string is the same as the literal
-        assert(rs.getString(1) == "2020-05-28 10:00:00.0")
-        // Parsing it to java.sql.Timestamp in the client will always result in a timestamp
-        // in client default JVM timezone. The string value of the Timestamp will match the literal,
-        // but if the JDBC application cares about the internal timezone and UTC offset of the
-        // Timestamp object, it should set spark.sql.session.timeZone to match its client JVM tz.
-        assert(rs.getTimestamp(1).toString() == "2020-05-28 10:00:00.0")
-      }
+      rs.next()
+      // The timestamp as string is the same as the literal
+      assert(rs.getString(1) == "2020-05-28 10:00:00.0")
+      // Parsing it to java.sql.Timestamp in the client will always result in a timestamp
+      // in client default JVM timezone. The string value of the Timestamp will match the literal,
+      // but if the JDBC application cares about the internal timezone and UTC offset of the
+      // Timestamp object, it should set spark.sql.session.timeZone to match its client JVM tz.
+      assert(rs.getTimestamp(1).toString() == "2020-05-28 10:00:00.0")
     }
   }
 
