diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/subquery.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/subquery.scala
index 80458cba846..91cd838ad61 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/subquery.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/subquery.scala
@@ -393,7 +393,9 @@ object RewriteCorrelatedScalarSubquery extends Rule[LogicalPlan] with AliasHelpe
     val newExpression = expression.transformWithPruning(_.containsPattern(SCALAR_SUBQUERY)) {
       case s: ScalarSubquery if s.children.nonEmpty =>
         subqueries += s
-        s.plan.output.head
+        // Results of scalar subqueries are nullable (as they get connected to the rest of the
+        // query via left outer join)
+        s.plan.output.head.withNullability(true)
     }
     newExpression.asInstanceOf[E]
   }
diff --git a/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
index 789c864dea8..311f3803902 100644
--- a/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
+++ b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
@@ -1241,3 +1241,20 @@ Filter (cast(t0a#x as bigint) < scalar-subquery#x [t0a#x && t0b#x])
       +- View (`t0`, [t0a#x,t0b#x])
          +- Project [cast(col1#x as int) AS t0a#x, cast(col2#x as int) AS t0b#x]
             +- LocalRelation [col1#x, col2#x]
+
+
+-- !query
+select *
+from range(1, 3) t1
+where (select t2.id c
+       from range (1, 2) t2 where t1.id = t2.id
+      ) is not null
+-- !query analysis
+Project [id#xL]
++- Filter isnotnull(scalar-subquery#x [id#xL])
+   :  +- Project [id#xL AS c#xL]
+   :     +- Filter (outer(id#xL) = id#xL)
+   :        +- SubqueryAlias t2
+   :           +- Range (1, 2, step=1, splits=None)
+   +- SubqueryAlias t1
+      +- Range (1, 3, step=1, splits=None)
diff --git a/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-select.sql.out b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-select.sql.out
index 3679b98e2a4..cb41f7cdc45 100644
--- a/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-select.sql.out
+++ b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/scalar-subquery/scalar-subquery-select.sql.out
@@ -1037,3 +1037,23 @@ WithCTE
 set spark.sql.optimizer.optimizeOneRowRelationSubquery.alwaysInline=true
 -- !query analysis
 SetCommand (spark.sql.optimizer.optimizeOneRowRelationSubquery.alwaysInline,Some(true))
+
+
+-- !query
+select * from (
+ select t1.id c1, (
+  select t2.id c from range (1, 2) t2
+  where t1.id = t2.id  ) c2
+ from range (1, 3) t1 ) t
+where t.c2 is not null
+-- !query analysis
+Project [c1#xL, c2#xL]
++- Filter isnotnull(c2#xL)
+   +- SubqueryAlias t
+      +- Project [id#xL AS c1#xL, scalar-subquery#x [id#xL] AS c2#xL]
+         :  +- Project [id#xL AS c#xL]
+         :     +- Filter (outer(id#xL) = id#xL)
+         :        +- SubqueryAlias t2
+         :           +- Range (1, 2, step=1, splits=None)
+         +- SubqueryAlias t1
+            +- Range (1, 3, step=1, splits=None)
diff --git a/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-predicate.sql b/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-predicate.sql
index c8fe4bea642..e015d577549 100644
--- a/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-predicate.sql
+++ b/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-predicate.sql
@@ -398,3 +398,10 @@ HAVING t0a <
   FROM   t2
   WHERE  t2b <= t0b)
 );
+
+-- SPARK-43760: the result of the subquery can be NULL.
+select *
+from range(1, 3) t1
+where (select t2.id c
+       from range (1, 2) t2 where t1.id = t2.id
+      ) is not null;
diff --git a/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-select.sql b/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-select.sql
index e487b3d1800..741292d2c0f 100644
--- a/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-select.sql
+++ b/sql/core/src/test/resources/sql-tests/inputs/subquery/scalar-subquery/scalar-subquery-select.sql
@@ -247,3 +247,11 @@ WITH T AS (SELECT 1 AS a)
 SELECT (SELECT sum(1) FROM T WHERE a = col OR upper(col)= 'Y')
 FROM (SELECT null as col) as foo;
 set spark.sql.optimizer.optimizeOneRowRelationSubquery.alwaysInline=true;
+
+-- SPARK-43760: the result of the subquery can be NULL.
+select * from (
+ select t1.id c1, (
+  select t2.id c from range (1, 2) t2
+  where t1.id = t2.id  ) c2
+ from range (1, 3) t1 ) t
+where t.c2 is not null;
diff --git a/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out b/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
index d5dc0f83ef4..02f3f9eae79 100644
--- a/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
+++ b/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-predicate.sql.out
@@ -648,3 +648,15 @@ HAVING t0a <
 struct<t0a:int,t0b:int>
 -- !query output
 1	1
+
+
+-- !query
+select *
+from range(1, 3) t1
+where (select t2.id c
+       from range (1, 2) t2 where t1.id = t2.id
+      ) is not null
+-- !query schema
+struct<id:bigint>
+-- !query output
+1
diff --git a/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-select.sql.out b/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-select.sql.out
index e94ceea5f87..de7fa974762 100644
--- a/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-select.sql.out
+++ b/sql/core/src/test/resources/sql-tests/results/subquery/scalar-subquery/scalar-subquery-select.sql.out
@@ -585,3 +585,16 @@ set spark.sql.optimizer.optimizeOneRowRelationSubquery.alwaysInline=true
 struct<key:string,value:string>
 -- !query output
 spark.sql.optimizer.optimizeOneRowRelationSubquery.alwaysInline	true
+
+
+-- !query
+select * from (
+ select t1.id c1, (
+  select t2.id c from range (1, 2) t2
+  where t1.id = t2.id  ) c2
+ from range (1, 3) t1 ) t
+where t.c2 is not null
+-- !query schema
+struct<c1:bigint,c2:bigint>
+-- !query output
+1	1
