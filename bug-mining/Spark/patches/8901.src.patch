diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/namedExpressions.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/namedExpressions.scala
index d18cfea1629..52d96f92fdf 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/namedExpressions.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/namedExpressions.scala
@@ -578,6 +578,16 @@ object FileSourceGeneratedMetadataAttribute {
 
   val FILE_SOURCE_GENERATED_METADATA_COL_ATTR_KEY = "__file_source_generated_metadata_col"
 
+  /**
+   * We keep generated metadata attributes nullability configurable here:
+   * 1. Before passing to readers, we create generated metadata attributes as nullable;
+   *    Because, for row_index, the readers do not consider the column required.
+   *    row_index can be generated with null in the process by readers.
+   * 2. When applying the projection, we change the nullability back to not-nullable;
+   *    For row_index, it is generated with nulls which are then replaced,
+   *    so it will not be null in the returned output.
+   *    See `FileSourceStrategy` for more information
+   */
   def apply(name: String, dataType: DataType, nullable: Boolean = false): AttributeReference =
     AttributeReference(name, dataType, nullable = nullable,
       new MetadataBuilder()
diff --git a/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/FileSourceStrategy.scala b/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/FileSourceStrategy.scala
index f48e44d1aab..5838f9e5478 100644
--- a/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/FileSourceStrategy.scala
+++ b/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/FileSourceStrategy.scala
@@ -230,6 +230,14 @@ object FileSourceStrategy extends Strategy with PredicateHelper with Logging {
         case MetadataStructColumn(attr) => attr
       }
 
+      // We divide metadata columns into two categories: constant and generated.
+      // For constant metadata columns, we create these attributes as non-nullable
+      //  when passing to readers, since the values are always available.
+      // For generated metadata columns, they are set as nullable when passed to readers,
+      //  as the values will be null when trying to read the missing column from the file.
+      //  They are then replaced by the actual values later in the process.
+      // All metadata columns will be non-null in the returned output.
+      // We then change the nullability to non-nullable in the metadata projection node below.
       val constantMetadataColumns: mutable.Buffer[Attribute] = mutable.Buffer.empty
       val generatedMetadataColumns: mutable.Buffer[Attribute] = mutable.Buffer.empty
 
