diff --git a/connector/connect/client/jvm/src/main/scala/org/apache/spark/sql/connect/client/ExecutePlanResponseReattachableIterator.scala b/connector/connect/client/jvm/src/main/scala/org/apache/spark/sql/connect/client/ExecutePlanResponseReattachableIterator.scala
index d412d9b5770..7a50801d8a6 100644
--- a/connector/connect/client/jvm/src/main/scala/org/apache/spark/sql/connect/client/ExecutePlanResponseReattachableIterator.scala
+++ b/connector/connect/client/jvm/src/main/scala/org/apache/spark/sql/connect/client/ExecutePlanResponseReattachableIterator.scala
@@ -211,10 +211,8 @@ class ExecutePlanResponseReattachableIterator(
       iterFun(iter)
     } catch {
       case ex: StatusRuntimeException
-          if StatusProto
-            .fromThrowable(ex)
-            .getMessage
-            .contains("INVALID_HANDLE.OPERATION_NOT_FOUND") =>
+          if Option(StatusProto.fromThrowable(ex))
+            .exists(_.getMessage.contains("INVALID_HANDLE.OPERATION_NOT_FOUND")) =>
         if (lastReturnedResponseId.isDefined) {
           throw new IllegalStateException(
             "OPERATION_NOT_FOUND on the server but responses were already received from it.",
diff --git a/python/pyspark/sql/connect/client/reattach.py b/python/pyspark/sql/connect/client/reattach.py
index 70c7d126ff1..c5c45904c9b 100644
--- a/python/pyspark/sql/connect/client/reattach.py
+++ b/python/pyspark/sql/connect/client/reattach.py
@@ -239,7 +239,7 @@ class ExecutePlanResponseReattachableIterator(Generator):
             return iter_fun()
         except grpc.RpcError as e:
             status = rpc_status.from_call(cast(grpc.Call, e))
-            if "INVALID_HANDLE.OPERATION_NOT_FOUND" in status.message:
+            if status is not None and "INVALID_HANDLE.OPERATION_NOT_FOUND" in status.message:
                 if self._last_returned_response_id is not None:
                     raise RuntimeError(
                         "OPERATION_NOT_FOUND on the server but "
