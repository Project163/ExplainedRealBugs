diff --git a/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/v2/V2ScanRelationPushDown.scala b/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/v2/V2ScanRelationPushDown.scala
index f7f1c4f522c..a91612625be 100644
--- a/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/v2/V2ScanRelationPushDown.scala
+++ b/sql/core/src/main/scala/org/apache/spark/sql/execution/datasources/v2/V2ScanRelationPushDown.scala
@@ -179,8 +179,12 @@ object V2ScanRelationPushDown extends Rule[LogicalPlan] with PredicateHelper {
         node.output
           .zip(leftSideRequiredColumnsWithAliases ++ rightSideRequiredColumnsWithAliases)
           .collect {
-            case (attr, columnWithAlias) if columnWithAlias.alias() != null =>
-              (attr, attr.withName(columnWithAlias.alias()))
+            case (attr, columnWithAlias) =>
+              if (columnWithAlias.alias() != null) {
+                (attr, attr.withName(columnWithAlias.alias()))
+              } else {
+                (attr, attr.withName(columnWithAlias.colName()))
+              }
           }
           .toMap
       )
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/jdbc/v2/JDBCV2JoinPushdownIntegrationSuiteBase.scala b/sql/core/src/test/scala/org/apache/spark/sql/jdbc/v2/JDBCV2JoinPushdownIntegrationSuiteBase.scala
index 27ca84bc2a2..6e2898bfdf7 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/jdbc/v2/JDBCV2JoinPushdownIntegrationSuiteBase.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/jdbc/v2/JDBCV2JoinPushdownIntegrationSuiteBase.scala
@@ -600,4 +600,44 @@ trait JDBCV2JoinPushdownIntegrationSuiteBase
       checkAnswer(df, rows)
     }
   }
+
+  test("Test condition with aliased column") {
+    // After the first join, columns will be aliased because we are doing self join in CTE.
+    // Second join, is joining on aliased column, so the aliased value should be used in generated
+    // SQL query.
+    val sqlQuery = s"""
+      |WITH ws_wh AS (
+      |    SELECT
+      |        ws1.ID,
+      |        ws1.AMOUNT wh1,
+      |        ws2.AMOUNT wh2
+      |    FROM
+      |        $catalogAndNamespace.$casedJoinTableName1 ws1,
+      |        $catalogAndNamespace.$casedJoinTableName1 ws2
+      |    WHERE
+      |        ws1.ID = ws2.ID
+      |        AND ws1.AMOUNT <> ws2.AMOUNT
+      |)
+      |SELECT
+      |   NEXT_ID
+      |FROM
+      |   $catalogAndNamespace.$casedJoinTableName2,
+      |   ws_wh
+      |WHERE
+      |   NEXT_ID = ws_wh.ID
+      |""".stripMargin
+
+    val rows = withSQLConf(SQLConf.DATA_SOURCE_V2_JOIN_PUSHDOWN.key -> "false") {
+      sql(sqlQuery).collect().toSeq
+    }
+
+    assert(!rows.isEmpty)
+
+    withSQLConf(SQLConf.DATA_SOURCE_V2_JOIN_PUSHDOWN.key -> "true") {
+      val df = sql(sqlQuery)
+
+      checkJoinPushed(df)
+      checkAnswer(df, rows)
+    }
+  }
 }
