diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/predicates.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/predicates.scala
index 38005e78653..ee2ba7c73d1 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/predicates.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/predicates.scala
@@ -399,7 +399,15 @@ case class InSubquery(values: Seq[Expression], query: ListQuery)
   }
 
   override def children: Seq[Expression] = values :+ query
-  override def nullable: Boolean = children.exists(_.nullable)
+  override def nullable: Boolean = {
+    if (!SQLConf.get.getConf(SQLConf.LEGACY_IN_SUBQUERY_NULLABILITY)) {
+      values.exists(_.nullable) || query.childOutputs.exists(_.nullable)
+    } else {
+      // Legacy (incorrect) behavior checked only the nullability of the left-hand side
+      // (see SPARK-43413).
+      values.exists(_.nullable)
+    }
+  }
   override def toString: String = s"$value IN ($query)"
   override def sql: String = s"(${value.sql} IN (${query.sql}))"
 
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/subquery.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/subquery.scala
index 1e957466308..b0f10895c17 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/subquery.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/expressions/subquery.scala
@@ -24,6 +24,7 @@ import org.apache.spark.sql.catalyst.plans.QueryPlan
 import org.apache.spark.sql.catalyst.plans.logical.{Filter, HintInfo, LogicalPlan}
 import org.apache.spark.sql.catalyst.trees.TreePattern._
 import org.apache.spark.sql.errors.QueryCompilationErrors
+import org.apache.spark.sql.internal.SQLConf
 import org.apache.spark.sql.types._
 import org.apache.spark.util.collection.BitSet
 
@@ -367,7 +368,14 @@ case class ListQuery(
     plan.output.head.dataType
   }
   override lazy val resolved: Boolean = childrenResolved && plan.resolved && numCols != -1
-  override def nullable: Boolean = false
+  override def nullable: Boolean = {
+    // ListQuery can't be executed alone so its nullability is not defined.
+    // Consider using ListQuery.childOutputs.exists(_.nullable)
+    if (!SQLConf.get.getConf(SQLConf.LEGACY_IN_SUBQUERY_NULLABILITY)) {
+      assert(false, "ListQuery nullability is not defined")
+    }
+    false
+  }
   override def withNewPlan(plan: LogicalPlan): ListQuery = copy(plan = plan)
   override def withNewHint(hint: Option[HintInfo]): ListQuery = copy(hint = hint)
   override def toString: String = s"list#${exprId.id} $conditionString"
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/internal/SQLConf.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/internal/SQLConf.scala
index bf056d7e93a..cd3d41cdb5b 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/internal/SQLConf.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/internal/SQLConf.scala
@@ -4199,6 +4199,16 @@ object SQLConf {
       .booleanConf
       .createWithDefault(false)
 
+  val LEGACY_IN_SUBQUERY_NULLABILITY =
+    buildConf("spark.sql.legacy.inSubqueryNullability")
+      .internal()
+      .doc(s"When set to false, IN subquery nullability is correctly calculated based on " +
+        s"both the left and right sides of the IN. When set to true, restores the legacy " +
+        "behavior that does not check the right side's nullability.")
+      .version("3.5.0")
+      .booleanConf
+      .createWithDefault(false)
+
   val ERROR_MESSAGE_FORMAT = buildConf("spark.sql.error.messageFormat")
     .doc("When PRETTY, the error message consists of textual representation of error class, " +
       "message and query context. The MINIMAL and STANDARD formats are pretty JSON formats where " +
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/BinaryComparisonSimplificationSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/BinaryComparisonSimplificationSuite.scala
index 8b41cbdbbed..d2368908d03 100644
--- a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/BinaryComparisonSimplificationSuite.scala
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/BinaryComparisonSimplificationSuite.scala
@@ -228,4 +228,36 @@ class BinaryComparisonSimplificationSuite extends PlanTest {
 
     checkCondition(nullableRelation, $"a" <=> nullLit, $"a".isNull)
   }
+
+  test("SPARK-43413: IN subquery nullability") {
+    // The following cases are pairs of (relation, expression)
+    // Cases we should not optimize because the IN subquery is nullable
+    Seq(
+      // IN subquery right-hand-side (ListQuery) is nullable
+      (nonNullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nullableRelation.select($"a"))) <=> TrueLiteral),
+      (nonNullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nullableRelation.select($"a"))) <=> FalseLiteral),
+      // Left-hand-side of the IN is nullable
+      (nullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nonNullableRelation.select($"a"))) <=> TrueLiteral),
+      (nullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nonNullableRelation.select($"a"))) <=> FalseLiteral),
+      // Both sides of the IN are nullable
+      (nullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nullableRelation.select($"a"))) <=> TrueLiteral),
+      (nullableRelation,
+        InSubquery(Seq($"a"), ListQuery(nullableRelation.select($"a"))) <=> FalseLiteral)
+    ).foreach {
+      case (relation, expr) =>
+      checkCondition(relation, expr, expr)
+    }
+
+    // Should optimize, since the IN is non-nullable
+    val inExpr = InSubquery(Seq($"a"), ListQuery(nonNullableRelation.select($"a")))
+    checkCondition(nonNullableRelation, inExpr <=> FalseLiteral, Not(inExpr))
+
+    val inExpr2 = InSubquery(Seq($"a"), ListQuery(nonNullableRelation.select($"a")))
+    checkCondition(nonNullableRelation, inExpr2 <=> TrueLiteral, inExpr2)
+  }
 }
diff --git a/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/in-subquery/in-nullability.sql.out b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/in-subquery/in-nullability.sql.out
new file mode 100644
index 00000000000..34a14c6f73d
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/analyzer-results/subquery/in-subquery/in-nullability.sql.out
@@ -0,0 +1,141 @@
+-- Automatically generated by SQLQueryTestSuite
+-- !query
+create temp view t0 as select 1 as a_nonnullable
+-- !query analysis
+CreateViewCommand `t0`, select 1 as a_nonnullable, false, false, LocalTempView, true
+   +- Project [1 AS a_nonnullable#x]
+      +- OneRowRelation
+
+
+-- !query
+create temp view t1 as select cast(null as int) as b_nullable
+-- !query analysis
+CreateViewCommand `t1`, select cast(null as int) as b_nullable, false, false, LocalTempView, true
+   +- Project [cast(null as int) AS b_nullable#x]
+      +- OneRowRelation
+
+
+-- !query
+create temp view t2 as select 2 as c
+-- !query analysis
+CreateViewCommand `t2`, select 2 as c, false, false, LocalTempView, true
+   +- Project [2 AS c#x]
+      +- OneRowRelation
+
+
+-- !query
+select * from t0 where a_nonnullable in (select b_nullable from t1)
+-- !query analysis
+Project [a_nonnullable#x]
++- Filter a_nonnullable#x IN (list#x [])
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   +- SubqueryAlias t0
+      +- View (`t0`, [a_nonnullable#x])
+         +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+            +- Project [1 AS a_nonnullable#x]
+               +- OneRowRelation
+
+
+-- !query
+select * from t0 where (a_nonnullable in (select b_nullable from t1)) <=> true
+-- !query analysis
+Project [a_nonnullable#x]
++- Filter (a_nonnullable#x IN (list#x []) <=> true)
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   +- SubqueryAlias t0
+      +- View (`t0`, [a_nonnullable#x])
+         +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+            +- Project [1 AS a_nonnullable#x]
+               +- OneRowRelation
+
+
+-- !query
+select * from t0 where a_nonnullable not in (select b_nullable from t1)
+-- !query analysis
+Project [a_nonnullable#x]
++- Filter NOT a_nonnullable#x IN (list#x [])
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   +- SubqueryAlias t0
+      +- View (`t0`, [a_nonnullable#x])
+         +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+            +- Project [1 AS a_nonnullable#x]
+               +- OneRowRelation
+
+
+-- !query
+select * from t0 where (a_nonnullable not in (select b_nullable from t1)) <=> true
+-- !query analysis
+Project [a_nonnullable#x]
++- Filter (NOT a_nonnullable#x IN (list#x []) <=> true)
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   +- SubqueryAlias t0
+      +- View (`t0`, [a_nonnullable#x])
+         +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+            +- Project [1 AS a_nonnullable#x]
+               +- OneRowRelation
+
+
+-- !query
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) is null
+-- !query analysis
+Project [a_nonnullable#x, c#x]
++- Join LeftOuter, isnull(a_nonnullable#x IN (list#x []))
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   :- SubqueryAlias t0
+   :  +- View (`t0`, [a_nonnullable#x])
+   :     +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+   :        +- Project [1 AS a_nonnullable#x]
+   :           +- OneRowRelation
+   +- SubqueryAlias t2
+      +- View (`t2`, [c#x])
+         +- Project [cast(c#x as int) AS c#x]
+            +- Project [2 AS c#x]
+               +- OneRowRelation
+
+
+-- !query
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) <=> true
+-- !query analysis
+Project [a_nonnullable#x, c#x]
++- Join LeftOuter, (a_nonnullable#x IN (list#x []) <=> true)
+   :  +- Project [b_nullable#x]
+   :     +- SubqueryAlias t1
+   :        +- View (`t1`, [b_nullable#x])
+   :           +- Project [cast(b_nullable#x as int) AS b_nullable#x]
+   :              +- Project [cast(null as int) AS b_nullable#x]
+   :                 +- OneRowRelation
+   :- SubqueryAlias t0
+   :  +- View (`t0`, [a_nonnullable#x])
+   :     +- Project [cast(a_nonnullable#x as int) AS a_nonnullable#x]
+   :        +- Project [1 AS a_nonnullable#x]
+   :           +- OneRowRelation
+   +- SubqueryAlias t2
+      +- View (`t2`, [c#x])
+         +- Project [cast(c#x as int) AS c#x]
+            +- Project [2 AS c#x]
+               +- OneRowRelation
diff --git a/sql/core/src/test/resources/sql-tests/inputs/subquery/in-subquery/in-nullability.sql b/sql/core/src/test/resources/sql-tests/inputs/subquery/in-subquery/in-nullability.sql
new file mode 100644
index 00000000000..07b4afe36c1
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/inputs/subquery/in-subquery/in-nullability.sql
@@ -0,0 +1,14 @@
+-- SPARK-43413: Tests for IN subquery nullability
+
+create temp view t0 as select 1 as a_nonnullable;
+create temp view t1 as select cast(null as int) as b_nullable;
+create temp view t2 as select 2 as c;
+
+select * from t0 where a_nonnullable in (select b_nullable from t1);
+select * from t0 where (a_nonnullable in (select b_nullable from t1)) <=> true;
+select * from t0 where a_nonnullable not in (select b_nullable from t1);
+select * from t0 where (a_nonnullable not in (select b_nullable from t1)) <=> true;
+
+-- IN subqueries in ON conditions are not rewritten to joins in RewritePredicateSubquery
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) is null;
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) <=> true;
diff --git a/sql/core/src/test/resources/sql-tests/results/subquery/in-subquery/in-nullability.sql.out b/sql/core/src/test/resources/sql-tests/results/subquery/in-subquery/in-nullability.sql.out
new file mode 100644
index 00000000000..4c8e9b300b8
--- /dev/null
+++ b/sql/core/src/test/resources/sql-tests/results/subquery/in-subquery/in-nullability.sql.out
@@ -0,0 +1,71 @@
+-- Automatically generated by SQLQueryTestSuite
+-- !query
+create temp view t0 as select 1 as a_nonnullable
+-- !query schema
+struct<>
+-- !query output
+
+
+
+-- !query
+create temp view t1 as select cast(null as int) as b_nullable
+-- !query schema
+struct<>
+-- !query output
+
+
+
+-- !query
+create temp view t2 as select 2 as c
+-- !query schema
+struct<>
+-- !query output
+
+
+
+-- !query
+select * from t0 where a_nonnullable in (select b_nullable from t1)
+-- !query schema
+struct<a_nonnullable:int>
+-- !query output
+
+
+
+-- !query
+select * from t0 where (a_nonnullable in (select b_nullable from t1)) <=> true
+-- !query schema
+struct<a_nonnullable:int>
+-- !query output
+
+
+
+-- !query
+select * from t0 where a_nonnullable not in (select b_nullable from t1)
+-- !query schema
+struct<a_nonnullable:int>
+-- !query output
+
+
+
+-- !query
+select * from t0 where (a_nonnullable not in (select b_nullable from t1)) <=> true
+-- !query schema
+struct<a_nonnullable:int>
+-- !query output
+
+
+
+-- !query
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) is null
+-- !query schema
+struct<a_nonnullable:int,c:int>
+-- !query output
+1	2
+
+
+-- !query
+select * from t0 left join t2 on (a_nonnullable IN (select b_nullable from t1)) <=> true
+-- !query schema
+struct<a_nonnullable:int,c:int>
+-- !query output
+1	NULL
