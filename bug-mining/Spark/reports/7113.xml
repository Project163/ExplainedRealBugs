<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 19:15:42 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-18886] Delay scheduling should not delay some executors indefinitely if one task is scheduled before delay timeout</title>
                <link>https://issues.apache.org/jira/browse/SPARK-18886</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;Delay scheduling can introduce an unbounded delay and underutilization of cluster resources under the following circumstances:&lt;/p&gt;

&lt;p&gt;1. Tasks have locality preferences for a subset of available resources&lt;br/&gt;
2. Tasks finish in less time than the delay scheduling.&lt;/p&gt;

&lt;p&gt;Instead of having &lt;b&gt;one&lt;/b&gt; delay to wait for resources with better locality, spark waits indefinitely.&lt;/p&gt;

&lt;p&gt;As an example, consider a cluster with 100 executors, and a taskset with 500 tasks.  Say all tasks have a preference for one executor, which is by itself on one host.  Given the default locality wait of 3s per level, we end up with a 6s delay till we schedule on other hosts (process wait + host wait).&lt;/p&gt;

&lt;p&gt;If each task takes 5 seconds (under the 6 second delay), then &lt;em&gt;all 500&lt;/em&gt; tasks get scheduled on &lt;em&gt;only one&lt;/em&gt; executor.  This means you&apos;re only using a 1% of your cluster, and you get a ~100x slowdown.  You&apos;d actually be better off if tasks took 7 seconds.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;WORKAROUNDS&lt;/b&gt;: &lt;/p&gt;

&lt;p&gt;(1) You can change the locality wait times so that it is shorter than the task execution time.  You need to take into account the sum of all wait times to use all the resources on your cluster.  For example, if you have resources on different racks, this will include the sum of &quot;spark.locality.wait.process&quot; + &quot;spark.locality.wait.node&quot; + &quot;spark.locality.wait.rack&quot;.  Those each default to &quot;3s&quot;.  The simplest way to be to set &quot;spark.locality.wait.process&quot; to your desired wait interval, and set both &quot;spark.locality.wait.node&quot; and &quot;spark.locality.wait.rack&quot; to &quot;0&quot;.  For example, if your tasks take ~3 seconds on average, you might set &quot;spark.locality.wait.process&quot; to &quot;1s&quot;.  &lt;b&gt;NOTE&lt;/b&gt;: due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-18967&quot; title=&quot;Locality preferences should be used when scheduling even when delay scheduling is turned off&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-18967&quot;&gt;&lt;del&gt;SPARK-18967&lt;/del&gt;&lt;/a&gt;, avoid setting the &lt;tt&gt;spark.locality.wait=0&lt;/tt&gt; &amp;#8211; instead, use &lt;tt&gt;spark.locality.wait=1ms&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Note that this workaround isn&apos;t perfect --with less delay scheduling, you may not get as good resource locality.  After this issue is fixed, you&apos;d most likely want to undo these configuration changes.&lt;/p&gt;

&lt;p&gt;(2) The worst case here will only happen if your tasks have extreme skew in their locality preferences.  Users may be able to modify their job to controlling the distribution of the original input data.&lt;/p&gt;

&lt;p&gt;(2a) A shuffle may end up with very skewed locality preferences, especially if you do a repartition starting from a small number of partitions.  (Shuffle locality preference is assigned if any node has more than 20% of the shuffle input data &amp;#8211; by chance, you may have one node just above that threshold, and all other nodes just below it.)  In this case, you can turn off locality preference for shuffle data by setting &lt;tt&gt;spark.shuffle.reduceLocality.enabled=false&lt;/tt&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13028442">SPARK-18886</key>
            <summary>Delay scheduling should not delay some executors indefinitely if one task is scheduled before delay timeout</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nmarcott">Nicholas Brett Marcott</assignee>
                                    <reporter username="irashid">Imran Rashid</reporter>
                        <labels>
                    </labels>
                <created>Thu, 15 Dec 2016 17:22:11 +0000</created>
                <updated>Sun, 17 May 2020 17:47:50 +0000</updated>
                            <resolved>Mon, 13 Apr 2020 06:00:58 +0000</resolved>
                                    <version>2.1.0</version>
                                    <fixVersion>3.1.0</fixVersion>
                                    <component>Scheduler</component>
                    <component>Spark Core</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>15</watches>
                                                                                                                <comments>
                            <comment id="15751949" author="irashid" created="Thu, 15 Dec 2016 17:29:03 +0000"  >&lt;p&gt;cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kayousterhout&quot; class=&quot;user-hover&quot; rel=&quot;kayousterhout&quot;&gt;kayousterhout&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=markhamstra&quot; class=&quot;user-hover&quot; rel=&quot;markhamstra&quot;&gt;markhamstra&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=zsxwing&quot; class=&quot;user-hover&quot; rel=&quot;zsxwing&quot;&gt;zsxwing&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15751956" author="irashid" created="Thu, 15 Dec 2016 17:30:44 +0000"  >&lt;p&gt;Here&apos;s a failing test case: (you can check it out directly here: &lt;a href=&quot;https://github.com/squito/spark/tree/delay_sched-SPARK-18886&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/squito/spark/tree/delay_sched-SPARK-18886&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  test(&lt;span class=&quot;code-quote&quot;&gt;&quot;Delay scheduling checks utilization at each locality level&quot;&lt;/span&gt;) {
    &lt;span class=&quot;code-comment&quot;&gt;// Create a cluster with 100 executors, and submit 100 tasks, but each task would prefer to
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// be on the same node in the cluster.  We should not wait to schedule each task on the one
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// executor.
&lt;/span&gt;    sc = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; SparkContext(&lt;span class=&quot;code-quote&quot;&gt;&quot;local&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;)
    val execs = Seq((&lt;span class=&quot;code-quote&quot;&gt;&quot;exec0&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;host0&quot;&lt;/span&gt;)) ++ (1 to 100).map { x =&amp;gt; (s&lt;span class=&quot;code-quote&quot;&gt;&quot;exec$x&quot;&lt;/span&gt;, s&lt;span class=&quot;code-quote&quot;&gt;&quot;host$x&quot;&lt;/span&gt;) }
    val sched = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FakeTaskScheduler(sc, execs: _*)
    val tasks = FakeTask.createTaskSet(500, (1 to 500).map { _ =&amp;gt;
      Seq(TaskLocation(TaskLocation.executorLocationTag + &lt;span class=&quot;code-quote&quot;&gt;&quot;host0_exec0&quot;&lt;/span&gt;))}: _*)
    val clock = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ManualClock
    val manager = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TaskSetManager(sched, tasks, MAX_TASK_FAILURES, clock)
    logInfo(&lt;span class=&quot;code-quote&quot;&gt;&quot;initial locality levels = &quot;&lt;/span&gt; + manager.myLocalityLevels.mkString(&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;))
    &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(manager.myLocalityLevels.sameElements(Array(PROCESS_LOCAL, NODE_LOCAL, ANY)))
    &lt;span class=&quot;code-comment&quot;&gt;// initially, the locality preferences should lead us to only schedule tasks on one executor
&lt;/span&gt;    logInfo(s&lt;span class=&quot;code-quote&quot;&gt;&quot;trying to schedule first task at ${clock.getTimeMillis()}&quot;&lt;/span&gt;)
    val firstScheduledTask = execs.flatMap { &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; (exec, host) =&amp;gt;
      val schedTaskOpt = manager.resourceOffer(execId = exec, host = host, ANY)
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(schedTaskOpt.isDefined === (exec == &lt;span class=&quot;code-quote&quot;&gt;&quot;exec0&quot;&lt;/span&gt;))
      schedTaskOpt
    }.head

    &lt;span class=&quot;code-comment&quot;&gt;// without advancing the clock, no matter how many times we make offers on the *other*
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// executors, nothing should get scheduled
&lt;/span&gt;    (0 until 50).foreach { _ =&amp;gt;
      execs.foreach { &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; (exec, host) =&amp;gt;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (exec != &lt;span class=&quot;code-quote&quot;&gt;&quot;exec0&quot;&lt;/span&gt;) {
          &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(manager.resourceOffer(execId = exec, host = host, ANY).isEmpty)
        }
      }
    }

    &lt;span class=&quot;code-comment&quot;&gt;// now we advance the clock till just *before* the locality delay is up, and we finish the first
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// task
&lt;/span&gt;    val processWait = sc.getConf.getTimeAsMs(&lt;span class=&quot;code-quote&quot;&gt;&quot;spark.locality.wait.process&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;3s&quot;&lt;/span&gt;)
    val nodeWait = sc.getConf.getTimeAsMs(&lt;span class=&quot;code-quote&quot;&gt;&quot;spark.locality.wait.node&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;3s&quot;&lt;/span&gt;)
    clock.advance(processWait + nodeWait - 1)
    logInfo(s&lt;span class=&quot;code-quote&quot;&gt;&quot;finishing first task at ${clock.getTimeMillis()}&quot;&lt;/span&gt;)
    manager.handleSuccessfulTask(firstScheduledTask.taskId,
      createTaskResult(firstScheduledTask.index))
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we offer all the resources again, still we should only schedule on one executor
&lt;/span&gt;    logInfo(s&lt;span class=&quot;code-quote&quot;&gt;&quot;trying to schedule second task at ${clock.getTimeMillis()}&quot;&lt;/span&gt;)
    val secondScheduledTask = execs.flatMap { &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; (exec, host) =&amp;gt;
      val schedTaskOpt = manager.resourceOffer(execId = exec, host = host, ANY)
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(schedTaskOpt.isDefined === (exec == &lt;span class=&quot;code-quote&quot;&gt;&quot;exec0&quot;&lt;/span&gt;))
      schedTaskOpt
    }.head

    &lt;span class=&quot;code-comment&quot;&gt;// Now lets advance the clock further, so that all of our other executors have been sitting
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// idle &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; longer than the locality wait time.  We have managed to schedule *something* at a
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// lower locality level within the time, but regardless, we *should* still schedule on the all
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// the other resources by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; point
&lt;/span&gt;    clock.advance(10)
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; would pass &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we advanced the clock by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; much instead
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;//    clock.advance(processWait + nodeWait + 10)
&lt;/span&gt;    logInfo(s&lt;span class=&quot;code-quote&quot;&gt;&quot;trying to schedule everyting at ${clock.getTimeMillis()}&quot;&lt;/span&gt;)
    execs.foreach { &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; (exec, host) =&amp;gt;
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (exec != &lt;span class=&quot;code-quote&quot;&gt;&quot;exec0&quot;&lt;/span&gt;) {
        withClue(s&lt;span class=&quot;code-quote&quot;&gt;&quot;trying to schedule on $exec:$host at time ${clock.getTimeMillis()}&quot;&lt;/span&gt;) {
          &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(manager.resourceOffer(execId = exec, host = host, ANY).isDefined)
        }
      }
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15752098" author="markhamstra" created="Thu, 15 Dec 2016 18:23:30 +0000"  >&lt;p&gt;That&apos;s a great explanation of the issue, and nice example code, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=imranr&quot; class=&quot;user-hover&quot; rel=&quot;imranr&quot;&gt;imranr&lt;/a&gt;.  I&apos;m sure that I have seen this kind of excessive Task stickiness with many quick-to-execute Tasks, but I never got to the level of diagnosing the problem that you have.&lt;/p&gt;

&lt;p&gt;Your listed workarounds, while interesting, aren&apos;t a complete long-term solution, of course.  Have you thought at all yet about possible paths to a solution?  One idea that comes to my mind is that speculative execution has at least the potential to get the delayed Tasks executed more quickly elsewhere &amp;#8211; but our prior concerns or lack of confidence with speculative execution remain.  &lt;/p&gt;</comment>
                            <comment id="15752426" author="mridulm80" created="Thu, 15 Dec 2016 20:28:19 +0000"  >
&lt;p&gt;Spark scheduler can be suboptimal for a lot of degenerate cases, not just this. But for the most part it does quite well : and for others, you can simply change the config to better suit the workload better - for example, I have used 0 for the delay timeout in some production jobs actually - you get prioritized scheduling, and fallback to ANY quickly when all tasks with preference have been scheduled to remove any waiting : when benefits of colocation are trumped by needing quicker schedules.&lt;/p&gt;

&lt;p&gt;That is not to say we cant improve scheduling in spark - for example, treat it as a bin packing problem for schedules of a single (or across) locality preference to &apos;pack&apos; more tasks - doing it without incurring high cost is why lot of these did not make it in unfortunately.&lt;/p&gt;</comment>
                            <comment id="15752451" author="irashid" created="Thu, 15 Dec 2016 20:36:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=markhamstra&quot; class=&quot;user-hover&quot; rel=&quot;markhamstra&quot;&gt;markhamstra&lt;/a&gt; I&apos;m not really sure yet, I can&apos;t really decide exactly what the right behavior should be.  My initial thought was that the TSM should track the last time that anything has been scheduled at &lt;b&gt;each&lt;/b&gt; locality level, rather than just one overall &lt;tt&gt;lastLaunchTime&lt;/tt&gt;, so that it realizes that some resources have been waiting a long time at a higher locality level.  But I wasn&apos;t exactly sure what should happen after you schedule one task at a higher locality level.  Do you reset the timer?  Or do you just keep scheduling at the locality level for the rest of the task set?  If you reset the timer, than you will only schedule one task on the other resources, before adding another locality delay, so that doesn&apos;t work.  But if you keep scheduling at that new locality level, then you&apos;ve thrown away delay scheduling for the rest of the task set.  Is that OK?&lt;/p&gt;

&lt;p&gt;To put that last question a different way &amp;#8211; what is the point of delay scheduling anyway?  What are we hoping will happen in that delay window?&lt;br/&gt;
1) the tasks run so fast that the preferred localities make it through all of the tasks in the entire task set before the delay is up&lt;br/&gt;
2) other tasksets are concurrently submitted with different locality preferences, so we can submit those tasks to the remaining executors (rather than sitting idle)&lt;br/&gt;
3) new resources will be spun up with the desired locality preferences.  (Eg., we&apos;ve requested a bunch of resources from dynamic allocation, and the resources which have become available so far don&apos;t have the preferred localities, but more are still getting spun up.)&lt;/p&gt;

&lt;p&gt;Under all the scenarios I can think of, you might as well turn off delay scheduling for the rest of the taskset.  But to be honest I don&apos;t feel like I&apos;ve got good justification for delay scheduling in the first place, so I feel like I may be missing something.&lt;/p&gt;


&lt;p&gt;Also I did a bit more digging into the case I had, and its happening because of a repartition from a small number (~10) of partitions to a much larger one.  The shuffle map stage ends up running two tasks on one host, and with a very small amount of skew, it turns out that one host has &amp;gt; 20% of the shuffle output, while none of the other hosts do.   I feel like there is also something else we can do here to improve the shuffle locality preferences, but I don&apos;t have any concrete ideas on what that improvement should be.&lt;/p&gt;</comment>
                            <comment id="15752462" author="irashid" created="Thu, 15 Dec 2016 20:42:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mridulm80&quot; class=&quot;user-hover&quot; rel=&quot;mridulm80&quot;&gt;mridulm80&lt;/a&gt; good point, perhaps the right answer here is just to turn off delay scheduling completely &amp;#8211; not setting &lt;tt&gt;&quot;spark.locality.wait.process&quot;&lt;/tt&gt; to a small value, as I had suggested in the initial workaround, but just turning it off completely, to avoid having to futz with tuning that value relative to task runtime.&lt;/p&gt;

&lt;p&gt;But lemme ask you more or less the same question I just asked mark, phrased a little differently &amp;#8211; given the fragility of this, wouldn&apos;t it make more sense for us to turn delay scheduling &lt;b&gt;off&lt;/b&gt; by default?&lt;/p&gt;</comment>
                            <comment id="15752579" author="mridulm80" created="Thu, 15 Dec 2016 21:34:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=imranr&quot; class=&quot;user-hover&quot; rel=&quot;imranr&quot;&gt;imranr&lt;/a&gt; For almost all cases, delay scheduling dramatically increases performance. The difference even between PROCESS and NODE is significantly high (between NODE and &apos;lower&apos; levels, it can depend on your network config).&lt;br/&gt;
For both tasks with short duration and tasks processing large amounts of data, it has non trivial impact : long tasks processing small data, it is not so useful in comparison iirc, same for degenerate cases where locality preference is suboptimal to begin with. &lt;span class=&quot;error&quot;&gt;&amp;#91;As an aside, the ability to not specify PROCESS level locality preference actually is a drawback in our api&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The job(s) I mentioned where we set it to 0 were special cases, where we knew the costs well enough to make the decision to lower it : but I would not recommend it unless users are very sure of what they are doing. While analysing the cost, it should also be kept in mind that transferring data across nodes impacts not just spark job, but every other job in the cluster.&lt;/p&gt;</comment>
                            <comment id="15752722" author="irashid" created="Thu, 15 Dec 2016 22:40:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mridul&quot; class=&quot;user-hover&quot; rel=&quot;mridul&quot;&gt;mridul&lt;/a&gt; sorry if I am being slow here, but do you mind spelling out for me in more detail?  I&apos;m &lt;b&gt;not&lt;/b&gt; asking about the benefits of using locality preferences &amp;#8211; I get that part.  I&apos;m asking about why the &lt;b&gt;delay&lt;/b&gt;.  There has to be something happening during the delay which we want to wait for.&lt;/p&gt;

&lt;p&gt;One possibility is that you&apos;ve got multiple tasksets running concurrently, with different locality preferences.  You wouldn&apos;t want the first taskset to use all the resources, you&apos;d rather take both tasksets into account.  This is accomplished with delay scheduling, but you don&apos;t actually &lt;b&gt;need&lt;/b&gt; the delay.&lt;/p&gt;

&lt;p&gt;Another possibility is that there is such a huge gap in runtime that you expect your preferred locations will finish &lt;b&gt;all&lt;/b&gt; tasks in the taskset before that delay is up, by having some executors run multiple tasks.&lt;/p&gt;

&lt;p&gt;The reason I&apos;m trying to figure this out is to figure out if there is a sensible fix here (and what the smallest possible fix would be).  If this is it, then the fix I suggested above to Mark should handle this case, while still working as intended in other cases.&lt;/p&gt;</comment>
                            <comment id="15756179" author="mridulm80" created="Sat, 17 Dec 2016 03:10:12 +0000"  >
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Delay &apos;using up&apos; all resources - another task/taskset which has better locality preference might be available for that executor (also, see speculative exec impact)&lt;/li&gt;
	&lt;li&gt;A delay would cause a better locality preference to become available for the task. Suboptimal schedule has a cascading effect on rest of the executors, application and cluster.&lt;/li&gt;
	&lt;li&gt;Note that not all executors are available at the same time in resourceOffer : you have bulk reschedule periodically,  sporadic reschedules when tasks finish and periodic bulk speculative schedule updates.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15762296" author="irashid" created="Mon, 19 Dec 2016 21:01:00 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mridul&quot; class=&quot;user-hover&quot; rel=&quot;mridul&quot;&gt;mridul&lt;/a&gt;, that helps &amp;#8211; in particular I was only thinking about bulk scheduling, I had forgotten to take that into account.&lt;/p&gt;

&lt;p&gt;After a closer look through the code, I think my earlier proposal makes sense &amp;#8211; rather than resetting the timeout as each task is scheduled, change it to start the timer as soon as there is an offer which goes unused due to the delay.  Once that timer is started, it is never reset (for that TSM).&lt;/p&gt;

&lt;p&gt;I can think of one scenario where this would result in worse scheduling than what we currently have.  Suppose that initially, a TSM is offered one resource which only matches on rack_local.  But immediately after that, many process_local offers are made, which are all used up.  Some time later, more offers that are only rack_local come in.  They&apos;ll immediately get used, even though there may be plenty more offers that are process_local that are just about to come in (perhaps enough for all of the remaining tasks).&lt;/p&gt;

&lt;p&gt;That wouldn&apos;t be great, but its also not nearly as bad as letting most of your cluster sit idle.&lt;/p&gt;

&lt;p&gt;Other alternatives I can think of:&lt;/p&gt;

&lt;p&gt;a) Turn off delay scheduling by default, and change &lt;a href=&quot;https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/scheduler/TaskSchedulerImpl.scala#L357-L360&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;&lt;tt&gt;TaskSchedulerImpl.resourceOffer&lt;/tt&gt;&lt;/a&gt; to go through all task sets, then advance locality levels, rather than the other way around.  Perhaps we should invert those loops anyway, just for when users turn off delay scheduling.&lt;/p&gt;

&lt;p&gt;b) Have TSM use some knowledge about all available executors to decide whether or not it is even possible for enough resources at the right locality level to appear.  Eg., in the original case, the TSM would realize there is only one executor which is process_local, so it doesn&apos;t make sense to wait to schedule all tasks on that executor.  However, I&apos;m pretty skeptical about doing anything like this, as it may be a somewhat complicated thing inside the scheduler, and it could just turn into a mess of heuristics which has lots of corner cases.&lt;/p&gt;

&lt;p&gt;I think implementing my proposed solution should be relatively easy, so I&apos;ll take a stab at it, but I&apos;d still appreciate more input on the right approach here.  Perhaps seeing an implementation will make it easier to discuss.&lt;/p&gt;</comment>
                            <comment id="15764795" author="apachespark" created="Tue, 20 Dec 2016 17:50:05 +0000"  >&lt;p&gt;User &apos;squito&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/16354&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/16354&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15764876" author="mridulm80" created="Tue, 20 Dec 2016 18:26:28 +0000"  >&lt;p&gt;I am not sure what is described will work as expected &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=imranr&quot; class=&quot;user-hover&quot; rel=&quot;imranr&quot;&gt;imranr&lt;/a&gt;.&lt;br/&gt;
Consider a taskset which has number of tasks as many multiples of number of executors (fairly common scenario).&lt;br/&gt;
In this case, if the timer is never reset, you will effectively make delay to 0 once it expires, across all waves for the taskset.&lt;br/&gt;
(I am assuming I understood the proposal right).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=kayousterhout&quot; class=&quot;user-hover&quot; rel=&quot;kayousterhout&quot;&gt;kayousterhout&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=markhamstra&quot; class=&quot;user-hover&quot; rel=&quot;markhamstra&quot;&gt;markhamstra&lt;/a&gt; might have more comments though - in case I am missing something here.&lt;/p&gt;</comment>
                            <comment id="15765322" author="irashid" created="Tue, 20 Dec 2016 21:43:25 +0000"  >&lt;p&gt;You understand correctly &amp;#8211; that is precisely what I&apos;m proposing.&lt;/p&gt;

&lt;p&gt;The scenario with multiple waves is a good example for why I think this is a &lt;b&gt;good&lt;/b&gt; change.  If only 1% of your cluster can take advantage of locality, then 99% of your cluster goes unused across all those waves.  That may be an extreme (though a case I have actually seen in practice on large clusters).  even if its 50%, then you have 50% of your cluster going unused.  Unless local tasks are more than 2x faster, it would make more sense to make the change I&apos;m proposing.  What&apos;s the worst case after this change?  All but one executor are local &amp;#8211; the result is that you have one task running slower.  But the more waves there are, the less the downside.  Eg., you complete 10 waves on the local executors, and only 8 waves on the non-local one.&lt;/p&gt;

&lt;p&gt;The worst case is if there is only one wave, there is a huge gap (multiples Xs) in runtime between local and non-local execution, and moments after you schedule on non-local resources, some local resource would become available.  I think this situation is not very common &amp;#8211; in particular, there normally isn&apos;t &lt;b&gt;such&lt;/b&gt; an enormous gap between local and non-local that users would prefer their non-local resources sit idle indefinitely.  I&apos;d argue that if such a use case is important, we should add a special conf for that in particular.&lt;/p&gt;</comment>
                            <comment id="15830530" author="irashid" created="Thu, 19 Jan 2017 20:14:24 +0000"  >&lt;p&gt;I had another idea for how to fix this.  In addition to tracking the last time any task was launched, TaskScheduler also tracks the last time it didn&apos;t schedule anything due to locality constraints, on &lt;b&gt;each resource&lt;/b&gt;.  Then when a new offer comes in, you are allowed to schedule if either the overall locality timer is up, or if the timer is up for that particular resource.&lt;/p&gt;

&lt;p&gt;On the plus side &amp;#8211; I think this keeps all the properties we want.  You avoid an indefinite delay just because &lt;b&gt;one&lt;/b&gt; resource is local;  but you also keep the delay if those resources get used up by another task set.&lt;/p&gt;

&lt;p&gt;The downside &amp;#8211; significantly more complex.  It adds to the memory usage of TaskScheduler (though in the scheme of things, pretty nominal increase), but it will also make the code significantly more complicated.&lt;/p&gt;

&lt;p&gt;Aside: There is also weird relationship between taskset priority, and locality scheduling.  Assuming all tasksets have cleared their locality wait timeouts, then we favor taskset priority over locality.  But if the tasksets haven&apos;t cleared those timeouts, then things get strange.  It really depends on what the current locality levels are in each taskset.  In the simple case, you end up favoring locality, by limiting the max Locality of each taskset.  A very low priority taskset easily &quot;steals&quot; the resources from a high priority one if it doesn&apos;t have locality preferences.  We should probably figure out what the desired behavior is so we can make it a little more consistent (or at least document it).&lt;/p&gt;</comment>
                            <comment id="15931009" author="kayousterhout" created="Sat, 18 Mar 2017 02:21:59 +0000"  >&lt;p&gt;Sorry for the slow response here!  I realized this is the same issue as &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-11460&quot; title=&quot;Locality waits should be based on task set creation time, not last launch time&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-11460&quot;&gt;&lt;del&gt;SPARK-11460&lt;/del&gt;&lt;/a&gt; (although that JIRA proposed a slightly different solution), which stalled for reasons that are completely my fault (I neglected it because I couldn&apos;t think of a practical way of solving it).&lt;/p&gt;

&lt;p&gt;Imran, unfortunately I don&apos;t think your latest idea will quite work.  Delay scheduling was originally intended for situations where the number of slots that a particular job could use was limited by a fairness policy.  In that case, it can be better to wait a bit for a &quot;better&quot; slot (i.e., one that satisfies locality preferences).  In particular, if you never wait, you end up with this &quot;sticky slot&quot; issue where tasks for a job keep finishing up in a &quot;bad&quot; slot (one with no locality preferences), and then they&apos;ll be re-offered to the same job, which will again accept the bad slot.  If the job just waited a bit, it could get a better slot (e.g., as a result of tasks from another job finishing). &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This relates to your idea because of the following situation: suppose you have a cluster with 10 machines, the job has locality preferences for 5 of them (with ids 1, 2, 3, 4, 5), and fairness dictates that the job can only use 3 slots at a time (e.g., it&apos;s sharing equally with 2 other jobs).  Suppose that for a long time, the job has been running tasks on slots 1, 2, and 3 (so local slots).  At this point, the times for machines 6, 7, 8, 9, and 10 will have expired, because the job has been running for a while.  But if the job is now offered a slot on one of those non-local machines (e.g., 6), the job hasn&apos;t been waiting long for non-local resources: until this point, it&apos;s been running it&apos;s full share of 3 slots at a time, and it&apos;s been doing so on machines that satisfy locality preferences.  So, we shouldn&apos;t accept that slot on machine 6 &amp;#8211; we should wait a bit to see if we can get a slot on 1, 2, 3, 4, or 5.&lt;/p&gt;

&lt;p&gt;The solution I proposed (in a long PR comment) for the other JIRA is: if the task set is using fewer than the number of slots it could be using (where &#8220;# slots it could be using&#8221; is all of the slots in the cluster if the job is running alone, or the job&#8217;s fair share, if it&#8217;s not) for some period of time, increase the locality level.   The problem with that solution is that I thought it was completely impractical to determine the number of slots a TSM &quot;should&quot; be allowed to use.&lt;/p&gt;

&lt;p&gt;However, after thinking about this more today, I think we might be able to do this in a practical way:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;First, I thought that we could use information about when offers are rejected to determine this (e.g., if you&apos;ve been rejecting offers for a while, then you&apos;re not using your fair share).  But the problem here is that it&apos;s not easy to determine when you &lt;b&gt;are&lt;/b&gt; using your fair / allowed share: accepting a single offer doesn&apos;t necessarily mean that you&apos;re now using the allowed share.  This is precisely the problem with the current approach, hence this JIRA.&lt;/li&gt;
	&lt;li&gt;v1: one possible proxy for this is if there are slots that are currently available that haven&apos;t been accepted by any job.  The TaskSchedulerImpl could feasibly pass this information to each TaskSetManager, and the TSM could use it to update it&apos;s delay timer: something like only reset the delay timer to 0 if (a) the TSM accepts an offer and (b) the flag passed by the TSM indicates that there are no other unused slots in the cluster.  This fixes the problem described in the JIRA: in that case, the flag would indicate that there &lt;b&gt;were&lt;/b&gt; other unused slots, even though a task got successfully scheduled with this offer, so the delay timer wouldn&apos;t be reset, and would eventually correctly expire.&lt;/li&gt;
	&lt;li&gt;v2: The problem with v1 is that it doesn&apos;t correctly handle situations where e.g., you have two jobs A and B with equal shares.  B is &quot;greedy&quot; and will accept any slot (e.g., it&apos;s a reduce stage), and A is doing delay scheduling.  In this case, A might have much less than its share, but the flag from the TaskSchedulerImpl would indicate that there were no other free slots in the cluster, so the delay timer wouldn&apos;t ever expire.  I suspect we could handle this (e.g., with some logic in the TaskSchedulerImpl to detect when a particular TSM is getting starved: when it keeps rejecting offers that are later accepted by someone else) but before thinking about this further, I wanted to run the general idea by you to see what your thoughts are.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; There&apos;s a whole side question / discussion of how often this is useful for Spark at all.  It can be useful if you&apos;re running in a shared cluster where e.g. Yarn might be assigning you more slots over time, and it&apos;s also useful when a single Spark context is being shared across many jobs.  But often for Spark, you have one job running alone, in which case delay scheduling should arguably be turned of altogether, as you suggested earlier Imran.  But let&apos;s separate that discussion from this one, of how to make it work better.&lt;/p&gt;</comment>
                            <comment id="15931893" author="irashid" created="Sun, 19 Mar 2017 19:18:53 +0000"  >&lt;p&gt;Thanks Kay for the full description (and finding the old jira, sorry I didn&apos;t notice the duplicate).  Your explanation and alternative makes sense.  One detail from v1:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;flag passed by the TSM indicates that there are no other unused slots in the cluster&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;neither the TSM nor TaskSchedulerImpl currently track this &amp;#8211; they know about executors, but not individual slots.  With bulk-scheduling calls to &lt;tt&gt;resourceOffer()&lt;/tt&gt; that include the entire set of slots that isn&apos;t a problem, but it is for single offers.  Anyway, its still solvable, just more bookkeeping and more complex change.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;But often for Spark, you have one job running alone, in which case delay scheduling should arguably be turned of altogether, as you suggested earlier Imran. But let&apos;s separate that discussion from this one, of how to make it work better.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah, you can see that earlier in the thread I was trying to figure out what the purpose of this was anyway ... I am going to be recommending folks to turn it off more often.  But even when you have just one job running at a time, this still matters for jobs with parallel stages in the DAG, eg. a join.  Fairness doesn&apos;t matter at all between the stages, but overall efficiency does.  If you turn delay scheduling off entirely, then whichever taskset comes first will get all the resources, rather than giving both a shot at local resources.  So I feel like the right recommendation is &lt;tt&gt;1ms&lt;/tt&gt;.  There is probably something else to fix and another jira here though I don&apos;t have a clear idea around it yet.&lt;/p&gt;

&lt;p&gt;I will keep thinking about your v2.  What you are proposing makes sense, but I worry that we continue to band-aid these situations where things are really bad, but we&apos;re still stuck with a system where the delay should really be closely tuned to the task length, otherwise there is a lot of inefficiency.  This wasted time isn&apos;t even tracked anywhere (its not included in &quot;scheduler delay&quot;), so users have no idea their hitting this.&lt;/p&gt;</comment>
                            <comment id="16225335" author="willshen" created="Mon, 30 Oct 2017 17:11:30 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=imranr&quot; class=&quot;user-hover&quot; rel=&quot;imranr&quot;&gt;imranr&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I came across this issue because it is marked as duplicated by &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-11460&quot; title=&quot;Locality waits should be based on task set creation time, not last launch time&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-11460&quot;&gt;&lt;del&gt;SPARK-11460&lt;/del&gt;&lt;/a&gt;. &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-11460&quot; title=&quot;Locality waits should be based on task set creation time, not last launch time&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-11460&quot;&gt;&lt;del&gt;SPARK-11460&lt;/del&gt;&lt;/a&gt; has affected versions of 1.0.0, 1.0.1, 1.0.2, 1.1.0, 1.1.1, 1.2.0, 1.2.1, 1.2.2, 1.3.0, 1.3.1, 1.4.0, 1.4.1, 1.5.0, 1.5.1, and this issue has affected version of 2.1.0. Do we know if this is also an issue for 1.6.0? I am observing similar behavior for our application in 1.6.0. We are also able to achieve better utilization of the executors and performance through setting the wait to 0.&lt;/p&gt;

&lt;p&gt;Thank you&lt;/p&gt;</comment>
                            <comment id="16225412" author="irashid" created="Mon, 30 Oct 2017 17:48:34 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=willshen&quot; class=&quot;user-hover&quot; rel=&quot;willshen&quot;&gt;willshen&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I haven&apos;t looked closely, but I would expect this to also exist in 1.6.0.  Btw, due to &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-18967&quot; title=&quot;Locality preferences should be used when scheduling even when delay scheduling is turned off&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-18967&quot;&gt;&lt;del&gt;SPARK-18967&lt;/del&gt;&lt;/a&gt; (which I assume is also in 1.6.0, but again havne&apos;t looked closely), I would advise setting the wait to &lt;tt&gt;1ms&lt;/tt&gt;, not &lt;tt&gt;0&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="16987037" author="tgraves" created="Tue, 3 Dec 2019 16:06:05 +0000"  >&lt;p&gt;Note there is discussion on this subject on prs:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/spark/pull/26633&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/26633&lt;/a&gt; (hack to work around it for a particular RDD)&lt;/p&gt;

&lt;p&gt;PR with proposed solution - but really more discussion solution:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/spark/pull/26696&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/26696&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;My proposal I believe is similar to Kay&apos;s where we use slots and track the delay per slot.&#160; I haven&apos;t looked at the code in specific detail, especially in the FairScheduler where most of the issues in the conversations above were mentioned.&#160; One way around this is we have different policies and allow users to configure, or have one for FairScheduler and one for fifo.&lt;/p&gt;</comment>
                            <comment id="16987633" author="nmarcott" created="Wed, 4 Dec 2019 08:05:53 +0000"  >&lt;p&gt;Thanks for mentioning the PRs here.&lt;/p&gt;

&lt;p&gt;My proposed solution in the second &lt;a href=&quot;https://github.com/apache/spark/pull/26696&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;PR mentioned above&lt;/a&gt;&#160;is what I believe Kay said was ideal in comments of this &lt;a href=&quot;https://github.com/apache/spark/pull/9433&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;PR&lt;/a&gt;,&#160;but seemed to think was impractical.&#160;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The proposed solution:&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Currently the time window that locality wait times are measuring is the time since the last task launched for a TSM. The proposed change is to instead measure the time since this TSM&apos;s available slots were fully utilized.&lt;/p&gt;

&lt;p&gt;The number of available slots for a TSM can be determined by dividing all slots among the TSMs according to the scheduling policy (FIFO vs FAIR).&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Other possible solutions and their issues:&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Never reset timer: delay scheduling would likely only work on first wave*&lt;/li&gt;
	&lt;li&gt;Per slot timer: delay scheduling should apply per task/taskset, otherwise, timers started by one taskset could cause delay scheduling to be ignored for the next taskset, &#160;which might lead you to try approach #3&lt;/li&gt;
	&lt;li&gt;Per slot per stage timer: tasks can be starved by being offered unique slots over a period of time. Possibly a taskset or other job that doesn&apos;t care about locality would use those resources. &#160;Also too many timers/bookkeeping&lt;/li&gt;
	&lt;li&gt;Per task timer: you still need a way to distinguish between when a task is waiting for a slot to become available vs it has them available but is not utilizing them (which is what this PR does). To do this right seems to be this PR + more timers.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;*wave = one round of running as many tasks as there are available slots for a taskset. imagine you have 2 slots and 10 tasks. it would take 10 / 2 = 5 waves to complete the taskset&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12909778">SPARK-11460</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13222815">SPARK-27214</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 49 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i37ngn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>