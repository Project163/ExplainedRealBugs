<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:56:52 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-22443] AggregatedDialect doesn&apos;t override quoteIdentifier and other methods in JdbcDialects</title>
                <link>https://issues.apache.org/jira/browse/SPARK-22443</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;The AggregatedDialect only implements canHandle, getCatalystType, getJDBCType. It doesn&apos;t implement other methods in JdbcDialect. &lt;br/&gt;
So if multiple Dialects are registered with the same driver, the implementation of these methods will not be taken and the default implementation in JdbcDialect will be used.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; example

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.Properties

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.spark.sql.SparkSession
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.spark.sql.jdbc.{JdbcDialect, JdbcDialects}
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.spark.sql.types.{DataType, MetadataBuilder}

object AnotherMySQLDialect &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; JdbcDialect {
  override def canHandle(url : &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;): &lt;span class=&quot;code-object&quot;&gt;Boolean&lt;/span&gt; = url.startsWith(&lt;span class=&quot;code-quote&quot;&gt;&quot;jdbc:mysql&quot;&lt;/span&gt;)

  override def getCatalystType(
                                sqlType: Int, typeName: &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, size: Int, md: MetadataBuilder): Option[DataType] = {
    None
  }

  override def quoteIdentifier(colName: &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;): &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; = {
    s&lt;span class=&quot;code-quote&quot;&gt;&quot;`$colName`&quot;&lt;/span&gt;
  }
}

object App {
  def main(args: Array[&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;]) {
    val spark = SparkSession.builder.master(&lt;span class=&quot;code-quote&quot;&gt;&quot;local&quot;&lt;/span&gt;).appName(&lt;span class=&quot;code-quote&quot;&gt;&quot;Simple Application&quot;&lt;/span&gt;).getOrCreate()
    JdbcDialects.registerDialect(AnotherMySQLDialect)
    val jdbcUrl = s&lt;span class=&quot;code-quote&quot;&gt;&quot;jdbc:mysql:&lt;span class=&quot;code-comment&quot;&gt;//host:port/db?user=user&amp;amp;password=password&quot;&lt;/span&gt;
&lt;/span&gt;    spark.read.jdbc(jdbcUrl, &lt;span class=&quot;code-quote&quot;&gt;&quot;badge&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Properties()).show()
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;will throw an exception. &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
17/11/03 17:08:39 ERROR Executor: Exception in task 0.0 in stage 0.0 (TID 0)
java.sql.SQLDataException: Cannot determine value type from string &apos;id&apos;
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:530)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:513)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:505)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:479)
	at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:489)
	at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:89)
	at com.mysql.cj.jdbc.result.ResultSetImpl.getLong(ResultSetImpl.java:853)
	at org.apache.spark.sql.execution.datasources.jdbc.JdbcUtils$$anonfun$org$apache$spark$sql$execution$datasources$jdbc$JdbcUtils$$makeGetter$8.apply(JdbcUtils.scala:409)
	at org.apache.spark.sql.execution.datasources.jdbc.JdbcUtils$$anonfun$org$apache$spark$sql$execution$datasources$jdbc$JdbcUtils$$makeGetter$8.apply(JdbcUtils.scala:408)
	at org.apache.spark.sql.execution.datasources.jdbc.JdbcUtils$$anon$1.getNext(JdbcUtils.scala:330)
	at org.apache.spark.sql.execution.datasources.jdbc.JdbcUtils$$anon$1.getNext(JdbcUtils.scala:312)
	at org.apache.spark.util.NextIterator.hasNext(NextIterator.scala:73)
	at org.apache.spark.InterruptibleIterator.hasNext(InterruptibleIterator.scala:37)
	at org.apache.spark.util.CompletionIterator.hasNext(CompletionIterator.scala:32)
	at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIterator.processNext(Unknown Source)
	at org.apache.spark.sql.execution.BufferedRowIterator.hasNext(BufferedRowIterator.java:43)
	at org.apache.spark.sql.execution.WholeStageCodegenExec$$anonfun$8$$anon$1.hasNext(WholeStageCodegenExec.scala:395)
	at org.apache.spark.sql.execution.SparkPlan$$anonfun$2.apply(SparkPlan.scala:234)
	at org.apache.spark.sql.execution.SparkPlan$$anonfun$2.apply(SparkPlan.scala:228)
	at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:827)
	at org.apache.spark.rdd.RDD$$anonfun$mapPartitionsInternal$1$$anonfun$apply$25.apply(RDD.scala:827)
	at org.apache.spark.rdd.MapPartitionsRDD.compute(MapPartitionsRDD.scala:38)
	at org.apache.spark.rdd.RDD.computeOrReadCheckpoint(RDD.scala:323)
	at org.apache.spark.rdd.RDD.iterator(RDD.scala:287)
	at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87)
	at org.apache.spark.scheduler.Task.run(Task.scala:108)
	at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:335)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: com.mysql.cj.core.exceptions.DataConversionException: Cannot determine value type from string &apos;id&apos;
	at com.mysql.cj.core.io.StringConverter.createFromBytes(StringConverter.java:121)
	at com.mysql.cj.core.io.MysqlTextValueDecoder.decodeByteArray(MysqlTextValueDecoder.java:232)
	at com.mysql.cj.mysqla.result.AbstractResultsetRow.decodeAndCreateReturnValue(AbstractResultsetRow.java:124)
	at com.mysql.cj.mysqla.result.AbstractResultsetRow.getValueFromBytes(AbstractResultsetRow.java:225)
	at com.mysql.cj.mysqla.result.ByteArrayRow.getValue(ByteArrayRow.java:84)
	at com.mysql.cj.jdbc.result.ResultSetImpl.getNonStringValueFromRow(ResultSetImpl.java:630)
	... 24 more
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Though the quoteIdentifier is correctly implemented in Spark&apos;s MySQLDialect and our AnotherMySQLDialect.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13116060">SPARK-22443</key>
            <summary>AggregatedDialect doesn&apos;t override quoteIdentifier and other methods in JdbcDialects</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="huaxing">Huaxin Gao</assignee>
                                    <reporter username="liuhb86">Hongbo</reporter>
                        <labels>
                    </labels>
                <created>Fri, 3 Nov 2017 21:24:23 +0000</created>
                <updated>Sun, 5 Nov 2017 06:14:44 +0000</updated>
                            <resolved>Sun, 5 Nov 2017 06:10:00 +0000</resolved>
                                    <version>2.2.0</version>
                                    <fixVersion>2.3.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16238482" author="srowen" created="Fri, 3 Nov 2017 22:16:08 +0000"  >&lt;p&gt;Good catch. I suppose that this and getTableExistsQuery and getSchemaQuery need to return the value from the first dialect?&lt;/p&gt;</comment>
                            <comment id="16238858" author="apachespark" created="Sat, 4 Nov 2017 09:15:04 +0000"  >&lt;p&gt;User &apos;huaxingao&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/19658&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/19658&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16239097" author="liuhb86" created="Sat, 4 Nov 2017 16:50:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=srowen&quot; class=&quot;user-hover&quot; rel=&quot;srowen&quot;&gt;srowen&lt;/a&gt; Thanks for the quick response!&lt;/p&gt;

&lt;p&gt;I think returning the first dialect is an acceptable solution. But I was wondering whether it could be better?&lt;/p&gt;

&lt;p&gt;Suppose the first dialect doesn&apos;t override,  e.g., the quoteIdentifier method, but the second dialect overrides it. Naturally, using the implementation in the second dialect is better.  But in the current implementation, it will use the default implementation in the base JdbcDialect class.&lt;/p&gt;

&lt;p&gt;Maybe we can derive new dialects from another base class which returns null(I hate null, but wrap with Option will change external API) for the string methods? And in AggregatedDialect, it can return the first non-null result. If all the dialects return null, then it returns the default implementation in NoopDialect (the trivial concrete object derived from JdbcDialect).&lt;/p&gt;

&lt;p&gt;Just my two cents.&lt;/p&gt;</comment>
                            <comment id="16239133" author="srowen" created="Sat, 4 Nov 2017 17:57:27 +0000"  >&lt;p&gt;The semantics here are already odd. The methods might return values from different implementations already, and there&apos;s no reason to expect they&apos;re consistent or compatible. There&apos;s also not a way to know if a method is overridden (short of reflection).&lt;/p&gt;

&lt;p&gt;I&apos;m not actually sure what the use case is for this, but assume it intends to wrap a dialect, with another dialect as fallback. If so, it makes sense to prefer the first dialect&apos;s value, as it&apos;s also the first implementation that returns a non-None value, always.&lt;/p&gt;

&lt;p&gt;Returning the first non-null value seems reasonable too, OK.&lt;/p&gt;</comment>
                            <comment id="16239312" author="liuhb86" created="Sat, 4 Nov 2017 22:56:52 +0000"  >&lt;p&gt;In our case, we want to map MySQL YEAR to ShortType instead of DateType. Ideally, I&apos;d like to write a custom dialect by overriding the getCatalystType method. But it doesn&apos;t work because it breaks the quoteIdentifier implemented in the predefined MySQLDialect.&lt;/p&gt;

&lt;p&gt;We have a workaround. The custom dialect needs to override all other methods and redirect to the implementation in MySQLDialect. Then we unregister MySQLDialect and register our custom dialect. It&apos;s not robust because if there are new methods added to JdbcDialect in the future, it may break again.&lt;/p&gt;</comment>
                            <comment id="16239418" author="smilegator" created="Sun, 5 Nov 2017 06:14:44 +0000"  >&lt;p&gt;It sounds your custom dialect is a good solution for your scenario. You can customize it based on your requirement.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 2 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3mdxb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>