<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:56:46 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-17788] RangePartitioner results in few very large tasks and many small to empty tasks </title>
                <link>https://issues.apache.org/jira/browse/SPARK-17788</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;Greetings everyone,&lt;/p&gt;

&lt;p&gt;I was trying to read a single field of a Hive table stored as Parquet in Spark (~140GB for the entire table, this single field is a Double, ~1.4B records) and look at the sorted output using the following:&lt;br/&gt;
sql(&quot;SELECT &quot; + field + &quot; FROM MY_TABLE ORDER BY &quot; + field + &quot; DESC&quot;) &lt;br/&gt;
&#8203;But this simple line of code gives:&lt;br/&gt;
Caused by: java.lang.IllegalArgumentException: Cannot allocate a page with more than 17179869176 bytes&lt;/p&gt;

&lt;p&gt;Same error for:&lt;br/&gt;
sql(&quot;SELECT &quot; + field + &quot; FROM MY_TABLE).sort(field)&lt;br/&gt;
and:&lt;br/&gt;
sql(&quot;SELECT &quot; + field + &quot; FROM MY_TABLE).orderBy(field)&lt;/p&gt;

&lt;p&gt;After doing some searching, the issue seems to lie in the RangePartitioner trying to create equal ranges. &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;https://spark.apache.org/docs/2.0.0/api/java/org/apache/spark/RangePartitioner.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://spark.apache.org/docs/2.0.0/api/java/org/apache/spark/RangePartitioner.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt; The Double values I&apos;m trying to sort are mostly in the range &lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt; (~70% of the data which roughly equates 1 billion records), other numbers in the dataset are as high as 2000. With the RangePartitioner trying to create equal ranges, some tasks are becoming almost empty while others are extremely large, due to the heavily skewed distribution. &lt;/p&gt;

&lt;p&gt;This is either a bug in Apache Spark or a major limitation of the framework. I hope one of the devs can help solve this issue.&lt;/p&gt;

&lt;p&gt;P.S. Email thread on Spark user mailing list:&lt;br/&gt;
&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/spark-user/201610.mbox/%3CCA%2B_of14hTVYTUHXC%3DmS9Kqd6qegVvkoF-ry3Yj2%2BRT%2BWSBNzhg%40mail.gmail.com%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://mail-archives.apache.org/mod_mbox/spark-user/201610.mbox/%3CCA%2B_of14hTVYTUHXC%3DmS9Kqd6qegVvkoF-ry3Yj2%2BRT%2BWSBNzhg%40mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;</description>
                <environment>&lt;p&gt;Ubuntu 14.04 64bit&lt;br/&gt;
Java 1.8.0_101&lt;/p&gt;</environment>
        <key id="13009924">SPARK-17788</key>
            <summary>RangePartitioner results in few very large tasks and many small to empty tasks </summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cloud_fan">Wenchen Fan</assignee>
                                    <reporter username="babak.alipour@gmail.com">Babak Alipour</reporter>
                        <labels>
                    </labels>
                <created>Wed, 5 Oct 2016 17:17:44 +0000</created>
                <updated>Wed, 6 Dec 2017 14:57:41 +0000</updated>
                            <resolved>Mon, 30 Oct 2017 16:59:44 +0000</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>2.3.0</fixVersion>
                                    <component>Spark Core</component>
                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                                                                <comments>
                            <comment id="15656549" author="cloud_fan" created="Fri, 11 Nov 2016 08:53:44 +0000"  >&lt;p&gt;can you provide the full stacktrace? thanks!&lt;/p&gt;</comment>
                            <comment id="15664035" author="babak.alipour@gmail.com" created="Mon, 14 Nov 2016 14:15:05 +0000"  >&lt;p&gt;The details were in the email thread.&lt;br/&gt;
Here&apos;s the full stack trace: &lt;/p&gt;

&lt;p&gt;Caused by: java.lang.IllegalArgumentException: Cannot allocate a page with more than 17179869176 bytes&lt;br/&gt;
        at org.apache.spark.memory.TaskMemoryManager.allocatePage(TaskMemoryManager.java:241)&lt;br/&gt;
        at org.apache.spark.memory.MemoryConsumer.allocatePage(MemoryConsumer.java:121)&lt;br/&gt;
        at org.apache.spark.util.collection.unsafe.sort.UnsafeExternalSorter.acquireNewPageIfNecessary(UnsafeExternalSorter.java:374)&lt;br/&gt;
        at org.apache.spark.util.collection.unsafe.sort.UnsafeExternalSorter.insertRecord(UnsafeExternalSorter.java:396)&lt;br/&gt;
        at org.apache.spark.sql.execution.UnsafeExternalRowSorter.insertRow(UnsafeExternalRowSorter.java:94)&lt;br/&gt;
        at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIterator.sort_addToSorter$(Unknown Source)&lt;br/&gt;
        at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIterator.agg_doAggregateWithoutKey$(Unknown Source)&lt;br/&gt;
        at org.apache.spark.sql.catalyst.expressions.GeneratedClass$GeneratedIterator.processNext(Unknown Source)&lt;br/&gt;
        at org.apache.spark.sql.execution.BufferedRowIterator.hasNext(BufferedRowIterator.java:43)&lt;br/&gt;
        at org.apache.spark.sql.execution.WholeStageCodegenExec$$anonfun$8$$anon$1.hasNext(WholeStageCodegenExec.scala:370)&lt;br/&gt;
        at scala.collection.Iterator$$anon$11.hasNext(Iterator.scala:408)&lt;br/&gt;
        at org.apache.spark.shuffle.sort.BypassMergeSortShuffleWriter.write(BypassMergeSortShuffleWriter.java:125)&lt;br/&gt;
        at org.apache.spark.scheduler.ShuffleMapTask.runTask(ShuffleMapTask.scala:79)&lt;br/&gt;
        at org.apache.spark.scheduler.ShuffleMapTask.runTask(ShuffleMapTask.scala:47)&lt;br/&gt;
        at org.apache.spark.scheduler.Task.run(Task.scala:85)&lt;br/&gt;
        at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:274)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)&lt;br/&gt;
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:745)&lt;/p&gt;</comment>
                            <comment id="15695956" author="holdenk" created="Fri, 25 Nov 2016 14:14:00 +0000"  >&lt;p&gt;This is semi-expected behaviour of the range partitioner (and really all Spark partitioners) don&apos;t support creating a split on the same key (e.g. 70% of your data has the same key and you are partitioning on that key 70% of that day is going to end up in the same partition).&lt;/p&gt;

&lt;p&gt;We could try and fix this in a few ways - either by having Spark SQL do something special in this case or having Spark&apos;s sortBy automatically add &quot;noise&quot; to the key when the sampling indicates there is too much data for a given key or allowing partitioners to be non-determinstic and updating the general sortBy logic in Spark.&lt;/p&gt;

&lt;p&gt;I think this would be something good for us to consider - but it&apos;s probably going to take awhile (and certainly not in time for 2.1.0).&lt;/p&gt;</comment>
                            <comment id="15696134" author="hvanhovell" created="Fri, 25 Nov 2016 15:37:20 +0000"  >&lt;p&gt;Spark makes a sketch of your data as soon when you want to order the entire dataset. Based on that sketch Spark tries to create equally sized partitions. As &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=holdenk&quot; class=&quot;user-hover&quot; rel=&quot;holdenk&quot;&gt;holdenk&lt;/a&gt; said, your problem is caused by skew (a lot of rows with the same key), and none of the current partitioning schemes can help you with this. On the short run, you could follow her suggestion and add noise to the order (this only works for global ordering and not for joins/aggregation with skewed values). On the long run, there is an ongoing effort to reduce skew for joining, see &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-9862&quot; title=&quot;Join: Handling data skew&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-9862&quot;&gt;&lt;del&gt;SPARK-9862&lt;/del&gt;&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;I have created the follow little spark program to illustrate how range partitioning works:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;import org.apache.spark.sql.Row

// Set the partitions and parallelism to relatively low value so we can read the results.
spark.conf.set(&quot;spark.default.parallelism&quot;, &quot;20&quot;)
spark.conf.set(&quot;spark.sql.shuffle.partitions&quot;, &quot;20&quot;)

// Create a skewed data frame.
val df = spark
  .range(10000000)
  .select(
    $&quot;id&quot;,
    (rand(34) * when($&quot;id&quot; % 10 &amp;lt;= 7, lit(1.0)).otherwise(lit(10.0))).as(&quot;value&quot;))

// Make a summary per partition. The partition intervals should not overlap and the number of
// elements in a partition should roughly be the same for all partitions.
case class PartitionSummary(count: Long, min: Double, max: Double, range: Double)
val res = df.orderBy($&quot;value&quot;).mapPartitions { iterator =&amp;gt;
  val (count, min, max) = iterator.foldLeft((0L, Double.PositiveInfinity, Double.NegativeInfinity)) {
    case ((count, min, max), Row(_, value: Double)) =&amp;gt;
      (count + 1L, Math.min(min, value), Math.max(max, value))
  }
  Iterator.single(PartitionSummary(count, min, max, max - min))
}

// Get results and make them look nice
res.orderBy($&quot;min&quot;)
  .select($&quot;count&quot;, $&quot;min&quot;.cast(&quot;decimal(5,3)&quot;), $&quot;max&quot;.cast(&quot;decimal(5,3)&quot;), $&quot;range&quot;.cast(&quot;decimal(5,3)&quot;))
  .show(30)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This yields the following results (notice how the partition range varies and the row count is relatively similar):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;+------+-----+------+-----+                                                     
| count|  min|   max|range|
+------+-----+------+-----+
|484005|0.000| 0.059|0.059|
|426212|0.059| 0.111|0.052|
|381796|0.111| 0.157|0.047|
|519954|0.157| 0.221|0.063|
|496842|0.221| 0.281|0.061|
|539082|0.281| 0.347|0.066|
|516798|0.347| 0.410|0.063|
|558487|0.410| 0.478|0.068|
|419825|0.478| 0.529|0.051|
|402257|0.529| 0.578|0.049|
|557225|0.578| 0.646|0.068|
|518626|0.646| 0.710|0.063|
|611478|0.710| 0.784|0.075|
|544556|0.784| 0.851|0.066|
|454356|0.851| 0.906|0.055|
|450535|0.906| 0.961|0.055|
|575996|0.961| 2.290|1.329|
|525915|2.290| 4.920|2.630|
|518757|4.920| 7.510|2.590|
|497298|7.510|10.000|2.490|
+------+-----+------+-----+
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15696154" author="hvanhovell" created="Fri, 25 Nov 2016 15:49:38 +0000"  >&lt;p&gt;I am closing this one as a duplicate. Feel free to reopen if you disagree.&lt;/p&gt;</comment>
                            <comment id="15696188" author="holdenk" created="Fri, 25 Nov 2016 16:05:22 +0000"  >&lt;p&gt;I don&apos;t think this is a duplicate - its related but a join doesn&apos;t necessarily use a range partitioner and sortBy is a different operation. I agree the potential solution could share a lot the same underlying implementation.&lt;/p&gt;</comment>
                            <comment id="15696190" author="holdenk" created="Fri, 25 Nov 2016 16:05:55 +0000"  >&lt;p&gt;This is somewhat distinct from the join case, but certainly related.&lt;/p&gt;</comment>
                            <comment id="15696321" author="hvanhovell" created="Fri, 25 Nov 2016 17:09:04 +0000"  >&lt;p&gt;That is fair. The solution is not that straightforward TBH:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Always add some kind of tie breaking value to the range. This could be random, but I&apos;d rather add something like monotonically_increasing_id(). This always incurs some cost.&lt;/li&gt;
	&lt;li&gt;Only add a tie-breaker when the you have (suspect) skew. Here we need to add some heavy hitter algorithm, which is potentially much more resource intensive than reservoir sampling. The other thing is that when we suspect skew, we would need to scan the data again (which would make the total of scans 3).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So I would be slightly in favor of option 1 and a flag to disable it.&lt;/p&gt;</comment>
                            <comment id="15698037" author="cloud_fan" created="Sat, 26 Nov 2016 14:44:48 +0000"  >&lt;p&gt;Should we investigate this?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Caused by: java.lang.IllegalArgumentException: Cannot allocate a page with more than 17179869176 bytes
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Although some partitions can be very large, but Spark should be able to process it(slowly), instead of throwing exception.&lt;/p&gt;</comment>
                            <comment id="15699276" author="cloud_fan" created="Sun, 27 Nov 2016 08:10:21 +0000"  >&lt;p&gt;After looking at the code, it seems the only way to trigger this exception is setting `spark.buffer.pageSize` to a value larger than `((1L &amp;lt;&amp;lt; 31) - 1) * 8L`, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=babak.alipour%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;babak.alipour@gmail.com&quot;&gt;babak.alipour@gmail.com&lt;/a&gt; did you set this conf?&lt;/p&gt;</comment>
                            <comment id="15700013" author="babak.alipour@gmail.com" created="Sun, 27 Nov 2016 17:14:51 +0000"  >&lt;p&gt;No, I didn&apos;t change that conf. I did try to change `spark.executor.memory` to various values ranging from 8g to 64g; nothing changes and I get the same exception. &lt;/p&gt;</comment>
                            <comment id="15700440" author="hvanhovell" created="Sun, 27 Nov 2016 22:48:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=babak.alipour%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;babak.alipour@gmail.com&quot;&gt;babak.alipour@gmail.com&lt;/a&gt; A few questions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Is it possible to get a reproducible piece of code?&lt;/li&gt;
	&lt;li&gt;Could you give us the value of the &lt;tt&gt;spark.buffer.pageSize&lt;/tt&gt; configuration property? When we allocate the memory for a new record we try to allocate either the page size (which is a Long value) or the size of the record (which is an Int value). The size of the page is larger than the maximum integer value, so this implies the page size is set at a very high value.&lt;/li&gt;
	&lt;li&gt;I am also quite surprised why this is not spilling. Could you give us the value of the &lt;tt&gt;spark.shuffle.spill.numElementsForceSpillThreshold&lt;/tt&gt; configuration property? What is the average row size?&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="16223837" author="apachespark" created="Sun, 29 Oct 2017 04:29:04 +0000"  >&lt;p&gt;User &apos;cloud-fan&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/18251&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/18251&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16225316" author="cloud_fan" created="Mon, 30 Oct 2017 17:02:08 +0000"  >&lt;p&gt;Unfortunately I don&apos;t have a reproducible code snippet to prove it has been fixed, but I&apos;m pretty confident my fix should work for it. cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=babak.alipour%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;babak.alipour@gmail.com&quot;&gt;babak.alipour@gmail.com&lt;/a&gt; please reopen this ticket if you still hit this issue, thanks!&lt;/p&gt;</comment>
                            <comment id="16280271" author="sesshomurai" created="Wed, 6 Dec 2017 14:57:13 +0000"  >&lt;p&gt;I&apos;m also running into this error on spark 2.1.0&lt;br/&gt;
: org.apache.spark.SparkException: Job aborted due to stage failure: Task 42 in stage 11.0 failed 4 times, most recent failure: Lost task 42.3 in stage 11.0 (TID 7544,xxx.xxx.xxx.xxx.xx, executor 2): java.lang.IllegalArgumentException: Cannot allocate a page with more than 17179869176 bytes&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="12855444">SPARK-9862</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 49 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i34hc7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>