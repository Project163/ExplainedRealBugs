<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:23:19 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-5388] Provide a stable application submission gateway in standalone cluster mode</title>
                <link>https://issues.apache.org/jira/browse/SPARK-5388</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;The existing submission gateway in standalone mode is not compatible across Spark versions. If you have a newer version of Spark submitting to an older version of the standalone Master, it is currently not guaranteed to work. The goal is to provide a stable REST interface to replace this channel.&lt;/p&gt;

&lt;p&gt;For more detail, please see the most recent design doc attached.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12769723">SPARK-5388</key>
            <summary>Provide a stable application submission gateway in standalone cluster mode</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="andrewor14">Andrew Or</assignee>
                                    <reporter username="andrewor14">Andrew Or</reporter>
                        <labels>
                    </labels>
                <created>Fri, 23 Jan 2015 19:16:01 +0000</created>
                <updated>Thu, 14 Jul 2016 08:18:51 +0000</updated>
                            <resolved>Fri, 6 Feb 2015 23:57:35 +0000</resolved>
                                    <version>1.2.0</version>
                                    <fixVersion>1.3.0</fixVersion>
                                    <component>Spark Core</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>18</watches>
                                                                                                                <comments>
                            <comment id="14290847" author="tigerquoll" created="Sat, 24 Jan 2015 22:06:35 +0000"  >&lt;p&gt;Hi Andrew,&lt;br/&gt;
I think the idea is well worth considering. &lt;/p&gt;

&lt;p&gt;I have a question if there is an intention for other entities (such as job servers) to communicate with the master at all? If so then the proposed gateway is semantically defined at a fairly low level (just RPC over JSON/HTTP). This is fine if the interface is not going to be exposed to anybody who is not a spark developer with detailed knowledge of spark internals. Did you use the term &#8220;REST&#8221; to simply mean RPC over JSON/HTTP?&lt;/p&gt;

&lt;p&gt;Creating a REST interface is more then a HTTP RPC gateway. If the interface is going to be exposed to 3rd parties (such as developers of Job servers and web notebooks etc) then there is a benefit to simplifying some of the exposed application semantics, and exposing an API that is more integrated with HTTP&#8217;s protocol semantics which most people are already familiar with - this is what a true REST interface does and if you are defining an endpoint for others to use it is a very powerful concept that allows other people to quickly grasp how to properly use the exposed interface.&lt;/p&gt;

&lt;p&gt;A rough sketch of a more &#8220;REST&#8221;ed version of the API would be:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Submit_driver_request&lt;/b&gt;&lt;br/&gt;
HTTP POST JSON body of request &lt;a href=&quot;http://host:port/SparkMaster?SubmitDriver&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://host:port/SparkMaster?SubmitDriver&lt;/a&gt;&lt;br/&gt;
Responds with standard HTTP Response including allocated DRIVER_ID if driver submission ok, http error codes with spark specific error if not.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Get status of DRIVER&lt;/b&gt;&lt;br/&gt;
HTTP GET &lt;a href=&quot;http://host:port/SparkMaster/Drivers/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://host:port/SparkMaster/Drivers/&lt;/a&gt;&amp;lt;DRIVER_ID&amp;gt;&lt;br/&gt;
Responds with JSON body containing information on driver execution.  If no record of driver_id, then http error code 404 (Not found) returned.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Kill Driver request&lt;/b&gt;&lt;br/&gt;
HTTP DELETE &lt;a href=&quot;http://host:port/SparkMaster/Drivers/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://host:port/SparkMaster/Drivers/&lt;/a&gt;&amp;lt;DRIVER_ID&amp;gt;&lt;br/&gt;
Responds with JSON body containing information on driver kill request, or http error code if an error occurs.&lt;/p&gt;

&lt;p&gt;I would be happy to prototype something like this up to test the concept out for you if you are looking for something more than just RPC over JSON/HTTP.&lt;/p&gt;
</comment>
                            <comment id="14292866" author="apachespark" created="Tue, 27 Jan 2015 02:26:57 +0000"  >&lt;p&gt;User &apos;andrewor14&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/4216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/4216&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14292874" author="andrewor14" created="Tue, 27 Jan 2015 02:33:12 +0000"  >&lt;p&gt;Hi Dale, thank you for your comments. Yes, in the design doc I used REST roughly interchangeably with HTTP/JSON. But the goal is not to provide a mechanism for other entities to communicate with the Master as you suggested; it is simply to provide a stable mechanism for Spark to work across multiple versions. For instance, you might have a long-running Master that outlives multiple Spark versions, in which case we want to guarantee that newer versions of Spark will still be able to submit to the long-running Master.&lt;/p&gt;

&lt;p&gt;I think your proposal to make this more REST-like is potentially a great idea. However, I find the alternative of simply putting the action in the JSON itself easier to reason about. This also allows us to add other messages in the future that are not strictly limited to the semantics of GET, POST, and DELETE. That said, my proposal is also not set in stone yet so if there is a reason compelling enough to change it then I will do so.&lt;/p&gt;

&lt;p&gt;Also, a first-cut implementation of my design is now posted at: &lt;a href=&quot;https://github.com/apache/spark/pull/4216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/4216&lt;/a&gt;. Please take a look if you feel inclined.&lt;/p&gt;</comment>
                            <comment id="14296068" author="vanzin" created="Wed, 28 Jan 2015 23:42:06 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=andrewor14&quot; class=&quot;user-hover&quot; rel=&quot;andrewor14&quot;&gt;andrewor14&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I read through the spec and the protocol specification seems to be lacking some details. The mains things that bother me are:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It&apos;s not really a REST API. There&apos;s a single endpoint to which you POST different messages. This sort of forces your hand to use a custom implementation, instead of being able to use a much nicer framework for this purpose such as JAX-RS. Using a framework like that can later benefit other parts of Spark too, such as providing a REST API for application data through the web ui / history server. And as I mentioned in the PR, it allows you to define the endpoints using classes or interfaces, which serves two purposes: it allows you to do backwards compatibility checks with tools like MIMA, and it allows you to use the client functionality of JAX-RS for client requests too (and similar tools for other languages for those who, sort of feeding back into Dale&apos;s comment). Plus, you can use things like Jackson and not care about how to parse or generate JSON.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;It&apos;s unclear how the protocol will be allowed to evolve. What happens when you add a new field or message in a later version, and that version tries to submit to Spark 1.3? Is there a version negotiation up front, so that the new client knows to use the old protocol if possible, or does the client just send the new message and the server will complain if it contains things it doesn&apos;t understand?&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The latter kinda feeds into the first comment. With a proper REST-based API, you&apos;d put the first version of the protocol under &quot;/v1&quot;, for example. Later versions are added under &quot;/v2&quot; and can add new things. Client and server can then negotiate up front (e.g, client needs at least version &quot;x&quot; for the current app, asks the server for its supported versions, and complains if &quot;x&quot; is not there).&lt;/p&gt;

&lt;p&gt;Also, it could be more specific about how errors are reported. Do you get specific HTTP error codes for different things? Is there an &quot;Error&quot; type that is sent back to the client in JSON, and if so, what fields does it have?&lt;/p&gt;</comment>
                            <comment id="14302006" author="pwendell" created="Mon, 2 Feb 2015 21:57:20 +0000"  >&lt;p&gt;Hey &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vanzin&quot; class=&quot;user-hover&quot; rel=&quot;vanzin&quot;&gt;vanzin&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tigerquoll&quot; class=&quot;user-hover&quot; rel=&quot;tigerquoll&quot;&gt;tigerquoll&lt;/a&gt;, the original goal of this was just to provide a stable API between the spark-submit and the standalone master, similar to what YARN has. And a simple JSON/REST API was something that is easy to support in the long term.&lt;/p&gt;

&lt;p&gt;In terms of using more of the standard web services conventions for the HTTP method (i.e. using GET, POST, and DELETE), I agree that would be nicer if it&apos;s not too hard to do. It be mostly for clarity though rather than correctness, this isn&apos;t something where we expect things like caching of responses, etc, which depend on strict interpretation of the HTTP method.&lt;/p&gt;

&lt;p&gt;In terms of versioning, the original proposal has the client and server communicate versions, so the idea is that compatibility could be handled on that basis, and that all older versions would be supported (hence this being a stable API). For web services API&apos;s they sometimes have &quot;v1&quot;, &quot;v2&quot; labels at the URL path. However, this type of versioning implies breakage of older versions, which is exactly what we want to avoid, right? For instance if github adds new fields to a return type (in a way that is backward compatible), I&apos;m assuming they don&apos;t increment the version identifier, right? I think the idea here is similar to our handling of the event logs, we want to make sure we support older versions by only increasing what is communicated over time, and having the server gracefully handle older clients. So I&apos;m not totally sure what the &quot;v2&quot; style labeling would help with unless we actually think we are going to break this API in a way that&apos;s not backwards compatible.&lt;/p&gt;

&lt;p&gt;All that said, maybe we could add &quot;v1&quot; here just as a hedge in cases this is ever changed (e.g. in Spark 2.0) and we do end up having third party integrations that write against this API. Just wanted to be clear on what the intention was in terms of when we&apos;d change it.&lt;/p&gt;</comment>
                            <comment id="14303702" author="vanzin" created="Tue, 3 Feb 2015 18:22:26 +0000"  >&lt;p&gt;HI &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pwendell&quot; class=&quot;user-hover&quot; rel=&quot;pwendell&quot;&gt;pwendell&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Let me try to write a point-by-point feedback for the current spec.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;Publicprotocolornot%3F&quot;&gt;&lt;/a&gt;Public protocol or not?&lt;/h4&gt;

&lt;p&gt;If this is not supposed to be public (i.e., we don&apos;t expect someone to try to directly try to talk to the Spark master, it&apos;s always going to happen through the Spark libraries), then the underlying protocol is less important, since we only care about different versions being compatible in some way.&lt;/p&gt;

&lt;p&gt;Assuming a non-public protocol, my question would be: why implement your own RPC framework? Why not reuse something that&apos;s already there? For example, Avro has a stable serialization infrastructure that defines semantics for versioned data, and works well on top of HTTP. If handles serialization and dispatching - which would remove a lot of code from the current patch, and probably has other features that the current, &quot;cluster-mode&quot; only protocol doesn&apos;t need but other future uses might.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;Nonsubmissionuses&quot;&gt;&lt;/a&gt;Non-submission uses&lt;/h4&gt;

&lt;p&gt;Similarly, in the non-public protocol scenario, a proper REST-based API would look like overkill. But a proper REST infrastructure provides interesting room for growth of the master&apos;s public-facing API. For example, you could easily expose an endpoint for listing the current applications being tracked by the master, or an endpoint to kill an application. The former could benefit, also, the history server, which could expose the same API to list the applications it has found.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;EvolvabilityandVersioning&quot;&gt;&lt;/a&gt;Evolvability and Versioning&lt;/h4&gt;

&lt;p&gt;The current spec does not specify the behavior of the cluster nor the client with regards to different versions of the protocol. It has a table that basically says &quot;future versions need to be able to submit standalone cluster applications to a 1.3 master&quot;, but it doesn&apos;t explain what that means or how that happens.&lt;/p&gt;

&lt;p&gt;Does it mean that, after 1.3, you can&apos;t ever change any of the messages used to launch a standalone cluster app, nor can you add new messages? Or, if that&apos;s allowed, what happens on the server side if it sees a field it doesn&apos;t understand? Does it ignore it, which could potentially break the application being submitted? Does it throw an error, in which case the client should make sure to submit an older version of the data structures if that&apos;s compatible with the app being submitted? If the latter, how does it know which version to use?&lt;/p&gt;

&lt;p&gt;As an example of how you could do this &quot;negotiation&quot;: the client checks what features the app being submitted needs, and chooses the oldest supported api version based on that. It then can submit the request to, e.g., &quot;/v2&quot; and, if submitting to a 1.3 cluster, it will fail, because it doesn&apos;t support the features needed by that app.&lt;/p&gt;

&lt;p&gt;Also, thinking about the framework, what if later you need different features than the ones provided now? What if you need to use query params, path params, or non-json request bodies (e.g. for uploading files)? Are you gonna extend the current framework to the point where it starts looking like other existing ones?&lt;/p&gt;

&lt;p&gt;Of, if HTTP is being used mostly as a dumb pipe, what are the semantics for when something goes wrong? Should clients only bother about a response if the status is &quot;200 OK&quot;, or should they try to interpret the body of a &quot;500 Internal Server Error&quot; message or &quot;401 Bad Request&quot;? Those things need to be specified.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;Others&quot;&gt;&lt;/a&gt;Others&lt;/h4&gt;

&lt;p&gt;If the suggestions above don&apos;t sound particularly interesting for this use case, I&apos;d strongly suggest, in the very least, removing any mention of REST from the spec and the code, because this is not a REST protocol in any way.&lt;/p&gt;

&lt;p&gt;Also, a question: if it&apos;s an HTTP protocol, why not expose it through the existing http port?&lt;/p&gt;


&lt;p&gt;To reply to the questions about my suggestions for how to use REST:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;when you add a new version, you don&apos;t remove old ones. Spark v1.4 could add &quot;/v2&quot;, but it must still support &quot;/v1&quot; in the way that it was specified.&lt;/li&gt;
	&lt;li&gt;as for new fields / types, that really depends on how you specify things. Personally, I like to declare a released API &quot;frozen&quot;: you can&apos;t add new types, fields, or anything that the old release doesn&apos;t know about. Any new thing requires a new protocol version. But you could take a different approach, by adding optional fields that don&apos;t cause breakages when submitted to the old server that doesn&apos;t know about them. Again, these choices need to be specified up front, otherwise the implementation of v1 becomes the spec, since where the spec is not clear, the choices made by the implementation will become a de facto specification.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(BTW, especially with a v1, the implementation will invariably become a &quot;de facto&quot; specification, that&apos;s unavoidable. But it helps to have the spec clearly cover all areas, so that hopefully you don&apos;t need to reverse-engineer the implementation code to figure out how things work.)&lt;/p&gt;

&lt;p&gt;Anyway, hope this is useful and clarifies some of the concerns I have about the current spec.&lt;/p&gt;</comment>
                            <comment id="14304010" author="pwendell" created="Tue, 3 Feb 2015 21:17:14 +0000"  >&lt;p&gt;The intention for this is really just to take single RPC that was using Akka and add a stable version of it that we are okay supporting long term. It doesn&apos;t preclude moving to avro or some other RPC as a general thing we use across all of Spark. However, that design choice was intentionally excluded from this decision given all the complexities you bring up. Doing some basic message dispatching on our own - there is only a small and very straightforward code related to this. Adopting Avro would be overkill for this.&lt;/p&gt;

&lt;p&gt;In the current implementation the client and server exchange Spark versions, so this is the basis of reasoning about version changes - maybe it wasn&apos;t in the design doc. In terms of evolvability, the way you do this is that you only add new functionality over time, and you never remove fields from messages. This is similar to the API contract of the history logs with the history server. So the idea is that newer clients would implement a super set of messages and fields as older ones.&lt;/p&gt;

&lt;p&gt;Adding v1 seems like a good idea in case this evolves into something public or more well specified over time. It would just be good to define precisely what it means to advance that version identifier. That all matters a lot more if we want it to be something others interact with.&lt;/p&gt;</comment>
                            <comment id="14304052" author="vanzin" created="Tue, 3 Feb 2015 21:36:02 +0000"  >&lt;p&gt;Hi Patrick,&lt;/p&gt;

&lt;p&gt;Most of my questions are related to the protocol specification attached to this bug. So when I ask about something, I generally mean that the specification is vague about that. If the implementation made a choice about that thing, it just means that the implementation should be the specification, and everybody should just ignore the document attached to this bug. And we can then move the discussion to the PR itself.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The intention for this is really just to take single RPC that was using Akka and add a stable version of it that we are okay supporting long term. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s fine, but I&apos;d really like the spec to actually be very clear about what this means. For example, the very last sentence:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;n. This set of fields must remain compatible across Spark version&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;See my previous comment, where I asked the same question: what does that mean? Does that mean that you can never add any fields to existing messages? You mention the code does some version negotiation, but the spec doesn&apos;t mention that. So maybe that negotiation is the answer to my question?&lt;/p&gt;

&lt;p&gt;Anyway, I&apos;m just a little concerned that there&apos;s still some vagueness in the spec, for a protocol that is supposed to be stable from the get go.&lt;/p&gt;
</comment>
                            <comment id="14306552" author="andrewor14" created="Thu, 5 Feb 2015 03:01:45 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vanzin&quot; class=&quot;user-hover&quot; rel=&quot;vanzin&quot;&gt;vanzin&lt;/a&gt;, thank you for all of your comments. I agree with many of the points that you raised and have addressed them in the PR. I&apos;d just like to clarify, in case there is any confusion, that this is intended to be an internal submission gateway only for standalone cluster mode. This is in no way expected to interface with third party applications or intended to be a stable alternative to Spark submit across all cluster managers and deploy modes&lt;/p&gt;

&lt;p&gt;For this reason, the protocol has very few core requirements, the most important of which, backward and forward compatibility, is sufficiently handled by using any stable RPC framework. It&apos;s just so that we chose a HTTP/JSON-based design because it is the simplest one that fulfills this requirement. The initial design did not adhere closely to conventions commonly used by other REST protocols because this was not strictly necessary to achieve the compatibility guarantees we wanted to provide. Not to mention there is not really a formal W3C-style REST specification, and many existing REST protocols out there (e.g. twitter, flickr, github) actually diverge widely in terms of the extent to which they adherence to these vaguely-defined conventions.&lt;/p&gt;

&lt;p&gt;That said, I agree completely that the initial design doc was vague. I have updated it by expanding in much greater detail on things like how the server responds to different error conditions and how versioning is handled. Please have a look and let me know if you have any other concerns.&lt;/p&gt;</comment>
                            <comment id="14306899" author="tigerquoll" created="Thu, 5 Feb 2015 09:24:01 +0000"  >&lt;p&gt;Heh Andrew, definitely starting to look a bit more Rest-like in the protocol!&lt;/p&gt;

&lt;p&gt;Http Delete should be used for your kill request - it is considered best practice&lt;/p&gt;

&lt;p&gt;The primary resource you are dealing with is a submission - this should form the base of your url structure.&lt;br/&gt;
For a rest protocol, actions/verbs are used to affect these resources - so they are mapped to to the HTTP operations of GET/POST/DELETE/HEAD/OPTIONS etc, against the resources defined by the full url.&lt;/p&gt;

&lt;p&gt;Full URLs serve to identify the resources that these actions are performed on. GET/DELETE are used where the full identity of the resource is known at the time of generating the request, POST is used when you may not know the address of the resource at the time of generating the request (eg When submitting a program to run, you will not know submission id because it is returned by the request)&lt;/p&gt;

&lt;p&gt;So, taking this into account:&lt;br/&gt;
RequestSubmitDriver &#8594; POST /submission/create&lt;br/&gt;
RequestKillDriver &#8594; DELETE /submission/&lt;span class=&quot;error&quot;&gt;&amp;#91;submissionId&amp;#93;&lt;/span&gt;&lt;br/&gt;
RequestDriverStatus &#8594; GET /submission/&lt;span class=&quot;error&quot;&gt;&amp;#91;submissionId&amp;#93;&lt;/span&gt;/status  - The resource is the submission, so the current status of the submission in a sub-resource of the submission, other sub entries such as &lt;br/&gt;
/submission/&lt;span class=&quot;error&quot;&gt;&amp;#91;submissionId&amp;#93;&lt;/span&gt;/performanceCounters &lt;br/&gt;
could be added in the future without affecting existing clients.&lt;/p&gt;

</comment>
                            <comment id="14308260" author="vanzin" created="Thu, 5 Feb 2015 23:40:19 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=andrewor14&quot; class=&quot;user-hover&quot; rel=&quot;andrewor14&quot;&gt;andrewor14&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Thanks for updating the spec! This one looks much, much better. I think most of my concerns have been addressed. Adherence to &quot;RESTfulness&quot; is not super important since this is an internal API, although I really would suggest picking a better name for the Scala package (e.g. &quot;org.apache.spark.deploy.proto&quot; or something, instead of &quot;rest&quot;).&lt;/p&gt;

&lt;p&gt;A few questions:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;is the &quot;action&quot; field required? Since you have different URIs handling different messages, it seems redundant now. And responses having an &quot;action&quot; is kinda weird.&lt;/li&gt;
	&lt;li&gt;what is the &quot;protocolVersion&quot; field in ErrorResponse? From the spec, it sounds like the maximum protocol version supported by the server. If that&apos;s the case, can the property be renamed to &quot;maxProtocolVersion&quot;?&lt;/li&gt;
	&lt;li&gt;the message definitions use strings for all data, is that intentional? It would feel more natural to have proper types, e.g.: &quot;jars&quot; : [ &quot;one.jar&quot;, &quot;two.jar&quot; ], driverCores: 8, superviseDriver: false.&lt;/li&gt;
	&lt;li&gt;The spec says the server should report unknown fields back to the client. There&apos;s nothing in the response type that supports that; is the server expected to embed that information in the &quot;message&quot; field? Feels like it would be better to have an explicit field for that.&lt;/li&gt;
	&lt;li&gt;Is the &quot;kill&quot; endpoint protected in any way? Right now it seems like anyone can post to that and kill a driver, if they know (or guess) the submission ID. If there&apos;s no special protection, I&apos;d say in the spec that the submission ID should be, at least, cryptographically secure. At that point, as long as the server has SSL enabled, it should be hard enough to kill a random driver.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14308263" author="vanzin" created="Thu, 5 Feb 2015 23:42:06 +0000"  >&lt;p&gt;Also, a fun fact about the Jersey dependency. Here&apos;s an excerpt of the output of &quot;mvn dependency:tree&quot; for the yarn module:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;[INFO] +- org.apache.hadoop:hadoop-yarn-common:jar:2.4.0:compile
[INFO] |  +- javax.xml.bind:jaxb-api:jar:2.2.2:compile
[INFO] |  |  +- javax.xml.stream:stax-api:jar:1.0-2:compile
[INFO] |  |  \- javax.activation:activation:jar:1.1:compile
[INFO] |  +- org.apache.commons:commons-compress:jar:1.4.1:compile
[INFO] |  |  \- org.tukaani:xz:jar:1.0:compile
[INFO] |  +- commons-codec:commons-codec:jar:1.5:compile
[INFO] |  +- com.sun.jersey:jersey-core:jar:1.9:compile
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14308598" author="andrewor14" created="Fri, 6 Feb 2015 04:43:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tigerquoll&quot; class=&quot;user-hover&quot; rel=&quot;tigerquoll&quot;&gt;tigerquoll&lt;/a&gt; I still don&apos;t think we should use DELETE for kill for the following reason. In normal REST servers that host static resources, if you GET after a DELETE, you run into a 404. Here, our resources are by no means static, and if you GET after a DELETE you actually get a different status (that your driver is now KILLED instead of RUNNING) instead. Because of these side-effects I think it is safest to use POST.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vanzin&quot; class=&quot;user-hover&quot; rel=&quot;vanzin&quot;&gt;vanzin&lt;/a&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The action field is actually required especially since many of the responses look quite alike. We need to know how to deserialize the messages safely in case the response we get from the server is not the type that we expect it to be (e.g. ErrorResponse).&lt;/li&gt;
	&lt;li&gt;Yes, I could rename the protocolVersion field.&lt;/li&gt;
	&lt;li&gt;The issue with having non-String types is that you will need to deal with numeric and boolean values specially. For instance, if the user does not explicitly set the field there is no easy way to not include it in the JSON without doing some Option hack. I went down that route and opted out for simpler code.&lt;/li&gt;
	&lt;li&gt;The unknown fields reporting is added in the PR but is missing in the spec. In the PR it is reported in its own explicit field.&lt;/li&gt;
	&lt;li&gt;Even in the existing interface you can use o.a.s.deploy.Client to kill an application, and the security guarantees there are the same. I agree that it is something we need to address that at some point, but I prefer to keep that outside the scope of this patch.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="14308599" author="andrewor14" created="Fri, 6 Feb 2015 04:47:44 +0000"  >&lt;p&gt;By the way for the more specific comments it would be good if you can leave them on the PR itself: &lt;a href=&quot;https://github.com/apache/spark/pull/4216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/4216&lt;/a&gt;. The specs and the actual code will diverge after some review so the most up-to-date version will likely be there.&lt;/p&gt;</comment>
                            <comment id="14308635" author="pwendell" created="Fri, 6 Feb 2015 05:18:42 +0000"  >&lt;p&gt;I think it&apos;s reasonable to use DELETE per &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=tigerquoll&quot; class=&quot;user-hover&quot; rel=&quot;tigerquoll&quot;&gt;tigerquoll&lt;/a&gt;&apos;s suggestion. It&apos;s not a perfect match with DELETE semantics, but I think it&apos;s fine to use it if it&apos;s not too much work. I also think calling it maxProtocolVersion is a good idea if those are indeed the semantics. For security, yeah the killing is the same as it is in the current mode, which is that there is no security. One thing we could do if there is user demand is add a flag that globally disables killing, but let&apos;s see if users request this first.&lt;/p&gt;</comment>
                            <comment id="14309600" author="vanzin" created="Fri, 6 Feb 2015 18:42:10 +0000"  >&lt;p&gt;I kinda agree with Andrew regarding delete. You&apos;re not deleting the submission, you&apos;re killing it. It will still exist afterwards, in a different state.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The action field is actually required especially since many of the responses look quite alike. We need to know how to deserialize the messages&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I thought each endpoint could only return a single type. So the handler for a particular endpoint knows what the types of the request / response are without having to include that information in the JSON payload itself.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;The issue with having non-String types is that you will need to deal with numeric and boolean values specially.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;tt&gt;java.lang.Boolean&lt;/tt&gt;, &lt;tt&gt;java.lang.Long&lt;/tt&gt; and friends are nullable. Another reason why I like to use POJOs (instead of Scala classes) when using Jackson.&lt;/p&gt;</comment>
                            <comment id="14309784" author="pwendell" created="Fri, 6 Feb 2015 20:06:00 +0000"  >&lt;p&gt;On DELETE, I&apos;ll defer to you guys, have zero strong feelings either way.&lt;/p&gt;</comment>
                            <comment id="14309825" author="pwendell" created="Fri, 6 Feb 2015 20:23:21 +0000"  >&lt;p&gt;One the boolean and numeric values. I don&apos;t mind one way or the other how they are handled programmatically (since we are not exposing this). However, it does seem weird that in the wire protocol defines these as string types. I looked at a few other API&apos;s, Github, Twitter, etc and they all use proper boolean types. So I&apos;d definitely recommend setting them as proper types in the JSON, and if that&apos;s easier to do by making them nullable Boolean and Long values, seems like a good approach.&lt;/p&gt;</comment>
                            <comment id="14310076" author="andrewor14" created="Fri, 6 Feb 2015 22:40:12 +0000"  >&lt;p&gt;Great nullable booleans and numbers are all I&apos;m looking for. Thanks.&lt;/p&gt;</comment>
                            <comment id="14517546" author="jeromatron" created="Tue, 28 Apr 2015 18:07:00 +0000"  >&lt;p&gt;Would people be amenable to having additional features for this such as a shared context and others described in &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-818&quot; title=&quot;Design Spark Job Server&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-818&quot;&gt;&lt;del&gt;SPARK-818&lt;/del&gt;&lt;/a&gt; done by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=velvia&quot; class=&quot;user-hover&quot; rel=&quot;velvia&quot;&gt;velvia&lt;/a&gt;?&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12989240">SPARK-16532</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12696651" name="stable-spark-submit-in-standalone-mode-2-4-15.pdf" size="394926" author="andrewor14" created="Thu, 5 Feb 2015 02:34:00 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 30 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i24ql3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310320" key="com.atlassian.jira.plugin.system.customfieldtypes:multiversion">
                        <customfieldname>Target Version/s</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="12327642">1.3.0</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>