<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 19:03:10 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-26352] Join reordering should not change the order of output attributes</title>
                <link>https://issues.apache.org/jira/browse/SPARK-26352</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;The optimizer rule &lt;tt&gt;org.apache.spark.sql.catalyst.optimizer.ReorderJoin&lt;/tt&gt; performs join reordering on inner joins. This was introduced from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-12032&quot; title=&quot;Filter can&amp;#39;t be pushed down to correct Join because of bad order of Join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-12032&quot;&gt;&lt;del&gt;SPARK-12032&lt;/del&gt;&lt;/a&gt; in 2015-12.&lt;/p&gt;

&lt;p&gt;After it had reordered the joins, though, it didn&apos;t check whether or not the column order (in terms of the &lt;tt&gt;output&lt;/tt&gt; attribute list) is still the same as before. Thus, it&apos;s possible to have a mismatch between the reordered column order vs the schema that a DataFrame thinks it has.&lt;/p&gt;

&lt;p&gt;This can be demonstrated with the example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
spark.sql(&quot;create table table_a (x int, y int) using parquet&quot;)
spark.sql(&quot;create table table_b (i int, j int) using parquet&quot;)
spark.sql(&quot;create table table_c (a int, b int) using parquet&quot;)
val df = spark.sql(&quot;with df1 as (select * from table_a cross join table_b) select * from df1 join table_c on a = x and b = i&quot;)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;here&apos;s what the DataFrame thinks:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
scala&amp;gt; df.printSchema
root
 |-- x: integer (nullable = true)
 |-- y: integer (nullable = true)
 |-- i: integer (nullable = true)
 |-- j: integer (nullable = true)
 |-- a: integer (nullable = true)
 |-- b: integer (nullable = true)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;here&apos;s what the optimized plan thinks, after join reordering:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
scala&amp;gt; df.queryExecution.optimizedPlan.output.foreach(a =&amp;gt; println(s&quot;|-- ${a.name}: ${a.dataType.typeName}&quot;))
|-- x: integer
|-- y: integer
|-- a: integer
|-- b: integer
|-- i: integer
|-- j: integer
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we exclude the &lt;tt&gt;ReorderJoin&lt;/tt&gt; rule (using Spark 2.4&apos;s optimizer rule exclusion feature), it&apos;s back to normal:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-none&quot;&gt;
scala&amp;gt; spark.conf.set(&quot;spark.sql.optimizer.excludedRules&quot;, &quot;org.apache.spark.sql.catalyst.optimizer.ReorderJoin&quot;)

scala&amp;gt; val df = spark.sql(&quot;with df1 as (select * from table_a cross join table_b) select * from df1 join table_c on a = x and b = i&quot;)
df: org.apache.spark.sql.DataFrame = [x: int, y: int ... 4 more fields]

scala&amp;gt; df.queryExecution.optimizedPlan.output.foreach(a =&amp;gt; println(s&quot;|-- ${a.name}: ${a.dataType.typeName}&quot;))
|-- x: integer
|-- y: integer
|-- i: integer
|-- j: integer
|-- a: integer
|-- b: integer
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that this column ordering problem leads to data corruption, and can manifest itself in various symptoms:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Silently corrupting data, if the reordered columns happen to either have matching types or have sufficiently-compatible types (e.g. all fixed length primitive types are considered as &quot;sufficiently compatible&quot; in an UnsafeRow), then only the resulting data is going to be wrong but it might not trigger any alarms immediately. Or&lt;/li&gt;
	&lt;li&gt;Weird Java-level exceptions like &lt;tt&gt;java.lang.NegativeArraySizeException&lt;/tt&gt;, or even SIGSEGVs.&lt;/li&gt;
&lt;/ul&gt;
</description>
                <environment></environment>
        <key id="13204131">SPARK-26352</key>
            <summary>Join reordering should not change the order of output attributes</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rednaxelafx">Kris Mok</assignee>
                                    <reporter username="rednaxelafx">Kris Mok</reporter>
                        <labels>
                            <label>correctness</label>
                    </labels>
                <created>Thu, 13 Dec 2018 01:17:39 +0000</created>
                <updated>Fri, 29 May 2020 11:03:46 +0000</updated>
                            <resolved>Mon, 17 Dec 2018 05:52:12 +0000</resolved>
                                    <version>2.2.0</version>
                    <version>2.3.0</version>
                    <version>2.4.0</version>
                                    <fixVersion>2.3.3</fixVersion>
                    <fixVersion>2.4.1</fixVersion>
                    <fixVersion>3.0.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16719620" author="githubbot" created="Thu, 13 Dec 2018 01:22:49 +0000"  >&lt;p&gt;rednaxelafx opened a new pull request #23303: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt; ReorderJoin should not change the order of columns&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23303&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What changes were proposed in this pull request?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   The optimizer rule `org.apache.spark.sql.catalyst.optimizer.ReorderJoin` performs join reordering on inner joins. This was introduced from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-12032&quot; title=&quot;Filter can&amp;#39;t be pushed down to correct Join because of bad order of Join&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-12032&quot;&gt;&lt;del&gt;SPARK-12032&lt;/del&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/apache/spark/pull/10073&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/10073&lt;/a&gt;) in 2015-12.&lt;/p&gt;

&lt;p&gt;   After it had reordered the joins, though, it didn&apos;t check whether or not the column order (in terms of the `output` attribute list) is still the same as before. Thus, it&apos;s possible to have a mismatch between the reordered column order vs the schema that a DataFrame thinks it has.&lt;/p&gt;

&lt;p&gt;   This can be demonstrated with the example:&lt;br/&gt;
   ```scala&lt;br/&gt;
   spark.sql(&quot;create table table_a (x int, y int) using parquet&quot;)&lt;br/&gt;
   spark.sql(&quot;create table table_b (i int, j int) using parquet&quot;)&lt;br/&gt;
   spark.sql(&quot;create table table_c (a int, b int) using parquet&quot;)&lt;br/&gt;
   val df = spark.sql(&quot;&quot;&quot;&lt;br/&gt;
     with df1 as (select * from table_a cross join table_b)&lt;br/&gt;
     select * from df1 join table_c on a = x and b = i&lt;br/&gt;
   &quot;&quot;&quot;)&lt;br/&gt;
   ```&lt;br/&gt;
   here&apos;s what the DataFrame thinks:&lt;br/&gt;
   ```&lt;br/&gt;
   scala&amp;gt; df.printSchema&lt;br/&gt;
   root&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; x: integer (nullable = true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; y: integer (nullable = true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; i: integer (nullable = true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; j: integer (nullable = true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; a: integer (nullable = true)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; b: integer (nullable = true)&lt;br/&gt;
   ```&lt;br/&gt;
   here&apos;s what the optimized plan thinks, after join reordering:&lt;br/&gt;
   ```&lt;br/&gt;
   scala&amp;gt; df.queryExecution.optimizedPlan.output.foreach(a =&amp;gt; println(s&quot;&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; ${a.name}: ${a.dataType.typeName}&quot;))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; x: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; y: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; a: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; b: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; i: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; j: integer&lt;br/&gt;
   ```&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;   If we exclude the `ReorderJoin` rule (using Spark 2.4&apos;s optimizer rule exclusion feature), it&apos;s back to normal:&lt;br/&gt;
   ```&lt;br/&gt;
   scala&amp;gt; spark.conf.set(&quot;spark.sql.optimizer.excludedRules&quot;, &quot;org.apache.spark.sql.catalyst.optimizer.ReorderJoin&quot;)&lt;/p&gt;

&lt;p&gt;   scala&amp;gt; val df = spark.sql(&quot;with df1 as (select * from table_a cross join table_b) select * from df1 join table_c on a = x and b = i&quot;)&lt;br/&gt;
   df: org.apache.spark.sql.DataFrame = &lt;span class=&quot;error&quot;&gt;&amp;#91;x: int, y: int ... 4 more fields&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;   scala&amp;gt; df.queryExecution.optimizedPlan.output.foreach(a =&amp;gt; println(s&quot;|-- ${a.name}: ${a.dataType.typeName}&quot;))&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; x: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; y: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; i: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; j: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; a: integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;&amp;#8211; b: integer&lt;br/&gt;
   ```&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;   Note that this column ordering problem leads to data corruption, and can manifest itself in various symptoms:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Silently corrupting data, if the reordered columns happen to either have matching types or have sufficiently-compatible types (e.g. all fixed length primitive types are considered as &quot;sufficiently compatible&quot; in an `UnsafeRow`), then only the resulting data is going to be wrong but it might not trigger any alarms immediately. Or&lt;/li&gt;
	&lt;li&gt;Weird Java-level exceptions like `java.lang.NegativeArraySizeException`, or even SIGSEGVs.&lt;/li&gt;
&lt;/ul&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;How was this patch tested?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Added new unit test in `JoinReorderSuite` and new end-to-end test in `JoinSuite`.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16722697" author="githubbot" created="Mon, 17 Dec 2018 05:46:36 +0000"  >&lt;p&gt;asfgit closed pull request #23303: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt; join reorder should not change the order of output attributes&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23303&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/CostBasedJoinReorder.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/CostBasedJoinReorder.scala&lt;br/&gt;
index 064ca68b7a628..01634a9d852c6 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/CostBasedJoinReorder.scala&lt;br/&gt;
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/CostBasedJoinReorder.scala&lt;br/&gt;
@@ -48,6 +48,7 @@ object CostBasedJoinReorder extends Rule&lt;span class=&quot;error&quot;&gt;&amp;#91;LogicalPlan&amp;#93;&lt;/span&gt; with PredicateHelper &lt;/p&gt;
{
           if projectList.forall(_.isInstanceOf[Attribute]) =&amp;gt;
           reorder(p, p.output)
       }
&lt;p&gt;+&lt;br/&gt;
       // After reordering is finished, convert OrderedJoin back to Join&lt;br/&gt;
       result transformDown {&lt;br/&gt;
         case OrderedJoin(left, right, jt, cond) =&amp;gt; Join(left, right, jt, cond)&lt;br/&gt;
@@ -175,11 +176,20 @@ object JoinReorderDP extends PredicateHelper with Logging &lt;/p&gt;
{
         assert(topOutputSet == p.outputSet)
         // Keep the same order of final output attributes.
         p.copy(projectList = output)
+      case finalPlan if !sameOutput(finalPlan, output) =&amp;gt;
+        Project(output, finalPlan)
       case finalPlan =&amp;gt;
         finalPlan
     }
&lt;p&gt;   }&lt;/p&gt;

&lt;p&gt;+  private def sameOutput(plan: LogicalPlan, expectedOutput: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt;): Boolean = {&lt;br/&gt;
+    val thisOutput = plan.output&lt;br/&gt;
+    thisOutput.length == expectedOutput.length &amp;amp;&amp;amp; thisOutput.zip(expectedOutput).forall &lt;/p&gt;
{
+      case (a1, a2) =&amp;gt; a1.semanticEquals(a2)
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
   /** Find all possible plans at the next level, based on existing levels. */&lt;br/&gt;
   private def searchLevel(&lt;br/&gt;
       existingLevels: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;JoinPlanMap&amp;#93;&lt;/span&gt;,&lt;br/&gt;
diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
index 6ebb194d71c2e..0b6471289a471 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
@@ -86,9 +86,9 @@ object ReorderJoin extends Rule&lt;span class=&quot;error&quot;&gt;&amp;#91;LogicalPlan&amp;#93;&lt;/span&gt; with PredicateHelper {&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;   def apply(plan: LogicalPlan): LogicalPlan = plan transform {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;case ExtractFiltersAndInnerJoins(input, conditions)&lt;br/&gt;
+    case p @ ExtractFiltersAndInnerJoins(input, conditions)&lt;br/&gt;
         if input.size &amp;gt; 2 &amp;amp;&amp;amp; conditions.nonEmpty =&amp;gt;&lt;/li&gt;
	&lt;li&gt;if (SQLConf.get.starSchemaDetection &amp;amp;&amp;amp; !SQLConf.get.cboEnabled) {&lt;br/&gt;
+      val reordered = if (SQLConf.get.starSchemaDetection &amp;amp;&amp;amp; !SQLConf.get.cboEnabled) {&lt;br/&gt;
         val starJoinPlan = StarSchemaDetection.reorderStarJoins(input, conditions)&lt;br/&gt;
         if (starJoinPlan.nonEmpty) {&lt;br/&gt;
           val rest = input.filterNot(starJoinPlan.contains(_))&lt;br/&gt;
@@ -99,6 +99,14 @@ object ReorderJoin extends Rule&lt;span class=&quot;error&quot;&gt;&amp;#91;LogicalPlan&amp;#93;&lt;/span&gt; with PredicateHelper {&lt;br/&gt;
       } else 
{
         createOrderedJoin(input, conditions)
       }
&lt;p&gt;+&lt;br/&gt;
+      if (p.sameOutput(reordered)) &lt;/p&gt;
{
+        reordered
+      }
&lt;p&gt; else &lt;/p&gt;
{
+        // Reordering the joins have changed the order of the columns.
+        // Inject a projection to make sure we restore to the expected ordering.
+        Project(p.output, reordered)
+      }
&lt;p&gt;   }&lt;br/&gt;
 }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinOptimizationSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinOptimizationSuite.scala&lt;br/&gt;
index ccd9d8dd4d213..e9438b2eee550 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinOptimizationSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinOptimizationSuite.scala&lt;br/&gt;
@@ -102,16 +102,19 @@ class JoinOptimizationSuite extends PlanTest {&lt;br/&gt;
         x.join&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/thumbs_up.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.join(z).where((&quot;x.b&quot;.attr === &quot;z.b&quot;.attr) &amp;amp;&amp;amp; (&quot;y.d&quot;.attr === &quot;z.a&quot;.attr)),&lt;br/&gt;
         x.join(z, condition = Some(&quot;x.b&quot;.attr === &quot;z.b&quot;.attr))&lt;br/&gt;
           .join(y, condition = Some(&quot;y.d&quot;.attr === &quot;z.a&quot;.attr))&lt;br/&gt;
+          .select(Seq(&quot;x.a&quot;, &quot;x.b&quot;, &quot;x.c&quot;, &quot;y.d&quot;, &quot;z.a&quot;, &quot;z.b&quot;, &quot;z.c&quot;).map(_.attr): _*)&lt;br/&gt;
       ),&lt;br/&gt;
       (&lt;br/&gt;
         x.join(y, Cross).join(z, Cross)&lt;br/&gt;
           .where((&quot;x.b&quot;.attr === &quot;z.b&quot;.attr) &amp;amp;&amp;amp; (&quot;y.d&quot;.attr === &quot;z.a&quot;.attr)),&lt;br/&gt;
         x.join(z, Cross, Some(&quot;x.b&quot;.attr === &quot;z.b&quot;.attr))&lt;br/&gt;
           .join(y, Cross, Some(&quot;y.d&quot;.attr === &quot;z.a&quot;.attr))&lt;br/&gt;
+          .select(Seq(&quot;x.a&quot;, &quot;x.b&quot;, &quot;x.c&quot;, &quot;y.d&quot;, &quot;z.a&quot;, &quot;z.b&quot;, &quot;z.c&quot;).map(_.attr): _*)&lt;br/&gt;
       ),&lt;br/&gt;
       (&lt;br/&gt;
         x.join(y, Inner).join(z, Cross).where(&quot;x.b&quot;.attr === &quot;z.a&quot;.attr),&lt;br/&gt;
         x.join(z, Cross, Some(&quot;x.b&quot;.attr === &quot;z.a&quot;.attr)).join(y, Inner)&lt;br/&gt;
+          .select(Seq(&quot;x.a&quot;, &quot;x.b&quot;, &quot;x.c&quot;, &quot;y.d&quot;, &quot;z.a&quot;, &quot;z.b&quot;, &quot;z.c&quot;).map(_.attr): _*)&lt;br/&gt;
       )&lt;br/&gt;
     )&lt;/p&gt;

&lt;p&gt;diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
index 565b0a10154a8..c94a8b9e318f6 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
@@ -20,8 +20,8 @@ package org.apache.spark.sql.catalyst.optimizer&lt;br/&gt;
 import org.apache.spark.sql.catalyst.dsl.expressions._&lt;br/&gt;
 import org.apache.spark.sql.catalyst.dsl.plans._&lt;br/&gt;
 import org.apache.spark.sql.catalyst.expressions.&lt;/p&gt;
{Attribute, AttributeMap}
&lt;p&gt;-import org.apache.spark.sql.catalyst.plans.&lt;/p&gt;
{Inner, PlanTest}
&lt;p&gt;-import org.apache.spark.sql.catalyst.plans.logical.&lt;/p&gt;
{ColumnStat, LogicalPlan}
&lt;p&gt;+import org.apache.spark.sql.catalyst.plans.&lt;/p&gt;
{Cross, Inner, PlanTest}
&lt;p&gt;+import org.apache.spark.sql.catalyst.plans.logical.&lt;/p&gt;
{ColumnStat, LocalRelation, LogicalPlan}
&lt;p&gt; import org.apache.spark.sql.catalyst.rules.RuleExecutor&lt;br/&gt;
 import org.apache.spark.sql.catalyst.statsEstimation.&lt;/p&gt;
{StatsEstimationTestBase, StatsTestPlan}
&lt;p&gt; import org.apache.spark.sql.internal.SQLConf.&lt;/p&gt;
{CBO_ENABLED, JOIN_REORDER_ENABLED}
&lt;p&gt;@@ -124,7 +124,8 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase &lt;/p&gt;
{
     // the original order (t1 J t2) J t3.
     val bestPlan =
       t1.join(t3, Inner, Some(nameToAttr(&quot;t1.v-1-10&quot;) === nameToAttr(&quot;t3.v-1-100&quot;)))
-      .join(t2, Inner, Some(nameToAttr(&quot;t1.k-1-2&quot;) === nameToAttr(&quot;t2.k-1-5&quot;)))
+        .join(t2, Inner, Some(nameToAttr(&quot;t1.k-1-2&quot;) === nameToAttr(&quot;t2.k-1-5&quot;)))
+        .select(outputsOf(t1, t2, t3): _*)
 
     assertEqualPlans(originalPlan, bestPlan)
   }
&lt;p&gt;@@ -139,7 +140,9 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase &lt;/p&gt;
{
     val bestPlan =
       t1.join(t3, Inner, Some(nameToAttr(&quot;t1.v-1-10&quot;) === nameToAttr(&quot;t3.v-1-100&quot;)))
         .join(t2, Inner, Some(nameToAttr(&quot;t1.k-1-2&quot;) === nameToAttr(&quot;t2.k-1-5&quot;)))
+        .select(outputsOf(t1, t2, t3): _*) // this is redundant but we&apos;ll take it for now
         .join(t4)
+        .select(outputsOf(t1, t2, t4, t3): _*)
 
     assertEqualPlans(originalPlan, bestPlan)
   }
&lt;p&gt;@@ -202,6 +205,7 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase &lt;/p&gt;
{
       t1.join(t2, Inner, Some(nameToAttr(&quot;t1.k-1-2&quot;) === nameToAttr(&quot;t2.k-1-5&quot;)))
         .join(t4.join(t3, Inner, Some(nameToAttr(&quot;t4.v-1-10&quot;) === nameToAttr(&quot;t3.v-1-100&quot;))),
           Inner, Some(nameToAttr(&quot;t1.k-1-2&quot;) === nameToAttr(&quot;t4.k-1-2&quot;)))
+        .select(outputsOf(t1, t4, t2, t3): _*)
 
     assertEqualPlans(originalPlan, bestPlan)
   }
&lt;p&gt;@@ -219,6 +223,23 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  test(&quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;: join reordering should not change the order of attributes&quot;) &lt;/p&gt;
{
+    // This test case does not rely on CBO.
+    // It&apos;s similar to the test case above, but catches a reordering bug that the one above doesn&apos;t
+    val tab1 = LocalRelation(&apos;x.int, &apos;y.int)
+    val tab2 = LocalRelation(&apos;i.int, &apos;j.int)
+    val tab3 = LocalRelation(&apos;a.int, &apos;b.int)
+    val original =
+      tab1.join(tab2, Cross)
+          .join(tab3, Inner, Some(&apos;a === &apos;x &amp;amp;&amp;amp; &apos;b === &apos;i))
+    val expected =
+      tab1.join(tab3, Inner, Some(&apos;a === &apos;x))
+          .join(tab2, Cross, Some(&apos;b === &apos;i))
+          .select(outputsOf(tab1, tab2, tab3): _*)
+
+    assertEqualPlans(original, expected)
+  }
&lt;p&gt;+&lt;br/&gt;
   test(&quot;reorder recursively&quot;) {&lt;br/&gt;
     // Original order:&lt;br/&gt;
     //          Join&lt;br/&gt;
@@ -266,8 +287,17 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {&lt;br/&gt;
   private def assertEqualPlans(&lt;br/&gt;
       originalPlan: LogicalPlan,&lt;br/&gt;
       groundTruthBestPlan: LogicalPlan): Unit = &lt;/p&gt;
{
-    val optimized = Optimize.execute(originalPlan.analyze)
+    val analyzed = originalPlan.analyze
+    val optimized = Optimize.execute(analyzed)
     val expected = groundTruthBestPlan.analyze
+
+    assert(analyzed.sameOutput(expected)) // if this fails, the expected plan itself is incorrect
+    assert(analyzed.sameOutput(optimized))
+
     compareJoinOrder(optimized, expected)
   }
&lt;p&gt;+&lt;br/&gt;
+  private def outputsOf(plans: LogicalPlan*): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt; = &lt;/p&gt;
{
+    plans.map(_.output).reduce(_ ++ _)
+  }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinCostBasedReorderSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinCostBasedReorderSuite.scala&lt;br/&gt;
index d4d23ad69b2c2..baae934e1e4fe 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinCostBasedReorderSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinCostBasedReorderSuite.scala&lt;br/&gt;
@@ -218,6 +218,7 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
         .join(d1, Inner, Some(nameToAttr(&quot;f1_fk1&quot;) === nameToAttr(&quot;d1_pk&quot;)))&lt;br/&gt;
         .join(t2, Inner, Some(nameToAttr(&quot;f1_c2&quot;) === nameToAttr(&quot;t2_c1&quot;)))&lt;br/&gt;
         .join(t1, Inner, Some(nameToAttr(&quot;f1_c1&quot;) === nameToAttr(&quot;t1_c1&quot;)))&lt;br/&gt;
+        .select(outputsOf(f1, t1, t2, d1, d2): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
@@ -256,6 +257,7 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
         .join(t3.join(t2, Inner, Some(nameToAttr(&quot;t2_c2&quot;) === nameToAttr(&quot;t3_c1&quot;))), Inner,&lt;br/&gt;
           Some(nameToAttr(&quot;d1_c2&quot;) === nameToAttr(&quot;t2_c1&quot;)))&lt;br/&gt;
         .join(t1, Inner, Some(nameToAttr(&quot;t1_c1&quot;) === nameToAttr(&quot;f1_c1&quot;)))&lt;br/&gt;
+        .select(outputsOf(d1, t1, t2, f1, d2, t3): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
@@ -297,6 +299,7 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
           Some(nameToAttr(&quot;t3_c1&quot;) === nameToAttr(&quot;t4_c1&quot;)))&lt;br/&gt;
         .join(t1.join(t2, Inner, Some(nameToAttr(&quot;t1_c1&quot;) === nameToAttr(&quot;t2_c1&quot;))), Inner,&lt;br/&gt;
           Some(nameToAttr(&quot;t1_c2&quot;) === nameToAttr(&quot;t4_c2&quot;)))&lt;br/&gt;
+        .select(outputsOf(d1, t1, t2, t3, t4, f1, d2): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
@@ -347,6 +350,7 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
           Some(nameToAttr(&quot;d3_c2&quot;) === nameToAttr(&quot;t1_c1&quot;)))&lt;br/&gt;
         .join(t5.join(t6, Inner, Some(nameToAttr(&quot;t5_c2&quot;) === nameToAttr(&quot;t6_c2&quot;))), Inner,&lt;br/&gt;
           Some(nameToAttr(&quot;d2_c2&quot;) === nameToAttr(&quot;t5_c1&quot;)))&lt;br/&gt;
+        .select(outputsOf(d1, t3, t4, f1, d2, t5, t6, d3, t1, t2): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
@@ -375,6 +379,7 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
       f1.join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;d3_pk&quot;)))&lt;br/&gt;
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk&quot;)))&lt;br/&gt;
         .join(d1, Inner, Some(nameToAttr(&quot;f1_fk1&quot;) === nameToAttr(&quot;d1_pk&quot;)))&lt;br/&gt;
+        .select(outputsOf(d1, d2, f1, d3): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
@@ -400,13 +405,27 @@ class StarJoinCostBasedReorderSuite extends PlanTest with StatsEstimationTestBas&lt;br/&gt;
       f1.join(t3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;t3_c1&quot;)))&lt;br/&gt;
         .join(t2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;t2_c1&quot;)))&lt;br/&gt;
         .join(t1, Inner, Some(nameToAttr(&quot;f1_fk1&quot;) === nameToAttr(&quot;t1_c1&quot;)))&lt;br/&gt;
+        .select(outputsOf(t1, f1, t2, t3): _*)&lt;br/&gt;
 &lt;br/&gt;
     assertEqualPlans(query, expected)&lt;br/&gt;
   }&lt;br/&gt;
 &lt;br/&gt;
   private def assertEqualPlans( plan1: LogicalPlan, plan2: LogicalPlan): Unit = {
-    val optimized = Optimize.execute(plan1.analyze)
+    val analyzed = plan1.analyze
+    val optimized = Optimize.execute(analyzed)
     val expected = plan2.analyze
+
+    assert(equivalentOutput(analyzed, expected)) // if this fails, the expected itself is incorrect
+    assert(equivalentOutput(analyzed, optimized))
+
     compareJoinOrder(optimized, expected)
   }&lt;br/&gt;
+&lt;br/&gt;
+  private def outputsOf(plans: LogicalPlan*): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt; = {+    plans.map(_.output).reduce(_ ++ _)+  }
&lt;p&gt;+&lt;br/&gt;
+  private def equivalentOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = &lt;/p&gt;
{
+    normalizeExprIds(plan1).output == normalizeExprIds(plan2).output
+  }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinReorderSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinReorderSuite.scala&lt;br/&gt;
index 4e0883e91e84a..9dc653b9d6c44 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinReorderSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/StarJoinReorderSuite.scala&lt;br/&gt;
@@ -182,6 +182,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d1, Inner, Some(nameToAttr(&quot;f1_fk1&quot;) === nameToAttr(&quot;d1_pk1&quot;)))
         .join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;d3_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d2, f1, d3, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -220,6 +221,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;d3_pk1&quot;)))
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) &amp;lt; nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, f1, d2, s3, d3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -255,7 +257,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;s3_c2&quot;)))
-
+        .select(outputsOf(d1, f1, d2, s3, d3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -292,6 +294,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;d3_pk1&quot;)))
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_c2&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) &amp;lt; nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, f1, d2, s3, d3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -395,6 +398,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d2.where(nameToAttr(&quot;d2_c2&quot;) === 2), Inner,
           Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;f11_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, f11, f1, d2, s3): _*)
 
     assertEqualPlans(query, equivQuery)
   }&lt;br/&gt;
@@ -430,6 +434,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d2.where(nameToAttr(&quot;d2_c2&quot;) === 2), Inner,
           Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_c4&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d3, f1, d2, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -465,6 +470,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d2.where(nameToAttr(&quot;d2_c2&quot;) === 2), Inner,
           Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d3, f1, d2, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -499,6 +505,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d2.where(nameToAttr(&quot;d2_c2&quot;) === 2),
           Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d3, f1, d2, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -532,6 +539,7 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) &amp;lt; nameToAttr(&quot;d3_pk1&quot;)))
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) &amp;lt; nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) &amp;lt; nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d3, f1, d2, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
@@ -565,13 +573,27 @@ class StarJoinReorderSuite extends PlanTest with StatsEstimationTestBase {
         .join(d3, Inner, Some(nameToAttr(&quot;f1_fk3&quot;) === nameToAttr(&quot;d3_pk1&quot;)))
         .join(d2, Inner, Some(nameToAttr(&quot;f1_fk2&quot;) === nameToAttr(&quot;d2_pk1&quot;)))
         .join(s3, Inner, Some(nameToAttr(&quot;d3_fk1&quot;) === nameToAttr(&quot;s3_pk1&quot;)))
+        .select(outputsOf(d1, d3, f1, d2, s3): _*)
 
     assertEqualPlans(query, expected)
   }&lt;br/&gt;
 &lt;br/&gt;
-  private def assertEqualPlans( plan1: LogicalPlan, plan2: LogicalPlan): Unit = {&lt;br/&gt;
-    val optimized = Optimize.execute(plan1.analyze)&lt;br/&gt;
+  private def assertEqualPlans(plan1: LogicalPlan, plan2: LogicalPlan): Unit = {
+    val analyzed = plan1.analyze
+    val optimized = Optimize.execute(analyzed)
     val expected = plan2.analyze
+
+    assert(equivalentOutput(analyzed, expected)) // if this fails, the expected itself is incorrect
+    assert(equivalentOutput(analyzed, optimized))
+
     compareJoinOrder(optimized, expected)
   }&lt;br/&gt;
+&lt;br/&gt;
+  private def outputsOf(plans: LogicalPlan*): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt; = {
+    plans.map(_.output).reduce(_ ++ _)
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private def equivalentOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = {+    normalizeExprIds(plan1).output == normalizeExprIds(plan2).output+  }
&lt;p&gt; }&lt;br/&gt;
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/JoinSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/JoinSuite.scala&lt;br/&gt;
index aa2162c9d2cda..91445c8d96d85 100644&lt;br/&gt;
&amp;#8212; a/sql/core/src/test/scala/org/apache/spark/sql/JoinSuite.scala&lt;br/&gt;
+++ b/sql/core/src/test/scala/org/apache/spark/sql/JoinSuite.scala&lt;br/&gt;
@@ -895,4 +895,18 @@ class JoinSuite extends QueryTest with SharedSQLContext &lt;/p&gt;
{
       checkAnswer(res, Row(0, 0, 0))
     }
&lt;p&gt;   }&lt;br/&gt;
+&lt;br/&gt;
+  test(&quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;: join reordering should not change the order of columns&quot;) {&lt;br/&gt;
+    withTable(&quot;tab1&quot;, &quot;tab2&quot;, &quot;tab3&quot;) &lt;/p&gt;
{
+      spark.sql(&quot;select 1 as x, 100 as y&quot;).write.saveAsTable(&quot;tab1&quot;)
+      spark.sql(&quot;select 42 as i, 200 as j&quot;).write.saveAsTable(&quot;tab2&quot;)
+      spark.sql(&quot;select 1 as a, 42 as b&quot;).write.saveAsTable(&quot;tab3&quot;)
+
+      val df = spark.sql(&quot;&quot;&quot;
+        with tmp as (select * from tab1 cross join tab2)
+        select * from tmp join tab3 on a = x and b = i
+      &quot;&quot;&quot;)
+      checkAnswer(df, Row(1, 100, 42, 200, 1, 42))
+    }
&lt;p&gt;+  }&lt;br/&gt;
 }&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16722701" author="cloud_fan" created="Mon, 17 Dec 2018 05:52:12 +0000"  >&lt;p&gt;Issue resolved by pull request 23303&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/23303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23303&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16722730" author="githubbot" created="Mon, 17 Dec 2018 06:56:43 +0000"  >&lt;p&gt;rednaxelafx opened a new pull request #23330: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;FOLLOWUP-2.4&amp;#93;&lt;/span&gt; Fix missing sameOutput in branch-2.4&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23330&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What changes were proposed in this pull request?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   After &lt;a href=&quot;https://github.com/apache/spark/pull/23303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23303&lt;/a&gt; was merged to branch-2.3/2.4, the builds on those branches were broken due to missing a `LogicalPlan.sameOutput` function which came from &lt;a href=&quot;https://github.com/apache/spark/pull/22713&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/22713&lt;/a&gt; only available on master.&lt;/p&gt;

&lt;p&gt;   This PR is to follow-up with the broken 2.3/2.4 branches and make a copy of the new `LogicalPlan.sameOutput` into `ReorderJoin` to make it locally available.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;How was this patch tested?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Fix the build of 2.3/2.4.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16722779" author="githubbot" created="Mon, 17 Dec 2018 08:26:30 +0000"  >&lt;p&gt;rednaxelafx opened a new pull request #23333: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;FOLLOWUP-2.3&amp;#93;&lt;/span&gt; Fix missing sameOutput in branch-2.3&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23333&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23333&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;What changes were proposed in this pull request?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   This is the branch-2.3 equivalent of &lt;a href=&quot;https://github.com/apache/spark/pull/23330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23330&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;   After &lt;a href=&quot;https://github.com/apache/spark/pull/23303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23303&lt;/a&gt; was merged to branch-2.3/2.4, the builds on those branches were broken due to missing a `LogicalPlan.sameOutput` function which came from &lt;a href=&quot;https://github.com/apache/spark/pull/22713&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/22713&lt;/a&gt; only available on master.&lt;/p&gt;

&lt;p&gt;   This PR is to follow-up with the broken 2.3/2.4 branches and make a copy of the new `LogicalPlan.sameOutput` into `ReorderJoin` to make it locally available.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;How was this patch tested?&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;   Fix the build of 2.3/2.4.&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16723039" author="githubbot" created="Mon, 17 Dec 2018 14:55:19 +0000"  >&lt;p&gt;cloud-fan closed pull request #23330: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;FOLLOWUP-2.4&amp;#93;&lt;/span&gt; Fix missing sameOutput in branch-2.4&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23330&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
index 0b6471289a471..2feb4720f9f92 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
@@ -100,7 +100,7 @@ object ReorderJoin extends Rule&lt;span class=&quot;error&quot;&gt;&amp;#91;LogicalPlan&amp;#93;&lt;/span&gt; with PredicateHelper &lt;/p&gt;
{
         createOrderedJoin(input, conditions)
       }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (p.sameOutput(reordered)) {&lt;br/&gt;
+      if (sameOutput(p, reordered)) 
{
         reordered
       }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {         // Reordering the joins have changed the order of the columns.@@ -108,6 +108,21 @@ object ReorderJoin extends Rule[LogicalPlan] with PredicateHelper {
         Project(p.output, reordered)
       }   }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns true iff output of both plans are semantically the same, ie.:&lt;br/&gt;
+   *  - they contain the same number of `Attribute`s;&lt;br/&gt;
+   *  - references are the same;&lt;br/&gt;
+   *  - the order is equal too.&lt;br/&gt;
+   * NOTE: this is copied over from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-25691&quot; title=&quot;Analyzer rule &amp;quot;AliasViewChild&amp;quot; does not stabilize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-25691&quot;&gt;&lt;del&gt;SPARK-25691&lt;/del&gt;&lt;/a&gt; from master.&lt;br/&gt;
+   */&lt;br/&gt;
+  def sameOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+    val output1 = plan1.output+    val output2 = plan2.output+    output1.length == output2.length &amp;amp;&amp;amp; output1.zip(output2).forall {
+      case (a1, a2) =&amp;gt; a1.semanticEquals(a2)
+    }&lt;br/&gt;
+  }&lt;br/&gt;
 }&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
index c94a8b9e318f6..38a70f0691dd4 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
@@ -291,8 +291,8 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {
     val optimized = Optimize.execute(analyzed)
     val expected = groundTruthBestPlan.analyze
 
-    assert(analyzed.sameOutput(expected)) // if this fails, the expected plan itself is incorrect
-    assert(analyzed.sameOutput(optimized))
+    assert(sameOutput(analyzed, expected)) // if this fails, the expected plan itself is incorrect
+    assert(sameOutput(analyzed, optimized))
 
     compareJoinOrder(optimized, expected)
   }&lt;br/&gt;
@@ -300,4 +300,19 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {&lt;br/&gt;
   private def outputsOf(plans: LogicalPlan*): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt; = {
     plans.map(_.output).reduce(_ ++ _)
   }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns true iff output of both plans are semantically the same, ie.:&lt;br/&gt;
+   *  - they contain the same number of `Attribute`s;&lt;br/&gt;
+   *  - references are the same;&lt;br/&gt;
+   *  - the order is equal too.&lt;br/&gt;
+   * NOTE: this is copied over from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-25691&quot; title=&quot;Analyzer rule &amp;quot;AliasViewChild&amp;quot; does not stabilize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-25691&quot;&gt;&lt;del&gt;SPARK-25691&lt;/del&gt;&lt;/a&gt; from master.&lt;br/&gt;
+   */&lt;br/&gt;
+  def sameOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = {&lt;br/&gt;
+    val output1 = plan1.output&lt;br/&gt;
+    val output2 = plan2.output&lt;br/&gt;
+    output1.length == output2.length &amp;amp;&amp;amp; output1.zip(output2).forall {+      case (a1, a2) =&amp;gt; a1.semanticEquals(a2)+    }+  }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16723050" author="githubbot" created="Mon, 17 Dec 2018 15:01:29 +0000"  >&lt;p&gt;cloud-fan closed pull request #23333: &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-26352&quot; title=&quot;Join reordering should not change the order of output attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-26352&quot;&gt;&lt;del&gt;SPARK-26352&lt;/del&gt;&lt;/a&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;SQL&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;FOLLOWUP-2.3&amp;#93;&lt;/span&gt; Fix missing sameOutput in branch-2.3&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/spark/pull/23333&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/23333&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
index fedef68bf8513..503e20490a92c 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/joins.scala&lt;br/&gt;
@@ -99,7 +99,7 @@ object ReorderJoin extends Rule&lt;span class=&quot;error&quot;&gt;&amp;#91;LogicalPlan&amp;#93;&lt;/span&gt; with PredicateHelper &lt;/p&gt;
{
         createOrderedJoin(input, conditions)
       }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (p.sameOutput(reordered)) {&lt;br/&gt;
+      if (sameOutput(p, reordered)) 
{
         reordered
       }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {         // Reordering the joins have changed the order of the columns.@@ -107,6 +107,21 @@ object ReorderJoin extends Rule[LogicalPlan] with PredicateHelper {
         Project(p.output, reordered)
       }   }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns true iff output of both plans are semantically the same, ie.:&lt;br/&gt;
+   *  - they contain the same number of `Attribute`s;&lt;br/&gt;
+   *  - references are the same;&lt;br/&gt;
+   *  - the order is equal too.&lt;br/&gt;
+   * NOTE: this is copied over from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-25691&quot; title=&quot;Analyzer rule &amp;quot;AliasViewChild&amp;quot; does not stabilize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-25691&quot;&gt;&lt;del&gt;SPARK-25691&lt;/del&gt;&lt;/a&gt; from master.&lt;br/&gt;
+   */&lt;br/&gt;
+  def sameOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+    val output1 = plan1.output+    val output2 = plan2.output+    output1.length == output2.length &amp;amp;&amp;amp; output1.zip(output2).forall {
+      case (a1, a2) =&amp;gt; a1.semanticEquals(a2)
+    }&lt;br/&gt;
+  }&lt;br/&gt;
 }&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
diff --git a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
index c8a4b6da4fcd0..9526cbca77094 100644&lt;br/&gt;
&amp;#8212; a/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
+++ b/sql/catalyst/src/test/scala/org/apache/spark/sql/catalyst/optimizer/JoinReorderSuite.scala&lt;br/&gt;
@@ -300,8 +300,8 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {
     val optimized = Optimize.execute(analyzed)
     val expected = groundTruthBestPlan.analyze
 
-    assert(analyzed.sameOutput(expected)) // if this fails, the expected plan itself is incorrect
-    assert(analyzed.sameOutput(optimized))
+    assert(sameOutput(analyzed, expected)) // if this fails, the expected plan itself is incorrect
+    assert(sameOutput(analyzed, optimized))
 
     compareJoinOrder(optimized, expected)
   }&lt;br/&gt;
@@ -309,4 +309,19 @@ class JoinReorderSuite extends PlanTest with StatsEstimationTestBase {&lt;br/&gt;
   private def outputsOf(plans: LogicalPlan*): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Attribute&amp;#93;&lt;/span&gt; = {
     plans.map(_.output).reduce(_ ++ _)
   }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Returns true iff output of both plans are semantically the same, ie.:&lt;br/&gt;
+   *  - they contain the same number of `Attribute`s;&lt;br/&gt;
+   *  - references are the same;&lt;br/&gt;
+   *  - the order is equal too.&lt;br/&gt;
+   * NOTE: this is copied over from &lt;a href=&quot;https://issues.apache.org/jira/browse/SPARK-25691&quot; title=&quot;Analyzer rule &amp;quot;AliasViewChild&amp;quot; does not stabilize&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPARK-25691&quot;&gt;&lt;del&gt;SPARK-25691&lt;/del&gt;&lt;/a&gt; from master.&lt;br/&gt;
+   */&lt;br/&gt;
+  def sameOutput(plan1: LogicalPlan, plan2: LogicalPlan): Boolean = {&lt;br/&gt;
+    val output1 = plan1.output&lt;br/&gt;
+    val output2 = plan2.output&lt;br/&gt;
+    output1.length == output2.length &amp;amp;&amp;amp; output1.zip(output2).forall {+      case (a1, a2) =&amp;gt; a1.semanticEquals(a2)+    }+  }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310560">
                    <name>Problem/Incident</name>
                                                                <inwardlinks description="is caused by">
                                        <issuelink>
            <issuekey id="12916718">SPARK-12032</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 48 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|s01guo:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>