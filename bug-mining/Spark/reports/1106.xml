<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:21:00 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-4672] Cut off the super long serialization chain in GraphX to avoid the StackOverflow error</title>
                <link>https://issues.apache.org/jira/browse/SPARK-4672</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;While running iterative algorithms in GraphX, a StackOverflow error will stably occur in the serialization phase at about 300th iteration. In general, these kinds of algorithms have two things in common:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;They have a long computing chain.
&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;(e.g., &#8220;degreeGraph=&amp;gt;subGraph=&amp;gt;degreeGraph=&amp;gt;subGraph=&amp;gt;&#8230;=&amp;gt;&#8221;)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;li&gt;They will iterate many times to converge. An example:
&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;//K-Core Algorithm
&lt;/span&gt;val kNum = 5

&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; degreeGraph = graph.outerJoinVertices(graph.degrees) {
		(vid, vd, degree) =&amp;gt; degree.getOrElse(0)
}.cache()
	
&lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
	val subGraph = degreeGraph.subgraph(
		vpred = (vid, degree) =&amp;gt; degree &amp;gt;= KNum
	).cache()

	val newDegreeGraph = subGraph.degrees

	degreeGraph = subGraph.outerJoinVertices(newDegreeGraph) {
		(vid, vd, degree) =&amp;gt; degree.getOrElse(0)
	}.cache()

	isConverged = check(degreeGraph)
} &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt;(isConverged == &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;After about 300 iterations, StackOverflow will definitely occur with the following stack trace:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Exception in thread &lt;span class=&quot;code-quote&quot;&gt;&quot;main&quot;&lt;/span&gt; org.apache.spark.SparkException: Job aborted due to stage failure: Task serialization failed: java.lang.StackOverflowError
java.io.ObjectOutputStream.writeNonProxyDesc(ObjectOutputStream.java:1275)
java.io.ObjectOutputStream.writeClassDesc(ObjectOutputStream.java:1230)
java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1426)
java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1177)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is a very tricky bug, which only occurs with enough iterations. Since it took us a long time to find out its causes, we will detail the causes in the following 3 paragraphs. &lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;Phase1%3ATryusingcheckpoint%28%29toshortenthelineage&quot;&gt;&lt;/a&gt;Phase 1: Try using checkpoint() to shorten the lineage&lt;/h3&gt;

&lt;p&gt;It&apos;s easy to come to the thought that the long lineage may be the cause. For some RDDs, their lineages may grow with the iterations. Also, for some magical references,  their lineage lengths never decrease and finally become very long. As a result, the call stack of task&apos;s serialization()/deserialization() method will be very long too, which finally exhausts the whole JVM stack.&lt;/p&gt;

&lt;p&gt;In deed, the lineage of some RDDs (e.g., EdgeRDD.partitionsRDD) increases 3 OneToOne dependencies in each iteration in the above example. Lineage length refers to the  maximum length of OneToOne dependencies (e.g., from the finalRDD to the ShuffledRDD) in each stage.&lt;/p&gt;

&lt;p&gt;To shorten the lineage, a checkpoint() is performed every N (e.g., 10) iterations. Then, the lineage will drop down when it reaches a certain length (e.g., 33). &lt;/p&gt;

&lt;p&gt;However, StackOverflow error still occurs after 300+ iterations!&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;Phase2%3AAbnormalfclosurefunctionleadstoaunbreakableserializationchain&quot;&gt;&lt;/a&gt;Phase 2:  Abnormal f closure function leads to a unbreakable serialization chain&lt;/h3&gt;

&lt;p&gt;After a long-time debug, we found that an abnormal &lt;em&gt;&lt;b&gt;f&lt;/b&gt;&lt;/em&gt; function closure and a potential bug in GraphX (will be detailed in Phase 3) are the &quot;Suspect Zero&quot;. They together build another serialization chain that can bypass the broken lineage cut by checkpoint() (as shown in Figure 1). In other words, the serialization chain can be as long as the original lineage before checkpoint().&lt;/p&gt;

&lt;p&gt;Figure 1 shows how the unbreakable serialization chain is generated. Yes, the OneToOneDep can be cut off by checkpoint(). However, the serialization chain can still access the previous RDDs through the (1)-&amp;gt;(2) reference chain. As a result, the checkpoint() action is meaningless and the lineage is as long as that before. &lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JerryLead/Misc/master/SparkPRFigures/g1.png&quot; width=&quot;100%&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The (1)-&amp;gt;(2) chain can be observed in the debug view (in Figure 2).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;_rdd (i.e., A in Figure 1, checkpointed) -&amp;gt; f -&amp;gt; $&lt;span class=&quot;code-keyword&quot;&gt;outer&lt;/span&gt; (VertexRDD) -&amp;gt; partitionsRDD:MapPartitionsRDD -&amp;gt; RDDs in  the previous iterations
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JerryLead/Misc/master/SparkPRFigures/g2.png&quot; width=&quot;100%&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;More description: While a RDD is being serialized, its f function &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;e.g., f: (Iterator[A], Iterator[B]) =&amp;gt; Iterator[V]) in ZippedPartitionsRDD2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;will be serialized too. This action will be very dangerous if the f closure has a member &#8220;$outer&#8221; that references its outer class (as shown in Figure 1). This reference will be another way (except the OneToOneDependency) that a RDD (e.g., PartitionsRDD) can reference the other RDDs (e.g., VertexRDD). Note that checkpoint() only cuts off the direct lineage, while the function reference is still kept. So, serialization() can still access the other RDDs along the f references. &lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;Phase3%3ANontransientmembervariableofVertexRDDmakesthingsworse&quot;&gt;&lt;/a&gt;Phase 3: Non-transient member variable of VertexRDD makes things worse&lt;/h3&gt;

&lt;p&gt;&quot;Reference (1)&quot; in Figure 1 is caused by the abnormal f clousre, while &quot;Reference (2)&quot; is caused by the potential bug in GraphX: &lt;b&gt;PartitionsRDD is a non-transient member variable of VertexRDD&lt;/b&gt;. &lt;/p&gt;

&lt;p&gt;With this &lt;em&gt;small&lt;/em&gt; bug, the f closure itself (without OneToOne dependency) can cause StackOverflow error, as shown in the red box in Figure 3:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;While &lt;em&gt;vertices:VertexRDD&lt;/em&gt; is being serialized, its member &lt;em&gt;PartitionsRDD&lt;/em&gt; will be serialized too.&lt;/li&gt;
	&lt;li&gt;Next, while serializing this &lt;em&gt;partitionsRDD&lt;/em&gt;, serialization() will simultaneously serialize its f&#8217;s referenced $outer. Here, it is another &lt;em&gt;partitionsRDD&lt;/em&gt;.&lt;/li&gt;
	&lt;li&gt;Finally, the chain
&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot;f =&amp;gt; f$3 =&amp;gt; f$3 =&amp;gt; $&lt;span class=&quot;code-keyword&quot;&gt;outer&lt;/span&gt; =&amp;gt; vertices: VertexRDD =&amp;gt; partitionsRDD =&amp;gt; &#8230; =&amp;gt; ShuffledRDD&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;comes into shape. As a result, the serialization chain can be as long as the original lineage and finally triggers StackOverflow error.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JerryLead/Misc/master/SparkPRFigures/g3.png&quot; width=&quot;100%&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;a name=&quot;Conclusions&quot;&gt;&lt;/a&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;In conclusion, the root cause of StackOverflow error is the long serialization chain, which cannot be cut off by &lt;em&gt;checkpoint()&lt;/em&gt;. This long chain is caused by the multiple factors, including:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;long lineage&lt;/li&gt;
	&lt;li&gt;$outer reference in the f closure&lt;/li&gt;
	&lt;li&gt;non-transient member variable&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;&lt;a name=&quot;Howtofixthiserror&quot;&gt;&lt;/a&gt;How to fix this error&lt;/h2&gt;

&lt;p&gt;We propose three pull requests as follows to solve this problem thoroughly.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;PR-3544&lt;br/&gt;
In this pr, we change the &quot;val PartitionsRDD&quot; to be transient in EdgeRDDImpl and VertexRDDImpl. As a result, while &lt;em&gt;vertices:VertexRDD&lt;/em&gt; is being serialized, its member &lt;em&gt;PartitionsRDD&lt;/em&gt; will not be serialized. In other words, the &quot;Reference (2)&quot; in Figure 1 will be cut off.&lt;/li&gt;
	&lt;li&gt;PR-3545&lt;br/&gt;
In this pr, we set &quot;f = null&quot; if ZippedPartitionsRDD is checkpointed. As a result, when PartitionsRDD is checkpointed, its f closure will be cleared and the &quot;Reference (1)&quot; (i.e., f =&amp;gt; $outer) in Figure 1 will no exist.&lt;/li&gt;
	&lt;li&gt;PR-3549&lt;br/&gt;
To cut off the long lineage, we need to perform checkpoint()  on PartitionsRDD. However, current checkpoint() is performed on VertexRDD and EdgeRDD themselves. As a result, we need to override the checkpoint() methods in VertexRDDImpl and EdgeRDDImpl to perform checkpoint() on PartitionsRDD.&lt;/li&gt;
&lt;/ol&gt;







</description>
                <environment></environment>
        <key id="12758581">SPARK-4672</key>
            <summary>Cut off the super long serialization chain in GraphX to avoid the StackOverflow error</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="jerrylead">Lijie Xu</reporter>
                        <labels>
                    </labels>
                <created>Mon, 1 Dec 2014 07:53:22 +0000</created>
                <updated>Wed, 3 Dec 2014 10:11:11 +0000</updated>
                            <resolved>Wed, 3 Dec 2014 07:54:07 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.2.0</fixVersion>
                                    <component>GraphX</component>
                    <component>Spark Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="14230931" author="apachespark" created="Tue, 2 Dec 2014 03:51:49 +0000"  >&lt;p&gt;User &apos;JerryLead&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/3545&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/3545&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14231064" author="apachespark" created="Tue, 2 Dec 2014 06:31:30 +0000"  >&lt;p&gt;User &apos;JerryLead&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/3549&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/3549&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14231891" author="rxin" created="Tue, 2 Dec 2014 18:40:20 +0000"  >&lt;p&gt;cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ankurdave&quot; class=&quot;user-hover&quot; rel=&quot;ankurdave&quot;&gt;ankurdave&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you take a look at this ASAP? Would be great to fix for 1.2.&lt;/p&gt;</comment>
                            <comment id="14232524" author="jason.dai" created="Wed, 3 Dec 2014 03:35:44 +0000"  >&lt;p&gt;We ran into the same issue, and this is a nice summary for the bug analysis. On the other hand, while this may fix the specific GraphX issue, I don&apos;t think it is generally applicable for dealing with super long lineage that can be generated in GraphX or other iterative algorithms. &lt;/p&gt;

&lt;p&gt;In particular, the user can define arbitrary functions, which can be called in RDD.compute() and refer to an arbitrary member variable that is an RDD, or can be used to construct another RDD, such as:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;  class MyRDD (val rdd1, val rdd2, func1) extends RDD {
    val func2 = (f, iter1, iter2) =&amp;gt; iter1&#8211; f(iter2)
    &#8230;
    override def compute(part, sc) {
      func2(func1, rdd1.iterator(part, sc), rdd2.iterator(part, sc))
    }
    &#8230;
   define newRDD(val rdd3, func3) = {
     val func4 = func2(func3)
     new AnotherRDD() {
       override def compute(part, sc) {
         func4(rdd1.iterator(part, sc) + rdd2.iterator(part, sc), rdd3.iterator(part, sc))
       }  
    }
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case, we will need to serialize rdd1 and rdd2 before MyRDD is checkpointed; after MyRDD is checkpointed, we don&#8217;t need to serialize rdd1 or rdd2, but we cannot clear func2 either. &lt;/p&gt;

&lt;p&gt;I think we can fix this more general issues as follows:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;As only RDD.compute(or RDD.iterator) should be called at the worker side, we only need to serialize anything that is referenced in that function (no matter it&#8217;s a member variable or not)&lt;/li&gt;
	&lt;li&gt;After the RDD is checkpointed, the RDD.compute should be changed to read the checkpint file, which will not reference other variables &#8211; again, we only need to serialize whatever is referenced in that function now&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="14232527" author="rxin" created="Wed, 3 Dec 2014 03:37:15 +0000"  >&lt;p&gt;Yea it makes sense to remove all the function closure f from an RDD if it is checkpointed.&lt;/p&gt;</comment>
                            <comment id="14232529" author="jason.dai" created="Wed, 3 Dec 2014 03:44:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rxin&quot; class=&quot;user-hover&quot; rel=&quot;rxin&quot;&gt;rxin&lt;/a&gt; what exactly do you mean by &quot;remove all the function closure f from an RDD if it is checkpointed&quot;?&lt;/p&gt;

&lt;p&gt;In my previous example, we should not clear func2 even if MyRDD is checkpointed, otherwise newRDD() will be no longer correct. Instead, we should make sure we only include RDD.compute(or RDD.iterator) in the closure (no matter whether it is checkpointed or not), and change RDD.compute to reading checkpoint files once it is checkpointed.&lt;/p&gt;</comment>
                            <comment id="14232533" author="rxin" created="Wed, 3 Dec 2014 03:50:19 +0000"  >&lt;p&gt;Ok I admit I wasn&apos;t reading your comment too carefully &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Is there a concrete way you are proposing that would solve this problem for arbitrarily defined RDDs? I don&apos;t think it is solvable at this point.&lt;/p&gt;

&lt;p&gt;That said, we can solve this for most of the built-in RDDs.&lt;/p&gt;

</comment>
                            <comment id="14232549" author="jason.dai" created="Wed, 3 Dec 2014 04:08:41 +0000"  >&lt;p&gt;I can see two possible ways to fix this:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Define customized closure serialization mechanisms in task serializations, which can use reflections to carefully choose which to serialize (i.e., only those referenced by RDD.iterator); this potentially needs to deal with many details and can be error prone.&lt;/li&gt;
	&lt;li&gt;In task serialization, each &quot;base&quot; RDD can generate a dual, &quot;shippable&quot; RDD, which only has transient member variables, and only implements the compute() function (which in turn calls the compute() function of the &quot;base&quot; RDD through ClosureCleaner.clean()); we can then probably rely on the Java serializer to handle this correctly.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="14232732" author="ankurd" created="Wed, 3 Dec 2014 07:54:07 +0000"  >&lt;p&gt;Issue resolved by pull request 3545&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/3545&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/3545&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14232734" author="ankurd" created="Wed, 3 Dec 2014 07:55:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jerrylead&quot; class=&quot;user-hover&quot; rel=&quot;jerrylead&quot;&gt;jerrylead&lt;/a&gt; Thanks for investigating this bug and the excellent explanation. Now that the PRs are merged, can you confirm that the bug is fixed for you? I haven&apos;t yet been able to reproduce it locally.&lt;/p&gt;</comment>
                            <comment id="14232845" author="jerrylead" created="Wed, 3 Dec 2014 10:11:11 +0000"  >&lt;p&gt;Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ankurdave&quot; class=&quot;user-hover&quot; rel=&quot;ankurdave&quot;&gt;ankurdave&lt;/a&gt;. Yes, the StackOverflow error disappears once the PRs are merged and checkpoint() is performed every N iterations. However, If the lineage of iterative algorithms are too long, we still need to do checkpoint() manually to cut off the lineage to avoid this error. Moreover, the fix suggestion given by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jason.dai&quot; class=&quot;user-hover&quot; rel=&quot;jason.dai&quot;&gt;jason.dai&lt;/a&gt; is fine since it is a general problem. We need more elegant methods to avoid the long chain of task&apos;s serialization().&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12743010">SPARK-3623</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 50 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i22wtr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>