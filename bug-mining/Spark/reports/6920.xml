<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 19:09:16 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-29748] Remove sorting of fields in PySpark SQL Row creation</title>
                <link>https://issues.apache.org/jira/browse/SPARK-29748</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;Currently, when a PySpark Row is created with keyword arguments, the fields are sorted alphabetically. This has created a lot of confusion with users because it is not obvious (although it is stated in the pydocs) that they will be sorted alphabetically, and then an error can occur later when applying a schema and the field order does not match.&lt;/p&gt;

&lt;p&gt;The original reason for sorting fields is because kwargs in python &amp;lt; 3.6 are not guaranteed to be in the same order that they were entered. Sorting alphabetically would ensure a consistent order.  Matters are further complicated with the flag &lt;tt&gt;_&lt;em&gt;from_dict&lt;/em&gt;_&lt;/tt&gt; that allows the &lt;tt&gt;Row&lt;/tt&gt; fields to to be referenced by name when made by kwargs, but this flag is not serialized with the Row and leads to inconsistent behavior.&lt;/p&gt;

&lt;p&gt;This JIRA proposes that any sorting of the Fields is removed. Users with Python 3.6+ creating Rows with kwargs can continue to do so since Python will ensure the order is the same as entered. Users with Python &amp;lt; 3.6 will have to create Rows with an OrderedDict or by using the Row class as a factory (explained in the pydoc).  If kwargs are used, an error will be raised or based on a conf setting it can fall back to a LegacyRow that will sort the fields as before. This LegacyRow will be immediately deprecated and removed once support for Python &amp;lt; 3.6 is dropped.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13266194">SPARK-29748</key>
            <summary>Remove sorting of fields in PySpark SQL Row creation</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bryanc">Bryan Cutler</assignee>
                                    <reporter username="bryanc">Bryan Cutler</reporter>
                        <labels>
                            <label>release-notes</label>
                    </labels>
                <created>Mon, 4 Nov 2019 21:40:25 +0000</created>
                <updated>Fri, 14 Feb 2020 20:12:38 +0000</updated>
                            <resolved>Fri, 10 Jan 2020 22:39:39 +0000</resolved>
                                    <version>3.0.0</version>
                                    <fixVersion>3.0.0</fixVersion>
                                    <component>PySpark</component>
                    <component>SQL</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="16973695" author="zero323" created="Wed, 13 Nov 2019 21:11:19 +0000"  >&lt;p&gt;While this is a step in the right direction I think it justifies a broader discussion about &lt;tt&gt;Row&lt;/tt&gt; purpose, API, and behavior guarantees. Especially if we&apos;re going to introduce diverging implementations, with &lt;tt&gt;Row&lt;/tt&gt; and &lt;tt&gt;LegacyRow&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Over the years Spark code have accumulated a lot of conflicting behaviors and special cases related to &lt;tt&gt;Row&lt;/tt&gt;:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Sometimes &lt;tt&gt;Row&lt;/tt&gt; are reordered (subject of this JIRA), sometimes are not.&lt;/li&gt;
	&lt;li&gt;Sometimes there are treated as ordered products (&lt;tt&gt;tuples&lt;/tt&gt;), sometimes as unordered dictionaries.&lt;/li&gt;
	&lt;li&gt;We provide efficient access only by position, but the primary access method is by name.&lt;/li&gt;
	&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Some of the unusual properties, are well documented (but still confusing), other are not. For example objects that are indistinguishable using public API&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-python&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;from&lt;/span&gt; pyspark.sql.types &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; StructType, StructField, IntegerType, StringType

a = Row(x1=1, x2=&lt;span class=&quot;code-quote&quot;&gt;&quot;foo&quot;&lt;/span&gt;)
b = Row(&lt;span class=&quot;code-quote&quot;&gt;&quot;x1&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;x2&quot;&lt;/span&gt;)(1, &lt;span class=&quot;code-quote&quot;&gt;&quot;foo&quot;&lt;/span&gt;)

a == b
&lt;span class=&quot;code-comment&quot;&gt;# &lt;span class=&quot;code-keyword&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;True&lt;/span&gt;&lt;/span&gt; 
&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt;(a) == &lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt;(b)
&lt;span class=&quot;code-comment&quot;&gt;#&lt;span class=&quot;code-keyword&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;
&lt;span class=&quot;code-object&quot;&gt;list&lt;/span&gt;(a.__fields__) == &lt;span class=&quot;code-object&quot;&gt;list&lt;/span&gt;(b.__fields__)  &lt;span class=&quot;code-comment&quot;&gt;# Not really public, but just to make a point&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;cannot be substituted in practice.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-python&quot;&gt;
schema = StructType([
    StructField(&lt;span class=&quot;code-quote&quot;&gt;&quot;x2&quot;&lt;/span&gt;, StringType()),
    StructField(&lt;span class=&quot;code-quote&quot;&gt;&quot;x1&quot;&lt;/span&gt;, IntegerType())])

spark.createDataFrame([a], schema)                                                                                                                                              
&lt;span class=&quot;code-comment&quot;&gt;# DataFrame[x2: string, x1: &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;]
&lt;/span&gt;
spark.createDataFrame([b], schema) 
&lt;span class=&quot;code-comment&quot;&gt;# &lt;span class=&quot;code-object&quot;&gt;TypeError&lt;/span&gt;                                 Traceback (most recent call last)
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;# ...
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;# &lt;span class=&quot;code-object&quot;&gt;TypeError&lt;/span&gt;: field x1: IntegerType can &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt; accept &lt;span class=&quot;code-object&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&apos;foo&apos;&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt; &amp;lt;class &lt;span class=&quot;code-quote&quot;&gt;&apos;&lt;span class=&quot;code-object&quot;&gt;str&lt;/span&gt;&apos;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To make things even worse the primary (while I don&apos;t have hard data here, but it is common both in the internal API as well as the code I&apos;ve seen in the wild) access method - by name - is &lt;em&gt;O(M)&lt;/em&gt;&#160; where is the width of schema.&lt;/p&gt;

&lt;p&gt;So if we&apos;re going to modify the core behavior (sorting) it makes sense to rethink the whole design.&lt;/p&gt;

&lt;p&gt;Since the schema is carried around with each object and pass over the wire we might as well convert &lt;tt&gt;Row&lt;/tt&gt; into a proxy of &lt;tt&gt;OrderedDict&lt;/tt&gt; getting something around these lines:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-python&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; sys
&lt;span class=&quot;code-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; OrderedDict

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Row:
    slots = [&lt;span class=&quot;code-quote&quot;&gt;&quot;_store&quot;&lt;/span&gt;]

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __init__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, *args, **kwargs):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; args &lt;span class=&quot;code-keyword&quot;&gt;and&lt;/span&gt; kwargs:
            &lt;span class=&quot;code-keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;ValueError&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;Can &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt; use both args &quot;&lt;/span&gt;
                             &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;and&lt;/span&gt; kwargs to create Row&quot;&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; args:
            &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store = OrderedDict.fromkeys(args)
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store = OrderedDict(kwargs)

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __getattr__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, x):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store[x]

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __getitem__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, x):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(x, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;):
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.values())[x]
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store[x]

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __iter__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;iter&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.values())

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __repr__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;Row({})&quot;&lt;/span&gt;.&lt;span class=&quot;code-object&quot;&gt;format&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;, &quot;&lt;/span&gt;.join(
	    &lt;span class=&quot;code-quote&quot;&gt;&quot;{}={}&quot;&lt;/span&gt;.&lt;span class=&quot;code-object&quot;&gt;format&lt;/span&gt;(k, v) &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.items()
	))

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __len__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store)

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __call__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, *args):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;len&lt;/span&gt;(args) &amp;gt; &lt;span class=&quot;code-object&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;):
            &lt;span class=&quot;code-keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;ValueError&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;Can &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt; create Row &lt;span class=&quot;code-keyword&quot;&gt;with&lt;/span&gt; fields %s, expected %d values &quot;&lt;/span&gt;
                             &lt;span class=&quot;code-quote&quot;&gt;&quot;but got %s&quot;&lt;/span&gt; % (&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;len&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;), args))

        &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.update(&lt;span class=&quot;code-object&quot;&gt;zip&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.keys(), args))
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __eq__(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, other):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(other, Row) &lt;span class=&quot;code-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store == other._store

    @&lt;span class=&quot;code-object&quot;&gt;property&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; _fields(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store.keys()

    @&lt;span class=&quot;code-object&quot;&gt;staticmethod&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; _conv(obj):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(obj, Row):
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; obj.asDict(&lt;span class=&quot;code-keyword&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;True&lt;/span&gt;&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(obj, &lt;span class=&quot;code-object&quot;&gt;list&lt;/span&gt;):
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; [conv(o) &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; o &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; obj]
        &lt;span class=&quot;code-keyword&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(obj, &lt;span class=&quot;code-object&quot;&gt;dict&lt;/span&gt;):
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;dict&lt;/span&gt;((k, conv(v)) &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; obj.items())
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; obj

    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; asDict(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;, recursive=&lt;span class=&quot;code-keyword&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;False&lt;/span&gt;&lt;/span&gt;):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; recursive:
            result = OrderedDict.fromkeys(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._fields)
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._fields:
                result[key] = Row._conv(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store[key])
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; result
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._store

    @&lt;span class=&quot;code-object&quot;&gt;classmethod&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt;  from_dict(cls, d):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6):
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(d, &lt;span class=&quot;code-object&quot;&gt;dict&lt;/span&gt;)):
                &lt;span class=&quot;code-keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;ValueError&lt;/span&gt;(
                    &lt;span class=&quot;code-quote&quot;&gt;&quot;from_dict requires &lt;span class=&quot;code-object&quot;&gt;dict&lt;/span&gt; but got {}&quot;&lt;/span&gt;.&lt;span class=&quot;code-object&quot;&gt;format&lt;/span&gt;(
                        &lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt;(d)))

        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;isinstance&lt;/span&gt;(d, OrderedDict)):
                &lt;span class=&quot;code-keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;ValueError&lt;/span&gt;(
                    &lt;span class=&quot;code-quote&quot;&gt;&quot;from_dict requires collections.OrderedDict {}&quot;&lt;/span&gt;.&lt;span class=&quot;code-object&quot;&gt;format&lt;/span&gt;(
                        &lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt;(d)))
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; cls(**d)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If we&apos;re committed to &lt;tt&gt;Row&lt;/tt&gt; being a &lt;tt&gt;tuple&lt;/tt&gt; (with &lt;em&gt;O(1)&lt;/em&gt; by index access) we could actually try to hack &lt;tt&gt;namedtuple&lt;/tt&gt;:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-python&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; namedtuple
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; hashlib
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; json

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Row:
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; __new__(cls, *args, **kwargs):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; args &lt;span class=&quot;code-keyword&quot;&gt;and&lt;/span&gt; kwargs:
            &lt;span class=&quot;code-keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;ValueError&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;Can &lt;span class=&quot;code-keyword&quot;&gt;not&lt;/span&gt; use both args &quot;&lt;/span&gt;
                             &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;and&lt;/span&gt; kwargs to create Row&quot;&lt;/span&gt;)
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; args:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; _SchemaRegistry.schema(&lt;span class=&quot;code-object&quot;&gt;tuple&lt;/span&gt;(args))
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; _SchemaRegistry.make(&lt;span class=&quot;code-object&quot;&gt;tuple&lt;/span&gt;(kwargs.keys()), kwargs.values())

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;_SchemaRegistry:
    registry = {}
    @&lt;span class=&quot;code-object&quot;&gt;classmethod&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; schema(cls, fields):
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; fields &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; cls.registry:
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; cls.registry[fields]
        &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;:
            m = hashlib.md5()
            m.update(json.dumps(fields).encode())
            suffix = m.hexdigest()

            reducer = &lt;span class=&quot;code-keyword&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;: (cls.make, (&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._fields, &lt;span class=&quot;code-object&quot;&gt;tuple&lt;/span&gt;(&lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;)))
            &lt;span class=&quot;code-comment&quot;&gt;# TODO Add recursive case
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; asDict = &lt;span class=&quot;code-keyword&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;: &lt;span class=&quot;code-keyword&quot;&gt;self&lt;/span&gt;._asdict()

            schema = &lt;span class=&quot;code-object&quot;&gt;type&lt;/span&gt;(
                &lt;span class=&quot;code-quote&quot;&gt;&quot;Row&quot;&lt;/span&gt;,
                (namedtuple(&lt;span class=&quot;code-quote&quot;&gt;&quot;Row_{}&quot;&lt;/span&gt;.&lt;span class=&quot;code-object&quot;&gt;format&lt;/span&gt;(suffix), fields), Row),
                {&lt;span class=&quot;code-quote&quot;&gt;&quot;__reduce__&quot;&lt;/span&gt;: reducer, &lt;span class=&quot;code-quote&quot;&gt;&quot;asDict&quot;&lt;/span&gt;: asDict})
            cls.registry[fields] = schema  &lt;span class=&quot;code-comment&quot;&gt;# Idempotent so we don&apos;t need lock
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; schema

    @&lt;span class=&quot;code-object&quot;&gt;classmethod&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; make(cls, fields, values):
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; cls.schema(fields)(*values)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and get efficient name and index access for free.&lt;/p&gt;</comment>
                            <comment id="16974678" author="bryanc" created="Thu, 14 Nov 2019 23:24:45 +0000"  >&lt;p&gt;Thanks for discussing &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=zero323&quot; class=&quot;user-hover&quot; rel=&quot;zero323&quot;&gt;zero323&lt;/a&gt; . The goal here is to only remove the sorting of fields, which causes all kinds of weird inconsistencies like in your above example. I&apos;d prefer to leave efficient field access for another time. Since Row is a subclass of tuple, accessing fields by name has never been efficient and I don&apos;t want to change the fundamental design here. The only reason to introduce LegacyRow (which will be deprecated) is to maintain backward compatibility with existing code that expects fields to be sorted.&lt;/p&gt;</comment>
                            <comment id="16974821" author="jhereth" created="Fri, 15 Nov 2019 05:47:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bryanc&quot; class=&quot;user-hover&quot; rel=&quot;bryanc&quot;&gt;bryanc&lt;/a&gt;&#160;With simply removing sorting we change the semantics, e.g. `Row(a=1, b=2) != Row(b=2, a=1)` (opposed to what we currently have.&lt;/p&gt;

&lt;p&gt;Also, there might be problems if data was written with Spark pre-change and read after the change.&lt;/p&gt;

&lt;p&gt;Adding workarounds (if possible) will make the code very complex.&lt;/p&gt;

&lt;p&gt;I think &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=zero323&quot; class=&quot;user-hover&quot; rel=&quot;zero323&quot;&gt;zero323&lt;/a&gt;&#160;was thinking about changes for the upcoming 3.0?&lt;/p&gt;</comment>
                            <comment id="16975054" author="zero323" created="Fri, 15 Nov 2019 12:28:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jhereth&quot; class=&quot;user-hover&quot; rel=&quot;jhereth&quot;&gt;jhereth&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;With simply removing sorting we change the semantics, e.g. `Row(a=1, b=2) != Row(b=2, a=1)` (opposed to what we currently have.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is even more messy. At the moment we adhere to &lt;tt&gt;tuple&lt;/tt&gt; semantics so &lt;tt&gt;Row(a=1, b=2) == Row(y=1, z=2)&lt;/tt&gt;. That might be acceptable (namedtuples use the same approach, but I think we should state that explicitly).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I think Maciej Szymkiewicz was thinking about changes for the upcoming 3.0?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indeed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bryanc&quot; class=&quot;user-hover&quot; rel=&quot;bryanc&quot;&gt;bryanc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let me clarify things - I am not suggesting that any of these changes should be implemented here. Instead I think we should have clear picture what &lt;tt&gt;Row&lt;/tt&gt; suppose to be (not only in terms of API, but also intended applications) before we decide on a concrete solution. That&apos;s particularly important because we already have special cases that were introduced specifically to target &lt;tt&gt;**kwargs&lt;/tt&gt; and sorting behavior.&lt;/p&gt;

&lt;p&gt;That being said, if we want to discuss this case in isolation&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Introducing &lt;tt&gt;LegacyRow&lt;/tt&gt; seems to make little sense if implementation of &lt;tt&gt;Row&lt;/tt&gt; stays the same otherwise.  Sorting or not, depending on the config, should be enough.&lt;/li&gt;
	&lt;li&gt;&lt;blockquote&gt;&lt;p&gt; Users with Python &amp;lt; 3.6 will have to create Rows with an OrderedDict or by using the Row class as a factory (explained in the pydoc).  &lt;/p&gt;&lt;/blockquote&gt;   I don&apos;t think we should introduce such behavior now, when 3.5 is deprecated. Having yet another way to initialize &lt;tt&gt;Row&lt;/tt&gt; will be confusing at best (and introduce new problems  when using complex structures). Furthermore we already have one mechanism that provides ordered behavior independent of version.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Instead I&apos;d suggest we:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Make legacy behavior the only option for Python &amp;lt; 3.6.&lt;/li&gt;
	&lt;li&gt;For Python 3.6 let&apos;s introduce legacy sorting mechanism (keeping only single &lt;tt&gt;Row&lt;/tt&gt;) class, enabled by default and deprecated.&lt;/li&gt;
&lt;/ul&gt;


</comment>
                            <comment id="16977749" author="bryanc" created="Tue, 19 Nov 2019 19:06:33 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=zero323&quot; class=&quot;user-hover&quot; rel=&quot;zero323&quot;&gt;zero323&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jhereth&quot; class=&quot;user-hover&quot; rel=&quot;jhereth&quot;&gt;jhereth&lt;/a&gt; this is targeted for Spark 3.0 and I agree, the behavior of Row should be very well defined to avoid any further confusion.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Introducing &lt;tt&gt;LegacyRow&lt;/tt&gt; seems to make little sense if implementation of &lt;tt&gt;Row&lt;/tt&gt; stays the same otherwise. Sorting or not, depending on the config, should be enough.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;LegacyRow isn&apos;t meant to be public and the user will not be aware of it. The reasons for it are to separate different implementations and make for a clean removal in the future without affecting the standard Row class. Having a separate implementation will make it easier to debug and diagnose problems - I don&apos;t want to get in the situation where a Row could sort fields or not, and then getting bug reports not knowing which way it was configured.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I don&apos;t think we should introduce such behavior now, when 3.5 is deprecated. Having yet another way to initialize Row will be confusing at best &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s reasonable. I&apos;m not crazy about an option for OrderedDict as input, but I think users of Python &amp;lt; 3.6 should have a way to create a Row with ordered fields other than the 2-step process in the pydoc. We can explore other options for this.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Make legacy behavior the only option for Python &amp;lt; 3.6.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I don&apos;t think we should have 2 very different behaviors that are chosen based on your Python verison. The user should be aware of what is happening and need to make the decision to use the legacy sorting. Some users will not know this, then upgrade their Python version and see Rows breaking. We should allow users with Python &amp;lt; 3.6 to make Rows with ordered fields and then be able to upgrade Python version without breaking their Spark app.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For Python 3.6 let&apos;s introduce legacy sorting mechanism (keeping only single Row) class, enabled by default and deprecated.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, I&apos;m not sure if we should enable the legacy sorting as default or not, what do others think?&lt;br/&gt;
&#160;&lt;/p&gt;</comment>
                            <comment id="16987252" author="bryanc" created="Tue, 3 Dec 2019 20:51:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=zero323&quot; class=&quot;user-hover&quot; rel=&quot;zero323&quot;&gt;zero323&lt;/a&gt; I made some updates to the PR with remove the _LegacyRow and option for OrderedDict, and also like you suggested for Python 3.6 will automatically fall back to legacy behavior of sorting and print a warning to the user.&lt;/p&gt;</comment>
                            <comment id="17013251" author="bryanc" created="Fri, 10 Jan 2020 22:39:39 +0000"  >&lt;p&gt;Issue resolved by pull request 26496&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/26496&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/26496&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13108183">SPARK-22232</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13174312">SPARK-24915</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13237356">SPARK-27939</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13233324">SPARK-27712</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 44 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z088z4:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>