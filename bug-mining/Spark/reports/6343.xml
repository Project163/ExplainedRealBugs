<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 19:04:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-27097] Avoid embedding platform-dependent offsets literally in whole-stage generated code</title>
                <link>https://issues.apache.org/jira/browse/SPARK-27097</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;Avoid embedding platform-dependent offsets literally in whole-stage generated code.&lt;/p&gt;

&lt;p&gt;Spark SQL performs whole-stage code generation to speed up query execution. There are two steps to it:&lt;/p&gt;

&lt;p&gt;Java source code is generated from the physical query plan on the driver. A single version of the source code is generated from a query plan, and sent to all executors.&lt;br/&gt;
It&apos;s compiled to bytecode on the driver to catch compilation errors before sending to executors, but currently only the generated source code gets sent to the executors. The bytecode compilation is for fail-fast only.&lt;br/&gt;
Executors receive the generated source code and compile to bytecode, then the query runs like a hand-written Java program.&lt;/p&gt;

&lt;p&gt;In this model, there&apos;s an implicit assumption about the driver and executors being run on similar platforms. Some code paths accidentally embedded platform-dependent object layout information into the generated code, such as:&lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Platform.putLong(buffer, &lt;span class=&quot;code-comment&quot;&gt;/* offset */&lt;/span&gt; 24, &lt;span class=&quot;code-comment&quot;&gt;/* value */&lt;/span&gt; 1);

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This code expects a field to be at offset +24 of the buffer object, and sets a value to that field.&lt;br/&gt;
But whole-stage code generation generally uses platform-dependent information from the driver. If the object layout is significantly different on the driver and executors, the generated code can be reading/writing to wrong offsets on the executors, causing all kinds of data corruption.&lt;/p&gt;

&lt;p&gt;One code pattern that leads to such problem is the use of Platform.XXX constants in generated code, e.g. Platform.BYTE_ARRAY_OFFSET.&lt;/p&gt;

&lt;p&gt;Bad:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

val baseOffset = Platform.BYTE_ARRAY_OFFSET
&lt;span class=&quot;code-comment&quot;&gt;// codegen template:
&lt;/span&gt;s&lt;span class=&quot;code-quote&quot;&gt;&quot;Platform.putLong($buffer, $baseOffset, $value);&quot;&lt;/span&gt;
This will embed the value of Platform.BYTE_ARRAY_OFFSET on the driver into the generated code.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;Good:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

val baseOffset = &lt;span class=&quot;code-quote&quot;&gt;&quot;Platform.BYTE_ARRAY_OFFSET&quot;&lt;/span&gt;
&lt;span class=&quot;code-comment&quot;&gt;// codegen template:
&lt;/span&gt;s&lt;span class=&quot;code-quote&quot;&gt;&quot;Platform.putLong($buffer, $baseOffset, $value);&quot;&lt;/span&gt;
This will generate the offset symbolically -- Platform.putLong(buffer, Platform.BYTE_ARRAY_OFFSET, value), which will be able to pick up the correct value on the executors.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;Caveat: these offset constants are declared as runtime-initialized static final in Java, so they&apos;re not compile-time constants from the Java language&apos;s perspective. It does lead to a slightly increased size of the generated code, but this is necessary for correctness.&lt;/p&gt;

&lt;p&gt;NOTE: there can be other patterns that generate platform-dependent code on the driver which is invalid on the executors. e.g. if the endianness is different between the driver and the executors, and if some generated code makes strong assumption about endianness, it would also be problematic.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="13220351">SPARK-27097</key>
            <summary>Avoid embedding platform-dependent offsets literally in whole-stage generated code</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rednaxelafx">Kris Mok</assignee>
                                    <reporter username="smilegator">Xiao Li</reporter>
                        <labels>
                            <label>correctness</label>
                    </labels>
                <created>Fri, 8 Mar 2019 00:22:45 +0000</created>
                <updated>Sat, 21 Mar 2020 13:23:24 +0000</updated>
                            <resolved>Sun, 10 Mar 2019 06:00:55 +0000</resolved>
                                    <version>2.0.0</version>
                    <version>2.1.3</version>
                    <version>2.2.3</version>
                    <version>2.3.4</version>
                    <version>2.4.0</version>
                                    <fixVersion>2.4.1</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16787356" author="smilegator" created="Fri, 8 Mar 2019 00:25:13 +0000"  >&lt;p&gt;The fix will be pushed soon. &lt;/p&gt;</comment>
                            <comment id="16787357" author="smilegator" created="Fri, 8 Mar 2019 00:25:32 +0000"  >&lt;p&gt;This is not a regression but a long-standing issue. &lt;/p&gt;</comment>
                            <comment id="16788369" author="irashid" created="Fri, 8 Mar 2019 23:14:07 +0000"  >&lt;p&gt;I&apos;m kind of amazed Spark works at all on different Platforms.  As you note, endianness probably cannot be different.  What kind of platform difference results in this issue?  Is it different versions of the JVM?  I&apos;d also be amazed if that worked properly.&lt;/p&gt;

&lt;p&gt;I&apos;m not saying we shouldn&apos;t fix this if its easy, but maybe we should clarify how different the &quot;platform&quot; can be between containers in a spark app?&lt;/p&gt;</comment>
                            <comment id="16788848" author="dbtsai" created="Sun, 10 Mar 2019 06:00:55 +0000"  >&lt;p&gt;Issue resolved by pull request 24032&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/24032&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/24032&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16788862" author="dbtsai" created="Sun, 10 Mar 2019 08:23:20 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=irashid&quot; class=&quot;user-hover&quot; rel=&quot;irashid&quot;&gt;irashid&lt;/a&gt; Initially, I was thinking this fix is for the platform difference of endianness. By looking at the test, this bug can happen when both executors and driver are x86, but `UseCompressedOops` is turned off in the executors to access more than 32GB of the heap while the driver uses the default JVM option with `UseCompressedOops` on with less memory. Thus, in driver, the references will be 32-bit in 64-bit JVM resulting different byte array offset. &lt;/p&gt;</comment>
                            <comment id="17063909" author="angerszhuuu" created="Sat, 21 Mar 2020 13:23:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=irashid&quot; class=&quot;user-hover&quot; rel=&quot;irashid&quot;&gt;irashid&lt;/a&gt;&#160;to be honest, I meet this problem these days.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dbtsai&quot; class=&quot;user-hover&quot; rel=&quot;dbtsai&quot;&gt;dbtsai&lt;/a&gt;&#160;I have some question.&#160;&lt;br/&gt;
We start a self-developed thrift server program &#160;and use spark as compute engine with below javaOptions parameter&lt;br/&gt;
&#160;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Xmx64g&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Djava.library.path=/home/hadoop/hadoop/lib/native&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Djavax.security.auth.useSubjectCredsOnly=false&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Dcom.sun.management.jmxremote.port=9021&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Dcom.sun.management.jmxremote.authenticate=false&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-Dcom.sun.management.jmxremote.ssl=false&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-XX:MaxPermSize=1024m -XX:PermSize=256m -XX:MaxDirectMemorySize=8192m -XX:-TraceClassUnloading&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;-XX:+UseCompressedOops -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelRemarkEnabled -XX:+DisableExplicitGC -XX:+PrintTenuringDistribution -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=75 -Xnoclassgc -XX:+PrintGCDetails -XX:+PrintGCDateStamps&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;&#160;&lt;/font&gt;&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;&#160;&lt;/font&gt;&lt;br/&gt;
Then the &lt;font color=&quot;#347eec&quot;&gt;Platform&lt;/font&gt;&lt;font color=&quot;#e14141&quot;&gt;.&lt;/font&gt;&#160;&lt;font color=&quot;#347eec&quot;&gt;BYTE_ARRAY_OFFSET&lt;/font&gt; will be 24, when we start a normal spark thrift server, the value will be 16, this problem cause strange data&#160;corruption.&#160;&lt;br/&gt;
After few days check,&#160;I located the problem because of spark &#160;&lt;b&gt;codegen&lt;/b&gt;&#65292; and&#160; this pr can fix our problem , but I can&#8217;t find &#160;evidence why&#160;&lt;br/&gt;
Platform.BYTE_ARRAY_OFFSET will be 24 in above parameter. Since I test in local that when we set &#160;&lt;font color=&quot;#e14141&quot;&gt; -XX:+&#160;UseCompressedOops, &#160;&lt;/font&gt;&#160;using pointer compression it&apos;s going to be 16.&lt;br/&gt;
&lt;font color=&quot;#e14141&quot;&gt;&#160;&lt;del&gt;XX:&lt;/del&gt;&#160;UseCompressedOops, &#160;&lt;/font&gt;&#160;not using pointer compression it&apos;s going to be 24. This is easy to understand why the offset is not same.&lt;br/&gt;
But I don&#8217;t know why above parameter will be 24 since I am not a professor &#160;about java compiler and &#160;Basic computer knowledge.&lt;br/&gt;
&#160;&lt;br/&gt;
Can you give me some advisor or&#160;information about how to understand and find the root cause.&lt;br/&gt;
&#160;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 34 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z00hbk:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>