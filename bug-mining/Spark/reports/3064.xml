<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:37:26 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-13122] Race condition in MemoryStore.unrollSafely() causes memory leak</title>
                <link>https://issues.apache.org/jira/browse/SPARK-13122</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;The &lt;a href=&quot;https://github.com/apache/spark/blob/v1.6.0/core/src/main/scala/org/apache/spark/storage/MemoryStore.scala#L249&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;unrollSafely()&lt;/a&gt; method in MemoryStore will progressively unroll the contents of a block iterator into memory. It works by reserving an initial chunk of unroll memory and periodically checking if more memory must be reserved as it unrolls the iterator. The memory reserved for performing the unroll is considered &quot;pending&quot; memory and is tracked on a per-task attempt ID bases in a map object named pendingUnrollMemoryMap. When the unrolled block is committed to storage memory in the &lt;a href=&quot;https://github.com/apache/spark/blob/v1.6.0/core/src/main/scala/org/apache/spark/storage/MemoryStore.scala#L362&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;tryToPut()&lt;/a&gt; method, a method named &lt;a href=&quot;https://github.com/apache/spark/blob/v1.6.0/core/src/main/scala/org/apache/spark/storage/MemoryStore.scala#L521&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;releasePendingUnrollMemoryForThisTask()&lt;/a&gt; is invoked and this pending memory is released. tryToPut() then proceeds to allocate the storage memory required for the block.&lt;/p&gt;

&lt;p&gt;The unrollSafely() method computes the amount of pending memory used for the unroll operation by saving the amount of unroll memory reserved for the particular task attempt ID at the start of the method in a variable named previousMemoryReserved and subtracting this value from the unroll memory dedicated to the task at the end of the method. This value is stored as the variable amountToTransferToPending. This amount is then subtracted from the per-task unrollMemoryMap and added to pendingUnrollMemoryMap.&lt;/p&gt;

&lt;p&gt;The amount of unroll memory consumed for the task is obtained from unrollMemoryMap via the currentUnrollMemoryForThisTask method. In order for the semantics of unrollSafely() to work, the value of unrollMemoryMap for the task returned by &lt;a href=&quot;https://github.com/apache/spark/blob/v1.6.0/core/src/main/scala/org/apache/spark/storage/MemoryStore.scala#L475&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;currentTaskAttemptId()&lt;/a&gt; must not be mutated between the computation of previousMemoryReserved and amountToTransferToPending. However, since there is no synchronization in place to ensure that computing both variables and updating the memory maps happens atomically, a race condition can occur when multiple threads for which currentTaskAttemptId() returns the same value are both trying to store blocks. This can lead to a negative value being computed for amountToTransferToPending, corrupting the unrollMemoryMap and pendingUnrollMemoryMap memory maps which in turn can lead to the memory manager leaking unroll memory.&lt;/p&gt;

&lt;p&gt;For example, lets consider how the state of the unrollMemoryMap and pendingUnrollMemoryMap variables might be affected if two threads returning the same value for currentTaskAttemptId() both execute unrollSafely() concurrently:&lt;/p&gt;


&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Thread 1&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Thread 2&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;unrollMemoryMap&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;pendingUnrollMemoryMap&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Enter unrollSafely()&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;perviousMemoryReserved = 0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;(perform unroll)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2097152 (2 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Enter unrollSafely()&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2097152 (2 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;perviousMemoryReserved = 2097152&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;2097152 (2 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;(performUnroll)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Enter finally { }&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;amtToTransfer =  3145728&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Update memory maps&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Return&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Enter finally { }&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;amtToTrasnfer = -2097152&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;0&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;3145728 (3 MiB)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;Update memory maps&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;-2097152 (2 MiB)&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;1048576 (1 MiB)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;



&lt;p&gt;In this example, we end up leaking 2 MiB of unroll memory since both Thread 1 and Thread 2 think that the task has only 1 MiB of unroll memory allocated to it when it actually has 3 MiB. The negative value stored in unrollMemoryMap will also propagate to future invocations of unrollSafely().&lt;/p&gt;

&lt;p&gt;In our particular case, this behavior manifests since the currentTaskAttemptId() method is returning -1 for each Spark receiver task. This in and of itself could be a bug and is something I&apos;m going to look into. We noticed that blocks would start to spill over to disk when more than enough storage memory was available, so we inserted log statements into MemoryManager&apos;s acquireUnrollMemory() and releaseUnrollMemory() in order to collect the number of unroll bytes acquired and released. When we plot the output, it is apparent that unroll memory is being leaked:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/budde/spark_debug/master/plots/UnifiedMemoryManager/leaked_unroll_bytes.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Running difference between acquire/release bytes:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/budde/spark_debug/master/plots/UnifiedMemoryManager/leaked_unroll_bytes_running_diff.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;However, if we change the implementation of unrollSafely() so that the entire method is within a synchronized block, we no longer see this leak:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/budde/spark_debug/master/plots/UnifiedMemoryManager/synchronized_unroll_bytes.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Running difference between acquire/release bytes:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/budde/spark_debug/master/plots/UnifiedMemoryManager/synchronized_unroll_bytes_running_diff.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12935801">SPARK-13122</key>
            <summary>Race condition in MemoryStore.unrollSafely() causes memory leak</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="budde">Adam Budde</assignee>
                                    <reporter username="budde">Adam Budde</reporter>
                        <labels>
                    </labels>
                <created>Tue, 2 Feb 2016 00:10:27 +0000</created>
                <updated>Wed, 3 Feb 2016 03:34:49 +0000</updated>
                            <resolved>Wed, 3 Feb 2016 03:34:49 +0000</resolved>
                                    <version>1.6.0</version>
                                    <fixVersion>1.6.1</fixVersion>
                    <fixVersion>2.0.0</fixVersion>
                                    <component>DStreams</component>
                    <component>Spark Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="15127381" author="apachespark" created="Tue, 2 Feb 2016 01:18:03 +0000"  >&lt;p&gt;User &apos;budde&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/11012&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/11012&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 42 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2s9k7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310320" key="com.atlassian.jira.plugin.system.customfieldtypes:multiversion">
                        <customfieldname>Target Version/s</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="12334009">1.6.1</customfieldvalue>
    <customfieldvalue id="12329449">2.0.0</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>