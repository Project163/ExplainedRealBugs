<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 18:50:48 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[SPARK-19017] NOT IN subquery with more than one column may return incorrect results</title>
                <link>https://issues.apache.org/jira/browse/SPARK-19017</link>
                <project id="12315420" key="SPARK">Spark</project>
                    <description>&lt;p&gt;When putting more than one column in the NOT IN, the query may not return correctly if there is a null data. We can demonstrate the problem with the following data set and query:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Seq((2,1)).toDF(&lt;span class=&quot;code-quote&quot;&gt;&quot;a1&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;b1&quot;&lt;/span&gt;).createOrReplaceTempView(&lt;span class=&quot;code-quote&quot;&gt;&quot;t1&quot;&lt;/span&gt;)
Seq[(java.lang.&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;,java.lang.&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;)]((1,&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)).toDF(&lt;span class=&quot;code-quote&quot;&gt;&quot;a2&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;b2&quot;&lt;/span&gt;).createOrReplaceTempView(&lt;span class=&quot;code-quote&quot;&gt;&quot;t2&quot;&lt;/span&gt;)

sql(&lt;span class=&quot;code-quote&quot;&gt;&quot;select * from t1 where (a1,b1) not in (select a2,b2 from t2)&quot;&lt;/span&gt;).show
+---+---+
| a1| b1|
+---+---+
+---+---+
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13030946">SPARK-19017</key>
            <summary>NOT IN subquery with more than one column may return incorrect results</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nsyca">Nattavut Sutyanyong</assignee>
                                    <reporter username="nsyca">Nattavut Sutyanyong</reporter>
                        <labels>
                            <label>correctness</label>
                    </labels>
                <created>Wed, 28 Dec 2016 20:22:53 +0000</created>
                <updated>Tue, 14 May 2019 06:27:04 +0000</updated>
                            <resolved>Tue, 24 Jan 2017 22:32:01 +0000</resolved>
                                    <version>2.0.0</version>
                    <version>2.0.1</version>
                    <version>2.0.2</version>
                    <version>2.1.0</version>
                                    <fixVersion>2.1.1</fixVersion>
                    <fixVersion>2.2.0</fixVersion>
                                    <component>SQL</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="15783653" author="nsyca" created="Wed, 28 Dec 2016 20:33:20 +0000"  >&lt;p&gt;The semantics of the NOT IN for multiple columns T1(a1, b1, ... ) NOT IN T2(a2, b2, ...) is&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;For any rows of T1 if a1 &amp;lt;&amp;gt; ALL (T2.a2), those rows are returned.&lt;/li&gt;
	&lt;li&gt;For any rows of T1 if a1 = ANY (T2.a2), take the qualified rows from T1 and T2 and compare the values from the next pair of columns with the similar condition in 1. &amp;#8211; if b1 &amp;lt;&amp;gt; ALL (T2.b2), those rows are returned.&lt;/li&gt;
	&lt;li&gt;Repeat the steps until the last pair in the column list.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="15783937" author="hvanhovell" created="Wed, 28 Dec 2016 23:10:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nsyca&quot; class=&quot;user-hover&quot; rel=&quot;nsyca&quot;&gt;nsyca&lt;/a&gt; Why is this incorrect?&lt;/p&gt;

&lt;p&gt;If I rewrite the NOT IN into a WHERE statement this would become:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;select * from t1 where (a1 &amp;lt;&amp;gt; 1 AND b1 &amp;lt;&amp;gt; NULL)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;There WHERE would evaluate to NULL, and it would never return a result.&lt;/p&gt;</comment>
                            <comment id="15785417" author="nsyca" created="Thu, 29 Dec 2016 14:33:39 +0000"  >&lt;p&gt;Using your interpretation, (2,1) not in (2,0) would be evaluated to false. Spark returns (2,1). So do many other SQL engines.&lt;/p&gt;</comment>
                            <comment id="15785436" author="hvanhovell" created="Thu, 29 Dec 2016 14:43:28 +0000"  >&lt;p&gt;Ok, that is fair. Let me correct my mistake.&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;NOT IN&lt;/tt&gt; can be rewritten into, in to a sequence of NOT equals statements. Each statement contains one tuple of the subquery relation. So we would get something like:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;WHERE (NOT (a1 = a2(1) AND  b1 = b2(1))) AND (NOT (a1 = a2(2) AND  b1 = b2(2))) AND ... AND (NOT (a1 = a2(n) AND  b1 = b2(n)))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Which can be rewritten into:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;WHERE  (a1 &amp;lt;&amp;gt; a2(1) OR  b1 &amp;lt;&amp;gt; b2(1)) AND (a1 &amp;lt;&amp;gt; a2(2) OR  b1 &amp;lt;&amp;gt; b2(2)) AND ... AND (a1 &amp;lt;&amp;gt; a2(n) OR  b1 &amp;lt;&amp;gt; b2(n))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This would evaluate to null if one of the tuples in the subquery relation contains a null.&lt;/p&gt;</comment>
                            <comment id="15785496" author="nsyca" created="Thu, 29 Dec 2016 15:13:11 +0000"  >&lt;p&gt;In 3-value logic, true OR unknown = true. Using your formula above, we will have (2,1) NOT IN (1,null) evaluated as (2 &amp;lt;&amp;gt; 1) OR (1 &amp;lt;&amp;gt; null) which is true.&lt;/p&gt;</comment>
                            <comment id="15796839" author="apachespark" created="Wed, 4 Jan 2017 01:40:04 +0000"  >&lt;p&gt;User &apos;nsyca&apos; has created a pull request for this issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/spark/pull/16467&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/spark/pull/16467&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15798758" author="hvanhovell" created="Wed, 4 Jan 2017 17:09:47 +0000"  >&lt;p&gt;Ok, my bad. Lets try this again.&lt;/p&gt;

&lt;p&gt;If I follow the NAAJ explanation in the section 6.1 of the Enhanced Subquery Optimizations in Oracle paper (�����������&lt;a href=&quot;http://www.vldb.org/pvldb/2/vldb09-423.pdf&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.vldb.org/pvldb/2/vldb09-423.pdf&lt;/a&gt;). Then I can rewrite the following query &lt;tt&gt;select * from tbl_a where a not in (select b from tbl_b)&lt;/tt&gt; into the following (given that tbl_b has n elements):&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;SELECT *
FROM    TBL_a
WHERE  a &amp;lt;&amp;gt; b1 AND a &amp;lt;&amp;gt; b2 AND ... AND a &amp;lt;&amp;gt; bn
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My basic thought here is that if we are comparing a complete tuple, for instance (2, 1), to an incomplete tuple, for instance (2, null), then the result should be unknown (null). Following this it would be obvious that a conjunctive predicate containing such an incomplete comparison should also evaluate to unknown.&lt;/p&gt;

&lt;p&gt;It now boils down to how we should compare the tuples; i.e. how is &lt;tt&gt;a &amp;lt;&amp;gt; b&lt;/tt&gt; evaluated. Note that I do not have an answer here. The following two things could apply:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;not(a.x1 = b.x1 and a.x2 = b.x2 and ... and a.xn = b.xn)&lt;/tt&gt;  - I would lean towards this option.&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;a.x1 &amp;lt;&amp;gt; b.x1 or a.x2 &amp;lt;&amp;gt; b.x2 or ... or a.xn &amp;lt;&amp;gt; b.xn)&lt;/tt&gt; - Spark currently implements this option if you compare structs.&lt;/li&gt;
&lt;/ul&gt;


</comment>
                            <comment id="15799055" author="nsyca" created="Wed, 4 Jan 2017 18:59:40 +0000"  >&lt;p&gt;I think we both agree that the result of the expression &lt;tt&gt;(2, 1) = (2, null)&lt;/tt&gt; is unknown (null). It is the negation of this expression that is the centre of this discussion.&lt;/p&gt;

&lt;p&gt;If &lt;tt&gt;a = (2, 1)&lt;/tt&gt; and &lt;tt&gt;b = (1, null)&lt;/tt&gt;, what is the semantics of &lt;tt&gt;a &amp;lt;&amp;gt; b&lt;/tt&gt;? You have suggested two formulas&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;not(a.x1 = b.x1 and a.x2 = b.x2)&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;a.x1 &amp;lt;&amp;gt; b.x1 or a.x2 &amp;lt;&amp;gt; b.x2&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;Would you agree that these two formulas are equivalent? The second formula is just the result of applying De Morgan&apos;s laws on the first formula, i.e., &lt;tt&gt;not (x and y) == (not x) or (not y)&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;How does Spark evaluate the formulas today? Here is my test:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;scala&amp;gt; Seq(1).toDF(&lt;span class=&quot;code-quote&quot;&gt;&quot;t1a&quot;&lt;/span&gt;).createOrReplaceTempView(&lt;span class=&quot;code-quote&quot;&gt;&quot;t1&quot;&lt;/span&gt;)

scala&amp;gt; sql(&lt;span class=&quot;code-quote&quot;&gt;&quot;select t1a from t1&quot;&lt;/span&gt;).show
+---+
|t1a|
+---+
|  1|
+---+

scala&amp;gt; sql(&lt;span class=&quot;code-quote&quot;&gt;&quot;select t1a from t1 where not (2=1 and 1=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)&quot;&lt;/span&gt;).show
+---+
|t1a|
+---+
|  1|
+---+


scala&amp;gt; sql(&lt;span class=&quot;code-quote&quot;&gt;&quot;select t1a from t1 where 2&amp;lt;&amp;gt;1 or 1&amp;lt;&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&quot;&lt;/span&gt;).show
+---+
|t1a|
+---+
|  1|
+---+
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15799335" author="nsyca" created="Wed, 4 Jan 2017 21:05:35 +0000"  >&lt;p&gt;I also have the output from a MySQL system. Note that I changed the tuple in &lt;tt&gt;t2&lt;/tt&gt; to &lt;tt&gt;(3, null)&lt;/tt&gt; to avoid having the value &lt;tt&gt;1&lt;/tt&gt; twice but it should not make any difference.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;$ mysql -V
mysql  Ver 14.14 Distrib 5.1.73, &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; redhat-linux-gnu (x86_64) using readline 5.1

mysql&amp;gt; create table mydb.t1(t1a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, t1b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
Query OK, 0 rows affected (0.08 sec)

mysql&amp;gt; create table mydb.t2(t2a &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;, t2b &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;);
Query OK, 0 rows affected (0.11 sec)

mysql&amp;gt; insert into mydb.t1 values(2,1);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; insert into mydb.t2 values(3, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; select * from mydb.t1 where(t1a, t1b) not in(select t2a, t2b from mydb.t2);
+------+------+
| t1a  | t1b  |
+------+------+
|    2 |    1 |
+------+------+
1 row in set (0.00 sec)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15799369" author="hvanhovell" created="Wed, 4 Jan 2017 21:15:34 +0000"  >&lt;p&gt;I agree that they are equal.&lt;/p&gt;

&lt;p&gt;It just seems weird to me that in some cases it is ok that the tuples in the subquery can have null values. That being said, I am convinced that your approach is correct.&lt;/p&gt;

&lt;p&gt;I have also checked if comparing structs returns the same results as the underlying fields. In some cases it does not:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;scala&amp;gt; sql(&quot;select (2, 2) &amp;lt;&amp;gt; (2, cast(null as int)) as c1, 2 &amp;lt;&amp;gt; 1 or 2 &amp;lt;&amp;gt; cast(null as int) as c2&quot;).show
+----+----+
|  c1|  c2|
+----+----+
|true|true|
+----+----+

scala&amp;gt; sql(&quot;select (1, 2) &amp;lt;&amp;gt; (2, cast(null as int)) as c1, 1 &amp;lt;&amp;gt; 1 or 2 &amp;lt;&amp;gt; cast(null as int) as c2&quot;).show
+----+----+
|  c1|  c2|
+----+----+
|true|null| &amp;lt;-- Result for struct is wrong.
+----+----+
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We fortunately do not use this, but this is still a bug.&lt;/p&gt;</comment>
                            <comment id="15799374" author="hvanhovell" created="Wed, 4 Jan 2017 21:16:28 +0000"  >&lt;p&gt;Thanks for checking!&lt;/p&gt;</comment>
                            <comment id="15799388" author="nsyca" created="Wed, 4 Jan 2017 21:24:42 +0000"  >&lt;p&gt;In the first query, the result does not look right to me.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;c1: (2 &amp;lt;&amp;gt; 2) or (2 &amp;lt;&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; or unknown =&amp;gt; unknown &amp;lt;- why &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;?
c2: (2 &amp;lt;&amp;gt; 1) or (2 &amp;lt;&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; or unknown =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In the second query,&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;c1: (1 &amp;lt;&amp;gt; 2) or (2 &amp;lt;&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; or unknown =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;
c2: (1 &amp;lt;&amp;gt; 1) or (2 &amp;lt;&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt; or unknown =&amp;gt; unknown &amp;lt;-- This is correct, right?
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In (P1 or P2), if P1 is true, we can short-circuit and conclude the result is true. In the latter case, if P1 is false, we have to continue evaluating P2 and since P2 is unknown, the result is unknown.&lt;/p&gt;</comment>
                            <comment id="15801624" author="nsyca" created="Thu, 5 Jan 2017 15:20:47 +0000"  >&lt;p&gt;One way to interpret the behaviour of the comparison of tuples is it operates strictly on 2-value logic of the comparison of each element of the tuples.&lt;/p&gt;

&lt;p&gt;That is,&lt;/p&gt;

&lt;p&gt;Case 1:&lt;br/&gt;
(a1, a2) = (b1, b2)&lt;/p&gt;

&lt;p&gt;is interpreted as&lt;/p&gt;

&lt;p&gt;IF (a1 = b1) is true THEN true ELSE false&lt;br/&gt;
AND&lt;br/&gt;
IF (a2 = b2) is true THEN true ELSE false&lt;/p&gt;

&lt;p&gt;Case 2:&lt;br/&gt;
(a1, a2) &amp;lt;&amp;gt; (b1, b2)&lt;/p&gt;

&lt;p&gt;is interpreted as a negation of the equality operator on the 2-value logic of each element.&lt;/p&gt;

&lt;p&gt;IF (a1 = b1) is true THEN false ELSE true&lt;br/&gt;
OR&lt;br/&gt;
IF (a2 = b2) is true THEN false ELSE true&lt;/p&gt;


&lt;p&gt;The NOT IN semantics is different that it preserves the 3-value logic in the comparison of each element.&lt;/p&gt;

&lt;p&gt;I don&apos;t know that we should align the two usages to the same semantics or not. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13029845">SPARK-18966</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 45 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i382wv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>