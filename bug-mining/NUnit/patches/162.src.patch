diff --git a/src/NUnitFramework/framework/Attributes/RepeatAttribute.cs b/src/NUnitFramework/framework/Attributes/RepeatAttribute.cs
index 48b725541..06ee409ed 100644
--- a/src/NUnitFramework/framework/Attributes/RepeatAttribute.cs
+++ b/src/NUnitFramework/framework/Attributes/RepeatAttribute.cs
@@ -40,7 +40,7 @@ namespace NUnit.Framework
     /// to run it multiple times.
     /// </summary>
     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
-    public class RepeatAttribute : PropertyAttribute, IWrapSetUpTearDown
+    public class RepeatAttribute : PropertyAttribute, IRepeatTest
     {
         private readonly int _count;
 
@@ -53,7 +53,7 @@ namespace NUnit.Framework
             _count = count;
         }
 
-        #region IWrapSetUpTearDown Members
+        #region IRepeatTest Members
 
         /// <summary>
         /// Wrap a command and return the result.
diff --git a/src/NUnitFramework/framework/Attributes/RetryAttribute.cs b/src/NUnitFramework/framework/Attributes/RetryAttribute.cs
index 6d52e1862..6fb5d8c01 100644
--- a/src/NUnitFramework/framework/Attributes/RetryAttribute.cs
+++ b/src/NUnitFramework/framework/Attributes/RetryAttribute.cs
@@ -1,5 +1,5 @@
 // ***********************************************************************
-// Copyright (c) 2015 Charlie Poole, Rob Prouse
+// Copyright (c) 2018 Charlie Poole, Rob Prouse
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -33,7 +33,7 @@ namespace NUnit.Framework
     /// be rerun if it fails, up to a maximum number of times.
     /// </summary>
     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
-    public class RetryAttribute : PropertyAttribute, IWrapSetUpTearDown
+    public class RetryAttribute : PropertyAttribute, IRepeatTest
     {
         private readonly int _tryCount;
 
@@ -46,7 +46,7 @@ namespace NUnit.Framework
             _tryCount = tryCount;
         }
 
-        #region IWrapSetUpTearDown Members
+        #region IRepeatTest Members
 
         /// <summary>
         /// Wrap a command and return the result.
diff --git a/src/NUnitFramework/framework/Interfaces/ICommandWrapper.cs b/src/NUnitFramework/framework/Interfaces/ICommandWrapper.cs
index daab12f5d..6d12c32cf 100644
--- a/src/NUnitFramework/framework/Interfaces/ICommandWrapper.cs
+++ b/src/NUnitFramework/framework/Interfaces/ICommandWrapper.cs
@@ -63,4 +63,13 @@ namespace NUnit.Framework.Interfaces
     public interface IWrapSetUpTearDown : ICommandWrapper
     {
     }
+
+    /// <summary>
+    /// Objects implementing this interface are used to wrap
+    /// tests that can repeat. The implementing command is run once,
+    /// invoking the chained commands any number of times.
+    /// </summary>
+    public interface IRepeatTest : ICommandWrapper
+    {
+    }
 }
diff --git a/src/NUnitFramework/framework/Internal/Builders/NUnitTestCaseBuilder.cs b/src/NUnitFramework/framework/Internal/Builders/NUnitTestCaseBuilder.cs
index 192c2aa7e..87aa527aa 100644
--- a/src/NUnitFramework/framework/Internal/Builders/NUnitTestCaseBuilder.cs
+++ b/src/NUnitFramework/framework/Internal/Builders/NUnitTestCaseBuilder.cs
@@ -59,6 +59,8 @@ namespace NUnit.Framework.Internal.Builders
                 Seed = _randomizer.Next()
             };
 
+            CheckTestMethodAttributes(testMethod);
+
             CheckTestMethodSignature(testMethod, parms);
 
             if (parms == null || parms.Arguments == null)
@@ -106,6 +108,20 @@ namespace NUnit.Framework.Internal.Builders
 
         #region Helper Methods
 
+        /// <summary>
+        /// Checks to see if we have valid combinations of attributes.
+        /// </summary>
+        /// <param name="testMethod">The TestMethod to be checked. If it
+        /// is found to be non-runnable, it will be modified.</param>
+        /// <returns>True if the method signature is valid, false if not</returns>
+        private static bool CheckTestMethodAttributes(TestMethod testMethod)
+        {
+            if (testMethod.Method.GetAttributes<IRepeatTest>(true).Length > 1)
+                return MarkAsNotRunnable(testMethod, "Multiple attributes that repeat a test may cause issues.");
+
+            return true;
+        }
+
         /// <summary>
         /// Helper method that checks the signature of a TestMethod and
         /// any supplied parameters to determine if the test is valid.
diff --git a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItem.cs b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItem.cs
index c723d5711..8977da8c6 100644
--- a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItem.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItem.cs
@@ -153,6 +153,10 @@ namespace NUnit.Framework.Internal.Execution
                     command = new TimeoutCommand(command, timeout);
 #endif
 
+                // Add wrappers for repeatable tests after timeout so the timeout is reset on each repeat
+                foreach (var repeatableAttribute in method.GetAttributes<IRepeatTest>(true))
+                    command = repeatableAttribute.Wrap(command);
+
                 return command;
             }
             else
diff --git a/src/NUnitFramework/tests/Attributes/RepeatableTestsWithTimeoutAttributesTests.cs b/src/NUnitFramework/tests/Attributes/RepeatableTestsWithTimeoutAttributesTests.cs
new file mode 100644
index 000000000..4837dbaf4
--- /dev/null
+++ b/src/NUnitFramework/tests/Attributes/RepeatableTestsWithTimeoutAttributesTests.cs
@@ -0,0 +1,145 @@
+// ***********************************************************************
+// Copyright (c) 2018 Charlie Poole, Rob Prouse
+//
+// Permission is hereby granted, free of charge, to any person obtaining
+// a copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+// 
+// The above copyright notice and this permission notice shall be
+// included in all copies or substantial portions of the Software.
+// 
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+// ***********************************************************************
+
+using System;
+using NUnit.Framework.Interfaces;
+using NUnit.Framework.Internal;
+using NUnit.Framework.Internal.Commands;
+using NUnit.TestUtilities;
+
+#if THREAD_ABORT
+
+namespace NUnit.Framework.Attributes
+{
+    [TestFixture]
+    public class RepeatableTestsWithTimeoutAttributesTests
+    {
+        private int retryOnlyCount;
+        private int retryTimeoutCount;
+        private int repeatTimeoutCount;
+
+        [Test]
+        [Retry(3)]
+        public void ShouldPassAfter3Retries()
+        {
+            retryOnlyCount++;
+            Assert.True(retryOnlyCount >= 2);
+        }
+
+        [Test]
+        [Retry(3), Timeout(85)]
+        public void ShouldPassAfter3RetriesAndTimeoutIsResetEachTime()
+        {
+            retryTimeoutCount++;
+
+            System.Threading.Thread.Sleep(30);
+            Assert.True(retryTimeoutCount >= 2);
+        }
+
+        [Test]
+        [Repeat(3), Timeout(85)]
+        public void ShouldPassAfter2RepeatsAndTimeoutIsResetEachTime()
+        {
+            repeatTimeoutCount++;
+
+            System.Threading.Thread.Sleep(30);
+            Assert.True(repeatTimeoutCount >= 1);
+        }
+
+        [Test]
+        public void ShouldFailOnMultipleRepeatableAttributes()
+        {
+            var testCase = TestBuilder.MakeTestCase(GetType(), nameof(TestMethodForRepeatAndRetryExpectedFail));
+            var workItem = TestBuilder.CreateWorkItem(testCase);
+            var result = TestBuilder.ExecuteWorkItem(workItem);
+            
+            Assert.AreEqual(TestStatus.Failed, result.ResultState.Status);
+            Assert.AreEqual(FailureSite.Test, result.ResultState.Site);
+            Assert.AreEqual("Invalid", result.ResultState.Label);
+        }
+
+        [Test]
+        public void ShouldFailOnMultipleRepeatableAttributesIncludingCustom()
+        {
+            var testCase = TestBuilder.MakeTestCase(GetType(), nameof(TestMethodForRepeatAndCustomRepeatExpectedFail));
+            var workItem = TestBuilder.CreateWorkItem(testCase);
+            var result = TestBuilder.ExecuteWorkItem(workItem);
+
+            Assert.AreEqual(TestStatus.Failed, result.ResultState.Status);
+            Assert.AreEqual(FailureSite.Test, result.ResultState.Site);
+            Assert.AreEqual("Invalid", result.ResultState.Label);
+        }
+
+        [Repeat(1), Retry(1)]
+        public void TestMethodForRepeatAndRetryExpectedFail() { }
+
+        [Repeat(1), CustomRepeater]
+        public void TestMethodForRepeatAndCustomRepeatExpectedFail() { }
+
+        #region TestCustomAttribute
+
+        internal class CustomRepeater : Attribute, IRepeatTest
+        {
+            public TestCommand Wrap(TestCommand command) { return null; }
+        }
+
+        #endregion
+    }
+
+    [TestFixture]
+    public class BaseRepeatableTestFixture
+    {
+        protected int RepeatCount = 0;
+
+        [Test, Retry(2)]
+        public virtual void ShouldBeOveridden()
+        {
+            RepeatCount++;
+            Assert.True(RepeatCount >= 1);
+        }
+    }
+
+    [TestFixture]
+    public class DerivedRepeatableTestFixture : BaseRepeatableTestFixture
+    {
+        [Test, Retry(3)]
+        public override void ShouldBeOveridden()
+        {
+            RepeatCount++;
+            Assert.True(RepeatCount >= 2);
+        }
+    }
+
+    [TestFixture]
+    public class DerivedRepeatableTestFixtureWithNoRepeat : BaseRepeatableTestFixture
+    {
+        [Test]
+        public override void ShouldBeOveridden()
+        {
+            RepeatCount++;
+            Assert.True(RepeatCount == 1);
+        }
+    }
+}
+
+#endif
