diff --git a/src/NUnitFramework/framework/Constraints/MsgUtils.cs b/src/NUnitFramework/framework/Constraints/MsgUtils.cs
index 0f1f0893b..a5ee253d7 100644
--- a/src/NUnitFramework/framework/Constraints/MsgUtils.cs
+++ b/src/NUnitFramework/framework/Constraints/MsgUtils.cs
@@ -25,6 +25,7 @@ using System;
 using System.Text;
 using System.Collections;
 using System.Globalization;
+using NUnit.Framework.Internal;
 
 namespace NUnit.Framework.Constraints
 {
@@ -43,37 +44,6 @@ namespace NUnit.Framework.Constraints
     /// <remarks>If the given formatter is unable to handle a certain format, it must call the next formatter in the chain</remarks>
     public delegate ValueFormatter ValueFormatterFactory(ValueFormatter next);
 
-    /// <summary>
-    /// Small class to allow adding ValueFormatter instances to MsgUtils
-    /// without exposing MsgUtils publicly.
-    /// </summary>
-    public static class ValueFormatters
-    {
-        /// <summary>
-        /// This method adds the a new ValueFormatterFactory to the
-        /// chain of responsibility.
-        /// </summary>
-        /// <param name="formatterFactory">The factory delegate</param>
-        public static void Add(ValueFormatterFactory formatterFactory)
-        {
-            MsgUtils.AddFormatter(formatterFactory);
-        }
-
-        /// <summary>
-        /// This method provides a simplified way to add a ValueFormatter
-        /// delegate to the chain of responsibility, creating the factory
-        /// delegate internally. It is useful when the Type of the object
-        /// is the only criterion for selection of the formatter, since
-        /// it can be used without getting involved with a compould function.
-        /// </summary>
-        /// <typeparam name="TSUPPORTED">The type supported by this formatter</typeparam>
-        /// <param name="formatter">The ValueFormatter delegate</param>
-        public static void Add<TSUPPORTED>(ValueFormatter formatter)
-        {
-            Add(next => val => (val is TSUPPORTED) ? formatter(val) : next(val));
-        }
-    }
-
     /// <summary>
     /// Static methods used in creating messages
     /// </summary>
@@ -98,12 +68,15 @@ namespace NUnit.Framework.Constraints
         private static readonly string Fmt_Default = "<{0}>";
 
         /// <summary>
-        /// Format function that will be invoked as last effort
-        /// for values of indeterminate type.
+        /// Current head of chain of value formatters. Public for testing.
         /// </summary>
-        static ValueFormatter ValueFormatter = val => string.Format(Fmt_Default, val);
+        public static ValueFormatter DefaultValueFormatter { get; set; }
+
         static MsgUtils()
         {
+            // Initialize formatter to default for values of indeterminate type.
+            DefaultValueFormatter = val => string.Format(Fmt_Default, val);
+
             AddFormatter(next => val => val is ValueType ? string.Format(Fmt_ValueType, val) : next(val));
 
             AddFormatter(next => val => val is DateTime ? FormatDateTime((DateTime)val) : next(val));
@@ -139,7 +112,7 @@ namespace NUnit.Framework.Constraints
         /// <param name="formatterFactory"></param>
         public static void AddFormatter(ValueFormatterFactory formatterFactory)
         {
-            ValueFormatter = formatterFactory(ValueFormatter);
+            DefaultValueFormatter = formatterFactory(DefaultValueFormatter);
         }
 
         /// <summary>
@@ -149,7 +122,15 @@ namespace NUnit.Framework.Constraints
         /// <returns>The formatted text</returns>
         public static string FormatValue(object val)
         {
-            return val == null ? Fmt_Null : ValueFormatter(val);
+            if (val == null)
+                return Fmt_Null;
+
+            var context = TestExecutionContext.CurrentContext;
+
+            if (context != null)
+                return context.CurrentValueFormatter(val);
+            else
+                return DefaultValueFormatter(val);
         }
 
         /// <summary>
diff --git a/src/NUnitFramework/framework/GlobalSettings.cs b/src/NUnitFramework/framework/GlobalSettings.cs
index 7f9214f6f..80cd9ac02 100644
--- a/src/NUnitFramework/framework/GlobalSettings.cs
+++ b/src/NUnitFramework/framework/GlobalSettings.cs
@@ -1,5 +1,5 @@
 // ***********************************************************************
-// Copyright (c) 2008 Charlie Poole
+// Copyright (c) 2016 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
@@ -22,18 +22,45 @@
 // ***********************************************************************
 
 using System;
+using NUnit.Framework.Constraints;
 
 namespace NUnit.Framework
 {
 	/// <summary>
-	/// GlobalSettings is a place for setting default _values used
-	/// by the framework in performing asserts.
+	/// GlobalSettings is a place for setting default values used
+	/// by the framework in performing asserts. Anything set through
+    /// this class applies to the entire test run. It should not normally
+    /// be used from within a test, since it is not thread-safe.
 	/// </summary>
-	public class GlobalSettings
+	public static class GlobalSettings
 	{
 		/// <summary>
 		/// Default tolerance for floating point equality
 		/// </summary>
 		public static double DefaultFloatingPointTolerance = 0.0d;
-	}
+
+        /// <summary>
+        /// This method adds the a new ValueFormatterFactory to the
+        /// global chain of responsibility maintained by MsgUtils.
+        /// </summary>
+        /// <param name="formatterFactory">The factory delegate</param>
+        public static void AddFormatter(ValueFormatterFactory formatterFactory)
+        {
+            MsgUtils.AddFormatter(formatterFactory);
+        }
+
+        /// <summary>
+        /// This method provides a simplified way to add a ValueFormatter
+        /// delegate to the chain of responsibility, creating the factory
+        /// delegate internally. It is useful when the Type of the object
+        /// is the only criterion for selection of the formatter, since
+        /// it can be used without getting involved with a compould function.
+        /// </summary>
+        /// <typeparam name="TSUPPORTED">The type supported by this formatter</typeparam>
+        /// <param name="formatter">The ValueFormatter delegate</param>
+        public static void AddFormatter<TSUPPORTED>(ValueFormatter formatter)
+        {
+            AddFormatter(next => val => (val is TSUPPORTED) ? formatter(val) : next(val));
+        }
+    }
 }
diff --git a/src/NUnitFramework/framework/Internal/TestExecutionContext.cs b/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
index f9f6414fe..d3363aa33 100644
--- a/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
+++ b/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
@@ -27,6 +27,7 @@ using System.Globalization;
 using System.Diagnostics;
 using System.IO;
 using System.Threading;
+using NUnit.Framework.Constraints;
 using NUnit.Framework.Interfaces;
 using NUnit.Framework.Internal.Execution;
 
@@ -117,8 +118,8 @@ namespace NUnit.Framework.Internal
         public TestExecutionContext()
         {
             _priorContext = null;
-            this.TestCaseTimeout = 0;
-            this.UpstreamActions = new List<ITestAction>();
+            TestCaseTimeout = 0;
+            UpstreamActions = new List<ITestAction>();
 
             _currentCulture = CultureInfo.CurrentCulture;
             _currentUICulture = CultureInfo.CurrentUICulture;
@@ -126,6 +127,8 @@ namespace NUnit.Framework.Internal
 #if !NETCF && !SILVERLIGHT && !PORTABLE
             _currentPrincipal = Thread.CurrentPrincipal;
 #endif
+
+            CurrentValueFormatter = (val) => MsgUtils.DefaultValueFormatter(val);
         }
 
         /// <summary>
@@ -136,14 +139,14 @@ namespace NUnit.Framework.Internal
         {
             _priorContext = other;
 
-            this.CurrentTest = other.CurrentTest;
-            this.CurrentResult = other.CurrentResult;
-            this.TestObject = other.TestObject;
-            this.WorkDirectory = other.WorkDirectory;
+            CurrentTest = other.CurrentTest;
+            CurrentResult = other.CurrentResult;
+            TestObject = other.TestObject;
+            WorkDirectory = other.WorkDirectory;
             _listener = other._listener;
-            this.StopOnError = other.StopOnError;
-            this.TestCaseTimeout = other.TestCaseTimeout;
-            this.UpstreamActions = new List<ITestAction>(other.UpstreamActions);
+            StopOnError = other.StopOnError;
+            TestCaseTimeout = other.TestCaseTimeout;
+            UpstreamActions = new List<ITestAction>(other.UpstreamActions);
 
             _currentCulture = other.CurrentCulture;
             _currentUICulture = other.CurrentUICulture;
@@ -152,8 +155,10 @@ namespace NUnit.Framework.Internal
             _currentPrincipal = other.CurrentPrincipal;
 #endif
 
-            this.Dispatcher = other.Dispatcher;
-            this.ParallelScope = other.ParallelScope;
+            CurrentValueFormatter = other.CurrentValueFormatter;
+
+            Dispatcher = other.Dispatcher;
+            ParallelScope = other.ParallelScope;
         }
 
         #endregion
@@ -435,6 +440,11 @@ namespace NUnit.Framework.Internal
         }
 #endif
 
+        /// <summary>
+        /// The current head of the ValueFormatter chain, copied from MsgUtils.ValueFormatter
+        /// </summary>
+        public ValueFormatter CurrentValueFormatter { get; private set; }
+
         #endregion
 
         #region Instance Methods
@@ -491,6 +501,15 @@ namespace NUnit.Framework.Internal
                 Interlocked.Increment(ref _assertCount);
         }
 
+        /// <summary>
+        /// Adds a new ValueFormatterFactory to the chain of formatters
+        /// </summary>
+        /// <param name="formatterFactory">The new factory</param>
+        public void AddFormatter(ValueFormatterFactory formatterFactory)
+        {
+            CurrentValueFormatter = formatterFactory(CurrentValueFormatter);
+        }
+
         #endregion
 
         #region InitializeLifetimeService
diff --git a/src/NUnitFramework/framework/TestContext.cs b/src/NUnitFramework/framework/TestContext.cs
index c3672987c..889529aff 100644
--- a/src/NUnitFramework/framework/TestContext.cs
+++ b/src/NUnitFramework/framework/TestContext.cs
@@ -23,6 +23,7 @@
 
 using System;
 using System.IO;
+using NUnit.Framework.Constraints;
 using NUnit.Framework.Interfaces;
 using NUnit.Framework.Internal;
 
@@ -226,6 +227,31 @@ namespace NUnit.Framework
         /// <summary>Write a formatted string to the current result followed by a line terminator</summary>
         public static void WriteLine(string format, params object[] args) { Out.WriteLine(format, args); }
 
+        /// <summary>
+        /// This method adds the a new ValueFormatterFactory to the
+        /// chain of responsibility used for fomatting values in messages.
+        /// The scope of the change is the current TestContext.
+        /// </summary>
+        /// <param name="formatterFactory">The factory delegate</param>
+        public static void AddFormatter(ValueFormatterFactory formatterFactory)
+        {
+            TestExecutionContext.CurrentContext.AddFormatter(formatterFactory);
+        }
+
+        /// <summary>
+        /// This method provides a simplified way to add a ValueFormatter
+        /// delegate to the chain of responsibility, creating the factory
+        /// delegate internally. It is useful when the Type of the object
+        /// is the only criterion for selection of the formatter, since
+        /// it can be used without getting involved with a compould function.
+        /// </summary>
+        /// <typeparam name="TSUPPORTED">The type supported by this formatter</typeparam>
+        /// <param name="formatter">The ValueFormatter delegate</param>
+        public static void AddFormatter<TSUPPORTED>(ValueFormatter formatter)
+        {
+            AddFormatter(next => val => (val is TSUPPORTED) ? formatter(val) : next(val));
+        }
+
         #endregion
 
         #region Nested TestAdapter Class
diff --git a/src/NUnitFramework/tests/Constraints/MsgUtilTests.cs b/src/NUnitFramework/tests/Constraints/MsgUtilTests.cs
index f40269a13..c732dd2f3 100644
--- a/src/NUnitFramework/tests/Constraints/MsgUtilTests.cs
+++ b/src/NUnitFramework/tests/Constraints/MsgUtilTests.cs
@@ -35,26 +35,75 @@ namespace NUnit.Framework.Constraints
         class CustomFormattableType { }
 
         [Test]
-        public static void FormatValue_CustomFormatterInvoked_FactoryArg()
+        public static void FormatValue_GlobalCustomFormatterInvoked_FactoryArg()
         {
-            ValueFormatters.Add(next => val => (val is CustomFormattableType) ? "custom_formatted" : next(val));
+            var originalFormatter = MsgUtils.DefaultValueFormatter;
+
+            try
+            {
+                GlobalSettings.AddFormatter(next => val => (val is CustomFormattableType) ? "custom_formatted" : next(val));
+                Assert.That(MsgUtils.FormatValue(new CustomFormattableType()), Is.EqualTo("custom_formatted"));
+            }
+            finally
+            {
+                MsgUtils.DefaultValueFormatter = originalFormatter;
+            }
+        }
+
+        [Test]
+        public static void FormatValue_GlobalCustomFormatterNotInvokedForNull()
+        {
+            var originalFormatter = MsgUtils.DefaultValueFormatter;
+
+            try
+            {
+                // If this factory is actually called with null, it will throw
+                GlobalSettings.AddFormatter(next => val => (val.GetType() == typeof(CustomFormattableType)) ? val.ToString() : next(val));
+                Assert.That(MsgUtils.FormatValue(null), Is.EqualTo("null"));
+            }
+            finally
+            {
+                MsgUtils.DefaultValueFormatter = originalFormatter;
+            }
+        }
+
+        [Test]
+        public static void FormatValue_GlobalCustomFormatterInvoked_FormatterArg()
+        {
+            var originalFormatter = MsgUtils.DefaultValueFormatter;
+
+            try
+            {
+                GlobalSettings.AddFormatter<CustomFormattableType>(val => "custom_formatted_using_type");
+                Assert.That(MsgUtils.FormatValue(new CustomFormattableType()), Is.EqualTo("custom_formatted_using_type"));
+            }
+            finally
+            {
+                MsgUtils.DefaultValueFormatter = originalFormatter;
+            }
+        }
+
+        [Test]
+        public static void FormatValue_ContextualCustomFormatterInvoked_FactoryArg()
+        {
+            TestContext.AddFormatter(next => val => (val is CustomFormattableType) ? "custom_formatted" : next(val));
 
             Assert.That(MsgUtils.FormatValue(new CustomFormattableType()), Is.EqualTo("custom_formatted"));
         }
 
         [Test]
-        public static void FormatValue_CustomFormatterNotInvokedForNull()
+        public static void FormatValue_ContextualCustomFormatterNotInvokedForNull()
         {
             // If this factory is actually called with null, it will throw
-            ValueFormatters.Add(next => val => (val.GetType() == typeof(CustomFormattableType)) ? val.ToString() : next(val));
+            TestContext.AddFormatter(next => val => (val.GetType() == typeof(CustomFormattableType)) ? val.ToString() : next(val));
 
             Assert.That(MsgUtils.FormatValue(null), Is.EqualTo("null"));
         }
 
         [Test]
-        public static void FormatValue_CustomFormatterInvoked_FormatterArg()
+        public static void FormatValue_ContextualCustomFormatterInvoked_FormatterArg()
         {
-            ValueFormatters.Add<CustomFormattableType>(val => "custom_formatted_using_type");
+            TestContext.AddFormatter<CustomFormattableType>(val => "custom_formatted_using_type");
 
             Assert.That(MsgUtils.FormatValue(new CustomFormattableType()), Is.EqualTo("custom_formatted_using_type"));
         }
diff --git a/src/NUnitFramework/tests/Internal/TestExecutionContextTests.cs b/src/NUnitFramework/tests/Internal/TestExecutionContextTests.cs
index 55f9c2768..42f19263f 100644
--- a/src/NUnitFramework/tests/Internal/TestExecutionContextTests.cs
+++ b/src/NUnitFramework/tests/Internal/TestExecutionContextTests.cs
@@ -27,11 +27,13 @@ using System.Threading;
 using System.Globalization;
 using NUnit.Common;
 using NUnit.Framework;
+using NUnit.Framework.Constraints;
+using NUnit.TestData.TestContextData;
+using NUnit.TestUtilities;
+
 #if !NETCF
 using System.Security.Principal;
 #endif
-using NUnit.TestData.TestContextData;
-using NUnit.TestUtilities;
 
 namespace NUnit.Framework.Internal
 {
@@ -195,7 +197,7 @@ namespace NUnit.Framework.Internal
         CultureInfo originalUICulture;
 
         [Test]
-        public void FixtureSetUpontextReflectsCurrentCulture()
+        public void FixtureSetUpContextReflectsCurrentCulture()
         {
             Assert.That(fixtureContext.CurrentCulture, Is.EqualTo(CultureInfo.CurrentCulture));
         }
@@ -326,6 +328,34 @@ namespace NUnit.Framework.Internal
 
         #endregion
 
+        #region ValueFormatter
+
+        [Test]
+        public void SetAndRestoreValueFormatter()
+        {
+            var context = new TestExecutionContext(setupContext);
+            var originalFormatter = context.CurrentValueFormatter;
+
+            try
+            {
+                ValueFormatter f = val => "dummy";
+                context.AddFormatter(next => f);
+                Assert.That(context.CurrentValueFormatter, Is.EqualTo(f));
+
+                context.EstablishExecutionEnvironment();
+                Assert.That(MsgUtils.FormatValue(123), Is.EqualTo("dummy"));
+            }
+            finally
+            {
+                setupContext.EstablishExecutionEnvironment();
+            }
+
+            Assert.That(TestExecutionContext.CurrentContext.CurrentValueFormatter, Is.EqualTo(originalFormatter));
+            Assert.That(MsgUtils.FormatValue(123), Is.EqualTo("123"));
+        }
+
+        #endregion
+
         #region ExecutionStatus
 
         [Test]
