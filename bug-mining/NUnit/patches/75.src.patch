diff --git a/src/Common/nunit/PackageSettings.cs b/src/Common/nunit/PackageSettings.cs
index 416ff398f..170e7d71a 100644
--- a/src/Common/nunit/PackageSettings.cs
+++ b/src/Common/nunit/PackageSettings.cs
@@ -182,6 +182,11 @@ namespace NUnit.Common
         /// </summary>
         public const string StopOnError = "StopOnError";
 
+        /// <summary>
+        /// If true, use of the event queue is suppressed and test events are synchronous.
+        /// </summary>
+        public const string SynchronousEvents = "SynchronousEvents";
+
         #endregion
     }
 }
diff --git a/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs b/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
index 28abb40a4..279d3f850 100644
--- a/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
+++ b/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
@@ -235,13 +235,15 @@ namespace NUnit.Framework.Api
 #endif
 
 #if PARALLEL
-            QueuingEventListener queue = new QueuingEventListener();
-            Context.Listener = queue;
+            // Queue and pump events, unless settings have SynchronousEvents == false
+            if (!Settings.Contains(PackageSettings.SynchronousEvents) || !(bool)Settings[PackageSettings.SynchronousEvents])
+            {
+                QueuingEventListener queue = new QueuingEventListener();
+                Context.Listener = queue;
 
-            _pump = new EventPump(listener, queue.Events);
-            _pump.Start();
-#else
-            Context.Dispatcher = new SimpleWorkItemDispatcher();
+                _pump = new EventPump(listener, queue.Events);
+                _pump.Start();
+            }
 #endif
 
             if (!System.Diagnostics.Debugger.IsAttached &&
@@ -311,6 +313,8 @@ namespace NUnit.Framework.Api
             }
             else
                 Context.Dispatcher = new SimpleWorkItemDispatcher();
+#else
+                Context.Dispatcher = new SimpleWorkItemDispatcher();
 #endif
         }
 
@@ -320,7 +324,8 @@ namespace NUnit.Framework.Api
         private void OnRunCompleted(object sender, EventArgs e)
         {
 #if PARALLEL
-            _pump.Dispose();
+            if (_pump != null)
+                _pump.Dispose();
 #endif
 
 #if !SILVERLIGHT && !NETCF && !PORTABLE
diff --git a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
index 72cea7441..fa2fa7cd9 100644
--- a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
@@ -66,7 +66,7 @@ namespace NUnit.Framework.Internal.Execution
                 _topLevelWorkItem = work;
                 _runnerThread = new Thread(RunnerThreadProc);
                 _runnerThread.Start();
-			}	
+            }	
 #endif
         }
 
@@ -77,21 +77,21 @@ namespace NUnit.Framework.Internal.Execution
     }
 #endif
 
-		/// <summary>
-		/// Cancel the ongoing run completely.
-		/// If no run is in process, the call has no effect.
-		/// </summary>
-		public void CancelRun()
-		{
-	#if !PORTABLE
-	#if NETCF
-			if (_runnerThread != null && !_runnerThread.Join(0))
-	#else
-			if (_runnerThread != null && _runnerThread.IsAlive)
-	#endif
-				ThreadUtility.Kill(_runnerThread);
-	#endif
-		}
-		#endregion
-	}
+        /// <summary>
+        /// Cancel the ongoing run completely.
+        /// If no run is in process, the call has no effect.
+        /// </summary>
+        public void CancelRun()
+        {
+    #if !PORTABLE
+    #if NETCF
+            if (_runnerThread != null && !_runnerThread.Join(0))
+    #else
+            if (_runnerThread != null && _runnerThread.IsAlive)
+    #endif
+                ThreadUtility.Kill(_runnerThread);
+    #endif
+        }
+        #endregion
+    }
 }
