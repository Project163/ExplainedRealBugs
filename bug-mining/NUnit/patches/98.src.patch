diff --git a/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerStaticTests.cs b/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerStaticTests.cs
index 2aadf8000..3c9916e7d 100644
--- a/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerStaticTests.cs
+++ b/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerStaticTests.cs
@@ -22,6 +22,7 @@
 // ***********************************************************************
 
 using System;
+using System.Collections.Generic;
 using System.Configuration;
 using System.IO;
 using NUnit.Framework;
@@ -98,6 +99,52 @@ namespace NUnit.Engine.Services.Tests
             Assert.That(ConfigurationManager.AppSettings.Get("test.setting"), Is.EqualTo("54321"));
         }
 
+        [TestCase("/path/to/mytest.dll", null, "/path/to/")]
+        [TestCase("/path/to/mytest.dll", "/path", "/path/")]
+        public static void ApplicationBaseTests(string filePath, string appBase, string expected)
+        {
+            filePath = TestPath(filePath);
+            appBase = TestPath(appBase);
+            expected = TestPath(expected);
+
+            var package = new TestPackage(filePath);
+            if (appBase != null)
+                package.Settings["BasePath"] = appBase;
+
+            Assert.That(DomainManager.GetApplicationBase(package), Is.SamePath(expected));
+        }
+
+        [TestCase("/path/to/mytest.dll", "/path/to", null)]
+        [TestCase("/path/to/mytest.dll", "/path", "to")]
+        public static void PrivateBinPathTests(string filePath, string appBase, string expected)
+        {
+            filePath = TestPath(filePath);
+            appBase = TestPath(appBase);
+            expected = TestPath(expected);
+
+            var package = new TestPackage(filePath);
+
+            Assert.That(DomainManager.GetPrivateBinPath(appBase, package), Is.EqualTo(expected));
+        }
+
+        [TestCase("/path/to/mytest.dll", "/path/to", null, "/path/to/mytest.dll.config")]
+        [TestCase("/path/to/mytest.dll", "/path", null, "/path/to/mytest.dll.config")]
+        [TestCase("/path/to/mytest.nunit", "/path/to", null, null)]
+        [TestCase("/path/to/mytest.nunit", "/path/to", "/path/to/mytest.config", "/path/to/mytest.config")]
+        public static void ConfigFileTests(string filePath, string appBase, string configSetting, string expected)
+        {
+            filePath = TestPath(filePath);
+            appBase = TestPath(appBase);
+            configSetting = TestPath(configSetting);
+            expected = TestPath(expected);
+
+            var package = new TestPackage(filePath);
+            if (configSetting != null)
+                package.Settings["ConfigurationFile"] = configSetting;
+
+            Assert.That(DomainManager.GetConfigFile(appBase, package), Is.EqualTo(expected));
+        }
+
         /// <summary>
         /// Take a valid Linux filePath and make a valid windows filePath out of it
         /// if we are on Windows. Change slashes to backslashes and, if the
@@ -105,7 +152,7 @@ namespace NUnit.Engine.Services.Tests
         /// </summary>
         private static string TestPath(string path)
         {
-            if (Path.DirectorySeparatorChar != '/')
+            if (path != null && Path.DirectorySeparatorChar != '/')
             {
                 path = path.Replace('/', Path.DirectorySeparatorChar);
                 if (path[0] == Path.DirectorySeparatorChar)
@@ -114,5 +161,10 @@ namespace NUnit.Engine.Services.Tests
 
             return path;
         }
+
+        private static IEnumerable<TestCaseData> AppDomainData()
+        {
+            yield return new TestCaseData(new TestPackage(@"C:\path\to\mytest.dll"), @"C:\path\to");
+        }
     }
 }
diff --git a/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerTests.cs b/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerTests.cs
index 0b9e744c0..059e1ba73 100644
--- a/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerTests.cs
+++ b/src/NUnitEngine/nunit.engine.tests/Services/DomainManagerTests.cs
@@ -31,17 +31,15 @@ namespace NUnit.Engine.Services.Tests
     public class DomainManagerTests
     {
         private DomainManager _domainManager;
-        private AppDomain _domain;
+        private TestPackage _package = new TestPackage(MockAssembly.AssemblyPath);
 
         [SetUp]
-        public void CreateDomainManagerAndDomain()
+        public void CreateDomainManager()
         {
             var context = new ServiceContext();
             _domainManager = new DomainManager();
             context.Add(_domainManager);
             context.ServiceManager.StartServices();
-
-            _domain = _domainManager.CreateDomain(new TestPackage(MockAssembly.AssemblyPath));
         }
 
         [Test]
@@ -53,8 +51,10 @@ namespace NUnit.Engine.Services.Tests
         [Test, Platform("Linux,Net", Reason = "get_SetupInformation() fails on Windows+Mono")]
         public void CanCreateDomain()
         {
-            Assert.NotNull(_domain);
-            var setup = _domain.SetupInformation;
+            var domain = _domainManager.CreateDomain(_package);
+
+            Assert.NotNull(domain);
+            var setup = domain.SetupInformation;
 
             Assert.That(setup.ApplicationName, Does.StartWith("Tests_"));
             Assert.That(setup.ApplicationBase, Is.SamePath(Path.GetDirectoryName(MockAssembly.AssemblyPath)), "ApplicationBase");
@@ -67,27 +67,48 @@ namespace NUnit.Engine.Services.Tests
             //Assert.That(setup.ShadowCopyDirectories, Is.SamePath(Path.GetDirectoryName(MockAssembly.AssemblyPath)), "ShadowCopyDirectories" );
         }
 
+        [Test, Platform("Linux,Net", Reason = "get_SetupInformation() fails on Windows+Mono")]
+        public void CanCreateDomainWithApplicationBaseSpecified()
+        {
+            string basePath = Path.GetDirectoryName(Path.GetDirectoryName(Path.GetDirectoryName(_package.FullName)));
+            _package.Settings["BasePath"] = basePath;
+            var domain = _domainManager.CreateDomain(_package);
+
+            Assert.NotNull(domain);
+            var setup = domain.SetupInformation;
+
+            Assert.That(setup.ApplicationName, Does.StartWith("Tests_"));
+            Assert.That(setup.ApplicationBase, Is.SamePath(basePath), "ApplicationBase");
+            Assert.That(
+                Path.GetFileName(setup.ConfigurationFile),
+                Is.EqualTo("mock-nunit-assembly.exe.config").IgnoreCase,
+                "ConfigurationFile");
+            Assert.That(setup.PrivateBinPath, Is.SamePath(@"bin\Debug"), "PrivateBinPath");
+            Assert.That(setup.ShadowCopyFiles, Is.Null.Or.EqualTo("false"));
+        }
+
         [Test]
         public void CanUnloadDomain()
         {
-            _domainManager.Unload(_domain);
+            var domain = _domainManager.CreateDomain(_package);
+            _domainManager.Unload(domain);
 
-            CheckDomainIsUnloaded();
+            CheckDomainIsUnloaded(domain);
         }
 
         [Test]
         public void UnloadingTwiceDoesNoHarm()
         {
+            var domain = _domainManager.CreateDomain(_package);
+            _domainManager.Unload(domain);
+            _domainManager.Unload(domain);
 
-            _domainManager.Unload(_domain);
-            _domainManager.Unload(_domain);
-
-            CheckDomainIsUnloaded();
+            CheckDomainIsUnloaded(domain);
         }
 
         #region Helper Methods
 
-        private void CheckDomainIsUnloaded()
+        private void CheckDomainIsUnloaded(AppDomain domain)
         {
             // HACK: Either the Assert will succeed or the
             // exception should be thrown.
@@ -95,7 +116,7 @@ namespace NUnit.Engine.Services.Tests
 
             try
             {
-                unloaded = _domain.IsFinalizingForUnload();
+                unloaded = domain.IsFinalizingForUnload();
             }
             catch (AppDomainUnloadedException)
             {
diff --git a/src/NUnitEngine/nunit.engine/Internal/ResultHelper.cs b/src/NUnitEngine/nunit.engine/Internal/ResultHelper.cs
index 56e5a65a0..5b9e64308 100644
--- a/src/NUnitEngine/nunit.engine/Internal/ResultHelper.cs
+++ b/src/NUnitEngine/nunit.engine/Internal/ResultHelper.cs
@@ -141,6 +141,7 @@ namespace NUnit.Engine.Internal
 
             string aggregateResult = "Inconclusive";
             string aggregateLabel = null;
+            string aggregateSite = null;
 
             //double totalDuration = 0.0d;
             int testcasecount = 0;
@@ -180,6 +181,8 @@ namespace NUnit.Engine.Internal
                         case "Failed":
                             aggregateResult = "Failed";
                             aggregateLabel = label;
+                            if (elementName == "test-suite")
+                                aggregateSite = "Child";
                             break;
                     }
 
@@ -202,6 +205,8 @@ namespace NUnit.Engine.Internal
                 combinedNode.AddAttribute("result", aggregateResult);
                 if (aggregateLabel != null)
                     combinedNode.AddAttribute("label", aggregateLabel);
+                if (aggregateSite != null)
+                    combinedNode.AddAttribute("site", aggregateSite);
 
                 //combinedNode.AddAttribute("duration", totalDuration.ToString("0.000000", NumberFormatInfo.InvariantInfo));
                 combinedNode.AddAttribute("total", total.ToString());
diff --git a/src/NUnitEngine/nunit.engine/Services/DomainManager.cs b/src/NUnitEngine/nunit.engine/Services/DomainManager.cs
index 9643b973c..46d7eeace 100644
--- a/src/NUnitEngine/nunit.engine/Services/DomainManager.cs
+++ b/src/NUnitEngine/nunit.engine/Services/DomainManager.cs
@@ -44,10 +44,10 @@ namespace NUnit.Engine.Services
     {
         static Logger log = InternalTrace.GetLogger(typeof(DomainManager));
 
+        private ISettings _settingsService;
+
         // Default settings used if SettingsService is unavailable
         private string _shadowCopyPath = Path.Combine(NUnitConfiguration.NUnitBinDirectory, "ShadowCopyCache");
-        private PrincipalPolicy _principalPolicy = PrincipalPolicy.UnauthenticatedPrincipal;
-        private bool _setPrincipalPolicy = false;
 
         #region Create and Unload Domains
         /// <summary>
@@ -75,16 +75,20 @@ namespace NUnit.Engine.Services
             log.Info("Creating AppDomain " + domainName);
 
             AppDomain runnerDomain = AppDomain.CreateDomain(domainName, evidence, setup);
-            
+
             // Set PrincipalPolicy for the domain if called for in the settings
-            if (_setPrincipalPolicy)
-                runnerDomain.SetPrincipalPolicy(_principalPolicy);
+            if (_settingsService != null && _settingsService.GetSetting("Options.TestLoader.SetPrincipalPolicy", false))
+            {
+                runnerDomain.SetPrincipalPolicy(_settingsService.GetSetting(
+                    "Options.TestLoader.PrincipalPolicy", 
+                    PrincipalPolicy.UnauthenticatedPrincipal));
+            }
 
             return runnerDomain;
         }
 
-        // Made separate and public for testing
-        public AppDomainSetup CreateAppDomainSetup(TestPackage package)
+        // Made separate and internal for testing
+        AppDomainSetup CreateAppDomainSetup(TestPackage package)
         {
             AppDomainSetup setup = new AppDomainSetup();
 
@@ -94,57 +98,27 @@ namespace NUnit.Engine.Services
             //For parallel tests, we need to use distinct application name
             setup.ApplicationName = "Tests" + "_" + Environment.TickCount;
 
-            FileInfo testFile = package.FullName != null && package.FullName != string.Empty
-                ? new FileInfo(package.FullName)
-                : null;
-
-            string appBase = package.GetSetting(PackageSettings.BasePath, string.Empty);
-            string configFile = package.GetSetting(PackageSettings.ConfigurationFile, string.Empty);
-            string binPath = package.GetSetting(PackageSettings.PrivateBinPath, string.Empty);
+            string appBase = GetApplicationBase(package);
+            setup.ApplicationBase = appBase;
+            setup.ConfigurationFile = GetConfigFile(appBase, package);
+            setup.PrivateBinPath = GetPrivateBinPath(appBase, package); 
 
-            if (testFile != null)
+            if (!string.IsNullOrEmpty(package.FullName))
             {
-                if (appBase == null || appBase == string.Empty)
-                    appBase = testFile.DirectoryName;
-
-                if (configFile == null || configFile == string.Empty)
-                    configFile = testFile.Name + ".config";
-
                 // Setting the target framework is only supported when running with
                 // multiple AppDomains, one per assembly.
-                SetTargetFramework(testFile.FullName, setup);
-            }
-            else
-            {
-                if (appBase == null || appBase == string.Empty)
-                    appBase = GetCommonAppBase(package.SubPackages);
-
-                // TODO: What about config file for multiple assemblies?
+                SetTargetFramework(package.FullName, setup);
             }
 
-            char lastChar = appBase[appBase.Length - 1];
-            if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)
-                appBase += Path.DirectorySeparatorChar;
-
-            setup.ApplicationBase = appBase;
-            // TODO: Check whether Mono still needs full path to config file...
-            setup.ConfigurationFile = appBase != null && configFile != null
-                ? Path.Combine(appBase, configFile)
-                : configFile;
-
-            if (package.GetSetting(PackageSettings.AutoBinPath, binPath == string.Empty))
-                binPath = GetPrivateBinPath(appBase, package.SubPackages);
-
-            setup.PrivateBinPath = binPath;
-
             if (package.GetSetting("ShadowCopyFiles", false))
             {
                 setup.ShadowCopyFiles = "true";
-                setup.ShadowCopyDirectories = appBase;
+                setup.ShadowCopyDirectories = setup.ApplicationBase;
                 setup.CachePath = GetCachePath();
             }
             else
                 setup.ShadowCopyFiles = "false";
+
             return setup;
         }
 
@@ -220,6 +194,71 @@ namespace NUnit.Engine.Services
         #endregion
 
         #region Helper Methods
+
+        /// <summary>
+        /// Figure out the ApplicationBase for a package
+        /// </summary>
+        /// <param name="package">The package</param>
+        /// <returns>The ApplicationBase</returns>
+        public static string GetApplicationBase(TestPackage package)
+        {
+            Guard.ArgumentNotNull(package, "package");
+
+            var appBase = package.GetSetting(PackageSettings.BasePath, string.Empty);
+
+            if (string.IsNullOrEmpty(appBase))
+                appBase = string.IsNullOrEmpty(package.FullName)
+                    ? GetCommonAppBase(package.SubPackages)
+                    : Path.GetDirectoryName(package.FullName);
+
+            if (!string.IsNullOrEmpty(appBase))
+            {
+                char lastChar = appBase[appBase.Length - 1];
+                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)
+                    appBase += Path.DirectorySeparatorChar;
+            }
+
+            return appBase;
+        }
+
+        public static string GetConfigFile(string appBase, TestPackage package)
+        {
+            Guard.ArgumentNotNullOrEmpty(appBase, "appBase");
+            Guard.ArgumentNotNull(package, "package");
+
+            // Use provided setting if available
+            string configFile = package.GetSetting(PackageSettings.ConfigurationFile, string.Empty);
+            if (configFile != string.Empty)
+                return Path.Combine(appBase, configFile);
+        
+            // The ProjectService adds any project config to the settings.
+            // So, at this point, we only want to handle assemblies or an
+            // anonymous package created from the comnand-line.
+            string fullName = package.FullName;
+            if (IsExecutable(fullName))
+                return fullName + ".config";
+
+            // Command-line package gets no config unless it's a single assembly
+            if (string.IsNullOrEmpty(fullName) && package.SubPackages.Count == 1)
+            {
+                fullName = package.SubPackages[0].FullName;
+                if (IsExecutable(fullName))
+                    return fullName + ".config";
+            }
+
+            // No config file will be specified
+            return null;
+        }
+
+        private static bool IsExecutable(string fileName)
+        {
+            if (string.IsNullOrEmpty(fileName))
+                return false;
+
+            string ext = Path.GetExtension(fileName).ToLower();
+            return ext == ".dll" || ext == ".exe";
+        }
+
         /// <summary>
         /// Get the location for caching and delete any old cache info
         /// </summary>
@@ -323,6 +362,25 @@ namespace NUnit.Engine.Services
             return commonBase;
         }
 
+        public static string GetPrivateBinPath(string basePath, string fileName)
+        {
+            return GetPrivateBinPath(basePath, new string[] { fileName });
+        }
+
+        public static string GetPrivateBinPath(string appBase, TestPackage package)
+        {
+            var binPath = package.GetSetting(PackageSettings.PrivateBinPath, string.Empty);
+
+            if (package.GetSetting(PackageSettings.AutoBinPath, binPath == string.Empty))
+                binPath = package.SubPackages.Count > 0
+                    ? GetPrivateBinPath(appBase, package.SubPackages)
+                    : package.FullName != null
+                        ? GetPrivateBinPath(appBase, package.FullName)
+                        : null;
+
+            return binPath;
+        }
+
         public static string GetPrivateBinPath(string basePath, IList<TestPackage> packages)
         {
             var assemblies = new List<string>();
@@ -369,15 +427,12 @@ namespace NUnit.Engine.Services
             {
                 // DomainManager has a soft dependency on the SettingsService.
                 // If it's not available, default values are used.
-                var settings = ServiceContext.GetService<ISettings>();
-                if (settings != null)
+                _settingsService = ServiceContext.GetService<ISettings>();
+                if (_settingsService != null)
                 {
-                    var pathSetting = settings.GetSetting("Options.TestLoader.ShadowCopyPath", "");
+                    var pathSetting = _settingsService.GetSetting("Options.TestLoader.ShadowCopyPath", "");
                     if (pathSetting != "")
                         _shadowCopyPath = Environment.ExpandEnvironmentVariables(pathSetting);
-
-                    _setPrincipalPolicy = settings.GetSetting("Options.TestLoader.SetPrincipalPolicy", false);
-                    _principalPolicy = settings.GetSetting("Options.TestLoader.PrincipalPolicy", PrincipalPolicy.UnauthenticatedPrincipal);
                 }
 
                 Status = ServiceStatus.Started;
diff --git a/src/NUnitEngine/nunit.engine/Services/ProjectService.cs b/src/NUnitEngine/nunit.engine/Services/ProjectService.cs
index 5f5716a1f..eb7b006f8 100644
--- a/src/NUnitEngine/nunit.engine/Services/ProjectService.cs
+++ b/src/NUnitEngine/nunit.engine/Services/ProjectService.cs
@@ -78,6 +78,16 @@ namespace NUnit.Engine.Services
 
             foreach (var subPackage in tempPackage.SubPackages)
                 package.AddSubPackage(subPackage);
+
+            // If no config is specified (by user or by the proejct loader) check
+            // to see if one exists in same directory as the package. If so, we
+            // use it. If not, each assembly will use it's own config, if present.
+            if (!package.Settings.ContainsKey(PackageSettings.ConfigurationFile))
+            {
+                var packageConfig = Path.ChangeExtension(path, ".config");
+                if (File.Exists(packageConfig))
+                    package.Settings[PackageSettings.ConfigurationFile] = packageConfig;
+            }
         }
 
         #endregion
