diff --git a/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs b/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
index b7da082f8..956c204fb 100644
--- a/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
+++ b/src/NUnitFramework/framework/Api/NUnitTestAssemblyRunner.cs
@@ -352,7 +352,7 @@ namespace NUnit.Framework.Api
                 : (LoadedTest.Properties.ContainsKey(PropertyNames.LevelOfParallelism)
                    ? (int)LoadedTest.Properties.Get(PropertyNames.LevelOfParallelism)
 #if NETCF
-                   : 1);
+                   : 2);
 #else
                    : Math.Max(Environment.ProcessorCount, 2));
 #endif
diff --git a/src/NUnitFramework/framework/Internal/Execution/EventQueue.cs b/src/NUnitFramework/framework/Internal/Execution/EventQueue.cs
index 6aa708764..f57953f06 100644
--- a/src/NUnitFramework/framework/Internal/Execution/EventQueue.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/EventQueue.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -31,11 +31,12 @@ using NUnit.Framework.Interfaces;
 
 namespace NUnit.Framework.Internal.Execution
 {
+
     #region Individual Event Classes
 
     /// <summary>
     /// NUnit.Core.Event is the abstract base for all stored events.
-    /// An Event is the stored representation of a call to the 
+    /// An Event is the stored representation of a call to the
     /// ITestListener interface and is used to record such calls
     /// or to queue them for forwarding on another thread or at
     /// a later time.
@@ -46,33 +47,30 @@ namespace NUnit.Framework.Internal.Execution
         /// The Send method is implemented by derived classes to send the event to the specified listener.
         /// </summary>
         /// <param name="listener">The listener.</param>
-        abstract public void Send( ITestListener listener );
-    
+        public abstract void Send(ITestListener listener);
+
         /// <summary>
         /// Gets a value indicating whether this event is delivered synchronously by the NUnit <see cref="EventPump"/>.
         /// <para>
-        /// If <c>true</c>, and if <see cref="EventQueue.SetWaitHandleForSynchronizedEvents"/> has been used to 
+        /// If <c>true</c>, and if <see cref="EventQueue.SetWaitHandleForSynchronizedEvents"/> has been used to
         /// set a WaitHandle, <see cref="EventQueue.Enqueue"/> blocks its calling thread until the <see cref="EventPump"/>
         /// thread has delivered the event and sets the WaitHandle.
         /// </para>
         /// </summary>
         public virtual bool IsSynchronous
         {
-            get
-            {
-                return false;
-            }
+            get { return false; }
         }
 
-        //protected static Exception WrapUnserializableException(Exception ex)
-        //{
+        // protected static Exception WrapUnserializableException(Exception ex)
+        // {
         //    string message = string.Format(
         //        CultureInfo.InvariantCulture,
         //        "(failed to serialize original Exception - original Exception follows){0}{1}",
         //        Environment.NewLine,
         //        ex);
         //    return new Exception(message);
-        //}
+        // }
     }
 
     /// <summary>
@@ -80,13 +78,13 @@ namespace NUnit.Framework.Internal.Execution
     /// </summary>
     public class TestStartedEvent : Event
     {
-        ITest test;
+        private ITest test;
 
         /// <summary>
         /// Initializes a new instance of the <see cref="TestStartedEvent"/> class.
         /// </summary>
         /// <param name="test">The test.</param>
-        public TestStartedEvent( ITest test )
+        public TestStartedEvent(ITest test)
         {
             this.test = test;
         }
@@ -94,19 +92,19 @@ namespace NUnit.Framework.Internal.Execution
         ///// <summary>
         ///// Gets a value indicating whether this event is delivered synchronously by the NUnit <see cref="EventPump"/>.
         ///// <para>
-        ///// If <c>true</c>, and if <see cref="EventQueue.SetWaitHandleForSynchronizedEvents"/> has been used to 
+        ///// If <c>true</c>, and if <see cref="EventQueue.SetWaitHandleForSynchronizedEvents"/> has been used to
         ///// set a WaitHandle, <see cref="EventQueue.Enqueue"/> blocks its calling thread until the <see cref="EventPump"/>
         ///// thread has delivered the event and sets the WaitHandle.
         ///// </para>
         ///// </summary>
         // Keeping this as a synchronous until we rewrite using multiple autoresetevents
-        //public override bool IsSynchronous
-        //{
+        // public override bool IsSynchronous
+        // {
         //    get
         //    {
         //        return true;
         //    }
-        //}
+        // }
 
         /// <summary>
         /// Calls TestStarted on the specified listener.
@@ -114,7 +112,7 @@ namespace NUnit.Framework.Internal.Execution
         /// <param name="listener">The listener.</param>
         public override void Send(ITestListener listener)
         {
-            listener.TestStarted( this.test );
+            listener.TestStarted(test);
         }
     }
 
@@ -123,13 +121,13 @@ namespace NUnit.Framework.Internal.Execution
     /// </summary>
     public class TestFinishedEvent : Event
     {
-        ITestResult result;
+        private ITestResult result;
 
         /// <summary>
         /// Initializes a new instance of the <see cref="TestFinishedEvent"/> class.
         /// </summary>
         /// <param name="result">The result.</param>
-        public TestFinishedEvent( ITestResult result )
+        public TestFinishedEvent(ITestResult result)
         {
             this.result = result;
         }
@@ -140,7 +138,7 @@ namespace NUnit.Framework.Internal.Execution
         /// <param name="listener">The listener.</param>
         public override void Send(ITestListener listener)
         {
-            listener.TestFinished( this.result );
+            listener.TestFinished(result);
         }
     }
 
@@ -157,19 +155,22 @@ namespace NUnit.Framework.Internal.Execution
         private readonly Queue queue = new Queue();
         private readonly object syncRoot;
         private bool stopped;
+#if NETCF
+        private ManualResetEvent syncEvent = new ManualResetEvent(false);
+#endif
 
         /// <summary>
         /// Construct a new EventQueue
         /// </summary>
         public EventQueue()
         {
-            this.syncRoot = queue.SyncRoot;
+            syncRoot = queue.SyncRoot;
         }
 
         /// <summary>
         /// WaitHandle for synchronous event delivery in <see cref="Enqueue"/>.
         /// <para>
-        /// Having just one handle for the whole <see cref="EventQueue"/> implies that 
+        /// Having just one handle for the whole <see cref="EventQueue"/> implies that
         /// there may be only one producer (the test thread) for synchronous events.
         /// If there can be multiple producers for synchronous events, one would have
         /// to introduce one WaitHandle per event.
@@ -182,11 +183,11 @@ namespace NUnit.Framework.Internal.Execution
         /// </summary>
         public int Count
         {
-            get 
+            get
             {
-                lock( this.syncRoot )
+                lock (syncRoot)
                 {
-                    return this.queue.Count; 
+                    return queue.Count;
                 }
             }
         }
@@ -202,30 +203,30 @@ namespace NUnit.Framework.Internal.Execution
         /// </param>
         public void SetWaitHandleForSynchronizedEvents(AutoResetEvent synchronousEventWaitHandle)
         {
-            this.synchronousEventSent = synchronousEventWaitHandle;
+            synchronousEventSent = synchronousEventWaitHandle;
         }
 
         /// <summary>
         /// Enqueues the specified event
         /// </summary>
         /// <param name="e">The event to enqueue.</param>
-        public void Enqueue( Event e )
+        public void Enqueue(Event e)
         {
-            lock( this.syncRoot )
+            lock (syncRoot)
             {
-                this.queue.Enqueue( e );
-                
-                Monitor.Pulse( this.syncRoot );
-            }
+                queue.Enqueue(e);
 
-            if (this.synchronousEventSent != null && e.IsSynchronous)
-            {
-                this.synchronousEventSent.WaitOne();
+#if NETCF
+                syncEvent.Set();
+#else
+                Monitor.Pulse(syncRoot);
+#endif
             }
+
+            if (synchronousEventSent != null && e.IsSynchronous)
+                synchronousEventSent.WaitOne();
             else
-            {
-                Thread.Sleep(0); // give EventPump thread a chance to process the event
-            }
+                Thread.Sleep(0);  // give EventPump thread a chance to process the event
         }
 
         /// <summary>
@@ -242,7 +243,7 @@ namespace NUnit.Framework.Internal.Execution
         ///     <description>the first element.</description>
         ///   </item>
         ///   <item>
-        ///     <term>otherwise, if <paramref name="blockWhenEmpty"/>==<c>false</c> 
+        ///     <term>otherwise, if <paramref name="blockWhenEmpty"/>==<c>false</c>
         ///       or <see cref="Stop"/> has been called</term>
         ///     <description><c>null</c>.</description>
         ///   </item>
@@ -250,21 +251,26 @@ namespace NUnit.Framework.Internal.Execution
         /// </returns>
         public Event Dequeue(bool blockWhenEmpty)
         {
-            lock (this.syncRoot)
+            lock (syncRoot)
             {
-                while (this.queue.Count == 0)
+                while (queue.Count == 0)
                 {
-                    if (blockWhenEmpty && !this.stopped)
+                    if (blockWhenEmpty && !stopped)
+#if NETCF
                     {
-                        Monitor.Wait(this.syncRoot);
+                        Monitor.Exit(syncRoot);
+                        syncEvent.WaitOne();
+                        Monitor.Enter(syncRoot);
+                        syncEvent.Reset();
                     }
+#else
+                        Monitor.Wait(syncRoot);
+#endif
                     else
-                    {
                         return null;
-                    }
                 }
 
-                return (Event)this.queue.Dequeue();
+                return (Event)queue.Dequeue();
             }
         }
 
@@ -273,15 +279,20 @@ namespace NUnit.Framework.Internal.Execution
         /// </summary>
         public void Stop()
         {
-            lock (this.syncRoot)
+            lock (syncRoot)
             {
-                if (!this.stopped)
+                if (!stopped)
                 {
-                    this.stopped = true;
-                    Monitor.Pulse(this.syncRoot);
+                    stopped = true;
+#if NETCF
+                    syncEvent.Set();
+#else
+                    Monitor.PulseAll(syncRoot);
+#endif
                 }
             }
         }
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/framework/Internal/Execution/ParallelWorkItemDispatcher.cs b/src/NUnitFramework/framework/Internal/Execution/ParallelWorkItemDispatcher.cs
index dbd1fa523..36277ee45 100644
--- a/src/NUnitFramework/framework/Internal/Execution/ParallelWorkItemDispatcher.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/ParallelWorkItemDispatcher.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2012-2014 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -34,7 +34,7 @@ namespace NUnit.Framework.Internal.Execution
     /// </summary>
     public class ParallelWorkItemDispatcher : IWorkItemDispatcher
     {
-        static Logger log = InternalTrace.GetLogger("WorkItemDispatcher");
+        private static Logger log = InternalTrace.GetLogger("WorkItemDispatcher");
 
         private int _levelOfParallelism;
         private int _itemsDispatched;
@@ -42,13 +42,19 @@ namespace NUnit.Framework.Internal.Execution
         // Our Shifts
         private WorkShift _parallelShift = new WorkShift("Parallel");
         private WorkShift _nonParallelShift = new WorkShift("NonParallel");
+#if !NETCF
         private WorkShift _nonParallelSTAShift = new WorkShift("NonParallelSTA");
+#endif
 
         // Our Queues
         private WorkItemQueue _parallelQueue;
+#if !NETCF
         private WorkItemQueue _parallelSTAQueue;
+#endif
         private WorkItemQueue _nonParallelQueue;
+#if !NETCF
         private WorkItemQueue _nonParallelSTAQueue;
+#endif
 
         // The first WorkItem to be dispatched, assumed to be top-level item
         private WorkItem _topLevelWorkItem;
@@ -61,7 +67,14 @@ namespace NUnit.Framework.Internal.Execution
         {
             _levelOfParallelism = levelOfParallelism;
 
-            Shifts = new WorkShift[] { _parallelShift, _nonParallelShift, _nonParallelSTAShift };
+            Shifts = new WorkShift[]
+            {
+                _parallelShift,
+                _nonParallelShift,
+#if !NETCF
+                _nonParallelSTAShift
+#endif
+            };
             foreach (var shift in Shifts)
                 shift.EndOfShift += OnEndOfShift;
         }
@@ -112,12 +125,18 @@ namespace NUnit.Framework.Internal.Execution
             log.Debug("Enqueuing {0}", work.Test.Name);
 
             if (work.IsParallelizable)
+            {
+#if !NETCF
                 if (work.TargetApartment == ApartmentState.STA)
                     ParallelSTAQueue.Enqueue(work);
                 else
-                    ParallelQueue.Enqueue(work);
+#endif
+                ParallelQueue.Enqueue(work);
+            }
+#if !NETCF
             else if (work.TargetApartment == ApartmentState.STA)
                 NonParallelSTAQueue.Enqueue(work);
+#endif
             else
                 NonParallelQueue.Enqueue(work);
         }
@@ -151,7 +170,11 @@ namespace NUnit.Framework.Internal.Execution
                     for (int i = 1; i <= _levelOfParallelism; i++)
                     {
                         string name = string.Format("Worker#" + i.ToString());
+#if NETCF
+                        _parallelShift.Assign(new TestWorker(_parallelQueue, name));
+#else
                         _parallelShift.Assign(new TestWorker(_parallelQueue, name, ApartmentState.MTA));
+#endif
                     }
                 }
 
@@ -159,6 +182,7 @@ namespace NUnit.Framework.Internal.Execution
             }
         }
 
+#if !NETCF
         private WorkItemQueue ParallelSTAQueue
         {
             get
@@ -173,6 +197,7 @@ namespace NUnit.Framework.Internal.Execution
                 return _parallelSTAQueue;
             }
         }
+#endif
 
         private WorkItemQueue NonParallelQueue
         {
@@ -182,13 +207,18 @@ namespace NUnit.Framework.Internal.Execution
                 {
                     _nonParallelQueue = new WorkItemQueue("NonParallelQueue");
                     _nonParallelShift.AddQueue(_nonParallelQueue);
+#if NETCF
+                    _nonParallelShift.Assign(new TestWorker(_nonParallelQueue, "Worker#NP"));
+#else
                     _nonParallelShift.Assign(new TestWorker(_nonParallelQueue, "Worker#STA_NP", ApartmentState.MTA));
+#endif
                 }
 
                 return _nonParallelQueue;
             }
         }
 
+#if !NETCF
         private WorkItemQueue NonParallelSTAQueue
         {
             get
@@ -203,7 +233,7 @@ namespace NUnit.Framework.Internal.Execution
                 return _nonParallelSTAQueue;
             }
         }
-
+#endif
         #endregion
 
         #region Helper Methods
@@ -211,8 +241,10 @@ namespace NUnit.Framework.Internal.Execution
         private void OnEndOfShift(object sender, EventArgs ea)
         {
             if (!StartNextShift())
+            {
                 foreach (var shift in Shifts)
                     shift.ShutDown();
+            }
         }
 
         private bool StartNextShift()
@@ -232,4 +264,5 @@ namespace NUnit.Framework.Internal.Execution
         #endregion
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
index a41318b9b..f42ffba0b 100644
--- a/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/SimpleWorkItemDispatcher.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2014 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -30,7 +30,7 @@ namespace NUnit.Framework.Internal.Execution
     /// <summary>
     /// SimpleWorkItemDispatcher handles execution of WorkItems by
     /// directly executing them. It is provided so that a dispatcher
-    /// is always available in the context, thereby simplifying the 
+    /// is always available in the context, thereby simplifying the
     /// code needed to run child tests.
     /// </summary>
     public class SimpleWorkItemDispatcher : IWorkItemDispatcher
@@ -66,34 +66,35 @@ namespace NUnit.Framework.Internal.Execution
                 _topLevelWorkItem = work;
                 _runnerThread = new Thread(RunnerThreadProc);
                 _runnerThread.Start();
-            }
 #endif
         }
-        
+    }
+
 #if !PORTABLE
-        private void RunnerThreadProc()
-        {
-            _topLevelWorkItem.Execute();
-        }
+    private void RunnerThreadProc()
+    {
+#if NETCF
+        _topLevelWorkItem.Context.EstablishExecutionEnvironment();
+#endif
+        _topLevelWorkItem.Execute();
+    }
 #endif
 
-        /// <summary>
-        /// Cancel the ongoing run completely.
-        /// If no run is in process, the call has no effect.
-        /// </summary>
-        public void CancelRun()
-        {
+    /// <summary>
+    /// Cancel the ongoing run completely.
+    /// If no run is in process, the call has no effect.
+    /// </summary>
+    public void CancelRun()
+    {
 #if !PORTABLE
 #if NETCF
-            // NETCF: Check if this can be done better
-            if (_runnerThread != null)
-                _runnerThread.Abort();
+        if (_runnerThread != null && !_runnerThread.Join(0))
 #else
-            if (_runnerThread != null && _runnerThread.IsAlive)
-                ThreadUtility.Kill(_runnerThread);
+        if (_runnerThread != null && _runnerThread.IsAlive)
 #endif
+            ThreadUtility.Kill(_runnerThread);
 #endif
-        }
-        #endregion
     }
-}
\ No newline at end of file
+    #endregion
+}
+}
diff --git a/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs b/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
index 6918ec2f3..c2fb0ee68 100644
--- a/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2012 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -33,7 +33,7 @@ namespace NUnit.Framework.Internal.Execution
     /// </summary>
     public class TestWorker
     {
-        static Logger log = InternalTrace.GetLogger("TestWorker");
+        private static Logger log = InternalTrace.GetLogger("TestWorker");
 
         private WorkItemQueue _readyQueue;
         private Thread _workerThread;
@@ -58,29 +58,45 @@ namespace NUnit.Framework.Internal.Execution
         /// <param name="queue">The queue from which to pull work items</param>
         /// <param name="name">The name of this worker</param>
         /// <param name="apartmentState">The apartment state to use for running tests</param>
-        public TestWorker(WorkItemQueue queue, string name, ApartmentState apartmentState)
+        public TestWorker(WorkItemQueue queue, string name
+#if !NETCF
+                          , ApartmentState apartmentState
+#endif
+                          )
         {
             _readyQueue = queue;
 
             _workerThread = new Thread(new ThreadStart(TestWorkerThreadProc));
             _workerThread.Name = name;
+#if !NETCF
             _workerThread.SetApartmentState(apartmentState);
+#endif
         }
 
         /// <summary>
         /// The name of this worker - also used for the thread
         /// </summary>
-        public string Name { get { return _workerThread.Name; } }
+        public string Name
+        {
+            get { return _workerThread.Name; }
+        }
 
         /// <summary>
         /// Indicates whether the worker thread is running
         /// </summary>
-        public bool IsAlive { get { return _workerThread.IsAlive; } }
+        public bool IsAlive
+        {
+#if NETCF
+            get { return !_workerThread.Join(0); }
+#else
+            get { return _workerThread.IsAlive; }
+#endif
+        }
 
         /// <summary>
         /// Our ThreadProc, which pulls and runs tests in a loop
         /// </summary>
-        void TestWorkerThreadProc()
+        private void TestWorkerThreadProc()
         {
             log.Info("{0} starting ", _workerThread.Name);
 
@@ -96,9 +112,11 @@ namespace NUnit.Framework.Internal.Execution
 
                     log.Info("{0} executing {1}", _workerThread.Name, workItem.Test.Name);
 
-                    if (Busy != null) Busy(this, EventArgs.Empty);
+                    if (Busy != null)
+                        Busy(this, EventArgs.Empty);
                     workItem.Execute();
-                    if (Idle != null) Idle(this, EventArgs.Empty);
+                    if (Idle != null)
+                        Idle(this, EventArgs.Empty);
 
                     ++_workItemCount;
                 }
@@ -124,9 +142,14 @@ namespace NUnit.Framework.Internal.Execution
         {
             _running = false;
 
+#if NETCF
+            if (_workerThread != null && !_workerThread.Join(0))
+#else
             if (_workerThread != null && _workerThread.IsAlive)
+#endif
                 ThreadUtility.Kill(_workerThread);
         }
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/framework/Internal/Execution/WorkItemQueue.cs b/src/NUnitFramework/framework/Internal/Execution/WorkItemQueue.cs
index b106769a1..019348b20 100644
--- a/src/NUnitFramework/framework/Internal/Execution/WorkItemQueue.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/WorkItemQueue.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2012 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -37,10 +37,12 @@ namespace NUnit.Framework.Internal.Execution
         /// The queue is paused
         /// </summary>
         Paused,
+
         /// <summary>
         /// The queue is running
         /// </summary>
         Running,
+
         /// <summary>
         /// The queue is stopped
         /// </summary>
@@ -54,10 +56,13 @@ namespace NUnit.Framework.Internal.Execution
     /// </summary>
     public class WorkItemQueue
     {
-        Logger log = InternalTrace.GetLogger("WorkItemQueue");
+        private Logger log = InternalTrace.GetLogger("WorkItemQueue");
 
         private Queue<WorkItem> _innerQueue = new Queue<WorkItem>();
         private object _syncRoot = new object();
+#if NETCF
+        private ManualResetEvent _syncEvent = new ManualResetEvent(false);
+#endif
 
         /// <summary>
         /// Initializes a new instance of the <see cref="WorkItemQueue"/> class.
@@ -116,7 +121,11 @@ namespace NUnit.Framework.Internal.Execution
                 _innerQueue.Enqueue(work);
                 if (_innerQueue.Count > MaxCount)
                     MaxCount = _innerQueue.Count;
+#if NETCF
+                _syncEvent.Set();
+#else
                 Monitor.PulseAll(_syncRoot);
+#endif
             }
         }
 
@@ -133,7 +142,16 @@ namespace NUnit.Framework.Internal.Execution
                     if (State == WorkItemQueueState.Stopped)
                         return null; // Tell worker to terminate
                     else // We are either paused or empty, so wait for something to change
+#if NETCF
+                    {
+                        Monitor.Exit(_syncRoot);
+                        _syncEvent.WaitOne();
+                        Monitor.Enter(_syncRoot);
+                        _syncEvent.Reset();
+                    }
+#else
                         Monitor.Wait(_syncRoot);
+#endif
                 }
 
                 // Queue is running and non-empty
@@ -151,7 +169,11 @@ namespace NUnit.Framework.Internal.Execution
             {
                 log.Info("{0} starting", Name);
                 State = WorkItemQueueState.Running;
+#if NETCF
+                _syncEvent.Set();
+#else
                 Monitor.PulseAll(_syncRoot);
+#endif
             }
         }
 
@@ -165,7 +187,11 @@ namespace NUnit.Framework.Internal.Execution
                 log.Info("{0} stopping - {1} WorkItems processed, max size {2}", Name, ItemsProcessed, MaxCount);
 
                 State = WorkItemQueueState.Stopped;
+#if NETCF
+                _syncEvent.Set();
+#else
                 Monitor.PulseAll(_syncRoot);
+#endif
             }
         }
 
@@ -183,4 +209,5 @@ namespace NUnit.Framework.Internal.Execution
         #endregion
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/framework/Internal/TestExecutionContext.cs b/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
index cfae4f148..1973d1a90 100644
--- a/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
+++ b/src/NUnitFramework/framework/Internal/TestExecutionContext.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -22,10 +22,10 @@
 // ***********************************************************************
 
 using System;
-using System.IO;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
+using System.Diagnostics;
+using System.IO;
 using System.Reflection;
 using System.Threading;
 using NUnit.Framework.Interfaces;
@@ -40,9 +40,9 @@ namespace NUnit.Framework.Internal
 {
     /// <summary>
     /// Helper class used to save and restore certain static or
-    /// singleton settings in the environment that affect tests 
+    /// singleton settings in the environment that affect tests
     /// or which might be changed by the user tests.
-    /// 
+    ///
     /// An internal class is used to hold settings and a stack
     /// of these objects is pushed and popped as Save and Restore
     /// are called.
@@ -53,7 +53,7 @@ namespace NUnit.Framework.Internal
 #endif
     {
         // NOTE: Be very careful when modifying this class. It uses
-        // conditional compilation extensively and you must give 
+        // conditional compilation extensively and you must give
         // thought to whether any new features will be supported
         // on each platform. In particular, instance fields,
         // properties, initialization and restoration must all
@@ -132,7 +132,7 @@ namespace NUnit.Framework.Internal
         /// Initializes a new instance of the <see cref="TestExecutionContext"/> class.
         /// </summary>
         /// <param name="other">An existing instance of TestExecutionContext.</param>
-        public TestExecutionContext( TestExecutionContext other )
+        public TestExecutionContext(TestExecutionContext other)
         {
             _priorContext = other;
 
@@ -149,7 +149,7 @@ namespace NUnit.Framework.Internal
             _currentUICulture = CultureInfo.CurrentUICulture;
 
 #if !NETCF && !SILVERLIGHT && !PORTABLE
-            _currentPrincipal = Thread.CurrentPrincipal;
+            _currentPrincipal = other.CurrentPrincipal;
 #endif
 
             this.Dispatcher = other.Dispatcher;
@@ -167,7 +167,7 @@ namespace NUnit.Framework.Internal
         [ThreadStatic]
         private static TestExecutionContext current;
 #elif NETCF
-        private static TestExecutionContext current;
+        private static LocalDataStoreSlot slotContext = Thread.AllocateDataSlot();
 #else
         private static readonly string CONTEXT_KEY = "NUnit.Framework.TestContext";
 #endif
@@ -178,18 +178,27 @@ namespace NUnit.Framework.Internal
         /// <value>The current context.</value>
         public static TestExecutionContext CurrentContext
         {
-            get 
+            get
             {
                 // If a user creates a thread then the current context
                 // will be null. This also happens when the compiler
                 // automatically creates threads for async methods.
                 // We create a new context, which is automatically
                 // populated with _values taken from the current thread.
-#if SILVERLIGHT || NETCF || PORTABLE
+#if SILVERLIGHT || PORTABLE
                 if (current == null)
                     current = new TestExecutionContext();
 
-                return current; 
+                return current;
+#elif NETCF
+                var current = (TestExecutionContext)Thread.GetData(slotContext);
+                if (current == null)
+                {
+                    current = new TestExecutionContext();
+                    Thread.SetData(slotContext, current);
+                }
+
+                return current;
 #else
                 var context = GetTestExecutionContext();
                 if (context == null) // This can happen on Mono
@@ -201,10 +210,13 @@ namespace NUnit.Framework.Internal
                 return context;
 #endif
             }
-            private set 
-            { 
-#if SILVERLIGHT || NETCF || PORTABLE
+
+            private set
+            {
+#if SILVERLIGHT || PORTABLE
                 current = value;
+#elif NETCF
+                Thread.SetData(slotContext, value);
 #else
                 if (value == null)
                     CallContext.FreeNamedDataSlot(CONTEXT_KEY);
@@ -262,7 +274,7 @@ namespace NUnit.Framework.Internal
             set
             {
                 _currentResult = value;
-                if(value != null)
+                if (value != null)
                     OutWriter = value.OutWriter;
             }
         }
@@ -277,7 +289,7 @@ namespace NUnit.Framework.Internal
         /// object on which tests are being executed.
         /// </summary>
         public object TestObject { get; set; }
-        
+
         /// <summary>
         /// Get or set the working directory
         /// </summary>
@@ -324,7 +336,7 @@ namespace NUnit.Framework.Internal
         /// <summary>
         /// The current WorkItemDispatcher
         /// </summary>
-        internal IWorkItemDispatcher Dispatcher 
+        internal IWorkItemDispatcher Dispatcher
         {
             get
             {
@@ -333,7 +345,7 @@ namespace NUnit.Framework.Internal
 
                 return _dispatcher;
             }
-            set { _dispatcher = value;  }
+            set { _dispatcher = value; }
         }
 
         /// <summary>
@@ -350,9 +362,7 @@ namespace NUnit.Framework.Internal
             get
             {
                 if (_randomGenerator == null)
-                {
                     _randomGenerator = new RandomGenerator(CurrentTest.Seed);
-                }
                 return _randomGenerator;
             }
         }
@@ -468,7 +478,7 @@ namespace NUnit.Framework.Internal
         /// </summary>
         public void IncrementAssertCount()
         {
-            System.Threading.Interlocked.Increment(ref _assertCount);
+            Interlocked.Increment(ref _assertCount);
         }
 
         /// <summary>
@@ -477,8 +487,8 @@ namespace NUnit.Framework.Internal
         public void IncrementAssertCount(int count)
         {
             // TODO: Temporary implementation
-            while(count-- > 0)
-                System.Threading.Interlocked.Increment(ref _assertCount);
+            while (count-- > 0)
+                Interlocked.Increment(ref _assertCount);
         }
 
         #endregion
diff --git a/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj b/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
index 1d4109b79..292961485 100644
--- a/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
@@ -1,4 +1,4 @@
-﻿<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
@@ -25,7 +25,7 @@
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
     <OutputPath>..\..\..\bin\Debug\netcf-3.5\</OutputPath>
-    <DefineConstants>TRACE;DEBUG;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5</DefineConstants>
+    <DefineConstants>TRACE;DEBUG;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;PARALLEL</DefineConstants>
     <NoStdLib>true</NoStdLib>
     <NoConfig>true</NoConfig>
     <ErrorReport>prompt</ErrorReport>
@@ -38,7 +38,7 @@
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
     <OutputPath>..\..\..\bin\Release\netcf-3.5\</OutputPath>
-    <DefineConstants>TRACE;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5</DefineConstants>
+    <DefineConstants>TRACE;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;PARALLEL</DefineConstants>
     <NoStdLib>true</NoStdLib>
     <NoConfig>true</NoConfig>
     <ErrorReport>prompt</ErrorReport>
diff --git a/src/NUnitFramework/testdata/MaxTimeFixture.cs b/src/NUnitFramework/testdata/MaxTimeFixture.cs
index d19fe1b46..96b447c97 100644
--- a/src/NUnitFramework/testdata/MaxTimeFixture.cs
+++ b/src/NUnitFramework/testdata/MaxTimeFixture.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -20,8 +20,11 @@
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 // ***********************************************************************
+
 #if !PORTABLE
 using System;
+using System.Threading;
+
 using NUnit.Framework;
 
 namespace NUnit.TestData
@@ -32,15 +35,12 @@ namespace NUnit.TestData
         [Test, MaxTime(1)]
         public void MaxTimeExceeded()
         {
-#if NETCF
-            long endTime = DateTime.Now.Ticks + TimeSpan.TicksPerMillisecond * 20;
-            while (endTime > DateTime.Now.Ticks) ;
-#elif SILVERLIGHT
+#if SILVERLIGHT
             // Silverlight does not have the high resolution StopWatch, so
             // we need to delay longer than their minimum clock resolution
-            System.Threading.Thread.Sleep(1000);
+            Thread.Sleep(1000);
 #else
-            System.Threading.Thread.Sleep(20);
+            Thread.Sleep(20);
 #endif
         }
     }
@@ -51,7 +51,7 @@ namespace NUnit.TestData
         [Test, MaxTime(1)]
         public void MaxTimeExceeded()
         {
-            System.Threading.Thread.Sleep(20);
+            Thread.Sleep(20);
             Assert.Fail("Intentional Failure");
         }
     }
@@ -62,9 +62,9 @@ namespace NUnit.TestData
         [Test, MaxTime(1)]
         public void MaxTimeExceeded()
         {
-            System.Threading.Thread.Sleep(20);
+            Thread.Sleep(20);
             throw new Exception("Exception message");
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/NUnitFramework/testdata/TestFixtureData.cs b/src/NUnitFramework/testdata/TestFixtureData.cs
index b8cb0499b..4046d709c 100644
--- a/src/NUnitFramework/testdata/TestFixtureData.cs
+++ b/src/NUnitFramework/testdata/TestFixtureData.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -36,19 +36,27 @@ namespace NUnit.TestData.TestFixtureData
     [TestFixture]
     public class NoDefaultCtorFixture
     {
-        public NoDefaultCtorFixture(int index) { }
+        public NoDefaultCtorFixture(int index)
+        {
+        }
 
         [Test]
-        public void OneTest() { }
+        public void OneTest()
+        {
+        }
     }
 
     [TestFixture(7,3)]
     public class FixtureWithArgsSupplied
     {
-        public FixtureWithArgsSupplied(int x, int y) { }
+        public FixtureWithArgsSupplied(int x, int y)
+        {
+        }
 
         [Test]
-        public void OneTest() { }
+        public void OneTest()
+        {
+        }
     }
 
     [TestFixture]
@@ -60,44 +68,57 @@ namespace NUnit.TestData.TestFixtureData
         }
 
         [Test] public void OneTest()
-        {}
+        {
+        }
     }
 
     [TestFixture]
     public class FixtureWithTestFixtureAttribute
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     public class FixtureWithoutTestFixtureAttributeContainingTest
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     public class FixtureWithoutTestFixtureAttributeContainingTestCase
     {
         [TestCase(42)]
-        public void SomeTest(int x) { }
+        public void SomeTest(int x)
+        {
+        }
     }
- 
+
     public class FixtureWithoutTestFixtureAttributeContainingTestCaseSource
     {
         [TestCaseSource("data")]
-        public void SomeTest(int x) { }
+        public void SomeTest(int x)
+        {
+        }
     }
- 
+
     public class FixtureWithoutTestFixtureAttributeContainingTheory
     {
         [Theory]
-        public void SomeTest(int x) { }
+        public void SomeTest(int x)
+        {
+        }
     }
- 
+
     public static class StaticFixtureWithoutTestFixtureAttribute
     {
         [Test]
-        public static void StaticTest() { }
+        public static void StaticTest()
+        {
+        }
     }
 
     [TestFixture]
@@ -105,14 +126,17 @@ namespace NUnit.TestData.TestFixtureData
     {
         [SetUp]
         public void Init1()
-        {}
+        {
+        }
 
         [SetUp]
         public void Init2()
-        {}
+        {
+        }
 
         [Test] public void OneTest()
-        {}
+        {
+        }
     }
 
     [TestFixture]
@@ -120,14 +144,17 @@ namespace NUnit.TestData.TestFixtureData
     {
         [TearDown]
         public void Destroy1()
-        {}
+        {
+        }
 
         [TearDown]
         public void Destroy2()
-        {}
+        {
+        }
 
         [Test] public void OneTest()
-        {}
+        {
+        }
     }
 
     [TestFixture]
@@ -136,7 +163,8 @@ namespace NUnit.TestData.TestFixtureData
     {
         [Test]
         public void Success()
-        { }
+        {
+        }
     }
 
     [TestFixture(Ignore = "testing ignore a fixture")]
@@ -144,7 +172,8 @@ namespace NUnit.TestData.TestFixtureData
     {
         [Test]
         public void Success()
-        { }
+        {
+        }
     }
 
     [TestFixture(IgnoreReason = "testing ignore a fixture")]
@@ -152,7 +181,8 @@ namespace NUnit.TestData.TestFixtureData
     {
         [Test]
         public void Success()
-        { }
+        {
+        }
     }
 
     [TestFixture]
@@ -162,7 +192,7 @@ namespace NUnit.TestData.TestFixtureData
         public class NestedTestFixture
         {
             [TestFixture]
-                public class DoublyNestedTestFixture
+            public class DoublyNestedTestFixture
             {
                 [Test]
                 public void Test()
@@ -177,7 +207,8 @@ namespace NUnit.TestData.TestFixtureData
     {
         [TearDown]
         public void Destroy1()
-        {}
+        {
+        }
 
         [Test]
         public void SomeTest()
@@ -193,9 +224,11 @@ namespace NUnit.TestData.TestFixtureData
     public class BaseClassTestFixture
     {
         [Test]
-        public void Success() { }
+        public void Success()
+        {
+        }
     }
-    
+
     public abstract class AbstractDerivedTestFixture : BaseClassTestFixture
     {
         [Test]
@@ -214,13 +247,11 @@ namespace NUnit.TestData.TestFixtureData
     }
 
     [TestFixture]
-    public abstract class AbstractDerivedFixtureWithSecondAttribute
-        : AbstractBaseFixtureWithAttribute
+    public abstract class AbstractDerivedFixtureWithSecondAttribute : AbstractBaseFixtureWithAttribute
     {
     }
 
-    public class DoubleDerivedClassWithTwoInheritedAttributes
-        : AbstractDerivedFixtureWithSecondAttribute
+    public class DoubleDerivedClassWithTwoInheritedAttributes : AbstractDerivedFixtureWithSecondAttribute
     {
     }
 
@@ -229,14 +260,17 @@ namespace NUnit.TestData.TestFixtureData
     {
         [OneTimeSetUp]
         public void Init1()
-        {}
+        {
+        }
 
         [OneTimeSetUp]
         public void Init2()
-        {}
+        {
+        }
 
         [Test] public void OneTest()
-        {}
+        {
+        }
     }
 
     [TestFixture]
@@ -244,161 +278,210 @@ namespace NUnit.TestData.TestFixtureData
     {
         [OneTimeTearDown]
         public void Destroy1()
-        {}
+        {
+        }
 
         [OneTimeTearDown]
         public void Destroy2()
-        {}
+        {
+        }
 
         [Test] public void OneTest()
-        {}
+        {
+        }
     }
 
     // Base class used to ensure following classes
     // all have at least one test
     public class OneTestBase
     {
-        [Test] public void OneTest() { }
+        [Test] public void OneTest()
+        {
+        }
     }
 
     [TestFixture]
     public class PrivateSetUp : OneTestBase
     {
         [SetUp]
-        private void Setup()	{}
+        private void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class ProtectedSetUp : OneTestBase
     {
         [SetUp]
-        protected void Setup()	{}
+        protected void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class StaticSetUp : OneTestBase
     {
         [SetUp]
-        public static void Setup() {}
+        public static void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class SetUpWithReturnValue : OneTestBase
     {
         [SetUp]
-        public int Setup() { return 0; }
+        public int Setup()
+        {
+            return 0;
+        }
     }
 
     [TestFixture]
     public class SetUpWithParameters : OneTestBase
     {
         [SetUp]
-        public void Setup(int j) { }
+        public void Setup(int j)
+        {
+        }
     }
 
     [TestFixture]
     public class PrivateTearDown : OneTestBase
     {
         [TearDown]
-        private void Teardown()	{}
+        private void Teardown()
+        {
+        }
     }
 
     [TestFixture]
     public class ProtectedTearDown : OneTestBase
     {
         [TearDown]
-        protected void Teardown()	{}
+        protected void Teardown()
+        {
+        }
     }
 
     [TestFixture]
     public class StaticTearDown : OneTestBase
     {
         [SetUp]
-        public static void TearDown() {}
+        public static void TearDown()
+        {
+        }
     }
 
     [TestFixture]
     public class TearDownWithReturnValue : OneTestBase
     {
         [TearDown]
-        public int Teardown() { return 0; }
+        public int Teardown()
+        {
+            return 0;
+        }
     }
 
     [TestFixture]
     public class TearDownWithParameters : OneTestBase
     {
         [TearDown]
-        public void Teardown(int j) { }
+        public void Teardown(int j)
+        {
+        }
     }
 
     [TestFixture]
     public class PrivateFixtureSetUp : OneTestBase
     {
         [OneTimeSetUp]
-        private void Setup()	{}
+        private void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class ProtectedFixtureSetUp : OneTestBase
     {
         [OneTimeSetUp]
-        protected void Setup()	{}
+        protected void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class StaticFixtureSetUp : OneTestBase
     {
         [OneTimeSetUp]
-        public static void Setup() {}
+        public static void Setup()
+        {
+        }
     }
 
     [TestFixture]
     public class FixtureSetUpWithReturnValue : OneTestBase
     {
         [OneTimeSetUp]
-        public int Setup() { return 0; }
+        public int Setup()
+        {
+            return 0;
+        }
     }
 
     [TestFixture]
     public class FixtureSetUpWithParameters : OneTestBase
     {
         [SetUp]
-        public void Setup(int j) { }
+        public void Setup(int j)
+        {
+        }
     }
 
     [TestFixture]
     public class PrivateFixtureTearDown : OneTestBase
     {
         [OneTimeTearDown]
-        private void Teardown()	{}
+        private void Teardown()
+        {
+        }
     }
 
     [TestFixture]
     public class ProtectedFixtureTearDown : OneTestBase
     {
         [OneTimeTearDown]
-        protected void Teardown()	{}
+        protected void Teardown()
+        {
+        }
     }
 
     [TestFixture]
     public class StaticFixtureTearDown : OneTestBase
     {
         [OneTimeTearDown]
-        public static void Teardown() {}
+        public static void Teardown()
+        {
+        }
     }
 
     [TestFixture]
     public class FixtureTearDownWithReturnValue : OneTestBase
     {
         [OneTimeTearDown]
-        public int Teardown() { return 0; }
+        public int Teardown()
+        {
+            return 0;
+        }
     }
 
     [TestFixture]
     public class FixtureTearDownWithParameters : OneTestBase
     {
         [OneTimeTearDown]
-        public void Teardown(int j) { }
+        public void Teardown(int j)
+        {
+        }
     }
 
 #if !NETCF && !SILVERLIGHT && !PORTABLE
@@ -415,33 +498,40 @@ namespace NUnit.TestData.TestFixtureData
     }
 #endif
 
-#if !NETCF
     [TestFixture(typeof(int))]
     [TestFixture(typeof(string))]
     public class GenericFixtureWithProperArgsProvided<T>
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     public class GenericFixtureWithNoTestFixtureAttribute<T>
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     [TestFixture]
     public class GenericFixtureWithNoArgsProvided<T>
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     [TestFixture]
     public abstract class AbstractFixtureBase
     {
         [Test]
-        public void SomeTest() { }
+        public void SomeTest()
+        {
+        }
     }
 
     public class GenericFixtureDerivedFromAbstractFixtureWithNoArgsProvided<T> : AbstractFixtureBase
@@ -453,5 +543,4 @@ namespace NUnit.TestData.TestFixtureData
     public class GenericFixtureDerivedFromAbstractFixtureWithArgsProvided<T> : AbstractFixtureBase
     {
     }
-#endif
 }
diff --git a/src/NUnitFramework/tests/Attributes/RequiresThreadAttributeTests.cs b/src/NUnitFramework/tests/Attributes/RequiresThreadAttributeTests.cs
index d1abcc6df..89ccc51f1 100644
--- a/src/NUnitFramework/tests/Attributes/RequiresThreadAttributeTests.cs
+++ b/src/NUnitFramework/tests/Attributes/RequiresThreadAttributeTests.cs
@@ -1,6 +1,6 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2014 Charlie Poole
-// 
+//
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the
 // "Software"), to deal in the Software without restriction, including
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -21,7 +21,7 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 // ***********************************************************************
 
-#if !SILVERLIGHT && !NETCF
+#if !SILVERLIGHT
 using System;
 using System.Threading;
 
@@ -31,7 +31,7 @@ namespace NUnit.Framework.Attributes
     public class RequiresThreadAttributeTests : ThreadingTests
     {
         private Thread SetupThread { get; set; }
-        
+
         [SetUp]
         public void GetSetUpThreadInfo()
         {
@@ -41,15 +41,16 @@ namespace NUnit.Framework.Attributes
         [Test, RequiresThread]
         public void TestWithRequiresThreadRunsInSeparateThread()
         {
-            Assert.That( Thread.CurrentThread, Is.Not.EqualTo( ParentThread ) );
+            Assert.That(Thread.CurrentThread, Is.Not.EqualTo(ParentThread));
         }
 
         [Test, RequiresThread]
         public void TestWithRequiresThreadRunsSetUpAndTestOnSameThread()
         {
-            Assert.That( Thread.CurrentThread, Is.EqualTo( SetupThread ) );
+            Assert.That(Thread.CurrentThread, Is.EqualTo(SetupThread));
         }
 
+#if !NETCF
         [Test, RequiresThread( ApartmentState.STA )]
         public void TestWithRequiresThreadWithSTAArgRunsOnSeparateThreadInSTA()
         {
@@ -63,6 +64,7 @@ namespace NUnit.Framework.Attributes
             Assert.That( GetApartmentState( Thread.CurrentThread ), Is.EqualTo( ApartmentState.MTA ) );
             Assert.That( Thread.CurrentThread, Is.Not.EqualTo( ParentThread ) );
         }
+#endif
 
         [TestFixture, RequiresThread]
         public class FixtureRequiresThread
@@ -71,7 +73,7 @@ namespace NUnit.Framework.Attributes
             public void RequiresThreadCanBeSetOnTestFixture()
             {
                 // TODO: Figure out how to test this
-                //Assert.That(Environment.StackTrace, Contains.Substring("RunTestProc"));
+                // Assert.That(Environment.StackTrace, Contains.Substring("RunTestProc"));
             }
         }
 
@@ -83,11 +85,11 @@ namespace NUnit.Framework.Attributes
             [Test]
             public void RequiresThreadAttributeIsInheritable()
             {
-                Attribute[] attributes = Attribute.GetCustomAttributes(GetType(), typeof (RequiresThreadAttribute), true);
+                Attribute[] attributes = Attribute.GetCustomAttributes(GetType(), typeof(RequiresThreadAttribute), true);
                 Assert.That(attributes, Has.Length.EqualTo(1),
                     "RequiresThreadAttribute was not inherited from the base class");
             }
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/NUnitFramework/tests/Attributes/ThreadingTests.cs b/src/NUnitFramework/tests/Attributes/ThreadingTests.cs
index f23257394..64b56ca76 100644
--- a/src/NUnitFramework/tests/Attributes/ThreadingTests.cs
+++ b/src/NUnitFramework/tests/Attributes/ThreadingTests.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -21,28 +21,34 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 // ***********************************************************************
 
-#if !SILVERLIGHT && !NETCF
+#if !SILVERLIGHT
 using System.Threading;
 
 namespace NUnit.Framework.Attributes
 {
-    //[Platform(Exclude = "Mono", Reason = "Runner hangs at end when these are run")]
+    // [Platform(Exclude = "Mono", Reason = "Runner hangs at end when these are run")]
     public class ThreadingTests
     {
         protected Thread ParentThread { get; private set; }
+#if !NETCF
         protected ApartmentState ParentThreadApartment { get; private set; }
+#endif
 
         [OneTimeSetUp]
         public void GetParentThreadInfo()
         {
             ParentThread = Thread.CurrentThread;
+#if !NETCF
             ParentThreadApartment = GetApartmentState(ParentThread);
+#endif
         }
 
+#if !NETCF
         protected static ApartmentState GetApartmentState(Thread thread)
-        { 
+        {
             return thread.GetApartmentState();
         }
+#endif
     }
 }
 #endif
diff --git a/src/NUnitFramework/tests/Internal/CallContextTests.cs b/src/NUnitFramework/tests/Internal/CallContextTests.cs
index e58e496a7..f7b590d14 100644
--- a/src/NUnitFramework/tests/Internal/CallContextTests.cs
+++ b/src/NUnitFramework/tests/Internal/CallContextTests.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -21,7 +21,7 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 // ***********************************************************************
 
-#if PARALLEL
+#if PARALLEL && !NETCF
 using System;
 using System.Threading;
 using System.Runtime.Remoting.Messaging;
@@ -60,16 +60,16 @@ namespace NUnit.Framework.Internal
 
         [Test]
         public void ILogicalThreadAffinativeTest()
-        {	
+        {
             CallContext.SetData( CONTEXT_DATA, new EmptyCallContextData() );
         }
 
         [Test]
         public void ILogicalThreadAffinativeTestConsole()
-        {	
+        {
             CallContext.SetData( CONTEXT_DATA, new EmptyCallContextData() );
             // TODO: make this Assertable
-            //Console.WriteLine("ILogicalThreadAffinativeTest");
+            // Console.WriteLine("ILogicalThreadAffinativeTest");
             Console.Out.Flush();
         }
 
@@ -77,8 +77,8 @@ namespace NUnit.Framework.Internal
         public void GenericPrincipalTest()
         {
             GenericIdentity ident = new GenericIdentity("Bob");
-            GenericPrincipal prpal = new GenericPrincipal(ident, 
-                new string[] {"Level1"});
+            GenericPrincipal prpal = new GenericPrincipal(ident,
+                    new string[] {"Level1"});
 
             CallContext.SetData( CONTEXT_DATA, new PrincipalCallContextData( prpal ) );
         }
@@ -87,8 +87,8 @@ namespace NUnit.Framework.Internal
         public void SetGenericPrincipalOnThread()
         {
             GenericIdentity ident = new GenericIdentity("Bob");
-            GenericPrincipal prpal = new GenericPrincipal(ident, 
-                new string[] {"Level1"});
+            GenericPrincipal prpal = new GenericPrincipal(ident,
+                    new string[] {"Level1"});
 
             System.Threading.Thread.CurrentPrincipal = prpal;
         }
@@ -106,7 +106,7 @@ namespace NUnit.Framework.Internal
         {
             TestIdentity ident = new TestIdentity( "test" );
             GenericPrincipal principal = new GenericPrincipal( ident, new string[] { "Level1" } );
-        
+
             System.Threading.Thread.CurrentPrincipal = principal;
         }
 
@@ -116,7 +116,7 @@ namespace NUnit.Framework.Internal
             IPrincipal principal = Thread.CurrentPrincipal;
 
             TestBuilder.RunTestFixture( typeof( FixtureThatChangesTheCurrentPrincipal ) );
-            
+
             Assert.That(
                 Thread.CurrentPrincipal,
                 Is.SameAs(principal),
@@ -163,7 +163,9 @@ namespace NUnit.Framework.Internal
     [Serializable]
     public class TestIdentity : GenericIdentity
     {
-        public TestIdentity( string name ) : base( name ) { }
+        public TestIdentity( string name ) : base( name )
+        {
+        }
     }
 
 }
diff --git a/src/NUnitFramework/tests/Internal/EventQueueTests.cs b/src/NUnitFramework/tests/Internal/EventQueueTests.cs
index cb0b40e22..6f4e732f6 100644
--- a/src/NUnitFramework/tests/Internal/EventQueueTests.cs
+++ b/src/NUnitFramework/tests/Internal/EventQueueTests.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -29,8 +29,6 @@ using System.IO;
 using System.Threading;
 using NUnit.Framework.Interfaces;
 
-using ThreadState = System.Threading.ThreadState;
-
 namespace NUnit.Framework.Internal.Execution
 {
     /// <summary>
@@ -39,14 +37,15 @@ namespace NUnit.Framework.Internal.Execution
     [TestFixture]
     public class EventQueueTests
     {
-        static readonly Event[] events = {
-                new TestStartedEvent( null ),
-                new TestStartedEvent( null ),
-                new TestFinishedEvent( null ),
-                new TestStartedEvent( null ),
-                new TestFinishedEvent( null ),
-                new TestFinishedEvent( null ),
-            };
+        private static readonly Event[] events =
+        {
+            new TestStartedEvent(null),
+            new TestStartedEvent(null),
+            new TestFinishedEvent(null),
+            new TestStartedEvent(null),
+            new TestFinishedEvent(null),
+            new TestFinishedEvent(null),
+        };
 
         private static void EnqueueEvents(EventQueue q)
         {
@@ -65,8 +64,7 @@ namespace NUnit.Framework.Internal.Execution
             for (int index = 0; index < events.Length; index++)
             {
                 Event e = q.Dequeue(false);
-                Assert.AreEqual(events[index].GetType(), e.GetType(),
-                    string.Format("Event {0}", index));
+                Assert.AreEqual(events[index].GetType(), e.GetType(), string.Format("Event {0}", index));
             }
         }
 
@@ -137,9 +135,7 @@ namespace NUnit.Framework.Internal.Execution
             {
                 EnqueueEvents(this.q);
                 while (this.receivedEvents < events.Length)
-                {
                     Thread.Sleep(30);
-                }
 
                 this.q.Stop();
             }
@@ -260,9 +256,7 @@ namespace NUnit.Framework.Internal.Execution
                     {
                         q.Enqueue(e);
                         if (e.IsSynchronous)
-                        {
                             Assert.That(q.Count, Is.EqualTo(0));
-                        }
                         else
                         {
                             sumOfAsynchronousQueueLength += q.Count;
@@ -275,8 +269,7 @@ namespace NUnit.Framework.Internal.Execution
             }
         }
 
-
-        /// <summary> 
+        /// <summary>
         /// Floods the queue of an EventPump with multiple concurrent event producers.
         /// Prints the maximum queue length to Console, but does not implement an
         /// oracle on what the maximum queue length should be.
@@ -294,9 +287,7 @@ namespace NUnit.Framework.Internal.Execution
             EventQueue q = new EventQueue();
             EventProducer[] producers = new EventProducer[numberOfProducers];
             for (int i = 0; i < numberOfProducers; i++)
-            {
                 producers[i] = new EventProducer(q, i, producerDelay);
-            }
 
             using (EventPump pump = new EventPump(TestListener.NULL, q))
             {
@@ -304,21 +295,16 @@ namespace NUnit.Framework.Internal.Execution
                 pump.Start();
 
                 foreach (EventProducer p in producers)
-                {
                     p.ProducerThread.Start();
-                }
                 foreach (EventProducer p in producers)
-                {
                     p.ProducerThread.Join();
-                }
                 pump.Stop();
             }
             Assert.That(q.Count, Is.EqualTo(0));
 
             foreach (EventProducer p in producers)
             {
-                Console.WriteLine(
-                    "#Events: {0}, MaxQueueLength: {1}", p.SentEventsCount, p.MaxQueueLength);
+                Console.WriteLine("#Events: {0}, MaxQueueLength: {1}", p.SentEventsCount, p.MaxQueueLength);
                 Assert.IsNull(p.Exception, "{0}", p.Exception);
             }
         }
@@ -358,9 +344,11 @@ namespace NUnit.Framework.Internal.Execution
                 {
                     this.Consumer();
                 }
-                catch (ThreadAbortException)
+                catch (System.Threading.ThreadAbortException)
                 {
+#if !NETCF
                     Thread.ResetAbort();
+#endif
                 }
                 catch (Exception ex)
                 {
@@ -400,9 +388,7 @@ namespace NUnit.Framework.Internal.Execution
 
                         // without Sleep or with just a Sleep(0), the EventPump thread does not keep up and the queue gets very long
                         if (this.delay)
-                        {
                             Thread.Sleep(1);
-                        }
                     }
                 }
                 catch (Exception ex)
@@ -413,4 +399,5 @@ namespace NUnit.Framework.Internal.Execution
         }
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/tests/Internal/RuntimeFrameworkTests.cs b/src/NUnitFramework/tests/Internal/RuntimeFrameworkTests.cs
index b29ed8dc2..cccbf18a6 100644
--- a/src/NUnitFramework/tests/Internal/RuntimeFrameworkTests.cs
+++ b/src/NUnitFramework/tests/Internal/RuntimeFrameworkTests.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2008 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -20,6 +20,7 @@
 // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 // ***********************************************************************
+
 #if !PORTABLE
 using System;
 
@@ -28,15 +29,15 @@ namespace NUnit.Framework.Internal
     [TestFixture]
     public class RuntimeFrameworkTests
     {
-        static RuntimeType currentRuntime = 
+        static RuntimeType currentRuntime =
 #if SILVERLIGHT
             RuntimeType.Silverlight;
 #else
-            Type.GetType("Mono.Runtime", false) != null 
-                ? RuntimeType.Mono 
-                : Environment.OSVersion.Platform == PlatformID.WinCE
-                    ? RuntimeType.NetCF
-                    : RuntimeType.Net;
+            Type.GetType("Mono.Runtime", false) != null
+            ? RuntimeType.Mono
+            : Environment.OSVersion.Platform == PlatformID.WinCE
+            ? RuntimeType.NetCF
+            : RuntimeType.Net;
 #endif
 
         [Test]
@@ -44,17 +45,17 @@ namespace NUnit.Framework.Internal
         {
             RuntimeFramework framework = RuntimeFramework.CurrentFramework;
 
-            Assert.That(framework.Runtime, Is.EqualTo(currentRuntime));
-#if SILVERLIGHT		
-            Version silverlightVersion = new Version(Environment.Version.Major, Environment.Version.Minor);		
-            Version clrVersion = Environment.Version.Major >= 4		
-                ? new Version(4,0,60310)		
-                : new Version(2,0,50727);		
-		
-            Assert.That(framework.FrameworkVersion, Is.EqualTo(silverlightVersion));		
-            Assert.That(framework.ClrVersion, Is.EqualTo(clrVersion));		
+            Assert.That(framework.Runtime, Is.EqualTo(currentRuntime), "#1");
+#if SILVERLIGHT
+            Version silverlightVersion = new Version(Environment.Version.Major, Environment.Version.Minor);
+            Version clrVersion = Environment.Version.Major >= 4
+                ? new Version(4,0,60310)
+                : new Version(2,0,50727);
+
+            Assert.That(framework.FrameworkVersion, Is.EqualTo(silverlightVersion));
+            Assert.That(framework.ClrVersion, Is.EqualTo(clrVersion));
 #else
-            Assert.That(framework.ClrVersion, Is.EqualTo(Environment.Version));
+            Assert.That(framework.ClrVersion, Is.EqualTo(Environment.Version), "#2");
 #endif
         }
 
@@ -68,36 +69,36 @@ namespace NUnit.Framework.Internal
         public void CanCreateUsingFrameworkVersion(FrameworkData data)
         {
             RuntimeFramework framework = new RuntimeFramework(data.runtime, data.frameworkVersion);
-            Assert.AreEqual(data.runtime, framework.Runtime);
-            Assert.AreEqual(data.frameworkVersion, framework.FrameworkVersion);
-            Assert.AreEqual(data.clrVersion, framework.ClrVersion);
+            Assert.AreEqual(data.runtime, framework.Runtime, "#1");
+            Assert.AreEqual(data.frameworkVersion, framework.FrameworkVersion, "#2");
+            Assert.AreEqual(data.clrVersion, framework.ClrVersion, "#3");
         }
 
         [TestCaseSource("frameworkData")]
         public void CanCreateUsingClrVersion(FrameworkData data)
         {
-            Assume.That(data.frameworkVersion.Major != 3);
+            Assume.That(data.frameworkVersion.Major != 3, "#0");
 
             RuntimeFramework framework = new RuntimeFramework(data.runtime, data.clrVersion);
-            Assert.AreEqual(data.runtime, framework.Runtime);
-            Assert.AreEqual(data.frameworkVersion, framework.FrameworkVersion);
-            Assert.AreEqual(data.clrVersion, framework.ClrVersion);
+            Assert.AreEqual(data.runtime, framework.Runtime, "#1");
+            Assert.AreEqual(data.frameworkVersion, framework.FrameworkVersion, "#2");
+            Assert.AreEqual(data.clrVersion, framework.ClrVersion, "#3");
         }
 
         [TestCaseSource("frameworkData")]
         public void CanParseRuntimeFramework(FrameworkData data)
         {
             RuntimeFramework framework = RuntimeFramework.Parse(data.representation);
-            Assert.AreEqual(data.runtime, framework.Runtime);
-            Assert.AreEqual(data.clrVersion, framework.ClrVersion);
+            Assert.AreEqual(data.runtime, framework.Runtime, "#1");
+            Assert.AreEqual(data.clrVersion, framework.ClrVersion, "#2");
         }
 
         [TestCaseSource("frameworkData")]
         public void CanDisplayFrameworkAsString(FrameworkData data)
         {
             RuntimeFramework framework = new RuntimeFramework(data.runtime, data.frameworkVersion);
-            Assert.AreEqual(data.representation, framework.ToString());
-            Assert.AreEqual(data.displayName, framework.DisplayName);
+            Assert.AreEqual(data.representation, framework.ToString(), "#1");
+            Assert.AreEqual(data.displayName, framework.DisplayName, "#2");
         }
 
         [TestCaseSource("matchData")]
@@ -108,82 +109,82 @@ namespace NUnit.Framework.Internal
 
         internal static TestCaseData[] matchData = new TestCaseData[] {
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(3,5)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(3,5)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(3,5))) 
-                .Returns(false),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
+                new RuntimeFramework(RuntimeType.Net, new Version(3,5)))
+            .Returns(false),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(3,5)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(3,5))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(3,5)),
+                new RuntimeFramework(RuntimeType.Net, new Version(3,5)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0)), 
-                new RuntimeFramework(RuntimeType.Mono, new Version(2,0))) 
-                .Returns(false),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
+                new RuntimeFramework(RuntimeType.Mono, new Version(2,0)))
+            .Returns(false),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(1,1))) 
-                .Returns(false),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
+                new RuntimeFramework(RuntimeType.Net, new Version(1,1)))
+            .Returns(false),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0,40607))) 
-                .Returns(false),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0,50727)),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0,40607)))
+            .Returns(false),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Mono, new Version(1,1)), // non-existent version but it works
-                new RuntimeFramework(RuntimeType.Mono, new Version(1,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Mono, new Version(1,0)))
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Mono, new Version(2,0)),
                 new RuntimeFramework(RuntimeType.Any, new Version(2,0)))
-                .Returns(true),
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Any, new Version(2,0)),
                 new RuntimeFramework(RuntimeType.Mono, new Version(2,0)))
-                .Returns(true),
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Any, new Version(2,0)),
                 new RuntimeFramework(RuntimeType.Any, new Version(2,0)))
-                .Returns(true),
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Any, new Version(2,0)),
                 new RuntimeFramework(RuntimeType.Any, new Version(4,0)))
-                .Returns(false),
+            .Returns(false),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Net, RuntimeFramework.DefaultVersion), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, RuntimeFramework.DefaultVersion),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
-                new RuntimeFramework(RuntimeType.Net, RuntimeFramework.DefaultVersion)) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Net, RuntimeFramework.DefaultVersion))
+            .Returns(true),
             new TestCaseData(
-                new RuntimeFramework(RuntimeType.Any, RuntimeFramework.DefaultVersion), 
-                new RuntimeFramework(RuntimeType.Net, new Version(2,0))) 
-                .Returns(true),
+                new RuntimeFramework(RuntimeType.Any, RuntimeFramework.DefaultVersion),
+                new RuntimeFramework(RuntimeType.Net, new Version(2,0)))
+            .Returns(true),
             new TestCaseData(
                 new RuntimeFramework(RuntimeType.Net, new Version(2,0)),
-                new RuntimeFramework(RuntimeType.Any, RuntimeFramework.DefaultVersion)) 
-                .Returns(true)
-            };
+                new RuntimeFramework(RuntimeType.Any, RuntimeFramework.DefaultVersion))
+            .Returns(true)
+        };
 
         public struct FrameworkData
         {
@@ -194,7 +195,7 @@ namespace NUnit.Framework.Internal
             public string displayName;
 
             public FrameworkData(RuntimeType runtime, Version frameworkVersion, Version clrVersion,
-                string representation, string displayName)
+                                 string representation, string displayName)
             {
                 this.runtime = runtime;
                 this.frameworkVersion = frameworkVersion;
@@ -211,30 +212,32 @@ namespace NUnit.Framework.Internal
 
         internal FrameworkData[] frameworkData = new FrameworkData[] {
             new FrameworkData(RuntimeType.Net, new Version(1,0), new Version(1,0,3705), "net-1.0", "Net 1.0"),
-            //new FrameworkData(RuntimeType.Net, new Version(1,0,3705), new Version(1,0,3705), "net-1.0.3705", "Net 1.0.3705"),
-            //new FrameworkData(RuntimeType.Net, new Version(1,0), new Version(1,0,3705), "net-1.0.3705", "Net 1.0.3705"),
+            // new FrameworkData(RuntimeType.Net, new Version(1,0,3705), new Version(1,0,3705), "net-1.0.3705", "Net 1.0.3705"),
+            // new FrameworkData(RuntimeType.Net, new Version(1,0), new Version(1,0,3705), "net-1.0.3705", "Net 1.0.3705"),
             new FrameworkData(RuntimeType.Net, new Version(1,1), new Version(1,1,4322), "net-1.1", "Net 1.1"),
-            //new FrameworkData(RuntimeType.Net, new Version(1,1,4322), new Version(1,1,4322), "net-1.1.4322", "Net 1.1.4322"),
+            // new FrameworkData(RuntimeType.Net, new Version(1,1,4322), new Version(1,1,4322), "net-1.1.4322", "Net 1.1.4322"),
             new FrameworkData(RuntimeType.Net, new Version(2,0), new Version(2,0,50727), "net-2.0", "Net 2.0"),
-            //new FrameworkData(RuntimeType.Net, new Version(2,0,40607), new Version(2,0,40607), "net-2.0.40607", "Net 2.0.40607"),
-            //new FrameworkData(RuntimeType.Net, new Version(2,0,50727), new Version(2,0,50727), "net-2.0.50727", "Net 2.0.50727"),
+            // new FrameworkData(RuntimeType.Net, new Version(2,0,40607), new Version(2,0,40607), "net-2.0.40607", "Net 2.0.40607"),
+            // new FrameworkData(RuntimeType.Net, new Version(2,0,50727), new Version(2,0,50727), "net-2.0.50727", "Net 2.0.50727"),
             new FrameworkData(RuntimeType.Net, new Version(3,0), new Version(2,0,50727), "net-3.0", "Net 3.0"),
             new FrameworkData(RuntimeType.Net, new Version(3,5), new Version(2,0,50727), "net-3.5", "Net 3.5"),
             new FrameworkData(RuntimeType.Net, new Version(4,0), new Version(4,0,30319), "net-4.0", "Net 4.0"),
             new FrameworkData(RuntimeType.Net, RuntimeFramework.DefaultVersion, RuntimeFramework.DefaultVersion, "net", "Net"),
+            new FrameworkData(RuntimeType.NetCF, new Version(3,5), new Version(3,5,7283), "netcf-3.5", "NetCF 3.5"),
+            new FrameworkData(RuntimeType.NetCF, RuntimeFramework.DefaultVersion, RuntimeFramework.DefaultVersion, "netcf", "NetCF"),
             new FrameworkData(RuntimeType.Mono, new Version(1,0), new Version(1,1,4322), "mono-1.0", "Mono 1.0"),
             new FrameworkData(RuntimeType.Mono, new Version(2,0), new Version(2,0,50727), "mono-2.0", "Mono 2.0"),
-            //new FrameworkData(RuntimeType.Mono, new Version(2,0,50727), new Version(2,0,50727), "mono-2.0.50727", "Mono 2.0.50727"),
+            // new FrameworkData(RuntimeType.Mono, new Version(2,0,50727), new Version(2,0,50727), "mono-2.0.50727", "Mono 2.0.50727"),
             new FrameworkData(RuntimeType.Mono, new Version(3,5), new Version(2,0,50727), "mono-3.5", "Mono 3.5"),
             new FrameworkData(RuntimeType.Mono, new Version(4,0), new Version(4,0,30319), "mono-4.0", "Mono 4.0"),
             new FrameworkData(RuntimeType.Mono, RuntimeFramework.DefaultVersion, RuntimeFramework.DefaultVersion, "mono", "Mono"),
             new FrameworkData(RuntimeType.Any, new Version(1,1), new Version(1,1,4322), "v1.1", "v1.1"),
             new FrameworkData(RuntimeType.Any, new Version(2,0), new Version(2,0,50727), "v2.0", "v2.0"),
-            //new FrameworkData(RuntimeType.Any, new Version(2,0,50727), new Version(2,0,50727), "v2.0.50727", "v2.0.50727"),
+            // new FrameworkData(RuntimeType.Any, new Version(2,0,50727), new Version(2,0,50727), "v2.0.50727", "v2.0.50727"),
             new FrameworkData(RuntimeType.Any, new Version(3,5), new Version(2,0,50727), "v3.5", "v3.5"),
             new FrameworkData(RuntimeType.Any, new Version(4,0), new Version(4,0,30319), "v4.0", "v4.0"),
             new FrameworkData(RuntimeType.Any, RuntimeFramework.DefaultVersion, RuntimeFramework.DefaultVersion, "any", "Any")
         };
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/NUnitFramework/tests/Internal/TestFixtureTests.cs b/src/NUnitFramework/tests/Internal/TestFixtureTests.cs
index a98f749f3..e359e477b 100644
--- a/src/NUnitFramework/tests/Internal/TestFixtureTests.cs
+++ b/src/NUnitFramework/tests/Internal/TestFixtureTests.cs
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -71,21 +71,20 @@ namespace NUnit.Framework.Internal
         [Test]
         public void ConstructFromDoublyNestedType()
         {
-            CanConstructFrom(typeof(OuterClass.NestedTestFixture.DoublyNestedTestFixture),
-                "OuterClass+NestedTestFixture+DoublyNestedTestFixture");
+            CanConstructFrom(typeof(OuterClass.NestedTestFixture.DoublyNestedTestFixture), "OuterClass+NestedTestFixture+DoublyNestedTestFixture");
         }
 
         public void ConstructFromTypeWithoutTestFixtureAttributeContainingTest()
         {
             CanConstructFrom(typeof(FixtureWithoutTestFixtureAttributeContainingTest));
         }
- 
+
         [Test]
         public void ConstructFromTypeWithoutTestFixtureAttributeContainingTestCase()
         {
             CanConstructFrom(typeof(FixtureWithoutTestFixtureAttributeContainingTestCase));
         }
- 
+
         [Test]
         public void ConstructFromTypeWithoutTestFixtureAttributeContainingTestCaseSource()
         {
@@ -118,13 +117,13 @@ namespace NUnit.Framework.Internal
             TestAssert.IsNotRunnable(typeof(BadCtorFixture));
         }
 
-        [Test] 
+        [Test]
         public void CanRunMultipleSetUp()
         {
             TestAssert.IsRunnable(typeof(MultipleSetUpAttributes));
         }
 
-        [Test] 
+        [Test]
         public void CanRunMultipleTearDown()
         {
             TestAssert.IsRunnable(typeof(MultipleTearDownAttributes));
@@ -154,7 +153,7 @@ namespace NUnit.Framework.Internal
             Assert.AreEqual("testing ignore a fixture", suite.Properties.Get(PropertyNames.SkipReason));
         }
 
-        //		[Test]
+//		[Test]
 //		public void CannotRunAbstractFixture()
 //		{
 //            TestAssert.IsNotRunnable(typeof(AbstractTestFixture));
@@ -186,13 +185,13 @@ namespace NUnit.Framework.Internal
             Assert.That(suite.Tests.Count, Is.EqualTo(0));
         }
 
-        [Test] 
+        [Test]
         public void CanRunMultipleTestFixtureSetUp()
         {
             TestAssert.IsRunnable(typeof(MultipleFixtureSetUpAttributes));
         }
 
-        [Test] 
+        [Test]
         public void CanRunMultipleTestFixtureTearDown()
         {
             TestAssert.IsRunnable(typeof(MultipleFixtureTearDownAttributes));
@@ -216,12 +215,11 @@ namespace NUnit.Framework.Internal
             TestAssert.IsRunnable(typeof(StaticFixtureWithoutTestFixtureAttribute));
         }
 
-#if !NETCF
         [Test]
         public void CanRunGenericFixtureWithProperArgsProvided()
         {
             TestSuite suite = TestBuilder.MakeFixture(typeof(GenericFixtureWithProperArgsProvided<>));
-                //GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureWithProperArgsProvided`1"));
+            // GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureWithProperArgsProvided`1"));
             Assert.That(suite.RunState, Is.EqualTo(RunState.Runnable));
             Assert.That(suite is ParameterizedFixtureSuite);
             Assert.That(suite.Tests.Count, Is.EqualTo(2));
@@ -234,7 +232,7 @@ namespace NUnit.Framework.Internal
 //                GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureWithNoTestFixtureAttribute`1"));
 //
 //            Assert.That(suite.RunState, Is.EqualTo(RunState.NotRunnable));
-//            Assert.That(suite.Properties.Get(PropertyNames.SkipReason), 
+//            Assert.That(suite.Properties.Get(PropertyNames.SkipReason),
 //                Does.StartWith("Fixture type contains generic parameters"));
 //        }
 
@@ -242,7 +240,7 @@ namespace NUnit.Framework.Internal
         public void CannotRunGenericFixtureWithNoArgsProvided()
         {
             TestSuite suite = TestBuilder.MakeFixture(typeof(GenericFixtureWithNoArgsProvided<>));
-                //GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureWithNoArgsProvided`1"));
+            // GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureWithNoArgsProvided`1"));
 
             Test fixture = (Test)suite.Tests[0];
             Assert.That(fixture.RunState, Is.EqualTo(RunState.NotRunnable));
@@ -253,7 +251,7 @@ namespace NUnit.Framework.Internal
         public void CannotRunGenericFixtureDerivedFromAbstractFixtureWithNoArgsProvided()
         {
             TestSuite suite = TestBuilder.MakeFixture(typeof(GenericFixtureDerivedFromAbstractFixtureWithNoArgsProvided<>));
-                //GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureDerivedFromAbstractFixtureWithNoArgsProvided`1"));
+            // GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureDerivedFromAbstractFixtureWithNoArgsProvided`1"));
             TestAssert.IsNotRunnable((Test)suite.Tests[0]);
         }
 
@@ -261,21 +259,21 @@ namespace NUnit.Framework.Internal
         public void CanRunGenericFixtureDerivedFromAbstractFixtureWithArgsProvided()
         {
             TestSuite suite = TestBuilder.MakeFixture(typeof(GenericFixtureDerivedFromAbstractFixtureWithArgsProvided<>));
-                //GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureDerivedFromAbstractFixtureWithArgsProvided`1"));
+            // GetTestDataType("NUnit.TestData.TestFixtureData.GenericFixtureDerivedFromAbstractFixtureWithArgsProvided`1"));
             Assert.That(suite.RunState, Is.EqualTo(RunState.Runnable));
             Assert.That(suite is ParameterizedFixtureSuite);
             Assert.That(suite.Tests.Count, Is.EqualTo(2));
         }
-#endif
-        
+
         #region SetUp Signature
-        [Test] 
+
+        [Test]
         public void CannotRunPrivateSetUp()
         {
             TestAssert.IsNotRunnable(typeof(PrivateSetUp));
         }
 
-        [Test] 
+        [Test]
         public void CanRunProtectedSetUp()
         {
             TestAssert.IsRunnable(typeof(ProtectedSetUp));
@@ -284,7 +282,7 @@ namespace NUnit.Framework.Internal
         /// <summary>
         /// Determines whether this instance [can run static set up].
         /// </summary>
-        [Test] 
+        [Test]
         public void CanRunStaticSetUp()
         {
             TestAssert.IsRunnable(typeof(StaticSetUp));
@@ -301,22 +299,24 @@ namespace NUnit.Framework.Internal
         {
             TestAssert.IsNotRunnable(typeof(SetUpWithParameters));
         }
+
         #endregion
 
         #region TearDown Signature
-        [Test] 
+
+        [Test]
         public void CannotRunPrivateTearDown()
         {
             TestAssert.IsNotRunnable(typeof(PrivateTearDown));
         }
 
-        [Test] 
+        [Test]
         public void CanRunProtectedTearDown()
         {
             TestAssert.IsRunnable(typeof(ProtectedTearDown));
         }
 
-        [Test] 
+        [Test]
         public void CanRunStaticTearDown()
         {
             TestAssert.IsRunnable(typeof(StaticTearDown));
@@ -333,22 +333,24 @@ namespace NUnit.Framework.Internal
         {
             TestAssert.IsNotRunnable(typeof(TearDownWithParameters));
         }
+
         #endregion
 
         #region TestFixtureSetUp Signature
-        [Test] 
+
+        [Test]
         public void CannotRunPrivateFixtureSetUp()
         {
             TestAssert.IsNotRunnable(typeof(PrivateFixtureSetUp));
         }
 
-        [Test] 
+        [Test]
         public void CanRunProtectedFixtureSetUp()
         {
             TestAssert.IsRunnable(typeof(ProtectedFixtureSetUp));
         }
 
-        [Test] 
+        [Test]
         public void CanRunStaticFixtureSetUp()
         {
             TestAssert.IsRunnable(typeof(StaticFixtureSetUp));
@@ -365,22 +367,24 @@ namespace NUnit.Framework.Internal
         {
             TestAssert.IsNotRunnable(typeof(FixtureSetUpWithParameters));
         }
+
         #endregion
 
         #region TestFixtureTearDown Signature
-        [Test] 
+
+        [Test]
         public void CannotRunPrivateFixtureTearDown()
         {
             TestAssert.IsNotRunnable(typeof(PrivateFixtureTearDown));
         }
 
-        [Test] 
+        [Test]
         public void CanRunProtectedFixtureTearDown()
         {
             TestAssert.IsRunnable(typeof(ProtectedFixtureTearDown));
         }
 
-        [Test] 
+        [Test]
         public void CanRunStaticFixtureTearDown()
         {
             TestAssert.IsRunnable(typeof(StaticFixtureTearDown));
@@ -389,14 +393,14 @@ namespace NUnit.Framework.Internal
 //		[TestFixture]
 //			[Category("fixture category")]
 //			[Category("second")]
-//			private class HasCategories 
+//			private class HasCategories
 //		{
 //			[Test] public void OneTest()
 //			{}
 //		}
 //
 //		[Test]
-//		public void LoadCategories() 
+//		public void LoadCategories()
 //		{
 //			TestSuite fixture = LoadFixture("NUnit.Core.Tests.TestFixtureBuilderTests+HasCategories");
 //			Assert.IsNotNull(fixture);
@@ -414,45 +418,45 @@ namespace NUnit.Framework.Internal
         {
             TestAssert.IsNotRunnable(typeof(FixtureTearDownWithParameters));
         }
+
         #endregion
-    }
 
+        #region Issue 318 - Test Fixture is null on ITest objects
 
-    #region Issue 318 - Test Fixture is null on ITest objects
+        public class FixtureNotNullTestAttribute : TestActionAttribute
+        {
+            private readonly string _location;
 
-    public class FixtureNotNullTestAttribute : TestActionAttribute
-    {
-        private readonly string _location;
+            public FixtureNotNullTestAttribute(string location)
+            {
+                _location = location;
+            }
 
-        public FixtureNotNullTestAttribute(string location)
-        {
-            _location = location;
+            public override void BeforeTest(ITest test)
+            {
+                Assert.That(test, Is.Not.Null, "ITest is null on a " + _location);
+                Assert.That(test.Fixture, Is.Not.Null, "ITest.Fixture is null on a " + _location);
+                Assert.That(test.Fixture.GetType(), Is.EqualTo(test.FixtureType), "ITest.Fixture is not the correct type on a " + _location);
+            }
         }
 
-        public override void BeforeTest(ITest test)
+        [FixtureNotNullTest("TestFixture class")]
+        [TestFixture]
+        public class FixtureIsNotNullForTests
         {
-            Assert.That(test, Is.Not.Null, "ITest is null on a " + _location);
-            Assert.That(test.Fixture, Is.Not.Null, "ITest.Fixture is null on a " + _location);
-            Assert.That(test.Fixture.GetType(), Is.EqualTo(test.FixtureType), "ITest.Fixture is not the correct type on a " + _location);
-        }
-    }
+            [FixtureNotNullTest("Test method")]
+            [Test]
+            public void TestMethod()
+            {
+            }
 
-    [FixtureNotNullTest("TestFixture class")]
-    [TestFixture]
-    public class FixtureIsNotNullForTests
-    {
-        [FixtureNotNullTest("Test method")]
-        [Test]
-        public void TestMethod()
-        {
+            [FixtureNotNullTest("TestCase method")]
+            [TestCase(1)]
+            public void TestCaseMethod(int i)
+            {
+            }
         }
 
-        [FixtureNotNullTest("TestCase method")]
-        [TestCase(1)]
-        public void TestCaseMethod(int i)
-        {
-        }
+        #endregion
     }
-
-    #endregion
 }
diff --git a/src/NUnitFramework/tests/Internal/TestWorkerTests.cs b/src/NUnitFramework/tests/Internal/TestWorkerTests.cs
index 3842e1f78..f62db83ca 100644
--- a/src/NUnitFramework/tests/Internal/TestWorkerTests.cs
+++ b/src/NUnitFramework/tests/Internal/TestWorkerTests.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2014 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -37,7 +37,11 @@ namespace NUnit.Framework.Internal.Execution
         public void SetUp()
         {
             _queue = new WorkItemQueue("TestQ");
+#if NETCF
+            _worker = new TestWorker(_queue, "TestQ_Worker");
+#else
             _worker = new TestWorker(_queue, "TestQ_Worker", ApartmentState.MTA);
+#endif
         }
 
         [TearDown]
@@ -54,7 +58,7 @@ namespace NUnit.Framework.Internal.Execution
 
             _worker.Busy += (s, ea) => { sb.Append("Busy"); };
             work.Executed += (s, ea) => { sb.Append("Exec"); };
-            _worker.Idle += (s, ea) => { sb.Append("Idle"); };                                                                                                                                                                                                                                       
+			_worker.Idle += (s, ea) => { sb.Append ("Idle"); };
 
             _queue.Enqueue(work);
             _worker.Start();
@@ -63,7 +67,10 @@ namespace NUnit.Framework.Internal.Execution
             Assert.That(() => sb.ToString(), Is.EqualTo("BusyExecIdle").After(200));
         }
 
-        private void FakeMethod() { }
+        private void FakeMethod()
+        {
+        }
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/tests/Internal/WorkItemQueueTests.cs b/src/NUnitFramework/tests/Internal/WorkItemQueueTests.cs
index 1d857f553..01c0e165c 100644
--- a/src/NUnitFramework/tests/Internal/WorkItemQueueTests.cs
+++ b/src/NUnitFramework/tests/Internal/WorkItemQueueTests.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2014 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -63,10 +63,17 @@ namespace NUnit.Framework.Internal.Execution
         [Test]
         public void StopQueue_WithWorkers()
         {
-            var workers = new TestWorker[] {
+            var workers = new TestWorker[]
+            {
+#if NETCF
+                new TestWorker(_queue, "1"),
+                new TestWorker(_queue, "2"),
+                new TestWorker(_queue, "3")
+#else
                 new TestWorker(_queue, "1", ApartmentState.MTA),
                 new TestWorker(_queue, "2", ApartmentState.MTA),
                 new TestWorker(_queue, "3", ApartmentState.MTA)
+#endif
             };
 
             foreach (var worker in workers)
@@ -79,7 +86,7 @@ namespace NUnit.Framework.Internal.Execution
             _queue.Stop();
             Assert.That(_queue.State, Is.EqualTo(WorkItemQueueState.Stopped));
 
-            Thread.Sleep(20); // Allow time for workers to stop
+            Thread.Sleep(20);  // Allow time for workers to stop
 
             foreach (var worker in workers)
                 Assert.False(worker.IsAlive, "Worker thread {0} did not stop", worker.Name);
@@ -142,9 +149,19 @@ namespace NUnit.Framework.Internal.Execution
             Assert.That(_queue.Dequeue().Test.Name, Is.EqualTo("Test2"));
             Assert.That(_queue.Dequeue().Test.Name, Is.EqualTo("Test3"));
         }
-        private void Test1() { }
-        private void Test2() { }
-        private void Test3() { }
+
+        private void Test1()
+        {
+        }
+
+        private void Test2()
+        {
+        }
+
+        private void Test3()
+        {
+        }
     }
 }
+
 #endif
diff --git a/src/NUnitFramework/tests/Syntax/ThrowsTests.cs b/src/NUnitFramework/tests/Syntax/ThrowsTests.cs
index 1b141485c..5b64027a1 100644
--- a/src/NUnitFramework/tests/Syntax/ThrowsTests.cs
+++ b/src/NUnitFramework/tests/Syntax/ThrowsTests.cs
@@ -1,4 +1,4 @@
-﻿// ***********************************************************************
+// ***********************************************************************
 // Copyright (c) 2009 Charlie Poole
 //
 // Permission is hereby granted, free of charge, to any person obtaining
@@ -8,10 +8,10 @@
 // distribute, sublicense, and/or sell copies of the Software, and to
 // permit persons to whom the Software is furnished to do so, subject to
 // the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be
 // included in all copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
@@ -126,7 +126,6 @@ namespace NUnit.Framework.Syntax
                 Throws.InstanceOf<ArgumentNullException>());
         }
 
-#if !NETCF
         [Test]
         public void LambdaThrowsExceptionWithMessage()
         {
@@ -136,16 +135,13 @@ namespace NUnit.Framework.Syntax
                 Throws.InstanceOf<ArgumentNullException>()
                 .And.Message.EqualTo(expectedExceptionMessage));
         }
-#endif
 
         internal class MyClass
         {
             public MyClass(string s)
             {
                 if (s == null)
-                {
                     throw new ArgumentNullException();
-                }
             }
         }
     }
diff --git a/src/NUnitFramework/tests/nunit.framework.tests-netcf-3.5.csproj b/src/NUnitFramework/tests/nunit.framework.tests-netcf-3.5.csproj
index 9b341c00d..f919feab0 100644
--- a/src/NUnitFramework/tests/nunit.framework.tests-netcf-3.5.csproj
+++ b/src/NUnitFramework/tests/nunit.framework.tests-netcf-3.5.csproj
@@ -25,7 +25,7 @@
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
     <OutputPath>..\..\..\bin\Debug\netcf-3.5\</OutputPath>
-    <DefineConstants>TRACE;DEBUG;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;NUNITLITE</DefineConstants>
+    <DefineConstants>TRACE;DEBUG;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;NUNITLITE;PARALLEL</DefineConstants>
     <NoStdLib>true</NoStdLib>
     <NoConfig>true</NoConfig>
     <ErrorReport>prompt</ErrorReport>
@@ -37,7 +37,7 @@
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
     <OutputPath>..\..\..\bin\Release\netcf-3.5\</OutputPath>
-    <DefineConstants>TRACE;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;NUNITLITE</DefineConstants>
+    <DefineConstants>TRACE;NUNIT_FRAMEWORK;WindowsCE;NETCF;NETCF_3_5;NUNITLITE;PARALLEL</DefineConstants>
     <NoStdLib>true</NoStdLib>
     <NoConfig>true</NoConfig>
     <ErrorReport>prompt</ErrorReport>
@@ -125,6 +125,7 @@
     <Compile Include="Attributes\TestMethodBuilderTests.cs" />
     <Compile Include="Attributes\TestOfTests.cs" />
     <Compile Include="Attributes\TheoryTests.cs" />
+    <Compile Include="Attributes\ThreadingTests.cs" />
     <Compile Include="Attributes\TimeoutTests.cs" />
     <Compile Include="Attributes\ValuesAttributeEnumTests.cs" />
     <Compile Include="Attributes\ValuesAttributeTests.cs" />
