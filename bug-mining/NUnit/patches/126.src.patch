diff --git a/src/NUnitFramework/framework/Compatibility/InterlockedExtensions.cs b/src/NUnitFramework/framework/Compatibility/InterlockedExtensions.cs
new file mode 100644
index 000000000..5141c6300
--- /dev/null
+++ b/src/NUnitFramework/framework/Compatibility/InterlockedExtensions.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Linq;
+using System.Collections.Generic;
+using System.Text;
+using System.Threading;
+
+namespace System.Threading
+	{
+	/// <summary>Provides atomic operations for variables that are shared by multiple threads.</summary>
+	public static class InterlockedEx
+		{
+		/// <summary>
+		///     Adds a 32-bit signed integer to a 32-bit signed integer and replaces the first integer with the sum, as an
+		///     atomic operation.
+		/// </summary>
+		/// <param name="target">
+		///     A variable containing the first value to be added. The sum of the two values is stored in
+		///     <paramref name="target" />.
+		/// </param>
+		/// <param name="value">The value to be added to the integer at <paramref name="target" />.</param>
+		/// <returns>The new value stored at <paramref name="target" />.</returns>
+		public static Int32 Add (ref Int32 target, Int32 value)
+			{
+			Int32 i, j = target, n;
+			do
+				{
+				i = j;
+				n = unchecked (i + value);
+				j = Interlocked.CompareExchange (ref target, n, i);
+				}
+			while (i != j);
+			return n;
+			}
+		}
+	}
diff --git a/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/ConcurrentQueue.cs b/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/ConcurrentQueue.cs
new file mode 100644
index 000000000..afdbe6af5
--- /dev/null
+++ b/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/ConcurrentQueue.cs
@@ -0,0 +1,413 @@
+// ConcurrentQueue.cs
+//
+// Copyright (c) 2008 Jérémie "Garuma" Laval
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+//
+//
+
+using System;
+using System.Threading;
+using System.Collections;
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+namespace System.Collections.Concurrent
+{
+
+    /// <summary>
+    /// Represents a thread-safe first-in, first-out collection of objects.
+    /// </summary>
+    /// <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
+    /// <remarks>
+    /// All public  and protected members of <see cref="ConcurrentQueue{T}"/> are thread-safe and may be used
+    /// concurrently from multiple threads.
+    /// </remarks>
+#if !NETCF
+	[System.Diagnostics.DebuggerDisplay ("Count={Count}")]
+	[System.Diagnostics.DebuggerTypeProxy (typeof (CollectionDebuggerView<>))]
+#endif
+	public class ConcurrentQueue<T> : IProducerConsumerCollection<T>, IEnumerable<T>, ICollection,
+	                                  IEnumerable
+	{
+		class Node
+		{
+			public T Value;
+			public Node Next;
+		}
+		
+		Node head = new Node ();
+		Node tail;
+		int count;
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ConcurrentQueue{T}"/> class.
+        /// </summary>
+		public ConcurrentQueue ()
+		{
+			tail = head;
+		}
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ConcurrentQueue{T}"/>
+        /// class that contains elements copied from the specified collection
+        /// </summary>
+        /// <param name="collection">The collection whose elements are copied to the new <see
+        /// cref="ConcurrentQueue{T}"/>.</param>
+        /// <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
+        /// null.</exception>
+        public ConcurrentQueue (IEnumerable<T> collection): this()
+		{
+            if (collection == null)
+                throw new ArgumentNullException("collection");
+
+            foreach (T item in collection)
+				Enqueue (item);
+		}
+
+        /// <summary>
+        /// Adds an object to the end of the <see cref="ConcurrentQueue{T}"/>.
+        /// </summary>
+        /// <param name="item">The object to add to the end of the <see
+        /// cref="ConcurrentQueue{T}"/>. The value can be a null reference
+        /// (Nothing in Visual Basic) for reference types.
+        /// </param>
+        public void Enqueue (T item)
+		{
+			Node node = new Node ();
+			node.Value = item;
+			
+			Node oldTail = null;
+			Node oldNext = null;
+			
+			bool update = false;
+			while (!update) {
+				oldTail = tail;
+				oldNext = oldTail.Next;
+				
+				// Did tail was already updated ?
+				if (tail == oldTail) {
+					if (oldNext == null) {
+						// The place is for us
+						update = Interlocked.CompareExchange (ref tail.Next, node, null) == null;
+					} else {
+						// another Thread already used the place so give him a hand by putting tail where it should be
+						Interlocked.CompareExchange (ref tail, oldNext, oldTail);
+					}
+				}
+			}
+			// At this point we added correctly our node, now we have to update tail. If it fails then it will be done by another thread
+			Interlocked.CompareExchange (ref tail, node, oldTail);
+			Interlocked.Increment (ref count);
+		}
+
+        /// <summary>
+        /// Attempts to add an object to the <see
+        /// cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
+        /// </summary>
+        /// <param name="item">The object to add to the <see
+        /// cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. The value can be a null
+        /// reference (Nothing in Visual Basic) for reference types.
+        /// </param>
+        /// <returns>true if the object was added successfully; otherwise, false.</returns>
+        /// <remarks>For <see cref="ConcurrentQueue{T}"/>, this operation will always add the object to the
+        /// end of the <see cref="ConcurrentQueue{T}"/>
+        /// and return true.</remarks>
+        bool IProducerConsumerCollection<T>.TryAdd (T item)
+		{
+			Enqueue (item);
+			return true;
+		}
+
+        /// <summary>
+        /// Attempts to remove and return the object at the beginning of the <see
+        /// cref="ConcurrentQueue{T}"/>.
+        /// </summary>
+        /// <param name="result">
+        /// When this method returns, if the operation was successful, <paramref name="result"/> contains the
+        /// object removed. If no object was available to be removed, the value is unspecified.
+        /// </param>
+        /// <returns>true if an element was removed and returned from the beginning of the <see
+        /// cref="ConcurrentQueue{T}"/>
+        /// successfully; otherwise, false.</returns>
+		public bool TryDequeue (out T result)
+		{
+			result = default (T);
+			Node oldNext = null;
+			bool advanced = false;
+
+			while (!advanced) {
+				Node oldHead = head;
+				Node oldTail = tail;
+				oldNext = oldHead.Next;
+				
+				if (oldHead == head) {
+					// Empty case ?
+					if (oldHead == oldTail) {
+						// This should be false then
+						if (oldNext != null) {
+							// If not then the linked list is mal formed, update tail
+							Interlocked.CompareExchange (ref tail, oldNext, oldTail);
+							continue;
+						}
+						result = default (T);
+						return false;
+					} else {
+						result = oldNext.Value;
+						advanced = Interlocked.CompareExchange (ref head, oldNext, oldHead) == oldHead;
+					}
+				}
+			}
+
+			oldNext.Value = default (T);
+
+			Interlocked.Decrement (ref count);
+
+			return true;
+		}
+
+        /// <summary>
+        /// Attempts to return an object from the beginning of the <see cref="ConcurrentQueue{T}"/>
+        /// without removing it.
+        /// </summary>
+        /// <param name="result">When this method returns, <paramref name="result"/> contains an object from
+        /// the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue{T}"/> or an
+        /// unspecified value if the operation failed.</param>
+        /// <returns>true if and object was returned successfully; otherwise, false.</returns>
+        public bool TryPeek (out T result)
+		{
+			result = default (T);
+			bool update = true;
+			
+			while (update)
+			{
+				Node oldHead = head;
+				Node oldNext = oldHead.Next;
+
+				if (oldNext == null) {
+					result = default (T);
+					return false;
+				}
+
+				result = oldNext.Value;
+				
+				//check if head has been updated
+				update = head != oldHead;
+			}
+			return true;
+		}
+		
+		internal void Clear ()
+		{
+			count = 0;
+			tail = head = new Node ();
+		}
+
+        /// <summary>
+        /// Returns an enumerator that iterates through a collection.
+        /// </summary>
+        /// <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
+        IEnumerator IEnumerable.GetEnumerator ()
+		{
+			return (IEnumerator)InternalGetEnumerator ();
+		}
+
+        /// <summary>
+        /// Returns an enumerator that iterates through the <see
+        /// cref="ConcurrentQueue{T}"/>.
+        /// </summary>
+        /// <returns>An enumerator for the contents of the <see
+        /// cref="ConcurrentQueue{T}"/>.</returns>
+        /// <remarks>
+        /// The enumeration represents a moment-in-time snapshot of the contents
+        /// of the queue.  It does not reflect any updates to the collection after 
+        /// <see cref="GetEnumerator"/> was called.  The enumerator is safe to use
+        /// concurrently with reads from and writes to the queue.
+        /// </remarks>
+        public IEnumerator<T> GetEnumerator ()
+		{
+			return InternalGetEnumerator ();
+		}
+		
+		IEnumerator<T> InternalGetEnumerator ()
+		{
+			Node my_head = head;
+			while ((my_head = my_head.Next) != null) {
+				yield return my_head.Value;
+			}
+		}
+
+        /// <summary>
+        /// Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see
+        /// cref="T:System.Array"/>, starting at a particular
+        /// <see cref="T:System.Array"/> index.
+        /// </summary>
+        /// <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
+        /// destination of the elements copied from the
+        /// <see cref="T:System.Collections.Concurrent.ConcurrentBag"/>. The <see
+        /// cref="T:System.Array">Array</see> must have zero-based indexing.</param>
+        /// <param name="index">The zero-based index in <paramref name="array"/> at which copying
+        /// begins.</param>
+        /// <exception cref="ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
+        /// Visual Basic).</exception>
+        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"/> is less than
+        /// zero.</exception>
+        /// <exception cref="ArgumentException">
+        /// <paramref name="array"/> is multidimensional. -or-
+        /// <paramref name="array"/> does not have zero-based indexing. -or-
+        /// <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
+        /// -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
+        /// greater than the available space from <paramref name="index"/> to the end of the destination
+        /// <paramref name="array"/>. -or- The type of the source <see
+        /// cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
+        /// destination <paramref name="array"/>.
+        /// </exception>
+        void ICollection.CopyTo (Array array, int index)
+		{
+			if (array == null)
+				throw new ArgumentNullException ("array");
+			if (array.Rank > 1)
+				throw new ArgumentException ("The array can't be multidimensional");
+			if (array.GetLowerBound (0) != 0)
+				throw new ArgumentException ("The array needs to be 0-based");
+
+			T[] dest = array as T[];
+			if (dest == null)
+				throw new ArgumentException ("The array cannot be cast to the collection element type", "array");
+			CopyTo (dest, index);
+		}
+
+        /// <summary>
+        /// Copies the <see cref="ConcurrentQueue{T}"/> elements to an existing one-dimensional <see
+        /// cref="T:System.Array">Array</see>, starting at the specified array index.
+        /// </summary>
+        /// <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
+        /// destination of the elements copied from the
+        /// <see cref="ConcurrentQueue{T}"/>. The <see cref="T:System.Array">Array</see> must have zero-based
+        /// indexing.</param>
+        /// <param name="index">The zero-based index in <paramref name="array"/> at which copying
+        /// begins.</param>
+        /// <exception cref="ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
+        /// Visual Basic).</exception>
+        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"/> is less than
+        /// zero.</exception>
+        /// <exception cref="ArgumentException"><paramref name="index"/> is equal to or greater than the
+        /// length of the <paramref name="array"/>
+        /// -or- The number of elements in the source <see cref="ConcurrentQueue{T}"/> is greater than the
+        /// available space from <paramref name="index"/> to the end of the destination <paramref
+        /// name="array"/>.
+        /// </exception>
+        public void CopyTo (T[] array, int index)
+		{
+			if (array == null)
+				throw new ArgumentNullException ("array");
+			if (index < 0)
+				throw new ArgumentOutOfRangeException ("index");
+			if (index >= array.Length)
+				throw new ArgumentException ("index is equals or greather than array length", "index");
+
+			IEnumerator<T> e = InternalGetEnumerator ();
+			int i = index;
+			while (e.MoveNext ()) {
+				if (i == array.Length - index)
+					throw new ArgumentException ("The number of elememts in the collection exceeds the capacity of array", "array");
+				array[i++] = e.Current;
+			}
+		}
+
+        /// <summary>
+        /// Copies the elements stored in the <see cref="ConcurrentQueue{T}"/> to a new array.
+        /// </summary>
+        /// <returns>A new array containing a snapshot of elements copied from the <see
+        /// cref="ConcurrentQueue{T}"/>.</returns>
+        public T[] ToArray ()
+		{
+			return new List<T> (this).ToArray ();
+		}
+
+        /// <summary>
+        /// Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
+        /// synchronized with the SyncRoot.
+        /// </summary>
+        /// <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
+        /// with the SyncRoot; otherwise, false. For <see cref="ConcurrentQueue{T}"/>, this property always
+        /// returns false.</value>
+        bool ICollection.IsSynchronized {
+			get { return false; }
+		}
+
+        /// <summary>
+        /// Attempts to remove and return an object from the <see
+        /// cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
+        /// </summary>
+        /// <param name="item">
+        /// When this method returns, if the operation was successful, <paramref name="item"/> contains the
+        /// object removed. If no object was available to be removed, the value is unspecified.
+        /// </param>
+        /// <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
+        /// <remarks>For <see cref="ConcurrentQueue{T}"/>, this operation will attempt to remove the object
+        /// from the beginning of the <see cref="ConcurrentQueue{T}"/>.
+        /// </remarks>
+		bool IProducerConsumerCollection<T>.TryTake (out T item)
+		{
+			return TryDequeue (out item);
+		}
+		
+        /// <summary>
+        /// Gets an object that can be used to synchronize access to the <see
+        /// cref="T:System.Collections.ICollection"/>. This property is not supported.
+        /// </summary>
+        /// <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
+		object ICollection.SyncRoot {
+			get { throw new NotSupportedException (); }
+		}
+
+        /// <summary>
+        /// Gets the number of elements contained in the <see cref="ConcurrentQueue{T}"/>.
+        /// </summary>
+        /// <value>The number of elements contained in the <see cref="ConcurrentQueue{T}"/>.</value>
+        /// <remarks>
+        /// For determining whether the collection contains any items, use of the <see cref="IsEmpty"/>
+        /// property is recommended rather than retrieving the number of items from the <see cref="Count"/>
+        /// property and comparing it to 0.
+        /// </remarks>
+        public int Count {
+			get {
+				return count;
+			}
+		}
+
+        /// <summary>
+        /// Gets a value that indicates whether the <see cref="ConcurrentQueue{T}"/> is empty.
+        /// </summary>
+        /// <value>true if the <see cref="ConcurrentQueue{T}"/> is empty; otherwise, false.</value>
+        /// <remarks>
+        /// For determining whether the collection contains any items, use of this property is recommended
+        /// rather than retrieving the number of items from the <see cref="Count"/> property and comparing it
+        /// to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
+        /// that another thread will modify the collection after <see cref="IsEmpty"/> returns, thus invalidating
+        /// the result.
+        /// </remarks>
+        public bool IsEmpty {
+			get {
+				return count == 0;
+			}
+		}
+	}
+}
diff --git a/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/IProducerConsumerCollection.cs b/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/IProducerConsumerCollection.cs
new file mode 100644
index 000000000..17ec90a9f
--- /dev/null
+++ b/src/NUnitFramework/framework/Compatibility/System.Collections.Concurrent/IProducerConsumerCollection.cs
@@ -0,0 +1,90 @@
+// IConcurrentCollection.cs
+//
+// Copyright (c) 2008 Jérémie "Garuma" Laval
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+//
+//
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace System.Collections.Concurrent
+{
+    /// <summary>
+    /// Defines methods to manipulate thread-safe collections intended for producer/consumer usage.
+    /// </summary>
+    /// <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
+    /// <remarks>
+    /// All implementations of this interface must enable all members of this interface
+    /// to be used concurrently from multiple threads.
+    /// </remarks>
+	public interface IProducerConsumerCollection<T> : IEnumerable<T>, ICollection, IEnumerable
+	{
+        /// <summary>
+        /// Attempts to add an object to the <see
+        /// cref="IProducerConsumerCollection{T}"/>.
+        /// </summary>
+        /// <param name="item">The object to add to the <see
+        /// cref="IProducerConsumerCollection{T}"/>.</param>
+        /// <returns>true if the object was added successfully; otherwise, false.</returns>
+        /// <exception cref="T:System.ArgumentException">The <paramref name="item"/> was invalid for this collection.</exception>
+		bool TryAdd (T item);
+
+        /// <summary>
+        /// Attempts to remove and return an object from the <see cref="IProducerConsumerCollection{T}"/>.
+        /// </summary>
+        /// <param name="item">
+        /// When this method returns, if the object was removed and returned successfully, <paramref
+        /// name="item"/> contains the removed object. If no object was available to be removed, the value is
+        /// unspecified.
+        /// </param>
+        /// <returns>true if an object was removed and returned successfully; otherwise, false.</returns>
+		bool TryTake (out T item);
+
+        /// <summary>
+        /// Copies the elements contained in the <see cref="IProducerConsumerCollection{T}"/> to a new array.
+        /// </summary>
+        /// <returns>A new array containing the elements copied from the <see cref="IProducerConsumerCollection{T}"/>.</returns>
+		T[] ToArray ();
+
+        /// <summary>
+        /// Copies the elements of the <see cref="IProducerConsumerCollection{T}"/> to
+        /// an
+        /// <see cref="T:System.Array"/>, starting at a specified index.
+        /// </summary>
+        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
+        /// the elements copied from the <see cref="IProducerConsumerCollection{T}"/>.
+        /// The array must have zero-based indexing.</param>
+        /// <param name="index">The zero-based index in <paramref name="array"/> at which copying
+        /// begins.</param>
+        /// <exception cref="ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
+        /// Visual Basic).</exception>
+        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"/> is less than
+        /// zero.</exception>
+        /// <exception cref="ArgumentException"><paramref name="index"/> is equal to or greater than the
+        /// length of the <paramref name="array"/>
+        /// -or- The number of elements in the source <see cref="ConcurrentQueue{T}"/> is greater than the
+        /// available space from <paramref name="index"/> to the end of the destination <paramref
+        /// name="array"/>.
+        /// </exception>
+		void CopyTo (T[] array, int index);
+	}
+}
diff --git a/src/NUnitFramework/framework/Compatibility/System.Linq/CollectionDebuggerView.cs b/src/NUnitFramework/framework/Compatibility/System.Collections/CollectionDebuggerView.cs
similarity index 100%
rename from src/NUnitFramework/framework/Compatibility/System.Linq/CollectionDebuggerView.cs
rename to src/NUnitFramework/framework/Compatibility/System.Collections/CollectionDebuggerView.cs
diff --git a/src/NUnitFramework/framework/Constraints/EqualConstraint.cs b/src/NUnitFramework/framework/Constraints/EqualConstraint.cs
index 581f7cd0d..96639420f 100644
--- a/src/NUnitFramework/framework/Constraints/EqualConstraint.cs
+++ b/src/NUnitFramework/framework/Constraints/EqualConstraint.cs
@@ -167,6 +167,7 @@ namespace NUnit.Framework.Constraints
             return this;
         }
 
+#if !NETCF
         /// <summary>
         /// Flags the constraint to include <see cref="DateTimeOffset.Offset"/>
         /// property in comparison of two <see cref="DateTimeOffset"/> values.
@@ -183,6 +184,7 @@ namespace NUnit.Framework.Constraints
                 return this;
             }
         }
+#endif
 
         /// <summary>
         /// Switches the .Within() modifier to interpret its tolerance as
diff --git a/src/NUnitFramework/framework/Constraints/NUnitEqualityComparer.cs b/src/NUnitFramework/framework/Constraints/NUnitEqualityComparer.cs
index 6aa9cb321..935970336 100644
--- a/src/NUnitFramework/framework/Constraints/NUnitEqualityComparer.cs
+++ b/src/NUnitFramework/framework/Constraints/NUnitEqualityComparer.cs
@@ -114,6 +114,7 @@ namespace NUnit.Framework.Constraints
             get { return failurePoints; }
         }
 
+#if !NETCF
         /// <summary>
         /// Flags the comparer to include <see cref="DateTimeOffset.Offset"/>
         /// property in comparison of two <see cref="DateTimeOffset"/> values.
@@ -123,8 +124,8 @@ namespace NUnit.Framework.Constraints
         /// modifier.
         /// </remarks>
         public bool WithSameOffset { get; set; }
-
-        #endregion
+#endif
+		  #endregion
 
         #region Public Methods
         /// <summary>
diff --git a/src/NUnitFramework/framework/Interfaces/ITestResult.cs b/src/NUnitFramework/framework/Interfaces/ITestResult.cs
index 016c78645..4d2eb0d84 100644
--- a/src/NUnitFramework/framework/Interfaces/ITestResult.cs
+++ b/src/NUnitFramework/framework/Interfaces/ITestResult.cs
@@ -157,7 +157,7 @@ namespace NUnit.Framework.Interfaces
         /// <summary>
         /// Gets the the collection of child results.
         /// </summary>
-        System.Collections.Generic.IList<ITestResult> Children
+        System.Collections.Concurrent.ConcurrentQueue<ITestResult> Children
         {
             get;
         }
diff --git a/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs b/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
index bd094e16d..208ff5387 100644
--- a/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
+++ b/src/NUnitFramework/framework/Internal/Execution/TestWorker.cs
@@ -52,17 +52,22 @@ namespace NUnit.Framework.Internal.Execution
         /// </summary>
         public event EventHandler Idle;
 
+#if NETCF
+        /// <summary>
+        /// Construct a new TestWorker.
+        /// </summary>
+        /// <param name="queue">The queue from which to pull work items</param>
+        /// <param name="name">The name of this worker</param>
+        public TestWorker(WorkItemQueue queue, string name)
+#else
         /// <summary>
         /// Construct a new TestWorker.
         /// </summary>
         /// <param name="queue">The queue from which to pull work items</param>
         /// <param name="name">The name of this worker</param>
         /// <param name="apartmentState">The apartment state to use for running tests</param>
-        public TestWorker(WorkItemQueue queue, string name
-#if !NETCF
-                          , ApartmentState apartmentState
+        public TestWorker(WorkItemQueue queue, string name, ApartmentState apartmentState)
 #endif
-                          )
         {
             _readyQueue = queue;
 
diff --git a/src/NUnitFramework/framework/Internal/Results/TestCaseResult.cs b/src/NUnitFramework/framework/Internal/Results/TestCaseResult.cs
index 6b6a0105e..9b122f6c8 100644
--- a/src/NUnitFramework/framework/Internal/Results/TestCaseResult.cs
+++ b/src/NUnitFramework/framework/Internal/Results/TestCaseResult.cs
@@ -23,6 +23,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Concurrent;
 using NUnit.Framework.Interfaces;
 
 namespace NUnit.Framework.Internal
@@ -87,9 +88,9 @@ namespace NUnit.Framework.Internal
         /// <summary>
         /// Gets the collection of child results.
         /// </summary>
-        public override IList<ITestResult> Children
+        public override ConcurrentQueue<ITestResult> Children
         {
-            get { return new ITestResult[0]; }
+            get { return EmptyChildQueue; }
         }
 
         #endregion
diff --git a/src/NUnitFramework/framework/Internal/Results/TestResult.cs b/src/NUnitFramework/framework/Internal/Results/TestResult.cs
index 4795c5b7a..ba61cfdca 100644
--- a/src/NUnitFramework/framework/Internal/Results/TestResult.cs
+++ b/src/NUnitFramework/framework/Internal/Results/TestResult.cs
@@ -23,10 +23,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Concurrent;
 using System.Globalization;
 using System.IO;
 using System.Text;
 using NUnit.Framework.Interfaces;
+using System.Threading;
 
 namespace NUnit.Framework.Internal
 {
@@ -52,11 +54,23 @@ namespace NUnit.Framework.Internal
         /// </summary>
         internal const double MIN_DURATION = 0.000001d;
 
-//        static Logger log = InternalTrace.GetLogger("TestResult");
+        /// <summary>
+        /// Empty child queue
+        /// </summary>
+        protected static readonly ConcurrentQueue<ITestResult> EmptyChildQueue = new ConcurrentQueue<ITestResult> ();
+
+        //        static Logger log = InternalTrace.GetLogger("TestResult");
 
         private StringBuilder _output = new StringBuilder();
         private double _duration;
 
+        /// <summary>
+        /// Aggregate assertion count
+        /// </summary>
+        protected int InternalAssertCount;
+
+        private ResultState _resultState;
+
         #endregion
 
         #region Constructor
@@ -90,7 +104,11 @@ namespace NUnit.Framework.Internal
         /// Gets the ResultState of the test result, which 
         /// indicates the success or failure of the test.
         /// </summary>
-        public ResultState ResultState { get; private set; }
+        public ResultState ResultState
+        {
+            get { return _resultState; }
+            private set { _resultState = value; }
+        }
 
         /// <summary>
         /// Gets the name of the test result
@@ -143,7 +161,11 @@ namespace NUnit.Framework.Internal
         /// Gets or sets the count of asserts executed
         /// when running the test.
         /// </summary>
-        public int AssertCount { get; set; }
+        public int AssertCount
+        {
+            get { return InternalAssertCount; }
+            set { InternalAssertCount = value; }
+        }
 
         /// <summary>
         /// Gets the number of test cases that failed
@@ -177,7 +199,7 @@ namespace NUnit.Framework.Internal
         /// <summary>
         /// Gets the collection of child results.
         /// </summary>
-        public abstract IList<ITestResult> Children { get; }
+        public abstract ConcurrentQueue<ITestResult> Children { get; }
 
         /// <summary>
         /// Gets a TextWriter, which will write output to be included in the result.
@@ -192,7 +214,7 @@ namespace NUnit.Framework.Internal
             get { return _output.ToString(); }
         }
 
-#endregion
+        #endregion
 
         #region IXmlNodeBuilder Members
 
@@ -447,6 +469,42 @@ namespace NUnit.Framework.Internal
             return targetNode.AddElementWithCDATA("output", Output);
         }
 
+        /// <summary>
+        /// Set the result of the test only if the current ResultState has not changed
+        /// </summary>
+        /// <param name="currentResultState">The current ResultState</param>
+        /// <param name="resultState">The ResultState to use in the result</param>
+        protected void SetResultIf(ResultState currentResultState, ResultState resultState)
+        {
+            SetResultIf(currentResultState, resultState, null, null);
+        }
+
+        /// <summary>
+        /// Set the result of the test only if the current ResultState has not changed
+        /// </summary>
+        /// <param name="currentResultState">The current ResultState</param>
+        /// <param name="resultState">The ResultState to use in the result</param>
+        /// <param name="message">A message associated with the result state</param>
+        protected void SetResultIf(ResultState currentResultState, ResultState resultState, string message)
+        {
+            SetResultIf(currentResultState, resultState, message, null);
+        }
+
+        /// <summary>
+        /// Set the result of the test only if the current ResultState has not changed
+        /// </summary>
+        /// <param name="currentResultState">The current ResultState</param>
+        /// <param name="resultState">The ResultState to use in the result</param>
+        /// <param name="message">A message associated with the result state</param>
+        /// <param name="stackTrace">Stack trace giving the location of the command</param>
+        protected void SetResultIf(ResultState currentResultState, ResultState resultState, string message, string stackTrace)
+        {
+            if (Interlocked.CompareExchange(ref _resultState, resultState, currentResultState) != currentResultState)
+                return;
+
+            Message = message;
+            StackTrace = stackTrace;
+        }
         #endregion
     }
 }
diff --git a/src/NUnitFramework/framework/Internal/Results/TestSuiteResult.cs b/src/NUnitFramework/framework/Internal/Results/TestSuiteResult.cs
index e4f1d3906..ebf7caaae 100644
--- a/src/NUnitFramework/framework/Internal/Results/TestSuiteResult.cs
+++ b/src/NUnitFramework/framework/Internal/Results/TestSuiteResult.cs
@@ -23,7 +23,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Concurrent;
 using NUnit.Framework.Interfaces;
+using System.Threading;
+#if NETCF
+using Interlocked = System.Threading.InterlockedEx;
+#endif
 
 namespace NUnit.Framework.Internal
 {
@@ -36,7 +41,7 @@ namespace NUnit.Framework.Internal
         private int _failCount = 0;
         private int _skipCount = 0;
         private int _inconclusiveCount = 0;
-        private List<ITestResult> _children;
+        private ConcurrentQueue<ITestResult> _children;
 
         /// <summary>
         /// Construct a TestSuiteResult base on a TestSuite
@@ -44,7 +49,7 @@ namespace NUnit.Framework.Internal
         /// <param name="suite">The TestSuite to which the result applies</param>
         public TestSuiteResult(TestSuite suite) : base(suite)
         {
-            _children = new List<ITestResult>();
+            _children = new ConcurrentQueue<ITestResult>();
         }
 
         #region Overrides
@@ -96,7 +101,7 @@ namespace NUnit.Framework.Internal
         /// <summary>
         /// Gets the collection of child results.
         /// </summary>
-        public override IList<ITestResult> Children
+        public override ConcurrentQueue<ITestResult> Children
         {
             get { return _children; }
         }
@@ -112,34 +117,36 @@ namespace NUnit.Framework.Internal
         /// <param name="result">The result to be added</param>
         public virtual void AddResult(ITestResult result)
         {
-            Children.Add(result);
+            Children.Enqueue(result);
 
             //AssertCount += result.AssertCount;
 
+            var resultState = ResultState;
+
             // If this result is marked cancelled, don't change it
-            if (ResultState != ResultState.Cancelled)
+            if (resultState != ResultState.Cancelled)
                 switch (result.ResultState.Status)
                 {
                     case TestStatus.Passed:
 
-                        if (ResultState.Status == TestStatus.Inconclusive)
-                            SetResult(ResultState.Success);
+                        if (resultState.Status == TestStatus.Inconclusive)
+                            SetResultIf(resultState, ResultState.Success);
 
                         break;
 
                     case TestStatus.Failed:
 
 
-                        if (ResultState.Status != TestStatus.Failed)
-                            SetResult(ResultState.ChildFailure, CHILD_ERRORS_MESSAGE);
+                        if (resultState.Status != TestStatus.Failed)
+                            SetResultIf(resultState, ResultState.ChildFailure, CHILD_ERRORS_MESSAGE);
 
                         break;
 
                     case TestStatus.Skipped:
 
                         if (result.ResultState.Label == "Ignored")
-                            if (ResultState.Status == TestStatus.Inconclusive || ResultState.Status == TestStatus.Passed)
-                                SetResult(ResultState.Ignored, CHILD_IGNORE_MESSAGE);
+                            if (resultState.Status == TestStatus.Inconclusive || resultState.Status == TestStatus.Passed)
+                                SetResultIf(resultState, ResultState.Ignored, CHILD_IGNORE_MESSAGE);
 
                         break;
 
@@ -147,11 +154,11 @@ namespace NUnit.Framework.Internal
                         break;
                 }
 
-            AssertCount += result.AssertCount;
-            _passCount += result.PassCount;
-            _failCount += result.FailCount;
-            _skipCount += result.SkipCount;
-            _inconclusiveCount += result.InconclusiveCount;
+            Interlocked.Add (ref InternalAssertCount, result.AssertCount);
+            Interlocked.Add (ref _passCount, result.PassCount);
+            Interlocked.Add (ref _failCount, result.FailCount);
+            Interlocked.Add (ref _skipCount, result.SkipCount);
+            Interlocked.Add (ref _inconclusiveCount, result.InconclusiveCount);
         }
 
         #endregion
diff --git a/src/NUnitFramework/framework/nunit.framework-2.0.csproj b/src/NUnitFramework/framework/nunit.framework-2.0.csproj
index f570c0619..a43ebf09f 100644
--- a/src/NUnitFramework/framework/nunit.framework-2.0.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-2.0.csproj
@@ -122,9 +122,11 @@
     <Compile Include="Attributes\TestActionAttribute.cs" />
     <Compile Include="Attributes\TestFixtureSourceAttribute.cs" />
     <Compile Include="Attributes\TestOfAttribute.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\IProducerConsumerCollection.cs" />
     <Compile Include="Compatibility\System.Linq\Actions.cs" />
     <Compile Include="Compatibility\System.Linq\Check.cs" />
-    <Compile Include="Compatibility\System.Linq\CollectionDebuggerView.cs" />
+    <Compile Include="Compatibility\System.Collections\CollectionDebuggerView.cs" />
     <Compile Include="Compatibility\System.Linq\Enumerable.cs" />
     <Compile Include="Compatibility\System.Linq\ExtensionAttribute.cs" />
     <Compile Include="Compatibility\System.Linq\Funcs.cs" />
diff --git a/src/NUnitFramework/framework/nunit.framework-3.5.csproj b/src/NUnitFramework/framework/nunit.framework-3.5.csproj
index a7286b3f5..47e7e62f5 100644
--- a/src/NUnitFramework/framework/nunit.framework-3.5.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-3.5.csproj
@@ -122,6 +122,9 @@
     <Compile Include="Attributes\TestActionAttribute.cs" />
     <Compile Include="Attributes\TestFixtureSourceAttribute.cs" />
     <Compile Include="Attributes\TestOfAttribute.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\IProducerConsumerCollection.cs" />
+    <Compile Include="Compatibility\System.Collections\CollectionDebuggerView.cs" />
     <Compile Include="Constraints\CollectionSupersetConstraint.cs" />
     <Compile Include="Constraints\DictionaryContainsValueConstraint.cs" />
     <Compile Include="Constraints\EqualConstraintResult.cs" />
diff --git a/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj b/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
index a4b8833cf..958977fc8 100644
--- a/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-netcf-3.5.csproj
@@ -200,6 +200,9 @@
     <Compile Include="Attributes\ValuesAttribute.cs" />
     <Compile Include="Attributes\ValueSourceAttribute.cs" />
     <Compile Include="CollectionAssert.cs" />
+    <Compile Include="Compatibility\InterlockedExtensions.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\IProducerConsumerCollection.cs" />
     <Compile Include="Constraints\AllItemsConstraint.cs" />
     <Compile Include="Constraints\AndConstraint.cs" />
     <Compile Include="Constraints\AssignableFromConstraint.cs" />
@@ -462,6 +465,9 @@
       <Link>nunit.snk</Link>
     </None>
   </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Compatibility\System.Collections\" />
+  </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CompactFramework.CSharp.targets" />
   <ProjectExtensions>
     <VisualStudio>
diff --git a/src/NUnitFramework/framework/nunit.framework-portable.csproj b/src/NUnitFramework/framework/nunit.framework-portable.csproj
index 4e5886677..f4b94f529 100644
--- a/src/NUnitFramework/framework/nunit.framework-portable.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-portable.csproj
@@ -186,6 +186,9 @@
     <Compile Include="Attributes\ValuesAttribute.cs" />
     <Compile Include="Attributes\ValueSourceAttribute.cs" />
     <Compile Include="CollectionAssert.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\IProducerConsumerCollection.cs" />
+    <Compile Include="Compatibility\System.Collections\CollectionDebuggerView.cs" />
     <Compile Include="Constraints\AllItemsConstraint.cs" />
     <Compile Include="Constraints\AndConstraint.cs" />
     <Compile Include="Constraints\AssignableFromConstraint.cs" />
diff --git a/src/NUnitFramework/framework/nunit.framework-sl-5.0.csproj b/src/NUnitFramework/framework/nunit.framework-sl-5.0.csproj
index 41348f519..e47cdf90b 100644
--- a/src/NUnitFramework/framework/nunit.framework-sl-5.0.csproj
+++ b/src/NUnitFramework/framework/nunit.framework-sl-5.0.csproj
@@ -202,6 +202,9 @@
     <Compile Include="Attributes\ValuesAttribute.cs" />
     <Compile Include="Attributes\ValueSourceAttribute.cs" />
     <Compile Include="CollectionAssert.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Compatibility\System.Collections.Concurrent\IProducerConsumerCollection.cs" />
+    <Compile Include="Compatibility\System.Collections\CollectionDebuggerView.cs" />
     <Compile Include="Constraints\AllItemsConstraint.cs" />
     <Compile Include="Constraints\AndConstraint.cs" />
     <Compile Include="Constraints\AssignableFromConstraint.cs" />
diff --git a/src/NUnitFramework/tests/Assertions/AssertIgnoreTests.cs b/src/NUnitFramework/tests/Assertions/AssertIgnoreTests.cs
index 4037c1113..f09c85c0a 100644
--- a/src/NUnitFramework/tests/Assertions/AssertIgnoreTests.cs
+++ b/src/NUnitFramework/tests/Assertions/AssertIgnoreTests.cs
@@ -73,7 +73,7 @@ namespace NUnit.Framework.Assertions
         {
             TestSuite suite = new TestSuite("IgnoredTestFixture");
             suite.Add( TestBuilder.MakeFixture( typeof( IgnoredTestSuiteFixture ) ) );
-            ITestResult fixtureResult = TestBuilder.RunTest(suite).Children[0];
+            ITestResult fixtureResult = TestBuilder.RunTest(suite).Children.ToArray ()[0];
 
             Assert.AreEqual(ResultState.Ignored.WithSite(FailureSite.SetUp), fixtureResult.ResultState);
 
diff --git a/src/NUnitFramework/tests/Attributes/MaxTimeTests.cs b/src/NUnitFramework/tests/Attributes/MaxTimeTests.cs
index 43504c1b4..77147d51c 100644
--- a/src/NUnitFramework/tests/Attributes/MaxTimeTests.cs
+++ b/src/NUnitFramework/tests/Attributes/MaxTimeTests.cs
@@ -46,7 +46,7 @@ namespace NUnit.Framework.Attributes
         {
             ITestResult suiteResult = TestBuilder.RunTestFixture(typeof(MaxTimeFixture));
             Assert.AreEqual(ResultState.ChildFailure, suiteResult.ResultState);
-            ITestResult result = suiteResult.Children[0];
+            ITestResult result = suiteResult.Children.ToArray()[0];
             Assert.That(result.Message, Does.Contain("exceeds maximum of 1ms"));
         }
 
@@ -55,7 +55,7 @@ namespace NUnit.Framework.Attributes
         {
             ITestResult suiteResult = TestBuilder.RunTestFixture(typeof(MaxTimeFixtureWithTestCase));
             Assert.AreEqual(ResultState.ChildFailure, suiteResult.ResultState);
-            ITestResult result = suiteResult.Children[0].Children[0];
+            ITestResult result = suiteResult.Children.ToArray()[0].Children.ToArray()[0];
             Assert.That(result.Message, Does.Contain("exceeds maximum of 1ms"));
         }
 
@@ -72,7 +72,7 @@ namespace NUnit.Framework.Attributes
         {
             ITestResult result = TestBuilder.RunTestFixture(typeof(MaxTimeFixtureWithFailure));
             Assert.AreEqual(ResultState.ChildFailure, result.ResultState);
-            result = (TestResult)result.Children[0];
+            result = (TestResult)result.Children.ToArray()[0];
             Assert.AreEqual(ResultState.Failure, result.ResultState);
             Assert.That(result.Message, Is.EqualTo("Intentional Failure"));
         }
@@ -82,7 +82,7 @@ namespace NUnit.Framework.Attributes
         {
             ITestResult result = TestBuilder.RunTestFixture(typeof(MaxTimeFixtureWithError));
             Assert.AreEqual(ResultState.ChildFailure, result.ResultState);
-            result = result.Children[0];
+            result = result.Children.ToArray()[0];
             Assert.AreEqual(ResultState.Error, result.ResultState);
             Assert.That(result.Message, Does.Contain("Exception message"));
         }
diff --git a/src/NUnitFramework/tests/Attributes/SingleThreadedFixtureTests.cs b/src/NUnitFramework/tests/Attributes/SingleThreadedFixtureTests.cs
index 7f6d7f316..296bcd191 100644
--- a/src/NUnitFramework/tests/Attributes/SingleThreadedFixtureTests.cs
+++ b/src/NUnitFramework/tests/Attributes/SingleThreadedFixtureTests.cs
@@ -94,10 +94,10 @@ namespace NUnit.Framework.Attributes
         {
             var result = TestBuilder.RunTestFixture(typeof(TFixture));
             Assert.That(result.ResultState, Is.EqualTo(ResultState.Failure.WithSite(FailureSite.Child)));
-            Assert.That(result.Children[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
+            Assert.That(result.Children.ToArray()[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
 
             foreach (string reason in reasons)
-                Assert.That(result.Children[0].Message, Does.Contain(reason));
+                Assert.That(result.Children.ToArray()[0].Message, Does.Contain(reason));
         }
     }
 
diff --git a/src/NUnitFramework/tests/Attributes/TestCaseSourceTests.cs b/src/NUnitFramework/tests/Attributes/TestCaseSourceTests.cs
index debe7c84b..047bc4c9c 100644
--- a/src/NUnitFramework/tests/Attributes/TestCaseSourceTests.cs
+++ b/src/NUnitFramework/tests/Attributes/TestCaseSourceTests.cs
@@ -60,7 +60,7 @@ namespace NUnit.Framework.Attributes
         public void SourceUsingInstancePropertyIsNotRunnable()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(typeof(TestCaseSourceAttributeFixture), "MethodWithInstancePropertyAsSource");
-            Assert.AreEqual(result.Children[0].ResultState, ResultState.NotRunnable);
+            Assert.AreEqual(result.Children.ToArray()[0].ResultState, ResultState.NotRunnable);
         }
 
         [Test, TestCaseSource("StaticMethod")]
@@ -78,7 +78,7 @@ namespace NUnit.Framework.Attributes
         public void SourceUsingInstanceMethodIsNotRunnable()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(typeof(TestCaseSourceAttributeFixture), "MethodWithInstanceMethodAsSource");
-            Assert.AreEqual(result.Children[0].ResultState, ResultState.NotRunnable);
+            Assert.AreEqual(result.Children.ToArray()[0].ResultState, ResultState.NotRunnable);
         }
 
         IEnumerable InstanceMethod()
@@ -99,7 +99,7 @@ namespace NUnit.Framework.Attributes
         public void SourceUsingInstanceFieldIsNotRunnable()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(typeof(TestCaseSourceAttributeFixture), "MethodWithInstanceFieldAsSource");
-            Assert.AreEqual(result.Children[0].ResultState, ResultState.NotRunnable);
+            Assert.AreEqual(result.Children.ToArray()[0].ResultState, ResultState.NotRunnable);
         }
 
         #endregion
@@ -232,8 +232,8 @@ namespace NUnit.Framework.Attributes
         [Test]
         public void IgnoreTakesPrecedenceOverExpectedException()
         {
-            ITestResult result = TestBuilder.RunParameterizedMethodSuite(
-                typeof(TestCaseSourceAttributeFixture), "MethodCallsIgnore").Children[0];
+            var result = TestBuilder.RunParameterizedMethodSuite(
+                typeof(TestCaseSourceAttributeFixture), "MethodCallsIgnore").Children.ToArray()[0];
             Assert.AreEqual(ResultState.Ignored, result.ResultState);
             Assert.AreEqual("Ignore this", result.Message);
         }
diff --git a/src/NUnitFramework/tests/Attributes/TimeoutTests.cs b/src/NUnitFramework/tests/Attributes/TimeoutTests.cs
index c61b0d031..43e00e8e9 100644
--- a/src/NUnitFramework/tests/Attributes/TimeoutTests.cs
+++ b/src/NUnitFramework/tests/Attributes/TimeoutTests.cs
@@ -130,8 +130,8 @@ namespace NUnit.Framework.Attributes
             ParameterizedMethodSuite testMethod = (ParameterizedMethodSuite)TestFinder.Find("TestTimeOutTestCase", suite, false);
             ITestResult result = TestBuilder.RunTest(testMethod, fixture);
             Assert.That(result.ResultState, Is.EqualTo(ResultState.Failure), "Suite result");
-            Assert.That(result.Children[0].ResultState, Is.EqualTo(ResultState.Success), "First test");
-            Assert.That(result.Children[1].ResultState, Is.EqualTo(ResultState.Failure), "Second test");
+            Assert.That(result.Children.ToArray()[0].ResultState, Is.EqualTo(ResultState.Success), "First test");
+            Assert.That(result.Children.ToArray()[1].ResultState, Is.EqualTo(ResultState.Failure), "Second test");
         }
     }
 }
diff --git a/src/NUnitFramework/tests/Attributes/ValueSourceTests.cs b/src/NUnitFramework/tests/Attributes/ValueSourceTests.cs
index 5f5772559..0297fcd9f 100644
--- a/src/NUnitFramework/tests/Attributes/ValueSourceTests.cs
+++ b/src/NUnitFramework/tests/Attributes/ValueSourceTests.cs
@@ -62,7 +62,7 @@ namespace NUnit.Framework.Attributes
         public void ValueSourceMayNotBeInstanceProperty()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(GetType(), "MethodWithValueSourceInstanceProperty");
-            Assert.That(result.Children[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
+            Assert.That(result.Children.ToArray()[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
         }
 
         public void MethodWithValueSourceInstanceProperty(
@@ -92,7 +92,7 @@ namespace NUnit.Framework.Attributes
         public void ValueSourceMayNotBeInstanceMethod()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(GetType(), "MethodWithValueSourceInstanceMethod");
-            Assert.That(result.Children[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
+            Assert.That(result.Children.ToArray()[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
         }
 
         public void MethodWithValueSourceInstanceMethod(
@@ -119,7 +119,7 @@ namespace NUnit.Framework.Attributes
         public void ValueSourceMayNotBeInstanceField()
         {
             var result = TestBuilder.RunParameterizedMethodSuite(GetType(), "MethodWithValueSourceInstanceField");
-            Assert.That(result.Children[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
+            Assert.That(result.Children.ToArray ()[0].ResultState, Is.EqualTo(ResultState.NotRunnable));
         }
 
         public void MethodWithValueSourceInstanceField(
diff --git a/src/NUnitFramework/tests/Internal/GenericTestMethodTests.cs b/src/NUnitFramework/tests/Internal/GenericTestMethodTests.cs
index b9a375a3e..36c8c9137 100644
--- a/src/NUnitFramework/tests/Internal/GenericTestMethodTests.cs
+++ b/src/NUnitFramework/tests/Internal/GenericTestMethodTests.cs
@@ -52,7 +52,7 @@ namespace NUnit.Framework.Internal
 
             int invalid = 0;
             // Examine grandchildren - child is parameterized method suite
-            var suiteResult = result.Children[0];
+            var suiteResult = result.Children.ToArray()[0];
             foreach (var childResult in suiteResult.Children)
                 if (childResult.ResultState == ResultState.NotRunnable)
                     invalid++;
@@ -99,7 +99,7 @@ namespace NUnit.Framework.Internal
 
             int invalid = 0;
             // Examine grandchildren - child is parameterized method suite
-            var suiteResult = result.Children[0];
+            var suiteResult = result.Children.ToArray()[0];
             foreach (var childResult in suiteResult.Children)
                 if (childResult.ResultState == ResultState.NotRunnable)
                     invalid++;
@@ -142,7 +142,7 @@ namespace NUnit.Framework.Internal
 
             int invalid = 0;
             // Examine grandchildren - child is parameterized method suite
-            var suiteResult = result.Children[0];
+            var suiteResult = result.Children.ToArray()[0];
             foreach (var childResult in suiteResult.Children)
                 if (childResult.ResultState == ResultState.NotRunnable)
                     invalid++;
diff --git a/src/NUnitFramework/tests/Internal/SetUpTearDownTests.cs b/src/NUnitFramework/tests/Internal/SetUpTearDownTests.cs
index 880be5ab4..7627428dd 100644
--- a/src/NUnitFramework/tests/Internal/SetUpTearDownTests.cs
+++ b/src/NUnitFramework/tests/Internal/SetUpTearDownTests.cs
@@ -122,7 +122,7 @@ namespace NUnit.Framework.Internal
             fixture.setupException = e;
             ITestResult suiteResult = TestBuilder.RunTestFixture(fixture);
             Assert.IsTrue(suiteResult.HasChildren, "Fixture test should have child result.");
-            TestResult result = (TestResult)suiteResult.Children[0];
+            TestResult result = (TestResult)suiteResult.Children.ToArray()[0];
             Assert.AreEqual(ResultState.Error, result.ResultState, "Test should be in error state");
             string expected = string.Format("{0} : {1}", e.GetType().FullName, e.Message);
             Assert.AreEqual(expected, result.Message);
@@ -137,7 +137,7 @@ namespace NUnit.Framework.Internal
             fixture.tearDownException = e;
             ITestResult suiteResult = TestBuilder.RunTestFixture(fixture);
             Assert.That(suiteResult.HasChildren, "Fixture test should have child result.");
-            ITestResult result = suiteResult.Children[0];
+            ITestResult result = suiteResult.Children.ToArray()[0];
             Assert.AreEqual(ResultState.Error, result.ResultState, "Test should be in error state");
             string expected = string.Format("TearDown : {0} : {1}", e.GetType().FullName, e.Message);
             Assert.AreEqual(expected, result.Message);
@@ -155,7 +155,7 @@ namespace NUnit.Framework.Internal
             fixture.tearDownException = e2;
             ITestResult suiteResult = TestBuilder.RunTestFixture(fixture);
             Assert.That(suiteResult.HasChildren, "Fixture test should have child result.");
-            ITestResult result = suiteResult.Children[0];
+            ITestResult result = suiteResult.Children.ToArray()[0];
             Assert.AreEqual(ResultState.Error, result.ResultState, "Test should be in error state");
             string expected = string.Format("{0} : {1}", e1.GetType().FullName, e1.Message) + Env.NewLine
                 + string.Format("TearDown : {0} : {1}", e2.GetType().FullName, e2.Message);
diff --git a/src/NUnitFramework/tests/TestUtilities/TestAssert.cs b/src/NUnitFramework/tests/TestUtilities/TestAssert.cs
index f9ec6c2f0..65ff768ed 100644
--- a/src/NUnitFramework/tests/TestUtilities/TestAssert.cs
+++ b/src/NUnitFramework/tests/TestUtilities/TestAssert.cs
@@ -57,7 +57,7 @@ namespace NUnit.TestUtilities
             object testObject = Reflect.Construct(type);
             ITestResult result = TestBuilder.RunTest(test, testObject);
             if (result.HasChildren) // In case it's a parameterized method
-                result = result.Children[0];
+                result = result.Children.ToArray()[0];
             Assert.That(result.ResultState, Is.EqualTo(resultState));
         }
         #endregion
