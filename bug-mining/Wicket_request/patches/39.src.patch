diff --git a/wicket-request/src/main/java/org/apache/wicket/request/HeaderCollection.java b/wicket-request/src/main/java/org/apache/wicket/request/HeaderCollection.java
deleted file mode 100644
index 7904af5047..0000000000
--- a/wicket-request/src/main/java/org/apache/wicket/request/HeaderCollection.java
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.wicket.request;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.wicket.util.lang.Args;
-
-/**
- * a multivalue map of headers names and header values suitable for 
- * processing request and response headers.
- *
- * @author Peter Ertl
- *
- * @since 1.5
- */
-public class HeaderCollection implements Iterable<HeaderCollection.Entry>
-{
-	private static final String[] NO_VALUES = new String[0];
-
-	private final Map<String, List<String>> headers;
-
-	public HeaderCollection()
-	{
-		headers = new HashMap<String, List<String>>();
-	}
-
-	/**
-	 * add header value
-	 *
-	 * @param name
-	 *          header name
-	 * @param value
-	 *          header value
-	 */
-	public void addHeader(String name, String value)
-	{
-		// be lenient and strip leading / trailing blanks
-		name = Args.notEmpty(name, "name").trim();
-		value = Args.notEmpty(value, "value").trim();
-
-		List<String> values = headers.get(name);
-
-		if (values == null)
-		{
-			values = new ArrayList<String>();
-			headers.put(name, values);
-		}
-		values.add(value);
-	}
-
-	/**
-	 * remove header values for header name
-	 *
-	 * @param name
-	 *          header name
-	 */
-	public void removeHeaderValues(String name)
-	{
-		name = Args.notEmpty(name, "name").trim();
-
-		final Iterator<Map.Entry<String, List<String>>> it = headers.entrySet().iterator();
-
-		while (it.hasNext())
-		{
-			Map.Entry<String, List<String>> header = it.next();
-
-			if (header.getKey().equalsIgnoreCase(name))
-			{
-				it.remove();
-			}
-		}
-	}
-
-	/**
-	 * get header values
-	 *
-	 *
-	 *
-	 * @param name
-	 *          header name
-	 *
-	 * @return header value or <code>null</code> if not found
-	 */
-	public String[] getValues(String name)
-	{
-		Args.notEmpty(name, "name");
-
-		// get the header value (case might differ)
-		for (Map.Entry<String, List<String>> header : headers.entrySet())
-		{
-			if (header.getKey().equalsIgnoreCase(name))
-			{
-				return header.getValue().toArray(new String[header.getValue().size()]);
-			}
-		}
-		return NO_VALUES;
-	}
-
-	/**
-	 * get iterator over header values
-	 *
-	 * @return iterator
-	 */
-	public Iterator<Entry> iterator()
-	{
-		final Iterator<Map.Entry<String,List<String>>> iterator = headers.entrySet().iterator();
-
-		return new Iterator<Entry>()
-		{
-			public boolean hasNext()
-			{
-				return iterator.hasNext();
-			}
-
-			public Entry next()
-			{
-				return new Entry(iterator.next());
-			}
-
-			public void remove()
-			{
-				throw new UnsupportedOperationException();
-			}
-		};
-	}
-
-	/**
-	 * check if collection is empty
-	 * 
-	 * @return <code>true</code> if collection is empty, <code>false</code> otherwise
-	 */
-	public boolean isEmpty()
-	{
-		return headers.isEmpty();
-	}
-
-	/**
-	 * get number of headers
-	 * 
-	 * @return count
-	 */
-	public int getCount()
-	{
-		return headers.size();
-	}
-
-	/**
-	 * read-only header entry
-	 */
-	public static class Entry
-	{
-		private final Map.Entry<String, List<String>> header;
-
-		public Entry(Map.Entry<String, List<String>> header)
-		{
-			this.header = header;
-		}
-
-		public String getName()
-		{
-			return header.getKey();
-		}
-
-		public String[] getValues()
-		{
-			return header.getValue().toArray(new String[header.getValue().size()]);
-		}
-	}
-}
diff --git a/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java
new file mode 100644
index 0000000000..ef96dc3c94
--- /dev/null
+++ b/wicket-request/src/main/java/org/apache/wicket/request/HttpHeaderCollection.java
@@ -0,0 +1,360 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.request;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.TimeZone;
+
+import org.apache.wicket.util.lang.Args;
+import org.apache.wicket.util.time.Time;
+
+/**
+ * a multivalue map of headers names and header values suitable for 
+ * processing http request and response headers.
+ *
+ * @author Peter Ertl
+ *
+ * @since 1.5
+ */
+public class HttpHeaderCollection
+{
+	private final Map<HeaderKey, List<Object>> headers;
+
+	/** Greenwich Mean Time (GMT) timezone */
+	private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
+	/** rfc 1123 compliant time stamp for headers */
+	private static final String RFC_1123_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz";
+
+	/** date format for date headers */
+	public static final DateFormat DATE_FORMAT;
+	
+	/** returned in case no header values were found */
+	private static final String[] NO_VALUES = new String[0];
+
+	static
+	{
+		DATE_FORMAT = new SimpleDateFormat(RFC_1123_DATE_FORMAT, Locale.US);
+		DATE_FORMAT.setTimeZone(GMT);
+	}
+
+	public HttpHeaderCollection()
+	{
+		headers = new HashMap<HeaderKey, List<Object>>();
+	}
+
+	/**
+	 * internally add new object to header values
+	 *
+	 * @param name
+	 *          header name
+	 * @param object
+	 *          header value (can be a string or a {@link Time} object
+	 */
+	private void internalAdd(String name, Object object)
+	{
+		final HeaderKey key = new HeaderKey(name);
+
+		List<Object> values = headers.get(key);
+
+		if (values == null)
+		{
+			values = new ArrayList<Object>();
+			headers.put(key, values);
+		}
+		values.add(object);
+	}
+
+	/**
+	 * set header value (and remove previous values)
+	 *
+	 * @param name
+	 *          header name
+	 * @param value
+	 *          header value
+	 */
+	public void setHeader(String name, String value)
+	{
+		// remove previous values
+		removeHeader(name);
+
+		// add new values
+		addHeader(name, value);
+	}
+
+	/**
+	 * add header value
+	 *
+	 * @param name
+	 *          header name
+	 * @param value
+	 *          header value
+	 */
+	public void addHeader(String name, String value)
+	{
+		// be lenient and strip leading / trailing blanks
+		value = Args.notEmpty(value, "value").trim();
+
+		internalAdd(name, value);
+	}
+
+	/**
+	 * add date header value
+	 *
+	 * @param name
+	 *          header name
+	 * @param time
+	 *          timestamp
+	 */
+	public void addDateHeader(String name, Time time)
+	{
+		internalAdd(name, time);
+	}
+
+	/**
+	 * add date header value
+	 *
+	 * @param name
+	 *          header name
+	 * @param time
+	 *          timestamp
+	 */
+	public void setDateHeader(String name, Time time)
+	{
+		// remove previous values
+		removeHeader(name);
+
+		// add time object to values
+		addDateHeader(name, time);
+	}
+
+	/**
+	 * remove header values for header name
+	 *
+	 * @param name
+	 *          header name
+	 */
+	public void removeHeader(String name)
+	{
+		final HeaderKey key = new HeaderKey(name);
+		final Iterator<Map.Entry<HeaderKey, List<Object>>> it = headers.entrySet().iterator();
+
+		while (it.hasNext())
+		{
+			final Map.Entry<HeaderKey, List<Object>> header = it.next();
+
+			if (header.getKey().equals(key))
+			{
+				it.remove();
+			}
+		}
+	}
+
+	private String valueToString(Object value)
+	{
+		if (value instanceof Time)
+		{
+			synchronized(DATE_FORMAT)
+			{
+				return DATE_FORMAT.format(new Date(((Time)value).getMilliseconds()));
+			}
+		}
+		else
+		{
+			return value.toString();
+		}
+	}
+
+	/**
+	 * check if header is defined
+	 *
+	 * @param name
+	 *        header name
+	 * @return <code>true</code> if header has one or more values
+	 */
+	public boolean containsHeader(String name)
+	{
+		final HeaderKey searchKey = new HeaderKey(name);
+
+		// get the header value (case might differ)
+		for (HeaderKey key : headers.keySet())
+		{
+			if (key.equals(searchKey))
+			{
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * returns names of headers
+	 *
+	 * @return set of header names
+	 */
+	public Set<String> getHeaderNames()
+	{
+		if (headers.isEmpty())
+		{
+			return Collections.emptySet();
+		}
+
+		final Set<String> names = new HashSet<String>(headers.size());
+
+		for (HeaderKey key : headers.keySet())
+		{
+			names.add(key.getName());
+		}
+		return names;
+	}
+
+	/**
+	 * get header values (dates will be converted into strings)
+	 *
+	 * @param name
+	 *          header name
+	 *
+	 * @return array of header values or empty array if not found
+	 */
+	public String[] getHeaderValues(String name)
+	{
+		final List<Object> objects = headers.get(new HeaderKey(name));
+
+		if (objects == null)
+		{
+			return NO_VALUES;
+		}
+
+		final String[] values = new String[objects.size()];
+
+		for (int i = 0; i < values.length; i++)
+		{
+			values[i] = valueToString(objects.get(i));
+		}
+		return values;
+	}
+
+	public String getHeader(String name)
+	{
+		final List<Object> objects = headers.get(new HeaderKey(name));
+
+		if (objects.isEmpty())
+		{
+			return null;
+		}
+		return valueToString(objects.get(0));
+	}
+
+	public Time getDateHeader(String name)
+	{
+		final List<Object> objects = headers.get(new HeaderKey(name));
+
+		if (objects.isEmpty())
+		{
+			return null;
+		}
+		Object object = objects.get(0);
+
+		if ((object instanceof Time) == false)
+		{
+			throw new IllegalStateException("header value is not of type date");
+		}
+		return (Time)object;
+	}
+
+	/**
+	 * check if collection is empty
+	 *
+	 * @return <code>true</code> if collection is empty, <code>false</code> otherwise
+	 */
+	public boolean isEmpty()
+	{
+		return headers.isEmpty();
+	}
+
+	/**
+	 * get number of headers
+	 *
+	 * @return count
+	 */
+	public int getCount()
+	{
+		return headers.size();
+	}
+
+	/**
+	 * clear all headers
+	 */
+	public void clear()
+	{
+		headers.clear();
+	}
+
+	/**
+	 * key for header collection
+	 */
+	private static class HeaderKey
+	{
+		private final String key;
+		private final String name;
+
+		private HeaderKey(String name)
+		{
+			this.name = Args.notEmpty(name, "name").trim();
+			this.key = this.name.toLowerCase(Locale.US);
+		}
+
+		public String getName()
+		{
+			return name;
+		}
+
+		@Override
+		public boolean equals(Object o)
+		{
+			if (this == o)
+				return true;
+
+			if (!(o instanceof HeaderKey))
+				return false;
+
+			HeaderKey that = (HeaderKey)o;
+
+			if (!key.equals(that.key))
+				return false;
+
+			return true;
+		}
+
+		@Override
+		public int hashCode()
+		{
+			return key.hashCode();
+		}
+	}
+}
diff --git a/wicket-request/src/main/java/org/apache/wicket/request/http/WebResponse.java b/wicket-request/src/main/java/org/apache/wicket/request/http/WebResponse.java
index 12be1f4c0e..f339c14d6d 100644
--- a/wicket-request/src/main/java/org/apache/wicket/request/http/WebResponse.java
+++ b/wicket-request/src/main/java/org/apache/wicket/request/http/WebResponse.java
@@ -61,6 +61,14 @@ public abstract class WebResponse extends Response
 	 */
 	public abstract void setHeader(String name, String value);
 
+	/**
+	 * Add a value to the servlet response stream.
+	 * 
+	 * @param name
+	 * @param value
+	 */
+	public abstract void addHeader(String name, String value);
+	
 	/**
 	 * Set a header to the date value in the servlet response stream.
 	 * 
@@ -109,7 +117,7 @@ public abstract class WebResponse extends Response
 	public void setAttachmentHeader(final String filename)
 	{
 		setHeader("Content-Disposition", "attachment" +
-			((!Strings.isEmpty(filename)) ? ("; filename=\"" + filename + "\"") : ""));
+		                                 ((!Strings.isEmpty(filename))? ("; filename=\"" + filename + "\"") : ""));
 	}
 
 	/**
@@ -206,7 +214,8 @@ public abstract class WebResponse extends Response
 		setDateHeader("Expires", now.add(duration));
 
 		// Enable caching and set max age
-		setHeader("Cache-Control", scope.cacheControl + ", max-age=" + duration.getMilliseconds());
+		setHeader("Cache-Control", scope.cacheControl);
+		addHeader("Cache-Control", "max-age=" + duration.getMilliseconds());
 	}
 
 	/**
diff --git a/wicket-request/src/test/java/org/apache/wicket/request/HeadersCollectionTest.java b/wicket-request/src/test/java/org/apache/wicket/request/HeadersCollectionTest.java
index b3e6268d80..9e3b66fbce 100644
--- a/wicket-request/src/test/java/org/apache/wicket/request/HeadersCollectionTest.java
+++ b/wicket-request/src/test/java/org/apache/wicket/request/HeadersCollectionTest.java
@@ -16,6 +16,10 @@
  */
 package org.apache.wicket.request;
 
+import java.util.Locale;
+import java.util.Set;
+
+import org.apache.wicket.util.time.Time;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
@@ -25,25 +29,83 @@ public class HeadersCollectionTest
 	@Test
 	public void testHeaderCollection()
 	{
-		HeaderCollection headers = new HeaderCollection();
+		HttpHeaderCollection headers = new HttpHeaderCollection();
 		assertTrue(headers.isEmpty());
 
 		headers.addHeader("X-Test", "foo");
 		headers.addHeader("X-Test", "bar");
-		assertArrayEquals(new String[]{"foo", "bar"}, headers.getValues("X-Test"));
+		assertArrayEquals(new String[]{"foo", "bar"}, headers.getHeaderValues("X-Test"));
 
-		headers.removeHeaderValues("x-test");
+		headers.removeHeader("x-test");
 		assertTrue(headers.isEmpty());
 
 		headers.addHeader("   X-Image    ", "    jpeg     ");
 		headers.addHeader("X-Image    ", "    gif     ");
-		assertArrayEquals(new String[]{"jpeg", "gif"}, headers.getValues("X-IMAGE"));
+		assertArrayEquals(new String[]{"jpeg", "gif"}, headers.getHeaderValues("X-IMAGE"));
 		assertEquals(1, headers.getCount());
 
 		headers.addHeader("X-Test", "123");
 		assertEquals(2, headers.getCount());
 
-		headers.removeHeaderValues(" x-tesT ");
+		headers.removeHeader(" x-tesT ");
 		assertEquals(1, headers.getCount());
 	}
+
+	@Test
+	public void getHeaderNames()
+	{
+		final HttpHeaderCollection headers = new HttpHeaderCollection();
+
+		headers.addHeader("key1", "a");
+		headers.addHeader("Key1", "b");
+		headers.addHeader("key2", "c");
+
+		Set<String> names = headers.getHeaderNames();
+		assertTrue(names.contains("key1"));
+		assertFalse(names.contains("Key1"));
+		assertTrue(names.contains("key2"));
+	}
+
+	@Test
+	public void dateValues()
+	{
+		final HttpHeaderCollection headers = new HttpHeaderCollection();
+
+		final Time time1 = Time.millis(1000000);
+		final Time time2 = Time.millis(2000000);
+
+		headers.setDateHeader("date", time1);
+		headers.addDateHeader("date", time2);
+		headers.addHeader("date", "not-a-date");
+
+		assertEquals(time1, headers.getDateHeader("date"));
+		assertEquals("Thu, 01 Jan 1970 00:16:40 GMT", headers.getHeader("date"));
+
+		// a change of the locale must not affect the date format
+		final Locale defaultLocale = Locale.getDefault();
+
+		try
+		{
+			Locale.setDefault(Locale.CHINESE);
+			assertEquals("Thu, 01 Jan 1970 00:16:40 GMT", headers.getHeader("date"));
+		}
+		finally
+		{
+			Locale.setDefault(defaultLocale);
+		}
+
+		assertArrayEquals(new String[]{"Thu, 01 Jan 1970 00:16:40 GMT", "Thu, 01 Jan 1970 00:33:20 GMT", "not-a-date"},
+		                  headers.getHeaderValues("date"));
+		
+		headers.setHeader("date", "foobar");
+		try
+		{
+			Time date = headers.getDateHeader("date");
+			fail();
+		}
+		catch (IllegalStateException e)
+		{
+			// ok
+		}
+	}
 }
