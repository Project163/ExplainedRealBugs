diff --git a/_examples/limits/main.go b/_examples/limits/main.go
index db0369d..b4449a5 100644
--- a/_examples/limits/main.go
+++ b/_examples/limits/main.go
@@ -1,16 +1,12 @@
 //
 // Limits
 // ======
-// This example demonstrates the use of Timeout, CloseNotify, and
-// Throttle middlewares.
+// This example demonstrates the use of Timeout, and Throttle middlewares.
 //
 // Timeout:
 //   cancel a request if processing takes longer than 2.5 seconds,
 //   server will respond with a http.StatusGatewayTimeout.
 //
-// CloseNotify:
-//   cancel a request if the client disconnects.
-//
 // Throttle:
 //   limit the number of in-flight requests along a particular
 //   routing path and backlog the others.
@@ -49,9 +45,6 @@ func main() {
 
 	// Slow handlers/operations.
 	r.Group(func(r chi.Router) {
-		// Stop processing when client disconnects.
-		r.Use(middleware.CloseNotify)
-
 		// Stop processing after 2.5 seconds.
 		r.Use(middleware.Timeout(2500 * time.Millisecond))
 
diff --git a/_examples/router-walk/main.go b/_examples/router-walk/main.go
index 0826aa0..fcaa6bb 100644
--- a/_examples/router-walk/main.go
+++ b/_examples/router-walk/main.go
@@ -3,6 +3,7 @@ package main
 import (
 	"fmt"
 	"net/http"
+	"strings"
 
 	"github.com/go-chi/chi"
 )
@@ -25,6 +26,7 @@ func main() {
 	r.Put("/ping", Ping)
 
 	walkFunc := func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {
+		route = strings.Replace(route, "/*/", "/", -1)
 		fmt.Printf("%s %s\n", method, route)
 		return nil
 	}
diff --git a/middleware/compress.go b/middleware/compress.go
index ee90aa3..0eee0fb 100644
--- a/middleware/compress.go
+++ b/middleware/compress.go
@@ -243,19 +243,6 @@ func (w *maybeCompressResponseWriter) Push(target string, opts *http.PushOptions
 	return errors.New("chi/middleware: http.Pusher is unavailable on the writer")
 }
 
-func (w *maybeCompressResponseWriter) CloseNotify() <-chan bool {
-	if cn, ok := w.w.(http.CloseNotifier); ok {
-		return cn.CloseNotify()
-	}
-
-	// If the underlying writer does not implement http.CloseNotifier, return
-	// a channel that never receives a value. The semantics here is that the
-	// client never disconnnects before the request is processed by the
-	// http.Handler, which is close enough to the default behavior (when
-	// CloseNotify() is not even called).
-	return make(chan bool, 1)
-}
-
 func (w *maybeCompressResponseWriter) Close() error {
 	if c, ok := w.w.(io.WriteCloser); ok {
 		return c.Close()
diff --git a/middleware/middleware_test.go b/middleware/middleware_test.go
index d1e8740..4035f4a 100644
--- a/middleware/middleware_test.go
+++ b/middleware/middleware_test.go
@@ -28,10 +28,6 @@ func init() {
 
 func TestWrapWriterHTTP2(t *testing.T) {
 	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		_, cn := w.(http.CloseNotifier)
-		if !cn {
-			t.Fatal("request should have been a http.CloseNotifier")
-		}
 		_, fl := w.(http.Flusher)
 		if !fl {
 			t.Fatal("request should have been a http.Flusher")
diff --git a/middleware/wrap_writer.go b/middleware/wrap_writer.go
index b9d5e86..5e5594f 100644
--- a/middleware/wrap_writer.go
+++ b/middleware/wrap_writer.go
@@ -13,20 +13,19 @@ import (
 // NewWrapResponseWriter wraps an http.ResponseWriter, returning a proxy that allows you to
 // hook into various parts of the response process.
 func NewWrapResponseWriter(w http.ResponseWriter, protoMajor int) WrapResponseWriter {
-	_, cn := w.(http.CloseNotifier)
 	_, fl := w.(http.Flusher)
 
 	bw := basicWriter{ResponseWriter: w}
 
 	if protoMajor == 2 {
 		_, ps := w.(http.Pusher)
-		if cn && fl && ps {
+		if fl && ps {
 			return &http2FancyWriter{bw}
 		}
 	} else {
 		_, hj := w.(http.Hijacker)
 		_, rf := w.(io.ReaderFrom)
-		if cn && fl && hj && rf {
+		if fl && hj && rf {
 			return &httpFancyWriter{bw}
 		}
 	}
@@ -124,7 +123,7 @@ func (f *flushWriter) Flush() {
 
 var _ http.Flusher = &flushWriter{}
 
-// httpFancyWriter is a HTTP writer that additionally satisfies http.CloseNotifier,
+// httpFancyWriter is a HTTP writer that additionally satisfies
 // http.Flusher, http.Hijacker, and io.ReaderFrom. It exists for the common case
 // of wrapping the http.ResponseWriter that package http gives you, in order to
 // make the proxied object support the full method set of the proxied object.
@@ -132,11 +131,6 @@ type httpFancyWriter struct {
 	basicWriter
 }
 
-func (f *httpFancyWriter) CloseNotify() <-chan bool {
-	cn := f.basicWriter.ResponseWriter.(http.CloseNotifier)
-	return cn.CloseNotify()
-}
-
 func (f *httpFancyWriter) Flush() {
 	f.wroteHeader = true
 
@@ -166,13 +160,12 @@ func (f *httpFancyWriter) ReadFrom(r io.Reader) (int64, error) {
 	return n, err
 }
 
-var _ http.CloseNotifier = &httpFancyWriter{}
 var _ http.Flusher = &httpFancyWriter{}
 var _ http.Hijacker = &httpFancyWriter{}
 var _ http.Pusher = &http2FancyWriter{}
 var _ io.ReaderFrom = &httpFancyWriter{}
 
-// http2FancyWriter is a HTTP2 writer that additionally satisfies http.CloseNotifier,
+// http2FancyWriter is a HTTP2 writer that additionally satisfies
 // http.Flusher, and io.ReaderFrom. It exists for the common case
 // of wrapping the http.ResponseWriter that package http gives you, in order to
 // make the proxied object support the full method set of the proxied object.
@@ -180,11 +173,6 @@ type http2FancyWriter struct {
 	basicWriter
 }
 
-func (f *http2FancyWriter) CloseNotify() <-chan bool {
-	cn := f.basicWriter.ResponseWriter.(http.CloseNotifier)
-	return cn.CloseNotify()
-}
-
 func (f *http2FancyWriter) Flush() {
 	f.wroteHeader = true
 
@@ -192,5 +180,4 @@ func (f *http2FancyWriter) Flush() {
 	fl.Flush()
 }
 
-var _ http.CloseNotifier = &http2FancyWriter{}
 var _ http.Flusher = &http2FancyWriter{}
