{"id":66,"status":"Accepted","summary":"x86_64 trouble with libunwind","labels":["Type-Defect","Priority-Low"],"stars":14,"commentCount":32,"comments":[{"id":0,"commenterId":-5676105695305143218,"content":"\r\nHaving read the INSTALL and README file, x86_64 seems to be difficult to\r\nget working in a stable manner.\r\n\r\nI tried all the libunwind, the -Wl,-fno-omit-frame-pointer,-leh_gcc, etc.\r\nflags but it reliably crashes whenever I want to use the CPU or heap profiler.\r\n\r\nGiven the increasing popularity of x86_64 users (especially those who are\r\nactually developers and require performance tuning of their applications),\r\ncan you please consider putting more effort into getting the x86_64\r\nusability to a higher level?\r\n\r\nThanks a lot!\r\n\r\n\r\n\r\n\u003cb\u003eWhat version of the product are you using? On what operating system?\u003c/b\u003e\n\r\nUbuntu 08.04 x86_64.\r\n\r\n","timestamp":1214820363,"attachments":[]},{"id":1,"commenterId":1451955930852924383,"content":"I\u0027m glad to see you read the INSTALL and README files; that\u0027s a common problem that\r\ntrips up folks trying to use x86_64 code.  The next step past that, I think, is to\r\ncreate a reproducible test case.  Can you attach a small program that, when compiled\r\nwith perftools, crashes when using the CPU or heap profiler?  Be sure to include the\r\ncompile commands you used, and the commands you used to actually run the profiler.\r\n\r\nIf that\u0027s not possible, at least try compiling perftools in debug mode (.;configure\r\nCXXLFAGS\u003d-g), and run your reliably-crashing binaries in gdb.  That will hopefully\r\ngive a usable stack trace, which may be helpful in figuring out where the code is\r\ncrashing, if not why.\r\n\r\nWe don\u0027t have access to a ubuntu 8 machine, but we do have access to quite a few\r\nx86_64 machines; hopefully we\u0027ll be able to reproduce whatever problems you\u0027re seeing\r\nand figure out what\u0027s going on.","timestamp":1214850323,"attachments":[]},{"id":2,"commenterId":-5676105695305143218,"content":"Thanks Craig, for the prompt feedback.\r\n\r\nHere is what I managed to reproduce.\r\n\r\nI use g++ 4.2.3 shipped with Ubuntu on x86_64.  I compile statically because the\r\nbinaries are regularly run on a set of older Debian x86_64 systems.  I downloaded and\r\ncompiled libunwind 0.99-alpha and google-perftools 0.98, and link with:\r\n\r\ng++ -static -o program program.o \\\r\n    -Wl,--eh-frame-hdr -lgcc_eh -L/opt/google-perftools-0.98/lib \\\r\n    -lprofiler -ltcmalloc -lpthread -L/opt/libunwind-0.99-alpha/lib -lunwind\r\n\r\nAlmost any other order of the libraries and options will not compile.  As mentioned\r\nin the README the libgcc_eh and libunwind contain the same methods.  If libgcc_eh is\r\nomitted, the following error results during linking:\r\n\r\n   /usr/lib/gcc/x86_64-linux-gnu/4.2.3/libgcc_eh.a(unwind-dw2.o): In function\r\n`_Unwind_Resume\u0027:\r\n   (.text+0x2240): multiple definition of `_Unwind_Resume\u0027\r\n  \r\n/opt/libunwind-0.99-alpha/lib/libunwind.a(Resume.o):/tmp/0/google-perftools-0.98/libunwind-0.99-alpha/src/unwind/Resume.c:30:\r\nfirst defined here\r\n\r\nIf compiled with the original line the programs runs perfectly, however CPUPROFILE\r\nand HEAPPROFILE have no effect and no output profile is created (or error message on\r\nthe console).\r\n\r\nThis noon I had another situation which I cannot reproduce anymore, sorry. \r\nUnfortunately I tried perftools during restructuring my Makefiles, definitely not a\r\ngood time.  Without testcase its not of much help, but the behaviour was as follows:\r\nit linked and ran perfectly, but when CPUPROFILE has been added it runs for only a\r\nsecond and then crashes with SIGSEGV, likewise with HEAPPROFILE.  The profile files\r\nexisted but were zero-sized.  I will continue to try to reproduce this, but have not\r\nbeen able to in the last 15 minutes.\r\n\r\nSorry if my original filed issue sounded harsh.  It just seems very difficult to get\r\nperftools to work at all with static binaries on x86_64.","timestamp":1214856299,"attachments":[]},{"id":3,"commenterId":1451955930852924383,"content":"Hmm, it\u0027s true we don\u0027t test much with -static, and -static has the capacity of\r\nmaking life difficult for us, because glibc does its initialization in a different\r\norder.  My guess, without testing, is that with -static, the environment doesn\u0027t get\r\nset properly before main(), so all the getenv() stuff we do in global constructors\r\nisn\u0027t working.  This would explain why the code runs but ignores CPUPROFILE and\r\nHEAPPROFILE.\r\n\r\nAha! -- looking at the code, I see that in fact we have a mechanism to work around\r\njust that problem, but don\u0027t seem to use it for CPUPROFILE and HEAPPROFILE.  We do\r\nuse it for leak-checking, though, so an easy way for you to test this theory is to\r\ntry running the heapchecker:\r\n   HEAPCHECK\u003dnormal ...\r\n\r\nIf that works (it should give some output at program exit), then this is the likely\r\ncause.  It should be easy to fix.  If not, let me know, and I\u0027ll investigate more\r\nthoroughly when I have time (which unfortunately may not be for a week or two).\r\n","timestamp":1214859056,"attachments":[]},{"id":4,"commenterId":1451955930852924383,"content":"Oh, another way to test the fix: try to apply the following patch (hopefully easy to\r\napply by hand if it doesn\u0027t work via \u0027patch\u0027).  This uses the more robust form of getenv.\r\n\r\n--cut here--\r\n\r\n--- /tmp/tmp.14922.1    2008-06-30 13:52:34.000000000 -0700                     \r\n+++ /home/csilvers/opensource/google-perftools/src/base/sysinfo.cc          \r\n@@ -152,7 +152,7 @@\r\n // still get a profile, but one with an unexpected name.\r\n // TODO(csilvers): set an envvar instead when we can do it reliably.\r\n bool GetUniquePathFromEnv(const char* env_name, char* path) {\r\n-  char* envval \u003d getenv(env_name);                                             \r\n+  char* envval \u003d GetenvBeforeMain(env_name);                                   \r\n   if (envval \u003d\u003d NULL || *envval \u003d\u003d \u0027\\0\u0027)\r\n     return false;\r\n   if (envval[0] \u0026 128) {                  // high bit is set\r\n","timestamp":1214859248,"attachments":[]},{"id":5,"commenterId":-5676105695305143218,"content":"I tried the HEAPCHECK\u003dnormal test and the heap checker seems not to be active: the\r\noutput is identical with what I get without setting HEAPCHECK.\r\n\r\nI will try the patch tomorrow.","timestamp":1214859577,"attachments":[]},{"id":6,"commenterId":1451955930852924383,"content":"Did the patch help at all?  You may need to add a const_cast to get it to compile\r\n(that should be fine in your case).  If so, I\u0027ll try to apply something like it.","timestamp":1216100692,"attachments":[]},{"id":7,"commenterId":-5676105695305143218,"content":"I applied the patch (after adding a const_cast), and compiled my program statically\r\nas follows on x86_64:\r\n\r\ng++-4.2 -static -Wall -Werror -std\u003dc++98 -O2 -march\u003dnative -msse -msse2 \\\r\n  -funroll-loops -fno-omit-frame-pointer \\\r\n  -I/opt/google-perftools-0.98-p/include -o extract extract.o \\\r\n  -Wl,--eh-frame-hdr -lgcc_eh -L/opt/google-perftools-0.98-p/lib \\\r\n  -lprofiler -ltcmalloc -lpthread -L/opt/libunwind-0.99-alpha/lib -lunwind\r\n\r\nThe result is that my program works as usual, but neither HEAPCHECK\u003dnormal nor\r\nCPUPROFILE\u003d/tmp/cpu works and there is no output on screen by the profiler.  It seems\r\nit is not called before program start at all.\r\n\r\nI checked all the unittests, and profiler_unittest.sh fails as follows (all other\r\ntests pass):\r\n   [...]\r\n   PROFILE: interrupts/evictions/bytes \u003d 29/0/2120\r\n   PROFILE: interrupts/evictions/bytes \u003d 28/0/2016\r\n   FORK test FAILED: expected 3 profiles (for main + 2 children), found 1\r\n   Tests finished with 1 failures\r\n\r\nI suspect its more about the link order used, as I had to experiment quite a lot with\r\nthe library link order just to get it to compile.\r\n\r\nIf I compile it as follows:\r\ng++-4.2 -static -Wall -Werror -std\u003dc++98 -O2 -march\u003dnative -msse -msse2 \\\r\n  -funroll-loops -fno-omit-frame-pointer -I/opt/google-perftools-0.98-p/include \\\r\n  -o extract extract.o \\\r\n  -L/opt/google-perftools-0.98-p/lib -lprofiler -ltcmalloc -lpthread \\\r\n  -L/opt/libunwind-0.99-alpha/lib -lunwind -Wl,--eh-frame-hdr\r\n\r\nit gives the following compile error\r\n  /usr/lib/gcc/x86_64-linux-gnu/4.2.3/libgcc_eh.a(unwind-dw2.o): In function\r\n`_Unwind_GetCFA\u0027:\r\n  (.text+0x70): multiple definition of `_Unwind_GetCFA\u0027\r\n \r\n/opt/libunwind-0.99-alpha/lib/libunwind.a(GetCFA.o):/tmp/0/google-perftools-0.98/libunwind-0.99-alpha/src/unwind/GetCFA.c:30:\r\nfirst defined here\r\n  /usr/lib/gcc/x86_64-linux-gnu/4.2.3/libgcc_eh.a(unwind-dw2.o): In function\r\n`_Unwind_Resume\u0027:\r\n  (.text+0x2240): multiple definition of `_Unwind_Resume\u0027\r\n \r\n/opt/libunwind-0.99-alpha/lib/libunwind.a(Resume.o):/tmp/0/google-perftools-0.98/libunwind-0.99-alpha/src/unwind/Resume.c:30:\r\nfirst defined here\r\n  /usr/lib/gcc/x86_64-linux-gnu/4.2.3/libgcc_eh.a(unwind-dw2.o): In function\r\n`_Unwind_ForcedUnwind\u0027:\r\n  (.text+0x2340): multiple definition of `_Unwind_ForcedUnwind\u0027\r\n \r\n/opt/libunwind-0.99-alpha/lib/libunwind.a(ForcedUnwind.o):/tmp/0/google-perftools-0.98/libunwind-0.99-alpha/src/unwind/ForcedUnwind.c:31:\r\nfirst defined here\r\n  collect2: ld returned 1 exit status\r\n\r\nDoes this information help?  Thanks for all the efforts.","timestamp":1216192998,"attachments":[]},{"id":8,"commenterId":-5676105695305143218,"content":"Addendum: I overlooked the other *.sh unittests, here are the results:\r\n\r\n$ ./heap-profiler_unittest.sh \r\nProfile not found: /tmp/heap_profile_info/test_*.0723.heap\r\n\r\n\r\n\r\n$ ./heap-checker-death_unittest.sh \r\nTesting ./heap-checker_unittest with HEAPCHECK\u003d ... PASS\r\nTesting ./heap-checker_unittest with HEAP_CHECKER_TEST_NO_THREADS\u003d1 ... FAIL\r\n[: 129: \u003d\u003d: unexpected operator\r\nWrong exit code: expected: \u00270\u0027; actual: 134\r\nOutput did not match \u0027^PASS$\u0027\r\nOutput from failed run:\r\n---\r\nWARNING: Heap leak checker is active -- Performance may suffer\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nAdding pthread-specifics for thread 140100123244288 pid 13655\r\nAdding pthread-specifics for thread 140100123244288 pid 13655\r\nIn main(): heap_check\u003dstrict\r\nHave memory regions w/o callers: might report false leaks\r\nNo leaks found for check \"_main_\" (but no 100% guarantee that there aren\u0027t any):\r\nfound 275 reachable heap objects of 28270 bytes\r\nHave memory regions w/o callers: might report false leaks\r\nHave memory regions w/o callers: might report false leaks\r\nHave memory regions w/o callers: might report false leaks\r\nNo leaks found for check \"trivial\" (but no 100% guarantee that there aren\u0027t any):\r\nfound 951 reachable heap objects of 52655 bytes\r\nHave memory regions w/o callers: might report false leaks\r\nHave memory regions w/o callers: might report false leaks\r\nNo leaks found for check \"simple\" (but no 100% guarantee that there aren\u0027t any):\r\nfound 951 reachable heap objects of 52654 bytes\r\n\r\nPre leaking : 0xf0b3837b ^ 0xf03a5f7b\r\n\r\nPre leaking : 0xf0b3b3fb ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b0547b ^ 0xf03a5f7b\r\n\r\nLeaking : 0xf0b2277b ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b3f17b ^ 0xf03a5f7b\r\n\r\nLeaking : 0xf0b042bb ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b27d5b ^ 0xf03a5f7b\r\n\r\nLeaking : 0xf0b27d6b ^ 0xf03a5f7b\r\n\r\nPre leaking : 0xf0b3837b ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b3f17b ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\nHave memory regions w/o callers: might report false leaks\r\nNo leaks found for check \"death_noleaks\" (but no 100% guarantee that there aren\u0027t\r\nany): found 951 reachable heap objects of 52661 bytes\r\n\r\nPre leaking : 0xf0b031db ^ 0xf03a5f7b\r\n\r\nPre leaking : 0xf0b032ab ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b3f17b ^ 0xf03a5f7b\r\n\r\nPre leaking : 0xf0b3f17b ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\n\r\nLeaking : 0xf0b032ab ^ 0xf03a5f7b\r\n\r\nLeaking : 0xf0b031db ^ 0xf03a5f7b\r\nHave memory regions w/o callers: might report false leaks\r\nThe pprof command failed: pprof\r\n--base\u003d\"/tmp/lt-heap-checker_unittest.13655.death_trick-beg.heap\"\r\n/tmp/google-perftools-0.98/.libs/lt-heap-checker_unittest\r\n\"/tmp/lt-heap-checker_unittest.13655.death_trick-end.heap\"\r\n--ignore\u003d\u0027^NamedDisabledLeaks$\u0027 --inuse_objects --lines --text\r\n\r\n\r\n\r\n$ ./heap-checker_unittest.sh \r\nTesting ./heap-checker_unittest with HEAPCHECK\u003d ... OK\r\nTesting ./heap-checker_unittest with HEAPCHECK\u003dlocal ... OK\r\nTesting ./heap-checker_unittest with HEAPCHECK\u003dnormal ... OK\r\nTesting ./heap-checker_unittest with HEAPCHECK\u003dstrict ... OK\r\nPASS\r\n\r\n\r\n$ ./maybe_threads_unittest.sh \r\nPASS\r\n\r\n","timestamp":1216193636,"attachments":[]},{"id":9,"commenterId":1451955930852924383,"content":"Issue 102 has been merged into this issue.","timestamp":1233355601,"attachments":[]},{"id":10,"commenterId":-5816528364620498132,"content":"\r\nFolks,\r\n\r\ngoogle-perftools was causing crashes for me too on x86_64. However, I found out that \r\nthese crashes were in libunwind. So I configured google perftools without libunwind \r\nsupport by using \u0027configure --enable-frame-pointers\u0027. And that\u0027s been working like a \r\ncharm for me.\r\n\r\n\r\n- Mohit ","timestamp":1233482303,"attachments":[]},{"id":11,"commenterId":-5676105695305143218,"content":"Mohit, I just tried to build everything from scratch with --enable-frame-pointers,\r\nand indeed all 23 unit tests pass with 1.0 on Ubuntu 8.10 x86_64.  Thanks for the\r\nadvice.  I will test it on my programs now.","timestamp":1233483271,"attachments":[]},{"id":12,"commenterId":-5676105695305143218,"content":"After some extensive tests today, using Mohit\u0027s advice all the perftools functions\r\nseem to work: tcmalloc, heap profiling, cpu profiling.\r\n\r\nThanks to Mohit and Craig for all your help.","timestamp":1233521583,"attachments":[]},{"id":13,"commenterId":1451955930852924383,"content":"(Note: I\u0027m keeping this bug open to track the fact that libunwind does not work well\r\nwith tcmalloc, due to the fact it allocates memory at unfortunate times for us.  I\u0027m\r\nhoping to work with the libunwind team to resolve this issue.)","timestamp":1236362416,"attachments":[]},{"id":14,"commenterId":8898996878260548504,"content":"It would really really helpful if you could work through this with the libunwind\r\nteam.  My team is currently unable to use TCMalloc because we can\u0027t find a version of\r\nlibunwind that makes all the tests pass.  We\u0027ve been working on building with\r\n--enable-framed-pointers which does get the unittests to pass, but, as you mentioned,\r\nit\u0027s impossible to get absolutely everything built with frame pointers and thus we\r\nhave weird problems unrolling the stack.\r\n\r\nI yearn for the memory profiling :)\r\n\r\n","timestamp":1236545574,"attachments":[]},{"id":15,"commenterId":1451955930852924383,"content":"I talked to the libunwind folks, and they had this to say:\r\n---\r\nThere are two separate deadlock cases: (a) the malloc deadlock and\r\n(b) the dl_iterate_phdr deadlock.\r\n\r\nThe malloc deadlock was introduced into the \"master\" Git tree by\r\ncode for ARM, and is trivial to revert.\r\n\r\nThe dl_iterate_phdr deadlock is \"impossible\" to work around\r\nwithout patching glibc, and that makes using libunwind with tcmalloc\r\na non-starter.\r\n---\r\n\r\nThis doesn\u0027t bode well for a fix anytime soon. :-(\r\n\r\nI think in the meantime, --enable-frame-pointer is the best I can recommend.  I\u0027ll\r\nchange the README to point this out.","timestamp":1236629862,"attachments":[]},{"id":16,"commenterId":1451955930852924383,"content":"A new version of libunwind was just released at\r\n   http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-beta.tar.gz\r\n\r\nAnyone who is affected by this, feel free to try this version and see if this\r\nresolves any of these issues for you.","timestamp":1237680606,"attachments":[]},{"id":17,"commenterId":8898996878260548504,"content":"I just tried the new libunwind with perftools 1.1, and I\u0027m still getting the same\r\ndeadlock in the heap leak checker (output below).\r\n\r\nI\u0027ve tried to use, instead, --enable-frame-pointer, but it\u0027s hard for me to get a\r\nlibc and libc++ version built with these options so then my CPU profiles contain a\r\nlot of disconnected boxes and are pretty impossible to use.\r\n\r\nIs this supposed to be the malloc() deadlock or the dl_iterate_phdr deadlock?\r\n\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\n\r\nHeapLeak checker deadlock (infinite loop?) info:\r\n\r\nTesting ./heap-checker_unittest with HEAPCHECK\u003dlocal ... \r\n\u003cruns forever, memory keeps growing out of bounds\u003e\r\n\r\nChild stack:\r\n(gdb) bt\r\n#0  0x0000003bd910ba81 in nanosleep () from /lib64/libpthread.so.0\r\n#1  0x00002aaaaaadec7f in SpinLock::SlowLock (this\u003d0x2aaaaac0fc40)\r\n    at src/base/spinlock.cc:99\r\n#2  0x00002aaaaaac6636 in DeleteHook (ptr\u003d0x798080) at src/base/spinlock.h:72\r\n#3  0x00002aaaaaae06dc in free (ptr\u003d0x798080) at src/malloc_hook-inl.h:107\r\n#4  0x00002aaaab0aa6cd in ?? () from /lib64/libnss_ldap.so.2\r\n#5  0x00002aaaab0aa738 in ?? () from /lib64/libnss_ldap.so.2\r\n#6  0x00002aaaab0a78cc in ?? () from /lib64/libnss_ldap.so.2\r\n#7  0x00002aaaab0a0696 in ?? () from /lib64/libnss_ldap.so.2\r\n#8  0x00002aaaab093a58 in ?? () from /lib64/libnss_ldap.so.2\r\n#9  0x00002aaaab093c31 in ?? () from /lib64/libnss_ldap.so.2\r\n#10 0x0000003bd8892797 in fork () from /lib64/libc.so.6\r\n#11 0x00002aaaaaad879d in HeapProfileTable::Snapshot::ReportLeaks (\r\n    this\u003d0x2aaaab5e4640, checker_name\u003d\u003cvalue optimized out\u003e, \r\n    filename\u003d0x2aaaab5ecf40 \"/tmp/lt-heap-checker_unittest.22298.trick-end.heap\")\r\n    at src/heap-profile-table.cc:549\r\n#12 0x00002aaaaaacbddd in HeapLeakChecker::DoNoLeaks (this\u003d0x7ffffffce950, \r\n    check_type\u003d\u003cvalue optimized out\u003e, fullness\u003d\u003cvalue optimized out\u003e, \r\n    report_mode\u003d\u003cvalue optimized out\u003e) at src/heap-checker.cc:1712\r\n#13 0x000000000040bcd8 in HeapLeakChecker::BriefNoLeaks (this\u003d0x7ffffffcd880)\r\n    at ./src/google/heap-checker.h:148\r\n#14 0x000000000040387b in RunSilent (check\u003d\u003cvalue optimized out\u003e, \r\n    func\u003d0x40bcc0 \u003cHeapLeakChecker::BriefNoLeaks()\u003e)\r\n    at src/tests/heap-checker_unittest.cc:396\r\n#15 0x0000000000405854 in VerifyLeaks (check\u003d0x7ffffffce950, \r\n    type\u003d\u003cvalue optimized out\u003e, leaked_bytes\u003d1600, leaked_objects\u003d2)\r\n    at src/tests/heap-checker_unittest.cc:410\r\n#16 0x0000000000405e7a in TestLeakButTotalsMatch ()\r\n    at src/tests/heap-checker_unittest.cc:608\r\n#17 0x000000000040a9a5 in main (argc\u003d\u003cvalue optimized out\u003e, \r\n    argv\u003d\u003cvalue optimized out\u003e) at src/tests/heap-checker_unittest.cc:1381\r\n(gdb) q\r\n\r\nParent is just doing a read() from the child socket.\r\n\r\n\r\n\r\n\r\n","timestamp":1237955357,"attachments":[]},{"id":18,"commenterId":1451955930852924383,"content":"Hmm, I think this is a totally different problem altogether.  When I\u0027ve seen this\r\naround here, it\u0027s because someone has an old version of pprof on their path; the new\r\nperftools requires the new pprof to do proper leak reporting.  I admit we could do a\r\nbetter job of diagnosing and reporting that problem.  In the meantime, if you can\r\nmake sure you only have the latest pprof installed, see if that makes the problem go\r\naway.","timestamp":1238015237,"attachments":[]},{"id":19,"commenterId":8898996878260548504,"content":"I did have an older version of \u0027pprof\u0027 on the path, but when I removed it the test\r\nstill fails in the exact same way as above.  Is there any more additional information\r\nI can provide you that would help tracking this down?\r\n\r\nIt seems that there\u0027s many threads burning CPU in the leak-checker test -- output\r\nfrom \u0027top\u0027 is below. \r\n\r\nIn addition, I do have another test failure in this same build, \"sampling_test.sh\",\r\nwithout output from that below as well.\r\n\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\nsampling_test.sh failure output\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\n\r\nTesting heap output...large does not exist.\r\nlarge does not exist.\r\nFAILED\r\nreason:\r\n\r\n----\r\n\r\n\r\n\r\n\r\n\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\n\u0027top\u0027 output for the lt-heap-checker_unittest\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\n\r\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND           \r\n\r\n11888 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.89 lt-heap-checker    \r\n11880 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.87 lt-heap-checker    \r\n11881 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.82 lt-heap-checker    \r\n11883 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.83 lt-heap-checker    \r\n11885 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.83 lt-heap-checker    \r\n11887 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.80 lt-heap-checker    \r\n11890 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.94 lt-heap-checker    \r\n11891 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.85 lt-heap-checker    \r\n11892 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.87 lt-heap-checker    \r\n11893 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.84 lt-heap-checker    \r\n11894 mrabkin   15   0  373m 186m 2268 S    2  2.3   0:02.87 lt-heap-checker    \r\n11878 mrabkin   15   0  373m 186m 2268 R    1  2.3   0:02.88 lt-heap-checker    \r\n11879 mrabkin   15   0  373m 186m 2268 S    1  2.3   0:02.79 lt-heap-checker    \r\n11882 mrabkin   15   0  373m 186m 2268 S    1  2.3   0:02.85 lt-heap-checker    \r\n11884 mrabkin   15   0  373m 186m 2268 S    1  2.3   0:02.85 lt-heap-checker    \r\n11886 mrabkin   15   0  373m 186m 2268 S    1  2.3   0:02.96 lt-heap-checker    \r\n11889 mrabkin   15   0  373m 186m 2268 S    1  2.3   0:02.83 lt-heap-checker \r\n\r\n11816 mrabkin   16   0 53912 1172  976 S    0  0.0   0:00.00 heap-checker_un    \r\n11864 mrabkin   18   0  412m 225m 2268 S    0  2.8   0:00.23 lt-heap-checker    \r\n11966 mrabkin   15   0  200m  13m 2268 S    0  0.2   0:00.04 lt-heap-checker \r\n","timestamp":1238023900,"attachments":[]},{"id":20,"commenterId":1451955930852924383,"content":"Actually, I take it back -- the problem seems to be with the fork() call I added in\r\nperftools 1.1, not necessarily with the version of perftools being used.\r\n\r\nI\u0027ve managed to reproduce this on my own machine.  I\u0027m looking into it.  This is\r\nprobably not a libunwind bug; feel free to open a new bug report for it.","timestamp":1238024001,"attachments":[]},{"id":21,"commenterId":8898996878260548504,"content":"This should probably be a separate bug for release 1.1, but for me \u0027sampling_test.sh\u0027\r\nattempts to figure out the real binary location of \u0027./sampling_test\u0027 by looking at\r\nthe first line, which is:\r\n\r\ntcmalloc: large alloc 65536 bytes \u003d\u003d 0x785000 @  0x2aaaaaac46fb 0x2aaaaaae1918\r\n0x3bd9551792 0x3bd9109a6c 0x3bd9551f21 0x3bd9596994 0x3bd959a471 0x3bd959ae50\r\n0x2aaaaaad8bc0 0x2aaaaaae03c2\r\n\r\nThe _last_ line of the output is \u0027USAGE: .libs/sampling_test \u003cbase of output files\u003e\u0027,\r\nwhich is, I believe, what we\u0027re trying to capture.\r\n\r\nSo it uses \u0027large\u0027 instead of the correct binary.\r\n\r\nI propose this patch (it fixes the problem for me):\r\n\r\n--- sampling_test.sh\t2009-03-25 17:02:07.043065000 -0700\r\n+++ sampling_test2.sh\t2009-03-25 17:02:46.859905000 -0700\r\n@@ -52,7 +52,7 @@ OUTDIR\u003d\"/tmp/sampling_test_dir\"\r\n # libtool is annoying, and puts the actual executable in a different\r\n # directory, replacing the seeming-executable with a shell script.\r\n # We use the error output of sampling_test to indicate its real location\r\n+SAMPLING_TEST_BINARY\u003d`\"$SAMPLING_TEST\" 2\u003e\u00261 | awk \u0027/USAGE/ {print $2; exit;}\u0027`\r\n-SAMPLING_TEST_BINARY\u003d`\"$SAMPLING_TEST\" 2\u003e\u00261 | awk \u0027{print $2; exit;}\u0027`\r\n \r\n die() {\r\n     echo \"FAILED\"\r\n\r\n\r\n","timestamp":1238025964,"attachments":[]},{"id":22,"commenterId":1451955930852924383,"content":"Good point, I\u0027ll add it to the next release (and yes, it should definitely be a\r\nseparate bug! :-) ).  I\u0027m curious why you\u0027re getting large-alloc warnings for only\r\n64k allocations though.  Did you set something up -- an envvar perhaps -- to do that?","timestamp":1238031450,"attachments":[]},{"id":23,"commenterId":-7291907736826274153,"content":"I encountered a hanging up while using cpu profiler. I used the perf tool 1.1 with\r\nlibunwind 0.99 beta version on a x86_64 machine with glibc 2.3.4 (does 2.3.4 has the\r\nsame issue as glibc2.4 mentioned in the README \u0026INSTALL notes?).\r\n\r\nIt seems it always hangs on the same location:\r\n\r\n(gdb) #0  0x000000302f50af8b in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0\r\n#1  0x0000007fbfff90a0 in ?? ()\r\n#2  0x0000000000000008 in ?? ()\r\n#3  0x000000302f507d6f in ?? () from /lib64/tls/libpthread.so.0\r\n#4  0x0000000000000001 in ?? ()\r\n#5  0x000000000044b899 in _start ()\r\n\r\nW/o cpu profiler, it can finish the execution. \r\n\r\nAnybody can help?\r\n","timestamp":1239317515,"attachments":[]},{"id":24,"commenterId":1451955930852924383,"content":"Issue 151 has been merged into this issue.","timestamp":1245820101,"attachments":[]},{"id":25,"commenterId":1451955930852924383,"content":"","timestamp":1268867051,"attachments":[]},{"id":26,"commenterId":1451955930852924383,"content":"Issue 223 has been merged into this issue.","timestamp":1268867171,"attachments":[]},{"id":27,"commenterId":4127005246389846762,"content":"Hi,\r\n\r\nI think I\u0027ve run into the glibc dl_iterate_phdr issue with tcmalloc.  This is on an\r\nx86_64 system, kernel 2.6.23, glibc 2.5.  I have another nearly-identical system, but\r\nwith glibc 2.6.1, which does not show the problem.  I can upgrade glibc, but just\r\nthought I\u0027d include a stack trace in case it has anything interesting in it for you.\r\n\r\n-dave\r\n\r\n#0  0x00002b9ea142c5f0 in __nanosleep_nocancel () from /lib/libpthread.so.0\r\n#1  0x00002b9ea085964f in SpinLock::SlowLock (this\u003d0x2b9ea0ca8340)\r\n    at ./src/base/spinlock_linux-inl.h:80\r\n#2  0x00002b9ea0a8717e in tcmalloc::ThreadCache::InitModule () at src/base/spinlock.h:74\r\n#3  0x00002b9ea0a91a2a in tc_malloc (size\u003d568) at src/thread_cache.h:378\r\n#4  0x00002b9ea1e467ea in ?? () from /lib/libc.so.6\r\n#5  0x00002b9ea202ca79 in load_debug_frame (file\u003d0x7fff0a5dcf80 \"\",\r\nbuf\u003d0x7fff0a5e0340, bufsize\u003d0x1,\r\n    is_local\u003d-1) at dwarf/Gfind_proc_info-lsb.c:119\r\n#6  0x00002b9ea202d25f in callback (info\u003d0x7fff0a5e03b0, size\u003d\u003cvalue optimized out\u003e,\r\n    ptr\u003d\u003cvalue optimized out\u003e) at dwarf/Gfind_proc_info-lsb.c:321\r\n#7  0x00002b9ea1ed8131 in dl_iterate_phdr () from /lib/libc.so.6\r\n#8  0x00002b9ea202c986 in _ULx86_64_dwarf_find_proc_info (as\u003d0x2b9ea2235240,\r\nip\u003d47960297931755,\r\n    pi\u003d0x7fff0a5e0d58, need_unwind_info\u003d1, arg\u003d0x7fff0a5e0c80) at\r\ndwarf/Gfind_proc_info-lsb.c:732\r\n#9  0x00002b9ea202b2fd in fetch_proc_info (c\u003d0x7fff0a5e0c80, ip\u003d\u003cvalue optimized out\u003e,\r\n    need_unwind_info\u003d1) at dwarf/Gparser.c:397\r\n#10 0x00002b9ea202c32f in _ULx86_64_dwarf_find_save_locs (c\u003d0x7fff0a5e0c80) at\r\ndwarf/Gparser.c:825\r\n#11 0x00002b9ea202c719 in _ULx86_64_dwarf_step (c\u003d0x7fff0a5dcf80) at dwarf/Gstep.c:35\r\n#12 0x00002b9ea202ec4a in _ULx86_64_step (cursor\u003d0x7fff0a5dcf80) at x86_64/Gstep.c:42\r\n#13 0x00002b9ea085841b in GetStackTrace (result\u003d0x623010, max_depth\u003d30,\r\n    skip_count\u003d\u003cvalue optimized out\u003e) at src/stacktrace_libunwind-inl.h:81\r\n#14 0x00002b9ea0a84b53 in tcmalloc::PageHeap::GrowHeap (this\u003d0x2b9ea0cb9ce0, n\u003d\u003cvalue\r\noptimized out\u003e)\r\n    at src/page_heap.cc:435\r\n#15 0x00002b9ea0a84e67 in tcmalloc::PageHeap::New (this\u003d0x2b9ea0cb9ce0, n\u003d3) at\r\nsrc/page_heap.cc:89\r\n#16 0x00002b9ea0a834d9 in tcmalloc::CentralFreeList::Populate (this\u003d0x2b9ea0cb22a0)\r\n    at src/central_freelist.cc:269\r\n#17 0x00002b9ea0a83668 in tcmalloc::CentralFreeList::FetchFromSpansSafe\r\n(this\u003d0x2b9ea0cb22a0)\r\n    at src/central_freelist.cc:236\r\n#18 0x00002b9ea0a836f9 in tcmalloc::CentralFreeList::RemoveRange (this\u003d0x2b9ea0cb22a0,\r\n    start\u003d0x7fff0a5e15a0, end\u003d0x7fff0a5e1598, N\u003d\u003cvalue optimized out\u003e) at\r\nsrc/central_freelist.cc:214\r\n#19 0x00002b9ea0a869b8 in tcmalloc::ThreadCache::FetchFromCentralCache (this\u003d0x863000,\r\n    cl\u003d\u003cvalue optimized out\u003e, byte_size\u003d1664) at src/thread_cache.cc:149\r\n#20 0x00002b9ea0a781b5 in (anonymous namespace)::cpp_alloc (size\u003d\u003cvalue optimized out\u003e,\r\n    nothrow\u003dfalse) at src/thread_cache.h:340\r\n#21 0x00002b9ea0a919a8 in tc_new (size\u003d140733367308160) at src/tcmalloc.cc:1346\r\n#22 0x00002b9ea0fe21ba in\r\nstd::vector\u003c__gnu_cxx::_Hashtable_node\u003cstd::pair\u003cstd::string const,\r\ngoogle::protobuf::FieldDescriptorProto_Type\u003e \u003e*,\r\nstd::allocator\u003c__gnu_cxx::_Hashtable_node\u003cstd::pair\u003cstd::string const,\r\ngoogle::protobuf::FieldDescriptorProto_Type\u003e \u003e*\u003e \u003e::reserve ()\r\n   from /usr/lib/libprotobuf.so.4\r\n#23 0x00002b9ea0fe036f in google::protobuf::compiler::(anonymous\r\nnamespace)::MakeTypeNameTable ()\r\n   from /usr/lib/libprotobuf.so.4\r\n#24 0x00002b9ea0fe1924 in ?? () from /usr/lib/libprotobuf.so.4\r\n#25 0x00002b9ea0fe25f2 in ?? () from /usr/lib/libprotobuf.so.4\r\n#26 0x00007fff0a5e19e8 in ?? ()\r\n#27 0x00002b9ea0cca4c8 in ?? ()\r\n#28 0x00002b9ea04e0000 in ?? ()\r\n#29 0x00002b9ea0f50033 in _init () from /usr/lib/libprotobuf.so.4\r\n#30 0x00002b9ea1b87960 in ?? ()\r\n#31 0x00002b9ea04d1bfb in call_init () from /lib64/ld-linux-x86-64.so.2\r\n#32 0x00002b9ea04d1d2d in _dl_init_internal () from /lib64/ld-linux-x86-64.so.2\r\n#33 0x00002b9ea04c5bba in _dl_start_user () from /lib64/ld-linux-x86-64.so.2\r\n#34 0x0000000000000006 in ?? ()\r\n#35 0x00007fff0a5e364b in ?? ()\r\n#36 0x00007fff0a5e3656 in ?? ()\r\n#37 0x00007fff0a5e3659 in ?? ()\r\n#38 0x00007fff0a5e365c in ?? ()\r\n#39 0x00007fff0a5e365f in ?? ()\r\n#40 0x00007fff0a5e366e in ?? ()\r\n#41 0x0000000000000000 in ?? ()\r\n(gdb)\r\n\r\n\r\n\r\n","timestamp":1273773797,"attachments":[]},{"id":28,"commenterId":1451955930852924383,"content":"Thanks for the report.  You\u0027re right, it looks exactly like a typical libunwind \r\nproblem we\u0027re seeing.","timestamp":1273779118,"attachments":[]},{"id":29,"commenterId":-3427604388790985155,"content":"Don\u0027t know if it\u0027s the same problem, but we\u0027ve run into deadlocks between tcmalloc and libunwind when we build in debug mode.  We work around it by setting the TCMALLOC_MAX_FREE_QUEUE_SIZE environment variable to 0 before running our commands.","timestamp":1278704400,"attachments":[]},{"id":30,"commenterId":-3314720809220871880,"content":"I just saw your dead lock problem with nssldap (Comment 17).\r\nThis dead lock is a bug in nssldap. It registers a function with atfork() that calls free() internally. All functions registered with atfork() must be async-signal-safe,\r\nand you just hit the spot that is not.\r\n\r\nSee also:\r\nhttps://bugzilla.redhat.com/show_bug.cgi?id\u003d474181\r\n-\u003e fixed in \u0027nss_ldap-253-36.el5\u0027","timestamp":1299662665,"attachments":[]},{"id":31,"commenterId":1451955930852924383,"content":"I\u0027ve updated the INSTALL file based on Arun Sharma\u0027s latest update on how libunwind works with perftools.  I don\u0027t think there\u0027s anything more for perftools to do here.  I consider the bug closed, though I\u0027ll keep it open to make it easy for folks to find if they\u0027re searching for this problem.\r\n\r\nIf you\u0027re one of those folks: check out the INSTALL and README files for more information about libunwind other 64-bit issues.","timestamp":1318458407,"attachments":[]}]}