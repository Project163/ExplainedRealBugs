diff --git a/leakcanary-android-core/api/leakcanary-android-core.api b/leakcanary-android-core/api/leakcanary-android-core.api
index fdca51ebc..944bd3a91 100644
--- a/leakcanary-android-core/api/leakcanary-android-core.api
+++ b/leakcanary-android-core/api/leakcanary-android-core.api
@@ -7,6 +7,11 @@ public final class com/squareup/leakcanary/core/BuildConfig {
 	public fun <init> ()V
 }
 
+public final class leakcanary/AndroidDebugHeapDumper : leakcanary/HeapDumper {
+	public static final field INSTANCE Lleakcanary/AndroidDebugHeapDumper;
+	public fun dumpHeap (Lleakcanary/HeapDumper$DumpLocation;)Lleakcanary/HeapDumper$Result;
+}
+
 public final class leakcanary/DefaultOnHeapAnalyzedListener : leakcanary/OnHeapAnalyzedListener {
 	public static final field Companion Lleakcanary/DefaultOnHeapAnalyzedListener$Companion;
 	public fun <init> (Landroid/app/Application;)V
@@ -18,6 +23,41 @@ public final class leakcanary/DefaultOnHeapAnalyzedListener$Companion {
 	public final fun create ()Lleakcanary/OnHeapAnalyzedListener;
 }
 
+public abstract interface class leakcanary/HeapDumper {
+	public abstract fun dumpHeap (Lleakcanary/HeapDumper$DumpLocation;)Lleakcanary/HeapDumper$Result;
+}
+
+public abstract class leakcanary/HeapDumper$DumpLocation {
+}
+
+public final class leakcanary/HeapDumper$DumpLocation$FileLocation : leakcanary/HeapDumper$DumpLocation {
+	public fun <init> (Ljava/io/File;)V
+	public final fun getFile ()Ljava/io/File;
+}
+
+public final class leakcanary/HeapDumper$DumpLocation$Unspecified : leakcanary/HeapDumper$DumpLocation {
+	public static final field INSTANCE Lleakcanary/HeapDumper$DumpLocation$Unspecified;
+}
+
+public abstract class leakcanary/HeapDumper$Result {
+}
+
+public final class leakcanary/HeapDumper$Result$Failure : leakcanary/HeapDumper$Result {
+	public fun <init> (Ljava/lang/Throwable;)V
+	public final fun getException ()Ljava/lang/Throwable;
+}
+
+public final class leakcanary/HeapDumper$Result$HeapDump : leakcanary/HeapDumper$Result {
+	public fun <init> (Ljava/io/File;J)V
+	public final fun getDurationMillis ()J
+	public final fun getFile ()Ljava/io/File;
+}
+
+public final class leakcanary/HeapDumpersKt {
+	public static final fun leakCanaryHeapDumper (Lleakcanary/HeapDumper;ZZ)Lleakcanary/HeapDumper;
+	public static synthetic fun leakCanaryHeapDumper$default (Lleakcanary/HeapDumper;ZZILjava/lang/Object;)Lleakcanary/HeapDumper;
+}
+
 public final class leakcanary/LeakCanary {
 	public static final field INSTANCE Lleakcanary/LeakCanary;
 	public final fun dumpHeap ()V
@@ -29,12 +69,13 @@ public final class leakcanary/LeakCanary {
 
 public final class leakcanary/LeakCanary$Config {
 	public fun <init> ()V
-	public fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Z)V
-	public synthetic fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Z)V
+	public synthetic fun <init> (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;ZILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun component1 ()Z
 	public final fun component10 ()Z
 	public final fun component11 ()Lshark/LeakingObjectFinder;
-	public final fun component12 ()Z
+	public final fun component12 ()Lleakcanary/HeapDumper;
+	public final fun component13 ()Z
 	public final fun component2 ()Z
 	public final fun component3 ()I
 	public final fun component4 ()Ljava/util/List;
@@ -43,12 +84,13 @@ public final class leakcanary/LeakCanary$Config {
 	public final fun component7 ()Lshark/MetadataExtractor;
 	public final fun component8 ()Z
 	public final fun component9 ()I
-	public final fun copy (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Z)Lleakcanary/LeakCanary$Config;
-	public static synthetic fun copy$default (Lleakcanary/LeakCanary$Config;ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;ZILjava/lang/Object;)Lleakcanary/LeakCanary$Config;
+	public final fun copy (ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;Z)Lleakcanary/LeakCanary$Config;
+	public static synthetic fun copy$default (Lleakcanary/LeakCanary$Config;ZZILjava/util/List;Ljava/util/List;Lleakcanary/OnHeapAnalyzedListener;Lshark/MetadataExtractor;ZIZLshark/LeakingObjectFinder;Lleakcanary/HeapDumper;ZILjava/lang/Object;)Lleakcanary/LeakCanary$Config;
 	public fun equals (Ljava/lang/Object;)Z
 	public final fun getComputeRetainedHeapSize ()Z
 	public final fun getDumpHeap ()Z
 	public final fun getDumpHeapWhenDebugging ()Z
+	public final fun getHeapDumper ()Lleakcanary/HeapDumper;
 	public final fun getLeakingObjectFinder ()Lshark/LeakingObjectFinder;
 	public final fun getMaxStoredHeapDumps ()I
 	public final fun getMetadataExtractor ()Lshark/MetadataExtractor;
@@ -68,6 +110,7 @@ public final class leakcanary/LeakCanary$Config$Builder {
 	public final fun computeRetainedHeapSize (Z)Lleakcanary/LeakCanary$Config$Builder;
 	public final fun dumpHeap (Z)Lleakcanary/LeakCanary$Config$Builder;
 	public final fun dumpHeapWhenDebugging (Z)Lleakcanary/LeakCanary$Config$Builder;
+	public final fun heapDumper (Lleakcanary/HeapDumper;)Lleakcanary/LeakCanary$Config$Builder;
 	public final fun leakingObjectFinder (Lshark/LeakingObjectFinder;)Lleakcanary/LeakCanary$Config$Builder;
 	public final fun maxStoredHeapDumps (I)Lleakcanary/LeakCanary$Config$Builder;
 	public final fun metadataExtractor (Lshark/MetadataExtractor;)Lleakcanary/LeakCanary$Config$Builder;
diff --git a/leakcanary-android-core/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
index 72f9d6c59..9930bd720 100644
--- a/leakcanary-android-core/consumer-proguard-rules.pro
+++ b/leakcanary-android-core/consumer-proguard-rules.pro
@@ -1,6 +1,6 @@
 # Loaded via reflection & referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_INTERNAL
 -keep class leakcanary.internal.InternalLeakCanary { *; }
 # Referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_HEAP_DUMPER
--keep class leakcanary.internal.AndroidHeapDumper { *; }
+-keep class leakcanary.internal.HeapDumperController { *; }
 # Marshmallow removed Notification.setLatestEventInfo()
 -dontwarn android.app.Notification
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt
new file mode 100644
index 000000000..bc6ffda52
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidDebugHeapDumper.kt
@@ -0,0 +1,38 @@
+package leakcanary
+
+import android.os.Debug
+import leakcanary.HeapDumper.DumpLocation
+import leakcanary.HeapDumper.DumpLocation.FileLocation
+import leakcanary.HeapDumper.Result
+import leakcanary.HeapDumper.Result.Failure
+import leakcanary.HeapDumper.Result.HeapDump
+import leakcanary.internal.friendly.measureDurationMillis
+
+/**
+ * Dumps the heap using [Debug.dumpHprofData]. [dumpHeap] is expected to be passed in a
+ * [FileLocation] and will otherwise fail.
+ *
+ * Note: measures the duration of the call to [Debug.dumpHprofData] using
+ * [android.os.SystemClock.uptimeMillis].
+ */
+object AndroidDebugHeapDumper : HeapDumper {
+  override fun dumpHeap(dumpLocation: DumpLocation): Result {
+    return if (dumpLocation is FileLocation) {
+      val outputFile = dumpLocation.file
+      try {
+        val durationMillis = measureDurationMillis {
+          Debug.dumpHprofData(outputFile.absolutePath)
+        }
+        if (outputFile.length() == 0L) {
+          Failure(RuntimeException("Dumped heap file is 0 byte length"))
+        } else {
+          HeapDump(outputFile, durationMillis)
+        }
+      } catch (e: Throwable) {
+        Failure(e)
+      }
+    } else {
+      Failure(RuntimeException("HeapDumper.DumpLocation is Unspecified"))
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt
new file mode 100644
index 000000000..f6b50898c
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/HeapDumper.kt
@@ -0,0 +1,33 @@
+package leakcanary
+
+import java.io.File
+
+fun interface HeapDumper {
+
+  sealed class DumpLocation {
+    object Unspecified : DumpLocation()
+    class FileLocation(val file: File) : DumpLocation()
+  }
+
+  sealed class Result {
+    class Failure(val exception: Throwable) : Result()
+    class HeapDump(
+      val file: File,
+      val durationMillis: Long
+    ) : Result()
+  }
+
+  /**
+   * Dumps the heap. The implementation is expected to be blocking until the heap is dumped
+   * or heap dumping failed.
+   *
+   * The [HeapDumper] interface is designed for delegation.
+   *
+   * [dumpLocation] may be [DumpLocation.Unspecified] or [DumpLocation.FileLocation], and
+   * it's ok for implementations to know how to deal with one or the other (or both) and otherwise
+   * return a [Result.Failure].
+   *
+   * @return [Result.HeapDump] if dumping the heap succeeded, and [Result.Failure] otherwise.
+   */
+  fun dumpHeap(dumpLocation: DumpLocation): Result
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/HeapDumpers.kt b/leakcanary-android-core/src/main/java/leakcanary/HeapDumpers.kt
new file mode 100644
index 000000000..76e319d4f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/HeapDumpers.kt
@@ -0,0 +1,32 @@
+package leakcanary
+
+import leakcanary.internal.withManagedHeapDumpDirectory
+import leakcanary.internal.withNotification
+import leakcanary.internal.withResourceIdNames
+import leakcanary.internal.withToast
+
+fun leakCanaryHeapDumper(
+  /**
+   * The core [HeapDumper] which will be wrapped by delegates.
+   */
+  coreHeapDumper: HeapDumper = AndroidDebugHeapDumper,
+  /**
+   * Wraps [HeapDumper.dumpHeap] to show cute canary Toast while the heap is being dumped.
+   */
+  toastOnDump: Boolean = true,
+  /**
+   * Wraps [HeapDumper.dumpHeap] to show an Android notification that says "Dumping Heap" while the
+   * heap is being dumped.
+   */
+  notificationOnDump: Boolean = true
+): HeapDumper {
+  var heapDumper = coreHeapDumper.withResourceIdNames()
+  if (notificationOnDump) {
+    heapDumper = heapDumper.withNotification()
+  }
+  if (toastOnDump) {
+    heapDumper = heapDumper.withToast()
+  }
+  heapDumper = heapDumper.withManagedHeapDumpDirectory()
+  return heapDumper
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 4c309e4b1..4e7fb613d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -168,6 +168,21 @@ object LeakCanary {
      */
     val leakingObjectFinder: LeakingObjectFinder = KeyedWeakReferenceFinder,
 
+    /**
+     * Dumps the Java heap. You may replace this with your own implementation if you wish to
+     * change how LeakCanary notifies the user of that the heap is dumping, or the core heap
+     * dumping implementation. It's highly recommended that you call [leakCanaryHeapDumper] and
+     * either provide a custom core heap dumper or wrap the returned heap dumper with a delegate
+     * that perform additional work. Example usage:
+     *
+     * ```
+     * LeakCanary.config = LeakCanary.config.copy(
+     *     heapDumper = leakCanaryHeapDumper(toastOnDump = false)
+     * )
+     * ```
+     */
+    val heapDumper: HeapDumper = leakCanaryHeapDumper(),
+
     /**
      * Deprecated: This is a no-op, set a custom [leakingObjectFinder] instead.
      */
@@ -213,6 +228,7 @@ object LeakCanary {
       private var requestWriteExternalStoragePermission =
         config.requestWriteExternalStoragePermission
       private var leakingObjectFinder = config.leakingObjectFinder
+      private var heapDumper = config.heapDumper
 
       /** @see [LeakCanary.Config.dumpHeap] */
       fun dumpHeap(dumpHeap: Boolean) =
@@ -258,6 +274,10 @@ object LeakCanary {
       fun leakingObjectFinder(leakingObjectFinder: LeakingObjectFinder) =
         apply { this.leakingObjectFinder = leakingObjectFinder }
 
+      /** @see [LeakCanary.Config.heapDumper] */
+      fun heapDumper(heapDumper: HeapDumper) =
+        apply { this.heapDumper = heapDumper }
+
       fun build() = config.copy(
         dumpHeap = dumpHeap,
         dumpHeapWhenDebugging = dumpHeapWhenDebugging,
@@ -269,7 +289,8 @@ object LeakCanary {
         computeRetainedHeapSize = computeRetainedHeapSize,
         maxStoredHeapDumps = maxStoredHeapDumps,
         requestWriteExternalStoragePermission = requestWriteExternalStoragePermission,
-        leakingObjectFinder = leakingObjectFinder
+        leakingObjectFinder = leakingObjectFinder,
+        heapDumper = heapDumper
       )
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
deleted file mode 100644
index c8b47e7a1..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.animation.Animator
-import android.animation.AnimatorListenerAdapter
-import android.app.Notification
-import android.app.NotificationManager
-import android.content.Context
-import android.os.Debug
-import android.view.Gravity
-import android.view.LayoutInflater
-import android.view.View
-import android.widget.Toast
-import com.squareup.leakcanary.core.R
-import leakcanary.internal.NotificationType.LEAKCANARY_LOW
-import leakcanary.internal.friendly.mainHandler
-import leakcanary.internal.friendly.measureDurationMillis
-import shark.SharkLog
-import java.util.concurrent.TimeUnit.SECONDS
-
-internal class AndroidHeapDumper(
-  context: Context,
-  private val leakDirectoryProvider: LeakDirectoryProvider
-) : HeapDumper {
-
-  private val context: Context = context.applicationContext
-
-  override fun dumpHeap(): DumpHeapResult {
-    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return NoHeapDump
-
-    val waitingForToast = FutureResult<Toast?>()
-    showToast(waitingForToast)
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      SharkLog.d { "Did not dump heap, too much time waiting for Toast." }
-      return NoHeapDump
-    }
-
-    val notificationManager =
-      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
-    if (Notifications.canShowNotification) {
-      val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
-      val builder = Notification.Builder(context)
-        .setContentTitle(dumpingHeap)
-      val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)
-      notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
-    }
-
-    val toast = waitingForToast.get()
-
-    return try {
-      val durationMillis = measureDurationMillis {
-        Debug.dumpHprofData(heapDumpFile.absolutePath)
-      }
-      if (heapDumpFile.length() == 0L) {
-        SharkLog.d { "Dumped heap file is 0 byte length" }
-        NoHeapDump
-      } else {
-        HeapDump(file = heapDumpFile, durationMillis = durationMillis)
-      }
-    } catch (e: Exception) {
-      SharkLog.d(e) { "Could not dump heap" }
-      // Abort heap dump
-      NoHeapDump
-    } finally {
-      cancelToast(toast)
-      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
-    }
-  }
-
-  private fun showToast(waitingForToast: FutureResult<Toast?>) {
-    mainHandler.post(Runnable {
-      val resumedActivity = InternalLeakCanary.resumedActivity
-      if (resumedActivity == null) {
-        waitingForToast.set(null)
-        return@Runnable
-      }
-      val toast = Toast(resumedActivity)
-      // Resources from application context: https://github.com/square/leakcanary/issues/2023
-      val iconSize = context.resources.getDimensionPixelSize(
-        R.dimen.leak_canary_toast_icon_size
-      )
-      toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
-      toast.duration = Toast.LENGTH_LONG
-      // Inflating with application context: https://github.com/square/leakcanary/issues/1385
-      val inflater = LayoutInflater.from(context)
-      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
-      toast.show()
-
-      val toastIcon = toast.view!!.findViewById<View>(R.id.leak_canary_toast_icon)
-      toastIcon.translationY = -iconSize.toFloat()
-      toastIcon
-        .animate()
-        .translationY(0f)
-        .setListener(object : AnimatorListenerAdapter() {
-          override fun onAnimationEnd(animation: Animator) {
-            waitingForToast.set(toast)
-          }
-        })
-    })
-  }
-
-  private fun cancelToast(toast: Toast?) {
-    if (toast == null) {
-      return
-    }
-    mainHandler.post { toast.cancel() }
-  }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index c4421e96d..cdf6b0742 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -4,12 +4,15 @@ import android.app.Application
 import android.app.Notification
 import android.app.NotificationManager
 import android.content.Context
-import android.content.res.Resources.NotFoundException
 import android.os.Handler
 import android.os.SystemClock
 import com.squareup.leakcanary.core.R
 import leakcanary.AppWatcher
 import leakcanary.GcTrigger
+import leakcanary.HeapDumper
+import leakcanary.HeapDumper.DumpLocation
+import leakcanary.HeapDumper.Result.Failure
+import leakcanary.HeapDumper.Result.HeapDump
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
 import leakcanary.ObjectWatcher
@@ -23,15 +26,14 @@ import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
 import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
-import shark.AndroidResourceIdNames
 import shark.SharkLog
+import java.io.File
 
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
   private val objectWatcher: ObjectWatcher,
   private val gcTrigger: GcTrigger,
-  private val heapDumper: HeapDumper,
   private val configProvider: () -> Config
 ) {
 
@@ -159,18 +161,17 @@ internal class HeapDumpTrigger(
     retry: Boolean,
     reason: String
   ) {
-    saveResourceIdNamesToMemory()
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
     KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
-    when (val heapDumpResult = heapDumper.dumpHeap()) {
-      is NoHeapDump -> {
+    when (val heapDumpResult = configProvider().heapDumper.dumpHeap(DumpLocation.Unspecified)) {
+      is Failure -> {
         if (retry) {
-          SharkLog.d { "Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms" }
+          SharkLog.d(heapDumpResult.exception) { "Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms" }
           scheduleRetainedObjectCheck(
             delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS
           )
         } else {
-          SharkLog.d { "Failed to dump heap, will not automatically retry" }
+          SharkLog.d(heapDumpResult.exception) { "Failed to dump heap, will not automatically retry" }
         }
         showRetainedCountNotification(
           objectCount = retainedReferenceCount,
@@ -193,25 +194,6 @@ internal class HeapDumpTrigger(
     }
   }
 
-  private fun saveResourceIdNamesToMemory() {
-    val resources = application.resources
-    AndroidResourceIdNames.saveToMemory(
-      getResourceTypeName = { id ->
-        try {
-          resources.getResourceTypeName(id)
-        } catch (e: NotFoundException) {
-          null
-        }
-      },
-      getResourceEntryName = { id ->
-        try {
-          resources.getResourceEntryName(id)
-        } catch (e: NotFoundException) {
-          null
-        }
-      })
-  }
-
   fun onDumpHeapReceived(forceDump: Boolean) {
     backgroundHandler.post {
       dismissNoRetainedOnTapNotification()
@@ -396,4 +378,14 @@ internal class HeapDumpTrigger(
     private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
     private const val WAIT_BETWEEN_HEAP_DUMPS_MILLIS = 60_000L
   }
-}
\ No newline at end of file
+}
+
+/** Dump heap result holding the file and the dump heap duration */
+internal sealed class DumpHeapResult
+
+internal data class HeapDump(
+  val file: File,
+  val durationMillis: Long
+) : DumpHeapResult()
+
+internal object NoHeapDump : DumpHeapResult()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
deleted file mode 100644
index dc7ea0025..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumper.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import java.io.File
-
-/** Dumps the heap into a file.  */
-internal fun interface HeapDumper {
-
-  /**
-   * @return a [File] referencing the dumped heap, or [.RETRY_LATER] if the heap could
-   * not be dumped.
-   */
-  fun dumpHeap(): DumpHeapResult
-}
-
-/** Dump heap result holding the file and the dump heap duration */
-internal sealed class DumpHeapResult
-
-internal data class HeapDump(
-  val file: File,
-  val durationMillis: Long
-) : DumpHeapResult()
-
-internal object NoHeapDump : DumpHeapResult()
-
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpers.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpers.kt
new file mode 100644
index 000000000..5e6b7c19d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpers.kt
@@ -0,0 +1,137 @@
+package leakcanary.internal
+
+import android.animation.Animator
+import android.animation.AnimatorListenerAdapter
+import android.app.Notification.Builder
+import android.app.NotificationManager
+import android.content.Context
+import android.content.res.Resources.NotFoundException
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import leakcanary.HeapDumper
+import leakcanary.HeapDumper.DumpLocation
+import leakcanary.HeapDumper.DumpLocation.FileLocation
+import leakcanary.HeapDumper.Result.Failure
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import leakcanary.internal.friendly.mainHandler
+import shark.AndroidResourceIdNames
+import java.util.concurrent.TimeUnit.SECONDS
+
+/**
+ * Wraps [HeapDumper.dumpHeap] and swaps a passed in [DumpLocation.Unspecified] with a
+ * [FileLocation] created in a managed heap dump directory, ensure we never store more than
+ * [LeakCanary.Config.maxStoredHeapDumps] heap dumps, managing permissions and access to external
+ * or app store, and creating a heap dump file that follows the "yyyy-MM-dd_HH-mm-ss_SSS'.hprof'"
+ * pattern.
+ */
+internal fun HeapDumper.withManagedHeapDumpDirectory(): HeapDumper {
+  val directoryProvider =
+    InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)
+  return HeapDumper { dumpLocation ->
+    if (dumpLocation is FileLocation) {
+      Failure(RuntimeException("HeapDumper.DumpLocation is already a FileLocation, pointing to ${dumpLocation.file.absolutePath}"))
+    } else {
+      val heapDumpFile = directoryProvider.newHeapDumpFile()
+      if (heapDumpFile == null) {
+        Failure(RuntimeException("Could not create heap dump file"))
+      } else {
+        dumpHeap(FileLocation(heapDumpFile))
+      }
+    }
+  }
+}
+
+internal fun HeapDumper.withNotification(): HeapDumper = HeapDumper { dumpLocation ->
+  if (Notifications.canShowNotification) {
+    val context = InternalLeakCanary.application
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
+    val builder = Builder(context)
+      .setContentTitle(dumpingHeap)
+    val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
+    dumpHeap(dumpLocation).also {
+      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
+    }
+  } else {
+    dumpHeap(dumpLocation)
+  }
+}
+
+/**
+ * Stores in memory the mapping of resource id ints to their corresponding name, so that the heap
+ * analysis can label views with their resource id names.
+ */
+internal fun HeapDumper.withResourceIdNames(): HeapDumper = HeapDumper { dumpLocation ->
+  val resources = InternalLeakCanary.application.resources
+  AndroidResourceIdNames.saveToMemory(
+    getResourceTypeName = { id ->
+      try {
+        resources.getResourceTypeName(id)
+      } catch (e: NotFoundException) {
+        null
+      }
+    },
+    getResourceEntryName = { id ->
+      try {
+        resources.getResourceEntryName(id)
+      } catch (e: NotFoundException) {
+        null
+      }
+    })
+  dumpHeap(dumpLocation)
+}
+
+internal fun HeapDumper.withToast(): HeapDumper = HeapDumper { dumpLocation ->
+  val toast = showToastBlocking(InternalLeakCanary.application)
+  if (toast == null) {
+    Failure(RuntimeException("Too much time waiting for Toast to show"))
+  } else {
+    dumpHeap(dumpLocation).also {
+      mainHandler.post { toast.cancel() }
+    }
+  }
+}
+
+private fun showToastBlocking(context: Context): Toast? {
+  val waitingForToast = FutureResult<Toast?>()
+  mainHandler.post(Runnable {
+    val resumedActivity = InternalLeakCanary.resumedActivity
+    if (resumedActivity == null) {
+      waitingForToast.set(null)
+      return@Runnable
+    }
+    val toast = Toast(resumedActivity)
+    // Resources from application context: https://github.com/square/leakcanary/issues/2023
+    val iconSize = context.resources.getDimensionPixelSize(
+      R.dimen.leak_canary_toast_icon_size
+    )
+    toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
+    toast.duration = Toast.LENGTH_LONG
+    // Inflating with application context: https://github.com/square/leakcanary/issues/1385
+    val inflater = LayoutInflater.from(context)
+    toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
+    toast.show()
+
+    val toastIcon = toast.view!!.findViewById<View>(R.id.leak_canary_toast_icon)
+    toastIcon.translationY = -iconSize.toFloat()
+    toastIcon
+      .animate()
+      .translationY(0f)
+      .setListener(object : AnimatorListenerAdapter() {
+        override fun onAnimationEnd(animation: Animator) {
+          waitingForToast.set(toast)
+        }
+      })
+  })
+
+  return if (!waitingForToast.wait(5, SECONDS)) {
+    null
+  } else {
+    waitingForToast.get()
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index d47fbc640..0091781db 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -22,6 +22,7 @@ import android.os.Handler
 import android.os.HandlerThread
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
+import leakcanary.AndroidDebugHeapDumper
 import leakcanary.AppWatcher
 import leakcanary.GcTrigger
 import leakcanary.LeakCanary
@@ -127,8 +128,6 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
 
     AppWatcher.objectWatcher.addOnObjectRetainedListener(this)
 
-    val heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))
-
     val gcTrigger = GcTrigger.Default
 
     val configProvider = { LeakCanary.config }
@@ -138,7 +137,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-      application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,
+      application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,
       configProvider
     )
     application.registerVisibilityListener { applicationVisible ->
