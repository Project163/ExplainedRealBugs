diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index c3d88fc22..9ce2eaffb 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -11,8 +11,8 @@ class LegacyHprofTest {
     assertThat(analysis.applicationLeaks).hasSize(2)
     val leak1 = analysis.applicationLeaks[0]
     val leak2 = analysis.applicationLeaks[1]
-    assertThat(leak1.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak2.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak1.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak2.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   @Test fun androidM() {
@@ -21,20 +21,28 @@ class LegacyHprofTest {
     assertThat(analysis.applicationLeaks).hasSize(1)
     val leak = analysis.applicationLeaks[0]
     assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: 'AsyncTask #1'")
+    assertThat(leak.leakTrace.elements[0].labels).contains("GC Root: System class")
   }
 
   @Test fun androidMStripped() {
     val stripper = HprofPrimitiveArrayStripper()
-    val strippedHprof =
-      stripper.stripPrimitiveArrays(fileFromResources("leak_asynctask_m.hprof"))
+    val sourceHprof = fileFromResources("leak_asynctask_m.hprof")
+    val strippedHprof = stripper.stripPrimitiveArrays(sourceHprof)
 
-    val analysis = analyzeHprof(strippedHprof)
+    assertThat(readThreadNames(sourceHprof)).contains("AsyncTask #1")
+    assertThat(readThreadNames(strippedHprof)).containsOnly("")
+  }
 
-    assertThat(analysis.applicationLeaks).hasSize(1)
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: ''")
+  private fun readThreadNames(hprofFile: File): List<String> {
+    val threadNames = Hprof.open(hprofFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.findClassByName("java.lang.Thread")!!.instances.map { instance ->
+            instance["java.lang.Thread", "name"]!!.value.readAsJavaString()!!
+          }
+              .toList()
+        }
+    return threadNames
   }
 
   @Test fun androidO() {
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
index 908aa3765..82b839662 100644
--- a/shark-graph/src/main/java/shark/HeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -13,7 +13,8 @@ interface HeapGraph {
    */
   val context: GraphContext
   /**
-   * All GC roots which type matches types known to this heap graph.
+   * All GC roots which type matches types known to this heap graph and which point to non null
+   * references.
    */
   val gcRoots: List<GcRoot>
   /**
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index 2b6976a8c..70cd1a6f5 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -29,6 +29,7 @@ import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StringRecord
 import shark.OnHprofRecordListener
 import shark.PrimitiveType
+import shark.ValueHolder
 import shark.internal.IndexedObject.IndexedClass
 import shark.internal.IndexedObject.IndexedInstance
 import shark.internal.IndexedObject.IndexedObjectArray
@@ -149,7 +150,7 @@ internal class HprofInMemoryIndex private constructor(
         }
         is GcRootRecord -> {
           val gcRoot = record.gcRoot
-          if (gcRoot.id != 0L && gcRoot::class in indexedGcRootsTypes) {
+          if (gcRoot.id != ValueHolder.NULL_REFERENCE && gcRoot::class in indexedGcRootsTypes) {
             gcRoots += gcRoot
           }
         }
diff --git a/shark/src/main/java/shark/internal/ShortestPathFinder.kt b/shark/src/main/java/shark/internal/ShortestPathFinder.kt
index c02fd8488..9b8f718e5 100644
--- a/shark/src/main/java/shark/internal/ShortestPathFinder.kt
+++ b/shark/src/main/java/shark/internal/ShortestPathFinder.kt
@@ -15,8 +15,6 @@
  */
 package shark.internal
 
-import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
-import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
 import shark.GcRoot
 import shark.GcRoot.JavaFrame
 import shark.GcRoot.ThreadObject
@@ -27,20 +25,23 @@ import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
 import shark.HeapObject.HeapPrimitiveArray
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.IgnoredReferenceMatcher
 import shark.LeakReference
 import shark.LeakTraceElement.Type.ARRAY_ENTRY
 import shark.LeakTraceElement.Type.INSTANCE_FIELD
 import shark.LeakTraceElement.Type.LOCAL
 import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.LibraryLeakReferenceMatcher
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
 import shark.PrimitiveType
 import shark.ReferenceMatcher
-import shark.IgnoredReferenceMatcher
-import shark.LibraryLeakReferenceMatcher
 import shark.ReferencePattern
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.StaticFieldPattern
 import shark.SharkLog
 import shark.ValueHolder
+import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.ChildNode.NormalNode
 import shark.internal.ReferencePathNode.RootNode
@@ -61,7 +62,12 @@ internal class ShortestPathFinder {
 
   /** Set of instances to visit */
   private val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
-  private val toVisitLastQueue: Deque<LibraryLeakNode> = ArrayDeque()
+
+  /**
+   * Instances to visit when [toVisitQueue] is empty. Should contain [JavaFrame] gc roots first,
+   * then [LibraryLeakNode].
+   */
+  private val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
   /**
    * Enables fast checking of whether a node is already in the queue.
    */
@@ -246,10 +252,10 @@ internal class ShortestPathFinder {
           val referenceMatcher = threadNameReferenceMatchers[threadName]
 
           if (referenceMatcher !is IgnoredReferenceMatcher) {
-            // visitOrder is unused as this root node isn't enqueued.
             val rootNode = RootNode(gcRoot, threadRoot.id)
-            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
-            // We should also add the full stacktrace as a label of thread objects
+            // Unfortunately Android heap dumps do not include stack trace data, so
+            // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
+            // reference to be held.
             val leakReference = LeakReference(LOCAL, "")
 
             val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
@@ -439,10 +445,14 @@ internal class ShortestPathFinder {
     if (toVisitSet.contains(node.instance)) {
       return
     }
-    //
+
+    val visitLast =
+      node is LibraryLeakNode ||
+          (node is NormalNode && node.parent is RootNode && node.parent.gcRoot is JavaFrame)
+
     if (toVisitLastSet.contains(node.instance)) {
       // Already enqueued => shorter or equal distance amongst library leak ref patterns.
-      if (node is LibraryLeakNode) {
+      if (visitLast) {
         return
       } else {
         toVisitQueue.add(node)
@@ -476,7 +486,7 @@ internal class ShortestPathFinder {
         return
       }
     }
-    if (node is LibraryLeakNode) {
+    if (visitLast) {
       toVisitLastQueue.add(node)
       toVisitLastSet.add(node.instance)
     } else {
diff --git a/shark/src/test/java/shark/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
index 53bd1f5ab..f0b7a9016 100644
--- a/shark/src/test/java/shark/HeapAnalyzerTest.kt
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -7,6 +7,7 @@ import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import shark.GcRoot.ThreadObject
 import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
@@ -107,6 +108,18 @@ class HeapAnalyzerTest {
     assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
   }
 
+  @Test fun localVariableLeakShortestPathGoesLast() {
+    hprofFile.writeTwoPathJavaLocalShorterLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    println(analysis)
+
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(STATIC_FIELD)
+  }
+
   @Test fun threadFieldLeak() {
     hprofFile.dump {
       val threadClassId =
diff --git a/shark/src/test/java/shark/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
index 8c8988dac..961490afd 100644
--- a/shark/src/test/java/shark/HeapDumps.kt
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -136,4 +136,34 @@ fun File.writeJavaLocalLeak(
     val leaking = "Leaking" watchedInstance {}
     gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
   }
+}
+
+fun File.writeTwoPathJavaLocalShorterLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+
+    val hasLeaking = instance(
+        clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+        fields = listOf(leaking)
+    )
+    clazz(
+        "GcRoot", staticFields = listOf(
+        "longestPath" to hasLeaking
+    )
+    )
+  }
 }
\ No newline at end of file
