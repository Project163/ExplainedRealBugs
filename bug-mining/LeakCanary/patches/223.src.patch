diff --git a/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt b/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt
new file mode 100644
index 000000000..8aa2f87be
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/EventListener.kt
@@ -0,0 +1,37 @@
+package leakcanary
+
+import android.app.PendingIntent
+import java.io.File
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.OnAnalysisProgressListener.Step
+
+fun interface EventListener {
+
+  sealed class Event {
+    object DumpingHeap : Event()
+
+    // TODO Ooooh maybe this is where we plug in the pipeline?
+    class HeapDumped(
+      val file: File,
+      val durationMillis: Long
+    ) : Event()
+
+    class HeapDumpFailed(val exception: Throwable) : Event()
+
+    class HeapAnalysisProgress(val step: Step) : Event()
+
+    class HeapAnalysisSucceeded(
+      val heapAnalysis: HeapAnalysisSuccess,
+      val unreadLeakSignatures: Set<String>,
+      val showIntent: PendingIntent
+    ) : Event()
+
+    class HeapAnalysisFailed(
+      val heapAnalysis: HeapAnalysisFailure,
+      val showIntent: PendingIntent
+    ) : Event()
+  }
+
+  fun onEvent(event: Event)
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 4e7fb613d..4a9e83078 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -183,6 +183,11 @@ object LeakCanary {
      */
     val heapDumper: HeapDumper = leakCanaryHeapDumper(),
 
+    /**
+     * TODO
+     */
+    val eventListener: EventListener = EventListener {},
+
     /**
      * Deprecated: This is a no-op, set a custom [leakingObjectFinder] instead.
      */
@@ -229,6 +234,7 @@ object LeakCanary {
         config.requestWriteExternalStoragePermission
       private var leakingObjectFinder = config.leakingObjectFinder
       private var heapDumper = config.heapDumper
+      private var eventListener = config.eventListener
 
       /** @see [LeakCanary.Config.dumpHeap] */
       fun dumpHeap(dumpHeap: Boolean) =
@@ -278,6 +284,10 @@ object LeakCanary {
       fun heapDumper(heapDumper: HeapDumper) =
         apply { this.heapDumper = heapDumper }
 
+      /** @see [LeakCanary.Config.eventListener] */
+      fun eventListener(eventListener: EventListener) =
+        apply { this.eventListener = eventListener }
+
       fun build() = config.copy(
         dumpHeap = dumpHeap,
         dumpHeapWhenDebugging = dumpHeapWhenDebugging,
@@ -290,7 +300,8 @@ object LeakCanary {
         maxStoredHeapDumps = maxStoredHeapDumps,
         requestWriteExternalStoragePermission = requestWriteExternalStoragePermission,
         leakingObjectFinder = leakingObjectFinder,
-        heapDumper = heapDumper
+        heapDumper = heapDumper,
+        eventListener = eventListener
       )
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index ded273196..0430c7e65 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -20,8 +20,18 @@ import android.content.Intent
 import android.os.Build.VERSION.SDK_INT
 import android.os.Process
 import com.squareup.leakcanary.core.R
+import leakcanary.EventListener.Event.HeapAnalysisFailed
+import leakcanary.EventListener.Event.HeapAnalysisProgress
+import leakcanary.EventListener.Event.HeapAnalysisSucceeded
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakTable
+import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
+import leakcanary.internal.activity.screen.HeapDumpScreen
+import leakcanary.internal.activity.screen.HeapDumpsScreen
 import shark.HeapAnalysis
 import shark.HeapAnalysisException
 import shark.HeapAnalysisFailure
@@ -86,6 +96,39 @@ internal class HeapAnalyzerService : ForegroundService(
       }
     }
     onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
+
+    val db = LeaksDbHelper(application).writableDatabase
+    val id = HeapAnalysisTable.insert(db, heapAnalysis)
+
+    when (fullHeapAnalysis) {
+      is HeapAnalysisSuccess -> {
+        val screenToShow = HeapDumpScreen(id)
+        val showIntent = LeakActivity.createPendingIntent(
+          application, arrayListOf(HeapDumpsScreen(), screenToShow)
+        )
+        val leakSignatures = fullHeapAnalysis.allLeaks.map { it.signature }.toSet()
+        val leakSignatureStatuses = LeakTable.retrieveLeakReadStatuses(db, leakSignatures)
+        val unreadLeakSignatures = leakSignatureStatuses.filter { (_, read) ->
+          !read
+        }.keys
+        config.eventListener.onEvent(
+          HeapAnalysisSucceeded(
+            fullHeapAnalysis,
+            unreadLeakSignatures,
+            showIntent
+          )
+        )
+      }
+      is HeapAnalysisFailure -> {
+        val screenToShow = HeapAnalysisFailureScreen(id)
+        val showIntent = LeakActivity.createPendingIntent(
+          application, arrayListOf(HeapDumpsScreen(), screenToShow)
+        )
+        config.eventListener.onEvent(HeapAnalysisFailed(fullHeapAnalysis, showIntent))
+      }
+    }
+    // Can't leverage .use{} because close() was added in API 16 and we're min SDK 14.
+    db.releaseReference()
     config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)
   }
 
@@ -94,7 +137,6 @@ internal class HeapAnalyzerService : ForegroundService(
     config: Config
   ): HeapAnalysis {
     val heapAnalyzer = HeapAnalyzer(this)
-
     val proguardMappingReader = try {
       ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME))
     } catch (e: IOException) {
@@ -127,6 +169,7 @@ internal class HeapAnalyzerService : ForegroundService(
   }
 
   override fun onAnalysisProgress(step: OnAnalysisProgressListener.Step) {
+    LeakCanary.config.eventListener.onEvent(HeapAnalysisProgress(step))
     val percent =
       (100f * step.ordinal / OnAnalysisProgressListener.Step.values().size).toInt()
     SharkLog.d { "Analysis in progress, working on: ${step.name}" }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index a01ceec44..fc1d2e8fb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -8,6 +8,9 @@ import android.os.Handler
 import android.os.SystemClock
 import com.squareup.leakcanary.core.R
 import leakcanary.AppWatcher
+import leakcanary.EventListener.Event.DumpingHeap
+import leakcanary.EventListener.Event.HeapDumpFailed
+import leakcanary.EventListener.Event.HeapDumped
 import leakcanary.GcTrigger
 import leakcanary.HeapDumper.DumpLocation
 import leakcanary.HeapDumper.Result.Failure
@@ -35,6 +38,7 @@ internal class HeapDumpTrigger(
   private val configProvider: () -> Config
 ) {
 
+
   private val notificationManager
     get() =
       application.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
@@ -161,8 +165,10 @@ internal class HeapDumpTrigger(
   ) {
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
     KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
+    configProvider().eventListener.onEvent(DumpingHeap)
     when (val heapDumpResult = configProvider().heapDumper.dumpHeap(DumpLocation.Unspecified)) {
       is Failure -> {
+        configProvider().eventListener.onEvent(HeapDumpFailed(heapDumpResult.exception))
         if (retry) {
           SharkLog.d(heapDumpResult.exception) { "Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms" }
           scheduleRetainedObjectCheck(
@@ -182,6 +188,7 @@ internal class HeapDumpTrigger(
         lastDisplayedRetainedObjectCount = 0
         lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()
         objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
+        configProvider().eventListener.onEvent(HeapDumped(heapDumpResult.file, heapDumpResult.durationMillis))
         HeapAnalyzerService.runAnalysis(
           context = application,
           heapDumpFile = heapDumpResult.file,
@@ -260,6 +267,7 @@ internal class HeapDumpTrigger(
           }
         }
       } else if (applicationInvisibleLessThanWatchPeriod) {
+        // TODO This is a bug, should use AppWatcher.retainedDelayMillis instead
         val wait =
           AppWatcher.config.watchDurationMillis - (SystemClock.uptimeMillis() - applicationInvisibleAt)
         if (nopeReason != null) {
