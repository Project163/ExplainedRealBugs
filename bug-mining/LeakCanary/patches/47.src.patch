diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 574e3f275..26ef2c1b9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -19,6 +19,8 @@ import java.io.Serializable;
 
 public final class AnalysisResult implements Serializable {
 
+  public static final long RETAINED_HEAP_SKIPPED = -1;
+
   public static AnalysisResult noLeak(long analysisDurationMs) {
     return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
@@ -59,7 +61,8 @@ public final class AnalysisResult implements Serializable {
 
   /**
    * The number of bytes which would be freed if all references to the leaking object were
-   * released. 0 if {@link #leakFound} is false.
+   * released. {@link #RETAINED_HEAP_SKIPPED} if the retained heap size was not computed. 0 if
+   * {@link #leakFound} is false.
    */
   public final long retainedHeapSize;
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 95a881208..58c9da295 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -112,11 +112,21 @@ public final class HeapAnalyzer {
     }
   }
 
+  /**
+   * Calls {@link #checkForLeak(File, String, boolean)} with computeRetainedSize set to true.
+   * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
+   */
+  @Deprecated
+  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+    return checkForLeak(heapDumpFile, referenceKey, true);
+  }
+
   /**
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
    */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey,
+      boolean computeRetainedSize) {
     long analysisStartNanoTime = System.nanoTime();
 
     if (!heapDumpFile.exists()) {
@@ -139,7 +149,7 @@ public final class HeapAnalyzer {
       if (leakingRef == null) {
         return noLeak(since(analysisStartNanoTime));
       }
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
+      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);
     } catch (Throwable e) {
       return failure(e, since(analysisStartNanoTime));
     }
@@ -189,7 +199,7 @@ public final class HeapAnalyzer {
   }
 
   private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef) {
+      Instance leakingRef, boolean computeRetainedSize) {
 
     listener.onProgressUpdate(FINDING_SHORTEST_PATH);
     ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
@@ -205,18 +215,24 @@ public final class HeapAnalyzer {
 
     String className = leakingRef.getClassObj().getClassName();
 
-    listener.onProgressUpdate(COMPUTING_DOMINATORS);
-    // Side effect: computes retained size.
-    snapshot.computeDominators();
+    long retainedSize;
+    if (computeRetainedSize) {
+
+      listener.onProgressUpdate(COMPUTING_DOMINATORS);
+      // Side effect: computes retained size.
+      snapshot.computeDominators();
 
-    Instance leakingInstance = result.leakingNode.instance;
+      Instance leakingInstance = result.leakingNode.instance;
 
-    long retainedSize = leakingInstance.getTotalRetainedSize();
+      retainedSize = leakingInstance.getTotalRetainedSize();
 
-    // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
-    if (SDK_INT <= N_MR1) {
-      listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
-      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+      // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
+      if (SDK_INT <= N_MR1) {
+        listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
+        retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+      }
+    } else {
+      retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;
     }
 
     return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
index 92a65685e..fad9f3ec9 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -56,7 +56,7 @@ final class TestUtil {
     String referenceKey = heapDumpFile.referenceKey;
     HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
     AnalysisResult result =
-        heapAnalyzer.checkForLeak(file, referenceKey);
+        heapAnalyzer.checkForLeak(file, referenceKey, true);
     if (result.failure != null) {
       result.failure.printStackTrace();
     }
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
index 3f84d5aa3..c1eb0c6f4 100644
--- a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
@@ -183,10 +183,12 @@ public final class InstrumentationLeakDetector {
         continue;
       }
 
+      HeapDump.Durations durations = new HeapDump.Durations(0, 0, 0);
       HeapDump heapDump =
-          new HeapDump(heapDumpFile, trackedReference.key, trackedReference.name, excludedRefs, 0,
-              0, 0);
-      AnalysisResult analysisResult = heapAnalyzer.checkForLeak(heapDumpFile, trackedReference.key);
+          new HeapDump(heapDumpFile, trackedReference.key, trackedReference.name, excludedRefs,
+              false, durations);
+      AnalysisResult analysisResult =
+          heapAnalyzer.checkForLeak(heapDumpFile, trackedReference.key, false);
 
       InstrumentationLeakResults.Result leakResult =
           new InstrumentationLeakResults.Result(heapDump, analysisResult);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 6bf9450a4..3ac0f6036 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -63,12 +63,22 @@ public class DisplayLeakService extends AbstractAnalysisResultService {
       pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
       if (result.failure == null) {
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        if (result.excludedLeak) {
-          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
+        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          String className = classSimpleName(result.className);
+          if (result.excludedLeak) {
+            contentTitle = getString(R.string.leak_canary_leak_excluded, className);
+          } else {
+            contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
+          }
         } else {
-          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
+          String size = formatShortFileSize(this, result.retainedHeapSize);
+          String className = classSimpleName(result.className);
+          if (result.excludedLeak) {
+            contentTitle = getString(R.string.leak_canary_leak_excluded_retaining, className, size);
+          } else {
+            contentTitle =
+                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
+          }
         }
       } else {
         contentTitle = getString(R.string.leak_canary_analysis_failed);
@@ -118,9 +128,11 @@ public class DisplayLeakService extends AbstractAnalysisResultService {
       CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
           newFile.getPath());
     }
+    HeapDump.Durations durations =
+        new HeapDump.Durations(heapDump.watchDurationMs, heapDump.gcDurationMs,
+            heapDump.heapDumpDurationMs);
     return new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName,
-        heapDump.excludedRefs, heapDump.watchDurationMs, heapDump.gcDurationMs,
-        heapDump.heapDumpDurationMs);
+        heapDump.excludedRefs, heapDump.computeRetainedHeapSize, durations);
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 636259244..0af04f2b5 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -111,7 +111,9 @@ public final class LeakCanary {
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
+      if (result.retainedHeapSize != AnalysisResult.RETAINED_HEAP_SKIPPED) {
+        info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
+      }
       if (detailed) {
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index bf8421cbb..5c7ae3b03 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -329,9 +329,14 @@ public final class DisplayLeakActivity extends Activity {
         }
         HeapDump heapDump = visibleLeak.heapDump;
         adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
+        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          String className = classSimpleName(result.className);
+          setTitle(getString(R.string.leak_canary_class_has_leaked, className));
+        } else {
+          String size = formatShortFileSize(this, result.retainedHeapSize);
+          String className = classSimpleName(result.className);
+          setTitle(getString(R.string.leak_canary_class_has_leaked_retaining, className, size));
+        }
       }
     } else {
       if (listAdapter instanceof LeakListAdapter) {
@@ -419,8 +424,12 @@ public final class DisplayLeakActivity extends Activity {
       String title;
       if (leak.result.failure == null) {
         String className = classSimpleName(leak.result.className);
-        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
-        title = getString(R.string.leak_canary_class_has_leaked, className, size);
+        if (leak.result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          title = getString(R.string.leak_canary_class_has_leaked, className);
+        } else {
+          String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
+          title = getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
+        }
         if (leak.result.excludedLeak) {
           title = getString(R.string.leak_canary_excluded_row, title);
         }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 06d0796fd..db900687b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -62,8 +62,8 @@ public final class HeapAnalyzerService extends ForegroundService
 
     HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs, this);
 
-    AnalysisResult result =
-        heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
+    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
+        heapDump.computeRetainedHeapSize);
     AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
   }
 
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
index a159c806d..40b9ce7ff 100644
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -14,8 +14,10 @@
   ~ limitations under the License.
   -->
 <resources>
-    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
-    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+    <string name="leak_canary_class_has_leaked">%1$s hat geleaked</string>
+    <string name="leak_canary_class_has_leaked_retaining">%1$s hat %2$s geleaked</string>
+    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat geleaked</string>
+    <string name="leak_canary_leak_excluded_retaining">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
     <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
     <string name="leak_canary_leak_list_title">Leaks in %s</string>
     <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index 67366c9f4..ff66160d5 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -15,8 +15,10 @@
   ~ limitations under the License.
   -->
 <resources>
-  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked</string>
+  <string name="leak_canary_class_has_leaked_retaining">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked</string>
+  <string name="leak_canary_leak_excluded_retaining">[Excluded] %1$s leaked %2$s</string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
   <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index ee201585d..f73546d30 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -57,15 +57,46 @@ public final class HeapDump implements Serializable {
   public final long watchDurationMs;
   public final long gcDurationMs;
   public final long heapDumpDurationMs;
+  public final boolean computeRetainedHeapSize;
 
+  /**
+   * Calls {@link #HeapDump(File, String, String, ExcludedRefs, boolean, Durations)}
+   * with computeRetainedHeapSize set to true.
+   *
+   * @deprecated Use
+   * {@link #HeapDump(File, String, String, ExcludedRefs, boolean, Durations)}  instead.
+   */
+  @Deprecated
   public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
       ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+    this(heapDumpFile, referenceKey, referenceName, excludedRefs, true,
+        new Durations(watchDurationMs, gcDurationMs, heapDumpDurationMs));
+  }
+
+  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
+      ExcludedRefs excludedRefs, boolean computeRetainedHeapSize, Durations durations) {
     this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
     this.referenceKey = checkNotNull(referenceKey, "referenceKey");
     this.referenceName = checkNotNull(referenceName, "referenceName");
     this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.watchDurationMs = watchDurationMs;
-    this.gcDurationMs = gcDurationMs;
-    this.heapDumpDurationMs = heapDumpDurationMs;
+    this.computeRetainedHeapSize = computeRetainedHeapSize;
+    this.watchDurationMs = durations.watchDurationMs;
+    this.gcDurationMs = durations.gcDurationMs;
+    this.heapDumpDurationMs = durations.heapDumpDurationMs;
+  }
+
+  /**
+   * A group of duration related parameters required when constructing a {@link HeapDump} instance.
+   */
+  public static final class Durations {
+    final long watchDurationMs;
+    final long gcDurationMs;
+    final long heapDumpDurationMs;
+
+    public Durations(long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+      this.watchDurationMs = watchDurationMs;
+      this.gcDurationMs = gcDurationMs;
+      this.heapDumpDurationMs = heapDumpDurationMs;
+    }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 998820a85..7e19a8958 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -46,15 +46,18 @@ public final class RefWatcher {
   private final ReferenceQueue<Object> queue;
   private final HeapDump.Listener heapdumpListener;
   private final ExcludedRefs excludedRefs;
+  private final boolean computeRetainedHeapSize;
 
   RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs,
+      boolean computeRetainedHeapSize) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
     this.heapDumper = checkNotNull(heapDumper, "heapDumper");
     this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
     this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
+    this.computeRetainedHeapSize = computeRetainedHeapSize;
     retainedKeys = new CopyOnWriteArraySet<>();
     queue = new ReferenceQueue<>();
   }
@@ -145,9 +148,11 @@ public final class RefWatcher {
         return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
+      HeapDump.Durations durations =
+          new HeapDump.Durations(watchDurationMs, gcDurationMs, heapDumpDurationMs);
       heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
-              gcDurationMs, heapDumpDurationMs));
+          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs,
+              computeRetainedHeapSize, durations));
     }
     return DONE;
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index b4c9eb339..0c631f420 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -12,6 +12,7 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
   private HeapDumper heapDumper;
   private WatchExecutor watchExecutor;
   private GcTrigger gcTrigger;
+  private boolean computeRetainedHeapSize;
 
   /** @see HeapDump.Listener */
   public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
@@ -49,6 +50,15 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
     return self();
   }
 
+  /**
+   * Whether LeakCanary should compute the retained heap size when a leak is detected. False by
+   * default, because computing the retained heap size takes a long time.
+   */
+  public final T computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+    this.computeRetainedHeapSize = computeRetainedHeapSize;
+    return self();
+  }
+
   /** Creates a {@link RefWatcher}. */
   public final RefWatcher build() {
     if (isDisabled()) {
@@ -86,7 +96,7 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
     }
 
     return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
-        excludedRefs);
+        excludedRefs, computeRetainedHeapSize);
   }
 
   protected boolean isDisabled() {
