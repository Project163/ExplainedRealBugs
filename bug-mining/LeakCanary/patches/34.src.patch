diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
new file mode 100644
index 000000000..5f6a202da
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -0,0 +1,89 @@
+package com.squareup.leakcanary;
+
+import android.app.Application;
+import android.content.Context;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.leakcanary.RefWatcher.DISABLED;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/** A {@link RefWatcherBuilder} with appropriate Android defaults. */
+public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRefWatcherBuilder> {
+
+  private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
+
+  private final Context context;
+
+  AndroidRefWatcherBuilder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  /**
+   * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
+   * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
+   */
+  public AndroidRefWatcherBuilder listenerServiceClass(
+      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
+  }
+
+  /**
+   * Sets a custom delay for how long the {@link RefWatcher} should wait until it checks if a
+   * tracked object has been garbage collected. This overrides any call to {@link
+   * #watchExecutor(WatchExecutor)}.
+   */
+  public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
+    return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
+  }
+
+  /**
+   * Sets the maximum number of heap dumps stored. This overrides any call to {@link
+   * #heapDumper(HeapDumper)} as well as any call to
+   * {@link LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)})}
+   *
+   * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
+   */
+  public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+    LeakDirectoryProvider leakDirectoryProvider =
+        new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
+    LeakCanary.setDisplayLeakActivityDirectoryProvider(leakDirectoryProvider);
+    return heapDumper(new AndroidHeapDumper(context, leakDirectoryProvider));
+  }
+
+  /**
+   * Creates a {@link RefWatcher} instance and starts watching activity references (on ICS+).
+   */
+  public RefWatcher buildAndInstall() {
+    RefWatcher refWatcher = build();
+    if (refWatcher != DISABLED) {
+      LeakCanary.enableDisplayLeakActivity(context);
+      ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher);
+    }
+    return refWatcher;
+  }
+
+  @Override protected boolean isDisabled() {
+    return LeakCanary.isInAnalyzerProcess(context);
+  }
+
+  @Override protected HeapDumper defaultHeapDumper() {
+    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    return new AndroidHeapDumper(context, leakDirectoryProvider);
+  }
+
+  @Override protected DebuggerControl defaultDebuggerControl() {
+    return new AndroidDebuggerControl();
+  }
+
+  @Override protected HeapDump.Listener defaultHeapDumpListener() {
+    return new ServiceHeapDumpListener(context, DisplayLeakService.class);
+  }
+
+  @Override protected ExcludedRefs defaultExcludedRefs() {
+    return AndroidExcludedRefs.createAppDefaults().build();
+  }
+
+  @Override protected WatchExecutor defaultWatchExecutor() {
+    return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index 44eb3ef05..c0011c8e4 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -35,7 +35,7 @@ public final class AndroidWatchExecutor implements WatchExecutor {
   private final long initialDelayMillis;
   private final long maxBackoffFactor;
 
-  public AndroidWatchExecutor(int initialDelayMillis) {
+  public AndroidWatchExecutor(long initialDelayMillis) {
     mainHandler = new Handler(Looper.getMainLooper());
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
index 98eda0085..94957554c 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -18,7 +18,6 @@ package com.squareup.leakcanary;
 import android.annotation.TargetApi;
 import android.app.PendingIntent;
 import android.content.Context;
-import android.content.res.Resources;
 import android.os.Environment;
 import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
 import java.io.File;
@@ -40,6 +39,8 @@ import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotificat
 
 public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
 
+  private static final int DEFAULT_MAX_STORED_HEAP_DUMPS = 7;
+
   private static final String HPROF_SUFFIX = ".hprof";
   private static final String PENDING_HEAPDUMP_SUFFIX = "_pending" + HPROF_SUFFIX;
 
@@ -47,12 +48,21 @@ public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider
   private static final int ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000;
 
   private final Context context;
+  private final int maxStoredHeapDumps;
 
-  private boolean writeExternalStorageGranted;
-  private boolean permissionNotificationDisplayed;
+  private volatile boolean writeExternalStorageGranted;
+  private volatile boolean permissionNotificationDisplayed;
 
   public DefaultLeakDirectoryProvider(Context context) {
+    this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
+  }
+
+  public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
+    if (maxStoredHeapDumps < 1) {
+      throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
+    }
     this.context = context.getApplicationContext();
+    this.maxStoredHeapDumps = maxStoredHeapDumps;
   }
 
   @Override public List<File> listFiles(FilenameFilter filter) {
@@ -176,9 +186,6 @@ public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider
   }
 
   private void cleanupOldHeapDumps() {
-    Resources resources = context.getResources();
-    int configStoredHeapDumps = resources.getInteger(R.integer.leak_canary_max_stored_leaks);
-    int maxStoredHeapDumps = Math.max(configStoredHeapDumps, 1);
     List<File> hprofFiles = listFiles(new FilenameFilter() {
       @Override public boolean accept(File dir, String filename) {
         return filename.endsWith(HPROF_SUFFIX);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index ffbb17da9..98f8325a3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -19,7 +19,6 @@ import android.app.Application;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.content.res.Resources;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
@@ -38,47 +37,25 @@ public final class LeakCanary {
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
+    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
+        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
+        .buildAndInstall();
   }
 
-  /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
-   */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
-    }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
-    return refWatcher;
-  }
-
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
-    Resources resources = context.getResources();
-    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
-    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
-    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
-        heapDumpListener, excludedRefs);
+  /** Builder to create a customized {@link RefWatcher} with appropriate Android defaults. */
+  public static AndroidRefWatcherBuilder refWatcher(Context context) {
+    return new AndroidRefWatcherBuilder(context);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
     setEnabled(context, DisplayLeakActivity.class, true);
   }
 
+  /**
+   * If you build a {@link RefWatcher} with a {@link AndroidHeapDumper} that has a custom {@link
+   * LeakDirectoryProvider}, then you should also call this method to make sure the activity in
+   * charge of displaying leaks can find those on the file system.
+   */
   public static void setDisplayLeakActivityDirectoryProvider(
       LeakDirectoryProvider leakDirectoryProvider) {
     DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
deleted file mode 100644
index b7197372b..000000000
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-  <integer name="leak_canary_watch_delay_millis">5000</integer>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
index b5f11b976..7e90f5979 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -19,7 +19,5 @@
   <public name="leak_canary_display_activity_label" type="string"/>
   <public name="leak_canary_heap_dump_toast" type="layout"/>
   <public name="leak_canary_icon" type="drawable"/>
-  <public name="leak_canary_max_stored_leaks" type="integer"/>
-  <public name="leak_canary_watch_delay_millis" type="integer"/>
 
 </resources>
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index fe88f38e2..ee201585d 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -20,9 +20,16 @@ import java.io.Serializable;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 
+/** Data structure holding information about a heap dump. */
 public final class HeapDump implements Serializable {
 
+  /** Receives a heap dump to analyze. */
   public interface Listener {
+    Listener NONE = new Listener() {
+      @Override public void analyze(HeapDump heapDump) {
+      }
+    };
+
     void analyze(HeapDump heapDump);
   }
 
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 344c74079..43a9499d6 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -17,7 +17,13 @@ package com.squareup.leakcanary;
 
 import java.io.File;
 
+/** Dumps the heap into a file. */
 public interface HeapDumper {
+  HeapDumper NONE = new HeapDumper() {
+    @Override public File dumpHeap() {
+      return RETRY_LATER;
+    }
+  };
 
   File RETRY_LATER = null;
 
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 2d2340fd1..57ee1e32d 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -35,22 +35,7 @@ import static java.util.concurrent.TimeUnit.NANOSECONDS;
  */
 public final class RefWatcher {
 
-  public static final RefWatcher DISABLED = new RefWatcher(new WatchExecutor() {
-    @Override public void execute(Retryable retryable) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return RETRY_LATER;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.BuilderWithParams().build());
+  public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
 
   private final WatchExecutor watchExecutor;
   private final DebuggerControl debuggerControl;
@@ -61,9 +46,8 @@ public final class RefWatcher {
   private final HeapDump.Listener heapdumpListener;
   private final ExcludedRefs excludedRefs;
 
-  public RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl,
-      GcTrigger gcTrigger, HeapDumper heapDumper, HeapDump.Listener heapdumpListener,
-      ExcludedRefs excludedRefs) {
+  RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
@@ -91,6 +75,9 @@ public final class RefWatcher {
    * @param referenceName An logical identifier for the watched object.
    */
   public void watch(Object watchedReference, String referenceName) {
+    if (this == DISABLED) {
+      return;
+    }
     checkNotNull(watchedReference, "watchedReference");
     checkNotNull(referenceName, "referenceName");
     final long watchStartNanoTime = System.nanoTime();
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
new file mode 100644
index 000000000..9e5d2a1d5
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -0,0 +1,124 @@
+package com.squareup.leakcanary;
+
+/**
+ * Responsible for building {@link RefWatcher} instances. Subclasses should provide sane defaults
+ * for the platform they support.
+ */
+public class RefWatcherBuilder<T extends RefWatcherBuilder> {
+
+  private ExcludedRefs excludedRefs;
+  private HeapDump.Listener heapDumpListener;
+  private DebuggerControl debuggerControl;
+  private HeapDumper heapDumper;
+  private WatchExecutor watchExecutor;
+  private GcTrigger gcTrigger;
+
+  /** @see HeapDump.Listener */
+  public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
+    this.heapDumpListener = heapDumpListener;
+    return self();
+  }
+
+  /** @see ExcludedRefs */
+  public final T excludedRefs(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+    return self();
+  }
+
+  /** @see HeapDumper */
+  public final T heapDumper(HeapDumper heapDumper) {
+    this.heapDumper = heapDumper;
+    return self();
+  }
+
+  /** @see DebuggerControl */
+  public final T debuggerControl(DebuggerControl debuggerControl) {
+    this.debuggerControl = debuggerControl;
+    return self();
+  }
+
+  /** @see WatchExecutor */
+  public final T watchExecutor(WatchExecutor watchExecutor) {
+    this.watchExecutor = watchExecutor;
+    return self();
+  }
+
+  /** @see GcTrigger */
+  public final T gcTrigger(GcTrigger gcTrigger) {
+    this.gcTrigger = gcTrigger;
+    return self();
+  }
+
+  /** Creates a {@link RefWatcher}. */
+  public final RefWatcher build() {
+    if (isDisabled()) {
+      return RefWatcher.DISABLED;
+    }
+
+    ExcludedRefs excludedRefs = this.excludedRefs;
+    if (excludedRefs == null) {
+      excludedRefs = defaultExcludedRefs();
+    }
+
+    HeapDump.Listener heapDumpListener = this.heapDumpListener;
+    if (heapDumpListener == null) {
+      heapDumpListener = defaultHeapDumpListener();
+    }
+
+    DebuggerControl debuggerControl = this.debuggerControl;
+    if (debuggerControl == null) {
+      debuggerControl = defaultDebuggerControl();
+    }
+
+    HeapDumper heapDumper = this.heapDumper;
+    if (heapDumper == null) {
+      heapDumper = defaultHeapDumper();
+    }
+
+    WatchExecutor watchExecutor = this.watchExecutor;
+    if (watchExecutor == null) {
+      watchExecutor = defaultWatchExecutor();
+    }
+
+    GcTrigger gcTrigger = this.gcTrigger;
+    if (gcTrigger == null) {
+      gcTrigger = defaultGcTrigger();
+    }
+
+    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
+        excludedRefs);
+  }
+
+  protected boolean isDisabled() {
+    return false;
+  }
+
+  protected GcTrigger defaultGcTrigger() {
+    return GcTrigger.DEFAULT;
+  }
+
+  protected DebuggerControl defaultDebuggerControl() {
+    return DebuggerControl.NONE;
+  }
+
+  protected ExcludedRefs defaultExcludedRefs() {
+    return ExcludedRefs.builder().build();
+  }
+
+  protected HeapDumper defaultHeapDumper() {
+    return HeapDumper.NONE;
+  }
+
+  protected HeapDump.Listener defaultHeapDumpListener() {
+    return HeapDump.Listener.NONE;
+  }
+
+  protected WatchExecutor defaultWatchExecutor() {
+    return WatchExecutor.NONE;
+  }
+
+  protected final T self() {
+    //noinspection unchecked
+    return (T) this;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
index 81579dff5..d9d19d402 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
@@ -1,5 +1,6 @@
 package com.squareup.leakcanary;
 
+/** A unit of work that can be retried later. */
 public interface Retryable {
 
   enum Result {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
index 85fd90bab..9446877c4 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
@@ -1,5 +1,14 @@
 package com.squareup.leakcanary;
 
+/**
+ * A {@link WatchExecutor} is in charge of executing a {@link Retryable} in the future, and retry
+ * later if needed.
+ */
 public interface WatchExecutor {
+  WatchExecutor NONE = new WatchExecutor() {
+    @Override public void execute(Retryable retryable) {
+    }
+  };
+
   void execute(Retryable retryable);
 }
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index b5c253750..c10b4d70b 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -23,8 +23,6 @@ import static org.junit.Assert.assertTrue;
 
 public class RefWatcherTest {
 
-  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
-
   static class TestDumper implements HeapDumper {
     boolean called;
 
@@ -73,7 +71,9 @@ public class RefWatcherTest {
   }
 
   private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
+    return new RefWatcherBuilder<>().watchExecutor(executor)
+        .heapDumper(dumper)
+        .heapDumpListener(new TestListener())
+        .build();
   }
 }
