diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
index 09023b971..2758e4fd8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -10,7 +10,7 @@ import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.internal.HeapAnalyzerService
 import leakcanary.internal.LeakCanaryUtils
-import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.Db
 import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.navigation.NavigatingActivity
 import leakcanary.internal.navigation.Screen
@@ -19,25 +19,13 @@ import java.io.IOException
 
 internal class LeakActivity : NavigatingActivity() {
 
-  private lateinit var dbHelper: LeaksDbHelper
-
-  val db get() = dbHelper.writableDatabase!!
-
   override fun onCreate(savedInstanceState: Bundle?) {
     super.onCreate(savedInstanceState)
     setContentView(R.layout.leak_canary_leak_activity)
 
-    val dbHelperOrNull = lastNonConfigurationInstance
-    dbHelper = dbHelperOrNull as LeaksDbHelper? ?: LeaksDbHelper(application)
-
-
     installNavigation(savedInstanceState, findViewById(R.id.main_container))
   }
 
-  override fun onRetainNonConfigurationInstance(): Any {
-    return dbHelper
-  }
-
   override fun getLauncherScreen(): Screen {
     return GroupListScreen()
   }
@@ -96,7 +84,7 @@ internal class LeakActivity : NavigatingActivity() {
   override fun onDestroy() {
     super.onDestroy()
     if (!isChangingConfigurations) {
-      dbHelper.close()
+      Db.closeDatabase()
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index 40075cd23..e454652a7 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -14,9 +14,6 @@ import com.squareup.leakcanary.core.R
 import leakcanary.internal.navigation.activity
 import java.io.File
 
-internal val View.db
-  get() = activity<LeakActivity>().db
-
 internal fun View.share(content: String) {
   val intent = Intent(Intent.ACTION_SEND)
   intent.type = "text/plain"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
new file mode 100644
index 000000000..f314cba87
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
@@ -0,0 +1,53 @@
+package leakcanary.internal.activity.db
+
+import android.database.sqlite.SQLiteDatabase
+import android.view.View
+import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.activity.db.Db.OnDb
+import leakcanary.internal.activity.db.Io.OnIo
+
+internal object Db {
+
+  private val dbHelper = LeaksDbHelper(InternalLeakCanary.application)
+
+  interface OnDb : OnIo {
+    val db: SQLiteDatabase
+  }
+
+  private class DbContext(override val db: SQLiteDatabase) : OnDb {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(
+    view: View,
+    block: OnDb.() -> Unit
+  ) {
+
+    Io.execute(view) {
+      val dbBlock = DbContext(dbHelper.writableDatabase)
+      block(dbBlock)
+      val updateUi = dbBlock.updateUi
+      if (updateUi != null) {
+        updateUi {
+          updateUi()
+        }
+      }
+    }
+  }
+
+  fun closeDatabase() {
+    // Closing on the serial IO thread to ensure we don't close while using the db.
+    Io.execute {
+      dbHelper.close()
+    }
+  }
+
+}
+
+internal fun View.executeOnDb(block: OnDb.() -> Unit) {
+  Db.execute(this, block)
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
new file mode 100644
index 000000000..712299087
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
@@ -0,0 +1,80 @@
+package leakcanary.internal.activity.db
+
+import android.os.Handler
+import android.os.Looper
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import leakcanary.internal.activity.db.Io.OnIo
+import java.util.concurrent.Executors
+
+internal object Io {
+
+  private val serialExecutor = Executors.newSingleThreadExecutor()
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  interface OnIo {
+    fun updateUi(updateUi: View.() -> Unit)
+  }
+
+  private class IoContext : OnIo {
+    var updateUi: (View.() -> Unit)? = null
+
+    override fun updateUi(updateUi: View.() -> Unit) {
+      this.updateUi = updateUi
+    }
+  }
+
+  fun execute(block: () -> Unit) {
+    serialExecutor.execute(block)
+  }
+
+  fun execute(
+    view: View,
+    block: OnIo.() -> Unit
+  ) {
+    checkMainThread()
+    val viewWrapper: VolatileObjectRef<View> = VolatileObjectRef(view)
+    view.addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+      override fun onViewAttachedToWindow(v: View?) {
+      }
+
+      override fun onViewDetachedFromWindow(v: View?) {
+        viewWrapper.element = null
+      }
+    })
+    serialExecutor.execute backgroundExecute@{
+      if (viewWrapper.element == null) {
+        return@backgroundExecute
+      }
+      val context = IoContext()
+      block(context)
+      val updateUi = context.updateUi
+      if (viewWrapper.element != null && updateUi != null) {
+        mainHandler.post mainThreadPost@{
+          val attachedView = viewWrapper.element ?: return@mainThreadPost
+          updateUi(attachedView)
+        }
+      }
+    }
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+
+  /**
+   * Similar to kotlin.jvm.internal.Ref.ObjectRef but volatile
+   */
+  private class VolatileObjectRef<T>(
+    @Volatile
+    var element: T? = null
+  )
+}
+
+internal fun View.executeOnIo(block: OnIo.() -> Unit) {
+  Io.execute(this, block)
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
index 6a399833f..005e697df 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -3,6 +3,7 @@ package leakcanary.internal.activity.screen
 import android.app.AlertDialog
 import android.text.format.DateUtils
 import android.text.method.LinkMovementMethod
+import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
@@ -10,8 +11,9 @@ import androidx.core.content.ContextCompat
 import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.LeakActivity
-import leakcanary.internal.activity.db
 import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.GroupProjection
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
@@ -22,32 +24,10 @@ import leakcanary.internal.navigation.onCreateOptionsMenu
 internal class GroupListScreen : Screen() {
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_list).apply {
-      val projections = LeakingInstanceTable.retrieveAllGroups(db)
-
-      activity.title =
-        resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
-
-      val listView = findViewById<ListView>(R.id.leak_canary_list)
-
-      listView.adapter =
-        SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
-          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
-
-          val projection = projections[position]
-
-          titleView.text = "(${projection.leakCount}) ${projection.description}"
-
-          val formattedDate = DateUtils.formatDateTime(
-              view.context, projection.createdAtTimeMillis,
-              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
-          )
-          timeView.text =
-            resources.getString(R.string.leak_canary_group_list_time_label, formattedDate)
-        }
-
-      listView.setOnItemClickListener { _, _, position, _ ->
-        goTo(GroupScreen(projections[position].hash))
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val projections = LeakingInstanceTable.retrieveAllGroups(db)
+        updateUi { onGroupsRetrieved(projections) }
       }
 
       onCreateOptionsMenu { menu ->
@@ -63,8 +43,10 @@ internal class GroupListScreen : Screen() {
                   .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
                   .setTitle(R.string.leak_canary_about_title)
                   .setMessage(
-                      HtmlCompat.fromHtml(resources.getString(R.string.leak_canary_about_message),
-                          HtmlCompat.FROM_HTML_MODE_LEGACY)
+                      HtmlCompat.fromHtml(
+                          resources.getString(R.string.leak_canary_about_message),
+                          HtmlCompat.FROM_HTML_MODE_LEGACY
+                      )
                   )
                   .setPositiveButton(android.R.string.ok, null)
                   .show()
@@ -81,4 +63,32 @@ internal class GroupListScreen : Screen() {
       }
 
     }
+
+  private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
+    activity.title =
+      resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+
+        val projection = projections[position]
+
+        titleView.text = "(${projection.leakCount}) ${projection.description}"
+
+        val formattedDate = DateUtils.formatDateTime(
+            view.context, projection.createdAtTimeMillis,
+            DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+        timeView.text =
+          resources.getString(R.string.leak_canary_group_list_time_label, formattedDate)
+      }
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      goTo(GroupScreen(projections[position].hash))
+    }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
index 1637bbc24..f15a5b470 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -1,11 +1,15 @@
 package leakcanary.internal.activity.screen
 
+import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
+import com.squareup.leakcanary.core.R.plurals
+import leakcanary.LeakTrace
 import leakcanary.internal.DisplayLeakAdapter
-import leakcanary.internal.activity.db
 import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
@@ -14,34 +18,42 @@ import leakcanary.internal.navigation.inflate
 internal class GroupScreen(private val groupHash: String) : Screen() {
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_list).apply {
-
-      val triple = LeakingInstanceTable.retrieveGroup(db, groupHash)
-
-      if (triple == null) {
-        activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
-        return this
-      }
-
-      // TODO add projects to list.
-      val (leakTrace, groupDescription, projections) = triple
-
-      activity.title = String.format(
-          resources.getQuantityText(
-              R.plurals.leak_canary_group_screen_title, projections.size
-          ).toString(), projections.size, groupDescription
-      )
-
-      val listView = findViewById<ListView>(R.id.leak_canary_list)
-
-      val adapter = DisplayLeakAdapter(resources, leakTrace, projections)
-      listView.adapter = adapter
-
-      listView.setOnItemClickListener { _, _, position, _ ->
-        val index = position - (adapter.count - projections.size)
-        if (index >= 0) {
-          goTo(LeakingInstanceScreen(projections[index].id))
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val triple = LeakingInstanceTable.retrieveGroup(db, groupHash)
+        updateUi {
+          if (triple == null) {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          } else {
+            // TODO add projects to list.
+            val (leakTrace, groupDescription, projections) = triple
+            onGroupRetrieved(projections, groupDescription, leakTrace)
+          }
         }
       }
+    }
 
+  private fun View.onGroupRetrieved(
+    projections: List<InstanceProjection>,
+    groupDescription: String,
+    leakTrace: LeakTrace
+  ) {
+    activity.title = String.format(
+        resources.getQuantityText(
+            plurals.leak_canary_group_screen_title, projections.size
+        ).toString(), projections.size, groupDescription
+    )
+
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val adapter = DisplayLeakAdapter(resources, leakTrace, projections)
+    listView.adapter = adapter
+
+    listView.setOnItemClickListener { _, _, position, _ ->
+      val index = position - (adapter.count - projections.size)
+      if (index >= 0) {
+        goTo(LeakingInstanceScreen(projections[index].id))
+      }
     }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
index 68c9a5b02..23c7084ae 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -1,12 +1,13 @@
 package leakcanary.internal.activity.screen
 
+import android.view.View
 import android.view.ViewGroup
 import android.widget.TextView
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.HeapAnalysisFailure
-import leakcanary.internal.activity.db
 import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.share
 import leakcanary.internal.activity.shareHeapDump
 import leakcanary.internal.navigation.Screen
@@ -21,50 +22,62 @@ internal class HeapAnalysisFailureScreen(
 
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_heap_analysis_failure_screen).apply {
-      val pair = HeapAnalysisTable.retrieve<HeapAnalysisFailure>(db, analysisId)
-
-      if (pair == null) {
-        activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
-        return this
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
+      executeOnDb {
+        val pair = HeapAnalysisTable.retrieve<HeapAnalysisFailure>(db, analysisId)
+        if (pair == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val (heapAnalysis, _) = pair
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onFailureRetrieved(heapAnalysis, heapDumpFileExist) }
+        }
       }
+    }
 
-      val (heapAnalysis, _) = pair
-
-      activity.title = resources.getString(R.string.leak_canary_analysis_failed)
+  private fun View.onFailureRetrieved(
+    heapAnalysis: HeapAnalysisFailure,
+    heapDumpFileExist: Boolean
+  ) {
+    activity.title = resources.getString(R.string.leak_canary_analysis_failed)
 
-      val failureTextView = findViewById<TextView>(R.id.leak_canary_failure)
-      val path = heapAnalysis.heapDumpFile.absolutePath
+    val failureTextView = findViewById<TextView>(R.id.leak_canary_failure)
+    val path = heapAnalysis.heapDumpFile.absolutePath
 
-      val failureText = """
+    val failureText = """
           |${resources.getString(R.string.leak_canary_failure_report)}
           |LeakCanary ${BuildConfig.LIBRARY_VERSION} ${BuildConfig.GIT_SHA}
           |${heapAnalysis.exception}
           |${resources.getString(R.string.leak_canary_download_dump, path)}
           """.trimMargin()
-      failureTextView.text = failureText
+    failureTextView.text = failureText
 
-      onCreateOptionsMenu { menu ->
-        menu.add(R.string.leak_canary_share_leak)
-            .setOnMenuItemClickListener {
-              // TODO Add version information
-              share(heapAnalysis.exception.toString())
-              true
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_share_leak)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            share(heapAnalysis.exception.toString())
+            true
+          }
+      menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
+              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
+              updateUi {
+                goBack()
+              }
             }
-        menu.add(R.string.leak_canary_delete)
+            true
+          }
+      if (heapDumpFileExist) {
+        menu.add(R.string.leak_canary_share_heap_dump)
             .setOnMenuItemClickListener {
-              HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
-              goBack()
+              shareHeapDump(heapAnalysis.heapDumpFile)
               true
             }
-        if (heapAnalysis.heapDumpFile.exists()) {
-          menu.add(R.string.leak_canary_share_heap_dump)
-              .setOnMenuItemClickListener {
-                shareHeapDump(heapAnalysis.heapDumpFile)
-                true
-              }
-        }
-
       }
     }
-
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
index a732d5e84..6eb7ab035 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -2,12 +2,14 @@ package leakcanary.internal.activity.screen
 
 import android.app.AlertDialog
 import android.text.format.DateUtils
+import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.internal.activity.db
 import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.HeapAnalysisTable.Projection
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
@@ -22,8 +24,6 @@ internal class HeapAnalysisListScreen : Screen() {
           R.string.leak_canary_heap_analysis_list_screen_title
       )
 
-      val listView = findViewById<ListView>(R.id.leak_canary_list)
-
       onCreateOptionsMenu { menu ->
         menu.add(R.string.leak_canary_delete_all)
             .setOnMenuItemClickListener {
@@ -32,9 +32,16 @@ internal class HeapAnalysisListScreen : Screen() {
                   .setTitle(R.string.leak_canary_delete_all)
                   .setMessage(R.string.leak_canary_delete_all_leaks_title)
                   .setPositiveButton(android.R.string.ok) { _, _ ->
-                    HeapAnalysisTable.deleteAll(db, context)
-                    listView.adapter =
-                      SimpleListAdapter(R.layout.leak_canary_leak_row, emptyList<Any>()) { _, _ -> }
+                    executeOnDb {
+                      HeapAnalysisTable.deleteAll(db, context)
+                      updateUi {
+                        val listView = findViewById<ListView>(R.id.leak_canary_list)
+                        listView.adapter =
+                          SimpleListAdapter(
+                              R.layout.leak_canary_leak_row, emptyList<Any>()
+                          ) { _, _ -> }
+                      }
+                    }
                   }
                   .setNegativeButton(android.R.string.cancel, null)
                   .show()
@@ -42,38 +49,46 @@ internal class HeapAnalysisListScreen : Screen() {
             }
       }
 
-      val projections = HeapAnalysisTable.retrieveAll(db)
-
-      listView.setOnItemClickListener { _, _, position, _ ->
-        val projection = projections[position]
-        val analysisScreen = if (projection.exceptionSummary != null)
-          HeapAnalysisFailureScreen(projection.id)
-        else
-          HeapAnalysisSuccessScreen(projection.id)
-        goTo(analysisScreen)
+      executeOnDb {
+        val projections = HeapAnalysisTable.retrieveAll(db)
+        updateUi { onAnalysesRetrieved(projections) }
       }
 
-      listView.adapter =
-        SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
-          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
-          // Results are sorted by timestamp DESC so the top item of the list is the last
-          // occurrence, hence the reversed index.
-          val index = count - position
-
-          val projection = getItem(position)
+    }
 
-          timeView.text = DateUtils.formatDateTime(
-              view.context, projection.createdAtTimeMillis,
-              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
-          )
+  private fun View.onAnalysesRetrieved(projections: List<Projection>) {
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-          val title = projection.exceptionSummary ?: resources.getQuantityString(
-              R.plurals.leak_canary_heap_analysis_list_retained_instances,
-              projection.retainedInstanceCount, projection.retainedInstanceCount
-          )
-          titleView.text = "$index. $title"
-        }
+    listView.setOnItemClickListener { _, _, position, _ ->
+      val projection = projections[position]
+      val analysisScreen = if (projection.exceptionSummary != null)
+        HeapAnalysisFailureScreen(projection.id)
+      else
+        HeapAnalysisSuccessScreen(projection.id)
+      goTo(analysisScreen)
     }
 
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, projections) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+        // Results are sorted by timestamp DESC so the top item of the list is the last
+        // occurrence, hence the reversed index.
+        val index = count - position
+
+        val projection = getItem(position)
+
+        timeView.text = DateUtils.formatDateTime(
+            view.context, projection.createdAtTimeMillis,
+            DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+        )
+
+        val title = projection.exceptionSummary ?: resources.getQuantityString(
+            R.plurals.leak_canary_heap_analysis_list_retained_instances,
+            projection.retainedInstanceCount, projection.retainedInstanceCount
+        )
+        titleView.text = "$index. $title"
+      }
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index b26eee778..db7cf3929 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal.activity.screen
 
 import android.text.format.DateUtils
+import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
@@ -10,8 +11,9 @@ import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import leakcanary.WeakReferenceCleared
 import leakcanary.WeakReferenceMissing
-import leakcanary.internal.activity.db
 import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.shareHeapDump
 import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.navigation.Screen
@@ -27,134 +29,149 @@ internal class HeapAnalysisSuccessScreen(
 
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_list).apply {
-      val pair = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, analysisId)
+      activity.title = resources.getString(R.string.leak_canary_loading_title)
 
-      if (pair == null) {
-        activity.title =
-          resources.getString(R.string.leak_canary_analysis_deleted_title)
-        return this
+      executeOnDb {
+        val pair = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, analysisId)
+        if (pair == null) {
+          updateUi {
+            activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+          }
+        } else {
+          val (heapAnalysis, leakGroupByHash) = pair
+          val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
+          updateUi { onSuccessRetrieved(heapAnalysis, leakGroupByHash, heapDumpFileExist) }
+        }
       }
+    }
 
-      val (heapAnalysis, leakGroupByHash) = pair
-
-      activity.title = resources.getString(
-          R.string.leak_canary_heap_analysis_success_screen_title,
-          heapAnalysis.retainedInstances.size
-      )
-
-      onCreateOptionsMenu { menu ->
-        menu.add(R.string.leak_canary_delete)
-            .setOnMenuItemClickListener {
+  private fun View.onSuccessRetrieved(
+    heapAnalysis: HeapAnalysisSuccess,
+    leakGroupByHash: Map<String, HeapAnalysisGroupProjection>,
+    heapDumpFileExist: Boolean
+  ) {
+    activity.title = resources.getString(
+        R.string.leak_canary_heap_analysis_success_screen_title,
+        heapAnalysis.retainedInstances.size
+    )
+
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_delete)
+          .setOnMenuItemClickListener {
+            executeOnDb {
               HeapAnalysisTable.delete(db, analysisId, heapAnalysis.heapDumpFile)
-              goBack()
+              updateUi {
+                goBack()
+              }
+            }
+            true
+          }
+      if (heapDumpFileExist) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener {
+              shareHeapDump(heapAnalysis.heapDumpFile)
+              true
+            }
+        menu.add(R.string.leak_canary_options_menu_render_heap_dump)
+            .setOnMenuItemClickListener {
+              goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
               true
             }
-        if (heapAnalysis.heapDumpFile.exists()) {
-          menu.add(R.string.leak_canary_share_heap_dump)
-              .setOnMenuItemClickListener {
-                shareHeapDump(heapAnalysis.heapDumpFile)
-                true
-              }
-          menu.add(R.string.leak_canary_options_menu_render_heap_dump)
-              .setOnMenuItemClickListener {
-                goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
-                true
-              }
-        }
       }
+    }
 
-      val listView = findViewById<ListView>(R.id.leak_canary_list)
-
-      val retainedInstances = heapAnalysis.retainedInstances
-
-      var weakReferenceClearedCount = 0
-      var noPathToInstanceCount = 0
-      var weakReferenceMissingCount = 0
-      retainedInstances.forEach { retainedInstance ->
-        // if a leak, add to a map of groupSha -> (description, count, total count, time)
-        // => instead of list of shas we can get the list of projections that already exists
-        // TODO If the sha doesn't exist in the map then this is a removed group. Can't happen
-        // right now as we don't allow removing groups
-        when (retainedInstance) {
-          is LeakingInstance -> {
-            if (leakGroupByHash[retainedInstance.groupHash] == null) {
-              TODO("Removing groups is not supported yet, this should not happen yet.")
-            }
-          }
-          is WeakReferenceCleared -> {
-            weakReferenceClearedCount++
-          }
-          is NoPathToInstance -> {
-            noPathToInstanceCount++
-          }
-          is WeakReferenceMissing -> {
-            weakReferenceMissingCount++
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
+
+    val retainedInstances = heapAnalysis.retainedInstances
+
+    var weakReferenceClearedCount = 0
+    var noPathToInstanceCount = 0
+    var weakReferenceMissingCount = 0
+    retainedInstances.forEach { retainedInstance ->
+      // if a leak, add to a map of groupSha -> (description, count, total count, time)
+      // => instead of list of shas we can get the list of projections that already exists
+      // TODO If the sha doesn't exist in the map then this is a removed group. Can't happen
+      // right now as we don't allow removing groups
+      when (retainedInstance) {
+        is LeakingInstance -> {
+          if (leakGroupByHash[retainedInstance.groupHash] == null) {
+            TODO("Removing groups is not supported yet, this should not happen yet.")
           }
         }
+        is WeakReferenceCleared -> {
+          weakReferenceClearedCount++
+        }
+        is NoPathToInstance -> {
+          noPathToInstanceCount++
+        }
+        is WeakReferenceMissing -> {
+          weakReferenceMissingCount++
+        }
       }
+    }
 
-      val rowList = mutableListOf<Pair<String, String>>()
-
-      val leakGroups = leakGroupByHash.values.toList()
-
-      rowList.addAll(leakGroups.map { projection ->
-        val titleText = resources.getString(
-            R.string.leak_canary_heap_analysis_success_screen_row_title, projection.leakCount,
-            projection.totalLeakCount, projection.description
-        )
-        val timeText = resources.getString(
-            R.string.leak_canary_heap_analysis_success_screen_row_time_format,
-            DateUtils.formatDateTime(
-                context, projection.createdAtTimeMillis,
-                DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
-            )
-        )
-        titleText to timeText
-      })
-
-      if (weakReferenceClearedCount > 0) {
-        rowList.add(
-            resources.getString(
-                R.string.leak_canary_heap_analysis_success_screen_weak_reference_cleared_count,
-                weakReferenceClearedCount
-            ) to ""
-        )
-      }
+    val rowList = mutableListOf<Pair<String, String>>()
 
-      if (noPathToInstanceCount > 0) {
-        rowList.add(
-            resources.getString(
-                R.string.leak_canary_heap_analysis_success_screen_no_path_to_instance_count,
-                noPathToInstanceCount
-            ) to ""
-        )
-      }
+    val leakGroups = leakGroupByHash.values.toList()
 
-      if (weakReferenceMissingCount > 0) {
-        rowList.add(
-            resources.getString(
-                R.string.leak_canary_heap_analysis_success_screen_garbage_collected_weak_references,
-                weakReferenceMissingCount
-            ) to ""
-        )
-      }
+    rowList.addAll(leakGroups.map { projection ->
+      val titleText = resources.getString(
+          R.string.leak_canary_heap_analysis_success_screen_row_title, projection.leakCount,
+          projection.totalLeakCount, projection.description
+      )
+      val timeText = resources.getString(
+          R.string.leak_canary_heap_analysis_success_screen_row_time_format,
+          DateUtils.formatDateTime(
+              context, projection.createdAtTimeMillis,
+              DateUtils.FORMAT_SHOW_TIME or DateUtils.FORMAT_SHOW_DATE
+          )
+      )
+      titleText to timeText
+    })
+
+    if (weakReferenceClearedCount > 0) {
+      rowList.add(
+          resources.getString(
+              R.string.leak_canary_heap_analysis_success_screen_weak_reference_cleared_count,
+              weakReferenceClearedCount
+          ) to ""
+      )
+    }
+
+    if (noPathToInstanceCount > 0) {
+      rowList.add(
+          resources.getString(
+              R.string.leak_canary_heap_analysis_success_screen_no_path_to_instance_count,
+              noPathToInstanceCount
+          ) to ""
+      )
+    }
+
+    if (weakReferenceMissingCount > 0) {
+      rowList.add(
+          resources.getString(
+              R.string.leak_canary_heap_analysis_success_screen_garbage_collected_weak_references,
+              weakReferenceMissingCount
+          ) to ""
+      )
+    }
 
 
-      listView.adapter =
-        SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
-          val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-          val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
+    listView.adapter =
+      SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
 
-          val (titleText, timeText) = getItem(position)
+        val (titleText, timeText) = getItem(position)
 
-          titleView.text = titleText
-          timeView.text = timeText
-        }
+        titleView.text = titleText
+        timeView.text = timeText
+      }
 
-      listView.setOnItemClickListener { _, _, position, _ ->
-        if (position < leakGroupByHash.size) {
-          goTo(GroupScreen(leakGroups[position].hash))
-        }
+    listView.setOnItemClickListener { _, _, position, _ ->
+      if (position < leakGroupByHash.size) {
+        goTo(GroupScreen(leakGroups[position].hash))
       }
     }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
similarity index 88%
rename from leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt
rename to leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index 385fccb1b..b2dd1f3cf 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpTask.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -9,9 +9,6 @@ import android.graphics.Paint
 import android.graphics.Paint.Style.FILL
 import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
-import android.os.AsyncTask
-import android.os.Handler
-import android.os.Looper
 import com.squareup.leakcanary.core.R
 import leakcanary.HprofParser
 import leakcanary.HprofParser.RecordCallbacks
@@ -35,18 +32,28 @@ import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import java.io.File
 
-class RenderHeapDumpTask private constructor(
-  private val resources: Resources,
-  private val heapDumpFile: File,
-  private val width: Int,
-  private val height: Int,
-  private val bytesPerPixel: Int,
-  private var resultCallback: ((Bitmap) -> Unit)?
-) {
+object HeapDumpRenderer {
 
-  private val uiHandler = Handler(Looper.getMainLooper())
+  private class HasDensity(resources: Resources) {
+    val density = resources.displayMetrics.density
 
-  private val runnable = Runnable {
+    val Int.dp
+      get() = this * density
+
+    val Float.dp
+      get() = this * density
+  }
+
+  fun render(
+    resources: Resources,
+    heapDumpFile: File,
+    sourceWidth: Int,
+    sourceHeight: Int,
+    /**
+     * If [bytesPerPixel] > 0 then height will be ignored.
+     */
+    sourceBytesPerPixel: Int
+  ): Bitmap = with(HasDensity(resources)) {
     val parser = HprofParser.open(heapDumpFile)
 
     val recordPositions = mutableListOf<Pair<Int, Long>>()
@@ -147,17 +154,16 @@ class RenderHeapDumpTask private constructor(
     val heapLength = parser.position
     parser.close()
 
-    val width = width
-
+    val width = sourceWidth
     var height: Int
     val bytesPerPixel: Double
 
-    if (this.bytesPerPixel > 0) {
-      bytesPerPixel = this.bytesPerPixel.toDouble()
+    if (sourceBytesPerPixel > 0) {
+      bytesPerPixel = sourceBytesPerPixel.toDouble()
       height = Math.ceil((heapLength / bytesPerPixel) / width)
           .toInt()
     } else {
-      height = this.height
+      height = sourceHeight
       bytesPerPixel = heapLength * 1.0 / (width * height)
     }
 
@@ -267,37 +273,7 @@ class RenderHeapDumpTask private constructor(
         canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
       }
     }
-    uiHandler.post {
-      resultCallback?.invoke(bitmap)
-    }
+    return bitmap
   }
 
-  private val Int.dp
-    get() = this * resources.displayMetrics.density
-
-  private val Float.dp
-    get() = this * resources.displayMetrics.density
-
-  fun cancel() {
-    resultCallback = null
-  }
-
-  companion object {
-    fun renderAsync(
-      resources: Resources,
-      heapDumpFile: File,
-      width: Int,
-      height: Int,
-      /**
-       * If [bytesPerPixel] > 0 then height will be ignored.
-       */
-      bytesPerPixel: Int,
-      resultCallback: ((Bitmap) -> Unit)?
-    ): RenderHeapDumpTask {
-      val renderTask =
-        RenderHeapDumpTask(resources, heapDumpFile, width, height, bytesPerPixel, resultCallback)
-      AsyncTask.THREAD_POOL_EXECUTOR.execute(renderTask.runnable)
-      return renderTask
-    }
-  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index 2335aec14..584e91967 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -1,14 +1,15 @@
 package leakcanary.internal.activity.screen
 
+import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
 import leakcanary.LeakingInstance
 import leakcanary.internal.DisplayLeakAdapter
-import leakcanary.internal.activity.db
+import leakcanary.internal.activity.db.LeakingInstanceTable
+import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Id
 import leakcanary.internal.activity.screen.LeakingInstanceScreen.InstanceOrId.Instance
-import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.share
 import leakcanary.internal.activity.shareToStackOverflow
 import leakcanary.internal.lastSegment
@@ -37,49 +38,63 @@ internal class LeakingInstanceScreen private constructor(
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_list).apply {
 
-      val pair = when (instanceOrId) {
-        is Instance -> instanceOrId.heapAnalysisId to instanceOrId.instance
-        is Id -> LeakingInstanceTable.retrieve(db, instanceOrId.id)
-      }
-
-      if (pair == null) {
-        activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
-        return this
+      when (instanceOrId) {
+        is Instance -> {
+          onInstanceRetrieved(instanceOrId.heapAnalysisId, instanceOrId.instance)
+        }
+        is Id -> {
+          activity.title = resources.getString(R.string.leak_canary_loading_title)
+          executeOnDb {
+            val pair = LeakingInstanceTable.retrieve(db, instanceOrId.id)
+            updateUi {
+              if (pair == null) {
+                activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
+              } else {
+                val (heapAnalysisId, leakingInstance) = pair
+                onInstanceRetrieved(heapAnalysisId, leakingInstance)
+              }
+            }
+          }
+        }
       }
+    }
 
-      val (heapAnalysisId, leakingInstance) = pair
-
-      val classSimpleName = leakingInstance.instanceClassName.lastSegment('.')
-      activity.title = resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
+  private fun View.onInstanceRetrieved(
+    heapAnalysisId: Long,
+    leakingInstance: LeakingInstance
+  ) {
+    val classSimpleName = leakingInstance.instanceClassName.lastSegment('.')
+    activity.title =
+      resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
 
-      val listView = findViewById<ListView>(R.id.leak_canary_list)
+    val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-      val adapter =
-        DisplayLeakAdapter(resources, leakingInstance.leakTrace, leakingInstance.referenceName)
-      listView.adapter = adapter
+    val adapter =
+      DisplayLeakAdapter(resources, leakingInstance.leakTrace, leakingInstance.referenceName)
+    listView.adapter = adapter
 
-      listView.setOnItemClickListener { _, _, position, _ ->
-        adapter.toggleRow(position)
-      }
+    listView.setOnItemClickListener { _, _, position, _ ->
+      adapter.toggleRow(position)
+    }
 
-      onCreateOptionsMenu { menu ->
-        menu.add(R.string.leak_canary_go_to_heap_analysis)
-            .setOnMenuItemClickListener {
-              goTo(HeapAnalysisSuccessScreen(heapAnalysisId))
-              true
-            }
-        menu.add(R.string.leak_canary_share_leak)
-            .setOnMenuItemClickListener {
-              // TODO Add version information
-              share(leakingInstance.toString())
-              true
-            }
-        menu.add(R.string.leak_canary_stackoverflow_share)
-            .setOnMenuItemClickListener {
-              // TODO Add version information
-              shareToStackOverflow(leakingInstance.toString())
-              true
-            }
-      }
+    onCreateOptionsMenu { menu ->
+      menu.add(R.string.leak_canary_go_to_heap_analysis)
+          .setOnMenuItemClickListener {
+            goTo(HeapAnalysisSuccessScreen(heapAnalysisId))
+            true
+          }
+      menu.add(R.string.leak_canary_share_leak)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            share(leakingInstance.toString())
+            true
+          }
+      menu.add(R.string.leak_canary_stackoverflow_share)
+          .setOnMenuItemClickListener {
+            // TODO Add version information
+            shareToStackOverflow(leakingInstance.toString())
+            true
+          }
     }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index 6cdc5e99b..5b8ddafa6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -2,7 +2,6 @@ package leakcanary.internal.activity.screen
 
 import android.content.Intent
 import android.graphics.Bitmap
-import android.os.AsyncTask
 import android.os.Environment
 import android.os.Environment.DIRECTORY_DOWNLOADS
 import android.view.View
@@ -14,6 +13,7 @@ import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
@@ -28,33 +28,40 @@ internal class RenderHeapDumpScreen(
 
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_heap_render).apply {
-      container.activity.title = resources.getString(
-          R.string.leak_canary_heap_dump_screen_title,
-          humanReadableByteCount(heapDumpFile.length(), false)
-      )
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      executeOnIo {
+        val byteCount = humanReadableByteCount(heapDumpFile.length(), false)
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_heap_dump_screen_title, byteCount)
+        }
+      }
 
       val loadingView = findViewById<View>(R.id.leak_canary_loading)
       val imageView = findViewById<ImageView>(R.id.leak_canary_heap_rendering)
 
       viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
         override fun onGlobalLayout() {
-          RenderHeapDumpTask.renderAsync(
-              resources,
-              heapDumpFile, measuredWidth, measuredHeight, 0
-          ) { bitmap ->
-            imageView.setImageBitmap(bitmap)
-            loadingView.visibility = View.GONE
-            imageView.visibility = View.VISIBLE
+
+          executeOnIo {
+            val bitmap = HeapDumpRenderer.render(
+                resources,
+                heapDumpFile, measuredWidth, measuredHeight, 0
+            )
+            updateUi {
+              imageView.setImageBitmap(bitmap)
+              loadingView.visibility = View.GONE
+              imageView.visibility = View.VISIBLE
+            }
           }
           viewTreeObserver.removeGlobalOnLayoutListener(this)
         }
-
       })
 
       onCreateOptionsMenu { menu ->
         menu.add(R.string.leak_canary_options_menu_generate_hq_bitmap)
             .setOnMenuItemClickListener {
-
               val leakDirectoryProvider = LeakCanaryUtils.getLeakDirectoryProvider(activity)
               if (!leakDirectoryProvider.hasStoragePermission()) {
                 Toast.makeText(
@@ -71,55 +78,52 @@ internal class RenderHeapDumpScreen(
                     Toast.LENGTH_LONG
                 )
                     .show()
-                RenderHeapDumpTask.renderAsync(
-                    resources,
-                    heapDumpFile, 2048, 0, 4
-                ) { bitmap ->
-
-                  AsyncTask.THREAD_POOL_EXECUTOR.execute {
+                executeOnIo {
+                  val bitmap = HeapDumpRenderer.render(
+                      resources,
+                      heapDumpFile, 2048, 0, 4
+                  )
+                  val storageDir =
+                    Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
 
-                    val storageDir =
-                      Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+                  val imageFile = File(storageDir, "${heapDumpFile.name}.png")
+                  val saved = savePng(imageFile, bitmap)
+                  if (saved) {
+                    CanaryLog.d("Png saved at $imageFile")
+                    imageFile.setReadable(true, false)
+                    val imageUri = FileProvider.getUriForFile(
+                        activity,
+                        "com.squareup.leakcanary.fileprovider." + activity.packageName,
+                        imageFile
+                    )
 
-                    val imageFile = File(storageDir, "${heapDumpFile.name}.png")
-                    val saved = savePng(imageFile, bitmap)
-                    if (saved) {
-                      CanaryLog.d("Png saved at $imageFile")
-                      imageFile.setReadable(true, false)
-                      val imageUri = FileProvider.getUriForFile(
-                          activity,
-                          "com.squareup.leakcanary.fileprovider." + activity.packageName,
-                          imageFile
+                    updateUi {
+                      val intent = Intent(Intent.ACTION_SEND)
+                      intent.type = "image/png"
+                      intent.putExtra(Intent.EXTRA_STREAM, imageUri)
+                      activity.startActivity(
+                          Intent.createChooser(
+                              intent,
+                              resources.getString(
+                                  R.string.leak_canary_share_heap_dump_bitmap_screen_title
+                              )
+                          )
                       )
-                      activity.runOnUiThread {
-                        val intent = Intent(Intent.ACTION_SEND)
-                        intent.type = "image/png"
-                        intent.putExtra(Intent.EXTRA_STREAM, imageUri)
-                        activity.startActivity(
-                            Intent.createChooser(
-                                intent,
-                                resources.getString(
-                                    R.string.leak_canary_share_heap_dump_bitmap_screen_title
-                                )
-                            )
-                        )
-                      }
-                    } else {
-                      activity.runOnUiThread {
-                        Toast.makeText(
-                            context,
-                            R.string.leak_canary_generating_hq_bitmap_toast_failure_notice,
-                            Toast.LENGTH_LONG
-                        )
-                            .show()
-                      }
+                    }
+                  } else {
+                    updateUi {
+                      Toast.makeText(
+                          context,
+                          R.string.leak_canary_generating_hq_bitmap_toast_failure_notice,
+                          Toast.LENGTH_LONG
+                      )
+                          .show()
                     }
                   }
                 }
               }
               true
             }
-
       }
     }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
index d152db062..13603e4ee 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -18,6 +18,7 @@ internal fun <T : Activity> View.activity() = context as T
 
 internal fun View.onCreateOptionsMenu(onCreateOptionsMenu: (Menu) -> Unit) {
   activity<NavigatingActivity>().onCreateOptionsMenu = onCreateOptionsMenu
+  activity.invalidateOptionsMenu()
 }
 
 internal fun View.goTo(screen: Screen) {
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 7c85b3e78..e95253e4d 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -21,14 +21,15 @@
   <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by <a href="https://square.github.io">Square</a>.<br><br>
   We welcome contributions from the community, please do not hesitate to
   <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
+  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
   <string name="leak_canary_class_has_leaked_retaining">%1$s leaked %2$s</string>
   <string name="leak_canary_class_no_leak">%1$s was never GCed but no leak was found</string>
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
   <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked</string>
   <string name="leak_canary_leak_excluded_retaining">[Excluded] %1$s leaked %2$s</string>
-  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
+  <string name="leak_canary_loading_title">Loading</string>
   <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
   <string name="leak_canary_notification_channel">LeakCanary</string>
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
index b8d708ff3..87a017733 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
@@ -16,9 +16,24 @@
 package com.example.leakcanary
 
 import android.app.Application
+import android.os.StrictMode
 import android.view.View
 
 open class ExampleApplication : Application() {
   val leakedViews = mutableListOf<View>()
-}
 
+  override fun onCreate() {
+    super.onCreate()
+    enabledStrictMode()
+  }
+
+  private fun enabledStrictMode() {
+    StrictMode.setThreadPolicy(
+        StrictMode.ThreadPolicy.Builder()
+            .detectAll()
+            .penaltyLog()
+            .penaltyDeath()
+            .build()
+    )
+  }
+}
