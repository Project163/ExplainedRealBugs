diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index eb4ffc4ed..3cb594bc3 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -7,8 +7,6 @@ import shark.LeakTraceObject.LeakingStatus.UNKNOWN
 import shark.LeakTraceReference.ReferenceType.STATIC_FIELD
 import shark.internal.createSHA1Hash
 import java.io.Serializable
-import kotlin.math.ln
-import kotlin.math.pow
 
 /**
  * The best strong reference path from a GC root to the leaking object. "Best" here means the
@@ -98,18 +96,6 @@ data class LeakTrace(
 
   fun toSimplePathString(): String = leakTraceAsString(showLeakingStatus = false)
 
-  // https://stackoverflow.com/a/3758880
-  private fun humanReadableByteCount(
-    bytes: Long,
-    si: Boolean
-  ): String {
-    val unit = if (si) 1000 else 1024
-    if (bytes < unit) return "$bytes B"
-    val exp = (ln(bytes.toDouble()) / ln(unit.toDouble())).toInt()
-    val pre = (if (si) "kMGTPE" else "KMGTPE")[exp - 1] + if (si) "" else "i"
-    return String.format("%.1f %sB", bytes / unit.toDouble().pow(exp.toDouble()), pre)
-  }
-
   private fun leakTraceAsString(showLeakingStatus: Boolean): String {
     var result = """
         ┬───
@@ -119,52 +105,30 @@ data class LeakTrace(
 
     referencePath.forEachIndexed { index, element ->
       val originObject = element.originObject
-      val leakStatus = when (originObject.leakingStatus) {
-        UNKNOWN -> "UNKNOWN"
-        NOT_LEAKING -> "NO (${originObject.leakingStatusReason})"
-        LEAKING -> "YES (${originObject.leakingStatusReason})"
-      }
-
-      /**
-       * When the GC Root is a Java Frame, Shark inserts the corresponding thread as an extra
-       * element in the leaktrace.
-       */
-      val typeName =
-        if (index == 0 && gcRootType == JAVA_FRAME) "thread" else originObject.typeName
-
-      result += "\n├─ ${originObject.className} $typeName"
-      if (showLeakingStatus) {
-        result += "\n│    Leaking: $leakStatus"
-      }
-      if (originObject.retainedHeapByteSize != null) {
-        val humanReadableRetainedHeapSize =
-          humanReadableByteCount(originObject.retainedHeapByteSize.toLong(), si = true)
-        result += "\n│    Retaining $humanReadableRetainedHeapSize in ${originObject.retainedObjectCount} objects"
-      }
-
-      for (label in originObject.labels) {
-        result += "\n│    $label"
-      }
+      result += "\n"
+      result += originObject.toString(
+        firstLinePrefix = "├─ ",
+        additionalLinesPrefix = "│    ",
+        showLeakingStatus = showLeakingStatus,
+        /**
+         * When the GC Root is a Java Frame, Shark inserts the corresponding thread as an extra
+         * element in the leaktrace.
+         */
+        typeName = if (index == 0 && gcRootType == JAVA_FRAME) {
+          "thread"
+        } else {
+          originObject.typeName
+        }
+      )
       result += getNextElementString(this, element, index, showLeakingStatus)
     }
 
     result += "\n"
-    result += "╰→ ${leakingObject.className} ${leakingObject.typeName}"
-    if (showLeakingStatus) {
-      result += "\n$ZERO_WIDTH_SPACE"
-      result += "     Leaking: YES (${leakingObject.leakingStatusReason})"
-    }
-    if (leakingObject.retainedHeapByteSize != null) {
-      result += "\n$ZERO_WIDTH_SPACE"
-      val humanReadableRetainedHeapSize =
-        humanReadableByteCount(leakingObject.retainedHeapByteSize.toLong(), si = true)
-      result += "     Retaining $humanReadableRetainedHeapSize in ${leakingObject.retainedObjectCount} objects"
-    }
-    for (label in leakingObject.labels) {
-      result += "\n$ZERO_WIDTH_SPACE"
-      result += "     $label"
-    }
-
+    result += leakingObject.toString(
+      firstLinePrefix = "╰→ ",
+      additionalLinesPrefix = "$ZERO_WIDTH_SPACE     ",
+      showLeakingStatus = showLeakingStatus
+    )
     return result
   }
 
@@ -235,7 +199,7 @@ data class LeakTrace(
       }
     }
 
-    private const val ZERO_WIDTH_SPACE = '\u200b'
+    internal const val ZERO_WIDTH_SPACE = '\u200b'
     private const val serialVersionUID = -6315725584154386429
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTraceObject.kt b/shark/src/main/java/shark/LeakTraceObject.kt
index 650e1e674..e9c2b7a5a 100644
--- a/shark/src/main/java/shark/LeakTraceObject.kt
+++ b/shark/src/main/java/shark/LeakTraceObject.kt
@@ -1,8 +1,15 @@
 package shark
 
+import shark.LeakTrace.Companion.ZERO_WIDTH_SPACE
+import shark.LeakTraceObject.LeakingStatus
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
 import shark.internal.lastSegment
 import java.io.Serializable
 import java.util.Locale
+import kotlin.math.ln
+import kotlin.math.pow
 
 data class LeakTraceObject(
   val type: ObjectType,
@@ -42,6 +49,41 @@ data class LeakTraceObject(
   val typeName
     get() = type.name.toLowerCase(Locale.US)
 
+  override fun toString(): String {
+    val firstLinePrefix = ""
+    val additionalLinesPrefix = "$ZERO_WIDTH_SPACE  "
+    return toString(firstLinePrefix, additionalLinesPrefix, true)
+  }
+
+  internal fun toString(
+    firstLinePrefix: String,
+    additionalLinesPrefix: String,
+    showLeakingStatus: Boolean,
+    typeName: String = this.typeName
+  ): String {
+    val leakStatus = when (leakingStatus) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO ($leakingStatusReason)"
+      LEAKING -> "YES ($leakingStatusReason)"
+    }
+
+    var result = ""
+    result += "$firstLinePrefix$className $typeName"
+    if (showLeakingStatus) {
+      result += "\n${additionalLinesPrefix}Leaking: $leakStatus"
+    }
+
+    if (retainedHeapByteSize != null) {
+      val humanReadableRetainedHeapSize =
+        humanReadableByteCount(retainedHeapByteSize.toLong())
+      result += "\n${additionalLinesPrefix}Retaining $humanReadableRetainedHeapSize in $retainedObjectCount objects"
+    }
+    for (label in labels) {
+      result += "\n${additionalLinesPrefix}$label"
+    }
+    return result
+  }
+
   enum class ObjectType {
     CLASS,
     ARRAY,
@@ -61,5 +103,14 @@ data class LeakTraceObject(
 
   companion object {
     private const val serialVersionUID = -3616216391305196341L
+
+    // https://stackoverflow.com/a/3758880
+    private fun humanReadableByteCount(bytes: Long): String {
+      val unit = 1000
+      if (bytes < unit) return "$bytes B"
+      val exp = (ln(bytes.toDouble()) / ln(unit.toDouble())).toInt()
+      val pre = "kMGTPE"[exp - 1]
+      return String.format("%.1f %sB", bytes / unit.toDouble().pow(exp.toDouble()), pre)
+    }
   }
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
similarity index 99%
rename from shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
rename to shark/src/test/java/shark/LeakTraceRenderingTest.kt
index 72ba6fdae..01f8a9d1a 100644
--- a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
@@ -12,7 +12,7 @@ import shark.ReferencePattern.StaticFieldPattern
 import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
-class LeakTraceStringRenderingTest {
+class LeakTraceRenderingTest {
 
   @get:Rule
   var testFolder = TemporaryFolder()
diff --git a/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt b/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt
new file mode 100644
index 000000000..6f30cb101
--- /dev/null
+++ b/shark/src/test/java/shark/UnreachableObjectRenderingTest.kt
@@ -0,0 +1,31 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class UnreachableObjectRenderingTest {
+
+  @Test fun `renders unreachable object`() {
+    val heapDump = dump {
+      "com.example.SomeClass" watchedInstance {
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    com.example.SomeClass instance
+    _  Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    _  key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    _  watchDurationMillis = 25000
+    _  retainedDurationMillis = 10000
+        """
+  }
+
+  private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
+    assertThat(unreachableObjects[0].toString()).isEqualTo(
+      expectedString.trimIndent().replace('_', LeakTrace.ZERO_WIDTH_SPACE)
+    )
+  }
+
+}
\ No newline at end of file
