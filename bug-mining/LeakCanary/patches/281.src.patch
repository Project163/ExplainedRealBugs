diff --git a/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt
index f2186c406..a4b69cca9 100644
--- a/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt
+++ b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerWorker.kt
@@ -6,12 +6,14 @@ import androidx.work.Data
 import androidx.work.ForegroundInfo
 import androidx.work.Worker
 import androidx.work.WorkerParameters
-import androidx.work.impl.utils.futures.SettableFuture
 import com.google.common.util.concurrent.ListenableFuture
 import com.squareup.leakcanary.core.R
 import leakcanary.EventListener.Event
 
-internal class HeapAnalyzerWorker(appContext: Context, workerParams: WorkerParameters) :
+internal class HeapAnalyzerWorker(
+  appContext: Context,
+  workerParams: WorkerParameters
+) :
   Worker(appContext, workerParams) {
   override fun doWork(): Result {
     val doneEvent =
@@ -23,7 +25,9 @@ internal class HeapAnalyzerWorker(appContext: Context, workerParams: WorkerParam
   }
 
   override fun getForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
-    return applicationContext.heapAnalysisForegroundInfoAsync()
+    return LazyImmediateFuture {
+      applicationContext.heapAnalysisForegroundInfo()
+    }
   }
 
   companion object {
@@ -36,21 +40,17 @@ internal class HeapAnalyzerWorker(appContext: Context, workerParams: WorkerParam
     inline fun <reified T> Data.asEvent(): T =
       Serializables.fromByteArray<T>(getByteArray(EVENT_BYTES)!!)!!
 
-    fun Context.heapAnalysisForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
-      val infoFuture = SettableFuture.create<ForegroundInfo>()
+    fun Context.heapAnalysisForegroundInfo(): ForegroundInfo {
       val builder = Notification.Builder(this)
         .setContentTitle(getString(R.string.leak_canary_notification_analysing))
         .setContentText("LeakCanary is working.")
         .setProgress(100, 0, true)
       val notification =
         Notifications.buildNotification(this, builder, NotificationType.LEAKCANARY_LOW)
-      infoFuture.set(
-        ForegroundInfo(
-          R.id.leak_canary_notification_analyzing_heap,
-          notification
-        )
+      return ForegroundInfo(
+        R.id.leak_canary_notification_analyzing_heap,
+        notification
       )
-      return infoFuture
     }
   }
 }
diff --git a/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/LazyImmediateFuture.kt b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/LazyImmediateFuture.kt
new file mode 100644
index 000000000..a382748ac
--- /dev/null
+++ b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/LazyImmediateFuture.kt
@@ -0,0 +1,34 @@
+package leakcanary.internal
+
+import com.google.common.util.concurrent.ListenableFuture
+import java.util.concurrent.Executor
+import java.util.concurrent.TimeUnit
+
+internal class LazyImmediateFuture<V>(
+  valueProvider: () -> V
+) : ListenableFuture<V> {
+
+  private val value by lazy {
+    valueProvider()
+  }
+
+  override fun cancel(mayInterruptIfRunning: Boolean) = false
+
+  override fun isCancelled() = false
+
+  override fun isDone() = true
+
+  override fun get() = value
+
+  override fun get(
+    timeout: Long,
+    unit: TimeUnit?
+  ): V = value
+
+  override fun addListener(
+    listener: Runnable,
+    executor: Executor
+  ) {
+    executor.execute(listener)
+  }
+}
diff --git a/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt
index 31223ccfd..d94593897 100644
--- a/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt
+++ b/leakcanary/leakcanary-android-core/src/main/java/leakcanary/internal/RemoteHeapAnalyzerWorker.kt
@@ -9,10 +9,13 @@ import com.google.common.util.concurrent.ListenableFuture
 import leakcanary.BackgroundThreadHeapAnalyzer.heapAnalyzerThreadHandler
 import leakcanary.EventListener.Event.HeapDump
 import leakcanary.internal.HeapAnalyzerWorker.Companion.asEvent
-import leakcanary.internal.HeapAnalyzerWorker.Companion.heapAnalysisForegroundInfoAsync
+import leakcanary.internal.HeapAnalyzerWorker.Companion.heapAnalysisForegroundInfo
 import shark.SharkLog
 
-internal class RemoteHeapAnalyzerWorker(appContext: Context, workerParams: WorkerParameters) :
+internal class RemoteHeapAnalyzerWorker(
+  appContext: Context,
+  workerParams: WorkerParameters
+) :
   RemoteListenableWorker(appContext, workerParams) {
 
   override fun startRemoteWork(): ListenableFuture<Result> {
@@ -37,6 +40,8 @@ internal class RemoteHeapAnalyzerWorker(appContext: Context, workerParams: Worke
   }
 
   override fun getForegroundInfoAsync(): ListenableFuture<ForegroundInfo> {
-    return applicationContext.heapAnalysisForegroundInfoAsync()
+    return LazyImmediateFuture {
+      applicationContext.heapAnalysisForegroundInfo()
+    }
   }
 }
