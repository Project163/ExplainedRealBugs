diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 8f83bfe39..ccd73d413 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -6,8 +6,11 @@ import leakcanary.internal.InternalLeakCanary
 import shark.AndroidMetadataExtractor
 import shark.AndroidObjectInspectors
 import shark.AndroidReferenceMatchers
+import shark.FilteringLeakingObjectFinder
 import shark.HeapAnalysisSuccess
 import shark.IgnoredReferenceMatcher
+import shark.KeyedWeakReferenceFinder
+import shark.LeakingObjectFinder
 import shark.LibraryLeakReferenceMatcher
 import shark.MetadataExtractor
 import shark.ObjectInspector
@@ -137,13 +140,35 @@ object LeakCanary {
     val requestWriteExternalStoragePermission: Boolean = false,
 
     /**
-     * When true, [objectInspectors] are used to find leaks instead of only checking instances
-     * tracked by [KeyedWeakReference]. This leads to finding more leaks and shorter leak traces.
-     * However this also means the same leaking instances will be found in every heap dump for a
-     * given process life.
-     *
-     * Defaults to false.
+     * Finds the objects that are leaking, for which LeakCanary will compute leak traces.
+     *
+     * Defaults to [KeyedWeakReferenceFinder] which finds all objects tracked by a
+     * [KeyedWeakReference], ie all objects that were passed to [ObjectWatcher.watch].
+     *
+     * You could instead replace it with a [FilteringLeakingObjectFinder], which scans all objects
+     * in the heap dump and delegates the decision to a list of
+     * [FilteringLeakingObjectFinder.LeakingObjectFilter]. This can lead to finding more leaks
+     * than the default and shorter leak traces. This also means that every analysis during a
+     * given process life will bring up the same leaking objects over and over again, unlike
+     * when using [KeyedWeakReferenceFinder] (because [KeyedWeakReference] instances are cleared
+     * after each heap dump).
+     *
+     * The list of filters can be built from [AndroidObjectInspectors]:
+     *
+     * ```
+     * LeakCanary.config = LeakCanary.config.copy(
+     *     leakingObjectFinder = FilteringLeakingObjectFinder(
+     *         AndroidObjectInspectors.appLeakingObjectFilters
+     *     )
+     * )
+     * ```
+     */
+    val leakingObjectFinder: LeakingObjectFinder = KeyedWeakReferenceFinder,
+
+    /**
+     * Deprecated: This is a no-op, set a custom [leakingObjectFinder] instead.
      */
+    @Deprecated("This is a no-op, set a custom leakingObjectFinder instead")
     val useExperimentalLeakFinders: Boolean = false
   )
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 1f35376c2..282697e6a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -26,7 +26,6 @@ import shark.HeapAnalysis
 import shark.HeapAnalysisException
 import shark.HeapAnalysisFailure
 import shark.HeapAnalyzer
-import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
 import shark.OnAnalysisProgressListener
 import shark.OnAnalysisProgressListener.Step.REPORTING_HEAP_ANALYSIS
 import shark.ProguardMappingReader
@@ -77,12 +76,10 @@ internal class HeapAnalyzerService : ForegroundService(
     }
     return heapAnalyzer.analyze(
         heapDumpFile = heapDumpFile,
+        leakingObjectFinder = config.leakingObjectFinder,
         referenceMatchers = config.referenceMatchers,
         computeRetainedHeapSize = config.computeRetainedHeapSize,
         objectInspectors = config.objectInspectors,
-        leakFinders = if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
-            KEYED_WEAK_REFERENCE
-        ),
         metadataExtractor = config.metatadaExtractor,
         proguardMapping = proguardMappingReader?.readProguardMapping()
     )
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
index 6ef224685..ee3831dda 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -7,7 +7,7 @@ import org.junit.Test
 import shark.AndroidObjectInspectors
 import shark.AndroidReferenceMatchers
 import shark.HeapAnalyzer
-import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
+import shark.KeyedWeakReferenceFinder
 import shark.OnAnalysisProgressListener
 import shark.OnAnalysisProgressListener.Step
 import shark.SharkLog
@@ -39,10 +39,10 @@ class ProfiledTest {
     })
     val result = analyzer.analyze(
         heapDumpFile = heapDumpFile,
+        leakingObjectFinder = KeyedWeakReferenceFinder,
         referenceMatchers = AndroidReferenceMatchers.appDefaults,
         objectInspectors = AndroidObjectInspectors.appDefaults,
-        computeRetainedHeapSize = true,
-        leakFinders = listOf(KEYED_WEAK_REFERENCE)
+        computeRetainedHeapSize = true
     )
     SharkLog.d { result.toString() }
     // Giving time to stop CPU profiler (otherwise trace won't succeed)
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 00119392b..deed229b0 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -27,7 +27,6 @@ import shark.HeapAnalysis
 import shark.HeapAnalysisException
 import shark.HeapAnalysisFailure
 import shark.HeapAnalyzer
-import shark.ObjectInspectors
 import shark.SharkLog
 import java.io.File
 
@@ -172,12 +171,11 @@ class InstrumentationLeakDetector {
 
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.analyze(
-        heapDumpFile, config.referenceMatchers,
-        config.computeRetainedHeapSize,
-        config.objectInspectors,
-        if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
-            ObjectInspectors.KEYED_WEAK_REFERENCE
-        )
+        heapDumpFile = heapDumpFile,
+        leakingObjectFinder = config.leakingObjectFinder,
+        referenceMatchers = config.referenceMatchers,
+        computeRetainedHeapSize = config.computeRetainedHeapSize,
+        objectInspectors = config.objectInspectors
     )
 
     SharkLog.d { "Heap Analysis:\n$heapAnalysis" }
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index c6bf56be1..225b6c8d2 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -16,7 +16,9 @@
 package shark
 
 import shark.AndroidObjectInspectors.Companion.appDefaults
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapInstance
+import java.util.EnumSet
 
 /**
  * A set of default [ObjectInspector]s that knows about common AOSP and library
@@ -35,6 +37,15 @@ import shark.HeapObject.HeapInstance
 enum class AndroidObjectInspectors : ObjectInspector {
 
   VIEW {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      if (heapObject is HeapInstance && heapObject instanceOf "android.view.View") {
+        val mContext = heapObject["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
+        val activityContext = mContext.unwrapActivityContext()
+        (activityContext != null &&
+            activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true)
+      } else false
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -66,12 +77,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
         } else {
           if (mParentSet && mWindowAttachCount > 0) {
             if (viewDetached) {
-              likelyLeakingReasons += "View detached and has parent"
+              leakingReasons += "View detached and has parent"
             } else {
               val viewParent = mParentRef.asObject!!.asInstance!!
               if (viewParent instanceOf "android.view.View") {
                 if (viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
-                  likelyLeakingReasons += "View attached but parent ${viewParent.instanceClassName} detached (attach disorder)"
+                  leakingReasons += "View attached but parent ${viewParent.instanceClassName} detached (attach disorder)"
                 } else {
                   notLeakingReasons += "View attached"
                   labels += "View.parent ${viewParent.instanceClassName} attached as well"
@@ -84,32 +95,41 @@ enum class AndroidObjectInspectors : ObjectInspector {
           }
         }
 
-        if (mParentSet) {
-          labels += "View#mParent is set"
+        labels += if (mParentSet) {
+          "View#mParent is set"
         } else {
-          labels += "View#mParent is null"
+          "View#mParent is null"
         }
 
-        if (viewDetached) {
-          labels += "View#mAttachInfo is null (view detached)"
+        labels += if (viewDetached) {
+          "View#mAttachInfo is null (view detached)"
         } else {
-          labels += "View#mAttachInfo is not null (view attached)"
+          "View#mAttachInfo is not null (view attached)"
         }
 
-        AndroidResourceIdNames.readFromHeap(instance.graph)?.let { resIds ->
-         val mID = instance["android.view.View", "mID"]!!.value.asInt!!
-          val noViewId = -1
-          if (mID != noViewId) {
-            val resourceName = resIds[mID]
-            labels += "View.mID = R.id.$resourceName"
-          }
-        }
+        AndroidResourceIdNames.readFromHeap(instance.graph)
+            ?.let { resIds ->
+              val mID = instance["android.view.View", "mID"]!!.value.asInt!!
+              val noViewId = -1
+              if (mID != noViewId) {
+                val resourceName = resIds[mID]
+                labels += "View.mID = R.id.$resourceName"
+              }
+            }
         labels += "View.mWindowAttachCount = $mWindowAttachCount"
       }
     }
   },
 
   EDITOR {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.widget.Editor" &&
+          heapObject["android.widget.Editor", "mTextView"]?.value?.asObject?.let { textView ->
+            VIEW.leakingObjectFilter!!(textView)
+          } ?: false
+    }
+
     override fun inspect(reporter: ObjectReporter) {
       reporter.whenInstanceOf("android.widget.Editor") { instance ->
         applyFromField(VIEW, instance["android.widget.Editor", "mTextView"])
@@ -118,6 +138,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   ACTIVITY {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.app.Activity" &&
+          heapObject["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -139,6 +165,14 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   CONTEXT_WRAPPER {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.app.Activity" &&
+          heapObject.unwrapActivityContext()
+              ?.get("android.app.Activity", "mDestroyed")?.value?.asBoolean == true
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -166,6 +200,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   DIALOG {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.app.Dialog" &&
+          heapObject["android.app.Dialog", "mDecor"]!!.value.isNullReference
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -201,6 +241,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   FRAGMENT {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.app.Fragment" &&
+          heapObject["android.app.Fragment", "mFragmentManager"]!!.value.isNullReference
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -220,6 +266,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   SUPPORT_FRAGMENT {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.support.v4.app.Fragment" &&
+          heapObject["android.support.v4.app.Fragment", "mFragmentManager"]!!.value.isNullReference
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -239,6 +292,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   ANDROIDX_FRAGMENT {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "androidx.fragment.app.Fragment" &&
+          heapObject["androidx.fragment.app.Fragment", "mFragmentManager"]!!.value.isNullReference
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -258,6 +317,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   MESSAGE_QUEUE {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.os.MessageQueue" &&
+          (heapObject["android.os.MessageQueue", "mQuitting"]
+              ?: heapObject["android.os.MessageQueue", "mQuiting"]!!).value.asBoolean!!
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -276,6 +342,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   MORTAR_PRESENTER {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "mortar.Presenter" &&
+          heapObject["mortar.Presenter", "view"]!!.value.isNullReference
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -294,6 +366,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   MORTAR_SCOPE {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "mortar.MortarScope" &&
+          heapObject["mortar.MortarScope", "dead"]!!.value.asBoolean!!
+    }
+
     override fun inspect(reporter: ObjectReporter) {
       reporter.whenInstanceOf("mortar.MortarScope") { instance ->
         val dead = instance["mortar.MortarScope", "dead"]!!.value.asBoolean!!
@@ -308,6 +386,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   COORDINATOR {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "com.squareup.coordinators.Coordinator" &&
+          !heapObject["com.squareup.coordinators.Coordinator", "attached"]!!.value.asBoolean!!
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -336,6 +420,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   VIEW_ROOT_IMPL {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.view.ViewRootImpl" &&
+          heapObject["android.view.ViewRootImpl", "mView"]!!.value.isNullReference
+    }
+
     override fun inspect(reporter: ObjectReporter) {
       reporter.whenInstanceOf("android.view.ViewRootImpl") { instance ->
         val mViewField = instance["android.view.ViewRootImpl", "mView"]!!
@@ -349,6 +439,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   WINDOW {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      heapObject is HeapInstance &&
+          heapObject instanceOf "android.view.Window" &&
+          heapObject["android.view.Window", "mDestroyed"]!!.value.asBoolean!!
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -365,6 +461,15 @@ enum class AndroidObjectInspectors : ObjectInspector {
   },
 
   TOAST {
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      if (heapObject is HeapInstance && heapObject instanceOf "android.widget.Toast") {
+        val tnInstance =
+          heapObject["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
+        (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference &&
+            tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference)
+      } else false
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
@@ -385,12 +490,30 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   };
 
+  internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
+
   companion object {
     /** @see AndroidObjectInspectors */
     val appDefaults: List<ObjectInspector>
-      get() {
-        return values().toList() + ObjectInspectors.jdkDefaults
-      }
+      get() = ObjectInspectors.jdkDefaults + values()
+
+    /**
+     * Returns a list of [LeakingObjectFilter] suitable for apps.
+     */
+    val appLeakingObjectFilters: List<LeakingObjectFilter> =
+      ObjectInspectors.jdkLeakingObjectFilters +
+          createLeakingObjectFilters(EnumSet.allOf(AndroidObjectInspectors::class.java))
+
+    /**
+     * Creates a list of [LeakingObjectFilter] based on the passed in [AndroidObjectInspectors].
+     */
+    fun createLeakingObjectFilters(inspectors: Set<AndroidObjectInspectors>): List<LeakingObjectFilter> =
+      inspectors.mapNotNull { it.leakingObjectFilter }
+          .map { filter ->
+            object : LeakingObjectFilter {
+              override fun isLeakingObject(heapObject: HeapObject) = filter(heapObject)
+            }
+          }
   }
 }
 
@@ -415,7 +538,6 @@ private fun ObjectReporter.applyFromField(
 
   labels += delegateReporter.labels.map { "$prefix $it" }
   leakingReasons += delegateReporter.leakingReasons.map { "$prefix $it" }
-  likelyLeakingReasons += delegateReporter.likelyLeakingReasons.map { "$prefix $it" }
   notLeakingReasons += delegateReporter.notLeakingReasons.map { "$prefix $it" }
 }
 
@@ -424,7 +546,7 @@ private fun ObjectReporter.applyFromField(
  * returned. Returns null if no activity was found.
  */
 @Suppress("NestedBlockDepth")
-fun HeapInstance.unwrapActivityContext(): HeapInstance? {
+internal fun HeapInstance.unwrapActivityContext(): HeapInstance? {
   if (this instanceOf "android.app.Activity") {
     return this
   }
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index 22e0f66f0..f8f5aeb10 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -2,6 +2,7 @@ package shark
 
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
@@ -143,6 +144,9 @@ class LegacyHprofTest {
     val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
     val analysis = heapAnalyzer.analyze(
         heapDumpFile = hprofFile,
+        leakingObjectFinder = FilteringLeakingObjectFinder(
+            AndroidObjectInspectors.appLeakingObjectFilters
+        ),
         referenceMatchers = AndroidReferenceMatchers.appDefaults,
         computeRetainedHeapSize = false,
         objectInspectors = AndroidObjectInspectors.appDefaults,
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
index 1963436fe..8223b80b4 100644
--- a/shark-cli/src/main/java/shark/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -197,7 +197,7 @@ private fun dumpHeap(
 
   SharkLog.d { "Pulling $heapDumpDevicePath" }
 
-  val pullResult = runCommand(workingDirectory, "adb",  "-s", deviceId, "pull", heapDumpDevicePath)
+  val pullResult = runCommand(workingDirectory, "adb", "-s", deviceId, "pull", heapDumpDevicePath)
   SharkLog.d { pullResult }
   SharkLog.d { "Removing $heapDumpDevicePath" }
 
@@ -244,8 +244,13 @@ private fun analyze(
   val heapAnalyzer = HeapAnalyzer(listener)
   SharkLog.d { "Analyzing heap dump $heapDumpFile" }
   val heapAnalysis = heapAnalyzer.analyze(
-      heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
-      AndroidObjectInspectors.appDefaults,
+      heapDumpFile = heapDumpFile,
+      leakingObjectFinder = FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+      ),
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      computeRetainedHeapSize = true,
+      objectInspectors = AndroidObjectInspectors.appDefaults,
       proguardMapping = proguardMapping
   )
 
diff --git a/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt b/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt
new file mode 100644
index 000000000..1fcebf457
--- /dev/null
+++ b/shark/src/main/java/shark/FilteringLeakingObjectFinder.kt
@@ -0,0 +1,31 @@
+package shark
+
+/**
+ * Finds the objects that are leaking by scanning all objects in the heap dump
+ * and delegating the decision to a list of [FilteringLeakingObjectFinder.LeakingObjectFilter]
+ */
+class FilteringLeakingObjectFinder(private val filters: List<LeakingObjectFilter>) :
+    LeakingObjectFinder {
+
+  /**
+   * Filter to be passed to the [FilteringLeakingObjectFinder] constructor.
+   */
+  interface LeakingObjectFilter {
+    /**
+     * Returns whether the passed in [heapObject] is leaking. This should only return true
+     * when we're 100% sure the passed in [heapObject] should not be in memory anymore.
+     */
+    fun isLeakingObject(heapObject: HeapObject): Boolean
+  }
+
+  override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> {
+    return graph.objects
+        .filter { heapObject ->
+          filters.any { filter ->
+            filter.isLeakingObject(heapObject)
+          }
+        }
+        .map { it.objectId }
+        .toSet()
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 1a74843d9..87fadfb7a 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -66,7 +66,6 @@ class HeapAnalyzer constructor(
 
   private class FindLeakInput(
     val graph: HeapGraph,
-    val leakFinders: List<ObjectInspector>,
     val referenceMatchers: List<ReferenceMatcher>,
     val computeRetainedHeapSize: Boolean,
     val objectInspectors: List<ObjectInspector>
@@ -78,10 +77,10 @@ class HeapAnalyzer constructor(
    */
   fun analyze(
     heapDumpFile: File,
+    leakingObjectFinder: LeakingObjectFinder,
     referenceMatchers: List<ReferenceMatcher> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
     objectInspectors: List<ObjectInspector> = emptyList(),
-    leakFinders: List<ObjectInspector> = objectInspectors,
     metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
     proguardMapping: ProguardMapping? = null
   ): HeapAnalysis {
@@ -104,10 +103,14 @@ class HeapAnalyzer constructor(
             listener.onAnalysisProgress(EXTRACTING_METADATA)
             val metadata = metadataExtractor.extractMetadata(graph)
 
-            val findLeakInput = FindLeakInput(
-                graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
-            )
-            val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
+            listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
+            val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
+
+            val helpers =
+              FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
+
+            val (applicationLeaks, libraryLeaks) = helpers.findLeaks(leakingObjectIds)
+
             return HeapAnalysisSuccess(
                 heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime), metadata,
                 applicationLeaks, libraryLeaks
@@ -121,35 +124,19 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private fun FindLeakInput.findLeaks(): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
-    val leakingInstanceObjectIds = findRetainedObjects()
-
+  private fun FindLeakInput.findLeaks(leakingObjectIds: Set<Long>): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
     val pathFinder = PathFinder(graph, listener, referenceMatchers)
     val pathFindingResults =
-      pathFinder.findPathsFromGcRoots(leakingInstanceObjectIds, computeRetainedHeapSize)
+      pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)
 
     SharkLog.d {
-      "Found ${leakingInstanceObjectIds.size} retained objects" +
+      "Found ${leakingObjectIds.size} retained objects" +
           " and ${pathFindingResults.pathsToLeakingObjects.size} paths."
     }
 
     return buildLeakTraces(pathFindingResults)
   }
 
-  private fun FindLeakInput.findRetainedObjects(): Set<Long> {
-    listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
-    return graph.objects
-        .filter { objectRecord ->
-          val reporter = ObjectReporter(objectRecord)
-          leakFinders.any { inspector ->
-            inspector.inspect(reporter)
-            reporter.leakingReasons.isNotEmpty()
-          }
-        }
-        .map { it.objectId }
-        .toSet()
-  }
-
   internal sealed class TrieNode {
     abstract val objectId: Long
 
@@ -489,7 +476,7 @@ class HeapAnalyzer constructor(
       reason = reporter.notLeakingReasons.joinToString(" and ")
     }
 
-    val leakingReasons = reporter.leakingReasons + reporter.likelyLeakingReasons
+    val leakingReasons = reporter.leakingReasons
     if (leakingReasons.isNotEmpty()) {
       // NOT_LEAKING wins over LEAKING
       if (status == NOT_LEAKING) {
diff --git a/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
new file mode 100644
index 000000000..10fc65802
--- /dev/null
+++ b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
@@ -0,0 +1,48 @@
+package shark
+
+import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
+import shark.internal.KeyedWeakReferenceMirror
+
+/**
+ * Finds all objects tracked by a KeyedWeakReference, ie all objects that were passed to
+ * ObjectWatcher.watch.
+ */
+object KeyedWeakReferenceFinder : LeakingObjectFinder {
+
+  override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> =
+    findKeyedWeakReferences(graph).map { it.referent.value }.toSet()
+
+  internal fun findKeyedWeakReferences(graph: HeapGraph): List<KeyedWeakReferenceMirror> {
+    return graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+      val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
+
+      val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+        null
+      } else {
+        keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+      }
+
+      if (heapDumpUptimeMillis == null) {
+        SharkLog.d {
+          "leakcanary.KeyedWeakReference.heapDumpUptimeMillis field not found, " +
+              "this must be a heap dump from an older version of LeakCanary."
+        }
+      }
+
+      val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+          .filter { instance ->
+            val className = instance.instanceClassName
+            className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+          }
+          .map {
+            KeyedWeakReferenceMirror.fromInstance(
+                it, heapDumpUptimeMillis
+            )
+          }
+          .filter { it.hasReferent }
+          .toList()
+      graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+      addedToContext
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakingObjectFinder.kt b/shark/src/main/java/shark/LeakingObjectFinder.kt
new file mode 100644
index 000000000..c23ee8a42
--- /dev/null
+++ b/shark/src/main/java/shark/LeakingObjectFinder.kt
@@ -0,0 +1,14 @@
+package shark
+
+/**
+ * Finds the objects that are leaking, for which Shark will compute
+ * leak traces.
+ */
+interface LeakingObjectFinder {
+
+  /**
+   * For a given heap graph, returns a set of object ids for the objects that are leaking.
+   */
+  fun findLeakingObjectIds(graph: HeapGraph): Set<Long>
+
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
index 827e1d409..c1c68dd0c 100644
--- a/shark/src/main/java/shark/ObjectInspectors.kt
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -15,9 +15,10 @@
  */
 package shark
 
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
-import shark.internal.KeyedWeakReferenceMirror
+import java.util.EnumSet
 
 /**
  * A set of default [ObjectInspector]s that knows about common JDK objects.
@@ -25,38 +26,19 @@ import shark.internal.KeyedWeakReferenceMirror
 enum class ObjectInspectors : ObjectInspector {
 
   KEYED_WEAK_REFERENCE {
+
+    override val leakingObjectFilter = { heapObject: HeapObject ->
+      KeyedWeakReferenceFinder.findKeyedWeakReferences(heapObject.graph)
+          .any { reference ->
+            reference.referent.value == heapObject.objectId
+          }
+    }
+
     override fun inspect(
       reporter: ObjectReporter
     ) {
       val graph = reporter.heapObject.graph
-      val references: List<KeyedWeakReferenceMirror> =
-        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
-          val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
-
-          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-            null
-          } else {
-            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
-          }
-
-          if (heapDumpUptimeMillis == null) {
-            SharkLog.d {
-                "leakcanary.KeyedWeakReference.heapDumpUptimeMillis field not found, " +
-                    "this must be a heap dump from an older version of LeakCanary."
-            }
-          }
-
-          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
-              .filter { instance ->
-                val className = instance.instanceClassName
-                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
-              }
-              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
-              .filter { it.hasReferent }
-              .toList()
-          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
-          addedToContext
-        }
+      val references = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)
 
       val objectId = reporter.heapObject.objectId
       references.forEach { ref ->
@@ -142,6 +124,8 @@ enum class ObjectInspectors : ObjectInspector {
     }
   };
 
+  internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
+
   companion object {
     private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
     private val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
@@ -150,5 +134,22 @@ enum class ObjectInspectors : ObjectInspector {
       get() {
         return values().toList()
       }
+
+    /**
+     * Returns a list of [LeakingObjectFilter] suitable for common JDK projects.
+     */
+    val jdkLeakingObjectFilters: List<LeakingObjectFilter> =
+      createLeakingObjectFilters(EnumSet.allOf(ObjectInspectors::class.java))
+
+    /**
+     * Creates a list of [LeakingObjectFilter] based on the passed in [ObjectInspectors].
+     */
+    fun createLeakingObjectFilters(inspectors: Set<ObjectInspectors>): List<LeakingObjectFilter> =
+      inspectors.mapNotNull { it.leakingObjectFilter }
+          .map { filter ->
+            object : LeakingObjectFilter {
+              override fun isLeakingObject(heapObject: HeapObject) = filter(heapObject)
+            }
+          }
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
index 850d968a9..d13b9d9e2 100644
--- a/shark/src/main/java/shark/ObjectReporter.kt
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -19,17 +19,20 @@ class ObjectReporter constructor(val heapObject: HeapObject) {
 
   /**
    * Reasons for which this object is expected to be unreachable (ie it's leaking).
-   *
-   * Only add reasons to this if you're 100% sure this object is leaking, otherwise add reasons to
-   * [likelyLeakingReasons]. The difference is that objects that are "likely leaking" are not
-   * considered to be leaking objects on which LeakCanary should compute the leak trace.
    */
   val leakingReasons = mutableSetOf<String>()
 
   /**
-   * @see leakingReasons
+   * Deprecated, use leakingReasons instead.
    */
-  val likelyLeakingReasons = mutableSetOf<String>()
+  @Deprecated(
+      "Replace likelyLeakingReasons with leakingReasons",
+      replaceWith = ReplaceWith(
+          "leakingReasons"
+      )
+  )
+  val likelyLeakingReasons
+    get() = leakingReasons
 
   /**
    * Reasons for which this object is expected to be reachable (ie it's not leaking).
diff --git a/shark/src/test/java/shark/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
index 6183afe61..54e14f043 100644
--- a/shark/src/test/java/shark/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -5,6 +5,7 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.LeakNodeStatus.LEAKING
@@ -151,6 +152,10 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakFilters = listOf(object : LeakingObjectFilter {
+            override fun isLeakingObject(heapObject: HeapObject) =
+              heapObject is HeapInstance && heapObject instanceOf "Class1"
+          }),
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
diff --git a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
index 9b67fceb4..a41493a83 100644
--- a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
+++ b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
@@ -5,6 +5,8 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.HeapObject.HeapInstance
 import shark.ReferencePattern.InstanceFieldPattern
 import java.io.File
 
@@ -98,6 +100,10 @@ class LeakTraceStringRenderingTest {
               }
             }
           })
+          , leakFilters = listOf(object : LeakingObjectFilter {
+        override fun isLeakingObject(heapObject: HeapObject) =
+          heapObject is HeapInstance && heapObject instanceOf "ClassB"
+      })
       )
 
     analysis renders """
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
index 491871ffb..3428a9419 100644
--- a/shark/src/test/java/shark/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -1,5 +1,6 @@
 package shark
 
+import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
 import java.io.File
@@ -13,7 +14,8 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   computeRetainedHeapSize: Boolean = false,
   referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
   metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
-  proguardMapping: ProguardMapping? = null
+  proguardMapping: ProguardMapping? = null,
+  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters
 ): T {
   val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
     objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
@@ -23,10 +25,11 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
   val result = heapAnalyzer.analyze(
       heapDumpFile = this,
+      leakingObjectFinder = FilteringLeakingObjectFinder(leakFilters),
       referenceMatchers = referenceMatchers,
       computeRetainedHeapSize = computeRetainedHeapSize,
       objectInspectors = inspectors,
-      metadataExtractor =  metadataExtractor,
+      metadataExtractor = metadataExtractor,
       proguardMapping = proguardMapping
   )
   if (result is HeapAnalysisFailure) {
