diff --git a/shark-android/src/test/java/shark/HprofIOPerfTest.kt b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
index 8c83cbbd8..30a299a5b 100644
--- a/shark-android/src/test/java/shark/HprofIOPerfTest.kt
+++ b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
@@ -180,7 +180,7 @@ class HprofIOPerfTest {
     )
       .isEqualTo(
         listOf(
-          25752, 40.0, 1308325, 25757, 40.0, 1308505
+          25760, 40.0, 1309045, 25765, 40.0, 1309225
         )
       )
   }
@@ -198,7 +198,7 @@ class HprofIOPerfTest {
     )
       .isEqualTo(
         listOf(
-          22489, 40.0, 2203274, 22494, 40.0, 2203454
+          22493, 40.0, 2203818, 22498, 40.0, 2203998
         )
       )
   }
@@ -216,7 +216,7 @@ class HprofIOPerfTest {
     )
       .isEqualTo(
         listOf(
-          16888, 32.0, 768676, 16890, 32.0, 768740
+          16889, 32.0, 768692, 16891, 32.0, 768756
         )
       )
   }
diff --git a/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt b/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt
index 468559e12..9c07b384f 100644
--- a/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt
+++ b/shark/src/main/java/shark/internal/AndroidReferenceReaders.kt
@@ -162,9 +162,45 @@ internal enum class AndroidReferenceReaders : OptionalFactory {
         }
       }
     }
-  };
+  },
+
+  ARRAY_SET {
+    override fun create(graph: HeapGraph): VirtualInstanceReferenceReader? {
+      val arraySetClassId = graph.findClassByName(ARRAY_SET_CLASS_NAME)?.objectId ?:return null
+
+      return object : VirtualInstanceReferenceReader {
+        override fun matches(instance: HeapInstance) = instance.instanceClassId == arraySetClassId
+
+        override fun read(source: HeapInstance): Sequence<Reference> {
+          val mArray = source[ARRAY_SET_CLASS_NAME, "mArray"]!!.valueAsObjectArray!!
+          val locationClassObjectId = source.instanceClassId
+          return mArray.readElements()
+            .filter { it.isNonNullReference }
+            .map { reference ->
+              Reference(
+                valueObjectId = reference.asNonNullObjectId!!,
+                isLowPriority = false,
+                lazyDetailsResolver = {
+                  LazyDetails(
+                    name = "element()",
+                    locationClassObjectId = locationClassObjectId,
+                    locationType = ARRAY_ENTRY,
+                    isVirtual = true,
+                    matchedLibraryLeak = null,
+                  )
+                }
+              )
+            }
+        }
+      }
+    }
+  },
+
+  ;
 
   companion object {
+    private const val ARRAY_SET_CLASS_NAME = "android.util.ArraySet"
+
     // Note: not supporting the support lib version of these, which is identical but with an
     // "android" package prefix instead of "androidx".
     private const val SAFE_ITERABLE_MAP_CLASS_NAME = "androidx.arch.core.internal.SafeIterableMap"
diff --git a/shark/src/test/java/shark/LeakTraceRenderingTest.kt b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
index 91aaeba3a..7ebb55e61 100644
--- a/shark/src/test/java/shark/LeakTraceRenderingTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRenderingTest.kt
@@ -103,9 +103,9 @@ class LeakTraceRenderingTest {
               leakingReasons += "because reasons"
             }
           }
-        }), leakFilters = listOf(LeakingObjectFilter { heapObject ->
+        }), leakingObjectFinder = FilteringLeakingObjectFinder(listOf(LeakingObjectFilter { heapObject ->
           heapObject is HeapInstance && heapObject instanceOf "ClassB"
-      })
+      }))
       )
 
     analysis renders """
diff --git a/shark/src/test/java/shark/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
index e58e32534..fe00929ac 100644
--- a/shark/src/test/java/shark/RetainedSizeTest.kt
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -330,10 +330,10 @@ class RetainedSizeTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
       computeRetainedHeapSize = true,
-      leakFilters = listOf(FilteringLeakingObjectFinder.LeakingObjectFilter { heapObject ->
+      leakingObjectFinder = FilteringLeakingObjectFinder(listOf(FilteringLeakingObjectFinder.LeakingObjectFilter { heapObject ->
         heapObject is HeapInstance &&
           heapObject.instanceClassName == Thread::class.java.name
-      })
+      }))
     )
     println(analysis.toString())
     analysis as HeapAnalysisSuccess
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
index e3b7f323f..74bbd0142 100644
--- a/shark/src/test/java/shark/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -1,13 +1,12 @@
 package shark
 
-import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
-import shark.HprofHeapGraph.Companion.openHeapGraph
-import shark.ReferencePattern.InstanceFieldPattern
-import shark.ReferencePattern.JavaLocalPattern
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
 import java.lang.ref.WeakReference
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
 
 fun <T : HeapAnalysis> DualSourceProvider.checkForLeaks(
   objectInspectors: List<ObjectInspector> = emptyList(),
@@ -15,7 +14,7 @@ fun <T : HeapAnalysis> DualSourceProvider.checkForLeaks(
   referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
   metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
   proguardMapping: ProguardMapping? = null,
-  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters,
+  leakingObjectFinder: LeakingObjectFinder = FilteringLeakingObjectFinder(ObjectInspectors.jdkLeakingObjectFilters),
   file: File = File("/no/file")
 ): T {
   val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
@@ -29,7 +28,7 @@ fun <T : HeapAnalysis> DualSourceProvider.checkForLeaks(
     heapAnalyzer.analyze(
       heapDumpFile = file,
       graph = graph,
-      leakingObjectFinder = FilteringLeakingObjectFinder(leakFilters),
+      leakingObjectFinder = leakingObjectFinder,
       referenceMatchers = referenceMatchers,
       computeRetainedHeapSize = computeRetainedHeapSize,
       objectInspectors = inspectors,
@@ -49,11 +48,11 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
   metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
   proguardMapping: ProguardMapping? = null,
-  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters,
+  leakingObjectFinder: LeakingObjectFinder = FilteringLeakingObjectFinder(ObjectInspectors.jdkLeakingObjectFilters),
 ): T {
   return FileSourceProvider(this).checkForLeaks(
     objectInspectors, computeRetainedHeapSize, referenceMatchers, metadataExtractor,
-    proguardMapping, leakFilters, this
+    proguardMapping, leakingObjectFinder, this
   )
 }
 
diff --git a/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt b/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt
index 128ed44ab..62d7a097f 100644
--- a/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt
+++ b/shark/src/test/java/shark/internal/AndroidReferenceReadersHprofTest.kt
@@ -3,9 +3,20 @@ package shark.internal
 import java.io.File
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import shark.FilteringLeakingObjectFinder
 import shark.HeapAnalysisSuccess
+import shark.HeapGraph
+import shark.HeapObject
+import shark.HeapObject.HeapInstance
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.IgnoredReferenceMatcher
 import shark.LeakTraceReference.ReferenceType.ARRAY_ENTRY
+import shark.LeakingObjectFinder
+import shark.ReferenceMatcher
+import shark.ReferencePattern.StaticFieldPattern
 import shark.checkForLeaks
+import shark.defaultReferenceMatchers
+import shark.internal.AndroidReferenceReaders.Companion
 
 class AndroidReferenceReadersHprofTest {
 
@@ -30,6 +41,57 @@ class AndroidReferenceReadersHprofTest {
     assertThat(mapReference.referenceName).isEqualTo("\"leaking\"")
     assertThat(mapReference.referenceType).isEqualTo(ARRAY_ENTRY)
   }
+
+  @Test fun `ArraySet traversed as set`() {
+    // This hprof happens to have an ArraySet in it.
+    val hprofFile = "safe_iterable_map.hprof".classpathFile()
+
+    val analysis = hprofFile.checkForFakeArraySetLeak()
+
+    val leakTrace = analysis.applicationLeaks.single().leakTraces.single()
+
+    println(leakTrace)
+
+    val mapReference =
+      leakTrace.referencePath.single { it.owningClassSimpleName == "ArraySet" }
+    assertThat(mapReference.referenceName).isEqualTo("element()")
+    assertThat(mapReference.referenceType).isEqualTo(ARRAY_ENTRY)
+  }
+}
+
+fun File.checkForFakeArraySetLeak(): HeapAnalysisSuccess {
+  val instanceHeldByArraySet =
+    "android.view.accessibility.AccessibilityNodeInfo\$AccessibilityAction"
+
+  class ArraySetFakeLeakingObjectFinder : LeakingObjectFinder {
+    override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> {
+      val arraySetInstances = graph.findClassByName("android.util.ArraySet")!!
+        .instances
+        .map { arraySetInstance ->
+          arraySetInstance to arraySetInstance["android.util.ArraySet", "mArray"]!!
+            .valueAsObjectArray!!
+            .readElements()
+            .filter {
+              it.asObject?.asInstance?.instanceClass?.name == instanceHeldByArraySet
+            }
+            .toList()
+        }
+      val firstElementReferencedByArraySet = arraySetInstances.first { (_, elements) ->
+        elements.isNotEmpty()
+      }.second.first()
+
+      return setOf(firstElementReferencedByArraySet.asObjectId!!)
+    }
+  }
+  return checkForLeaks(
+    referenceMatchers = defaultReferenceMatchers + IgnoredReferenceMatcher(
+      StaticFieldPattern(
+        instanceHeldByArraySet,
+        "ACTION_FOCUS"
+      )
+    ),
+    leakingObjectFinder = ArraySetFakeLeakingObjectFinder()
+  )
 }
 
 fun String.classpathFile(): File {
