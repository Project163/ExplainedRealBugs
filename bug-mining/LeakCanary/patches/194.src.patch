diff --git a/shark-android/src/test/java/shark/HprofIOPerfTest.kt b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
index b58a1905c..4fe756053 100644
--- a/shark-android/src/test/java/shark/HprofIOPerfTest.kt
+++ b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
@@ -181,8 +181,8 @@ class HprofIOPerfTest {
     )
         .isEqualTo(
             listOf(
-                19676, 40.0, 1016798,
-                21115, 40.0, 1074786
+                19704, 40.0, 1029289,
+                21144, 40.0, 1087313
             )
         )
   }
@@ -200,8 +200,8 @@ class HprofIOPerfTest {
     )
         .isEqualTo(
             listOf(
-                17383, 40.0, 1951122,
-                17528, 40.0, 1951862
+                17403, 40.0, 1961113,
+                17548, 40.0, 1961853
             )
         )
   }
@@ -219,8 +219,8 @@ class HprofIOPerfTest {
     )
         .isEqualTo(
             listOf(
-                11767, 32.0, 553258,
-                11838, 32.0, 553626
+                11768, 32.0, 553704,
+                11839, 32.0, 554072
             )
         )
   }
diff --git a/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
index 62109ed5a..df685c4ae 100644
--- a/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
+++ b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
@@ -353,7 +353,7 @@ fun dump(
   block: HprofWriterHelper.() -> Unit
 ): DualSourceProvider {
   val buffer = Buffer()
-  HprofWriterHelper(HprofWriter.openWriterFor(buffer))
+  HprofWriterHelper(HprofWriter.openWriterFor(buffer, hprofHeader))
       .use(block)
   return ByteArraySourceProvider(buffer.readByteArray())
 }
diff --git a/shark/api/shark.api b/shark/api/shark.api
index e1e1c1b4b..e4dda71a7 100644
--- a/shark/api/shark.api
+++ b/shark/api/shark.api
@@ -76,8 +76,8 @@ public final class shark/HeapAnalysisFailure$Companion {
 
 public final class shark/HeapAnalysisSuccess : shark/HeapAnalysis {
 	public static final field Companion Lshark/HeapAnalysisSuccess$Companion;
-	public fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;)V
-	public synthetic fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;)V
+	public synthetic fun <init> (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun component1 ()Ljava/io/File;
 	public final fun component2 ()J
 	public final fun component3 ()J
@@ -85,8 +85,9 @@ public final class shark/HeapAnalysisSuccess : shark/HeapAnalysis {
 	public final fun component5 ()Ljava/util/Map;
 	public final fun component6 ()Ljava/util/List;
 	public final fun component7 ()Ljava/util/List;
-	public final fun copy (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;)Lshark/HeapAnalysisSuccess;
-	public static synthetic fun copy$default (Lshark/HeapAnalysisSuccess;Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;ILjava/lang/Object;)Lshark/HeapAnalysisSuccess;
+	public final fun component8 ()Ljava/util/List;
+	public final fun copy (Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;)Lshark/HeapAnalysisSuccess;
+	public static synthetic fun copy$default (Lshark/HeapAnalysisSuccess;Ljava/io/File;JJJLjava/util/Map;Ljava/util/List;Ljava/util/List;Ljava/util/List;ILjava/lang/Object;)Lshark/HeapAnalysisSuccess;
 	public fun equals (Ljava/lang/Object;)Z
 	public final fun getAllLeaks ()Lkotlin/sequences/Sequence;
 	public fun getAnalysisDurationMillis ()J
@@ -96,6 +97,7 @@ public final class shark/HeapAnalysisSuccess : shark/HeapAnalysis {
 	public fun getHeapDumpFile ()Ljava/io/File;
 	public final fun getLibraryLeaks ()Ljava/util/List;
 	public final fun getMetadata ()Ljava/util/Map;
+	public final fun getUnreachableObjects ()Ljava/util/List;
 	public fun hashCode ()I
 	public fun toString ()Ljava/lang/String;
 }
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
index 415b04be6..4b4854680 100644
--- a/shark/src/main/java/shark/HeapAnalysis.kt
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -92,7 +92,8 @@ data class HeapAnalysisSuccess(
   /**
    * The list of [LibraryLeak] found in the heap dump by [HeapAnalyzer].
    */
-  val libraryLeaks: List<LibraryLeak>
+  val libraryLeaks: List<LibraryLeak>,
+  val unreachableObjects: List<LeakTraceObject>
 ) : HeapAnalysis() {
   /**
    * The list of [Leak] found in the heap dump by [HeapAnalyzer], ie all [applicationLeaks] and
@@ -119,6 +120,13 @@ See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-cat
 ${if (libraryLeaks.isNotEmpty()) "\n" + libraryLeaks.joinToString(
         "\n\n"
     ) + "\n" else ""}====================================
+${unreachableObjects.size} UNREACHABLE OBJECTS
+
+An unreachable object is still in memory but LeakCanary could not find a strong reference path
+from GC roots.
+${if (unreachableObjects.isNotEmpty()) "\n" + unreachableObjects.joinToString(
+        "\n\n"
+    ) + "\n" else ""}====================================
 METADATA
 
 Please include this in bug reports and Stack Overflow questions.
@@ -166,7 +174,8 @@ Heap dump duration: ${if (dumpDurationMillis != DUMP_DURATION_UNKNOWN) "$dumpDur
           analysisDurationMillis = fromV20.analysisDurationMillis,
           metadata = fromV20.metadata,
           applicationLeaks = applicationLeaks,
-          libraryLeaks = libraryLeaks
+          libraryLeaks = libraryLeaks,
+          unreachableObjects = listOf()
       )
     }
   }
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 3993ce4e8..9ff634b99 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -40,6 +40,7 @@ import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
 import shark.internal.AndroidNativeSizeMapper
 import shark.internal.DominatorTree
 import shark.internal.PathFinder
+import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
 import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.LibraryLeakNode
@@ -159,7 +160,7 @@ class HeapAnalyzer constructor(
     listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
     val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
 
-    val (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)
+    val (applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)
 
     return HeapAnalysisSuccess(
         heapDumpFile = heapDumpFile,
@@ -167,16 +168,23 @@ class HeapAnalyzer constructor(
         analysisDurationMillis = since(analysisStartNanoTime),
         metadata = metadata,
         applicationLeaks = applicationLeaks,
-        libraryLeaks = libraryLeaks
+        libraryLeaks = libraryLeaks,
+        unreachableObjects = unreachableObjects
     )
   }
 
-  private fun FindLeakInput.findLeaks(leakingObjectIds: Set<Long>): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+  private data class LeaksAndUnreachableObjects(
+    val applicationLeaks: List<ApplicationLeak>,
+    val libraryLeaks: List<LibraryLeak>,
+    val unreachableObjects: List<LeakTraceObject>
+  )
+
+  private fun FindLeakInput.findLeaks(leakingObjectIds: Set<Long>): LeaksAndUnreachableObjects {
     val pathFinder = PathFinder(graph, listener, referenceMatchers)
     val pathFindingResults =
       pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)
 
-    SharkLog.d { "Found ${leakingObjectIds.size} retained objects" }
+    val unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)
 
     val shortestPaths =
       deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
@@ -189,7 +197,45 @@ class HeapAnalyzer constructor(
       } else {
         null
       }
-    return buildLeakTraces(shortestPaths, inspectedObjectsByPath, retainedSizes)
+    val (applicationLeaks, libraryLeaks) = buildLeakTraces(
+        shortestPaths, inspectedObjectsByPath, retainedSizes
+    )
+    return LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)
+  }
+
+  private fun FindLeakInput.findUnreachableObjects(
+    pathFindingResults: PathFindingResults,
+    leakingObjectIds: Set<Long>
+  ): List<LeakTraceObject> {
+    val reachableLeakingObjectIds =
+      pathFindingResults.pathsToLeakingObjects.map { it.objectId }.toSet()
+
+    val unreachableLeakingObjectIds = leakingObjectIds - reachableLeakingObjectIds
+
+    val unreachableObjectReporters = unreachableLeakingObjectIds.map { objectId ->
+      ObjectReporter(heapObject = graph.findObjectById(objectId))
+    }
+
+    objectInspectors.forEach { inspector ->
+      unreachableObjectReporters.forEach { reporter ->
+        inspector.inspect(reporter)
+      }
+    }
+
+    val unreachableInspectedObjects = unreachableObjectReporters.map { reporter ->
+      val reason = resolveStatus(reporter, leakingWins = true).let { (status, reason) ->
+        when (status) {
+          LEAKING -> reason
+          UNKNOWN -> "This is a leaking object"
+          NOT_LEAKING -> "This is a leaking object. Conflicts with $reason"
+        }
+      }
+      InspectedObject(
+          reporter.heapObject, LEAKING, reason, reporter.labels
+      )
+    }
+
+    return buildLeakTraceObjects(unreachableInspectedObjects, null)
   }
 
   internal sealed class TrieNode {
diff --git a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
index a6327de83..c3d41d9f7 100644
--- a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
+++ b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
@@ -20,7 +20,8 @@ class HeapAnalysisStringRenderingTest {
   }
 
   @Test fun emptyFile() {
-    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(hprofFile, leakingObjectFinder = { error("never called") })
 
     analysis renders """
       |====================================
@@ -67,11 +68,15 @@ class HeapAnalysisStringRenderingTest {
       |A Library Leak is a leak caused by a known bug in 3rd party code that you do not have control over.
       |See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks
       |====================================
+      |0 UNREACHABLE OBJECTS
+      |
+      |An unreachable object is still in memory but LeakCanary could not find a strong reference path
+      |from GC roots.
+      |====================================
       |METADATA
       |
       |Please include this in bug reports and Stack Overflow questions.
       |
-      |Stats: .*
       |Analysis duration: \d* ms
       |Heap dump file path: ${hprofFile.absolutePath}
       |Heap dump timestamp: \d*
@@ -110,11 +115,15 @@ class HeapAnalysisStringRenderingTest {
       |A Library Leak is a leak caused by a known bug in 3rd party code that you do not have control over.
       |See https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/#4-categorizing-leaks
       |====================================
+      |0 UNREACHABLE OBJECTS
+      |
+      |An unreachable object is still in memory but LeakCanary could not find a strong reference path
+      |from GC roots.
+      |====================================
       |METADATA
       |
       |Please include this in bug reports and Stack Overflow questions.
       |
-      |Stats: .*
       |Analysis duration: \d* ms
       |Heap dump file path: ${hprofFile.absolutePath}
       |Heap dump timestamp: \d*
diff --git a/shark/src/test/java/shark/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
index 953e08652..28476a7e6 100644
--- a/shark/src/test/java/shark/LabelerTest.kt
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -21,13 +21,9 @@ class LabelerTest {
   @Test fun stringContentAsLabel() {
     hprofFile.writeSinglePathToString("World")
 
-    val labeler = object : ObjectInspector {
-      override fun inspect(
-        reporter: ObjectReporter
-      ) {
-        reporter.whenInstanceOf("java.lang.String") { instance ->
-          labels += "Hello ${instance.readAsJavaString()}"
-        }
+    val labeler = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("java.lang.String") { instance ->
+        labels += "Hello ${instance.readAsJavaString()}"
       }
     }
 
@@ -38,6 +34,23 @@ class LabelerTest {
     assertThat(leakTrace.leakingObject.labels).contains("Hello World")
   }
 
+  @Test fun labelOnUnreachableObject() {
+    val heapDump = dump {
+      "com.example.SomeClass" watchedInstance {
+      }
+    }
+
+    val labeler = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("java.lang.Object") { instance ->
+        labels += instance.instanceClassSimpleName
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
+
+    assertThat(analysis.unreachableObjects[0].labels).contains("SomeClass")
+  }
+
   @Test fun threadNameLabel() {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
diff --git a/shark/src/test/java/shark/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
index ddcca1940..5e1da403a 100644
--- a/shark/src/test/java/shark/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -46,6 +46,17 @@ class LeakStatusTest {
     assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
   }
 
+  @Test fun unreachableInstanceLeaking() {
+    val heapDump = dump {
+      "SomeClass" watchedInstance {
+      }
+    }
+
+    val analysis = heapDump.checkForLeaks<HeapAnalysisSuccess>()
+
+    assertThat(analysis.unreachableObjects[0].leakingStatus).isEqualTo(LEAKING)
+  }
+
   @Test fun defaultsToUnknown() {
     hprofFile.dump {
       "GcRoot" clazz {
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
index 3428a9419..7eee8d356 100644
--- a/shark/src/test/java/shark/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -1,6 +1,7 @@
 package shark
 
 import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.HprofHeapGraph.Companion.openHeapGraph
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
 import java.io.File
@@ -8,14 +9,14 @@ import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
 import java.lang.ref.WeakReference
 
-@Suppress("UNCHECKED_CAST")
-fun <T : HeapAnalysis> File.checkForLeaks(
+fun <T : HeapAnalysis> DualSourceProvider.checkForLeaks(
   objectInspectors: List<ObjectInspector> = emptyList(),
   computeRetainedHeapSize: Boolean = false,
   referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
   metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
   proguardMapping: ProguardMapping? = null,
-  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters
+  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters,
+  file: File = File("/no/file")
 ): T {
   val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
     objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
@@ -23,76 +24,82 @@ fun <T : HeapAnalysis> File.checkForLeaks(
     objectInspectors
   }
   val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
-  val result = heapAnalyzer.analyze(
-      heapDumpFile = this,
+
+  val result = openHeapGraph(proguardMapping).use { graph ->
+    heapAnalyzer.analyze(
+      heapDumpFile = file,
+      graph = graph,
       leakingObjectFinder = FilteringLeakingObjectFinder(leakFilters),
       referenceMatchers = referenceMatchers,
       computeRetainedHeapSize = computeRetainedHeapSize,
       objectInspectors = inspectors,
-      metadataExtractor = metadataExtractor,
-      proguardMapping = proguardMapping
-  )
+      metadataExtractor = metadataExtractor
+    )
+  }
   if (result is HeapAnalysisFailure) {
     println(result)
   }
+  @Suppress("UNCHECKED_CAST")
   return result as T
 }
 
+fun <T : HeapAnalysis> File.checkForLeaks(
+  objectInspectors: List<ObjectInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
+  metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,
+  proguardMapping: ProguardMapping? = null,
+  leakFilters: List<LeakingObjectFilter> = ObjectInspectors.jdkLeakingObjectFilters
+): T {
+  return FileSourceProvider(this).checkForLeaks(
+    objectInspectors, computeRetainedHeapSize, referenceMatchers, metadataExtractor,
+    proguardMapping, leakFilters, this
+  )
+}
+
 val defaultReferenceMatchers: List<ReferenceMatcher> =
   listOf(
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern(SoftReference::class.java.name, "referent")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern(PhantomReference::class.java.name, "referent")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "prev")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "element")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "next")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "prev")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "element")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "next")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("sun.misc.Cleaner", "prev")
-      )
-      ,
-      IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern("sun.misc.Cleaner", "next")
-      )
-      ,
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(SoftReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern(PhantomReference::class.java.name, "referent")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "element")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "next")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "element")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "next")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("sun.misc.Cleaner", "prev")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = InstanceFieldPattern("sun.misc.Cleaner", "next")
+    ),
 
-      IgnoredReferenceMatcher(
-          pattern = JavaLocalPattern("FinalizerWatchdogDaemon")
-      ),
-      IgnoredReferenceMatcher(
-          pattern = JavaLocalPattern("main")
-      )
+    IgnoredReferenceMatcher(
+      pattern = JavaLocalPattern("FinalizerWatchdogDaemon")
+    ),
+    IgnoredReferenceMatcher(
+      pattern = JavaLocalPattern("main")
+    )
   )
\ No newline at end of file
