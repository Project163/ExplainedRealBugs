diff --git a/docs/faq.md b/docs/faq.md
index afb4c4b0c..1fbcd9feb 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -11,7 +11,7 @@ If you find a new one, please [create an issue](https://github.com/square/leakca
 3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
 4. If it's still happening, build a simple repro case.
 5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case.
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+6. Create a PR in LeakCanary to update [AndroidReferenceMatchers](/api/shark-android/shark/-android-reference-matchers/). Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
 
 ## How do I share a leak trace?
 
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 952c7db2e..07085a143 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -10,7 +10,7 @@ For example, an Android activity instance is no longer needed after its `onDestr
 
 Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
 
-* Storing an Activity context as a field in an object that survives activity recreation configuration changes.
+* Storing an Activity context as a field in an object that survives activity recreation due to configuration changes.
 * Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
 * Storing a view in a static field, and not clearing that field when the view is detached.
 
@@ -24,17 +24,17 @@ When we first enabled LeakCanary in the Square Point Of Sale app, we were able t
 
 ### Detecting retained instances
 
-The foundation of LeakCanary is a library called Object Watcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+The foundation of LeakCanary is a library called ObjectWatcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, for example a detached view, a destroyed presenter, etc.
 
 If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
 
 ### Dumping the heap
 
-When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, and 1 retained instance when the app is not visible.
 
 ### Analyzing the heap
 
-LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to retained instances*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
+LeakCanary parses the `.hprof` file using [Shark](shark.md) and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to a retained object*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
 
 ### Grouping leaks
 
@@ -113,7 +113,7 @@ At the top of the leak trace is a garbage-collection (GC) root. GC roots are spe
 is true)
 ```
 
-At the bottom of the leak trace is the leaking instance. This instance was passed to `RefWatcher.watch()` to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
+At the bottom of the leak trace is the leaking instance. This instance was passed to [AppWatcher.objectWatcher](/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/) to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
 
 ### Chain of references
 
@@ -143,17 +143,19 @@ The chain of references from the GC root to the leaking instance is what is prev
     │    View.mWindowAttachCount=1
 ```
 
-LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can customize this behavior and add your own heuristics by updating `LeakCanary.Config.leakTraceInspectors`.
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. LeakCanary comes with a set of default heuristics ([AndroidObjectInspectors](/api/shark-android/shark/-android-object-inspectors/), you can add your own heuristics by updating [LeakCanary.Config.objectInspectors](/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors/).
 
 ### Narrowing down the cause of a leak
 
 ```
     ┬
-    ├─ leakcanary.internal.InternalLeakCanary
-    │    Leaking: NO (it's a GC root and a class is never leaking)
-    │    ↓ static InternalLeakCanary.application
+    ├─ android.provider.FontsContract
+    │    Leaking: NO (ExampleApplication↓ is not leaking and a class is never leaking)
+    │    GC Root: System class
+    │    ↓ static FontsContract.sContext
     ├─ com.example.leakcanary.ExampleApplication
     │    Leaking: NO (Application is a singleton)
+    │    ExampleApplication does not wrap an activity context
     │    ↓ ExampleApplication.leakedViews
     │                         ~~~~~~~~~~~
     ├─ java.util.ArrayList
@@ -162,13 +164,13 @@ LeakCanary runs heuristics to determine the lifecycle state of the nodes of the
     │                ~~~~~~~~~~~
     ├─ java.lang.Object[]
     │    Leaking: UNKNOWN
-    │    ↓ array Object[].[0]
+    │    ↓ array Object[].[1]
     │                     ~~~
     ├─ android.widget.TextView
-    │    Leaking: YES (View detached and has parent)
+    │    Leaking: YES (View.mContext references a destroyed activity)
     │    ↓ TextView.mContext
     ╰→ com.example.leakcanary.MainActivity
-    ​     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)
+    ​     Leaking: YES (TextView↑ is leaking and Activity#mDestroyed is true and ObjectWatcher was watching this)
 ```
 
 If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last `Leaking: NO`	and before the first `Leaking: YES`.
@@ -190,7 +192,7 @@ In this example, the last `Leaking: NO` is on `com.example.leakcanary.ExampleApp
 ...
 ```
 
-Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
+Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
 
 ```
 open class ExampleApplication : Application() {
diff --git a/docs/recipes.md b/docs/recipes.md
index 875686115..68e2d0670 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -2,9 +2,9 @@
 
 If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
 
-## Configuring ObjectWatcher Android
+## Configuring AppWatcher in `object-watcher-android`
 
-ObjectWatcher Android can be configured by replacing `AppWatcher.config`:
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing `AppWatcher.config`:
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
@@ -55,7 +55,7 @@ dependencies {
 
 In your leak reporting code:
 ```kotlin
-val retainedInstanceCount = AppWatcher.objectWatcher.retainedKeys.size
+val retainedInstanceCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
 ## Running LeakCanary in instrumentation tests
@@ -82,7 +82,7 @@ android {
 Run the instrumentation tests:
 
 ```
-./gradlew leakcanary-sample:connectedCheck
+./gradlew leakcanary-android-sample:connectedCheck
 ```
 
 You can extend `FailTestOnLeakRunListener` to customize the behavior.
@@ -121,15 +121,15 @@ You can change the default behavior to upload the analysis result to a server of
 Create a custom `AnalysisResultListener` that delegates to the default: 
 
 ```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     TODO("Upload heap analysis to server")
 
     // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
   }
 }
 ```
@@ -141,57 +141,65 @@ class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+    LeakCanary.config = LeakCanary.config.copy(onHeapAnalyzedListener = LeakUploader())
   }
 }
 ```
 
 
-## Identifying 3rd party leaks as "won't fix"
+## Matching known library leaks
 
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+Set [LeakCanary.Config.referenceMatchers](/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers/) to a list that builds on top of [AndroidReferenceMatchers.appDefaults](/api/shark-android/shark/-android-reference-matchers/app-defaults/):
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
+    LeakCanary.config = LeakCanary.config.copy(
+        referenceMatchers = AndroidReferenceMatchers.appDefaults +
+            AndroidReferenceMatchers.staticFieldLeak(
+                className = "com.samsing.SomeSingleton",
+                fieldName = "sContext",
+                description = "SomeSingleton has a static field leaking a context.",
+                patternApplies = {
+                  manufacturer == "Samsing" && sdkInt == 26
+                }
+            )
+    )
   }
 }
 ```
 
-## Identifying leaking instances and labeling instances
+## Identifying leaking objects and labeling objects
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
+    val addObjectIdLabel = ObjectInspector { reporter ->
+      reporter.addLabel("Heap dump object id is ${reporter.heapObject.objectId}")
     }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
 
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
+    val singletonsInspector =
+      AppSingletonInspector("com.example.MySingleton", "com.example.OtherSingleton")
+
+    val mmvmInspector = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("com.mmvm.SomeViewModel") { instance ->
+        val destroyedField = instance["com.mmvm.SomeViewModel", "destroyed"]!!
+        if (destroyedField.value.asBoolean!!) {
+          reportLeaking("SomeViewModel.destroyed is true")
+        } else {
+          reportNotLeaking("SomeViewModel.destroyed is false")
+        }
       }
     }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
 
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+    LeakCanary.config = LeakCanary.config.copy(
+        objectInspectors = AndroidObjectInspectors.appDefaults +
+            listOf(addObjectIdLabel, singletonsInspector, mmvmInspector)
+    )
   }
 }
 ```
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index 480b67456..93a89c73e 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -15,7 +15,7 @@ dependencies {
 
 ```groovy
 dependencies {
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-1'
 }
 ```
 
@@ -24,8 +24,8 @@ dependencies {
 * The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
   * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
   * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
-* LeakCanary now **depends on AndroidX** instead of the support library.
-* Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.
+* LeakCanary does not depend on the support library anymore, and it doesn't depend on AndroidX either.
+* Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency.
 
 ## Default setup code
 
@@ -61,58 +61,58 @@ There is no more code for default setup.
 ### Before
 
 ```kotlin
-val refWatcher = LeakCanary.installedRefWatcher()
+val refWatcher: RefWatcher = LeakCanary.installedRefWatcher()
 ```
 
 ### Now
 
 ```kotlin
-val refWatcher = LeakSentry.refWatcher
+val objectWatcher: ObjectWatcher = AppWatcher.objectWatcher
 ```
 
 ## Compile errors because RefWatcher is used in release code
 
-If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `RefWatcher` now lives in the `leaksentry` artifact, which is suitable for production. You have two options:
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `ObjectWatcher` now lives in the `object-watcher` artifact, which is suitable for production. You have two options:
 
-### Option 1: Add `leaksentry` to release builds.
+### Option 1: Add `object-watcher-android` to release builds.
 
 ```groovy
 dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  implementation 'com.squareup.leakcanary:object-watcher-android:2.0-beta-1'
 }
 ```
 
-* It will automatically keep weak references on activities, fragments, and any instance you pass to `RefWatcher`.
+* It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to `ObjectWatcher`.
 * It will not trigger heap dumps or anything else that LeakCanary does.
 * It's very little code and should have a no impact on your release app.
-* You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
+* You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes:
 
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedInstanceCount
+val retainedObjectCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
-### Option 2: Make your own `RefWatcher` interface
+### Option 2: Make your own `ObjectWatcher` interface
 
 ```kotlin
 // In shared code
-interface MaybeRefWatcher {
-  fun watch(watchedInstance: Any)
+interface MaybeObjectWatcher {
+  fun watch(watchedObject: Any)
 
-  object None : MaybeRefWatcher {
-    override fun watch(watchedInstance: Any) {
+  object None : MaybeObjectWatcher {
+    override fun watch(watchedObject: Any) {
     }
   }
 }
 
 // In debug code
-class RealRefWatcher : MaybeRefWatcher {
-  override fun watch(watchedInstance: Any) {
-    LeakSentry.refWatcher.watch(watchedInstance)
+class RealObjectWatcher : MaybeObjectWatcher {
+  override fun watch(watchedObject: Any) {
+    AppWatcher.objectWatcher.watch(watchedObject)
   }
 }
 ```
 
-Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.
+Use MaybeObjectWatcher.None in release code and RealObjectWatcher in debug code.
 
 ## Configuring LeakCanary
 
@@ -131,13 +131,14 @@ public class DebugExampleApplication extends ExampleApplication {
 
 ### Now
 
-LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing `AppWatcher.config`:
+
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
   }
 }
 ```
@@ -236,21 +237,36 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 ### Now
 
 ```Kotlin
-LeakCanary.config = LeakCanary.config.copy(
-    analysisResultListener = { application, heapAnalysis ->
-      // TODO Upload result to server
-      DefaultAnalysisResultListener(application, heapAnalysis)
-    }
-)
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
+  }
+}
+
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        onHeapAnalyzedListener = LeakUploader()
+    )
+  }
+}
 ```
 
-### Marking known framework leaks as won't fix
+### Matching known library leaks
 
 ### Before
 
 ```java
 ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-    .instanceField("com.example.ExampleClass", "exampleField")
+    .staticField("com.samsing.SomeSingleton", "sContext")
     .build();
 RefWatcher refWatcher = LeakCanary.refWatcher(this)
   .excludedRefs(excludedRefs)
@@ -262,16 +278,11 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 
 ```kotlin
 LeakCanary.config = LeakCanary.config.copy(
-  exclusionsFactory = { parser ->
-    val build = BuildMirror.readFromHprof(parser)
-    val exclusions =
-      AndroidExcludedRefs.exclusionsMatchingBuild(AndroidExcludedRefs.appDefaults, build)
-          .toMutableList()
-    exclusions += Exclusion(
-        type = InstanceFieldExclusion("com.example.ExampleClass", "exampleField")
-    )
-    exclusions
-  }
+    referenceMatchers = AndroidReferenceMatchers.appDefaults +
+        AndroidReferenceMatchers.staticFieldLeak(
+            "com.samsing.SomeSingleton",
+            "sContext"
+        )
 )
 ```
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index bb7dd5b63..74eec268e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -2,6 +2,7 @@ package leakcanary
 
 import android.app.Application
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
 import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
@@ -71,4 +72,9 @@ class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHe
         LEAKCANARY_RESULT
     )
   }
+
+  companion object {
+    fun create(): OnHeapAnalyzedListener =
+      DefaultOnHeapAnalyzedListener(InternalLeakCanary.application)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index d2174f6d1..43175756b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -5,10 +5,10 @@ import leakcanary.LeakCanary.config
 import leakcanary.internal.InternalLeakCanary
 import shark.AndroidObjectInspectors
 import shark.AndroidReferenceMatchers
-import shark.ObjectInspector
-import shark.ReferenceMatcher
 import shark.IgnoredReferenceMatcher
 import shark.LibraryLeakReferenceMatcher
+import shark.ObjectInspector
+import shark.ReferenceMatcher
 
 /**
  * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
@@ -89,9 +89,7 @@ object LeakCanary {
      *
      * Defaults to [DefaultOnHeapAnalyzedListener]
      */
-    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener(
-        InternalLeakCanary.application
-    ),
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),
 
     /**
      * Whether to compute the retained heap size, which is the total number of bytes in memory that
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index 372697942..01720567a 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -53,7 +53,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
           addLabel("mContext instance of ${mContext.instanceClassName}, not wrapping activity")
         } else {
           val activityDescription =
-            " with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+            "with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
                 ?: "UNKNOWN")
           if (activityContext == mContext) {
             addLabel(
@@ -65,9 +65,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
             )
           }
         }
-
-        addLabel("mContext = ${mContext.instanceClassName}")
-
         if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
           reportLeaking("View.mContext references a destroyed activity")
         } else {
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 28e4bfdab..a25e3376f 100644
--- a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -17,8 +17,6 @@ package shark
 
 import shark.AndroidReferenceMatchers.Companion.appDefaults
 import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
-import shark.IgnoredReferenceMatcher
-import shark.LibraryLeakReferenceMatcher
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
 import shark.ReferencePattern.StaticFieldPattern
@@ -971,7 +969,7 @@ enum class AndroidReferenceMatchers {
     }
   },
 
-  ANDROID_HEAP_DUMPER {
+  LEAK_CANARY_HEAP_DUMPER {
     override fun add(references: MutableList<ReferenceMatcher>) {
       // Holds on to the resumed activity (which is never destroyed), so this will not cause leaks
       // but may surface on the path when a resumed activity holds on to destroyed objects.
@@ -980,6 +978,12 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  LEAK_CANARY_INTERNAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += ignoredInstanceField("leakcanary.internal.InternalLeakCanary", "application")
+    }
+  },
+
   EVENT_RECEIVER__MMESSAGE_QUEUE {
     override fun add(
       references: MutableList<ReferenceMatcher>
