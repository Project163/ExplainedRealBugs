diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
index bc677a779..21cc48ec6 100644
--- a/shark/src/main/java/shark/HeapAnalysis.kt
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -37,7 +37,29 @@ data class HeapAnalysisFailure(
    * An exception wrapping the actual exception that was thrown.
    */
   val exception: HeapAnalysisException
-) : HeapAnalysis()
+) : HeapAnalysis() {
+
+  override fun toString(): String {
+    return """====================================
+HEAP ANALYSIS FAILED
+
+You can report this failure at https://github.com/square/leakcanary/issues
+Please provide the stacktrace, metadata and the heap dump file.
+====================================
+STACKTRACE
+
+$exception====================================
+METADATA
+
+Build.VERSION.SDK_INT: ${androidSdkInt()}
+Build.MANUFACTURER: ${androidManufacturer()}
+LeakCanary version: ${leakCanaryVersion()}
+Analysis duration: $analysisDurationMillis ms
+Heap dump file path: ${heapDumpFile.absolutePath}
+Heap dump timestamp: $createdAtTimeMillis
+===================================="""
+  }
+}
 
 /**
  * The result of a successful heap analysis performed by [HeapAnalyzer].
@@ -62,6 +84,35 @@ data class HeapAnalysisSuccess(
    */
   val allLeaks: List<Leak>
     get() = applicationLeaks + libraryLeaks
+
+  override fun toString(): String {
+    return """====================================
+HEAP ANALYSIS RESULT
+====================================
+${applicationLeaks.size} APPLICATION LEAKS
+
+References underlined with "~~~" are likely causes.
+Learn more at https://squ.re/leaks.
+${if (applicationLeaks.isNotEmpty()) "\n" + applicationLeaks.joinToString(
+        "\n\n"
+    ) + "\n" else ""}====================================
+${libraryLeaks.size} LIBRARY LEAKS
+
+Leaks coming from the Android Framework or Google libraries.
+${if (libraryLeaks.isNotEmpty()) "\n" + libraryLeaks.joinToString(
+        "\n\n"
+    ) + "\n" else ""}====================================
+METADATA
+
+Please include this in bug reports and Stack Overflow questions.
+${if (metadata.isNotEmpty()) "\n" + metadata.map { "${it.key}: ${it.value}" }.joinToString(
+        "\n"
+    ) else ""}
+Analysis duration: $analysisDurationMillis ms
+Heap dump file path: ${heapDumpFile.absolutePath}
+Heap dump timestamp: $createdAtTimeMillis
+===================================="""
+  }
 }
 
 /**
@@ -103,6 +154,10 @@ sealed class Leak : Serializable {
       return if (separator == -1) className else className.substring(separator + 1)
     }
 
+  override fun toString(): String {
+    return if (retainedHeapByteSize != null) "$retainedHeapByteSize bytes retained" else "" + leakTrace
+  }
+
   protected abstract fun createGroupHash(): String
 }
 
@@ -126,6 +181,13 @@ data class LibraryLeak(
   val description: String
 ) : Leak() {
   override fun createGroupHash() = pattern.toString().createSHA1Hash()
+
+  override fun toString(): String {
+    return """Known leak pattern: $pattern
+Description: $description
+${super.toString()}
+"""
+  }
 }
 
 /**
@@ -144,4 +206,40 @@ data class ApplicationLeak(
         }
         .createSHA1Hash()
   }
+
+  // Required to avoid the default toString() from data classes
+  override fun toString(): String {
+    return super.toString()
+  }
+}
+
+private fun androidSdkInt(): Int {
+  return try {
+    val versionClass = Class.forName("android.os.Build\$VERSION")
+    val sdkIntField = versionClass.getDeclaredField("SDK_INT")
+    sdkIntField.get(null) as Int
+  } catch (e: Exception) {
+    -1
+  }
+}
+
+private fun androidManufacturer(): String {
+  return try {
+    val buildClass = Class.forName("android.os.Build")
+    val manufacturerField = buildClass.getDeclaredField("MANUFACTURER")
+    manufacturerField.get(null) as String
+  } catch (e: Exception) {
+    "Unknown"
+  }
+}
+
+private fun leakCanaryVersion(): String {
+  return try {
+    val versionHolderClass = Class.forName("leakcanary.internal.InternalLeakCanary")
+    val versionField = versionHolderClass.getDeclaredField("version")
+    versionField.isAccessible = true
+    versionField.get(null) as String
+  } catch (e: Exception) {
+    "Unknown"
+  }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalysisException.kt b/shark/src/main/java/shark/HeapAnalysisException.kt
index 5a1205a2c..55b835e83 100644
--- a/shark/src/main/java/shark/HeapAnalysisException.kt
+++ b/shark/src/main/java/shark/HeapAnalysisException.kt
@@ -8,6 +8,6 @@ class HeapAnalysisException(cause: Throwable) : RuntimeException(cause) {
   override fun toString(): String {
     val stringWriter = StringWriter()
     cause!!.printStackTrace(PrintWriter(stringWriter))
-    return "\n$stringWriter\n"
+    return stringWriter.toString()
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index 386765fbb..7c0e14278 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -1,9 +1,13 @@
 package shark
 
+import shark.LeakNodeStatus.LEAKING
 import shark.LeakNodeStatus.NOT_LEAKING
 import shark.LeakNodeStatus.UNKNOWN
-import shark.internal.renderToString
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.THREAD
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.io.Serializable
+import java.util.Locale
 
 /**
  * A chain of references that constitute the shortest strong reference path from a GC root to the
@@ -16,10 +20,6 @@ data class LeakTrace(
     elementMayBeLeakCause(index)
   }
 
-  override fun toString(): String {
-    return "\n${renderToString()}\n"
-  }
-
   fun elementMayBeLeakCause(index: Int): Boolean {
     return when (elements[index].leakStatus) {
       UNKNOWN -> true
@@ -31,4 +31,73 @@ data class LeakTrace(
       else -> false
     }
   }
+
+  override fun toString(): String {
+    var result = "┬"
+
+    elements.forEachIndexed { index, element ->
+      val isLast = index == elements.lastIndex
+      val nodePrefix = if (!isLast) {
+        "├─ "
+      } else {
+        "╰→ "
+      }
+      result += "\n" + nodePrefix + element.className
+
+      val contentPrefix = if (!isLast) {
+        "│    "
+      } else {
+        "$ZERO_WIDTH_SPACE     "
+      }
+
+      result += "\n" + contentPrefix + "Leaking: " + when (elements[index].leakStatus) {
+        UNKNOWN -> "UNKNOWN"
+        NOT_LEAKING -> "NO (${elements[index].leakStatusReason})"
+        LEAKING -> "YES (${elements[index].leakStatusReason})"
+      }
+
+      for (label in element.labels) {
+        result += "\n" + contentPrefix + label
+      }
+
+      if (!isLast) {
+        result += "\n$contentPrefix↓ " + getNextElementString(this, element, index)
+      }
+
+    }
+    return result
+  }
+
+  companion object {
+    private fun getNextElementString(
+      leakTrace: LeakTrace,
+      element: LeakTraceElement,
+      index: Int
+    ): String {
+      val maybeLeakCause = leakTrace.elementMayBeLeakCause(index)
+
+      val staticString =
+        if (element.reference != null && element.reference.type == STATIC_FIELD) "static " else ""
+      val holderString =
+        if (element.holder == ARRAY || element.holder == THREAD) {
+          "${element.holder.name.toLowerCase(Locale.US)} "
+        } else ""
+      val simpleClassName = element.classSimpleName
+      val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
+      val requiredSpaces =
+        staticString.length + holderString.length + simpleClassName.length + "├─".length
+      val leakString = if (maybeLeakCause) {
+        "\n│$ELEMENT_DEFAULT_NEW_LINE_SPACE" + " ".repeat(
+            requiredSpaces
+        ) + "~".repeat(referenceName.length - 1)
+      } else {
+        ""
+      }
+
+      return staticString + holderString + simpleClassName + referenceName + leakString
+    }
+
+    private const val ZERO_WIDTH_SPACE = '\u200b'
+    private const val ELEMENT_DEFAULT_NEW_LINE_SPACE = "     "
+  }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/LeakTraceRenderer.kt b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
deleted file mode 100644
index 3603848d6..000000000
--- a/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
+++ /dev/null
@@ -1,78 +0,0 @@
-package shark.internal
-
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
-import shark.LeakTrace
-import shark.LeakTraceElement
-import shark.LeakTraceElement.Holder.ARRAY
-import shark.LeakTraceElement.Holder.THREAD
-import shark.LeakTraceElement.Type.STATIC_FIELD
-import java.util.Locale
-
-internal fun LeakTrace.renderToString(): String {
-  var result = "┬"
-
-  elements.forEachIndexed { index, element ->
-    val isLast = index == elements.lastIndex
-    val nodePrefix = if (!isLast) {
-      "├─ "
-    } else {
-      "╰→ "
-    }
-    result += "\n" + nodePrefix + element.className
-
-    val contentPrefix = if (!isLast) {
-      "│    "
-    } else {
-      "$ZERO_WIDTH_SPACE     "
-    }
-
-    result += "\n" + contentPrefix + "Leaking: " + when (elements[index].leakStatus) {
-      UNKNOWN -> "UNKNOWN"
-      NOT_LEAKING -> "NO (${elements[index].leakStatusReason})"
-      LEAKING -> "YES (${elements[index].leakStatusReason})"
-    }
-
-    for (label in element.labels) {
-      result += "\n" + contentPrefix + label
-    }
-
-    if (!isLast) {
-      result += "\n" + contentPrefix + "↓ " + getNextElementString(this, element, index)
-    }
-
-  }
-  return result
-}
-
-private fun getNextElementString(
-  leakTrace: LeakTrace,
-  element: LeakTraceElement,
-  index: Int
-): String {
-  val maybeLeakCause = leakTrace.elementMayBeLeakCause(index)
-
-  val staticString =
-    if (element.reference != null && element.reference.type == STATIC_FIELD) "static " else ""
-  val holderString =
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      "${element.holder.name.toLowerCase(Locale.US)} "
-    } else ""
-  val simpleClassName = element.classSimpleName
-  val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
-  val requiredSpaces =
-    staticString.length + holderString.length + simpleClassName.length + "├─".length
-  val leakString = if (maybeLeakCause) {
-    "\n│$ELEMENT_DEFAULT_NEW_LINE_SPACE" + " ".repeat(
-        requiredSpaces
-    ) + "~".repeat(referenceName.length - 1)
-  } else {
-    ""
-  }
-
-  return staticString + holderString + simpleClassName + referenceName + leakString
-}
-
-private const val ZERO_WIDTH_SPACE = '\u200b'
-private const val ELEMENT_DEFAULT_NEW_LINE_SPACE = "     "
\ No newline at end of file
diff --git a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
new file mode 100644
index 000000000..ec926b450
--- /dev/null
+++ b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
@@ -0,0 +1,122 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.util.regex.Pattern
+
+class HeapAnalysisStringRenderingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun emptyFile() {
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS FAILED
+      |
+      |You can report this failure at https://github.com/square/leakcanary/issues
+      |Please provide the stacktrace, metadata and the heap dump file.
+      |====================================
+      |STACKTRACE
+      |
+      |java.lang.IllegalArgumentException: Hprof file is 0 byte length
+      |.*
+      |====================================
+      |METADATA
+      |
+      |Build.VERSION.SDK_INT: -1
+      |Build.MANUFACTURER: Unknown
+      |LeakCanary version: Unknown
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |===================================="""
+  }
+
+  @Test fun successNoLeak() {
+    hprofFile.dump {
+      "GcRoot" clazz {}
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS RESULT
+      |====================================
+      |0 APPLICATION LEAKS
+      |
+      |References underlined with "~~~" are likely causes.
+      |Learn more at https://squ.re/leaks.
+      |====================================
+      |0 LIBRARY LEAKS
+      |
+      |Leaks coming from the Android Framework or Google libraries.
+      |====================================
+      |METADATA
+      |
+      |Please include this in bug reports and Stack Overflow questions.
+      |
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |===================================="""
+  }
+
+  @Test fun successWithLeaks() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+
+
+    analysis renders """
+      |====================================
+      |HEAP ANALYSIS RESULT
+      |====================================
+      |1 APPLICATION LEAKS
+      |
+      |References underlined with "~~~" are likely causes.
+      |Learn more at https://squ.re/leaks.
+      |
+      |┬
+      |├─ GcRoot
+      |.*
+      |====================================
+      |0 LIBRARY LEAKS
+      |
+      |Leaks coming from the Android Framework or Google libraries.
+      |====================================
+      |METADATA
+      |
+      |Please include this in bug reports and Stack Overflow questions.
+      |
+      |Analysis duration: \d* ms
+      |Heap dump file path: ${hprofFile.absolutePath}
+      |Heap dump timestamp: \d*
+      |===================================="""
+  }
+
+  private infix fun HeapAnalysis.renders(multilineRegexString: String) {
+    val regex: Pattern =
+      Pattern.compile("^" + multilineRegexString.trimMargin() + "$", Pattern.DOTALL)
+    assertThat(toString()).matches(regex)
+  }
+
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LeakTraceRendererTest.kt b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
similarity index 96%
rename from shark/src/test/java/shark/LeakTraceRendererTest.kt
rename to shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
index a946699b0..6a48e6d46 100644
--- a/shark/src/test/java/shark/LeakTraceRendererTest.kt
+++ b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
@@ -6,10 +6,9 @@ import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import shark.ReferencePattern.InstanceFieldPattern
-import shark.internal.renderToString
 import java.io.File
 
-class LeakTraceRendererTest {
+class LeakTraceStringRenderingTest {
 
   @get:Rule
   var testFolder = TemporaryFolder()
@@ -238,13 +237,13 @@ class LeakTraceRendererTest {
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    assertThat(applicationLeaks[0].leakTrace.renderToString()).isEqualTo(
+    assertThat(applicationLeaks[0].leakTrace.toString()).isEqualTo(
         expectedString.trimIndent()
     )
   }
 
   private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
-    assertThat(libraryLeaks[0].leakTrace.renderToString()).isEqualTo(
+    assertThat(libraryLeaks[0].leakTrace.toString()).isEqualTo(
         expectedString.trimIndent()
     )
   }
