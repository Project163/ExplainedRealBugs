diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
index c4e69faa1..8af5c1c7a 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
@@ -28,8 +28,8 @@ interface HasActivityTestRule<T : Activity> {
 }
 
 inline fun <reified T : Activity> activityTestRule(
-  initialTouchMode: Boolean,
-  launchActivity: Boolean
+  initialTouchMode: Boolean = false,
+  launchActivity: Boolean = true
 ): ActivityTestRule<T> = ActivityTestRule(
   T::class.java, initialTouchMode, launchActivity
 )
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt
new file mode 100644
index 000000000..2d5331e2e
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ObjectInspectorTest.kt
@@ -0,0 +1,47 @@
+package leakcanary
+
+import androidx.lifecycle.LifecycleObserver
+import leakcanary.TestUtils.detectLeaks
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class ObjectInspectorTest : HasActivityTestRule<TestActivity> {
+
+  @get:Rule
+  override val activityRule = activityTestRule<TestActivity>(launchActivity = false)
+
+  @Before fun setUp() {
+    AppWatcher.objectWatcher.clearWatchedObjects()
+  }
+
+  @After fun tearDown() {
+    AppWatcher.objectWatcher.clearWatchedObjects()
+  }
+
+  @Test fun LifecycleRegistry_LeakingStatus_Is_Reported() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+    activity.lifecycle retained {
+      runOnMainSync {
+        val observer = object : LifecycleObserver {}
+        activity.lifecycle.addObserver(observer)
+        AppWatcher.objectWatcher.expectWeaklyReachable(observer, "observer")
+      }
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      Thread.sleep(AppWatcher.retainedDelayMillis)
+
+      val heapAnalysis = detectLeaks()
+
+      val leaktrace = heapAnalysis.allLeaks.single().leakTraces.single()
+      val ref = leaktrace.referencePath.single { it.owningClassSimpleName == "LifecycleRegistry" }
+      val lifecycleRegistry = ref.originObject
+      assertThat(lifecycleRegistry.labels.single()).isEqualTo("mState = DESTROYED")
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
index 86b6f2c11..2e28ebbb0 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -4,18 +4,37 @@ import shark.HeapAnalysis
 import shark.HeapAnalysisSuccess
 
 object TestUtils {
+
   fun assertLeak(expectedLeakClass: Class<*>) {
+    val heapAnalysis = detectLeaks()
+    val applicationLeaks = heapAnalysis.applicationLeaks
+    if (applicationLeaks.size != 1) {
+      throw AssertionError(
+        "Expected exactly one leak in $heapAnalysis"
+      )
+    }
+
+    val leak = applicationLeaks.first()
+
+    val leakTrace = leak.leakTraces.first()
+    val className = leakTrace.leakingObject.className
+    if (className != expectedLeakClass.name) {
+      throw AssertionError(
+        "Expected a leak of $expectedLeakClass, not $className in $heapAnalysis"
+      )
+    }
+  }
+
+  fun detectLeaks(): HeapAnalysisSuccess {
     var heapAnalysisOrNull: HeapAnalysis? = null
     AndroidDetectLeaksAssert { heapAnalysis ->
       heapAnalysisOrNull = heapAnalysis
     }.assertNoLeaks("")
-
     if (heapAnalysisOrNull == null) {
       throw AssertionError(
         "Expected analysis to be performed but skipped"
       )
     }
-
     val heapAnalysis = heapAnalysisOrNull
 
     if (heapAnalysis !is HeapAnalysisSuccess) {
@@ -23,25 +42,8 @@ object TestUtils {
         "Expected analysis success not $heapAnalysis"
       )
     }
-
     // Save disk space on emulator
     heapAnalysis.heapDumpFile.delete()
-
-    val applicationLeaks = heapAnalysis.applicationLeaks
-    if (applicationLeaks.size != 1) {
-      throw AssertionError(
-        "Expected exactly one leak in $heapAnalysis"
-      )
-    }
-
-    val leak = applicationLeaks.first()
-
-    val leakTrace = leak.leakTraces.first()
-    val className = leakTrace.leakingObject.className
-    if (className != expectedLeakClass.name) {
-      throw AssertionError(
-        "Expected a leak of $expectedLeakClass, not $className in $heapAnalysis"
-      )
-    }
+    return heapAnalysis
   }
 }
diff --git a/shark-android/api/shark-android.api b/shark-android/api/shark-android.api
index 4991d9f25..3b3a9c817 100644
--- a/shark-android/api/shark-android.api
+++ b/shark-android/api/shark-android.api
@@ -31,6 +31,7 @@ public abstract class shark/AndroidObjectInspectors : java/lang/Enum, shark/Obje
 	public static final field EDITOR Lshark/AndroidObjectInspectors;
 	public static final field FRAGMENT Lshark/AndroidObjectInspectors;
 	public static final field INPUT_METHOD_MANAGER Lshark/AndroidObjectInspectors;
+	public static final field LIFECYCLE_REGISTRY Lshark/AndroidObjectInspectors;
 	public static final field LOADED_APK Lshark/AndroidObjectInspectors;
 	public static final field MAIN_THREAD Lshark/AndroidObjectInspectors;
 	public static final field MESSAGE Lshark/AndroidObjectInspectors;
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index 43a65ddce..cda50362c 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -837,6 +837,27 @@ enum class AndroidObjectInspectors : ObjectInspector {
       }
     }
   },
+
+  LIFECYCLE_REGISTRY {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.lifecycle.LifecycleRegistry") { instance ->
+        val state = instance.lifecycleRegistryState
+        labels += "mState = $state"
+        // If state is DESTROYED, this doesn't mean the LifecycleRegistry itself is leaking.
+        // Fragment.mViewLifecycleRegistry becomes DESTROYED when the fragment view is destroyed,
+        // but the registry itself is still held in memory by the fragment.
+        if (state != "DESTROYED") {
+          notLeakingReasons += "mState is not DESTROYED"
+        }
+      }
+    }
+
+    private val HeapInstance.lifecycleRegistryState: String
+      get() {
+        val state = this["androidx.lifecycle.LifecycleRegistry", "mState"]!!.valueAsInstance!!
+        return state["java.lang.Enum", "name"]!!.value.readAsJavaString()!!
+      }
+  },
   ;
 
   internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
