diff --git a/.travis.yml b/.travis.yml
index 176714233..ee5ea2c79 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -25,7 +25,6 @@ before_script:
 
 script:
   - ./gradlew leakcanary-android-instrumentation:connectedCheck --stacktrace
-  - ./gradlew leakcanary-support-fragment:connectedCheck --stacktrace
 
 after_success:
   - .buildscript/deploy_snapshot.sh || test true
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 959a0ba2b..b714d1606 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -35,6 +35,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import leaksentry.KeyedWeakReference;
 import org.jetbrains.annotations.TestOnly;
 
 import static com.squareup.leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE;
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
index a66a5f43b..0b10ef998 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
@@ -7,6 +7,7 @@ import com.squareup.leakcanary.LeakTraceElement.Holder.THREAD
 import com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
+import org.junit.Ignore
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
@@ -30,7 +31,7 @@ internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
         .alwaysExclude()
   }
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun leakFound() {
     val result = analyze(heapDumpFile, excludedRefs)
     assertThat(result.leakFound).isTrue()
@@ -41,7 +42,8 @@ internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
     assertThat(gcRoot.extra).contains(ASYNC_TASK_THREAD)
   }
 
-  @Test fun excludeThread() {
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
+  fun excludeThread() {
     excludedRefs.thread(ASYNC_TASK_THREAD)
     val result = analyze(heapDumpFile, excludedRefs)
     assertThat(result.leakFound).isTrue()
@@ -54,7 +56,8 @@ internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
     ).isTrue()
   }
 
-  @Test fun excludeStatic() {
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
+  fun excludeStatic() {
     excludedRefs.thread(ASYNC_TASK_THREAD)
         .named(ASYNC_TASK_THREAD)
     excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1)
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.kt
index a10cef258..54149a812 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.kt
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.kt
@@ -4,6 +4,7 @@ import com.squareup.leakcanary.HeapDumpFile.ASYNC_TASK_P
 import com.squareup.leakcanary.HeapDumpFile.GC_ROOT_IN_NON_PRIMARY_HEAP
 import com.squareup.leakcanary.HeapDumpFile.MISSING_THREAD
 import org.assertj.core.api.Assertions.assertThat
+import org.junit.Ignore
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.JUnit4
@@ -11,7 +12,7 @@ import org.junit.runners.JUnit4
 @RunWith(JUnit4::class)
 class HeapAnalyzerHeapDumpTest {
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun findsExpectedRef() {
     val leak = findLeak(ASYNC_TASK_P)!!
     assertThat(leak.leakFound).isTrue()
@@ -19,19 +20,19 @@ class HeapAnalyzerHeapDumpTest {
     assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun findsSeveralRefs() {
     val results = findAllLeaks(ASYNC_TASK_P)
     assertThat(results).hasSize(3)
   }
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun leakFoundWithGcRootInNonPrimaryHeap() {
     val result = analyze(GC_ROOT_IN_NON_PRIMARY_HEAP)
     assertThat(result.leakFound).isTrue()
   }
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun heapDumpWithMissingNativeThread() {
     val result = analyze(MISSING_THREAD)
     assertThat(result.leakFound).isTrue()
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.kt
index 48668b4ed..9f09ebfd9 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.kt
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.kt
@@ -4,6 +4,7 @@ import com.squareup.leakcanary.HeapDumpFile.ASYNC_TASK_M
 import com.squareup.leakcanary.HeapDumpFile.ASYNC_TASK_O
 import com.squareup.leakcanary.HeapDumpFile.ASYNC_TASK_PRE_M
 import org.assertj.core.api.Assertions.assertThat
+import org.junit.Ignore
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.junit.runners.Parameterized
@@ -17,7 +18,7 @@ internal class RetainedSizeTest(
   val expectedRetainedHeapSize: Long
 ) {
 
-  @Test
+  @Test @Ignore("KeyedWeakReference has moved packages, need new heap dumps")
   fun leakFound() {
     val result = analyze(heapDumpFile)
     assertThat(expectedRetainedHeapSize).isEqualTo(result.retainedHeapSize)
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index 6f046f262..0b07c35ac 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -6,6 +6,12 @@ dependencies {
 
   implementation deps.androidx.test.runner
   implementation deps.kotlin.stdlib
+
+  androidTestImplementation deps.androidx.test.core
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
+  androidTestImplementation deps.androidx.test.runner
+  androidTestImplementation deps.androidx.fragment
 }
 
 android {
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index dc076259b..6cf2fa9aa 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -17,5 +17,6 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.squareup.leakcanary.instrumentation.test">
   <application android:name="com.squareup.leakcanary.InstrumentationTestApplication">
+    <activity android:name="com.squareup.leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/FragmentLeakTest.kt
similarity index 93%
rename from leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/FragmentLeakTest.kt
index 75663f4d3..e0ad21e90 100644
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/FragmentLeakTest.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary.tests
+package com.squareup.leakcanary
 
 import android.app.Activity
 import android.app.Application
@@ -9,10 +9,8 @@ import android.os.MessageQueue
 import android.view.View
 import androidx.test.core.app.ApplicationProvider.getApplicationContext
 import androidx.test.rule.ActivityTestRule
-import com.squareup.leakcanary.InstrumentationLeakDetector
-import com.squareup.leakcanary.InstrumentationLeakResults
-import com.squareup.leakcanary.LeakCanary
-import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter
+import leaksentry.LeakSentry
+import leaksentry.internal.ActivityLifecycleCallbacksAdapter
 import org.junit.After
 import org.junit.Before
 import org.junit.Rule
@@ -25,12 +23,12 @@ class FragmentLeakTest {
   var activityRule = ActivityTestRule(TestActivity::class.java, !TOUCH_MODE, !LAUNCH_ACTIVITY)
 
   @Before fun setUp() {
-    LeakCanary.refWatcher
+    LeakSentry.refWatcher
         .clearWatchedReferences()
   }
 
   @After fun tearDown() {
-    LeakCanary.refWatcher
+    LeakSentry.refWatcher
         .clearWatchedReferences()
   }
 
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/Fragments.kt
similarity index 96%
rename from leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/Fragments.kt
index 687821770..839b68daf 100644
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/Fragments.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/Fragments.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary.tests
+package com.squareup.leakcanary
 
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.kt
index 9ce541a06..fcfb537da 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -1,5 +1,6 @@
 package com.squareup.leakcanary
 
+import leaksentry.LeakSentry
 import org.junit.After
 import org.junit.Before
 import org.junit.Test
@@ -12,18 +13,18 @@ import java.util.Date
 class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
-    LeakCanary.refWatcher
+    LeakSentry.refWatcher
         .clearWatchedReferences()
   }
 
   @After fun tearDown() {
-    LeakCanary.refWatcher
+    LeakSentry.refWatcher
         .clearWatchedReferences()
   }
 
   @Test fun detectsLeak() {
     leaking = Date()
-    val refWatcher = LeakCanary.refWatcher
+    val refWatcher = LeakSentry.refWatcher
     refWatcher.watch(leaking)
 
     val leakDetector = InstrumentationLeakDetector()
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/LeakingFragment.kt
similarity index 93%
rename from leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/LeakingFragment.kt
index 61c5d2ff2..946f24fdd 100644
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/LeakingFragment.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/LeakingFragment.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary.tests
+package com.squareup.leakcanary
 
 import androidx.fragment.app.Fragment
 
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/TestActivity.kt
similarity index 74%
rename from leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/TestActivity.kt
index c056bb3c3..fddc7af4e 100644
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/TestActivity.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/TestActivity.kt
@@ -1,8 +1,8 @@
-package com.squareup.leakcanary.tests
+package com.squareup.leakcanary
 
 import android.os.Bundle
 import androidx.fragment.app.FragmentActivity
-import com.squareup.leakcanary.support.fragment.R
+import com.squareup.leakcanary.instrumentation.test.R
 
 class TestActivity : FragmentActivity() {
   override fun onCreate(savedInstanceState: Bundle?) {
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/ViewLeakingFragment.kt
similarity index 92%
rename from leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/ViewLeakingFragment.kt
index 8c1825964..85a7ba40e 100644
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/ViewLeakingFragment.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/com/squareup/leakcanary/ViewLeakingFragment.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary.tests
+package com.squareup.leakcanary
 
 import android.os.Bundle
 import android.view.LayoutInflater
@@ -6,7 +6,7 @@ import android.view.View
 import android.view.ViewGroup
 import androidx.fragment.app.Fragment
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
-import com.squareup.leakcanary.support.fragment.R
+import com.squareup.leakcanary.instrumentation.test.R
 
 class ViewLeakingFragment : Fragment() {
 
diff --git a/leakcanary-support-fragment/src/main/res/layout/activity_test.xml b/leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
similarity index 100%
rename from leakcanary-support-fragment/src/main/res/layout/activity_test.xml
rename to leakcanary-android-instrumentation/src/androidTest/res/layout/activity_test.xml
diff --git a/leakcanary-android-instrumentation/src/main/AndroidManifest.xml b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
index c500f0572..72e8cd5fe 100644
--- a/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/main/AndroidManifest.xml
@@ -15,7 +15,4 @@
   ~ limitations under the License.
   -->
 <manifest package="com.squareup.leakcanary.instrumentation">
-
-  <application>
-  </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.kt
index 887b93253..2450498fe 100644
--- a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/FailTestOnLeakRunListener.kt
@@ -20,6 +20,7 @@ import android.os.Bundle
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leaksentry.LeakSentry
 import org.junit.runner.Description
 import org.junit.runner.Result
 import org.junit.runner.notification.Failure
@@ -80,10 +81,12 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakCanary.refWatcher.clearWatchedReferences()
+    LeakSentry.refWatcher.clearWatchedReferences()
   }
 
-  override fun testRunStarted(description: Description) {}
+  override fun testRunStarted(description: Description) {
+    InstrumentationLeakDetector.updateConfig()
+  }
 
   override fun testRunFinished(result: Result) {}
 
@@ -124,7 +127,7 @@ open class FailTestOnLeakRunListener : RunListener() {
     detectedLeaks.forEach { detectedLeak ->
       failureMessage.append(
           LeakCanary.leakInfo(
-              context, detectedLeak.heapDump, detectedLeak.analysisResult, true
+              context, detectedLeak.heapDump, detectedLeak.analysisResult, false
           )
       )
       failureMessage.append(SEPARATOR)
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.kt
index 62cd86997..b1b3fdad0 100644
--- a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.kt
@@ -18,6 +18,7 @@ package com.squareup.leakcanary
 import android.os.Debug
 import android.os.SystemClock
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
+import leaksentry.LeakSentry
 import org.junit.runner.notification.RunListener
 import java.io.File
 
@@ -96,21 +97,23 @@ import java.io.File
 class InstrumentationLeakDetector {
 
   fun detectLeaks(): InstrumentationLeakResults {
+    val leakDetectionTime = SystemClock.uptimeMillis()
+    val watchDurationMillis = LeakSentry.config.watchDurationMillis
     val instrumentation = getInstrumentation()
     val context = instrumentation.targetContext
-    val refWatcher = LeakCanary.refWatcher
+    val refWatcher = LeakSentry.refWatcher
 
-    if (refWatcher.isEmpty) {
+    if (!refWatcher.hasWatchedReferences) {
       return InstrumentationLeakResults.NONE
     }
 
     instrumentation.waitForIdleSync()
-    if (refWatcher.isEmpty) {
+    if (!refWatcher.hasWatchedReferences) {
       return InstrumentationLeakResults.NONE
     }
 
     GcTrigger.DEFAULT.runGc()
-    if (refWatcher.isEmpty) {
+    if (!refWatcher.hasWatchedReferences) {
       return InstrumentationLeakResults.NONE
     }
 
@@ -118,7 +121,7 @@ class InstrumentationLeakDetector {
     // Android simply has way too many delayed posts that aren't canceled when views are detached.
     SystemClock.sleep(2000)
 
-    if (refWatcher.isEmpty) {
+    if (!refWatcher.hasWatchedReferences) {
       return InstrumentationLeakResults.NONE
     }
 
@@ -126,16 +129,22 @@ class InstrumentationLeakDetector {
     // 4 seconds (2+2) is greater than the 3 seconds delay for
     // FINISH_TOKEN in android.widget.Filter
     SystemClock.sleep(2000)
+
+    val endOfWatchDelay = watchDurationMillis - (SystemClock.uptimeMillis() - leakDetectionTime)
+    if (endOfWatchDelay > 0) {
+      SystemClock.sleep(endOfWatchDelay)
+    }
+
     GcTrigger.DEFAULT.runGc()
 
-    if (refWatcher.isEmpty) {
+    if (!refWatcher.hasRetainedReferences) {
       return InstrumentationLeakResults.NONE
     }
 
     // We're always reusing the same file since we only execute this once at a time.
     val heapDumpFile = File(context.filesDir, "instrumentation_tests_heapdump.hprof")
 
-    val retainedKeys = refWatcher.allRetainedKeys
+    val retainedKeys = refWatcher.retainedKeys
     HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
     HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
 
@@ -195,9 +204,8 @@ class InstrumentationLeakDetector {
 
     /**
      * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
-     * and we can look for leaks at the end of a test. This should be called from the test
-     * application class, and should be used in combination with a [RunListener] that
-     * calls [detectLeaks], for instance [FailTestOnLeakRunListener].
+     * and we can look for leaks at the end of a test. This is automatically called by
+     * [FailTestOnLeakRunListener] when the tests start running.
      */
     fun updateConfig() {
       LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 249c2db76..89d393063 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'kotlin-android'
 
 dependencies {
   api project(':leakcanary-analyzer')
+  api project(':leakcanary-leaksentry')
 
   implementation deps.androidx.annotation
   implementation deps.androidx.core
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 618ac86ce..defc6f2cf 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -74,8 +74,13 @@
         android:theme="@style/leak_canary_Theme.Transparent"
         />
 
-    <provider
-        android:name=".LeakCanaryInstaller"
-        android:authorities="${applicationId}.leak-canary-installer"/>
+    <receiver android:name="com.squareup.leakcanary.internal.LeakCanaryReceiver">
+      <intent-filter>
+        <action android:name="leaksentry.LeakSentryReceiver.referenceRetained"/>
+      </intent-filter>
+      <intent-filter>
+        <action android:name="leaksentry.LeakSentryReceiver.leakSentryInstalled"/>
+      </intent-filter>
+    </receiver>
   </application>
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index c5a7e79cf..71e6a841c 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -163,7 +163,7 @@ public enum AndroidExcludedRefs {
     }
   },
 
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= P) {
     @Override void add(ExcludedRefs.Builder excluded) {
       excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
           .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 09166d297..45155c5c7 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -30,7 +30,7 @@ import android.view.LayoutInflater;
 import android.widget.Toast;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
-import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter;
+import leaksentry.internal.ActivityLifecycleCallbacksAdapter;
 import com.squareup.leakcanary.internal.FutureResult;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
@@ -40,17 +40,15 @@ import static java.util.concurrent.TimeUnit.SECONDS;
 public final class AndroidHeapDumper implements HeapDumper {
 
   private final Context context;
-  private final RefWatcher refWatcher;
   private final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
   private Activity resumedActivity;
 
   public AndroidHeapDumper(@NonNull Context context,
-      @NonNull LeakDirectoryProvider leakDirectoryProvider, RefWatcher refWatcher) {
+      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
     this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
-    this.refWatcher = refWatcher;
     mainHandler = new Handler(Looper.getMainLooper());
 
     Application application = (Application) context.getApplicationContext();
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java
index ff5afad02..eb9b2c801 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java
@@ -18,7 +18,7 @@ package com.squareup.leakcanary;
 /**
  * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
  * in the reference queue yet. This gives the application a hook to run the GC before the {@link
- * RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
+ * leaksentry.RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
  */
 public interface GcTrigger {
   GcTrigger DEFAULT = new GcTrigger() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
index c6a05d3a1..f71391565 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
@@ -5,6 +5,7 @@ import android.os.Handler
 import android.os.SystemClock
 import com.squareup.leakcanary.LeakCanary.Config
 import com.squareup.leakcanary.internal.registerVisibilityListener
+import leaksentry.RefWatcher
 
 class HeapDumpTrigger(
   private val application: Application,
@@ -21,16 +22,17 @@ class HeapDumpTrigger(
   @Volatile
   var applicationVisible = false
 
-  fun watchForLeaks() {
+  fun registerToVisibilityChanges() {
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
       if (!applicationVisible) {
-        backgroundHandler.post(this@HeapDumpTrigger::tick)
+        scheduleTick()
       }
     }
-    refWatcher.addNewRefListener {
-      scheduleTick(WAIT_FOR_LEAKS_MILLIS)
-    }
+  }
+
+  fun onReferenceRetained() {
+    scheduleTick()
   }
 
   private fun tick() {
@@ -41,7 +43,7 @@ class HeapDumpTrigger(
     }
 
     val minLeaks = if (applicationVisible) MIN_LEAKS_WHEN_VISIBLE else MIN_LEAKS_WHEN_NOT_VISIBLE
-    var retainedKeys = refWatcher.getRetainedKeysOlderThan(WAIT_FOR_LEAKS_MILLIS)
+    var retainedKeys = refWatcher.retainedKeys
     if (retainedKeys.size < minLeaks) {
       // No need to scheduleTick, new refs always schedule one.
       CanaryLog.d(
@@ -72,7 +74,7 @@ class HeapDumpTrigger(
     val gcDurationMillis = SystemClock.uptimeMillis() - gcStartUptimeMillis
 
 
-    retainedKeys = refWatcher.getRetainedKeysOlderThan(WAIT_FOR_LEAKS_MILLIS)
+    retainedKeys = refWatcher.retainedKeys
     if (retainedKeys.size < minLeaks) {
       CanaryLog.d(
           "Found %d potential leaks after GC, which is less than the min of %d", retainedKeys.size,
@@ -108,13 +110,16 @@ class HeapDumpTrigger(
     heapdumpListener.analyze(heapDump)
   }
 
+  private fun scheduleTick() {
+    backgroundHandler.post(this@HeapDumpTrigger::tick)
+  }
+
   private fun scheduleTick(delayMillis: Long) {
     backgroundHandler.postDelayed(this@HeapDumpTrigger::tick, delayMillis)
   }
 
   companion object {
     const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
-    const val WAIT_FOR_LEAKS_MILLIS = 5_000L
     const val WAIT_FOR_PENDING_ANALYSIS_MILLIS = 20_000L
     const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     const val WAIT_FOR_HEAP_DUMPER_MILLIS = 5_000L
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.kt
index 974ae8a68..3b985e115 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.kt
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.kt
@@ -1,15 +1,12 @@
 package com.squareup.leakcanary
 
-import android.app.Application
 import android.content.Context
 import com.squareup.leakcanary.internal.HeapAnalyzerService
+import com.squareup.leakcanary.internal.InternalLeakCanary
 
 object LeakCanary {
 
   data class Config(
-    val watchActivities: Boolean = true,
-    val watchFragments: Boolean = true,
-    val watchFragmentViews: Boolean = true,
     val dumpHeap: Boolean = true,
     val excludedRefs: ExcludedRefs = AndroidExcludedRefs.createAppDefaults().build(),
     val reachabilityInspectorClasses: List<Class<out Reachability.Inspector>> = AndroidReachabilityInspectors.defaultAndroidInspectors(),
@@ -19,29 +16,19 @@ object LeakCanary {
   @Volatile
   var config: Config = Config()
 
-  val refWatcher
-    get() = LeakCanaryInternal.refWatcher
-
   /** Returns a string representation of the result of a heap analysis.  */
   fun leakInfo(
     context: Context,
     heapDump: HeapDump,
     result: AnalysisResult,
     detailed: Boolean
-  ): String = LeakCanaryInternal.leakInfo(context, heapDump, result, detailed)
+  ): String = InternalLeakCanary.leakInfo(context, heapDump, result, detailed)
 
   /**
    * Whether the current process is the process running the [HeapAnalyzerService], which is
    * a different process than the normal app process.
    */
   fun isInAnalyzerProcess(context: Context): Boolean =
-    LeakCanaryInternal.isInAnalyzerProcess(context)
-
-  /**
-   * LeakCanary is automatically installed on process start with [LeakCanaryInstaller] which is
-   * automatically registered in the AndroidManifest.xml of your app. If you disabled
-   * [LeakCanaryInstaller] then you can call this method to install LeakCanary.
-   */
-  fun manualInstall(application: Application) = LeakCanaryInternal.install(application)
+    InternalLeakCanary.isInAnalyzerProcess(context)
 
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java
deleted file mode 100644
index 67e9c0c61..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ActivityLifecycleCallbacksAdapter.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-
-public abstract class ActivityLifecycleCallbacksAdapter
-    implements Application.ActivityLifecycleCallbacks {
-  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-  }
-
-  @Override public void onActivityStarted(Activity activity) {
-  }
-
-  @Override public void onActivityResumed(Activity activity) {
-  }
-
-  @Override public void onActivityPaused(Activity activity) {
-  }
-
-  @Override public void onActivityStopped(Activity activity) {
-  }
-
-  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-  }
-
-  @Override public void onActivityDestroyed(Activity activity) {
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java
deleted file mode 100644
index f732c1f19..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/AndroidOFragmentRefWatcher.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.FragmentManager;
-import android.os.Build;
-import android.view.View;
-import androidx.annotation.RequiresApi;
-import com.squareup.leakcanary.LeakCanary;
-import com.squareup.leakcanary.RefWatcher;
-import kotlin.jvm.functions.Function0;
-
-@RequiresApi(Build.VERSION_CODES.O) //
-class AndroidOFragmentRefWatcher implements FragmentRefWatcher {
-
-  private final RefWatcher refWatcher;
-  private final Function0<LeakCanary.Config> configProvider;
-
-  AndroidOFragmentRefWatcher(RefWatcher refWatcher, Function0<LeakCanary.Config> configProvider) {
-    this.refWatcher = refWatcher;
-    this.configProvider = configProvider;
-  }
-
-  private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks =
-      new FragmentManager.FragmentLifecycleCallbacks() {
-
-        @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {
-          View view = fragment.getView();
-          if (view != null && configProvider.invoke().getWatchFragmentViews()) {
-            refWatcher.watch(view);
-          }
-        }
-
-        @Override
-        public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) {
-          if (configProvider.invoke().getWatchFragments()) {
-            refWatcher.watch(fragment);
-          }
-        }
-      };
-
-  @Override public void watchFragments(Activity activity) {
-    FragmentManager fragmentManager = activity.getFragmentManager();
-    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
deleted file mode 100644
index 24c50466e..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-import com.squareup.leakcanary.LeakCanary;
-import com.squareup.leakcanary.RefWatcher;
-import java.lang.reflect.Constructor;
-import java.util.ArrayList;
-import java.util.List;
-import kotlin.jvm.functions.Function0;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.O;
-
-/**
- * Internal class used to watch for fragments leaks.
- */
-public interface FragmentRefWatcher {
-
-  void watchFragments(Activity activity);
-
-  final class Helper {
-
-    private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =
-        "com.squareup.leakcanary.internal.SupportFragmentRefWatcher";
-
-    public static void install(Application application, RefWatcher refWatcher,
-        Function0<LeakCanary.Config> configProvider) {
-      List<FragmentRefWatcher> fragmentRefWatchers = new ArrayList<>();
-
-      if (SDK_INT >= O) {
-        fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher, configProvider));
-      }
-
-      try {
-        Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
-        Constructor<?> constructor =
-            fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class, Function0.class);
-        FragmentRefWatcher supportFragmentRefWatcher =
-            (FragmentRefWatcher) constructor.newInstance(refWatcher, configProvider);
-        fragmentRefWatchers.add(supportFragmentRefWatcher);
-      } catch (Exception ignored) {
-      }
-
-      if (fragmentRefWatchers.size() == 0) {
-        return;
-      }
-
-      Helper helper = new Helper(fragmentRefWatchers);
-
-      application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);
-    }
-
-    private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =
-        new ActivityLifecycleCallbacksAdapter() {
-          @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-            for (FragmentRefWatcher watcher : fragmentRefWatchers) {
-              watcher.watchFragments(activity);
-            }
-          }
-        };
-
-    private final List<FragmentRefWatcher> fragmentRefWatchers;
-
-    private Helper(List<FragmentRefWatcher> fragmentRefWatchers) {
-      this.fragmentRefWatchers = fragmentRefWatchers;
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInternal.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/InternalLeakCanary.kt
similarity index 74%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInternal.kt
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/InternalLeakCanary.kt
index 979b95563..e6c2246ab 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInternal.kt
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/InternalLeakCanary.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary
+package com.squareup.leakcanary.internal
 
 import android.app.Application
 import android.content.Context
@@ -7,44 +7,34 @@ import android.content.pm.PackageManager
 import android.os.Build
 import android.os.Handler
 import android.os.HandlerThread
-import android.os.Looper
-import android.os.SystemClock
 import android.text.format.Formatter
 import android.util.Log
-import com.squareup.leakcanary.internal.DisplayLeakActivity
-import com.squareup.leakcanary.internal.FragmentRefWatcher
-import com.squareup.leakcanary.internal.HeapAnalyzerService
-import com.squareup.leakcanary.internal.LeakCanaryInternals
-
-internal object LeakCanaryInternal {
-
-  private var installed = false
-
-  private val clock = object : Clock {
-    override fun uptimeMillis(): Long {
-      return SystemClock.uptimeMillis()
-    }
-  }
-
-  val refWatcher = RefWatcher(clock)
-
-  fun install(application: Application) {
-    checkMainThread()
-    if (installed) {
-      throw UnsupportedOperationException("LeakCanary.install() can only be called once")
-    }
-    installed = true
-
+import com.squareup.leakcanary.AnalysisResult
+import com.squareup.leakcanary.AndroidDebuggerControl
+import com.squareup.leakcanary.AndroidHeapDumper
+import com.squareup.leakcanary.BuildConfig
+import com.squareup.leakcanary.DisplayLeakService
+import com.squareup.leakcanary.GcTrigger
+import com.squareup.leakcanary.HeapDump
+import com.squareup.leakcanary.HeapDumpTrigger
+import com.squareup.leakcanary.LeakCanary
+import com.squareup.leakcanary.ServiceHeapDumpListener
+import leaksentry.LeakSentry
+
+internal object InternalLeakCanary {
+
+  private lateinit var heapDumpTrigger: HeapDumpTrigger
+
+  fun onLeakSentryInstalled(application: Application) {
     if (isInAnalyzerProcess(application)) {
       return
     }
-
     val heapDumpListener = ServiceHeapDumpListener(application, DisplayLeakService::class.java)
 
     val debuggerControl = AndroidDebuggerControl()
 
     val leakDirectoryProvider = LeakCanaryInternals.getLeakDirectoryProvider(application)
-    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider, refWatcher)
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
 
     val gcTrigger = GcTrigger.DEFAULT
 
@@ -54,24 +44,17 @@ internal object LeakCanaryInternal {
     handlerThread.start()
     val backgroundHandler = Handler(handlerThread.looper)
 
-    val trigger = HeapDumpTrigger(
-        application, backgroundHandler, debuggerControl, refWatcher, leakDirectoryProvider,
-        gcTrigger, heapDumper,
-        heapDumpListener, configProvider
+    heapDumpTrigger = HeapDumpTrigger(
+        application, backgroundHandler, debuggerControl, LeakSentry.refWatcher,
+        leakDirectoryProvider, gcTrigger, heapDumper, heapDumpListener, configProvider
     )
-
-    trigger.watchForLeaks()
-
+    heapDumpTrigger.registerToVisibilityChanges()
     LeakCanaryInternals.setEnabledAsync(application, DisplayLeakActivity::class.java, true)
-    ActivityRefWatcher.install(application, refWatcher, configProvider)
-    FragmentRefWatcher.Helper.install(application, refWatcher, configProvider)
   }
 
-  private fun checkMainThread() {
-    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
-      throw UnsupportedOperationException(
-          "Should be called from the main thread, not ${Thread.currentThread()}"
-      )
+  fun onReferenceRetained() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onReferenceRetained()
     }
   }
 
@@ -174,6 +157,6 @@ internal object LeakCanaryInternal {
         LeakCanaryInternals.isInServiceProcess(context, HeapAnalyzerService::class.java)
       LeakCanaryInternals.isInAnalyzerProcess = isInAnalyzerProcess
     }
-    return isInAnalyzerProcess!!
+    return isInAnalyzerProcess
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryReceiver.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryReceiver.kt
new file mode 100644
index 000000000..7290df3c4
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryReceiver.kt
@@ -0,0 +1,14 @@
+package com.squareup.leakcanary.internal
+
+import android.app.Application
+import leaksentry.AbstractLeakSentryReceiver
+
+internal class LeakCanaryReceiver : AbstractLeakSentryReceiver() {
+  override fun onLeakSentryInstalled(application: Application) {
+    InternalLeakCanary.onLeakSentryInstalled(application)
+  }
+
+  override fun onReferenceRetained() {
+    InternalLeakCanary.onReferenceRetained()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/VisibilityTracker.kt
index 81e0c6c2d..0d8144c19 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/VisibilityTracker.kt
@@ -2,6 +2,7 @@ package com.squareup.leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
+import leaksentry.internal.ActivityLifecycleCallbacksAdapter
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
@@ -17,7 +18,7 @@ internal class VisibilityTracker(
    */
   private var hasVisibleActivities: Boolean = false
 
-  override fun onActivityStarted(activity: Activity?) {
+  override fun onActivityStarted(activity: Activity) {
     startedActivityCount++
     if (!hasVisibleActivities && startedActivityCount == 1) {
       hasVisibleActivities = true
@@ -26,7 +27,11 @@ internal class VisibilityTracker(
   }
 
   override fun onActivityStopped(activity: Activity) {
-    startedActivityCount--
+    // This could happen if the callbacks were registered after some activities were already
+    // started. In that case we effectively considers those past activities as not visible.
+    if (startedActivityCount > 0) {
+      startedActivityCount--
+    }
     if (hasVisibleActivities && startedActivityCount == 0 && !activity.isChangingConfigurations) {
       hasVisibleActivities = false
       listener.invoke(false)
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-leaksentry/build.gradle
new file mode 100644
index 000000000..dd0f4e90d
--- /dev/null
+++ b/leakcanary-leaksentry/build.gradle
@@ -0,0 +1,32 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-watcher')
+
+  implementation deps.androidx.core
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    check 'Interoperability'
+  }
+
+  // TODO replace with https://issuetracker.google.com/issues/72050365 once released.
+  libraryVariants.all {
+    it.generateBuildConfig.enabled = false
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-leaksentry/gradle.properties b/leakcanary-leaksentry/gradle.properties
new file mode 100644
index 000000000..a0b9bd2c9
--- /dev/null
+++ b/leakcanary-leaksentry/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leaksentry
+POM_NAME=LeakSentry
+POM_PACKAGING=aar
diff --git a/leakcanary-leaksentry/src/main/AndroidManifest.xml b/leakcanary-leaksentry/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..0d8f2c667
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/AndroidManifest.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.squareup.leakcanary.leaksentry"
+    >
+
+  <application>
+    <provider
+        android:name="leaksentry.internal.LeakSentryInstaller"
+        android:authorities="${applicationId}.leak-sentry-installer"
+        android:exported="false"/>
+  </application>
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/AbstractLeakSentryReceiver.kt b/leakcanary-leaksentry/src/main/java/leaksentry/AbstractLeakSentryReceiver.kt
new file mode 100644
index 000000000..e159ca641
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/AbstractLeakSentryReceiver.kt
@@ -0,0 +1,48 @@
+package leaksentry
+
+import android.app.Application
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import leaksentry.internal.InternalLeakSentry
+
+abstract class AbstractLeakSentryReceiver : BroadcastReceiver() {
+
+  final override fun onReceive(
+    context: Context,
+      // Nullable because Android can never be trusted.
+    intent: Intent?
+  ) {
+    when (intent?.action) {
+      LEAK_SENTRY_INSTALLED_INTENT_ACTION -> onLeakSentryInstalled(InternalLeakSentry.application)
+      REFERENCE_RETAINED_INTENT_ACTION -> onReferenceRetained()
+    }
+  }
+
+  abstract fun onLeakSentryInstalled(application: Application)
+
+  abstract fun onReferenceRetained()
+
+  companion object {
+
+    const val REFERENCE_RETAINED_INTENT_ACTION =
+      "leaksentry.AbstractLeakSentryReceiver.referenceRetained"
+    const val LEAK_SENTRY_INSTALLED_INTENT_ACTION =
+      "leaksentry.AbstractLeakSentryReceiver.leakSentryInstalled"
+
+    internal fun sendLeakSentryInstalled() {
+      sendPrivateBroadcast(LEAK_SENTRY_INSTALLED_INTENT_ACTION)
+    }
+
+
+    internal fun sendReferenceRetained() {
+      sendPrivateBroadcast(REFERENCE_RETAINED_INTENT_ACTION)
+    }
+
+    private fun sendPrivateBroadcast(action: String) {
+      val intent = Intent(action)
+      intent.setPackage(InternalLeakSentry.application.packageName)
+      InternalLeakSentry.application.sendBroadcast(intent)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leaksentry/LeakSentry.kt
new file mode 100644
index 000000000..8223b988e
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/LeakSentry.kt
@@ -0,0 +1,30 @@
+package leaksentry
+
+import android.app.Application
+import leaksentry.internal.InternalLeakSentry
+import java.util.concurrent.TimeUnit
+
+object LeakSentry {
+
+  data class Config(
+    val watchActivities: Boolean = true,
+    val watchFragments: Boolean = true,
+    val watchFragmentViews: Boolean = true,
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
+  )
+
+  @Volatile
+  var config: Config = Config()
+
+  val refWatcher
+    get() = InternalLeakSentry.refWatcher
+
+  /**
+   * [LeakSentry] is automatically installed on process start by
+   * [leaksentry.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leaksentry.internal.LeakSentryInstaller] then you can call this
+   * method to install [LeakSentry].
+   */
+  fun manualInstall(application: Application) = InternalLeakSentry.install(application)
+
+}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityDestroyWatcher.kt
similarity index 75%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.kt
rename to leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityDestroyWatcher.kt
index 85928e37e..be9fade6f 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityDestroyWatcher.kt
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary
+package leaksentry.internal
 
 import android.app.Activity
 import android.app.Application
-import com.squareup.leakcanary.LeakCanary.Config
-import com.squareup.leakcanary.internal.ActivityLifecycleCallbacksAdapter
+import leaksentry.RefWatcher
+import leaksentry.LeakSentry.Config
 
-internal class ActivityRefWatcher private constructor(
+internal class ActivityDestroyWatcher private constructor(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
 ) {
@@ -39,8 +39,8 @@ internal class ActivityRefWatcher private constructor(
       refWatcher: RefWatcher,
       configProvider: () -> Config
     ) {
-      val activityRefWatcher = ActivityRefWatcher(refWatcher, configProvider)
-      application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks)
+      val activityDestroyWatcher = ActivityDestroyWatcher(refWatcher, configProvider)
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
     }
   }
 }
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityLifecycleCallbacksAdapter.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityLifecycleCallbacksAdapter.kt
new file mode 100644
index 000000000..9f2917ae3
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/ActivityLifecycleCallbacksAdapter.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leaksentry.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+
+abstract class ActivityLifecycleCallbacksAdapter : Application.ActivityLifecycleCallbacks {
+  override fun onActivityCreated(
+    activity: Activity,
+    savedInstanceState: Bundle?
+  ) {
+  }
+
+  override fun onActivityStarted(activity: Activity) {}
+
+  override fun onActivityResumed(activity: Activity) {}
+
+  override fun onActivityPaused(activity: Activity) {}
+
+  override fun onActivityStopped(activity: Activity) {}
+
+  override fun onActivitySaveInstanceState(
+    activity: Activity,
+    outState: Bundle
+  ) {
+  }
+
+  override fun onActivityDestroyed(activity: Activity) {}
+}
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/AndroidOFragmentDestroyWatcher.kt
new file mode 100644
index 000000000..c8f0a16e5
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/AndroidOFragmentDestroyWatcher.kt
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+@file:Suppress("DEPRECATION")
+
+package leaksentry.internal
+
+import android.app.Activity
+import android.app.Fragment
+import android.app.FragmentManager
+import android.os.Build
+import androidx.annotation.RequiresApi
+import leaksentry.RefWatcher
+import leaksentry.LeakSentry.Config
+
+@RequiresApi(Build.VERSION_CODES.O) //
+internal class AndroidOFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
+
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
+
+  override fun watchFragments(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/FragmentDestroyWatcher.kt
new file mode 100644
index 000000000..fe64231b0
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/FragmentDestroyWatcher.kt
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leaksentry.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.O
+import android.os.Bundle
+import leaksentry.RefWatcher
+import leaksentry.LeakSentry
+
+/**
+ * Internal class used to watch for fragments leaks.
+ */
+internal interface FragmentDestroyWatcher {
+
+  fun watchFragments(activity: Activity)
+
+  companion object {
+
+    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> LeakSentry.Config
+    ) {
+      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+
+      if (SDK_INT >= O) {
+        fragmentDestroyWatchers.add(AndroidOFragmentDestroyWatcher(refWatcher, configProvider))
+      }
+
+      if (classAvailable(SUPPORT_FRAGMENT_CLASS_NAME)) {
+        fragmentDestroyWatchers.add(SupportFragmentDestroyWatcher(refWatcher, configProvider))
+      }
+
+      if (fragmentDestroyWatchers.size == 0) {
+        return
+      }
+
+      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          for (watcher in fragmentDestroyWatchers) {
+            watcher.watchFragments(activity)
+          }
+        }
+      })
+    }
+
+    private fun classAvailable(className: String): Boolean {
+      return try {
+        Class.forName(className)
+        true
+      } catch (e: ClassNotFoundException) {
+        false
+      }
+    }
+  }
+}
diff --git a/leakcanary-leaksentry/src/main/java/leaksentry/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/InternalLeakSentry.kt
new file mode 100644
index 000000000..163ccd6f2
--- /dev/null
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/InternalLeakSentry.kt
@@ -0,0 +1,52 @@
+package leaksentry.internal
+
+import android.app.Application
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import leaksentry.AbstractLeakSentryReceiver
+import leaksentry.Clock
+import leaksentry.LeakSentry
+import leaksentry.RefWatcher
+import java.util.concurrent.Executor
+
+internal object InternalLeakSentry {
+
+  lateinit var application: Application
+
+  private val clock = object : Clock {
+    override fun uptimeMillis(): Long {
+      return SystemClock.uptimeMillis()
+    }
+  }
+
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  private val checkRetainedExecutor = Executor {
+    mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
+  }
+  val refWatcher = RefWatcher(clock, checkRetainedExecutor) {
+    AbstractLeakSentryReceiver.sendReferenceRetained()
+  }
+
+  fun install(application: Application) {
+    checkMainThread()
+    if (this::application.isInitialized) {
+      return
+    }
+    this.application = application
+
+    val configProvider = { LeakSentry.config }
+    ActivityDestroyWatcher.install(application, refWatcher, configProvider)
+    FragmentDestroyWatcher.install(application, refWatcher, configProvider)
+    AbstractLeakSentryReceiver.sendLeakSentryInstalled()
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInstaller.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/LeakSentryInstaller.kt
similarity index 74%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInstaller.kt
rename to leakcanary-leaksentry/src/main/java/leaksentry/internal/LeakSentryInstaller.kt
index 24f8aac55..ad694f661 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanaryInstaller.kt
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/LeakSentryInstaller.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary
+package leaksentry.internal
 
 import android.app.Application
 import android.content.ContentProvider
@@ -7,14 +7,14 @@ import android.database.Cursor
 import android.net.Uri
 
 /**
- * Content providers are loaded before the application class is created. [LeakCanaryInstaller] is
- * used to install LeakCanary on application start.
+ * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
+ * used to install [leaksentry.LeakSentry] on application start.
  */
-internal class LeakCanaryInstaller : ContentProvider() {
+internal class LeakSentryInstaller : ContentProvider() {
 
   override fun onCreate(): Boolean {
-    val application = context.applicationContext as Application
-    LeakCanaryInternal.install(application)
+    val application = context!!.applicationContext as Application
+    InternalLeakSentry.install(application)
     return true
   }
 
diff --git a/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.kt b/leakcanary-leaksentry/src/main/java/leaksentry/internal/SupportFragmentDestroyWatcher.kt
similarity index 82%
rename from leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.kt
rename to leakcanary-leaksentry/src/main/java/leaksentry/internal/SupportFragmentDestroyWatcher.kt
index 71dba2b61..94cad0e7e 100644
--- a/leakcanary-support-fragment/src/main/java/com/squareup/leakcanary/internal/SupportFragmentRefWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leaksentry/internal/SupportFragmentDestroyWatcher.kt
@@ -13,19 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary.internal
+package leaksentry.internal
 
 import android.app.Activity
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
-import com.squareup.leakcanary.LeakCanary.Config
-import com.squareup.leakcanary.RefWatcher
+import leaksentry.RefWatcher
+import leaksentry.LeakSentry.Config
 
-internal class SupportFragmentRefWatcher(
+internal class SupportFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
-) : FragmentRefWatcher {
+) : FragmentDestroyWatcher {
 
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
@@ -33,10 +33,9 @@ internal class SupportFragmentRefWatcher(
       fm: FragmentManager,
       fragment: Fragment
     ) {
-      if (configProvider().watchFragmentViews) {
-        fragment.view?.let {
-          refWatcher.watch(it)
-        }
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
       }
     }
 
diff --git a/leakcanary-sample/src/androidTest/AndroidManifest.xml b/leakcanary-sample/src/androidTest/AndroidManifest.xml
index 902375ba7..d23bb44d0 100644
--- a/leakcanary-sample/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-sample/src/androidTest/AndroidManifest.xml
@@ -15,9 +15,5 @@
   ~ limitations under the License.
   -->
 <manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.squareup.leakcanary.instrumentation.test">
-
-  <application android:name="com.example.leakcanary.tests.InstrumentationExampleApplication">
-  </application>
 </manifest>
diff --git a/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.kt b/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.kt
deleted file mode 100644
index 0b860efb1..000000000
--- a/leakcanary-sample/src/androidTest/java/com/example/leakcanary/tests/InstrumentationExampleApplication.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package com.example.leakcanary.tests
-
-import com.example.leakcanary.ExampleApplication
-import com.squareup.leakcanary.InstrumentationLeakDetector
-
-class InstrumentationExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    InstrumentationLeakDetector.updateConfig()
-  }
-}
diff --git a/leakcanary-support-fragment/build.gradle b/leakcanary-support-fragment/build.gradle
deleted file mode 100644
index 5dfff4f73..000000000
--- a/leakcanary-support-fragment/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-apply plugin: 'com.android.library'
-apply plugin: 'kotlin-android'
-
-dependencies {
-  api project(':leakcanary-android')
-
-  implementation deps.androidx.fragment
-  implementation deps.androidx.annotation
-  implementation deps.kotlin.stdlib
-
-  androidTestImplementation project(':leakcanary-android-instrumentation')
-  androidTestImplementation deps.androidx.test.core
-  androidTestImplementation deps.androidx.test.espresso
-  androidTestImplementation deps.androidx.test.rules
-  androidTestImplementation deps.androidx.test.runner
-}
-
-android {
-  compileSdkVersion versions.compileSdk
-  defaultConfig {
-    minSdkVersion versions.minSdk
-
-    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
-  }
-  lintOptions {
-    disable 'GoogleAppIndexingWarning'
-    // junit references java.lang.management
-    ignore 'InvalidPackage'
-  }
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-support-fragment/gradle.properties b/leakcanary-support-fragment/gradle.properties
deleted file mode 100644
index 426b01873..000000000
--- a/leakcanary-support-fragment/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-support-fragment
-POM_NAME=LeakCanary extension to watch Android support fragments
-POM_PACKAGING=aar
\ No newline at end of file
diff --git a/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml b/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml
deleted file mode 100644
index d12071a3b..000000000
--- a/leakcanary-support-fragment/src/androidTest/AndroidManifest.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2018 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary.support.fragment.test">
-
-  <application android:name="com.squareup.leakcanary.tests.InstrumentationTestApplication">
-
-    <activity android:name="com.squareup.leakcanary.tests.TestActivity"/>
-
-  </application>
-</manifest>
diff --git a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.kt b/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.kt
deleted file mode 100644
index b59f56462..000000000
--- a/leakcanary-support-fragment/src/androidTest/java/com/squareup/leakcanary/tests/InstrumentationTestApplication.kt
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.squareup.leakcanary.tests
-
-import android.app.Application
-import com.squareup.leakcanary.InstrumentationLeakDetector
-
-class InstrumentationTestApplication : Application() {
-  override fun onCreate() {
-    super.onCreate()
-    InstrumentationLeakDetector.updateConfig()
-  }
-}
diff --git a/leakcanary-support-fragment/src/main/AndroidManifest.xml b/leakcanary-support-fragment/src/main/AndroidManifest.xml
deleted file mode 100644
index 41a070026..000000000
--- a/leakcanary-support-fragment/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2018 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest package="com.squareup.leakcanary.support.fragment">
-
-  <application>
-  </application>
-</manifest>
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leaksentry/Clock.kt
similarity index 75%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/Clock.kt
rename to leakcanary-watcher/src/main/java/leaksentry/Clock.kt
index af792ce43..ede8229e2 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Clock.kt
+++ b/leakcanary-watcher/src/main/java/leaksentry/Clock.kt
@@ -1,4 +1,4 @@
-package com.squareup.leakcanary
+package leaksentry
 
 interface Clock {
   /** See Android SystemClock.uptimeMillis().  */
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leaksentry/KeyedWeakReference.kt
similarity index 96%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.kt
rename to leakcanary-watcher/src/main/java/leaksentry/KeyedWeakReference.kt
index cf6bf7869..aba52dac0 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-watcher/src/main/java/leaksentry/KeyedWeakReference.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary
+package leaksentry
 
 import java.lang.ref.ReferenceQueue
 import java.lang.ref.WeakReference
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leaksentry/RefWatcher.kt
similarity index 61%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.kt
rename to leakcanary-watcher/src/main/java/leaksentry/RefWatcher.kt
index c01205d3f..affa7ce1f 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leaksentry/RefWatcher.kt
@@ -13,43 +13,51 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary
+package leaksentry
 
 import java.lang.ref.ReferenceQueue
 import java.util.HashSet
 import java.util.UUID
+import java.util.concurrent.Executor
 
 /**
  * Thread safe by locking on all methods, which is reasonably efficient given how often
  * these methods are accessed.
  */
 class RefWatcher constructor(
-  private val clock: Clock
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  private val onReferenceRetained: () -> Unit
 ) {
 
-  private val retainedKeys = mutableMapOf<String, KeyedWeakReference>()
+  /**
+   * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   */
+  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
+  /**
+   * References passed to [watch] that we have determined to be retained longer than they should
+   * have been.
+   */
+  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
   private val queue = ReferenceQueue<Any>()
-  private val newRefListeners = mutableListOf<() -> Unit>()
 
-  val isEmpty: Boolean
+  val hasRetainedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return retainedKeys.isEmpty()
+      return !retainedReferences.isEmpty()
     }
 
-  val allRetainedKeys: Set<String>
+  val hasWatchedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return HashSet(retainedKeys.keys)
+      return !retainedReferences.isEmpty() || !watchedReferences.isEmpty()
     }
 
-  @Synchronized fun addNewRefListener(listener: () -> Unit) {
-    newRefListeners.add(listener)
-  }
-
-  @Synchronized fun removeNewRefListener(listener: () -> Unit) {
-    newRefListeners.remove(listener)
-  }
+  val retainedKeys: Set<String>
+    @Synchronized get() {
+      removeWeaklyReachableReferences()
+      return HashSet(retainedReferences.keys)
+    }
 
   /**
    * Identical to [.watch] with an empty string reference name.
@@ -67,50 +75,34 @@ class RefWatcher constructor(
     watchedReference: Any,
     referenceName: String
   ) {
+    removeWeaklyReachableReferences()
     val key = UUID.randomUUID()
         .toString()
     val watchUptimeMillis = clock.uptimeMillis()
     val reference =
       KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
-    retainedKeys[key] = reference
-
-    newRefListeners.forEach { it() }
-  }
-
-  /**
-   * LeakCanary will stop watching any references that were passed to [.watch]
-   * so far.
-   */
-  @Synchronized fun clearWatchedReferences() {
-    retainedKeys.clear()
-  }
-
-  @Synchronized fun hasReferencesOlderThan(durationMillis: Long): Boolean {
-    removeWeaklyReachableReferences()
-    val now = clock.uptimeMillis()
-    var count = 0
-    for (reference in retainedKeys.values) {
-      if (now - reference.watchUptimeMillis >= durationMillis) {
-        count++
-      }
+    watchedReferences[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
     }
-    return count > 0
   }
 
-  @Synchronized fun getRetainedKeysOlderThan(durationMillis: Long): Set<String> {
+  @Synchronized private fun moveToRetained(key: String) {
     removeWeaklyReachableReferences()
-    val now = clock.uptimeMillis()
-    val retainedKeys = HashSet<String>()
-    for ((key, value) in this.retainedKeys) {
-      if (now - value.watchUptimeMillis >= durationMillis) {
-        retainedKeys.add(key)
-      }
+    val retainedRef = watchedReferences.remove(key)
+    if (retainedRef != null) {
+      retainedReferences[key] = retainedRef
+      onReferenceRetained()
     }
-    return retainedKeys
   }
 
   @Synchronized fun removeRetainedKeys(keysToRemove: Set<String>) {
-    retainedKeys.keys.removeAll(keysToRemove)
+    retainedReferences.keys.removeAll(keysToRemove)
+  }
+
+  @Synchronized fun clearWatchedReferences() {
+    watchedReferences.clear()
+    retainedReferences.clear()
   }
 
   @Synchronized private fun removeWeaklyReachableReferences() {
@@ -120,7 +112,10 @@ class RefWatcher constructor(
     do {
       ref = queue.poll() as KeyedWeakReference?
       if (ref != null) {
-        retainedKeys.remove(ref.key)
+        val removedRef = watchedReferences.remove(ref.key)
+        if (removedRef == null) {
+          retainedReferences.remove(ref.key)
+        }
       }
     } while (ref != null)
   }
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leaksentry/RefWatcherTest.kt
similarity index 59%
rename from leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.kt
rename to leakcanary-watcher/src/test/java/leaksentry/RefWatcherTest.kt
index 5ebdb4baf..505a6046b 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-watcher/src/test/java/leaksentry/RefWatcherTest.kt
@@ -1,30 +1,38 @@
-package com.squareup.leakcanary
+package leaksentry
 
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import java.util.concurrent.Executor
 
 class RefWatcherTest {
 
+  private val onRefRetained: () -> Unit = {
+  }
+
+  private val checkRetainedExecutor: Executor = Executor {
+    it.run()
+  }
+
   val refWatcher = RefWatcher(object : Clock {
     override fun uptimeMillis(): Long {
       return time
     }
-  })
+  }, checkRetainedExecutor, onRefRetained)
   var time: Long = 0
 
   var ref: Any? = Any()
 
-  @Test fun `unreachable object not tracked`() {
+  @Test fun `unreachable object not retained`() {
     refWatcher.watch(ref!!)
     ref = null
     runGc()
-    assertThat(refWatcher.isEmpty).isTrue()
+    assertThat(refWatcher.hasRetainedReferences).isFalse()
   }
 
-  @Test fun `reachable object not tracked`() {
+  @Test fun `reachable object retained`() {
     refWatcher.watch(ref!!)
     runGc()
-    assertThat(refWatcher.isEmpty).isFalse()
+    assertThat(refWatcher.hasRetainedReferences).isTrue()
   }
 
   private fun runGc() {
diff --git a/settings.gradle b/settings.gradle
index 237d6ee42..c3d7742fa 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,6 +1,6 @@
-include ':leakcanary-watcher'
 include ':leakcanary-analyzer'
 include ':leakcanary-android'
 include ':leakcanary-android-instrumentation'
+include ':leakcanary-leaksentry'
 include ':leakcanary-sample'
-include ':leakcanary-support-fragment'
+include ':leakcanary-watcher'
\ No newline at end of file
