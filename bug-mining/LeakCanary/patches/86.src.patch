diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
index 3fcac6ba8..1c6c61aa0 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -7,6 +7,7 @@ import java.util.concurrent.TimeUnit
 object LeakSentry {
 
   data class Config(
+    val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
     val watchActivities: Boolean = true,
     val watchFragments: Boolean = true,
     val watchFragmentViews: Boolean = true,
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index c7b1acd78..6966d81b1 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import android.app.Application
+import android.content.pm.ApplicationInfo
 import android.os.Handler
 import android.os.Looper
 import android.os.SystemClock
@@ -14,6 +15,10 @@ internal object InternalLeakSentry {
 
   private val listener: LeakSentryListener
 
+  val isDebuggableBuild by lazy {
+    (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
+  }
+
   lateinit var application: Application
 
   private val clock = object : Clock {
@@ -37,11 +42,11 @@ internal object InternalLeakSentry {
     mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
   }
   val refWatcher = RefWatcher(
-      clock,
-      checkRetainedExecutor
-  ) {
-    listener.onReferenceRetained()
-  }
+      clock = clock,
+      checkRetainedExecutor = checkRetainedExecutor,
+      onReferenceRetained = { listener.onReferenceRetained() },
+      isEnabled = { LeakSentry.config.enabled }
+  )
 
   fun install(application: Application) {
     CanaryLog.d("Installing LeakSentry")
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index f2e66c468..8916c8878 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -27,7 +27,11 @@ import java.util.concurrent.Executor
 class RefWatcher constructor(
   private val clock: Clock,
   private val checkRetainedExecutor: Executor,
-  private val onReferenceRetained: () -> Unit
+  private val onReferenceRetained: () -> Unit,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
 ) {
 
   /**
@@ -44,13 +48,13 @@ class RefWatcher constructor(
   val hasRetainedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return !retainedReferences.isEmpty()
+      return retainedReferences.isNotEmpty()
     }
 
   val hasWatchedReferences: Boolean
     @Synchronized get() {
       removeWeaklyReachableReferences()
-      return !retainedReferences.isEmpty() || !watchedReferences.isEmpty()
+      return retainedReferences.isNotEmpty() || watchedReferences.isNotEmpty()
     }
 
   val retainedKeys: Set<String>
@@ -75,6 +79,9 @@ class RefWatcher constructor(
     watchedReference: Any,
     referenceName: String
   ) {
+    if (!isEnabled()) {
+      return
+    }
     removeWeaklyReachableReferences()
     val key = UUID.randomUUID()
         .toString()
