diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
index 52ca9f9cf..709ad51ef 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
@@ -1,24 +1,19 @@
 package leakcanary
 
+/**
+ * Used to report progress by the [HeapAnalyzer].
+ */
 interface AnalyzerProgressListener {
 
-  // These steps should be defined in the order in which they occur.
+  // These steps are defined in the order in which they occur.
   enum class Step {
-    READING_HEAP_DUMP_FILE,
     PARSING_HEAP_DUMP,
-    SCANNING_HEAP_DUMP,
-    FINDING_WATCHED_REFERENCES,
-    DEDUPLICATING_GC_ROOTS,
-    FINDING_LEAKING_REF,
-    FINDING_LEAKING_REFS,
-    FINDING_SHORTEST_PATH,
-    FINDING_SHORTEST_PATHS,
+    FINDING_LEAKING_INSTANCES,
+    FINDING_PATHS_TO_LEAKING_INSTANCES,
     FINDING_DOMINATORS,
     COMPUTING_NATIVE_RETAINED_SIZE,
     COMPUTING_RETAINED_SIZE,
-    BUILDING_LEAK_TRACE,
     BUILDING_LEAK_TRACES,
-    COMPUTING_DOMINATORS
   }
 
   fun onProgressUpdate(step: Step)
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
index 619b9906d..9fb23b537 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
@@ -17,8 +17,8 @@ class AndroidBuildMirror(
 val HprofGraph.androidBuildMirror: AndroidBuildMirror
   get() {
     return context.getOrPut(AndroidBuildMirror::class.java.name) {
-      val buildClass = indexedClass("android.os.Build")!!
-      val versionClass = indexedClass("android.os.Build\$VERSION")!!
+      val buildClass = findClassByClassName("android.os.Build")!!
+      val versionClass = findClassByClassName("android.os.Build\$VERSION")!!
       val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
       val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
       AndroidBuildMirror(manufacturer, sdkInt)
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
index 81a41a090..f8a24f400 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
@@ -30,6 +30,9 @@ import kotlin.reflect.KClass
  *
  * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
  * will not be influenced by those mistakes.
+ *
+ * Most developers should use the entire set of default [ObjectInspector] by calling [appDefaults],
+ * unless there's a bug and you temporarily want to remove an inspector.
  */
 enum class AndroidObjectInspectors : ObjectInspector {
 
@@ -38,38 +41,39 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      val references: List<KeyedWeakReferenceMirror> = graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
-        val keyedWeakReferenceClass = graph.indexedClass("leakcanary.KeyedWeakReference")
+      val references: List<KeyedWeakReferenceMirror> =
+        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+          val keyedWeakReferenceClass = graph.findClassByClassName("leakcanary.KeyedWeakReference")
 
-        val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-          null
-        } else {
-          keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
-        }
+          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+            null
+          } else {
+            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+          }
 
-        if (heapDumpUptimeMillis == null) {
-          CanaryLog.d(
-              "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
-                  "this must be a heap dump from an older version of LeakCanary."
-          )
-        }
+          if (heapDumpUptimeMillis == null) {
+            CanaryLog.d(
+                "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
+                    "this must be a heap dump from an older version of LeakCanary."
+            )
+          }
 
-        val addedToContext: List<KeyedWeakReferenceMirror> = graph.instanceSequence()
-            .filter { instance ->
-              val className = instance.className
-              className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
-            }
-            .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
-            .filter { it.hasReferent }
-            .toList()
-        graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
-        addedToContext
-      }
+          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+              .filter { instance ->
+                val className = instance.className
+                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+              }
+              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
+              .filter { it.hasReferent }
+              .toList()
+          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+          addedToContext
+        }
 
       val objectId = reporter.objectRecord.objectId
       references.forEach { ref ->
         if (ref.referent.value == objectId) {
-          reporter.reportLeaking("RefWatcher was watching this")
+          reporter.reportLeaking("ObjectWatcher was watching this")
           reporter.addLabel("key = ${ref.key}")
           if (ref.name.isNotEmpty()) {
             reporter.addLabel("name = ${ref.name}")
@@ -474,9 +478,11 @@ enum class AndroidObjectInspectors : ObjectInspector {
   };
 
   companion object {
-    fun defaultInspectors(): List<ObjectInspector> {
-      return values().toList()
-    }
+    /** @see AndroidObjectInspectors */
+    val appDefaults: List<ObjectInspector>
+      get() {
+        return values().toList()
+      }
   }
 }
 
@@ -484,6 +490,9 @@ private infix fun GraphField.describedWithValue(valueDescription: String): Strin
   return "${classRecord.simpleName}#$name is $valueDescription"
 }
 
+/**
+ * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClass].
+ */
 inline fun ObjectReporter.whenInstanceOf(
   expectedClass: KClass<out Any>,
   action: ObjectReporter.(GraphInstanceRecord) -> Unit
@@ -491,15 +500,22 @@ inline fun ObjectReporter.whenInstanceOf(
   whenInstanceOf(expectedClass.java.name, action)
 }
 
+/**
+ * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClassName].
+ */
 inline fun ObjectReporter.whenInstanceOf(
-  className: String,
+  expectedClassName: String,
   block: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
-  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf className) {
+  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf expectedClassName) {
     block(objectRecord)
   }
 }
 
+/**
+ * Recursively unwraps `this` [GraphInstanceRecord] as a ContextWrapper until an Activity is found in which case it is
+ * returned. Returns null if no activity was found.
+ */
 fun GraphInstanceRecord.unwrapActivityContext(): GraphInstanceRecord? {
   if (this instanceOf "android.app.Activity") {
     return this
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
index e95ff6061..0da175018 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
@@ -28,6 +28,14 @@ import java.lang.ref.WeakReference
 import java.util.EnumSet
 
 /**
+ * [AndroidReferenceMatchers] values add [ReferenceMatcher] instances to a global list via their
+ * [add] method. A [ReferenceMatcher] is either a [IgnoredReferenceMatcher] or
+ * a [LibraryLeakReferenceMatcher].
+ *
+ * [AndroidReferenceMatchers] is used to build the list of known references that cannot ever create
+ * leaks (via [IgnoredReferenceMatcher]) as well as the list of known leaks in the Android Framework
+ * and in manufacturer specific Android implementations.
+ *
  * This class is a work in progress. You can help by reporting leak traces that seem to be caused
  * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
  *
@@ -35,9 +43,9 @@ import java.util.EnumSet
  * manufacturer implementation, they usually share their builds across multiple models, and the
  * leaks eventually get fixed in newer versions.
  *
- * Most app developers should use [appDefaults]. However, you can also pick the
- * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
- * [buildKnownReferences]
+ * Most app developers should use [appDefaults]. However, you can also use a subset of
+ * [AndroidReferenceMatchers] by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences].
  */
 enum class AndroidReferenceMatchers {
 
@@ -993,9 +1001,10 @@ enum class AndroidReferenceMatchers {
     const val VIVO = "vivo"
 
     /**
-     * This returns the references in the leak path that should be ignored by all on Android.
+     * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
+     * [LibraryLeakReferenceMatcher].
      */
-    val androidDefaults: List<ReferenceMatcher>
+    val ignoredReferencesOnly: List<ReferenceMatcher>
       get() = buildKnownReferences(
           EnumSet.of(
               REFERENCES,
@@ -1007,17 +1016,18 @@ enum class AndroidReferenceMatchers {
       )
 
     /**
-     * This returns the references in the leak path that can be ignored for app developers. This
-     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     * @see [AndroidReferenceMatchers]
      */
     val appDefaults: List<ReferenceMatcher>
       get() = buildKnownReferences(EnumSet.allOf(AndroidReferenceMatchers::class.java))
 
-    fun buildKnownReferences(defaults: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
+    /**
+     * Builds a list of [ReferenceMatcher] from the [referenceMatchers] set of
+     * [AndroidReferenceMatchers].
+     */
+    fun buildKnownReferences(referenceMatchers: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
       val resultSet = mutableListOf<ReferenceMatcher>()
-      defaults.forEach {
+      referenceMatchers.forEach {
         it.add(resultSet)
       }
       return resultSet
@@ -1027,6 +1037,9 @@ enum class AndroidReferenceMatchers {
       true
     }
 
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
+     */
     fun staticFieldLeak(
       className: String,
       fieldName: String,
@@ -1036,6 +1049,9 @@ enum class AndroidReferenceMatchers {
       return libraryLeak(StaticFieldPattern(className, fieldName), description, patternApplies)
     }
 
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
     fun instanceFieldLeak(
       className: String,
       fieldName: String,
@@ -1059,6 +1075,9 @@ enum class AndroidReferenceMatchers {
       )
     }
 
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
     fun ignoredInstanceField(
       className: String,
       fieldName: String
@@ -1066,6 +1085,9 @@ enum class AndroidReferenceMatchers {
       return IgnoredReferenceMatcher(pattern = InstanceFieldPattern(className, fieldName))
     }
 
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [JavaLocalPattern].
+     */
     fun ignoredJavaLocal(
       threadName: String
     ): IgnoredReferenceMatcher {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index c04919e5c..0f0cf0881 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -18,9 +18,8 @@ package leakcanary
 import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
-import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
-import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_INSTANCES
+import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
 import leakcanary.GcRoot.JavaFrame
 import leakcanary.GcRoot.JniGlobal
 import leakcanary.GcRoot.JniLocal
@@ -46,9 +45,10 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.ReferencePathNode.ChildNode
-import leakcanary.ReferencePathNode.ChildNode.LibraryLeakNode
-import leakcanary.ReferencePathNode.RootNode
+import leakcanary.internal.ReferencePathNode
+import leakcanary.internal.ReferencePathNode.ChildNode
+import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import leakcanary.internal.ReferencePathNode.RootNode
 import leakcanary.internal.ShortestPathFinder
 import leakcanary.internal.ShortestPathFinder.Results
 import leakcanary.internal.hppc.LongLongScatterMap
@@ -86,15 +86,12 @@ class HeapAnalyzer constructor(
       )
     }
 
-    listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
-
     try {
-      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-
+      listener.onProgressUpdate(PARSING_HEAP_DUMP)
       val (graph, hprofCloseable) = HprofGraph.readHprof(heapDumpFile)
 
       hprofCloseable.use {
-        listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
+        listener.onProgressUpdate(FINDING_LEAKING_INSTANCES)
 
         val leakingInstanceObjectIds = findLeakingInstances(graph, leakFinders)
 
@@ -130,7 +127,7 @@ class HeapAnalyzer constructor(
     graph: HprofGraph,
     objectInspectors: List<ObjectInspector>
   ): Set<Long> {
-    return graph.objectSequence()
+    return graph.objects
         .filter { objectRecord ->
           val reporter = ObjectReporter(objectRecord)
           objectInspectors.forEach { inspector ->
@@ -249,13 +246,13 @@ class HeapAnalyzer constructor(
     // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
-    graph.instanceSequence()
+    graph.instances
         .filter { it.className == "sun.misc.Cleaner" }
         .forEach { cleaner ->
           val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
-          val thunkId = thunkField?.value?.asNonNullObjectIdReference
+          val thunkId = thunkField?.value?.asNonNullObjectId
           val referentId =
-            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
+            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
           if (thunkId != null && referentId != null) {
             val thunkRecord = thunkField.value.asObject
             if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
@@ -283,7 +280,7 @@ class HeapAnalyzer constructor(
     results.forEach { pathNode ->
       val leakingInstanceObjectId = pathNode.instance
       leakingInstanceIds.add(leakingInstanceObjectId)
-      val instanceRecord = graph.indexedObject(leakingInstanceObjectId).asInstance!!
+      val instanceRecord = graph.findObjectByObjectId(leakingInstanceObjectId).asInstance!!
       val classRecord = instanceRecord.instanceClass
       var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
 
@@ -298,7 +295,14 @@ class HeapAnalyzer constructor(
       if (instanceId !in leakingInstanceIds) {
         val currentSize = sizeByDominator.getValue(dominatorId)
         val nativeSize = nativeSizes.getValue(instanceId)
-        val shallowSize = graph.computeShallowSize(graph.indexedObject(instanceId))
+        val shallowSize = when (val objectRecord = graph.findObjectByObjectId(instanceId)) {
+          is GraphInstanceRecord -> objectRecord.size
+          is GraphObjectArrayRecord -> objectRecord.readSize()
+          is GraphPrimitiveArrayRecord -> objectRecord.readSize()
+          is GraphClassRecord -> throw IllegalStateException(
+              "Unexpected class record $objectRecord"
+          )
+        }
         sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
       }
     }
@@ -355,7 +359,7 @@ class HeapAnalyzer constructor(
         buildLeakTrace(graph, objectInspectors, rootNode, shortestChildPath)
 
       val className =
-        recordClassName(graph.indexedObject(pathNode.instance))
+        recordClassName(graph.findObjectByObjectId(pathNode.instance))
 
       val firstLibraryLeakNode =
         shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
@@ -382,7 +386,7 @@ class HeapAnalyzer constructor(
     shortestPath.add(0, rootNode)
 
     val leakReporters = shortestPath.map {
-      ObjectReporter(graph.indexedObject(it.instance))
+      ObjectReporter(graph.findObjectByObjectId(it.instance))
     }
 
     // Looping on inspectors first to get more cache hits.
@@ -521,7 +525,7 @@ class HeapAnalyzer constructor(
   ): LeakTraceElement {
     val objectId = node.instance
 
-    val graphRecord = graph.indexedObject(objectId)
+    val graphRecord = graph.findObjectByObjectId(objectId)
 
     val className = recordClassName(graphRecord)
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
index 3c0be75f4..f2724880f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
@@ -1,8 +1,44 @@
 package leakcanary
 
+/**
+ * Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
+ * heap. [inspect] will be called for each object that LeakCanary wants to know more about.
+ * The implementation can then use the provided [ObjectReporter] to provide insights for that
+ * object.
+ *
+ * You can create a [ObjectInspector] from a lambda by calling [invoke].
+ */
 interface ObjectInspector {
+
+  /**
+   * @see [ObjectInspector]
+   */
   fun inspect(
     graph: HprofGraph,
     reporter: ObjectReporter
   )
+
+  companion object {
+    /**
+     * Utility function to create a [ObjectInspector] from the passed in [block] lambda instead of
+     * using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val inspector = ObjectInspector { graph, reporter ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HprofGraph, ObjectReporter) -> Unit): ObjectInspector =
+      object : ObjectInspector {
+        override fun inspect(
+          graph: HprofGraph,
+          reporter: ObjectReporter
+        ) {
+          block(graph, reporter)
+        }
+      }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
index 3f00f5c65..c98338ae0 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
@@ -1,6 +1,13 @@
 package leakcanary
 
-class ObjectReporter(val objectRecord: GraphObjectRecord) {
+/**
+ * Enables [ObjectInspector] implementations to provide insights on [objectRecord], which is
+ * an object (class, instance or array) found in the heap.
+ *
+ * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
+ * [ObjectInspector] implementations and accumulates insights.
+ */
+class ObjectReporter internal constructor(val objectRecord: GraphObjectRecord) {
 
   private val mutableLabels = mutableListOf<String>()
 
@@ -8,36 +15,54 @@ class ObjectReporter(val objectRecord: GraphObjectRecord) {
   private val mutableLikelyLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
   private val mutableNotLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
 
+  /**
+   * All labels added via [addLabel] for the [objectRecord] instance.
+   */
   val labels: List<String>
     get() = mutableLabels
 
+  /**
+   * All leaking insights added via [reportLikelyLeaking], [reportLeaking] and [reportNotLeaking]
+   * for the [objectRecord] instance.
+   */
   val leakNodeStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses + mutableLikelyLeakingStatuses + mutableNotLeakingStatuses
 
+  /**
+   * All leaking insights added via [reportLeaking] for the [objectRecord] instance.
+   */
   val leakingStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses
 
+  /**
+   * Adds a label that will be visible on the corresponding node in the leak trace.
+   */
   fun addLabel(label: String) {
     mutableLabels += label
   }
 
-
   /**
-   * The inspector is almost sure this instance is leaking, but not 100%. This information will
-   * be used for decorating leaktraces, but [HeapAnalyzer] will not look for these instances.
+   * @see [reportLeaking]
    */
   fun reportLikelyLeaking(reason: String) {
     mutableLikelyLeakingStatuses += LeakNodeStatus.leaking(reason)
   }
 
   /**
-   * The inspector is 100% sure this instance is leaking. [HeapAnalyzer] will look for these
-   * instances.
+   * Call this to let LeakCanary know that this instance was expected to be unreachable, ie that
+   * it's leaking.
+   *
+   * Only call this method if you're 100% sure this instance is leaking, otherwise call
+   * [reportLikelyLeaking]. The difference is that instances that are "likely leaking" are not
+   * considered to be leaking instances on which LeakCanary should compute the leak trace.
    */
   fun reportLeaking(reason: String) {
     mutableLeakingStatuses += LeakNodeStatus.leaking(reason)
   }
 
+  /**
+   * Call this to let LeakCanary know that this instance was expected to be reachable.
+   */
   fun reportNotLeaking(reason: String) {
     mutableNotLeakingStatuses += LeakNodeStatus.notLeaking(reason)
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt b/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
index c0550e2ce..8233c3c07 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
@@ -1,13 +1,20 @@
 package leakcanary
 
+/**
+ * Used to pattern match known patterns of references in the heap, either to ignore them
+ * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+ */
 sealed class ReferenceMatcher {
+
+  /** The pattern that references will be matched against. */
   abstract val pattern: ReferencePattern
 
   /**
    * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
    * known to create leaks and are beyond your control. The shortest path finder will only go
    * through matching references after it has exhausted references that don't match, prioritizing
-   * finding an application leak over a known library leak.
+   * finding an application leak over a known library leak. Library leaks will be reported as
+   * [Leak.LibraryLeak] instead of [Leak.ApplicationLeak].
    */
   data class LibraryLeakReferenceMatcher(
     override val pattern: ReferencePattern,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt b/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
index 3b116ed6e..f80a3c8dc 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
@@ -2,10 +2,13 @@ package leakcanary
 
 import java.io.Serializable
 
+/**
+ * A pattern that will match references for a given [ReferenceMatcher].
+ */
 sealed class ReferencePattern : Serializable {
 
   /**
-   * Local references held in the stack of frames of a given thread.
+   * Matches local references held in the stack of frames of a given thread, identified by its name.
    */
   data class JavaLocalPattern(
     val threadName: String
@@ -15,6 +18,9 @@ sealed class ReferencePattern : Serializable {
     }
   }
 
+  /**
+   * Matches static field references, identified by [className] and [fieldName].
+   */
   data class StaticFieldPattern(
     val className: String,
     val fieldName: String
@@ -25,10 +31,12 @@ sealed class ReferencePattern : Serializable {
   }
 
   /**
-   * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
-   * and will still match for subclasses. This is to support overriding of rules for specific
-   * cases. If two exclusions for the same field name but different classname match in a class
-   * hierarchy, then the closest class in the hierarchy wins.
+   * Matches instances field references, identified by [className] and [fieldName].
+   *
+   * Note: If [fieldName] is declared in a superclass it will still match for subclasses.
+   * This is to support overriding of rules for specific cases. If two [ReferenceMatcher] match for
+   * the same [fieldName] but for different [className] in a class hierarchy, then the closest
+   * class in the hierarchy wins.
    */
   data class InstanceFieldPattern(
     val className: String,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index e47af6260..93b5bd206 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
 
 internal class KeyedWeakReferenceMirror(
@@ -14,7 +15,7 @@ internal class KeyedWeakReferenceMirror(
   val retainedDurationMillis: Long?
 ) {
 
-  val hasReferent = referent.value != 0L
+  val hasReferent = referent.value != HeapValue.NULL_REFERENCE
 
   val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePathNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
similarity index 86%
rename from leakcanary-analyzer/src/main/java/leakcanary/ReferencePathNode.kt
rename to leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
index 73fb2540b..22a229c34 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePathNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
@@ -1,8 +1,10 @@
-package leakcanary
+package leakcanary.internal
 
+import leakcanary.GcRoot
+import leakcanary.LeakReference
 import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
 
-sealed class ReferencePathNode {
+internal sealed class ReferencePathNode {
   abstract val instance: Long
 
   class RootNode(
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 750bcddd9..8b1f4c5d0 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -17,7 +17,7 @@ package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
 import leakcanary.CanaryLog
 import leakcanary.GcRoot
 import leakcanary.GcRoot.JavaFrame
@@ -27,6 +27,7 @@ import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HeapValue
 import leakcanary.HprofGraph
 import leakcanary.HprofReader
 import leakcanary.LeakReference
@@ -38,10 +39,9 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.ReferenceMatcher
 import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
 import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.ReferencePathNode
-import leakcanary.ReferencePathNode.ChildNode.LibraryLeakNode
-import leakcanary.ReferencePathNode.ChildNode.NormalNode
-import leakcanary.ReferencePathNode.RootNode
+import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import leakcanary.internal.ReferencePathNode.ChildNode.NormalNode
+import leakcanary.internal.ReferencePathNode.RootNode
 import leakcanary.ReferencePattern
 import leakcanary.ReferencePattern.InstanceFieldPattern
 import leakcanary.ReferencePattern.StaticFieldPattern
@@ -77,7 +77,7 @@ internal class ShortestPathFinder {
    * var because the instance will be returned by [findPaths] and replaced with a new empty map
    * here (copying it could be expensive).
    *
-   * If an instance has been added to [toVisitMap] or [visitedSet] and is missing from
+   * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
    * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
    * and cannot be dominated by a leaking instance.
    */
@@ -97,11 +97,11 @@ internal class ShortestPathFinder {
     listener: AnalyzerProgressListener
   ): Results {
 
-    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
+    listener.onProgressUpdate(FINDING_PATHS_TO_LEAKING_INSTANCES)
     clearState()
     this.leakingInstanceObjectIds = leakingInstanceObjectIds
 
-    val objectClass = graph.indexedClass("java.lang.Object")
+    val objectClass = graph.findClassByClassName("java.lang.Object")
     sizeOfObjectInstances = if (objectClass != null) {
       // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
       // Better rely on our own computation of instance size.
@@ -190,7 +190,7 @@ internal class ShortestPathFinder {
         }
       }
 
-      when (val graphRecord = graph.indexedObject(node.instance)) {
+      when (val graphRecord = graph.findObjectByObjectId(node.instance)) {
         is GraphClassRecord -> visitClassRecord(
             graph, graphRecord, node, staticFieldNameByClassName, computeDominators
         )
@@ -296,8 +296,8 @@ internal class ShortestPathFinder {
       }
     }
 
-    return graph.gcRoots()
-        .map { graph.indexedObject(it.id) to it }
+    return graph.gcRoots
+        .map { graph.findObjectByObjectId(it.id) to it }
         .sortedWith(Comparator { (graphObject1, root1), (graphObject2, root2) ->
           // Sorting based on pattern name first. In reverse order so that ThreadObject is before JavaLocalPattern
           val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
@@ -328,7 +328,7 @@ internal class ShortestPathFinder {
         continue
       }
 
-      val objectId = staticField.value.asObjectIdReference!!
+      val objectId = staticField.value.asObjectId!!
 
       if (computeRetainedHeapSize) {
         undominateWithSkips(graph, objectId)
@@ -380,7 +380,7 @@ internal class ShortestPathFinder {
 
     fieldNamesAndValues.filter { it.value.isNonNullReference }
         .forEach { field ->
-          val objectId = field.value.asObjectIdReference!!
+          val objectId = field.value.asObjectId!!
           if (computeRetainedHeapSize) {
             updateDominatorWithSkips(graph, parent.instance, objectId)
           }
@@ -410,7 +410,7 @@ internal class ShortestPathFinder {
     computeRetainedHeapSize: Boolean
   ) {
     record.elementIds.filter { objectId ->
-      objectId != 0L && graph.objectIdExists(objectId).apply {
+      objectId != HeapValue.NULL_REFERENCE && graph.objectExists(objectId).apply {
         if (!this) {
           // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
           // otherwise exist in the heap dump.
@@ -434,8 +434,7 @@ internal class ShortestPathFinder {
     graph: HprofGraph,
     node: ReferencePathNode
   ) {
-    // 0L is null
-    if (node.instance == 0L) {
+    if (node.instance == HeapValue.NULL_REFERENCE) {
       return
     }
     if (visitedSet.contains(node.instance)) {
@@ -463,7 +462,7 @@ internal class ShortestPathFinder {
     val isLeakingInstance = node.instance in leakingInstanceObjectIds
 
     if (!isLeakingInstance) {
-      val skip = when (val graphObject = graph.indexedObject(node.instance)) {
+      val skip = when (val graphObject = graph.findObjectByObjectId(node.instance)) {
         is GraphClassRecord -> false
         is GraphInstanceRecord ->
           when {
@@ -497,7 +496,7 @@ internal class ShortestPathFinder {
     objectId: Long
   ) {
 
-    when (val graphObject = graph.indexedObject(objectId)) {
+    when (val graphObject = graph.findObjectByObjectId(objectId)) {
       is GraphClassRecord -> {
         undominate(objectId, false)
       }
@@ -505,7 +504,7 @@ internal class ShortestPathFinder {
         // String internal array is never enqueued
         if (graphObject.className == "java.lang.String") {
           updateDominator(parentObjectId, objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
             updateDominator(parentObjectId, valueId, true)
           }
@@ -597,7 +596,7 @@ internal class ShortestPathFinder {
     graph: HprofGraph,
     objectId: Long
   ) {
-    when (val graphObject = graph.indexedObject(objectId)) {
+    when (val graphObject = graph.findObjectByObjectId(objectId)) {
       is GraphClassRecord -> {
         undominate(objectId, false)
       }
@@ -605,7 +604,7 @@ internal class ShortestPathFinder {
         // String internal array is never enqueued
         if (graphObject.className == "java.lang.String") {
           undominate(objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
             undominate(valueId, true)
           }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
index 73c565696..07856ea46 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
@@ -22,7 +22,7 @@ class JvmHprofParsingTest {
     val (graph, closeable) = HprofGraph.readHprof(hprofFile)
 
     closeable.use {
-      val testInstances = graph.instanceSequence()
+      val testInstances = graph.instances
           .filter { it.className == JvmHprofParsingTest::class.name }
           .toList()
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index d3b03aa7f..1b462ee8b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -232,7 +232,7 @@ class LeakStatusTest {
     val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "Leaking is not leaking. Conflicts with RefWatcher was watching this"
+        "Leaking is not leaking. Conflicts with ObjectWatcher was watching this"
     )
   }
 
@@ -246,7 +246,7 @@ class LeakStatusTest {
     val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "Leaking is leaking and RefWatcher was watching this"
+        "Leaking is leaking and ObjectWatcher was watching this"
     )
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
index bd9fd5b48..7ae61f686 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -42,7 +42,7 @@ class LeakTraceRendererTest {
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -118,7 +118,7 @@ class LeakTraceRendererTest {
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     ¯\_(ツ)_/¯
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
@@ -154,7 +154,7 @@ class LeakTraceRendererTest {
     │    ↓ ClassA.leak
     │             ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -183,7 +183,7 @@ class LeakTraceRendererTest {
     │    ↓ array Object[].[0]
     │                     ~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -204,7 +204,7 @@ class LeakTraceRendererTest {
     │    ↓ thread MyThread.<Java Local>
     │                      ~~~~~~~~~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
index 73434d9ae..81d9cfc33 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -72,7 +72,7 @@ class LegacyHprofTest {
 
   private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        objectInspectors = AndroidObjectInspectors.defaultInspectors(),
+        objectInspectors = AndroidObjectInspectors.appDefaults,
         referenceMatchers = AndroidReferenceMatchers.appDefaults
     )
     print(analysis)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
similarity index 77%
rename from leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
rename to leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index e43ad7480..f0fae9e40 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -13,12 +13,13 @@ import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
 
-object DefaultAnalysisResultListener : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+/**
+ * Default [OnHeapAnalyzedListener] implementation, which will store the analysis to disk and
+ * show a notification summarizing the result.
+ */
+class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHeapAnalyzedListener {
 
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     // TODO better log that include leakcanary version, exclusions, etc.
     CanaryLog.d("%s", heapAnalysis)
 
@@ -39,12 +40,12 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         var libraryLeakCount = 0
 
         for ((_, projection) in groupProjections) {
-            leakCount += projection.leakCount
-            when {
-              projection.isLibraryLeak -> libraryLeakCount += projection.leakCount
-              projection.isNew -> newLeakCount += projection.leakCount
-              else -> knownLeakCount += projection.leakCount
-            }
+          leakCount += projection.leakCount
+          when {
+            projection.isLibraryLeak -> libraryLeakCount += projection.leakCount
+            projection.isNew -> newLeakCount += projection.leakCount
+            else -> knownLeakCount += projection.leakCount
+          }
         }
 
         application.getString(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 3295d3b1f..732fff3b0 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -1,18 +1,39 @@
 package leakcanary
 
-import android.app.Application
 import android.content.Intent
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
 import leakcanary.internal.InternalLeakCanary
 
-typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
-
+/**
+ * The entry point API for LeakCanary. LeakCanary builds on top of [LeakSentry]. LeakSentry
+ * notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
+ * publishes the results.
+ *
+ * LeakCanary can be configured by updating [config].
+ */
 object LeakCanary {
 
+  /**
+   * LeakCanary configuration data class. Properties can be updated via [copy].
+   *
+   * @see [config]
+   */
   data class Config(
+    /**
+     * Whether LeakCanary should dump the heap when enough retained instances are found. This needs
+     * to be true for LeakCanary to work, but sometimes you may want to temporarily disable
+     * LeakCanary (e.g. for a product demo).
+     *
+     * Defaults to true.
+     */
     val dumpHeap: Boolean = true,
     /**
-     * The debugger can create temporary memory leaks (for instance if a thread is blocked on a
-     * breakpoint) so by default LeakCanary does not dump the heap when the debugger is attached.
+     * If [dumpHeapWhenDebugging] is false then LeakCanary will not dump the heap
+     * when the debugger is attached. The debugger can create temporary memory leaks (for instance
+     * if a thread is blocked on a breakpoint).
+     *
+     * Defaults to false.
      */
     val dumpHeapWhenDebugging: Boolean = false,
     /**
@@ -22,43 +43,81 @@ object LeakCanary {
      * especially frustrating as the Android Framework has a number of leaks that cannot easily
      * be fixed.
      *
-     * When the app becomes invisible, LeakCanary dumps the heap immediately.
+     * When the app becomes invisible, LeakCanary dumps the heap after
+     * [LeakSentry.Config.watchDurationMillis] ms.
+     *
+     * The app is considered visible if it has at least one activity in started state.
      *
      * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
      * bothering developers as much but it could miss some leaks.
+     *
+     * Defaults to 5.
      */
     val retainedVisibleThreshold: Int = 5,
 
+    /**
+     * Known patterns of references in the heap, lister here either to ignore them
+     * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+     *
+     * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
+     * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
+     * for the Android OS version and manufacturer. The build information can be obtained by calling
+     * [HprofGraph.androidBuildMirror].
+     *
+     * Defaults to [AndroidReferenceMatchers.appDefaults]
+     */
     val referenceMatchers: List<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults,
 
-    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.defaultInspectors(),
+    /**
+     * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
+     * heap. You can create your own [ObjectInspector] implementations, and also add
+     * a [AppSingletonInspector] instance created with the list of internal singletons.
+     *
+     * Defaults to [AndroidObjectInspectors.appDefaults]
+     */
+    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.appDefaults,
 
     /**
-     * Called with the heap analysis result from a background thread.
-     * The heap dump file will be removed immediately after this function is invoked.
+     * Called on a background thread when the heap analysis is complete.
      * If you want leaks to be added to the activity that lists leaks, make sure to delegate
-     * calls to [DefaultAnalysisResultListener].
+     * calls to a [DefaultOnHeapAnalyzedListener].
+     *
+     * Defaults to [DefaultOnHeapAnalyzedListener]
      */
-    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener,
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener(
+        InternalLeakCanary.application
+    ),
+
     /**
-     * Whether to compute the total number of bytes in memory that would be reclaimed if the
-     * detected leaks didn't happen. This includes native memory associated to Java objects
-     * (e.g. bitmaps).
-     * Computing the retained heap size can slow down the leak analysis and is off by default.
+     * Whether to compute the retained heap size, which is the total number of bytes in memory that
+     * would be reclaimed if the detected leaks didn't happen. This includes native memory
+     * associated to Java objects (e.g. Android bitmaps).
+     *
+     * Computing the retained heap size can slow down the analysis because it requires navigating
+     * from GC roots through the entire object graph, whereas [HeapAnalyzer] would otherwise stop
+     * as soon as all leaking instances are found.
+     *
+     * Defaults to true.
      */
-    val computeRetainedHeapSize: Boolean = false,
+    val computeRetainedHeapSize: Boolean = true,
 
     /**
-     * How many heap dumps are kept locally. When this threshold is reached LeakCanary starts
-     * deleting the older heap dumps. As several heap dumps may be enqueued you should avoid
-     * going down to 1 or 2.
+     * How many heap dumps are kept on the Android device for this app package. When this threshold
+     * is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued
+     * you should avoid going down to 1 or 2.
+     *
+     * Defaults to 7.
      */
     val maxStoredHeapDumps: Int = 7,
 
     /**
-     * LeakCanary always attempts to store heap dumps on the external storage first. If the
-     * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
-     * is true, then LeakCanary will display a notification to ask for that permission.
+     * LeakCanary always attempts to store heap dumps on the external storage if the
+     * WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage.
+     * If the WRITE_EXTERNAL_STORAGE permission is not granted and
+     * [requestWriteExternalStoragePermission] is true, then LeakCanary will display a notification
+     * to ask for that permission.
+     *
+     * Defaults to false because that permission notification can be annoying.
      */
     val requestWriteExternalStoragePermission: Boolean = false,
 
@@ -67,14 +126,32 @@ object LeakCanary {
      * tracked by [KeyedWeakReference]. This leads to finding more leaks and shorter leak traces.
      * However this also means the same leaking instances will be found in every heap dump for a
      * given process life.
+     *
+     * Defaults to false.
      */
     val useExperimentalLeakFinders: Boolean = false
   )
 
+  /**
+   * The current LeakCanary configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(computeRetainedHeapSize = true)
+   * ```
+   */
   @Volatile
   var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
 
-  /** [Intent] that can be used to programmatically launch the leak display activity. */
-  val leakDisplayActivityIntent
-    get() = InternalLeakCanary.leakDisplayActivityIntent
+  /**
+   * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
+   */
+  fun newLeakDisplayActivityIntent() = InternalLeakCanary.leakDisplayActivityIntent
+
+  /**
+   * Immediately triggers a heap dump and analysis, if there is at least one retained instance
+   * tracked by [LeakSentry.objectWatcher]. If there are no retained instances then the heap will not
+   * be dumped and a notification will be shown instead.
+   */
+  fun dumpHeap() = InternalLeakCanary.onDumpHeapReceived()
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
new file mode 100644
index 000000000..50d552cf1
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
@@ -0,0 +1,39 @@
+package leakcanary
+
+import leakcanary.ObjectInspector.Companion.invoke
+import leakcanary.OnHeapAnalyzedListener.Companion.invoke
+
+/**
+ * Listener set in [LeakCanary.Config] and called by LeakCanary on a background thread when the
+ * heap analysis is complete.
+ *
+ * You can create a [OnHeapAnalyzedListener] from a lambda by calling [invoke].
+ */
+interface OnHeapAnalyzedListener {
+
+  /**
+   * @see OnHeapAnalyzedListener
+   */
+  fun onHeapAnalyzed(heapAnalysis: HeapAnalysis)
+
+  companion object {
+    /**
+     * Utility function to create a [OnHeapAnalyzedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHeapAnalyzedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapAnalysis) -> Unit): OnHeapAnalyzedListener =
+      object : OnHeapAnalyzedListener {
+        override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+          block(heapAnalysis)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 7c661f0aa..324c68dde 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -21,7 +21,6 @@ import android.os.Build.VERSION.SDK_INT
 import android.os.Process
 import com.squareup.leakcanary.core.R
 import leakcanary.AnalyzerProgressListener
-import leakcanary.AndroidReferenceMatchers
 import leakcanary.AndroidObjectInspectors
 import leakcanary.CanaryLog
 import leakcanary.HeapAnalyzer
@@ -66,7 +65,7 @@ internal class HeapAnalyzerService : ForegroundService(
           )
       )
 
-    config.analysisResultListener(application, heapAnalysis)
+    config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)
   }
 
   override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index c01105594..8183afbca 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -12,7 +12,7 @@ import leakcanary.GcTrigger
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
@@ -20,7 +20,7 @@ import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val gcTrigger: GcTrigger,
   private val heapDumper: HeapDumper,
   private val configProvider: () -> Config
@@ -36,7 +36,7 @@ internal class HeapDumpTrigger(
   @Volatile
   private var checkScheduled: Boolean = false
 
-  private var lastDisplayedRetainedInstanceCount = 0
+  private var lastDisplayedRetainedObjectCount = 0
 
   private val scheduleDismissRetainedCountNotification = {
     dismissRetainedCountNotification()
@@ -65,35 +65,35 @@ internal class HeapDumpTrigger(
       applicationInvisibleAt = -1L
     } else {
       applicationInvisibleAt = SystemClock.uptimeMillis()
-      scheduleRetainedInstanceCheck("app became invisible", LeakSentry.config.watchDurationMillis)
+      scheduleRetainedObjectCheck("app became invisible", LeakSentry.config.watchDurationMillis)
     }
   }
 
-  fun onReferenceRetained() {
-    scheduleRetainedInstanceCheck("found new instance retained")
+  fun onObjectRetained() {
+    scheduleRetainedObjectCheck("found new object retained")
   }
 
-  private fun checkRetainedInstances(reason: String) {
+  private fun checkRetainedObjects(reason: String) {
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
-      CanaryLog.d("No checking for retained instance: LeakCanary.Config.dumpHeap is false")
+      CanaryLog.d("No checking for retained object: LeakCanary.Config.dumpHeap is false")
       return
     }
-    CanaryLog.d("Checking retained instances because %s", reason)
+    CanaryLog.d("Checking retained object because %s", reason)
 
-    var retainedReferenceCount = refWatcher.retainedInstanceCount
+    var retainedReferenceCount = objectWatcher.retainedObjectCount
 
     if (retainedReferenceCount > 0) {
       gcTrigger.runGc()
-      retainedReferenceCount = refWatcher.retainedInstanceCount
+      retainedReferenceCount = objectWatcher.retainedObjectCount
     }
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
       showRetainedCountWithDebuggerAttached(retainedReferenceCount)
-      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      scheduleRetainedObjectCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
       CanaryLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
           WAIT_FOR_DEBUG_MILLIS
@@ -108,12 +108,12 @@ internal class HeapDumpTrigger(
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
       CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
-      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedObjectCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
       showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
     }
-    lastDisplayedRetainedInstanceCount = 0
-    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+    lastDisplayedRetainedObjectCount = 0
+    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -122,17 +122,17 @@ internal class HeapDumpTrigger(
     backgroundHandler.post {
       dismissNoRetainedOnTapNotification()
       gcTrigger.runGc()
-      val retainedReferenceCount = refWatcher.retainedInstanceCount
+      val retainedReferenceCount = objectWatcher.retainedObjectCount
       if (retainedReferenceCount == 0) {
-        CanaryLog.d("No retained instances after GC")
+        CanaryLog.d("No retained objects after GC")
         @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
-                application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+                application.getString(R.string.leak_canary_notification_no_retained_object_title)
             )
             .setContentText(
                 application.getString(
-                    R.string.leak_canary_notification_no_retained_instance_content
+                    R.string.leak_canary_notification_no_retained_object_content
                 )
             )
             .setAutoCancel(true)
@@ -140,13 +140,13 @@ internal class HeapDumpTrigger(
         val notification =
           Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
         notificationManager.notify(
-            R.id.leak_canary_notification_no_retained_instance_on_tap, notification
+            R.id.leak_canary_notification_no_retained_object_on_tap, notification
         )
         backgroundHandler.postDelayed(
             scheduleDismissNoRetainedOnTapNotification,
-            DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+            DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
         )
-        lastDisplayedRetainedInstanceCount = 0
+        lastDisplayedRetainedObjectCount = 0
         return@post
       }
 
@@ -160,8 +160,8 @@ internal class HeapDumpTrigger(
         showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
-      lastDisplayedRetainedInstanceCount = 0
-      refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+      lastDisplayedRetainedObjectCount = 0
+      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
@@ -170,12 +170,12 @@ internal class HeapDumpTrigger(
     retainedKeysCount: Int,
     retainedVisibleThreshold: Int
   ): Boolean {
-    val countChanged = lastDisplayedRetainedInstanceCount != retainedKeysCount
-    lastDisplayedRetainedInstanceCount = retainedKeysCount
+    val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
+    lastDisplayedRetainedObjectCount = retainedKeysCount
     if (retainedKeysCount == 0) {
-      CanaryLog.d("No retained instances")
+      CanaryLog.d("No retained objects")
       if (countChanged) {
-        showNoMoreRetainedInstanceNotification()
+        showNoMoreRetainedObjectNotification()
       }
       return true
     }
@@ -183,13 +183,13 @@ internal class HeapDumpTrigger(
     if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
         CanaryLog.d(
-            "Found %d retained instances, which is less than the visible threshold of %d",
+            "Found %d retained objects, which is less than the visible threshold of %d",
             retainedKeysCount,
             retainedVisibleThreshold
         )
         showRetainedCountBelowThresholdNotification(retainedKeysCount, retainedVisibleThreshold)
-        scheduleRetainedInstanceCheck(
-            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        scheduleRetainedObjectCheck(
+            "Showing retained objects notification", WAIT_FOR_OBJECT_THRESHOLD_MILLIS
         )
         return true
       }
@@ -197,7 +197,7 @@ internal class HeapDumpTrigger(
     return false
   }
 
-  private fun scheduleRetainedInstanceCheck(reason: String) {
+  private fun scheduleRetainedObjectCheck(reason: String) {
     if (checkScheduled) {
       CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
       return
@@ -205,11 +205,11 @@ internal class HeapDumpTrigger(
     checkScheduled = true
     backgroundHandler.post {
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }
   }
 
-  private fun scheduleRetainedInstanceCheck(
+  private fun scheduleRetainedObjectCheck(
     reason: String,
     delayMillis: Long
   ) {
@@ -220,60 +220,60 @@ internal class HeapDumpTrigger(
     checkScheduled = true
     backgroundHandler.postDelayed({
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }, delayMillis)
   }
 
   private fun showRetainedCountBelowThresholdNotification(
-    instanceCount: Int,
+    objectCount: Int,
     retainedVisibleThreshold: Int
   ) {
     showRetainedCountNotification(
-        instanceCount, application.getString(
+        objectCount, application.getString(
         R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
     )
     )
   }
 
-  private fun showRetainedCountWithDebuggerAttached(instanceCount: Int) {
+  private fun showRetainedCountWithDebuggerAttached(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount,
+        objectCount,
         application.getString(R.string.leak_canary_notification_retained_debugger_attached)
     )
   }
 
-  private fun showRetainedCountWithHeapDumpFailed(instanceCount: Int) {
+  private fun showRetainedCountWithHeapDumpFailed(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
+        objectCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
     )
   }
 
-  private fun showNoMoreRetainedInstanceNotification() {
+  private fun showNoMoreRetainedObjectNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     if (!Notifications.canShowNotification) {
       return
     }
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+            application.getString(R.string.leak_canary_notification_no_retained_object_title)
         )
         .setContentText(
             application.getString(
-                R.string.leak_canary_notification_no_retained_instance_content
+                R.string.leak_canary_notification_no_retained_object_content
             )
         )
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
     backgroundHandler.postDelayed(
-        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
     )
   }
 
   private fun showRetainedCountNotification(
-    instanceCount: Int,
+    objectCount: Int,
     contentText: String
   ) {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
@@ -283,31 +283,31 @@ internal class HeapDumpTrigger(
     @Suppress("DEPRECATION")
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
+            application.getString(R.string.leak_canary_notification_retained_title, objectCount)
         )
         .setContentText(contentText)
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
   }
 
   private fun dismissRetainedCountNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
+    notificationManager.cancel(R.id.leak_canary_notification_retained_objects)
   }
 
   private fun dismissNoRetainedOnTapNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_no_retained_instance_on_tap)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_object_on_tap)
   }
 
   companion object {
     private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
-    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 2_000L
-    private const val DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS = 30_000L
+    private const val WAIT_FOR_OBJECT_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index be4be031e..6c0470a8c 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -17,13 +17,13 @@ import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
-import leakcanary.OnInstanceRetainedListener
+import leakcanary.OnObjectRetainedListener
 import leakcanary.internal.activity.LeakActivity
 import java.lang.reflect.InvocationHandler
 import java.lang.reflect.Proxy
 import java.util.concurrent.atomic.AtomicReference
 
-internal object InternalLeakCanary : (Application) -> Unit, OnInstanceRetainedListener {
+internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
 
   private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
 
@@ -64,7 +64,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnInstanceRetainedLi
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+        application, backgroundHandler, LeakSentry.objectWatcher, gcTrigger, heapDumper, configProvider
     )
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
@@ -208,9 +208,9 @@ internal object InternalLeakCanary : (Application) -> Unit, OnInstanceRetainedLi
     }
   }
 
-  override fun onReferenceRetained() {
+  override fun onObjectRetained() {
     if (this::heapDumpTrigger.isInitialized) {
-      heapDumpTrigger.onReferenceRetained()
+      heapDumpTrigger.onObjectRetained()
     }
   }
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
similarity index 85%
rename from leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
rename to leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
index 786cb3aad..19800a17b 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package leakcanary.internal
 
 import java.io.ByteArrayInputStream
 import java.io.ByteArrayOutputStream
@@ -6,13 +6,13 @@ import java.io.ObjectInputStream
 import java.io.ObjectOutputStream
 import java.io.Serializable
 
-fun Serializable.toByteArray(): ByteArray {
+internal fun Serializable.toByteArray(): ByteArray {
   val outputStream = ByteArrayOutputStream()
   ObjectOutputStream(outputStream).writeObject(this)
   return outputStream.toByteArray()
 }
 
-object Serializables {
+internal object Serializables {
 
   inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
     val inputStream = ByteArrayInputStream(byteArray)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 086a45efe..4f4d02ab3 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -8,10 +8,10 @@ import leakcanary.CanaryLog
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.Serializables
+import leakcanary.internal.Serializables
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.LeakDirectoryProvider
-import leakcanary.toByteArray
+import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
 import java.io.File
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index c16478e0d..a557df8aa 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -7,9 +7,9 @@ import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.Leak
 import leakcanary.Leak.LibraryLeak
-import leakcanary.Serializables
+import leakcanary.internal.Serializables
 import leakcanary.internal.utils.to
-import leakcanary.toByteArray
+import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
 
 internal object LeakingInstanceTable {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
index 6eb7ab035..7225747ad 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -84,7 +84,7 @@ internal class HeapAnalysisListScreen : Screen() {
         )
 
         val title = projection.exceptionSummary ?: resources.getQuantityString(
-            R.plurals.leak_canary_heap_analysis_list_retained_instances,
+            R.plurals.leak_canary_heap_analysis_list_retained_objects,
             projection.retainedInstanceCount, projection.retainedInstanceCount
         )
         titleView.text = "$index. $title"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index 91d784c74..dfafa8f4a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -100,7 +100,8 @@ internal object HeapDumpRenderer {
     val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
     val parser = HprofPushRecordsParser()
-    val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
+    var lastPosition = 0L
+    parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
       override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
 
       val hprofStringCache = mutableMapOf<Long, String>()
@@ -113,6 +114,7 @@ internal object HeapDumpRenderer {
         position: Long,
         record: Record
       ) {
+        lastPosition = position
         when (record) {
           is StringRecord -> {
             hprofStringCache[record.id] = record.string
@@ -158,9 +160,8 @@ internal object HeapDumpRenderer {
           }
         }
       }
-    }))
-    val heapLength = reader.position
-    reader.close()
+    })).close()
+    val heapLength = lastPosition
 
     val width = sourceWidth
     var height: Int
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index 78addf1f1..ef8fdb22c 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -26,14 +26,6 @@ import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
 import leakcanary.HprofGraph
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.BYTE
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.PrimitiveType.DOUBLE
-import leakcanary.PrimitiveType.FLOAT
-import leakcanary.PrimitiveType.INT
-import leakcanary.PrimitiveType.LONG
-import leakcanary.PrimitiveType.SHORT
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
@@ -93,7 +85,7 @@ internal class HprofExplorerScreen(
                 .setPositiveButton(android.R.string.ok) { _, _ ->
                   executeOnIo {
                     val partialClassName = input.text.toString()
-                    val matchingClasses = graph.classSequence()
+                    val matchingClasses = graph.classes
                         .filter { partialClassName in it.name }
                         .toList()
 
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index 0c625e360..ed47a2739 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -48,7 +48,7 @@
   <string name="leak_canary_options_menu_permission_toast">Bitte erlaube zunächst die Speicher-Berechtigung, siehe Benachrichtigung…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
     <item quantity="one">%d erhaltene Instanz</item>
     <item quantity="other">%d erhaltene Instanzen</item>
   </plurals>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
index d352338b9..c1074bd4f 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -19,6 +19,6 @@
   <item type="id" name="leak_canary_notification_analysis_result" />
   <item type="id" name="leak_canary_notification_dumping_heap" />
   <item type="id" name="leak_canary_notification_analyzing_heap" />
-  <item type="id" name="leak_canary_notification_retained_instances" />
-  <item type="id" name="leak_canary_notification_no_retained_instance_on_tap" />
+  <item type="id" name="leak_canary_notification_retained_objects" />
+  <item type="id" name="leak_canary_notification_no_retained_object_on_tap" />
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 0d46f60ad..523de211c 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -34,12 +34,12 @@
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_notification_no_retained_instance_title">All retained instances were garbage collected</string>
-  <string name="leak_canary_notification_no_retained_instance_content">Tap to dismiss</string>
+  <string name="leak_canary_notification_no_retained_object_title">All retained objects were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_object_content">Tap to dismiss</string>
   <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
   <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
-  <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
-  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained instances</string>
+  <string name="leak_canary_notification_retained_title">%d retained objects, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained objects</string>
   <string name="leak_canary_share_leak">Share Info</string>
   <string name="leak_canary_share_heap_dump">Share Heap Dump</string>
   <string name="leak_canary_share_with">Share with…</string>
@@ -61,15 +61,15 @@
   <string name="leak_canary_options_menu_permission_toast">Please grant the External Storage Permission first, see notification…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendering HQ Bitmap, this may take a while…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendering HQ Bitmap, this may take a while…</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
-    <item quantity="one">%d Retained Instance</item>
-    <item quantity="other">%d Retained Instances</item>
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
+    <item quantity="one">%d Retained Objects</item>
+    <item quantity="other">%d Retained Objects</item>
   </plurals>
   <string name="leak_canary_share_heap_dump_bitmap_screen_title">Share Heap Dump Bitmap</string>
   <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
   <string name="leak_canary_analysis_deleted_title">Analysis Deleted</string>
   <string name="leak_canary_go_to_heap_analysis">Go to Heap Analysis</string>
-  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Instances)</string>
+  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Objects)</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title">(%1$d / %2$d Total) %3$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title_new">[NEW] (%1$d) %2$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_time_format">Latest: %s</string>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index bb5beb058..f99e738eb 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -25,13 +25,13 @@ class FragmentLeakTest {
   )
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
index 3f15083f7..b168ee2a9 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -13,18 +13,18 @@ import java.util.Date
 class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test fun detectsLeak() {
     leaking = Date()
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = LeakSentry.objectWatcher
     refWatcher.watch(leaking)
     assertLeak(Date::class.java)
   }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
index 346cd2397..2d49a6556 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
@@ -4,8 +4,7 @@ import org.junit.runner.Description
 import org.junit.runner.notification.RunListener
 
 /**
- *
- * A JUnit [RunListener] subclassing [FailTestOnLeakRunListener] for detecting memory
+ * A JUnit [RunListener] extending [FailTestOnLeakRunListener] to detecting memory
  * leaks in Android instrumentation tests only when the [FailTestOnLeak] annotation
  * is used.
  *
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
index 1721e18c8..024e3aa03 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
@@ -1,7 +1,6 @@
 package leakcanary
 
 /**
- *
  * An [Annotation] class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener]
  * for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener], the tests
  * should be annotated with this class in order for the listener to detect memory leaks.
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index b0d2a6e6d..b8d149663 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -29,12 +29,12 @@ import org.junit.runner.notification.RunListener
 
 /**
  *
- * A JUnit [RunListener] for detecting memory leaks in Android instrumentation tests. It
- * waits for the end of a test, and if the test succeeds then it will look for leaking
- * references, trigger a heap dump if needed and perform an analysis.
+ * A JUnit [RunListener] that uses [InstrumentationLeakDetector] to detect memory leaks in Android
+ * instrumentation tests. It waits for the end of a test, and if the test succeeds then it will
+ * look for retained objects, trigger a heap dump if needed and perform an analysis.
  *
- *  [FailTestOnLeakRunListener] can be subclassed to override
- * [skipLeakDetectionReason] and [onAnalysisPerformed]
+ *  [FailTestOnLeakRunListener] can be subclassed to override [skipLeakDetectionReason] and
+ *  [onAnalysisPerformed]
  *
  * @see InstrumentationLeakDetector
  */
@@ -60,7 +60,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   /**
    * Can be overridden to skip leak detection based on the description provided when a test
-   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * is started. Return null to continue leak detection, or a string describing the reason for
    * skipping otherwise.
    */
   protected open fun skipLeakDetectionReason(description: Description): String? {
@@ -81,7 +81,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakSentry.refWatcher.clearWatchedInstances()
+    LeakSentry.objectWatcher.clearWatchedObjects()
   }
 
   override fun testRunStarted(description: Description) {
@@ -106,7 +106,9 @@ open class FailTestOnLeakRunListener : RunListener() {
   }
 
   /**
-   * Default implementation call [failTest] if the [heapAnalysis] failed or if
+   * Called when a heap analysis has been performed and a result is available.
+   *
+   * The default implementation call [failTest] if the [heapAnalysis] failed or if
    * [HeapAnalysisSuccess.applicationLeaks] is not empty.
    */
   protected open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis) {
@@ -123,6 +125,9 @@ open class FailTestOnLeakRunListener : RunListener() {
     }
   }
 
+  /**
+   * Reports that the test has failed, with the provided [message].
+   */
   protected fun failTest(message: String) {
     bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
     getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 7e0076c64..276ac33f2 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -25,40 +25,20 @@ import org.junit.runner.notification.RunListener
 import java.io.File
 
 /**
- * TODO Update this doc to match LeakCanary 2.0
- *
  * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
  *
  * To use it, you need to:
  *
- *  * Install a custom RefWatcher that will not trigger heapdumps while the tests run.
- *  * Add an instrumentation test listener (a [RunListener]) that will invoke
- * [detectLeaks]
- *
- * ### Installing the instrumentation RefWatcher
- *
- * For [detectLeaks] to work correctly, the [RefWatcher] must keep track of
- * references but not trigger any heap dump until this [detectLeaks] runs, otherwise an
- * analysis in progress might prevent this listener from performing its own analysis.
- *
- * Create and install the [RefWatcher] instance using
- * [instrumentationRefWatcher] instead of
- * [LeakCanary.install] or [LeakCanary.refWatcher].
- *
- * ```
- * public class InstrumentationExampleApplication extends ExampleApplication {
- *  @Override protected void setupLeakCanary() {
- *    InstrumentationLeakDetector.instrumentationRefWatcher(this)
- *      .buildAndInstall();
- *  }
- * }
- * ```
+ *  - Call [updateConfig] so that [LeakSentry] will watch objects and [LeakCanary] will not dump
+ *  the heap on retained objects
+ *  - Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener]) that will invoke
+ * [detectLeaks].
  *
  * ### Add an instrumentation test listener
  *
- * LeakCanary provides [FailTestOnLeakRunListener], but you should feel free to implement
- * your own [RunListener] and call [.detectLeaks] directly if you need a more custom
- * behavior (for instance running it only once per test suite, or reporting to a backend).
+ * LeakCanary provides [FailTestOnLeakRunListener], but you can also implement
+ * your own [RunListener] and call [detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite).
  *
  * All you need to do is add the following to the defaultConfig of your build.gradle:
  *
@@ -80,46 +60,52 @@ import java.io.File
  * ```
  *
  * ### Rationale
- * Instead of using the [FailTestOnLeakRunListener], one could simply enable LeakCanary in
+ * Instead of using the [InstrumentationLeakDetector], one could simply enable LeakCanary in
  * instrumentation tests.
  *
  * This approach would have two disadvantages:
  *
- *  * Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ *  - Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
  * the test and introduce flakiness
- *  * The leak analysis is asynchronous by default, and happens in a separate process. This means
- * the tests could finish and the process die before the analysis is finished.
+ *  - The leak analysis is asynchronous by default. This means the tests could finish and the
+ *  process die before the analysis is finished.
  *
- * The approach taken here is to collect all references to watch as you run the test, but not
+ * The approach taken here is to collect all objects to watch as you run the test, but not
  * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
  * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
- * no matter the number of objects leaking.
+ * no matter the number of objects retained.
  */
 class InstrumentationLeakDetector {
 
+  /**
+   * The result of calling [detectLeaks], which is either [NoAnalysis] or [AnalysisPerformed].
+   */
   sealed class Result {
     object NoAnalysis : Result()
     class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
   }
 
+  /**
+   * Looks for retained objects, triggers a heap dump if needed and performs an analysis.
+   */
   fun detectLeaks(): Result {
     val leakDetectionTime = SystemClock.uptimeMillis()
     val watchDurationMillis = LeakSentry.config.watchDurationMillis
     val instrumentation = getInstrumentation()
     val context = instrumentation.targetContext
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = LeakSentry.objectWatcher
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     instrumentation.waitForIdleSync()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     runGc()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -127,7 +113,7 @@ class InstrumentationLeakDetector {
     // Android simply has way too many delayed posts that aren't canceled when views are detached.
     SystemClock.sleep(2000)
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -143,7 +129,7 @@ class InstrumentationLeakDetector {
 
     runGc()
 
-    if (!refWatcher.hasRetainedInstances) {
+    if (!refWatcher.hasRetainedObjects) {
       return NoAnalysis
     }
 
@@ -168,7 +154,7 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
     val listener = AnalyzerProgressListener.NONE
 
@@ -190,12 +176,14 @@ class InstrumentationLeakDetector {
   companion object {
 
     /**
-     * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
-     * and we can look for leaks at the end of a test. This is automatically called by
-     * [FailTestOnLeakRunListener] when the tests start running.
+     * Configures [LeakSentry] to watch objects and [LeakCanary] to not dump the heap on retained
+     * objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
+     * a test. This is automatically called by [FailTestOnLeakRunListener] when the tests start
+     * running.
      */
     fun updateConfig() {
       LeakSentry.config = LeakSentry.config.copy(enabled = true)
+      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
     }
   }
 }
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
index 39186f607..456102075 100644
--- a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -8,6 +8,14 @@ import android.content.pm.PackageInfo
 import android.content.pm.PackageManager
 import android.content.pm.ServiceInfo
 
+/**
+ * Used to determine whether the current process is the LeakCanary analyzer process. By depending
+ * on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary
+ * will automatically run its analysis in a separate process.
+ *
+ * As such, you'll need to be careful to do any custom configuration of LeakCanary in both the main
+ * process and the analyzer process.
+ */
 object LeakCanaryProcess {
 
   @Volatile private var isInAnalyzerProcess: Boolean? = null
diff --git a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
index ddfea9c9f..59b328d42 100644
--- a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
+++ b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
@@ -19,17 +19,14 @@ class CLILogger : Logger {
   }
 
   override fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
     d(String.format(message, *args) + '\n' + getStackTraceString(throwable))
   }
 
-  private fun getStackTraceString(throwable: Throwable?): String {
-    if (throwable == null) {
-      return ""
-    }
+  private fun getStackTraceString(throwable: Throwable): String {
     val stringWriter = StringWriter()
     val printWriter = PrintWriter(stringWriter, false)
     throwable.printStackTrace(printWriter)
diff --git a/leakcanary-cli/src/main/java/leakcanary/Main.kt b/leakcanary-cli/src/main/java/leakcanary/Main.kt
index 4ac6d9e51..9d5569d2f 100644
--- a/leakcanary-cli/src/main/java/leakcanary/Main.kt
+++ b/leakcanary-cli/src/main/java/leakcanary/Main.kt
@@ -134,7 +134,7 @@ private fun analyze(heapDumpFile: File) {
   CanaryLog.d("Analyzing heap dump $heapDumpFile")
   val heapAnalysis = heapAnalyzer.checkForLeaks(
       heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
-      AndroidObjectInspectors.defaultInspectors()
+      AndroidObjectInspectors.appDefaults
   )
 
   CanaryLog.d(heapAnalysis.toString())
diff --git a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index 3c579c0b8..a7bae01a8 100644
--- a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
+++ b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -20,10 +20,10 @@ import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
 import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 
 internal class AndroidXFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
 ) : (Activity) -> Unit {
 
@@ -35,7 +35,7 @@ internal class AndroidXFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -44,7 +44,7 @@ internal class AndroidXFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
index fa7b3b9fc..01f2e243d 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
@@ -1,9 +1,18 @@
 package leakcanary
 
+/**
+ * A GcRoot as identified by [Record.HeapDumpRecord.GcRootRecord] in the heap dump.
+ */
 sealed class GcRoot {
 
+  /**
+   * The object id of the object that this gc root references.
+   */
   abstract val id: Long
 
+  /**
+   * An unknown gc root.
+   */
   class Unknown(override val id: Long) : GcRoot()
 
   /**
@@ -27,7 +36,7 @@ sealed class GcRoot {
   ) : GcRoot()
 
   /**
-   * Java local variable
+   * A java local variable
    */
   class JavaFrame(
     override val id: Long,
@@ -51,7 +60,7 @@ sealed class GcRoot {
   ) : GcRoot()
 
   /**
-   * System class
+   * A system class
    */
   class StickyClass(override val id: Long) : GcRoot()
 
@@ -67,6 +76,8 @@ sealed class GcRoot {
   class MonitorUsed(override val id: Long) : GcRoot()
 
   /**
+   * A thread.
+   *
    * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
    */
   class ThreadObject(
@@ -75,16 +86,28 @@ sealed class GcRoot {
     val stackTraceSerialNumber: Int
   ) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class ReferenceCleanup(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class VmInternal(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class JniMonitor(
     override val id: Long,
     val stackTraceSerialNumber: Int,
     val stackDepth: Int
   ) : GcRoot()
 
+  /**
+   * An interned string, see [java.lang.String.intern].
+   */
   class InternedString(override val id: Long) : GcRoot()
 
   /**
@@ -92,6 +115,9 @@ sealed class GcRoot {
    */
   class Finalizing(override val id: Long) : GcRoot()
 
+  /**
+   * An object held by a connected debugger
+   */
   class Debugger(override val id: Long) : GcRoot()
 
   /**
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
index 2b12fbe26..3fed69d68 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
@@ -1,5 +1,9 @@
 package leakcanary
 
+/**
+ * In memory store that can be used to store objects in a given [HprofGraph] instance.
+ * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
+ */
 class GraphContext {
   private val store = mutableMapOf<String, Any>()
   operator fun <T> get(key: String): T? {
@@ -7,6 +11,9 @@ class GraphContext {
     return store[key] as T?
   }
 
+  /**
+   * @see MutableMap.getOrPut
+   */
   fun <T> getOrPut(
     key: String,
     defaultValue: () -> T
@@ -17,6 +24,9 @@ class GraphContext {
     }) as T
   }
 
+  /**
+   * @see MutableMap.set
+   */
   operator fun <T> set(
     key: String,
     value: T
@@ -24,10 +34,16 @@ class GraphContext {
     store[key] = (value as Any)
   }
 
+  /**
+   * @see MutableMap.containsKey
+   */
   operator fun contains(key: String): Boolean {
     return key in store
   }
 
+  /**
+   * @see MutableMap.remove
+   */
   operator fun minusAssign(key: String) {
     @Suppress("UNCHECKED_CAST")
     store -= key
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
index f03b68e93..882db9f22 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
@@ -5,21 +5,47 @@ import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 
+/**
+ * Represents a static field or an instance field.
+ */
 class GraphField(
+  /**
+   * The class this field was declared in.
+   */
   val classRecord: GraphClassRecord,
+  /**
+   * Name of the field
+   */
   val name: String,
+  /**
+   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
+   * [valueAsObjectArray], [valueAsPrimitiveArray].
+   */
   val value: GraphHeapValue
 ) {
 
+  /**
+   * Return a [GraphClassRecord] is [value] references a class, and null otherwise.
+   */
   val valueAsClass: GraphClassRecord?
     get() = value.asObject?.asClass
 
+  /**
+   * Return a [GraphInstanceRecord] is [value] references an instance, and null otherwise.
+   */
   val valueAsInstance: GraphInstanceRecord?
     get() = value.asObject?.asInstance
 
+  /**
+   * Return a [GraphObjectArrayRecord] is [value] references an object array, and null otherwise.
+   */
   val valueAsObjectArray: GraphObjectArrayRecord?
     get() = value.asObject?.asObjectArray
 
+  /**
+   * Return a [GraphPrimitiveArrayRecord] is [value] references a primitive array, and null
+   * otherwise.
+   */
   val valueAsPrimitiveArray: GraphPrimitiveArrayRecord?
     get() = value.asObject?.asPrimitiveArray
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
index a19c8de33..6cf1eb15d 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -10,6 +10,10 @@ import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
 
+/**
+ * Represents a value in the heap dump, which can be an object reference or
+ * a primitive type. Provides navigation capabilities.
+ */
 class GraphHeapValue(
   private val graph: HprofGraph,
   val actual: HeapValue
@@ -38,10 +42,10 @@ class GraphHeapValue(
   val asLong: Long?
     get() = if (actual is LongValue) actual.value else null
 
-  val asObjectIdReference: Long?
+  val asObjectId: Long?
     get() = if (actual is ObjectReference) actual.value else null
 
-  val asNonNullObjectIdReference: Long?
+  val asNonNullObjectId: Long?
     get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
 
   val isNullReference: Boolean
@@ -53,7 +57,7 @@ class GraphHeapValue(
   val asObject: GraphObjectRecord?
     get() {
       return if (actual is ObjectReference && !actual.isNull) {
-        return graph.indexedObject(actual.value)
+        return graph.findObjectByObjectId(actual.value)
       } else {
         null
       }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index 11539f120..43a7c5405 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -14,8 +14,14 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.internal.IndexedObject.IndexedClass
 import leakcanary.internal.IndexedObject.IndexedInstance
 import leakcanary.internal.IndexedObject.IndexedObjectArray
@@ -23,8 +29,13 @@ import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
 import java.nio.charset.Charset
 import kotlin.reflect.KClass
 
+/**
+ * Represents an object in the heap dump and provides navigation capabilities.
+ */
 sealed class GraphObjectRecord {
 
+  abstract val graph: HprofGraph
+
   abstract val objectId: Long
 
   abstract fun readRecord(): ObjectRecord
@@ -41,11 +52,15 @@ sealed class GraphObjectRecord {
   val asPrimitiveArray: GraphPrimitiveArrayRecord?
     get() = if (this is GraphPrimitiveArrayRecord) this else null
 
+  /**
+   * Represents a class in the heap dump and provides navigation capabilities.
+   */
   class GraphClassRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedClass,
     override val objectId: Long
   ) : GraphObjectRecord() {
+
     override fun readRecord(): ClassDumpRecord {
       return graph.readClassDumpRecord(objectId, indexedObject)
     }
@@ -69,15 +84,15 @@ sealed class GraphObjectRecord {
 
     val superClass: GraphClassRecord?
       get() {
-        if (indexedObject.superClassId == 0L) return null
-        return graph.indexedObject(indexedObject.superClassId) as GraphClassRecord
+        if (indexedObject.superClassId == HeapValue.NULL_REFERENCE) return null
+        return graph.findObjectByObjectId(indexedObject.superClassId) as GraphClassRecord
       }
 
     val classHierarchy: Sequence<GraphClassRecord>
       get() = generateSequence(this) { it.superClass }
 
     val directInstances: Sequence<GraphInstanceRecord>
-      get() = graph.instanceSequence().filter { it.indexedObject.classId == objectId }
+      get() = graph.instances.filter { it.indexedObject.classId == objectId }
 
     fun readStaticFields(): Sequence<GraphField> {
       return readRecord().staticFields.asSequence()
@@ -104,19 +119,26 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents an instance in the heap dump and provides navigation capabilities.
+   */
   class GraphInstanceRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     internal val indexedObject: IndexedInstance,
     override val objectId: Long,
     val isPrimitiveWrapper: Boolean
   ) : GraphObjectRecord() {
+
+    val size
+      get() = instanceClass.instanceSize
+
     override fun readRecord(): InstanceDumpRecord {
       return graph.readInstanceDumpRecord(objectId, indexedObject)
     }
 
     infix fun instanceOf(className: String): Boolean {
       var currentClassId = indexedObject.classId
-      while (currentClassId != 0L) {
+      while (currentClassId != HeapValue.NULL_REFERENCE) {
         if (graph.className(currentClassId) == className) {
           return true
         }
@@ -160,7 +182,7 @@ sealed class GraphObjectRecord {
 
     val instanceClass: GraphClassRecord
       get() {
-        return graph.indexedObject(indexedObject.classId) as GraphClassRecord
+        return graph.findObjectByObjectId(indexedObject.classId) as GraphClassRecord
       }
 
     fun readFields(): Sequence<GraphField> {
@@ -209,7 +231,7 @@ sealed class GraphObjectRecord {
             val toIndex = if (offset + count > valueRecord.array.size) {
               valueRecord.array.size
             } else offset + count
-             valueRecord.array.copyOfRange(offset, toIndex)
+            valueRecord.array.copyOfRange(offset, toIndex)
           } else {
             valueRecord.array
           }
@@ -230,8 +252,11 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents an object array in the heap dump and provides navigation capabilities.
+   */
   class GraphObjectArrayRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedObjectArray,
     override val objectId: Long,
     val isPrimitiveWrapperArray: Boolean
@@ -240,6 +265,10 @@ sealed class GraphObjectRecord {
     val arrayClassName: String
       get() = graph.className(indexedObject.arrayClassId)
 
+    fun readSize(): Int {
+      return readRecord().elementIds.size * graph.idSize
+    }
+
     override fun readRecord(): ObjectArrayDumpRecord {
       return graph.readObjectArrayDumpRecord(objectId, indexedObject)
     }
@@ -254,11 +283,28 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents a primitive array in the heap dump and provides navigation capabilities.
+   */
   class GraphPrimitiveArrayRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedPrimitiveArray,
     override val objectId: Long
   ) : GraphObjectRecord() {
+
+    fun readSize(): Int {
+      return when (val record = readRecord()) {
+        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+      }
+    }
+
     val primitiveType: PrimitiveType
       get() = indexedObject.primitiveType
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
index 3178c4795..bf7208dda 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
@@ -1,19 +1,15 @@
 package leakcanary
 
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
 
+/**
+ * A value in the heap dump, which can be an [ObjectReference] or
+ * a primitive type.
+ */
 sealed class HeapValue {
   data class ObjectReference(val value: Long) : HeapValue() {
     val isNull
-      get() = value == 0L
+      get() = value == NULL_REFERENCE
   }
 
   data class BooleanValue(val value: Boolean) : HeapValue()
@@ -24,61 +20,8 @@ sealed class HeapValue {
   data class ShortValue(val value: Short) : HeapValue()
   data class IntValue(val value: Int) : HeapValue()
   data class LongValue(val value: Long) : HeapValue()
-}
 
-val HeapValue?.isNullReference
-  get() = this is ObjectReference && isNull
-
-val HeapValue?.reference
-  get() = if (this is ObjectReference && !isNull) {
-    this.value
-  } else
-    null
-
-val HeapValue?.boolean
-  get() = if (this is BooleanValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.char
-  get() = if (this is CharValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.float
-  get() = if (this is FloatValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.double
-  get() = if (this is DoubleValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.byte
-  get() = if (this is ByteValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.short
-  get() = if (this is ShortValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.int
-  get() = if (this is IntValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.long
-  get() = if (this is LongValue) {
-    this.value
-  } else
-    null
\ No newline at end of file
+  companion object {
+    const val NULL_REFERENCE = 0L
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index 3dbcb35b3..fd8fe4f56 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -20,6 +20,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.internal.FieldValuesReader
 import leakcanary.internal.HprofInMemoryIndex
 import leakcanary.internal.IndexedObject
 import leakcanary.internal.IndexedObject.IndexedClass
@@ -39,91 +40,102 @@ class HprofGraph internal constructor(
   private val index: HprofInMemoryIndex
 ) {
 
+  /**
+   * In memory store that can be used to store objects this [HprofGraph] instance.
+   */
   val context = GraphContext()
 
   /**
-   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
-   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
-   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+   * All GC roots which type matches the set passed to [HprofInMemoryIndex.createOnRecordListener].
    */
-  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+  val gcRoots: List<GcRoot>
+    get() = index.gcRoots()
 
-  fun indexedClass(className: String): GraphClassRecord? {
-    val classId = index.classId(className)
-    return if (classId == null) {
-      null
-    } else {
-      return indexedObject(classId) as GraphClassRecord
+  /**
+   * Sequence of all objects in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objects: Sequence<GraphObjectRecord>
+    get() {
+      return index.indexedObjectSequence()
+          .map {
+            wrapIndexedObject(it.second, it.first)
+          }
     }
-  }
 
-  fun readObjectRecord(objectId: Long): ObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
-      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
-      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
-      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+  /**
+   * Sequence of all classes in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val classes: Sequence<GraphClassRecord>
+    get() {
+      return index.indexedClassSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            GraphClassRecord(this, indexedObject, objectId)
+          }
     }
-  }
-
-  fun indexedObject(objectId: Long): GraphObjectRecord {
-    return wrapIndexedObject(index.indexedObject(objectId), objectId)
-  }
 
-  fun objectIdExists(objectId: Long): Boolean {
-    return index.objectIdIsIndexed(objectId)
-  }
-
-  fun computeShallowSize(graphObject: GraphObjectRecord): Int {
-    return when (graphObject) {
-      is GraphInstanceRecord -> graphObject.instanceClass.instanceSize
-      is GraphObjectArrayRecord -> graphObject.readRecord().elementIds.size * index.idSize
-      is GraphPrimitiveArrayRecord -> when (val record = graphObject.readRecord()) {
-        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-      }
-      is GraphClassRecord -> throw IllegalStateException(
-          "Unexpected record ${graphObject.readRecord()}"
-      )
+  /**
+   * Sequence of all instances in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val instances: Sequence<GraphInstanceRecord>
+    get() {
+      return index.indexedInstanceSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+            GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+          }
     }
-  }
 
-  fun instanceSequence(): Sequence<GraphInstanceRecord> {
-    return index.indexedInstanceSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-          GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-        }
-  }
+  internal val idSize
+    get() = index.idSize
+
+  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+  // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+  // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
 
-  fun objectSequence(): Sequence<GraphObjectRecord> {
-    return index.indexedObjectSequence()
-        .map {
-          wrapIndexedObject(it.second, it.first)
-        }
+  /**
+   * Returns the [GraphObjectRecord] corresponding to the provided [objectId], and throws
+   * [IllegalArgumentException] otherwise.
+   */
+  fun findObjectByObjectId(objectId: Long): GraphObjectRecord {
+    return wrapIndexedObject(index.indexedObject(objectId), objectId)
   }
 
-  fun gcRoots(): List<GcRoot> {
-    return index.gcRoots()
+  /**
+   * Returns the [GraphClassRecord] corresponding to the provided [className], or null if the
+   * class cannot be found.
+   */
+  fun findClassByClassName(className: String): GraphClassRecord? {
+    val classId = index.classId(className)
+    return if (classId == null) {
+      null
+    } else {
+      return findObjectByObjectId(classId) as GraphClassRecord
+    }
   }
 
-  fun classSequence(): Sequence<GraphClassRecord> {
-    return index.indexedClassSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          GraphClassRecord(this, indexedObject, objectId)
-        }
+  /**
+   * Returns true if the provided [objectId] exists in the heap dump.
+   */
+  fun objectExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
   }
 
+  /**
+   * Returns the byte size of the provided [hprofType].
+   *
+   * Note: this API may be removed eventually.
+   */
   fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
 
   internal fun fieldName(fieldRecord: FieldRecord): String {
@@ -147,6 +159,15 @@ class HprofGraph internal constructor(
     }
   }
 
+  internal fun readObjectRecord(objectId: Long): ObjectRecord {
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
+      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
+      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
+      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+  }
+
   internal fun className(classId: Long): String {
     return index.className(classId)
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
index f0243e50d..2dd8758f6 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
@@ -13,6 +13,9 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Sh
 import java.io.File
 import kotlin.reflect.KClass
 
+/**
+ * Transforms a Hprof to all primitive arrays, which can be useful to remove PII.
+ */
 class HprofPrimitiveArrayStripper {
 
   fun stripPrimitiveArrays(
@@ -77,7 +80,7 @@ class HprofPrimitiveArrayStripper {
             }
         )
       }
-    }))
+    })).close()
     writer.close()
     return outputHprofFile
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
index 14117cddb..c6e1403a2 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
@@ -40,7 +40,7 @@ import kotlin.reflect.KClass
  * A streaming push heap dump parser.
  *
  * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
- * and notify the provided listener of records found.
+ * and notify the provided listeners of records found.
  *
  * This class is not thread safe, should be used from a single thread.
  *
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
index 596228ef4..109460408 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
@@ -29,6 +29,8 @@ import java.io.Closeable
 import java.nio.charset.Charset
 
 /**
+ * Reads hprof content from an Okio [BufferedSource].
+ *
  * Not thread safe, should be used from a single thread.
  */
 open class HprofReader constructor(
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
index 421f922d7..f9828f742 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
@@ -50,6 +50,11 @@ import okio.sink
 import java.io.Closeable
 import java.io.File
 
+/**
+ * Generates Hprof files.
+ *
+ * Call [open] to create an instance, [write] to add instances and [close] when you're done.
+ */
 class HprofWriter private constructor(
   private val sink: BufferedSink,
   val idSize: Int
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
deleted file mode 100644
index f3d730f90..000000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-
-class HydratedClass(
-  val record: ClassDumpRecord,
-  val className: String,
-  val staticFieldNames: List<String>,
-  val fieldNames: List<String>
-) {
-  inline fun <reified T : HeapValue> staticFieldValue(name: String): T {
-    return staticFieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find static field $name in class $className with id ${record.id} and static fields $staticFieldNames"
-    )
-  }
-
-  fun fieldType(name: String): Int {
-    fieldNames.forEachIndexed { index, fieldName ->
-      if (fieldName == name) {
-        return record.fields[index].type
-      }
-    }
-    throw IllegalArgumentException(
-        "Could not find field $name in class $className with id ${record.id} and fields $fieldNames"
-    )
-  }
-
-  inline fun <reified T : HeapValue> staticFieldValueOrNull(name: String): T? {
-    staticFieldNames.forEachIndexed { fieldIndex, fieldName ->
-      if (fieldName == name) {
-        val fieldValue = record.staticFields[fieldIndex].value
-        return if (fieldValue is T) {
-          fieldValue
-        } else null
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = staticFieldValueOrNull(name)
-
-  fun hasStaticField(name: String): Boolean {
-    staticFieldNames.forEach { fieldName ->
-      if (fieldName == name) {
-        return true
-      }
-    }
-    return false
-  }
-
-  val simpleClassName: String
-    get() {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) {
-        className
-      } else {
-        className.substring(separator + 1)
-      }
-    }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
deleted file mode 100644
index 87affe41f..000000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-
-class HydratedInstance(
-  val record: InstanceDumpRecord,
-  val classHierarchy: List<HydratedClass>,
-  /**
-   * One list of field values per class
-   */
-  val fieldValues: List<List<HeapValue>>
-) {
-  inline fun <reified T : HeapValue> fieldValue(name: String): T {
-    return fieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find field $name in instance with id ${record.id}"
-    )
-  }
-
-  inline fun <reified T : HeapValue> fieldValueOrNull(name: String): T? {
-    classHierarchy.forEachIndexed { classIndex, hydratedClass ->
-      hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
-        if (fieldName == name) {
-          val fieldValue = fieldValues[classIndex][fieldIndex]
-          return if (fieldValue is T) {
-            fieldValue
-          } else null
-        }
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = fieldValueOrNull(name)
-
-  fun hasField(name: String): Boolean {
-    classHierarchy.forEach { hydratedClass ->
-      hydratedClass.fieldNames.forEach { fieldName ->
-        if (fieldName == name) {
-          return true
-        }
-      }
-    }
-    return false
-  }
-
-  fun isInstanceOf(className: String): Boolean {
-    return classHierarchy.any { it.className == className }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index cd139855b..85fa9a09e 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -1,5 +1,8 @@
 package leakcanary
 
+/**
+ * A Hprof record. These data structure map 1:1 with how records are written in hprof files.
+ */
 sealed class Record {
   class StringRecord(
     val id: Long,
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
index d5ec5a227..ba68cd278 100644
--- a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
@@ -3,6 +3,9 @@ package leakcanary
 import okio.BufferedSource
 import java.nio.channels.FileChannel
 
+/**
+ * A [HprofReader] that can be moved ([moveTo]) to a new position.
+ */
 class SeekableHprofReader(
   private val channel: FileChannel,
   source: BufferedSource,
diff --git a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
similarity index 57%
rename from leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
rename to leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
index 9ab4dfe5f..eb3ca46cb 100644
--- a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
@@ -1,7 +1,8 @@
-package leakcanary
+package leakcanary.internal
 
+import leakcanary.HeapValue
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 
-interface FieldValuesReader {
+internal interface FieldValuesReader {
   fun readValue(field: FieldRecord): HeapValue
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
index 3ba589f32..a4e915a4a 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
@@ -87,7 +87,9 @@ internal class HprofInMemoryIndex private constructor(
   }
 
   fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId]!!
+    return objectIndex[objectId] ?: throw IllegalArgumentException(
+        "Object id $objectId not found in heap dump."
+    )
   }
 
   fun objectIdIsIndexed(objectId: Long): Boolean {
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
index bbe8ddef4..bc5b33fa4 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
@@ -33,7 +33,7 @@ class HprofPrimitiveArrayStripperTest {
     val strippedFile = stripper.stripPrimitiveArrays(hprofFile)
 
     strippedFile.readHprof { graph ->
-      val booleanArrays = graph.objectSequence()
+      val booleanArrays = graph.objects
           .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == BOOLEAN }
           .map { it.readRecord() as BooleanArrayDump }
           .toList()
@@ -41,7 +41,7 @@ class HprofPrimitiveArrayStripperTest {
       assertThat(booleanArrays[0].id).isEqualTo(booleanArray.id)
       assertThat(booleanArrays[0].array).isEmpty()
 
-      val charArrays = graph.objectSequence()
+      val charArrays = graph.objects
           .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == CHAR }
           .map { it.readRecord() as CharArrayDump }
           .toList()
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
index a3d0b26d0..5544321f1 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -30,7 +30,7 @@ class HprofWriterTest {
     hprofFile.writeRecords(records)
 
     hprofFile.readHprof { graph ->
-      val treasureChestClass = graph.indexedClass(TREASURE_CHEST_CLASS_NAME)!!
+      val treasureChestClass = graph.findClassByClassName(TREASURE_CHEST_CLASS_NAME)!!
       val baguetteInstance =
         treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
index c79c1d451..36507b5fa 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -4,37 +4,67 @@ import android.app.Application
 import leakcanary.internal.InternalLeakSentry
 import java.util.concurrent.TimeUnit
 
+/**
+ * The entry point API for LeakSentry. LeakSentry is in charge of detecting retained objects.
+ *
+ * LeakSentry can be configured by updating [config]. You can ask LeakSentry to watch any object
+ * that you expect to be unreachable by calling [ObjectWatcher.watch] on [objectWatcher].
+ */
 object LeakSentry {
 
   data class Config(
     /**
-     * Whether LeakSentry should watch instances (by keeping weak references to them). Default is
-     * true in debuggable builds and false is non debuggable builds.
+     * Whether LeakSentry should watch objects (by keeping weak references to them).
+     *
+     * Default to true in debuggable builds and false is non debuggable builds.
      */
     val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed activities.
+     * Whether LeakSentry should automatically watch destroyed activity instances.
+     *
+     * Defaults to true.
      */
     val watchActivities: Boolean = true,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed fragments.
+     * Whether LeakSentry should automatically watch destroyed fragment instances.
+     *
+     * Defaults to true.
      */
     val watchFragments: Boolean = true,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed fragment views.
+     * Whether LeakSentry should automatically watch destroyed fragment view instances.
+     *
+     * Defaults to true.
      */
     val watchFragmentViews: Boolean = true,
+
     /**
-     * How long to wait before reporting a watched instance as retained. Default is 5 seconds.
+     * How long to wait before reporting a watched object as retained.
+     *
+     * Default to 5 seconds.
      */
     val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
   )
 
+  /**
+   * The current LeakSentry configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(enabled = false)
+   * ```
+   */
   @Volatile
   var config: Config = if (isInstalled) Config() else Config(enabled = false)
 
-  val refWatcher
-    get() = InternalLeakSentry.refWatcher
+  /**
+   * The [ObjectWatcher] used by LeakSentry to detect retained objects.
+   */
+  val objectWatcher
+    get() = InternalLeakSentry.objectWatcher
 
   /** @see [manualInstall] */
   val isInstalled
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index 522b17855..87b4fd970 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -18,11 +18,11 @@ package leakcanary.internal
 import android.app.Activity
 import android.app.Application
 import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
 ) {
 
@@ -30,7 +30,7 @@ internal class ActivityDestroyWatcher private constructor(
     object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
       override fun onActivityDestroyed(activity: Activity) {
         if (configProvider().watchActivities) {
-          refWatcher.watch(activity)
+          objectWatcher.watch(activity)
         }
       }
     }
@@ -38,11 +38,11 @@ internal class ActivityDestroyWatcher private constructor(
   companion object {
     fun install(
       application: Application,
-      refWatcher: RefWatcher,
+      objectWatcher: ObjectWatcher,
       configProvider: () -> Config
     ) {
       val activityDestroyWatcher =
-        ActivityDestroyWatcher(refWatcher, configProvider)
+        ActivityDestroyWatcher(objectWatcher, configProvider)
       application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
     }
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index ba14af118..02e1bbc1f 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -22,11 +22,11 @@ import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
 import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 
 @SuppressLint("NewApi")
 internal class AndroidOFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
 ) : (Activity) -> Unit {
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
@@ -37,7 +37,7 @@ internal class AndroidOFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -46,7 +46,7 @@ internal class AndroidOFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
index 2b7e8e458..673fc5870 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -26,7 +26,7 @@ internal class DefaultCanaryLog : Logger {
   }
 
   override fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index a13093b4f..dee5d5edb 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -21,7 +21,7 @@ import android.os.Build.VERSION.SDK_INT
 import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
 import leakcanary.LeakSentry
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 /**
@@ -35,14 +35,14 @@ internal object FragmentDestroyWatcher {
 
   fun install(
     application: Application,
-    refWatcher: RefWatcher,
+    objectWatcher: ObjectWatcher,
     configProvider: () -> LeakSentry.Config
   ) {
     val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
 
     if (SDK_INT >= O) {
       fragmentDestroyWatchers.add(
-          AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)
       )
     }
 
@@ -50,10 +50,10 @@ internal object FragmentDestroyWatcher {
         classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
     ) {
       val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
-          .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
+          .getDeclaredConstructor(ObjectWatcher::class.java, Function0::class.java)
       @kotlin.Suppress("UNCHECKED_CAST")
       fragmentDestroyWatchers.add(
-          watcherConstructor.newInstance(refWatcher, configProvider) as (Activity) -> Unit
+          watcherConstructor.newInstance(objectWatcher, configProvider) as (Activity) -> Unit
       )
     }
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index 414671102..2578e8259 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -8,8 +8,8 @@ import android.os.SystemClock
 import leakcanary.CanaryLog
 import leakcanary.Clock
 import leakcanary.LeakSentry
-import leakcanary.OnInstanceRetainedListener
-import leakcanary.RefWatcher
+import leakcanary.OnObjectRetainedListener
+import leakcanary.ObjectWatcher
 import java.lang.reflect.InvocationHandler
 import java.lang.reflect.Proxy
 import java.util.concurrent.Executor
@@ -20,7 +20,7 @@ internal object InternalLeakSentry {
     get() = ::application.isInitialized
 
   private val onLeakSentryInstalled: (Application) -> Unit
-  private val onInstanceRetainedListener: OnInstanceRetainedListener
+  private val ON_OBJECT_RETAINED_LISTENER: OnObjectRetainedListener
 
   val isDebuggableBuild by lazy {
     (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
@@ -46,16 +46,16 @@ internal object InternalLeakSentry {
     }
     @kotlin.Suppress("UNCHECKED_CAST")
     onLeakSentryInstalled = internalLeakCanary as (Application) -> Unit
-    onInstanceRetainedListener = internalLeakCanary as OnInstanceRetainedListener
+    ON_OBJECT_RETAINED_LISTENER = internalLeakCanary as OnObjectRetainedListener
   }
 
   private val checkRetainedExecutor = Executor {
     mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
   }
-  val refWatcher = RefWatcher(
+  val objectWatcher = ObjectWatcher(
       clock = clock,
       checkRetainedExecutor = checkRetainedExecutor,
-      onInstanceRetainedListener = onInstanceRetainedListener,
+      onObjectRetainedListener = ON_OBJECT_RETAINED_LISTENER,
       isEnabled = { LeakSentry.config.enabled }
   )
 
@@ -68,8 +68,8 @@ internal object InternalLeakSentry {
     InternalLeakSentry.application = application
 
     val configProvider = { LeakSentry.config }
-    ActivityDestroyWatcher.install(application, refWatcher, configProvider)
-    FragmentDestroyWatcher.install(application, refWatcher, configProvider)
+    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)
+    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)
     onLeakSentryInstalled(application)
   }
 
@@ -91,11 +91,11 @@ internal object InternalLeakSentry {
     }
   }
 
-  object NoLeakCanary : (Application) -> Unit, OnInstanceRetainedListener {
+  object NoLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
     override fun invoke(application: Application) {
     }
 
-    override fun onReferenceRetained() {
+    override fun onObjectRetained() {
     }
   }
 }
\ No newline at end of file
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
index a2eccf46a..cb2ab6e76 100644
--- a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
+++ b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
@@ -1,15 +1,28 @@
 package leakcanary
 
+/**
+ * Central Logger for all LeakCanary artifacts. Set [logger] to change where these logs go.
+ */
 object CanaryLog {
 
+  /**
+   * @see CanaryLog
+   */
   interface Logger {
+
+    /**
+     * Logs a debug message formatted with the passed in arguments.
+     */
     fun d(
       message: String,
       vararg args: Any?
     )
 
+    /**
+     * Logs a [Throwable] and debug message formatted with the passed in arguments.
+     */
     fun d(
-      throwable: Throwable?,
+      throwable: Throwable,
       message: String,
       vararg args: Any?
     )
@@ -17,6 +30,9 @@ object CanaryLog {
 
   @Volatile var logger: Logger? = null
 
+  /**
+   * @see Logger.d
+   */
   fun d(
     message: String,
     vararg args: Any?
@@ -26,8 +42,11 @@ object CanaryLog {
     logger.d(message, *args)
   }
 
+  /**
+   * @see Logger.d
+   */
   fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
index b07ec28fa..8be7b1b05 100644
--- a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
+++ b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -18,7 +18,7 @@ import org.junit.Test
  *
  * ./gradlew leakcanary-sample:connectedCheck
  *
- * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * To set this up, we installed a special ObjectWatcher dedicated to detecting leaks in
  * instrumentation tests in [InstrumentationExampleApplication], and then added the FailTestOnLeakRunListener
  * to the config of our build.gradle:
  *
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
index bd3b146b1..749e97f9b 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
@@ -1,6 +1,11 @@
 package leakcanary
 
+/**
+ * An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+ */
 interface Clock {
-  /** See Android SystemClock.uptimeMillis().  */
+  /**
+   * On Android VMs, this should return android.os.SystemClock.uptimeMillis().
+   */
   fun uptimeMillis(): Long
 }
diff --git a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
index 023889b8b..762432b73 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -16,13 +16,20 @@
 package leakcanary
 
 /**
- * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
+ * [GcTrigger] is used to try triggering garbage collection and enqueuing [KeyedWeakReference] into
+ * the associated [java.lang.ref.ReferenceQueue]. The default implementation [Default] comes from
+ * AOSP.
  */
 interface GcTrigger {
 
+  /**
+   * Attempts to run garbage collection.
+   */
   fun runGc()
 
+  /**
+   * Default implementation of [GcTrigger].
+   */
   object Default : GcTrigger {
     override fun runGc() {
       // Code taken from AOSP FinalizationTest:
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index 7772ce2d7..8a63e2b49 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -15,9 +15,18 @@
  */
 package leakcanary
 
+import leakcanary.KeyedWeakReference.Companion.heapDumpUptimeMillis
 import java.lang.ref.ReferenceQueue
 import java.lang.ref.WeakReference
 
+/**
+ * A weak reference used by [ObjectWatcher] to determine which objects become weakly reachable
+ * and which don't. [ObjectWatcher] uses [key] to keep track of [KeyedWeakReference] instances that
+ * haven't made it into the associated [ReferenceQueue] yet.
+ *
+ * [heapDumpUptimeMillis] should be set with the current time from [Clock.uptimeMillis] right
+ * before dumping the heap, so that we can later determine how long an object was retained.
+ */
 @Suppress("unused")
 class KeyedWeakReference(
   referent: Any,
@@ -29,9 +38,9 @@ class KeyedWeakReference(
     referent, referenceQueue
 ) {
   /**
-   * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
-   * instances that were moved to retained, then used to remove weak references post heap dump.
-   **/
+   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't
+   * been yet.
+   */
   @Volatile
   var retainedUptimeMillis = -1L
 
diff --git a/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
new file mode 100644
index 000000000..ffb469ca6
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances
+ * that reference watches objects, and check if those references have been cleared as expected on
+ * the [checkRetainedExecutor] executor. If not, these objects are considered retained and
+ * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread.
+ *
+ * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant
+ * to give the GC the opportunity to identify weakly reachable objects.
+ *
+ * [ObjectWatcher] is thread safe.
+ */
+// Thread safe by locking on all methods, which is reasonably efficient given how often
+// these methods are accessed.
+class ObjectWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  private val onObjectRetainedListener: OnObjectRetainedListener,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
+) {
+
+  /**
+   * References passed to [watch].
+   */
+  private val watchedObjects = mutableMapOf<String, KeyedWeakReference>()
+
+  private val queue = ReferenceQueue<Any>()
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
+  val hasRetainedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns the number of retained objects, ie the number of watched objects that aren't weakly
+   * reachable, and have been watched for long enough to be considered retained.
+   */
+  val retainedObjectCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.count { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
+  val hasWatchedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.isNotEmpty()
+    }
+
+  /**
+   * Returns the objects that are currently considered retained. Useful for logging purposes.
+   * Be careful with those objects and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedObjects: List<Any>
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      val instances = mutableListOf<Any>()
+      for (weakReference in watchedObjects.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
+    }
+
+  /**
+   * Identical to [watch] with an empty string reference name.
+   */
+  @Synchronized fun watch(watchedObject: Any) {
+    watch(watchedObject, "")
+  }
+
+  /**
+   * Watches the provided [watchedObject].
+   *
+   * @param name A logical identifier for the watched object.
+   */
+  @Synchronized fun watch(
+    watchedObject: Any,
+    name: String
+  ) {
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableObjects()
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)
+    CanaryLog.d(
+        "Watching %s with key %s",
+        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
+    )
+
+    watchedObjects[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  /**
+   * Clears all [KeyedWeakReference] that were created before [heapDumpUptimeMillis] (based on
+   * [clock] [Clock.uptimeMillis])
+   */
+  @Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {
+    val weakRefsToRemove = watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    weakRefsToRemove.values.forEach { it.clear() }
+    watchedObjects.keys.removeAll(weakRefsToRemove.keys)
+  }
+
+  /**
+   * Clears all [KeyedWeakReference]
+   */
+  @Synchronized fun clearWatchedObjects() {
+    watchedObjects.values.forEach { it.clear() }
+    watchedObjects.clear()
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableObjects()
+    val retainedRef = watchedObjects[key]
+    if (retainedRef != null) {
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
+      onObjectRetainedListener.onObjectRetained()
+    }
+  }
+
+  private fun removeWeaklyReachableObjects() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        watchedObjects.remove(ref.key)
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt b/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt
deleted file mode 100644
index e401bc5e5..000000000
--- a/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt
+++ /dev/null
@@ -1,6 +0,0 @@
-package leakcanary
-
-interface OnInstanceRetainedListener {
-
-  fun onReferenceRetained()
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
new file mode 100644
index 000000000..174121721
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+/**
+ * Listener used by [ObjectWatcher] to report retained objects.
+ */
+interface OnObjectRetainedListener {
+
+  /**
+   * A watched object became retained.
+   */
+  fun onObjectRetained()
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
deleted file mode 100644
index 20731ebd5..000000000
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import java.lang.ref.ReferenceQueue
-import java.util.UUID
-import java.util.concurrent.Executor
-
-/**
- * Thread safe by locking on all methods, which is reasonably efficient given how often
- * these methods are accessed.
- */
-class RefWatcher constructor(
-  private val clock: Clock,
-  private val checkRetainedExecutor: Executor,
-  private val onInstanceRetainedListener: OnInstanceRetainedListener,
-  /**
-   * Calls to [watch] will be ignored when [isEnabled] returns false
-   */
-  private val isEnabled: () -> Boolean = { true }
-) {
-
-  /**
-   * References passed to [watch].
-   */
-  private val watchedInstances = mutableMapOf<String, KeyedWeakReference>()
-
-  private val queue = ReferenceQueue<Any>()
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, and
-   * have been watched for long enough to be considered retained.
-   */
-  val hasRetainedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.any { it.value.retainedUptimeMillis != -1L }
-    }
-
-  val retainedInstanceCount: Int
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.count { it.value.retainedUptimeMillis != -1L }
-    }
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, even
-   * if they haven't been watched for long enough to be considered retained.
-   */
-  val hasWatchedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.isNotEmpty()
-    }
-
-  /**
-   * Returns the instances that are currently considered retained. Useful for logging purposes.
-   * Be careful with those instances and release them ASAP as you may creating longer lived leaks
-   * then the one that are already there.
-   */
-  val retainedInstances: List<Any>
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      val instances = mutableListOf<Any>()
-      for (weakReference in watchedInstances.values) {
-        if (weakReference.retainedUptimeMillis != -1L) {
-          val instance = weakReference.get()
-          if (instance != null) {
-            instances.add(instance)
-          }
-        }
-      }
-      return instances
-    }
-
-  /**
-   * Identical to [.watch] with an empty string reference name.
-   */
-  @Synchronized fun watch(watchedInstance: Any) {
-    watch(watchedInstance, "")
-  }
-
-  /**
-   * Watches the provided instances.
-   *
-   * @param name A logical identifier for the watched object.
-   */
-  @Synchronized fun watch(
-    watchedInstance: Any,
-    name: String
-  ) {
-    if (!isEnabled()) {
-      return
-    }
-    removeWeaklyReachableInstances()
-    val key = UUID.randomUUID()
-        .toString()
-    val watchUptimeMillis = clock.uptimeMillis()
-    val reference =
-      KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
-    CanaryLog.d(
-        "Watching %s with key %s",
-        ((if (watchedInstance is Class<*>) watchedInstance.toString() else "instance of ${watchedInstance.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
-    )
-
-    watchedInstances[key] = reference
-    checkRetainedExecutor.execute {
-      moveToRetained(key)
-    }
-  }
-
-  @Synchronized private fun moveToRetained(key: String) {
-    removeWeaklyReachableInstances()
-    val retainedRef = watchedInstances[key]
-    if (retainedRef != null) {
-      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onInstanceRetainedListener.onReferenceRetained()
-    }
-  }
-
-  @Synchronized fun removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis: Long) {
-    val weakRefsToRemove = watchedInstances.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
-    weakRefsToRemove.values.forEach { it.clear() }
-    watchedInstances.keys.removeAll(weakRefsToRemove.keys)
-  }
-
-  @Synchronized fun clearWatchedInstances() {
-    watchedInstances.clear()
-  }
-
-  private fun removeWeaklyReachableInstances() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    var ref: KeyedWeakReference?
-    do {
-      ref = queue.poll() as KeyedWeakReference?
-      if (ref != null) {
-        watchedInstances.remove(ref.key)
-      }
-    } while (ref != null)
-  }
-}
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
similarity index 59%
rename from leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
rename to leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
index 04c5063ab..614122a3e 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
@@ -5,17 +5,17 @@ import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.util.concurrent.Executor
 
-class RefWatcherTest {
+class ObjectWatcherTest {
 
-  private val onInstanceRetained = object: OnInstanceRetainedListener {
-    override fun onReferenceRetained() {}
+  private val onInstanceRetained = object: OnObjectRetainedListener {
+    override fun onObjectRetained() {}
   }
 
   private val checkRetainedExecutor: Executor = Executor {
     it.run()
   }
 
-  val refWatcher = RefWatcher(object : Clock {
+  private val objectWatcher = ObjectWatcher(object : Clock {
     override fun uptimeMillis(): Long {
       return time
     }
@@ -25,16 +25,16 @@ class RefWatcherTest {
   var ref: Any? = Any()
 
   @Test fun `unreachable object not retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     ref = null
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isFalse()
+    assertThat(objectWatcher.hasRetainedObjects).isFalse()
   }
 
   @Test fun `reachable object retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isTrue()
+    assertThat(objectWatcher.hasRetainedObjects).isTrue()
   }
 
 }
\ No newline at end of file
