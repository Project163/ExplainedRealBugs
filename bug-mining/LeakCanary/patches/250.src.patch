diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
index 0e57c6db5..cfe2c82bd 100644
--- a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
@@ -5,6 +5,7 @@ import androidx.test.platform.app.InstrumentationRegistry
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakTable
 import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
 import org.junit.Test
 import shark.HeapAnalysis
 import shark.HeapAnalysisSuccess
@@ -97,7 +98,7 @@ class DatabaseMigrationTest {
           input.copyTo(output)
         }
       }
-    LeaksDbHelper(context).readableDatabase.use { db ->
+    ScopedLeaksDb.readableDatabase(context) { db ->
       db.block()
     }
   }
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
index fd2427a14..5049cafde 100644
--- a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
@@ -3,6 +3,7 @@ package leakcanary
 import android.database.sqlite.SQLiteDatabase
 import androidx.test.platform.app.InstrumentationRegistry
 import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
 import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
@@ -17,10 +18,10 @@ class DatabaseRule(private val updateDb: (SQLiteDatabase) -> Unit = {}) : TestRu
         val instrumentation = InstrumentationRegistry.getInstrumentation()
         val context = instrumentation.targetContext
         context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
-        LeaksDbHelper(context).writableDatabase.use(updateDb)
+        ScopedLeaksDb.writableDatabase(context, updateDb)
         base.evaluate()
         context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
index 23ef3c06b..d27919806 100644
--- a/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
@@ -14,7 +14,7 @@ import java.io.File
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakTable.AllLeaksProjection
-import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
 import org.hamcrest.Description
 import org.hamcrest.Matcher
 import org.hamcrest.TypeSafeMatcher
@@ -118,7 +118,7 @@ internal class LeakActivityTest {
     )
     val instrumentation = InstrumentationRegistry.getInstrumentation()
     val context = instrumentation.targetContext
-    LeaksDbHelper(context).writableDatabase.use { db ->
+    ScopedLeaksDb.writableDatabase(context) { db ->
       HeapAnalysisTable.insert(db, result)
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt
index 5622b5c39..4c9769c8d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebugHeapAnalyzer.kt
@@ -12,7 +12,7 @@ import leakcanary.LeakCanary
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakTable
-import leakcanary.internal.activity.db.LeaksDbHelper
+import leakcanary.internal.activity.db.ScopedLeaksDb
 import shark.ConstantMemoryMetricsDualSourceProvider
 import shark.HeapAnalysis
 import shark.HeapAnalysisException
@@ -90,33 +90,31 @@ internal object AndroidDebugHeapAnalyzer {
     }
     progressListener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
 
-    val db = LeaksDbHelper(application).writableDatabase
-    val id = HeapAnalysisTable.insert(db, heapAnalysis)
-
-    val analysisDoneEvent = when (fullHeapAnalysis) {
-      is HeapAnalysisSuccess -> {
-        val showIntent = LeakActivity.createSuccessIntent(application, id)
-        val leakSignatures = fullHeapAnalysis.allLeaks.map { it.signature }.toSet()
-        val leakSignatureStatuses = LeakTable.retrieveLeakReadStatuses(db, leakSignatures)
-        val unreadLeakSignatures = leakSignatureStatuses.filter { (_, read) ->
-          !read
-        }.keys
-          // keys returns LinkedHashMap$LinkedKeySet which isn't Serializable
-          .toSet()
-        HeapAnalysisSucceeded(
-          heapDumped.uniqueId,
-          fullHeapAnalysis,
-          unreadLeakSignatures,
-          showIntent
-        )
-      }
-      is HeapAnalysisFailure -> {
-        val showIntent = LeakActivity.createFailureIntent(application, id)
-        HeapAnalysisFailed(heapDumped.uniqueId, fullHeapAnalysis, showIntent)
+    val analysisDoneEvent = ScopedLeaksDb.writableDatabase(application) { db ->
+      val id = HeapAnalysisTable.insert(db, heapAnalysis)
+      when (fullHeapAnalysis) {
+        is HeapAnalysisSuccess -> {
+          val showIntent = LeakActivity.createSuccessIntent(application, id)
+          val leakSignatures = fullHeapAnalysis.allLeaks.map { it.signature }.toSet()
+          val leakSignatureStatuses = LeakTable.retrieveLeakReadStatuses(db, leakSignatures)
+          val unreadLeakSignatures = leakSignatureStatuses.filter { (_, read) ->
+            !read
+          }.keys
+            // keys returns LinkedHashMap$LinkedKeySet which isn't Serializable
+            .toSet()
+          HeapAnalysisSucceeded(
+            heapDumped.uniqueId,
+            fullHeapAnalysis,
+            unreadLeakSignatures,
+            showIntent
+          )
+        }
+        is HeapAnalysisFailure -> {
+          val showIntent = LeakActivity.createFailureIntent(application, id)
+          HeapAnalysisFailed(heapDumped.uniqueId, fullHeapAnalysis, showIntent)
+        }
       }
     }
-    // Can't leverage .use{} because close() was added in API 16 and we're min SDK 14.
-    db.releaseReference()
     LeakCanary.config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)
     return analysisDoneEvent
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
index 087ebd56b..87ca446eb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Db.kt
@@ -4,11 +4,12 @@ import android.database.sqlite.SQLiteDatabase
 import android.view.View
 import leakcanary.internal.activity.db.Db.OnDb
 import leakcanary.internal.activity.db.Io.OnIo
+import leakcanary.internal.activity.db.ScopedLeaksDb.DbOpener
 
 internal object Db {
 
   // Accessed on the IO thread only.
-  private var dbHelper: LeaksDbHelper? = null
+  private var dbHelper: DbOpener? = null
 
   interface OnDb : OnIo {
     val db: SQLiteDatabase
@@ -29,7 +30,7 @@ internal object Db {
     val appContext = view.context.applicationContext
     Io.execute(view) {
       if (dbHelper == null) {
-        dbHelper = LeaksDbHelper(appContext)
+        dbHelper = ScopedLeaksDb.open(appContext)
       }
       val dbBlock = DbContext(dbHelper!!.writableDatabase)
       block(dbBlock)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt
new file mode 100644
index 000000000..c8272741d
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/ScopedLeaksDb.kt
@@ -0,0 +1,74 @@
+package leakcanary.internal.activity.db
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import java.io.Closeable
+
+internal object ScopedLeaksDb {
+
+  @Volatile
+  private lateinit var leaksDbHelper: LeaksDbHelper
+
+  private val lock = Any()
+
+  @Volatile
+  private var openCount: Int = 0
+
+  fun <T> readableDatabase(context: Context, block: (SQLiteDatabase) -> T): T {
+    return open(context).use {
+      block(it.readableDatabase)
+    }
+  }
+
+  fun <T> writableDatabase(context: Context, block: (SQLiteDatabase) -> T): T {
+    return open(context).use {
+      block(it.writableDatabase)
+    }
+  }
+
+  fun open(context: Context): DbOpener {
+    synchronized(lock) {
+      if (!::leaksDbHelper.isInitialized) {
+        leaksDbHelper = LeaksDbHelper(context.applicationContext)
+      }
+      openCount++
+      return DbOpener()
+    }
+  }
+
+  class DbOpener : Closeable {
+
+    private var closed = false
+
+    val readableDatabase: SQLiteDatabase
+      get() {
+        checkClosed()
+        return leaksDbHelper.readableDatabase
+      }
+
+    val writableDatabase: SQLiteDatabase
+      get() {
+        checkClosed()
+        return leaksDbHelper.writableDatabase
+      }
+
+    override fun close() {
+      synchronized(lock) {
+        checkClosed()
+        closed = true
+        openCount--
+        if (openCount == 0) {
+          // No one else needs this right now, let's close the database (will reopen on
+          // next use)
+          leaksDbHelper.close()
+        }
+      }
+    }
+
+    private fun checkClosed() {
+      check(!closed) {
+        "Already closed"
+      }
+    }
+  }
+}
