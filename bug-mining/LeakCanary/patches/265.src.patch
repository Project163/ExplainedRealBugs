diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index f8081c3c6..6c68dbf6e 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -1,15 +1,18 @@
 package shark
 
+import java.io.File
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import shark.HeapObject.HeapInstance
 import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecordTag.LOAD_CLASS
+import shark.HprofRecordTag.ROOT_STICKY_CLASS
+import shark.HprofRecordTag.STRING_IN_UTF8
 import shark.LeakTrace.GcRootType
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
 import shark.SharkLog.Logger
-import java.io.File
-import shark.HeapObject.HeapInstance
 
 class LegacyHprofTest {
 
@@ -163,6 +166,77 @@ class LegacyHprofTest {
     assertThat(firstReference.referenceDisplayName).isEqualTo("[0]")
   }
 
+  @Test fun `duplicated unloaded classes are ignored`() {
+    val expectedDuplicatedClassNames = setOf(
+      "leakcanary.internal.DebuggerControl",
+      "shark.AndroidResourceIdNames\$Companion",
+      "shark.GraphContext",
+      "shark.AndroidResourceIdNames\$Companion\$readFromHeap$1",
+      "leakcanary.internal.HeapDumpTrigger\$saveResourceIdNamesToMemory$1",
+      "leakcanary.internal.HeapDumpTrigger\$saveResourceIdNamesToMemory$2",
+      "shark.AndroidResourceIdNames",
+      "leakcanary.internal.FutureResult",
+      "leakcanary.internal.AndroidHeapDumper\$showToast$1",
+      "android.widget.Toast\$TN",
+      "android.widget.Toast\$TN$1",
+      "android.widget.Toast\$TN$2",
+      "leakcanary.internal.AndroidHeapDumper\$showToast$1$1",
+      "com.squareup.leakcanary.core.R\$dimen",
+      "com.squareup.leakcanary.core.R\$layout",
+      "android.text.style.WrapTogetherSpan[]"
+    )
+
+    val file = "unloaded_classes-stripped.hprof".classpathFile()
+
+    val header = HprofHeader.parseHeaderOf(file)
+
+    val stickyClasses = mutableListOf<Long>()
+    val classesAndNameStringId = mutableMapOf<Long, Long>()
+    val stringRecordById = mutableMapOf<Long, String>()
+    StreamingHprofReader.readerFor(file, header).readRecords(setOf(ROOT_STICKY_CLASS, STRING_IN_UTF8, LOAD_CLASS)) { tag, length, reader ->
+      when(tag) {
+        ROOT_STICKY_CLASS -> reader.readStickyClassGcRootRecord().apply {
+          stickyClasses += id
+        }
+        STRING_IN_UTF8 -> reader.readStringRecord(length).apply {
+          stringRecordById[id] = string
+        }
+        LOAD_CLASS -> reader.readLoadClassRecord().apply {
+          classesAndNameStringId[id] = classNameStringId
+        }
+      }
+    }
+    val duplicatedClassObjectIdsByNameStringId =
+      classesAndNameStringId.entries
+        .groupBy { (_, className) -> className }
+        .mapValues { (_, value) -> value.map { (key, _) -> key } }
+        .filter { (_, values) -> values.size > 1 }
+
+    val actualDuplicatedClassNames = duplicatedClassObjectIdsByNameStringId.keys
+      .map { stringRecordById.getValue(it) }
+      .toSet()
+    assertThat(actualDuplicatedClassNames).isEqualTo(expectedDuplicatedClassNames)
+
+    val duplicateRootClassObjectIdByClassName = duplicatedClassObjectIdsByNameStringId
+      .mapKeys { (key, _) -> stringRecordById.getValue(key) }
+      .mapValues { (_, value) -> value.single { it in stickyClasses } }
+
+    file.openHeapGraph().use { graph ->
+      val expectedDuplicatedRootClassObjectIds =
+        duplicateRootClassObjectIdByClassName.values.toSortedSet()
+
+      val actualDuplicatedRootClassObjectIds = duplicateRootClassObjectIdByClassName.keys
+        .map { className ->
+          graph.findClassByName(className)!!.objectId
+        }
+        .toSortedSet()
+
+      assertThat(actualDuplicatedRootClassObjectIds).isEqualTo(
+        expectedDuplicatedRootClassObjectIds
+      )
+    }
+  }
+
   private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
     return analyzeHprof(fileName.classpathFile())
   }
diff --git a/shark-android/src/test/resources/unloaded_classes-stripped.hprof b/shark-android/src/test/resources/unloaded_classes-stripped.hprof
new file mode 100644
index 000000000..e9097f187
Binary files /dev/null and b/shark-android/src/test/resources/unloaded_classes-stripped.hprof differ
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index f5473dbd4..486f9a71c 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -1,6 +1,9 @@
 package shark.internal
 
+import java.util.EnumSet
+import kotlin.math.max
 import shark.GcRoot
+import shark.GcRoot.StickyClass
 import shark.HprofHeader
 import shark.HprofRecordReader
 import shark.HprofRecordTag
@@ -26,6 +29,7 @@ import shark.HprofRecordTag.ROOT_UNKNOWN
 import shark.HprofRecordTag.ROOT_UNREACHABLE
 import shark.HprofRecordTag.ROOT_VM_INTERNAL
 import shark.HprofRecordTag.STRING_IN_UTF8
+import shark.HprofVersion
 import shark.HprofVersion.ANDROID
 import shark.OnHprofRecordTagListener
 import shark.PrimitiveType
@@ -41,10 +45,8 @@ import shark.internal.hppc.IntObjectPair
 import shark.internal.hppc.LongLongScatterMap
 import shark.internal.hppc.LongObjectPair
 import shark.internal.hppc.LongObjectScatterMap
-import shark.internal.hppc.to
-import java.util.EnumSet
-import kotlin.math.max
 import shark.internal.hppc.LongScatterSet
+import shark.internal.hppc.to
 
 /**
  * This class is not thread safe, should be used from a single thread.
@@ -65,7 +67,8 @@ internal class HprofInMemoryIndex private constructor(
   private val bytesForPrimitiveArraySize: Int,
   private val useForwardSlashClassPackageSeparator: Boolean,
   val classFieldsReader: ClassFieldsReader,
-  private val classFieldsIndexSize: Int
+  private val classFieldsIndexSize: Int,
+  private val stickyClassGcRootIds: LongScatterSet,
 ) {
 
   val classCount: Int
@@ -104,6 +107,15 @@ internal class HprofInMemoryIndex private constructor(
     }
   }
 
+  /**
+   * Returns the first class that matches the provided name, prioritizing system classes (as held
+   * by sticky class gc roots).
+   *
+   * On Android, all currently loaded classes are sticky. The heap dump may also contain classes
+   * that were unloaded but not garbage collected yet, leading to classes being present twice
+   * in the heap dump. To work around that we prioritize classes that are held by a sticky class GC
+   * root.
+   */
   fun classId(className: String): Long? {
     val internalClassName = if (useForwardSlashClassPackageSeparator) {
       // JVM heap dumps use "/" for package separators (vs "." for Android heap dumps)
@@ -113,12 +125,22 @@ internal class HprofInMemoryIndex private constructor(
     // Note: this performs two linear scans over arrays
     val hprofStringId = hprofStringCache.entrySequence()
       .firstOrNull { it.second == internalClassName }
-      ?.first
-    return hprofStringId?.let { stringId ->
-      classNames.entrySequence()
-        .firstOrNull { it.second == stringId }
-        ?.first
+      ?.first ?: return null
+
+    val classNamesIterator = classNames.entrySequence().iterator()
+
+    var firstNonStickyMatchingClass: Long? = null
+    while(classNamesIterator.hasNext()) {
+      val (classId, classNameStringId) = classNamesIterator.next()
+      if (hprofStringId == classNameStringId) {
+        if (classId in stickyClassGcRootIds) {
+          return classId
+        } else {
+          firstNonStickyMatchingClass = classId
+        }
+      }
     }
+    return firstNonStickyMatchingClass
   }
 
   fun indexedClassSequence(): Sequence<LongObjectPair<IndexedClass>> {
@@ -311,7 +333,8 @@ internal class HprofInMemoryIndex private constructor(
     val bytesForInstanceSize: Int,
     val bytesForObjectArraySize: Int,
     val bytesForPrimitiveArraySize: Int,
-    val classFieldsTotalBytes: Int
+    val classFieldsTotalBytes: Int,
+    val stickyClassGcRootIds: LongScatterSet,
   ) : OnHprofRecordTagListener {
 
     private val identifierSize = if (longIdentifiers) 8 else 4
@@ -360,9 +383,12 @@ internal class HprofInMemoryIndex private constructor(
       initialCapacity = primitiveArrayCount
     )
 
-    private val gcRoots = mutableListOf<GcRoot>()
-
-    private val stickyClassGcRootIds = LongScatterSet()
+    // Pre seeding gc roots with the sticky class gc roots we've already parsed.
+    private val gcRoots: MutableList<GcRoot> = ArrayList<GcRoot>(stickyClassGcRootIds.size()).apply {
+      stickyClassGcRootIds.elementSequence().forEach {classId ->
+        add(StickyClass(classId))
+      }
+    }
 
     private fun HprofRecordReader.copyToClassFields(byteCount: Int) {
       for (i in 1..byteCount) {
@@ -429,16 +455,8 @@ internal class HprofInMemoryIndex private constructor(
           }
         }
         ROOT_STICKY_CLASS -> {
-          reader.readStickyClassGcRootRecord().apply {
-            // StickyClass has only 1 field: id. Our API 23 emulators in CI are creating heap
-            // dumps with duplicated sticky class roots, up to 30K times for some objects.
-            // There's no point in keeping all these in our list of roots, 1 per each is enough
-            // so we deduplicate with stickyClassGcRootIds.
-            if (id != ValueHolder.NULL_REFERENCE && id !in stickyClassGcRootIds) {
-              stickyClassGcRootIds += id
-              gcRoots += this
-            }
-          }
+          // We already parse these gc roots in the initial scan.
+          reader.skipId()
         }
         ROOT_THREAD_BLOCK -> {
           reader.readThreadBlockGcRootRecord().apply {
@@ -642,7 +660,8 @@ internal class HprofInMemoryIndex private constructor(
         bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,
         useForwardSlashClassPackageSeparator = hprofHeader.version != ANDROID,
         classFieldsReader = ClassFieldsReader(identifierSize, classFieldBytes),
-        classFieldsIndexSize = classFieldsIndexSize
+        classFieldsIndexSize = classFieldsIndexSize,
+        stickyClassGcRootIds = stickyClassGcRootIds,
       )
     }
   }
@@ -676,9 +695,16 @@ internal class HprofInMemoryIndex private constructor(
       var objectArrayCount = 0
       var primitiveArrayCount = 0
       var classFieldsTotalBytes = 0
+      val stickyClassGcRootIds = LongScatterSet()
 
       val bytesRead = reader.readRecords(
-        EnumSet.of(CLASS_DUMP, INSTANCE_DUMP, OBJECT_ARRAY_DUMP, PRIMITIVE_ARRAY_DUMP)
+        EnumSet.of(
+          CLASS_DUMP,
+          INSTANCE_DUMP,
+          OBJECT_ARRAY_DUMP,
+          PRIMITIVE_ARRAY_DUMP,
+          ROOT_STICKY_CLASS
+        )
       ) { tag, _, reader ->
         val bytesReadStart = reader.bytesRead
         when (tag) {
@@ -706,6 +732,16 @@ internal class HprofInMemoryIndex private constructor(
             reader.skipPrimitiveArrayDumpRecord()
             maxPrimitiveArraySize = max(maxPrimitiveArraySize, reader.bytesRead - bytesReadStart)
           }
+          ROOT_STICKY_CLASS -> {
+            // StickyClass has only 1 field: id. Our API 23 emulators in CI are creating heap
+            // dumps with duplicated sticky class roots, up to 30K times for some objects.
+            // There's no point in keeping all these in our list of roots, 1 per each is enough
+            // so we deduplicate with stickyClassGcRootIds.
+            val id = reader.readStickyClassGcRootRecord().id
+            if (id != ValueHolder.NULL_REFERENCE) {
+              stickyClassGcRootIds += id
+            }
+          }
         }
       }
 
@@ -725,7 +761,8 @@ internal class HprofInMemoryIndex private constructor(
         bytesForInstanceSize = bytesForInstanceSize,
         bytesForObjectArraySize = bytesForObjectArraySize,
         bytesForPrimitiveArraySize = bytesForPrimitiveArraySize,
-        classFieldsTotalBytes = classFieldsTotalBytes
+        classFieldsTotalBytes = classFieldsTotalBytes,
+        stickyClassGcRootIds
       )
 
       val recordTypes = EnumSet.of(
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
index abdc18bd1..b311d48f2 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -60,6 +60,29 @@ internal class LongScatterSet(expectedElements: Int = 4) {
     ensureCapacity(expectedElements)
   }
 
+  fun elementSequence(): Sequence<Long> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence 0L
+      }
+      return@generateSequence null
+    }
+  }
+
   private fun hashKey(key: Long): Int {
     return HPPC.mixPhi(key)
   }
diff --git a/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt b/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt
new file mode 100644
index 000000000..c2f3b6089
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofHeapGraphTest.kt
@@ -0,0 +1,100 @@
+package shark
+
+import java.io.File
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.StickyClass
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+
+class HprofHeapGraphTest {
+
+  @get:Rule
+  val testFolder = TemporaryFolder()
+
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test
+  fun `non system class can be found`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(42, classNameRecord, rootClass = false)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      assertThat(graph.findClassByName(className)).isNotNull
+    }
+  }
+
+  @Test
+  fun `system class can be found`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(42, classNameRecord, rootClass = true)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      assertThat(graph.findClassByName(className)).isNotNull
+    }
+  }
+
+  @Test
+  fun `system class prioritized over non system class`() {
+    val className = "com.example.SimpleClass"
+
+    HprofWriter.openWriterFor(hprofFile).use { writer ->
+      val classNameRecord = StringRecord(1L, className)
+      writer.write(classNameRecord)
+      writer.writeClass(24, classNameRecord, rootClass = false)
+      writer.writeClass(25, classNameRecord, rootClass = false)
+      writer.writeClass(42, classNameRecord, rootClass = true)
+      writer.writeClass(43, classNameRecord, rootClass = false)
+    }
+
+    hprofFile.openHeapGraph().use { graph ->
+      val heapClass = graph.findClassByName(className)!!
+      assertThat(heapClass.objectId).isEqualTo(42)
+    }
+  }
+
+  private fun HprofWriter.writeClass(
+    classId: Long,
+    classNameRecord: StringRecord,
+    rootClass: Boolean
+  ) {
+    val loadClass = LoadClassRecord(1, classId, 1, classNameRecord.id)
+    val classDump = ClassDumpRecord(
+      id = loadClass.id,
+      stackTraceSerialNumber = 1,
+      superclassId = 0,
+      classLoaderId = 0,
+      signersId = 0,
+      protectionDomainId = 0,
+      instanceSize = 0,
+      staticFields = emptyList(),
+      fields = emptyList()
+    )
+    write(loadClass)
+    if (rootClass) {
+      write(GcRootRecord(gcRoot = StickyClass(classId)))
+    }
+    write(classDump)
+  }
+}
diff --git a/shark-hprof/api/shark-hprof.api b/shark-hprof/api/shark-hprof.api
index 1ac7d315c..5acd19940 100644
--- a/shark-hprof/api/shark-hprof.api
+++ b/shark-hprof/api/shark-hprof.api
@@ -431,6 +431,7 @@ public final class shark/HprofRecordReader {
 	public final fun skipClassDumpRecord ()V
 	public final fun skipClassDumpStaticFields ()V
 	public final fun skipHeapDumpInfoRecord ()V
+	public final fun skipId ()V
 	public final fun skipInstanceDumpRecord ()V
 	public final fun skipObjectArrayDumpRecord ()V
 	public final fun skipPrimitiveArrayDumpRecord ()V
diff --git a/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt b/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt
index 73de7de5f..e87e47724 100644
--- a/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt
+++ b/shark-hprof/src/main/java/shark/HprofDeobfuscator.kt
@@ -104,10 +104,7 @@ class HprofDeobfuscator {
       StreamingHprofReader.readerFor(inputHprofFile, hprofHeader).asStreamingRecordReader()
     HprofWriter.openWriterFor(
       outputHprofFile,
-      hprofHeader = HprofHeader(
-        identifierByteSize = hprofHeader.identifierByteSize,
-        version = hprofHeader.version
-      )
+      hprofHeader = hprofHeader
     ).use { writer ->
       reader.readRecords(setOf(HprofRecord::class),
         OnHprofRecordListener { _,
diff --git a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
index 66c3c8bdb..1e0b69188 100644
--- a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
+++ b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
@@ -55,10 +55,7 @@ class HprofPrimitiveArrayStripper {
       StreamingHprofReader.readerFor(hprofSourceProvider, header).asStreamingRecordReader()
     HprofWriter.openWriterFor(
       hprofSink,
-      hprofHeader = HprofHeader(
-        identifierByteSize = header.identifierByteSize,
-        version = header.version
-      )
+      hprofHeader = header
     )
       .use { writer ->
         reader.readRecords(setOf(HprofRecord::class),
diff --git a/shark-hprof/src/main/java/shark/HprofRecordReader.kt b/shark-hprof/src/main/java/shark/HprofRecordReader.kt
index abc61ad42..44f771f3c 100644
--- a/shark-hprof/src/main/java/shark/HprofRecordReader.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecordReader.kt
@@ -409,6 +409,10 @@ class HprofRecordReader internal constructor(
     return source.skip(byteCount.toLong())
   }
 
+  fun skipId() {
+    skip(identifierByteSize)
+  }
+
   fun skip(byteCount: Long) {
     bytesRead += byteCount
     return source.skip(byteCount)
