diff --git a/build.gradle b/build.gradle
index 33b91ed1d..55339ce6a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -7,7 +7,7 @@ buildscript {
       'errorProne': '2.3.1',
       // We would like to use Kotlin 1.4 language features but keep Kotlin 1.3 library APIs
       // The benefit is that depending clients do not have to upgrade to Kotlin 1.4
-      'kotlinCompiler': '1.4.10',
+      'kotlinCompiler': '1.4.21',
       'kotlinLib': '1.3.72',
   ]
   ext.deps = [
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index e7553e03c..5a591b79d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -17,7 +17,7 @@ import leakcanary.internal.activity.screen.HeapDumpsScreen
 import leakcanary.internal.activity.screen.LeakTraceWrapper
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.tv.TvToast
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.mainHandler
 import shark.HeapAnalysis
 import shark.HeapAnalysisFailure
 import shark.HeapAnalysisSuccess
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 10aabd0a3..99c473ee6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -21,16 +21,14 @@ import android.app.Notification
 import android.app.NotificationManager
 import android.content.Context
 import android.os.Debug
-import android.os.Handler
-import android.os.Looper
 import android.view.Gravity
 import android.view.LayoutInflater
 import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
-import leakcanary.internal.utils.mainHandler
-import leakcanary.internal.utils.measureDurationMillis
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.friendly.measureDurationMillis
 import shark.SharkLog
 import java.util.concurrent.TimeUnit.SECONDS
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
index 0c5ee32d7..e1cd3383e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
@@ -10,7 +10,7 @@ import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
 import leakcanary.internal.HeapDumpControl.ICanHazHeap.NotifyingNope
 import leakcanary.internal.HeapDumpControl.ICanHazHeap.SilentNope
 import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.mainHandler
 
 internal object HeapDumpControl {
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index f83633241..2edef4169 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -20,7 +20,6 @@ import android.os.Build.VERSION
 import android.os.Build.VERSION_CODES
 import android.os.Handler
 import android.os.HandlerThread
-import android.os.StrictMode
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.AppWatcher
@@ -32,11 +31,10 @@ import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
 import leakcanary.internal.InternalLeakCanary.FormFactor.MOBILE
 import leakcanary.internal.InternalLeakCanary.FormFactor.TV
 import leakcanary.internal.InternalLeakCanary.FormFactor.WATCH
+import leakcanary.internal.friendly.noOpDelegate
 import leakcanary.internal.tv.TvOnRetainInstanceListener
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.mainHandler
 import shark.SharkLog
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
 
 internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
 
@@ -333,15 +331,5 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     application.packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP)
   }
 
-  inline fun <reified T : Any> noOpDelegate(): T {
-    val javaClass = T::class.java
-    val noOpHandler = InvocationHandler { _, _, _ ->
-      // no op
-    }
-    return Proxy.newProxyInstance(
-      javaClass.classLoader, arrayOf(javaClass), noOpHandler
-    ) as T
-  }
-
   private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
index 81716e27a..ae4ad0047 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -2,7 +2,7 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.internal.InternalLeakCanary.noOpDelegate
+import leakcanary.internal.friendly.noOpDelegate
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 6084ac454..96b81dcc4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -6,8 +6,8 @@ import android.os.AsyncTask
 import leakcanary.internal.LeakDirectoryProvider
 import leakcanary.internal.Serializables
 import leakcanary.internal.toByteArray
-import leakcanary.internal.utils.checkNotMainThread
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.checkNotMainThread
+import leakcanary.internal.friendly.mainHandler
 import org.intellij.lang.annotations.Language
 import shark.HeapAnalysis
 import shark.HeapAnalysisFailure
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
index dea1c10ed..0d95c006e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/Io.kt
@@ -3,8 +3,8 @@ package leakcanary.internal.activity.db
 import android.view.View
 import leakcanary.internal.activity.db.Io.OnIo
 import leakcanary.internal.navigation.onScreenExiting
-import leakcanary.internal.utils.checkMainThread
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.mainHandler
 import java.util.concurrent.Executors
 
 internal object Io {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 000000000..f3ae923e9
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,16 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-android-core_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun checkNotMainThread() = leakcanary.internal.checkNotMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline fun measureDurationMillis(block: () -> Unit) =
+  leakcanary.internal.measureDurationMillis(block)
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
index 37f059a31..10ab26dee 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
@@ -12,7 +12,7 @@ import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
 import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
-import leakcanary.internal.utils.mainHandler
+import leakcanary.internal.friendly.mainHandler
 import shark.SharkLog
 
 /**
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Timing.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Timing.kt
deleted file mode 100644
index f5b7d7fbf..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Timing.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary.internal.utils
-
-import android.os.SystemClock
-
-/**
- * Executes the given [block] and returns elapsed time in milliseconds using [SystemClock.uptimeMillis]
- */
-internal inline fun measureDurationMillis(block: () -> Unit): Long {
-  val start = SystemClock.uptimeMillis()
-  block()
-  return SystemClock.uptimeMillis() - start
-}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
index 891ff319f..73c4a8872 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
@@ -15,8 +15,7 @@ import androidx.lifecycle.ViewModelStoreOwner
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.rule.ActivityTestRule
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
+import leakcanary.internal.friendly.noOpDelegate
 import java.util.concurrent.CountDownLatch
 import java.util.concurrent.atomic.AtomicReference
 import kotlin.reflect.KClass
@@ -122,16 +121,6 @@ fun <R> waitForTriggered(
   return result
 }
 
-inline fun <reified T : Any> noOpDelegate(): T {
-  val javaClass = T::class.java
-  val noOpHandler = InvocationHandler { _, _, _ ->
-    // no op
-  }
-  return Proxy.newProxyInstance(
-    javaClass.classLoader, arrayOf(javaClass), noOpHandler
-  ) as T
-}
-
 fun <T> getOnMainSync(block: () -> T): T {
   val resultHolder = AtomicReference<T>()
   val latch = CountDownLatch(1)
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index c72a32a6a..c813e727e 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -1,18 +1,3 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package leakcanary
 
 import android.app.Activity
@@ -31,10 +16,9 @@ import shark.HeapAnalysis
 import shark.HeapAnalysisFailure
 import shark.HeapAnalysisSuccess
 import shark.SharkLog
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
 import java.util.concurrent.CountDownLatch
 import java.util.concurrent.TimeUnit.SECONDS
+import leakcanary.internal.friendly.noOpDelegate
 
 /**
  *
@@ -185,14 +169,4 @@ open class FailTestOnLeakRunListener : RunListener() {
     SharkLog.d { trace }
     testResultPublisher.publishTestFailure(currentTestDescription, trace)
   }
-
-  private inline fun <reified T : Any> noOpDelegate(): T {
-    val javaClass = T::class.java
-    val noOpHandler = InvocationHandler { _, _, _ ->
-      // no op
-    }
-    return Proxy.newProxyInstance(
-      javaClass.classLoader, arrayOf(javaClass), noOpHandler
-    ) as T
-  }
 }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 000000000..d75a17acb
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,5 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
+@file:JvmName("leakcanary-android-instrumentation_Friendly")
+package leakcanary.internal.friendly
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
\ No newline at end of file
diff --git a/leakcanary-android-release/build.gradle b/leakcanary-android-release/build.gradle
index 78895fe46..dab16f1ab 100644
--- a/leakcanary-android-release/build.gradle
+++ b/leakcanary-android-release/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'kotlin-android'
 
 dependencies {
   api project(':shark-android')
+  api project(':leakcanary-android-utils')
 
   implementation deps.kotlin.stdlib
   implementation deps.okio
diff --git a/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt b/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt
index 1462a36bf..9d4100367 100644
--- a/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt
+++ b/leakcanary-android-release/src/main/java/leakcanary/BackgroundTrigger.kt
@@ -2,7 +2,7 @@ package leakcanary
 
 import android.app.Application
 import leakcanary.internal.BackgroundListener
-import leakcanary.internal.checkMainThread
+import leakcanary.internal.friendly.checkMainThread
 import shark.SharkLog
 import java.util.concurrent.Executor
 
diff --git a/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt b/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt
index 6b2a8414d..0ffee4ede 100644
--- a/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt
+++ b/leakcanary-android-release/src/main/java/leakcanary/ScreenOffTrigger.kt
@@ -7,7 +7,7 @@ import android.content.Intent
 import android.content.Intent.ACTION_SCREEN_OFF
 import android.content.Intent.ACTION_SCREEN_ON
 import android.content.IntentFilter
-import leakcanary.internal.checkMainThread
+import leakcanary.internal.friendly.checkMainThread
 import shark.SharkLog
 import java.util.concurrent.Executor
 
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt
index c5d25321c..d9e997398 100644
--- a/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/BackgroundListener.kt
@@ -4,6 +4,8 @@ import android.app.Activity
 import android.app.Application
 import android.app.Application.ActivityLifecycleCallbacks
 import leakcanary.ProcessInfo
+import leakcanary.internal.friendly.mainHandler
+import leakcanary.internal.friendly.noOpDelegate
 
 /**
  * Tracks whether the app is in background, based on the app's importance.
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/Handlers.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/Handlers.kt
deleted file mode 100644
index a8c9ce911..000000000
--- a/leakcanary-android-release/src/main/java/leakcanary/internal/Handlers.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-@file:JvmName("leakcanary-android-release_Handlers")
-
-package leakcanary.internal
-
-import android.os.Handler
-import android.os.HandlerThread
-import android.os.Looper
-import android.os.Process
-
-internal val mainHandler = Handler(Looper.getMainLooper())
-
-internal fun checkMainThread() {
-  if (Looper.getMainLooper().thread !== Thread.currentThread()) {
-    throw UnsupportedOperationException(
-      "Should be called from the main thread, not ${Thread.currentThread()}"
-    )
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/Objects.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/Objects.kt
deleted file mode 100644
index c1764337d..000000000
--- a/leakcanary-android-release/src/main/java/leakcanary/internal/Objects.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-@file:JvmName("leakcanary-android-release_Objects")
-
-package leakcanary.internal
-
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
-
-inline fun <reified T : Any> noOpDelegate(): T {
-  val javaClass = T::class.java
-  val noOpHandler = InvocationHandler { _, _, _ ->
-    // no op
-  }
-  return Proxy.newProxyInstance(
-    javaClass.classLoader, arrayOf(javaClass), noOpHandler
-  ) as T
-}
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt
index 4d462865b..b4434ccea 100644
--- a/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/RealHeapAnalysisJob.kt
@@ -9,7 +9,6 @@ import leakcanary.HeapAnalysisJob.Result
 import leakcanary.HeapAnalysisJob.Result.Canceled
 import leakcanary.HeapAnalysisJob.Result.Done
 import leakcanary.JobContext
-import okio.BufferedSource
 import okio.buffer
 import okio.sink
 import shark.CloseableHeapGraph
@@ -130,7 +129,7 @@ internal class RealHeapAnalysisJob(
 
       val stripDurationMillis =
         if (config.stripHeapDump) {
-          measureDurationMillis {
+          leakcanary.internal.friendly.measureDurationMillis {
             val strippedHeapDumpFile = File(filesDir, "$fileNameBase-stripped$HPROF_SUFFIX").apply {
               deleteOnExit()
             }
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 000000000..cf621fbfb
--- /dev/null
+++ b/leakcanary-android-release/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,14 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-android-release_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
+
+internal inline fun measureDurationMillis(block: () -> Unit) =
+  leakcanary.internal.measureDurationMillis(block)
\ No newline at end of file
diff --git a/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt b/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt
index 9cadb10f4..55d1fe15d 100644
--- a/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt
+++ b/leakcanary-android-sample/src/release/java/com/example/leakcanary/ReleaseExampleApplication.kt
@@ -6,6 +6,8 @@ import leakcanary.BackgroundTrigger
 import leakcanary.HeapAnalysisClient
 import leakcanary.HeapAnalysisConfig
 import leakcanary.HeapAnalysisJob.Result
+import leakcanary.LogcatSharkLog
+import leakcanary.LogcatSharkLog.Companion
 import leakcanary.ScreenOffTrigger
 import shark.SharkLog
 import shark.SharkLog.Logger
@@ -16,24 +18,7 @@ class ReleaseExampleApplication : ExampleApplication() {
   override fun onCreate() {
     super.onCreate()
     // Useful to debug in release builds. Don't use in real builds.
-    SharkLog.logger = object : Logger {
-      override fun d(message: String) {
-        if (message.length < 4000) {
-          Log.d("LeakCanary", message)
-        } else {
-          message.lines().forEach { line ->
-            Log.d("LeakCanary", line)
-          }
-        }
-      }
-
-      override fun d(
-        throwable: Throwable,
-        message: String
-      ) {
-        d("$message\n${Log.getStackTraceString(throwable)}")
-      }
-    }
+    LogcatSharkLog.install()
 
     val analysisClient = HeapAnalysisClient(
       heapDumpDirectoryProvider = { cacheDir },
diff --git a/leakcanary-android-utils/api/leakcanary-android-utils.api b/leakcanary-android-utils/api/leakcanary-android-utils.api
new file mode 100644
index 000000000..e848d2aba
--- /dev/null
+++ b/leakcanary-android-utils/api/leakcanary-android-utils.api
@@ -0,0 +1,20 @@
+public final class com/squareup/leakcanary/utils/BuildConfig {
+	public static final field BUILD_TYPE Ljava/lang/String;
+	public static final field DEBUG Z
+	public static final field LIBRARY_PACKAGE_NAME Ljava/lang/String;
+	public static final field VERSION_CODE I
+	public static final field VERSION_NAME Ljava/lang/String;
+	public fun <init> ()V
+}
+
+public final class leakcanary/LogcatSharkLog : shark/SharkLog$Logger {
+	public static final field Companion Lleakcanary/LogcatSharkLog$Companion;
+	public fun <init> ()V
+	public fun d (Ljava/lang/String;)V
+	public fun d (Ljava/lang/Throwable;Ljava/lang/String;)V
+}
+
+public final class leakcanary/LogcatSharkLog$Companion {
+	public final fun install ()V
+}
+
diff --git a/leakcanary-android-utils/build.gradle b/leakcanary-android-utils/build.gradle
new file mode 100644
index 000000000..c1652855e
--- /dev/null
+++ b/leakcanary-android-utils/build.gradle
@@ -0,0 +1,22 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':shark-log')
+
+  implementation deps.kotlin.stdlib
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-utils/gradle.properties b/leakcanary-android-utils/gradle.properties
new file mode 100644
index 000000000..77779b2f0
--- /dev/null
+++ b/leakcanary-android-utils/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-android-utils
+POM_NAME=LeakCanary Android Utils
+POM_PACKAGING=aar
diff --git a/leakcanary-android-utils/src/main/AndroidManifest.xml b/leakcanary-android-utils/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..7699f1d20
--- /dev/null
+++ b/leakcanary-android-utils/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest package="com.squareup.leakcanary.utils" />
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt
similarity index 70%
rename from leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
rename to leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt
index 3007c3017..cb76ce69b 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-android-utils/src/main/java/leakcanary/LogcatSharkLog.kt
@@ -1,9 +1,10 @@
-package leakcanary.internal
+package leakcanary
 
 import android.util.Log
+import shark.SharkLog
 import shark.SharkLog.Logger
 
-internal class DefaultCanaryLog : Logger {
+class LogcatSharkLog : Logger {
 
   override fun d(message: String) {
     if (message.length < 4000) {
@@ -21,4 +22,10 @@ internal class DefaultCanaryLog : Logger {
   ) {
     d("$message\n${Log.getStackTraceString(throwable)}")
   }
+
+  companion object {
+    fun install() {
+      SharkLog.logger = LogcatSharkLog()
+    }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Handlers.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt
similarity index 92%
rename from leakcanary-android-core/src/main/java/leakcanary/internal/utils/Handlers.kt
rename to leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt
index 7b0d7fc70..8a0ab128e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Handlers.kt
+++ b/leakcanary-android-utils/src/main/java/leakcanary/internal/Handlers.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal.utils
+package leakcanary.internal
 
 import android.os.Handler
 import android.os.Looper
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Objects.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt
similarity index 64%
rename from leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Objects.kt
rename to leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt
index 062c14aeb..f7afa1657 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Objects.kt
+++ b/leakcanary-android-utils/src/main/java/leakcanary/internal/Objects.kt
@@ -1,4 +1,3 @@
-
 package leakcanary.internal
 
 import java.lang.reflect.InvocationHandler
@@ -6,10 +5,11 @@ import java.lang.reflect.Proxy
 
 internal inline fun <reified T : Any> noOpDelegate(): T {
   val javaClass = T::class.java
-  val noOpHandler = InvocationHandler { _, _, _ ->
-    // no op
-  }
   return Proxy.newProxyInstance(
-    javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    javaClass.classLoader, arrayOf(javaClass), NO_OP_HANDLER
   ) as T
 }
+
+private val NO_OP_HANDLER = InvocationHandler { _, _, _ ->
+  // no op
+}
\ No newline at end of file
diff --git a/leakcanary-android-release/src/main/java/leakcanary/internal/Timing.kt b/leakcanary-android-utils/src/main/java/leakcanary/internal/Timing.kt
similarity index 100%
rename from leakcanary-android-release/src/main/java/leakcanary/internal/Timing.kt
rename to leakcanary-android-utils/src/main/java/leakcanary/internal/Timing.kt
diff --git a/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api b/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api
index c4ea7bc3d..6b2e5c49e 100644
--- a/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api
+++ b/leakcanary-object-watcher-android/api/leakcanary-object-watcher-android.api
@@ -53,11 +53,15 @@ public final class leakcanary/AppWatcher$Config$Builder {
 }
 
 public final class leakcanary/FragmentAndViewModelWatcher : leakcanary/InstallableWatcher {
+	public static final field Companion Lleakcanary/FragmentAndViewModelWatcher$Companion;
 	public fun <init> (Landroid/app/Application;Lleakcanary/ReachabilityWatcher;)V
 	public fun install ()V
 	public fun uninstall ()V
 }
 
+public final class leakcanary/FragmentAndViewModelWatcher$Companion {
+}
+
 public abstract interface class leakcanary/InstallableWatcher {
 	public abstract fun install ()V
 	public abstract fun uninstall ()V
@@ -70,8 +74,12 @@ public final class leakcanary/RootViewWatcher : leakcanary/InstallableWatcher {
 }
 
 public final class leakcanary/ServiceWatcher : leakcanary/InstallableWatcher {
+	public static final field Companion Lleakcanary/ServiceWatcher$Companion;
 	public fun <init> (Lleakcanary/ReachabilityWatcher;)V
 	public fun install ()V
 	public fun uninstall ()V
 }
 
+public final class leakcanary/ServiceWatcher$Companion {
+}
+
diff --git a/leakcanary-object-watcher-android/build.gradle b/leakcanary-object-watcher-android/build.gradle
index 7335315c5..1bfd62ef4 100644
--- a/leakcanary-object-watcher-android/build.gradle
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'kotlin-android'
 
 dependencies {
   api project(':leakcanary-object-watcher')
+  api project(':leakcanary-android-utils')
 
   implementation deps.kotlin.stdlib
 
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/ActivityWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/ActivityWatcher.kt
index 5a0c73599..49ce28149 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/ActivityWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/ActivityWatcher.kt
@@ -1,23 +1,8 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package leakcanary
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.internal.noOpDelegate
+import leakcanary.internal.friendly.noOpDelegate
 
 /**
  * Expects activities to become weakly reachable soon after they receive the [Activity.onDestroy]
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
index ba0f8607d..199940436 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
@@ -3,13 +3,11 @@ package leakcanary
 import android.app.Application
 import android.os.SystemClock
 import leakcanary.AppWatcher.objectWatcher
-import leakcanary.internal.DefaultCanaryLog
 import leakcanary.internal.LeakCanaryDelegate
-import leakcanary.internal.checkMainThread
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.mainHandler
 import leakcanary.internal.isDebuggableBuild
-import leakcanary.internal.mainHandler
 import shark.SharkLog
-import java.util.concurrent.Executor
 import java.util.concurrent.TimeUnit
 
 /**
@@ -102,7 +100,7 @@ object AppWatcher {
     }
     this.retainedDelayMillis = retainedDelayMillis
     if (application.isDebuggableBuild) {
-      SharkLog.logger = DefaultCanaryLog()
+      LogcatSharkLog.install()
     }
     // Requires AppWatcher.objectWatcher to be set
     LeakCanaryDelegate.loadLeakCanary(application)
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt
index a8ba15ae4..2588b6a6e 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/FragmentAndViewModelWatcher.kt
@@ -1,18 +1,3 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package leakcanary
 
 import android.app.Activity
@@ -21,7 +6,7 @@ import android.os.Build.VERSION.SDK_INT
 import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
 import leakcanary.internal.AndroidOFragmentDestroyWatcher
-import leakcanary.internal.noOpDelegate
+import leakcanary.internal.friendly.noOpDelegate
 
 /**
  * Expects:
@@ -119,7 +104,7 @@ class FragmentAndViewModelWatcher(
     }
   }
 
-  private companion object {
+  companion object {
     private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
     private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
       "leakcanary.internal.AndroidXFragmentDestroyWatcher"
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/RootViewWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/RootViewWatcher.kt
index 7899fb1be..633a0424d 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/RootViewWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/RootViewWatcher.kt
@@ -18,7 +18,7 @@ package leakcanary
 import android.annotation.SuppressLint
 import android.view.View
 import android.view.View.OnAttachStateChangeListener
-import leakcanary.internal.mainHandler
+import leakcanary.internal.friendly.mainHandler
 import shark.SharkLog
 
 /**
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/ServiceWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/ServiceWatcher.kt
index 5eb584177..7c03e7629 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/ServiceWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/ServiceWatcher.kt
@@ -5,7 +5,7 @@ import android.app.Service
 import android.os.Build
 import android.os.Handler
 import android.os.IBinder
-import leakcanary.internal.checkMainThread
+import leakcanary.internal.friendly.checkMainThread
 import shark.SharkLog
 import java.lang.ref.WeakReference
 import java.lang.reflect.Proxy
@@ -149,7 +149,7 @@ class ServiceWatcher(private val reachabilityWatcher: ReachabilityWatcher) : Ins
       swap(iActivityManagerInterface, activityManagerInstance!!)
   }
 
-  private companion object {
+  companion object {
     private const val STOP_SERVICE = 116
 
     private const val METHOD_SERVICE_DONE_EXECUTING = "serviceDoneExecuting"
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Handlers.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Handlers.kt
deleted file mode 100644
index f35e76f1c..000000000
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/Handlers.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary.internal
-
-import android.os.Handler
-import android.os.Looper
-
-internal val mainHandler by lazy { Handler(Looper.getMainLooper()) }
-
-internal fun checkMainThread() {
-  check(Looper.getMainLooper().thread === Thread.currentThread()) {
-    "Should be called from the main thread, not ${Thread.currentThread()}"
-  }
-}
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/friendly/Friendly.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 000000000..b8c81cefc
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,11 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("leakcanary-object-watcher-android_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline val mainHandler
+  get() = leakcanary.internal.mainHandler
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
diff --git a/plumber-android/build.gradle b/plumber-android/build.gradle
index f0eb8febd..48b1bc9ba 100644
--- a/plumber-android/build.gradle
+++ b/plumber-android/build.gradle
@@ -3,6 +3,7 @@ apply plugin: 'kotlin-android'
 
 dependencies {
   api project(':shark-log')
+  api project(':leakcanary-android-utils')
 
   implementation deps.kotlin.stdlib
   // Optional dependency
diff --git a/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt b/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
index 5dd909a44..f98104384 100644
--- a/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
+++ b/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
@@ -22,10 +22,11 @@ import android.view.inputmethod.InputMethodManager
 import android.view.textservice.TextServicesManager
 import android.widget.TextView
 import leakcanary.internal.ReferenceCleaner
+import leakcanary.internal.friendly.checkMainThread
+import leakcanary.internal.friendly.noOpDelegate
 import shark.SharkLog
 import java.lang.reflect.Array
 import java.lang.reflect.Field
-import java.lang.reflect.InvocationHandler
 import java.lang.reflect.InvocationTargetException
 import java.lang.reflect.Method
 import java.lang.reflect.Modifier
@@ -740,24 +741,6 @@ enum class AndroidLeakFixes {
       })
     }
 
-    internal inline fun <reified T : Any> noOpDelegate(): T {
-      val javaClass = T::class.java
-      val noOpHandler = InvocationHandler { _, _, _ ->
-        // no op
-      }
-      return Proxy.newProxyInstance(
-        javaClass.classLoader, arrayOf(javaClass), noOpHandler
-      ) as T
-    }
-
-    internal fun checkMainThread() {
-      if (Looper.getMainLooper().thread !== Thread.currentThread()) {
-        throw UnsupportedOperationException(
-          "Should be called from the main thread, not ${Thread.currentThread()}"
-        )
-      }
-    }
-
     private fun Window.onDecorViewReady(callback: () -> Unit) {
       if (peekDecorView() == null) {
         onContentChanged {
diff --git a/plumber-android/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt b/plumber-android/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt
index 5920731cc..7d8b07cee 100644
--- a/plumber-android/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt
+++ b/plumber-android/src/main/java/leakcanary/ViewLocationHolderLeakFix.kt
@@ -8,9 +8,10 @@ import android.os.Bundle
 import android.view.View
 import android.view.ViewGroup
 import android.widget.FrameLayout
-import leakcanary.AndroidLeakFixes.Companion.checkMainThread
+import leakcanary.internal.friendly.checkMainThread
 import leakcanary.internal.onAndroidXFragmentViewDestroyed
 import shark.SharkLog
+import leakcanary.internal.friendly.noOpDelegate
 
 /**
  * @see [AndroidLeakFixes.VIEW_LOCATION_HOLDER].
@@ -26,7 +27,7 @@ object ViewLocationHolderLeakFix {
       return
     }
     application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks
-    by AndroidLeakFixes.noOpDelegate() {
+    by noOpDelegate() {
 
       override fun onActivityCreated(
         activity: Activity,
diff --git a/plumber-android/src/main/java/leakcanary/internal/friendly/Friendly.kt b/plumber-android/src/main/java/leakcanary/internal/friendly/Friendly.kt
new file mode 100644
index 000000000..b4569ade7
--- /dev/null
+++ b/plumber-android/src/main/java/leakcanary/internal/friendly/Friendly.kt
@@ -0,0 +1,8 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "NOTHING_TO_INLINE")
+@file:JvmName("plumber-android_Friendly")
+
+package leakcanary.internal.friendly
+
+internal inline fun checkMainThread() = leakcanary.internal.checkMainThread()
+
+internal inline fun <reified T : Any> noOpDelegate(): T = leakcanary.internal.noOpDelegate()
\ No newline at end of file
diff --git a/settings.gradle b/settings.gradle
index 4dc8fe6ef..a71c2d8bc 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -5,6 +5,7 @@ include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
 include ':leakcanary-android-release'
 include ':leakcanary-android-sample'
+include ':leakcanary-android-utils'
 include ':leakcanary-object-watcher'
 include ':leakcanary-object-watcher-android'
 include ':leakcanary-object-watcher-android-androidx'
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
index d68b1fa5a..cc69801fa 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -23,7 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongScatterSet {
+internal class LongScatterSet(expectedElements: Int = 4) {
   /** The hash array holding keys.  */
   private var keys: LongArray = longArrayOf()
 
@@ -57,7 +57,7 @@ internal class LongScatterSet {
   private val loadFactor = 0.75
 
   init {
-    ensureCapacity(4)
+    ensureCapacity(expectedElements)
   }
 
   private fun hashKey(key: Long): Int {
diff --git a/shark/src/main/java/shark/internal/DominatorTree.kt b/shark/src/main/java/shark/internal/DominatorTree.kt
index ebad41896..c497255a1 100644
--- a/shark/src/main/java/shark/internal/DominatorTree.kt
+++ b/shark/src/main/java/shark/internal/DominatorTree.kt
@@ -1,10 +1,11 @@
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER", "CANNOT_OVERRIDE_INVISIBLE_MEMBER")
 package shark.internal
 
 import shark.ValueHolder
 import shark.internal.ObjectDominators.DominatorNode
-import shark.internal.hppcshark.LongLongScatterMap
-import shark.internal.hppcshark.LongLongScatterMap.ForEachCallback
-import shark.internal.hppcshark.LongScatterSet
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongLongScatterMap.ForEachCallback
+import shark.internal.hppc.LongScatterSet
 
 internal class DominatorTree(expectedElements: Int = 4) {
 
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index f6bb4f776..a2022e800 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -1,18 +1,4 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+@file:Suppress("INVISIBLE_REFERENCE", "INVISIBLE_MEMBER")
 package shark.internal
 
 import shark.GcRoot
@@ -60,9 +46,7 @@ import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
 import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
 import shark.internal.ReferencePathNode.RootNode.NormalRootNode
-import shark.internal.hppcshark.LongObjectPair
-import shark.internal.hppcshark.LongScatterSet
-import shark.internal.hppcshark.to
+import shark.internal.hppc.LongScatterSet
 import java.util.ArrayDeque
 import java.util.Deque
 import java.util.LinkedHashMap
@@ -276,7 +260,7 @@ internal class PathFinder(
     val shortestPathsToLeakingObjects = mutableListOf<ReferencePathNode>()
     visitingQueue@ while (queuesNotEmpty) {
       val node = poll()
-      if (node.objectId in leakingObjectIds) {
+      if (leakingObjectIds.contains(node.objectId)) {
         shortestPathsToLeakingObjects.add(node)
         // Found all refs, stop searching (unless computing retained size)
         if (shortestPathsToLeakingObjects.size == leakingObjectIds.size()) {
@@ -672,7 +656,7 @@ internal class PathFinder(
       return
     }
 
-    val isLeakingObject = node.objectId in leakingObjectIds
+    val isLeakingObject = leakingObjectIds.contains(node.objectId)
 
     if (!isLeakingObject) {
       val skip = when (val graphObject = graph.findObjectById(node.objectId)) {
diff --git a/shark/src/main/java/shark/internal/hppcshark/HHPC.kt b/shark/src/main/java/shark/internal/hppcshark/HHPC.kt
deleted file mode 100644
index 510df62fd..000000000
--- a/shark/src/main/java/shark/internal/hppcshark/HHPC.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package shark.internal.hppcshark
-
-import java.util.Locale
-
-/**
- * Code from https://github.com/carrotsearch/hppc copy pasted, inlined and converted to Kotlin.
- */
-internal object HHPC {
-
-  private const val PHI_C64 = -0x61c8864680b583ebL
-
-  fun mixPhi(k: Long): Int {
-    val h = k * PHI_C64
-    return (h xor h.ushr(32)).toInt()
-  }
-
-  private const val MIN_HASH_ARRAY_LENGTH = 4
-  private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
-
-  fun minBufferSize(
-    elements: Int,
-    loadFactor: Double
-  ): Int {
-    var length = Math.ceil(elements / loadFactor)
-      .toLong()
-    if (length == elements.toLong()) {
-      length++
-    }
-    length = Math.max(
-      MIN_HASH_ARRAY_LENGTH.toLong(),
-      nextHighestPowerOfTwo(length)
-    )
-
-    if (length > MAX_HASH_ARRAY_LENGTH) {
-      throw RuntimeException(
-        String.format(
-          Locale.ROOT,
-          "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
-          elements,
-          loadFactor
-        )
-      )
-    }
-
-    return length.toInt()
-  }
-
-  fun nextHighestPowerOfTwo(input: Long): Long {
-    var v = input
-    v--
-    v = v or (v shr 1)
-    v = v or (v shr 2)
-    v = v or (v shr 4)
-    v = v or (v shr 8)
-    v = v or (v shr 16)
-    v = v or (v shr 32)
-    v++
-    return v
-  }
-
-  fun expandAtCount(
-    arraySize: Int,
-    loadFactor: Double
-  ): Int {
-    return Math.min(arraySize - 1, Math.ceil(arraySize * loadFactor).toInt())
-  }
-
-  fun nextBufferSize(
-    arraySize: Int,
-    elements: Int,
-    loadFactor: Double
-  ): Int {
-    if (arraySize == MAX_HASH_ARRAY_LENGTH) {
-      throw RuntimeException(
-        String.format(
-          Locale.ROOT,
-          "Maximum array size exceeded for this load factor (elements: %d, load factor: %f)",
-          elements,
-          loadFactor
-        )
-      )
-    }
-
-    return arraySize shl 1
-  }
-}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/hppcshark/LongLongScatterMap.kt b/shark/src/main/java/shark/internal/hppcshark/LongLongScatterMap.kt
deleted file mode 100644
index 514823f7f..000000000
--- a/shark/src/main/java/shark/internal/hppcshark/LongLongScatterMap.kt
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package shark.internal.hppcshark
-
-import java.util.Locale
-
-/**
- * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
- *
- * See https://github.com/carrotsearch/hppc .
- */
-internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
-
-  interface ForEachCallback {
-    fun onEntry(
-      key: Long,
-      value: Long
-    )
-  }
-
-  /**
-   * The array holding keys.
-   */
-  private var keys: LongArray = longArrayOf()
-
-  /**
-   * The array holding values.
-   */
-  private var values: LongArray = longArrayOf()
-
-  /**
-   * The number of stored keys (assigned key slots), excluding the special
-   * "empty" key, if any (use [.size] instead).
-   *
-   * @see .size
-   */
-  private var assigned: Int = 0
-
-  /**
-   * Mask for slot scans in [.keys].
-   */
-  private var mask: Int = 0
-
-  /**
-   * Expand (rehash) [.keys] when [.assigned] hits this value.
-   */
-  private var resizeAt: Int = 0
-
-  /**
-   * Special treatment for the "empty slot" key marker.
-   */
-  private var hasEmptyKey: Boolean = false
-
-  /**
-   * The load factor for [.keys].
-   */
-  private var loadFactor: Double = 0.75
-
-  val isEmpty: Boolean
-    get() = size == 0
-
-  init {
-    ensureCapacity(expectedElements)
-  }
-
-  operator fun set(
-    key: Long,
-    value: Long
-  ): Long {
-    val mask = this.mask
-    if (key == 0L) {
-      hasEmptyKey = true
-      val previousValue = values[mask + 1]
-      values[mask + 1] = value
-      return previousValue
-    } else {
-      val keys = this.keys
-      var slot = hashKey(key) and mask
-
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          val previousValue = values[slot]
-          values[slot] = value
-          return previousValue
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-
-      if (assigned == resizeAt) {
-        allocateThenInsertThenRehash(slot, key, value)
-      } else {
-        keys[slot] = key
-        values[slot] = value
-      }
-
-      assigned++
-      return 0L
-    }
-  }
-
-  fun remove(key: Long): Long {
-    val mask = this.mask
-    if (key == 0L) {
-      hasEmptyKey = false
-      val previousValue = values[mask + 1]
-      values[mask + 1] = 0L
-      return previousValue
-    } else {
-      val keys = this.keys
-      var slot = hashKey(key) and mask
-
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          val previousValue = values[slot]
-          shiftConflictingKeys(slot)
-          return previousValue
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-
-      return 0L
-    }
-  }
-
-  /**
-   * Being given a key looks it up in the map and returns the slot where element sits, so it later
-   * can be retrieved with [getSlotValue]; return '-1' if element not found.
-   * Why so complicated and not just make [get] return null if value not found? The reason is performance:
-   * this approach prevents unnecessary boxing of the primitive long that would happen with nullable Long?
-   */
-  fun getSlot(key: Long): Int {
-    if (key == 0L) {
-      return if (hasEmptyKey) mask + 1 else -1
-    } else {
-      val keys = this.keys
-      val mask = this.mask
-      var slot = hashKey(key) and mask
-
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          return slot
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-
-      return -1
-    }
-  }
-
-  /**
-   * Being given a slot of element retrieves it from the collection
-   */
-  fun getSlotValue(slot: Int): Long = values[slot]
-
-  /**
-   * Returns an element matching a provided [key]; throws [IllegalArgumentException] if element not found
-   */
-  operator fun get(key: Long): Long {
-    val slot = getSlot(key)
-    require(slot != -1) { "Unknown key $key" }
-
-    return getSlotValue(slot)
-  }
-
-  fun forEach(forEachCallback: ForEachCallback) {
-    val max = mask + 1
-    var slot = -1
-
-    exitWhile@ while (true) {
-      if (slot < max) {
-        var existing: Long
-        slot++
-        while (slot < max) {
-          existing = keys[slot]
-          if (existing != 0L) {
-            forEachCallback.onEntry(existing, values[slot])
-            continue@exitWhile
-          }
-          slot++
-        }
-      }
-
-      if (slot == max && hasEmptyKey) {
-        slot++
-        forEachCallback.onEntry(0L, values[max])
-        continue@exitWhile
-      }
-      break@exitWhile
-    }
-  }
-
-  fun entrySequence(): Sequence<LongLongPair> {
-    val max = mask + 1
-    var slot = -1
-    return generateSequence {
-      if (slot < max) {
-        var existing: Long
-        slot++
-        while (slot < max) {
-          existing = keys[slot]
-          if (existing != 0L) {
-            return@generateSequence existing to values[slot]
-          }
-          slot++
-        }
-      }
-      if (slot == max && hasEmptyKey) {
-        slot++
-        return@generateSequence 0L to values[max]
-      }
-      return@generateSequence null
-    }
-  }
-
-  fun containsKey(key: Long): Boolean {
-    if (key == 0L) {
-      return hasEmptyKey
-    } else {
-      val keys = this.keys
-      val mask = this.mask
-      var slot = hashKey(key) and mask
-
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          return true
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-
-      return false
-    }
-  }
-
-  fun release() {
-    assigned = 0
-    hasEmptyKey = false
-
-    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
-  }
-
-  val size: Int
-    get() {
-      return assigned + if (hasEmptyKey) 1 else 0
-    }
-
-  fun ensureCapacity(expectedElements: Int) {
-    if (expectedElements > resizeAt) {
-      val prevKeys = this.keys
-      val prevValues = this.values
-      allocateBuffers(
-        HHPC.minBufferSize(
-          expectedElements, loadFactor
-        )
-      )
-      if (!isEmpty) {
-        rehash(prevKeys, prevValues)
-      }
-    }
-  }
-
-  private fun hashKey(key: Long): Int {
-    return HHPC.mixPhi(key)
-  }
-
-  /**
-   * Rehash from old buffers to new buffers.
-   */
-  private fun rehash(
-    fromKeys: LongArray,
-    fromValues: LongArray
-  ) {
-    // Rehash all stored key/value pairs into the new buffers.
-    val keys = this.keys
-    val values = this.values
-    val mask = this.mask
-    var existing: Long
-
-    // Copy the zero element's slot, then rehash everything else.
-    var from = fromKeys.size - 1
-    keys[keys.size - 1] = fromKeys[from]
-    values[values.size - 1] = fromValues[from]
-    while (--from >= 0) {
-      existing = fromKeys[from]
-      if (existing != 0L) {
-        var slot = hashKey(existing) and mask
-        while (keys[slot] != 0L) {
-          slot = slot + 1 and mask
-        }
-        keys[slot] = existing
-        values[slot] = fromValues[from]
-      }
-    }
-  }
-
-  /**
-   * Allocate new internal buffers. This method attempts to allocate
-   * and assign internal buffers atomically (either allocations succeed or not).
-   */
-  private fun allocateBuffers(arraySize: Int) {
-
-    // Ensure no change is done if we hit an OOM.
-    val prevKeys = this.keys
-    val prevValues = this.values
-    try {
-      val emptyElementSlot = 1
-      this.keys = LongArray(arraySize + emptyElementSlot)
-      this.values = LongArray(arraySize + emptyElementSlot)
-    } catch (e: OutOfMemoryError) {
-      this.keys = prevKeys
-      this.values = prevValues
-      throw RuntimeException(
-        String.format(
-          Locale.ROOT,
-          "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
-          this.mask + 1,
-          arraySize
-        ), e
-      )
-    }
-
-    this.resizeAt =
-      HHPC.expandAtCount(arraySize, loadFactor)
-    this.mask = arraySize - 1
-  }
-
-  /**
-   * This method is invoked when there is a new key/ value pair to be inserted into
-   * the buffers but there is not enough empty slots to do so.
-   *
-   * New buffers are allocated. If this succeeds, we know we can proceed
-   * with rehashing so we assign the pending element to the previous buffer
-   * (possibly violating the invariant of having at least one empty slot)
-   * and rehash all keys, substituting new buffers at the end.
-   */
-  private fun allocateThenInsertThenRehash(
-    slot: Int,
-    pendingKey: Long,
-    pendingValue: Long
-  ) {
-
-    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
-    val prevKeys = this.keys
-    val prevValues = this.values
-    allocateBuffers(
-      HHPC.nextBufferSize(mask + 1, size, loadFactor)
-    )
-
-    // We have succeeded at allocating new data so insert the pending key/value at
-    // the free slot in the old arrays before rehashing.
-    prevKeys[slot] = pendingKey
-    prevValues[slot] = pendingValue
-
-    // Rehash old keys, including the pending key.
-    rehash(prevKeys, prevValues)
-  }
-
-  /**
-   * Shift all the slot-conflicting keys and values allocated to
-   * (and including) `slot`.
-   */
-  private fun shiftConflictingKeys(gapSlotArg: Int) {
-    var gapSlot = gapSlotArg
-    val keys = this.keys
-    val values = this.values
-    val mask = this.mask
-
-    // Perform shifts of conflicting keys to fill in the gap.
-    var distance = 0
-    while (true) {
-      val slot = gapSlot + ++distance and mask
-      val existing = keys[slot]
-      if (existing == 0L) {
-        break
-      }
-
-      val idealSlot = hashKey(existing)
-      val shift = slot - idealSlot and mask
-      if (shift >= distance) {
-        // Entry at this position was originally at or before the gap slot.
-        // Move the conflict-shifted entry to the gap's position and repeat the procedure
-        // for any entries to the right of the current position, treating it
-        // as the new gap.
-        keys[gapSlot] = existing
-        values[gapSlot] = values[slot]
-        gapSlot = slot
-        distance = 0
-      }
-    }
-
-    // Mark the last found gap slot without a conflict as empty.
-    keys[gapSlot] = 0L
-    values[gapSlot] = 0L
-    assigned--
-  }
-}
diff --git a/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt b/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt
deleted file mode 100644
index 9c4be5da3..000000000
--- a/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package shark.internal.hppcshark
-
-import java.util.Locale
-
-/**
- * Code from com.carrotsearch.hppc.LongScatterSet copy pasted, inlined and converted to Kotlin.
- *
- * See https://github.com/carrotsearch/hppc .
- */
-internal class LongScatterSet(expectedElements: Int = 4) {
-  /** The hash array holding keys.  */
-  private var keys: LongArray = longArrayOf()
-
-  /**
-   * The number of stored keys (assigned key slots), excluding the special
-   * "empty" key, if any.
-   *
-   * @see .size
-   * @see .hasEmptyKey
-   */
-  private var assigned = 0
-
-  /**
-   * Mask for slot scans in [.keys].
-   */
-  private var mask = 0
-
-  /**
-   * Expand (rehash) [.keys] when [.assigned] hits this value.
-   */
-  private var resizeAt = 0
-
-  /**
-   * Special treatment for the "empty slot" key marker.
-   */
-  private var hasEmptyKey = false
-
-  /**
-   * The load factor for [.keys].
-   */
-  private val loadFactor = 0.75
-
-  init {
-    ensureCapacity(expectedElements)
-  }
-
-  private fun hashKey(key: Long): Int {
-    return HHPC.mixPhi(key)
-  }
-
-  operator fun plusAssign(key: Long) {
-    add(key)
-  }
-
-  fun add(key: Long): Boolean {
-    if (key == 0L) {
-      val added = !hasEmptyKey
-      hasEmptyKey = true
-      return added
-    } else {
-      val keys = this.keys
-      val mask = this.mask
-      var slot = hashKey(key) and mask
-
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          return false
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-
-      if (assigned == resizeAt) {
-        allocateThenInsertThenRehash(slot, key)
-      } else {
-        keys[slot] = key
-      }
-
-      assigned++
-      return true
-    }
-  }
-
-  operator fun contains(key: Long): Boolean {
-    if (key == 0L) {
-      return hasEmptyKey
-    } else {
-      val keys = this.keys
-      val mask = this.mask
-      var slot = hashKey(key) and mask
-      var existing = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          return true
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-      return false
-    }
-  }
-
-  fun remove(key: Long): Boolean {
-    return if (key == 0L) {
-      val hadEmptyKey = hasEmptyKey
-      hasEmptyKey = false
-      hadEmptyKey
-    } else {
-      val keys = this.keys
-      val mask = this.mask
-      var slot = hashKey(key) and mask
-      var existing: Long = keys[slot]
-      while (existing != 0L) {
-        if (existing == key) {
-          shiftConflictingKeys(slot)
-          return true
-        }
-        slot = slot + 1 and mask
-        existing = keys[slot]
-      }
-      false
-    }
-  }
-
-  /**
-   * Shift all the slot-conflicting keys allocated to (and including) `slot`.
-   */
-  private fun shiftConflictingKeys(inputGapSlot: Int) {
-    var gapSlot = inputGapSlot
-    val keys = keys
-    val mask = mask
-    // Perform shifts of conflicting keys to fill in the gap.
-    var distance = 0
-    while (true) {
-      val slot = (gapSlot + (++distance)) and mask
-      val existing = keys[slot]
-      if (existing == 0L) {
-        break
-      }
-      val idealSlot = hashKey(existing)
-      val shift = (slot - idealSlot) and mask
-      if (shift >= distance) {
-        // Entry at this position was originally at or before the gap slot.
-        // Move the conflict-shifted entry to the gap's position and repeat the procedure
-        // for any entries to the right of the current position, treating it
-        // as the new gap.
-        keys[gapSlot] = existing
-        gapSlot = slot
-        distance = 0
-      }
-    }
-    // Mark the last found gap slot without a conflict as empty.
-    keys[gapSlot] = 0L
-    assigned--
-  }
-
-  fun release() {
-    assigned = 0
-    hasEmptyKey = false
-    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
-  }
-
-  fun ensureCapacity(expectedElements: Int) {
-    if (expectedElements > resizeAt) {
-      val prevKeys = this.keys
-      allocateBuffers(
-        HHPC.minBufferSize(
-          expectedElements, loadFactor
-        )
-      )
-      if (size() != 0) {
-        rehash(prevKeys)
-      }
-    }
-  }
-
-  fun size(): Int {
-    return assigned + if (hasEmptyKey) 1 else 0
-  }
-
-  private fun rehash(fromKeys: LongArray) {
-    // Rehash all stored keys into the new buffers.
-    val keys = this.keys
-    val mask = this.mask
-    var existing: Long
-    var i = fromKeys.size - 1
-    while (--i >= 0) {
-      existing = fromKeys[i]
-      if (existing != 0L) {
-        var slot = hashKey(existing) and mask
-        while (keys[slot] != 0L) {
-          slot = slot + 1 and mask
-        }
-        keys[slot] = existing
-      }
-    }
-  }
-
-  /**
-   * Allocate new internal buffers. This method attempts to allocate
-   * and assign internal buffers atomically (either allocations succeed or not).
-   */
-  private fun allocateBuffers(arraySize: Int) {
-    // Ensure no change is done if we hit an OOM.
-    val prevKeys = this.keys
-    try {
-      val emptyElementSlot = 1
-      this.keys = LongArray(arraySize + emptyElementSlot)
-    } catch (e: OutOfMemoryError) {
-      this.keys = prevKeys
-      throw RuntimeException(
-        String.format(
-          Locale.ROOT,
-          "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
-          size(),
-          arraySize
-        ), e
-      )
-    }
-
-    this.resizeAt =
-      HHPC.expandAtCount(arraySize, loadFactor)
-    this.mask = arraySize - 1
-  }
-
-  private fun allocateThenInsertThenRehash(
-    slot: Int,
-    pendingKey: Long
-  ) {
-    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
-    val prevKeys = this.keys
-    allocateBuffers(
-      HHPC.nextBufferSize(
-        mask + 1, size(), loadFactor
-      )
-    )
-
-    // We have succeeded at allocating new data so insert the pending key/value at
-    // the free slot in the old arrays before rehashing.
-    prevKeys[slot] = pendingKey
-
-    // Rehash old keys, including the pending key.
-    rehash(prevKeys)
-  }
-}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/hppcshark/Tuples.kt b/shark/src/main/java/shark/internal/hppcshark/Tuples.kt
deleted file mode 100644
index 8597386b2..000000000
--- a/shark/src/main/java/shark/internal/hppcshark/Tuples.kt
+++ /dev/null
@@ -1,17 +0,0 @@
-package shark.internal.hppcshark
-
-/** Alternative to Pair<Long, Object> that doesn't box long.*/
-internal data class LongObjectPair<out B>(
-  val first: Long,
-  val second: B
-)
-
-/** Alternative to Pair<Long, Long> that doesn't box longs. */
-internal data class LongLongPair(
-  val first: Long,
-  val second: Long
-)
-
-internal infix fun <B> Long.to(that: B): LongObjectPair<B> = LongObjectPair(this, that)
-
-internal infix fun Long.to(that: Long): LongLongPair = LongLongPair(this, that)
