diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index 66b5f7da4..e1b267089 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -12,8 +12,10 @@ dependencies {
   testImplementation deps.junit
   testImplementation deps.mockito
   testImplementation deps.mockito_kotlin
-
+  androidTestImplementation deps.androidx.test.espresso
+  androidTestImplementation deps.androidx.test.rules
   androidTestImplementation deps.androidx.test.runner
+  androidTestImplementation project(':shark-hprof-test')
 }
 
 def gitSha() {
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
new file mode 100644
index 000000000..fd2427a14
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseRule.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import android.database.sqlite.SQLiteDatabase
+import androidx.test.platform.app.InstrumentationRegistry
+import leakcanary.internal.activity.db.LeaksDbHelper
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.model.Statement
+
+class DatabaseRule(private val updateDb: (SQLiteDatabase) -> Unit = {}) : TestRule {
+  override fun apply(
+    base: Statement,
+    description: Description
+  ): Statement {
+    return object : Statement() {
+      override fun evaluate() {
+        val instrumentation = InstrumentationRegistry.getInstrumentation()
+        val context = instrumentation.targetContext
+        context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
+        LeaksDbHelper(context).writableDatabase.use(updateDb)
+        base.evaluate()
+        context.deleteDatabase(LeaksDbHelper.DATABASE_NAME)
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
new file mode 100644
index 000000000..fcb1c750f
--- /dev/null
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/LeakActivityTest.kt
@@ -0,0 +1,143 @@
+package leakcanary
+
+import android.os.SystemClock
+import androidx.test.espresso.Espresso.onData
+import androidx.test.espresso.Espresso.onView
+import androidx.test.espresso.action.ViewActions.click
+import androidx.test.espresso.assertion.ViewAssertions.matches
+import androidx.test.espresso.matcher.ViewMatchers.isDisplayed
+import androidx.test.espresso.matcher.ViewMatchers.withId
+import androidx.test.espresso.matcher.ViewMatchers.withSubstring
+import androidx.test.espresso.matcher.ViewMatchers.withText
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.rule.ActivityTestRule
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.LeakActivity
+import leakcanary.internal.activity.db.HeapAnalysisTable
+import leakcanary.internal.activity.db.HeapAnalysisTable.Projection
+import leakcanary.internal.activity.db.LeakTable.AllLeaksProjection
+import leakcanary.internal.activity.db.LeaksDbHelper
+import org.hamcrest.Description
+import org.hamcrest.Matcher
+import org.hamcrest.TypeSafeMatcher
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.RuleChain
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
+import shark.HeapAnalyzer
+import shark.HprofWriterHelper
+import shark.LeakTraceObject
+import shark.LeakTraceReference
+import shark.OnAnalysisProgressListener
+import shark.SharkLog
+import shark.ValueHolder.IntHolder
+import shark.dump
+import kotlin.reflect.KClass
+
+internal class LeakActivityTest {
+
+  private val activityTestRule = ActivityTestRule(LeakActivity::class.java, false, false)
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @get:Rule
+  var rules: RuleChain = RuleChain.outerRule(DatabaseRule())
+      .around(activityTestRule)
+
+  @Test
+  fun noLeakOnHome() {
+    activityTestRule.launchActivity(null)
+    onView(withText("0 Distinct Leaks")).check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun oneLeakOnHome() {
+    insertHeapDump {
+      "Holder" clazz {
+        staticField["leak"] = "com.example.Leaking" watchedInstance {}
+      }
+    }
+    activityTestRule.launchActivity(null)
+    onView(withText("1 Distinct Leak")).check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun seeLeakOnLeakScreen() {
+    insertHeapDump {
+      "Holder" clazz {
+        staticField["leak"] = "com.example.Leaking" watchedInstance {}
+      }
+    }
+    activityTestRule.launchActivity(null)
+
+    onData(withItem<AllLeaksProjection> { it.shortDescription == "Holder.leak" })
+        .perform(click())
+    onData(withItem<LeakTraceObject> { it.className == "com.example.Leaking" })
+        .inAdapterView(withId(R.id.leak_canary_list))
+        .check(matches(isDisplayed()))
+  }
+
+  @Test
+  fun leakWithEmptyReferencePath() {
+    insertHeapDump {
+      val leakingInstance = "com.example.Leaking" watchedInstance {}
+      gcRoot(JniGlobal(id = leakingInstance.value, jniGlobalRefId = 42))
+    }
+    activityTestRule.launchActivity(null)
+
+    onData(withItem<AllLeaksProjection> { it.shortDescription == "com.example.Leaking" })
+        .perform(click())
+    onData(withItem<LeakTraceObject> { it.className == "com.example.Leaking" })
+        .inAdapterView(withId(R.id.leak_canary_list))
+        .check(matches(isDisplayed()))
+  }
+
+  private fun insertHeapDump(block: HprofWriterHelper.() -> Unit) {
+    val hprofFile = testFolder.newFile("temp.hprof")
+    hprofFile.dump {
+      "android.os.Build" clazz {
+        staticField["MANUFACTURER"] = string("Samsing")
+      }
+      "android.os.Build\$VERSION" clazz {
+        staticField["SDK_INT"] = IntHolder(47)
+      }
+      block()
+    }
+
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val result = heapAnalyzer.analyze(
+        heapDumpFile = hprofFile,
+        leakingObjectFinder = LeakCanary.config.leakingObjectFinder,
+        referenceMatchers = LeakCanary.config.referenceMatchers,
+        computeRetainedHeapSize = LeakCanary.config.computeRetainedHeapSize,
+        objectInspectors = LeakCanary.config.objectInspectors,
+        metadataExtractor = LeakCanary.config.metadataExtractor,
+        proguardMapping = null
+    )
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+    LeaksDbHelper(context).writableDatabase.use { db ->
+      HeapAnalysisTable.insert(db, result)
+    }
+  }
+
+  inline fun <reified T : Any> withItem(
+    filterDescription: String? = null,
+    crossinline filter: (T) -> Boolean
+  ): Matcher<T> {
+    return object : TypeSafeMatcher<T>(T::class.java) {
+      override fun describeTo(description: Description) {
+        if (filterDescription != null) {
+          description.appendText("is $filterDescription")
+        }
+      }
+
+      override fun matchesSafely(item: T): Boolean {
+        return filter(item)
+      }
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 9a5963799..d823dccd8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -191,16 +191,16 @@ internal class DisplayLeakAdapter constructor(
     if (position == 1) {
       return GC_ROOT
     } else if (position == 2) {
-      if (leakTrace.referencePath.size == 1) {
-        return START_LAST_REACHABLE
+      return when (leakTrace.referencePath.size) {
+        0 -> END_FIRST_UNREACHABLE
+        1 -> START_LAST_REACHABLE
+        else -> {
+          val nextReachability = leakTrace.referencePath[1].originObject
+          if (nextReachability.leakingStatus != NOT_LEAKING) {
+            START_LAST_REACHABLE
+          } else START
+        }
       }
-      val nextReachability =
-        if (position + 1 == count - 1) leakTrace.leakingObject else leakTrace.referencePath[elementIndex(
-            position + 1
-        )].originObject
-      return if (nextReachability.leakingStatus != NOT_LEAKING) {
-        START_LAST_REACHABLE
-      } else START
     } else {
       val isLeakingInstance = position == count - 1
       if (isLeakingInstance) {
@@ -245,7 +245,11 @@ internal class DisplayLeakAdapter constructor(
 
   override fun getCount() = leakTrace.referencePath.size + 3
 
-  override fun getItem(position: Int) = null
+  override fun getItem(position: Int) = when {
+    position == 0 || position == 1 -> null
+    position == count - 1 -> leakTrace.leakingObject
+    else -> leakTrace.referencePath[elementIndex(position)]
+  }
 
   private fun elementIndex(position: Int) = position - 2
 
diff --git a/settings.gradle b/settings.gradle
index e7a1e66f6..3964e5fc6 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -12,6 +12,7 @@ include ':shark-android'
 include ':shark-cli'
 include ':shark-graph'
 include ':shark-hprof'
+include ':shark-hprof-test'
 include ':shark-log'
 include ':shark-test'
 include ':leakcanary-deobfuscation-gradle-plugin'
diff --git a/shark-hprof-test/build.gradle b/shark-hprof-test/build.gradle
new file mode 100644
index 000000000..7401ca5ee
--- /dev/null
+++ b/shark-hprof-test/build.gradle
@@ -0,0 +1,11 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+    implementation deps.kotlin.stdlib
+    implementation deps.junit
+    implementation project(':shark-hprof')
+}
diff --git a/shark/src/test/java/shark/HprofWriterHelper.kt b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
similarity index 99%
rename from shark/src/test/java/shark/HprofWriterHelper.kt
rename to shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
index dcc9d70d2..a752a881a 100644
--- a/shark/src/test/java/shark/HprofWriterHelper.kt
+++ b/shark-hprof-test/src/main/kotlin/shark/HprofWriterHelper.kt
@@ -33,6 +33,7 @@ import java.util.UUID
 import kotlin.random.Random
 import kotlin.reflect.KClass
 
+@Suppress("TooManyFunctions")
 class HprofWriterHelper constructor(
   private val writer: HprofWriter
 ) : Closeable {
diff --git a/shark/build.gradle b/shark/build.gradle
index 79baede58..7d9a0dbdc 100644
--- a/shark/build.gradle
+++ b/shark/build.gradle
@@ -13,6 +13,7 @@ dependencies {
   testImplementation deps.assertj_core
   testImplementation deps.junit
   testImplementation deps.okio
+  testImplementation project(':shark-hprof-test')
 }
 
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
