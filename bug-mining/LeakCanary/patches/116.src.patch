diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index fd9c48630..372697942 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -136,7 +136,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
         if (!(instance instanceOf "android.app.Activity")) {
           val activityContext = instance.unwrapActivityContext()
           if (activityContext != null) {
-            val mDestroyed = instance["android.app.Activity", "mDestroyed"]
+            val mDestroyed = activityContext["android.app.Activity", "mDestroyed"]
             if (mDestroyed != null) {
               if (mDestroyed.value.asBoolean!!) {
                 reportLeaking(
@@ -150,6 +150,8 @@ enum class AndroidObjectInspectors : ObjectInspector {
                 )
               }
             }
+          } else {
+            addLabel("${instance.instanceClassSimpleName} does not wrap an activity context")
           }
         }
       }
@@ -282,6 +284,20 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   },
 
+  MORTAR_SCOPE {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("mortar.MortarScope") { instance ->
+        val dead = instance["mortar.MortarScope", "dead"]!!.value.asBoolean!!
+        val scopeName = instance["mortar.MortarScope", "name"]!!.value.readAsJavaString()
+        if (dead) {
+          reportLeaking("mortar.MortarScope.dead is true for scope $scopeName")
+        } else {
+          reportNotLeaking("mortar.MortarScope.dead is false for scope $scopeName")
+        }
+      }
+    }
+  },
+
   COORDINATOR {
     override fun inspect(
       reporter: ObjectReporter
@@ -310,6 +326,19 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   },
 
+  VIEW_ROOT_IMPL {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.view.ViewRootImpl") { instance ->
+        val mViewField = instance["android.view.ViewRootImpl", "mView"]!!
+        if (mViewField.value.isNullReference) {
+          reportLeaking(mViewField describedWithValue "null")
+        } else {
+          reportNotLeaking(mViewField describedWithValue "not null")
+        }
+      }
+    }
+  },
+
   WINDOW {
     override fun inspect(
       reporter: ObjectReporter
@@ -382,14 +411,29 @@ fun HeapInstance.unwrapActivityContext(): HeapInstance? {
       val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
 
       if (mBase.isNonNullReference) {
+        var parentContext = context
         context = mBase.asObject!!.asInstance!!
         if (context instanceOf "android.app.Activity") {
           return context
-        } else if (context instanceOf "android.content.ContextWrapper" &&
-            // Avoids infinite loops
-            context.objectId !in visitedInstances
-        ) {
-          keepUnwrapping = true
+        } else {
+          if (parentContext instanceOf "com.android.internal.policy.DecorContext") {
+            // mBase isn't an activity, let's unwrap DecorContext.mPhoneWindow.mContext instead
+            val mPhoneWindowField =
+              parentContext["com.android.internal.policy.DecorContext", "mPhoneWindow"]
+            if (mPhoneWindowField != null) {
+              val phoneWindow = mPhoneWindowField.valueAsInstance!!
+              context = phoneWindow["android.view.Window", "mContext"]!!.valueAsInstance!!
+              if (context instanceOf "android.app.Activity") {
+                return context
+              }
+            }
+          }
+          if (context instanceOf "android.content.ContextWrapper" &&
+              // Avoids infinite loops
+              context.objectId !in visitedInstances
+          ) {
+            keepUnwrapping = true
+          }
         }
       }
     }
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index 9ce2eaffb..2258b836a 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -2,6 +2,10 @@ package shark
 
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
+import shark.LeakNodeStatus.LEAKING
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
 import java.io.File
 
 class LegacyHprofTest {
@@ -53,6 +57,39 @@ class LegacyHprofTest {
     assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
+  private enum class WRAPS_ACTIVITY {
+    DESTROYED,
+    NOT_DESTROYED,
+    NOT_ACTIVITY
+  }
+
+  @Test fun androidOCountActivityWrappingContexts() {
+    val contextWrapperStatuses = Hprof.open(fileFromResources("leak_asynctask_o.hprof"))
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.instances.filter { it instanceOf "android.content.ContextWrapper" && !(it instanceOf "android.app.Activity") }
+              .map { instance ->
+                val reporter = ObjectReporter(instance)
+                AndroidObjectInspectors.CONTEXT_WRAPPER.inspect(reporter)
+                if (reporter.leakingStatuses.size == 1 && reporter.leakingStatuses[0].status == LEAKING) {
+                  DESTROYED
+                } else if (reporter.labels.size == 1) {
+                  if ("Activity.mDestroyed false" in reporter.labels[0]) {
+                    NOT_DESTROYED
+                  } else {
+                    NOT_ACTIVITY
+                  }
+                } else throw IllegalStateException(
+                    "Unexpected, should have 1 leaking status ${reporter.leakingStatuses} or one label ${reporter.labels}"
+                )
+              }
+              .toList()
+        }
+    assertThat(contextWrapperStatuses.filter { it == DESTROYED }).hasSize(12)
+    assertThat(contextWrapperStatuses.filter { it == NOT_DESTROYED }).hasSize(6)
+    assertThat(contextWrapperStatuses.filter { it == NOT_ACTIVITY }).hasSize(1)
+  }
+
   @Test fun gcRootInNonPrimaryHeap() {
     val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
 
diff --git a/shark/src/main/java/shark/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
index 1a0e5a203..4b3c9d510 100644
--- a/shark/src/main/java/shark/ObjectReporter.kt
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -10,7 +10,7 @@ import kotlin.reflect.KClass
  * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
  * [ObjectInspector] implementations and accumulates insights.
  */
-class ObjectReporter internal constructor(val heapObject: HeapObject) {
+class ObjectReporter constructor(val heapObject: HeapObject) {
 
   private val mutableLabels = mutableListOf<String>()
 
