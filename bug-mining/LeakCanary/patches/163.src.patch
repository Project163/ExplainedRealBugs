diff --git a/build.gradle b/build.gradle
index 61410c4ca..6863c800d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -27,6 +27,7 @@ buildscript {
       ],
       android_support: 'com.android.support:support-v4:28.0.0',
       clikt: 'com.github.ajalt:clikt:2.3.0',
+      jline: 'jline:jline:2.14.6',
       detekt: 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.2.1',
       junit: 'junit:junit:4.12',
       kotlin: [
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
index 000283caa..7bed8f144 100644
--- a/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
@@ -2,6 +2,8 @@ package leakcanary
 
 /**
  * An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+ *
+ * You can create a [Clock] from a lambda by calling [invoke].
  */
 interface Clock {
   /**
diff --git a/shark-cli/build.gradle b/shark-cli/build.gradle
index a4340f85b..4a5442997 100644
--- a/shark-cli/build.gradle
+++ b/shark-cli/build.gradle
@@ -2,13 +2,14 @@ apply plugin: 'java'
 apply plugin: 'kotlin'
 apply plugin: 'application'
 
-sourceCompatibility = JavaVersion.VERSION_1_7
-targetCompatibility = JavaVersion.VERSION_1_7
+sourceCompatibility = JavaVersion.VERSION_1_8
+targetCompatibility = JavaVersion.VERSION_1_8
 
 dependencies {
   api project(':shark-android')
 
   implementation deps.clikt
+  implementation deps.jline
   implementation deps.kotlin.stdlib
 }
 
diff --git a/shark-cli/src/main/java/shark/AnalyzeCommand.kt b/shark-cli/src/main/java/shark/AnalyzeCommand.kt
new file mode 100644
index 000000000..a00694008
--- /dev/null
+++ b/shark-cli/src/main/java/shark/AnalyzeCommand.kt
@@ -0,0 +1,49 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import shark.SharkCliCommand.Companion.echo
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+import java.io.File
+
+class AnalyzeCommand : CliktCommand(
+    name = "analyze",
+    help = "Analyze a heap dump."
+) {
+
+  override fun run() {
+    val params = context.sharkCliParams
+    analyze(retrieveHeapDumpFile(params), params.obfuscationMappingPath)
+  }
+
+  companion object {
+    fun CliktCommand.analyze(
+      heapDumpFile: File,
+      proguardMappingFile: File?
+    ) {
+      val proguardMapping = proguardMappingFile?.let {
+        ProguardMappingReader(it.inputStream()).readProguardMapping()
+      }
+      val objectInspectors = AndroidObjectInspectors.appDefaults.toMutableList()
+
+      val listener = OnAnalysisProgressListener { step ->
+        SharkLog.d { "Analysis in progress, working on: ${step.name}" }
+      }
+
+      val heapAnalyzer = HeapAnalyzer(listener)
+      SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+
+      val heapAnalysis = heapAnalyzer.analyze(
+          heapDumpFile = heapDumpFile,
+          leakingObjectFinder = FilteringLeakingObjectFinder(
+              AndroidObjectInspectors.appLeakingObjectFilters
+          ),
+          referenceMatchers = AndroidReferenceMatchers.appDefaults,
+          computeRetainedHeapSize = true,
+          objectInspectors = objectInspectors,
+          proguardMapping = proguardMapping
+      )
+      echo(heapAnalysis)
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/AnalyzeHprof.kt b/shark-cli/src/main/java/shark/AnalyzeHprof.kt
deleted file mode 100644
index 419b2eec8..000000000
--- a/shark-cli/src/main/java/shark/AnalyzeHprof.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-package shark
-
-import com.github.ajalt.clikt.core.CliktCommand
-import com.github.ajalt.clikt.parameters.arguments.argument
-import com.github.ajalt.clikt.parameters.options.option
-import com.github.ajalt.clikt.parameters.types.file
-import shark.SharkCli.Companion.SHARK_CLI_COMMAND
-import shark.SharkCli.Companion.USAGE_HELP_TAG
-import java.io.File
-
-class AnalyzeHprof : CliktCommand(
-    name = COMMAND,
-    help = "Analyzes the provided $HPROF_ARG_NAME.",
-    helpTags = mapOf(
-        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$MAPPING_USAGE] $HPROF_ARG_NAME"
-    ),
-    printHelpOnEmptyArgs = true
-) {
-
-  private val heapDumpFile by argument(name = HPROF_ARG_NAME, help = HPROF_HELP).file()
-
-  private val obfuscationMappingPath by option(
-      names = *MAPPING_OPTION_NAMES, help = MAPPING_OPTION_HELP
-  ).file()
-
-  override fun run() {
-    analyze(heapDumpFile, obfuscationMappingPath)
-  }
-
-  companion object {
-    private const val COMMAND = "analyze-hprof"
-
-    const val HPROF_ARG_NAME = "HPROF_FILE_PATH"
-    const val HPROF_HELP = "Path to a .hprof file"
-
-    val MAPPING_OPTION_NAMES = arrayOf("-m", "--obfuscation-mapping")
-    const val MAPPING_OPTION_HELP = "path to obfuscation mapping file"
-    const val MAPPING_USAGE = "--obfuscation-mapping PATH"
-
-    fun analyze(
-      heapDumpFile: File,
-      proguardMappingFile: File?
-    ) {
-      val listener = OnAnalysisProgressListener { step ->
-        SharkLog.d { step.name }
-      }
-
-      val proguardMapping = proguardMappingFile?.let {
-        ProguardMappingReader(it.inputStream()).readProguardMapping()
-      }
-
-      val heapAnalyzer = HeapAnalyzer(listener)
-      SharkLog.d { "Analyzing heap dump $heapDumpFile" }
-      val heapAnalysis = heapAnalyzer.analyze(
-          heapDumpFile = heapDumpFile,
-          leakingObjectFinder = FilteringLeakingObjectFinder(
-              AndroidObjectInspectors.appLeakingObjectFilters
-          ),
-          referenceMatchers = AndroidReferenceMatchers.appDefaults,
-          computeRetainedHeapSize = true,
-          objectInspectors = AndroidObjectInspectors.appDefaults,
-          proguardMapping = proguardMapping
-      )
-
-      SharkLog.d { heapAnalysis.toString() }
-    }
-  }
-}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/AnalyzeProcess.kt b/shark-cli/src/main/java/shark/AnalyzeProcess.kt
deleted file mode 100644
index c609d5ffd..000000000
--- a/shark-cli/src/main/java/shark/AnalyzeProcess.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-package shark
-
-import com.github.ajalt.clikt.core.CliktCommand
-import com.github.ajalt.clikt.parameters.arguments.argument
-import com.github.ajalt.clikt.parameters.options.option
-import com.github.ajalt.clikt.parameters.types.file
-import shark.AnalyzeHprof.Companion
-import shark.AnalyzeHprof.Companion.MAPPING_OPTION_HELP
-import shark.AnalyzeHprof.Companion.MAPPING_OPTION_NAMES
-import shark.AnalyzeHprof.Companion.MAPPING_USAGE
-import shark.DumpProcess.Companion.DEVICE_METAVAR
-import shark.DumpProcess.Companion.DEVICE_OPTION_HELP
-import shark.DumpProcess.Companion.DEVICE_OPTION_NAMES
-import shark.DumpProcess.Companion.DEVICE_USAGE
-import shark.DumpProcess.Companion.PROCESS_NAME_ARG_NAME
-import shark.DumpProcess.Companion.PROCESS_NAME_HELP
-import shark.SharkCli.Companion.SHARK_CLI_COMMAND
-import shark.SharkCli.Companion.USAGE_HELP_TAG
-
-class AnalyzeProcess : CliktCommand(
-    name = COMMAND,
-    help = "Dumps the heap for the provided partial $PROCESS_NAME_ARG_NAME, pulls the hprof file and analyzes it.",
-    helpTags = mapOf(
-        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$DEVICE_USAGE $MAPPING_USAGE] $PROCESS_NAME_ARG_NAME"
-    ),
-    printHelpOnEmptyArgs = true
-) {
-
-  private val processName by argument(name = PROCESS_NAME_ARG_NAME, help = PROCESS_NAME_HELP)
-
-  private val device by option(
-      *DEVICE_OPTION_NAMES, metavar = DEVICE_METAVAR, help = DEVICE_OPTION_HELP
-  )
-
-  private val obfuscationMappingPath by option(
-      names = *MAPPING_OPTION_NAMES, help = MAPPING_OPTION_HELP
-  ).file()
-
-  override fun run() {
-    val heapDumpFile = DumpProcess.dumpHeap(processName, device)
-    AnalyzeHprof.analyze(heapDumpFile, obfuscationMappingPath)
-  }
-
-  companion object {
-    private const val COMMAND = "analyze-process"
-  }
-
-}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/DumpProcess.kt b/shark-cli/src/main/java/shark/DumpProcessCommand.kt
similarity index 70%
rename from shark-cli/src/main/java/shark/DumpProcess.kt
rename to shark-cli/src/main/java/shark/DumpProcessCommand.kt
index 7c65d4efa..3e2eaa294 100644
--- a/shark-cli/src/main/java/shark/DumpProcess.kt
+++ b/shark-cli/src/main/java/shark/DumpProcessCommand.kt
@@ -2,52 +2,37 @@ package shark
 
 import com.github.ajalt.clikt.core.CliktCommand
 import com.github.ajalt.clikt.core.PrintMessage
-import com.github.ajalt.clikt.parameters.arguments.argument
-import com.github.ajalt.clikt.parameters.options.option
-import shark.SharkCli.Companion.SHARK_CLI_COMMAND
-import shark.SharkCli.Companion.USAGE_HELP_TAG
-import shark.SharkCli.Companion.runCommand
+import com.github.ajalt.clikt.core.UsageError
+import shark.SharkCliCommand.Companion.echo
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.runCommand
+import shark.SharkCliCommand.Companion.sharkCliParams
+import shark.SharkCliCommand.HeapDumpSource.ProcessSource
 import java.io.File
 import java.text.SimpleDateFormat
 import java.util.Date
 import java.util.Locale
 
-class DumpProcess : CliktCommand(
-    name = COMMAND,
-    help = "Dumps the heap for the provided partial $PROCESS_NAME_ARG_NAME and pulls the hprof file.",
-    helpTags = mapOf(
-        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$DEVICE_USAGE] $PROCESS_NAME_ARG_NAME"
-    ),
-    printHelpOnEmptyArgs = true
+class DumpProcessCommand : CliktCommand(
+    name = "dump-process",
+    help = "Dump the heap and pull the hprof file."
 ) {
 
-  private val processName by argument(name = PROCESS_NAME_ARG_NAME, help = PROCESS_NAME_HELP)
-
-  private val device by option(
-      *DEVICE_OPTION_NAMES, metavar = DEVICE_METAVAR, help = DEVICE_OPTION_HELP
-  )
-
   override fun run() {
-    dumpHeap(processName, device)
+    val params = context.sharkCliParams
+    if (params.source !is ProcessSource) {
+      throw UsageError("dump-process must be used with --process")
+    }
+    val file = retrieveHeapDumpFile(params)
+    echo("Pulled heap dump to $file")
   }
 
   companion object {
 
-    private const val COMMAND = "dump-process"
-
-    const val PROCESS_NAME_HELP =
-      "Full or partial name of a process, e.g. \"example\" would match \"com.example.app\""
-    const val PROCESS_NAME_ARG_NAME = "PROCESS_NAME"
-
-    val DEVICE_OPTION_NAMES = arrayOf("-d", "--device")
-    const val DEVICE_OPTION_HELP = "device/emulator id"
-    const val DEVICE_METAVAR = "ID"
-    const val DEVICE_USAGE = "--device ID"
-
     private val SPACE_PATTERN = Regex("\\s+")
 
     @Suppress("ThrowsCount")
-    fun dumpHeap(
+    fun CliktCommand.dumpHeap(
       processNameParam: String,
       maybeDeviceId: String?
     ): File {
@@ -112,9 +97,9 @@ class DumpProcess : CliktCommand(
 
       val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
 
-      SharkLog.d {
-        "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
-      }
+      echo(
+        "Dumping heap on $deviceId for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+      )
 
       runCommand(
           workingDirectory, "adb", "-s", deviceId, "shell", "am", "dumpheap", processId,
diff --git a/shark-cli/src/main/java/shark/InteractiveCommand.kt b/shark-cli/src/main/java/shark/InteractiveCommand.kt
new file mode 100644
index 000000000..0e050ab39
--- /dev/null
+++ b/shark-cli/src/main/java/shark/InteractiveCommand.kt
@@ -0,0 +1,612 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.PrintMessage
+import jline.console.ConsoleReader
+import jline.console.UserInterruptException
+import jline.console.completer.CandidateListCompletionHandler
+import jline.console.completer.StringsCompleter
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.InteractiveCommand.COMMAND.ANALYZE
+import shark.InteractiveCommand.COMMAND.ARRAY
+import shark.InteractiveCommand.COMMAND.CLASS
+import shark.InteractiveCommand.COMMAND.Companion.matchesCommand
+import shark.InteractiveCommand.COMMAND.DETAILED_PATH_TO_INSTANCE
+import shark.InteractiveCommand.COMMAND.EXIT
+import shark.InteractiveCommand.COMMAND.HELP
+import shark.InteractiveCommand.COMMAND.INSTANCE
+import shark.InteractiveCommand.COMMAND.PATH_TO_INSTANCE
+import shark.SharkCliCommand.Companion.echoNewline
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.File
+import java.util.Locale
+
+@Suppress("TooManyFunctions")
+class InteractiveCommand : CliktCommand(
+    name = "interactive",
+    help = "Explore a heap dump."
+) {
+
+  enum class COMMAND(
+    val commandName: String,
+    val suffix: String = "",
+    val help: String
+  ) {
+    ANALYZE(
+        commandName = "analyze",
+        help = "Analyze the heap dump."
+    ),
+    CLASS(
+        commandName = "class",
+        suffix = "NAME@ID",
+        help = "Show class with a matching NAME and Object ID."
+    ),
+    INSTANCE(
+        commandName = "instance",
+        suffix = "CLASS_NAME@ID",
+        help = "Show instance with a matching CLASS_NAME and Object ID."
+    ),
+    ARRAY(
+        commandName = "array",
+        suffix = "CLASS_NAME@ID",
+        help = "Show array instance with a matching CLASS_NAME and Object ID."
+    ),
+    PATH_TO_INSTANCE(
+        commandName = "->instance",
+        suffix = "CLASS_NAME@ID",
+        help = "Show path from GC Roots to instance."
+    ),
+    DETAILED_PATH_TO_INSTANCE(
+        commandName = "~>instance",
+        suffix = "CLASS_NAME@ID",
+        help = "Show path from GC Roots to instance, highlighting suspect references."
+    ),
+    HELP(
+        commandName = "help",
+        help = "Show this message."
+    ),
+    EXIT(
+        commandName = "exit",
+        help = "Exit this interactive prompt."
+    ),
+    ;
+
+    val pattern: String
+      get() = if (suffix.isEmpty()) commandName else "$commandName "
+
+    val patternHelp: String
+      get() = pattern + suffix
+
+    override fun toString() = commandName
+
+    companion object {
+      infix fun String.matchesCommand(command: COMMAND): Boolean {
+        return if (command.suffix.isEmpty()) {
+          this == command.commandName
+        } else {
+          startsWith(command.pattern)
+        }
+      }
+    }
+  }
+
+  override fun run() {
+    openHprof { graph, heapDumpFile ->
+      val console = setupConsole(graph)
+      var exit = false
+      while (!exit) {
+        val input = console.readCommand()
+        exit = handleCommand(input, heapDumpFile, graph)
+        echoNewline()
+      }
+    }
+  }
+
+  private fun openHprof(block: (HeapGraph, File) -> Unit) {
+    val params = context.sharkCliParams
+    val heapDumpFile = retrieveHeapDumpFile(params)
+    val obfuscationMappingPath = params.obfuscationMappingPath
+
+    val proguardMapping = obfuscationMappingPath?.let {
+      ProguardMappingReader(it.inputStream()).readProguardMapping()
+    }
+
+    Hprof.open(heapDumpFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)
+          block(graph, heapDumpFile)
+        }
+  }
+
+  private fun setupConsole(graph: HeapGraph): ConsoleReader {
+    val console = ConsoleReader()
+    console.handleUserInterrupt = true
+
+    console.addCompleter(StringsCompleter(COMMAND.values().map { it.pattern }))
+    console.addCompleter { buffer, _, candidates ->
+      if (buffer != null) {
+        when {
+          buffer matchesCommand CLASS -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.classes) {
+              it.name
+            }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+          buffer matchesCommand INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+          buffer matchesCommand PATH_TO_INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { "->${renderHeapObject(it)}" })
+          }
+          buffer matchesCommand DETAILED_PATH_TO_INSTANCE -> {
+            val matchingObjects = findMatchingObjects(buffer, graph.instances) {
+              it.instanceClassSimpleName
+            }
+            candidates.addAll(matchingObjects.map { "~>${renderHeapObject(it)}" })
+          }
+          buffer matchesCommand ARRAY -> {
+            val matchingObjects =
+              findMatchingObjects(buffer, graph.primitiveArrays + graph.objectArrays) {
+                if (it is HeapPrimitiveArray) {
+                  it.arrayClassName
+                } else {
+                  (it as HeapObjectArray).arrayClassSimpleName
+                }
+              }
+            candidates.addAll(matchingObjects.map { renderHeapObject(it) })
+          }
+        }
+      }
+      if (candidates.isEmpty()) -1 else 0
+    }
+    val completionHandler = CandidateListCompletionHandler()
+    completionHandler.printSpaceAfterFullCompletion = false
+    console.completionHandler = completionHandler
+    console.prompt = "Enter command [help]:\n"
+    return console
+  }
+
+  private fun ConsoleReader.readCommand(): String? {
+    val input = try {
+      readLine()
+    } catch (ignored: UserInterruptException) {
+      throw PrintMessage("Program interrupted by user")
+    }
+    echoNewline()
+    return input
+  }
+
+  private fun handleCommand(
+    input: String?,
+    heapDumpFile: File,
+    graph: HeapGraph
+  ): Boolean {
+    when {
+      input == null -> throw PrintMessage("End Of File was encountered")
+      input.isBlank() || input matchesCommand HELP -> echoHelp()
+      input matchesCommand EXIT -> return true
+      input matchesCommand ANALYZE -> analyze(heapDumpFile, graph)
+      input matchesCommand PATH_TO_INSTANCE -> {
+        analyzeMatchingObjects(heapDumpFile, input, graph.instances, false) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand DETAILED_PATH_TO_INSTANCE -> {
+        analyzeMatchingObjects(heapDumpFile, input, graph.instances, true) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand CLASS -> {
+        renderMatchingObjects(input, graph.classes) {
+          it.name
+        }
+      }
+      input matchesCommand INSTANCE -> {
+        renderMatchingObjects(input, graph.instances) {
+          it.instanceClassSimpleName
+        }
+      }
+      input matchesCommand ARRAY -> {
+        renderMatchingObjects(input, graph.primitiveArrays + graph.objectArrays) {
+          if (it is HeapPrimitiveArray) {
+            it.arrayClassName
+          } else {
+            (it as HeapObjectArray).arrayClassSimpleName
+          }
+        }
+      }
+      else -> {
+        echo("Unknown command [$input].\n")
+        echoHelp()
+      }
+    }
+    return false
+  }
+
+  private fun echoHelp() {
+    echo("Available commands:")
+    val longestPatternHelp = COMMAND.values()
+        .map { it.patternHelp }.maxBy { it.length }!!.length
+    COMMAND.values()
+        .forEach { command ->
+          val patternHelp = command.patternHelp
+          val extraSpaceCount = (longestPatternHelp - patternHelp.length)
+          val extraSpaces = " ".repeat(extraSpaceCount)
+          println("  $patternHelp$extraSpaces  ${command.help}")
+        }
+  }
+
+  private fun <T : HeapObject> renderMatchingObjects(
+    pattern: String,
+    objects: Sequence<T>,
+    namer: (T) -> String
+  ) {
+    val matchingObjects = findMatchingObjects(pattern, objects, namer)
+    when {
+      matchingObjects.size == 1 -> {
+        matchingObjects.first()
+            .show()
+      }
+      matchingObjects.isNotEmpty() -> {
+        matchingObjects.forEach { heapObject ->
+          echo(renderHeapObject(heapObject))
+        }
+      }
+      else -> {
+        echo("No object found matching [$pattern]")
+      }
+    }
+  }
+
+  private fun <T : HeapObject> analyzeMatchingObjects(
+    heapDumpFile: File,
+    pattern: String,
+    objects: Sequence<T>,
+    showDetails: Boolean,
+    namer: (T) -> String
+  ) {
+    val matchingObjects = findMatchingObjects(pattern, objects, namer)
+    when {
+      matchingObjects.size == 1 -> {
+        val heapObject = matchingObjects.first()
+        analyze(heapDumpFile, heapObject.graph, showDetails, heapObject.objectId)
+      }
+      matchingObjects.isNotEmpty() -> {
+        matchingObjects.forEach { heapObject ->
+          echo(if (showDetails) "~>" else "->" + renderHeapObject(heapObject))
+        }
+      }
+      else -> {
+        echo("No object found matching [$pattern]")
+      }
+    }
+  }
+
+  private fun <T : HeapObject> findMatchingObjects(
+    pattern: String,
+    objects: Sequence<T>,
+    namer: (T) -> String
+  ): List<T> {
+    val firstSpaceIndex = pattern.indexOf(' ')
+    val contentStartIndex = firstSpaceIndex + 1
+    val nextSpaceIndex = pattern.indexOf(' ', contentStartIndex)
+    val endIndex = if (nextSpaceIndex != -1) nextSpaceIndex else pattern.length
+    val content = pattern.substring(contentStartIndex, endIndex)
+    val identifierIndex = content.indexOf('@')
+    val (classNamePart, objectIdStart) = if (identifierIndex == -1) {
+      content to null
+    } else {
+      content.substring(0, identifierIndex) to
+          content.substring(identifierIndex + 1)
+    }
+
+    val objectId = objectIdStart?.toLongOrNull()
+    val checkObjectId = objectId != null
+    val matchingObjects = objects
+        .filter {
+          classNamePart in namer(it) &&
+              (!checkObjectId ||
+                  it.objectId.toString().startsWith(objectIdStart!!))
+        }
+        .toList()
+
+    if (objectIdStart != null) {
+      val exactMatchingByObjectId = matchingObjects.firstOrNull { objectId == it.objectId }
+      if (exactMatchingByObjectId != null) {
+        return listOf(exactMatchingByObjectId)
+      }
+    }
+
+    val exactMatchingByName = matchingObjects.filter { classNamePart == namer(it) }
+
+    return if (exactMatchingByName.isNotEmpty()) {
+      exactMatchingByName
+    } else {
+      matchingObjects
+    }
+  }
+
+  private fun HeapObject.show() {
+    when (this) {
+      is HeapInstance -> showInstance()
+      is HeapClass -> showClass()
+      is HeapObjectArray -> showObjectArray()
+      is HeapPrimitiveArray -> showPrimitiveArray()
+    }
+  }
+
+  private fun HeapInstance.showInstance() {
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(instanceClass)}")
+
+    val fieldsPerClass = readFields()
+        .toList()
+        .groupBy { it.declaringClass }
+        .toList()
+        .filter { it.first.name != "java.lang.Object" }
+        .reversed()
+
+    fieldsPerClass.forEach { (heapClass, fields) ->
+      echo("  Fields from ${renderHeapObject(heapClass)}")
+      fields.forEach { field ->
+        echo("    ${field.name} = ${renderHeapValue(field.value)}")
+      }
+    }
+  }
+
+  private fun HeapClass.showClass() {
+    echo(this@InteractiveCommand.renderHeapObject(this))
+    val superclass = superclass
+    if (superclass != null) {
+      echo("  Extends ${renderHeapObject(superclass)}")
+    }
+
+    val staticFields = readStaticFields()
+        .filter { field ->
+          !field.name.startsWith(
+              "\$class\$"
+          ) && field.name != "\$classOverhead"
+        }
+        .toList()
+    if (staticFields.isNotEmpty()) {
+      echo("  Static fields")
+      staticFields
+          .forEach { field ->
+            echo("    static ${field.name} = ${renderHeapValue(field.value)}")
+          }
+    }
+
+    val instances = when {
+      isPrimitiveArrayClass -> primitiveArrayInstances
+      isObjectArrayClass -> objectArrayInstances
+      else -> instances
+    }.toList()
+    if (instances.isNotEmpty()) {
+      echo("  ${instances.size} instance" + if (instances.size != 1) "s" else "")
+      instances.forEach { arrayOrInstance ->
+        echo("    ${renderHeapObject(arrayOrInstance)}")
+      }
+    }
+  }
+
+  private fun HeapObjectArray.showObjectArray() {
+    val elements = readElements()
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(arrayClass)}")
+    var repeatedValue: HeapValue? = null
+    var repeatStartIndex = 0
+    var lastIndex = 0
+    elements.forEachIndexed { index, element ->
+      lastIndex = index
+      if (repeatedValue == null) {
+        repeatedValue = element
+        repeatStartIndex = index
+      } else if (repeatedValue != element) {
+        val repeatEndIndex = index - 1
+        if (repeatStartIndex == repeatEndIndex) {
+          echo("  $repeatStartIndex = ${renderHeapValue(repeatedValue!!)}")
+        } else {
+          echo("  $repeatStartIndex..$repeatEndIndex = ${renderHeapValue(repeatedValue!!)}")
+        }
+        repeatedValue = element
+        repeatStartIndex = index
+      }
+    }
+    if (repeatedValue != null) {
+      if (repeatStartIndex == lastIndex) {
+        echo("  $repeatStartIndex = ${renderHeapValue(repeatedValue!!)}")
+      } else {
+        echo("  $repeatStartIndex..$lastIndex = ${renderHeapValue(repeatedValue!!)}")
+      }
+    }
+  }
+
+  private fun HeapPrimitiveArray.showPrimitiveArray() {
+    val record = readRecord()
+    echo(renderHeapObject(this))
+    echo("  Instance of ${renderHeapObject(arrayClass)}")
+
+    var repeatedValue: Any? = null
+    var repeatStartIndex = 0
+    var lastIndex = 0
+    val action: (Int, Any) -> Unit = { index, value ->
+      lastIndex = index
+      if (repeatedValue == null) {
+        repeatedValue = value
+        repeatStartIndex = index
+      } else if (repeatedValue != value) {
+        val repeatEndIndex = index - 1
+        if (repeatStartIndex == repeatEndIndex) {
+          echo("  $repeatStartIndex = $repeatedValue")
+        } else {
+          echo("  $repeatStartIndex..$repeatEndIndex = $repeatedValue")
+        }
+        repeatedValue = value
+        repeatStartIndex = index
+      }
+    }
+
+    when (record) {
+      is BooleanArrayDump -> record.array.forEachIndexed(action)
+      is CharArrayDump -> record.array.forEachIndexed(action)
+      is FloatArrayDump -> record.array.forEachIndexed(action)
+      is DoubleArrayDump -> record.array.forEachIndexed(action)
+      is ByteArrayDump -> record.array.forEachIndexed(action)
+      is ShortArrayDump -> record.array.forEachIndexed(action)
+      is IntArrayDump -> record.array.forEachIndexed(action)
+      is LongArrayDump -> record.array.forEachIndexed(action)
+    }
+    if (repeatedValue != null) {
+      if (repeatStartIndex == lastIndex) {
+        echo("  $repeatStartIndex = $repeatedValue")
+      } else {
+        echo("  $repeatStartIndex..$lastIndex = $repeatedValue")
+      }
+    }
+  }
+
+  private fun renderHeapValue(heapValue: HeapValue): String {
+    return when (val holder = heapValue.holder) {
+      is ReferenceHolder -> {
+        when {
+          holder.isNull -> "null"
+          !heapValue.graph.objectExists(holder.value) -> "@${holder.value} object not found"
+          else -> {
+            val heapObject = heapValue.asObject!!
+            renderHeapObject(heapObject)
+          }
+        }
+      }
+      is BooleanHolder -> holder.value.toString()
+      is CharHolder -> holder.value.toString()
+      is FloatHolder -> holder.value.toString()
+      is DoubleHolder -> holder.value.toString()
+      is ByteHolder -> holder.value.toString()
+      is ShortHolder -> holder.value.toString()
+      is IntHolder -> holder.value.toString()
+      is LongHolder -> holder.value.toString()
+    }
+  }
+
+  private fun renderHeapObject(heapObject: HeapObject): String {
+    return when (heapObject) {
+      is HeapClass -> {
+        val instanceCount = when {
+          heapObject.isPrimitiveArrayClass -> heapObject.primitiveArrayInstances
+          heapObject.isObjectArrayClass -> heapObject.objectArrayInstances
+          else -> heapObject.instances
+        }.count()
+        val plural = if (instanceCount != 1) "s" else ""
+        "$CLASS ${heapObject.name}@${heapObject.objectId} (${instanceCount} instance$plural)"
+      }
+      is HeapInstance -> {
+        val asJavaString = heapObject.readAsJavaString()
+
+        val value =
+          if (asJavaString != null) {
+            " \"${asJavaString}\""
+          } else ""
+
+        "$INSTANCE ${heapObject.instanceClassSimpleName}@${heapObject.objectId}$value"
+      }
+      is HeapObjectArray -> {
+        val className = heapObject.arrayClassSimpleName.removeSuffix("[]")
+        "$ARRAY $className[${heapObject.readElements().count()}]@${heapObject.objectId}"
+      }
+      is HeapPrimitiveArray -> {
+        val record = heapObject.readRecord()
+        val primitiveName = heapObject.primitiveType.name.toLowerCase(Locale.US)
+        "$ARRAY $primitiveName[${record.size}]@${heapObject.objectId}"
+      }
+    }
+  }
+
+  private fun analyze(
+    heapDumpFile: File,
+    graph: HeapGraph,
+    showDetails: Boolean = true,
+    leakingObjectId: Long? = null
+  ) {
+    if (leakingObjectId != null) {
+      if (!graph.objectExists(leakingObjectId)) {
+        echo("@$leakingObjectId not found")
+        return
+      } else {
+        val heapObject = graph.findObjectById(leakingObjectId)
+        if (heapObject !is HeapInstance) {
+          echo("${renderHeapObject(heapObject)} is not an instance")
+          return
+        }
+      }
+    }
+
+    val objectInspectors =
+      if (showDetails) AndroidObjectInspectors.appDefaults.toMutableList() else mutableListOf()
+
+    objectInspectors += ObjectInspector {
+      it.labels += renderHeapObject(it.heapObject)
+    }
+
+    val leakingObjectFinder = if (leakingObjectId == null) {
+      FilteringLeakingObjectFinder(
+          AndroidObjectInspectors.appLeakingObjectFilters
+      )
+    } else {
+      LeakingObjectFinder {
+        setOf(leakingObjectId)
+      }
+    }
+
+    val listener = OnAnalysisProgressListener { step ->
+      SharkLog.d { "Analysis in progress, working on: ${step.name}" }
+    }
+
+    val heapAnalyzer = HeapAnalyzer(listener)
+    SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+
+    val heapAnalysis = heapAnalyzer.analyze(
+        heapDumpFile = heapDumpFile,
+        graph = graph,
+        leakingObjectFinder = leakingObjectFinder,
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        computeRetainedHeapSize = true,
+        objectInspectors = objectInspectors
+    )
+
+    if (leakingObjectId == null || heapAnalysis is HeapAnalysisFailure) {
+      echo(heapAnalysis)
+    } else {
+      val leakTrace = (heapAnalysis as HeapAnalysisSuccess).allLeaks.first()
+          .leakTraces.first()
+      echo(if (showDetails) leakTrace else leakTrace.toSimplePathString())
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
index 4330f4610..7f0ea5c5d 100644
--- a/shark-cli/src/main/java/shark/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -3,9 +3,9 @@ package shark
 import com.github.ajalt.clikt.core.subcommands
 
 fun main(args: Array<String>) =
-  SharkCli().subcommands(
-      AnalyzeProcess(),
-      DumpProcess(),
-      AnalyzeHprof(),
-      StripHprof()
+  SharkCliCommand().subcommands(
+      InteractiveCommand(),
+      AnalyzeCommand(),
+      DumpProcessCommand(),
+      StripHprofCommand()
   ).main(args)
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/SharkCli.kt b/shark-cli/src/main/java/shark/SharkCli.kt
deleted file mode 100644
index e8f203ace..000000000
--- a/shark-cli/src/main/java/shark/SharkCli.kt
+++ /dev/null
@@ -1,88 +0,0 @@
-package shark
-
-import com.github.ajalt.clikt.core.CliktCommand
-import shark.SharkLog.Logger
-import java.io.File
-import java.io.PrintWriter
-import java.io.StringWriter
-import java.util.concurrent.TimeUnit.SECONDS
-
-class SharkCli : CliktCommand(
-    name = SHARK_CLI_COMMAND,
-    // This ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
-    help = """
-    |```
-    |$S                ^`.                 .=""=.
-    |$S^_              \  \               / _  _ \
-    |$S\ \             {   \             |  d  b  |
-    |$S{  \           /     `~~~--__     \   /\   /
-    |$S{   \___----~~'              `~~-_/'-=\/=-'\,
-    |$S \                         /// a  `~.      \ \
-    |$S / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
-    |$S \/      \/    `~~~;   ,---~~-_`/ \        / \/
-    |$S                  /   /            '.    .'
-    |$S                 '._.'             _|`~~`|_
-    |$S                                   /|\  /|\
-    |```
-    """.trimMargin()
-
-) {
-
-  override fun run() {
-    class CLILogger : Logger {
-
-      override fun d(message: String) {
-        echo(message)
-      }
-
-      override fun d(
-        throwable: Throwable,
-        message: String
-      ) {
-        d("$message\n${getStackTraceString(throwable)}")
-      }
-
-      private fun getStackTraceString(throwable: Throwable): String {
-        val stringWriter = StringWriter()
-        val printWriter = PrintWriter(stringWriter, false)
-        throwable.printStackTrace(printWriter)
-        printWriter.flush()
-        return stringWriter.toString()
-      }
-    }
-
-    SharkLog.logger = CLILogger()
-
-  }
-
-  companion object {
-
-    const val SHARK_CLI_COMMAND = "shark-cli"
-
-    const val USAGE_HELP_TAG = "Usage"
-
-    /** Zero width space */
-    private const val S = '\u200b'
-
-    fun runCommand(
-      directory: File,
-      vararg arguments: String
-    ): String {
-      val process = ProcessBuilder(*arguments)
-          .directory(directory)
-          .start()
-          .also { it.waitFor(10, SECONDS) }
-
-      if (process.exitValue() != 0) {
-        throw Exception(
-            "Failed command: '${arguments.joinToString(
-                " "
-            )}', error output: '${process.errorStream.bufferedReader().readText()}'"
-        )
-      }
-      return process.inputStream.bufferedReader()
-          .readText()
-    }
-
-  }
-}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/SharkCliCommand.kt b/shark-cli/src/main/java/shark/SharkCliCommand.kt
new file mode 100644
index 000000000..5d1f2ef3e
--- /dev/null
+++ b/shark-cli/src/main/java/shark/SharkCliCommand.kt
@@ -0,0 +1,193 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.CliktError
+import com.github.ajalt.clikt.core.Context
+import com.github.ajalt.clikt.core.UsageError
+import com.github.ajalt.clikt.output.TermUi
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.groups.cooccurring
+import com.github.ajalt.clikt.parameters.options.flag
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.required
+import com.github.ajalt.clikt.parameters.types.file
+import shark.DumpProcessCommand.Companion.dumpHeap
+import shark.SharkCliCommand.HeapDumpSource.HprofFileSource
+import shark.SharkCliCommand.HeapDumpSource.ProcessSource
+import shark.SharkLog.Logger
+import java.io.File
+import java.io.PrintWriter
+import java.io.StringWriter
+import java.util.concurrent.TimeUnit.SECONDS
+
+class SharkCliCommand : CliktCommand(
+    name = "shark-cli",
+    // This ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
+    help = """
+    |```
+    |$S                ^`.                 .=""=.
+    |$S^_              \  \               / _  _ \
+    |$S\ \             {   \             |  d  b  |
+    |$S{  \           /     `~~~--__     \   /\   /
+    |$S{   \___----~~'              `~~-_/'-=\/=-'\,
+    |$S \                         /// a  `~.      \ \
+    |$S / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+    |$S \/      \/    `~~~;   ,---~~-_`/ \        / \/
+    |$S                  /   /            '.    .'
+    |$S                 '._.'             _|`~~`|_
+    |$S                                   /|\  /|\
+    |```
+    """.trimMargin()
+) {
+
+  private class ProcessOptions : OptionGroup() {
+    val processName by option(
+        "--process", "-p",
+        help = "Full or partial name of a process, e.g. \"example\" would match \"com.example.app\""
+    ).required()
+
+    val device by option(
+        "-d", "--device", metavar = "ID", help = "device/emulator id"
+    )
+  }
+
+  private val processOptions by ProcessOptions().cooccurring()
+
+  private val obfuscationMappingPath by option(
+      "-m", "--obfuscation-mapping", help = "path to obfuscation mapping file"
+  ).file()
+
+  private val verbose by option(
+      help = "provide additional details as to what shark-cli is doing"
+  ).flag("--no-verbose")
+
+  private val heapDumpFile by option("--hprof", "-h", help = "path to a .hprof file").file(
+      exists = true,
+      folderOkay = false,
+      readable = true
+  )
+
+  class CommandParams(
+    val source: HeapDumpSource,
+    val obfuscationMappingPath: File?
+  )
+
+  sealed class HeapDumpSource {
+    class HprofFileSource(val file: File) : HeapDumpSource()
+    class ProcessSource(
+      val processName: String,
+      val deviceId: String?
+    ) : HeapDumpSource()
+  }
+
+  override fun run() {
+    if (verbose) {
+      setupVerboseLogger()
+    }
+    if (processOptions != null && heapDumpFile != null) {
+      throw UsageError("Option --process cannot be used with --hprof")
+    } else if (processOptions != null) {
+      context.sharkCliParams = CommandParams(
+          source = ProcessSource(processOptions!!.processName, processOptions!!.device),
+          obfuscationMappingPath = obfuscationMappingPath
+      )
+    } else if (heapDumpFile != null) {
+      context.sharkCliParams = CommandParams(
+          source = HprofFileSource(heapDumpFile!!),
+          obfuscationMappingPath = obfuscationMappingPath
+      )
+    } else {
+      throw UsageError("Must provide one of --process, --hprof")
+    }
+  }
+
+  private fun setupVerboseLogger() {
+    class CLILogger : Logger {
+
+      override fun d(message: String) {
+        echo(message)
+      }
+
+      override fun d(
+        throwable: Throwable,
+        message: String
+      ) {
+        d("$message\n${getStackTraceString(throwable)}")
+      }
+
+      private fun getStackTraceString(throwable: Throwable): String {
+        val stringWriter = StringWriter()
+        val printWriter = PrintWriter(stringWriter, false)
+        throwable.printStackTrace(printWriter)
+        printWriter.flush()
+        return stringWriter.toString()
+      }
+    }
+
+    SharkLog.logger = CLILogger()
+  }
+
+  companion object {
+    /** Zero width space */
+    private const val S = '\u200b'
+
+    var Context.sharkCliParams: CommandParams
+      get() {
+        var ctx: Context? = this
+        while (ctx != null) {
+          if (ctx.obj is CommandParams) return ctx.obj as CommandParams
+          ctx = ctx.parent
+        }
+        throw IllegalStateException("CommandParams not found in Context.obj")
+      }
+      set(value) {
+        obj = value
+      }
+
+    fun CliktCommand.retrieveHeapDumpFile(params: CommandParams): File {
+      return when (val source = params.source) {
+        is HprofFileSource -> source.file
+        is ProcessSource -> dumpHeap(source.processName, source.deviceId)
+      }
+    }
+
+    fun CliktCommand.echoNewline() {
+      echo("")
+    }
+
+    /**
+     * Copy of [CliktCommand.echo] to make it publicly visible and therefore accessible
+     * from [CliktCommand] extension functions
+     */
+    fun CliktCommand.echo(
+      message: Any?,
+      trailingNewline: Boolean = true,
+      err: Boolean = false,
+      lineSeparator: String = context.console.lineSeparator
+    ) {
+      TermUi.echo(message, trailingNewline, err, context.console, lineSeparator)
+    }
+
+    fun runCommand(
+      directory: File,
+      vararg arguments: String
+    ): String {
+      val process = ProcessBuilder(*arguments)
+          .directory(directory)
+          .start()
+          .also { it.waitFor(10, SECONDS) }
+
+      if (process.exitValue() != 0) {
+        val command = arguments.joinToString(" ")
+        val errorOutput = process.errorStream.bufferedReader()
+            .readText()
+        throw CliktError(
+            "Failed command: '$command', error output:\n```$errorOutput```"
+        )
+      }
+      return process.inputStream.bufferedReader()
+          .readText()
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/StripHprof.kt b/shark-cli/src/main/java/shark/StripHprof.kt
deleted file mode 100644
index 1fa5822f2..000000000
--- a/shark-cli/src/main/java/shark/StripHprof.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-package shark
-
-import com.github.ajalt.clikt.core.CliktCommand
-import com.github.ajalt.clikt.parameters.arguments.argument
-import com.github.ajalt.clikt.parameters.types.file
-import shark.AnalyzeHprof.Companion.HPROF_ARG_NAME
-import shark.AnalyzeHprof.Companion.HPROF_HELP
-import shark.SharkCli.Companion.SHARK_CLI_COMMAND
-import shark.SharkCli.Companion.USAGE_HELP_TAG
-import java.io.File
-
-class StripHprof : CliktCommand(
-    name = COMMAND,
-    help = "Replaces all primitive arrays from the provided $HPROF_ARG_NAME with arrays of zeroes and generates a new \"-stripped.hprof\" file.",
-    helpTags = mapOf(USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND $HPROF_ARG_NAME"),
-    printHelpOnEmptyArgs = true
-) {
-
-  private val heapDumpFile by argument(name = HPROF_ARG_NAME, help = HPROF_HELP).file()
-
-  override fun run() {
-    stripHprof(heapDumpFile)
-  }
-
-  companion object {
-
-    private const val COMMAND = "strip-hprof"
-
-    private fun stripHprof(heapDumpFile: File) {
-      SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
-      val stripper = HprofPrimitiveArrayStripper()
-      val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
-      SharkLog.d { "Stripped primitive arrays to $outputFile" }
-    }
-  }
-}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/StripHprofCommand.kt b/shark-cli/src/main/java/shark/StripHprofCommand.kt
new file mode 100644
index 000000000..7690fd7a8
--- /dev/null
+++ b/shark-cli/src/main/java/shark/StripHprofCommand.kt
@@ -0,0 +1,19 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import shark.SharkCliCommand.Companion.retrieveHeapDumpFile
+import shark.SharkCliCommand.Companion.sharkCliParams
+
+class StripHprofCommand : CliktCommand(
+    name = "strip-hprof",
+    help = "Replace all primitive arrays from the provided heap dump with arrays of zeroes and generate a new \"-stripped.hprof\" file."
+) {
+
+  override fun run() {
+    val heapDumpFile = retrieveHeapDumpFile(context.sharkCliParams)
+    SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
+    val stripper = HprofPrimitiveArrayStripper()
+    val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
+    echo("Created hprof with stripped primitive arrays to $outputFile")
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
index 93fafa978..ad9c00460 100644
--- a/shark-graph/src/main/java/shark/HeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -2,6 +2,8 @@ package shark
 
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
 
 /**
  * Enables navigation through the heap graph of objects.
@@ -37,6 +39,18 @@ interface HeapGraph {
    * This sequence does not trigger any IO reads.
    */
   val instances: Sequence<HeapInstance>
+  /**
+   * Sequence of all object arrays in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objectArrays: Sequence<HeapObjectArray>
+  /**
+   * Sequence of all primitive arrays in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val primitiveArrays: Sequence<HeapPrimitiveArray>
 
   /**
    * Returns the [HeapObject] corresponding to the provided [objectId], and throws
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
index e38c1931e..fdebc2750 100644
--- a/shark-graph/src/main/java/shark/HeapObject.kt
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -27,6 +27,7 @@ import shark.internal.IndexedObject.IndexedInstance
 import shark.internal.IndexedObject.IndexedObjectArray
 import shark.internal.IndexedObject.IndexedPrimitiveArray
 import java.nio.charset.Charset
+import java.util.Locale
 import kotlin.reflect.KClass
 
 /**
@@ -108,6 +109,18 @@ sealed class HeapObject {
     val instanceByteSize: Int
       get() = indexedObject.instanceSize
 
+    /**
+     * Returns true if this class is an array class, and false otherwise.
+     */
+    val isArrayClass: Boolean
+      get() = name.endsWith("[]")
+
+    val isPrimitiveArrayClass: Boolean
+      get() = name in primitiveArrayClassesByName
+
+    val isObjectArrayClass: Boolean
+      get() = isArrayClass && !isPrimitiveArrayClass
+
     /**
      * The total byte size of fields for instances of this class, computed as the sum of the
      * individual size of each field of this class. This does not include the size of fields from
@@ -170,7 +183,26 @@ sealed class HeapObject {
      * All instances of this class, including instances of subclasses of this class.
      */
     val instances: Sequence<HeapInstance>
-      get() = hprofGraph.instances.filter { it instanceOf this }
+      get() = if (!isArrayClass) {
+        hprofGraph.instances.filter { it instanceOf this }
+      } else {
+        emptySequence()
+      }
+
+    val objectArrayInstances: Sequence<HeapObjectArray>
+      get() = if (isObjectArrayClass) {
+        hprofGraph.objectArrays.filter { it.indexedObject.arrayClassId == objectId }
+      } else {
+        emptySequence()
+      }
+
+    val primitiveArrayInstances: Sequence<HeapPrimitiveArray>
+      get() = if (isPrimitiveArrayClass) {
+        val primitiveType = primitiveArrayClassesByName[name]
+        hprofGraph.primitiveArrays.filter { it.primitiveType == primitiveType }
+      } else {
+        emptySequence()
+      }
 
     /**
      * All direct instances of this class, ie excluding any instance of subclasses of this class.
@@ -431,7 +463,7 @@ sealed class HeapObject {
    */
   class HeapObjectArray internal constructor(
     private val hprofGraph: HprofHeapGraph,
-    private val indexedObject: IndexedObjectArray,
+    internal val indexedObject: IndexedObjectArray,
     override val objectId: Long,
     val isPrimitiveWrapperArray: Boolean
   ) : HeapObject() {
@@ -526,16 +558,13 @@ sealed class HeapObject {
      * The name of the class of this array, identical to [Class.getName].
      */
     val arrayClassName: String
-      get() = when (primitiveType) {
-        BOOLEAN -> "boolean[]"
-        CHAR -> "char[]"
-        FLOAT -> "float[]"
-        DOUBLE -> "double[]"
-        BYTE -> "byte[]"
-        SHORT -> "short[]"
-        INT -> "int[]"
-        LONG -> "long[]"
-      }
+      get() = "${primitiveType.name.toLowerCase(Locale.US)}[]"
+
+    /**
+     * The class of this array.
+     */
+    val arrayClass: HeapClass
+      get() = graph.findClassByName(arrayClassName)!!
 
     /**
      * Reads and returns the underlying [PrimitiveArrayDumpRecord].
@@ -552,6 +581,11 @@ sealed class HeapObject {
   }
 
   companion object {
+
+    private val primitiveArrayClassesByName = PrimitiveType.values()
+        .map { "${it.name.toLowerCase(Locale.US)}[]" to it }
+        .toMap()
+
     private fun classSimpleName(className: String): String {
       val separator = className.lastIndexOf('.')
       return if (separator == -1) {
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index 26fad2819..7634355bb 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -76,6 +76,21 @@ class HprofHeapGraph internal constructor(
           }
     }
 
+  override val objectArrays: Sequence<HeapObjectArray>
+    get() = index.indexedObjectArraySequence().map {
+      val objectId = it.first
+      val indexedObject = it.second
+      val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+      HeapObjectArray(this, indexedObject, objectId, isPrimitiveWrapper)
+    }
+
+  override val primitiveArrays: Sequence<HeapPrimitiveArray>
+    get() = index.indexedPrimitiveArraySequence().map {
+      val objectId = it.first
+      val indexedObject = it.second
+      HeapPrimitiveArray(this, indexedObject, objectId)
+    }
+
   // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
   // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
   // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index cf9f2965b..ce0ebec91 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -86,40 +86,73 @@ class HeapAnalyzer constructor(
       )
     }
 
-    try {
+    return try {
       listener.onAnalysisProgress(PARSING_HEAP_DUMP)
       Hprof.open(heapDumpFile)
           .use { hprof ->
             val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)
-
-            listener.onAnalysisProgress(EXTRACTING_METADATA)
-            val metadata = metadataExtractor.extractMetadata(graph)
-
-            listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
-            val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
-
             val helpers =
               FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
-
-            val (applicationLeaks, libraryLeaks) = helpers.findLeaks(leakingObjectIds)
-
-            return HeapAnalysisSuccess(
-                heapDumpFile = heapDumpFile,
-                createdAtTimeMillis = System.currentTimeMillis(),
-                analysisDurationMillis = since(analysisStartNanoTime),
-                metadata = metadata,
-                applicationLeaks = applicationLeaks,
-                libraryLeaks = libraryLeaks
+            helpers.analyzeGraph(
+                metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
             )
           }
     } catch (exception: Throwable) {
-      return HeapAnalysisFailure(
+      HeapAnalysisFailure(
+          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+  }
+
+  fun analyze(
+    heapDumpFile: File,
+    graph: HeapGraph,
+    leakingObjectFinder: LeakingObjectFinder,
+    referenceMatchers: List<ReferenceMatcher> = emptyList(),
+    computeRetainedHeapSize: Boolean = false,
+    objectInspectors: List<ObjectInspector> = emptyList(),
+    metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+    return try {
+      val helpers =
+        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
+      helpers.analyzeGraph(
+          metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
+      )
+    } catch (exception: Throwable) {
+      HeapAnalysisFailure(
           heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
           HeapAnalysisException(exception)
       )
     }
   }
 
+  private fun FindLeakInput.analyzeGraph(
+    metadataExtractor: MetadataExtractor,
+    leakingObjectFinder: LeakingObjectFinder,
+    heapDumpFile: File,
+    analysisStartNanoTime: Long
+  ): HeapAnalysisSuccess {
+    listener.onAnalysisProgress(EXTRACTING_METADATA)
+    val metadata = metadataExtractor.extractMetadata(graph)
+
+    listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
+    val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
+
+    val (applicationLeaks, libraryLeaks) = findLeaks(leakingObjectIds)
+
+    return HeapAnalysisSuccess(
+        heapDumpFile = heapDumpFile,
+        createdAtTimeMillis = System.currentTimeMillis(),
+        analysisDurationMillis = since(analysisStartNanoTime),
+        metadata = metadata,
+        applicationLeaks = applicationLeaks,
+        libraryLeaks = libraryLeaks
+    )
+  }
+
   private fun FindLeakInput.findLeaks(leakingObjectIds: Set<Long>): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
     val pathFinder = PathFinder(graph, listener, referenceMatchers)
     val pathFindingResults =
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index a45b39a70..fbb4fb6cd 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -71,12 +71,16 @@ data class LeakTrace(
     }
   }
 
-  override fun toString(): String {
+  override fun toString(): String = leakTraceAsString(showLeakingStatus = true)
+
+  fun toSimplePathString(): String = leakTraceAsString(showLeakingStatus = false)
+
+  private fun leakTraceAsString(showLeakingStatus: Boolean): String {
     var result = """
-      
-       GC Root: ${gcRootType.description}
-      
-    """.trimIndent()
+        
+         GC Root: ${gcRootType.description}
+        
+      """.trimIndent()
 
     referencePath.forEachIndexed { index, element ->
       val leakStatus = when (referencePath[index].originObject.leakingStatus) {
@@ -93,17 +97,22 @@ data class LeakTrace(
         if (index == 0 && gcRootType == JAVA_FRAME) "thread" else element.originObject.typeName
 
       result += "\n ${element.originObject.className} $typeName"
-      result += "\n    Leaking: $leakStatus"
+      if (showLeakingStatus) {
+        result += "\n    Leaking: $leakStatus"
+      }
 
       for (label in element.originObject.labels) {
         result += "\n    $label"
       }
-      result += getNextElementString(this, element, index)
+      result += getNextElementString(this, element, index, showLeakingStatus)
     }
 
     result += "\n"
-    result += " ${leakingObject.className} ${leakingObject.typeName}\n$ZERO_WIDTH_SPACE"
-    result += "     Leaking: YES (${leakingObject.leakingStatusReason})"
+    result += " ${leakingObject.className} ${leakingObject.typeName}"
+    if (showLeakingStatus) {
+      result += "\n$ZERO_WIDTH_SPACE"
+      result += "     Leaking: YES (${leakingObject.leakingStatusReason})"
+    }
     for (label in leakingObject.labels) {
       result += "\n$ZERO_WIDTH_SPACE"
       result += "     $label"
@@ -159,13 +168,14 @@ data class LeakTrace(
     private fun getNextElementString(
       leakTrace: LeakTrace,
       reference: LeakTraceReference,
-      index: Int
+      index: Int,
+      showLeakingStatus: Boolean
     ): String {
       val static = if (reference.referenceType == STATIC_FIELD) " static" else ""
       val referenceLine =
         "    $static ${reference.originObject.classSimpleName}.${reference.referenceDisplayName}"
 
-      return if (leakTrace.referencePathElementIsSuspect(index)) {
+      return if (showLeakingStatus && leakTrace.referencePathElementIsSuspect(index)) {
         val lengthBeforeReferenceName = referenceLine.lastIndexOf('.') + 1
         val referenceLength = referenceLine.length - lengthBeforeReferenceName
 
diff --git a/shark/src/main/java/shark/LeakingObjectFinder.kt b/shark/src/main/java/shark/LeakingObjectFinder.kt
index c23ee8a42..4ef36325f 100644
--- a/shark/src/main/java/shark/LeakingObjectFinder.kt
+++ b/shark/src/main/java/shark/LeakingObjectFinder.kt
@@ -1,8 +1,12 @@
 package shark
 
+import shark.ObjectInspector.Companion.invoke
+
 /**
  * Finds the objects that are leaking, for which Shark will compute
  * leak traces.
+ *
+ * You can create a [LeakingObjectFinder] from a lambda by calling [invoke].
  */
 interface LeakingObjectFinder {
 
@@ -11,4 +15,24 @@ interface LeakingObjectFinder {
    */
   fun findLeakingObjectIds(graph: HeapGraph): Set<Long>
 
+  companion object {
+    /**
+     * Utility function to create a [LeakingObjectFinder] from the passed in [block] lambda
+     * instead of using the anonymous `object : LeakingObjectFinder` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = LeakingObjectFinder {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapGraph) -> Set<Long>): LeakingObjectFinder =
+      object : LeakingObjectFinder {
+        override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> = block(graph)
+
+      }
+  }
+
 }
\ No newline at end of file
