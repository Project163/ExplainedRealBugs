diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index cf4d3a4a8..c3ae9ff5f 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -8,7 +8,6 @@ dependencies {
   api project(':leakcanary-watcher')
   api project(':leakcanary-haha')
 
-  implementation deps.androidx.annotation
   implementation deps.kotlin.stdlib
 
   testImplementation deps.assertj_core
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index 89d393063..a854cfeee 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -4,9 +4,8 @@ apply plugin: 'kotlin-android'
 dependencies {
   api project(':leakcanary-analyzer')
   api project(':leakcanary-leaksentry')
+  api project(':leakcanary-fragments-androidx')
 
-  implementation deps.androidx.annotation
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
 
   testImplementation deps.junit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 353d7abab..6da53dd2d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -16,6 +16,7 @@
 package leakcanary.internal
 
 import android.content.Context
+import android.text.Html
 import android.text.SpannableStringBuilder
 import android.text.Spanned
 import android.text.format.DateUtils
@@ -23,9 +24,6 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
 import android.widget.TextView
-import androidx.annotation.ColorRes
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
@@ -50,7 +48,10 @@ import leakcanary.internal.MoreDetailsView.Details.NONE
 import leakcanary.internal.MoreDetailsView.Details.OPENED
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
 import leakcanary.internal.navigation.inflate
+import android.os.Build.VERSION.SDK_INT
+import leakcanary.internal.navigation.getColorCompat
 
+@Suppress("DEPRECATION")
 internal class DisplayLeakAdapter constructor(
   context: Context,
   private val leakTrace: LeakTrace,
@@ -139,27 +140,23 @@ internal class DisplayLeakAdapter constructor(
     val resources = view.resources
     if (isFirstConnectorRow(position)) {
       titleView.text = if (isLeakGroup) {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>Known likely causes of leak group</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       } else {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>${resources.getString(R.string.leak_canary_help_title)}</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       }
     } else {
-      val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
-
       val elementIndex = elementIndex(position)
       val element = leakTrace.elements[elementIndex]
 
@@ -172,7 +169,7 @@ internal class DisplayLeakAdapter constructor(
       titleView.text = htmlTitle
 
       if (opened[position]) {
-        val htmlDetail = htmlDetails(isLast, element)
+        val htmlDetail = htmlDetails(element)
         detailView.text = htmlDetail
       }
     }
@@ -249,8 +246,7 @@ internal class DisplayLeakAdapter constructor(
     if (exclusion != null) {
       htmlString += " (excluded)"
     }
-    val builder =
-      HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY) as SpannableStringBuilder
+    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
     if (maybeLeakCause) {
       SquigglySpan.replaceUnderlineSpans(builder, context)
     }
@@ -258,10 +254,7 @@ internal class DisplayLeakAdapter constructor(
     return builder
   }
 
-  private fun htmlDetails(
-    isLeakingInstance: Boolean,
-    element: LeakTraceElement
-  ): Spanned {
+  private fun htmlDetails(element: LeakTraceElement): Spanned {
     var htmlString = ""
     val exclusion = element.exclusion
     if (exclusion != null) {
@@ -271,7 +264,7 @@ internal class DisplayLeakAdapter constructor(
         htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
       }
     }
-    return HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY)
+    return Html.fromHtml(htmlString)
   }
 
   private fun getConnectorType(position: Int): Type {
@@ -353,8 +346,8 @@ internal class DisplayLeakAdapter constructor(
     private const val TOP_ROW_COUNT = 2
 
     // https://stackoverflow.com/a/6540378/703646
-    private fun hexStringColor(context: Context, @ColorRes colorResId: Int): String {
-      return String.format("#%06X", 0xFFFFFF and ContextCompat.getColor(context, colorResId))
+    private fun hexStringColor(context: Context, colorResId: Int): String {
+      return String.format("#%06X", 0xFFFFFF and context.getColorCompat(colorResId))
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
index 923e20aee..03c7fbc55 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -26,7 +26,6 @@ import android.graphics.PorterDuff.Mode.CLEAR
 import android.graphics.PorterDuffXfermode
 import android.util.AttributeSet
 import android.view.View
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
@@ -39,6 +38,7 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.navigation.getColorCompat
 
 internal class DisplayLeakConnectorView(
   context: Context,
@@ -81,18 +81,18 @@ internal class DisplayLeakConnectorView(
         .toFloat()
 
     classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    classNamePaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    classNamePaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     classNamePaint.strokeWidth = strokeSize
 
     leakGroupRootPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakGroupRootPaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    leakGroupRootPaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     leakGroupRootPaint.strokeWidth = strokeSize
     val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
         .toFloat()
     leakGroupRootPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathLines), 0f)
 
     leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    leakPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     leakPaint.style = Paint.Style.STROKE
     leakPaint.strokeWidth = strokeSize
 
@@ -105,7 +105,7 @@ internal class DisplayLeakConnectorView(
     clearPaint.xfermode = CLEAR_XFER_MODE
 
     referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    referencePaint.color = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referencePaint.color = context.getColorCompat(R.color.leak_canary_reference)
     referencePaint.strokeWidth = strokeSize
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 7c700c986..f99a2da52 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -17,8 +17,8 @@ package leakcanary.internal
 
 import android.content.Context
 import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
 import android.os.Process
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AndroidKnownReference
@@ -88,7 +88,19 @@ internal class HeapAnalyzerService : ForegroundService(
     ) {
       val intent = Intent(context, HeapAnalyzerService::class.java)
       intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
-      ContextCompat.startForegroundService(context, intent)
+      startForegroundService(context, intent)
+    }
+
+    fun startForegroundService(
+      context: Context,
+      intent: Intent
+    ) {
+      if (SDK_INT >= 26) {
+        context.startForegroundService(intent)
+      } else {
+        // Pre-O behavior.
+        context.startService(intent)
+      }
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 0666dff49..c01105594 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -125,6 +125,7 @@ internal class HeapDumpTrigger(
       val retainedReferenceCount = refWatcher.retainedInstanceCount
       if (retainedReferenceCount == 0) {
         CanaryLog.d("No retained instances after GC")
+        @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
                 application.getString(R.string.leak_canary_notification_no_retained_instance_title)
@@ -279,6 +280,7 @@ internal class HeapDumpTrigger(
     if (!Notifications.canShowNotification) {
       return
     }
+    @Suppress("DEPRECATION")
     val builder = Notification.Builder(application)
         .setContentTitle(
             application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
new file mode 100644
index 000000000..a76fe7f42
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
@@ -0,0 +1,541 @@
+package leakcanary.internal;
+
+import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
+import static org.xmlpull.v1.XmlPullParser.START_TAG;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ProviderInfo;
+import android.content.res.XmlResourceParser;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Environment;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.text.TextUtils;
+import android.webkit.MimeTypeMap;
+
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class LeakCanaryFileProvider extends ContentProvider {
+    private static final String[] COLUMNS = {
+            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE };
+
+    private static final String
+            META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";
+
+    private static final String TAG_ROOT_PATH = "root-path";
+    private static final String TAG_FILES_PATH = "files-path";
+    private static final String TAG_CACHE_PATH = "cache-path";
+    private static final String TAG_EXTERNAL = "external-path";
+    private static final String TAG_EXTERNAL_FILES = "external-files-path";
+    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
+    private static final String TAG_EXTERNAL_MEDIA = "external-media-path";
+
+    private static final String ATTR_NAME = "name";
+    private static final String ATTR_PATH = "path";
+
+    private static final File DEVICE_ROOT = new File("/");
+
+    private static HashMap<String, PathStrategy> sCache = new HashMap<String, PathStrategy>();
+
+    private PathStrategy mStrategy;
+
+    /**
+     * The default FileProvider implementation does not need to be initialized. If you want to
+     * override this method, you must provide your own subclass of FileProvider.
+     */
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    /**
+     * After the FileProvider is instantiated, this method is called to provide the system with
+     * information about the provider.
+     *
+     * @param context A {@link Context} for the current component.
+     * @param info A {@link ProviderInfo} for the new provider.
+     */
+    @Override
+    public void attachInfo(Context context, ProviderInfo info) {
+        super.attachInfo(context, info);
+
+        // Sanity check our security
+        if (info.exported) {
+            throw new SecurityException("Provider must not be exported");
+        }
+        if (!info.grantUriPermissions) {
+            throw new SecurityException("Provider must grant uri permissions");
+        }
+
+        mStrategy = getPathStrategy(context, info.authority);
+    }
+
+    /**
+     * Return a content URI for a given {@link File}. Specific temporary
+     * permissions for the content URI can be set with
+     * {@link Context#grantUriPermission(String, Uri, int)}, or added
+     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
+     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
+     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
+     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
+     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
+     * meta-data element. See the Class Overview for more information.
+     *
+     * @param context A {@link Context} for the current component.
+     * @param authority The authority of a {@link FileProvider} defined in a
+     *            {@code <provider>} element in your app's manifest.
+     * @param file A {@link File} pointing to the filename for which you want a
+     * <code>content</code> {@link Uri}.
+     * @return A content URI for the file.
+     * @throws IllegalArgumentException When the given {@link File} is outside
+     * the paths supported by the provider.
+     */
+    public static Uri getUriForFile(Context context, String authority,
+            File file) {
+        final PathStrategy strategy = getPathStrategy(context, authority);
+        return strategy.getUriForFile(file);
+    }
+
+    /**
+     * Use a content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
+     * managed by the FileProvider.
+     * FileProvider reports the column names defined in {@link android.provider.OpenableColumns}:
+     * <ul>
+     * <li>{@link android.provider.OpenableColumns#DISPLAY_NAME}</li>
+     * <li>{@link android.provider.OpenableColumns#SIZE}</li>
+     * </ul>
+     * For more information, see
+     * {@link ContentProvider#query(Uri, String[], String, String[], String)
+     * ContentProvider.query()}.
+     *
+     * @param uri A content URI returned by {@link #getUriForFile}.
+     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
+     * included.
+     * @param selection Selection criteria to apply. If null then all data that matches the content
+     * URI is returned.
+     * @param selectionArgs An array of {@link java.lang.String}, containing arguments to bind to
+     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
+     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
+     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
+     * values are bound to <i>selection</i> as {@link java.lang.String} values.
+     * @param sortOrder A {@link java.lang.String} containing the column name(s) on which to sort
+     * the resulting {@link Cursor}.
+     * @return A {@link Cursor} containing the results of the query.
+     *
+     */
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs,
+            String sortOrder) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+
+        if (projection == null) {
+            projection = COLUMNS;
+        }
+
+        String[] cols = new String[projection.length];
+        Object[] values = new Object[projection.length];
+        int i = 0;
+        for (String col : projection) {
+            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
+                cols[i] = OpenableColumns.DISPLAY_NAME;
+                values[i++] = file.getName();
+            } else if (OpenableColumns.SIZE.equals(col)) {
+                cols[i] = OpenableColumns.SIZE;
+                values[i++] = file.length();
+            }
+        }
+
+        cols = copyOf(cols, i);
+        values = copyOf(values, i);
+
+        final MatrixCursor cursor = new MatrixCursor(cols, 1);
+        cursor.addRow(values);
+        return cursor;
+    }
+
+    /**
+     * Returns the MIME type of a content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     *
+     * @param uri A content URI returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @return If the associated file has an extension, the MIME type associated with that
+     * extension; otherwise <code>application/octet-stream</code>.
+     */
+    @Override
+    public String getType(Uri uri) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+
+        final int lastDot = file.getName().lastIndexOf('.');
+        if (lastDot >= 0) {
+            final String extension = file.getName().substring(lastDot + 1);
+            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
+            if (mime != null) {
+                return mime;
+            }
+        }
+
+        return "application/octet-stream";
+    }
+
+    /**
+     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
+     * subclass FileProvider if you want to provide different functionality.
+     */
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("No external inserts");
+    }
+
+    /**
+     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
+     * subclass FileProvider if you want to provide different functionality.
+     */
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+        throw new UnsupportedOperationException("No external updates");
+    }
+
+    /**
+     * Deletes the file associated with the specified content URI, as
+     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
+     * method does <b>not</b> throw an {@link java.io.IOException}; you must check its return value.
+     *
+     * @param uri A content URI for a file, as returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @param selection Ignored. Set to {@code null}.
+     * @param selectionArgs Ignored. Set to {@code null}.
+     * @return 1 if the delete succeeds; otherwise, 0.
+     */
+    @Override
+    public int delete(Uri uri, String selection,
+            String[] selectionArgs) {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+        return file.delete() ? 1 : 0;
+    }
+
+    /**
+     * By default, FileProvider automatically returns the
+     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
+     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
+     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
+     * ContentResolver.openFileDescriptor}.
+     *
+     * To override this method, you must provide your own subclass of FileProvider.
+     *
+     * @param uri A content URI associated with a file, as returned by
+     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
+     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
+     * write access, or "rwt" for read and write access that truncates any existing file.
+     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
+     */
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode)
+            throws FileNotFoundException {
+        // ContentProvider has already checked granted permissions
+        final File file = mStrategy.getFileForUri(uri);
+        final int fileMode = modeToMode(mode);
+        return ParcelFileDescriptor.open(file, fileMode);
+    }
+
+    /**
+     * Return {@link PathStrategy} for given authority, either by parsing or
+     * returning from cache.
+     */
+    private static PathStrategy getPathStrategy(Context context, String authority) {
+        PathStrategy strat;
+        synchronized (sCache) {
+            strat = sCache.get(authority);
+            if (strat == null) {
+                try {
+                    strat = parsePathStrategy(context, authority);
+                } catch (IOException e) {
+                    throw new IllegalArgumentException(
+                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
+                } catch (XmlPullParserException e) {
+                    throw new IllegalArgumentException(
+                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
+                }
+                sCache.put(authority, strat);
+            }
+        }
+        return strat;
+    }
+
+    /**
+     * Parse and return {@link PathStrategy} for given authority as defined in
+     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
+     *
+     * @see #getPathStrategy(Context, String)
+     */
+    private static PathStrategy parsePathStrategy(Context context, String authority)
+            throws IOException, XmlPullParserException {
+        final SimplePathStrategy strat = new SimplePathStrategy(authority);
+
+        final ProviderInfo info = context.getPackageManager()
+                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
+        final XmlResourceParser in = info.loadXmlMetaData(
+                context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
+        if (in == null) {
+            throw new IllegalArgumentException(
+                    "Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
+        }
+
+        int type;
+        while ((type = in.next()) != END_DOCUMENT) {
+            if (type == START_TAG) {
+                final String tag = in.getName();
+
+                final String name = in.getAttributeValue(null, ATTR_NAME);
+                String path = in.getAttributeValue(null, ATTR_PATH);
+
+                File target = null;
+                if (TAG_ROOT_PATH.equals(tag)) {
+                    target = DEVICE_ROOT;
+                } else if (TAG_FILES_PATH.equals(tag)) {
+                    target = context.getFilesDir();
+                } else if (TAG_CACHE_PATH.equals(tag)) {
+                    target = context.getCacheDir();
+                } else if (TAG_EXTERNAL.equals(tag)) {
+                    target = Environment.getExternalStorageDirectory();
+                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
+                    File[] externalFilesDirs = getExternalFilesDirs(context, null);
+                    if (externalFilesDirs.length > 0) {
+                        target = externalFilesDirs[0];
+                    }
+                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
+                    File[] externalCacheDirs = getExternalCacheDirs(context);
+                    if (externalCacheDirs.length > 0) {
+                        target = externalCacheDirs[0];
+                    }
+                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
+                        && TAG_EXTERNAL_MEDIA.equals(tag)) {
+                    File[] externalMediaDirs = context.getExternalMediaDirs();
+                    if (externalMediaDirs.length > 0) {
+                        target = externalMediaDirs[0];
+                    }
+                }
+
+                if (target != null) {
+                    strat.addRoot(name, buildPath(target, path));
+                }
+            }
+        }
+
+        return strat;
+    }
+
+    private static File[] getExternalFilesDirs(Context context, String type) {
+        if (Build.VERSION.SDK_INT >= 19) {
+            return context.getExternalFilesDirs(type);
+        } else {
+            return new File[] { context.getExternalFilesDir(type) };
+        }
+    }
+
+    private static File[] getExternalCacheDirs(Context context) {
+        if (Build.VERSION.SDK_INT >= 19) {
+            return context.getExternalCacheDirs();
+        } else {
+            return new File[] { context.getExternalCacheDir() };
+        }
+    }
+
+    /**
+     * Strategy for mapping between {@link File} and {@link Uri}.
+     * <p>
+     * Strategies must be symmetric so that mapping a {@link File} to a
+     * {@link Uri} and then back to a {@link File} points at the original
+     * target.
+     * <p>
+     * Strategies must remain consistent across app launches, and not rely on
+     * dynamic state. This ensures that any generated {@link Uri} can still be
+     * resolved if your process is killed and later restarted.
+     *
+     * @see SimplePathStrategy
+     */
+    interface PathStrategy {
+        /**
+         * Return a {@link Uri} that represents the given {@link File}.
+         */
+        Uri getUriForFile(File file);
+
+        /**
+         * Return a {@link File} that represents the given {@link Uri}.
+         */
+        File getFileForUri(Uri uri);
+    }
+
+    /**
+     * Strategy that provides access to files living under a narrow whitelist of
+     * filesystem roots. It will throw {@link SecurityException} if callers try
+     * accessing files outside the configured roots.
+     * <p>
+     * For example, if configured with
+     * {@code addRoot("myfiles", context.getFilesDir())}, then
+     * {@code context.getFileStreamPath("foo.txt")} would map to
+     * {@code content://myauthority/myfiles/foo.txt}.
+     */
+    static class SimplePathStrategy implements PathStrategy {
+        private final String mAuthority;
+        private final HashMap<String, File> mRoots = new HashMap<String, File>();
+
+        SimplePathStrategy(String authority) {
+            mAuthority = authority;
+        }
+
+        /**
+         * Add a mapping from a name to a filesystem root. The provider only offers
+         * access to files that live under configured roots.
+         */
+        void addRoot(String name, File root) {
+            if (TextUtils.isEmpty(name)) {
+                throw new IllegalArgumentException("Name must not be empty");
+            }
+
+            try {
+                // Resolve to canonical path to keep path checking fast
+                root = root.getCanonicalFile();
+            } catch (IOException e) {
+                throw new IllegalArgumentException(
+                        "Failed to resolve canonical path for " + root, e);
+            }
+
+            mRoots.put(name, root);
+        }
+
+        @Override
+        public Uri getUriForFile(File file) {
+            String path;
+            try {
+                path = file.getCanonicalPath();
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
+            }
+
+            // Find the most-specific root path
+            Map.Entry<String, File> mostSpecific = null;
+            for (Map.Entry<String, File> root : mRoots.entrySet()) {
+                final String rootPath = root.getValue().getPath();
+                if (path.startsWith(rootPath) && (mostSpecific == null
+                        || rootPath.length() > mostSpecific.getValue().getPath().length())) {
+                    mostSpecific = root;
+                }
+            }
+
+            if (mostSpecific == null) {
+                throw new IllegalArgumentException(
+                        "Failed to find configured root that contains " + path);
+            }
+
+            // Start at first char of path under root
+            final String rootPath = mostSpecific.getValue().getPath();
+            if (rootPath.endsWith("/")) {
+                path = path.substring(rootPath.length());
+            } else {
+                path = path.substring(rootPath.length() + 1);
+            }
+
+            // Encode the tag and path separately
+            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
+            return new Uri.Builder().scheme("content")
+                    .authority(mAuthority).encodedPath(path).build();
+        }
+
+        @Override
+        public File getFileForUri(Uri uri) {
+            String path = uri.getEncodedPath();
+
+            final int splitIndex = path.indexOf('/', 1);
+            final String tag = Uri.decode(path.substring(1, splitIndex));
+            path = Uri.decode(path.substring(splitIndex + 1));
+
+            final File root = mRoots.get(tag);
+            if (root == null) {
+                throw new IllegalArgumentException("Unable to find configured root for " + uri);
+            }
+
+            File file = new File(root, path);
+            try {
+                file = file.getCanonicalFile();
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
+            }
+
+            if (!file.getPath().startsWith(root.getPath())) {
+                throw new SecurityException("Resolved path jumped beyond configured root");
+            }
+
+            return file;
+        }
+    }
+
+    /**
+     * Copied from ContentResolver.java
+     */
+    private static int modeToMode(String mode) {
+        int modeBits;
+        if ("r".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
+        } else if ("w".equals(mode) || "wt".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_TRUNCATE;
+        } else if ("wa".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_APPEND;
+        } else if ("rw".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
+                    | ParcelFileDescriptor.MODE_CREATE;
+        } else if ("rwt".equals(mode)) {
+            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
+                    | ParcelFileDescriptor.MODE_CREATE
+                    | ParcelFileDescriptor.MODE_TRUNCATE;
+        } else {
+            throw new IllegalArgumentException("Invalid mode: " + mode);
+        }
+        return modeBits;
+    }
+
+    private static File buildPath(File base, String... segments) {
+        File cur = base;
+        for (String segment : segments) {
+            if (segment != null) {
+                cur = new File(cur, segment);
+            }
+        }
+        return cur;
+    }
+
+    private static String[] copyOf(String[] original, int newLength) {
+        final String[] result = new String[newLength];
+        System.arraycopy(original, 0, result, 0, newLength);
+        return result;
+    }
+
+    private static Object[] copyOf(Object[] original, int newLength) {
+        final Object[] result = new Object[newLength];
+        System.arraycopy(original, 0, result, 0, newLength);
+        return result;
+    }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
deleted file mode 100644
index cade0684a..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
+++ /dev/null
@@ -1,9 +0,0 @@
-package leakcanary.internal
-
-import androidx.core.content.FileProvider
-
-/**
- * There can only be one [FileProvider] provider registered per app, so we extend that class
- * just to use a distinct name.
- */
-internal class LeakCanaryFileProvider : FileProvider()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index a42d6fdc8..d569f8335 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -154,6 +154,7 @@ internal class LeakDirectoryProvider constructor(
     )
   }
 
+  @Suppress("DEPRECATION")
   private fun externalStorageDirectory(): File {
     val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
     return File(downloadsDirectory, "leakcanary-" + context.packageName)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
index 677f7f48c..b033e32d6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -1,9 +1,8 @@
 package leakcanary.internal
 
-import androidx.annotation.StringRes
 import com.squareup.leakcanary.core.R
 
-enum class NotificationType(@StringRes val nameResId: Int, val importance: Int) {
+enum class NotificationType(val nameResId: Int, val importance: Int) {
   LEAKCANARY_LOW(
       R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
   ),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
index 3559c1537..9db6e9242 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -83,6 +83,7 @@ internal object Notifications {
     }
 
     return if (SDK_INT < JELLY_BEAN) {
+      @Suppress("DEPRECATION")
       builder.notification
     } else {
       builder.build()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
index 747f488f6..a817e24be 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -22,8 +22,8 @@ import android.graphics.Path
 import android.text.SpannableStringBuilder
 import android.text.style.ReplacementSpan
 import android.text.style.UnderlineSpan
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.navigation.getColorCompat
 
 /**
  * Inspired from https://github.com/flavienlaurent/spans and
@@ -44,7 +44,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
   init {
     val resources = context.resources
     squigglyPaint.style = Paint.Style.STROKE
-    squigglyPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    squigglyPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     val strokeWidth =
       resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
           .toFloat()
@@ -59,7 +59,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
     path = Path()
     val waveHeight = 2 * amplitude + strokeWidth
     halfWaveHeight = waveHeight / 2
-    referenceColor = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referenceColor = context.getColorCompat(R.color.leak_canary_reference)
   }
 
   override fun getSize(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index d6e750d7b..4f7c8db62 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -9,8 +9,8 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.view.View
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.navigation.activity
 import java.io.File
 
@@ -27,7 +27,7 @@ internal fun View.share(content: String) {
 internal fun View.shareHeapDump(heapDumpFile: File) {
   AsyncTask.SERIAL_EXECUTOR.execute {
     heapDumpFile.setReadable(true, false)
-    val heapDumpUri = FileProvider.getUriForFile(
+    val heapDumpUri = LeakCanaryFileProvider.getUriForFile(
         activity,
         "com.squareup.leakcanary.fileprovider." + activity.packageName,
         heapDumpFile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
index 18b437547..628befce6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -1,14 +1,16 @@
 package leakcanary.internal.activity.screen
 
 import android.app.AlertDialog
+import android.content.Context
+import android.graphics.drawable.Drawable
+import android.os.Build.VERSION.SDK_INT
+import android.text.Html
 import android.text.format.DateUtils
 import android.text.method.LinkMovementMethod
 import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.LeakActivity
@@ -40,14 +42,12 @@ internal class GroupListScreen : Screen() {
 
         menu.add(R.string.leak_canary_about_menu)
             .setOnMenuItemClickListener {
+              @Suppress("DEPRECATION")
               val dialog = AlertDialog.Builder(context)
-                  .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
+                  .setIcon(context.getDrawableCompat(R.drawable.leak_canary_icon))
                   .setTitle(resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION))
                   .setMessage(
-                      HtmlCompat.fromHtml(
-                          resources.getString(R.string.leak_canary_about_message),
-                          HtmlCompat.FROM_HTML_MODE_LEGACY
-                      )
+                      Html.fromHtml(resources.getString(R.string.leak_canary_about_message))
                   )
                   .setPositiveButton(android.R.string.ok, null)
                   .show()
@@ -65,6 +65,15 @@ internal class GroupListScreen : Screen() {
 
     }
 
+  private fun Context.getDrawableCompat(id: Int): Drawable {
+    if (SDK_INT >= 21) {
+      return getDrawable(id)!!
+    } else  {
+      @Suppress("DEPRECATION")
+      return resources.getDrawable(id)
+    }
+  }
+
   private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
     activity.title =
       resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index d310f95d7..ddd3fbba8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -10,7 +10,6 @@ import android.graphics.Paint
 import android.graphics.Paint.Style.FILL
 import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.HprofPushRecordsParser
 import leakcanary.HprofPushRecordsParser.OnRecordListener
@@ -32,6 +31,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Sh
 import leakcanary.Record.LoadClassRecord
 import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
+import leakcanary.internal.navigation.getColorCompat
 import java.io.File
 import kotlin.reflect.KClass
 
@@ -60,21 +60,21 @@ object HeapDumpRenderer {
     val recordPositions = mutableListOf<Pair<Int, Long>>()
     var currentRecord: Record? = null
 
-    val otherColor = ContextCompat.getColor(context, R.color.leak_canary_heap_other)
-    val stackTraceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_stack_trace)
-    val hprofStringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_hprof_string)
-    val loadClassColor = ContextCompat.getColor(context, R.color.leak_canary_heap_load_class)
-    val classDumpColor = ContextCompat.getColor(context, R.color.leak_canary_heap_class_dump)
-    val instanceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance)
-    val objectArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_object_array)
-    val booleanArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_boolean_array)
-    val charArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_char_array)
-    val floatArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_float_array)
-    val doubleArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_double_array)
-    val byteArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_byte_array)
-    val shortArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_short_array)
-    val intArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_int_array)
-    val longArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_long_array)
+    val otherColor = context.getColorCompat(R.color.leak_canary_heap_other)
+    val stackTraceColor = context.getColorCompat(R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = context.getColorCompat(R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = context.getColorCompat(R.color.leak_canary_heap_load_class)
+    val classDumpColor = context.getColorCompat(R.color.leak_canary_heap_class_dump)
+    val instanceColor = context.getColorCompat(R.color.leak_canary_heap_instance)
+    val objectArrayColor = context.getColorCompat(R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = context.getColorCompat(R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = context.getColorCompat(R.color.leak_canary_heap_char_array)
+    val floatArrayColor = context.getColorCompat(R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = context.getColorCompat(R.color.leak_canary_heap_double_array)
+    val byteArrayColor = context.getColorCompat(R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = context.getColorCompat(R.color.leak_canary_heap_short_array)
+    val intArrayColor = context.getColorCompat(R.color.leak_canary_heap_int_array)
+    val longArrayColor = context.getColorCompat(R.color.leak_canary_heap_long_array)
     val colors = mapOf(
         StringRecord::class to hprofStringColor,
         LoadClassRecord::class to loadClassColor,
@@ -94,10 +94,10 @@ object HeapDumpRenderer {
         GcRootRecord::class to otherColor
     )
 
-    val appHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_app)
-    val imageHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_image)
-    val zygoteHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_zygote)
-    val stringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance_string)
+    val appHeapColor = context.getColorCompat(R.color.leak_canary_heap_app)
+    val imageHeapColor = context.getColorCompat(R.color.leak_canary_heap_image)
+    val zygoteHeapColor = context.getColorCompat(R.color.leak_canary_heap_zygote)
+    val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
     val parser = HprofPushRecordsParser()
     val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index 7311da165..e07fecbb5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -11,10 +11,10 @@ import android.view.ViewGroup
 import android.view.ViewTreeObserver.OnGlobalLayoutListener
 import android.widget.ImageView
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
@@ -85,7 +85,7 @@ internal class RenderHeapDumpScreen(
                     .show()
                 executeOnIo {
                   val bitmap = HeapDumpRenderer.render(context, heapDumpFile, 2048, 0, 4)
-                  val storageDir =
+                  @Suppress("DEPRECATION") val storageDir =
                     Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
 
                   val imageFile = File(storageDir, "${heapDumpFile.name}.png")
@@ -93,7 +93,7 @@ internal class RenderHeapDumpScreen(
                   if (saved) {
                     CanaryLog.d("Png saved at $imageFile")
                     imageFile.setReadable(true, false)
-                    val imageUri = FileProvider.getUriForFile(
+                    val imageUri = LeakCanaryFileProvider.getUriForFile(
                         activity,
                         "com.squareup.leakcanary.fileprovider." + activity.packageName,
                         imageFile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
index 292640917..2c6979008 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -3,11 +3,9 @@ package leakcanary.internal.activity.ui
 import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
-import androidx.annotation.LayoutRes
 import leakcanary.internal.navigation.inflate
 
 class SimpleListAdapter<T>(
-  @LayoutRes
   private val rowResId: Int,
   private val items: List<T>,
   private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
index 13603e4ee..89d3c5ec2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -1,13 +1,14 @@
 package leakcanary.internal.navigation
 
 import android.app.Activity
+import android.content.Context
+import android.os.Build.VERSION
 import android.view.LayoutInflater
 import android.view.Menu
 import android.view.View
 import android.view.ViewGroup
-import androidx.annotation.LayoutRes
 
-internal fun ViewGroup.inflate(@LayoutRes layoutResId: Int) = LayoutInflater.from(context)
+internal fun ViewGroup.inflate(layoutResId: Int) = LayoutInflater.from(context)
     .inflate(layoutResId, this, false)!!
 
 internal val View.activity
@@ -27,4 +28,12 @@ internal fun View.goTo(screen: Screen) {
 
 internal fun View.goBack() {
   activity<NavigatingActivity>().goBack()
+}
+
+internal fun Context.getColorCompat(id: Int): Int {
+  return if (VERSION.SDK_INT >= 23) {
+    getColor(id)
+  } else {
+    resources.getColor(id)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index db8d12fec..cd9660abd 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -15,14 +15,9 @@
   ~ limitations under the License.
   -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
     package="com.squareup.leakcanary.instrumentation.test">
-  <!-- Disabled debuggable for accurate performance results -->
-  <application android:name="leakcanary.InstrumentationTestApplication"
-      android:debuggable="false"
-      tools:ignore="HardcodedDebugMode"
-      tools:replace="android:debuggable"
-      >
+
+  <application android:name="leakcanary.InstrumentationTestApplication">
     <activity android:name="leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-cli/build.gradle b/leakcanary-cli/build.gradle
index 0aa040f95..a28332746 100644
--- a/leakcanary-cli/build.gradle
+++ b/leakcanary-cli/build.gradle
@@ -8,7 +8,6 @@ targetCompatibility = JavaVersion.VERSION_1_7
 dependencies {
   api project(':leakcanary-analyzer')
 
-  implementation deps.androidx.annotation
   implementation deps.kotlin.stdlib
 }
 
diff --git a/leakcanary-fragments-androidx/build.gradle b/leakcanary-fragments-androidx/build.gradle
new file mode 100644
index 000000000..3e2f7a909
--- /dev/null
+++ b/leakcanary-fragments-androidx/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-leaksentry')
+
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-fragments-androidx/gradle.properties b/leakcanary-fragments-androidx/gradle.properties
new file mode 100644
index 000000000..54f530989
--- /dev/null
+++ b/leakcanary-fragments-androidx/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-fragments-androidx
+POM_NAME=LeakCanary Android X fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-fragments-androidx/src/main/AndroidManifest.xml b/leakcanary-fragments-androidx/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..22eac3057
--- /dev/null
+++ b/leakcanary-fragments-androidx/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    package="com.squareup.leakcanary.fragments.androidx"
+    >
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
similarity index 97%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
rename to leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index a4fc2f299..d12efa0ca 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
+++ b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -22,7 +22,7 @@ import androidx.fragment.app.FragmentManager
 import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
 
-internal class SupportFragmentDestroyWatcher(
+internal class AndroidXFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
 ) : FragmentDestroyWatcher {
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-leaksentry/build.gradle
index dd0f4e90d..97ffdfca5 100644
--- a/leakcanary-leaksentry/build.gradle
+++ b/leakcanary-leaksentry/build.gradle
@@ -4,10 +4,7 @@ apply plugin: 'kotlin-android'
 dependencies {
   api project(':leakcanary-watcher')
 
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
-  // Optional dependency
-  compileOnly deps.androidx.fragment
 }
 
 android {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index 62ef6a25c..dd2f7d4aa 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -17,15 +17,14 @@
 
 package leakcanary.internal
 
+import android.annotation.SuppressLint
 import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
-import android.os.Build
-import androidx.annotation.RequiresApi
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
+import leakcanary.RefWatcher
 
-@RequiresApi(Build.VERSION_CODES.O) //
+@SuppressLint("NewApi")
 internal class AndroidOFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 54976015d..9cbe23e9d 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -27,13 +27,15 @@ import leakcanary.internal.InternalHelper.noOpDelegate
 /**
  * Internal class used to watch for fragments leaks.
  */
-internal interface FragmentDestroyWatcher {
+interface FragmentDestroyWatcher {
 
   fun watchFragments(activity: Activity)
 
   companion object {
 
-    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+    private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+    private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+      "leakcanary.internal.AndroidXFragmentDestroyWatcher"
 
     fun install(
       application: Application,
@@ -48,12 +50,13 @@ internal interface FragmentDestroyWatcher {
         )
       }
 
-      if (classAvailable(
-              SUPPORT_FRAGMENT_CLASS_NAME
-          )
+      if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
+          classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
       ) {
+        val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+            .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
         fragmentDestroyWatchers.add(
-            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+            watcherConstructor.newInstance(refWatcher, configProvider) as FragmentDestroyWatcher
         )
       }
 
diff --git a/settings.gradle b/settings.gradle
index 5b1579ed5..3fddcaea7 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -4,6 +4,7 @@ include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
 include ':leakcanary-cli'
+include ':leakcanary-fragments-androidx'
 include ':leakcanary-haha'
 include ':leakcanary-leaksentry'
 include ':leakcanary-log'
