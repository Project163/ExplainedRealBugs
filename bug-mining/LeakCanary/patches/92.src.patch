diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
index 739a5eaf4..c6ea86bf4 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
@@ -47,11 +47,14 @@ data class Exclusion(
   sealed class ExclusionType {
     abstract val matching: String
 
-    class ThreadExclusion(
+    /**
+     * Local references held in the stack of frames of a given thread.
+     */
+    class JavaLocalExclusion(
       val threadName: String
     ) : ExclusionType() {
       override val matching: String
-        get() = "any threads named $threadName"
+        get() = "local variable on thread $threadName"
     }
 
     class StaticFieldExclusion(
@@ -62,6 +65,12 @@ data class Exclusion(
         get() = "static field $className#$fieldName"
     }
 
+    /**
+     * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
+     * and will still match for subclasses. This is to support overriding of rules for specific
+     * cases. If two exclusions for the same field name but different classname match in a class
+     * hierarchy, then the closest class in the hierarchy wins.
+     */
     class InstanceFieldExclusion(
       val className: String,
       val fieldName: String
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index fccdfb44a..ca2d78e79 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -31,6 +31,7 @@ import leakcanary.GcRoot.NativeStack
 import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -153,7 +154,7 @@ class HeapAnalyzer constructor(
   }
 
   private data class ScanResult(
-    val gcRootIds: MutableList<Long>,
+    val gcRootIds: MutableList<GcRoot>,
     val keyedWeakReferenceInstances: List<InstanceDumpRecord>,
     val cleaners: MutableList<Long>
   )
@@ -163,7 +164,7 @@ class HeapAnalyzer constructor(
     computeRetainedSize: Boolean
   ): ScanResult {
     val keyedWeakReferenceInstances = mutableListOf<InstanceDumpRecord>()
-    val gcRootIds = mutableListOf<Long>()
+    val gcRoot = mutableListOf<GcRoot>()
     val cleaners = mutableListOf<Long>()
     val callbacks = RecordCallbacks()
         .on(InstanceDumpRecord::class.java) { record ->
@@ -173,12 +174,14 @@ class HeapAnalyzer constructor(
           }
         }
         .on(GcRootRecord::class.java) {
-          // TODO Why is ThreadObject ignored?
           // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
           // to do? What's VmInternal exactly? History does not go further than
           // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
           // We should log to figure out what objects VmInternal points to.
           when (it.gcRoot) {
+            // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
+            // belongs to
+            is ThreadObject,
             is JniGlobal,
             is JniLocal,
             is JavaFrame,
@@ -190,12 +193,12 @@ class HeapAnalyzer constructor(
             is ReferenceCleanup,
             is JniMonitor
             -> {
-              gcRootIds.add(it.gcRoot.id)
+              gcRoot.add(it.gcRoot)
             }
           }
         }
     parser.scan(callbacks)
-    return ScanResult(gcRootIds, keyedWeakReferenceInstances, cleaners)
+    return ScanResult(gcRoot, keyedWeakReferenceInstances, cleaners)
   }
 
   private fun readHeapDumpMemoryStore(
@@ -252,7 +255,7 @@ class HeapAnalyzer constructor(
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>,
+    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean
   ): Results {
     val pathFinder = ShortestPathFinder()
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
index 0a59b875b..60ef3694d 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -6,11 +6,9 @@ sealed class LeakNode {
   abstract val visitOrder: Int
 
   class RootNode(
-    override val instance: Long
-  ) : LeakNode() {
-    override val visitOrder
-      get() = 0
-  }
+    override val instance: Long,
+    override val visitOrder: Int
+  ) : LeakNode()
 
   class ChildNode(
     override val instance: Long,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index 073431422..8c71ac307 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -57,7 +57,7 @@ private fun getNextElementString(
   val simpleClassName = element.simpleClassName
   val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
   val exclusionString =
-    if (element.exclusion != null) " , matching exclusion ${element.exclusion.matching}" else ""
+    if (element.exclusion != null) ", matching exclusion ${element.exclusion.matching}" else ""
   val requiredSpaces =
     staticString.length + holderString.length + simpleClassName.length + "├─".length
   val leakString = if (maybeLeakCause) {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index e5441abc7..0501a9cbc 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -19,13 +19,16 @@ import leakcanary.AnalyzerProgressListener
 import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
 import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
 import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
 import leakcanary.Exclusion.Status
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
+import leakcanary.GcRoot
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofParser
@@ -35,9 +38,12 @@ import leakcanary.LeakNode.RootNode
 import leakcanary.LeakReference
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.ObjectIdMetadata.CLASS
 import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
+import leakcanary.ObjectIdMetadata.INSTANCE
+import leakcanary.ObjectIdMetadata.OBJECT_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
 import leakcanary.ObjectIdMetadata.STRING
@@ -106,7 +112,7 @@ internal class ShortestPathFinder {
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>,
+    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean,
     listener: AnalyzerProgressListener
   ): Results {
@@ -115,14 +121,13 @@ internal class ShortestPathFinder {
 
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    // TODO Use thread name exclusions
     val threadNames = mutableMapOf<String, Exclusion>()
 
     exclusionsFactory(parser)
         .forEach { exclusion ->
 
           when (exclusion.type) {
-            is ThreadExclusion -> {
+            is ExclusionType.JavaLocalExclusion -> {
               threadNames[exclusion.type.threadName] = exclusion
             }
             is StaticFieldExclusion -> {
@@ -149,8 +154,7 @@ internal class ShortestPathFinder {
     // Referent object id to weak ref mirror
     referentMap = leakingWeakRefs.associateBy { it.referent.value }
 
-    enqueueGcRoots(parser, gcRootIds, computeDominators)
-    gcRootIds.clear()
+    enqueueGcRoots(parser, gcRootIds, threadNames, computeDominators)
 
     var lowestPriority = ALWAYS_REACHABLE
     val results = mutableListOf<Result>()
@@ -221,21 +225,83 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueueGcRoots(
-    hprofParser: HprofParser,
-    gcRootIds: List<Long>,
+    parser: HprofParser,
+    gcRoots: MutableList<GcRoot>,
+    threadNameExclusions: Map<String, Exclusion>,
     computeDominators: Boolean
   ) {
-    // TODO sort GC roots based on type and class name (for class / instance / array)
-    // Goal is to get a stable shortest path
-    // TODO Add root type so that for java local we could exclude specific threads.
-    // TODO java local: exclude specific threads,
-    // TODO java local: parent should be set to the allocated thread
-    gcRootIds.forEach {
+    gcRoots.removeAll { it.id == 0L }
+
+    // Sorting GC roots to get stable shortest path
+    // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
+    // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+    // built before JavaFrames.
+    sortGcRoots(parser, gcRoots)
+
+    val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
+    gcRoots.forEach { gcRoot ->
       if (computeDominators) {
-        undominateWithSkips(hprofParser, it)
+        undominateWithSkips(parser, gcRoot.id)
+      }
+      when (gcRoot) {
+        is ThreadObject -> {
+          threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
+          enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+        }
+        is JavaFrame -> with(parser) {
+          val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
+          val threadInstance = threadRoot.id.objectRecord.hydratedInstance
+          val threadName = threadInstance["name"].reference.stringOrNull
+          val exclusion = threadNameExclusions[threadName]
+
+          if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
+            // visitOrder is unused as this root node isn't enqueued.
+            val rootNode = RootNode(threadRoot.id, visitOrder = 0)
+            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
+            // We should also add the full stacktrace as a label of thread objects
+            val leakReference = LeakReference(LOCAL, "")
+            enqueue(
+                parser,
+                ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
+                exclusionPriority = exclusion?.status
+            )
+          }
+        }
+        else -> enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
       }
-      enqueue(hprofParser, RootNode(it), exclusionPriority = null)
     }
+    gcRoots.clear()
+  }
+
+  private fun sortGcRoots(
+    parser: HprofParser,
+    gcRoots: MutableList<GcRoot>
+  ) {
+    val rootClassName: (GcRoot) -> String = {
+      when (val metadata = parser.objectIdMetadata(it.id)) {
+        PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, EMPTY_INSTANCE -> metadata.name
+        STRING -> "java.lang.String"
+        OBJECT_ARRAY -> {
+          val record = parser.retrieveRecordById(it.id) as ObjectArrayDumpRecord
+          parser.className(record.arrayClassId)
+        }
+        INSTANCE -> {
+          val record = parser.retrieveRecordById(it.id) as InstanceDumpRecord
+          parser.className(record.classId)
+        }
+        CLASS -> parser.className(it.id)
+        else -> throw IllegalStateException("Unexpected type $metadata")
+      }
+    }
+    gcRoots.sortWith(Comparator { root1, root2 ->
+      // Sorting based on type name first. In reverse order so that ThreadObject is before JavaLocalExclusion
+      val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+      if (gcRootTypeComparison != 0) {
+        gcRootTypeComparison
+      } else {
+        rootClassName(root1).compareTo(rootClassName(root2))
+      }
+    })
   }
 
   private fun visitClassRecord(
@@ -284,7 +350,14 @@ internal class ShortestPathFinder {
     val ignoredFields = LinkedHashMap<String, Exclusion>()
 
     instance.classHierarchy.forEach {
-      ignoredFields.putAll(fieldNameByClassName[it.className] ?: emptyMap())
+      val classExclusions = fieldNameByClassName[it.className]
+      if (classExclusions != null) {
+        for ((fieldName, exclusion) in classExclusions) {
+          if (!ignoredFields.containsKey(fieldName)) {
+            ignoredFields[fieldName] = exclusion
+          }
+        }
+      }
     }
 
     val fieldNamesAndValues = mutableListOf<Pair<String, HeapValue>>()
@@ -333,7 +406,7 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueue(
-    hprofParser: HprofParser,
+    parser: HprofParser,
     node: LeakNode,
     exclusionPriority: Status?
   ) {
@@ -359,7 +432,7 @@ internal class ShortestPathFinder {
 
     val isLeakingInstance = referentMap[node.instance] != null
 
-    val objectIdMetadata = hprofParser.objectIdMetadata(node.instance)
+    val objectIdMetadata = parser.objectIdMetadata(node.instance)
     if (!isLeakingInstance && objectIdMetadata in SKIP_ENQUEUE) {
       return
     }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
index f89e2d800..9690bdbe7 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
@@ -2,9 +2,13 @@ package leakcanary.internal
 
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
+import leakcanary.KeyedWeakReference
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import org.assertj.core.api.Assertions.assertThat
@@ -13,6 +17,7 @@ import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import java.io.File
+import java.lang.ref.WeakReference
 
 class ExclusionTest {
 
@@ -52,7 +57,7 @@ class ExclusionTest {
     }
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.exclusionStatus).isEqualTo(Exclusion.Status.WONT_FIX_LEAK)
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
@@ -68,7 +73,60 @@ class ExclusionTest {
           Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
       )
     }
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
+    }
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
+  }
+
+  @Test fun weaklyReachableExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(
+          Exclusion(
+              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+              status = WEAKLY_REACHABLE
+          )
+      )
+    }
 
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(
+          Exclusion(
+              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+              status = WEAKLY_REACHABLE
+          ), Exclusion(
+          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      )
+    }
     assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index e7a0450a4..75b9c6d7d 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -1,8 +1,11 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import leakcanary.WeakReferenceCleared
@@ -90,8 +93,7 @@ class HeapAnalyzerTest {
     assertThat(analysis).isInstanceOf(HeapAnalysisFailure::class.java)
   }
 
-  @Test
-  fun findMultipleLeaks() {
+  @Test fun findMultipleLeaks() {
     hprofFile.writeMultipleActivityLeaks(5)
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
@@ -99,4 +101,43 @@ class HeapAnalyzerTest {
     assertThat(leaks.retainedInstances).hasSize(5)
         .hasOnlyElementsOfType(LeakingInstance::class.java)
   }
+
+  @Test fun localVariableLeak() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun threadFieldLeak() {
+    hprofFile.dump {
+      val threadClassId =
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+      val myThreadClassId = clazz(
+          className = "MyThread", superClassId = threadClassId,
+          fields = listOf("leaking" to ObjectReference::class)
+      )
+      val threadInstance =
+        instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
+      gcRoot(
+          ThreadObject(
+              id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+          )
+      )
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
index 17e2a2e42..9d61a1e4d 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
@@ -1,10 +1,11 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofWriter
 import java.io.File
-import kotlin.jvm.internal.Ref.ObjectRef
 
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
@@ -116,4 +117,24 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
           keyedWeakReference("com.example.ExampleActivity", instanceId)
         }
       }
+}
+
+fun File.writeJavaLocalLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+    val myThreadClassId = clazz(className = threadClass, superClassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index a5097712e..bf68c2678 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -1,5 +1,6 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot
 import leakcanary.GcRoot.StickyClass
 import leakcanary.HeapDumpMemoryStore
 import leakcanary.HeapValue
@@ -126,11 +127,16 @@ class HprofWriterHelper constructor(
     )
     classDumps[loadClass.id] = classDump
     writer.write(classDump)
-    val gcRootRecord = GcRootRecord(gcRoot = StickyClass(classDump.id))
-    writer.write(gcRootRecord)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
     return classDump.id
   }
 
+  fun gcRoot(gcRoot: GcRoot) {
+    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
+    writer.write(gcRootRecord)
+  }
+
   fun arrayClass(className: String): Long {
     return clazz(className = "$className[]")
   }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
similarity index 69%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt
rename to leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index 20922dbc0..46350e3c2 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -2,7 +2,9 @@ package leakcanary.internal
 
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofParser
+import leakcanary.InstanceDefaultLabeler
 import leakcanary.LeakNode
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
 import leakcanary.ObjectIdMetadata.STRING
 import org.assertj.core.api.Assertions.assertThat
@@ -12,7 +14,7 @@ import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import java.io.File
 
-class LabelTest {
+class LabelerTest {
 
   @get:Rule
   var testFolder = TemporaryFolder()
@@ -42,4 +44,15 @@ class LabelTest {
     assertThat(leak.leakTrace.elements.last().labels).isEqualTo(listOf("Hello World"))
   }
 
+  @Test fun threadNameLabel() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf(InstanceDefaultLabeler))
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index a1a2c24c1..bb2aedab0 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -1,18 +1,15 @@
 package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
-import leakcanary.CanaryLog
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
 import leakcanary.LeakInspector
 import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalyzer
-import leakcanary.HprofParser
 import leakcanary.KeyedWeakReference
 import leakcanary.Labeler
 import java.io.File
@@ -95,11 +92,11 @@ val defaultExclusionsFactory: ExclusionsFactory = {
       ,
 
       Exclusion(
-          type = ThreadExclusion("FinalizerWatchdogDaemon"),
+          type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
           status = NEVER_REACHABLE
       ),
       Exclusion(
-          type = ThreadExclusion("main"),
+          type = JavaLocalExclusion("main"),
           status = NEVER_REACHABLE
       )
   )
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
index 294f2f365..0bab26f77 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -31,7 +31,7 @@ import android.os.Build.VERSION_CODES.P
 import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.internal.HeapDumpTrigger
@@ -1112,7 +1112,7 @@ enum class AndroidExcludedRefs {
       // reference to the object and it was about to be GCed.
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion("FinalizerWatchdogDaemon"),
+              type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
               status = NEVER_REACHABLE
           )
       )
@@ -1129,7 +1129,7 @@ enum class AndroidExcludedRefs {
       // a real leak.
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion("main"),
+              type = JavaLocalExclusion("main"),
               status = NEVER_REACHABLE
           )
       )
@@ -1143,7 +1143,7 @@ enum class AndroidExcludedRefs {
     ) {
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
+              type = JavaLocalExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
               status = NEVER_REACHABLE
           )
       )
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index 9d64edd11..b8d5daa86 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -38,6 +38,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
 import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackFrameRecord
 import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import leakcanary.internal.LongToIntSparseArray
@@ -232,6 +233,23 @@ class HprofParser private constructor(
             skip(length)
           }
         }
+        STACK_FRAME -> {
+          val callback = callbacks.get<StackFrameRecord>()
+          if (callback != null) {
+            callback(
+                StackFrameRecord(
+                    id = readId(),
+                    methodNameStringId = readId(),
+                    methodSignatureStringId = readId(),
+                    sourceFileNameStringId = readId(),
+                    classSerialNumber = readInt(),
+                    lineNumber = readInt()
+                )
+            )
+          } else {
+            skip(length)
+          }
+        }
         STACK_TRACE -> {
           val callback = callbacks.get<StackTraceRecord>()
           if (callback != null) {
@@ -444,10 +462,10 @@ class HprofParser private constructor(
                       primitiveWrapperTypes.contains(
                           instanceDumpRecord.classId
                       ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
-                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> ObjectIdMetadata.STRING
+                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> STRING
                       instanceDumpRecord.fieldValues.isEmpty() -> EMPTY_INSTANCE
                       instanceDumpRecord.fieldValues.size <= maybeEmptySize -> INTERNAL_MAYBE_EMPTY_INSTANCE
-                      else -> ObjectIdMetadata.INSTANCE
+                      else -> INSTANCE
                     }
                     objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
                   }
@@ -840,7 +858,6 @@ class HprofParser private constructor(
     const val STRING_IN_UTF8 = 0x01
     const val LOAD_CLASS = 0x02
     const val UNLOAD_CLASS = 0x03
-    // TODO Maybe parse this?
     const val STACK_FRAME = 0x04
     const val STACK_TRACE = 0x05
     const val ALLOC_SITES = 0x06
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index 250eb44f8..9f1a420d0 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -15,6 +15,22 @@ sealed class Record {
 
   object HeapDumpEndRecord : Record()
 
+  class StackFrameRecord(
+    val id: Long,
+    val methodNameStringId: Long,
+    val methodSignatureStringId: Long,
+    val sourceFileNameStringId: Long,
+    val classSerialNumber: Int,
+    /**
+     * >0 line number
+     * 0 no line information available
+     * -1 unknown location
+     * -2 compiled method (Not implemented)
+     * -3 native method (Not implemented)
+     */
+    val lineNumber: Int
+  ) : Record()
+
   class StackTraceRecord(
     val stackTraceSerialNumber: Int,
     val threadSerialNumber: Int,
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
index a0602506d..6fa5b3fd4 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
@@ -17,7 +17,9 @@ package com.example.leakcanary
 
 import android.app.Activity
 import android.os.Bundle
+import android.os.SystemClock
 import android.view.View
+import java.util.concurrent.atomic.AtomicReference
 import kotlin.random.Random
 
 class MainActivity : Activity() {
@@ -29,10 +31,27 @@ class MainActivity : Activity() {
     val app = application as ExampleApplication
     val leakedView = findViewById<View>(R.id.helper_text)
 
-    when (Random.nextInt(3)) {
-      0 -> app.leakedViews
-      1 -> LeakingSingleton.leakedViews
-      else -> LeakingThread.thread.leakedViews
-    }.add(leakedView)
+    when (Random.nextInt(4)) {
+      // Leak from application class
+      0 -> app.leakedViews.add(leakedView)
+      // Leak from Kotlin object singleton
+      1 -> LeakingSingleton.leakedViews.add(leakedView)
+      2 -> {
+        // Leak from local variable on thread
+        val ref = AtomicReference(this)
+        val thread = Thread {
+          val activity = ref.get()
+          ref.set(null)
+          while (true) {
+            print(activity)
+            SystemClock.sleep(1000)
+          }
+        }
+        thread.name = "Leaking local variables"
+        thread.start()
+      }
+      // Leak from thread fields
+      else -> LeakingThread.thread.leakedViews.add(leakedView)
+    }
   }
 }
