diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt
index 523aa6a8a..6d231190f 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/DetectLeaksAfterTestSuccess.kt
@@ -10,18 +10,20 @@ import org.junit.runners.model.Statement
  * rule chain as you might detect different leaks (e.g. around vs wrapped by the
  * activity rule). It's also possible to use this rule several times in a rule
  * chain.
+ *
+ * This rule automatically applies the [TestDescriptionHolder] rule.
  */
 class DetectLeaksAfterTestSuccess(
   private val tag: String = DetectLeaksAfterTestSuccess::class.java.simpleName
 ) : TestRule {
   override fun apply(base: Statement, description: Description): Statement {
-    return object : Statement() {
+    return TestDescriptionHolder.wrap(object : Statement() {
       override fun evaluate() {
         // If the test fails, evaluate() will throw and we won't run the analysis (which is good).
         base.evaluate()
         LeakAssertions.assertNoLeaks(tag)
       }
-    }
+    }, description)
   }
 }
 
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt
index bff793a98..5c284e63c 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/TestDescriptionHolder.kt
@@ -1,12 +1,16 @@
 package leakcanary
 
+import leakcanary.TestDescriptionHolder.testDescription
 import org.junit.rules.TestRule
 import org.junit.runner.Description
 import org.junit.runners.model.Statement
+import shark.SharkLog
 
 /**
  * A [TestRule] that holds onto the test [Description] in a thread local while evaluating, making
  * it possible to retrieve that test [Description] from the test thread via [testDescription].
+ *
+ * This rule is automatically applied by [DetectLeaksAfterTestSuccess].
  */
 object TestDescriptionHolder : TestRule {
 
@@ -23,21 +27,25 @@ object TestDescriptionHolder : TestRule {
     }
 
   override fun apply(base: Statement, description: Description): Statement {
-    return object : Statement() {
-      override fun evaluate() {
-        try {
-          val previousDescription = descriptionThreadLocal.get()
-          check(previousDescription == null) {
-            "Test description should be null not [$previousDescription] before the rule evaluates. " +
-              "Did you add the TestDescriptionHolder rule twice by mistake?"
-          }
-          descriptionThreadLocal.set(description)
-          base.evaluate()
-        } finally {
+    return wrap(base, description)
+  }
+
+  fun wrap(base: Statement, description: Description) = object : Statement() {
+    override fun evaluate() {
+      val previousDescription = descriptionThreadLocal.get()
+      val descriptionNotAlreadySet = previousDescription == null
+      if (descriptionNotAlreadySet) {
+        descriptionThreadLocal.set(description)
+      } else {
+        SharkLog.d { "Test description already set, you should remove the TestDescriptionHolder rule." }
+      }
+      try {
+        base.evaluate()
+      } finally {
+        if (descriptionNotAlreadySet) {
           val currentDescription = descriptionThreadLocal.get()
           check(currentDescription != null) {
-            "Test description should not be null after the rule evaluates. " +
-              "Did you add the TestDescriptionHolder rule twice by mistake?"
+            "Test description should not be null after the rule evaluates."
           }
           descriptionThreadLocal.remove()
         }
