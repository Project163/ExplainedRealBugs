diff --git a/leakcanary-android-core/src/main/AndroidManifest.xml b/leakcanary-android-core/src/main/AndroidManifest.xml
index 4b39f91c3..9e055c2e4 100644
--- a/leakcanary-android-core/src/main/AndroidManifest.xml
+++ b/leakcanary-android-core/src/main/AndroidManifest.xml
@@ -68,5 +68,8 @@
         android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         android:theme="@style/leak_canary_Theme.Transparent"
         />
+
+    <receiver android:name="leakcanary.internal.NotificationReceiver" />
+
   </application>
 </manifest>
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
index f5cbc7481..8851bb17b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -35,14 +35,6 @@ import leakcanary.Exclusion.ExclusionType.ThreadExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.internal.HeapDumpTrigger
-import leakcanary.internal.LeakCanaryUtils.HUAWEI
-import leakcanary.internal.LeakCanaryUtils.LENOVO
-import leakcanary.internal.LeakCanaryUtils.LG
-import leakcanary.internal.LeakCanaryUtils.MEIZU
-import leakcanary.internal.LeakCanaryUtils.MOTOROLA
-import leakcanary.internal.LeakCanaryUtils.NVIDIA
-import leakcanary.internal.LeakCanaryUtils.SAMSUNG
-import leakcanary.internal.LeakCanaryUtils.VIVO
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
 import java.lang.ref.WeakReference
@@ -1228,3 +1220,12 @@ enum class AndroidExcludedRefs {
 
   }
 }
+
+private const val SAMSUNG = "samsung"
+private const val MOTOROLA = "motorola"
+private const val LENOVO = "LENOVO"
+private const val LG = "LGE"
+private const val NVIDIA = "NVIDIA"
+private const val MEIZU = "Meizu"
+private const val HUAWEI = "HUAWEI"
+private const val VIVO = "vivo"
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
index b660d2756..78dee99ba 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
@@ -1,11 +1,11 @@
 package leakcanary
 
 import android.app.Application
-import android.app.PendingIntent
 import com.squareup.leakcanary.core.R
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.Notifications
+import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -74,18 +74,11 @@ object DefaultAnalysisResultListener : (Application, HeapAnalysis) -> Unit {
     )
 
     val contentText = application.getString(R.string.leak_canary_notification_message)
-    showNotification(application, pendingIntent, contentTitle, contentText)
-  }
 
-  private fun showNotification(
-    application: Application,
-    pendingIntent: PendingIntent?,
-    contentTitle: String,
-    contentText: String
-  ) {
-    val notificationId = 0x00F06D
-    LeakCanaryUtils.showNotification(
-        application, contentTitle, contentText, pendingIntent, notificationId
+    Notifications.showNotification(
+        application, contentTitle, contentText, pendingIntent,
+        R.id.leak_canary_notification_analysis_result,
+        LEAKCANARY_RESULT
     )
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 23322336f..ada08e8f0 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -8,6 +8,24 @@ object LeakCanary {
 
   data class Config(
     val dumpHeap: Boolean = true,
+    /**
+     * The debugger can create temporary memory leaks (for instance if a thread is blocked on a
+     * breakpoint) so by default LeakCanary does not dump the heap when the debugger is attached.
+     */
+    val dumpHeapWhenDebugging: Boolean = false,
+    /**
+     * When the app is visible, LeakCanary will wait for at least
+     * [retainedVisibleThreshold] retained instances before dumping the heap. Dumping the heap
+     * freezes the UI and can be frustrating for developers who are trying to work. This is
+     * especially frustrating as the Android Framework has a number of leaks that cannot easily
+     * be fixed.
+     *
+     * When the app becomes invisible, LeakCanary dumps the heap immediately.
+     *
+     * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
+     * bothering developers as much but it could miss some leaks.
+     */
+    val retainedVisibleThreshold: Int = 5,
     val exclusionsFactory: (HprofParser) -> List<Exclusion> = exclusionsFactory(
         AndroidExcludedRefs.appDefaults
     ),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt
deleted file mode 100644
index 0caf07d68..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidDebuggerControl.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.os.Debug
-
-internal class AndroidDebuggerControl : DebuggerControl {
-  override val isDebuggerAttached: Boolean
-    get() = Debug.isDebuggerConnected()
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 3ed5f7f95..c2de9a420 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -25,13 +25,13 @@ import android.content.Context
 import android.os.Debug
 import android.os.Handler
 import android.os.Looper
-import android.os.SystemClock
 import android.view.Gravity
 import android.view.LayoutInflater
 import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
 
@@ -60,8 +60,7 @@ internal class AndroidHeapDumper(
     })
   }
 
-  override// Explicitly checking for named null.
-  fun dumpHeap(): File? {
+  override fun dumpHeap(): File? {
     val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return null
 
     val waitingForToast = FutureResult<Toast?>()
@@ -72,15 +71,15 @@ internal class AndroidHeapDumper(
       return null
     }
 
-    val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
-    val builder = Notification.Builder(context)
-        .setContentTitle(dumpingHeap)
-    val notification = LeakCanaryUtils.buildNotification(context, builder)
     val notificationManager =
       context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
-    val notificationId = SystemClock.uptimeMillis()
-        .toInt()
-    notificationManager.notify(notificationId, notification)
+    if (Notifications.canShowNotification) {
+      val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping)
+      val builder = Notification.Builder(context)
+          .setContentTitle(dumpingHeap)
+      val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW)
+      notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification)
+    }
 
     val toast = waitingForToast.get()
 
@@ -93,7 +92,7 @@ internal class AndroidHeapDumper(
       null
     } finally {
       cancelToast(toast)
-      notificationManager.cancel(notificationId)
+      notificationManager.cancel(R.id.leak_canary_notification_dumping_heap)
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
index 00595886d..ae001bb24 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DebuggerControl.kt
@@ -15,18 +15,15 @@
  */
 package leakcanary.internal
 
+import android.os.Debug
+
 /**
  * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
  * An attached debugger might retain references and create false positives.
  */
-internal interface DebuggerControl {
+internal object DebuggerControl {
 
   val isDebuggerAttached: Boolean
+    get() = Debug.isDebuggerConnected()
 
-  companion object {
-    val NONE: DebuggerControl = object : DebuggerControl {
-      override val isDebuggerAttached: Boolean
-        get() = false
-    }
-  }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
index d27575dce..9208e0d1e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
@@ -19,15 +19,14 @@ import android.app.IntentService
 import android.app.Notification
 import android.content.Intent
 import android.os.IBinder
-import android.os.SystemClock
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 
 abstract class ForegroundService(
   name: String,
-  private val notificationContentTitleResId: Int
+  private val notificationContentTitleResId: Int,
+  private val notificationId: Int
 ) : IntentService(name) {
-  private val notificationId: Int = SystemClock.uptimeMillis()
-      .toInt()
 
   override fun onCreate() {
     super.onCreate()
@@ -48,7 +47,7 @@ abstract class ForegroundService(
         .setContentText(contentText)
         .setProgress(max, progress, indeterminate)
     val notification =
-      LeakCanaryUtils.buildNotification(this, builder)
+      Notifications.buildNotification(this, builder, LEAKCANARY_LOW)
     startForeground(notificationId, notification)
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index df7d1a000..da8d9c91d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -31,7 +31,8 @@ import java.io.File
  */
 internal class HeapAnalyzerService : ForegroundService(
     HeapAnalyzerService::class.java.simpleName,
-    R.string.leak_canary_notification_analysing
+    R.string.leak_canary_notification_analysing,
+    R.id.leak_canary_notification_analyzing_heap
 ), AnalyzerProgressListener {
 
   override fun onHandleIntentInForeground(intent: Intent?) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index f99058c32..ca2188159 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -1,65 +1,80 @@
 package leakcanary.internal
 
 import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
 import android.os.Handler
 import android.os.SystemClock
+import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.HeapDumpMemoryStore
 import leakcanary.LeakCanary.Config
+import leakcanary.LeakSentry
 import leakcanary.RefWatcher
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
-  private val debuggerControl: DebuggerControl,
   private val refWatcher: RefWatcher,
-  private val leakDirectoryProvider: LeakDirectoryProvider,
   private val gcTrigger: GcTrigger,
   private val heapDumper: HeapDumper,
   private val configProvider: () -> Config
 ) {
 
-  @Volatile
-  var applicationVisible = false
+  private val notificationManager
+    get() =
+      application.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+
+  private val applicationVisible
+    get() = applicationInvisibleAt == -1L
+
+  /**
+   * When the app becomes invisible, we don't dump the heap immediately. Instead we wait in case
+   * the app came back to the foreground, but also to wait for new leaks that typically occur on
+   * back press (activity destroy).
+   */
+  private val applicationInvisibleLessThanWatchPeriod: Boolean
+    get() {
+      val applicationInvisibleAt = applicationInvisibleAt
+      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < LeakSentry.config.watchDurationMillis
+    }
 
-  fun registerToVisibilityChanges() {
-    application.registerVisibilityListener { applicationVisible ->
-      this.applicationVisible = applicationVisible
-      if (!applicationVisible) {
-        scheduleTick("app became invisible")
-      }
+  @Volatile
+  private var applicationInvisibleAt = -1L
+
+  fun onApplicationVisibilityChanged(applicationVisible: Boolean) {
+    if (applicationVisible) {
+      applicationInvisibleAt = -1L
+    } else {
+      applicationInvisibleAt = SystemClock.uptimeMillis()
+      scheduleRetainedInstanceCheck("app became invisible", LeakSentry.config.watchDurationMillis)
     }
   }
 
   fun onReferenceRetained() {
-    scheduleTick("found new reference retained")
+    scheduleRetainedInstanceCheck("found new instance retained")
   }
 
-  private fun tick(reason: String) {
-    CanaryLog.d("Checking retained references because %s", reason)
+  private fun checkRetainedInstances(reason: String) {
+    CanaryLog.d("Checking retained instances because %s", reason)
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
       return
     }
 
-    val minLeaks = if (applicationVisible) MIN_LEAKS_WHEN_VISIBLE else MIN_LEAKS_WHEN_NOT_VISIBLE
     var retainedKeys = refWatcher.retainedKeys
-    if (retainedKeys.size < minLeaks) {
-      // No need to scheduleTick, new refs always schedule one.
-      CanaryLog.d(
-          "Found %d retained references, which is less than the min of %d", retainedKeys.size,
-          minLeaks
-      )
-      return
-    }
 
-    if (debuggerControl.isDebuggerAttached) {
-      scheduleTick(
-          "debugger was attached",
-          WAIT_FOR_DEBUG_MILLIS
-      )
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
+
+    if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      showRetainedCountWithDebuggerAttached(retainedKeys.size)
+      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
       CanaryLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
           WAIT_FOR_DEBUG_MILLIS
@@ -70,60 +85,163 @@ internal class HeapDumpTrigger(
     gcTrigger.runGc()
 
     retainedKeys = refWatcher.retainedKeys
-    if (retainedKeys.size < minLeaks) {
-      CanaryLog.d(
-          "Found %d retained references after GC, which is less than the min of %d",
-          retainedKeys.size,
-          minLeaks
-      )
-      return
-    }
+
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
     HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
 
-    CanaryLog.d(
-        "Found %d retained references, dumping the heap", retainedKeys.size
-    )
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
     HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    dismissNotification()
     val heapDumpFile = heapDumper.dumpHeap()
-
     if (heapDumpFile == null) {
-      CanaryLog.d(
-          "Failed to dump heap, will retry in %d ms",
-          WAIT_FOR_HEAP_DUMPER_MILLIS
-      )
-      scheduleTick(
-          "failed to dump heap",
-          WAIT_FOR_HEAP_DUMPER_MILLIS
-      )
+      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      showRetainedCountWithHeapDumpFailed(retainedKeys.size)
       return
     }
+
     refWatcher.removeRetainedKeys(retainedKeys)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
 
-  private fun scheduleTick(reason: String) {
+  fun onDumpHeapReceived() {
+    backgroundHandler.post {
+      gcTrigger.runGc()
+      val retainedKeys = refWatcher.retainedKeys
+      if (retainedKeys.isEmpty()) {
+        CanaryLog.d("No retained instances after GC")
+        val builder = Notification.Builder(application)
+            .setContentTitle(
+                application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+            )
+            .setContentText(
+                application.getString(
+                    R.string.leak_canary_notification_no_retained_instance_content
+                )
+            )
+            .setAutoCancel(true)
+            .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+        val notification =
+          Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+        notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+        return@post
+      }
+
+      HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
+
+      CanaryLog.d("Dumping the heap because user tapped notification")
+
+      val heapDumpFile = heapDumper.dumpHeap()
+      if (heapDumpFile == null) {
+        CanaryLog.d("Failed to dump heap")
+        showRetainedCountWithHeapDumpFailed(retainedKeys.size)
+        return@post
+      }
+
+      refWatcher.removeRetainedKeys(retainedKeys)
+      HeapAnalyzerService.runAnalysis(application, heapDumpFile)
+    }
+  }
+
+  private fun checkRetainedCount(
+    retainedKeys: Set<String>,
+    retainedVisibleThreshold: Int
+  ): Boolean {
+    if (retainedKeys.isEmpty()) {
+      CanaryLog.d("No retained instances")
+      dismissNotification()
+      return true
+    }
+
+    if (retainedKeys.size < retainedVisibleThreshold) {
+      if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
+        CanaryLog.d(
+            "Found %d retained instances, which is less than the visible threshold of %d",
+            retainedKeys.size,
+            retainedVisibleThreshold
+        )
+        showRetainedCountBelowThresholdNotification(retainedKeys.size, retainedVisibleThreshold)
+        // If the application just because invisible, a check is already scheduled.
+        if (applicationVisible) {
+          scheduleRetainedInstanceCheck(
+              "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+          )
+        }
+        return true
+      }
+    }
+    return false
+  }
+
+  private fun scheduleRetainedInstanceCheck(reason: String) {
     backgroundHandler.post {
-      tick(reason)
+      checkRetainedInstances(reason)
     }
   }
 
-  private fun scheduleTick(
+  private fun scheduleRetainedInstanceCheck(
     reason: String,
     delayMillis: Long
   ) {
     backgroundHandler.postDelayed({
-      tick(reason)
+      checkRetainedInstances(reason)
     }, delayMillis)
   }
 
+  private fun showRetainedCountBelowThresholdNotification(
+    instanceCount: Int,
+    retainedVisibleThreshold: Int
+  ) {
+    showRetainedCountNotification(
+        instanceCount, application.getString(
+        R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
+    )
+    )
+  }
+
+  private fun showRetainedCountWithDebuggerAttached(instanceCount: Int) {
+    showRetainedCountNotification(
+        instanceCount,
+        application.getString(R.string.leak_canary_notification_retained_debugger_attached)
+    )
+  }
+
+  private fun showRetainedCountWithHeapDumpFailed(instanceCount: Int) {
+    showRetainedCountNotification(
+        instanceCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
+    )
+  }
+
+  private fun showRetainedCountNotification(
+    instanceCount: Int,
+    contentText: String
+  ) {
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(application)
+        .setContentTitle(
+            application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
+        )
+        .setContentText(contentText)
+        .setAutoCancel(true)
+        .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+  }
+
+  private fun dismissNotification() {
+    notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
+  }
+
   companion object {
     const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
-    const val WAIT_FOR_DEBUG_MILLIS = 20_000L
-    const val WAIT_FOR_HEAP_DUMPER_MILLIS = 5_000L
-    const val MIN_LEAKS_WHEN_VISIBLE = 5
-    const val MIN_LEAKS_WHEN_NOT_VISIBLE = 1
+    private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
+    private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
+    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 5_000L
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 8b80a1839..17ba32b55 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -24,13 +24,17 @@ internal object InternalLeakCanary : LeakSentryListener {
   private lateinit var heapDumpTrigger: HeapDumpTrigger
 
   lateinit var application: Application
+  @Volatile
+  var applicationVisible = false
+    private set
+
+  val leakDirectoryProvider: LeakDirectoryProvider by lazy {
+    LeakDirectoryProvider(application)
+  }
 
   override fun onLeakSentryInstalled(application: Application) {
     this.application = application
-    val debuggerControl = AndroidDebuggerControl()
 
-    val leakDirectoryProvider =
-      LeakCanaryUtils.getLeakDirectoryProvider(application)
     val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
 
     val gcTrigger = GcTrigger.Default
@@ -42,11 +46,12 @@ internal object InternalLeakCanary : LeakSentryListener {
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-        application, backgroundHandler, debuggerControl, LeakSentry.refWatcher,
-        leakDirectoryProvider, gcTrigger, heapDumper, configProvider
+        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
     )
-    heapDumpTrigger.registerToVisibilityChanges()
-
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
+    }
     addDynamicShortcut(application)
   }
 
@@ -160,4 +165,10 @@ internal object InternalLeakCanary : LeakSentryListener {
       heapDumpTrigger.onReferenceRetained()
     }
   }
+
+  fun onDumpHeapReceived() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onDumpHeapReceived()
+    }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt
deleted file mode 100644
index f4f5f7fe8..000000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryUtils.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.annotation.SuppressLint
-import android.app.ActivityManager
-import android.app.Notification
-import android.app.NotificationChannel
-import android.app.NotificationManager
-import android.app.PendingIntent
-import android.app.Service
-import android.content.ComponentName
-import android.content.Context
-import android.content.pm.PackageInfo
-import android.content.pm.PackageManager
-import android.content.pm.PackageManager.GET_SERVICES
-import android.content.pm.ServiceInfo
-import android.os.Build.VERSION.SDK_INT
-import android.os.Build.VERSION_CODES.JELLY_BEAN
-import android.os.Build.VERSION_CODES.O
-import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
-
-internal object LeakCanaryUtils {
-
-  const val SAMSUNG = "samsung"
-  const val MOTOROLA = "motorola"
-  const val LENOVO = "LENOVO"
-  const val LG = "LGE"
-  const val NVIDIA = "NVIDIA"
-  const val MEIZU = "Meizu"
-  const val HUAWEI = "HUAWEI"
-  const val VIVO = "vivo"
-
-  // Lint is wrong about what constitutes a leak. Ironic.
-  @SuppressLint("StaticFieldLeak")
-  @Volatile private var leakDirectoryProvider: LeakDirectoryProvider? = null
-
-  fun getLeakDirectoryProvider(context: Context): LeakDirectoryProvider {
-    var leakDirectoryProvider =
-      leakDirectoryProvider
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = LeakDirectoryProvider(context)
-    }
-    return leakDirectoryProvider
-  }
-
-  private const val NOTIFICATION_CHANNEL_ID = "leakcanary"
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name.  */
-  fun classSimpleName(className: String): String {
-    val separator = className.lastIndexOf('.')
-    return if (separator == -1) {
-      className
-    } else {
-      className.substring(separator + 1)
-    }
-  }
-
-  fun showNotification(
-    context: Context,
-    contentTitle: CharSequence,
-    contentText: CharSequence,
-    pendingIntent: PendingIntent?,
-    notificationId: Int
-  ) {
-    val builder = Notification.Builder(context)
-        .setContentText(contentText)
-        .setContentTitle(contentTitle)
-        .setAutoCancel(true)
-        .setContentIntent(pendingIntent)
-
-    val notification =
-      buildNotification(context, builder)
-    val notificationManager =
-      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
-    try {
-      notificationManager.notify(notificationId, notification)
-    } catch (ignored: SecurityException) {
-      // https://github.com/square/leakcanary/issues/1197
-    }
-  }
-
-  fun buildNotification(
-    context: Context,
-    builder: Notification.Builder
-  ): Notification {
-    builder.setSmallIcon(R.drawable.leak_canary_notification)
-        .setWhen(System.currentTimeMillis())
-        .setOnlyAlertOnce(true)
-
-    if (SDK_INT >= O) {
-      val notificationManager =
-        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
-      var notificationChannel: NotificationChannel? =
-        notificationManager.getNotificationChannel(
-            NOTIFICATION_CHANNEL_ID
-        )
-      if (notificationChannel == null) {
-        val channelName = context.getString(R.string.leak_canary_notification_channel)
-        notificationChannel = NotificationChannel(
-            NOTIFICATION_CHANNEL_ID, channelName,
-            NotificationManager.IMPORTANCE_DEFAULT
-        )
-        notificationManager.createNotificationChannel(notificationChannel)
-      }
-      builder.setChannelId(
-          NOTIFICATION_CHANNEL_ID
-      )
-    }
-
-    return if (SDK_INT < JELLY_BEAN) {
-      builder.notification
-    } else {
-      builder.build()
-    }
-  }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index 8f8bba91d..6e06d3a55 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -25,6 +25,7 @@ import android.os.Environment
 import android.os.Environment.DIRECTORY_DOWNLOADS
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
+import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.io.FilenameFilter
 import java.util.ArrayList
@@ -145,8 +146,9 @@ internal class LeakDirectoryProvider @JvmOverloads constructor(
     val contentText =
       context.getString(R.string.leak_canary_permission_notification_text, packageName)
 
-    LeakCanaryUtils.showNotification(
-        context, contentTitle, contentText, pendingIntent, 0x00_DA_BEEF
+    Notifications.showNotification(
+        context, contentTitle, contentText, pendingIntent,
+        R.id.leak_canary_notification_write_permission, LEAKCANARY_LOW
     )
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
new file mode 100644
index 000000000..f7e7f86cc
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
@@ -0,0 +1,45 @@
+package leakcanary.internal
+
+import android.app.PendingIntent
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import leakcanary.CanaryLog
+import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
+import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+
+internal class NotificationReceiver : BroadcastReceiver() {
+
+  enum class Action {
+    DUMP_HEAP,
+    CANCEL_NOTIFICATION
+  }
+
+  override fun onReceive(
+    context: Context,
+    intent: Intent
+  ) {
+    when (intent.action) {
+      DUMP_HEAP.name -> {
+        InternalLeakCanary.onDumpHeapReceived()
+      }
+      CANCEL_NOTIFICATION.name -> {
+        // Do nothing, the notification has auto cancel true.
+      }
+      else -> {
+        CanaryLog.d("NotificationReceiver received unknown intent action for $intent")
+      }
+    }
+  }
+
+  companion object {
+    fun pendingIntent(
+      context: Context,
+      action: Action
+    ): PendingIntent {
+      val broadcastIntent = Intent(context, NotificationReceiver::class.java)
+      broadcastIntent.action = action.name
+      return PendingIntent.getBroadcast(context, 0, broadcastIntent, 0)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
new file mode 100644
index 000000000..677f7f48c
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -0,0 +1,16 @@
+package leakcanary.internal
+
+import androidx.annotation.StringRes
+import com.squareup.leakcanary.core.R
+
+enum class NotificationType(@StringRes val nameResId: Int, val importance: Int) {
+  LEAKCANARY_LOW(
+      R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
+  ),
+  LEAKCANARY_RESULT(
+      R.string.leak_canary_notification_channel_result, IMPORTANCE_DEFAULT
+  );
+}
+
+private const val IMPORTANCE_LOW = 2
+private const val IMPORTANCE_DEFAULT = 3
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
new file mode 100644
index 000000000..3559c1537
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.content.Context
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.O
+import com.squareup.leakcanary.core.R
+
+internal object Notifications {
+
+  val canShowNotification: Boolean
+    get() = canShowBackgroundNotifications || InternalLeakCanary.applicationVisible
+
+  private val canShowBackgroundNotifications = if (SDK_INT >= O) {
+    // Instants apps cannot show background notifications
+    // See https://github.com/square/leakcanary/issues/1197
+    !InternalLeakCanary.application.packageManager.isInstantApp
+  } else true
+
+  fun showNotification(
+    context: Context,
+    contentTitle: CharSequence,
+    contentText: CharSequence,
+    pendingIntent: PendingIntent?,
+    notificationId: Int,
+    type: NotificationType
+  ) {
+    if (!canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(context)
+        .setContentText(contentText)
+        .setContentTitle(contentTitle)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent)
+
+    val notification =
+      buildNotification(context, builder, type)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    notificationManager.notify(notificationId, notification)
+  }
+
+  fun buildNotification(
+    context: Context,
+    builder: Notification.Builder,
+    type: NotificationType
+  ): Notification {
+    builder.setSmallIcon(R.drawable.leak_canary_notification)
+        .setWhen(System.currentTimeMillis())
+
+    if (SDK_INT >= O) {
+      val notificationManager =
+        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+      var notificationChannel: NotificationChannel? =
+        notificationManager.getNotificationChannel(type.name)
+      if (notificationChannel == null) {
+        val channelName = context.getString(type.nameResId)
+        notificationChannel =
+          NotificationChannel(type.name, channelName, type.importance)
+        notificationManager.createNotificationChannel(notificationChannel)
+      }
+      builder.setChannelId(type.name)
+    }
+
+    return if (SDK_INT < JELLY_BEAN) {
+      builder.notification
+    } else {
+      builder.build()
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
index 2758e4fd8..bd1ba2e00 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -9,7 +9,7 @@ import android.os.Bundle
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
 import leakcanary.internal.HeapAnalyzerService
-import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.activity.db.Db
 import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.navigation.NavigatingActivity
@@ -64,7 +64,7 @@ internal class LeakActivity : NavigatingActivity() {
       contentResolver.openFileDescriptor(fileUri, "r")
           ?.fileDescriptor?.let { fileDescriptor ->
         val inputStream = FileInputStream(fileDescriptor)
-        LeakCanaryUtils.getLeakDirectoryProvider(this)
+        InternalLeakCanary.leakDirectoryProvider
             .newHeapDumpFile()
             ?.let { target ->
               inputStream.use { input ->
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 18dd1ee7e..6fb91079a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -9,7 +9,7 @@ import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.Serializables
-import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.leakingInstances
 import leakcanary.toByteArray
 import org.intellij.lang.annotations.Language
@@ -137,7 +137,7 @@ internal object HeapAnalysisTable {
     db: SQLiteDatabase,
     context: Context
   ) {
-    val leakDirectoryProvider = LeakCanaryUtils.getLeakDirectoryProvider(context)
+    val leakDirectoryProvider = InternalLeakCanary.leakDirectoryProvider
     AsyncTask.SERIAL_EXECUTOR.execute { leakDirectoryProvider.clearLeakDirectory() }
     db.inTransaction {
       db.delete("heap_analysis", null, null)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index 8152b7d29..7311da165 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -14,7 +14,7 @@ import android.widget.Toast
 import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
-import leakcanary.internal.LeakCanaryUtils
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
@@ -67,7 +67,7 @@ internal class RenderHeapDumpScreen(
       onCreateOptionsMenu { menu ->
         menu.add(R.string.leak_canary_options_menu_generate_hq_bitmap)
             .setOnMenuItemClickListener {
-              val leakDirectoryProvider = LeakCanaryUtils.getLeakDirectoryProvider(activity)
+              val leakDirectoryProvider = InternalLeakCanary.leakDirectoryProvider
               if (!leakDirectoryProvider.hasStoragePermission()) {
                 Toast.makeText(
                     context,
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index 20f43f20c..4695b3ed4 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -24,7 +24,6 @@
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
   <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
   <string name="leak_canary_notification_analysing">Analysiere Heap Dump</string>
-  <string name="leak_canary_notification_channel">LeakCanary</string>
   <string name="leak_canary_notification_dumping">Sichere Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary ist beschäftigt.</string>
   <string name="leak_canary_notification_message">Für mehr Details, hier klicken</string>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
new file mode 100644
index 000000000..85f0bcd3b
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <item type="id" name="leak_canary_notification_write_permission" />
+  <item type="id" name="leak_canary_notification_analysis_result" />
+  <item type="id" name="leak_canary_notification_dumping_heap" />
+  <item type="id" name="leak_canary_notification_analyzing_heap" />
+  <item type="id" name="leak_canary_notification_retained_instances" />
+  <item type="id" name="leak_canary_notification_no_retained_instance" />
+</resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index a5ad966c6..8787cb4a0 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -27,10 +27,17 @@
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
   <string name="leak_canary_loading_title">Loading…</string>
   <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
-  <string name="leak_canary_notification_channel">LeakCanary</string>
+  <string name="leak_canary_notification_channel_low">LeakCanary Low Priority</string>
+  <string name="leak_canary_notification_channel_result">LeakCanary Result</string>
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_no_retained_instance_title">No retained instances</string>
+  <string name="leak_canary_notification_no_retained_instance_content">All instances cleared after LeakCanary ran GC</string>
+  <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
+  <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
+  <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained instances</string>
   <string name="leak_canary_share_leak">Share Info</string>
   <string name="leak_canary_share_heap_dump">Share Heap Dump</string>
   <string name="leak_canary_share_with">Share with…</string>
