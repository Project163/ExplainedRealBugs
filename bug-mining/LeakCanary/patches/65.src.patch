diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0116785de..1881e5aef 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,7 @@
 ## Future release
 
 * [#1153](https://github.com/square/leakcanary/issues/1153) `LeakCanary.isInAnalyzerProcess` now correctly returns true in the analyzer process prior to any first leak (could be triggered by starting the leak result activity).
+* [#1158](https://github.com/square/leakcanary/issues/1158) Stopped enabling DisplayLeakActivity when not using DisplayLeakService.
 
 
 ## Version 1.6.2 (2018-10-16)
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index bc72bb116..43816beb3 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -19,6 +19,7 @@ public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRef
   private final Context context;
   private boolean watchActivities = true;
   private boolean watchFragments = true;
+  private boolean enableDisplayLeakActivity = false;
 
   AndroidRefWatcherBuilder(@NonNull Context context) {
     this.context = context.getApplicationContext();
@@ -30,6 +31,7 @@ public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRef
    */
   public @NonNull AndroidRefWatcherBuilder listenerServiceClass(
       @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);
     return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
   }
 
@@ -88,7 +90,9 @@ public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRef
     }
     RefWatcher refWatcher = build();
     if (refWatcher != DISABLED) {
-      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
+      if (enableDisplayLeakActivity) {
+        LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
+      }
       if (watchActivities) {
         ActivityRefWatcher.install(context, refWatcher);
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 8f4ab8d74..87e2e8841 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -62,9 +62,9 @@ public final class LeakCanary {
 
   /**
    * Blocking inter process call that enables the {@link DisplayLeakActivity}. When you first
-   * install the app, {@link DisplayLeakActivity} is disabled by default and will only be enabled
-   * once a potential leak has been found and the analysis starts. You can call this method to
-   * enable {@link DisplayLeakActivity} before any potential leak has been detected.
+   * install the app, {@link DisplayLeakActivity} is enabled by default if LeakCanary is configured
+   * to use {@link DisplayLeakService}. You can call this method to enable
+   * {@link DisplayLeakActivity} manually.
    */
   public static void enableDisplayLeakActivity(@NonNull Context context) {
     LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);
