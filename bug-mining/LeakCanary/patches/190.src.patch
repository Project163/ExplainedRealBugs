diff --git a/shark-android/src/test/java/shark/HprofIOPerfTest.kt b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
index 8fd3e0d5b..17bcd5ce6 100644
--- a/shark-android/src/test/java/shark/HprofIOPerfTest.kt
+++ b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
@@ -181,7 +181,7 @@ class HprofIOPerfTest {
     .isEqualTo(
             listOf(
                 25710, 42.0, 1749038,
-                45140, 36.0, 2510709
+                27152, 44.0, 1807225
             )
         )
   }
@@ -200,7 +200,7 @@ class HprofIOPerfTest {
         .isEqualTo(
             listOf(
                 22667, 40.0, 2554813,
-                86068, 36.0, 4883521
+                22813, 40.0, 2555657
             )
         )
   }
@@ -219,7 +219,7 @@ class HprofIOPerfTest {
         .isEqualTo(
             listOf(
                 16079, 36.0, 1012375,
-                29612, 32.0, 1483387
+                16151, 36.0, 1012852
             )
         )
   }
diff --git a/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt b/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt
index a784b1fc9..e85341c90 100644
--- a/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt
+++ b/shark-android/src/test/java/shark/HprofRetainedHeapPerfTest.kt
@@ -1,13 +1,14 @@
 package shark
 
 import org.assertj.core.api.AbstractIntegerAssert
+import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
 import shark.AndroidReferenceMatchers.FINALIZER_WATCHDOG_DAEMON
 import shark.AndroidReferenceMatchers.REFERENCES
-import shark.HeapObject.HeapClass
+import shark.GcRoot.ThreadObject
 import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.EXTRACTING_METADATA
@@ -16,24 +17,37 @@ import shark.OnAnalysisProgressListener.Step.FINDING_RETAINED_OBJECTS
 import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
 import java.io.File
 import java.util.EnumSet
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit.SECONDS
 import kotlin.math.absoluteValue
 import kotlin.reflect.KClass
 
+private const val ANALYSIS_THREAD = "analysis"
+
 class HprofRetainedHeapPerfTest {
 
   @get:Rule
   var tmpFolder = TemporaryFolder()
 
-  @Test fun `freeze retained memory when indexing leak_asynctask_o`() {
-    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+  lateinit var folder: File
 
-    val baselineHeap = dumpHeap("baseline")
+  @Before
+  fun setUp() {
+    folder = tmpFolder.newFolder()
+  }
 
-    val hprofIndex = indexRecordsOf(hprofFile)
+  @Test fun `freeze retained memory when indexing leak_asynctask_o`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
 
-    val heapWithIndex = dumpHeapRetaining(hprofIndex)
+    val (baselineHeap, heapWithIndex) = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      val hprofIndex = indexRecordsOf(hprofFile)
+      val heapWithIndex = dumpHeapRetaining(hprofIndex)
+      baselineHeap to heapWithIndex
+    }
 
-    val retained = heapWithIndex.retainedHeap() - baselineHeap.retainedHeap()
+    val retained =
+      heapWithIndex.retainedHeap(ANALYSIS_THREAD) - baselineHeap.retainedHeap(ANALYSIS_THREAD)
 
     assertThat(retained).isEqualTo(4.8 MB +-5 % margin)
   }
@@ -41,13 +55,15 @@ class HprofRetainedHeapPerfTest {
   @Test fun `freeze retained memory when indexing leak_asynctask_m`() {
     val hprofFile = "leak_asynctask_m.hprof".classpathFile()
 
-    val baselineHeap = dumpHeap("baseline")
-
-    val hprofIndex = indexRecordsOf(hprofFile)
-
-    val heapWithIndex = dumpHeapRetaining(hprofIndex)
+    val (baselineHeap, heapWithIndex) = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      val hprofIndex = indexRecordsOf(hprofFile)
+      val heapWithIndex = dumpHeapRetaining(hprofIndex)
+      baselineHeap to heapWithIndex
+    }
 
-    val retained = heapWithIndex.retainedHeap() - baselineHeap.retainedHeap()
+    val retained =
+      heapWithIndex.retainedHeap(ANALYSIS_THREAD) - baselineHeap.retainedHeap(ANALYSIS_THREAD)
 
     assertThat(retained).isEqualTo(8.2 MB +-5 % margin)
   }
@@ -58,33 +74,42 @@ class HprofRetainedHeapPerfTest {
     val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener { step ->
       stepsToHeapDumpFile[step] = dumpHeap(step.name)
     })
-    val baselineHeap = dumpHeap("baseline")
-
-    heapAnalyzer.analyze(
-        heapDumpFile = hprofFile,
-        leakingObjectFinder = FilteringLeakingObjectFinder(
-            AndroidObjectInspectors.appLeakingObjectFilters
-        ),
-        referenceMatchers = AndroidReferenceMatchers.appDefaults,
-        objectInspectors = AndroidObjectInspectors.appDefaults,
-        metadataExtractor = AndroidMetadataExtractor,
-        computeRetainedHeapSize = true
-    ).apply {
-      check(this is HeapAnalysisSuccess) {
-        "Expected success not $this"
+
+    // matchers contain large description strings which depending on the VM maybe be reachable
+    // only via matchers (=> thread locals), and otherwise also statically by the enum class that
+    // defines them. So we create a reference outside of the working thread to exclude them from
+    // the retained count and avoid a varying count.
+    val matchers = AndroidReferenceMatchers.appDefaults
+    val baselineHeap = runInThread(ANALYSIS_THREAD) {
+      val baselineHeap = dumpHeap("baseline")
+      heapAnalyzer.analyze(
+          heapDumpFile = hprofFile,
+          leakingObjectFinder = FilteringLeakingObjectFinder(
+              AndroidObjectInspectors.appLeakingObjectFilters
+          ),
+          referenceMatchers = matchers,
+          objectInspectors = AndroidObjectInspectors.appDefaults,
+          metadataExtractor = AndroidMetadataExtractor,
+          computeRetainedHeapSize = true
+      ).apply {
+        check(this is HeapAnalysisSuccess) {
+          "Expected success not $this"
+        }
       }
+      baselineHeap
     }
 
-    val retainedBeforeAnalysis = baselineHeap.retainedHeap()
-    val retained =
-      stepsToHeapDumpFile.mapValues { it.value.retainedHeap() - retainedBeforeAnalysis }
-
-    assertThat(retained after PARSING_HEAP_DUMP).isEqualTo(4.9 MB +-10 % margin)
-    assertThat(retained after EXTRACTING_METADATA).isEqualTo(4.9 MB +-10 % margin)
-    assertThat(retained after FINDING_RETAINED_OBJECTS).isEqualTo(5 MB +-10 % margin)
-    assertThat(retained after FINDING_PATHS_TO_RETAINED_OBJECTS).isEqualTo(5.4 MB +-10 % margin)
-    assertThat(retained after COMPUTING_NATIVE_RETAINED_SIZE).isEqualTo(5.4 MB +-10 % margin)
-    assertThat(retained after COMPUTING_RETAINED_SIZE).isEqualTo(5.4 MB +-10 % margin)
+    val retainedBeforeAnalysis = baselineHeap.retainedHeap(ANALYSIS_THREAD)
+    val retained = stepsToHeapDumpFile.mapValues {
+      it.value.retainedHeap(ANALYSIS_THREAD) - retainedBeforeAnalysis
+    }
+
+    assertThat(retained after PARSING_HEAP_DUMP).isEqualTo(4.70 MB +-5 % margin)
+    assertThat(retained after EXTRACTING_METADATA).isEqualTo(4.75 MB +-5 % margin)
+    assertThat(retained after FINDING_RETAINED_OBJECTS).isEqualTo(4.85 MB +-5 % margin)
+    assertThat(retained after FINDING_PATHS_TO_RETAINED_OBJECTS).isEqualTo(6.25 MB +-5 % margin)
+    assertThat(retained after COMPUTING_NATIVE_RETAINED_SIZE).isEqualTo(6.26 MB +-5 % margin)
+    assertThat(retained after COMPUTING_RETAINED_SIZE).isEqualTo(5.18 MB +-5 % margin)
   }
 
   private fun indexRecordsOf(hprofFile: File): HprofIndex {
@@ -102,12 +127,33 @@ class HprofRetainedHeapPerfTest {
   }
 
   private fun dumpHeap(name: String): File {
-    val testHprofFile = File(tmpFolder.newFolder(), "$name.hprof")
-    if (testHprofFile.exists()) {
-      testHprofFile.delete()
+    // Dumps the heap in a separate thread to avoid java locals being added to the count of
+    // bytes retained by this thread.
+    return runInThread("heap dump") {
+      val testHprofFile = File(folder, "$name.hprof")
+      if (testHprofFile.exists()) {
+        testHprofFile.delete()
+      }
+      JvmTestHeapDumper.dumpHeap(testHprofFile.absolutePath)
+      testHprofFile
+    }
+  }
+
+  private fun <T : Any> runInThread(
+    threadName: String,
+    work: () -> T
+  ): T {
+    lateinit var result: T
+    val latch = CountDownLatch(1)
+    Thread {
+      result = work()
+      latch.countDown()
+    }.apply {
+      name = threadName
+      start()
     }
-    JvmTestHeapDumper.dumpHeap(testHprofFile.absolutePath)
-    return testHprofFile
+    check(latch.await(30, SECONDS))
+    return result
   }
 
   private infix fun Map<OnAnalysisProgressListener.Step, Bytes>.after(step: OnAnalysisProgressListener.Step): Bytes {
@@ -121,29 +167,26 @@ class HprofRetainedHeapPerfTest {
     error("No step in $this after $step")
   }
 
-  private fun File.retainedHeap(): Bytes {
+  private fun File.retainedHeap(threadName: String): Bytes {
     val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
     val analysis = heapAnalyzer.analyze(
         heapDumpFile = this,
         referenceMatchers = buildKnownReferences(EnumSet.of(REFERENCES, FINALIZER_WATCHDOG_DAEMON)),
         leakingObjectFinder = LeakingObjectFinder { graph ->
-          graph.gcRoots
-              .filter { gcRoot ->
-                graph.objectExists(gcRoot.id)
-              }.filter {
-                graph.findObjectById(it.id) !is HeapClass
-              }.map { it.id }.toSet()
+          setOf(graph.gcRoots.first { gcRoot ->
+            gcRoot is ThreadObject &&
+                graph.objectExists(gcRoot.id) &&
+                graph.findObjectById(gcRoot.id)
+                    .asInstance!!["java.lang.Thread", "name"]!!
+                    .value.readAsJavaString() == threadName
+          }.id)
         },
         computeRetainedHeapSize = true
     )
     check(analysis is HeapAnalysisSuccess) {
       "Expected success not $analysis"
     }
-    return analysis.applicationLeaks
-        .flatMap { it.leakTraces }
-        .sumBy {
-          it.retainedHeapByteSize!!
-        }.bytes
+    return analysis.applicationLeaks.single().leakTraces.single().retainedHeapByteSize!!.bytes
   }
 
   class BytesAssert(bytes: Bytes) : AbstractIntegerAssert<BytesAssert>(
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index 77a3148ff..fa5e76a74 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -27,7 +27,7 @@ class LegacyHprofTest {
             "LeakCanary version" to "Unknown"
         )
     )
-    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(193439)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(193431)
   }
 
   @Test fun androidM() {
@@ -37,14 +37,14 @@ class LegacyHprofTest {
     val leak = analysis.applicationLeaks[0].leakTraces.first()
     assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
     assertThat(leak.gcRootType).isEqualTo(GcRootType.STICKY_CLASS)
-    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(175112)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(49584)
   }
 
   @Test fun gcRootReferencesUnknownObject() {
     val analysis = analyzeHprof("gcroot_unknown_object.hprof")
 
     assertThat(analysis.applicationLeaks).hasSize(2)
-    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(5315935)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(5306170)
   }
 
   @Test fun androidMStripped() {
@@ -73,7 +73,7 @@ class LegacyHprofTest {
     assertThat(analysis.applicationLeaks).hasSize(1)
     val leak = analysis.applicationLeaks[0].leakTraces.first()
     assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(210802)
+    assertThat(analysis.allLeaks.sumBy { it.totalRetainedHeapByteSize!! }).isEqualTo(211038)
   }
 
   private enum class WRAPS_ACTIVITY {
diff --git a/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt b/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt
new file mode 100644
index 000000000..732ea0bcc
--- /dev/null
+++ b/shark-android/src/test/java/shark/StringPathFinderOptimTest.kt
@@ -0,0 +1,54 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import java.io.File
+
+/**
+ * Our path finding algorithm skips going through the content of strings to avoid unnecessary reads.
+ * We add back the corresponding size when computing the shallow size of retained strings,
+ * however that only works if those byte arrays aren't reachable through other references.
+ * If they were, this could either inflate the retained size number (byte array should not be
+ * considered retained) or deflate it (byte array counted twice when reached from two retained
+ * instances).
+ */
+class StringPathFinderOptimTest {
+
+  @Test fun `String#value not reachable on Android O`() {
+    val hprofFile = "leak_asynctask_o.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(0)
+  }
+
+  @Test fun `String#value not reachable on Android M`() {
+    val hprofFile = "leak_asynctask_m.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(0)
+  }
+
+  @Test fun `String#value only reachable for String#ASCII pre Android M`() {
+    val hprofFile = "leak_asynctask_pre_m.hprof".classpathFile()
+    val analysis = findStringContent(hprofFile)
+    assertThat(analysis.allLeaks.count()).isEqualTo(1)
+    val path = analysis.applicationLeaks.first().leakTraces.first()
+    assertThat(path.referencePath.first().referenceName).isEqualTo("ASCII")
+  }
+
+  private fun findStringContent(hprofFile: File): HeapAnalysisSuccess {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+        heapDumpFile = hprofFile,
+        leakingObjectFinder = LeakingObjectFinder { graph ->
+          graph.findClassByName("java.lang.String")!!.instances.map { instance ->
+            instance["java.lang.String", "value"]?.value?.asNonNullObjectId!!
+          }.toSet()
+        },
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        computeRetainedHeapSize = true,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        metadataExtractor = AndroidMetadataExtractor
+    )
+    println(analysis)
+    return analysis as HeapAnalysisSuccess
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
index ad9c00460..7ffaabee0 100644
--- a/shark-graph/src/main/java/shark/HeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -10,10 +10,22 @@ import shark.HeapObject.HeapPrimitiveArray
  */
 interface HeapGraph {
   val identifierByteSize: Int
+
   /**
    * In memory store that can be used to store objects this [HeapGraph] instance.
    */
   val context: GraphContext
+
+  val objectCount: Int
+
+  val classCount: Int
+
+  val instanceCount: Int
+
+  val objectArrayCount: Int
+
+  val primitiveArrayCount: Int
+
   /**
    * All GC roots which type matches types known to this heap graph and which point to non null
    * references. You can retrieve the object that a GC Root points to by calling [findObjectById]
@@ -21,30 +33,35 @@ interface HeapGraph {
    * GC roots can point to objects that don't exist in the heap dump.
    */
   val gcRoots: List<GcRoot>
+
   /**
    * Sequence of all objects in the heap dump.
    *
    * This sequence does not trigger any IO reads.
    */
   val objects: Sequence<HeapObject>
+
   /**
    * Sequence of all classes in the heap dump.
    *
    * This sequence does not trigger any IO reads.
    */
   val classes: Sequence<HeapClass>
+
   /**
    * Sequence of all instances in the heap dump.
    *
    * This sequence does not trigger any IO reads.
    */
   val instances: Sequence<HeapInstance>
+
   /**
    * Sequence of all object arrays in the heap dump.
    *
    * This sequence does not trigger any IO reads.
    */
   val objectArrays: Sequence<HeapObjectArray>
+
   /**
    * Sequence of all primitive arrays in the heap dump.
    *
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
index ec3a57f85..08a4fc67d 100644
--- a/shark-graph/src/main/java/shark/HeapObject.kt
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -96,6 +96,15 @@ sealed class HeapObject {
     val instanceByteSize: Int
       get() = indexedObject.instanceSize
 
+    /**
+     * The total byte size for the record of this class in the heap dump. This gives an
+     * approximation of the shallow size of the class in memory.
+     */
+    val recordSize: Int
+      get() {
+        return indexedObject.recordSize.toInt()
+      }
+
     /**
      * Returns true if this class is an array class, and false otherwise.
      */
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index f8378755a..a6c85e593 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -43,6 +43,21 @@ class HprofHeapGraph internal constructor(
 
   override val context = GraphContext()
 
+  override val objectCount: Int
+    get() = classCount + instanceCount + objectArrayCount + primitiveArrayCount
+
+  override val classCount: Int
+    get() = index.classCount
+
+  override val instanceCount: Int
+    get() = index.instanceCount
+
+  override val objectArrayCount: Int
+    get() = index.objectArrayCount
+
+  override val primitiveArrayCount: Int
+    get() = index.primitiveArrayCount
+
   override val gcRoots: List<GcRoot>
     get() = index.gcRoots()
 
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index 97f9346b3..b4fa7479c 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -49,6 +49,18 @@ internal class HprofInMemoryIndex private constructor(
   private val useForwardSlashClassPackageSeparator: Boolean
 ) {
 
+  val classCount: Int
+    get() = classIndex.size
+
+  val instanceCount: Int
+    get() = instanceIndex.size
+
+  val objectArrayCount: Int
+    get() = objectArrayIndex.size
+
+  val primitiveArrayCount: Int
+    get() = primitiveArrayIndex.size
+
   fun fieldName(
     classId: Long,
     id: Long
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
index dd87d3288..284baf99c 100644
--- a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -19,7 +19,7 @@ internal class SortedBytesMap(
   private val bytesPerKey = if (longIdentifiers) 8 else 4
   private val bytesPerEntry = bytesPerKey + bytesPerValue
 
-  private val size = sortedEntries.size / bytesPerEntry
+  val size = sortedEntries.size / bytesPerEntry
 
   operator fun get(key: Long): ByteSubArray? {
     val keyIndex = binarySearch(key)
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index a8afb1c94..de32445cd 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -35,20 +35,20 @@ import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.EXTRACTING_METADATA
 import shark.OnAnalysisProgressListener.Step.FINDING_RETAINED_OBJECTS
+import shark.OnAnalysisProgressListener.Step.INSPECTING_OBJECTS
 import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.internal.AndroidNativeSizeMapper
+import shark.internal.DominatorTree
 import shark.internal.PathFinder
-import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
 import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ShallowSizeCalculator
 import shark.internal.createSHA1Hash
-import shark.internal.hppcshark.LongLongScatterMap.ForEachCallback
-import shark.internal.hppcshark.LongScatterSet
 import shark.internal.lastSegment
 import java.io.File
 import java.util.ArrayList
-import java.util.LinkedHashMap
 import java.util.concurrent.TimeUnit.NANOSECONDS
 
 /**
@@ -166,14 +166,23 @@ class HeapAnalyzer constructor(
 
     SharkLog.d { "Found ${leakingObjectIds.size} retained objects" }
 
-    return buildLeakTraces(pathFindingResults)
+    val shortestPaths =
+      deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
+
+    val inspectedObjectsByPath = inspectObjects(shortestPaths)
+
+    val retainedSizes =
+      if (pathFindingResults.dominatorTree != null) {
+        computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)
+      } else {
+        null
+      }
+    return buildLeakTraces(shortestPaths, inspectedObjectsByPath, retainedSizes)
   }
 
   internal sealed class TrieNode {
     abstract val objectId: Long
 
-    var retainedSize = 0
-
     class ParentNode(override val objectId: Long) : TrieNode() {
       val children = mutableMapOf<Long, TrieNode>()
       override fun toString(): String {
@@ -189,12 +198,11 @@ class HeapAnalyzer constructor(
   }
 
   private fun deduplicateShortestPaths(
-    inputPathResults: List<ReferencePathNode>,
-    retainedSizes: List<Int>?
-  ): List<Pair<ReferencePathNode, Int>> {
+    inputPathResults: List<ReferencePathNode>
+  ): List<ShortestPath> {
     val rootTrieNode = ParentNode(0)
 
-    inputPathResults.forEachIndexed { index, pathNode ->
+    inputPathResults.forEach { pathNode ->
       // Go through the linked list of nodes and build the reverse list of instances from
       // root to leaking.
       val path = mutableListOf<Long>()
@@ -204,44 +212,57 @@ class HeapAnalyzer constructor(
         leakNode = leakNode.parent
       }
       path.add(0, leakNode.objectId)
-      updateTrie(pathNode, path, 0, rootTrieNode, retainedSizes?.get(index) ?: 0)
+      updateTrie(pathNode, path, 0, rootTrieNode)
     }
 
-    val outputPathResults = mutableListOf<Pair<ReferencePathNode, Int>>()
+    val outputPathResults = mutableListOf<ReferencePathNode>()
     findResultsInTrie(rootTrieNode, outputPathResults)
-    return outputPathResults
+
+    if (outputPathResults.size != inputPathResults.size) {
+      SharkLog.d {
+        "Found ${inputPathResults.size} paths to retained objects," +
+            " down to ${outputPathResults.size} after removing duplicated paths"
+      }
+    } else {
+      SharkLog.d { "Found ${outputPathResults.size} paths to retained objects" }
+    }
+
+    return outputPathResults.map { retainedObjectNode ->
+      val shortestChildPath = mutableListOf<ChildNode>()
+      var node = retainedObjectNode
+      while (node is ChildNode) {
+        shortestChildPath.add(0, node)
+        node = node.parent
+      }
+      val rootNode = node as RootNode
+      ShortestPath(rootNode, shortestChildPath)
+    }
   }
 
   private fun updateTrie(
     pathNode: ReferencePathNode,
     path: List<Long>,
     pathIndex: Int,
-    parentNode: ParentNode,
-    retainedSize: Int
+    parentNode: ParentNode
   ) {
     val objectId = path[pathIndex]
     if (pathIndex == path.lastIndex) {
-      // Replace any preexisting children, this is shorter.
-      val previousRetained = parentNode.children[objectId]?.retainedSize ?: 0
-      parentNode.children[objectId] = LeafNode(objectId, pathNode).apply {
-        this.retainedSize = previousRetained + retainedSize
-      }
+      parentNode.children[objectId] = LeafNode(objectId, pathNode)
     } else {
       val childNode = parentNode.children[objectId] ?: {
         val newChildNode = ParentNode(objectId)
         parentNode.children[objectId] = newChildNode
         newChildNode
       }()
-      childNode.retainedSize += retainedSize
       if (childNode is ParentNode) {
-        updateTrie(pathNode, path, pathIndex + 1, childNode, retainedSize)
+        updateTrie(pathNode, path, pathIndex + 1, childNode)
       }
     }
   }
 
   private fun findResultsInTrie(
     parentNode: ParentNode,
-    outputPathResults: MutableList<Pair<ReferencePathNode, Int>>
+    outputPathResults: MutableList<ReferencePathNode>
   ) {
     parentNode.children.values.forEach { childNode ->
       when (childNode) {
@@ -249,178 +270,62 @@ class HeapAnalyzer constructor(
           findResultsInTrie(childNode, outputPathResults)
         }
         is LeafNode -> {
-          outputPathResults += childNode.pathNode to childNode.retainedSize
+          outputPathResults += childNode.pathNode
         }
       }
     }
   }
 
-  private fun FindLeakInput.computeRetainedSizes(pathFindingResults: PathFindingResults): List<Int>? {
-    if (!computeRetainedHeapSize) {
-      return null
-    }
-    val pathsToLeakingInstances = pathFindingResults.pathsToLeakingObjects
-    val dominatedInstances = pathFindingResults.dominatedObjectIds
-
-    listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
-
-    // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
-    val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
-    // Doc from perflib:
-    // Native allocations can be identified by looking at instances of
-    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
-    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
-    // CleanerThunk.
-    //
-    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
-    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
-    // the CleanerThunk. The hprof does not include the native bytes pointed to.
-
-    graph.instances
-        .filter { it.instanceClassName == "sun.misc.Cleaner" }
-        .forEach { cleaner ->
-          val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
-          val thunkId = thunkField?.value?.asNonNullObjectId
-          val referentId =
-            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
-          if (thunkId != null && referentId != null) {
-            val thunkRecord = thunkField.value.asObject
-            if (thunkRecord is HeapInstance && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
-              val allocationRegistryIdField =
-                thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
-              if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
-                val allocationRegistryRecord = allocationRegistryIdField.value.asObject
-                if (allocationRegistryRecord is HeapInstance && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
-                  var nativeSize = nativeSizes.getValue(referentId)
-                  nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
-                      ?: 0
-                  nativeSizes[referentId] = nativeSize
-                }
-              }
-            }
-          }
-        }
-
-    listener.onAnalysisProgress(COMPUTING_RETAINED_SIZE)
-
-    val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
-
-    // Update sizeByDominator to include self size for leaking instances
-    val leakingInstanceIds = LongScatterSet()
-    pathsToLeakingInstances.forEach { pathNode ->
-      val leakingInstanceObjectId = pathNode.objectId
-      leakingInstanceIds.add(leakingInstanceObjectId)
-
-      val shallowSize = when (val heapObject = graph.findObjectById(leakingInstanceObjectId)) {
-        is HeapInstance -> heapObject.byteSize
-        is HeapObjectArray -> heapObject.readByteSize()
-        is HeapPrimitiveArray -> heapObject.readByteSize()
-        is HeapClass -> throw IllegalStateException(
-            "Unexpected class record $heapObject"
-        )
-      }
-      var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
-
-      retainedSize += shallowSize
-      sizeByDominator[leakingInstanceObjectId] = retainedSize
-    }
-
-    // Compute the size of each dominated instance and add to dominator
-    dominatedInstances.forEach(object : ForEachCallback {
-      override fun onEntry(
-        instanceId: Long,
-        dominatorId: Long
-      ) {
-        // Avoid double reporting as leakingInstanceIds sizes will move up to the root dominator
-        // We do a separate pass for leakingInstanceIds right before because those are sometimes
-        // part of dominators and sometmes not.
-        if (instanceId !in leakingInstanceIds) {
-          val currentSize = sizeByDominator.getValue(dominatorId)
-          val nativeSize = nativeSizes.getValue(instanceId)
-          val shallowSize = when (val heapObject = graph.findObjectById(instanceId)) {
-            is HeapInstance -> heapObject.byteSize
-            is HeapObjectArray -> heapObject.readByteSize()
-            is HeapPrimitiveArray -> heapObject.readByteSize()
-            is HeapClass -> throw IllegalStateException(
-                "Unexpected class record $heapObject"
-            )
-          }
-          sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
-        }
-      }
-    })
-
-    // Move retained sizes from dominated leaking instance to dominators leaking instances.
-    // Keep doing this until nothing moves.
-    var sizedMoved: Boolean
-    do {
-      sizedMoved = false
-      pathsToLeakingInstances.map { it.objectId }
-          .forEach { leakingInstanceId ->
-            val dominatorSlot = dominatedInstances.getSlot(leakingInstanceId)
-            if (dominatorSlot != -1) {
-              val dominator = dominatedInstances.getSlotValue(dominatorSlot)
-              val retainedSize = sizeByDominator.getValue(leakingInstanceId)
-              if (retainedSize > 0) {
-                sizeByDominator[leakingInstanceId] = 0
-                val dominatorRetainedSize = sizeByDominator.getValue(dominator)
-                sizeByDominator[dominator] = retainedSize + dominatorRetainedSize
-                sizedMoved = true
-              }
-            }
-          }
-    } while (sizedMoved)
-    dominatedInstances.release()
-    return pathsToLeakingInstances.map { pathNode ->
-      sizeByDominator[pathNode.objectId]!!
-    }
+  internal class ShortestPath(
+    val root: RootNode,
+    val childPath: List<ChildNode>
+  ) {
+    fun asList() = listOf(root) + childPath
   }
 
-  private fun FindLeakInput.buildLeakTraces(pathFindingResults: PathFindingResults): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
-    val retainedSizes = computeRetainedSizes(pathFindingResults)
-
+  private fun buildLeakTraces(
+    shortestPaths: List<ShortestPath>,
+    inspectedObjectsByPath: List<List<InspectedObject>>,
+    retainedSizes: Map<Long, Int>?
+  ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
     listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
 
     val applicationLeaksMap = mutableMapOf<String, MutableList<LeakTrace>>()
     val libraryLeaksMap =
       mutableMapOf<String, Pair<LibraryLeakReferenceMatcher, MutableList<LeakTrace>>>()
 
-    val deduplicatedPaths =
-      deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects, retainedSizes)
+    shortestPaths.forEachIndexed { pathIndex, shortestPath ->
+      val inspectedObjects = inspectedObjectsByPath[pathIndex]
 
-    if (deduplicatedPaths.size != pathFindingResults.pathsToLeakingObjects.size) {
-      SharkLog.d {
-        "Found ${pathFindingResults.pathsToLeakingObjects.size} paths to retained objects," +
-            " down to ${deduplicatedPaths.size} after removing duplicated paths"
-      }
-    } else {
-      SharkLog.d { "Found ${deduplicatedPaths.size} paths to retained objects" }
-    }
-
-    deduplicatedPaths.forEachIndexed { index, (retainedObjectNode, retainedSize) ->
-      val shortestChildPath = mutableListOf<ChildNode>()
-      var node = retainedObjectNode
-      while (node is ChildNode) {
-        shortestChildPath.add(0, node)
-        node = node.parent
+      val firstLeakingRetainedSize = if (retainedSizes != null) {
+        var lastRetainedSize: Int? = null
+        inspectedObjects.forEach { inspectedObject ->
+          val retainedSize = retainedSizes[inspectedObject.heapObject.objectId]
+          if (retainedSize != null) {
+            inspectedObject.labels += "Retaining $retainedSize bytes"
+            lastRetainedSize = retainedSize
+          }
+        }
+        lastRetainedSize
+      } else {
+        null
       }
-      val rootNode = node as RootNode
-
-      val shortestPath = listOf(rootNode) + shortestChildPath
+      val leakTraceObjects = buildLeakTraceObjects(inspectedObjects)
 
-      val leakTraceObjects = buildLeakTraceObjects(objectInspectors, shortestPath)
-
-      val referencePath = buildReferencePath(shortestChildPath, leakTraceObjects)
+      val referencePath = buildReferencePath(shortestPath.childPath, leakTraceObjects)
 
       val leakTrace = LeakTrace(
-          gcRootType = GcRootType.fromGcRoot(rootNode.gcRoot),
+          gcRootType = GcRootType.fromGcRoot(shortestPath.root.gcRoot),
           referencePath = referencePath,
           leakingObject = leakTraceObjects.last(),
-          retainedHeapByteSize = if (retainedSizes == null) null else retainedSize
+          retainedHeapByteSize = firstLeakingRetainedSize
       )
 
-      val firstLibraryLeakNode =
-        shortestPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
+      val firstLibraryLeakNode = if (shortestPath.root is LibraryLeakNode) {
+        shortestPath.root
+      } else {
+        shortestPath.childPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
+      }
 
       if (firstLibraryLeakNode != null) {
         val matcher = firstLibraryLeakNode.matcher
@@ -442,36 +347,61 @@ class HeapAnalyzer constructor(
     return applicationLeaks to libraryLeaks
   }
 
-  private fun FindLeakInput.buildLeakTraceObjects(
-    objectInspectors: List<ObjectInspector>,
-    shortestPath: List<ReferencePathNode>
-  ): List<LeakTraceObject> {
-    val pathHeapObjects = shortestPath.map { graph.findObjectById(it.objectId) }
-
-    val leakReporters = pathHeapObjects.map { heapObject ->
-      ObjectReporter(heapObject)
+  private fun FindLeakInput.inspectObjects(shortestPaths: List<ShortestPath>): List<List<InspectedObject>> {
+    listener.onAnalysisProgress(INSPECTING_OBJECTS)
+
+    val leakReportersByPath = shortestPaths.map { path ->
+      val pathList = path.asList()
+      pathList
+          .mapIndexed { index, node ->
+            val reporter = ObjectReporter(heapObject = graph.findObjectById(node.objectId))
+            val nextNode = if (index + 1 < pathList.size) pathList[index + 1] else null
+            if (nextNode is LibraryLeakNode) {
+              reporter.labels += "Library leak match: ${nextNode.matcher.pattern}"
+            }
+            reporter
+          }
     }
 
-    // Looping on inspectors first to get more cache hits.
     objectInspectors.forEach { inspector ->
-      leakReporters.forEach { reporter ->
-        inspector.inspect(reporter)
+      leakReportersByPath.forEach { leakReporters ->
+        leakReporters.forEach { reporter ->
+          inspector.inspect(reporter)
+        }
       }
     }
 
-    val leakStatuses = computeLeakStatuses(leakReporters)
+    return leakReportersByPath.map { leakReporters ->
+      computeLeakStatuses(leakReporters)
+    }
+  }
 
-    return pathHeapObjects.mapIndexed { index, heapObject ->
-      val leakReporter = leakReporters[index]
-      val nextNode = if (index + 1 < shortestPath.size) {
-        shortestPath[index + 1]
-      } else {
-        null
-      }
-      if (nextNode is LibraryLeakNode) {
-        leakReporter.labels += "Library leak match: ${nextNode.matcher.pattern}"
-      }
-      val (leakStatus, leakStatusReason) = leakStatuses[index]
+  private fun FindLeakInput.computeRetainedSizes(
+    inspectedObjectsByPath: List<List<InspectedObject>>,
+    dominatorTree: DominatorTree
+  ): Map<Long, Int>? {
+    val nodeObjectIds = inspectedObjectsByPath.flatMap { inspectedObjects ->
+      val unknownLeakingObjectIds =
+        inspectedObjects.filter { it.leakingStatus == UNKNOWN }.map { it.heapObject.objectId }
+      val firstLeakingObjectId =
+        inspectedObjects.first { it.leakingStatus == LEAKING }.heapObject.objectId
+      unknownLeakingObjectIds + firstLeakingObjectId
+    }.toSet()
+    listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
+    val nativeSizeMapper = AndroidNativeSizeMapper(graph)
+    val nativeSizes = nativeSizeMapper.mapNativeSizes()
+    listener.onAnalysisProgress(COMPUTING_RETAINED_SIZE)
+    val shallowSizeCalculator = ShallowSizeCalculator(graph)
+    return dominatorTree.computeRetainedSizes(nodeObjectIds) { objectId ->
+      val nativeSize = nativeSizes[objectId] ?: 0
+      val shallowSize = shallowSizeCalculator.computeShallowSize(objectId)
+      nativeSize + shallowSize
+    }
+  }
+
+  private fun buildLeakTraceObjects(inspectedObjects: List<InspectedObject>): List<LeakTraceObject> {
+    return inspectedObjects.map { inspectedObject ->
+      val heapObject = inspectedObject.heapObject
       val className = recordClassName(heapObject)
 
       val objectType = if (heapObject is HeapClass) {
@@ -485,9 +415,9 @@ class HeapAnalyzer constructor(
       LeakTraceObject(
           type = objectType,
           className = className,
-          labels = leakReporter.labels,
-          leakingStatus = leakStatus,
-          leakingStatusReason = leakStatusReason
+          labels = inspectedObject.labels,
+          leakingStatus = inspectedObject.leakingStatus,
+          leakingStatusReason = inspectedObject.leakingStatusReason
       )
     }
   }
@@ -505,7 +435,14 @@ class HeapAnalyzer constructor(
     }
   }
 
-  private fun computeLeakStatuses(leakReporters: List<ObjectReporter>): List<Pair<LeakingStatus, String>> {
+  internal class InspectedObject(
+    val heapObject: HeapObject,
+    val leakingStatus: LeakingStatus,
+    val leakingStatusReason: String,
+    val labels: MutableSet<String>
+  )
+
+  private fun computeLeakStatuses(leakReporters: List<ObjectReporter>): List<InspectedObject> {
     val lastElementIndex = leakReporters.size - 1
 
     var lastNotLeakingElementIndex = -1
@@ -578,7 +515,13 @@ class HeapAnalyzer constructor(
         }
       }
     }
-    return leakStatuses
+
+    return leakReporters.mapIndexed { index, objectReporter ->
+      val (leakingStatus, leakingStatusReason) = leakStatuses[index]
+      InspectedObject(
+          objectReporter.heapObject, leakingStatus, leakingStatusReason, objectReporter.labels
+      )
+    }
   }
 
   private fun resolveStatus(
diff --git a/shark/src/main/java/shark/OnAnalysisProgressListener.kt b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
index cdd3f7e79..b481e7553 100644
--- a/shark/src/main/java/shark/OnAnalysisProgressListener.kt
+++ b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
@@ -12,6 +12,7 @@ interface OnAnalysisProgressListener {
     FINDING_RETAINED_OBJECTS,
     FINDING_PATHS_TO_RETAINED_OBJECTS,
     FINDING_DOMINATORS,
+    INSPECTING_OBJECTS,
     COMPUTING_NATIVE_RETAINED_SIZE,
     COMPUTING_RETAINED_SIZE,
     BUILDING_LEAK_TRACES,
diff --git a/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt b/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt
new file mode 100644
index 000000000..2e8d77516
--- /dev/null
+++ b/shark/src/main/java/shark/internal/AndroidNativeSizeMapper.kt
@@ -0,0 +1,48 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapInstance
+
+internal class AndroidNativeSizeMapper(private val graph: HeapGraph) {
+
+  /**
+   * Returns a map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
+   */
+  fun mapNativeSizes(): Map<Long, Int> {
+    val nativeSizes = mutableMapOf<Long, Int>()
+    // Doc from perflib:
+    // Native allocations can be identified by looking at instances of
+    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
+    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
+    // CleanerThunk.
+    //
+    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
+    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
+    // the CleanerThunk. The hprof does not include the native bytes pointed to.
+    graph.findClassByName("sun.misc.Cleaner")?.let { cleanerClass ->
+      cleanerClass.directInstances.forEach { cleaner ->
+        val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+        val thunkId = thunkField?.value?.asNonNullObjectId
+        val referentId =
+          cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
+        if (thunkId != null && referentId != null) {
+          val thunkRecord = thunkField.value.asObject
+          if (thunkRecord is HeapInstance && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+            val allocationRegistryIdField =
+              thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+            if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+              val allocationRegistryRecord = allocationRegistryIdField.value.asObject
+              if (allocationRegistryRecord is HeapInstance && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                var nativeSize = nativeSizes[referentId] ?: 0
+                nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                    ?: 0
+                nativeSizes[referentId] = nativeSize
+              }
+            }
+          }
+        }
+      }
+    }
+    return nativeSizes
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/DominatorTree.kt b/shark/src/main/java/shark/internal/DominatorTree.kt
new file mode 100644
index 000000000..c938a5234
--- /dev/null
+++ b/shark/src/main/java/shark/internal/DominatorTree.kt
@@ -0,0 +1,156 @@
+package shark.internal
+
+import shark.ValueHolder
+import shark.internal.hppcshark.LongLongScatterMap
+import shark.internal.hppcshark.LongLongScatterMap.ForEachCallback
+import shark.internal.hppcshark.LongScatterSet
+
+internal class DominatorTree(expectedElements: Int = 4) {
+
+  /**
+   * Map of objects to their dominator.
+   *
+   * If an object is dominated by more than one GC root then its dominator is set to
+   * [ValueHolder.NULL_REFERENCE].
+   */
+  private val dominated = LongLongScatterMap(expectedElements)
+
+  /**
+   * Records that [objectId] is a root.
+   */
+  fun updateDominatedAsRoot(objectId: Long): Boolean {
+    return updateDominated(objectId, ValueHolder.NULL_REFERENCE)
+  }
+
+  /**
+   * Records that [objectId] can be reached through [parentObjectId], updating the dominator for
+   * [objectId] to be either [parentObjectId] if [objectId] has no known dominator and otherwise to
+   * the Lowest Common Dominator between [parentObjectId] and the previously determined dominator
+   * for [objectId].
+   *
+   * [parentObjectId] should already have been added via [updateDominatedAsRoot]. Failing to do
+   * that will throw [IllegalStateException] on future calls.
+   *
+   * This implementation is optimized with the assumption that the graph is visited as a breadth
+   * first search, so when objectId already has a known dominator then its dominator path is
+   * shorter than the dominator path of [parentObjectId].
+   *
+   * @return true if [objectId] already had a known dominator, false otherwise.
+   */
+  fun updateDominated(
+    objectId: Long,
+    parentObjectId: Long
+  ): Boolean {
+    val dominatedSlot = dominated.getSlot(objectId)
+
+    val hasDominator = dominatedSlot != -1
+
+    if (!hasDominator || parentObjectId == ValueHolder.NULL_REFERENCE) {
+      dominated[objectId] = parentObjectId
+    } else {
+      val currentDominator = dominated.getSlotValue(dominatedSlot)
+      if (currentDominator != ValueHolder.NULL_REFERENCE) {
+        // We're looking for the Lowest Common Dominator between currentDominator and
+        // parentObjectId. We know that currentDominator likely has a shorter dominator path than
+        // parentObjectId since we're exploring the graph with a breadth first search. So we build
+        // a temporary hash set for the dominator path of currentDominator (since it's smaller)
+        // and then go through the dominator path of parentObjectId checking if any id exists
+        // in that hash set.
+        // Once we find either a common dominator or none, we update the map accordingly
+        val currentDominators = LongScatterSet()
+        var dominator = currentDominator
+        while (dominator != ValueHolder.NULL_REFERENCE) {
+          currentDominators.add(dominator)
+          val nextDominatorSlot = dominated.getSlot(dominator)
+          if (nextDominatorSlot == -1) {
+            throw IllegalStateException(
+                "Did not find dominator for $dominator when going through the dominator chain for $currentDominator: $currentDominators"
+            )
+          } else {
+            dominator = dominated.getSlotValue(nextDominatorSlot)
+          }
+        }
+        dominator = parentObjectId
+        while (dominator != ValueHolder.NULL_REFERENCE) {
+          if (dominator in currentDominators) {
+            break
+          }
+          val nextDominatorSlot = dominated.getSlot(dominator)
+          if (nextDominatorSlot == -1) {
+            throw IllegalStateException(
+                "Did not find dominator for $dominator when going through the dominator chain for $parentObjectId"
+            )
+          } else {
+            dominator = dominated.getSlotValue(nextDominatorSlot)
+          }
+        }
+        dominated[objectId] = dominator
+      }
+    }
+    return hasDominator
+  }
+
+  /**
+   * Computes the size retained by [retainedObjectIds] using the dominator tree built using
+   * [updateDominatedAsRoot]. The shallow size of each object is provided by [computeSize].
+   * @return a map of object id to retained size.
+   */
+  fun computeRetainedSizes(
+    retainedObjectIds: Set<Long>,
+    computeSize: (Long) -> Int
+  ): Map<Long, Int> {
+    val nodeRetainedSizes = mutableMapOf<Long, Int>()
+    retainedObjectIds.forEach { objectId ->
+      nodeRetainedSizes[objectId] = 0
+    }
+
+    dominated.forEach(object : ForEachCallback {
+      override fun onEntry(
+        key: Long,
+        value: Long
+      ) {
+        // lazy computing of instance size
+        var instanceSize = -1
+
+        // If the entry is a node, add its size to nodeRetainedSizes
+        nodeRetainedSizes[key]?.let { currentRetainedSize ->
+          instanceSize = computeSize(key)
+          nodeRetainedSizes[key] = currentRetainedSize + instanceSize
+        }
+
+        if (value != ValueHolder.NULL_REFERENCE) {
+          var dominator = value
+          val dominatedByNextNode = mutableListOf(key)
+          while (dominator != ValueHolder.NULL_REFERENCE) {
+            // If dominator is a node
+            if (nodeRetainedSizes.containsKey(dominator)) {
+              // Update dominator for all objects in the dominator path so far to directly point
+              // to it. We're compressing the dominator path to make this iteration faster and
+              // faster as we go through each entry.
+              dominatedByNextNode.forEach { objectId ->
+                dominated[objectId] = dominator
+              }
+              if (instanceSize == -1) {
+                instanceSize = computeSize(key)
+              }
+              // Update retained size for that node
+              val currentRetainedSize = nodeRetainedSizes.getValue(dominator)
+              nodeRetainedSizes[dominator] = currentRetainedSize + instanceSize
+              dominatedByNextNode.clear()
+            } else {
+              dominatedByNextNode += dominator
+            }
+            dominator = dominated[dominator]
+          }
+          // Update all dominator for all objects found in the dominator path after the last node
+          dominatedByNextNode.forEach { objectId ->
+            dominated[objectId] = ValueHolder.NULL_REFERENCE
+          }
+        }
+      }
+    })
+    dominated.release()
+
+    return nodeRetainedSizes
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index 67cc37723..2e59f348b 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -49,16 +49,17 @@ import shark.ReferencePattern
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.NativeGlobalVariablePattern
 import shark.ReferencePattern.StaticFieldPattern
-import shark.SharkLog
 import shark.ValueHolder
 import shark.ValueHolder.ReferenceHolder
+import shark.internal.PathFinder.VisitTracker.Dominated
+import shark.internal.PathFinder.VisitTracker.Visited
+import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.ChildNode.LibraryLeakChildNode
 import shark.internal.ReferencePathNode.ChildNode.NormalNode
 import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
 import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
 import shark.internal.ReferencePathNode.RootNode.NormalRootNode
-import shark.internal.hppcshark.LongLongScatterMap
 import shark.internal.hppcshark.LongObjectPair
 import shark.internal.hppcshark.LongScatterSet
 import shark.internal.hppcshark.to
@@ -81,14 +82,55 @@ internal class PathFinder(
 
   class PathFindingResults(
     val pathsToLeakingObjects: List<ReferencePathNode>,
-    val dominatedObjectIds: LongLongScatterMap
+    val dominatorTree: DominatorTree?
   )
 
+  sealed class VisitTracker {
+
+    abstract fun visited(
+      objectId: Long,
+      parentObjectId: Long
+    ): Boolean
+
+    class Dominated(expectedElements: Int) : VisitTracker() {
+      /**
+       * Tracks visited objecs and their dominator.
+       * If an object is not in [dominatorTree] then it hasn't been enqueued yet.
+       * If an object is in [dominatorTree] but not in [State.toVisitSet] nor [State.toVisitLastSet]
+       * then it has already been dequeued.
+       *
+       * If an object is dominated by more than one GC root then its dominator is set to
+       * [ValueHolder.NULL_REFERENCE].
+       */
+      val dominatorTree = DominatorTree(expectedElements)
+      override fun visited(
+        objectId: Long,
+        parentObjectId: Long
+      ): Boolean {
+        return dominatorTree.updateDominated(objectId, parentObjectId)
+      }
+    }
+
+    class Visited(expectedElements: Int) : VisitTracker() {
+      /**
+       * Set of visited objects.
+       */
+      private val visitedSet = LongScatterSet(expectedElements)
+      override fun visited(
+        objectId: Long,
+        parentObjectId: Long
+      ): Boolean {
+        return !visitedSet.add(objectId)
+      }
+    }
+  }
+
   private class State(
     val leakingObjectIds: LongScatterSet,
     val sizeOfObjectInstances: Int,
     val computeRetainedHeapSize: Boolean,
-    val javaLangObjectId: Long
+    val javaLangObjectId: Long,
+    estimatedVisitedObjects: Int
   ) {
 
     /** Set of objects to visit */
@@ -106,19 +148,15 @@ internal class PathFinder(
     val toVisitSet = LongScatterSet()
     val toVisitLastSet = LongScatterSet()
 
-    val visitedSet = LongScatterSet()
-
-    /**
-     * Map of objects to their leaking dominator.
-     * If an object has been added to [toVisitSet] or [visitedSet] and is missing from
-     * [dominatedObjectIds] then it's considered "undomitable" ie it is dominated by gc roots
-     * and cannot be dominated by a leaking object.
-     */
-    val dominatedObjectIds = LongLongScatterMap()
-
     val queuesNotEmpty: Boolean
       get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
 
+    val visitTracker = if (computeRetainedHeapSize) {
+      Dominated(estimatedVisitedObjects)
+    } else {
+      Visited(estimatedVisitedObjects)
+    }
+
     /**
      * A marker for when we're done exploring the graph of higher priority references and start
      * visiting the lower priority references, at which point we won't add any reference to
@@ -144,10 +182,6 @@ internal class PathFinder(
       )))
     }
 
-    SharkLog.d {
-      "Accounting for known reference patterns:\n${appliedRefMatchers.joinToString("\n")}"
-    }
-
     appliedRefMatchers.forEach { referenceMatcher ->
       when (val pattern = referenceMatcher.pattern) {
         is ReferencePattern.JavaLocalPattern -> {
@@ -192,13 +226,17 @@ internal class PathFinder(
     val sizeOfObjectInstances = determineSizeOfObjectInstances(objectClass, graph)
     val javaLangObjectId = objectClass?.objectId ?: -1
 
-    val state =
-      State(
-          leakingObjectIds = leakingObjectIds.toLongScatterSet(),
-          sizeOfObjectInstances = sizeOfObjectInstances,
-          computeRetainedHeapSize = computeRetainedHeapSize,
-          javaLangObjectId = javaLangObjectId
-      )
+    // Estimate of how many objects we'll visit. This is a conservative estimate, we should always
+    // visit more than that but this limits the number of early array growths.
+    val estimatedVisitedObjects = (graph.instanceCount / 2).coerceAtLeast(4)
+
+    val state = State(
+        leakingObjectIds = leakingObjectIds.toLongScatterSet(),
+        sizeOfObjectInstances = sizeOfObjectInstances,
+        computeRetainedHeapSize = computeRetainedHeapSize,
+        javaLangObjectId = javaLangObjectId,
+        estimatedVisitedObjects = estimatedVisitedObjects
+    )
 
     return state.findPathsFromGcRoots()
   }
@@ -235,13 +273,6 @@ internal class PathFinder(
     val shortestPathsToLeakingObjects = mutableListOf<ReferencePathNode>()
     visitingQueue@ while (queuesNotEmpty) {
       val node = poll()
-
-      if (checkSeen(node)) {
-        throw IllegalStateException(
-            "Node $node objectId=${node.objectId} should not be enqueued when already visited or enqueued"
-        )
-      }
-
       if (node.objectId in leakingObjectIds) {
         shortestPathsToLeakingObjects.add(node)
         // Found all refs, stop searching (unless computing retained size)
@@ -260,7 +291,10 @@ internal class PathFinder(
         is HeapObjectArray -> visitObjectArray(heapObject, node)
       }
     }
-    return PathFindingResults(shortestPathsToLeakingObjects, dominatedObjectIds)
+    return PathFindingResults(
+        shortestPathsToLeakingObjects,
+        if (visitTracker is Dominated) visitTracker.dominatorTree else null
+    )
   }
 
   private fun State.poll(): ReferencePathNode {
@@ -276,20 +310,12 @@ internal class PathFinder(
     }
   }
 
-  private fun State.checkSeen(node: ReferencePathNode): Boolean {
-    val neverSeen = visitedSet.add(node.objectId)
-    return !neverSeen
-  }
-
   private fun State.enqueueGcRoots() {
     val gcRoots = sortedGcRoots()
 
     val threadNames = mutableMapOf<HeapInstance, String>()
     val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
     gcRoots.forEach { (objectRecord, gcRoot) ->
-      if (computeRetainedHeapSize) {
-        undominateWithSkips(gcRoot.id)
-      }
       when (gcRoot) {
         is ThreadObject -> {
           threadsBySerialNumber[gcRoot.threadSerialNumber] = objectRecord.asInstance!! to gcRoot
@@ -301,7 +327,6 @@ internal class PathFinder(
             // Could not find the thread that this java frame is for.
             enqueue(NormalRootNode(gcRoot.id, gcRoot))
           } else {
-
             val (threadInstance, threadRoot) = threadPair
             val threadName = threadNames[threadInstance] ?: {
               val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString() ?: ""
@@ -413,7 +438,7 @@ internal class PathFinder(
       }
 
       val fieldName = staticField.name
-      if (fieldName == "\$staticOverhead") {
+      if (fieldName == "\$staticOverhead" || fieldName == "\$classOverhead") {
         continue
       }
 
@@ -421,10 +446,6 @@ internal class PathFinder(
       // and access value directly. This allows us to avoid unnecessary boxing of Long.
       val objectId = (staticField.value.holder as ReferenceHolder).value
 
-      if (computeRetainedHeapSize) {
-        undominateWithSkips(objectId)
-      }
-
       val node = when (val referenceMatcher = ignoredStaticFields[fieldName]) {
         null -> NormalNode(
             objectId = objectId,
@@ -472,10 +493,6 @@ internal class PathFinder(
 
     fieldNamesAndValues.forEach { pair ->
       val (objectId, name) = pair
-      if (computeRetainedHeapSize) {
-        updateDominatorWithSkips(parent.objectId, objectId)
-      }
-
       val node = when (val referenceMatcher = fieldReferenceMatchers[name]) {
         null -> NormalNode(
             objectId = objectId,
@@ -578,9 +595,6 @@ internal class PathFinder(
       objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId)
     }
     nonNullElementIds.forEachIndexed { index, elementId ->
-      if (computeRetainedHeapSize) {
-        updateDominatorWithSkips(parent.objectId, elementId)
-      }
       val name = index.toString()
       enqueue(
           NormalNode(
@@ -600,36 +614,50 @@ internal class PathFinder(
     if (node.objectId == ValueHolder.NULL_REFERENCE) {
       return
     }
-    if (visitedSet.contains(node.objectId)) {
-      return
-    }
-    // Already enqueued => shorter or equal distance
-    if (toVisitSet.contains(node.objectId)) {
-      return
-    }
 
     val visitLast =
       visitingLast ||
-      node is LibraryLeakNode ||
+          node is LibraryLeakNode ||
           // We deprioritize thread objects because on Lollipop the thread local values are stored
           // as a field.
           (node is RootNode && node.gcRoot is ThreadObject) ||
           (node is NormalNode && node.parent is RootNode && node.parent.gcRoot is JavaFrame)
 
-    if (toVisitLastSet.contains(node.objectId)) {
-      // Already enqueued => shorter or equal distance amongst library leak ref patterns.
+    val parentObjectId = if (node is RootNode) {
+      ValueHolder.NULL_REFERENCE
+    } else {
+      (node as ChildNode).parent.objectId
+    }
+
+    val alreadyEnqueued = visitTracker.visited(node.objectId, parentObjectId)
+
+    if (alreadyEnqueued) {
+      // Has already been enqueued and would be added to visit last => don't enqueue.
       if (visitLast) {
         return
-      } else {
-        toVisitQueue.add(node)
-        toVisitSet.add(node.objectId)
-        val nodeToRemove = toVisitLastQueue.first { it.objectId == node.objectId }
-        toVisitLastQueue.remove(nodeToRemove)
-        toVisitLastSet.remove(node.objectId)
+      }
+      // Has already been enqueued and exists in the to visit set => don't enqueue
+      if (toVisitSet.contains(node.objectId)) {
+        return
+      }
+      // Has already been enqueued, is not in toVisitSet, is not in toVisitLast => has been visited
+      if (!toVisitLastSet.contains(node.objectId)) {
         return
       }
     }
 
+    // Because of the checks and return statements right before, from this point on, if
+    // alreadyEnqueued then it's currently enqueued in the visit last set.
+    if (alreadyEnqueued) {
+      // Move from "visit last" to "visit first" queue.
+      toVisitQueue.add(node)
+      toVisitSet.add(node.objectId)
+      val nodeToRemove = toVisitLastQueue.first { it.objectId == node.objectId }
+      toVisitLastQueue.remove(nodeToRemove)
+      toVisitLastSet.remove(node.objectId)
+      return
+    }
+
     val isLeakingObject = node.objectId in leakingObjectIds
 
     if (!isLeakingObject) {
@@ -638,12 +666,25 @@ internal class PathFinder(
         is HeapInstance ->
           when {
             graphObject.isPrimitiveWrapper -> true
-            graphObject.instanceClassName == "java.lang.String" -> true
+            graphObject.instanceClassName == "java.lang.String" -> {
+              // We ignore the fact that String references a value array to avoid having
+              // to read the string record and find the object id for that array, since we know
+              // it won't be interesting anyway.
+              // That also means the value array isn't added to the dominator tree, so we need to
+              // add that back when computing shallow size in ShallowSizeCalculator.
+              // Another side effect is that if the array is referenced elsewhere, we might
+              // double count its side.
+              true
+            }
             graphObject.instanceClass.instanceByteSize <= sizeOfObjectInstances -> true
             else -> false
           }
         is HeapObjectArray -> when {
-          graphObject.isPrimitiveWrapperArray -> true
+          graphObject.isPrimitiveWrapperArray -> {
+            // Same optimization as we did for String above, as we know primitive wrapper arrays
+            // aren't interesting.
+            true
+          }
           else -> false
         }
         is HeapPrimitiveArray -> true
@@ -660,195 +701,4 @@ internal class PathFinder(
       toVisitSet.add(node.objectId)
     }
   }
-
-  private fun State.updateDominatorWithSkips(
-    parentObjectId: Long,
-    objectId: Long
-  ) {
-
-    when (val graphObject = graph.findObjectById(objectId)) {
-      is HeapClass -> {
-        undominate(objectId, false)
-      }
-      is HeapInstance -> {
-        // String internal array is never enqueued
-        if (graphObject.instanceClassName == "java.lang.String") {
-          updateDominator(parentObjectId, objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
-          if (valueId != null) {
-            updateDominator(parentObjectId, valueId, true)
-          }
-        } else {
-          updateDominator(parentObjectId, objectId, false)
-        }
-      }
-      is HeapObjectArray -> {
-        // Primitive wrapper array elements are never enqueued
-        if (graphObject.isPrimitiveWrapperArray) {
-          updateDominator(parentObjectId, objectId, true)
-          for (wrapperId in graphObject.readRecord().elementIds) {
-            updateDominator(parentObjectId, wrapperId, true)
-          }
-        } else {
-          updateDominator(parentObjectId, objectId, false)
-        }
-      }
-      else -> {
-        updateDominator(parentObjectId, objectId, false)
-      }
-    }
-  }
-
-  /**
-   * Every time we find a new object as we traverse the graph, we call this method.
-   *
-   * This is a twist on the traditional dominator tree / retained size algorithms: dominators here
-   * can only be retained instances, which means we don't need to track that many dominators.
-   *
-   * Here's how it works:
-   *
-   * - If [objectId] has no dominator known yet but has already been added to visit, then we know
-   * we've been here for that object already. We did not add this object to the map of dominated
-   * instances in the previous visit so it can't be dominated any more and we can stop there.
-   *
-   * - The parent of [objectId] has already been visited. If that parent is not a retained
-   * instance and has no known retained instance dominator, it cannot be dominated by a retained
-   * instance and therefore [objectId] cannot be dominated either.
-   *
-   * - The potential dominator of [objectId] is: either its parent if that parent is a retained
-   * object, or its parent's dominator (which therefore is a retained object).
-   *
-   * - If [objectId] has no known dominator, we set that potential dominator as its dominator.
-   *
-   * - If [objectId] has a known dominator, we now must find the common parent dominator between
-   * those two dominators. To find that common dominator, we compute the dominator chain for each
-   * dominator and the first found dominator is set as [objectId]'s dominator. If no common
-   * dominator was found, [objectId] cannot be dominated.
-   *
-   * @param neverEnqueued whether [updateDominator] is called right before [objectId] being added
-   * to the queue. There are a number of objects that are never added to the queue because we know
-   * they can't lead to leaks. When we mark objects as undominated and [neverEnqueued] is true,
-   * we also add these objects to visitedSet so that the next visit to [updateDominator] can be
-   * skipped early. If [neverEnqueued] is false then they'll be added to [State.toVisitSet] when
-   * enqueued.
-   */
-  @Suppress("ComplexCondition")
-  private fun State.updateDominator(
-    parent: Long,
-    objectId: Long,
-    neverEnqueued: Boolean
-  ) {
-    val currentDominatorSlot = dominatedObjectIds.getSlot(objectId)
-    if (currentDominatorSlot == -1 && (objectId in visitedSet || objectId in toVisitSet || objectId in toVisitLastSet)) {
-      return
-    }
-    val parentDominatorSlot = dominatedObjectIds.getSlot(parent)
-
-    val parentIsRetainedObject = parent in leakingObjectIds
-
-    if (!parentIsRetainedObject && parentDominatorSlot == -1) {
-      // parent is not a retained instance and parent has no dominator, but it must have been
-      // visited therefore we know parent belongs to undominated.
-      if (neverEnqueued) {
-        visitedSet.add(objectId)
-      }
-
-      if (currentDominatorSlot != -1) {
-        dominatedObjectIds.remove(objectId)
-      }
-      return
-    }
-    val nextDominator =
-      if (parentIsRetainedObject) parent else dominatedObjectIds.getSlotValue(parentDominatorSlot)
-    if (currentDominatorSlot == -1) {
-      dominatedObjectIds[objectId] = nextDominator
-    } else {
-      val parentDominators = mutableListOf<Long>()
-      val currentDominators = mutableListOf<Long>()
-      var stop = false
-      var dominator: Long = nextDominator
-      while (!stop) {
-        parentDominators.add(dominator)
-        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
-        if (nextDominatorSlot == -1) {
-          stop = true
-        } else {
-          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
-        }
-      }
-      stop = false
-      dominator = dominatedObjectIds.getSlotValue(currentDominatorSlot)
-      while (!stop) {
-        currentDominators.add(dominator)
-        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
-        if (nextDominatorSlot == -1) {
-          stop = true
-        } else {
-          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
-        }
-      }
-
-      var sharedDominator: Long? = null
-      exit@ for (parentD in parentDominators) {
-        for (currentD in currentDominators) {
-          if (currentD == parentD) {
-            sharedDominator = currentD
-            break@exit
-          }
-        }
-      }
-      if (sharedDominator == null) {
-        dominatedObjectIds.remove(objectId)
-        if (neverEnqueued) {
-          visitedSet.add(objectId)
-        }
-      } else {
-        dominatedObjectIds[objectId] = sharedDominator
-      }
-    }
-  }
-
-  private fun State.undominateWithSkips(objectId: Long) {
-    when (val graphObject = graph.findObjectById(objectId)) {
-      is HeapClass -> {
-        undominate(objectId, false)
-      }
-      is HeapInstance -> {
-        // String internal array is never enqueued
-        if (graphObject.instanceClassName == "java.lang.String") {
-          undominate(objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
-          if (valueId != null) {
-            undominate(valueId, true)
-          }
-        } else {
-          undominate(objectId, false)
-        }
-      }
-      is HeapObjectArray -> {
-        // Primitive wrapper array elements are never enqueued
-        if (graphObject.isPrimitiveWrapperArray) {
-          undominate(objectId, true)
-          for (wrapperId in graphObject.readRecord().elementIds) {
-            undominate(wrapperId, true)
-          }
-        } else {
-          undominate(objectId, false)
-        }
-      }
-      else -> {
-        undominate(objectId, false)
-      }
-    }
-  }
-
-  private fun State.undominate(
-    objectId: Long,
-    neverEnqueued: Boolean
-  ) {
-    dominatedObjectIds.remove(objectId)
-    if (neverEnqueued) {
-      visitedSet.add(objectId)
-    }
-  }
 }
diff --git a/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt b/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt
new file mode 100644
index 000000000..1d3664bc8
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ShallowSizeCalculator.kt
@@ -0,0 +1,64 @@
+package shark.internal
+
+import shark.HeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.ValueHolder
+
+/**
+ * Provides approximations for the shallow size of objects in memory.
+ *
+ * Determining the actual shallow size of an object in memory is hard, as it changes for each VM
+ * implementation, depending on the various memory layout optimizations and bit alignment.
+ *
+ * More on this topic: https://dev.to/pyricau/the-real-size-of-android-objects-1i2e
+ */
+internal class ShallowSizeCalculator(private val graph: HeapGraph) {
+
+  fun computeShallowSize(objectId: Long): Int {
+    return when (val heapObject = graph.findObjectById(objectId)) {
+      is HeapInstance -> {
+        if (heapObject.instanceClassName == "java.lang.String") {
+          // In PathFinder we ignore the value field of String instances when building the dominator
+          // tree, so we add that size back here.
+          val valueObjectId =
+            heapObject["java.lang.String", "value"]?.value?.asNonNullObjectId
+          heapObject.byteSize + if (valueObjectId != null) {
+            computeShallowSize(valueObjectId)
+          } else {
+            0
+          }
+        } else {
+          // Total byte size of fields for instances of this class, as registered in the class dump.
+          // The actual memory layout likely differs.
+          heapObject.byteSize
+        }
+      }
+      // Number of elements * object id size
+      is HeapObjectArray -> {
+        if (heapObject.isPrimitiveWrapperArray) {
+          // In PathFinder we ignore references sfrom primitive wrapper arrayss when building the
+          // dominator tree, so we add that size back here.
+          val elementIds = heapObject.readRecord().elementIds
+          val shallowSize = elementIds.size * graph.identifierByteSize
+          val firstNonNullElement = elementIds.firstOrNull { it != ValueHolder.NULL_REFERENCE }
+          if (firstNonNullElement != null) {
+            val sizeOfOneElement = computeShallowSize(firstNonNullElement)
+            val countOfNonNullElements = elementIds.count { it != ValueHolder.NULL_REFERENCE }
+            shallowSize + (sizeOfOneElement * countOfNonNullElements)
+          } else {
+            shallowSize
+          }
+        } else {
+          heapObject.readByteSize()
+        }
+      }
+      // Number of elements * primitive type size
+      is HeapPrimitiveArray -> heapObject.readByteSize()
+      // This is probably way off but is a cheap approximation.
+      is HeapClass -> heapObject.recordSize
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt b/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt
index 3c73ce0f9..209d249c4 100644
--- a/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt
+++ b/shark/src/main/java/shark/internal/hppcshark/LongScatterSet.kt
@@ -23,7 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongScatterSet {
+internal class LongScatterSet(expectedElements: Int = 4) {
   /** The hash array holding keys.  */
   private var keys: LongArray = longArrayOf()
   /**
@@ -53,7 +53,7 @@ internal class LongScatterSet {
   private val loadFactor = 0.75
 
   init {
-    ensureCapacity(4)
+    ensureCapacity(expectedElements)
   }
 
   private fun hashKey(key: Long): Int {
diff --git a/shark/src/test/java/shark/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
index b067e889f..e6125514a 100644
--- a/shark/src/test/java/shark/RetainedSizeTest.kt
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -42,7 +42,6 @@ class RetainedSizeTest {
         }
       }
     }
-
     val retainedSize = firstRetainedSize()
 
     // 8 bytes for long
diff --git a/shark/src/test/java/shark/internal/DominatorTreeTest.kt b/shark/src/test/java/shark/internal/DominatorTreeTest.kt
new file mode 100644
index 000000000..8bb397584
--- /dev/null
+++ b/shark/src/test/java/shark/internal/DominatorTreeTest.kt
@@ -0,0 +1,179 @@
+package shark.internal
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+@Suppress("UsePropertyAccessSyntax")
+class DominatorTreeTest {
+
+  var latestObjectId: Long = 0
+  private fun newObjectId() = ++latestObjectId
+
+  @Suppress("PrivatePropertyName")
+  private val `10 bytes per object`: (Long) -> Int = { 10 }
+
+  @Test fun `new object is not already dominated`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+
+    val alreadyDominated = tree.updateDominated(newObjectId(), root)
+
+    assertThat(alreadyDominated).isFalse()
+  }
+
+  @Test fun `dominated object is already dominated`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root1) }
+
+    val alreadyDominated = tree.updateDominated(child, root2)
+
+    assertThat(alreadyDominated).isTrue()
+  }
+
+  @Test fun `only retained objects are returned in sizes map`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+
+    val sizes = tree.computeRetainedSizes(setOf(child), `10 bytes per object`)
+
+    assertThat(sizes).containsOnlyKeys(child)
+  }
+
+  @Test fun `single root has self size as retained size`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+
+    val sizes = tree.computeRetainedSizes(setOf(root), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(10)
+  }
+
+  @Test fun `size of dominator includes dominated`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    tree.updateDominated(newObjectId(), root)
+
+    val sizes = tree.computeRetainedSizes(setOf(root), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(20)
+  }
+
+  @Test fun `size of chain of dominators is additive`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+    tree.updateDominated(newObjectId(), child)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child), `10 bytes per object`)
+
+    assertThat(sizes[root]).isEqualTo(30)
+    assertThat(sizes[child]).isEqualTo(20)
+  }
+
+  @Test fun `diamond dominators don't dominate`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child1 = newObjectId().apply { tree.updateDominated(this, root) }
+    val child2 = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild = newObjectId()
+    tree.updateDominated(grandChild, child1)
+    tree.updateDominated(grandChild, child2)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child1, child2), `10 bytes per object`)
+
+    assertThat(sizes[child1]).isEqualTo(10)
+    assertThat(sizes[child2]).isEqualTo(10)
+    assertThat(sizes[root]).isEqualTo(40)
+  }
+
+  @Test fun `two dominators dominated by common ancestor`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child1 = newObjectId().apply { tree.updateDominated(this, root) }
+    val child2 = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild = newObjectId()
+    tree.updateDominated(grandChild, child1)
+    tree.updateDominated(grandChild, child2)
+
+    val sizes = tree.computeRetainedSizes(setOf(root, child1, child2), `10 bytes per object`)
+
+    assertThat(sizes[child1]).isEqualTo(10)
+    assertThat(sizes[child2]).isEqualTo(10)
+    assertThat(sizes[root]).isEqualTo(40)
+  }
+
+  @Test fun `two dominators dominated by lowest common ancestor`() {
+    val tree = DominatorTree()
+    val root = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root) }
+    val grandChild1 = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandChild2 = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandGrandChild = newObjectId()
+    tree.updateDominated(grandGrandChild, grandChild1)
+    tree.updateDominated(grandGrandChild, grandChild2)
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root, child, grandChild1, grandChild2), `10 bytes per object`)
+
+    assertThat(sizes[grandChild1]).isEqualTo(10)
+    assertThat(sizes[grandChild1]).isEqualTo(10)
+    assertThat(sizes[child]).isEqualTo(40)
+    assertThat(sizes[root]).isEqualTo(50)
+  }
+
+  @Test fun `two separate trees do not share size`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    var descendant1 = root1
+    var descendant2 = root2
+    for (i in 1..10) {
+      descendant1 = newObjectId().apply { tree.updateDominated(this, descendant1) }
+      descendant2 = newObjectId().apply { tree.updateDominated(this, descendant2) }
+    }
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root1, root2), `10 bytes per object`)
+
+    assertThat(sizes[root1]).isEqualTo(110)
+    assertThat(sizes[root2]).isEqualTo(110)
+  }
+
+  @Test fun `no common descendant does not include size`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    var descendant = root1
+    for (i in 1..10) {
+      descendant = newObjectId().apply { tree.updateDominated(this, descendant) }
+    }
+    tree.updateDominated(descendant, root2)
+
+    val sizes =
+      tree.computeRetainedSizes(setOf(root1, root2), `10 bytes per object`)
+
+    assertThat(sizes[root1]).isEqualTo(100)
+    assertThat(sizes[root2]).isEqualTo(10)
+  }
+
+  @Test fun `only compute retained size for retained objects`() {
+    val tree = DominatorTree()
+    val root1 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val root2 = newObjectId().apply { tree.updateDominatedAsRoot(this) }
+    val child = newObjectId().apply { tree.updateDominated(this, root1) }
+    val grandChild = newObjectId().apply { tree.updateDominated(this, child) }
+    val grandGrandChild = newObjectId().apply { tree.updateDominated(this, grandChild) }
+    tree.updateDominated(grandGrandChild, root2)
+
+    val objectsWithComputedSize = mutableSetOf<Long>()
+    tree.computeRetainedSizes(setOf(child)) { objectId ->
+      objectsWithComputedSize += objectId
+      1
+    }
+
+    assertThat(objectsWithComputedSize).containsOnly(child, grandChild)
+  }
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt b/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt
new file mode 100644
index 000000000..0339e8a48
--- /dev/null
+++ b/shark/src/test/java/shark/internal/ShallowSizeCalculatorTest.kt
@@ -0,0 +1,108 @@
+package shark.internal
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HprofHeapGraph.Companion.openHeapGraph
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.dump
+import java.io.File
+
+private const val EMPTY_CLASS_SIZE = 42
+
+class ShallowSizeCalculatorTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun `empty class has instance size 0`() {
+    hprofFile.dump {
+      "SomeClass" instance {}
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+          graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+
+    assertThat(instanceSize).isEqualTo(0)
+  }
+
+  @Test fun `class with static field has instance size 0`() {
+    hprofFile.dump {
+      "SomeClass" instance {
+        staticField["someStaticField"] = LongHolder(42)
+      }
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+          graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+
+    assertThat(instanceSize).isEqualTo(0)
+  }
+
+  @Test fun `class with int field has instance size 4`() {
+    hprofFile.dump {
+      "SomeClass" instance {
+        field["someIntField"] = IntHolder(42)
+      }
+    }
+
+    val instanceSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(
+          graph.findClassByName("SomeClass")!!.instances.single().objectId
+      )
+    }
+    assertThat(instanceSize).isEqualTo(4)
+  }
+
+  @Test fun `empty class has size EMPTY_CLASS_SIZE`() {
+    hprofFile.dump {
+      "SomeClass" clazz {}
+    }
+
+    val classSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(graph.findClassByName("SomeClass")!!.objectId)
+    }
+    assertThat(classSize).isEqualTo(EMPTY_CLASS_SIZE)
+  }
+
+  @Test fun `class with static int field has class size that includes field`() {
+    hprofFile.dump {
+      "SomeClass" clazz {
+        staticField["someStaticField"] = IntHolder(42)
+      }
+    }
+
+    val classSize = hprofFile.openHeapGraph().use { graph ->
+      val calculator = ShallowSizeCalculator(graph)
+      calculator.computeShallowSize(graph.findClassByName("SomeClass")!!.objectId)
+    }
+
+    val bytesForFieldId = 4
+    val bytesForFieldType = 1
+    val bytesForFieldValue = 4
+
+    assertThat(classSize).isEqualTo(
+        EMPTY_CLASS_SIZE + bytesForFieldId + bytesForFieldType + bytesForFieldValue
+    )
+  }
+
+}
\ No newline at end of file
