diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
index 20bc677f1..6dda68d3f 100644
--- a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
@@ -8,8 +8,10 @@ import leakcanary.internal.activity.db.LeaksDbHelper
 import org.junit.Test
 import shark.HeapAnalysis
 import shark.HeapAnalysisSuccess
+import shark.LeakTrace.GcRootType.JAVA_FRAME
+import shark.LeakTrace.GcRootType.STICKY_CLASS
+import shark.SharkLog
 import java.io.FileOutputStream
-import kotlin.reflect.KClass
 
 class DatabaseMigrationTest {
 
@@ -35,6 +37,21 @@ class DatabaseMigrationTest {
     }
   }
 
+  @Test fun v19_has_8_leak_traces() {
+    DB_V19 upgrade {
+      val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
+          .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
+          .flatMap { analysis ->
+            analysis.allLeaks.toList()
+          }
+          .flatMap { leak ->
+            leak.leakTraces
+          }
+
+      allLeakTraces.size assertEquals 8
+    }
+  }
+
   @Test fun v19_has_3_leak_types() {
     DB_V19 upgrade {
       LeakTable.retrieveAllLeaks(this).size assertEquals 3
@@ -50,16 +67,21 @@ class DatabaseMigrationTest {
     }
   }
 
-  @Test fun v19_all_8_leaks_can_be_deserialized() {
+  @Test fun v19_has_5_sticky_class_and_3_java_frame_gc_roots() {
     DB_V19 upgrade {
-     val allLeaks = LeakTable.retrieveAllLeaks(this)
-          .flatMap { leakTypeProjection ->
-            LeakTable.retrieveLeaksByHash(this, leakTypeProjection.hash)
+      val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
+          .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
+          .flatMap { analysis ->
+            analysis.allLeaks.toList()
           }
-          .map { leakProjection ->
-            LeakTable.retrieveLeakById(this, leakProjection.id)
+          .flatMap { leak ->
+            leak.leakTraces
           }
-      allLeaks.size assertEquals 8
+      val gcRootCounts = allLeakTraces.groupingBy { it.gcRootType }
+          .eachCount()
+
+      gcRootCounts.getValue(STICKY_CLASS) assertEquals 5
+      gcRootCounts.getValue(JAVA_FRAME) assertEquals 3
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index 1370003fe..f46f631ad 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -7,7 +7,6 @@ import leakcanary.internal.NotificationType.LEAKCANARY_MAX
 import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
-import leakcanary.internal.activity.db.LeakTable
 import leakcanary.internal.activity.db.LeaksDbHelper
 import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapDumpScreen
@@ -26,10 +25,8 @@ class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHe
   override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     SharkLog.d { "$heapAnalysis" }
 
-    val (id, groupProjections) = LeaksDbHelper(application)
-        .writableDatabase.use { db ->
-      val id = HeapAnalysisTable.insert(db, heapAnalysis)
-      id to LeakTable.retrieveHeapDumpLeaks(db, id)
+    val id = LeaksDbHelper(application).writableDatabase.use { db ->
+      HeapAnalysisTable.insert(db, heapAnalysis)
     }
 
     val (contentTitle, screenToShow) = when (heapAnalysis) {
@@ -37,8 +34,8 @@ class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHe
           R.string.leak_canary_analysis_failed
       ) to HeapAnalysisFailureScreen(id)
       is HeapAnalysisSuccess -> {
-        val retainedObjectCount = groupProjections.values.sumBy { it.leakCount }
-        val leakTypeCount = groupProjections.size
+        val retainedObjectCount = heapAnalysis.allLeaks.sumBy { it.leakTraces.size }
+        val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
         application.getString(
             R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount
         ) to HeapDumpScreen(id)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 681f591d0..547f57895 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -18,7 +18,6 @@ package leakcanary.internal
 import android.content.Context
 import android.text.Html
 import android.text.SpannableStringBuilder
-import android.text.Spanned
 import android.text.method.LinkMovementMethod
 import android.view.View
 import android.view.ViewGroup
@@ -28,7 +27,7 @@ import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakConnectorView.Type
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
-import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.GC_ROOT
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
@@ -38,12 +37,13 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
 import leakcanary.internal.navigation.getColorCompat
 import leakcanary.internal.navigation.inflate
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
 import shark.LeakTrace
-import shark.LeakTraceElement
-import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakTrace.GcRootType.JAVA_FRAME
+import shark.LeakTraceObject
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.ReferencePathElement.ReferenceType.STATIC_FIELD
 
 @Suppress("DEPRECATION", "TooManyFunctions")
 internal class DisplayLeakAdapter constructor(
@@ -91,10 +91,11 @@ internal class DisplayLeakAdapter constructor(
   private fun bindHeaderRow(
     view: View
   ) {
-    view.findViewById<TextView>(R.id.leak_canary_header_text).apply {
-      movementMethod = LinkMovementMethod.getInstance()
-      text = header
-    }
+    view.findViewById<TextView>(R.id.leak_canary_header_text)
+        .apply {
+          movementMethod = LinkMovementMethod.getInstance()
+          text = header
+        }
   }
 
   private fun bindConnectorRow(
@@ -106,111 +107,132 @@ internal class DisplayLeakAdapter constructor(
 
     connector.setType(getConnectorType(position))
 
-    val elementIndex = elementIndex(position)
-    val element = leakTrace.elements[elementIndex]
+    titleView.text = when {
+      position == 1 -> {
+        "GC Root: ${leakTrace.gcRootType.description}"
+      }
+      position < count - 1 -> {
+        val referencePathIndex = elementIndex(position)
+        val referencePath = leakTrace.referencePath[referencePathIndex]
+        val isSuspect = leakTrace.referencePathElementIsSuspect(referencePathIndex)
 
-    val mayBeLeakCause = leakTrace.elementMayBeLeakCause(elementIndex)
+        val leakTraceObject = referencePath.originObject
 
-    titleView.text = htmlTitle(element, mayBeLeakCause, view.context)
-  }
+        val typeName =
+          if (position == 2 && leakTrace.gcRootType == JAVA_FRAME) "thread" else leakTraceObject.typeName
 
-  private fun htmlTitle(
-    element: LeakTraceElement,
-    maybeLeakCause: Boolean,
-    context: Context
-  ): Spanned {
+        var referenceName = referencePath.referenceDisplayName
 
-    val packageEnd = element.className.lastIndexOf('.')
-    var simpleName = element.classSimpleName
-    simpleName = simpleName.replace("[]", "[ ]")
-    val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
+        referenceName = referenceName.replace("<".toRegex(), "&lt;")
+            .replace(">".toRegex(), "&gt;")
 
-    var htmlString =
-      if (packageEnd != -1) "<font color='$extraColorHexString'>${element.className.substring(
-          0, packageEnd
-      )}</font>.$styledClassName" else styledClassName
+        referenceName = if (isSuspect) {
+          "<u><font color='$leakColorHexString'>$referenceName</font></u>"
+        } else {
+          "<font color='$referenceColorHexString'>$referenceName</font>"
+        }
 
-    htmlString += "<br>"
+        if (referencePath.referenceType == STATIC_FIELD) {
+          referenceName = "static <i>$referenceName</i>"
+        }
 
-    val reachabilityString = when (element.leakStatus) {
-      UNKNOWN -> "UNKNOWN"
-      NOT_LEAKING -> "NO (${element.leakStatusReason})"
-      LEAKING -> "YES (${element.leakStatusReason})"
-    }
+        if (isSuspect) {
+          referenceName = "<b>$referenceName</b>"
+        }
 
-    val indentation = "&nbsp;".repeat(4)
-    htmlString += "$indentation<font color='$extraColorHexString'>Leaking: $reachabilityString</font><br>"
+        val htmlString = leakTraceObject.asHtmlString(typeName) +
+            "$INDENTATION${leakTraceObject.styledClassSimpleName()}.$referenceName"
 
-    element.labels.forEach { label ->
-      htmlString += "$indentation<font color='$extraColorHexString'>$label</font><br>"
+        val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
+        if (isSuspect) {
+          SquigglySpan.replaceUnderlineSpans(builder, view.context)
+        }
+        builder
+      }
+      else -> {
+        Html.fromHtml(leakTrace.leakingObject.asHtmlString(leakTrace.leakingObject.typeName))
+      }
     }
+  }
 
-    val reference = element.reference
-    if (reference != null) {
-      var referenceName = reference.displayName.replace("<".toRegex(), "&lt;")
-          .replace(">".toRegex(), "&gt;")
+  private fun LeakTraceObject.asHtmlString(typeName: String): String {
+    val packageEnd = className.lastIndexOf('.')
 
-      referenceName = if (maybeLeakCause) {
-        "<u><font color='$leakColorHexString'>$referenceName</font></u>"
-      } else {
-        "<font color='$referenceColorHexString'>$referenceName</font>"
-      }
-
-      if (reference.type == STATIC_FIELD) {
-        referenceName = "<i>$referenceName</i>"
-      }
+    val styledClassName = styledClassSimpleName()
+    var htmlString =
+      if (packageEnd != -1) "<font color='$extraColorHexString'>${className.substring(
+          0, packageEnd
+      )}</font>.$styledClassName" else styledClassName
+    htmlString += " <font color='$extraColorHexString'>$typeName</font><br>"
 
-      htmlString += "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
+    val reachabilityString = when (leakingStatus) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO (${leakingStatusReason})"
+      LEAKING -> "YES (${leakingStatusReason})"
     }
-    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
-    if (maybeLeakCause) {
-      SquigglySpan.replaceUnderlineSpans(builder, context)
+
+    htmlString += "$INDENTATION<font color='$extraColorHexString'>Leaking: $reachabilityString</font><br>"
+
+    labels.forEach { label ->
+      htmlString += "$INDENTATION<font color='$extraColorHexString'>$label</font><br>"
     }
+    return htmlString
+  }
 
-    return builder
+  private fun LeakTraceObject.styledClassSimpleName(): String {
+    val simpleName = classSimpleName.replace("[]", "[ ]")
+    return "<font color='$classNameColorHexString'>$simpleName</font>"
   }
 
   @Suppress("ReturnCount")
   private fun getConnectorType(position: Int): Type {
-    if (position == 0) {
-      return HELP
-    } else if (position == 1) {
-      if (leakTrace.elements.size == 1) {
+    if (position == 1) {
+      return GC_ROOT
+    } else if (position == 2) {
+      if (leakTrace.referencePath.size == 1) {
         return START_LAST_REACHABLE
       }
-      val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-      return if (nextReachability.leakStatus != NOT_LEAKING) {
+      val nextReachability =
+        if (position + 1 == count - 1) leakTrace.leakingObject else leakTrace.referencePath[elementIndex(
+            position + 1
+        )].originObject
+      return if (nextReachability.leakingStatus != NOT_LEAKING) {
         START_LAST_REACHABLE
       } else START
     } else {
       val isLeakingInstance = position == count - 1
       if (isLeakingInstance) {
-        val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-        return if (previousReachability.leakStatus != LEAKING) {
+        val previousReachability = leakTrace.referencePath.last()
+            .originObject
+        return if (previousReachability.leakingStatus != LEAKING) {
           END_FIRST_UNREACHABLE
         } else END
       } else {
-        val reachability = leakTrace.elements[elementIndex(position)]
-        when (reachability.leakStatus) {
+        val reachability = leakTrace.referencePath[elementIndex(position)].originObject
+        when (reachability.leakingStatus) {
           UNKNOWN -> return NODE_UNKNOWN
           NOT_LEAKING -> {
-            val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-            return if (nextReachability.leakStatus != NOT_LEAKING) {
+            val nextReachability =
+              if (position + 1 == count - 1) leakTrace.leakingObject else leakTrace.referencePath[elementIndex(
+                  position + 1
+              )].originObject
+            return if (nextReachability.leakingStatus != NOT_LEAKING) {
               NODE_LAST_REACHABLE
             } else {
               NODE_REACHABLE
             }
           }
           LEAKING -> {
-            val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-            return if (previousReachability.leakStatus != LEAKING) {
+            val previousReachability =
+              leakTrace.referencePath[elementIndex(position - 1)].originObject
+            return if (previousReachability.leakingStatus != LEAKING) {
               NODE_FIRST_UNREACHABLE
             } else {
               NODE_UNREACHABLE
             }
           }
           else -> throw IllegalStateException(
-              "Unknown value: " + reachability.leakStatus
+              "Unknown value: " + reachability.leakingStatus
           )
         }
       }
@@ -219,11 +241,11 @@ internal class DisplayLeakAdapter constructor(
 
   override fun isEnabled(position: Int) = false
 
-  override fun getCount() = leakTrace.elements.size + 1
+  override fun getCount() = leakTrace.referencePath.size + 3
 
   override fun getItem(position: Int) = null
 
-  private fun elementIndex(position: Int) = position - 1
+  private fun elementIndex(position: Int) = position - 2
 
   override fun getViewTypeCount() = 2
 
@@ -235,6 +257,7 @@ internal class DisplayLeakAdapter constructor(
 
     const val HEADER_ROW = 0
     const val CONNECTOR_ROW = 1
+    val INDENTATION = "&nbsp;".repeat(4)
 
     // https://stackoverflow.com/a/6540378/703646
     private fun hexStringColor(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
index caf8513ae..5af14ca29 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -29,7 +29,7 @@ import android.view.View
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
-import leakcanary.internal.DisplayLeakConnectorView.Type.HELP
+import leakcanary.internal.DisplayLeakConnectorView.Type.GC_ROOT
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_REACHABLE
@@ -56,7 +56,7 @@ internal class DisplayLeakConnectorView(
   private var cache: Bitmap? = null
 
   enum class Type {
-    HELP,
+    GC_ROOT,
     START,
     START_LAST_REACHABLE,
     NODE_UNKNOWN,
@@ -141,7 +141,7 @@ internal class DisplayLeakConnectorView(
         END_FIRST_UNREACHABLE -> drawItems(
             cacheCanvas, leakPaint, null
         )
-        HELP -> drawRoot(cacheCanvas)
+        GC_ROOT -> drawGcRoot(cacheCanvas)
         else -> throw UnsupportedOperationException("Unknown type " + type!!)
       }
     }
@@ -154,16 +154,12 @@ internal class DisplayLeakConnectorView(
     cacheCanvas.drawLine(halfWidth, 0f, halfWidth, circleY, classNamePaint)
   }
 
-  private fun drawRoot(
+  private fun drawGcRoot(
     cacheCanvas: Canvas
   ) {
     val width = measuredWidth
     val height = measuredHeight
     val halfWidth = width / 2f
-    val radiusClear = halfWidth - strokeSize / 2f
-    cacheCanvas.drawRect(0f, 0f, width.toFloat(), radiusClear, classNamePaint)
-    cacheCanvas.drawCircle(0f, radiusClear, radiusClear, clearPaint)
-    cacheCanvas.drawCircle(width.toFloat(), radiusClear, radiusClear, clearPaint)
     cacheCanvas.drawLine(halfWidth, 0f, halfWidth, height.toFloat(), classNamePaint)
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index 9cce32ef0..0070a4f8f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -30,7 +30,6 @@ import java.io.File
 import java.io.FilenameFilter
 import java.text.SimpleDateFormat
 import java.util.ArrayList
-import java.util.Arrays
 import java.util.Date
 import java.util.Locale
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index e7f37a03a..9a13a92e9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -21,7 +21,7 @@ internal object HeapAnalysisTable {
         (
         id INTEGER PRIMARY KEY AUTOINCREMENT,
         created_at_time_millis INTEGER,
-        leak_group_count INTEGER DEFAULT 0,
+        leak_count INTEGER DEFAULT 0,
         exception_summary TEXT DEFAULT NULL,
         object BLOB
         )"""
@@ -38,8 +38,8 @@ internal object HeapAnalysisTable {
     values.put("object", heapAnalysis.toByteArray())
     when (heapAnalysis) {
       is HeapAnalysisSuccess -> {
-        val leakGroupCount = heapAnalysis.allLeaks.map { it.groupHash }.distinct().size
-        values.put("leak_group_count", leakGroupCount)
+        val leakCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size
+        values.put("leak_count", leakCount)
       }
       is HeapAnalysisFailure -> {
         val cause = heapAnalysis.exception.cause!!
@@ -95,7 +95,7 @@ internal object HeapAnalysisTable {
           SELECT
           id
           , created_at_time_millis
-          , leak_group_count
+          , leak_count
           , exception_summary
           FROM heap_analysis
           ORDER BY created_at_time_millis DESC
@@ -107,7 +107,7 @@ internal object HeapAnalysisTable {
             val summary = Projection(
                 id = cursor.getLong(0),
                 createdAtTimeMillis = cursor.getLong(1),
-                leakGroupCount = cursor.getInt(2),
+                leakCount = cursor.getInt(2),
                 exceptionSummary = cursor.getString(3)
             )
             all.add(summary)
@@ -118,7 +118,7 @@ internal object HeapAnalysisTable {
 
   fun delete(
     db: SQLiteDatabase,
-    id: Long,
+    heapAnalysisId: Long,
     heapDumpFile: File?
   ) {
     if (heapDumpFile != null) {
@@ -134,8 +134,8 @@ internal object HeapAnalysisTable {
     }
 
     db.inTransaction {
-      db.delete("heap_analysis", "id=$id", null)
-      LeakTable.deleteByHeapAnalysisId(db, id)
+      db.delete("heap_analysis", "id=$heapAnalysisId", null)
+      LeakTable.deleteByHeapAnalysisId(db, heapAnalysisId)
     }
   }
 
@@ -151,7 +151,7 @@ internal object HeapAnalysisTable {
   class Projection(
     val id: Long,
     val createdAtTimeMillis: Long,
-    val leakGroupCount: Int,
+    val leakCount: Int,
     val exceptionSummary: String?
   )
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
index 371e1645b..e0c892e47 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
@@ -2,10 +2,7 @@ package leakcanary.internal.activity.db
 
 import android.content.ContentValues
 import android.database.sqlite.SQLiteDatabase
-import leakcanary.internal.Serializables
-import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
-import shark.HeapAnalysisSuccess
 import shark.Leak
 import shark.LibraryLeak
 
@@ -16,19 +13,16 @@ internal object LeakTable {
         CREATE TABLE leak
         (
         id INTEGER PRIMARY KEY,
-        heap_analysis_id REFERENCES heap_analysis(id),
-        group_hash TEXT,
-        group_description TEXT,
-        class_simple_name TEXT,
+        signature TEXT UNIQUE,
+        short_description TEXT,
         is_library_leak INTEGER,
-        is_read INTEGER,
-        object BLOB
+        is_read INTEGER
         )"""
 
   @Language("RoomSql")
-  const val createGroupHashIndex = """
-        CREATE INDEX leak_group_hash
-        on leak (group_hash)
+  const val createSignatureIndex = """
+        CREATE INDEX leak_signature
+        on leak (signature)
     """
 
   @Language("RoomSql")
@@ -40,98 +34,94 @@ internal object LeakTable {
     leak: Leak
   ): Long {
     val values = ContentValues()
-    values.put("heap_analysis_id", heapAnalysisId)
-    values.put("group_hash", leak.groupHash)
-    values.put("group_description", leak.createGroupDescription())
-    values.put("class_simple_name", leak.classSimpleName)
+    values.put("signature", leak.signature)
+    values.put("short_description", leak.shortDescription)
     values.put("is_library_leak", if (leak is LibraryLeak) 1 else 0)
     values.put("is_read", 0)
-    values.put("object", leak.toByteArray())
-    return db.insertOrThrow("leak", null, values)
-  }
 
-  class HeapAnalysisGroupProjection(
-    val hash: String,
-    val description: String,
-    val createdAtTimeMillis: Long,
-    val leakCount: Int,
-    val isNew: Boolean,
-    val isLibraryLeak: Boolean
-  )
+    db.insertWithOnConflict("leak", null, values, SQLiteDatabase.CONFLICT_IGNORE)
+
+    val leakId =
+      db.rawQuery("SELECT id from leak WHERE signature = '${leak.signature}' LIMIT 1", null)
+          .use { cursor ->
+            if (cursor.moveToFirst()) cursor.getLong(0) else throw IllegalStateException(
+                "No id found for leak with signature '${leak.signature}'"
+            )
+          }
+
+    leak.leakTraces.forEachIndexed { index, leakTrace ->
+      LeakTraceTable.insert(
+          db = db,
+          leakId = leakId,
+          heapAnalysisId = heapAnalysisId,
+          leakTraceIndex = index,
+          leakingObjectClassSimpleName = leakTrace.leakingObject.classSimpleName
+      )
+    }
 
-  fun retrieveHeapDumpLeaks(
+    return leakId
+  }
+
+  fun retrieveLeakReadStatuses(
     db: SQLiteDatabase,
-    heapAnalysisId: Long
-  ): Map<String, HeapAnalysisGroupProjection> {
+    signatures: Set<String>
+  ): Map<String, Boolean> {
     return db.rawQuery(
         """
-          SELECT
-          group_hash
-          , group_description
-          , MAX(created_at_time_millis) as created_at_time_millis
-          , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
-          , MIN(is_library_leak) as is_library_leak
-          , MAX(is_read) as is_read
-          FROM leak l
-          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
-          GROUP BY 1, 2
-          HAVING leak_count > 0
-          ORDER BY leak_count, created_at_time_millis DESC
-          """, null
+      SELECT
+      signature
+      , is_read
+      FROM leak
+      WHERE signature IN (${signatures.joinToString { "'$it'" }})
+    """, null
     )
         .use { cursor ->
-          val projectionsByHash = linkedMapOf<String, HeapAnalysisGroupProjection>()
+          val leakReadStatuses = mutableMapOf<String, Boolean>()
           while (cursor.moveToNext()) {
-            val hash = cursor.getString(0)
-            val description = cursor.getString(1)
-            val createdAtTimeMillis = cursor.getLong(2)
-            val leakCount = cursor.getInt(3)
-            val isLibraryLeak = cursor.getInt(4) == 1
-            val isNew = cursor.getInt(5) == 0
-            val group = HeapAnalysisGroupProjection(
-                hash, description, createdAtTimeMillis, leakCount, isNew, isLibraryLeak
-            )
-            projectionsByHash[hash] = group
+            val signature = cursor.getString(0)
+            val isRead = cursor.getInt(1) == 1
+            leakReadStatuses[signature] = isRead
           }
-          projectionsByHash
+          leakReadStatuses
         }
   }
 
-  class GroupProjection(
-    val hash: String,
-    val description: String,
+  class AllLeaksProjection(
+    val signature: String,
+    val shortDescription: String,
     val createdAtTimeMillis: Long,
-    val leakCount: Int,
+    val leakTraceCount: Int,
     val isLibraryLeak: Boolean,
     val isNew: Boolean
   )
 
   fun retrieveAllLeaks(
     db: SQLiteDatabase
-  ): List<GroupProjection> {
+  ): List<AllLeaksProjection> {
     return db.rawQuery(
         """
           SELECT
-          group_hash
-          , group_description
-          , MAX(created_at_time_millis) as created_at_time_millis
-          , COUNT(*) as leak_count
-          , MIN(is_library_leak) as is_library_leak
-          , MAX(is_read) as is_read
-          FROM leak l
-          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
-          GROUP BY 1, 2
-          ORDER BY leak_count DESC, created_at_time_millis DESC
+          l.signature
+          , MIN(l.short_description)
+          , MAX(h.created_at_time_millis) as created_at_time_millis
+          , COUNT(*) as leak_trace_count
+          , MIN(l.is_library_leak) as is_library_leak
+          , MAX(l.is_read) as is_read
+          FROM leak_trace lt
+          LEFT JOIN leak l on lt.leak_id = l.id
+          LEFT JOIN heap_analysis h ON lt.heap_analysis_id = h.id
+          GROUP BY 1
+          ORDER BY leak_trace_count DESC, created_at_time_millis DESC
           """, null
     )
         .use { cursor ->
-          val all = mutableListOf<GroupProjection>()
+          val all = mutableListOf<AllLeaksProjection>()
           while (cursor.moveToNext()) {
-            val group = GroupProjection(
-                hash = cursor.getString(0),
-                description = cursor.getString(1),
+            val group = AllLeaksProjection(
+                signature = cursor.getString(0),
+                shortDescription = cursor.getString(1),
                 createdAtTimeMillis = cursor.getLong(2),
-                leakCount = cursor.getInt(3),
+                leakTraceCount = cursor.getInt(3),
                 isLibraryLeak = cursor.getInt(4) == 1,
                 isNew = cursor.getInt(5) == 0
             )
@@ -141,96 +131,72 @@ internal object LeakTable {
         }
   }
 
-  class LeakProjection(
-    val id: Long,
-    val analysisId: Long,
-    val classSimpleName: String,
-    val groupDescription: String,
-    val createdAtTimeMillis: Long,
-    val isNew: Boolean,
-    val isLibraryLeak: Boolean
-  )
-
   fun markAsRead(
     db: SQLiteDatabase,
-    leakId: Long
+    signature: String
   ) {
-    val values = ContentValues()
-    values.put("is_read", 1)
-    db.update("leak", values, "id = ?", arrayOf(leakId.toString()))
+    val values = ContentValues().apply { put("is_read", 1) }
+    db.update("leak", values, "signature = ?", arrayOf(signature))
   }
 
-  fun retrieveLeaksByHash(
+  class LeakProjection(
+    val shortDescription: String,
+    val isNew: Boolean,
+    val isLibraryLeak: Boolean,
+    val leakTraces: List<LeakTraceProjection>
+  )
+
+  class LeakTraceProjection(
+    val leakTraceIndex: Int,
+    val heapAnalysisId: Long,
+    val classSimpleName: String,
+    val createdAtTimeMillis: Long
+  )
+
+  fun retrieveLeakBySignature(
     db: SQLiteDatabase,
-    groupHash: String
-  ): List<LeakProjection> {
+    signature: String
+  ): LeakProjection? {
     return db.rawQuery(
         """
           SELECT
-          l.id
-          , l.heap_analysis_id
-          , l.class_simple_name
-          , l.group_description
+          lt.leak_trace_index
+          , lt.heap_analysis_id
+          , lt.class_simple_name
           , h.created_at_time_millis
+          , l.short_description
           , l.is_read
           , l.is_library_leak
-          FROM leak l
-          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
-          WHERE group_hash = ?
+          FROM leak_trace lt
+          LEFT JOIN leak l on lt.leak_id = l.id
+          LEFT JOIN heap_analysis h ON lt.heap_analysis_id = h.id
+          WHERE l.signature = ?
           ORDER BY h.created_at_time_millis DESC
-          """, arrayOf(groupHash)
+          """, arrayOf(signature)
     )
         .use { cursor ->
-          val leaks = mutableListOf<LeakProjection>()
-          while (cursor.moveToNext()) {
-            leaks += LeakProjection(
-                id = cursor.getLong(0),
-                analysisId = cursor.getLong(1),
-                classSimpleName = cursor.getString(2),
-                groupDescription = cursor.getString(3),
-                createdAtTimeMillis = cursor.getLong(4),
+          return if (cursor.moveToFirst()) {
+            val leakTraces = mutableListOf<LeakTraceProjection>()
+            val leakProjection = LeakProjection(
+                shortDescription = cursor.getString(4),
                 isNew = cursor.getInt(5) == 0,
-                isLibraryLeak = cursor.getInt(6) == 1
+                isLibraryLeak = cursor.getInt(6) == 1,
+                leakTraces = leakTraces
             )
+            leakTraces.addAll(generateSequence(cursor, {
+              if (cursor.moveToNext()) cursor else null
+            }).map {
+              LeakTraceProjection(
+                  leakTraceIndex = cursor.getInt(0),
+                  heapAnalysisId = cursor.getLong(1),
+                  classSimpleName = cursor.getString(2),
+                  createdAtTimeMillis = cursor.getLong(3)
+              )
+            })
+            leakProjection
+          } else {
+            null
           }
-          return leaks
-        }
-  }
-
-  class LeakDetails(
-    val leak: Leak,
-    val analysisId: Long,
-    val analysis: HeapAnalysisSuccess,
-    val isNew: Boolean
-  )
-
-  fun retrieveLeakById(
-    db: SQLiteDatabase,
-    leakId: Long
-  ): LeakDetails? {
-    return db.rawQuery(
-        """
-          SELECT
-          l.heap_analysis_id
-          , l.object
-          , h.object
-          , l.is_read
-          FROM leak l
-          LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
-          WHERE l.id = ?
-          LIMIT 1
-          """, arrayOf(leakId.toString())
-    )
-        .use { cursor ->
-          return if (cursor.moveToNext()) {
-            val heapAnalysisId = cursor.getLong(0)
-            val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(1))
-            val analysis = Serializables.fromByteArray<HeapAnalysisSuccess>(cursor.getBlob(2))
-            val isNew = cursor.getInt(3) == 0
-            if (leakingInstance != null && analysis != null) {
-              LeakDetails(leakingInstance, heapAnalysisId, analysis, isNew)
-            } else null
-          } else null
         }
   }
 
@@ -238,27 +204,20 @@ internal object LeakTable {
     db: SQLiteDatabase,
     heapAnalysisId: Long
   ) {
-    db.delete("leak", "heap_analysis_id=$heapAnalysisId", null)
+    LeakTraceTable.deleteByHeapAnalysisId(db, heapAnalysisId)
+    db.execSQL(
+        """
+      DELETE
+      FROM leak
+      WHERE NOT EXISTS (
+      SELECT *
+      FROM leak_trace lt
+      WHERE leak.id = lt.leak_id)
+    """)
   }
 
   fun deleteAll(db: SQLiteDatabase) {
     db.delete("leak", null, null)
-  }
-
-  private fun Leak.createGroupDescription(): String {
-    return if (this is LibraryLeak) {
-      pattern.toString()
-    } else {
-      val leakCauses = leakTrace.leakCauses
-      if (leakCauses.isEmpty()) {
-        // Should rarely happen, don't expect to see 0 unknown and 100% leaking or 100% not leaking
-        className
-      } else {
-        val element = leakCauses.first()
-        val referenceName = element.reference!!.groupingName
-        val refDescription = element.classSimpleName + "." + referenceName
-        refDescription
-      }
-    }
+    LeakTraceTable.deleteAll(db)
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt
new file mode 100644
index 000000000..9b050d38f
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTraceTable.kt
@@ -0,0 +1,48 @@
+package leakcanary.internal.activity.db
+
+import android.content.ContentValues
+import android.database.sqlite.SQLiteDatabase
+import org.intellij.lang.annotations.Language
+
+internal object LeakTraceTable {
+
+  @Language("RoomSql")
+  const val create = """
+        CREATE TABLE leak_trace
+        (
+        id INTEGER PRIMARY KEY,
+        heap_analysis_id REFERENCES heap_analysis(id),
+        leak_id REFERENCES leak(id),
+        class_simple_name TEXT,
+        leak_trace_index INTEGER
+        )"""
+
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS leak_trace"
+
+  fun insert(
+    db: SQLiteDatabase,
+    leakId: Long,
+    heapAnalysisId: Long,
+    leakTraceIndex: Int,
+    leakingObjectClassSimpleName: String
+  ): Long {
+    val values = ContentValues()
+    values.put("heap_analysis_id", heapAnalysisId)
+    values.put("leak_id", leakId)
+    values.put("class_simple_name", leakingObjectClassSimpleName)
+    values.put("leak_trace_index", leakTraceIndex)
+    return db.insertOrThrow("leak_trace", null, values)
+  }
+
+  fun deleteByHeapAnalysisId(
+    db: SQLiteDatabase,
+    heapAnalysisId: Long
+  ) {
+    db.delete("leak_trace", "heap_analysis_id=$heapAnalysisId", null)
+  }
+
+  fun deleteAll(db: SQLiteDatabase) {
+    db.delete("leak_trace", null, null)
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index bb3008f5f..530776670 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -4,6 +4,9 @@ import android.content.ContentValues
 import android.content.Context
 import android.database.sqlite.SQLiteDatabase
 import android.database.sqlite.SQLiteOpenHelper
+import leakcanary.internal.Serializables
+import shark.HeapAnalysis
+import shark.HeapAnalysisSuccess
 
 internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
     context, DATABASE_NAME, null, VERSION
@@ -12,7 +15,8 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   override fun onCreate(db: SQLiteDatabase) {
     db.execSQL(HeapAnalysisTable.create)
     db.execSQL(LeakTable.create)
-    db.execSQL(LeakTable.createGroupHashIndex)
+    db.execSQL(LeakTable.createSignatureIndex)
+    db.execSQL(LeakTraceTable.create)
   }
 
   override fun onUpgrade(
@@ -20,19 +24,35 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
     oldVersion: Int,
     newVersion: Int
   ) {
-    // LeakCanary 2.0 to LeakCanary 2.1
-    if (oldVersion == 19 && newVersion == 21) {
-      db.execSQL(
-          """
-        ALTER TABLE leak
-          ADD is_read INTEGER;
-      """.trimIndent()
-      )
-      db.update("leak", ContentValues().apply {
-        put("is_read", 1)
-      }, null, null)
-    } else {
+    if (oldVersion < 19) {
+      recreateDb(db)
+    } else if (oldVersion == 19) {
+      // Migration from LeakCanary 2.0
+      val allAnalysis = db.rawQuery("SELECT object FROM heap_analysis", null)
+          .use { cursor ->
+            generateSequence {
+              if (cursor.moveToNext()) {
+                Serializables.fromByteArray<HeapAnalysis>(cursor.getBlob(0))
+              } else {
+                null
+              }
+            }
+                .map {
+                  if (it is HeapAnalysisSuccess) {
+                    HeapAnalysisSuccess.upgradeFrom20Deserialized(it)
+                  } else it
+                }
+                .toList()
+          }
       recreateDb(db)
+      db.inTransaction {
+        allAnalysis.forEach { HeapAnalysisTable.insert(db, it) }
+        db.update("leak", ContentValues().apply {
+          put("is_read", 1)
+        }, null, null)
+      }
+    } else {
+      throw IllegalStateException("Database migration from $oldVersion not supported")
     }
   }
 
@@ -47,11 +67,12 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   private fun recreateDb(db: SQLiteDatabase) {
     db.execSQL(HeapAnalysisTable.drop)
     db.execSQL(LeakTable.drop)
+    db.execSQL(LeakTraceTable.drop)
     onCreate(db)
   }
 
   companion object {
-    internal const val VERSION = 21
+    internal const val VERSION = 23
     internal const val DATABASE_NAME = "leaks.db"
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
index 54a80d54d..278dfd11d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
@@ -13,7 +13,6 @@ import android.widget.TextView
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakTable
-import leakcanary.internal.activity.db.LeakTable.HeapAnalysisGroupProjection
 import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.share
 import leakcanary.internal.activity.shareHeapDump
@@ -26,6 +25,7 @@ import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
 import shark.HeapAnalysisSuccess
+import shark.LibraryLeak
 
 internal class HeapDumpScreen(
   private val analysisId: Long
@@ -42,17 +42,17 @@ internal class HeapDumpScreen(
             activity.title = resources.getString(R.string.leak_canary_analysis_deleted_title)
           }
         } else {
-          val leakGroupByHash =
-            LeakTable.retrieveHeapDumpLeaks(db, analysisId)
+          val signatures = heapAnalysis.allLeaks.map { it.signature }.toSet()
+          val leakReadStatus = LeakTable.retrieveLeakReadStatuses(db, signatures)
           val heapDumpFileExist = heapAnalysis.heapDumpFile.exists()
-          updateUi { onSuccessRetrieved(heapAnalysis, leakGroupByHash, heapDumpFileExist) }
+          updateUi { onSuccessRetrieved(heapAnalysis, leakReadStatus, heapDumpFileExist) }
         }
       }
     }
 
   private fun View.onSuccessRetrieved(
     heapAnalysis: HeapAnalysisSuccess,
-    leakGroupByHash: Map<String, HeapAnalysisGroupProjection>,
+    leakReadStatus: Map<String, Boolean>,
     heapDumpFileExist: Boolean
   ) {
 
@@ -80,17 +80,8 @@ internal class HeapDumpScreen(
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val retainedInstances = heapAnalysis.allLeaks
-
-    retainedInstances.forEach { retainedInstance ->
-      if (leakGroupByHash[retainedInstance.groupHash] == null) {
-        throw IllegalStateException(
-            "Removing groups is not supported, this should never happen."
-        )
-      }
-    }
-
-    val leakGroups = leakGroupByHash.values.toList()
+    val leaks = heapAnalysis.allLeaks.sortedByDescending { it.leakTraces.size }
+        .toList()
 
     listView.adapter = object : BaseAdapter() {
       override fun getView(
@@ -138,8 +129,6 @@ internal class HeapDumpScreen(
           }
 
           textView.text = title
-
-
           view
         }
         LEAK_TITLE -> {
@@ -147,7 +136,7 @@ internal class HeapDumpScreen(
           val leaksTextView = view.findViewById<TextView>(R.id.leak_canary_heap_dump_leaks)
           leaksTextView.text = resources.getQuantityString(
               R.plurals.leak_canary_distinct_leaks,
-              leakGroups.size, leakGroups.size
+              leaks.size, leaks.size
           )
           view
         }
@@ -159,19 +148,19 @@ internal class HeapDumpScreen(
           val newChipView = view.findViewById<TextView>(R.id.leak_canary_chip_new)
           val libraryLeakChipView = view.findViewById<TextView>(R.id.leak_canary_chip_library_leak)
 
-          val projection = leakGroups[position - 2]
+          val leak = leaks[position - 2]
 
-          countView.isEnabled = projection.isNew
-          newChipView.visibility = if (projection.isNew) VISIBLE else GONE
-          libraryLeakChipView.visibility = if (projection.isLibraryLeak) VISIBLE else GONE
+          val isNew = !leakReadStatus.getValue(leak.signature)
 
-          countView.text = projection.leakCount.toString()
-          descriptionView.text = projection.description
+          countView.isEnabled = isNew
+          countView.text = leak.leakTraces.size.toString()
+          newChipView.visibility = if (isNew) VISIBLE else GONE
+          libraryLeakChipView.visibility = if (leak is LibraryLeak) VISIBLE else GONE
+          descriptionView.text = leak.shortDescription
 
           val formattedDate =
-            TimeFormatter.formatTimestamp(view.context, projection.createdAtTimeMillis)
-          timeView.text =
-            resources.getString(R.string.leak_canary_group_list_time_label, formattedDate)
+            TimeFormatter.formatTimestamp(view.context, heapAnalysis.createdAtTimeMillis)
+          timeView.text = formattedDate
           view
         }
         else -> {
@@ -183,7 +172,7 @@ internal class HeapDumpScreen(
 
       override fun getItemId(position: Int) = position.toLong()
 
-      override fun getCount() = 2 + leakGroups.size
+      override fun getCount() = 2 + leaks.size
 
       override fun getItemViewType(position: Int) = when (position) {
         0 -> METADATA
@@ -198,7 +187,7 @@ internal class HeapDumpScreen(
 
     listView.setOnItemClickListener { _, _, position, _ ->
       if (position > LEAK_TITLE) {
-        goTo(LeakScreen(leakGroups[position - 2].hash, analysisId))
+        goTo(LeakScreen(leaks[position - 2].signature, analysisId))
       }
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
index a25b40b3d..ff2ce8310 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
@@ -94,7 +94,7 @@ internal class HeapDumpsScreen : Screen() {
 
         val count = projection.exceptionSummary ?: resources.getQuantityString(
             R.plurals.leak_canary_distinct_leaks,
-            projection.leakGroupCount, projection.leakGroupCount
+            projection.leakCount, projection.leakCount
         )
         countView.text = count
       }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index 63fc379ae..3c00fc740 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -17,13 +17,13 @@ import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
 import shark.HeapField
-import shark.HprofHeapGraph
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
 import shark.HeapObject.HeapPrimitiveArray
 import shark.HeapValue
 import shark.Hprof
+import shark.HprofHeapGraph
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
index 23f9f1899..ae35dbf35 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
@@ -12,8 +12,8 @@ import android.widget.TextView
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.SquigglySpan
+import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakTable
-import leakcanary.internal.activity.db.LeakTable.LeakDetails
 import leakcanary.internal.activity.db.LeakTable.LeakProjection
 import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.share
@@ -27,36 +27,45 @@ import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import shark.HeapAnalysisSuccess
-import shark.Leak
+import shark.LeakTrace
 import shark.LibraryLeak
 
 internal class LeakScreen(
-  private val groupHash: String,
+  private val leakSignature: String,
   private val selectedHeapAnalysisId: Long? = null
 ) : Screen() {
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_leak_screen).apply {
       activity.title = resources.getString(R.string.leak_canary_loading_title)
       executeOnDb {
-        val leaks = LeakTable.retrieveLeaksByHash(db, groupHash)
-        val selectedLeakIndex =
-          if (selectedHeapAnalysisId == null) 0 else leaks.indexOfFirst { it.analysisId == selectedHeapAnalysisId }
-        updateUi {
-          if (leaks.isEmpty()) {
+        val leak = LeakTable.retrieveLeakBySignature(db, leakSignature)
+
+        if (leak == null) {
+          updateUi {
             activity.title = resources.getString(R.string.leak_canary_leak_not_found)
-          } else {
-            onLeaksRetrieved(leaks, selectedLeakIndex)
           }
+        } else {
+          val selectedLeakIndex =
+            if (selectedHeapAnalysisId == null) 0 else leak.leakTraces.indexOfFirst { it.heapAnalysisId == selectedHeapAnalysisId }
+
+          val heapAnalysisId = leak.leakTraces[selectedLeakIndex].heapAnalysisId
+          val selectedHeapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, heapAnalysisId)!!
+
+          updateUi {
+            onLeaksRetrieved(leak, selectedLeakIndex, selectedHeapAnalysis)
+          }
+          LeakTable.markAsRead(db, leakSignature)
         }
       }
     }
 
   private fun View.onLeaksRetrieved(
-    leaks: List<LeakProjection>,
-    selectedLeakIndex: Int
+    leak: LeakProjection,
+    selectedLeakTraceIndex: Int,
+    selectedHeapAnalysis: HeapAnalysisSuccess
   ) {
-    val isLibraryLeak = leaks.any { it.isLibraryLeak }
-    val isNew = leaks.all { it.isNew }
+    val isLibraryLeak = leak.isLibraryLeak
+    val isNew = leak.isNew
     val newChipView = findViewById<TextView>(R.id.leak_canary_chip_new)
     val libraryLeakChipView = findViewById<TextView>(R.id.leak_canary_chip_library_leak)
     newChipView.visibility = if (isNew) View.VISIBLE else View.GONE
@@ -64,22 +73,26 @@ internal class LeakScreen(
 
     activity.title = String.format(
         resources.getQuantityText(
-            R.plurals.leak_canary_group_screen_title, leaks.size
-        ).toString(), leaks.size, leaks[0].groupDescription
+            R.plurals.leak_canary_group_screen_title, leak.leakTraces.size
+        ).toString(), leak.leakTraces.size, leak.shortDescription
     )
 
     val spinner = findViewById<Spinner>(R.id.leak_canary_spinner)
 
-    spinner.adapter = SimpleListAdapter(R.layout.leak_canary_simple_row, leaks) { view, position ->
-      val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-      val timeView = view.findViewById<TextView>(R.id.leak_canary_row_small_text)
-      titleView.text =
-        view.resources.getString(
-            R.string.leak_canary_class_has_leaked, leaks[position].classSimpleName
-        )
-      timeView.text =
-        TimeFormatter.formatTimestamp(view.context, leaks[position].createdAtTimeMillis)
-    }
+    spinner.adapter =
+      SimpleListAdapter(R.layout.leak_canary_simple_row, leak.leakTraces) { view, position ->
+        val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+        val timeView = view.findViewById<TextView>(R.id.leak_canary_row_small_text)
+        titleView.text =
+          view.resources.getString(
+              R.string.leak_canary_class_has_leaked, leak.leakTraces[position].classSimpleName
+          )
+        timeView.text =
+          TimeFormatter.formatTimestamp(view.context, leak.leakTraces[position].createdAtTimeMillis)
+      }
+
+    var lastSelectedLeakTraceIndex = selectedLeakTraceIndex
+    var lastSelectedHeapAnalysis = selectedHeapAnalysis
 
     spinner.onItemSelectedListener = object : OnItemSelectedListener {
       override fun onNothingSelected(parent: AdapterView<*>?) {
@@ -91,26 +104,33 @@ internal class LeakScreen(
         position: Int,
         id: Long
       ) {
-        executeOnDb {
-          val displayedLeak = leaks[position]
-          LeakTable.retrieveLeakById(db, displayedLeak.id)
-              ?.let { leak ->
-                updateUi {
-                  displayLeakTrace(leak)
-                }
-                if (leak.isNew) {
-                  LeakTable.markAsRead(db, displayedLeak.id)
-                }
-              }
+        val selectedLeakTrace = leak.leakTraces[position]
+
+        val selectedHeapAnalysisId = selectedLeakTrace.heapAnalysisId
+        val lastSelectedHeapAnalysisId = leak.leakTraces[lastSelectedLeakTraceIndex].heapAnalysisId
+
+        if (selectedHeapAnalysisId != lastSelectedHeapAnalysisId) {
+          executeOnDb {
+            val newSelectedHeapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(db, selectedHeapAnalysisId)!!
+            updateUi {
+              lastSelectedLeakTraceIndex = position
+              lastSelectedHeapAnalysis = newSelectedHeapAnalysis
+              onLeakTraceSelected(newSelectedHeapAnalysis, selectedHeapAnalysisId, selectedLeakTrace.leakTraceIndex)
+            }
+          }
+        } else {
+          lastSelectedLeakTraceIndex = position
+          onLeakTraceSelected(lastSelectedHeapAnalysis, selectedHeapAnalysisId, selectedLeakTrace.leakTraceIndex)
         }
       }
     }
-    spinner.setSelection(selectedLeakIndex)
+    spinner.setSelection(selectedLeakTraceIndex)
   }
 
-  private fun View.displayLeakTrace(projection: LeakDetails) {
-    val leak = projection.leak
-    val analysis = projection.analysis
+
+private fun View.onLeakTraceSelected(analysis: HeapAnalysisSuccess, heapAnalysisId: Long, leakTraceIndex: Int) {
+  val selectedLeak = analysis.allLeaks.first { it.signature == leakSignature }
+  val leakTrace = selectedLeak.leakTraces[leakTraceIndex]
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
     listView.alpha = 0f
@@ -123,10 +143,10 @@ internal class LeakScreen(
       Share <a href="share_hprof">Heap Dump file</a><br><br>
       References <b><u>underlined</u></b> are the likely causes of the leak.
       Learn more at <a href="https://squ.re/leaks">https://squ.re/leaks</a>
-    """.trimIndent() + if (leak is LibraryLeak) "<br><br>" +
+    """.trimIndent() + if (selectedLeak is LibraryLeak) "<br><br>" +
         "A <font color='#FFCC32'>Library Leak</font> is a leak coming from the Android Framework or Google libraries.<br><br>" +
-        "<b>Leak pattern</b>: ${leak.pattern}<br><br>" +
-        "<b>Description</b>: ${leak.description}" else ""
+        "<b>Leak pattern</b>: ${selectedLeak.pattern}<br><br>" +
+        "<b>Description</b>: ${selectedLeak.description}" else ""
 
     val title = Html.fromHtml(titleText) as SpannableStringBuilder
     SquigglySpan.replaceUnderlineSpans(title, context)
@@ -135,17 +155,17 @@ internal class LeakScreen(
       when (urlSpan) {
         "share" -> {
           {
-            share(leakToString(leak, analysis))
+            share(leakToString(leakTrace, analysis))
           }
         }
         "share_stack_overflow" -> {
           {
-            shareToStackOverflow(leakToString(leak, analysis))
+            shareToStackOverflow(leakToString(leakTrace, analysis))
           }
         }
         "open_analysis" -> {
           {
-            goTo(HeapDumpScreen(projection.analysisId))
+            goTo(HeapDumpScreen(heapAnalysisId))
           }
         }
         "share_hprof" -> {
@@ -157,14 +177,14 @@ internal class LeakScreen(
       }
     }
 
-    val adapter = DisplayLeakAdapter(context, leak.leakTrace, title)
+    val adapter = DisplayLeakAdapter(context, leakTrace, title)
     listView.adapter = adapter
   }
 
   private fun leakToString(
-    leak: Leak,
+    leakTrace: LeakTrace,
     analysis: HeapAnalysisSuccess
-  ) = """$leak
+  ) = """$leakTrace
 
 METADATA
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
index 5fcc292d9..28fdee233 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
@@ -8,7 +8,7 @@ import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.db.LeakTable
-import leakcanary.internal.activity.db.LeakTable.GroupProjection
+import leakcanary.internal.activity.db.LeakTable.AllLeaksProjection
 import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.activity.ui.TimeFormatter
@@ -26,7 +26,7 @@ internal class LeaksScreen : Screen() {
       }
     }
 
-  private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
+  private fun View.onGroupsRetrieved(projections: List<AllLeaksProjection>) {
     activity.title = resources.getQuantityString(
         R.plurals.leak_canary_distinct_leaks,
         projections.size, projections.size
@@ -48,8 +48,8 @@ internal class LeaksScreen : Screen() {
         newChipView.visibility = if (projection.isNew) VISIBLE else GONE
         libraryLeakChipView.visibility = if (projection.isLibraryLeak) VISIBLE else GONE
 
-        countView.text = projection.leakCount.toString()
-        descriptionView.text = projection.description
+        countView.text = projection.leakTraceCount.toString()
+        descriptionView.text = projection.shortDescription
 
         val formattedDate =
           TimeFormatter.formatTimestamp(view.context, projection.createdAtTimeMillis)
@@ -58,7 +58,7 @@ internal class LeaksScreen : Screen() {
       }
 
     listView.setOnItemClickListener { _, _, position, _ ->
-      goTo(LeakScreen(projections[position].hash))
+      goTo(LeakScreen(projections[position].signature))
     }
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
index 96c2b0c68..d9470b86d 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -26,11 +26,13 @@ object TestUtils {
       )
     }
 
-    val leakInstance = applicationLeaks.first()
+    val leak = applicationLeaks.first()
 
-    if (leakInstance.className != expectedLeakClass.name) {
+    val leakTrace = leak.leakTraces.first()
+    val className = leakTrace.leakingObject.className
+    if (className != expectedLeakClass.name) {
       throw AssertionError(
-          "Expected a leak of $expectedLeakClass, not ${leakInstance.className} in $heapAnalysis"
+          "Expected a leak of $expectedLeakClass, not $className in $heapAnalysis"
       )
     }
   }
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index f8f5aeb10..87baffcef 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -2,7 +2,8 @@ package shark
 
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
-import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
+import shark.GcRoot.StickyClass
+import shark.LeakTrace.GcRootType
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
 import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
@@ -14,10 +15,10 @@ class LegacyHprofTest {
   @Test fun preM() {
     val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
     assertThat(analysis.applicationLeaks).hasSize(2)
-    val leak1 = analysis.applicationLeaks[0]
-    val leak2 = analysis.applicationLeaks[1]
-    assertThat(leak1.className).isEqualTo("android.graphics.Bitmap")
-    assertThat(leak2.className).isEqualTo("com.example.leakcanary.MainActivity")
+    val leak1 = analysis.applicationLeaks[0].leakTraces.first()
+    val leak2 = analysis.applicationLeaks[1].leakTraces.first()
+    assertThat(leak1.leakingObject.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak2.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
     assertThat(analysis.metadata).isEqualTo(
         mapOf(
             "App process name" to "com.example.leakcanary",
@@ -32,9 +33,9 @@ class LegacyHprofTest {
     val analysis = analyzeHprof("leak_asynctask_m.hprof")
 
     assertThat(analysis.applicationLeaks).hasSize(1)
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak.leakTrace.elements[0].labels).contains("GC Root: System class")
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak.gcRootType).isEqualTo(GcRootType.STICKY_CLASS)
   }
 
   @Test fun gcRootReferencesUnknownObject() {
@@ -70,8 +71,8 @@ class LegacyHprofTest {
     val analysis = analyzeHprof("leak_asynctask_o.hprof")
 
     assertThat(analysis.applicationLeaks).hasSize(1)
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   private enum class WRAPS_ACTIVITY {
@@ -111,8 +112,8 @@ class LegacyHprofTest {
     val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
 
     assertThat(analysis.applicationLeaks).hasSize(1)
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+    val leak = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leak.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index f238e6a07..26fad2819 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -1,5 +1,14 @@
 package shark
 
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
@@ -20,6 +29,7 @@ import shark.internal.IndexedObject.IndexedInstance
 import shark.internal.IndexedObject.IndexedObjectArray
 import shark.internal.IndexedObject.IndexedPrimitiveArray
 import shark.internal.LruCache
+import kotlin.reflect.KClass
 
 /**
  * A [HeapGraph] that reads from an indexed [Hprof]. Create a new instance with [indexHprof].
@@ -188,9 +198,36 @@ class HprofHeapGraph internal constructor(
   companion object {
     fun indexHprof(
       hprof: Hprof,
-      proguardMapping: ProguardMapping? = null
+      proguardMapping: ProguardMapping? = null,
+      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
+          JniGlobal::class,
+          JavaFrame::class,
+          JniLocal::class,
+          MonitorUsed::class,
+          NativeStack::class,
+          StickyClass::class,
+          ThreadBlock::class,
+          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+          // belongs to
+          ThreadObject::class,
+          JniMonitor::class
+          /*
+          Not included here:
+
+          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+          to do? What's VmInternal exactly? History does not go further than
+          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+          We should log to figure out what objects VmInternal points to.
+
+          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+          Unknown: it's unknown, should we care?
+
+          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+           */
+      )
     ): HeapGraph {
-      val index = HprofInMemoryIndex.createReadingHprof(hprof, proguardMapping)
+      val index = HprofInMemoryIndex.createReadingHprof(hprof, proguardMapping, indexedGcRootTypes)
       return HprofHeapGraph(hprof, index)
     }
   }
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index 5e0d7d0f2..d95aa19a8 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -1,15 +1,6 @@
 package shark.internal
 
 import shark.GcRoot
-import shark.GcRoot.JavaFrame
-import shark.GcRoot.JniGlobal
-import shark.GcRoot.JniLocal
-import shark.GcRoot.JniMonitor
-import shark.GcRoot.MonitorUsed
-import shark.GcRoot.NativeStack
-import shark.GcRoot.StickyClass
-import shark.GcRoot.ThreadBlock
-import shark.GcRoot.ThreadObject
 import shark.Hprof
 import shark.HprofRecord
 import shark.HprofRecord.HeapDumpRecord.GcRootRecord
@@ -358,33 +349,7 @@ internal class HprofInMemoryIndex private constructor(
     fun createReadingHprof(
       hprof: Hprof,
       proguardMapping: ProguardMapping?,
-      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
-          JniGlobal::class,
-          JavaFrame::class,
-          JniLocal::class,
-          MonitorUsed::class,
-          NativeStack::class,
-          StickyClass::class,
-          ThreadBlock::class,
-          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
-          // belongs to
-          ThreadObject::class,
-          JniMonitor::class
-          /*
-          Not included here:
-
-          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
-          to do? What's VmInternal exactly? History does not go further than
-          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-          We should log to figure out what objects VmInternal points to.
-
-          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
-
-          Unknown: it's unknown, should we care?
-
-          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
-           */
-      )
+      indexedGcRootTypes: Set<KClass<out GcRoot>>
     ): HprofInMemoryIndex {
       val recordTypes = setOf(
           StringRecord::class,
diff --git a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
index 292f41e06..881a44be7 100644
--- a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
+++ b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
@@ -4,7 +4,6 @@ import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import shark.internal.aosp.ByteArrayComparator
 import shark.internal.aosp.ByteArrayTimSort
-import java.lang.IllegalStateException
 import kotlin.random.Random
 
 class ByteArrayTimSortTest {
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
index f8cdeb736..15ee1f237 100644
--- a/shark/src/main/java/shark/HeapAnalysis.kt
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -24,6 +24,10 @@ sealed class HeapAnalysis : Serializable {
    * Total time spent analyzing the heap.
    */
   abstract val analysisDurationMillis: Long
+
+  companion object {
+    private const val serialVersionUID: Long = -8657286725869987172
+  }
 }
 
 /**
@@ -59,6 +63,10 @@ Heap dump file path: ${heapDumpFile.absolutePath}
 Heap dump timestamp: $createdAtTimeMillis
 ===================================="""
   }
+
+  companion object {
+    private const val serialVersionUID: Long = 8483254400637792414
+  }
 }
 
 /**
@@ -82,8 +90,8 @@ data class HeapAnalysisSuccess(
    * The list of [Leak] found in the heap dump by [HeapAnalyzer], ie all [applicationLeaks] and
    * all [libraryLeaks] in one list.
    */
-  val allLeaks: List<Leak>
-    get() = applicationLeaks + libraryLeaks
+  val allLeaks: Sequence<Leak>
+    get() = applicationLeaks.asSequence() + libraryLeaks.asSequence()
 
   override fun toString(): String {
     return """====================================
@@ -113,53 +121,88 @@ Heap dump file path: ${heapDumpFile.absolutePath}
 Heap dump timestamp: $createdAtTimeMillis
 ===================================="""
   }
+
+  companion object {
+    private const val serialVersionUID: Long = 130453013437459642
+
+    /**
+     * If [fromV20] was serialized in LeakCanary 2.0, you must deserialize it and call this
+     * method to create a usable [HeapAnalysisSuccess] instance.
+     */
+    fun upgradeFrom20Deserialized(fromV20: HeapAnalysisSuccess): HeapAnalysisSuccess {
+      val applicationLeaks = fromV20.applicationLeaks
+          .map { it.leakTraceFromV20() }
+          .groupBy { it.signature }
+          .values
+          .map {
+            ApplicationLeak(it)
+          }
+
+      val libraryLeaks = fromV20.libraryLeaks
+          .map { it to it.leakTraceFromV20() }
+          .groupBy { it.second.signature }
+          .values
+          .map { listOfPairs ->
+            val libraryLeakFrom20 = listOfPairs.first()
+                .first
+            LibraryLeak(pattern = libraryLeakFrom20.pattern,
+                description = libraryLeakFrom20.description,
+                leakTraces = listOfPairs.map { it.second }
+            )
+          }
+      return HeapAnalysisSuccess(
+          heapDumpFile = fromV20.heapDumpFile,
+          createdAtTimeMillis = fromV20.createdAtTimeMillis,
+          analysisDurationMillis = fromV20.analysisDurationMillis,
+          metadata = fromV20.metadata,
+          applicationLeaks = applicationLeaks,
+          libraryLeaks = libraryLeaks
+      )
+    }
+  }
 }
 
 /**
  * A leak found by [HeapAnalyzer], either an [ApplicationLeak] or a [LibraryLeak].
  */
 sealed class Leak : Serializable {
-  /**
-   * Class name of the leaking object.
-   * The class name format is the same as what would be returned by [Class.getName].
-   */
-  abstract val className: String
 
   /**
-   * Shortest path from GC roots to the leaking object.
+   * Group of leak traces which share the same leak signature.
    */
-  abstract val leakTrace: LeakTrace
+  abstract val leakTraces: List<LeakTrace>
 
   /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. Null if the retained heap size was not computed.
+   * Sum of [LeakTrace.retainedHeapByteSize] for all elements in [leakTraces].
+   * Null if the retained heap size was not computed.
    */
-  abstract val retainedHeapByteSize: Int?
+  val totalRetainedHeapByteSize: Int?
+    get() = if (leakTraces.first().retainedHeapByteSize == null) {
+      null
+    } else {
+      leakTraces.sumBy { it.retainedHeapByteSize!! }
+    }
 
   /**
-   * A unique SHA1 hash that represents this group of leaks.
+   * A unique SHA1 hash that represents this group of leak traces.
    *
-   * For [ApplicationLeak] this is based on [LeakTrace.leakCauses] and for [LibraryLeak] this is
+   * For [ApplicationLeak] this is based on [LeakTrace.signature] and for [LibraryLeak] this is
    * based on [LibraryLeak.pattern].
    */
-  val groupHash
-    get() = createGroupHash()
+  abstract val signature: String
 
-  /**
-   * Returns [className] stripped of any string content before the last period (included).
-   */
-  val classSimpleName: String
-    get() {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) className else className.substring(separator + 1)
-    }
+  abstract val shortDescription: String
 
   override fun toString(): String {
-    return (if (retainedHeapByteSize != null) "$retainedHeapByteSize bytes retained\n" else "") +
-        leakTrace
+    return (if (totalRetainedHeapByteSize != null) "$totalRetainedHeapByteSize bytes retained by leaking objects\n" else "") +
+        (if (leakTraces.size > 1) "Displaying only 1 leak trace out of ${leakTraces.size} with the same signature\n" else "") +
+        "Signature: $signature\n" +
+        leakTraces.first()
   }
 
-  protected abstract fun createGroupHash(): String
+  companion object {
+    private const val serialVersionUID: Long = -2287572510360910916
+  }
 }
 
 /**
@@ -168,11 +211,9 @@ sealed class Leak : Serializable {
  * instance. This is a known leak in library code that is beyond your control.
  */
 data class LibraryLeak(
-  override val className: String,
-  override val leakTrace: LeakTrace,
-  override val retainedHeapByteSize: Int?,
+  override val leakTraces: List<LeakTrace>,
   /**
-   * The pattern that matched one of the references in [leakTrace], as provided to a
+   * The pattern that matched one of the references in each of [leakTraces], as provided to a
    * [LibraryLeakReferenceMatcher] instance.
    */
   val pattern: ReferencePattern,
@@ -181,7 +222,11 @@ data class LibraryLeak(
    */
   val description: String
 ) : Leak() {
-  override fun createGroupHash() = pattern.toString().createSHA1Hash()
+  override val signature: String
+    get() = pattern.toString().createSHA1Hash()
+
+  override val shortDescription: String
+    get() = pattern.toString()
 
   override fun toString(): String {
     return """Leak pattern: $pattern
@@ -189,29 +234,52 @@ Description: $description
 ${super.toString()}
 """
   }
+
+  /** This field is kept to support backward compatible deserialization. */
+  private val leakTrace: LeakTrace? = null
+  /** This field is kept to support backward compatible deserialization. */
+  private val retainedHeapByteSize: Int? = null
+
+  internal fun leakTraceFromV20() = leakTrace!!.fromV20(retainedHeapByteSize)
+
+  companion object {
+    private const val serialVersionUID: Long = 3943636164568681903
+  }
 }
 
 /**
  * A leak found by [HeapAnalyzer] in your application.
  */
 data class ApplicationLeak(
-  override val className: String,
-  override val leakTrace: LeakTrace,
-  override val retainedHeapByteSize: Int?
+  override val leakTraces: List<LeakTrace>
 ) : Leak() {
-  override fun createGroupHash(): String {
-    return leakTrace.leakCauses
-        .joinToString(separator = "") { element ->
-          val referenceName = element.reference!!.groupingName
-          element.className + referenceName
-        }
-        .createSHA1Hash()
-  }
+  override val signature: String
+    get() = leakTraces.first().signature
 
-  // Required to avoid the default toString() from data classes
+  override val shortDescription: String
+    get() {
+      val leakTrace = leakTraces.first()
+      return leakTrace.suspectReferenceSubpath.firstOrNull()?.let { firstSuspectReferencePath ->
+        val referenceName = firstSuspectReferencePath.referenceGenericName
+        firstSuspectReferencePath.originObject.classSimpleName + "." + referenceName
+      } ?: leakTrace.leakingObject.className
+    }
+
+  // Override required to avoid the default toString() from data classes
   override fun toString(): String {
     return super.toString()
   }
+
+  /** This field is kept to support backward compatible deserialization. */
+  private val leakTrace: LeakTrace? = null
+  /** This field is kept to support backward compatible deserialization. */
+  private val retainedHeapByteSize: Int? = null
+
+  internal fun leakTraceFromV20() = leakTrace!!.fromV20(retainedHeapByteSize)
+
+  companion object {
+    private const val serialVersionUID: Long = 524928276700576863
+  }
 }
 
 private fun androidSdkInt(): Int {
diff --git a/shark/src/main/java/shark/HeapAnalysisException.kt b/shark/src/main/java/shark/HeapAnalysisException.kt
index 55b835e83..81b5d4a77 100644
--- a/shark/src/main/java/shark/HeapAnalysisException.kt
+++ b/shark/src/main/java/shark/HeapAnalysisException.kt
@@ -10,4 +10,8 @@ class HeapAnalysisException(cause: Throwable) : RuntimeException(cause) {
     cause!!.printStackTrace(PrintWriter(stringWriter))
     return stringWriter.toString()
   }
+
+  companion object {
+    private const val serialVersionUID: Long = -2522323377375290608
+  }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 87fadfb7a..6234571f6 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -15,29 +15,20 @@
  */
 package shark
 
-import shark.GcRoot.JavaFrame
-import shark.GcRoot.JniGlobal
-import shark.GcRoot.JniLocal
-import shark.GcRoot.JniMonitor
-import shark.GcRoot.MonitorUsed
-import shark.GcRoot.NativeStack
-import shark.GcRoot.ReferenceCleanup
-import shark.GcRoot.StickyClass
-import shark.GcRoot.ThreadBlock
-import shark.GcRoot.ThreadObject
 import shark.HeapAnalyzer.TrieNode.LeafNode
 import shark.HeapAnalyzer.TrieNode.ParentNode
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
 import shark.HeapObject.HeapPrimitiveArray
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
-import shark.LeakTraceElement.Holder.ARRAY
-import shark.LeakTraceElement.Holder.CLASS
-import shark.LeakTraceElement.Holder.OBJECT
-import shark.LeakTraceElement.Holder.THREAD
+import shark.LeakTrace.GcRootType
+import shark.LeakTraceObject.LeakingStatus
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.LeakTraceObject.ObjectType.ARRAY
+import shark.LeakTraceObject.ObjectType.CLASS
+import shark.LeakTraceObject.ObjectType.INSTANCE
 import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
 import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
@@ -50,6 +41,7 @@ import shark.internal.ReferencePathNode
 import shark.internal.ReferencePathNode.ChildNode
 import shark.internal.ReferencePathNode.LibraryLeakNode
 import shark.internal.ReferencePathNode.RootNode
+import shark.internal.createSHA1Hash
 import shark.internal.lastSegment
 import java.io.File
 import java.util.ArrayList
@@ -112,8 +104,12 @@ class HeapAnalyzer constructor(
             val (applicationLeaks, libraryLeaks) = helpers.findLeaks(leakingObjectIds)
 
             return HeapAnalysisSuccess(
-                heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime), metadata,
-                applicationLeaks, libraryLeaks
+                heapDumpFile = heapDumpFile,
+                createdAtTimeMillis = System.currentTimeMillis(),
+                analysisDurationMillis = since(analysisStartNanoTime),
+                metadata = metadata,
+                applicationLeaks = applicationLeaks,
+                libraryLeaks = libraryLeaks
             )
           }
     } catch (exception: Throwable) {
@@ -325,26 +321,35 @@ class HeapAnalyzer constructor(
 
     listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
 
-    val applicationLeaks = mutableListOf<ApplicationLeak>()
-    val libraryLeaks = mutableListOf<LibraryLeak>()
+    val applicationLeaksMap = mutableMapOf<String, MutableList<LeakTrace>>()
+    val libraryLeaksMap =
+      mutableMapOf<String, Pair<LibraryLeakReferenceMatcher, MutableList<LeakTrace>>>()
 
     val deduplicatedPaths = deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
 
-    deduplicatedPaths.forEachIndexed { index, pathNode ->
-      val shortestChildPath = mutableListOf<ChildNode>()
+    deduplicatedPaths.forEachIndexed { index, retainedObjectNode ->
 
-      var node: ReferencePathNode = pathNode
+      val pathHeapObjects = mutableListOf<HeapObject>()
+      val shortestChildPath = mutableListOf<ChildNode>()
+      var node: ReferencePathNode = retainedObjectNode
       while (node is ChildNode) {
         shortestChildPath.add(0, node)
+        pathHeapObjects.add(0, graph.findObjectById(node.objectId))
         node = node.parent
       }
       val rootNode = node as RootNode
+      pathHeapObjects.add(0, graph.findObjectById(rootNode.objectId))
 
-      val leakTrace =
-        buildLeakTrace(graph, objectInspectors, rootNode, shortestChildPath)
+      val leakTraceObjects = buildLeakTraceObjects(objectInspectors, pathHeapObjects)
 
-      val className =
-        recordClassName(graph.findObjectById(pathNode.objectId))
+      val referencePath = buildReferencePath(shortestChildPath, leakTraceObjects)
+
+      val leakTrace = LeakTrace(
+          gcRootType = GcRootType.fromGcRoot(rootNode.gcRoot),
+          referencePath = referencePath,
+          leakingObject = leakTraceObjects.last(),
+          retainedHeapByteSize = retainedSizes?.get(index)
+      )
 
       val firstLibraryLeakNode = if (rootNode is LibraryLeakNode) {
         rootNode
@@ -354,27 +359,30 @@ class HeapAnalyzer constructor(
 
       if (firstLibraryLeakNode != null) {
         val matcher = firstLibraryLeakNode.matcher
-        libraryLeaks += LibraryLeak(
-            className, leakTrace, retainedSizes?.get(index), matcher.pattern, matcher.description
-        )
+        val signature: String = matcher.pattern.toString()
+            .createSHA1Hash()
+        libraryLeaksMap.getOrPut(signature) { matcher to mutableListOf() }
+            .second += leakTrace
       } else {
-        applicationLeaks += ApplicationLeak(className, leakTrace, retainedSizes?.get(index))
+        applicationLeaksMap.getOrPut(leakTrace.signature) { mutableListOf() } += leakTrace
       }
     }
+    val applicationLeaks = applicationLeaksMap.map { (_, leakTraces) ->
+      ApplicationLeak(leakTraces)
+    }
+    val libraryLeaks = libraryLeaksMap.map { (_, pair) ->
+      val (matcher, leakTraces) = pair
+      LibraryLeak(leakTraces, matcher.pattern, matcher.description)
+    }
     return applicationLeaks to libraryLeaks
   }
 
-  private fun buildLeakTrace(
-    graph: HeapGraph,
+  private fun buildLeakTraceObjects(
     objectInspectors: List<ObjectInspector>,
-    rootNode: RootNode,
-    shortestChildPath: List<ChildNode>
-  ): LeakTrace {
-    val shortestPath = shortestChildPath.toMutableList<ReferencePathNode>()
-    shortestPath.add(0, rootNode)
-
-    val leakReporters = shortestPath.map {
-      ObjectReporter(graph.findObjectById(it.objectId))
+    pathHeapObjects: List<HeapObject>
+  ): List<LeakTraceObject> {
+    val leakReporters = pathHeapObjects.map { heapObject ->
+      ObjectReporter(heapObject)
     }
 
     // Looping on inspectors first to get more cache hits.
@@ -384,50 +392,65 @@ class HeapAnalyzer constructor(
       }
     }
 
-    val leakStatuses = computeLeakStatuses(rootNode, leakReporters)
+    val leakStatuses = computeLeakStatuses(leakReporters)
 
-    val elements = shortestPath.mapIndexed { index, pathNode ->
+    return pathHeapObjects.mapIndexed { index, heapObject ->
       val leakReporter = leakReporters[index]
       val (leakStatus, leakStatusReason) = leakStatuses[index]
-      val reference =
-        if (index < shortestPath.lastIndex) (shortestPath[index + 1] as ChildNode).referenceFromParent else null
-      buildLeakElement(
-          graph, pathNode, reference, leakReporter.labels, leakStatus, leakStatusReason
+      val className = recordClassName(heapObject)
+
+      val objectType = if (heapObject is HeapClass) {
+        CLASS
+      } else if (heapObject is HeapObjectArray || heapObject is HeapPrimitiveArray) {
+        ARRAY
+      } else {
+        INSTANCE
+      }
+
+      LeakTraceObject(
+          type = objectType,
+          className = className,
+          labels = leakReporter.labels,
+          leakingStatus = leakStatus,
+          leakingStatusReason = leakStatusReason
       )
     }
-    return LeakTrace(elements)
   }
 
-  private fun computeLeakStatuses(
-    rootNode: RootNode,
-    leakReporters: List<ObjectReporter>
-  ): List<Pair<LeakNodeStatus, String>> {
-    val lastElementIndex = leakReporters.size - 1
+  private fun buildReferencePath(
+    shortestChildPath: List<ChildNode>,
+    leakTraceObjects: List<LeakTraceObject>
+  ): List<ReferencePathElement> {
+    return shortestChildPath.mapIndexed { index, childNode ->
+      ReferencePathElement(
+          originObject = leakTraceObjects[index],
+          referenceType = childNode.refFromParentType,
+          referenceName = childNode.refFromParentName
+      )
+    }
+  }
 
-    val rootNodeReporter = leakReporters[0]
-
-    rootNodeReporter.labels +=
-      "GC Root: " + when (rootNode.gcRoot) {
-        is ThreadObject -> "Thread object"
-        is JniGlobal -> "Global variable in native code"
-        is JniLocal -> "Local variable in native code"
-        is JavaFrame -> "Java local variable"
-        is NativeStack -> "Input or output parameters in native code"
-        is StickyClass -> "System class"
-        is ThreadBlock -> "Thread block"
-        is MonitorUsed -> "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
-        is ReferenceCleanup -> "Reference cleanup"
-        is JniMonitor -> "Root JNI monitor"
-        else -> throw IllegalStateException("Unexpected gc root ${rootNode.gcRoot}")
-      }
+  private fun computeLeakStatuses(leakReporters: List<ObjectReporter>): List<Pair<LeakingStatus, String>> {
+    val lastElementIndex = leakReporters.size - 1
 
-    var lastNotLeakingElementIndex = 0
+    var lastNotLeakingElementIndex = -1
     var firstLeakingElementIndex = lastElementIndex
 
-    val leakStatuses = ArrayList<Pair<LeakNodeStatus, String>>()
+    val leakStatuses = ArrayList<Pair<LeakingStatus, String>>()
 
     for ((index, reporter) in leakReporters.withIndex()) {
-      val resolvedStatusPair = resolveStatus(reporter)
+      val resolvedStatusPair =
+        resolveStatus(reporter, leakingWins = index == lastElementIndex).let { statusPair ->
+          if (index == lastElementIndex) {
+            // The last element should always be leaking.
+            when (statusPair.first) {
+              LEAKING -> statusPair
+              UNKNOWN -> LEAKING to "This is the leaking object"
+              NOT_LEAKING -> LEAKING to "This is the leaking object. Conflicts with ${statusPair.second}"
+            }
+          } else statusPair
+        }
+
       leakStatuses.add(resolvedStatusPair)
       val (leakStatus, _) = resolvedStatusPair
       if (leakStatus == NOT_LEAKING) {
@@ -435,7 +458,7 @@ class HeapAnalyzer constructor(
         // Reset firstLeakingElementIndex so that we never have
         // firstLeakingElementIndex < lastNotLeakingElementIndex
         firstLeakingElementIndex = lastElementIndex
-      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus == LEAKING) {
+      } else if (leakStatus == LEAKING && firstLeakingElementIndex == lastElementIndex) {
         firstLeakingElementIndex = index
       }
     }
@@ -444,18 +467,35 @@ class HeapAnalyzer constructor(
       recordClassName(reporter.heapObject).lastSegment('.')
     }
 
-    // First and last are always known.
-    for (i in 0..lastElementIndex) {
+    for (i in 0 until lastNotLeakingElementIndex) {
       val (leakStatus, leakStatusReason) = leakStatuses[i]
-      if (i < lastNotLeakingElementIndex) {
-        val nextNotLeakingName = simpleClassNames[i + 1]
-        leakStatuses[i] = when (leakStatus) {
-          UNKNOWN -> NOT_LEAKING to "$nextNotLeakingName is not leaking"
-          NOT_LEAKING -> NOT_LEAKING to "$nextNotLeakingName is not leaking and $leakStatusReason"
-          LEAKING -> NOT_LEAKING to "$nextNotLeakingName is not leaking. Conflicts with $leakStatusReason"
+      val nextNotLeakingIndex = generateSequence(i + 1) { index ->
+        if (index < lastNotLeakingElementIndex) index + 1 else null
+      }.first { index ->
+        leakStatuses[index].first == NOT_LEAKING
+      }
+
+      // Element is forced to NOT_LEAKING
+      val nextNotLeakingName = simpleClassNames[nextNotLeakingIndex]
+      leakStatuses[i] = when (leakStatus) {
+        UNKNOWN -> NOT_LEAKING to "$nextNotLeakingName is not leaking"
+        NOT_LEAKING -> NOT_LEAKING to "$nextNotLeakingName is not leaking and $leakStatusReason"
+        LEAKING -> NOT_LEAKING to "$nextNotLeakingName is not leaking. Conflicts with $leakStatusReason"
+      }
+    }
+
+    if (firstLeakingElementIndex < lastElementIndex - 1) {
+      // We already know the status of firstLeakingElementIndex and lastElementIndex
+      for (i in lastElementIndex - 1 downTo firstLeakingElementIndex + 1) {
+        val (leakStatus, leakStatusReason) = leakStatuses[i]
+        val previousLeakingIndex = generateSequence(i - 1) { index ->
+          if (index > firstLeakingElementIndex) index - 1 else null
+        }.first { index ->
+          leakStatuses[index].first == LEAKING
         }
-      } else if (i > firstLeakingElementIndex) {
-        val previousLeakingName = simpleClassNames[i - 1]
+
+        // Element is forced to LEAKING
+        val previousLeakingName = simpleClassNames[previousLeakingIndex]
         leakStatuses[i] = when (leakStatus) {
           UNKNOWN -> LEAKING to "$previousLeakingName is leaking"
           LEAKING -> LEAKING to "$previousLeakingName is leaking and $leakStatusReason"
@@ -467,58 +507,34 @@ class HeapAnalyzer constructor(
   }
 
   private fun resolveStatus(
-    reporter: ObjectReporter
-  ): Pair<LeakNodeStatus, String> {
+    reporter: ObjectReporter,
+    leakingWins: Boolean
+  ): Pair<LeakingStatus, String> {
     var status = UNKNOWN
     var reason = ""
     if (reporter.notLeakingReasons.isNotEmpty()) {
       status = NOT_LEAKING
       reason = reporter.notLeakingReasons.joinToString(" and ")
     }
-
     val leakingReasons = reporter.leakingReasons
     if (leakingReasons.isNotEmpty()) {
-      // NOT_LEAKING wins over LEAKING
+      val winReasons = leakingReasons.joinToString(" and ")
+      // Conflict
       if (status == NOT_LEAKING) {
-        reason += ". Conflicts with ${leakingReasons.joinToString(" and ")}"
+        if (leakingWins) {
+          status = LEAKING
+          reason = "$winReasons. Conflicts with $reason"
+        } else {
+          reason += ". Conflicts with $winReasons"
+        }
       } else {
         status = LEAKING
-        reason = leakingReasons.joinToString(" and ")
+        reason = winReasons
       }
     }
     return status to reason
   }
 
-  @Suppress("LongParameterList")
-  private fun buildLeakElement(
-    graph: HeapGraph,
-    node: ReferencePathNode,
-    reference: LeakReference?,
-    labels: Set<String>,
-    leakStatus: LeakNodeStatus,
-    leakStatusReason: String
-  ): LeakTraceElement {
-    val objectId = node.objectId
-
-    val graphRecord = graph.findObjectById(objectId)
-
-    val className = recordClassName(graphRecord)
-
-    val holderType = if (graphRecord is HeapClass) {
-      CLASS
-    } else if (graphRecord is HeapObjectArray || graphRecord is HeapPrimitiveArray) {
-      ARRAY
-    } else {
-      val instanceRecord = graphRecord.asInstance!!
-      if (instanceRecord.instanceClass.classHierarchy.any { it.name == Thread::class.java.name }) {
-        THREAD
-      } else {
-        OBJECT
-      }
-    }
-    return LeakTraceElement(reference, holderType, className, labels, leakStatus, leakStatusReason)
-  }
-
   private fun recordClassName(
     heap: HeapObject
   ): String {
diff --git a/shark/src/main/java/shark/LeakNodeStatus.kt b/shark/src/main/java/shark/LeakNodeStatus.kt
index a8193c1cf..f914ca365 100644
--- a/shark/src/main/java/shark/LeakNodeStatus.kt
+++ b/shark/src/main/java/shark/LeakNodeStatus.kt
@@ -1,10 +1,10 @@
 package shark
 
-enum class LeakNodeStatus {
-  /** The instance was needed and therefore expected to be reachable. */
+/**
+ * This class is kept to support backward compatible deserialization.
+ */
+internal enum class LeakNodeStatus {
   NOT_LEAKING,
-  /** The instance was no longer needed and therefore expected to be unreachable. */
   LEAKING,
-  /** No decision can be made about the provided instance. */
   UNKNOWN;
-}
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakReference.kt b/shark/src/main/java/shark/LeakReference.kt
index 58124214a..07d919876 100644
--- a/shark/src/main/java/shark/LeakReference.kt
+++ b/shark/src/main/java/shark/LeakReference.kt
@@ -1,21 +1,5 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package shark
 
-import shark.LeakTraceElement.Type
 import shark.LeakTraceElement.Type.ARRAY_ENTRY
 import shark.LeakTraceElement.Type.INSTANCE_FIELD
 import shark.LeakTraceElement.Type.LOCAL
@@ -23,29 +7,25 @@ import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.io.Serializable
 
 /**
- * A single field in a [LeakTraceElement].
+ * This class is kept to support backward compatible deserialization.
  */
-data class LeakReference(
-  val type: Type,
-  val name: String
-) : Serializable {
+internal class LeakReference : Serializable {
+
+  private val type: LeakTraceElement.Type? = null
+  private val name: String? = null
 
-  val displayName: String
-    get() {
-      return when (type) {
-        ARRAY_ENTRY -> "[$name]"
-        STATIC_FIELD, INSTANCE_FIELD -> name
-        LOCAL -> "<Java Local>"
-      }
-    }
+  fun fromV20(originObject: LeakTraceObject) = ReferencePathElement(
+      originObject = originObject,
+      referenceType = when (type!!) {
+        INSTANCE_FIELD -> ReferencePathElement.ReferenceType.INSTANCE_FIELD
+        STATIC_FIELD -> ReferencePathElement.ReferenceType.STATIC_FIELD
+        LOCAL -> ReferencePathElement.ReferenceType.LOCAL
+        ARRAY_ENTRY -> ReferencePathElement.ReferenceType.ARRAY_ENTRY
+      },
+      referenceName = name!!
+  )
 
-  val groupingName: String
-    get() {
-      return when (type) {
-        // The specific array index in a leak rarely matters, this improves grouping.
-        ARRAY_ENTRY -> "[x]"
-        STATIC_FIELD, INSTANCE_FIELD -> name
-        LOCAL -> "<Java Local>"
-      }
-    }
-}
+  companion object {
+    private const val serialVersionUID: Long = 2028550902155599651
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index 7c0e14278..334f727e1 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -1,103 +1,184 @@
 package shark
 
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
-import shark.LeakTraceElement.Holder.ARRAY
-import shark.LeakTraceElement.Holder.THREAD
-import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakTrace.GcRootType.JAVA_FRAME
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
+import shark.ReferencePathElement.ReferenceType.STATIC_FIELD
+import shark.internal.createSHA1Hash
 import java.io.Serializable
-import java.util.Locale
 
 /**
- * A chain of references that constitute the shortest strong reference path from a GC root to the
- * leaking object. Fixing the leak usually means breaking one of the references in that chain.
+ * The best strong reference path from a GC root to the leaking object. "Best" here means the
+ * shortest prioritized path. A large number of distinct paths can generally be found leading
+ * to a leaking object. Shark prioritizes paths that don't go through known
+ * [LibraryLeakReferenceMatcher] (because those are known to create leaks so it's more interesting
+ * to find other paths causing leaks), then it prioritize paths that don't go through java local
+ * gc roots (because those are harder to reason about). Taking those priorities into account,
+ * finding the shortest path means there are less [ReferencePathElement] that can be suspected to
+ * cause the leak.
  */
 data class LeakTrace(
-  val elements: List<LeakTraceElement>
+  /**
+   * The Garbage Collection root that references the [ReferencePathElement.originObject] in
+   * the first [ReferencePathElement] of [referencePath].
+   */
+  val gcRootType: GcRootType,
+  val referencePath: List<ReferencePathElement>,
+  val leakingObject: LeakTraceObject,
+  /**
+   * The minimum number of bytes which would be freed if all references to the leaking object were
+   * released. Null if the retained heap size was not computed.
+   */
+  val retainedHeapByteSize: Int?
 ) : Serializable {
-  val leakCauses = elements.filterIndexed { index, _ ->
-    elementMayBeLeakCause(index)
-  }
 
-  fun elementMayBeLeakCause(index: Int): Boolean {
-    return when (elements[index].leakStatus) {
+  /**
+   * A part of [referencePath] that contains the references suspected to cause the leak.
+   * Starts at the last non leaking object and ends before the first leaking object.
+   */
+  val suspectReferenceSubpath
+    get() = referencePath.asSequence()
+        .filterIndexed { index, _ ->
+          referencePathElementIsSuspect(index)
+        }
+
+  /**
+   * A SHA1 hash that represents this leak trace. This can be useful to group together similar
+   * leak traces.
+   *
+   * The signature is a hash of [suspectReferenceSubpath].
+   */
+  val signature: String
+    get() = suspectReferenceSubpath
+        .joinToString(separator = "") { element ->
+          element.originObject.className + element.referenceGenericName
+        }
+        .createSHA1Hash()
+
+  /**
+   * Returns true if the [referencePath] element at the provided [index] contains a reference
+   * that is suspected to cause the leak, ie if [index] is greater than or equal to the index
+   * of the [ReferencePathElement] of the last non leaking object and strictly lower than the index
+   * of the [ReferencePathElement] of the first leaking object.
+   */
+  fun referencePathElementIsSuspect(index: Int): Boolean {
+    return when (referencePath[index].originObject.leakingStatus) {
       UNKNOWN -> true
-      NOT_LEAKING -> if (index < elements.lastIndex) {
-        elements[index + 1].leakStatus != NOT_LEAKING
-      } else {
-        false
-      }
+      NOT_LEAKING -> index == referencePath.lastIndex ||
+          referencePath[index + 1].originObject.leakingStatus != NOT_LEAKING
       else -> false
     }
   }
 
   override fun toString(): String {
-    var result = ""
+    var result = """
+      
+       GC Root: ${gcRootType.description}
+      
+    """.trimIndent()
 
-    elements.forEachIndexed { index, element ->
-      val isLast = index == elements.lastIndex
-      val nodePrefix = if (!isLast) {
-        " "
-      } else {
-        " "
+    referencePath.forEachIndexed { index, element ->
+      val leakStatus = when (referencePath[index].originObject.leakingStatus) {
+        UNKNOWN -> "UNKNOWN"
+        NOT_LEAKING -> "NO (${referencePath[index].originObject.leakingStatusReason})"
+        LEAKING -> "YES (${referencePath[index].originObject.leakingStatusReason})"
       }
-      result += "\n" + nodePrefix + element.className
 
-      val contentPrefix = if (!isLast) {
-        "    "
-      } else {
-        "$ZERO_WIDTH_SPACE     "
-      }
+      /**
+       * When the GC Root is a Java Frame, Shark inserts the corresponding thread as an extra
+       * element in the leaktrace.
+       */
+      val typeName =
+        if (index == 0 && gcRootType == JAVA_FRAME) "thread" else element.originObject.typeName
 
-      result += "\n" + contentPrefix + "Leaking: " + when (elements[index].leakStatus) {
-        UNKNOWN -> "UNKNOWN"
-        NOT_LEAKING -> "NO (${elements[index].leakStatusReason})"
-        LEAKING -> "YES (${elements[index].leakStatusReason})"
-      }
+      result += "\n ${element.originObject.className} $typeName"
+      result += "\n    Leaking: $leakStatus"
 
-      for (label in element.labels) {
-        result += "\n" + contentPrefix + label
+      for (label in element.originObject.labels) {
+        result += "\n    $label"
       }
+      result += getNextElementString(this, element, index)
+    }
 
-      if (!isLast) {
-        result += "\n$contentPrefix " + getNextElementString(this, element, index)
+    result += "\n"
+    result += " ${leakingObject.className} ${leakingObject.typeName}\n$ZERO_WIDTH_SPACE"
+    result += "     Leaking: YES (${leakingObject.leakingStatusReason})"
+    for (label in leakingObject.labels) {
+      result += "\n$ZERO_WIDTH_SPACE"
+      result += "     $label"
+    }
+
+    return result
+  }
+
+  enum class GcRootType(val description: String) {
+    JNI_GLOBAL("Global variable in native code"),
+    JNI_LOCAL("Local variable in native code"),
+    JAVA_FRAME("Java local variable"),
+    NATIVE_STACK("Input or output parameters in native code"),
+    STICKY_CLASS("System class"),
+    THREAD_BLOCK("Thread block"),
+    MONITOR_USED(
+        "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
+    ),
+    THREAD_OBJECT("Thread object"),
+    JNI_MONITOR("Root JNI monitor"),
+    ;
+
+    companion object {
+      fun fromGcRoot(gcRoot: GcRoot): GcRootType = when (gcRoot) {
+        is GcRoot.JniGlobal -> JNI_GLOBAL
+        is GcRoot.JniLocal -> JNI_LOCAL
+        is GcRoot.JavaFrame -> JAVA_FRAME
+        is GcRoot.NativeStack -> NATIVE_STACK
+        is GcRoot.StickyClass -> STICKY_CLASS
+        is GcRoot.ThreadBlock -> THREAD_BLOCK
+        is GcRoot.MonitorUsed -> MONITOR_USED
+        is GcRoot.ThreadObject -> THREAD_OBJECT
+        is GcRoot.JniMonitor -> JNI_MONITOR
+        else -> throw IllegalStateException("Unexpected gc root $gcRoot")
       }
 
     }
-    return result
   }
 
+  /** This field is kept to support backward compatible deserialization. */
+  private val elements: List<LeakTraceElement>? = null
+
+  internal fun fromV20(retainedHeapByteSize: Int?) = LeakTrace(
+      gcRootType = elements!!.first().gcRootTypeFromV20(),
+      referencePath = elements.subList(
+          0, elements.lastIndex - 1
+      ).map { it.referencePathElementFromV20() },
+      leakingObject = elements.last().originObjectFromV20(),
+      retainedHeapByteSize = retainedHeapByteSize
+  )
+
   companion object {
     private fun getNextElementString(
       leakTrace: LeakTrace,
-      element: LeakTraceElement,
+      element: ReferencePathElement,
       index: Int
     ): String {
-      val maybeLeakCause = leakTrace.elementMayBeLeakCause(index)
-
-      val staticString =
-        if (element.reference != null && element.reference.type == STATIC_FIELD) "static " else ""
-      val holderString =
-        if (element.holder == ARRAY || element.holder == THREAD) {
-          "${element.holder.name.toLowerCase(Locale.US)} "
-        } else ""
-      val simpleClassName = element.classSimpleName
-      val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
-      val requiredSpaces =
-        staticString.length + holderString.length + simpleClassName.length + "".length
-      val leakString = if (maybeLeakCause) {
-        "\n$ELEMENT_DEFAULT_NEW_LINE_SPACE" + " ".repeat(
-            requiredSpaces
-        ) + "~".repeat(referenceName.length - 1)
+      val static = if (element.referenceType == STATIC_FIELD) " static" else ""
+      val referenceLine =
+        "    $static ${element.originObject.classSimpleName}.${element.referenceDisplayName}"
+
+      return if (leakTrace.referencePathElementIsSuspect(index)) {
+        val lengthBeforeReferenceName = referenceLine.lastIndexOf('.') + 1
+        val referenceLength = referenceLine.length - lengthBeforeReferenceName
+
+        val spaces = " ".repeat(lengthBeforeReferenceName)
+        val underline = "~".repeat(referenceLength)
+        "\n$referenceLine\n$spaces$underline"
       } else {
-        ""
+        "\n$referenceLine"
       }
-
-      return staticString + holderString + simpleClassName + referenceName + leakString
     }
 
     private const val ZERO_WIDTH_SPACE = '\u200b'
-    private const val ELEMENT_DEFAULT_NEW_LINE_SPACE = "     "
+    private const val serialVersionUID: Long = -6315725584154386429
+
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTraceElement.kt b/shark/src/main/java/shark/LeakTraceElement.kt
index ff5117691..6a9e09208 100644
--- a/shark/src/main/java/shark/LeakTraceElement.kt
+++ b/shark/src/main/java/shark/LeakTraceElement.kt
@@ -1,34 +1,28 @@
 package shark
 
-import shark.internal.lastSegment
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTrace.GcRootType
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.CLASS
+import shark.LeakTraceElement.Holder.OBJECT
+import shark.LeakTraceElement.Holder.THREAD
+import shark.LeakTraceObject.LeakingStatus
+import shark.LeakTraceObject.ObjectType
 import java.io.Serializable
 
-data class LeakTraceElement(
-  /**
-   * Information about the reference that points to the next [LeakTraceElement] in
-   * [LeakTrace.elements]. Null if this is the last element in the leak trace, ie the leaking
-   * object.
-   */
-  val reference: LeakReference?,
+/**
+ * This class is kept to support backward compatible deserialization.
+ */
+internal class LeakTraceElement : Serializable {
 
-  val holder: Holder,
-
-  val className: String,
-
-  /**
-   * Labels that were computed during analysis. A label provides extra information that helps
-   * understand the leak trace element.
-   */
-  val labels: Set<String>,
-  val leakStatus: LeakNodeStatus,
-  val leakStatusReason: String
-
-) : Serializable {
-
-  /**
-   * Returns {@link #className} without the package.
-   */
-  val classSimpleName: String get() = className.lastSegment('.')
+  private val reference: LeakReference? = null
+  private val holder: Holder? = null
+  private val className: String? = null
+  private val labels: Set<String>? = null
+  private val leakStatus: LeakNodeStatus? = null
+  private val leakStatusReason: String? = null
 
   enum class Type {
     INSTANCE_FIELD,
@@ -43,4 +37,44 @@ data class LeakTraceElement(
     THREAD,
     ARRAY
   }
+
+  fun gcRootTypeFromV20() = when (val gcRootLabel = labels!!
+      .first {
+        it.startsWith("GC Root: ")
+      }
+      .substring("GC Root: ".length)) {
+    "Thread object" -> GcRootType.THREAD_OBJECT
+    "Global variable in native code" -> GcRootType.JNI_GLOBAL
+    "Local variable in native code" -> GcRootType.JNI_LOCAL
+    "Java local variable" -> GcRootType.JAVA_FRAME
+    "Input or output parameters in native code" -> GcRootType.NATIVE_STACK
+    "System class" -> GcRootType.STICKY_CLASS
+    "Thread block" -> GcRootType.THREAD_BLOCK
+    "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)" -> GcRootType.MONITOR_USED
+    "Root JNI monitor" -> GcRootType.JNI_MONITOR
+    else -> throw IllegalStateException("Unexpected gc root label $gcRootLabel")
+  }
+
+  fun referencePathElementFromV20() = reference!!.fromV20(originObjectFromV20())
+
+  fun originObjectFromV20() = LeakTraceObject(
+      type = when (holder!!) {
+        OBJECT -> ObjectType.INSTANCE
+        CLASS -> ObjectType.CLASS
+        THREAD -> ObjectType.INSTANCE
+        ARRAY -> ObjectType.ARRAY
+      },
+      className = className!!,
+      labels = labels!!.filter { !it.startsWith("GC Root: ") }.toSet(),
+      leakingStatus = when (leakStatus!!) {
+        NOT_LEAKING -> LeakingStatus.NOT_LEAKING
+        LEAKING -> LeakingStatus.LEAKING
+        UNKNOWN -> LeakingStatus.UNKNOWN
+      },
+      leakingStatusReason = leakStatusReason!!
+  )
+
+  companion object {
+    private const val serialVersionUID: Long = -6795139831875582552
+  }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTraceObject.kt b/shark/src/main/java/shark/LeakTraceObject.kt
new file mode 100644
index 000000000..1d1e55451
--- /dev/null
+++ b/shark/src/main/java/shark/LeakTraceObject.kt
@@ -0,0 +1,47 @@
+package shark
+
+import shark.internal.lastSegment
+import java.io.Serializable
+import java.util.Locale
+
+data class LeakTraceObject(
+  val type: ObjectType,
+  /**
+   * Class name of the object.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  val className: String,
+
+  /**
+   * Labels that were computed during analysis. A label provides extra information that helps
+   * understand the state of the leak trace object.
+   */
+  val labels: Set<String>,
+  val leakingStatus: LeakingStatus,
+  val leakingStatusReason: String
+) : Serializable {
+
+  /**
+   * Returns {@link #className} without the package, ie stripped of any string content before the
+   * last period (included).
+   */
+  val classSimpleName: String get() = className.lastSegment('.')
+
+  val typeName
+    get() = type.name.toLowerCase(Locale.US)
+
+  enum class ObjectType {
+    CLASS,
+    ARRAY,
+    INSTANCE
+  }
+
+  enum class LeakingStatus {
+    /** The object was needed and therefore expected to be reachable. */
+    NOT_LEAKING,
+    /** The object was no longer needed and therefore expected to be unreachable. */
+    LEAKING,
+    /** No decision can be made about the provided object. */
+    UNKNOWN;
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ReferencePathElement.kt b/shark/src/main/java/shark/ReferencePathElement.kt
new file mode 100644
index 000000000..d396eec6d
--- /dev/null
+++ b/shark/src/main/java/shark/ReferencePathElement.kt
@@ -0,0 +1,54 @@
+package shark
+
+import shark.ReferencePathElement.ReferenceType.ARRAY_ENTRY
+import shark.ReferencePathElement.ReferenceType.INSTANCE_FIELD
+import shark.ReferencePathElement.ReferenceType.LOCAL
+import shark.ReferencePathElement.ReferenceType.STATIC_FIELD
+import java.io.Serializable
+
+/**
+ * A [ReferencePathElement] represents and origin [LeakTraceObject] and either a reference from that
+ * object to the [LeakTraceObject] in the next [ReferencePathElement] in [LeakTrace.referencePath],
+ * or to [LeakTrace.leakingObject] if this is the last [ReferencePathElement] in
+ * [LeakTrace.referencePath].
+ */
+data class ReferencePathElement(
+  val originObject: LeakTraceObject,
+
+  val referenceType: ReferenceType,
+
+  val referenceName: String
+
+) : Serializable {
+
+  enum class ReferenceType {
+    INSTANCE_FIELD,
+    STATIC_FIELD,
+    LOCAL,
+    ARRAY_ENTRY
+  }
+
+  val referenceDisplayName: String
+    get() {
+      return when (referenceType) {
+        ARRAY_ENTRY -> "[$referenceName]"
+        STATIC_FIELD, INSTANCE_FIELD -> referenceName
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  val referenceGenericName: String
+    get() {
+      return when (referenceType) {
+        // The specific array index in a leak rarely matters, this improves grouping.
+        ARRAY_ENTRY -> "[x]"
+        STATIC_FIELD, INSTANCE_FIELD -> referenceName
+        LOCAL -> "<Java Local>"
+      }
+    }
+
+  companion object {
+    private const val serialVersionUID = 1L
+  }
+
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ReferencePattern.kt b/shark/src/main/java/shark/ReferencePattern.kt
index eb17d5edd..a44c1f794 100644
--- a/shark/src/main/java/shark/ReferencePattern.kt
+++ b/shark/src/main/java/shark/ReferencePattern.kt
@@ -14,6 +14,10 @@ sealed class ReferencePattern : Serializable {
     val threadName: String
   ) : ReferencePattern() {
     override fun toString() = "local variable on thread $threadName"
+
+    companion object {
+      private const val serialVersionUID: Long = -8985446122829543654
+    }
   }
 
   /**
@@ -24,6 +28,10 @@ sealed class ReferencePattern : Serializable {
     val fieldName: String
   ) : ReferencePattern() {
     override fun toString() = "static field $className#$fieldName"
+
+    companion object {
+      private const val serialVersionUID: Long = 7656908128775899611
+    }
   }
 
   /**
@@ -39,6 +47,10 @@ sealed class ReferencePattern : Serializable {
     val fieldName: String
   ) : ReferencePattern() {
     override fun toString() = "instance field $className#$fieldName"
+
+    companion object {
+      private const val serialVersionUID: Long = 6649791455204159802
+    }
   }
 
   /**
@@ -48,5 +60,13 @@ sealed class ReferencePattern : Serializable {
    */
   data class NativeGlobalVariablePattern(val className: String) : ReferencePattern() {
     override fun toString() = "native global variable referencing $className"
+
+    companion object {
+      private const val serialVersionUID: Long = -2651328076202244933
+    }
+  }
+
+  companion object {
+    private const val serialVersionUID: Long = -5113635523713591133
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index 7663e98ba..e0da0b8ef 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -26,17 +26,16 @@ import shark.HeapObject.HeapInstance
 import shark.HeapObject.HeapObjectArray
 import shark.HeapObject.HeapPrimitiveArray
 import shark.IgnoredReferenceMatcher
-import shark.LeakReference
-import shark.LeakTraceElement.Type.ARRAY_ENTRY
-import shark.LeakTraceElement.Type.INSTANCE_FIELD
-import shark.LeakTraceElement.Type.LOCAL
-import shark.LeakTraceElement.Type.STATIC_FIELD
 import shark.LibraryLeakReferenceMatcher
 import shark.OnAnalysisProgressListener
 import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
 import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_RETAINED_OBJECTS
 import shark.PrimitiveType.INT
 import shark.ReferenceMatcher
+import shark.ReferencePathElement.ReferenceType.ARRAY_ENTRY
+import shark.ReferencePathElement.ReferenceType.INSTANCE_FIELD
+import shark.ReferencePathElement.ReferenceType.LOCAL
+import shark.ReferencePathElement.ReferenceType.STATIC_FIELD
 import shark.ReferencePattern
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.NativeGlobalVariablePattern
@@ -272,15 +271,28 @@ internal class PathFinder(
 
             if (referenceMatcher !is IgnoredReferenceMatcher) {
               val rootNode = NormalRootNode(threadRoot.id, gcRoot)
+
+              val refFromParentType = LOCAL
               // Unfortunately Android heap dumps do not include stack trace data, so
               // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
               // reference to be held.
-              val leakReference = LeakReference(LOCAL, "")
+              val refFromParentName = ""
 
               val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
-                LibraryLeakChildNode(gcRoot.id, rootNode, leakReference, referenceMatcher)
+                LibraryLeakChildNode(
+                    objectId = gcRoot.id,
+                    parent = rootNode,
+                    refFromParentType = refFromParentType,
+                    refFromParentName = refFromParentName,
+                    matcher = referenceMatcher
+                )
               } else {
-                NormalNode(gcRoot.id, rootNode, leakReference)
+                NormalNode(
+                    objectId = gcRoot.id,
+                    parent = rootNode,
+                    refFromParentType = refFromParentType,
+                    refFromParentName = refFromParentName
+                )
               }
               enqueue(childNode)
             }
@@ -371,9 +383,18 @@ internal class PathFinder(
       }
 
       val node = when (val referenceMatcher = ignoredStaticFields[fieldName]) {
-        null -> NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
+        null -> NormalNode(
+            objectId = objectId,
+            parent = parent,
+            refFromParentType = STATIC_FIELD,
+            refFromParentName = fieldName
+        )
         is LibraryLeakReferenceMatcher -> LibraryLeakChildNode(
-            objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
+            objectId = objectId,
+            parent = parent,
+            refFromParentType = STATIC_FIELD,
+            refFromParentName = fieldName,
+            matcher = referenceMatcher
         )
         is IgnoredReferenceMatcher -> null
       }
@@ -422,17 +443,29 @@ internal class PathFinder(
           // Earlier Android versions store local references in a Thread.localValues field.
           if (threadLocalValuesMatcher is LibraryLeakReferenceMatcher) {
             LibraryLeakChildNode(
-                objectId, parent, LeakReference(INSTANCE_FIELD, field.name),
-                threadLocalValuesMatcher
+                objectId = objectId,
+                parent = parent,
+                refFromParentType = INSTANCE_FIELD,
+                refFromParentName = field.name,
+                matcher = threadLocalValuesMatcher
             )
           } else {
             null
           }
         } else when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
-          null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
+          null -> NormalNode(
+              objectId = objectId,
+              parent = parent,
+              refFromParentType = INSTANCE_FIELD,
+              refFromParentName = field.name
+          )
           is LibraryLeakReferenceMatcher ->
             LibraryLeakChildNode(
-                objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
+                objectId = objectId,
+                parent = parent,
+                refFromParentType = INSTANCE_FIELD,
+                refFromParentName = field.name,
+                matcher = referenceMatcher
             )
           is IgnoredReferenceMatcher -> null
         }
@@ -455,7 +488,12 @@ internal class PathFinder(
         updateDominatorWithSkips(parent.objectId, elementId)
       }
       val name = index.toString()
-      enqueue(NormalNode(elementId, parent, LeakReference(ARRAY_ENTRY, name)))
+      enqueue(NormalNode(
+          objectId = elementId,
+          parent = parent,
+          refFromParentType = ARRAY_ENTRY,
+          refFromParentName = name
+      ))
     }
   }
 
diff --git a/shark/src/main/java/shark/internal/ReferencePathNode.kt b/shark/src/main/java/shark/internal/ReferencePathNode.kt
index bf83a23b5..e26798846 100644
--- a/shark/src/main/java/shark/internal/ReferencePathNode.kt
+++ b/shark/src/main/java/shark/internal/ReferencePathNode.kt
@@ -1,8 +1,8 @@
 package shark.internal
 
 import shark.GcRoot
-import shark.LeakReference
 import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePathElement
 
 internal sealed class ReferencePathNode {
   abstract val objectId: Long
@@ -34,19 +34,22 @@ internal sealed class ReferencePathNode {
     /**
      * The reference from the parent to this node
      */
-    abstract val referenceFromParent: LeakReference
+    abstract val refFromParentType: ReferencePathElement.ReferenceType
+    abstract val refFromParentName: String
 
     class LibraryLeakChildNode(
       override val objectId: Long,
       override val parent: ReferencePathNode,
-      override val referenceFromParent: LeakReference,
+      override val refFromParentType: ReferencePathElement.ReferenceType,
+      override val refFromParentName: String,
       override val matcher: LibraryLeakReferenceMatcher
     ) : ChildNode(), LibraryLeakNode
 
     class NormalNode(
       override val objectId: Long,
       override val parent: ReferencePathNode,
-      override val referenceFromParent: LeakReference
+      override val refFromParentType: ReferencePathElement.ReferenceType,
+      override val refFromParentName: String
     ) : ChildNode()
   }
 
diff --git a/shark/src/main/java/shark/internal/Strings.kt b/shark/src/main/java/shark/internal/Strings.kt
index d562cb08a..311a3b313 100644
--- a/shark/src/main/java/shark/internal/Strings.kt
+++ b/shark/src/main/java/shark/internal/Strings.kt
@@ -40,4 +40,4 @@ private fun createHash(
 }
 
 /** Gets the string as an array of UTF-8 bytes. */
-internal fun String.getBytes(): ByteArray = toByteArray(UTF_8)
+internal fun String.getBytes(): ByteArray = toByteArray(UTF_8)
\ No newline at end of file
diff --git a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
index 374b6d942..29e94f99d 100644
--- a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
+++ b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
@@ -95,8 +95,11 @@ class HeapAnalysisStringRenderingTest {
       |References underlined with "~~~" are likely causes.
       |Learn more at https://squ.re/leaks.
       |
-      |
-      | GcRoot
+      |Signature: a49095c3373b957532aff14eb32987bb75ffe9d5
+      |
+      | GC Root: System class
+      |
+      | GcRoot class
       |.*
       |====================================
       |0 LIBRARY LEAKS
diff --git a/shark/src/test/java/shark/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
index 17dcc54fb..32e4c6c19 100644
--- a/shark/src/test/java/shark/HeapAnalyzerTest.kt
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -7,8 +7,8 @@ import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import shark.GcRoot.JniGlobal
 import shark.GcRoot.ThreadObject
-import shark.LeakTraceElement.Type.LOCAL
-import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.ReferencePathElement.ReferenceType.STATIC_FIELD
+import shark.ReferencePathElement.ReferenceType.LOCAL
 import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
@@ -36,14 +36,14 @@ class HeapAnalyzerTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.className).isEqualTo("java.lang.String")
+    assertThat(leak.leakTraces.first().leakingObject.className).isEqualTo("java.lang.String")
   }
 
   @Test fun pathToCharArray() {
     hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.className).isEqualTo("char[]")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.className).isEqualTo("char[]")
   }
 
   // Two char arrays to ensure we keep going after finding the first one
@@ -58,11 +58,11 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("shortestPath")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
   }
 
   @Test fun noPathToInstance() {
@@ -88,12 +88,13 @@ class HeapAnalyzerTest {
     assertThat(analysis.applicationLeaks).isEmpty()
   }
 
-  @Test fun findMultipleLeaks() {
+  @Test fun findMultipleIdenticalLeaks() {
     hprofFile.writeMultipleActivityLeaks(5)
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(leaks.applicationLeaks).hasSize(5)
+    assertThat(leaks.applicationLeaks).hasSize(1)
+    assertThat(leaks.applicationLeaks.first().leakTraces).hasSize(5)
   }
 
   @Test fun localVariableLeak() {
@@ -101,11 +102,11 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
-    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("MyThread")
+    assertThat(leakTrace.referencePath[0].referenceType).isEqualTo(LOCAL)
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
   }
 
   @Test fun localVariableLeakShortestPathGoesLast() {
@@ -114,10 +115,10 @@ class HeapAnalyzerTest {
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
     println(analysis)
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(3)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(STATIC_FIELD)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceType).isEqualTo(STATIC_FIELD)
   }
 
   @Test fun threadFieldLeak() {
@@ -139,11 +140,11 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("MyThread")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("leaking")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
   }
 
   @Test fun nativeGlobalVariableApplicationLeak() {
diff --git a/shark/src/test/java/shark/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
index 425d4caf8..953e08652 100644
--- a/shark/src/test/java/shark/LabelerTest.kt
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -25,7 +25,7 @@ class LabelerTest {
       override fun inspect(
         reporter: ObjectReporter
       ) {
-        reporter.whenInstanceOf("java.lang.String")  { instance ->
+        reporter.whenInstanceOf("java.lang.String") { instance ->
           labels += "Hello ${instance.readAsJavaString()}"
         }
       }
@@ -33,20 +33,24 @@ class LabelerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
 
-    val leak = analysis.applicationLeaks[0]
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
 
-    assertThat(leak.leakTrace.elements.last().labels).contains("Hello World")
+    assertThat(leakTrace.leakingObject.labels).contains("Hello World")
   }
 
   @Test fun threadNameLabel() {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(ObjectInspectors.THREAD))
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          objectInspectors = listOf(ObjectInspectors.THREAD)
+      )
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
+    assertThat(leak.leakTraces.first().referencePath.first().originObject.labels).contains(
+        "Thread name: 'kroutine'"
+    )
   }
 
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
index 54e14f043..ddcca1940 100644
--- a/shark/src/test/java/shark/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -5,12 +5,11 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
-import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapClass
 import shark.HeapObject.HeapInstance
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.LeakingStatus.UNKNOWN
 import java.io.File
 
 class LeakStatusTest {
@@ -33,7 +32,9 @@ class LeakStatusTest {
 
     val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTraces.first().referencePath.first().originObject.leakingStatus).isEqualTo(
+        NOT_LEAKING
+    )
   }
 
   @Test fun leakingInstanceLeaking() {
@@ -41,9 +42,8 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.applicationLeaks[0]
-
-    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
   }
 
   @Test fun defaultsToUnknown() {
@@ -57,9 +57,8 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.applicationLeaks[0]
-
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(UNKNOWN)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(UNKNOWN)
   }
 
   @Test fun inspectorNotLeaking() {
@@ -75,8 +74,8 @@ class LeakStatusTest {
         objectInspectors = listOf(notLeakingInstance("Class1"))
     )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun inspectorLeaking() {
@@ -93,8 +92,10 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+        "Class1 is leaking"
+    )
   }
 
   @Test fun leakingWinsUnknown() {
@@ -111,8 +112,8 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(LEAKING)
   }
 
   @Test fun notLeakingWhenNextIsNotLeaking() {
@@ -133,8 +134,8 @@ class LeakStatusTest {
           objectInspectors = listOf(notLeakingInstance("Class3"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun leakingWhenPreviousIsLeaking() {
@@ -152,16 +153,15 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakFilters = listOf(object : LeakingObjectFilter {
-            override fun isLeakingObject(heapObject: HeapObject) =
-              heapObject is HeapInstance && heapObject instanceOf "Class1"
-          }),
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(4)
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatusReason).isEqualTo(
+        "Class1 is leaking"
+    )
   }
 
   @Test fun middleUnknown() {
@@ -184,8 +184,8 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[2].leakStatus).isEqualTo(UNKNOWN)
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[2].originObject.leakingStatus).isEqualTo(UNKNOWN)
   }
 
   @Test fun gcRootClassNotLeakingConflictingWithInspector() {
@@ -196,10 +196,10 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingClass("GcRoot"), ObjectInspectors.CLASS)
       )
 
-    val leak = analysis.applicationLeaks[0]
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
 
-    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatusReason).isEqualTo(
         "a class is never leaking. Conflicts with GcRoot is leaking"
     )
   }
@@ -214,10 +214,10 @@ class LeakStatusTest {
 
     println(analysis)
 
-    val leak = analysis.applicationLeaks[0]
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
 
-    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath.first().originObject.leakingStatusReason).isEqualTo(
         "GcRoot is not leaking and a class is never leaking"
     )
   }
@@ -229,10 +229,11 @@ class LeakStatusTest {
           objectInspectors = listOf(notLeakingInstance("Leaking"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
-        "Leaking is not leaking. Conflicts with ObjectWatcher was watching this because its lifecycle has ended"
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.leakingObject.leakingStatusReason).isEqualTo(
+        "ObjectWatcher was watching this because its lifecycle has ended. " +
+            "Conflicts with Leaking is not leaking"
     )
   }
 
@@ -243,9 +244,9 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Leaking"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.leakingObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.leakingObject.leakingStatusReason).isEqualTo(
         "Leaking is leaking and ObjectWatcher was watching this because its lifecycle has ended"
     )
   }
@@ -266,9 +267,12 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+
+    println(leakTrace)
+
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
         "Class1 is not leaking. Conflicts with Class1 is leaking"
     )
   }
@@ -289,9 +293,9 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
         "Class1 is not leaking"
     )
   }
@@ -310,13 +314,65 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"), leakingInstance("Class1"))
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
         "Class1 is leaking"
     )
   }
 
+  @Test fun notLeakingWhenFurtherDownIsNotLeaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          objectInspectors = listOf(notLeakingInstance("Class3"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[1].originObject.className).isEqualTo("Class1")
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leakTrace.referencePath[1].originObject.leakingStatusReason).isEqualTo(
+        "Class3 is not leaking"
+    )
+  }
+
+  @Test fun leakingWhenFurtherUpIsleaking() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          objectInspectors = listOf(leakingInstance("Class1"))
+      )
+
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath[3].originObject.className).isEqualTo("Class3")
+    assertThat(leakTrace.referencePath[3].originObject.leakingStatus).isEqualTo(LEAKING)
+    assertThat(leakTrace.referencePath[3].originObject.leakingStatusReason).isEqualTo(
+        "Class1 is leaking"
+    )
+  }
+
   @Test fun leakCausesAreLastNotLeakingAndUnknown() {
     hprofFile.dump {
       "GcRoot" clazz {
@@ -337,14 +393,13 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elementMayBeLeakCause(0)).isFalse()
-    assertThat(leak.leakTrace.elementMayBeLeakCause(1)).isTrue()
-    assertThat(leak.leakTrace.elementMayBeLeakCause(2)).isTrue()
-    assertThat(leak.leakTrace.elementMayBeLeakCause(3)).isFalse()
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePathElementIsSuspect(0)).isFalse()
+    assertThat(leakTrace.referencePathElementIsSuspect(1)).isTrue()
+    assertThat(leakTrace.referencePathElementIsSuspect(2)).isTrue()
   }
 
-  @Test fun sameLeakTraceSameGroup() {
+  @Test fun sameLeakTraceSameSignature() {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["staticField1"] = "Class1" instance {
@@ -356,7 +411,7 @@ class LeakStatusTest {
         }
       }
     }
-    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["staticField1"] = "Class1" instance {
@@ -368,11 +423,11 @@ class LeakStatusTest {
         }
       }
     }
-    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
     assertThat(hash1).isEqualTo(hash2)
   }
 
-  @Test fun differentLeakTraceDifferentGroup() {
+  @Test fun differentLeakTraceDifferentSignature() {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["staticField1"] = "Class1" instance {
@@ -384,7 +439,7 @@ class LeakStatusTest {
         }
       }
     }
-    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["staticField1"] = "Class1" instance {
@@ -396,11 +451,11 @@ class LeakStatusTest {
         }
       }
     }
-    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
     assertThat(hash1).isNotEqualTo(hash2)
   }
 
-  @Test fun sameCausesSameGroup() {
+  @Test fun sameCausesSameSignature() {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["staticField1"] = "Class1" instance {
@@ -412,7 +467,7 @@ class LeakStatusTest {
         }
       }
     }
-    val hash1 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash1 = computeSignature(notLeaking = "Class1", leaking = "Class3")
 
     hprofFile.dump {
       "GcRoot" clazz {
@@ -425,10 +480,33 @@ class LeakStatusTest {
         }
       }
     }
-    val hash2 = computeGroupHash(notLeaking = "Class1", leaking = "Class3")
+    val hash2 = computeSignature(notLeaking = "Class1", leaking = "Class3")
     assertThat(hash1).isEqualTo(hash2)
   }
 
+  @Test fun sameCausesSameApplicationLeak() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["staticField1"] = "Class1" instance {
+          field["field1"] = "Class2" instance {
+            field["field2"] = "Class3" instance {
+              field["field3a"] = "Leaking" watchedInstance {}
+              field["field3b"] = "Leaking" watchedInstance {}
+            }
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          objectInspectors = listOf(notLeakingInstance("Class1"), leakingInstance("Class3"))
+      )
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    assertThat(analysis.applicationLeaks.first().leakTraces).hasSize(2)
+  }
+
   private fun notLeakingInstance(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
@@ -481,7 +559,7 @@ class LeakStatusTest {
     }
   }
 
-  private fun computeGroupHash(
+  private fun computeSignature(
     notLeaking: String,
     leaking: String
   ): String {
@@ -493,6 +571,6 @@ class LeakStatusTest {
       "Expecting 1 retained instance in ${analysis.applicationLeaks}"
     }
     val leak = analysis.applicationLeaks[0]
-    return leak.groupHash
+    return leak.signature
   }
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
index a41493a83..9d4364780 100644
--- a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
+++ b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
@@ -31,13 +31,14 @@ class LeakTraceStringRenderingTest {
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
     analysis renders """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
-        GC Root: System class
          static GcRoot.leak
                         ~~~~
-     Leaking
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
          watchDurationMillis = 25000
@@ -64,13 +65,14 @@ class LeakTraceStringRenderingTest {
     )
 
     analysis renders """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
-        GC Root: System class
          static GcRoot.leak
                         ~~~~
-     Leaking
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
          watchDurationMillis = 25000
@@ -107,17 +109,18 @@ class LeakTraceStringRenderingTest {
       )
 
     analysis renders """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
-        GC Root: System class
          static GcRoot.instanceA
                         ~~~~~~~~~
-     ClassA
+     ClassA instance
         Leaking: UNKNOWN
          ClassA.instanceB
                  ~~~~~~~~~
-     ClassB
+     ClassB instance
          Leaking: YES (because reasons)
     """
   }
@@ -141,14 +144,15 @@ class LeakTraceStringRenderingTest {
     )
 
     analysis renders """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
         \_()_/
-        GC Root: System class
          static GcRoot.leak
                         ~~~~
-     Leaking
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          \_()_/
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
@@ -174,17 +178,18 @@ class LeakTraceStringRenderingTest {
       )
 
     analysis rendersLibraryLeak """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
-        GC Root: System class
          static GcRoot.instanceA
                         ~~~~~~~~~
-     ClassA
+     ClassA instance
         Leaking: UNKNOWN
          ClassA.leak
                  ~~~~
-     Leaking
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
          watchDurationMillis = 25000
@@ -203,17 +208,18 @@ class LeakTraceStringRenderingTest {
       hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
     analysis renders """
-    
-     GcRoot
+    
+     GC Root: System class
+    
+     GcRoot class
         Leaking: UNKNOWN
-        GC Root: System class
          static GcRoot.array
                         ~~~~~
-     java.lang.Object[]
+     java.lang.Object[] array
         Leaking: UNKNOWN
-         array Object[].[0]
-                         ~~~
-     Leaking
+         Object[].[0]
+                   ~~~
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
          watchDurationMillis = 25000
@@ -228,13 +234,14 @@ class LeakTraceStringRenderingTest {
       hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
     analysis renders """
-    
-     MyThread
+    
+     GC Root: Java local variable
+    
+     MyThread thread
         Leaking: UNKNOWN
-        GC Root: Java local variable
-         thread MyThread.<Java Local>
-                          ~~~~~~~~~~~~
-     Leaking
+         MyThread.<Java Local>
+                   ~~~~~~~~~~~~
+     Leaking instance
          Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
          key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
          watchDurationMillis = 25000
@@ -243,13 +250,13 @@ class LeakTraceStringRenderingTest {
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    assertThat(applicationLeaks[0].leakTrace.toString()).isEqualTo(
+    assertThat(applicationLeaks[0].leakTraces.first().toString()).isEqualTo(
         expectedString.trimIndent()
     )
   }
 
   private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
-    assertThat(libraryLeaks[0].leakTrace.toString()).isEqualTo(
+    assertThat(libraryLeaks[0].leakTraces.first().toString()).isEqualTo(
         expectedString.trimIndent()
     )
   }
diff --git a/shark/src/test/java/shark/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
index f9831986d..abba51dea 100644
--- a/shark/src/test/java/shark/ReferenceMatcherTest.kt
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -34,13 +34,13 @@ class ReferenceMatcherTest {
         )
     )
 
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(3)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
-    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
-    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("longestPath")
+    assertThat(leakTrace.referencePath[1].originObject.className).isEqualTo("HasLeaking")
+    assertThat(leakTrace.referencePath[1].referenceName).isEqualTo("leaking")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
   }
 
   @Test fun allPathsExcluded_ShortestWins() {
@@ -56,10 +56,11 @@ class ReferenceMatcherTest {
 
     val leak = analysis.libraryLeaks[0]
     assertThat(leak.pattern).isEqualTo(expectedMatcher.pattern)
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+    val leakTrace = leak.leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(1)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("shortestPath")
+    assertThat(leakTrace.leakingObject.className).isEqualTo("Leaking")
   }
 
   @Test fun noPathToInstanceNeverReachable() {
@@ -148,10 +149,10 @@ class ReferenceMatcherTest {
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
         referenceMatchers = listOf(matcher)
     )
-    val leak = analysis.applicationLeaks[0]
-    assertThat(leak.leakTrace.elements).hasSize(3)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+    val leakTrace = analysis.applicationLeaks[0].leakTraces.first()
+    assertThat(leakTrace.referencePath).hasSize(2)
+    assertThat(leakTrace.referencePath[0].originObject.className).isEqualTo("GcRoot")
+    assertThat(leakTrace.referencePath[0].referenceName).isEqualTo("longestPath")
   }
 
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
index 598c7531e..b067e889f 100644
--- a/shark/src/test/java/shark/RetainedSizeTest.kt
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -230,9 +230,9 @@ class RetainedSizeTest {
 
     val instance = retainedInstances[0]
 
-    assertThat(instance.className).isEqualTo("GrandParentLeaking")
+    assertThat(instance.leakTraces.first().leakingObject.className).isEqualTo("GrandParentLeaking")
     // 4 bytes per ref * 2 + short + int + long
-    assertThat(instance.retainedHeapByteSize).isEqualTo(22)
+    assertThat(instance.totalRetainedHeapByteSize).isEqualTo(22)
   }
 
   @Test fun crossDominatedIsNotDominated() {
@@ -255,7 +255,7 @@ class RetainedSizeTest {
 
     retainedInstances.forEach { instance ->
       // 4 byte reference
-      assertThat(instance.retainedHeapByteSize).isEqualTo(4)
+      assertThat(instance.totalRetainedHeapByteSize).isEqualTo(4)
     }
   }
 
@@ -309,7 +309,7 @@ class RetainedSizeTest {
 
   private fun firstRetainedSize(): Int {
     return retainedInstances()
-        .map { it.retainedHeapByteSize!! }
+        .map { it.totalRetainedHeapByteSize!! }
         .first()
   }
 
