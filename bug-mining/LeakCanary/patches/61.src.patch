diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
index 656010355..e8f3473e2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
@@ -21,11 +21,11 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.content.ContextCompat;
 import com.squareup.leakcanary.internal.ForegroundService;
+import java.io.File;
 
 public abstract class AbstractAnalysisResultService extends ForegroundService {
 
-  private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
-  private static final String RESULT_EXTRA = "result_extra";
+  private static final String ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra";
 
   public static void sendResultToListener(@NonNull Context context,
       @NonNull String listenerServiceClassName,
@@ -38,8 +38,11 @@ public abstract class AbstractAnalysisResultService extends ForegroundService {
       throw new RuntimeException(e);
     }
     Intent intent = new Intent(context, listenerServiceClass);
-    intent.putExtra(HEAP_DUMP_EXTRA, heapDump);
-    intent.putExtra(RESULT_EXTRA, result);
+
+    File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
+    if (analyzedHeapFile != null) {
+      intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
+    }
     ContextCompat.startForegroundService(context, intent);
   }
 
@@ -49,27 +52,60 @@ public abstract class AbstractAnalysisResultService extends ForegroundService {
   }
 
   @Override protected final void onHandleIntentInForeground(@Nullable Intent intent) {
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
-    AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
+    if (intent == null) {
+      CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.");
+      return;
+    }
+    if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
+      return;
+    }
+    File analyzedHeapFile = new File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA));
+    AnalyzedHeap analyzedHeap = AnalyzedHeap.load(analyzedHeapFile);
+    if (analyzedHeap == null) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file));
+      return;
+    }
     try {
-      onHeapAnalyzed(heapDump, result);
+      onHeapAnalyzed(analyzedHeap);
     } finally {
       //noinspection ResultOfMethodCallIgnored
-      heapDump.heapDumpFile.delete();
+      analyzedHeap.heapDump.heapDumpFile.delete();
+      //noinspection ResultOfMethodCallIgnored
+      analyzedHeap.selfFile.delete();
     }
   }
 
   /**
    * Called after a heap dump is analyzed, whether or not a leak was found.
-   * Check {@link AnalysisResult#leakFound} and {@link AnalysisResult#excludedLeak} to see if there
-   * was a leak and if it can be ignored.
-   *
+   * In {@link AnalyzedHeap#result} check {@link AnalysisResult#leakFound} and {@link
+   * AnalysisResult#excludedLeak} to see if there was a leak and if it can be ignored.
+   * <p>
    * This will be called from a background intent service thread.
    * <p>
    * It's OK to block here and wait for the heap dump to be uploaded.
    * <p>
-   * The heap dump file will be deleted immediately after this callback returns.
+   * The analyzed heap file and heap dump file will be deleted immediately after this callback
+   * returns.
+   */
+  protected void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+    onHeapAnalyzed(analyzedHeap.heapDump, analyzedHeap.result);
+  }
+
+  /**
+   * @deprecated Maintained for backward compatibility. You should override {@link
+   * #onHeapAnalyzed(AnalyzedHeap)} instead.
+   */
+  @SuppressWarnings("DeprecatedIsStillUsed")
+  @Deprecated
+  protected void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+  }
+
+  /**
+   * Called when there was an error saving or loading the analysis result. This will be called from
+   * a background intent service thread.
    */
-  protected abstract void onHeapAnalyzed(@NonNull HeapDump heapDump,
-      @NonNull AnalysisResult result);
+  protected void onAnalysisResultFailure(String failureMessage) {
+    CanaryLog.d(failureMessage);
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
new file mode 100644
index 000000000..5113bc921
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
@@ -0,0 +1,83 @@
+package com.squareup.leakcanary;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+/**
+ * Wraps a {@link HeapDump} and corresponding {@link AnalysisResult}.
+ */
+public final class AnalyzedHeap {
+
+  @Nullable public static File save(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+    File analyzedHeapfile = new File(heapDump.heapDumpFile.getParentFile(),
+        heapDump.heapDumpFile.getName() + ".result");
+    FileOutputStream fos = null;
+    try {
+      fos = new FileOutputStream(analyzedHeapfile);
+      ObjectOutputStream oos = new ObjectOutputStream(fos);
+      oos.writeObject(heapDump);
+      oos.writeObject(result);
+      return analyzedHeapfile;
+    } catch (IOException e) {
+      CanaryLog.d(e, "Could not save leak analysis result to disk.");
+    } finally {
+      if (fos != null) {
+        try {
+          fos.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+    return null;
+  }
+
+  @Nullable public static AnalyzedHeap load(@NonNull File resultFile) {
+    FileInputStream fis = null;
+    try {
+      fis = new FileInputStream(resultFile);
+      ObjectInputStream ois = new ObjectInputStream(fis);
+      HeapDump heapDump = (HeapDump) ois.readObject();
+      AnalysisResult result = (AnalysisResult) ois.readObject();
+      return new AnalyzedHeap(heapDump, result, resultFile);
+    } catch (IOException | ClassNotFoundException e) {
+      // Likely a change in the serializable result class.
+      // Let's remove the files, we can't read them anymore.
+      boolean deleted = resultFile.delete();
+      if (deleted) {
+        CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+      } else {
+        CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+            resultFile);
+      }
+    } finally {
+      if (fis != null) {
+        try {
+          fis.close();
+        } catch (IOException ignored) {
+        }
+      }
+    }
+    return null;
+  }
+
+  @NonNull public final HeapDump heapDump;
+  @NonNull public final AnalysisResult result;
+  @NonNull public final File selfFile;
+  public final boolean heapDumpFileExists;
+  public final long selfLastModified;
+
+  public AnalyzedHeap(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
+      @NonNull File analyzedHeapFile) {
+    this.heapDump = heapDump;
+    this.result = result;
+    this.selfFile = analyzedHeapFile;
+    heapDumpFileExists = heapDump.heapDumpFile.exists();
+    selfLastModified = analyzedHeapFile.lastModified();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index c88df6720..a2455c05b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -19,10 +19,8 @@ import android.app.PendingIntent;
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
+import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -30,19 +28,21 @@ import java.util.Locale;
 import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
  * DisplayLeakActivity}.
- *
+ * <p>
  * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
  * String)} to add custom behavior, e.g. uploading the heap dump.
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
   @Override
-  protected final void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
+  protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
+    HeapDump heapDump = analyzedHeap.heapDump;
+    AnalysisResult result = analyzedHeap.result;
+
     String leakInfo = leakInfo(this, heapDump, result, true);
     CanaryLog.d("%s", leakInfo);
 
@@ -53,16 +53,15 @@ public class DisplayLeakService extends AbstractAnalysisResultService {
       resultSaved = saveResult(heapDump, result);
     }
 
-    PendingIntent pendingIntent;
-    String contentTitle;
-    String contentText;
-
     if (!shouldSaveResult) {
-      contentTitle = getString(R.string.leak_canary_no_leak_title);
-      contentText = getString(R.string.leak_canary_no_leak_text);
-      pendingIntent = null;
+      String contentTitle = getString(R.string.leak_canary_no_leak_title);
+      String contentText = getString(R.string.leak_canary_no_leak_text);
+      showNotification(null, contentTitle, contentText);
     } else if (resultSaved) {
-      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
+      String contentTitle;
+      String contentText;
+      PendingIntent pendingIntent =
+          DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
       if (result.failure == null) {
         if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
@@ -86,38 +85,31 @@ public class DisplayLeakService extends AbstractAnalysisResultService {
         contentTitle = getString(R.string.leak_canary_analysis_failed);
       }
       contentText = getString(R.string.leak_canary_notification_message);
+      showNotification(pendingIntent, contentTitle, contentText);
     } else {
-      contentTitle = getString(R.string.leak_canary_could_not_save_title);
-      contentText = getString(R.string.leak_canary_could_not_save_text);
-      pendingIntent = null;
+      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
     }
+
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
+
+  @Override protected final void onAnalysisResultFailure(String failureMessage) {
+    super.onAnalysisResultFailure(failureMessage);
+    String failureTitle = getString(R.string.leak_canary_result_failure_title);
+    showNotification(null, failureTitle, failureMessage);
+  }
+
+  private void showNotification(PendingIntent pendingIntent, String contentTitle,
+      String contentText) {
     // New notification id every second.
     int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
-    showNotification(this, contentTitle, contentText, pendingIntent, notificationId);
-    afterDefaultHandling(heapDump, result, leakInfo);
+    LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent,
+        notificationId);
   }
 
   private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
-        heapDump.heapDumpFile.getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return true;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return false;
+    File resultFile = AnalyzedHeap.save(heapDump, result);
+    return resultFile != null;
   }
 
   private HeapDump renameHeapdump(HeapDump heapDump) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 3901ce290..98ad42ef2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -42,15 +42,13 @@ import android.widget.ListAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.AnalyzedHeap;
 import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.HeapDump;
 import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -93,7 +91,7 @@ public final class DisplayLeakActivity extends Activity {
   }
 
   // null until it's been first loaded.
-  List<Leak> leaks;
+  List<AnalyzedHeap> leaks;
   String visibleLeakRefKey;
 
   private ListView listView;
@@ -113,7 +111,7 @@ public final class DisplayLeakActivity extends Activity {
       }
     }
 
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
+    leaks = (List<AnalyzedHeap>) getLastNonConfigurationInstance();
 
     setContentView(R.layout.leak_canary_display_leak);
 
@@ -154,7 +152,7 @@ public final class DisplayLeakActivity extends Activity {
   }
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
-    Leak visibleLeak = getVisibleLeak();
+    AnalyzedHeap visibleLeak = getVisibleLeak();
     if (visibleLeak != null) {
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
@@ -195,7 +193,7 @@ public final class DisplayLeakActivity extends Activity {
   }
 
   void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
+    AnalyzedHeap visibleLeak = getVisibleLeak();
     String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
     intent.setType("text/plain");
@@ -205,7 +203,7 @@ public final class DisplayLeakActivity extends Activity {
 
   @SuppressLint("SetWorldReadable")
   void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
+    AnalyzedHeap visibleLeak = getVisibleLeak();
     final File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
     AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
       @Override public void run() {
@@ -231,11 +229,11 @@ public final class DisplayLeakActivity extends Activity {
   }
 
   void deleteVisibleLeak() {
-    final Leak visibleLeak = getVisibleLeak();
+    final AnalyzedHeap visibleLeak = getVisibleLeak();
     AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
       @Override public void run() {
         File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-        File resultFile = visibleLeak.resultFile;
+        File resultFile = visibleLeak.selfFile;
         boolean resultDeleted = resultFile.delete();
         if (!resultDeleted) {
           CanaryLog.d("Could not delete result file %s", resultFile.getPath());
@@ -271,7 +269,7 @@ public final class DisplayLeakActivity extends Activity {
       visibleLeakRefKey = null;
     }
 
-    final Leak visibleLeak = getVisibleLeak();
+    final AnalyzedHeap visibleLeak = getVisibleLeak();
     if (visibleLeak == null) {
       visibleLeakRefKey = null;
     }
@@ -384,11 +382,11 @@ public final class DisplayLeakActivity extends Activity {
     actionBar.setDisplayHomeAsUpEnabled(enabled);
   }
 
-  Leak getVisibleLeak() {
+  AnalyzedHeap getVisibleLeak() {
     if (leaks == null) {
       return null;
     }
-    for (Leak leak : leaks) {
+    for (AnalyzedHeap leak : leaks) {
       if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
         return leak;
       }
@@ -402,7 +400,7 @@ public final class DisplayLeakActivity extends Activity {
       return leaks.size();
     }
 
-    @Override public Leak getItem(int position) {
+    @Override public AnalyzedHeap getItem(int position) {
       return leaks.get(position);
     }
 
@@ -417,7 +415,7 @@ public final class DisplayLeakActivity extends Activity {
       }
       TextView titleView = convertView.findViewById(R.id.leak_canary_row_text);
       TextView timeView = convertView.findViewById(R.id.leak_canary_row_time);
-      Leak leak = getItem(position);
+      AnalyzedHeap leak = getItem(position);
 
       String index = (leaks.size() - position) + ". ";
 
@@ -442,29 +440,13 @@ public final class DisplayLeakActivity extends Activity {
       }
       titleView.setText(title);
       String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFileLastModified,
+          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.selfLastModified,
               FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
       timeView.setText(time);
       return convertView;
     }
   }
 
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
-    final File resultFile;
-    final boolean heapDumpFileExists;
-    final long resultFileLastModified;
-
-    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
-      this.heapDump = heapDump;
-      this.result = result;
-      this.resultFile = resultFile;
-      heapDumpFileExists = heapDump.heapDumpFile.exists();
-      resultFileLastModified = resultFile.lastModified();
-    }
-  }
-
   static class LoadLeaks implements Runnable {
 
     static final List<LoadLeaks> inFlight = new ArrayList<>();
@@ -495,43 +477,22 @@ public final class DisplayLeakActivity extends Activity {
     }
 
     @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
+      final List<AnalyzedHeap> leaks = new ArrayList<>();
       List<File> files = leakDirectoryProvider.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
           return filename.endsWith(".result");
         }
       });
       for (File resultFile : files) {
-        FileInputStream fis = null;
-        try {
-          fis = new FileInputStream(resultFile);
-          ObjectInputStream ois = new ObjectInputStream(fis);
-          HeapDump heapDump = (HeapDump) ois.readObject();
-          AnalysisResult result = (AnalysisResult) ois.readObject();
-          leaks.add(new Leak(heapDump, result, resultFile));
-        } catch (IOException | ClassNotFoundException e) {
-          // Likely a change in the serializable result class.
-          // Let's remove the files, we can't read them anymore.
-          boolean deleted = resultFile.delete();
-          if (deleted) {
-            CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-          } else {
-            CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                resultFile);
-          }
-        } finally {
-          if (fis != null) {
-            try {
-              fis.close();
-            } catch (IOException ignored) {
-            }
-          }
+        final AnalyzedHeap leak = AnalyzedHeap.load(resultFile);
+        if (leak != null) {
+          leaks.add(leak);
         }
       }
-      Collections.sort(leaks, new Comparator<Leak>() {
-        @Override public int compare(Leak lhs, Leak rhs) {
-          return Long.valueOf(rhs.resultFile.lastModified())
-              .compareTo(lhs.resultFile.lastModified());
+      Collections.sort(leaks, new Comparator<AnalyzedHeap>() {
+        @Override public int compare(AnalyzedHeap lhs, AnalyzedHeap rhs) {
+          return Long.valueOf(rhs.selfFile.lastModified())
+              .compareTo(lhs.selfFile.lastModified());
         }
       });
       mainHandler.post(new Runnable() {
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
index a7f3cde17..c91efa60c 100644
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -26,6 +26,9 @@
     <string name="leak_canary_notification_foreground_text">LeakCanary ist beschäftigt.</string>
     <string name="leak_canary_notification_message">Für mehr Details, hier klicken</string>
     <string name="leak_canary_notification_reporting">Sichere LeakCanary Ergebnis</string>
+    <string name="leak_canary_result_failure_no_disk_space">The analysis result could not be saved to disk</string>
+    <string name="leak_canary_result_failure_no_file">The analysis result could not be loaded from disk</string>
+    <string name="leak_canary_result_failure_title">Analysis result failure</string>
     <string name="leak_canary_share_leak">Info teilen</string>
     <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
     <string name="leak_canary_share_with">Teilen mit…</string>
@@ -36,7 +39,6 @@
     <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
     <string name="leak_canary_delete_all">Alle löschen</string>
     <string name="leak_canary_delete_all_leaks_title">Bist du dir sicher, dass du alle Leaks löschen möchtest?</string>
-    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
     <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
     <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
     <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index e39f1f539..38bbbe6d8 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -27,6 +27,9 @@
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
   <string name="leak_canary_notification_reporting">Reporting LeakCanary result</string>
+  <string name="leak_canary_result_failure_no_disk_space">The analysis result could not be saved to disk</string>
+  <string name="leak_canary_result_failure_no_file">The analysis result could not be loaded from disk</string>
+  <string name="leak_canary_result_failure_title">Analysis result failure</string>
   <string name="leak_canary_share_leak">Share info</string>
   <string name="leak_canary_share_heap_dump">Share heap dump</string>
   <string name="leak_canary_share_with">Share with…</string>
@@ -37,7 +40,6 @@
   <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary and share the heapdump file that caused it.\n"</string>
   <string name="leak_canary_delete_all">Delete all</string>
   <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
-  <string name="leak_canary_could_not_save_title">Could not save result.</string>
   <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
   <string name="leak_canary_no_leak_title">No leak found</string>
   <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
