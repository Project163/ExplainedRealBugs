diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index 8c71ac307..c8a67e51b 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -12,25 +12,40 @@ import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import java.util.Locale
 
 fun LeakTrace.renderToString(): String {
-  var leakInfo = "┬\n"
-  val lastElement = elements.last()
-  val lastReachability = lastElement.leakStatusAndReason
-  elements.dropLast(1)
-      .forEachIndexed { index, leakTraceElement ->
-        val currentReachability = elements[index].leakStatusAndReason
-        leakInfo += """
-        #├─ ${leakTraceElement.className}
-        #│    Leaking: ${currentReachability.renderToString()}${if (leakTraceElement.labels.isNotEmpty()) leakTraceElement.labels.joinToString(
-            "\n│    ", prefix = "\n│    "
-        ) else ""}
-        #│    ↓ ${getNextElementString(this, leakTraceElement, index)}
-        #""".trimMargin("#")
-      }
-  leakInfo += """╰→ ${lastElement.className}
-      #$ZERO_WIDTH_SPACE     Leaking: ${lastReachability.renderToString()}
-    """.trimMargin("#")
+  var result = "┬"
 
-  return leakInfo
+  elements.forEachIndexed { index, element ->
+    val isLast = index == elements.lastIndex
+    val nodePrefix = if (!isLast) {
+      "├─ "
+    } else {
+      "╰→ "
+    }
+    result += "\n" + nodePrefix + element.className
+
+    val contentPrefix = if (!isLast) {
+      "│    "
+    } else {
+      "$ZERO_WIDTH_SPACE     "
+    }
+
+    val currentReachability = elements[index].leakStatusAndReason
+    result += "\n" + contentPrefix + "Leaking: " + currentReachability.renderToString()
+
+    if (element.exclusion != null) {
+      result += "\n" + contentPrefix + "Matches exclusion ${element.exclusion.matching}"
+    }
+
+    for (label in element.labels) {
+      result += "\n" + contentPrefix + label
+    }
+
+    if (!isLast) {
+      result += "\n" + contentPrefix + "↓ " + getNextElementString(this, element, index)
+    }
+
+  }
+  return result
 }
 
 private fun LeakNodeStatusAndReason.renderToString(): String {
@@ -56,8 +71,6 @@ private fun getNextElementString(
     } else ""
   val simpleClassName = element.simpleClassName
   val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
-  val exclusionString =
-    if (element.exclusion != null) ", matching exclusion ${element.exclusion.matching}" else ""
   val requiredSpaces =
     staticString.length + holderString.length + simpleClassName.length + "├─".length
   val leakString = if (maybeLeakCause) {
@@ -68,7 +81,7 @@ private fun getNextElementString(
     ""
   }
 
-  return staticString + holderString + simpleClassName + referenceName + exclusionString + leakString
+  return staticString + holderString + simpleClassName + referenceName + leakString
 }
 
 private const val ZERO_WIDTH_SPACE = '\u200b'
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index bf68c2678..385113eab 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -56,6 +56,7 @@ class HprofWriterHelper constructor(
   private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
 
   private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
+  private val objectArrayClassId = arrayClass("java.lang.Object")
   private val stringClassId = clazz(
       className = "java.lang.String", fields = listOf(
       "value" to ObjectReference::class,
@@ -236,7 +237,7 @@ class HprofWriterHelper constructor(
   fun objectArray(
     vararg elements: ObjectReference
   ): ObjectReference {
-    return objectArrayOf(objectClassId, *elements)
+    return objectArrayOf(objectArrayClassId, *elements)
   }
 
   fun objectArrayOf(
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
new file mode 100644
index 000000000..300b054c4
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -0,0 +1,191 @@
+package leakcanary.internal
+
+import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.LeakNodeStatus
+import leakcanary.LeakingInstance
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Ignore
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LeakTraceRendererTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun rendersSimplePath() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersLeakingWithReason() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["instanceB"] = "ClassB" instance {
+            field["leak"] = "Leaking" watchedInstance {}
+          }
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakInspectors = listOf { parser, node ->
+        with(parser) {
+          val record = node.instance.objectRecord
+          if (record is InstanceDumpRecord && className(record.classId) == "ClassB") {
+            LeakNodeStatus.leaking("because reasons")
+          } else {
+            LeakNodeStatus.unknown()
+          }
+        }
+      })
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.instanceA
+    │                    ~~~~~~~~~
+    ├─ ClassA
+    │    Leaking: UNKNOWN
+    │    ↓ ClassA.instanceB
+    │             ~~~~~~~~~
+    ├─ ClassB
+    │    Leaking: YES (because reasons)
+    │    ↓ ClassB.leak
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersLabelsOnAllNodes() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf { _, _ ->
+      listOf("¯\\_(ツ)_/¯")
+    })
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ¯\_(ツ)_/¯
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    ​     ¯\_(ツ)_/¯
+    """
+  }
+
+  @Test fun rendersExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["instanceA"] = "ClassA" instance {
+          field["leak"] = "Leaking" watchedInstance {}
+        }
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(exclusionsFactory = {
+        listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
+      })
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.instanceA
+    │                    ~~~~~~~~~
+    ├─ ClassA
+    │    Leaking: UNKNOWN
+    │    Matches exclusion field ClassA#leak
+    │    ↓ ClassA.leak
+    │             ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersArray() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["array"] = objectArray("Leaking" watchedInstance {})
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: NO (it's a GC root)
+    │    ↓ static GcRoot.array
+    │                    ~~~~~
+    ├─ java.lang.Object[]
+    │    Leaking: UNKNOWN
+    │    ↓ array Object[].[0]
+    │                     ~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  @Test fun rendersThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    analysis renders """
+    ┬
+    ├─ MyThread
+    │    Leaking: NO (it's a GC root)
+    │    ↓ thread MyThread.<Java Local>
+    │                      ~~~~~~~~~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (RefWatcher was watching this)
+    """
+  }
+
+  private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
+    val leak = retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.renderToString()).isEqualTo(
+        expectedString.trimIndent()
+    )
+  }
+}
\ No newline at end of file
