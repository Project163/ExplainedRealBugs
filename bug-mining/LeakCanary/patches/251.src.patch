diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt
index fb302d0c9..78a2e2d50 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/AndroidDetectLeaksAssert.kt
@@ -1,9 +1,10 @@
 package leakcanary
 
-import leakcanary.internal.RetainedObjectsInstrumentationChecker.YesNo.No
+import android.os.SystemClock
 import leakcanary.internal.InstrumentationHeapAnalyzer
 import leakcanary.internal.InstrumentationHeapDumpFileProvider
 import leakcanary.internal.RetainedObjectsInstrumentationChecker
+import leakcanary.internal.RetainedObjectsInstrumentationChecker.YesNo.No
 import leakcanary.internal.RetryingHeapAnalyzer
 import leakcanary.internal.friendly.checkNotMainThread
 import leakcanary.internal.friendly.measureDurationMillis
@@ -28,6 +29,17 @@ class AndroidDetectLeaksAssert(
   private val heapAnalysisReporter: HeapAnalysisReporter = NoLeakAssertionFailedError.throwOnApplicationLeaks()
 ) : DetectLeaksAssert {
   override fun assertNoLeaks(tag: String) {
+    val assertionStartUptimeMillis = SystemClock.uptimeMillis()
+    try {
+      runLeakChecks(tag, assertionStartUptimeMillis)
+    } finally {
+      val totalDurationMillis = SystemClock.uptimeMillis() - assertionStartUptimeMillis
+      totalVmDurationMillis += totalDurationMillis
+      SharkLog.d { "Spent $totalDurationMillis ms detecting leaks on $tag, VM total so far: $totalVmDurationMillis ms" }
+    }
+  }
+
+  private fun runLeakChecks(tag: String, assertionStartUptimeMillis: Long) {
     if (TestDescriptionHolder.isEvaluating()) {
       val testDescription = TestDescriptionHolder.testDescription
       if (SkipLeakDetection.shouldSkipTest(testDescription, tag)) {
@@ -35,12 +47,16 @@ class AndroidDetectLeaksAssert(
       }
     }
     checkNotMainThread()
+
     val retainedObjectsChecker = RetainedObjectsInstrumentationChecker()
-    val yesNo = retainedObjectsChecker.shouldDumpHeapWaitingForRetainedObjects()
-    if (yesNo is No) {
-      SharkLog.d { "Test can keep going: no heap dump performed (${yesNo.reason})" }
-      return
+    val waitForRetainedDurationMillis = measureDurationMillis {
+      val yesNo = retainedObjectsChecker.shouldDumpHeapWaitingForRetainedObjects()
+      if (yesNo is No) {
+        SharkLog.d { "Test can keep going: no heap dump performed (${yesNo.reason})" }
+        return
+      }
     }
+
     val heapDumpFile = InstrumentationHeapDumpFileProvider().newHeapDumpFile()
 
     val config = LeakCanary.config
@@ -48,6 +64,7 @@ class AndroidDetectLeaksAssert(
     val heapDumpDurationMillis = measureDurationMillis {
       config.heapDumper.dumpHeap(heapDumpFile)
     }
+    retainedObjectsChecker.clearObjectsWatchedBeforeHeapDump()
 
     val heapAnalyzer = RetryingHeapAnalyzer(
       InstrumentationHeapAnalyzer(
@@ -59,13 +76,37 @@ class AndroidDetectLeaksAssert(
         proguardMapping = null
       )
     )
-    val heapAnalysis = heapAnalyzer.analyze(heapDumpFile).let {
+    val analysisResult = heapAnalyzer.analyze(heapDumpFile)
+    val totalDurationMillis = SystemClock.uptimeMillis() - assertionStartUptimeMillis
+    val heapAnalysisWithExtraDetails = analysisResult.let {
       when (it) {
-        is HeapAnalysisSuccess -> it.copy(dumpDurationMillis = heapDumpDurationMillis)
+        is HeapAnalysisSuccess -> it.copy(
+          dumpDurationMillis = heapDumpDurationMillis,
+          metadata = it.metadata + mapOf(
+            ASSERTION_TAG to tag,
+            WAIT_FOR_RETAINED to waitForRetainedDurationMillis.toString(),
+            TOTAL_DURATION to totalDurationMillis.toString()
+          ),
+        )
         is HeapAnalysisFailure -> it.copy(dumpDurationMillis = heapDumpDurationMillis)
       }
     }
-    retainedObjectsChecker.clearObjectsWatchedBeforeHeapDump()
-    heapAnalysisReporter.reportHeapAnalysis(heapAnalysis)
+    heapAnalysisReporter.reportHeapAnalysis(heapAnalysisWithExtraDetails)
+  }
+
+  companion object {
+    private val ASSERTION_TAG = "assertionTag"
+    private val WAIT_FOR_RETAINED = "waitForRetainedDurationMillis"
+    private val TOTAL_DURATION = "totalDurationMillis"
+    private var totalVmDurationMillis = 0L
+
+    val HeapAnalysisSuccess.assertionTag: String?
+      get() = metadata[ASSERTION_TAG]
+
+    val HeapAnalysisSuccess.waitForRetainedDurationMillis: Int?
+      get() = metadata[WAIT_FOR_RETAINED]?.toInt()
+
+    val HeapAnalysisSuccess.totalDurationMillis: Int?
+      get() = metadata[TOTAL_DURATION]?.toInt()
   }
 }
