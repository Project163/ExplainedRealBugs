diff --git a/leakcanary-android-core/src/androidTest/assets/leaks-v19-android-16.db b/leakcanary-android-core/src/androidTest/assets/leaks-v19-android-16.db
deleted file mode 100644
index 59e30fc0f..000000000
Binary files a/leakcanary-android-core/src/androidTest/assets/leaks-v19-android-16.db and /dev/null differ
diff --git a/leakcanary-android-core/src/androidTest/assets/leaks-v24.db b/leakcanary-android-core/src/androidTest/assets/leaks-v24.db
new file mode 100644
index 000000000..c4c20ce66
Binary files /dev/null and b/leakcanary-android-core/src/androidTest/assets/leaks-v24.db differ
diff --git a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
index e11ccdd29..a4fc10de3 100644
--- a/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
+++ b/leakcanary-android-core/src/androidTest/java/leakcanary/DatabaseMigrationTest.kt
@@ -10,25 +10,24 @@ import shark.HeapAnalysis
 import shark.HeapAnalysisSuccess
 import shark.LeakTrace.GcRootType.JAVA_FRAME
 import shark.LeakTrace.GcRootType.STICKY_CLASS
-import shark.SharkLog
 import java.io.FileOutputStream
 
 class DatabaseMigrationTest {
 
-  @Test fun v19_upgraded_to_latest() {
-    DB_V19 upgrade {
+  @Test fun v24_upgraded_to_latest() {
+    DB_V24 upgrade {
       version assertEquals LeaksDbHelper.VERSION
     }
   }
 
-  @Test fun v19_has_2_heap_dumps() {
-    DB_V19 upgrade {
-      HeapAnalysisTable.retrieveAll(this).size assertEquals 2
+  @Test fun v24_has_1_heap_dumps() {
+    DB_V24 upgrade {
+      HeapAnalysisTable.retrieveAll(this).size assertEquals 1
     }
   }
 
-  @Test fun v19_heap_dumps_can_be_deserialized() {
-    DB_V19 upgrade {
+  @Test fun v24_heap_dumps_can_be_deserialized() {
+    DB_V24 upgrade {
       HeapAnalysisTable.retrieveAll(this)
         .forEach { projection ->
           val heapAnalysis = HeapAnalysisTable.retrieve<HeapAnalysis>(this, projection.id)!!
@@ -37,8 +36,8 @@ class DatabaseMigrationTest {
     }
   }
 
-  @Test fun v19_has_8_leak_traces() {
-    DB_V19 upgrade {
+  @Test fun v24_has_8_leak_traces() {
+    DB_V24 upgrade {
       val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
         .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
         .flatMap { analysis ->
@@ -52,23 +51,23 @@ class DatabaseMigrationTest {
     }
   }
 
-  @Test fun v19_has_3_leak_types() {
-    DB_V19 upgrade {
+  @Test fun v24_has_3_leak_types() {
+    DB_V24 upgrade {
       LeakTable.retrieveAllLeaks(this).size assertEquals 3
     }
   }
 
-  @Test fun v19_leaks_are_not_new() {
-    DB_V19 upgrade {
+  @Test fun v24_leaks_are_new() {
+    DB_V24 upgrade {
       LeakTable.retrieveAllLeaks(this)
         .forEach { leak ->
-          leak.isNew assertEquals false
+          leak.isNew assertEquals true
         }
     }
   }
 
-  @Test fun v19_has_5_sticky_class_and_3_java_frame_gc_roots() {
-    DB_V19 upgrade {
+  @Test fun v24_has_5_sticky_class_and_3_java_frame_gc_roots() {
+    DB_V24 upgrade {
       val allLeakTraces = HeapAnalysisTable.retrieveAll(this)
         .map { HeapAnalysisTable.retrieve<HeapAnalysisSuccess>(this, it.id)!! }
         .flatMap { analysis ->
@@ -80,7 +79,7 @@ class DatabaseMigrationTest {
       val gcRootCounts = allLeakTraces.groupingBy { it.gcRootType }
         .eachCount()
 
-      gcRootCounts.getValue(STICKY_CLASS) assertEquals 5
+      gcRootCounts.getValue(STICKY_CLASS) assertEquals 2
       gcRootCounts.getValue(JAVA_FRAME) assertEquals 3
     }
   }
@@ -119,6 +118,6 @@ class DatabaseMigrationTest {
   }
 
   companion object {
-    const val DB_V19 = "leaks-v19-android-16.db"
+    const val DB_V24 = "leaks-v24.db"
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 5181e37de..0aaff9e9a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -5,8 +5,10 @@ import android.content.Context
 import android.database.sqlite.SQLiteDatabase
 import android.database.sqlite.SQLiteOpenHelper
 import leakcanary.internal.Serializables
+import leakcanary.internal.toByteArray
 import shark.HeapAnalysis
 import shark.HeapAnalysisSuccess
+import shark.LeakTrace
 
 internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   context, DATABASE_NAME, null, VERSION
@@ -24,35 +26,77 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
     oldVersion: Int,
     newVersion: Int
   ) {
-    if (oldVersion < 19) {
+    if (oldVersion < 23) {
       recreateDb(db)
-    } else if (oldVersion == 19) {
-      // Migration from LeakCanary 2.0
-      val allAnalysis = db.rawQuery("SELECT object FROM heap_analysis", null)
+      return
+    }
+    if (oldVersion < 24) {
+      db.execSQL("ALTER TABLE heap_analysis ADD COLUMN dump_duration_millis INTEGER DEFAULT -1")
+    }
+    if (oldVersion < 25) {
+      // Fix owningClassName=null in the serialized heap analysis.
+      // https://github.com/square/leakcanary/issues/2067
+      val idToAnalysis = db.rawQuery("SELECT id, object FROM heap_analysis", null)
         .use { cursor ->
           generateSequence {
             if (cursor.moveToNext()) {
-              Serializables.fromByteArray<HeapAnalysis>(cursor.getBlob(0))
+              val id = cursor.getLong(0)
+              val analysis = Serializables.fromByteArray<HeapAnalysis>(cursor.getBlob(1))
+              id to analysis
             } else {
               null
             }
-          }.map {
-            if (it is HeapAnalysisSuccess) {
-              HeapAnalysisSuccess.upgradeFrom20Deserialized(it)
-            } else it
-          }.toList()
+          }
+            .filter {
+              it.second is HeapAnalysisSuccess
+            }
+            .map { pair ->
+              val analysis = pair.second as HeapAnalysisSuccess
+
+              val unreachableObjects = try {
+                analysis.unreachableObjects
+              } catch (ignored: NullPointerException) {
+                // This currently doesn't trigger but the Kotlin compiler might change one day.
+                emptyList()
+              } ?: emptyList() // Compiler doesn't know it but runtime can have null.
+              pair.first to analysis.copy(
+                unreachableObjects = unreachableObjects,
+                applicationLeaks = analysis.applicationLeaks.map { leak ->
+                  leak.copy(leak.leakTraces.fixNullReferenceOwningClassName())
+                },
+                libraryLeaks = analysis.libraryLeaks.map { leak ->
+                  leak.copy(leak.leakTraces.fixNullReferenceOwningClassName())
+                }
+              )
+            }.toList()
         }
-      recreateDb(db)
       db.inTransaction {
-        allAnalysis.forEach { HeapAnalysisTable.insert(db, it) }
-        db.update("leak", ContentValues().apply {
-          put("is_read", 1)
-        }, null, null)
+        idToAnalysis.forEach { (id, heapAnalysis) ->
+          val values = ContentValues()
+          values.put("object", heapAnalysis.toByteArray())
+          db.update("heap_analysis", values, "id=$id", null)
+        }
       }
-    } else if (oldVersion == 23) {
-      db.execSQL("ALTER TABLE heap_analysis ADD COLUMN dump_duration_millis INTEGER DEFAULT -1")
-    } else {
-      throw IllegalStateException("Database migration from $oldVersion not supported")
+    }
+  }
+
+  private fun List<LeakTrace>.fixNullReferenceOwningClassName(): List<LeakTrace> {
+    return map { leakTrace ->
+      leakTrace.copy(
+        referencePath = leakTrace.referencePath.map { reference ->
+          val owningClassName = try {
+            // This can return null at runtime from previous serialized version without the field.
+            reference.owningClassName
+          } catch (ignored: NullPointerException) {
+            // This currently doesn't trigger but the Kotlin compiler might change one day.
+            null
+          }
+          if (owningClassName == null) {
+            reference.copy(owningClassName = reference.originObject.classSimpleName)
+          } else {
+            reference
+          }
+        })
     }
   }
 
@@ -72,7 +116,7 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   }
 
   companion object {
-    internal const val VERSION = 24
+    internal const val VERSION = 25
     internal const val DATABASE_NAME = "leaks.db"
   }
 }
\ No newline at end of file
diff --git a/shark/api/shark.api b/shark/api/shark.api
index e4dda71a7..54b1fd607 100644
--- a/shark/api/shark.api
+++ b/shark/api/shark.api
@@ -103,7 +103,6 @@ public final class shark/HeapAnalysisSuccess : shark/HeapAnalysis {
 }
 
 public final class shark/HeapAnalysisSuccess$Companion {
-	public final fun upgradeFrom20Deserialized (Lshark/HeapAnalysisSuccess;)Lshark/HeapAnalysisSuccess;
 }
 
 public final class shark/HeapAnalyzer {
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
index 78ba0469d..af3819438 100644
--- a/shark/src/main/java/shark/HeapAnalysis.kt
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -150,42 +150,6 @@ Heap dump duration: ${if (dumpDurationMillis != DUMP_DURATION_UNKNOWN) "$dumpDur
 
   companion object {
     private const val serialVersionUID: Long = 130453013437459642
-
-    /**
-     * If [fromV20] was serialized in LeakCanary 2.0, you must deserialize it and call this
-     * method to create a usable [HeapAnalysisSuccess] instance.
-     */
-    fun upgradeFrom20Deserialized(fromV20: HeapAnalysisSuccess): HeapAnalysisSuccess {
-      val applicationLeaks = fromV20.applicationLeaks
-        .map { it.leakTraceFromV20() }
-        .groupBy { it.signature }
-        .values
-        .map {
-          ApplicationLeak(it)
-        }
-
-      val libraryLeaks = fromV20.libraryLeaks
-        .map { it to it.leakTraceFromV20() }
-        .groupBy { it.second.signature }
-        .values
-        .map { listOfPairs ->
-          val libraryLeakFrom20 = listOfPairs.first()
-            .first
-          LibraryLeak(pattern = libraryLeakFrom20.pattern,
-            description = libraryLeakFrom20.description,
-            leakTraces = listOfPairs.map { it.second }
-          )
-        }
-      return HeapAnalysisSuccess(
-        heapDumpFile = fromV20.heapDumpFile,
-        createdAtTimeMillis = fromV20.createdAtTimeMillis,
-        analysisDurationMillis = fromV20.analysisDurationMillis,
-        metadata = fromV20.metadata,
-        applicationLeaks = applicationLeaks,
-        libraryLeaks = libraryLeaks,
-        unreachableObjects = listOf()
-      )
-    }
   }
 }
 
@@ -273,14 +237,6 @@ ${super.toString()}
 """
   }
 
-  /** This field is kept to support backward compatible deserialization. */
-  private val leakTrace: LeakTrace? = null
-
-  /** This field is kept to support backward compatible deserialization. */
-  private val retainedHeapByteSize: Int? = null
-
-  internal fun leakTraceFromV20() = leakTrace!!.fromV20(retainedHeapByteSize)
-
   companion object {
     private const val serialVersionUID: Long = 3943636164568681903
   }
@@ -309,14 +265,6 @@ data class ApplicationLeak(
     return super.toString()
   }
 
-  /** This field is kept to support backward compatible deserialization. */
-  private val leakTrace: LeakTrace? = null
-
-  /** This field is kept to support backward compatible deserialization. */
-  private val retainedHeapByteSize: Int? = null
-
-  internal fun leakTraceFromV20() = leakTrace!!.fromV20(retainedHeapByteSize)
-
   companion object {
     private const val serialVersionUID: Long = 524928276700576863
   }
diff --git a/shark/src/main/java/shark/LeakReference.kt b/shark/src/main/java/shark/LeakReference.kt
deleted file mode 100644
index 378b5744d..000000000
--- a/shark/src/main/java/shark/LeakReference.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-package shark
-
-import shark.LeakTraceElement.Type.ARRAY_ENTRY
-import shark.LeakTraceElement.Type.INSTANCE_FIELD
-import shark.LeakTraceElement.Type.LOCAL
-import shark.LeakTraceElement.Type.STATIC_FIELD
-import java.io.Serializable
-
-/**
- * This class is kept to support backward compatible deserialization.
- */
-internal class LeakReference : Serializable {
-
-  private val type: LeakTraceElement.Type? = null
-  private val name: String? = null
-
-  fun fromV20(originObject: LeakTraceObject) = LeakTraceReference(
-    originObject = originObject,
-    referenceType = when (type!!) {
-      INSTANCE_FIELD -> LeakTraceReference.ReferenceType.INSTANCE_FIELD
-      STATIC_FIELD -> LeakTraceReference.ReferenceType.STATIC_FIELD
-      LOCAL -> LeakTraceReference.ReferenceType.LOCAL
-      ARRAY_ENTRY -> LeakTraceReference.ReferenceType.ARRAY_ENTRY
-    },
-    owningClassName = originObject.className,
-    referenceName = name!!
-  )
-
-  companion object {
-    private const val serialVersionUID: Long = 2028550902155599651
-  }
-}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
index 3cb594bc3..5b420b1f8 100644
--- a/shark/src/main/java/shark/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -162,20 +162,6 @@ data class LeakTrace(
     }
   }
 
-  /** This field is kept to support backward compatible deserialization. */
-  private val elements: List<LeakTraceElement>? = null
-
-  internal fun fromV20(retainedHeapByteSize: Int?) = LeakTrace(
-    gcRootType = elements!!.first().gcRootTypeFromV20(),
-    referencePath = when {
-      elements.isEmpty() -> emptyList()
-      else -> elements
-        .subList(0, elements.lastIndex - 1)
-        .map { it.referencePathElementFromV20() }
-    },
-    leakingObject = elements.last().originObjectFromV20()
-  )
-
   companion object {
     private fun getNextElementString(
       leakTrace: LeakTrace,
diff --git a/shark/src/main/java/shark/LeakTraceElement.kt b/shark/src/main/java/shark/LeakTraceElement.kt
deleted file mode 100644
index 8db947f6e..000000000
--- a/shark/src/main/java/shark/LeakTraceElement.kt
+++ /dev/null
@@ -1,82 +0,0 @@
-package shark
-
-import shark.LeakNodeStatus.LEAKING
-import shark.LeakNodeStatus.NOT_LEAKING
-import shark.LeakNodeStatus.UNKNOWN
-import shark.LeakTrace.GcRootType
-import shark.LeakTraceElement.Holder.ARRAY
-import shark.LeakTraceElement.Holder.CLASS
-import shark.LeakTraceElement.Holder.OBJECT
-import shark.LeakTraceElement.Holder.THREAD
-import shark.LeakTraceObject.LeakingStatus
-import shark.LeakTraceObject.ObjectType
-import java.io.Serializable
-
-/**
- * This class is kept to support backward compatible deserialization.
- */
-internal class LeakTraceElement : Serializable {
-
-  private val reference: LeakReference? = null
-  private val holder: Holder? = null
-  private val className: String? = null
-  private val labels: Set<String>? = null
-  private val leakStatus: LeakNodeStatus? = null
-  private val leakStatusReason: String? = null
-
-  enum class Type {
-    INSTANCE_FIELD,
-    STATIC_FIELD,
-    LOCAL,
-    ARRAY_ENTRY
-  }
-
-  enum class Holder {
-    OBJECT,
-    CLASS,
-    THREAD,
-    ARRAY
-  }
-
-  fun gcRootTypeFromV20() = when (val gcRootLabel = labels!!
-    .first {
-      it.startsWith("GC Root: ")
-    }
-    .substring("GC Root: ".length)) {
-    "Thread object" -> GcRootType.THREAD_OBJECT
-    "Global variable in native code" -> GcRootType.JNI_GLOBAL
-    "Local variable in native code" -> GcRootType.JNI_LOCAL
-    "Java local variable" -> GcRootType.JAVA_FRAME
-    "Input or output parameters in native code" -> GcRootType.NATIVE_STACK
-    "System class" -> GcRootType.STICKY_CLASS
-    "Thread block" -> GcRootType.THREAD_BLOCK
-    "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)" -> GcRootType.MONITOR_USED
-    "Root JNI monitor" -> GcRootType.JNI_MONITOR
-    else -> throw IllegalStateException("Unexpected gc root label $gcRootLabel")
-  }
-
-  fun referencePathElementFromV20() = reference!!.fromV20(originObjectFromV20())
-
-  fun originObjectFromV20() = LeakTraceObject(
-    type = when (holder!!) {
-      OBJECT -> ObjectType.INSTANCE
-      CLASS -> ObjectType.CLASS
-      THREAD -> ObjectType.INSTANCE
-      ARRAY -> ObjectType.ARRAY
-    },
-    className = className!!,
-    labels = labels!!.filter { !it.startsWith("GC Root: ") }.toSet(),
-    leakingStatus = when (leakStatus!!) {
-      NOT_LEAKING -> LeakingStatus.NOT_LEAKING
-      LEAKING -> LeakingStatus.LEAKING
-      UNKNOWN -> LeakingStatus.UNKNOWN
-    },
-    leakingStatusReason = leakStatusReason!!,
-    retainedHeapByteSize = null,
-    retainedObjectCount = null
-  )
-
-  companion object {
-    private const val serialVersionUID: Long = -6795139831875582552
-  }
-}
\ No newline at end of file
