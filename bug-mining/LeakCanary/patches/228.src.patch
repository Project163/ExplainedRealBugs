diff --git a/shark-android/api/shark-android.api b/shark-android/api/shark-android.api
index 2e6198217..f53fd559f 100644
--- a/shark-android/api/shark-android.api
+++ b/shark-android/api/shark-android.api
@@ -19,6 +19,7 @@ public abstract class shark/AndroidObjectInspectors : java/lang/Enum, shark/Obje
 	public static final field ANDROIDX_FRAGMENT Lshark/AndroidObjectInspectors;
 	public static final field APPLICATION Lshark/AndroidObjectInspectors;
 	public static final field APPLICATION_PACKAGE_MANAGER Lshark/AndroidObjectInspectors;
+	public static final field COMPOSITION_IMPL Lshark/AndroidObjectInspectors;
 	public static final field CONTEXT_FIELD Lshark/AndroidObjectInspectors;
 	public static final field CONTEXT_IMPL Lshark/AndroidObjectInspectors;
 	public static final field CONTEXT_WRAPPER Lshark/AndroidObjectInspectors;
@@ -34,6 +35,7 @@ public abstract class shark/AndroidObjectInspectors : java/lang/Enum, shark/Obje
 	public static final field MESSAGE_QUEUE Lshark/AndroidObjectInspectors;
 	public static final field MORTAR_PRESENTER Lshark/AndroidObjectInspectors;
 	public static final field MORTAR_SCOPE Lshark/AndroidObjectInspectors;
+	public static final field RECOMPOSER Lshark/AndroidObjectInspectors;
 	public static final field SERVICE Lshark/AndroidObjectInspectors;
 	public static final field SUPPORT_FRAGMENT Lshark/AndroidObjectInspectors;
 	public static final field TOAST Lshark/AndroidObjectInspectors;
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index b2af03795..6721ce75b 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -15,8 +15,8 @@
  */
 package shark
 
-import shark.AndroidServices.aliveAndroidServiceObjectIds
 import shark.AndroidObjectInspectors.Companion.appDefaults
+import shark.AndroidServices.aliveAndroidServiceObjectIds
 import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapInstance
 import java.util.EnumSet
@@ -224,7 +224,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
         if (instance.objectId in instance.graph.aliveAndroidServiceObjectIds) {
           notLeakingReasons += "Service held by ActivityThread"
         } else {
-          leakingReasons +=  "Service not held by ActivityThread"
+          leakingReasons += "Service not held by ActivityThread"
         }
       }
     }
@@ -750,7 +750,39 @@ enum class AndroidObjectInspectors : ObjectInspector {
         }
       }
     }
-  };
+  },
+
+  RECOMPOSER {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.compose.runtime.Recomposer") { instance ->
+        val stateFlow =
+          instance["androidx.compose.runtime.Recomposer", "_state"]!!.valueAsInstance!!
+        val state = stateFlow["kotlinx.coroutines.flow.StateFlowImpl", "_state"]?.valueAsInstance
+        if (state != null) {
+          val stateName = state["java.lang.Enum", "name"]!!.valueAsInstance!!.readAsJavaString()!!
+          val label = "Recomposer is in state $stateName"
+          when (stateName) {
+            "ShutDown", "ShuttingDown" -> leakingReasons += label
+            "Inactive", "InactivePendingWork" -> labels += label
+            "PendingWork", "Idle" -> notLeakingReasons += label
+          }
+        }
+      }
+    }
+  },
+
+  COMPOSITION_IMPL {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("androidx.compose.runtime.CompositionImpl") { instance ->
+        if (instance["androidx.compose.runtime.CompositionImpl", "disposed"]!!.value.asBoolean!!) {
+          leakingReasons += "Composition disposed"
+        } else {
+          notLeakingReasons += "Composition not disposed"
+        }
+      }
+    }
+  }
+  ;
 
   internal open val leakingObjectFilter: ((heapObject: HeapObject) -> Boolean)? = null
 
diff --git a/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt b/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt
new file mode 100644
index 000000000..83908be96
--- /dev/null
+++ b/shark-android/src/test/java/shark/AndroidObjectInspectorsTest.kt
@@ -0,0 +1,67 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.LeakTraceObject.LeakingStatus.LEAKING
+import shark.LeakTraceObject.LeakingStatus.NOT_LEAKING
+import shark.LeakTraceObject.ObjectType.INSTANCE
+
+class AndroidObjectInspectorsTest {
+
+  @Test fun `RECOMPOSER leaking status relies on state`() {
+    val hprofFile = "compose_leak.hprof".classpathFile()
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = { graph ->
+        val composeViewClass =
+          graph.findClassByName("androidx.compose.ui.platform.AndroidComposeView")
+        composeViewClass!!.instances.filter { instance ->
+          val filter = AndroidObjectInspectors.VIEW.leakingObjectFilter!!
+          filter.invoke(instance)
+          true
+        }.map { it.objectId }.toSet()
+      },
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      objectInspectors = AndroidObjectInspectors.appDefaults
+    )
+    println(analysis)
+    analysis as HeapAnalysisSuccess
+    val recomposerNode = analysis.applicationLeaks.single()
+      .leakTraces.single()
+      .referencePath.single {
+        it.originObject.type == INSTANCE
+          && it.owningClassSimpleName == "Recomposer"
+      }
+    assertThat(recomposerNode.originObject.leakingStatus == NOT_LEAKING)
+    assertThat(recomposerNode.originObject.leakingStatusReason == "Recomposer is in state PendingWork")
+  }
+
+  @Test fun `COMPOSITION_IMPL leaking status relies on disposal`() {
+    val hprofFile = "compose_leak.hprof".classpathFile()
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+      heapDumpFile = hprofFile,
+      leakingObjectFinder = { graph ->
+        val composeViewClass =
+          graph.findClassByName("androidx.compose.ui.platform.AndroidComposeView")
+        composeViewClass!!.instances.filter { instance ->
+          val filter = AndroidObjectInspectors.VIEW.leakingObjectFilter!!
+          filter.invoke(instance)
+          true
+        }.map { it.objectId }.toSet()
+      },
+      referenceMatchers = AndroidReferenceMatchers.appDefaults,
+      objectInspectors = AndroidObjectInspectors.appDefaults
+    )
+    println(analysis)
+    analysis as HeapAnalysisSuccess
+    val recomposerNode = analysis.applicationLeaks.single()
+      .leakTraces.single()
+      .referencePath.single {
+        it.owningClassSimpleName == "CompositionImpl"
+      }
+    assertThat(recomposerNode.originObject.leakingStatus == LEAKING)
+    assertThat(recomposerNode.originObject.leakingStatusReason == "Composition disposed")
+  }
+}
diff --git a/shark-android/src/test/resources/compose_leak.hprof b/shark-android/src/test/resources/compose_leak.hprof
new file mode 100644
index 000000000..996ad2afc
Binary files /dev/null and b/shark-android/src/test/resources/compose_leak.hprof differ
