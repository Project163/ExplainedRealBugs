diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
similarity index 100%
rename from leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index c99f8c7f5..3653d46f7 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -184,7 +184,7 @@ class HprofHeapGraph internal constructor(
 
   companion object {
     fun indexHprof(hprof: Hprof): HeapGraph {
-      val index = HprofInMemoryIndex.createReadingHprof(hprof.reader)
+      val index = HprofInMemoryIndex.createReadingHprof(hprof)
       return HprofHeapGraph(hprof, index)
     }
   }
diff --git a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
new file mode 100644
index 000000000..6222e13a6
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
@@ -0,0 +1,95 @@
+package shark.internal
+
+/**
+ * Provides read access to a sub part of a larger array.
+ */
+internal class ByteSubArray(
+  private val array: ByteArray,
+  private val range: IntRange,
+  private val longIdentifiers: Boolean
+) {
+  private val endInclusive = range.endInclusive - range.start
+
+  val size = endInclusive + 1
+  private var currentIndex = 0
+
+  fun readByte(): Byte {
+    val index = currentIndex
+    currentIndex++
+    require(index in 0..endInclusive) {
+      "Index $index should be between 0 and $endInclusive"
+    }
+    return array[range.first + index]
+  }
+
+  fun readId(): Long {
+    return if (longIdentifiers) {
+      readLong()
+    } else {
+      readInt().toLong()
+    }
+  }
+
+  fun readInt(): Int {
+    val index = currentIndex
+    currentIndex += 4
+    require(index >= 0 && index <= endInclusive - 3) {
+      "Index $index should be between 0 and ${endInclusive - 3}"
+    }
+    return array.readInt(range.first + index)
+  }
+
+  fun readTruncatedLong(byteCount: Int): Long {
+    val index = currentIndex
+    currentIndex += byteCount
+    require(index >= 0 && index <= endInclusive - (byteCount - 1)) {
+      "Index $index should be between 0 and ${endInclusive - (byteCount - 1)}"
+    }
+    var pos = range.first + index
+    val array = array
+
+    var value = 0L
+    for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+      value = value or (array[pos++] and 0xffL shl shift)
+    }
+    value = value or (array[pos] and 0xffL)
+    return value
+  }
+
+  fun readLong(): Long {
+    val index = currentIndex
+    currentIndex += 8
+    require(index >= 0 && index <= endInclusive - 7) {
+      "Index $index should be between 0 and ${endInclusive - 7}"
+    }
+    return array.readLong(range.first + index)
+  }
+}
+
+internal fun ByteArray.readInt(index: Int): Int {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff))
+}
+
+internal fun ByteArray.readLong(index: Int): Long {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xffL shl 56
+      or (array[pos++] and 0xffL shl 48)
+      or (array[pos++] and 0xffL shl 40)
+      or (array[pos++] and 0xffL shl 32)
+      or (array[pos++] and 0xffL shl 24)
+      or (array[pos++] and 0xffL shl 16)
+      or (array[pos++] and 0xffL shl 8)
+      or (array[pos] and 0xffL))
+}
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Int): Int = toInt() and other
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index c7dd54852..1f9e41c07 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -10,21 +10,13 @@ import shark.GcRoot.NativeStack
 import shark.GcRoot.StickyClass
 import shark.GcRoot.ThreadBlock
 import shark.GcRoot.ThreadObject
-import shark.HprofReader
+import shark.Hprof
 import shark.HprofRecord
 import shark.HprofRecord.HeapDumpRecord.GcRootRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
 import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StringRecord
 import shark.OnHprofRecordListener
@@ -42,9 +34,13 @@ import kotlin.reflect.KClass
  * This class is not thread safe, should be used from a single thread.
  */
 internal class HprofInMemoryIndex private constructor(
+  private val positionSize: Int,
   private val hprofStringCache: LongObjectScatterMap<String>,
   private val classNames: LongLongScatterMap,
-  private val objectIndex: LongObjectScatterMap<IndexedObject>,
+  private val classIndex: SortedBytesMap,
+  private val instanceIndex: SortedBytesMap,
+  private val objectArrayIndex: SortedBytesMap,
+  private val primitiveArrayIndex: SortedBytesMap,
   private val gcRoots: List<GcRoot>,
   val primitiveWrapperTypes: Set<Long>
 ) {
@@ -62,9 +58,10 @@ internal class HprofInMemoryIndex private constructor(
 
   fun classId(className: String): Long? {
     // Note: this performs two linear scans over arrays
-    return hprofStringCache.entrySequence()
+    val hprofStringId = hprofStringCache.entrySequence()
         .firstOrNull { it.second == className }
-        ?.first?.let { stringId ->
+        ?.first
+    return hprofStringId?.let { stringId ->
       classNames.entrySequence()
           .firstOrNull { it.second == stringId }
           ?.first
@@ -72,19 +69,63 @@ internal class HprofInMemoryIndex private constructor(
   }
 
   fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedClass }
-        .map { it.first to it.second as IndexedClass }
+    return classIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          id to IndexedClass(
+              position = array.readTruncatedLong(positionSize),
+              superclassId = array.readId(),
+              instanceSize = array.readInt()
+          )
+        }
   }
 
   fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedInstance }
-        .map { it.first to it.second as IndexedInstance }
+    return instanceIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val instance = IndexedInstance(
+              position = array.readTruncatedLong(positionSize),
+              classId = array.readId()
+          )
+          id to instance
+        }
+  }
+
+  fun indexedObjectArraySequence(): Sequence<Pair<Long, IndexedObjectArray>> {
+    return objectArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val objectArray = IndexedObjectArray(
+              position = array.readTruncatedLong(positionSize),
+              arrayClassId = array.readId()
+          )
+          id to objectArray
+        }
+  }
+
+  fun indexedPrimitiveArraySequence(): Sequence<Pair<Long, IndexedPrimitiveArray>> {
+    return primitiveArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+
+          val primitiveArray = IndexedPrimitiveArray(
+              position = array.readTruncatedLong(positionSize),
+              primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+          )
+          id to primitiveArray
+        }
   }
 
   fun indexedObjectSequence(): Sequence<Pair<Long, IndexedObject>> {
-    return objectIndex.entrySequence()
+    return indexedClassSequence() +
+        indexedInstanceSequence() +
+        indexedObjectArraySequence() +
+        indexedPrimitiveArraySequence()
   }
 
   fun gcRoots(): List<GcRoot> {
@@ -92,27 +133,83 @@ internal class HprofInMemoryIndex private constructor(
   }
 
   fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId] ?: throw IllegalArgumentException(
+    return indexedObjectOrNull(objectId) ?: throw IllegalArgumentException(
         "Object id $objectId not found in heap dump."
     )
   }
 
+  private fun indexedObjectOrNull(objectId: Long): IndexedObject? {
+    var array: ByteSubArray? = classIndex[objectId]
+    if (array != null) {
+      return IndexedClass(
+          position = array.readTruncatedLong(positionSize),
+          superclassId = array.readId(),
+          instanceSize = array.readInt()
+      )
+    }
+    array = instanceIndex[objectId]
+    if (array != null) {
+      return IndexedInstance(
+          position = array.readTruncatedLong(positionSize),
+          classId = array.readId()
+      )
+    }
+    array = objectArrayIndex[objectId]
+    if (array != null) {
+      return IndexedObjectArray(
+          position = array.readTruncatedLong(positionSize),
+          arrayClassId = array.readId()
+      )
+    }
+    array = primitiveArrayIndex[objectId]
+    if (array != null) {
+      return IndexedPrimitiveArray(
+          position = array.readTruncatedLong(positionSize),
+          primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+      )
+    }
+    return null
+  }
+
   fun objectIdIsIndexed(objectId: Long): Boolean {
-    return objectIndex[objectId] != null
+    if (classIndex[objectId] != null) {
+      return true
+    }
+    if (instanceIndex[objectId] != null) {
+      return true
+    }
+    if (objectArrayIndex[objectId] != null) {
+      return true
+    }
+    if (primitiveArrayIndex[objectId] != null) {
+      return true
+    }
+    return false
   }
 
   private class Builder(
+    longIdentifiers: Boolean,
+    fileLength: Long,
+    classCount: Int,
+    instanceCount: Int,
+    objectArrayCount: Int,
+    primitiveArrayCount: Int,
     private val indexedGcRootsTypes: Set<KClass<out GcRoot>>
   ) : OnHprofRecordListener {
+
+    private val identifierSize = if (longIdentifiers) 8 else 4
+    private val positionSize = byteSizeForUnsigned(fileLength)
+
     /**
      * Map of string id to string
      * This currently keeps all the hprof strings that we could care about: class names,
      * static field names and instance fields names
      */
     // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
-    // memory.
-    // Another option is to switch back to reading from the file system as necessary, and keep a much
-    // smaller cache for strings we need during shortest path (those are for exclusions)
+    // memory. Can be stored as 3 arrays: array of keys, array of values which are indexes into
+    // a large array of string bytes. Each "entry" consists of a size, the index of the previous
+    // segment and then the segment content.
+
     private val hprofStringCache = LongObjectScatterMap<String>()
 
     /**
@@ -120,12 +217,26 @@ internal class HprofInMemoryIndex private constructor(
      */
     private val classNames = LongLongScatterMap()
 
-    /**
-     * Object id to [IndexedObject].
-     * The id can be for classes instances, classes, object arrays and primitive arrays
-     */
-    private val objectIndex =
-      LongObjectScatterMap<IndexedObject>()
+    private val classIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize + 4,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = classCount
+    )
+    private val instanceIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = instanceCount
+    )
+    private val objectArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = objectArrayCount
+    )
+    private val primitiveArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + 1,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = primitiveArrayCount
+    )
 
     /**
      * Class ids for primitive wrapper types
@@ -163,35 +274,49 @@ internal class HprofInMemoryIndex private constructor(
             gcRoots += gcRoot
           }
         }
-        is ClassDumpRecord -> {
-          objectIndex[record.id] = IndexedClass(position, record.superclassId, record.instanceSize)
+        is ClassSkipContentRecord -> {
+          classIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.superclassId)
+                writeInt(record.instanceSize)
+              }
         }
-        is InstanceDumpRecord -> {
-          objectIndex[record.id] = IndexedInstance(position, record.classId)
+        is InstanceSkipContentRecord -> {
+          instanceIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.classId)
+              }
         }
-        is ObjectArrayDumpRecord -> {
-          objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
+        is ObjectArraySkipContentRecord -> {
+          objectArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.arrayClassId)
+              }
         }
-        is PrimitiveArrayDumpRecord -> {
-          val primitiveType = when (record) {
-            is BooleanArrayDump -> PrimitiveType.BOOLEAN
-            is CharArrayDump -> PrimitiveType.CHAR
-            is FloatArrayDump -> PrimitiveType.FLOAT
-            is DoubleArrayDump -> PrimitiveType.DOUBLE
-            is ByteArrayDump -> PrimitiveType.BYTE
-            is ShortArrayDump -> PrimitiveType.SHORT
-            is IntArrayDump -> PrimitiveType.INT
-            is LongArrayDump -> PrimitiveType.LONG
-          }
-          objectIndex[record.id] = IndexedPrimitiveArray(position, primitiveType)
+        is PrimitiveArraySkipContentRecord -> {
+          primitiveArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeByte(record.type.ordinal.toByte())
+              }
         }
       }
     }
 
     fun buildIndex(): HprofInMemoryIndex {
+      val sortedInstanceIndex = instanceIndex.moveToSortedMap()
+      val sortedObjectArrayIndex = objectArrayIndex.moveToSortedMap()
+      val sortedPrimitiveArrayIndex = primitiveArrayIndex.moveToSortedMap()
+      val sortedClassIndex = classIndex.moveToSortedMap()
       // Passing references to avoid copying the underlying data structures.
       return HprofInMemoryIndex(
-          hprofStringCache, classNames, objectIndex, gcRoots,
+          positionSize,
+          hprofStringCache, classNames, sortedClassIndex, sortedInstanceIndex,
+          sortedObjectArrayIndex,
+          sortedPrimitiveArrayIndex, gcRoots,
           primitiveWrapperTypes
       )
     }
@@ -206,8 +331,18 @@ internal class HprofInMemoryIndex private constructor(
         Int::class.java.name, Long::class.java.name
     )
 
+    private fun byteSizeForUnsigned(maxValue: Long): Int {
+      var value = maxValue
+      var byteCount = 0
+      while (value != 0L) {
+        value = value shr 8
+        byteCount++
+      }
+      return byteCount
+    }
+
     fun createReadingHprof(
-      reader: HprofReader,
+      hprof: Hprof,
       indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
           JniGlobal::class,
           JavaFrame::class,
@@ -239,14 +374,42 @@ internal class HprofInMemoryIndex private constructor(
       val recordTypes = setOf(
           StringRecord::class,
           LoadClassRecord::class,
-          ClassDumpRecord::class,
-          InstanceDumpRecord::class,
-          ObjectArrayDumpRecord::class,
-          PrimitiveArrayDumpRecord::class,
+          ClassSkipContentRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class,
           GcRootRecord::class
       )
-      val indexBuilderListener = Builder(indexedGcRootTypes)
+      val reader = hprof.reader
+
+      // First pass to count and correctly size arrays once and for all.
+      var classCount = 0
+      var instanceCount = 0
+      var objectArrayCount = 0
+      var primitiveArrayCount = 0
+      reader.readHprofRecords(setOf(
+          LoadClassRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class
+      ), OnHprofRecordListener { position, record ->
+        when (record) {
+          is LoadClassRecord -> classCount++
+          is InstanceSkipContentRecord -> instanceCount++
+          is ObjectArraySkipContentRecord -> objectArrayCount++
+          is PrimitiveArraySkipContentRecord -> primitiveArrayCount++
+        }
+      })
+
+      hprof.moveReaderTo(reader.startPosition)
+      val indexBuilderListener =
+        Builder(
+            reader.identifierByteSize == 8, hprof.fileLength, classCount, instanceCount,
+            objectArrayCount, primitiveArrayCount, indexedGcRootTypes
+        )
+
       reader.readHprofRecords(recordTypes, indexBuilderListener)
+
       return indexBuilderListener.buildIndex()
     }
 
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
new file mode 100644
index 000000000..d34881918
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -0,0 +1,73 @@
+package shark.internal
+
+/**
+ * A read only map of `id` => `byte array` sorted by id, where `id` is a long if [longIdentifiers]
+ * is true and an int otherwise. Each entry has a value byte array of size [bytesPerValue].
+ *
+ * Instances are created by [UnsortedByteEntries]
+ *
+ * [get] and [contains] perform a binary search to locate a specific entry by key.
+ */
+internal class SortedBytesMap(
+  private val longIdentifiers: Boolean,
+  private val bytesPerValue: Int,
+  private val sortedEntries: ByteArray
+) {
+  private val bytesPerKey = if (longIdentifiers) 8 else 4
+  private val bytesPerEntry = bytesPerKey + bytesPerValue
+
+  private val size = sortedEntries.size / bytesPerEntry
+
+  operator fun get(key: Long): ByteSubArray? {
+    val keyIndex = binarySearch(key)
+    if (keyIndex < 0) {
+      return null
+    }
+    val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+    return ByteSubArray(
+        sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
+    )
+  }
+
+  operator fun contains(key: Long): Boolean {
+    val keyIndex = binarySearch(key)
+    return keyIndex >= 0
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, ByteSubArray>> {
+    return (0 until size).asSequence()
+        .map { keyIndex ->
+          val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+          keyAt(keyIndex) to ByteSubArray(
+              sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
+          )
+        }
+  }
+
+  private fun binarySearch(
+    key: Long
+  ): Int {
+    val startIndex = 0
+    val endIndex = size
+    var lo = startIndex
+    var hi = endIndex - 1
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = keyAt(mid)
+      when {
+        midVal < key -> lo = mid + 1
+        midVal > key -> hi = mid - 1
+        else -> return mid
+      }
+    }
+    return lo.inv()
+  }
+
+  private fun keyAt(index: Int): Long {
+    val keyIndex = index * bytesPerEntry
+    return if (longIdentifiers)
+      sortedEntries.readLong(keyIndex)
+    else
+      sortedEntries.readInt(keyIndex).toLong()
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
new file mode 100644
index 000000000..698ca66a7
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
@@ -0,0 +1,192 @@
+package shark.internal
+
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+
+/**
+ * Wraps a byte array of entries where each entry is an id followed by bytes for the value.
+ * `id` is a long if [longIdentifiers] is true and an int otherwise. Each entry has [bytesPerValue]
+ * value bytes. Entries are appended into the array via [append]. Once done, the backing array
+ * is sorted and turned into a [SortedBytesMap] by calling [moveToSortedMap].
+ */
+internal class UnsortedByteEntries(
+  private val bytesPerValue: Int,
+  private val longIdentifiers: Boolean,
+  private val initialCapacity: Int = 4,
+  private val growthFactor: Double = 2.0
+) {
+
+  private val bytesPerEntry = bytesPerValue + if (longIdentifiers) 8 else 4
+
+  private var entries: ByteArray? = null
+  private val subArray = MutableByteSubArray()
+  private var subArrayIndex = 0
+
+  private var assigned: Int = 0
+  private var currentCapacity = 0
+
+  fun append(
+    key: Long
+  ): MutableByteSubArray {
+    if (entries == null) {
+      currentCapacity = initialCapacity
+      entries = ByteArray(currentCapacity * bytesPerEntry)
+    } else {
+      if (currentCapacity == assigned) {
+        val newCapacity = (currentCapacity * growthFactor).toInt()
+        growEntries(newCapacity)
+        currentCapacity = newCapacity
+      }
+    }
+    assigned++
+    subArrayIndex = 0
+    subArray.writeId(key)
+    return subArray
+  }
+
+  fun moveToSortedMap(): SortedBytesMap {
+    if (assigned == 0) {
+      return SortedBytesMap(longIdentifiers, bytesPerValue, ByteArray(0))
+    }
+    val entries = entries!!
+    // Sort entries by keys, which are ids of 4 or 8 bytes.
+    ByteArrayTimSort.sort(entries, 0, assigned, bytesPerEntry, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return if (longIdentifiers) {
+          readLong(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readLong(o2Array, o2Index * entrySize)
+              )
+        } else {
+          readInt(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readInt(o2Array, o2Index * entrySize)
+              )
+        }
+      }
+    })
+    val sortedEntries = if (entries.size > assigned * bytesPerEntry) {
+      entries.copyOf(assigned * bytesPerEntry)
+    } else entries
+    this.entries = null
+    assigned = 0
+    return SortedBytesMap(
+        longIdentifiers, bytesPerValue, sortedEntries
+    )
+  }
+
+  private fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+  private fun readLong(
+    array: ByteArray,
+    index: Int
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xffL shl 56
+        or (array[pos++] and 0xffL shl 48)
+        or (array[pos++] and 0xffL shl 40)
+        or (array[pos++] and 0xffL shl 32)
+        or (array[pos++] and 0xffL shl 24)
+        or (array[pos++] and 0xffL shl 16)
+        or (array[pos++] and 0xffL shl 8)
+        or (array[pos] and 0xffL))
+  }
+
+  private fun growEntries(newCapacity: Int) {
+    val newEntries = ByteArray(newCapacity * bytesPerEntry)
+    System.arraycopy(entries, 0, newEntries, 0, assigned * bytesPerEntry)
+    entries = newEntries
+  }
+
+  internal inner class MutableByteSubArray {
+    fun writeByte(value: Byte) {
+      val index = subArrayIndex
+      subArrayIndex++
+      require(index in 0..bytesPerEntry) {
+        "Index $index should be between 0 and $bytesPerEntry"
+      }
+      val valuesIndex = ((assigned - 1) * bytesPerEntry) + index
+      entries!![valuesIndex] = value
+    }
+
+    fun writeId(value: Long) {
+      if (longIdentifiers) {
+        writeLong(value)
+      } else {
+        writeInt(value.toInt())
+      }
+    }
+
+    fun writeInt(value: Int) {
+      val index = subArrayIndex
+      subArrayIndex += 4
+      require(index >= 0 && index <= bytesPerEntry - 4) {
+        "Index $index should be between 0 and ${bytesPerEntry - 4}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 24 and 0xff).toByte()
+      values[pos++] = (value ushr 16 and 0xff).toByte()
+      values[pos++] = (value ushr 8 and 0xff).toByte()
+      values[pos] = (value and 0xff).toByte()
+    }
+
+    fun writeTruncatedLong(
+      value: Long,
+      byteCount: Int
+    ) {
+      val index = subArrayIndex
+      subArrayIndex += byteCount
+      require(index >= 0 && index <= bytesPerEntry - byteCount) {
+        "Index $index should be between 0 and ${bytesPerEntry - byteCount}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+        values[pos++] = (value ushr shift and 0xffL).toByte()
+      }
+      values[pos] = (value and 0xffL).toByte()
+    }
+
+    fun writeLong(value: Long) {
+      val index = subArrayIndex
+      subArrayIndex += 8
+      require(index >= 0 && index <= bytesPerEntry - 8) {
+        "Index $index should be between 0 and ${bytesPerEntry - 8}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 56 and 0xffL).toByte()
+      values[pos++] = (value ushr 48 and 0xffL).toByte()
+      values[pos++] = (value ushr 40 and 0xffL).toByte()
+      values[pos++] = (value ushr 32 and 0xffL).toByte()
+      values[pos++] = (value ushr 24 and 0xffL).toByte()
+      values[pos++] = (value ushr 16 and 0xffL).toByte()
+      values[pos++] = (value ushr 8 and 0xffL).toByte()
+      values[pos] = (value and 0xffL).toByte()
+    }
+  }
+
+}
+
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
new file mode 100644
index 000000000..b77672d47
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
@@ -0,0 +1,15 @@
+package shark.internal.aosp
+
+internal interface ByteArrayComparator {
+
+  /**
+   * Indexes are divided by entrySize
+   */
+  fun compare(
+    entrySize: Int,
+    o1Array: ByteArray,
+    o1Index: Int,
+    o2Array: ByteArray,
+    o2Index: Int
+  ): Int
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
new file mode 100644
index 000000000..21f3237f4
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
@@ -0,0 +1,1072 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark.internal.aosp
+
+/*
+This is TimSort.java from AOSP (Jelly Bean MR2, Apache 2 license), converted to Kotlin and adapted
+to work with byte array chunks. The passed in byte array is virtually divided into entries of a
+fixed number of bytes N. Each entry is compared by a custom comparator.
+
+ Copied from https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/util/TimSort.java
+*/
+
+/**
+ * A stable, adaptive, iterative mergesort that requires far fewer than
+ * n lg(n) comparisons when running on partially sorted arrays, while
+ * offering performance comparable to a traditional mergesort when run
+ * on random arrays.  Like all proper mergesorts, this sort is stable and
+ * runs O(n log n) time (worst case).  In the worst case, this sort requires
+ * temporary storage space for n/2 object references; in the best case,
+ * it requires only a small constant amount of space.
+ *
+ * This implementation was adapted from Tim Peters's list sort for
+ * Python, which is described in detail here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listsort.txt
+ *
+ * Tim's C code may be found here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listobject.c
+ *
+ * The underlying techniques are described in this paper (and may have
+ * even earlier origins):
+ *
+ * "Optimistic Sorting and Information Theoretic Complexity"
+ * Peter McIlroy
+ * SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
+ * pp 467-474, Austin, Texas, 25-27 January 1993.
+ *
+ * While the API to this class consists solely of static methods, it is
+ * (privately) instantiable; a TimSort instance holds the state of an ongoing
+ * sort, assuming the input array is large enough to warrant the full-blown
+ * TimSort. Small arrays are sorted in place, using a binary insertion sort.
+ */
+internal class ByteArrayTimSort
+/**
+ * Creates a TimSort instance to maintain the state of an ongoing sort.
+ *
+ * @param a the array to be sorted
+ * @param c the comparator to determine the order of the sort
+ */
+private constructor(
+  /**
+   * The array being sorted.
+   */
+  private val a: ByteArray,
+  /**
+   * The comparator for this sort.
+   */
+  private val c: ByteArrayComparator,
+
+  private val entrySize: Int
+) {
+  /**
+   * This controls when we get *into* galloping mode.  It is initialized
+   * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
+   * random data, and lower for highly structured data.
+   */
+  private var minGallop = MIN_GALLOP
+  /**
+   * Temp storage for merges.
+   */
+  private var tmp: ByteArray? = null // Actual runtime type will be Object[], regardless of T
+  /**
+   * A stack of pending runs yet to be merged.  Run i starts at
+   * address base[i] and extends for len[i] elements.  It's always
+   * true (so long as the indices are in bounds) that:
+   *
+   * runBase[i] + runLen[i] == runBase[i + 1]
+   *
+   * so we could cut the storage for this, but it's a minor amount,
+   * and keeping all the info explicit simplifies the code.
+   */
+  private var stackSize = 0  // Number of pending runs on stack
+  private val runBase: IntArray
+  private val runLen: IntArray
+
+  init {
+    // Allocate temp storage (which may be increased later if necessary)
+    val len = a.size / entrySize
+    val newArray = ByteArray(
+        entrySize *
+            if (len < 2 * INITIAL_TMP_STORAGE_LENGTH)
+              len.ushr(1)
+            else
+              INITIAL_TMP_STORAGE_LENGTH
+    )
+    tmp = newArray
+    /*
+         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
+         * stack length requirements are described in listsort.txt.  The C
+         * version always uses the same stack length (85), but this was
+         * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
+         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
+         * large) stack lengths for smaller arrays.  The "magic numbers" in the
+         * computation below must be changed if MIN_MERGE is decreased.  See
+         * the MIN_MERGE declaration above for more information.
+         */
+    val stackLen = if (len < 120)
+      5
+    else if (len < 1542)
+      10
+    else if (len < 119151) 19 else 40
+    runBase = IntArray(stackLen)
+    runLen = IntArray(stackLen)
+  }
+
+  /**
+   * Pushes the specified run onto the pending-run stack.
+   *
+   * @param runBase index of the first element in the run
+   * @param runLen  the number of elements in the run
+   */
+  private fun pushRun(
+    runBase: Int,
+    runLen: Int
+  ) {
+    this.runBase[stackSize] = runBase
+    this.runLen[stackSize] = runLen
+    stackSize++
+  }
+
+  /**
+   * Examines the stack of runs waiting to be merged and merges adjacent runs
+   * until the stack invariants are reestablished:
+   *
+   * 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
+   * 2. runLen[i - 2] > runLen[i - 1]
+   *
+   * This method is called each time a new run is pushed onto the stack,
+   * so the invariants are guaranteed to hold for i < stackSize upon
+   * entry to the method.
+   */
+  // Fixed with http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/
+  private fun mergeCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1] || n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1]) {
+        if (runLen[n - 1] < runLen[n + 1])
+          n--
+      } else if (runLen[n] > runLen[n + 1]) {
+        break // Invariant is established
+      }
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges all runs on the stack until only one remains.  This method is
+   * called once, to complete the sort.
+   */
+  private fun mergeForceCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n > 0 && runLen[n - 1] < runLen[n + 1])
+        n--
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges the two runs at stack indices i and i+1.  Run i must be
+   * the penultimate or antepenultimate run on the stack.  In other words,
+   * i must be equal to stackSize-2 or stackSize-3.
+   *
+   * @param i stack index of the first of the two runs to merge
+   */
+  private fun mergeAt(i: Int) {
+    if (DEBUG) assert(stackSize >= 2)
+    if (DEBUG) assert(i >= 0)
+    if (DEBUG) assert(i == stackSize - 2 || i == stackSize - 3)
+    var base1 = runBase[i]
+    var len1 = runLen[i]
+    val base2 = runBase[i + 1]
+    var len2 = runLen[i + 1]
+    if (DEBUG) assert(len1 > 0 && len2 > 0)
+    if (DEBUG) assert(base1 + len1 == base2)
+    /*
+         * Record the length of the combined runs; if i is the 3rd-last
+         * run now, also slide over the last run (which isn't involved
+         * in this merge).  The current run (i+1) goes away in any case.
+         */
+    runLen[i] = len1 + len2
+    if (i == stackSize - 3) {
+      runBase[i + 1] = runBase[i + 2]
+      runLen[i + 1] = runLen[i + 2]
+    }
+    stackSize--
+    /*
+         * Find where the first element of run2 goes in run1. Prior elements
+         * in run1 can be ignored (because they're already in place).
+         */
+    val k = gallopRight(a, base2, a, base1, len1, 0, entrySize, c)
+    if (DEBUG) assert(k >= 0)
+    base1 += k
+    len1 -= k
+    if (len1 == 0)
+      return
+    /*
+         * Find where the last element of run1 goes in run2. Subsequent elements
+         * in run2 can be ignored (because they're already in place).
+         */
+    len2 = gallopLeft(a, base1 + len1 - 1, a, base2, len2, len2 - 1, entrySize, c)
+    if (DEBUG) assert(len2 >= 0)
+    if (len2 == 0)
+      return
+    // Merge remaining runs, using tmp array with min(len1, len2) elements
+    if (len1 <= len2)
+      mergeLo(base1, len1, base2, len2)
+    else
+      mergeHi(base1, len1, base2, len2)
+  }
+
+  /**
+   * Merges two adjacent runs in place, in a stable fashion.  The first
+   * element of the first run must be greater than the first element of the
+   * second run (a[base1] > a[base2]), and the last element of the first run
+   * (a[base1 + len1-1]) must be greater than all elements of the second run.
+   *
+   * For performance, this method should be called only when len1 <= len2;
+   * its twin, mergeHi should be called if len1 >= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeLo(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy first run into temp array
+    val a = this.a // For performance
+    val entrySize = entrySize
+    val tmp = ensureCapacity(len1)
+    System.arraycopy(a, base1 * entrySize, tmp, 0, len1 * entrySize)
+    var cursor1 = 0       // Indexes into tmp array
+    var cursor2 = base2   // Indexes int a
+    var dest = base1      // Indexes int a
+    // Move first element of second run and deal with degenerate cases
+    val destIndex = dest * entrySize
+    val cursor2Index = cursor2 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor2Index + i]
+    }
+    dest++
+    cursor2++
+
+    if (--len2 == 0) {
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+      return
+    }
+    if (len1 == 1) {
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] // Last elt of run 1 to end of merge
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+       * Do the straightforward thing until (if ever) one run starts
+       * winning consistently.
+       */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        if (c.compare(entrySize, a, cursor2, tmp, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor2Index + i]
+          }
+          dest++
+          cursor2++
+          count2++
+          count1 = 0
+          if (--len2 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor1Index + i]
+          }
+          dest++
+          cursor1++
+          count1++
+          count2 = 0
+          if (--len1 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        count1 = gallopRight(a, cursor2, tmp, cursor1, len1, 0, entrySize, c)
+        if (count1 != 0) {
+          System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, count1 * entrySize)
+          dest += count1
+          cursor1 += count1
+          len1 -= count1
+          if (len1 <= 1)
+          // len1 == 1 || len1 == 0
+            break@outer
+        }
+        var destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor2Index + i]
+        }
+        dest++
+        cursor2++
+        if (--len2 == 0)
+          break@outer
+        count2 = gallopLeft(tmp, cursor1, a, cursor2, len2, 0, entrySize, c)
+        if (count2 != 0) {
+          System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, count2 * entrySize)
+          dest += count2
+          cursor2 += count2
+          len2 -= count2
+          if (len2 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor1Index + i]
+        }
+        dest++
+        cursor1++
+        if (--len1 == 1)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len1 == 1) {
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] //  Last elt of run 1 to end of merge
+      }
+    } else if (len1 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len2 == 0)
+      if (DEBUG) assert(len1 > 1)
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+    }
+  }
+
+  /**
+   * Like mergeLo, except that this method should be called only if
+   * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeHi(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy second run into temp array
+    val a = this.a // For performance
+    val tmp = ensureCapacity(len2)
+    val entrySize = entrySize
+    System.arraycopy(a, base2 * entrySize, tmp, 0, len2 * entrySize)
+    var cursor1 = base1 + len1 - 1  // Indexes into a
+    var cursor2 = len2 - 1          // Indexes into tmp array
+    var dest = base2 + len2 - 1     // Indexes into a
+    // Move last element of first run and deal with degenerate cases
+    var destIndex = dest * entrySize
+    val cursor1Index = cursor1 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor1Index + i]
+    }
+    dest--
+    cursor1--
+    if (--len1 == 0) {
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+      return
+    }
+    if (len2 == 1) {
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i]
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+             * Do the straightforward thing until (if ever) one run
+             * appears to win consistently.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        if (c.compare(entrySize, tmp, cursor2, a, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor1Index + i]
+          }
+          dest--
+          cursor1--
+          count1++
+          count2 = 0
+          if (--len1 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor2Index + i]
+          }
+          dest--
+          cursor2--
+          count2++
+          count1 = 0
+          if (--len2 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        count1 = len1 - gallopRight(tmp, cursor2, a, base1, len1, len1 - 1, entrySize, c)
+        if (count1 != 0) {
+          dest -= count1
+          cursor1 -= count1
+          len1 -= count1
+          System.arraycopy(
+              a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, count1 * entrySize
+          )
+          if (len1 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor2Index + i]
+        }
+        dest--
+        cursor2--
+        if (--len2 == 1)
+          break@outer
+        count2 = len2 - gallopLeft(a, cursor1, tmp, 0, len2, len2 - 1, entrySize, c)
+        if (count2 != 0) {
+          dest -= count2
+          cursor2 -= count2
+          len2 -= count2
+          System.arraycopy(
+              tmp, (cursor2 + 1) * entrySize, a, (dest + 1) * entrySize, count2 * entrySize
+          )
+          if (len2 <= 1)
+          // len2 == 1 || len2 == 0
+            break@outer
+        }
+        val destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor1Index + i]
+        }
+        dest--
+        cursor1--
+        if (--len1 == 0)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len2 == 1) {
+      if (DEBUG) assert(len1 > 0)
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i] // Move first elt of run2 to front of merge
+      }
+    } else if (len2 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len1 == 0)
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+    }
+  }
+
+  /**
+   * Ensures that the external array tmp has at least the specified
+   * number of elements, increasing its size if necessary.  The size
+   * increases exponentially to ensure amortized linear time complexity.
+   *
+   * @param minCapacity the minimum required capacity of the tmp array
+   * @return tmp, whether or not it grew
+   */
+  private fun ensureCapacity(minCapacity: Int): ByteArray {
+    if (tmp!!.size < minCapacity * entrySize) {
+      // Compute smallest power of 2 > minCapacity
+      var newSize = minCapacity
+      newSize = newSize or (newSize shr 1)
+      newSize = newSize or (newSize shr 2)
+      newSize = newSize or (newSize shr 4)
+      newSize = newSize or (newSize shr 8)
+      newSize = newSize or (newSize shr 16)
+      newSize++
+      if (newSize < 0)
+      // Not bloody likely!
+        newSize = minCapacity
+      else
+        newSize = Math.min(newSize, (a.size / entrySize).ushr(1))
+      val newArray = ByteArray(newSize * entrySize)
+      tmp = newArray
+    }
+    return tmp!!
+  }
+
+  companion object {
+    /**
+     * This is the minimum sized sequence that will be merged.  Shorter
+     * sequences will be lengthened by calling binarySort.  If the entire
+     * array is less than this length, no merges will be performed.
+     *
+     * This constant should be a power of two.  It was 64 in Tim Peter's C
+     * implementation, but 32 was empirically determined to work better in
+     * this implementation.  In the unlikely event that you set this constant
+     * to be a number that's not a power of two, you'll need to change the
+     * [.minRunLength] computation.
+     *
+     * If you decrease this constant, you must change the stackLen
+     * computation in the TimSort constructor, or you risk an
+     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
+     * of the minimum stack length required as a function of the length
+     * of the array being sorted and the minimum merge sequence length.
+     */
+    private val MIN_MERGE = 32
+    /**
+     * When we get into galloping mode, we stay there until both runs win less
+     * often than MIN_GALLOP consecutive times.
+     */
+    private val MIN_GALLOP = 7
+    /**
+     * Maximum initial size of tmp array, which is used for merging.  The array
+     * can grow to accommodate demand.
+     *
+     * Unlike Tim's original C version, we do not allocate this much storage
+     * when sorting smaller arrays.  This change was required for performance.
+     */
+    private val INITIAL_TMP_STORAGE_LENGTH = 256
+    /**
+     * Asserts have been placed in if-statements for performace. To enable them,
+     * set this field to true and enable them in VM with a command line flag.
+     * If you modify this class, please do test the asserts!
+     */
+    private val DEBUG = false
+
+    /*
+     * The next two methods (which are package private and static) constitute
+     * the entire API of this class.  Each of these methods obeys the contract
+     * of the public method with the same signature in java.util.Arrays.
+     */
+    fun sort(
+      a: ByteArray,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      sort(a, 0, a.size / entrySize, entrySize, c)
+    }
+
+    fun sort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var lo = lo
+      checkStartAndEnd(a.size / entrySize, lo, hi)
+      var nRemaining = hi - lo
+      if (nRemaining < 2)
+        return   // Arrays of size 0 and 1 are always sorted
+      // If array is small, do a "mini-TimSort" with no merges
+      if (nRemaining < MIN_MERGE) {
+        val initRunLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        binarySort(a, lo, hi, lo + initRunLen, entrySize, c)
+        return
+      }
+      /**
+       * March over the array once, left to right, finding natural runs,
+       * extending short natural runs to minRun elements, and merging runs
+       * to maintain stack invariant.
+       */
+      val ts = ByteArrayTimSort(a, c, entrySize)
+      val minRun = minRunLength(nRemaining)
+      do {
+        // Identify next run
+        var runLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        // If run is short, extend to min(minRun, nRemaining)
+        if (runLen < minRun) {
+          val force = if (nRemaining <= minRun) nRemaining else minRun
+          binarySort(a, lo, lo + force, lo + runLen, entrySize, c)
+          runLen = force
+        }
+        // Push run onto pending-run stack, and maybe merge
+        ts.pushRun(lo, runLen)
+        ts.mergeCollapse()
+        // Advance to find next run
+        lo += runLen
+        nRemaining -= runLen
+      } while (nRemaining != 0)
+      // Merge all remaining runs to complete sort
+      if (DEBUG) assert(lo == hi)
+      ts.mergeForceCollapse()
+      if (DEBUG) assert(ts.stackSize == 1)
+    }
+
+    private fun checkStartAndEnd(
+      len: Int,
+      start: Int,
+      end: Int
+    ) {
+      if (start < 0 || end > len) {
+        throw ArrayIndexOutOfBoundsException(
+            "start < 0 || end > len."
+                + " start=" + start + ", end=" + end + ", len=" + len
+        )
+      }
+      if (start > end) {
+        throw IllegalArgumentException("start > end: $start > $end")
+      }
+    }
+
+    /**
+     * Sorts the specified portion of the specified array using a binary
+     * insertion sort.  This is the best method for sorting small numbers
+     * of elements.  It requires O(n log n) compares, but O(n^2) data
+     * movement (worst case).
+     *
+     * If the initial part of the specified range is already sorted,
+     * this method can take advantage of it: the method assumes that the
+     * elements from index `lo`, inclusive, to `start`,
+     * exclusive are already sorted.
+     *
+     * @param a the array in which a range is to be sorted
+     * @param lo the index of the first element in the range to be sorted
+     * @param hi the index after the last element in the range to be sorted
+     * @param start the index of the first element in the range that is
+     * not already known to be sorted (@code lo <= start <= hi}
+     * @param c comparator to used for the sort
+     */
+    private fun binarySort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      start: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var start = start
+      if (DEBUG) assert(lo <= start && start <= hi)
+      if (start == lo)
+        start++
+      val pivot = ByteArray(entrySize)
+      while (start < hi) {
+        val startIndex = start * entrySize
+        for (i in 0 until entrySize) {
+          pivot[i] = a[startIndex + i]
+        }
+        // Set left (and right) to the index where a[start] (pivot) belongs
+        var left = lo
+        var right = start
+        if (DEBUG) assert(left <= right)
+        /*
+             * Invariants:
+             *   pivot >= all in [lo, left).
+             *   pivot <  all in [right, start).
+             */
+        while (left < right) {
+          val mid = (left + right).ushr(1)
+          if (c.compare(entrySize, pivot, 0, a, mid) < 0)
+            right = mid
+          else
+            left = mid + 1
+        }
+        if (DEBUG) assert(left == right)
+        /*
+             * The invariants still hold: pivot >= all in [lo, left) and
+             * pivot < all in [left, start), so pivot belongs at left.  Note
+             * that if there are elements equal to pivot, left points to the
+             * first slot after them -- that's why this sort is stable.
+             * Slide elements over to make room for pivot.
+             */
+        val n = start - left  // The number of elements to move
+        // Switch is just an optimization for arraycopy in default case
+        when (n) {
+          2 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            val leftPlusTwoIndex = (left + 2) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusTwoIndex + i] = a[leftPlusOneIndex + i]
+            }
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          1 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          else -> {
+            System.arraycopy(a, left * entrySize, a, (left + 1) * entrySize, n * entrySize)
+          }
+        }
+        val leftIndex = left * entrySize
+        for (i in 0 until entrySize) {
+          a[leftIndex + i] = pivot[i]
+        }
+        start++
+      }
+    }
+
+    /**
+     * Returns the length of the run beginning at the specified position in
+     * the specified array and reverses the run if it is descending (ensuring
+     * that the run will always be ascending when the method returns).
+     *
+     * A run is the longest ascending sequence with:
+     *
+     * a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
+     *
+     * or the longest descending sequence with:
+     *
+     * a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
+     *
+     * For its intended use in a stable mergesort, the strictness of the
+     * definition of "descending" is needed so that the call can safely
+     * reverse a descending sequence without violating stability.
+     *
+     * @param a the array in which a run is to be counted and possibly reversed
+     * @param lo index of the first element in the run
+     * @param hi index after the last element that may be contained in the run.
+     * It is required that @code{lo < hi}.
+     * @param c the comparator to used for the sort
+     * @return  the length of the run beginning at the specified position in
+     * the specified array
+     */
+    private fun countRunAndMakeAscending(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(lo < hi)
+      var runHi = lo + 1
+      if (runHi == hi)
+        return 1
+      // Find end of run, and reverse range if descending
+
+      val comparison = c.compare(entrySize, a, runHi, a, lo)
+      runHi++
+      if (comparison < 0) { // Descending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) < 0)
+          runHi++
+        reverseRange(a, lo, runHi, entrySize)
+      } else {                              // Ascending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) >= 0)
+          runHi++
+      }
+      return runHi - lo
+    }
+
+    /**
+     * Reverse the specified range of the specified array.
+     *
+     * @param a the array in which a range is to be reversed
+     * @param lo the index of the first element in the range to be reversed
+     * @param hi the index after the last element in the range to be reversed
+     */
+    private fun reverseRange(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int
+    ) {
+      var lo = lo
+      var hi = hi
+      hi--
+      while (lo < hi) {
+        val loIndex = lo * entrySize
+        val hiIndex = hi * entrySize
+        for (i in 0 until entrySize) {
+          val t = a[loIndex + i]
+          a[loIndex + i] = a[hiIndex + i]
+          a[hiIndex + i] = t
+        }
+        lo++
+        hi--
+      }
+    }
+
+    /**
+     * Returns the minimum acceptable run length for an array of the specified
+     * length. Natural runs shorter than this will be extended with
+     * [.binarySort].
+     *
+     * Roughly speaking, the computation is:
+     *
+     * If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
+     * Else if n is an exact power of 2, return MIN_MERGE/2.
+     * Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
+     * is close to, but strictly less than, an exact power of 2.
+     *
+     * For the rationale, see listsort.txt.
+     *
+     * @param n the length of the array to be sorted
+     * @return the length of the minimum run to be merged
+     */
+    private fun minRunLength(n: Int): Int {
+      var n = n
+      if (DEBUG) assert(n >= 0)
+      var r = 0      // Becomes 1 if any 1 bits are shifted off
+      while (n >= MIN_MERGE) {
+        r = r or (n and 1)
+        n = n shr 1
+      }
+      return n + r
+    }
+
+    /**
+     * Locates the position at which to insert the specified key into the
+     * specified sorted range; if the range contains an element equal to key,
+     * returns the index of the leftmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
+     * pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
+     * In other words, key belongs at index b + k; or in other words,
+     * the first k elements of a should precede key, and the last n - k
+     * should follow it.
+     */
+    private fun gallopLeft(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var lastOfs = 0
+      var ofs = 1
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) > 0) {
+        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint + ofs) > 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        lastOfs += hint
+        ofs += hint
+      } else { // key <= a[base + hint]
+        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint - ofs
+            ) <= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
+         * to the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) > 0)
+          lastOfs = m + 1  // a[base + m] < key
+        else
+          ofs = m          // key <= a[base + m]
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[base + ofs - 1] < key <= a[base + ofs]
+      return ofs
+    }
+
+    /**
+     * Like gallopLeft, except that if the range contains an element equal to
+     * key, gallopRight returns the index after the rightmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
+     */
+    private fun gallopRight(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var ofs = 1
+      var lastOfs = 0
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) < 0) {
+        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint - ofs) < 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      } else { // a[b + hint] <= key
+        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint + ofs
+            ) >= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        lastOfs += hint
+        ofs += hint
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
+         * the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) < 0)
+          ofs = m          // key < a[b + m]
+        else
+          lastOfs = m + 1  // a[b + m] <= key
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[b + ofs - 1] <= key < a[b + ofs]
+      return ofs
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
new file mode 100644
index 000000000..292f41e06
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
@@ -0,0 +1,110 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+import java.lang.IllegalStateException
+import kotlin.random.Random
+
+class ByteArrayTimSortTest {
+
+  @Test fun smallArray1BytePerEntry() {
+    val toSort = byteArrayOf(2, 1, 4)
+
+    ByteArrayTimSort.sort(toSort, 0, 3, 1, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return o1Array[o1Index].compareTo(o2Array[o2Index])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 2, 4)
+  }
+
+  @Test fun smallArray3BytesPerEntry1ByteKey() {
+    val toSort = byteArrayOf(2, 3, 3, 1, 5, 5, 4, 6, 6)
+
+    ByteArrayTimSort.sort(toSort, 3, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        // Sort based on first byte
+        return o1Array[o1Index * entrySize].compareTo(o2Array[o2Index * entrySize])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 5, 5, 2, 3, 3, 4, 6, 6)
+  }
+
+  @Test fun largeRandomArray8BytesPerEntry4BytesKey() {
+    val entryCount = 10000
+    val entrySize = 8
+    val random = Random(Int.MIN_VALUE)
+    val librarySorted = random.nextBytes(entryCount * entrySize)
+
+    class Entry(val eightBytes: ByteArray) : Comparable<Entry> {
+      override fun compareTo(other: Entry): Int {
+        val compared = readInt(eightBytes, 0).compareTo(readInt(other.eightBytes, 0))
+        if (compared == 0){
+          return readInt(eightBytes, 4).compareTo(readInt(other.eightBytes, 4))
+        }
+        return compared
+      }
+    }
+
+    val androidSorted = arrayOfNulls<Entry>(entryCount)
+    for (i in 0 until entryCount) {
+      val index = i * entrySize
+      androidSorted[i] = Entry(librarySorted.copyOfRange(index, index + entrySize))
+    }
+    androidSorted.sort()
+    val androidSortedAsBytes = ByteArray(entryCount * entrySize)
+
+    for (i in 0 until entryCount) {
+        System.arraycopy(
+            androidSorted[i]!!.eightBytes, 0, androidSortedAsBytes, i * entrySize, entrySize
+        )
+    }
+
+    ByteArrayTimSort.sort(librarySorted, entrySize, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        val compared = readInt(o1Array, o1Index * entrySize).compareTo(readInt(o2Array, o2Index * entrySize))
+        if (compared == 0) {
+          return readInt(o1Array, o1Index * entrySize + 4).compareTo(readInt(o2Array, o2Index * entrySize + 4))
+        }
+        return compared
+      }
+    })
+
+    assertThat(librarySorted.asList()).isEqualTo(androidSortedAsBytes.asList())
+  }
+
+  fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/SortedBytesMapTest.kt b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
new file mode 100644
index 000000000..a089564a2
--- /dev/null
+++ b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
@@ -0,0 +1,204 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.UnsortedByteEntries
+import java.util.Arrays
+import kotlin.random.Random
+
+class SortedBytesMapTest {
+
+  @Test fun writeAndReadLongValue() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 8, longIdentifiers = false)
+    unsortedEntries.append(1)
+        .apply {
+          writeLong(Long.MIN_VALUE)
+        }
+
+    val array = unsortedEntries.moveToSortedMap()[1]!!
+    assertThat(array.readLong()).isEqualTo(Long.MIN_VALUE)
+  }
+
+  @Test fun writeAndReadTruncatedLongValue() {
+    val maxUnsigned3Bytes = 0x00000FFFL
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = false)
+    unsortedMap.append(1)
+        .apply {
+          writeTruncatedLong(maxUnsigned3Bytes, 3)
+        }
+
+    val array = unsortedMap.moveToSortedMap()[1]!!
+    assertThat(array.readTruncatedLong(3)).isEqualTo(maxUnsigned3Bytes)
+  }
+
+  @Test fun fourEntriesWithLongKey1ByteValueSorted() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 1, longIdentifiers = true)
+    unsortedEntries.append(42)
+        .apply {
+          writeByte(4)
+        }
+    unsortedEntries.append(0)
+        .apply {
+          writeByte(3)
+        }
+    unsortedEntries.append(3)
+        .apply {
+          writeByte(20)
+        }
+    unsortedEntries.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+        }
+    val sortedEntries = unsortedEntries.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3), byteArrayOf(20), byteArrayOf(4),
+        byteArrayOf(127)
+    )
+  }
+
+  @Test fun fourEntriesWithLongKey3ByteValueSorted() {
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = true)
+    unsortedMap.append(42)
+        .apply {
+          writeByte(4)
+          writeByte(2)
+          writeByte(0)
+        }
+    unsortedMap.append(0)
+        .apply {
+          writeByte(3)
+          writeByte(2)
+          writeByte(1)
+        }
+    unsortedMap.append(3)
+        .apply {
+          writeByte(20)
+          writeByte(52)
+          writeByte(-17)
+        }
+    unsortedMap.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+          writeByte(0)
+          writeByte(-128)
+        }
+    val sortedEntries = unsortedMap.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte(), it.second.readByte(), it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3, 2, 1), byteArrayOf(20, 52, -17), byteArrayOf(4, 2, 0),
+        byteArrayOf(127, 0, -128)
+    )
+  }
+
+  class Entry(
+    val key: Long,
+    val value: ByteArray
+  ) : Comparable<Entry> {
+    override fun compareTo(other: Entry): Int = key.compareTo(other.key)
+    override fun equals(other: Any?): Boolean {
+      if (this === other) return true
+      if (javaClass != other?.javaClass) return false
+
+      other as Entry
+
+      if (key != other.key) return false
+      if (!value.contentEquals(other.value)) return false
+
+      return true
+    }
+
+    override fun toString(): String {
+      return "Entry(key=$key, value=${Arrays.toString(value)})"
+    }
+
+  }
+
+  @Test fun largeRandomArrayIntKey3ByteValueSorted() {
+    val random = Random(Long.MAX_VALUE)
+
+    val bytesPerValue = 3
+    val longIdentifiers = false
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextInt().toLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey3ByteValueSorted() {
+    val random = Random(42)
+
+    val bytesPerValue = 3
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey7ByteValueSorted() {
+    val random = Random(Long.MIN_VALUE)
+
+    val bytesPerValue = 7
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  private fun sortAndCompare(
+    bytesPerValue: Int,
+    longIdentifiers: Boolean,
+    sourceEntryArray: Array<Entry>
+  ) {
+    val unsortedEntries =
+      UnsortedByteEntries(bytesPerValue = bytesPerValue, longIdentifiers = longIdentifiers)
+
+    sourceEntryArray.forEach { entry ->
+      val subArray = unsortedEntries.append(entry.key)
+      entry.value.forEach { subArray.writeByte(it) }
+    }
+
+    val sortedMap = unsortedEntries.moveToSortedMap()
+    sourceEntryArray.sort()
+
+    val sortedEntryArray = sortedMap.entrySequence()
+        .map {
+          val key = it.first
+          val value = it.second
+
+          val bytes = mutableListOf<Byte>()
+          for (i in 0 until bytesPerValue) {
+            bytes += value.readByte()
+          }
+          Entry(key, bytes.toByteArray())
+        }
+        .toList()
+        .toTypedArray()
+
+    assertThat(sortedEntryArray).isEqualTo(sourceEntryArray)
+  }
+}
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
index 84a7e4b38..ecfc79521 100644
--- a/shark-hprof/src/main/java/shark/Hprof.kt
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -3,6 +3,7 @@ package shark
 import okio.BufferedSource
 import okio.buffer
 import okio.source
+import shark.Hprof.Companion.open
 import java.io.Closeable
 import java.io.File
 import java.nio.channels.FileChannel
@@ -18,30 +19,30 @@ class Hprof private constructor(
   /** Unix timestamp at which the heap was dumped. */
   val heapDumpTimestamp: Long,
   /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
-  val hprofVersion: HprofVersion
+  val hprofVersion: HprofVersion,
+  /**
+   * Length of the hprof file, in bytes.
+   */
+  val fileLength: Long
 ) : Closeable {
 
-  private var lastReaderByteReadCount = reader.byteReadCount
-  private var lastKnownPosition = reader.byteReadCount
-
   override fun close() {
     source.close()
   }
 
   /**
    * Moves [reader] to a new position in the hprof file. This is transparent to the reader, and
-   * will not reset [HprofReader.byteReadCount].
+   * will not reset [HprofReader.position].
    */
   fun moveReaderTo(newPosition: Long) {
-    val currentPosition = lastKnownPosition + (reader.byteReadCount - lastReaderByteReadCount)
+    val currentPosition = reader.position
 
     if (currentPosition == newPosition) {
       return
     }
     source.buffer.clear()
     channel.position(newPosition)
-    lastReaderByteReadCount = reader.byteReadCount
-    lastKnownPosition = newPosition
+    reader.position = newPosition
   }
 
   /**
@@ -56,14 +57,16 @@ class Hprof private constructor(
 
   companion object {
     private val supportedVersions = HprofVersion.values()
-        .map { it.versionString to it }.toMap()
+        .map { it.versionString to it }
+        .toMap()
 
     /**
      * Reads the headers of the provided [hprofFile] and returns an opened [Hprof]. Don't forget
      * to call [close] once done.
      */
     fun open(hprofFile: File): Hprof {
-      if (hprofFile.length() == 0L) {
+      val fileLength = hprofFile.length()
+      if (fileLength == 0L) {
         throw IllegalArgumentException("Hprof file is 0 byte length")
       }
       val inputStream = hprofFile.inputStream()
@@ -91,7 +94,7 @@ class Hprof private constructor(
       val reader = HprofReader(source, identifierByteSize, byteReadCount)
 
       return Hprof(
-          channel, source, reader, heapDumpTimestamp, hprofVersion
+          channel, source, reader, heapDumpTimestamp, hprofVersion, fileLength
       )
     }
   }
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
index b67be040a..e3742ef4c 100644
--- a/shark-hprof/src/main/java/shark/HprofReader.kt
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -25,8 +25,11 @@ import shark.HprofRecord.HeapDumpRecord.ObjectRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
@@ -36,6 +39,7 @@ import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
 import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StackFrameRecord
 import shark.HprofRecord.StackTraceRecord
@@ -81,31 +85,28 @@ class HprofReader constructor(
   /**
    * How many bytes have already been read from [source] when this [HprofReader] is created.
    */
-  val startByteReadCount: Long = 0L
+  val startPosition: Long = 0L
 ) {
 
   /**
-   * Starts at [startByteReadCount] and increases as [HprofReader] reads bytes. This is useful
+   * Starts at [startPosition] and increases as [HprofReader] reads bytes. This is useful
    * for tracking the position of content in the backing [source]. This never resets.
    */
-  var byteReadCount = startByteReadCount
-    private set
+  var position = startPosition
+    internal set
 
   private val typeSizes =
     PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to identifierByteSize)
 
   /**
    * Reads all hprof records from [source].
-   * Assumes the [reader] was just created, with a source that currently points to the start
-   * position of hprof records.
+   * Assumes the [reader] was has a source that currently points to the start position of hprof
+   * records.
    */
   fun readHprofRecords(
     recordTypes: Set<KClass<out HprofRecord>>,
     listener: OnHprofRecordListener
   ) {
-    require(byteReadCount == startByteReadCount) {
-      "readHprofRecords() should only be called on a unused HprofReader instance"
-    }
     val readAllRecords = HprofRecord::class in recordTypes
     val readStringRecord = readAllRecords || StringRecord::class in recordTypes
     val readLoadClassRecord = readAllRecords || LoadClassRecord::class in recordTypes
@@ -121,11 +122,15 @@ class HprofReader constructor(
     val readAllObjectRecords = readAllHeapDumpRecords || ObjectRecord::class in recordTypes
 
     val readClassDumpRecord = readAllObjectRecords || ClassDumpRecord::class in recordTypes
+    val readClassSkipContentRecord = ClassSkipContentRecord::class in recordTypes
     val readInstanceDumpRecord = readAllObjectRecords || InstanceDumpRecord::class in recordTypes
+    val readInstanceSkipContentRecord = InstanceSkipContentRecord::class in recordTypes
     val readObjectArrayDumpRecord =
       readAllObjectRecords || ObjectArrayDumpRecord::class in recordTypes
+    val readObjectArraySkipContentRecord = ObjectArraySkipContentRecord::class in recordTypes
     val readPrimitiveArrayDumpRecord =
       readAllObjectRecords || PrimitiveArrayDumpRecord::class in recordTypes
+    val readPrimitiveArraySkipContentRecord = PrimitiveArraySkipContentRecord::class in recordTypes
 
     val intByteSize = INT.byteSize
 
@@ -142,7 +147,7 @@ class HprofReader constructor(
       when (tag) {
         STRING_IN_UTF8 -> {
           if (readStringRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val id = readId()
             val stringLength = length - identifierByteSize
             val string = readUtf8(stringLength)
@@ -154,7 +159,7 @@ class HprofReader constructor(
         }
         LOAD_CLASS -> {
           if (readLoadClassRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val classSerialNumber = readInt()
             val id = readId()
             val stackTraceSerialNumber = readInt()
@@ -172,7 +177,7 @@ class HprofReader constructor(
         }
         STACK_FRAME -> {
           if (readStackFrameRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val record = StackFrameRecord(
                 id = readId(),
                 methodNameStringId = readId(),
@@ -188,7 +193,7 @@ class HprofReader constructor(
         }
         STACK_TRACE -> {
           if (readStackTraceRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val stackTraceSerialNumber = readInt()
             val threadSerialNumber = readInt()
             val frameCount = readInt()
@@ -204,15 +209,15 @@ class HprofReader constructor(
           }
         }
         HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
-          val heapDumpStart = byteReadCount
+          val heapDumpStart = position
           var previousTag = 0
-          while (byteReadCount - heapDumpStart < length) {
+          while (position - heapDumpStart < length) {
             val heapDumpTag = readUnsignedByte()
 
             when (heapDumpTag) {
               ROOT_UNKNOWN -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val record = GcRootRecord(gcRoot = Unknown(id = readId()))
                   listener.onHprofRecord(recordPosition, record)
                 } else {
@@ -221,7 +226,7 @@ class HprofReader constructor(
               }
               ROOT_JNI_GLOBAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord =
                     GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
                   listener.onHprofRecord(recordPosition, gcRootRecord)
@@ -232,7 +237,7 @@ class HprofReader constructor(
 
               ROOT_JNI_LOCAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JniLocal(
                           id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
@@ -246,7 +251,7 @@ class HprofReader constructor(
 
               ROOT_JAVA_FRAME -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JavaFrame(
                           id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
@@ -260,7 +265,7 @@ class HprofReader constructor(
 
               ROOT_NATIVE_STACK -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
                   )
@@ -272,7 +277,7 @@ class HprofReader constructor(
 
               ROOT_STICKY_CLASS -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = StickyClass(id = readId())
                   )
@@ -285,7 +290,7 @@ class HprofReader constructor(
               // An object that was referenced from an active thread block.
               ROOT_THREAD_BLOCK -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
                   )
@@ -297,7 +302,7 @@ class HprofReader constructor(
 
               ROOT_MONITOR_USED -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = MonitorUsed(id = readId())
                   )
@@ -309,7 +314,7 @@ class HprofReader constructor(
 
               ROOT_THREAD_OBJECT -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ThreadObject(
                           id = readId(),
@@ -325,7 +330,7 @@ class HprofReader constructor(
 
               ROOT_INTERNED_STRING -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
                   listener.onHprofRecord(recordPosition, gcRootRecord)
                 } else {
@@ -335,7 +340,7 @@ class HprofReader constructor(
 
               ROOT_FINALIZING -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Finalizing(id = readId())
                   )
@@ -347,7 +352,7 @@ class HprofReader constructor(
 
               ROOT_DEBUGGER -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Debugger(id = readId())
                   )
@@ -359,7 +364,7 @@ class HprofReader constructor(
 
               ROOT_REFERENCE_CLEANUP -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ReferenceCleanup(id = readId())
                   )
@@ -371,7 +376,7 @@ class HprofReader constructor(
 
               ROOT_VM_INTERNAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = VmInternal(id = readId())
                   )
@@ -383,7 +388,7 @@ class HprofReader constructor(
 
               ROOT_JNI_MONITOR -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JniMonitor(
                           id = readId(), stackTraceSerialNumber = readInt(),
@@ -398,7 +403,7 @@ class HprofReader constructor(
 
               ROOT_UNREACHABLE -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Unreachable(id = readId())
                   )
@@ -408,42 +413,65 @@ class HprofReader constructor(
                 }
               }
               CLASS_DUMP -> {
-                if (readClassDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val record = readClassDumpRecord()
-                  listener.onHprofRecord(recordPosition, record)
-                } else {
-                  skipClassDumpRecord()
+                when {
+                  readClassDumpRecord -> {
+                    val recordPosition = position
+                    val record = readClassDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readClassSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readClassSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipClassDumpRecord()
                 }
               }
-
               INSTANCE_DUMP -> {
-                if (readInstanceDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val instanceDumpRecord = readInstanceDumpRecord()
-                  listener.onHprofRecord(recordPosition, instanceDumpRecord)
-                } else {
-                  skipInstanceDumpRecord()
+                when {
+                  readInstanceDumpRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readInstanceSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipInstanceDumpRecord()
                 }
               }
 
               OBJECT_ARRAY_DUMP -> {
-                if (readObjectArrayDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val arrayRecord = readObjectArrayDumpRecord()
-                  listener.onHprofRecord(recordPosition, arrayRecord)
-                } else {
-                  skipObjectArrayDumpRecord()
+                when {
+                  readObjectArrayDumpRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  readObjectArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  else -> skipObjectArrayDumpRecord()
                 }
               }
 
               PRIMITIVE_ARRAY_DUMP -> {
-                if (readPrimitiveArrayDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val record = readPrimitiveArrayDumpRecord()
-                  listener.onHprofRecord(recordPosition, record)
-                } else {
-                  skipPrimitiveArrayDumpRecord()
+                when {
+                  readPrimitiveArrayDumpRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readPrimitiveArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipPrimitiveArrayDumpRecord()
                 }
               }
 
@@ -453,7 +481,7 @@ class HprofReader constructor(
 
               HEAP_DUMP_INFO -> {
                 if (readHeapDumpInfoRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val record = readHeapDumpInfoRecord()
                   listener.onHprofRecord(recordPosition, record)
                 } else {
@@ -469,7 +497,7 @@ class HprofReader constructor(
         }
         HEAP_DUMP_END -> {
           if (readHeapDumpEndRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val record = HeapDumpEndRecord
             listener.onHprofRecord(recordPosition, record)
           }
@@ -498,6 +526,22 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads an instance record after a instance dump tag, skipping its content.
+   */
+  fun readInstanceSkipContentRecord(): InstanceSkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+    return InstanceSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId
+    )
+  }
+
   /**
    * Reads a full class record after a class dump tag.
    */
@@ -565,6 +609,66 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads a class record after a class dump tag, skipping its content.
+   */
+  fun readClassSkipContentRecord(): ClassSkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(
+          if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+            identifierByteSize
+          } else {
+            PrimitiveType.byteSizeByHprofType.getValue(type)
+          }
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    // Each field takes id + byte.
+    skip((identifierByteSize + 1) * fieldCount)
+    return ClassSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superclassId = superclassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFieldCount = staticFieldCount,
+        fieldCount = fieldCount
+    )
+  }
+
   /**
    * Reads a full primitive array record after a primitive array dump tag.
    */
@@ -602,6 +706,19 @@ class HprofReader constructor(
     }
   }
 
+  /**
+   * Reads a primitive array record after a primitive array dump tag, skipping its content.
+   */
+  fun readPrimitiveArraySkipContentRecord(): PrimitiveArraySkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    val type = PrimitiveType.primitiveTypeByHprofType.getValue(readUnsignedByte())
+    skip(arrayLength * type.byteSize)
+    return PrimitiveArraySkipContentRecord(id, stackTraceSerialNumber, arrayLength, type)
+  }
+
   /**
    * Reads a full object array record after a object array dump tag.
    */
@@ -621,6 +738,25 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads an object array record after a object array dump tag, skipping its content.
+   */
+  fun readObjectArraySkipContentRecord(
+  ): ObjectArraySkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    skip(identifierByteSize * arrayLength)
+    return ObjectArraySkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        size = arrayLength
+    )
+  }
+
   /**
    * Reads a value in the heap dump, which can be a reference or a primitive type.
    */
@@ -644,12 +780,12 @@ class HprofReader constructor(
   }
 
   private fun readShort(): Short {
-    byteReadCount += SHORT_SIZE
+    position += SHORT_SIZE
     return source.readShort()
   }
 
   private fun readInt(): Int {
-    byteReadCount += INT_SIZE
+    position += INT_SIZE
     return source.readInt()
   }
 
@@ -669,7 +805,7 @@ class HprofReader constructor(
     byteCount: Int,
     charset: Charset
   ): String {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readString(byteCount.toLong(), charset)
   }
 
@@ -694,29 +830,29 @@ class HprofReader constructor(
   }
 
   private fun readLong(): Long {
-    byteReadCount += LONG_SIZE
+    position += LONG_SIZE
     return source.readLong()
   }
 
   private fun exhausted() = source.exhausted()
 
   private fun skip(byteCount: Long) {
-    byteReadCount += byteCount
+    position += byteCount
     return source.skip(byteCount)
   }
 
   private fun readByte(): Byte {
-    byteReadCount += BYTE_SIZE
+    position += BYTE_SIZE
     return source.readByte()
   }
 
   private fun readBoolean(): Boolean {
-    byteReadCount += BOOLEAN_SIZE
+    position += BOOLEAN_SIZE
     return source.readByte().toInt() != 0
   }
 
   private fun readByteArray(byteCount: Int): ByteArray {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readByteArray(byteCount.toLong())
   }
 
@@ -744,7 +880,7 @@ class HprofReader constructor(
   }
 
   private fun readUtf8(byteCount: Long): String {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readUtf8(byteCount)
   }
 
@@ -761,7 +897,7 @@ class HprofReader constructor(
   }
 
   private fun skip(byteCount: Int) {
-    byteReadCount += byteCount
+    position += byteCount
     return source.skip(byteCount.toLong())
   }
 
diff --git a/shark-hprof/src/main/java/shark/HprofRecord.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
index 5009a3cc1..66cb06569 100644
--- a/shark-hprof/src/main/java/shark/HprofRecord.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -73,6 +73,22 @@ sealed class HprofRecord {
         )
       }
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ClassDumpRecord] for when you don't need the class content.
+       */
+      class ClassSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superclassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFieldCount: Int,
+        val fieldCount: Int
+      ) : ObjectRecord()
+
       class InstanceDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
@@ -83,6 +99,16 @@ sealed class HprofRecord {
         val fieldValues: ByteArray
       ) : ObjectRecord()
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [InstanceDumpRecord] for when you don't need the instance content.
+       */
+      class InstanceSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long
+      ) : ObjectRecord()
+
       class ObjectArrayDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
@@ -91,11 +117,16 @@ sealed class HprofRecord {
       ) : ObjectRecord()
 
       /**
-       * Note: we could move the arrays to the parent class as a ByteString or ByteArray
-       * and then each subtype can create a new array of the right type if needed.
-       * However, experimenting with live parsing has shown that we never to read arrays except
-       * when we want to display leak trace information, in which case we do need the data.
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ObjectArrayDumpRecord] for when you don't need the array content.
        */
+      class ObjectArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val size: Int
+      ) : ObjectRecord()
+
       sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
         abstract val id: Long
         abstract val stackTraceSerialNumber: Int
@@ -173,6 +204,17 @@ sealed class HprofRecord {
             get() = array.size
         }
       }
+
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [PrimitiveArrayDumpRecord] for when you don't need the array content.
+       */
+      class PrimitiveArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val size: Int,
+        val type: PrimitiveType
+      ) : ObjectRecord()
     }
 
     class HeapDumpInfoRecord(
diff --git a/shark-hprof/src/main/java/shark/PrimitiveType.kt b/shark-hprof/src/main/java/shark/PrimitiveType.kt
index 8c39f4973..62794fc0c 100644
--- a/shark-hprof/src/main/java/shark/PrimitiveType.kt
+++ b/shark-hprof/src/main/java/shark/PrimitiveType.kt
@@ -29,5 +29,7 @@ enum class PrimitiveType(
     const val REFERENCE_HPROF_TYPE = 2
 
     val byteSizeByHprofType = values().map { it.hprofType to it.byteSize }.toMap()
+
+    val primitiveTypeByHprofType = values().map { it.hprofType to it }.toMap()
   }
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index 096ddedf4..3bd8196d6 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -233,6 +233,7 @@ internal class PathFinder(
   private fun State.enqueueGcRoots() {
     val gcRoots = sortedGcRoots()
 
+    val threadNames = mutableMapOf<HeapInstance, String>()
     val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
     gcRoots.forEach { (objectRecord, gcRoot) ->
       if (computeRetainedHeapSize) {
@@ -247,7 +248,11 @@ internal class PathFinder(
           val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
               gcRoot.threadSerialNumber
           )
-          val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
+          val threadName = threadNames[threadInstance] ?: {
+            val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()?:""
+            threadNames[threadInstance] = name
+            name
+          }()
           val referenceMatcher = threadNameReferenceMatchers[threadName]
 
           if (referenceMatcher !is IgnoredReferenceMatcher) {
