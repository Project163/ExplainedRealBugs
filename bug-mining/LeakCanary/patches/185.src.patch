diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index e742914c5..e0013504f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -2,6 +2,7 @@ package leakcanary
 
 import android.content.Intent
 import leakcanary.LeakCanary.config
+import leakcanary.internal.HeapDumpControl
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.activity.LeakActivity
 import shark.AndroidMetadataExtractor
@@ -294,6 +295,7 @@ object LeakCanary {
       val previousConfig = field
       field = newConfig
       logConfigChange(previousConfig, newConfig)
+      HeapDumpControl.updateICanHasHeap()
     }
 
   private fun logConfigChange(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
new file mode 100644
index 000000000..a4c6c9704
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpControl.kt
@@ -0,0 +1,84 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.os.Handler
+import android.os.Looper
+import com.squareup.leakcanary.core.R
+import leakcanary.AppWatcher
+import leakcanary.LeakCanary
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.NotifyingNope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.SilentNope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
+import leakcanary.internal.activity.screen.dumpEnabledInAboutScreen
+
+internal object HeapDumpControl {
+
+  sealed class ICanHazHeap {
+    object Yup : ICanHazHeap()
+    abstract class Nope(val reason: () -> String) : ICanHazHeap()
+    class SilentNope(reason: () -> String) : Nope(reason)
+
+    /**
+     * Allows manual dumping via a notification
+     */
+    class NotifyingNope(reason: () -> String) : Nope(reason)
+  }
+
+  @Volatile
+  private lateinit var latest: ICanHazHeap
+
+  private val app: Application
+    get() = InternalLeakCanary.application
+
+  private val handler = Handler(Looper.getMainLooper())
+
+  private val testClassName by lazy {
+    InternalLeakCanary.application.getString(R.string.leak_canary_test_class_name)
+  }
+
+  private val hasTestClass by lazy {
+    try {
+      Class.forName(testClassName)
+      true
+    } catch (e: Exception) {
+      false
+    }
+  }
+
+  fun updateICanHasHeap() {
+    iCanHasHeap()
+  }
+
+  fun iCanHasHeap(): ICanHazHeap {
+    val config = LeakCanary.config
+    val dumpHeap = if (!AppWatcher.isInstalled) {
+      // Can't use a resource, we don't have an Application instance when not installed
+      SilentNope { "AppWatcher is not installed." }
+    } else if (!app.dumpEnabledInAboutScreen) {
+      NotifyingNope {
+        app.getString(R.string.leak_canary_heap_dump_disabled_from_ui)
+      }
+    } else if (!config.dumpHeap) {
+      SilentNope { app.getString(R.string.leak_canary_heap_dump_disabled_by_app) }
+    } else if (hasTestClass) {
+      SilentNope {
+        app.getString(R.string.leak_canary_heap_dump_disabled_running_tests, testClassName)
+      }
+    } else if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      handler.postDelayed({
+        updateICanHasHeap()
+      }, 20_000L)
+      NotifyingNope { app.getString(R.string.leak_canary_notification_retained_debugger_attached) }
+    } else Yup
+
+    synchronized(this) {
+      if (::latest.isInitialized && dumpHeap is Yup && latest is Nope) {
+        InternalLeakCanary.scheduleRetainedObjectCheck()
+      }
+      latest = dumpHeap
+    }
+
+    return dumpHeap
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 6c1c93482..3b96b928a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -13,15 +13,16 @@ import leakcanary.GcTrigger
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
 import leakcanary.ObjectWatcher
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.NotifyingNope
 import leakcanary.internal.InternalLeakCanary.onRetainInstanceListener
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
-import leakcanary.internal.RetainInstanceEvent.CountChanged.DebuggerIsAttached
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
 import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
-import leakcanary.internal.activity.screen.AboutScreen
 import shark.AndroidResourceIdNames
 import shark.SharkLog
 
@@ -78,36 +79,45 @@ internal class HeapDumpTrigger(
       // Scheduling for after watchDuration so that any destroyed activity has time to become
       // watch and be part of this analysis.
       scheduleRetainedObjectCheck(
-          reason = "app became invisible",
-          rescheduling = false,
           delayMillis = AppWatcher.config.watchDurationMillis
       )
     }
   }
 
-  fun onObjectRetained() {
-    scheduleRetainedObjectCheck(
-        reason = "found new object retained",
-        rescheduling = false
-    )
-  }
+  private fun checkRetainedObjects() {
+    val iCanHasHeap = HeapDumpControl.iCanHasHeap()
 
-  private fun checkRetainedObjects(reason: String) {
     val config = configProvider()
-    // A tick will be rescheduled when this is turned back on.
-    if (!config.dumpHeap) {
-      val resources = application.resources
-      val heapDumpStatus =
-        AboutScreen.getHeapDumpStatus(resources = resources, context = application)
-      val message = when (heapDumpStatus) {
-        AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_FROM_ABOUT_SCREEN -> "Heap Dump is disabled from the About Screen"
-        else -> "LeakCanary.Config.dumpHeap is false"
-      }
 
-      SharkLog.d { "Ignoring check for retained objects scheduled because $reason: $message" }
+    if (iCanHasHeap is Nope) {
+      if (iCanHasHeap is NotifyingNope) {
+        // Before notifying that we can't dump heap, let's check if we still have retained object.
+        var retainedReferenceCount = objectWatcher.retainedObjectCount
+
+        if (retainedReferenceCount > 0) {
+          gcTrigger.runGc()
+          retainedReferenceCount = objectWatcher.retainedObjectCount
+        }
+
+        val nopeReason = iCanHasHeap.reason()
+        val wouldDump = !checkRetainedCount(
+            retainedReferenceCount, config.retainedVisibleThreshold, nopeReason
+        )
 
-      if (heapDumpStatus == AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_FROM_ABOUT_SCREEN) {
-        showHeapDumpDisabledNotification()
+        if (wouldDump) {
+          val uppercaseReason = nopeReason[0].toUpperCase() + nopeReason.substring(1)
+          onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))
+          showRetainedCountNotification(
+              objectCount = retainedReferenceCount,
+              contentText = uppercaseReason
+          )
+        }
+      } else {
+        SharkLog.d {
+          application.getString(
+              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
+          )
+        }
       }
       return
     }
@@ -121,22 +131,6 @@ internal class HeapDumpTrigger(
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
-    if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
-      onRetainInstanceListener.onEvent(DebuggerIsAttached)
-      showRetainedCountNotification(
-          objectCount = retainedReferenceCount,
-          contentText = application.getString(
-              R.string.leak_canary_notification_retained_debugger_attached
-          )
-      )
-      scheduleRetainedObjectCheck(
-          reason = "debugger is attached",
-          rescheduling = true,
-          delayMillis = WAIT_FOR_DEBUG_MILLIS
-      )
-      return
-    }
-
     val now = SystemClock.uptimeMillis()
     val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis
     if (elapsedSinceLastDumpMillis < WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {
@@ -146,14 +140,11 @@ internal class HeapDumpTrigger(
           contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)
       )
       scheduleRetainedObjectCheck(
-          reason = "previous heap dump was ${elapsedSinceLastDumpMillis}ms ago (< ${WAIT_BETWEEN_HEAP_DUMPS_MILLIS}ms)",
-          rescheduling = true,
           delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis
       )
       return
     }
 
-    SharkLog.d { "Check for retained objects found $retainedReferenceCount objects, dumping the heap" }
     dismissRetainedCountNotification()
     dumpHeap(retainedReferenceCount, retry = true)
   }
@@ -170,8 +161,6 @@ internal class HeapDumpTrigger(
       if (retry) {
         SharkLog.d { "Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms" }
         scheduleRetainedObjectCheck(
-            reason = "failed to dump heap",
-            rescheduling = true,
             delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS
         )
       } else {
@@ -249,19 +238,56 @@ internal class HeapDumpTrigger(
 
   private fun checkRetainedCount(
     retainedKeysCount: Int,
-    retainedVisibleThreshold: Int
+    retainedVisibleThreshold: Int,
+    nopeReason: String? = null
   ): Boolean {
     val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
     lastDisplayedRetainedObjectCount = retainedKeysCount
     if (retainedKeysCount == 0) {
-      SharkLog.d { "Check for retained object found no objects remaining" }
       if (countChanged) {
+        SharkLog.d { "All retained objects have been garbage collected" }
         onRetainInstanceListener.onEvent(NoMoreObjects)
         showNoMoreRetainedObjectNotification()
       }
       return true
     }
 
+    val applicationVisible = applicationVisible
+    val applicationInvisibleLessThanWatchPeriod = applicationInvisibleLessThanWatchPeriod
+
+    if (countChanged) {
+      val whatsNext = if (applicationVisible) {
+        if (retainedKeysCount < retainedVisibleThreshold) {
+          "not dumping heap yet (app is visible & < $retainedVisibleThreshold threshold)"
+        } else {
+          if (nopeReason != null) {
+            "would dump heap now (app is visible & >=$retainedVisibleThreshold threshold) but $nopeReason"
+          } else {
+            "dumping heap now (app is visible & >=$retainedVisibleThreshold threshold)"
+          }
+        }
+      } else if (applicationInvisibleLessThanWatchPeriod) {
+        val wait =
+          AppWatcher.config.watchDurationMillis - (SystemClock.uptimeMillis() - applicationInvisibleAt)
+        if (nopeReason!= null) {
+          "would dump heap in $wait ms (app just became invisible) but $nopeReason"
+        } else {
+          "dumping heap in $wait ms (app just became invisible)"
+        }
+      } else {
+        if (nopeReason != null) {
+          "would dump heap now (app is invisible) but $nopeReason"
+        } else {
+          "dumping heap now (app is invisible)"
+        }
+      }
+
+      SharkLog.d {
+        val s = if (retainedKeysCount > 1) "s" else ""
+        "Found $retainedKeysCount object$s retained, $whatsNext"
+      }
+    }
+
     if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
         if (countChanged) {
@@ -274,8 +300,6 @@ internal class HeapDumpTrigger(
             )
         )
         scheduleRetainedObjectCheck(
-            reason = "found only $retainedKeysCount retained objects (< $retainedVisibleThreshold while app visible)",
-            rescheduling = true,
             delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS
         )
         return true
@@ -284,25 +308,17 @@ internal class HeapDumpTrigger(
     return false
   }
 
-  private fun scheduleRetainedObjectCheck(
-    reason: String,
-    rescheduling: Boolean,
+  fun scheduleRetainedObjectCheck(
     delayMillis: Long = 0L
   ) {
     val checkCurrentlyScheduledAt = checkScheduledAt
     if (checkCurrentlyScheduledAt > 0) {
-      val scheduledIn = checkCurrentlyScheduledAt - SystemClock.uptimeMillis()
-      SharkLog.d { "Ignoring request to check for retained objects ($reason), already scheduled in ${scheduledIn}ms" }
       return
-    } else {
-      val verb = if (rescheduling) "Rescheduling" else "Scheduling"
-      val delay = if (delayMillis > 0) " in ${delayMillis}ms" else ""
-      SharkLog.d { "$verb check for retained objects${delay} because $reason" }
     }
     checkScheduledAt = SystemClock.uptimeMillis() + delayMillis
     backgroundHandler.postDelayed({
       checkScheduledAt = 0
-      checkRetainedObjects(reason)
+      checkRetainedObjects()
     }, delayMillis)
   }
 
@@ -351,26 +367,6 @@ internal class HeapDumpTrigger(
     notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
   }
 
-  private fun showHeapDumpDisabledNotification() {
-    if (!Notifications.canShowNotification) {
-      return
-    }
-    @Suppress("DEPRECATION")
-    val builder = Notification.Builder(application)
-        .setContentTitle(
-            application.getString(R.string.leak_canary_notification_heap_dump_disabled)
-        )
-        .setContentText(
-            application.getString(
-                R.string.leak_canary_notification_heap_dump_tap_to_dismiss
-            )
-        )
-        .setAutoCancel(true)
-        .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
-    val notification = Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_heap_dump_disabled, notification)
-  }
-
   private fun dismissRetainedCountNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     notificationManager.cancel(R.id.leak_canary_notification_retained_objects)
@@ -382,7 +378,6 @@ internal class HeapDumpTrigger(
   }
 
   companion object {
-    private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
     private const val WAIT_FOR_OBJECT_THRESHOLD_MILLIS = 2_000L
     private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index b80274124..b27d41d87 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -26,11 +26,11 @@ import leakcanary.AppWatcher
 import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.OnObjectRetainedListener
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
 import leakcanary.internal.InternalLeakCanary.FormFactor.MOBILE
 import leakcanary.internal.InternalLeakCanary.FormFactor.TV
 import leakcanary.internal.InternalLeakCanary.FormFactor.WATCH
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.getHeapDumpSwitchStatus
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.sharedPreferenceBackgroundExecutor
 import leakcanary.internal.tv.TvOnRetainInstanceListener
 import shark.SharkLog
 import java.lang.reflect.InvocationHandler
@@ -64,19 +64,6 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
   var applicationVisible = false
     private set
 
-  private val testClassName by lazy {
-    application.getString(R.string.leak_canary_test_class_name)
-  }
-
-  private val isRunningTests by lazy {
-    try {
-      Class.forName(testClassName)
-      true
-    } catch (e: Exception) {
-      false
-    }
-  }
-
   private val isDebuggableBuild by lazy {
     (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
   }
@@ -147,7 +134,17 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     registerResumedActivityListener(application)
     addDynamicShortcut(application)
 
-    disableDumpHeapIfNeeded(application)
+    // We post so that the log happens after Application.onCreate()
+    Handler().post {
+      SharkLog.d {
+        when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) {
+          is Yup -> application.getString(R.string.leak_canary_heap_dump_enabled_text)
+          is Nope -> application.getString(
+              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
+          )
+        }
+      }
+    }
   }
 
   private fun checkRunningInDebuggableBuild() {
@@ -185,38 +182,6 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     })
   }
 
-  private fun disableDumpHeapIfNeeded(context: Context) {
-    disableDumpHeapInTests()
-    disableDumpHeapAboutScreen(context)
-
-    if (LeakCanary.config.dumpHeap) {
-      SharkLog.d { "LeakCanary is running and ready to detect leaks" }
-    } else {
-      SharkLog.d { "LeakCanary heap dumping is disabled: LeakCanary.config.dumpHeap = false" }
-    }
-  }
-
-  private fun disableDumpHeapAboutScreen(context: Context) {
-    sharedPreferenceBackgroundExecutor.execute {
-      val disableHeapDump = !getHeapDumpSwitchStatus(context)
-      if (disableHeapDump) {
-        SharkLog.d { "Heap dumping turned off from About screen => disabling heap dumping & analysis" }
-        LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
-      }
-    }
-  }
-
-  private fun disableDumpHeapInTests() {
-    // This is called before Application.onCreate(), so if the class is loaded through a secondary
-    // dex it might not be available yet.
-    Handler().post {
-      if (isRunningTests) {
-        SharkLog.d { "$testClassName detected in classpath, app is running tests => disabling heap dumping & analysis" }
-      }
-      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
-    }
-  }
-
   @Suppress("ReturnCount")
   private fun addDynamicShortcut(application: Application) {
     if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
@@ -320,9 +285,11 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     }
   }
 
-  override fun onObjectRetained() {
+  override fun onObjectRetained() = scheduleRetainedObjectCheck()
+
+  fun scheduleRetainedObjectCheck() {
     if (this::heapDumpTrigger.isInitialized) {
-      heapDumpTrigger.onObjectRetained()
+      heapDumpTrigger.scheduleRetainedObjectCheck()
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt
index 12c9d0208..0988eaaf6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/OnRetainInstanceListener.kt
@@ -3,8 +3,8 @@ package leakcanary.internal
 internal sealed class RetainInstanceEvent {
   object NoMoreObjects : RetainInstanceEvent()
   sealed class CountChanged : RetainInstanceEvent() {
-    data class BelowThreshold(val retainedCount: Int) : RetainInstanceEvent()
-    object DebuggerIsAttached : RetainInstanceEvent()
+    class BelowThreshold(val retainedCount: Int) : RetainInstanceEvent()
+    class DumpingDisabled(val reason: String) : RetainInstanceEvent()
     object DumpHappenedRecently : RetainInstanceEvent()
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt
index a1d840a88..30f3aed9c 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/AboutScreen.kt
@@ -1,10 +1,6 @@
 package leakcanary.internal.activity.screen
 
 import android.content.Context
-import android.content.Context.MODE_PRIVATE
-import android.content.res.Resources
-import android.os.Handler
-import android.os.Process
 import android.text.Html
 import android.text.method.LinkMovementMethod
 import android.view.ViewGroup
@@ -12,31 +8,17 @@ import android.widget.Switch
 import android.widget.TextView
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
-import leakcanary.AppWatcher
-import leakcanary.LeakCanary
-import leakcanary.internal.DebuggerControl
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_BY_DEVELOPER
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_DEBUGGER_ATTACHED
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_FROM_ABOUT_SCREEN
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.DISABLED_RUNNING_TESTS
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.ENABLED
-import leakcanary.internal.activity.screen.AboutScreen.HeapDumpPolicy.HeapDumpStatus.NOT_INSTALLED
+import leakcanary.internal.HeapDumpControl
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Nope
+import leakcanary.internal.HeapDumpControl.ICanHazHeap.Yup
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
-import java.util.concurrent.Executors
-import java.util.concurrent.ScheduledExecutorService
-
-private const val HEAP_DUMP_SHARED_PREFERENCES = "HEAP_DUMP_SHARED_PREFERENCES"
-private const val HEAP_DUMP_SWITCH_ENABLED = "HEAP_DUMP_SWITCH_ENABLED"
-private const val HEAP_DUMP_SHARED_PREFERENCES_THREAD_NAME = "shared-preferences"
 
 internal class AboutScreen : Screen() {
-
   override fun createView(container: ViewGroup) =
     container.inflate(R.layout.leak_canary_about_screen)
         .apply {
-
           activity.title =
             resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION)
           val aboutTextView = findViewById<TextView>(R.id.leak_canary_about_text)
@@ -52,130 +34,38 @@ internal class AboutScreen : Screen() {
           )
 
           val heapDumpTextView = findViewById<TextView>(R.id.leak_canary_about_heap_dump_text)
-          updateHeapDumpTextView(heapDumpTextView, context, resources, ::getHeapDumpStatusMessage)
+          updateHeapDumpTextView(heapDumpTextView)
           val heapDumpSwitchView =
             findViewById<Switch>(R.id.leak_canary_about_heap_dump_switch_button)
-          val uiHandler = Handler()
-          sharedPreferenceBackgroundExecutor.execute {
-            val checked = getHeapDumpSwitchStatus(context)
-            uiHandler.post {
-              heapDumpSwitchView.isChecked = checked
-            }
-          }
+          heapDumpSwitchView.isChecked = context.dumpEnabledInAboutScreen
           heapDumpSwitchView.setOnCheckedChangeListener { _, checked ->
-            updateHeapDumpConfig(checked, context)
-            updateHeapDumpTextView(heapDumpTextView, context, resources, ::getHeapDumpStatusMessage)
+            // Updating the value wouldn't normally immediately trigger a heap dump, however
+            // by updating the view we also have a side effect of querying which will notify
+            // the heap dumper if the value has become positive.
+            context.dumpEnabledInAboutScreen = checked
+            updateHeapDumpTextView(heapDumpTextView)
           }
         }
 
-  private fun updateHeapDumpTextView(
-    heapDumpTextView: TextView,
-    context: Context,
-    resources: Resources,
-    getHeapDumpStatusMessage: (resources: Resources, context: Context) -> String
-  ) {
-    sharedPreferenceBackgroundExecutor.execute {
-      heapDumpTextView.text = getHeapDumpStatusMessage(resources, context)
-    }
-  }
-
-  private fun getHeapDumpStatusMessage(
-    resources: Resources,
-    context: Context
-  ) =
-    when (getHeapDumpStatus(resources, context)) {
-      NOT_INSTALLED -> resources.getString(R.string.leak_canary_heap_dump_not_installed_text)
-      ENABLED -> resources.getString(R.string.leak_canary_heap_dump_enabled_text)
-      DISABLED_DEBUGGER_ATTACHED -> String.format(
-          resources.getString(R.string.leak_canary_heap_dump_disabled_text),
-          resources.getString(R.string.leak_canary_heap_dump_disabled_build_non_debuggable)
-      )
-      DISABLED_BY_DEVELOPER -> String.format(
-          resources.getString(R.string.leak_canary_heap_dump_disabled_text),
-          resources.getString(R.string.leak_canary_heap_dump_disabled_by_app)
-      )
-      DISABLED_FROM_ABOUT_SCREEN -> String.format(
-          resources.getString(R.string.leak_canary_heap_dump_disabled_text),
-          resources.getString(R.string.leak_canary_heap_dump_disabled_from_ui)
+  private fun updateHeapDumpTextView(view: TextView) {
+    view.text = when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) {
+      is Yup -> view.resources.getString(R.string.leak_canary_heap_dump_enabled_text)
+      is Nope -> view.resources.getString(
+          R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()
       )
-      DISABLED_RUNNING_TESTS -> String.format(
-          resources.getString(R.string.leak_canary_heap_dump_disabled_text),
-          resources.getString(R.string.leak_canary_heap_dump_disabled_running_tests)
-      )
-    }
 
-  /**
-   * Updates leak canary config to enable/disable heap dump depending upon the Toggle switch from the about screen.
-   */
-  private fun updateHeapDumpConfig(
-    checked: Boolean,
-    context: Context
-  ) {
-    LeakCanary.config = LeakCanary.config.copy(dumpHeap = checked)
-    sharedPreferenceBackgroundExecutor.execute {
-      context
-          .getSharedPreferences(HEAP_DUMP_SHARED_PREFERENCES, MODE_PRIVATE)
-          .edit()
-          .putBoolean(HEAP_DUMP_SWITCH_ENABLED, checked)
-          .apply()
     }
   }
+}
 
-  companion object HeapDumpPolicy {
-    enum class HeapDumpStatus {
-      ENABLED,
-      DISABLED_DEBUGGER_ATTACHED,
-      DISABLED_BY_DEVELOPER,
-      DISABLED_FROM_ABOUT_SCREEN,
-      DISABLED_RUNNING_TESTS,
-      NOT_INSTALLED
-    }
-
-    // Shared preferences should be read on a background thread as reading them on UI Thread will
-    // invoke Strict mode violation.
-    val sharedPreferenceBackgroundExecutor: ScheduledExecutorService =
-      Executors.newSingleThreadScheduledExecutor { runnable ->
-        val thread = object : Thread() {
-          override fun run() {
-            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
-            runnable.run()
-          }
-        }
-        thread.name = HEAP_DUMP_SHARED_PREFERENCES_THREAD_NAME
-        thread
-      }
-
-    fun getHeapDumpSwitchStatus(context: Context) =
-      context
-          .getSharedPreferences(HEAP_DUMP_SHARED_PREFERENCES, MODE_PRIVATE)
-          .getBoolean(HEAP_DUMP_SWITCH_ENABLED, true)
-
-    fun getHeapDumpStatus(
-      resources: Resources,
-      context: Context
-    ): HeapDumpStatus {
-      val config = LeakCanary.config
-      return when {
-        !AppWatcher.isInstalled -> NOT_INSTALLED
-        !config.dumpHeap ->
-          if (isRunningTests(resources)) {
-            DISABLED_RUNNING_TESTS
-          } else if (!getHeapDumpSwitchStatus(context)) {
-            DISABLED_FROM_ABOUT_SCREEN
-          } else {
-            DISABLED_BY_DEVELOPER
-          }
-        !config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached -> DISABLED_DEBUGGER_ATTACHED
-        else -> ENABLED
-      }
-    }
-
-    private fun isRunningTests(resources: Resources) =
-      try {
-        Class.forName(resources.getString(R.string.leak_canary_test_class_name))
-        true
-      } catch (e: Exception) {
-        false
-      }
+internal var Context.dumpEnabledInAboutScreen: Boolean
+  get() {
+    return getSharedPreferences("LeakCanaryHeapDumpPrefs", Context.MODE_PRIVATE)
+        .getBoolean("AboutScreenDumpEnabled", true)
+  }
+  set(value) {
+    getSharedPreferences("LeakCanaryHeapDumpPrefs", Context.MODE_PRIVATE)
+        .edit()
+        .putBoolean("AboutScreenDumpEnabled", value)
+        .apply()
   }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
index e3fb7be2f..0dedbbc78 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/tv/TvOnRetainInstanceListener.kt
@@ -9,8 +9,8 @@ import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.OnRetainInstanceListener
 import leakcanary.internal.RetainInstanceEvent
 import leakcanary.internal.RetainInstanceEvent.CountChanged.BelowThreshold
-import leakcanary.internal.RetainInstanceEvent.CountChanged.DebuggerIsAttached
 import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpHappenedRecently
+import leakcanary.internal.RetainInstanceEvent.CountChanged.DumpingDisabled
 import leakcanary.internal.RetainInstanceEvent.NoMoreObjects
 import shark.SharkLog
 
@@ -39,8 +39,8 @@ internal class TvOnRetainInstanceListener(private val application: Application)
             LeakCanary.config.retainedVisibleThreshold
         )
       }
-      is DebuggerIsAttached -> {
-        application.getString(R.string.leak_canary_notification_retained_debugger_attached)
+      is DumpingDisabled -> {
+        event.reason
       }
       is DumpHappenedRecently -> {
         application.getString(R.string.leak_canary_notification_retained_dump_wait)
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml
index 2e9b6cb1f..424a13d6b 100644
--- a/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_about_screen.xml
@@ -3,7 +3,7 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     >
-  <TextView xmlns:android="http://schemas.android.com/apk/res/android"
+  <TextView
       android:id="@+id/leak_canary_about_text"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
@@ -12,29 +12,27 @@
       android:paddingRight="16dp"
       />
 
-  <Switch
-      android:id="@+id/leak_canary_about_heap_dump_switch_button"
+  <TextView
+      android:id="@+id/leak_canary_about_heap_dump_text"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
-      android:layout_above="@+id/leak_canary_about_heap_dump_text"
-      android:paddingBottom="16dp"
+      android:layout_above="@+id/leak_canary_about_heap_dump_switch_button"
+      android:paddingTop="16dp"
       android:paddingLeft="16dp"
       android:paddingRight="16dp"
-      android:checked="true"
-      android:text="@string/leak_canary_about_enable_heap_dump"
-      android:textOn="@string/leak_canary_about_enable_heap_dump_textOn"
-      android:textOff="@string/leak_canary_about_enable_heap_dump_textOff"
+      android:textStyle="italic"
       />
 
-  <TextView
-      android:id="@+id/leak_canary_about_heap_dump_text"
+  <Switch
+      android:id="@+id/leak_canary_about_heap_dump_switch_button"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:layout_alignParentBottom="true"
-      android:paddingBottom="16dp"
-      android:paddingLeft="16dp"
-      android:paddingRight="16dp"
-      android:textStyle="italic"
+      android:padding="16dp"
+      android:checked="true"
+      android:text="@string/leak_canary_about_enable_heap_dump"
+      android:textOn="@string/leak_canary_about_enable_heap_dump_textOn"
+      android:textOff="@string/leak_canary_about_enable_heap_dump_textOff"
       />
 
-</RelativeLayout>
\ No newline at end of file
+</RelativeLayout>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
index 965527eff..d94af9799 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -22,5 +22,4 @@
   <item type="id" name="leak_canary_notification_retained_objects" />
   <item type="id" name="leak_canary_notification_no_retained_object_on_tap" />
   <item type="id" name="leak_canary_notification_on_screen_exit" />
-  <item type="id" name="leak_canary_notification_heap_dump_disabled" />
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index bb117d5e2..9aab7d532 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -25,16 +25,15 @@
   We welcome contributions from the community - please do not hesitate to
   <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br><br>
 ]]></string>
-  <string name="leak_canary_about_enable_heap_dump">Enable Heap Dump</string>
+  <string name="leak_canary_about_enable_heap_dump">Dump heap automatically</string>
   <string name="leak_canary_about_enable_heap_dump_textOn">Enable</string>
   <string name="leak_canary_about_enable_heap_dump_textOff">Disable</string>
-  <string name="leak_canary_heap_dump_disabled_text">Heap dumping is currently disabled, because <i>%s</i>.</string>
-  <string name="leak_canary_heap_dump_not_installed_text">AppWatcher is not installed.</string>
-  <string name="leak_canary_heap_dump_enabled_text">Heap dumping is currently enabled.</string>
+  <string name="leak_canary_heap_dump_disabled_text">LeakCanary is currently disabled: <i>%s</i>.</string>
+  <string name="leak_canary_heap_dump_not_installed_text">AppWatcher is not installed</string>
+  <string name="leak_canary_heap_dump_enabled_text">LeakCanary is running and ready to detect memory leaks.</string>
   <string name="leak_canary_heap_dump_disabled_by_app">LeakCanary.Config.dumpHeap is set to false</string>
-  <string name="leak_canary_heap_dump_disabled_from_ui">Heap dump is disabled from About Screen</string>
-  <string name="leak_canary_heap_dump_disabled_running_tests">tests are running</string>
-  <string name="leak_canary_heap_dump_disabled_build_non_debuggable">the debugger is attached and LeakCanary.Config.dumpHeapWhenDebugging is set to false</string>
+  <string name="leak_canary_heap_dump_disabled_from_ui">heap dumping disabled from LeakCanary About screen</string>
+  <string name="leak_canary_heap_dump_disabled_running_tests">test class "%s" was found in classpath</string>
   <string name="leak_canary_analysis_failed">Heap analysis failed</string>
   <string name="leak_canary_analysis_success_notification">Found %1$d retained objects grouped as %2$d distinct leaks</string>
   <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
@@ -57,8 +56,6 @@
   <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
   <string name="leak_canary_notification_retained_dump_wait">Last heap dump was less than a minute ago</string>
   <string name="leak_canary_notification_retained_title">%d retained objects, tap to dump heap</string>
-  <string name="leak_canary_notification_heap_dump_disabled">Heap Dump was not triggered.</string>
-  <string name="leak_canary_notification_heap_dump_tap_to_dismiss">Heap Dump is disabled from the About Screen. Tap to dismiss.</string>
   <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained objects</string>
   <string name="leak_canary_share_with">Share withâ€¦</string>
   <string name="leak_canary_display_activity_label">Leaks</string>
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index cd9660abd..d6bf6bf85 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -17,7 +17,7 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.squareup.leakcanary.instrumentation.test">
 
-  <application android:name="leakcanary.InstrumentationTestApplication">
+  <application>
     <activity android:name="leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
deleted file mode 100644
index 289621e0f..000000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationTestApplication.kt
+++ /dev/null
@@ -1,10 +0,0 @@
-package leakcanary
-
-import android.app.Application
-
-class InstrumentationTestApplication : Application() {
-  override fun onCreate() {
-    super.onCreate()
-    InstrumentationLeakDetector.updateConfig()
-  }
-}
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index bb1e6d166..3e2cce506 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -60,7 +60,6 @@ open class FailTestOnLeakRunListener : RunListener() {
   private var allActivitiesDestroyedLatch: CountDownLatch? = null
 
   override fun testRunStarted(description: Description) {
-    InstrumentationLeakDetector.updateConfig()
     testResultPublisher = TestResultPublisher.install()
     trackActivities()
   }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 01983305c..e258cd173 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -19,7 +19,6 @@ import android.os.Debug
 import android.os.SystemClock
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
 import leakcanary.GcTrigger.Default.runGc
-import leakcanary.InstrumentationLeakDetector.Companion.updateConfig
 import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
 import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
 import org.junit.runner.notification.RunListener
@@ -33,12 +32,8 @@ import java.io.File
 /**
  * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
  *
- * To use it, you need to:
- *
- *  - Call [updateConfig] so that [AppWatcher] will watch objects and [LeakCanary] will not dump
- *  the heap on retained objects
- *  - Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener]) that will invoke
- * [detectLeaks].
+ * To use it, you need to add an instrumentation test listener (e.g. [FailTestOnLeakRunListener])
+ * that will invoke [detectLeaks].
  *
  * ### Add an instrumentation test listener
  *
@@ -182,14 +177,10 @@ class InstrumentationLeakDetector {
 
   companion object {
 
-    /**
-     * Configures [AppWatcher] to watch objects and [LeakCanary] to not dump the heap on retained
-     * objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
-     * a test. This is automatically called by [FailTestOnLeakRunListener] when the tests start
-     * running.
-     */
-    fun updateConfig() {
-      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
-    }
+    @Deprecated(
+        "This is a no-op as LeakCanary automatically detects tests",
+        replaceWith = ReplaceWith("")
+    )
+    fun updateConfig() = Unit
   }
 }
diff --git a/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt b/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
index bed35e57e..3192d67c1 100644
--- a/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
+++ b/plumber-android/src/main/java/leakcanary/AndroidLeakFixes.kt
@@ -160,7 +160,7 @@ enum class AndroidLeakFixes {
               var scheduleFlush = true
               val flushHandler = Handler(handlerThread.looper)
               flushHandler.onEachIdle {
-                if (scheduleFlush) {
+                if (handlerThread.isAlive && scheduleFlush) {
                   scheduleFlush = false
                   // When the Handler thread becomes idle, we post a message to force it to move.
                   // Source: https://developer.squareup.com/blog/a-small-leak-will-sink-a-great-ship/
