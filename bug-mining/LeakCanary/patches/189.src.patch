diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index 45347d96f..0b2997375 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -67,26 +67,7 @@ enum class AndroidObjectInspectors : ObjectInspector {
         val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
         val mContext = instance["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
 
-        val androidComponentContext = mContext.unwrapComponentContext()
-        val activityContext =
-          if (androidComponentContext != null && androidComponentContext instanceOf "android.app.Activity") androidComponentContext else null
-        labels += if (androidComponentContext == null) {
-          "mContext instance of ${mContext.instanceClassName}, not wrapping known Android context"
-        } else if (activityContext != null) {
-          val activityDescription =
-            "with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
-                ?: "UNKNOWN")
-          if (activityContext == mContext) {
-            "mContext instance of ${activityContext.instanceClassName} $activityDescription"
-          } else {
-            "mContext instance of ${mContext.instanceClassName}, wrapping activity ${activityContext.instanceClassName} $activityDescription"
-          }
-        } else if (androidComponentContext == mContext) {
-          // No need to add "instance of Application / Service", devs know their own classes.
-          "mContext instance of ${mContext.instanceClassName}"
-        } else {
-          "mContext instance of ${mContext.instanceClassName}, wrapping ${androidComponentContext.instanceClassName}"
-        }
+        val activityContext = mContext.unwrapActivityContext()
         if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
           leakingReasons += "View.mContext references a destroyed activity"
         } else {
@@ -172,6 +153,41 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   },
 
+  CONTEXT_FIELD {
+    override fun inspect(reporter: ObjectReporter) {
+      val instance = reporter.heapObject
+      if (instance !is HeapInstance) {
+        return
+      }
+      instance.readFields().forEach { field ->
+        val fieldInstance = field.valueAsInstance
+        if (fieldInstance != null && fieldInstance instanceOf "android.content.Context") {
+          reporter.run {
+            val componentContext = fieldInstance.unwrapComponentContext()
+            labels += if (componentContext == null) {
+              "${field.name} instance of ${fieldInstance.instanceClassName}, not wrapping known Android context"
+            } else if (componentContext instanceOf "android.app.Activity") {
+              val activityDescription =
+                "with mDestroyed = " + (componentContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+                    ?: "UNKNOWN")
+              if (componentContext == fieldInstance) {
+                "${field.name} instance of ${fieldInstance.instanceClassName} $activityDescription"
+              } else {
+                "${field.name} instance of ${fieldInstance.instanceClassName}, " +
+                    "wrapping activity ${componentContext.instanceClassName} $activityDescription"
+              }
+            } else if (componentContext == fieldInstance) {
+              // No need to add "instance of Application / Service", devs know their own classes.
+              "${field.name} instance of ${fieldInstance.instanceClassName}"
+            } else {
+              "${field.name} instance of ${fieldInstance.instanceClassName}, wrapping ${componentContext.instanceClassName}"
+            }
+          }
+        }
+      }
+    }
+  },
+
   CONTEXT_WRAPPER {
 
     override val leakingObjectFilter = { heapObject: HeapObject ->
diff --git a/shark-android/src/test/java/shark/HprofIOPerfTest.kt b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
index 6518d512c..ccddc7583 100644
--- a/shark-android/src/test/java/shark/HprofIOPerfTest.kt
+++ b/shark-android/src/test/java/shark/HprofIOPerfTest.kt
@@ -177,7 +177,7 @@ class HprofIOPerfTest {
     val medianBytesRead = randomAccessReads.median()
     val totalBytesRead = randomAccessReads.sum()
     assertThat(listOf(readsCount, medianBytesRead, totalBytesRead))
-        .isEqualTo(listOf(28586, 40.0, 1849317))
+        .isEqualTo(listOf(28596, 40.0, 1850100))
   }
 
   @Test fun `freeze leak_asynctask_m hprof random access metrics`() {
@@ -190,7 +190,7 @@ class HprofIOPerfTest {
     val medianBytesRead = randomAccessReads.median()
     val totalBytesRead = randomAccessReads.sum()
     assertThat(listOf(readsCount, medianBytesRead, totalBytesRead))
-        .isEqualTo(listOf(27195, 40.0, 2704907))
+        .isEqualTo(listOf(27205, 40.0, 2705654))
   }
 
   @Test fun `freeze leak_asynctask_pre_m hprof random access metrics`() {
@@ -202,7 +202,7 @@ class HprofIOPerfTest {
     val size = randomAccessReads.size
     val median = randomAccessReads.median()
     val sum = randomAccessReads.sum()
-    assertThat(listOf(size, median, sum)).isEqualTo(listOf(20061, 32.0, 1105877))
+    assertThat(listOf(size, median, sum)).isEqualTo(listOf(20079, 32.0, 1107595))
   }
 
   private fun trackAnalyzeIoReadMetrics(hprofFile: File): List<List<Int>> {
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index 85063d99f..3b12eaaff 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -78,6 +78,18 @@ class LegacyHprofTest {
     NOT_ACTIVITY
   }
 
+  @Test fun `AndroidObjectInspectors#CONTEXT_FIELD labels Context fields`() {
+    val toastLabels = "leak_asynctask_o.hprof".classpathFile().openHeapGraph().use { graph ->
+      graph.instances.filter { it.instanceClassName == "android.widget.Toast" }
+          .map { instance ->
+            ObjectReporter(instance).apply {
+              AndroidObjectInspectors.CONTEXT_FIELD.inspect(this)
+            }.labels.joinToString(",")
+          }.toList()
+    }
+    assertThat(toastLabels).containsExactly("mContext instance of com.example.leakcanary.ExampleApplication")
+  }
+
   @Test fun androidOCountActivityWrappingContexts() {
     val contextWrapperStatuses = Hprof.open("leak_asynctask_o.hprof".classpathFile())
         .use { hprof ->
@@ -122,7 +134,6 @@ class LegacyHprofTest {
     return analyzeHprof(fileName.classpathFile())
   }
 
-
   private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
     SharkLog.logger = object : Logger {
       override fun d(message: String) {
