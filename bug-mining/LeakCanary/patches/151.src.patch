diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
index 3ad487fa5..4227c1d45 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakTable.kt
@@ -21,6 +21,7 @@ internal object LeakTable {
         group_description TEXT,
         class_simple_name TEXT,
         is_library_leak INTEGER,
+        is_read INTEGER,
         object BLOB
         )"""
 
@@ -43,8 +44,9 @@ internal object LeakTable {
     values.put("group_hash", leak.groupHash)
     values.put("group_description", leak.createGroupDescription())
     values.put("class_simple_name", leak.classSimpleName)
-    values.put("object", leak.toByteArray())
     values.put("is_library_leak", if (leak is LibraryLeak) 1 else 0)
+    values.put("is_read", 0)
+    values.put("object", leak.toByteArray())
     return db.insertOrThrow("leak", null, values)
   }
 
@@ -61,13 +63,6 @@ internal object LeakTable {
     db: SQLiteDatabase,
     heapAnalysisId: Long
   ): Map<String, HeapAnalysisGroupProjection> {
-
-    val isLatestHeapAnalysis = db.rawQuery("SELECT MAX(id) FROM heap_analysis", null)
-        .use { cursor ->
-          cursor.moveToNext()
-          cursor.getLong(0) == heapAnalysisId
-        }
-
     return db.rawQuery(
         """
           SELECT
@@ -75,8 +70,8 @@ internal object LeakTable {
           , group_description
           , MAX(created_at_time_millis) as created_at_time_millis
           , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
-          , COUNT(*) as total_leak_count
           , MIN(is_library_leak) as is_library_leak
+          , CASE WHEN SUM(is_read) > 0 THEN 1 ELSE 0 END as is_read
           FROM leak l
           LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
           GROUP BY 1, 2
@@ -91,9 +86,8 @@ internal object LeakTable {
             val description = cursor.getString(1)
             val createdAtTimeMillis = cursor.getLong(2)
             val leakCount = cursor.getInt(3)
-            val totalLeakCount = cursor.getInt(4)
-            val isNew = isLatestHeapAnalysis && leakCount == totalLeakCount
-            val isLibraryLeak = cursor.getInt(5) == 1
+            val isLibraryLeak = cursor.getInt(4) == 1
+            val isNew = cursor.getInt(5) == 0
             val group = HeapAnalysisGroupProjection(
                 hash, description, createdAtTimeMillis, leakCount, isNew, isLibraryLeak
             )
@@ -107,7 +101,8 @@ internal object LeakTable {
     val hash: String,
     val description: String,
     val createdAtTimeMillis: Long,
-    val leakCount: Int
+    val leakCount: Int,
+    val isNew: Boolean
   )
 
   fun retrieveAllLeaks(
@@ -120,6 +115,7 @@ internal object LeakTable {
           , group_description
           , MAX(created_at_time_millis) as created_at_time_millis
           , COUNT(*) as leak_count
+          , CASE WHEN SUM(is_read) > 0 THEN 1 ELSE 0 END as is_read
           FROM leak l
           LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
           GROUP BY 1, 2
@@ -133,7 +129,8 @@ internal object LeakTable {
                 hash = cursor.getString(0),
                 description = cursor.getString(1),
                 createdAtTimeMillis = cursor.getLong(2),
-                leakCount = cursor.getInt(3)
+                leakCount = cursor.getInt(3),
+                isNew = cursor.getInt(4) == 0
             )
             all.add(group)
           }
@@ -149,6 +146,15 @@ internal object LeakTable {
     val createdAtTimeMillis: Long
   )
 
+  fun markAsRead(
+    db: SQLiteDatabase,
+    leakId: Long
+  ) {
+    val values = ContentValues()
+    values.put("is_read", 1)
+    db.update("leak", values, "id = ?", arrayOf(leakId.toString()))
+  }
+
   fun retrieveLeaksByHash(
     db: SQLiteDatabase,
     groupHash: String
@@ -186,7 +192,8 @@ internal object LeakTable {
   class LeakDetails(
     val leak: Leak,
     val analysisId: Long,
-    val analysis: HeapAnalysisSuccess
+    val analysis: HeapAnalysisSuccess,
+    val isNew: Boolean
   )
 
   fun retrieveLeakById(
@@ -199,6 +206,7 @@ internal object LeakTable {
           l.heap_analysis_id
           , l.object
           , h.object
+          , l.is_read
           FROM leak l
           LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
           WHERE l.id = ?
@@ -210,8 +218,9 @@ internal object LeakTable {
             val heapAnalysisId = cursor.getLong(0)
             val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(1))
             val analysis = Serializables.fromByteArray<HeapAnalysisSuccess>(cursor.getBlob(2))
+            val isNew = cursor.getInt(3) == 0
             if (leakingInstance != null && analysis != null) {
-              LeakDetails(leakingInstance, heapAnalysisId, analysis)
+              LeakDetails(leakingInstance, heapAnalysisId, analysis, isNew)
             } else null
           } else null
         }
@@ -228,7 +237,7 @@ internal object LeakTable {
     db.delete("leak", null, null)
   }
 
-  internal fun Leak.createGroupDescription(): String {
+  private fun Leak.createGroupDescription(): String {
     return if (this is LibraryLeak) {
       "Library Leak: $pattern"
     } else {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 04c21b172..9252f0936 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -25,6 +25,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
   }
 
   companion object {
-    private const val VERSION = 19
+    private const val VERSION = 20
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
index 142efe681..12b96e51b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpScreen.kt
@@ -158,6 +158,7 @@ internal class HeapDumpScreen(
           val projection = leakGroups[position - 2]
 
           val isNew = projection.isNew && !projection.isLibraryLeak
+          countView.isEnabled = isNew
 
           countView.text = projection.leakCount.toString()
           descriptionView.text =
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
index 6ad59f303..a25b40b3d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpsScreen.kt
@@ -87,6 +87,8 @@ internal class HeapDumpsScreen : Screen() {
         val countView = view.findViewById<TextView>(R.id.leak_canary_time_text)
 
         val projection = getItem(position)
+        // Enable means "new"
+        countView.isEnabled = false
 
         timeView.text = TimeFormatter.formatTimestamp(view.context, projection.createdAtTimeMillis)
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
index 698f286ea..522c37d0e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakScreen.kt
@@ -39,11 +39,13 @@ internal class LeakScreen(
       activity.title = resources.getString(R.string.leak_canary_loading_title)
       executeOnDb {
         val leaks = LeakTable.retrieveLeaksByHash(db, groupHash)
+        val selectedLeakIndex =
+          if (selectedHeapAnalysisId == null) 0 else leaks.indexOfFirst { it.analysisId == selectedHeapAnalysisId }
         updateUi {
           if (leaks.isEmpty()) {
             activity.title = resources.getString(R.string.leak_canary_leak_not_found)
           } else {
-            onLeaksRetrieved(leaks, selectedHeapAnalysisId)
+            onLeaksRetrieved(leaks, selectedLeakIndex)
           }
         }
       }
@@ -51,7 +53,7 @@ internal class LeakScreen(
 
   private fun View.onLeaksRetrieved(
     leaks: List<LeakProjection>,
-    selectedHeapAnalysisId: Long?
+    selectedLeakIndex: Int
   ) {
     activity.title = String.format(
         resources.getQuantityText(
@@ -83,23 +85,20 @@ internal class LeakScreen(
         id: Long
       ) {
         executeOnDb {
-          LeakTable.retrieveLeakById(db, leaks[position].id)
+          val displayedLeak = leaks[position]
+          LeakTable.retrieveLeakById(db, displayedLeak.id)
               ?.let { leak ->
                 updateUi {
                   displayLeakTrace(leak)
                 }
+                if (leak.isNew) {
+                  LeakTable.markAsRead(db, displayedLeak.id)
+                }
               }
         }
       }
     }
-
-    val selectedLeakIndex =
-      if (selectedHeapAnalysisId == null) -1 else leaks.indexOfFirst { it.analysisId == selectedHeapAnalysisId }
-    if (selectedLeakIndex != -1) {
-      spinner.setSelection(selectedLeakIndex)
-    } else {
-      spinner.setSelection(0)
-    }
+    spinner.setSelection(selectedLeakIndex)
   }
 
   private fun View.displayLeakTrace(projection: LeakDetails) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
index f8c1ee403..64e0fa172 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeaksScreen.kt
@@ -39,6 +39,7 @@ internal class LeaksScreen : Screen() {
         val timeView = view.findViewById<TextView>(R.id.leak_canary_time_text)
 
         val projection = projections[position]
+        countView.isEnabled = projection.isNew
 
         countView.text = projection.leakCount.toString()
         descriptionView.text = projection.description
diff --git a/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml b/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml
new file mode 100644
index 000000000..31fc8e291
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/color/leak_canary_count_text.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_enabled="true" android:color="@color/leak_canary_gray_darkest" />
+  <item android:color="@color/leak_canary_yellow" />
+</selector>
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml
new file mode 100644
index 000000000..c78fc7ead
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/drawable/leak_canary_count_background.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+  <item android:state_enabled="true">
+    <shape>
+      <solid android:color="@color/leak_canary_count_new" />
+      <corners android:radius="20dp" />
+      <stroke android:width="2dp" android:color="@color/leak_canary_count_new_border" />
+    </shape>
+  </item>
+  <item>
+    <shape>
+      <solid android:color="@color/leak_canary_count_default" />
+      <corners android:radius="20dp" />
+    </shape>
+  </item>
+</selector>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/drawable/leak_canary_yellow_fill.xml b/leakcanary-android-core/src/main/res/drawable/leak_canary_yellow_fill.xml
deleted file mode 100644
index 7302ba0ab..000000000
--- a/leakcanary-android-core/src/main/res/drawable/leak_canary_yellow_fill.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<shape xmlns:android="http://schemas.android.com/apk/res/android">
-    <solid android:color="@color/leak_canary_yellow_15p" />
-    <corners android:radius="20dp" />
-</shape>
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
index 95c948d30..3c1191789 100644
--- a/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_leak_row.xml
@@ -26,10 +26,10 @@
         android:layout_marginLeft="20dp"
         android:layout_alignParentLeft="true"
         android:layout_centerVertical="true"
-        android:background="@drawable/leak_canary_yellow_fill"
+        android:background="@drawable/leak_canary_count_background"
         android:gravity="center"
         android:padding="16dp"
-        android:textColor="@color/leak_canary_yellow"
+        android:textColor="@color/leak_canary_count_text"
         android:textSize="18sp"
         android:textStyle="bold"
         tools:text="1"
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
index 8a8a1b592..4d0534bf7 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_colors.xml
@@ -21,8 +21,10 @@
   <color name="leak_canary_extra">#919191</color>
   <color name="leak_canary_help">#6a98b9</color>
   <color name="leak_canary_background_color">#242424</color>
-  <color name="leak_canary_yellow">#FFD34C</color>
-  <color name="leak_canary_yellow_15p">#26FFD34C</color>
+  <color name="leak_canary_count_new">#FFD34C</color>
+  <color name="leak_canary_count_new_border">@color/leak_canary_yellow</color>
+  <color name="leak_canary_count_default">#26FFCC32</color>
+  <color name="leak_canary_yellow">#FFCC32</color>
   <color name="leak_canary_yellow_button">#FFE79F</color>
   <color name="leak_canary_yellow_button_pressed">#c4b47f</color>
   <color name="leak_canary_gray_3f">#3F3F3F</color>
