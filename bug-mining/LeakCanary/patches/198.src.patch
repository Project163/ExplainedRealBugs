diff --git a/leakcanary-object-watcher/api/leakcanary-object-watcher.api b/leakcanary-object-watcher/api/leakcanary-object-watcher.api
index b5a6d328c..317c99ec4 100644
--- a/leakcanary-object-watcher/api/leakcanary-object-watcher.api
+++ b/leakcanary-object-watcher/api/leakcanary-object-watcher.api
@@ -19,6 +19,7 @@ public final class leakcanary/GcTrigger$Default : leakcanary/GcTrigger {
 public final class leakcanary/KeyedWeakReference : java/lang/ref/WeakReference {
 	public static final field Companion Lleakcanary/KeyedWeakReference$Companion;
 	public fun <init> (Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;JLjava/lang/ref/ReferenceQueue;)V
+	public fun clear ()V
 	public final fun getDescription ()Ljava/lang/String;
 	public static final fun getHeapDumpUptimeMillis ()J
 	public final fun getKey ()Ljava/lang/String;
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index 0c525ef61..314155e8c 100644
--- a/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -43,6 +43,11 @@ class KeyedWeakReference(
   @Volatile
   var retainedUptimeMillis = -1L
 
+  override fun clear() {
+    super.clear()
+    retainedUptimeMillis = -1L
+  }
+
   companion object {
     @Volatile
     @JvmStatic var heapDumpUptimeMillis = 0L
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index e9ae9b40b..ddfe41fa1 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -39,6 +39,7 @@ import shark.OnAnalysisProgressListener.Step.INSPECTING_OBJECTS
 import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
 import shark.internal.AndroidNativeSizeMapper
 import shark.internal.DominatorTree
+import shark.internal.KeyedWeakReferenceMirror
 import shark.internal.PathFinder
 import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
@@ -157,6 +158,17 @@ class HeapAnalyzer constructor(
     listener.onAnalysisProgress(EXTRACTING_METADATA)
     val metadata = metadataExtractor.extractMetadata(graph)
 
+    val retainedClearedWeakRefCount = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)
+      .filter { it.isRetained && !it.hasReferent }.count()
+
+    // This should rarely happens, as we generally remove all cleared weak refs right before a heap
+    // dump.
+    val metadataWithCount = if (retainedClearedWeakRefCount > 0) {
+      metadata + ("Count of retained yet cleared" to "$retainedClearedWeakRefCount KeyedWeakReference instances")
+    } else {
+      metadata
+    }
+
     listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)
     val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)
 
@@ -166,7 +178,7 @@ class HeapAnalyzer constructor(
       heapDumpFile = heapDumpFile,
       createdAtTimeMillis = System.currentTimeMillis(),
       analysisDurationMillis = since(analysisStartNanoTime),
-      metadata = metadata,
+      metadata = metadataWithCount,
       applicationLeaks = applicationLeaks,
       libraryLeaks = libraryLeaks,
       unreachableObjects = unreachableObjects
diff --git a/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
index 90ef8033b..a98f064ba 100644
--- a/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
+++ b/shark/src/main/java/shark/KeyedWeakReferenceFinder.kt
@@ -10,7 +10,9 @@ import shark.internal.KeyedWeakReferenceMirror
 object KeyedWeakReferenceFinder : LeakingObjectFinder {
 
   override fun findLeakingObjectIds(graph: HeapGraph): Set<Long> =
-    findKeyedWeakReferences(graph).map { it.referent.value }
+    findKeyedWeakReferences(graph)
+      .filter { it.hasReferent && it.isRetained }
+      .map { it.referent.value }
       .toSet()
 
   fun heapDumpUptimeMillis(graph: HeapGraph): Long? {
@@ -49,7 +51,6 @@ object KeyedWeakReferenceFinder : LeakingObjectFinder {
             it, heapDumpUptimeMillis
           )
         }
-        .filter { it.hasReferent }
         .toList()
       graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
       addedToContext
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
index ef9d8b75b..0fefd7781 100644
--- a/shark/src/main/java/shark/ObjectInspectors.kt
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -29,6 +29,7 @@ enum class ObjectInspectors : ObjectInspector {
 
     override val leakingObjectFilter = { heapObject: HeapObject ->
       KeyedWeakReferenceFinder.findKeyedWeakReferences(heapObject.graph)
+        .filter { it.hasReferent && it.isRetained }
         .any { reference ->
           reference.referent.value == heapObject.objectId
         }
