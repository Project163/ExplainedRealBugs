diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
index c66ce8011..c3ced8fdb 100644
--- a/shark-android/src/test/java/shark/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -19,7 +19,7 @@ class LegacyHprofTest {
     val leak2 = analysis.applicationLeaks[1].leakTraces.first()
     assertThat(leak1.leakingObject.className).isEqualTo("android.graphics.Bitmap")
     assertThat(leak2.leakingObject.className).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(analysis.metadata).isEqualTo(
+    assertThat(analysis.metadata).containsAllEntriesOf(
         mapOf(
             "App process name" to "com.example.leakcanary",
             "Build.MANUFACTURER" to "Genymotion",
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index b3cc8b320..61a1437c0 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -134,6 +134,12 @@ class HprofHeapGraph internal constructor(
   // java.lang.Object is the most accessed class in Heap, so we want to memoize a reference to it
   private val javaLangObjectClass: HeapClass? = findClassByName("java.lang.Object")
 
+  /**
+   * This is only public so that we can publish stats. Accessing this requires casting
+   * [HeapGraph] to [HprofHeapGraph] so it's really not a public API. May change at any time!
+   */
+  fun lruCacheStats(): String = objectCache.toString()
+
   override fun findObjectById(objectId: Long): HeapObject {
     return findObjectByIdOrNull(objectId) ?: throw IllegalArgumentException(
         "Object id $objectId not found in heap dump."
diff --git a/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt b/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt
new file mode 100644
index 000000000..c66c8166c
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ConstantMemoryMetricsDualSourceProvider.kt
@@ -0,0 +1,63 @@
+package shark
+
+import okio.Buffer
+import kotlin.math.absoluteValue
+
+/**
+ * Captures IO read metrics without using much memory.
+ */
+class ConstantMemoryMetricsDualSourceProvider(
+  private val realSourceProvider: DualSourceProvider
+) : DualSourceProvider {
+
+  var randomAccessByteReads = 0L
+    internal set
+
+  var randomAccessReadCount = 0L
+    internal set
+
+  var randomAccessByteTravel = 0L
+    internal set
+
+  private var lastRandomAccessPosition = -1L
+  private var minPosition = -1L
+  private var maxPosition = -1L
+
+  private fun updateRandomAccessStatsOnRead(position: Long, bytesRead: Long) {
+    randomAccessByteReads += bytesRead
+    randomAccessReadCount++
+    if (lastRandomAccessPosition != -1L) {
+      randomAccessByteTravel += (position - lastRandomAccessPosition).absoluteValue
+      minPosition = minPosition.coerceAtMost(position)
+      maxPosition = maxPosition.coerceAtLeast(position)
+    } else {
+      minPosition = position
+      maxPosition = position
+    }
+
+
+    lastRandomAccessPosition = position
+  }
+
+  val byteTravelRange
+      get() = (maxPosition - minPosition)
+
+  override fun openStreamingSource() = realSourceProvider.openStreamingSource()
+
+  override fun openRandomAccessSource(): RandomAccessSource {
+    val randomAccessSource = realSourceProvider.openRandomAccessSource()
+    return object : RandomAccessSource {
+      override fun read(
+        sink: Buffer,
+        position: Long,
+        byteCount: Long
+      ): Long {
+        val bytesRead = randomAccessSource.read(sink, position, byteCount)
+        updateRandomAccessStatsOnRead(position, bytesRead)
+        return bytesRead
+      }
+      override fun close() = randomAccessSource.close()
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 8b305c95a..b8c23cb2e 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -92,12 +92,24 @@ class HeapAnalyzer constructor(
 
     return try {
       listener.onAnalysisProgress(PARSING_HEAP_DUMP)
-      heapDumpFile.openHeapGraph(proguardMapping).use { graph ->
+      val sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))
+      sourceProvider.openHeapGraph(proguardMapping).use { graph ->
         val helpers =
           FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)
-        helpers.analyzeGraph(
+        val result = helpers.analyzeGraph(
             metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime
         )
+        val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()
+        val randomAccessStats =
+          "RandomAccess[" +
+              "bytes=${sourceProvider.randomAccessByteReads}," +
+              "reads=${sourceProvider.randomAccessReadCount}," +
+              "travel=${sourceProvider.randomAccessByteTravel}," +
+              "range=${sourceProvider.byteTravelRange}," +
+              "size=${heapDumpFile.length()}" +
+              "]"
+        val stats = "$lruCacheStats $randomAccessStats"
+        result.copy(metadata = result.metadata + ("Stats" to stats))
       }
     } catch (exception: Throwable) {
       HeapAnalysisFailure(
diff --git a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
index 0d06d56bc..a6327de83 100644
--- a/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
+++ b/shark/src/test/java/shark/HeapAnalysisStringRenderingTest.kt
@@ -71,6 +71,7 @@ class HeapAnalysisStringRenderingTest {
       |
       |Please include this in bug reports and Stack Overflow questions.
       |
+      |Stats: .*
       |Analysis duration: \d* ms
       |Heap dump file path: ${hprofFile.absolutePath}
       |Heap dump timestamp: \d*
@@ -113,6 +114,7 @@ class HeapAnalysisStringRenderingTest {
       |
       |Please include this in bug reports and Stack Overflow questions.
       |
+      |Stats: .*
       |Analysis duration: \d* ms
       |Heap dump file path: ${hprofFile.absolutePath}
       |Heap dump timestamp: \d*
diff --git a/shark/src/test/java/shark/MetadataExtractorTest.kt b/shark/src/test/java/shark/MetadataExtractorTest.kt
index 059ea5d7b..54055c762 100644
--- a/shark/src/test/java/shark/MetadataExtractorTest.kt
+++ b/shark/src/test/java/shark/MetadataExtractorTest.kt
@@ -40,6 +40,6 @@ class MetadataExtractorTest {
 
     val metadata = analysis.metadata
 
-    assertThat(metadata).isEqualTo(mapOf("World message" to "Hello"))
+    assertThat(metadata).containsAllEntriesOf(mapOf("World message" to "Hello"))
   }
 }
\ No newline at end of file
