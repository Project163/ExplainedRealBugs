diff --git a/checkstyle.xml b/checkstyle.xml
index 09ae4d940..ce09c3d12 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -111,7 +111,7 @@
     <!--module name="AvoidNestedBlocks"/-->
     <!--module name="EmptyBlock"/-->
     <module name="LeftCurly"/>
-    <!--<module name="NeedBraces"/>-->
+    <module name="NeedBraces"/>
     <module name="RightCurly"/>
 
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 9f49e0ed9..7d879378f 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -34,7 +34,6 @@ import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -331,45 +330,46 @@ public final class HeapAnalyzer {
       node = node.parent;
     }
 
-    Map<LeakTraceElement, Reachability> expectedReachability =
+    List<Reachability> expectedReachability =
         computeExpectedReachability(elements);
 
     return new LeakTrace(elements, expectedReachability);
   }
 
-  private Map<LeakTraceElement, Reachability> computeExpectedReachability(
+  private List<Reachability> computeExpectedReachability(
       List<LeakTraceElement> elements) {
-    int lastAliveElement = 0;
-    int firstDeadElement = elements.size() - 1;
+    int lastReachableElement = 0;
+    int lastElementIndex = elements.size() - 1;
+    int firstUnreachableElement = lastElementIndex;
+    // No need to inspect the first and last element. We know the first should be reachable (gc
+    // root) and the last should be unreachable (watched instance).
     elementLoop:
-    for (int i = 0; i < elements.size(); i++) {
+    for (int i = 1; i < lastElementIndex; i++) {
       LeakTraceElement element = elements.get(i);
 
       for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
         Reachability reachability = reachabilityInspector.expectedReachability(element);
         if (reachability == REACHABLE) {
-          lastAliveElement = i;
+          lastReachableElement = i;
           break;
         } else if (reachability == UNREACHABLE) {
-          firstDeadElement = i;
+          firstUnreachableElement = i;
           break elementLoop;
         }
       }
     }
 
-    Map<LeakTraceElement, Reachability> expectedReachability = new HashMap<>();
+    List<Reachability> expectedReachability = new ArrayList<>();
     for (int i = 0; i < elements.size(); i++) {
-      LeakTraceElement element = elements.get(i);
-
       Reachability status;
-      if (i <= lastAliveElement) {
+      if (i <= lastReachableElement) {
         status = REACHABLE;
-      } else if (i >= firstDeadElement) {
+      } else if (i >= firstUnreachableElement) {
         status = UNREACHABLE;
       } else {
         status = UNKNOWN;
       }
-      expectedReachability.put(element, status);
+      expectedReachability.add(status);
     }
     return expectedReachability;
   }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 559b856ac..6b15fe63a 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -17,7 +17,6 @@ package com.squareup.leakcanary;
 
 import java.io.Serializable;
 import java.util.List;
-import java.util.Map;
 
 /**
  * A chain of references that constitute the shortest strong reference path from a leaking instance
@@ -26,9 +25,9 @@ import java.util.Map;
 public final class LeakTrace implements Serializable {
 
   public final List<LeakTraceElement> elements;
-  public final Map<LeakTraceElement, Reachability> expectedReachability;
+  public final List<Reachability> expectedReachability;
 
-  LeakTrace(List<LeakTraceElement> elements, Map<LeakTraceElement, Reachability> expectedReachability) {
+  LeakTrace(List<LeakTraceElement> elements, List<Reachability> expectedReachability) {
     this.elements = elements;
     this.expectedReachability = expectedReachability;
   }
@@ -42,11 +41,11 @@ public final class LeakTrace implements Serializable {
         sb.append("â†³ ");
       }
       boolean maybeLeakCause = false;
-      Reachability currentReachability = expectedReachability.get(element);
+      Reachability currentReachability = expectedReachability.get(i);
       if (currentReachability == Reachability.UNKNOWN) {
         maybeLeakCause = true;
       } else if (currentReachability == Reachability.REACHABLE) {
-        Reachability nextReachability = expectedReachability.get(elements.get(i + 1));
+        Reachability nextReachability = expectedReachability.get(i + 1);
         if (nextReachability !=  Reachability.REACHABLE) {
           maybeLeakCause = true;
         }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index 5918ad501..b350163bb 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -109,13 +109,13 @@ final class DisplayLeakAdapter extends BaseAdapter {
         boolean isLeakingInstance = position == getCount() - 1;
         LeakTraceElement element = getItem(position);
 
-        Reachability reachability = leakTrace.expectedReachability.get(element);
+        Reachability reachability = leakTrace.expectedReachability.get(elementIndex(position));
         boolean maybeLeakCause;
         if (isLeakingInstance || reachability == Reachability.UNREACHABLE) {
           maybeLeakCause = false;
         } else {
-          LeakTraceElement nextElement = getItem(position + 1);
-          Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+          Reachability nextReachability =
+              leakTrace.expectedReachability.get(elementIndex(position + 1));
           maybeLeakCause = nextReachability != Reachability.REACHABLE;
         }
 
@@ -215,8 +215,8 @@ final class DisplayLeakAdapter extends BaseAdapter {
     if (position == 1) {
       return DisplayLeakConnectorView.Type.HELP;
     } else if (position == 2) {
-      LeakTraceElement nextElement = getItem(position + 1);
-      Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+      Reachability nextReachability =
+          leakTrace.expectedReachability.get(elementIndex(position + 1));
       if (nextReachability != Reachability.REACHABLE) {
         return DisplayLeakConnectorView.Type.START_LAST_REACHABLE;
       }
@@ -224,29 +224,28 @@ final class DisplayLeakAdapter extends BaseAdapter {
     } else {
       boolean isLeakingInstance = position == getCount() - 1;
       if (isLeakingInstance) {
-        LeakTraceElement previousElement = getItem(position - 1);
-        Reachability previousReachability = leakTrace.expectedReachability.get(previousElement);
+        Reachability previousReachability =
+            leakTrace.expectedReachability.get(elementIndex(position - 1));
         if (previousReachability != Reachability.UNREACHABLE) {
           return DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE;
         }
         return DisplayLeakConnectorView.Type.END;
       } else {
-        LeakTraceElement element = getItem(position);
-        Reachability reachability = leakTrace.expectedReachability.get(element);
+        Reachability reachability = leakTrace.expectedReachability.get(elementIndex(position));
         switch (reachability) {
           case UNKNOWN:
             return DisplayLeakConnectorView.Type.NODE_UNKNOWN;
           case REACHABLE:
-            LeakTraceElement nextElement = getItem(position + 1);
-            Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+            Reachability nextReachability =
+                leakTrace.expectedReachability.get(elementIndex(position + 1));
             if (nextReachability != Reachability.REACHABLE) {
               return DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE;
             } else {
               return DisplayLeakConnectorView.Type.NODE_REACHABLE;
             }
           case UNREACHABLE:
-            LeakTraceElement previousElement = getItem(position - 1);
-            Reachability previousReachability = leakTrace.expectedReachability.get(previousElement);
+            Reachability previousReachability =
+                leakTrace.expectedReachability.get(elementIndex(position - 1));
             if (previousReachability != Reachability.UNREACHABLE) {
               return DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE;
             } else {
@@ -290,7 +289,11 @@ final class DisplayLeakAdapter extends BaseAdapter {
     if (position == 1) {
       return null;
     }
-    return leakTrace.elements.get(position - 2);
+    return leakTrace.elements.get(elementIndex(position));
+  }
+
+  private int elementIndex(int position) {
+    return position - 2;
   }
 
   @Override public int getViewTypeCount() {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 26929368d..2a73dfe8a 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -194,51 +194,4 @@ public final class LeakTraceElement implements Serializable {
     }
     return string;
   }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-
-    LeakTraceElement element = (LeakTraceElement) o;
-
-    if (reference != null ? !reference.equals(element.reference) : element.reference != null) {
-      return false;
-    }
-    if (referenceName != null ? !referenceName.equals(element.referenceName)
-        : element.referenceName != null) {
-      return false;
-    }
-    if (type != element.type) return false;
-    if (holder != element.holder) return false;
-    if (classHierarchy != null ? !classHierarchy.equals(element.classHierarchy)
-        : element.classHierarchy != null) {
-      return false;
-    }
-    if (className != null ? !className.equals(element.className) : element.className != null) {
-      return false;
-    }
-    if (extra != null ? !extra.equals(element.extra) : element.extra != null) return false;
-    if (exclusion != null ? !exclusion.equals(element.exclusion) : element.exclusion != null) {
-      return false;
-    }
-    if (fieldReferences != null ? !fieldReferences.equals(element.fieldReferences)
-        : element.fieldReferences != null) {
-      return false;
-    }
-    return fields != null ? fields.equals(element.fields) : element.fields == null;
-  }
-
-  @Override public int hashCode() {
-    int result = reference != null ? reference.hashCode() : 0;
-    result = 31 * result + (referenceName != null ? referenceName.hashCode() : 0);
-    result = 31 * result + (type != null ? type.hashCode() : 0);
-    result = 31 * result + (holder != null ? holder.hashCode() : 0);
-    result = 31 * result + (classHierarchy != null ? classHierarchy.hashCode() : 0);
-    result = 31 * result + (className != null ? className.hashCode() : 0);
-    result = 31 * result + (extra != null ? extra.hashCode() : 0);
-    result = 31 * result + (exclusion != null ? exclusion.hashCode() : 0);
-    result = 31 * result + (fieldReferences != null ? fieldReferences.hashCode() : 0);
-    result = 31 * result + (fields != null ? fields.hashCode() : 0);
-    return result;
-  }
 }
