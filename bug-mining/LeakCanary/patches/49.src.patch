diff --git a/checkstyle.xml b/checkstyle.xml
index ca4ebcc58..09ae4d940 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -83,7 +83,7 @@
       <!--property name="max" value="100"/-->
     <!--/module-->
     <!--module name="MethodLength"/-->
-    <module name="ParameterNumber"/>
+    <!--<module name="ParameterNumber"/>-->
 
 
     <!-- Checks for whitespace                               -->
@@ -111,7 +111,7 @@
     <!--module name="AvoidNestedBlocks"/-->
     <!--module name="EmptyBlock"/-->
     <module name="LeftCurly"/>
-    <module name="NeedBraces"/>
+    <!--<module name="NeedBraces"/>-->
     <module name="RightCurly"/>
 
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 58c9da295..9f49e0ed9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -30,8 +30,11 @@ import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
 import gnu.trove.THashMap;
 import gnu.trove.TObjectProcedure;
 import java.io.File;
+import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -61,6 +64,9 @@ import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
 import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.Reachability.REACHABLE;
+import static com.squareup.leakcanary.Reachability.UNKNOWN;
+import static com.squareup.leakcanary.Reachability.UNREACHABLE;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -72,14 +78,33 @@ public final class HeapAnalyzer {
 
   private final ExcludedRefs excludedRefs;
   private final AnalyzerProgressListener listener;
+  private final List<Reachability.Inspector> reachabilityInspectors;
 
+  /**
+   * @deprecated Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.
+   */
+  @Deprecated
   public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this(excludedRefs, AnalyzerProgressListener.NONE);
+    this(excludedRefs, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
   }
 
-  public HeapAnalyzer(ExcludedRefs excludedRefs, AnalyzerProgressListener listener) {
+  public HeapAnalyzer(ExcludedRefs excludedRefs, AnalyzerProgressListener listener,
+      List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
     this.excludedRefs = excludedRefs;
     this.listener = listener;
+
+    this.reachabilityInspectors = new ArrayList<>();
+    for (Class<? extends Reachability.Inspector> reachabilityInspectorClass
+        : reachabilityInspectorClasses) {
+      try {
+        Constructor<? extends Reachability.Inspector> defaultConstructor =
+            reachabilityInspectorClass.getDeclaredConstructor();
+        reachabilityInspectors.add(defaultConstructor.newInstance());
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
   }
 
   public List<TrackedReference> findTrackedReferences(File heapDumpFile) {
@@ -114,6 +139,7 @@ public final class HeapAnalyzer {
 
   /**
    * Calls {@link #checkForLeak(File, String, boolean)} with computeRetainedSize set to true.
+   *
    * @deprecated Use {@link #checkForLeak(File, String, boolean)} instead.
    */
   @Deprecated
@@ -304,7 +330,48 @@ public final class HeapAnalyzer {
       }
       node = node.parent;
     }
-    return new LeakTrace(elements);
+
+    Map<LeakTraceElement, Reachability> expectedReachability =
+        computeExpectedReachability(elements);
+
+    return new LeakTrace(elements, expectedReachability);
+  }
+
+  private Map<LeakTraceElement, Reachability> computeExpectedReachability(
+      List<LeakTraceElement> elements) {
+    int lastAliveElement = 0;
+    int firstDeadElement = elements.size() - 1;
+    elementLoop:
+    for (int i = 0; i < elements.size(); i++) {
+      LeakTraceElement element = elements.get(i);
+
+      for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
+        Reachability reachability = reachabilityInspector.expectedReachability(element);
+        if (reachability == REACHABLE) {
+          lastAliveElement = i;
+          break;
+        } else if (reachability == UNREACHABLE) {
+          firstDeadElement = i;
+          break elementLoop;
+        }
+      }
+    }
+
+    Map<LeakTraceElement, Reachability> expectedReachability = new HashMap<>();
+    for (int i = 0; i < elements.size(); i++) {
+      LeakTraceElement element = elements.get(i);
+
+      Reachability status;
+      if (i <= lastAliveElement) {
+        status = REACHABLE;
+      } else if (i >= firstDeadElement) {
+        status = UNREACHABLE;
+      } else {
+        status = UNKNOWN;
+      }
+      expectedReachability.put(element, status);
+    }
+    return expectedReachability;
   }
 
   private LeakTraceElement buildLeakElement(LeakNode node) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
index 607db22c1..559b856ac 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
@@ -16,10 +16,8 @@
 package com.squareup.leakcanary;
 
 import java.io.Serializable;
-import java.util.ArrayList;
 import java.util.List;
-
-import static java.util.Collections.unmodifiableList;
+import java.util.Map;
 
 /**
  * A chain of references that constitute the shortest strong reference path from a leaking instance
@@ -28,9 +26,11 @@ import static java.util.Collections.unmodifiableList;
 public final class LeakTrace implements Serializable {
 
   public final List<LeakTraceElement> elements;
+  public final Map<LeakTraceElement, Reachability> expectedReachability;
 
-  LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(new ArrayList<>(elements));
+  LeakTrace(List<LeakTraceElement> elements, Map<LeakTraceElement, Reachability> expectedReachability) {
+    this.elements = elements;
+    this.expectedReachability = expectedReachability;
   }
 
   @Override public String toString() {
@@ -38,14 +38,20 @@ public final class LeakTrace implements Serializable {
     for (int i = 0; i < elements.size(); i++) {
       LeakTraceElement element = elements.get(i);
       sb.append("* ");
-      if (i == 0) {
-        sb.append("GC ROOT ");
-      } else if (i == elements.size() - 1) {
-        sb.append("leaks ");
-      } else {
-        sb.append("references ");
+      if (i != 0) {
+        sb.append("â†³ ");
+      }
+      boolean maybeLeakCause = false;
+      Reachability currentReachability = expectedReachability.get(element);
+      if (currentReachability == Reachability.UNKNOWN) {
+        maybeLeakCause = true;
+      } else if (currentReachability == Reachability.REACHABLE) {
+        Reachability nextReachability = expectedReachability.get(elements.get(i + 1));
+        if (nextReachability !=  Reachability.REACHABLE) {
+          maybeLeakCause = true;
+        }
       }
-      sb.append(element).append("\n");
+      sb.append(element.toString(maybeLeakCause)).append("\n");
     }
     return sb.toString();
   }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
index 0e6937d5a..319ee285b 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -32,7 +32,8 @@ public class HeapAnalyzerTest {
 
   @Before
   public void setUp() {
-    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
   }
 
   @Test
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
index fad9f3ec9..40c8470e7 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -17,6 +17,7 @@ package com.squareup.leakcanary;
 
 import java.io.File;
 import java.net.URL;
+import java.util.Collections;
 import java.util.List;
 
 final class TestUtil {
@@ -46,7 +47,8 @@ final class TestUtil {
 
   static List<TrackedReference> findTrackedReferences(HeapDumpFile heapDumpFile) {
     File file = fileFromName(heapDumpFile.filename);
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS, AnalyzerProgressListener.NONE,
+        Collections.<Class<? extends Reachability.Inspector>>emptyList());
     return heapAnalyzer.findTrackedReferences(file);
   }
 
@@ -54,7 +56,9 @@ final class TestUtil {
       ExcludedRefs.BuilderWithParams excludedRefs) {
     File file = fileFromName(heapDumpFile.filename);
     String referenceKey = heapDumpFile.referenceKey;
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(excludedRefs.build(), AnalyzerProgressListener.NONE,
+            Collections.<Class<? extends Reachability.Inspector>>emptyList());
     AnalysisResult result =
         heapAnalyzer.checkForLeak(file, referenceKey, true);
     if (result.failure != null) {
diff --git a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
index c1eb0c6f4..def1e7811 100644
--- a/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
+++ b/leakcanary-android-instrumentation/src/main/java/com/squareup/leakcanary/InstrumentationLeakDetector.java
@@ -168,8 +168,10 @@ public final class InstrumentationLeakDetector {
       return InstrumentationLeakResults.NONE;
     }
 
-    ExcludedRefs excludedRefs = refWatcher.getExcludedRefs();
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs);
+    HeapDump.Builder heapDumpBuilder = refWatcher.getHeapDumpBuilder();
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(heapDumpBuilder.excludedRefs, AnalyzerProgressListener.NONE,
+            heapDumpBuilder.reachabilityInspectorClasses);
 
     List<TrackedReference> trackedReferences = heapAnalyzer.findTrackedReferences(heapDumpFile);
 
@@ -183,10 +185,14 @@ public final class InstrumentationLeakDetector {
         continue;
       }
 
-      HeapDump.Durations durations = new HeapDump.Durations(0, 0, 0);
-      HeapDump heapDump =
-          new HeapDump(heapDumpFile, trackedReference.key, trackedReference.name, excludedRefs,
-              false, durations);
+      HeapDump heapDump = HeapDump.builder()
+          .heapDumpFile(heapDumpFile)
+          .referenceKey(trackedReference.key)
+          .referenceName(trackedReference.name)
+          .excludedRefs(heapDumpBuilder.excludedRefs)
+          .reachabilityInspectorClasses(heapDumpBuilder.reachabilityInspectorClasses)
+          .build();
+
       AnalysisResult analysisResult =
           heapAnalyzer.checkForLeak(heapDumpFile, trackedReference.key, false);
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
new file mode 100644
index 000000000..b1387067b
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Dialog;
+import android.app.Fragment;
+import android.os.MessageQueue;
+import android.view.View;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A set of default {@link Reachability.Inspector}s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knownledge of AOSP and various library
+ * internals. We only make a reachability decision if we're reasonably sure such reachability is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+public enum AndroidReachabilityInspectors {
+
+  VIEW(ViewInspector.class),
+
+  ACTIVITY(ActivityInspector.class),
+
+  DIALOG(DialogInspector.class),
+
+  APPLICATION(ApplicationInspector.class),
+
+  FRAGMENT(FragmentInspector.class),
+
+  SUPPORT_FRAGMENT(SupportFragmentInspector.class),
+
+  MESSAGE_QUEUE(MessageQueueInspector.class),
+
+  MORTAR_PRESENTER(MortarPresenterInspector.class),
+
+  //
+  ;
+
+  private final Class<? extends Reachability.Inspector> inspectorClass;
+
+  AndroidReachabilityInspectors(Class<? extends Reachability.Inspector> inspectorClass) {
+    this.inspectorClass = inspectorClass;
+  }
+
+  public static List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
+    List<Class<? extends Reachability.Inspector>> inspectorClasses = new ArrayList<>();
+    for (AndroidReachabilityInspectors enumValue : AndroidReachabilityInspectors.values()) {
+      inspectorClasses.add(enumValue.inspectorClass);
+    }
+    return inspectorClasses;
+  }
+
+  public static class ViewInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf(View.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mAttachInfo = element.getFieldReferenceValue("mAttachInfo");
+      if (mAttachInfo == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mAttachInfo.equals("null") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class ActivityInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf(Activity.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDestroyed = element.getFieldReferenceValue("mDestroyed");
+      if (mDestroyed == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDestroyed.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class DialogInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf(Dialog.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDecor = element.getFieldReferenceValue("mDecor");
+      if (mDecor == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDecor.equals("null") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class ApplicationInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (element.isInstanceOf(Application.class)) {
+        return Reachability.REACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class FragmentInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf(Fragment.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mDetached = element.getFieldReferenceValue("mDetached");
+      if (mDetached == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDetached.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class SupportFragmentInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf("android.support.v4.app.Fragment")) {
+        return Reachability.UNKNOWN;
+      }
+      String mDetached = element.getFieldReferenceValue("mDetached");
+      if (mDetached == null) {
+        return Reachability.UNKNOWN;
+      }
+      return mDetached.equals("true") ? Reachability.UNREACHABLE : Reachability.REACHABLE;
+    }
+  }
+
+  public static class MessageQueueInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf(MessageQueue.class)) {
+        return Reachability.UNKNOWN;
+      }
+      String mQuitting = element.getFieldReferenceValue("mQuitting");
+      // If the queue is not quitting, maybe it should actually have been, we don't know.
+      // However, if it's quitting, it is very likely that's not a bug.
+      if ("true".equals(mQuitting)) {
+        return Reachability.UNREACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+  public static class MortarPresenterInspector implements Reachability.Inspector {
+    @Override public Reachability expectedReachability(LeakTraceElement element) {
+      if (!element.isInstanceOf("mortar.Presenter")) {
+        return Reachability.UNKNOWN;
+      }
+      String view = element.getFieldReferenceValue("view");
+
+      // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+      // should be a unreachable, so in that case we don't know their reachability status. However,
+      // when the view is null, we're pretty sure they should be unreachable.
+      if ("null".equals(view)) {
+        return Reachability.UNREACHABLE;
+      }
+      return Reachability.UNKNOWN;
+    }
+  }
+
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index a2fefc105..2ba0dba64 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -3,6 +3,7 @@ package com.squareup.leakcanary;
 import android.content.Context;
 import com.squareup.leakcanary.internal.FragmentRefWatcher;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import static com.squareup.leakcanary.RefWatcher.DISABLED;
@@ -121,4 +122,8 @@ public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRef
   @Override protected WatchExecutor defaultWatchExecutor() {
     return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
   }
+
+  @Override protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+    return AndroidReachabilityInspectors.defaultAndroidInspectors();
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 3ac0f6036..cba2fdb3a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -128,11 +128,7 @@ public class DisplayLeakService extends AbstractAnalysisResultService {
       CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
           newFile.getPath());
     }
-    HeapDump.Durations durations =
-        new HeapDump.Durations(heapDump.watchDurationMs, heapDump.gcDurationMs,
-            heapDump.heapDumpDurationMs);
-    return new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName,
-        heapDump.excludedRefs, heapDump.computeRetainedHeapSize, durations);
+    return heapDump.buildUpon().heapDumpFile(newFile).build();
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index 5c7ae3b03..3901ce290 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -309,7 +309,7 @@ public final class DisplayLeakActivity extends Activity {
         if (listAdapter instanceof DisplayLeakAdapter) {
           adapter = (DisplayLeakAdapter) listAdapter;
         } else {
-          adapter = new DisplayLeakAdapter();
+          adapter = new DisplayLeakAdapter(getResources());
           listView.setAdapter(adapter);
           listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index 4e71b4f14..5918ad501 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -16,7 +16,11 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
+import android.content.res.Resources;
+import android.support.annotation.ColorRes;
 import android.text.Html;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -26,12 +30,8 @@ import com.squareup.leakcanary.Exclusion;
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
+import com.squareup.leakcanary.Reachability;
 
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
 
 final class DisplayLeakAdapter extends BaseAdapter {
@@ -41,10 +41,29 @@ final class DisplayLeakAdapter extends BaseAdapter {
 
   private boolean[] opened = new boolean[0];
 
-  private List<LeakTraceElement> elements = Collections.emptyList();
+  private LeakTrace leakTrace = null;
   private String referenceKey;
   private String referenceName = "";
 
+  private final String classNameColorHexString;
+  private final String leakColorHexString;
+  private final String referenceColorHexString;
+  private final String extraColorHexString;
+  private final String helpColorHexString;
+
+  DisplayLeakAdapter(Resources resources) {
+    classNameColorHexString = hexStringColor(resources, R.color.leak_canary_class_name);
+    leakColorHexString = hexStringColor(resources, R.color.leak_canary_leak);
+    referenceColorHexString = hexStringColor(resources, R.color.leak_canary_reference);
+    extraColorHexString = hexStringColor(resources, R.color.leak_canary_extra);
+    helpColorHexString = hexStringColor(resources, R.color.leak_canary_help);
+  }
+
+  // https://stackoverflow.com/a/6540378/703646
+  private static String hexStringColor(Resources resources, @ColorRes int colorResId) {
+    return String.format("#%06X", (0xFFFFFF & resources.getColor(colorResId)));
+  }
+
   @Override public View getView(int position, View convertView, ViewGroup parent) {
     Context context = parent.getContext();
     if (getItemViewType(position) == TOP_ROW) {
@@ -59,98 +78,185 @@ final class DisplayLeakAdapter extends BaseAdapter {
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
 
-      boolean isRoot = position == 1;
-      boolean isLeakingInstance = position == getCount() - 1;
-      LeakTraceElement element = getItem(position);
-      String htmlString = elementToHtmlString(element, isRoot, opened[position]);
-      if (isLeakingInstance && !referenceName.equals("") && opened[position]) {
-        htmlString += " <font color='#919191'>" + referenceName + "</font>";
+      TextView titleView = findById(convertView, R.id.leak_canary_row_title);
+      TextView detailView = findById(convertView, R.id.leak_canary_row_details);
+      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
+      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
+
+      connector.setType(getConnectorType(position));
+      moreDetailsView.setOpened(opened[position]);
+
+      if (opened[position]) {
+        detailView.setVisibility(View.VISIBLE);
+      } else {
+        detailView.setVisibility(View.GONE);
       }
-      textView.setText(Html.fromHtml(htmlString));
 
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      if (isRoot) {
-        connector.setType(DisplayLeakConnectorView.Type.START);
+      Resources resources = convertView.getResources();
+      if (position == 1) {
+        titleView.setText(Html.fromHtml("<font color='"
+            + helpColorHexString
+            + "'>"
+            + "<b>" + resources.getString(R.string.leak_canary_help_title) + "</b>"
+            + "</font>"));
+        SpannableStringBuilder detailText =
+            (SpannableStringBuilder) Html.fromHtml(
+                resources.getString(R.string.leak_canary_help_detail));
+        SquigglySpan.replaceUnderlineSpans(detailText, resources);
+        detailView.setText(detailText);
       } else {
-        if (isLeakingInstance) {
-          connector.setType(DisplayLeakConnectorView.Type.END);
+        boolean isLeakingInstance = position == getCount() - 1;
+        LeakTraceElement element = getItem(position);
+
+        Reachability reachability = leakTrace.expectedReachability.get(element);
+        boolean maybeLeakCause;
+        if (isLeakingInstance || reachability == Reachability.UNREACHABLE) {
+          maybeLeakCause = false;
         } else {
-          connector.setType(DisplayLeakConnectorView.Type.NODE);
+          LeakTraceElement nextElement = getItem(position + 1);
+          Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+          maybeLeakCause = nextReachability != Reachability.REACHABLE;
+        }
+
+        Spanned htmlTitle =
+            htmlTitle(element, maybeLeakCause, resources);
+
+        titleView.setText(htmlTitle);
+
+        if (opened[position]) {
+          Spanned htmlDetail = htmlDetails(isLeakingInstance, element);
+          detailView.setText(htmlDetail);
         }
       }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-      moreDetailsView.setOpened(opened[position]);
     }
 
     return convertView;
   }
 
-  private String elementToHtmlString(LeakTraceElement element, boolean root, boolean opened) {
+  private Spanned htmlTitle(LeakTraceElement element, boolean maybeLeakCause, Resources resources) {
     String htmlString = "";
 
-    if (element.referenceName == null) {
-      htmlString += "leaks ";
-    } else if (!root) {
-      htmlString += "references ";
-    }
+    String simpleName = element.getSimpleClassName();
+    simpleName = simpleName.replace("[]", "[ ]");
 
-    if (element.type == STATIC_FIELD) {
-      htmlString += "<font color='#c48a47'>static</font> ";
-    }
+    String styledClassName =
+        "<font color='" + classNameColorHexString + "'>" + simpleName + "</font>";
 
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      htmlString += "<font color='#f3cf83'>" + element.holder.name().toLowerCase() + "</font> ";
-    }
+    if (element.reference != null) {
+      String referenceName = element.reference.getDisplayName().replaceAll("<", "&lt;")
+          .replaceAll(">", "&gt;");
 
-    int separator = element.className.lastIndexOf('.');
-    String qualifier;
-    String simpleName;
-    if (separator == -1) {
-      qualifier = "";
-      simpleName = element.className;
-    } else {
-      qualifier = element.className.substring(0, separator + 1);
-      simpleName = element.className.substring(separator + 1);
-    }
+      if (maybeLeakCause) {
+        referenceName =
+            "<u><font color='" + leakColorHexString + "'>" + referenceName + "</font></u>";
+      } else {
+        referenceName =
+            "<font color='" + referenceColorHexString + "'>" + referenceName + "</font>";
+      }
 
-    if (opened) {
-      htmlString += "<font color='#919191'>" + qualifier + "</font>";
-    }
+      if (element.reference.type == STATIC_FIELD) {
+        referenceName = "<i>" + referenceName + "</i>";
+      }
 
-    String styledClassName = "<font color='#ffffff'>" + simpleName + "</font>";
+      String classAndReference = styledClassName + "." + referenceName;
 
-    htmlString += styledClassName;
+      if (maybeLeakCause) {
+        classAndReference = "<b>" + classAndReference + "</b>";
+      }
 
-    if (element.referenceName != null) {
-      htmlString += ".<font color='#998bb5'>" + element.referenceName.replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;") + "</font>";
+      htmlString += classAndReference;
     } else {
-      htmlString += " <font color='#f3cf83'>instance</font>";
+      htmlString += styledClassName;
+    }
+
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      htmlString += " (excluded)";
     }
+    SpannableStringBuilder builder = (SpannableStringBuilder) Html.fromHtml(htmlString);
+    if (maybeLeakCause) {
+      SquigglySpan.replaceUnderlineSpans(builder, resources);
+    }
+
+    return builder;
+  }
 
-    if (opened && element.extra != null) {
-      htmlString += " <font color='#919191'>" + element.extra + "</font>";
+  private Spanned htmlDetails(boolean isLeakingInstance, LeakTraceElement element) {
+    String htmlString = "";
+    if (element.extra != null) {
+      htmlString += " <font color='" + extraColorHexString + "'>" + element.extra + "</font>";
     }
 
     Exclusion exclusion = element.exclusion;
     if (exclusion != null) {
-      if (opened) {
-        htmlString += "<br/><br/>Excluded by rule";
-        if (exclusion.name != null) {
-          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-        }
-        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-        if (exclusion.reason != null) {
-          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+      htmlString += "<br/><br/>Excluded by rule";
+      if (exclusion.name != null) {
+        htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+      }
+      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+      if (exclusion.reason != null) {
+        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+      }
+    }
+    htmlString += "<br>"
+        + "<font color='" + extraColorHexString + "'>"
+        + element.toDetailedString().replace("\n", "<br>")
+        + "</font>";
+
+    if (isLeakingInstance && !referenceName.equals("")) {
+      htmlString += " <font color='" + extraColorHexString + "'>" + referenceName + "</font>";
+    }
+
+    return Html.fromHtml(htmlString);
+  }
+
+  private DisplayLeakConnectorView.Type getConnectorType(int position) {
+    if (position == 1) {
+      return DisplayLeakConnectorView.Type.HELP;
+    } else if (position == 2) {
+      LeakTraceElement nextElement = getItem(position + 1);
+      Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+      if (nextReachability != Reachability.REACHABLE) {
+        return DisplayLeakConnectorView.Type.START_LAST_REACHABLE;
+      }
+      return DisplayLeakConnectorView.Type.START;
+    } else {
+      boolean isLeakingInstance = position == getCount() - 1;
+      if (isLeakingInstance) {
+        LeakTraceElement previousElement = getItem(position - 1);
+        Reachability previousReachability = leakTrace.expectedReachability.get(previousElement);
+        if (previousReachability != Reachability.UNREACHABLE) {
+          return DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE;
         }
+        return DisplayLeakConnectorView.Type.END;
       } else {
-        htmlString += " (excluded)";
+        LeakTraceElement element = getItem(position);
+        Reachability reachability = leakTrace.expectedReachability.get(element);
+        switch (reachability) {
+          case UNKNOWN:
+            return DisplayLeakConnectorView.Type.NODE_UNKNOWN;
+          case REACHABLE:
+            LeakTraceElement nextElement = getItem(position + 1);
+            Reachability nextReachability = leakTrace.expectedReachability.get(nextElement);
+            if (nextReachability != Reachability.REACHABLE) {
+              return DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE;
+            } else {
+              return DisplayLeakConnectorView.Type.NODE_REACHABLE;
+            }
+          case UNREACHABLE:
+            LeakTraceElement previousElement = getItem(position - 1);
+            Reachability previousReachability = leakTrace.expectedReachability.get(previousElement);
+            if (previousReachability != Reachability.UNREACHABLE) {
+              return DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE;
+            } else {
+              return DisplayLeakConnectorView.Type.NODE_UNREACHABLE;
+            }
+          default:
+            throw new IllegalStateException("Unknown value: " + reachability);
+        }
       }
     }
-
-    return htmlString;
   }
 
   public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
@@ -160,8 +266,8 @@ final class DisplayLeakAdapter extends BaseAdapter {
     }
     this.referenceKey = referenceKey;
     this.referenceName = referenceName;
-    this.elements = new ArrayList<>(leakTrace.elements);
-    opened = new boolean[1 + elements.size()];
+    this.leakTrace = leakTrace;
+    opened = new boolean[2 + leakTrace.elements.size()];
     notifyDataSetChanged();
   }
 
@@ -171,14 +277,20 @@ final class DisplayLeakAdapter extends BaseAdapter {
   }
 
   @Override public int getCount() {
-    return 1 + elements.size();
+    if (leakTrace == null) {
+      return 2;
+    }
+    return 2 + leakTrace.elements.size();
   }
 
   @Override public LeakTraceElement getItem(int position) {
     if (getItemViewType(position) == TOP_ROW) {
       return null;
     }
-    return elements.get(position - 1);
+    if (position == 1) {
+      return null;
+    }
+    return leakTrace.elements.get(position - 2);
   }
 
   @Override public int getViewTypeCount() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
index e854ac2ac..3bafb82b9 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
@@ -16,46 +16,81 @@
 package com.squareup.leakcanary.internal;
 
 import android.content.Context;
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.DashPathEffect;
 import android.graphics.Paint;
+import android.graphics.PorterDuffXfermode;
 import android.util.AttributeSet;
 import android.view.View;
+import com.squareup.leakcanary.R;
 
 import static android.graphics.Bitmap.Config.ARGB_8888;
+import static android.graphics.PorterDuff.Mode.CLEAR;
 
 public final class DisplayLeakConnectorView extends View {
 
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
-    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
-  }
+  private static final float SQRT_TWO = (float) Math.sqrt(2);
+  private static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
 
   public enum Type {
-    START, NODE, END
+    HELP,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE,
   }
 
+  private final Paint classNamePaint;
+  private final Paint leakPaint;
+  private final Paint clearPaint;
+  private final Paint referencePaint;
+  private final float strokeSize;
+  private final float circleY;
+
   private Type type;
   private Bitmap cache;
 
   public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
     super(context, attrs);
 
-    type = Type.NODE;
+    Resources resources = getResources();
+
+    type = Type.NODE_UNKNOWN;
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y);
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size);
+
+    classNamePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    classNamePaint.setColor(resources.getColor(R.color.leak_canary_class_name));
+    classNamePaint.setStrokeWidth(strokeSize);
+
+    leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    leakPaint.setColor(resources.getColor(R.color.leak_canary_leak));
+    leakPaint.setStyle(Paint.Style.STROKE);
+    leakPaint.setStrokeWidth(strokeSize);
+    float pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line);
+    float pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap);
+    leakPaint.setPathEffect(new DashPathEffect(new float[] { pathLines, pathGaps }, 0));
+
+    clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    clearPaint.setColor(Color.TRANSPARENT);
+    clearPaint.setXfermode(CLEAR_XFER_MODE);
+
+    referencePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    referencePaint.setColor(resources.getColor(R.color.leak_canary_reference));
+    referencePaint.setStrokeWidth(strokeSize);
   }
 
   @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
 
     if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
       cache.recycle();
@@ -67,40 +102,111 @@ public final class DisplayLeakConnectorView extends View {
 
       Canvas cacheCanvas = new Canvas(cache);
 
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3f;
-
-      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
-
-      iconPaint.setStrokeWidth(strokeSize);
-      rootPaint.setStrokeWidth(strokeSize);
-
       switch (type) {
-        case NODE:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+        case NODE_UNKNOWN:
+          drawItems(cacheCanvas, leakPaint, leakPaint);
           break;
-        case START:
-          float radiusClear = halfWidth - strokeSize / 2f;
-          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
+        case NODE_UNREACHABLE:
+        case NODE_REACHABLE:
+          drawItems(cacheCanvas, referencePaint, referencePaint);
           break;
-        default:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
+        case NODE_FIRST_UNREACHABLE:
+          drawItems(cacheCanvas, leakPaint, referencePaint);
+          break;
+        case NODE_LAST_REACHABLE:
+          drawItems(cacheCanvas, referencePaint, leakPaint);
+          break;
+        case START: {
+          drawStartLine(cacheCanvas);
+          drawItems(cacheCanvas, null, referencePaint);
+          break;
+        }
+        case START_LAST_REACHABLE:
+          drawStartLine(cacheCanvas);
+          drawItems(cacheCanvas, null, leakPaint);
+          break;
+        case END:
+          drawItems(cacheCanvas, referencePaint, null);
           break;
+        case END_FIRST_UNREACHABLE:
+          drawItems(cacheCanvas, leakPaint, null);
+          break;
+        case HELP:
+          drawRoot(cacheCanvas);
+          break;
+        default:
+          throw new UnsupportedOperationException("Unknown type " + type);
       }
     }
     canvas.drawBitmap(cache, 0, 0, null);
   }
 
+  private void drawStartLine(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    float halfWidth = width / 2f;
+    float halfHeight = getMeasuredHeight() / 2f;
+    cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, classNamePaint);
+  }
+
+  private void drawRoot(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    int height = getMeasuredHeight();
+    float halfWidth = width / 2f;
+    float radiusClear = halfWidth - strokeSize / 2f;
+    cacheCanvas.drawRect(0, 0, width, radiusClear, classNamePaint);
+    cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
+    cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
+    cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, classNamePaint);
+  }
+
+  private void drawItems(Canvas cacheCanvas, Paint arrowHeadPaint, Paint nextArrowPaint) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint);
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint);
+    }
+    drawInstanceCircle(cacheCanvas);
+  }
+
+  private void drawArrowHead(Canvas cacheCanvas, Paint paint) {
+    // Circle center is at half height
+    int width = getMeasuredWidth();
+    float halfWidth = width / 2f;
+    float centerX = halfWidth;
+    float circleRadius = width / 3f;
+    float arrowSideLength = halfWidth;
+    // Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    float arrowHeight = (arrowSideLength / 2) * SQRT_TWO;
+    float halfStrokeSize = strokeSize / 2;
+    float translateY = circleY - arrowHeight - (circleRadius * 2) - strokeSize;
+
+    float lineYEnd = circleY - circleRadius - (strokeSize / 2);
+    cacheCanvas.drawLine(centerX, 0, centerX, lineYEnd, paint);
+    cacheCanvas.translate(centerX, translateY);
+    cacheCanvas.rotate(45);
+    cacheCanvas.drawLine(0, arrowSideLength, arrowSideLength + halfStrokeSize, arrowSideLength,
+        paint);
+    cacheCanvas.drawLine(arrowSideLength, 0, arrowSideLength, arrowSideLength, paint);
+    cacheCanvas.rotate(-45);
+    cacheCanvas.translate(-centerX, -translateY);
+  }
+
+  private void drawNextArrowLine(Canvas cacheCanvas, Paint paint) {
+    int height = getMeasuredHeight();
+    int width = getMeasuredWidth();
+    float centerX = width / 2f;
+    cacheCanvas.drawLine(centerX, circleY, centerX, height, paint);
+  }
+
+  private void drawInstanceCircle(Canvas cacheCanvas) {
+    int width = getMeasuredWidth();
+    float circleX = width / 2f;
+    float circleRadius = width / 3f;
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint);
+  }
+
   public void setType(Type type) {
     if (type != this.type) {
       this.type = type;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index db900687b..b8af2f01b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -60,7 +60,8 @@ public final class HeapAnalyzerService extends ForegroundService
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
 
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs, this);
+    HeapAnalyzer heapAnalyzer =
+        new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);
 
     AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
         heapDump.computeRetainedHeapSize);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
deleted file mode 100644
index 74fbf9861..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.PorterDuffXfermode;
-import android.util.DisplayMetrics;
-
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-final class LeakCanaryUi {
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  /**
-   * Converts from device independent pixels (dp or dip) to
-   * device dependent pixels. This method returns the input
-   * multiplied by the display's density. The result is not
-   * rounded nor clamped.
-   *
-   * The value returned by this method is well suited for
-   * drawing with the Canvas API but should not be used to
-   * set layout dimensions.
-   *
-   * @param dp The value in dp to convert to pixels
-   * @param resources An instances of Resources
-   */
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    return metrics.density * dp;
-  }
-
-  private LeakCanaryUi() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
index 81bf8a0f3..c88e5dcf6 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
@@ -15,25 +15,37 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Paint;
 import android.util.AttributeSet;
 import android.view.View;
+import com.squareup.leakcanary.R;
 
 public final class MoreDetailsView extends View {
 
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-  }
+  private final Paint iconPaint;
 
   public MoreDetailsView(Context context, AttributeSet attrs) {
     super(context, attrs);
-
-    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
+    Resources resources = getResources();
+    iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    float strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width);
     iconPaint.setStrokeWidth(strokeSize);
+
+    // This lint check doesn't work for libraries which have a common prefix.
+    @SuppressLint("CustomViewStyleable") //
+        TypedArray a =
+        context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView);
+    int plusColor =
+        a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK);
+    a.recycle();
+
+    iconPaint.setColor(plusColor);
   }
 
   private boolean opened;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
new file mode 100644
index 000000000..f552716d3
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+import com.squareup.leakcanary.R;
+
+public class RowElementLayout extends ViewGroup {
+
+  private final int connectorWidth;
+  private final int rowMargins;
+  private final int moreSize;
+  private final int minHeight;
+  private final int titleMarginTop;
+  private final int moreMarginTop;
+
+  private View connector;
+  private View moreButton;
+  private View title;
+  private View details;
+
+  public RowElementLayout(Context context, AttributeSet attrs) {
+    super(context, attrs);
+    Resources resources = getResources();
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width);
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins);
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size);
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min);
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top);
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top);
+  }
+
+  @Override protected void onFinishInflate() {
+    super.onFinishInflate();
+    connector = findViewById(R.id.leak_canary_row_connector);
+    moreButton = findViewById(R.id.leak_canary_row_more);
+    title = findViewById(R.id.leak_canary_row_title);
+    details = findViewById(R.id.leak_canary_row_details);
+  }
+
+  @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+    int availableWidth = MeasureSpec.getSize(widthMeasureSpec);
+    int titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins;
+    int titleWidthSpec = MeasureSpec.makeMeasureSpec(titleWidth, MeasureSpec.AT_MOST);
+    int titleHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+    title.measure(titleWidthSpec, titleHeightSpec);
+
+    int moreSizeSpec = MeasureSpec.makeMeasureSpec(moreSize, MeasureSpec.EXACTLY);
+    moreButton.measure(moreSizeSpec, moreSizeSpec);
+
+    int totalHeight = titleMarginTop + title.getMeasuredHeight();
+
+    int detailsWidth = availableWidth - connectorWidth - 3 * rowMargins;
+    int detailsWidthSpec = MeasureSpec.makeMeasureSpec(detailsWidth, MeasureSpec.AT_MOST);
+    int detailsHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+    details.measure(detailsWidthSpec, detailsHeightSpec);
+    if (details.getVisibility() != GONE) {
+      totalHeight += details.getMeasuredHeight();
+    }
+    totalHeight = Math.max(totalHeight, minHeight);
+
+    int connectorWidthSpec = MeasureSpec.makeMeasureSpec(connectorWidth, MeasureSpec.EXACTLY);
+    int connectorHeightSpec = MeasureSpec.makeMeasureSpec(totalHeight, MeasureSpec.EXACTLY);
+
+    connector.measure(connectorWidthSpec, connectorHeightSpec);
+    setMeasuredDimension(availableWidth, totalHeight);
+  }
+
+  @Override protected void onLayout(boolean changed, int l, int t, int r, int b) {
+    int width = getMeasuredWidth();
+    int connectorRight = rowMargins + connector.getMeasuredWidth();
+    connector.layout(rowMargins, 0, connectorRight, connector.getMeasuredHeight());
+
+    moreButton.layout(width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
+        moreMarginTop + moreSize);
+
+    int titleLeft = connectorRight + rowMargins;
+    int titleBottom = titleMarginTop + title.getMeasuredHeight();
+    title.layout(titleLeft, titleMarginTop, titleLeft + title.getMeasuredWidth(), titleBottom);
+
+    if (details.getVisibility() != GONE) {
+      details.layout(titleLeft, titleBottom, width - rowMargins,
+          titleBottom + details.getMeasuredHeight());
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
new file mode 100644
index 000000000..31a2cfee0
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.text.SpannableStringBuilder;
+import android.text.style.ReplacementSpan;
+import android.text.style.UnderlineSpan;
+import com.squareup.leakcanary.R;
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+class SquigglySpan extends ReplacementSpan {
+
+
+  public static void replaceUnderlineSpans(SpannableStringBuilder builder, Resources resources) {
+    UnderlineSpan[] underlineSpans = builder.getSpans(0, builder.length(), UnderlineSpan.class);
+    for (UnderlineSpan span : underlineSpans) {
+      int start = builder.getSpanStart(span);
+      int end = builder.getSpanEnd(span);
+      builder.removeSpan(span);
+      builder.setSpan(new SquigglySpan(resources), start, end, 0);
+    }
+  }
+
+  private final Paint squigglyPaint;
+  private final Path path;
+  private final int referenceColor;
+  private final float halfStrokeWidth;
+  private final float amplitude;
+  private final float halfWaveHeight;
+  private final float periodDegrees;
+
+  private int width;
+
+  SquigglySpan(Resources resources) {
+    squigglyPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    squigglyPaint.setStyle(Paint.Style.STROKE);
+    squigglyPaint.setColor(resources.getColor(R.color.leak_canary_leak));
+    float strokeWidth =
+        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width);
+    squigglyPaint.setStrokeWidth(strokeWidth);
+
+    halfStrokeWidth = strokeWidth / 2;
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude);
+    periodDegrees =
+        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees);
+    path = new Path();
+    float waveHeight = 2 * amplitude + strokeWidth;
+    halfWaveHeight = waveHeight / 2;
+    referenceColor = resources.getColor(R.color.leak_canary_reference);
+  }
+
+  @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end,
+      @Nullable Paint.FontMetricsInt fm) {
+    width = (int) paint.measureText(text, start, end);
+    return width;
+  }
+
+  @Override
+  public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top,
+      int y, int bottom, @NonNull Paint paint) {
+    squigglyHorizontalPath(path,
+        x + halfStrokeWidth,
+        x + width - halfStrokeWidth,
+        bottom - halfWaveHeight,
+        amplitude, periodDegrees);
+    canvas.drawPath(path, squigglyPaint);
+
+    paint.setColor(referenceColor);
+    canvas.drawText(text, start, end, x, y, paint);
+  }
+
+  private static void squigglyHorizontalPath(Path path, float left, float right, float centerY,
+      float amplitude,
+      float periodDegrees) {
+    path.reset();
+
+    float y;
+    path.moveTo(left, centerY);
+    float period = (float) (2 * Math.PI / periodDegrees);
+
+    for (float x = 0; x <= right - left; x += 1) {
+      y = (float) (amplitude * Math.sin(40 + period * x) + centerY);
+      path.lineTo(left + x, y);
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index 8e56c3d12..9dde79741 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -18,7 +18,7 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:orientation="vertical"
-    android:background="#3c3c3c"
+    android:background="@color/leak_canary_background_color"
     >
   <ListView
       android:id="@+id/leak_canary_display_leak_list"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
index 947af46c4..2f1996a33 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
@@ -14,36 +14,39 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<com.squareup.leakcanary.internal.RowElementLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:orientation="horizontal"
+    android:id="@+id/leak_canary_row_layout"
+    android:clipChildren="false"
     >
 
   <com.squareup.leakcanary.internal.DisplayLeakConnectorView
       android:id="@+id/leak_canary_row_connector"
-      android:layout_width="16dp"
-      android:layout_height="match_parent"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      />
+
+  <com.squareup.leakcanary.internal.MoreDetailsView
+      android:id="@+id/leak_canary_row_more"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      lib:leak_canary_plus_color="@color/leak_canary_class_name"
       />
 
   <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
+      android:id="@+id/leak_canary_row_title"
+      android:layout_width="wrap_content"
       android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
       />
 
-  <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="12dp"
-      android:layout_height="12dp"
-      android:layout_gravity="center_vertical"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
+  <TextView
+      android:id="@+id/leak_canary_row_details"
+      android:layout_width="wrap_content"
+      android:layout_height="wrap_content"
+      android:visibility="gone"
       />
 
-</LinearLayout>
+</com.squareup.leakcanary.internal.RowElementLayout>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
index c4803b762..4d70df540 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -21,7 +21,7 @@
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
     android:textSize="18sp"
-    android:background="#84a6c5"
+    android:background="@color/leak_canary_class_name"
     android:padding="16dp"
-    android:textColor="#ffffff"
+    android:textColor="@color/leak_canary_background_color"
     />
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
index 40b9ce7ff..111874fd2 100644
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -44,4 +44,23 @@
     <string name="leak_canary_permission_not_granted">Bitte gewÃ¤hre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
     <string name="leak_canary_permission_notification_title">Leak erkannt, benÃ¶tige Berechtigung</string>
     <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung fÃ¼r %s zu aktivieren.</string>
+    <string name="leak_canary_help_title">Tap here to learn more</string>
+    <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
+  your application to keep a reference to an object that is no longer needed. As a result, the
+  memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError
+  crash.<br>
+  <br>For instance, an Android activity instance is no longer needed after its <i>onDestroy()</i>
+  method is called, and storing a reference to that activity in a static field would prevent it from
+  being garbage collected.<br>
+  <br>
+  LeakCanary identifies an object that is longer needed and finds the chain of
+  <font color=\'#9976a8\'>references</font> that prevents it from being garbage collected.<br>
+  <br>
+  To fix a memory leak, you need to look at that chain and find which reference is causing the
+  leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights
+  with a red underline wave the <b><u><font color=\'#9976a8\'>references</font></u></b> that are the
+  possible causes of the leak.<br>
+  <br>
+  Tap on each reference row for more details, tap again to close.
+]]></string>
 </resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_attrs.xml b/leakcanary-android/src/main/res/values/leak_canary_attrs.xml
new file mode 100644
index 000000000..092508ba4
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_attrs.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <declare-styleable name="leak_canary_MoreDetailsView">
+    <attr name="leak_canary_plus_color" format="color" />
+  </declare-styleable>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_colors.xml b/leakcanary-android/src/main/res/values/leak_canary_colors.xml
new file mode 100644
index 000000000..2d44e3841
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_colors.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <color name="leak_canary_class_name">#bababa</color>
+  <color name="leak_canary_leak">#be383f</color>
+  <color name="leak_canary_reference">#9976a8</color>
+  <color name="leak_canary_extra">#919191</color>
+  <color name="leak_canary_help">#6a98b9</color>
+  <color name="leak_canary_background_color">#2b2b2b</color>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_dimens.xml b/leakcanary-android/src/main/res/values/leak_canary_dimens.xml
new file mode 100644
index 000000000..f9cbdfb4e
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_dimens.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2018 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+  <dimen name="leak_canary_squiggly_span_stroke_width">1dp</dimen>
+  <dimen name="leak_canary_squiggly_span_amplitude">1dp</dimen>
+  <!-- DP because the period increased with the density. -->
+  <dimen name="leak_canary_squiggly_span_period_degrees">4dp</dimen>
+  <dimen name="leak_canary_connector_center_y">24dp</dimen>
+  <dimen name="leak_canary_connector_stroke_size">2dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_line">5dp</dimen>
+  <dimen name="leak_canary_connector_leak_dash_gap">1dp</dimen>
+  <dimen name="leak_canary_more_stroke_width">2dp</dimen>
+  <dimen name="leak_canary_connector_width">16dp</dimen>
+  <dimen name="leak_canary_row_margins">16dp</dimen>
+  <dimen name="leak_canary_more_size">12dp</dimen>
+  <dimen name="leak_canary_more_margin_top">18dp</dimen>
+  <dimen name="leak_canary_row_min">48dp</dimen>
+  <dimen name="leak_canary_row_title_margin_top">14.5dp</dimen>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index ff66160d5..b4faa52d0 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -45,4 +45,23 @@
   <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
   <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
   <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+  <string name="leak_canary_help_title">Tap here to learn more</string>
+  <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
+  your application to keep a reference to an object that is no longer needed. As a result, the
+  memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError
+  crash.<br>
+  <br>For instance, an Android activity instance is no longer needed after its <i>onDestroy()</i>
+  method is called, and storing a reference to that activity in a static field would prevent it from
+  being garbage collected.<br>
+  <br>
+  LeakCanary identifies an object that is longer needed and finds the chain of
+  <font color=\'#9976a8\'>references</font> that prevents it from being garbage collected.<br>
+  <br>
+  To fix a memory leak, you need to look at that chain and find which reference is causing the
+  leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights
+  with a red underline wave the <b><u><font color=\'#9976a8\'>references</font></u></b> that are the
+  possible causes of the leak.<br>
+  <br>
+  Tap on each reference row for more details, tap again to close.
+]]></string>
 </resources>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java b/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java
new file mode 100644
index 000000000..58569fe9a
--- /dev/null
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/HttpRequestHelper.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.leakcanary;
+
+import android.view.View;
+
+/**
+ * Fake class for the purpose of demonstrating a leak.
+ */
+public class HttpRequestHelper {
+
+  private final View button;
+
+  HttpRequestHelper(View button) {
+    this.button = button;
+  }
+}
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index 12b7dc17c..93a43378d 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -23,6 +23,8 @@ import android.view.View;
 
 public class MainActivity extends Activity {
 
+  private HttpRequestHelper httpRequestHelper;
+
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     setContentView(R.layout.main_activity);
@@ -33,6 +35,15 @@ public class MainActivity extends Activity {
         startAsyncWork();
       }
     });
+
+    httpRequestHelper = (HttpRequestHelper) getLastNonConfigurationInstance();
+    if (httpRequestHelper == null) {
+      httpRequestHelper = new HttpRequestHelper(button);
+    }
+  }
+
+  @Override public Object onRetainNonConfigurationInstance() {
+    return httpRequestHelper;
   }
 
   @SuppressLint("StaticFieldLeak")
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index e65f4f096..4d8968357 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -19,8 +19,7 @@
     tools:ignore="MissingTranslation" >
   <string name="app_name">LeakCanary Sample</string>
   <string name="start_async_work">Start new async work</string>
-  <string name="helper_text">Start the async work, <b>rotate the screen</b> and wait for a bit. A
-    wild notification appears.
-  </string>
+  <string name="helper_text">There are two example leaks you can trigger: 1) Rotate the screen and
+    wait. 2) Start the async work, <b>rotate the screen</b> and wait.</string>
   <string name="leak_canary_display_activity_label">Leaks Sample</string>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index f73546d30..48a8d5a03 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -17,12 +17,19 @@ package com.squareup.leakcanary;
 
 import java.io.File;
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static java.util.Collections.unmodifiableList;
 
 /** Data structure holding information about a heap dump. */
 public final class HeapDump implements Serializable {
 
+  public static Builder builder() {
+    return new Builder();
+  }
+
   /** Receives a heap dump to analyze. */
   public interface Listener {
     Listener NONE = new Listener() {
@@ -58,45 +65,130 @@ public final class HeapDump implements Serializable {
   public final long gcDurationMs;
   public final long heapDumpDurationMs;
   public final boolean computeRetainedHeapSize;
+  public final List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
 
   /**
-   * Calls {@link #HeapDump(File, String, String, ExcludedRefs, boolean, Durations)}
-   * with computeRetainedHeapSize set to true.
+   * Calls {@link #HeapDump(Builder)} with computeRetainedHeapSize set to true.
    *
-   * @deprecated Use
-   * {@link #HeapDump(File, String, String, ExcludedRefs, boolean, Durations)}  instead.
+   * @deprecated Use {@link #HeapDump(Builder)}  instead.
    */
   @Deprecated
   public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
       ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this(heapDumpFile, referenceKey, referenceName, excludedRefs, true,
-        new Durations(watchDurationMs, gcDurationMs, heapDumpDurationMs));
+    this(new Builder().heapDumpFile(heapDumpFile)
+        .referenceKey(referenceKey)
+        .referenceName(referenceName)
+        .excludedRefs(excludedRefs)
+        .computeRetainedHeapSize(true)
+        .watchDurationMs(watchDurationMs)
+        .gcDurationMs(gcDurationMs)
+        .heapDumpDurationMs(heapDumpDurationMs));
   }
 
-  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      ExcludedRefs excludedRefs, boolean computeRetainedHeapSize, Durations durations) {
-    this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-    this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-    this.referenceName = checkNotNull(referenceName, "referenceName");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.computeRetainedHeapSize = computeRetainedHeapSize;
-    this.watchDurationMs = durations.watchDurationMs;
-    this.gcDurationMs = durations.gcDurationMs;
-    this.heapDumpDurationMs = durations.heapDumpDurationMs;
+  HeapDump(Builder builder) {
+    this.heapDumpFile = builder.heapDumpFile;
+    this.referenceKey = builder.referenceKey;
+    this.referenceName = builder.referenceName;
+    this.excludedRefs = builder.excludedRefs;
+    this.computeRetainedHeapSize = builder.computeRetainedHeapSize;
+    this.watchDurationMs = builder.watchDurationMs;
+    this.gcDurationMs = builder.gcDurationMs;
+    this.heapDumpDurationMs = builder.heapDumpDurationMs;
+    this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses;
   }
 
-  /**
-   * A group of duration related parameters required when constructing a {@link HeapDump} instance.
-   */
-  public static final class Durations {
-    final long watchDurationMs;
-    final long gcDurationMs;
-    final long heapDumpDurationMs;
+  public Builder buildUpon() {
+    return new Builder(this);
+  }
+
+  public static final class Builder {
+    File heapDumpFile;
+    String referenceKey;
+    String referenceName;
+    ExcludedRefs excludedRefs;
+    long watchDurationMs;
+    long gcDurationMs;
+    long heapDumpDurationMs;
+    boolean computeRetainedHeapSize;
+    List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses;
+
+    Builder() {
+      this.heapDumpFile = null;
+      this.referenceKey = null;
+      referenceName = "";
+      excludedRefs = ExcludedRefs.builder().build();
+      watchDurationMs = 0;
+      gcDurationMs = 0;
+      heapDumpDurationMs = 0;
+      computeRetainedHeapSize = false;
+      reachabilityInspectorClasses = null;
+    }
+
+    Builder(HeapDump heapDump) {
+      this.heapDumpFile = heapDump.heapDumpFile;
+      this.referenceKey = heapDump.referenceKey;
+      this.referenceName = heapDump.referenceName;
+      this.excludedRefs = heapDump.excludedRefs;
+      this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize;
+      this.watchDurationMs = heapDump.watchDurationMs;
+      this.gcDurationMs = heapDump.gcDurationMs;
+      this.heapDumpDurationMs = heapDump.heapDumpDurationMs;
+      this.reachabilityInspectorClasses = heapDump.reachabilityInspectorClasses;
+    }
+
+    public Builder heapDumpFile(File heapDumpFile) {
+      this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
+      return this;
+    }
+
+    public Builder referenceKey(String referenceKey) {
+      this.referenceKey = checkNotNull(referenceKey, "referenceKey");
+      return this;
+    }
 
-    public Durations(long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+    public Builder referenceName(String referenceName) {
+      this.referenceName = checkNotNull(referenceName, "referenceName");
+      return this;
+    }
+
+    public Builder excludedRefs(ExcludedRefs excludedRefs) {
+      this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
+      return this;
+    }
+
+    public Builder watchDurationMs(long watchDurationMs) {
       this.watchDurationMs = watchDurationMs;
+      return this;
+    }
+
+    public Builder gcDurationMs(long gcDurationMs) {
       this.gcDurationMs = gcDurationMs;
+      return this;
+    }
+
+    public Builder heapDumpDurationMs(long heapDumpDurationMs) {
       this.heapDumpDurationMs = heapDumpDurationMs;
+      return this;
+    }
+
+    public Builder computeRetainedHeapSize(boolean computeRetainedHeapSize) {
+      this.computeRetainedHeapSize = computeRetainedHeapSize;
+      return this;
+    }
+
+    public Builder reachabilityInspectorClasses(
+        List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
+      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+      this.reachabilityInspectorClasses =
+          unmodifiableList(new ArrayList<>(reachabilityInspectorClasses));
+      return this;
+    }
+
+    public HeapDump build() {
+      checkNotNull(heapDumpFile, "heapDumpFile");
+      checkNotNull(referenceKey, "referenceKey");
+      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
+      return new HeapDump(this);
     }
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakReference.java
similarity index 100%
rename from leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakReference.java
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
similarity index 53%
rename from leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
rename to leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 5c1392ab2..714becda2 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -38,7 +38,10 @@ public final class LeakTraceElement implements Serializable {
     OBJECT, CLASS, THREAD, ARRAY
   }
 
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
+  /**
+   * Information about the reference that points to the next {@link LeakTraceElement} in the leak
+   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   */
   public final LeakReference reference;
 
   /**
@@ -98,7 +101,53 @@ public final class LeakTraceElement implements Serializable {
     fields = Collections.unmodifiableList(stringFields);
   }
 
+  /**
+   * Returns the string value of the first field reference that has the provided referenceName, or
+   * null if no field reference with that name was found.
+   */
+  public String getFieldReferenceValue(String referenceName) {
+    for (LeakReference fieldReference : fieldReferences) {
+      if (fieldReference.name.equals(referenceName)) {
+        return fieldReference.value;
+      }
+    }
+    return null;
+  }
+
+  /** @see #isInstanceOf(String) */
+  public boolean isInstanceOf(Class<?> expectedClass) {
+    return isInstanceOf(expectedClass.getName());
+  }
+
+  /**
+   * Returns true if this element is an instance of the provided class name, false otherwise.
+   */
+  public boolean isInstanceOf(String expectedClassName) {
+    for (String className : classHierarchy) {
+      if (className.equals(expectedClassName)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns {@link #className} without the package.
+   */
+  public String getSimpleClassName() {
+    int separator = className.lastIndexOf('.');
+    if (separator == -1) {
+      return className;
+    } else {
+      return className.substring(separator + 1);
+    }
+  }
+
   @Override public String toString() {
+    return toString(false);
+  }
+
+  public String toString(boolean maybeLeakCause) {
     String string = "";
 
     if (reference != null && reference.type == STATIC_FIELD) {
@@ -109,12 +158,14 @@ public final class LeakTraceElement implements Serializable {
       string += holder.name().toLowerCase(US) + " ";
     }
 
-    string += classHierarchy.get(0);
+    string += getSimpleClassName();
 
     if (reference != null) {
-      string += "." + reference.getDisplayName();
-    } else {
-      string += " instance";
+      String referenceName = reference.getDisplayName();
+      if (maybeLeakCause) {
+        referenceName = "âš " + referenceName + "âš ";
+      }
+      string += "." + referenceName;
     }
 
     if (extra != null) {
@@ -143,4 +194,51 @@ public final class LeakTraceElement implements Serializable {
     }
     return string;
   }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    LeakTraceElement element = (LeakTraceElement) o;
+
+    if (reference != null ? !reference.equals(element.reference) : element.reference != null) {
+      return false;
+    }
+    if (referenceName != null ? !referenceName.equals(element.referenceName)
+        : element.referenceName != null) {
+      return false;
+    }
+    if (type != element.type) return false;
+    if (holder != element.holder) return false;
+    if (classHierarchy != null ? !classHierarchy.equals(element.classHierarchy)
+        : element.classHierarchy != null) {
+      return false;
+    }
+    if (className != null ? !className.equals(element.className) : element.className != null) {
+      return false;
+    }
+    if (extra != null ? !extra.equals(element.extra) : element.extra != null) return false;
+    if (exclusion != null ? !exclusion.equals(element.exclusion) : element.exclusion != null) {
+      return false;
+    }
+    if (fieldReferences != null ? !fieldReferences.equals(element.fieldReferences)
+        : element.fieldReferences != null) {
+      return false;
+    }
+    return fields != null ? fields.equals(element.fields) : element.fields == null;
+  }
+
+  @Override public int hashCode() {
+    int result = reference != null ? reference.hashCode() : 0;
+    result = 31 * result + (referenceName != null ? referenceName.hashCode() : 0);
+    result = 31 * result + (type != null ? type.hashCode() : 0);
+    result = 31 * result + (holder != null ? holder.hashCode() : 0);
+    result = 31 * result + (classHierarchy != null ? classHierarchy.hashCode() : 0);
+    result = 31 * result + (className != null ? className.hashCode() : 0);
+    result = 31 * result + (extra != null ? extra.hashCode() : 0);
+    result = 31 * result + (exclusion != null ? exclusion.hashCode() : 0);
+    result = 31 * result + (fieldReferences != null ? fieldReferences.hashCode() : 0);
+    result = 31 * result + (fields != null ? fields.hashCode() : 0);
+    return result;
+  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java
new file mode 100644
index 000000000..ea46c4d10
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Reachability.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+/** Result returned by {@link Inspector#expectedReachability(LeakTraceElement)}. */
+public enum Reachability {
+  /** The instance was needed and therefore expected to be reachable. */
+  REACHABLE,
+
+  /** The instance was no longer needed and therefore expected to be unreachable. */
+  UNREACHABLE,
+
+  /** No decision can be made about the provided instance. */
+  UNKNOWN;
+
+  /**
+   * Evaluates whether a {@link LeakTraceElement} should be reachable or not.
+   *
+   * Implementations should have a public zero argument constructor as instances will be created
+   * via reflection in the LeakCanary analysis process.
+   */
+  public interface Inspector {
+
+    Reachability expectedReachability(LeakTraceElement element);
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 7e19a8958..c3d27a1cf 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -42,22 +42,19 @@ public final class RefWatcher {
   private final DebuggerControl debuggerControl;
   private final GcTrigger gcTrigger;
   private final HeapDumper heapDumper;
+  private final HeapDump.Listener heapdumpListener;
+  private final HeapDump.Builder heapDumpBuilder;
   private final Set<String> retainedKeys;
   private final ReferenceQueue<Object> queue;
-  private final HeapDump.Listener heapdumpListener;
-  private final ExcludedRefs excludedRefs;
-  private final boolean computeRetainedHeapSize;
 
   RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs,
-      boolean computeRetainedHeapSize) {
+      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, HeapDump.Builder heapDumpBuilder) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
     this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
     this.heapDumper = checkNotNull(heapDumper, "heapDumper");
     this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.computeRetainedHeapSize = computeRetainedHeapSize;
+    this.heapDumpBuilder = heapDumpBuilder;
     retainedKeys = new CopyOnWriteArraySet<>();
     queue = new ReferenceQueue<>();
   }
@@ -106,8 +103,8 @@ public final class RefWatcher {
     return retainedKeys.isEmpty();
   }
 
-  ExcludedRefs getExcludedRefs() {
-    return excludedRefs;
+  HeapDump.Builder getHeapDumpBuilder() {
+    return heapDumpBuilder;
   }
 
   Set<String> getRetainedKeys() {
@@ -148,11 +145,15 @@ public final class RefWatcher {
         return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-      HeapDump.Durations durations =
-          new HeapDump.Durations(watchDurationMs, gcDurationMs, heapDumpDurationMs);
-      heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs,
-              computeRetainedHeapSize, durations));
+
+      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
+          .referenceName(reference.name)
+          .watchDurationMs(watchDurationMs)
+          .gcDurationMs(gcDurationMs)
+          .heapDumpDurationMs(heapDumpDurationMs)
+          .build();
+
+      heapdumpListener.analyze(heapDump);
     }
     return DONE;
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index 0c631f420..866e35c49 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -1,18 +1,24 @@
 package com.squareup.leakcanary;
 
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Responsible for building {@link RefWatcher} instances. Subclasses should provide sane defaults
  * for the platform they support.
  */
 public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
 
-  private ExcludedRefs excludedRefs;
   private HeapDump.Listener heapDumpListener;
   private DebuggerControl debuggerControl;
   private HeapDumper heapDumper;
   private WatchExecutor watchExecutor;
   private GcTrigger gcTrigger;
-  private boolean computeRetainedHeapSize;
+  private final HeapDump.Builder heapDumpBuilder;
+
+  public RefWatcherBuilder() {
+    heapDumpBuilder = new HeapDump.Builder();
+  }
 
   /** @see HeapDump.Listener */
   public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
@@ -22,7 +28,7 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
 
   /** @see ExcludedRefs */
   public final T excludedRefs(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
+    heapDumpBuilder.excludedRefs(excludedRefs);
     return self();
   }
 
@@ -50,12 +56,19 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
     return self();
   }
 
+  /** @see Reachability.Inspector */
+  public final T stethoscopeClasses(
+      List<Class<? extends Reachability.Inspector>> stethoscopeClasses) {
+    heapDumpBuilder.reachabilityInspectorClasses(stethoscopeClasses);
+    return self();
+  }
+
   /**
    * Whether LeakCanary should compute the retained heap size when a leak is detected. False by
    * default, because computing the retained heap size takes a long time.
    */
   public final T computeRetainedHeapSize(boolean computeRetainedHeapSize) {
-    this.computeRetainedHeapSize = computeRetainedHeapSize;
+    heapDumpBuilder.computeRetainedHeapSize(computeRetainedHeapSize);
     return self();
   }
 
@@ -65,9 +78,8 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
       return RefWatcher.DISABLED;
     }
 
-    ExcludedRefs excludedRefs = this.excludedRefs;
-    if (excludedRefs == null) {
-      excludedRefs = defaultExcludedRefs();
+    if (heapDumpBuilder.excludedRefs == null) {
+      heapDumpBuilder.excludedRefs(defaultExcludedRefs());
     }
 
     HeapDump.Listener heapDumpListener = this.heapDumpListener;
@@ -95,8 +107,12 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
       gcTrigger = defaultGcTrigger();
     }
 
+    if (heapDumpBuilder.reachabilityInspectorClasses == null) {
+      heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());
+    }
+
     return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
-        excludedRefs, computeRetainedHeapSize);
+        heapDumpBuilder);
   }
 
   protected boolean isDisabled() {
@@ -127,6 +143,10 @@ public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
     return WatchExecutor.NONE;
   }
 
+  protected List<Class<? extends Reachability.Inspector>> defaultReachabilityInspectorClasses() {
+    return Collections.emptyList();
+  }
+
   @SuppressWarnings("unchecked")
   protected final T self() {
     return (T) this;
