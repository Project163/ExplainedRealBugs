diff --git a/build.gradle b/build.gradle
index 40783c4d6..61410c4ca 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,41 +2,42 @@ apply plugin: 'com.github.ben-manes.versions'
 
 buildscript {
   ext.versions = [
-      'minSdk'    : 14,
+      'minSdk': 14,
       'compileSdk': 29,
       'errorProne': '2.3.1',
-      'kotlin'    : '1.3.50',
+      'kotlin': '1.3.50',
   ]
   ext.deps = [
-      assertj_core  : 'org.assertj:assertj-core:3.9.1',
+      assertj_core: 'org.assertj:assertj-core:3.9.1',
       // We don't need the latest version of AndroidX (there are no bugs that impact what LeakCanary
       // relies on), we're sticking a bit older because most apps will be using a more recent version
       // and they'll automatically resolve to higher version without having to necessarily resort to a
       // resolution strategy.
-      androidx      : [
+      androidGradlePlugin: "com.android.tools.build:gradle:3.5.2",
+      androidx: [
           annotation: 'androidx.annotation:annotation:1.0.2',
           core: 'androidx.core:core:1.0.1',
-          fragment  : 'androidx.fragment:fragment:1.0.0',
-          test      : [
-              core    : 'androidx.test:core:1.0.0',
+          fragment: 'androidx.fragment:fragment:1.0.0',
+          test: [
+              core: 'androidx.test:core:1.0.0',
               espresso: 'androidx.test.espresso:espresso-core:3.1.0',
-              rules   : 'androidx.test:rules:1.1.0',
-              runner  : 'androidx.test:runner:1.1.0',
+              rules: 'androidx.test:rules:1.1.0',
+              runner: 'androidx.test:runner:1.1.0',
           ],
       ],
       android_support: 'com.android.support:support-v4:28.0.0',
-      junit         : 'junit:junit:4.12',
-      kotlin        : [
+      clikt: 'com.github.ajalt:clikt:2.3.0',
+      detekt: 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.2.1',
+      junit: 'junit:junit:4.12',
+      kotlin: [
           gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
-          stdlib      : "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
+          stdlib: "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
       ],
-      detekt        : 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.2.1',
-      mockito       : 'org.mockito:mockito-core:2.7.5',
+      mockito: 'org.mockito:mockito-core:2.7.5',
       mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
       okio: 'com.squareup.okio:okio:2.2.2',
       okio_1x: 'com.squareup.okio:okio:1.0.0',
-      robolectric   : 'org.robolectric:robolectric:4.0-alpha-3',
-      androidGradlePlugin: "com.android.tools.build:gradle:3.5.2"
+      robolectric: 'org.robolectric:robolectric:4.0-alpha-3',
   ]
   repositories {
     google()
diff --git a/docs/shark.md b/docs/shark.md
index 9e6fdffcc..c4ba7cb29 100644
--- a/docs/shark.md
+++ b/docs/shark.md
@@ -39,33 +39,37 @@ Usage instructions:
 ```
 $ ./bin/shark-cli
 
-Shark CLI
-
-                 ^`.                 .=""=.
- ^_              \  \               / _  _ \
- \ \             {   \             |  d  b  |
- {  \           /     `~~~--__     \   /\   /
- {   \___----~~'              `~~-_/'-=\/=-'\,
-  \                         /// a  `~.      \ \
-  / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
-  \/      \/    `~~~;   ,---~~-_`/ \        / \/
-                   /   /            '.    .'
-                  '._.'             _|`~~`|_
-                                    /|\  /|\
-
-Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
-
-analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
-  USAGE: analyze-process PROCESS_PACKAGE_NAME
-
-dump-process: Dumps the heap for the provided process name and pulls the hprof file.
-  USAGE: dump-process PROCESS_PACKAGE_NAME
-
-analyze-hprof: Analyzes the provided hprof file.
-  USAGE: analyze-hprof HPROF_FILE_PATH
-
-strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes.
-  USAGE: strip-hprof HPROF_FILE_PATH
+Usage: shark-cli [OPTIONS] COMMAND [ARGS]...
+
+                   ^`.                 .=""=.
+   ^_              \  \               / _  _ \
+   \ \             {   \             |  d  b  |
+   {  \           /     `~~~--__     \   /\   /
+   {   \___----~~'              `~~-_/'-=\/=-'\,
+    \                         /// a  `~.      \ \
+    / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+    \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                     /   /            '.    .'
+                    '._.'             _|`~~`|_
+                                      /|\  /|\
+
+Options:
+  -h, --help  Show this message and exit
+
+Commands:
+  analyze-process  Dumps the heap for the provided partial PROCESS_NAME, pulls
+                   the hprof file and analyzes it. (Usage: shark-cli
+                   analyze-process [--device ID --obfuscation-mapping PATH]
+                   PROCESS_NAME)
+  dump-process     Dumps the heap for the provided partial PROCESS_NAME and
+                   pulls the hprof file. (Usage: shark-cli dump-process
+                   [--device ID] PROCESS_NAME)
+  analyze-hprof    Analyzes the provided HPROF_FILE_PATH. (Usage: shark-cli
+                   analyze-hprof [--obfuscation-mapping PATH] HPROF_FILE_PATH)
+  strip-hprof      Replaces all primitive arrays from the provided
+                   HPROF_FILE_PATH with arrays of zeroes and generates a new
+                   "-stripped.hprof" file. (Usage: shark-cli strip-hprof
+                   HPROF_FILE_PATH)
 ```
 
 ## Shark code examples
diff --git a/shark-cli.sh b/shark-cli.sh
new file mode 100755
index 000000000..ed8b746a2
--- /dev/null
+++ b/shark-cli.sh
@@ -0,0 +1,2 @@
+./gradlew --quiet :shark-cli:installDist
+./shark-cli/build/install/shark-cli/bin/shark-cli "$@"
\ No newline at end of file
diff --git a/shark-cli/build.gradle b/shark-cli/build.gradle
index 533e9f793..a4340f85b 100644
--- a/shark-cli/build.gradle
+++ b/shark-cli/build.gradle
@@ -8,6 +8,7 @@ targetCompatibility = JavaVersion.VERSION_1_7
 dependencies {
   api project(':shark-android')
 
+  implementation deps.clikt
   implementation deps.kotlin.stdlib
 }
 
diff --git a/shark-cli/src/main/java/shark/AnalyzeHprof.kt b/shark-cli/src/main/java/shark/AnalyzeHprof.kt
new file mode 100644
index 000000000..419b2eec8
--- /dev/null
+++ b/shark-cli/src/main/java/shark/AnalyzeHprof.kt
@@ -0,0 +1,68 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.types.file
+import shark.SharkCli.Companion.SHARK_CLI_COMMAND
+import shark.SharkCli.Companion.USAGE_HELP_TAG
+import java.io.File
+
+class AnalyzeHprof : CliktCommand(
+    name = COMMAND,
+    help = "Analyzes the provided $HPROF_ARG_NAME.",
+    helpTags = mapOf(
+        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$MAPPING_USAGE] $HPROF_ARG_NAME"
+    ),
+    printHelpOnEmptyArgs = true
+) {
+
+  private val heapDumpFile by argument(name = HPROF_ARG_NAME, help = HPROF_HELP).file()
+
+  private val obfuscationMappingPath by option(
+      names = *MAPPING_OPTION_NAMES, help = MAPPING_OPTION_HELP
+  ).file()
+
+  override fun run() {
+    analyze(heapDumpFile, obfuscationMappingPath)
+  }
+
+  companion object {
+    private const val COMMAND = "analyze-hprof"
+
+    const val HPROF_ARG_NAME = "HPROF_FILE_PATH"
+    const val HPROF_HELP = "Path to a .hprof file"
+
+    val MAPPING_OPTION_NAMES = arrayOf("-m", "--obfuscation-mapping")
+    const val MAPPING_OPTION_HELP = "path to obfuscation mapping file"
+    const val MAPPING_USAGE = "--obfuscation-mapping PATH"
+
+    fun analyze(
+      heapDumpFile: File,
+      proguardMappingFile: File?
+    ) {
+      val listener = OnAnalysisProgressListener { step ->
+        SharkLog.d { step.name }
+      }
+
+      val proguardMapping = proguardMappingFile?.let {
+        ProguardMappingReader(it.inputStream()).readProguardMapping()
+      }
+
+      val heapAnalyzer = HeapAnalyzer(listener)
+      SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+      val heapAnalysis = heapAnalyzer.analyze(
+          heapDumpFile = heapDumpFile,
+          leakingObjectFinder = FilteringLeakingObjectFinder(
+              AndroidObjectInspectors.appLeakingObjectFilters
+          ),
+          referenceMatchers = AndroidReferenceMatchers.appDefaults,
+          computeRetainedHeapSize = true,
+          objectInspectors = AndroidObjectInspectors.appDefaults,
+          proguardMapping = proguardMapping
+      )
+
+      SharkLog.d { heapAnalysis.toString() }
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/AnalyzeProcess.kt b/shark-cli/src/main/java/shark/AnalyzeProcess.kt
new file mode 100644
index 000000000..c609d5ffd
--- /dev/null
+++ b/shark-cli/src/main/java/shark/AnalyzeProcess.kt
@@ -0,0 +1,48 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.types.file
+import shark.AnalyzeHprof.Companion
+import shark.AnalyzeHprof.Companion.MAPPING_OPTION_HELP
+import shark.AnalyzeHprof.Companion.MAPPING_OPTION_NAMES
+import shark.AnalyzeHprof.Companion.MAPPING_USAGE
+import shark.DumpProcess.Companion.DEVICE_METAVAR
+import shark.DumpProcess.Companion.DEVICE_OPTION_HELP
+import shark.DumpProcess.Companion.DEVICE_OPTION_NAMES
+import shark.DumpProcess.Companion.DEVICE_USAGE
+import shark.DumpProcess.Companion.PROCESS_NAME_ARG_NAME
+import shark.DumpProcess.Companion.PROCESS_NAME_HELP
+import shark.SharkCli.Companion.SHARK_CLI_COMMAND
+import shark.SharkCli.Companion.USAGE_HELP_TAG
+
+class AnalyzeProcess : CliktCommand(
+    name = COMMAND,
+    help = "Dumps the heap for the provided partial $PROCESS_NAME_ARG_NAME, pulls the hprof file and analyzes it.",
+    helpTags = mapOf(
+        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$DEVICE_USAGE $MAPPING_USAGE] $PROCESS_NAME_ARG_NAME"
+    ),
+    printHelpOnEmptyArgs = true
+) {
+
+  private val processName by argument(name = PROCESS_NAME_ARG_NAME, help = PROCESS_NAME_HELP)
+
+  private val device by option(
+      *DEVICE_OPTION_NAMES, metavar = DEVICE_METAVAR, help = DEVICE_OPTION_HELP
+  )
+
+  private val obfuscationMappingPath by option(
+      names = *MAPPING_OPTION_NAMES, help = MAPPING_OPTION_HELP
+  ).file()
+
+  override fun run() {
+    val heapDumpFile = DumpProcess.dumpHeap(processName, device)
+    AnalyzeHprof.analyze(heapDumpFile, obfuscationMappingPath)
+  }
+
+  companion object {
+    private const val COMMAND = "analyze-process"
+  }
+
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/CLILogger.kt b/shark-cli/src/main/java/shark/CLILogger.kt
deleted file mode 100644
index bb6a38a14..000000000
--- a/shark-cli/src/main/java/shark/CLILogger.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-package shark
-
-import shark.SharkLog.Logger
-import java.io.PrintWriter
-import java.io.StringWriter
-
-class CLILogger : Logger {
-
-  override fun d(message: String) {
-    println(message)
-  }
-
-  override fun d(throwable: Throwable, message: String) {
-    d("$message\n${getStackTraceString(throwable)}")
-  }
-
-  private fun getStackTraceString(throwable: Throwable): String {
-    val stringWriter = StringWriter()
-    val printWriter = PrintWriter(stringWriter, false)
-    throwable.printStackTrace(printWriter)
-    printWriter.flush()
-    return stringWriter.toString()
-  }
-}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/DumpProcess.kt b/shark-cli/src/main/java/shark/DumpProcess.kt
new file mode 100644
index 000000000..7c65d4efa
--- /dev/null
+++ b/shark-cli/src/main/java/shark/DumpProcess.kt
@@ -0,0 +1,143 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.core.PrintMessage
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.options.option
+import shark.SharkCli.Companion.SHARK_CLI_COMMAND
+import shark.SharkCli.Companion.USAGE_HELP_TAG
+import shark.SharkCli.Companion.runCommand
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+class DumpProcess : CliktCommand(
+    name = COMMAND,
+    help = "Dumps the heap for the provided partial $PROCESS_NAME_ARG_NAME and pulls the hprof file.",
+    helpTags = mapOf(
+        USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND [$DEVICE_USAGE] $PROCESS_NAME_ARG_NAME"
+    ),
+    printHelpOnEmptyArgs = true
+) {
+
+  private val processName by argument(name = PROCESS_NAME_ARG_NAME, help = PROCESS_NAME_HELP)
+
+  private val device by option(
+      *DEVICE_OPTION_NAMES, metavar = DEVICE_METAVAR, help = DEVICE_OPTION_HELP
+  )
+
+  override fun run() {
+    dumpHeap(processName, device)
+  }
+
+  companion object {
+
+    private const val COMMAND = "dump-process"
+
+    const val PROCESS_NAME_HELP =
+      "Full or partial name of a process, e.g. \"example\" would match \"com.example.app\""
+    const val PROCESS_NAME_ARG_NAME = "PROCESS_NAME"
+
+    val DEVICE_OPTION_NAMES = arrayOf("-d", "--device")
+    const val DEVICE_OPTION_HELP = "device/emulator id"
+    const val DEVICE_METAVAR = "ID"
+    const val DEVICE_USAGE = "--device ID"
+
+    private val SPACE_PATTERN = Regex("\\s+")
+
+    @Suppress("ThrowsCount")
+    fun dumpHeap(
+      processNameParam: String,
+      maybeDeviceId: String?
+    ): File {
+      val workingDirectory = File(System.getProperty("user.dir"))
+
+      val deviceList = runCommand(workingDirectory, "adb", "devices")
+
+      val connectedDevices = deviceList.lines()
+          .drop(1)
+          .filter { it.isNotBlank() }
+          .map { SPACE_PATTERN.split(it)[0] }
+
+      val deviceId = if (connectedDevices.isEmpty()) {
+        throw PrintMessage("Error: No device connected to adb")
+      } else if (maybeDeviceId == null) {
+        if (connectedDevices.size == 1) {
+          connectedDevices[0]
+        } else {
+          throw PrintMessage(
+              "Error: more than one device/emulator connected to adb," +
+                  " use '--device ID' argument with one of $connectedDevices"
+          )
+        }
+      } else {
+        if (maybeDeviceId in connectedDevices) {
+          maybeDeviceId
+        } else {
+          throw PrintMessage(
+              "Error: device '$maybeDeviceId' not in the list of connected devices $connectedDevices"
+          )
+        }
+      }
+
+      val processList = runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "ps")
+
+      val matchingProcesses = processList.lines()
+          .filter { it.contains(processNameParam) }
+          .map {
+            val columns = SPACE_PATTERN.split(it)
+            columns[8] to columns[1]
+          }
+
+      val (processName, processId) = when {
+        matchingProcesses.size == 1 -> {
+          matchingProcesses[0]
+        }
+        matchingProcesses.isEmpty() -> {
+          throw PrintMessage("Error: No process matching \"$processNameParam\"")
+        }
+        else -> {
+          matchingProcesses.firstOrNull { it.first == processNameParam }
+              ?: throw PrintMessage(
+                  "Error: More than one process matches \"$processNameParam\" but none matches exactly: ${matchingProcesses.map { it.first }}"
+              )
+        }
+      }
+
+      val heapDumpFileName =
+        SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'-$processName.hprof'", Locale.US).format(
+            Date()
+        )
+
+      val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
+
+      SharkLog.d {
+        "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+      }
+
+      runCommand(
+          workingDirectory, "adb", "-s", deviceId, "shell", "am", "dumpheap", processId,
+          heapDumpDevicePath
+      )
+
+      // Dump heap takes time but adb returns immediately.
+      Thread.sleep(5000)
+
+      SharkLog.d { "Pulling $heapDumpDevicePath" }
+
+      val pullResult =
+        runCommand(workingDirectory, "adb", "-s", deviceId, "pull", heapDumpDevicePath)
+      SharkLog.d { pullResult }
+      SharkLog.d { "Removing $heapDumpDevicePath" }
+
+      runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "rm", heapDumpDevicePath)
+
+      val heapDumpFile = File(workingDirectory, heapDumpFileName)
+      SharkLog.d { "Pulled heap dump to $heapDumpFile" }
+
+      return heapDumpFile
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
index 8223b80b4..4330f4610 100644
--- a/shark-cli/src/main/java/shark/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -1,267 +1,11 @@
 package shark
 
-import java.io.File
-import java.text.SimpleDateFormat
-import java.util.Date
-import java.util.Locale
-import java.util.concurrent.TimeUnit.SECONDS
-import kotlin.system.exitProcess
-
-fun main(args: Array<String>) {
-  SharkLog.logger = CLILogger()
-  if (args.isEmpty()) {
-    printHelp()
-    return
-  }
-
-  var argIndex = -1
-
-  when (val command = args[++argIndex]) {
-    "dump-process" -> {
-      val packageName = args[++argIndex]
-      argIndex++
-      val remainderArgs = args.drop(argIndex)
-      val deviceId = readDeviceIdFromArgs(remainderArgs)
-      dumpHeap(packageName, deviceId)
-    }
-    "analyze-process" -> {
-      val packageName = args[++argIndex]
-      argIndex++
-      val remainderArgs = args.drop(argIndex)
-      val deviceId = readDeviceIdFromArgs(remainderArgs)
-      val heapDumpFile = dumpHeap(packageName, deviceId)
-      val mappingFile = readMappingFileFromArgs(remainderArgs)
-      analyze(heapDumpFile, mappingFile)
-    }
-    "analyze-hprof" -> {
-      val hprofPath = args[++argIndex]
-      argIndex++
-      val remainderArgs = args.asList()
-          .subList(argIndex, args.size)
-      val mappingFile = readMappingFileFromArgs(remainderArgs)
-      analyze(File(hprofPath), mappingFile)
-    }
-    "strip-hprof" -> {
-      val hprofPath = args[++argIndex]
-      stripHprof(File(hprofPath))
-    }
-    else -> {
-      SharkLog.d {
-        "Error: unknown command [$command]"
-      }
-      printHelp()
-    }
-  }
-}
-
-private fun readMappingFileFromArgs(args: List<String>): File? {
-  val tagIndex = args.indexOfFirst {
-    it == "-p" || it == "--obfuscation-mapping"
-  }
-  if (tagIndex == -1 || tagIndex == args.lastIndex) {
-    return null
-  }
-  return File(args[tagIndex + 1])
-}
-
-private fun readDeviceIdFromArgs(args: List<String>): String? {
-  val tagIndex = args.indexOfFirst {
-    it == "-d" || it == "--device"
-  }
-  if (tagIndex == -1 || tagIndex == args.lastIndex) {
-    return null
-  }
-  return args[tagIndex + 1]
-}
-
-fun printHelp() {
-  val workingDirectory = File(System.getProperty("user.dir"))
-
-  // ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
-  SharkLog.d {
-    """
-    Shark CLI, running in directory $workingDirectory
-
-                     ^`.                 .=""=.
-     ^_              \  \               / _  _ \
-     \ \             {   \             |  d  b  |
-     {  \           /     `~~~--__     \   /\   /
-     {   \___----~~'              `~~-_/'-=\/=-'\,
-      \                         /// a  `~.      \ \
-      / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
-      \/      \/    `~~~;   ,---~~-_`/ \        / \/
-                       /   /            '.    .'
-                      '._.'             _|`~~`|_
-                                        /|\  /|\
-
-    Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
-
-    analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
-      USAGE: analyze-process PROCESS_PACKAGE_NAME
-               [-d ID, --device ID]                optional device/emulator id
-               [-p PATH, --obfuscation-mapping PATH]  optional path to obfuscation mapping file
-
-    dump-process: Dumps the heap for the provided process name and pulls the hprof file.
-      USAGE: dump-process PROCESS_PACKAGE_NAME
-               [-d ID, --device ID]  optional device/emulator id
-
-    analyze-hprof: Analyzes the provided hprof file.
-      USAGE: analyze-hprof HPROF_FILE_PATH
-               [-p PATH, --obfuscation-mapping PATH]  optional path to obfuscation mapping file
-
-    strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes and generates a new "-stripped" hprof file.
-      USAGE: strip-hprof HPROF_FILE_PATH
-  """.trimIndent()
-  }
-}
-
-private fun dumpHeap(
-  packageName: String,
-  maybeDeviceId: String?
-): File {
-  val workingDirectory = File(System.getProperty("user.dir"))
-
-  val deviceList = runCommand(workingDirectory, "adb", "devices")
-
-  val connectedDevices = deviceList.lines()
-      .drop(1)
-      .filter { it.isNotBlank() }
-      .map { SPACE_PATTERN.split(it)[0] }
-
-  val deviceId = if (connectedDevices.isEmpty()) {
-    SharkLog.d { "Error: No device connected to adb" }
-    exitProcess(1)
-  } else if (maybeDeviceId == null) {
-    if (connectedDevices.size == 1) {
-      connectedDevices[0]
-    } else {
-      SharkLog.d {
-        "Error: more than one device/emulator connected to adb," +
-            " use '--device ID' argument with one of $connectedDevices"
-      }
-      exitProcess(1)
-    }
-  } else {
-    if (maybeDeviceId in connectedDevices) {
-      maybeDeviceId
-    } else {
-      SharkLog.d { "Error: device '$maybeDeviceId' not in the list of connected devices $connectedDevices" }
-      exitProcess(1)
-    }
-  }
-
-  val processList = runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "ps")
-
-  val matchingProcesses = processList.lines()
-      .filter { it.contains(packageName) }
-      .map {
-        val columns = SPACE_PATTERN.split(it)
-        columns[8] to columns[1]
-      }
-
-  val (processName, processId) = if (matchingProcesses.size == 1) {
-    matchingProcesses[0]
-  } else if (matchingProcesses.isEmpty()) {
-    SharkLog.d { "Error: No process matching \"$packageName\"" }
-    exitProcess(1)
-  } else {
-    val matchingExactly = matchingProcesses.firstOrNull { it.first == packageName }
-    if (matchingExactly != null) {
-      matchingExactly
-    } else {
-      SharkLog.d {
-        "Error: More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
-      }
-      exitProcess(1)
-    }
-  }
-
-  val heapDumpFileName =
-    SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'-$processName.hprof'", Locale.US).format(
-        Date()
-    )
-
-  val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
-
-  SharkLog.d {
-    "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
-  }
-
-  runCommand(
-      workingDirectory, "adb", "-s", deviceId, "shell", "am", "dumpheap", processId,
-      heapDumpDevicePath
-  )
-
-  // Dump heap takes time but adb returns immediately.
-  Thread.sleep(5000)
-
-  SharkLog.d { "Pulling $heapDumpDevicePath" }
-
-  val pullResult = runCommand(workingDirectory, "adb", "-s", deviceId, "pull", heapDumpDevicePath)
-  SharkLog.d { pullResult }
-  SharkLog.d { "Removing $heapDumpDevicePath" }
-
-  runCommand(workingDirectory, "adb", "-s", deviceId, "shell", "rm", heapDumpDevicePath)
-
-  val heapDumpFile = File(workingDirectory, heapDumpFileName)
-  SharkLog.d { "Pulled heap dump to $heapDumpFile" }
-
-  return heapDumpFile
-}
-
-private fun runCommand(
-  directory: File,
-  vararg arguments: String
-): String {
-  val process = ProcessBuilder(*arguments)
-      .directory(directory)
-      .start()
-      .also { it.waitFor(10, SECONDS) }
-
-  if (process.exitValue() != 0) {
-    throw Exception(
-        "Failed command: '${arguments.joinToString(
-            " "
-        )}', error output: '${process.errorStream.bufferedReader().readText()}'"
-    )
-  }
-  return process.inputStream.bufferedReader()
-      .readText()
-}
-
-private fun analyze(
-  heapDumpFile: File,
-  proguardMappingFile: File?
-) {
-  val listener = OnAnalysisProgressListener { step ->
-    SharkLog.d { step.name }
-  }
-
-  val proguardMapping = proguardMappingFile?.let {
-    ProguardMappingReader(it.inputStream()).readProguardMapping()
-  }
-
-  val heapAnalyzer = HeapAnalyzer(listener)
-  SharkLog.d { "Analyzing heap dump $heapDumpFile" }
-  val heapAnalysis = heapAnalyzer.analyze(
-      heapDumpFile = heapDumpFile,
-      leakingObjectFinder = FilteringLeakingObjectFinder(
-          AndroidObjectInspectors.appLeakingObjectFilters
-      ),
-      referenceMatchers = AndroidReferenceMatchers.appDefaults,
-      computeRetainedHeapSize = true,
-      objectInspectors = AndroidObjectInspectors.appDefaults,
-      proguardMapping = proguardMapping
-  )
-
-  SharkLog.d { heapAnalysis.toString() }
-}
-
-private fun stripHprof(heapDumpFile: File) {
-  SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
-  val stripper = HprofPrimitiveArrayStripper()
-  val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
-  SharkLog.d { "Stripped primitive arrays to $outputFile" }
-}
-
-private val SPACE_PATTERN = Regex("\\s+")
\ No newline at end of file
+import com.github.ajalt.clikt.core.subcommands
+
+fun main(args: Array<String>) =
+  SharkCli().subcommands(
+      AnalyzeProcess(),
+      DumpProcess(),
+      AnalyzeHprof(),
+      StripHprof()
+  ).main(args)
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/SharkCli.kt b/shark-cli/src/main/java/shark/SharkCli.kt
new file mode 100644
index 000000000..e8f203ace
--- /dev/null
+++ b/shark-cli/src/main/java/shark/SharkCli.kt
@@ -0,0 +1,88 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import shark.SharkLog.Logger
+import java.io.File
+import java.io.PrintWriter
+import java.io.StringWriter
+import java.util.concurrent.TimeUnit.SECONDS
+
+class SharkCli : CliktCommand(
+    name = SHARK_CLI_COMMAND,
+    // This ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
+    help = """
+    |```
+    |$S                ^`.                 .=""=.
+    |$S^_              \  \               / _  _ \
+    |$S\ \             {   \             |  d  b  |
+    |$S{  \           /     `~~~--__     \   /\   /
+    |$S{   \___----~~'              `~~-_/'-=\/=-'\,
+    |$S \                         /// a  `~.      \ \
+    |$S / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+    |$S \/      \/    `~~~;   ,---~~-_`/ \        / \/
+    |$S                  /   /            '.    .'
+    |$S                 '._.'             _|`~~`|_
+    |$S                                   /|\  /|\
+    |```
+    """.trimMargin()
+
+) {
+
+  override fun run() {
+    class CLILogger : Logger {
+
+      override fun d(message: String) {
+        echo(message)
+      }
+
+      override fun d(
+        throwable: Throwable,
+        message: String
+      ) {
+        d("$message\n${getStackTraceString(throwable)}")
+      }
+
+      private fun getStackTraceString(throwable: Throwable): String {
+        val stringWriter = StringWriter()
+        val printWriter = PrintWriter(stringWriter, false)
+        throwable.printStackTrace(printWriter)
+        printWriter.flush()
+        return stringWriter.toString()
+      }
+    }
+
+    SharkLog.logger = CLILogger()
+
+  }
+
+  companion object {
+
+    const val SHARK_CLI_COMMAND = "shark-cli"
+
+    const val USAGE_HELP_TAG = "Usage"
+
+    /** Zero width space */
+    private const val S = '\u200b'
+
+    fun runCommand(
+      directory: File,
+      vararg arguments: String
+    ): String {
+      val process = ProcessBuilder(*arguments)
+          .directory(directory)
+          .start()
+          .also { it.waitFor(10, SECONDS) }
+
+      if (process.exitValue() != 0) {
+        throw Exception(
+            "Failed command: '${arguments.joinToString(
+                " "
+            )}', error output: '${process.errorStream.bufferedReader().readText()}'"
+        )
+      }
+      return process.inputStream.bufferedReader()
+          .readText()
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/StripHprof.kt b/shark-cli/src/main/java/shark/StripHprof.kt
new file mode 100644
index 000000000..1fa5822f2
--- /dev/null
+++ b/shark-cli/src/main/java/shark/StripHprof.kt
@@ -0,0 +1,36 @@
+package shark
+
+import com.github.ajalt.clikt.core.CliktCommand
+import com.github.ajalt.clikt.parameters.arguments.argument
+import com.github.ajalt.clikt.parameters.types.file
+import shark.AnalyzeHprof.Companion.HPROF_ARG_NAME
+import shark.AnalyzeHprof.Companion.HPROF_HELP
+import shark.SharkCli.Companion.SHARK_CLI_COMMAND
+import shark.SharkCli.Companion.USAGE_HELP_TAG
+import java.io.File
+
+class StripHprof : CliktCommand(
+    name = COMMAND,
+    help = "Replaces all primitive arrays from the provided $HPROF_ARG_NAME with arrays of zeroes and generates a new \"-stripped.hprof\" file.",
+    helpTags = mapOf(USAGE_HELP_TAG to "$SHARK_CLI_COMMAND $COMMAND $HPROF_ARG_NAME"),
+    printHelpOnEmptyArgs = true
+) {
+
+  private val heapDumpFile by argument(name = HPROF_ARG_NAME, help = HPROF_HELP).file()
+
+  override fun run() {
+    stripHprof(heapDumpFile)
+  }
+
+  companion object {
+
+    private const val COMMAND = "strip-hprof"
+
+    private fun stripHprof(heapDumpFile: File) {
+      SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
+      val stripper = HprofPrimitiveArrayStripper()
+      val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
+      SharkLog.d { "Stripped primitive arrays to $outputFile" }
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 5f83a41d0..cf9f2965b 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -125,10 +125,7 @@ class HeapAnalyzer constructor(
     val pathFindingResults =
       pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)
 
-    SharkLog.d {
-      "Found ${leakingObjectIds.size} retained objects" +
-          " and ${pathFindingResults.pathsToLeakingObjects.size} paths."
-    }
+    SharkLog.d { "Found ${leakingObjectIds.size} retained objects" }
 
     return buildLeakTraces(pathFindingResults)
   }
@@ -327,6 +324,15 @@ class HeapAnalyzer constructor(
 
     val deduplicatedPaths = deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
 
+    if (deduplicatedPaths.size != pathFindingResults.pathsToLeakingObjects.size) {
+      SharkLog.d {
+        "Found ${pathFindingResults.pathsToLeakingObjects.size} paths to retained objects," +
+            " down to ${deduplicatedPaths.size} after removing duplicated paths"
+      }
+    } else {
+      SharkLog.d { "Found ${deduplicatedPaths.size} paths to retained objects" }
+    }
+
     deduplicatedPaths.forEachIndexed { index, retainedObjectNode ->
 
       val pathHeapObjects = mutableListOf<HeapObject>()
