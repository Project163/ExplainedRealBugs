diff --git a/build.gradle b/build.gradle
index e3b62f246..3416611c1 100644
--- a/build.gradle
+++ b/build.gradle
@@ -39,7 +39,7 @@ buildscript {
       mockito: 'org.mockito:mockito-core:2.7.5',
       mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
       okio: 'com.squareup.okio:okio:2.2.2',
-      okio_1x: 'com.squareup.okio:okio:1.0.0',
+      okio_1x: 'com.squareup.okio:okio:1.14.0',
       robolectric: 'org.robolectric:robolectric:4.0-alpha-3',
   ]
   repositories {
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index 00ae58e9a..0cb1f280f 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -171,6 +171,7 @@ class HprofHeapGraph internal constructor(
       return cachedRecord.elementIds.size * identifierByteSize
     }
     hprof.moveReaderTo(indexedObject.position)
+    hprof.loadRecord(indexedObject.recordSize)
     val thinRecord = hprof.reader.readObjectArraySkipContentRecord()
     return thinRecord.size * identifierByteSize
   }
@@ -202,6 +203,7 @@ class HprofHeapGraph internal constructor(
       }
     }
     hprof.moveReaderTo(indexedObject.position)
+    hprof.loadRecord(indexedObject.recordSize)
     val thinRecord = hprof.reader.readPrimitiveArraySkipContentRecord()
     return  thinRecord.size * thinRecord.type.byteSize
   }
@@ -235,6 +237,7 @@ class HprofHeapGraph internal constructor(
       return objectRecordOrNull as T
     }
     hprof.moveReaderTo(indexedObject.position)
+    hprof.loadRecord(indexedObject.recordSize)
     return readBlock().apply { objectCache.put(objectId, this) }
   }
 
@@ -290,6 +293,7 @@ class HprofHeapGraph internal constructor(
       )
     ): HeapGraph {
       val index = HprofInMemoryIndex.createReadingHprof(hprof, proguardMapping, indexedGcRootTypes)
+      hprof.readFullRecords = true
       return HprofHeapGraph(hprof, index)
     }
   }
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index ac20d72d9..0498be0e9 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -20,6 +20,7 @@ import shark.internal.IndexedObject.IndexedObjectArray
 import shark.internal.IndexedObject.IndexedPrimitiveArray
 import shark.internal.hppc.LongLongScatterMap
 import shark.internal.hppc.LongObjectScatterMap
+import kotlin.math.max
 import kotlin.reflect.KClass
 
 /**
@@ -35,7 +36,11 @@ internal class HprofInMemoryIndex private constructor(
   private val primitiveArrayIndex: SortedBytesMap,
   private val gcRoots: List<GcRoot>,
   private val proguardMapping: ProguardMapping?,
-  val primitiveWrapperTypes: Set<Long>
+  val primitiveWrapperTypes: Set<Long>,
+  private val bytesForClassSize: Int,
+  private val bytesForInstanceSize: Int,
+  private val bytesForObjectArraySize: Int,
+  private val bytesForPrimitiveArraySize: Int
 ) {
 
   fun fieldName(
@@ -77,7 +82,8 @@ internal class HprofInMemoryIndex private constructor(
           id to IndexedClass(
               position = array.readTruncatedLong(positionSize),
               superclassId = array.readId(),
-              instanceSize = array.readInt()
+              instanceSize = array.readInt(),
+              recordSize = array.readTruncatedLong(bytesForClassSize)
           )
         }
   }
@@ -89,7 +95,8 @@ internal class HprofInMemoryIndex private constructor(
           val array = it.second
           val instance = IndexedInstance(
               position = array.readTruncatedLong(positionSize),
-              classId = array.readId()
+              classId = array.readId(),
+              recordSize = array.readTruncatedLong(bytesForInstanceSize)
           )
           id to instance
         }
@@ -102,7 +109,8 @@ internal class HprofInMemoryIndex private constructor(
           val array = it.second
           val objectArray = IndexedObjectArray(
               position = array.readTruncatedLong(positionSize),
-              arrayClassId = array.readId()
+              arrayClassId = array.readId(),
+              recordSize = array.readTruncatedLong(bytesForObjectArraySize)
           )
           id to objectArray
         }
@@ -117,7 +125,8 @@ internal class HprofInMemoryIndex private constructor(
           val primitiveArray = IndexedPrimitiveArray(
               position = array.readTruncatedLong(positionSize),
               primitiveType = PrimitiveType.values()[array.readByte()
-                  .toInt()]
+                  .toInt()],
+              recordSize = array.readTruncatedLong(bytesForPrimitiveArraySize)
           )
           id to primitiveArray
         }
@@ -141,21 +150,24 @@ internal class HprofInMemoryIndex private constructor(
       return IndexedClass(
           position = array.readTruncatedLong(positionSize),
           superclassId = array.readId(),
-          instanceSize = array.readInt()
+          instanceSize = array.readInt(),
+          recordSize = array.readTruncatedLong(bytesForClassSize)
       )
     }
     array = instanceIndex[objectId]
     if (array != null) {
       return IndexedInstance(
           position = array.readTruncatedLong(positionSize),
-          classId = array.readId()
+          classId = array.readId(),
+          recordSize = array.readTruncatedLong(bytesForInstanceSize)
       )
     }
     array = objectArrayIndex[objectId]
     if (array != null) {
       return IndexedObjectArray(
           position = array.readTruncatedLong(positionSize),
-          arrayClassId = array.readId()
+          arrayClassId = array.readId(),
+          recordSize = array.readTruncatedLong(bytesForObjectArraySize)
       )
     }
     array = primitiveArrayIndex[objectId]
@@ -163,7 +175,8 @@ internal class HprofInMemoryIndex private constructor(
       return IndexedPrimitiveArray(
           position = array.readTruncatedLong(positionSize),
           primitiveType = PrimitiveType.values()[array.readByte()
-              .toInt()]
+              .toInt()],
+          recordSize = array.readTruncatedLong(bytesForPrimitiveArraySize)
       )
     }
     return null
@@ -197,7 +210,11 @@ internal class HprofInMemoryIndex private constructor(
     instanceCount: Int,
     objectArrayCount: Int,
     primitiveArrayCount: Int,
-    private val indexedGcRootsTypes: Set<Class<out GcRoot>>
+    private val indexedGcRootsTypes: Set<Class<out GcRoot>>,
+    val bytesForClassSize: Int,
+    val bytesForInstanceSize: Int,
+    val bytesForObjectArraySize: Int,
+    val bytesForPrimitiveArraySize: Int
   ) : OnHprofRecordListener {
 
     private val identifierSize = if (longIdentifiers) 8 else 4
@@ -221,22 +238,22 @@ internal class HprofInMemoryIndex private constructor(
     private val classNames = LongLongScatterMap(expectedElements = classCount)
 
     private val classIndex = UnsortedByteEntries(
-        bytesPerValue = positionSize + identifierSize + 4,
+        bytesPerValue = positionSize + identifierSize + 4 + bytesForClassSize,
         longIdentifiers = longIdentifiers,
         initialCapacity = classCount
     )
     private val instanceIndex = UnsortedByteEntries(
-        bytesPerValue = positionSize + identifierSize,
+        bytesPerValue = positionSize + identifierSize + bytesForInstanceSize,
         longIdentifiers = longIdentifiers,
         initialCapacity = instanceCount
     )
     private val objectArrayIndex = UnsortedByteEntries(
-        bytesPerValue = positionSize + identifierSize,
+        bytesPerValue = positionSize + identifierSize + bytesForObjectArraySize,
         longIdentifiers = longIdentifiers,
         initialCapacity = objectArrayCount
     )
     private val primitiveArrayIndex = UnsortedByteEntries(
-        bytesPerValue = positionSize + 1,
+        bytesPerValue = positionSize + 1 + bytesForPrimitiveArraySize,
         longIdentifiers = longIdentifiers,
         initialCapacity = primitiveArrayCount
     )
@@ -285,6 +302,7 @@ internal class HprofInMemoryIndex private constructor(
                 writeTruncatedLong(position, positionSize)
                 writeId(record.superclassId)
                 writeInt(record.instanceSize)
+                writeTruncatedLong(record.recordSize, bytesForClassSize)
               }
         }
         is InstanceSkipContentRecord -> {
@@ -292,6 +310,7 @@ internal class HprofInMemoryIndex private constructor(
               .apply {
                 writeTruncatedLong(position, positionSize)
                 writeId(record.classId)
+                writeTruncatedLong(record.recordSize, bytesForInstanceSize)
               }
         }
         is ObjectArraySkipContentRecord -> {
@@ -299,6 +318,7 @@ internal class HprofInMemoryIndex private constructor(
               .apply {
                 writeTruncatedLong(position, positionSize)
                 writeId(record.arrayClassId)
+                writeTruncatedLong(record.recordSize, bytesForObjectArraySize)
               }
         }
         is PrimitiveArraySkipContentRecord -> {
@@ -306,6 +326,7 @@ internal class HprofInMemoryIndex private constructor(
               .apply {
                 writeTruncatedLong(position, positionSize)
                 writeByte(record.type.ordinal.toByte())
+                writeTruncatedLong(record.recordSize, bytesForPrimitiveArraySize)
               }
         }
       }
@@ -320,12 +341,20 @@ internal class HprofInMemoryIndex private constructor(
       val sortedClassIndex = classIndex.moveToSortedMap()
       // Passing references to avoid copying the underlying data structures.
       return HprofInMemoryIndex(
-          positionSize,
-          hprofStringCache, classNames, sortedClassIndex, sortedInstanceIndex,
-          sortedObjectArrayIndex,
-          sortedPrimitiveArrayIndex, gcRoots,
-          proguardMapping,
-          primitiveWrapperTypes
+          positionSize = positionSize,
+          hprofStringCache = hprofStringCache,
+          classNames = classNames,
+          classIndex = sortedClassIndex,
+          instanceIndex = sortedInstanceIndex,
+          objectArrayIndex = sortedObjectArrayIndex,
+          primitiveArrayIndex = sortedPrimitiveArrayIndex,
+          gcRoots = gcRoots,
+          proguardMapping = proguardMapping,
+          primitiveWrapperTypes = primitiveWrapperTypes,
+          bytesForClassSize = bytesForClassSize,
+          bytesForInstanceSize = bytesForInstanceSize,
+          bytesForObjectArraySize = bytesForObjectArraySize,
+          bytesForPrimitiveArraySize = bytesForPrimitiveArraySize
       )
     }
 
@@ -366,30 +395,60 @@ internal class HprofInMemoryIndex private constructor(
       val reader = hprof.reader
 
       // First pass to count and correctly size arrays once and for all.
+      var maxClassSize = 0L
+      var maxInstanceSize = 0L
+      var maxObjectArraySize = 0L
+      var maxPrimitiveArraySize = 0L
       var classCount = 0
       var instanceCount = 0
       var objectArrayCount = 0
       var primitiveArrayCount = 0
       reader.readHprofRecords(setOf(
-          LoadClassRecord::class,
+          ClassSkipContentRecord::class,
           InstanceSkipContentRecord::class,
           ObjectArraySkipContentRecord::class,
           PrimitiveArraySkipContentRecord::class
-      ), OnHprofRecordListener { position, record ->
+      ), OnHprofRecordListener { _, record ->
         when (record) {
-          is LoadClassRecord -> classCount++
-          is InstanceSkipContentRecord -> instanceCount++
-          is ObjectArraySkipContentRecord -> objectArrayCount++
-          is PrimitiveArraySkipContentRecord -> primitiveArrayCount++
+          is ClassSkipContentRecord -> {
+            classCount++
+            maxClassSize = max(maxClassSize, record.recordSize)
+          }
+          is InstanceSkipContentRecord -> {
+            instanceCount++
+            maxInstanceSize = max(maxInstanceSize, record.recordSize)
+          }
+          is ObjectArraySkipContentRecord -> {
+            objectArrayCount++
+            maxObjectArraySize = max(maxObjectArraySize, record.recordSize)
+          }
+          is PrimitiveArraySkipContentRecord -> {
+            primitiveArrayCount++
+            maxPrimitiveArraySize = max(maxPrimitiveArraySize, record.recordSize)
+          }
         }
       })
 
+      val bytesForClassSize = byteSizeForUnsigned(maxClassSize)
+      val bytesForInstanceSize = byteSizeForUnsigned(maxInstanceSize)
+      val bytesForObjectArraySize = byteSizeForUnsigned(maxObjectArraySize)
+      val bytesForPrimitiveArraySize = byteSizeForUnsigned(maxPrimitiveArraySize)
+
       hprof.moveReaderTo(reader.startPosition)
       val indexBuilderListener =
         Builder(
-            reader.identifierByteSize == 8, hprof.fileLength, classCount, instanceCount,
-            objectArrayCount, primitiveArrayCount, indexedGcRootTypes.map { it.java }
-            .toSet()
+            longIdentifiers = reader.identifierByteSize == 8,
+            fileLength = hprof.fileLength,
+            classCount = classCount,
+            instanceCount = instanceCount,
+            objectArrayCount = objectArrayCount,
+            primitiveArrayCount = primitiveArrayCount,
+            indexedGcRootsTypes = indexedGcRootTypes.map { it.java }
+                .toSet(),
+            bytesForClassSize = bytesForClassSize,
+            bytesForInstanceSize = bytesForInstanceSize,
+            bytesForObjectArraySize = bytesForObjectArraySize,
+            bytesForPrimitiveArraySize = bytesForPrimitiveArraySize
         )
 
       reader.readHprofRecords(recordTypes, indexBuilderListener)
diff --git a/shark-graph/src/main/java/shark/internal/IndexedObject.kt b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
index 007beb807..10377abd7 100644
--- a/shark-graph/src/main/java/shark/internal/IndexedObject.kt
+++ b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
@@ -4,26 +4,31 @@ import shark.PrimitiveType
 
 internal sealed class IndexedObject {
   abstract val position: Long
+  abstract val recordSize: Long
 
   class IndexedClass(
     override val position: Long,
     val superclassId: Long,
-    val instanceSize: Int
+    val instanceSize: Int,
+    override val recordSize: Long
   ) : IndexedObject()
 
   class IndexedInstance(
     override val position: Long,
-    val classId: Long
+    val classId: Long,
+    override val recordSize: Long
   ) : IndexedObject()
 
   class IndexedObjectArray(
     override val position: Long,
-    val arrayClassId: Long
+    val arrayClassId: Long,
+    override val recordSize: Long
   ) : IndexedObject()
 
   class IndexedPrimitiveArray(
     override val position: Long,
-    primitiveType: PrimitiveType
+    primitiveType: PrimitiveType,
+    override val recordSize: Long
   ) : IndexedObject() {
     private val primitiveTypeOrdinal: Byte = primitiveType.ordinal.toByte()
     val primitiveType: PrimitiveType
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
index f3c8cace3..74db36f15 100644
--- a/shark-hprof/src/main/java/shark/Hprof.kt
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -1,5 +1,6 @@
 package shark
 
+import okio.Buffer
 import okio.BufferedSource
 import okio.Okio
 import shark.Hprof.Companion.open
@@ -10,6 +11,12 @@ import java.nio.channels.FileChannel
 /**
  * An opened Hprof file which can be read via [reader]. Open a new hprof with [open], and don't
  * forget to call [close] once done.
+ *
+ * The default behavior for [reader] is to start at the beginning of the hprof file and move
+ * forward as one reads through it. If you need to start reading from further back in the file,
+ * you can use [moveReaderTo]. However, if you need to constantly read at different positions
+ * with random access, it's not efficient. If you know the size of the records you want to read,
+ * set [readFullRecords] to true, then call [moveReaderTo] followed by [loadRecord].
  */
 class Hprof private constructor(
   private val channel: FileChannel,
@@ -25,25 +32,80 @@ class Hprof private constructor(
   val fileLength: Long
 ) : Closeable {
 
+  private val randomAccessBuffer = Buffer()
+
+  /**
+   * When true, enables a more efficient way of reading records with random access.
+   *
+   * Default is false.
+   */
+  var readFullRecords: Boolean = false
+    set(setToRandomAccess) {
+      if (setToRandomAccess == field) {
+        return
+      }
+      require(randomAccessBuffer.size() == 0L)
+      if (setToRandomAccess) {
+        reader.source = randomAccessBuffer
+        reader.position = 0
+      } else {
+        reader.source = source
+        // This ensures moveReaderTo actually moves.
+        reader.position = reader.startPosition + 1
+        moveReaderTo(reader.startPosition)
+      }
+      field = setToRandomAccess
+    }
+
   override fun close() {
     source.close()
   }
 
   /**
-   * Moves [reader] to a new position in the hprof file. This is transparent to the reader, and
-   * will not reset [HprofReader.position].
+   * Moves [reader] to a new position in the hprof file.
+   * When [readFullRecords] is true, you MUST call [loadRecord] right after [moveReaderTo] or the
+   * next read will throw.
    */
   fun moveReaderTo(newPosition: Long) {
-    val currentPosition = reader.position
+    if (readFullRecords) {
+      require(randomAccessBuffer.size() == 0L) {
+        "?"
+      }
+    } else {
+      val currentPosition = reader.position
 
-    if (currentPosition == newPosition) {
-      return
+      if (currentPosition == newPosition) {
+        return
+      }
+      source.buffer()
+          .clear()
+      channel.position(newPosition)
     }
-    source.buffer().clear()
-    channel.position(newPosition)
     reader.position = newPosition
   }
 
+  /**
+   * If [readFullRecords] is true, loads the backing reader buffer with exactly
+   * [byteCount] bytes, all of which must then be read.
+   * If [readFullRecords] is false, this is a no-op.
+   */
+  fun loadRecord(byteCount: Long) {
+    if (!readFullRecords) {
+      return
+    }
+    require(byteCount > 0L) {
+      ""
+    }
+    var mutablePos = reader.position
+    var mutableByteCount = byteCount
+
+    while (mutableByteCount > 0L) {
+      val bytesRead = channel.transferTo(mutablePos, mutableByteCount, randomAccessBuffer)
+      mutablePos += bytesRead
+      mutableByteCount -= bytesRead
+    }
+  }
+
   /**
    * Supported hprof versions
    */
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
index e8b675f8e..d128e4899 100644
--- a/shark-hprof/src/main/java/shark/HprofReader.kt
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -76,7 +76,7 @@ import kotlin.reflect.KClass
  */
 @Suppress("LargeClass")
 class HprofReader constructor(
-  private var source: BufferedSource,
+  internal var source: BufferedSource,
   /**
    * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
    * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not
@@ -546,15 +546,18 @@ class HprofReader constructor(
    * Reads an instance record after a instance dump tag, skipping its content.
    */
   fun readInstanceSkipContentRecord(): InstanceSkipContentRecord {
+    val startPosition = position
     val id = readId()
     val stackTraceSerialNumber = readInt()
     val classId = readId()
     val remainingBytesInInstance = readInt()
     skip(remainingBytesInInstance)
+    val recordSize = position - startPosition
     return reusedInstanceSkipContentRecord.apply {
       this.id = id
       this.stackTraceSerialNumber = stackTraceSerialNumber
       this.classId = classId
+      this.recordSize = recordSize
     }
   }
 
@@ -629,6 +632,7 @@ class HprofReader constructor(
    * Reads a class record after a class dump tag, skipping its content.
    */
   fun readClassSkipContentRecord(): ClassSkipContentRecord {
+    val startPosition = position
     val id = readId()
     // stack trace serial number
     val stackTraceSerialNumber = readInt()
@@ -672,6 +676,8 @@ class HprofReader constructor(
     val fieldCount = readUnsignedShort()
     // Each field takes id + byte.
     skip((identifierByteSize + 1) * fieldCount)
+
+    val recordSize = position - startPosition
     return reusedClassSkipContentRecord.apply {
       this.id = id
       this.stackTraceSerialNumber = stackTraceSerialNumber
@@ -682,6 +688,7 @@ class HprofReader constructor(
       this.instanceSize = instanceSize
       this.staticFieldCount = staticFieldCount
       this.fieldCount = fieldCount
+      this.recordSize = recordSize
     }
   }
 
@@ -726,25 +733,27 @@ class HprofReader constructor(
    * Reads a primitive array record after a primitive array dump tag, skipping its content.
    */
   fun readPrimitiveArraySkipContentRecord(): PrimitiveArraySkipContentRecord {
+    val startPosition = position
     val id = readId()
     val stackTraceSerialNumber = readInt()
     // length
     val arrayLength = readInt()
     val type = PrimitiveType.primitiveTypeByHprofType.getValue(readUnsignedByte())
     skip(arrayLength * type.byteSize)
+    val recordSize = position - startPosition
     return reusedPrimitiveArraySkipContentRecord.apply {
       this.id = id
       this.stackTraceSerialNumber = stackTraceSerialNumber
       this.size = arrayLength
       this.type = type
+      this.recordSize = recordSize
     }
   }
 
   /**
    * Reads a full object array record after a object array dump tag.
    */
-  fun readObjectArrayDumpRecord(
-  ): ObjectArrayDumpRecord {
+  fun readObjectArrayDumpRecord(): ObjectArrayDumpRecord {
     val id = readId()
     // stack trace serial number
     val stackTraceSerialNumber = readInt()
@@ -762,19 +771,21 @@ class HprofReader constructor(
   /**
    * Reads an object array record after a object array dump tag, skipping its content.
    */
-  fun readObjectArraySkipContentRecord(
-  ): ObjectArraySkipContentRecord {
+  fun readObjectArraySkipContentRecord(): ObjectArraySkipContentRecord {
+    val startPosition = position
     val id = readId()
     // stack trace serial number
     val stackTraceSerialNumber = readInt()
     val arrayLength = readInt()
     val arrayClassId = readId()
     skip(identifierByteSize * arrayLength)
+    val recordSize = position - startPosition
     return reusedObjectArraySkipContentRecord.apply {
       this.id = id
       this.stackTraceSerialNumber = stackTraceSerialNumber
       this.arrayClassId = arrayClassId
       this.size = arrayLength
+      this.recordSize = recordSize
     }
   }
 
diff --git a/shark-hprof/src/main/java/shark/HprofRecord.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
index 15d28dc01..9877a932b 100644
--- a/shark-hprof/src/main/java/shark/HprofRecord.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -128,6 +128,8 @@ sealed class HprofRecord {
           internal set
         var fieldCount: Int
           internal set
+        var recordSize: Long = 0
+          internal set
 
         init {
           this.id = id
@@ -166,12 +168,12 @@ sealed class HprofRecord {
       ) : ObjectRecord() {
         var id: Long
           internal set
-
         var stackTraceSerialNumber: Int
           internal set
-
         var classId: Long
           internal set
+        var recordSize: Long = 0
+          internal set
 
         init {
           this.id = id
@@ -208,6 +210,8 @@ sealed class HprofRecord {
           internal set
         var size: Int
           internal set
+        var recordSize: Long = 0
+          internal set
 
         init {
           this.id = id
@@ -316,6 +320,8 @@ sealed class HprofRecord {
           internal set
         var type: PrimitiveType
           internal set
+        var recordSize: Long = 0
+          internal set
 
         init {
           this.id = id
