diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.kt
index cdd28e7a2..d3d452b78 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.kt
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.kt
@@ -6,8 +6,8 @@ import java.util.UUID
 data class AnalysisResult(
 
   /**
-   * Key associated to the [KeyedWeakReference] used to detect the memory leak.
-   * When analyzing a heap dump, search for all [KeyedWeakReference] instances, then open
+   * Key associated to the [leaksentry.KeyedWeakReference] used to detect the memory leak.
+   * When analyzing a heap dump, search for all [leaksentry.KeyedWeakReference] instances, then open
    * the one that has its "key" field set to this value. Its "referent" field contains the
    * leaking object. Computing the shortest path to GC roots on that leaking object should enable
    * you to figure out the cause of the leak.
@@ -91,11 +91,11 @@ data class AnalysisResult(
     val leakSimpleName = classSimpleName(className!!)
 
     val runtimeException = RuntimeException(
-        "${leakSimpleName} leak from ${rootSimpleName} (holder=${firstElement.holder}, type= ${firstElement.type})"
+        "$leakSimpleName leak from $rootSimpleName (holder=${firstElement.holder}, type= ${firstElement.reference!!.type})"
     )
     val stackTrace = mutableListOf<StackTraceElement>()
     leakTrace.elements.onEach { element ->
-      val methodName = if (element.referenceName != null) element.referenceName else "leaking"
+      val methodName = if (element.reference!!.name != null) element.reference.name else "leaking"
       val file = classSimpleName(element.className) + ".java"
       stackTrace.add(StackTraceElement(element.className, methodName, file, 42))
     }
@@ -109,7 +109,7 @@ data class AnalysisResult(
   }
 
   companion object {
-    val RETAINED_HEAP_SKIPPED: Long = -1
+    const val RETAINED_HEAP_SKIPPED: Long = -1
 
     fun noLeak(
       className: String,
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.java
deleted file mode 100644
index 3c9b0810a..000000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class Exclusion implements Serializable {
-  public final String name;
-  public final String reason;
-  public final boolean alwaysExclude;
-  public final String matching;
-
-  Exclusion(ExcludedRefs.ParamsBuilder builder) {
-    this.name = builder.getName();
-    this.reason = builder.getReason();
-    this.alwaysExclude = builder.getAlwaysExclude();
-    this.matching = builder.getMatching();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.kt
new file mode 100644
index 000000000..6493eea01
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Exclusion.kt
@@ -0,0 +1,10 @@
+package com.squareup.leakcanary
+
+import java.io.Serializable
+
+class Exclusion internal constructor(builder: ExcludedRefs.ParamsBuilder) : Serializable {
+  val name: String? = builder.name
+  val reason: String? = builder.reason
+  val alwaysExclude: Boolean = builder.alwaysExclude
+  val matching: String = builder.matching
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.kt
index dc39e5165..46d62aa19 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.kt
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.kt
@@ -22,12 +22,10 @@ import com.squareup.haha.perflib.Instance
 import com.squareup.haha.perflib.Type
 import java.lang.reflect.InvocationTargetException
 import java.nio.charset.Charset
-import java.util.ArrayList
 import java.util.Arrays.asList
 import java.util.HashSet
 
-// TODO @JvmStatic and make internal when all code is kotlin.
-object HahaHelper {
+internal object HahaHelper {
 
   private val WRAPPER_TYPES = HashSet(
       asList(
@@ -37,7 +35,7 @@ object HahaHelper {
       )
   )
 
-  @JvmStatic fun threadName(holder: Instance): String {
+  fun threadName(holder: Instance): String {
     val values = classInstanceValues(holder)
     val nameField = fieldValue<Any>(values, "name")
         ?: // Sometimes we can't find the String at the expected memory address in the heap dump.
@@ -46,7 +44,7 @@ object HahaHelper {
     return asString(nameField)
   }
 
-  @JvmStatic fun extendsThread(clazz: ClassObj): Boolean {
+  fun extendsThread(clazz: ClassObj): Boolean {
     var extendsThread = false
     var parentClass = clazz
     while (parentClass.superClassObj != null) {
@@ -62,7 +60,7 @@ object HahaHelper {
   /**
    * This returns a string representation of any object or value passed in.
    */
-  @JvmStatic fun valueAsString(value: Any?): String {
+  fun valueAsString(value: Any?): String {
     val stringValue: String
     if (value == null) {
       stringValue = "null"
@@ -79,8 +77,8 @@ object HahaHelper {
     return stringValue
   }
 
-  @JvmStatic fun asStringArray(arrayInstance: ArrayInstance): List<String> {
-    val entries = ArrayList<String>()
+  fun asStringArray(arrayInstance: ArrayInstance): MutableList<String> {
+    val entries = mutableListOf<String>()
     for (arrayEntry in arrayInstance.values) {
       entries.add(asString(arrayEntry))
     }
@@ -88,7 +86,7 @@ object HahaHelper {
   }
 
   /** Given a string instance from the heap dump, this returns its actual string value.  */
-  @JvmStatic fun asString(stringObject: Any): String {
+  fun asString(stringObject: Any): String {
     val instance = stringObject as Instance
     val values = classInstanceValues(instance)
 
@@ -140,7 +138,7 @@ object HahaHelper {
     }
   }
 
-  @JvmStatic fun isPrimitiveWrapper(value: Any): Boolean {
+  fun isPrimitiveWrapper(value: Any): Boolean {
     return if (value !is ClassInstance) {
       false
     } else WRAPPER_TYPES.contains(
@@ -148,7 +146,7 @@ object HahaHelper {
     )
   }
 
-  @JvmStatic fun isPrimitiveOrWrapperArray(value: Any): Boolean {
+  fun isPrimitiveOrWrapperArray(value: Any): Boolean {
     if (value !is ArrayInstance) {
       return false
     }
@@ -159,20 +157,20 @@ object HahaHelper {
     )
   }
 
-  @JvmStatic private fun isCharArray(value: Any): Boolean {
+  private fun isCharArray(value: Any): Boolean {
     return value is ArrayInstance && value.arrayType == Type.CHAR
   }
 
-  @JvmStatic private fun isByteArray(value: Any): Boolean {
+  private fun isByteArray(value: Any): Boolean {
     return value is ArrayInstance && value.arrayType == Type.BYTE
   }
 
-  @JvmStatic fun classInstanceValues(instance: Instance): List<ClassInstance.FieldValue> {
+  fun classInstanceValues(instance: Instance): List<ClassInstance.FieldValue> {
     val classInstance = instance as ClassInstance
     return classInstance.values
   }
 
-  @JvmStatic fun <T> fieldValue(
+  fun <T> fieldValue(
     values: List<ClassInstance.FieldValue>,
     fieldName: String
   ): T? {
@@ -185,7 +183,7 @@ object HahaHelper {
     throw IllegalArgumentException("Field $fieldName does not exists")
   }
 
-  @JvmStatic fun hasField(
+  fun hasField(
     values: List<ClassInstance.FieldValue>,
     fieldName: String
   ): Boolean {
@@ -198,7 +196,7 @@ object HahaHelper {
     return false
   }
 
-  @JvmStatic fun <T> staticFieldValue(
+  fun <T> staticFieldValue(
     classObj: ClassObj,
     fieldName: String
   ): T {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
deleted file mode 100644
index 228808dcb..000000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ /dev/null
@@ -1,521 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import androidx.annotation.NonNull;
-import com.android.tools.perflib.captures.DataBuffer;
-import com.android.tools.perflib.captures.MemoryMappedFileBuffer;
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import gnu.trove.THashMap;
-import gnu.trove.TObjectProcedure;
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import leaksentry.KeyedWeakReference;
-import org.jetbrains.annotations.TestOnly;
-
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE;
-import static com.squareup.leakcanary.HahaHelper.asString;
-import static com.squareup.leakcanary.HahaHelper.asStringArray;
-import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
-import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldValue;
-import static com.squareup.leakcanary.HahaHelper.staticFieldValue;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.HahaHelper.valueAsString;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.Reachability.Status.REACHABLE;
-import static com.squareup.leakcanary.Reachability.Status.UNREACHABLE;
-import static java.util.Collections.singletonList;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Analyzes heap dumps to look for leaks.
- */
-public final class HeapAnalyzer {
-
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs excludedRefs;
-  private final AnalyzerProgressListener listener;
-  private final List<Reachability.Inspector> reachabilityInspectors;
-  private final String keyedWeakReferenceClassName;
-
-  public HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
-      @NonNull AnalyzerProgressListener listener,
-      @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses) {
-    this(excludedRefs, listener, reachabilityInspectorClasses, KeyedWeakReference.class.getName());
-  }
-
-  @TestOnly HeapAnalyzer(@NonNull ExcludedRefs excludedRefs,
-      @NonNull AnalyzerProgressListener listener,
-      @NonNull List<Class<? extends Reachability.Inspector>> reachabilityInspectorClasses,
-      String keyedWeakReferenceClassName) {
-    this.excludedRefs = excludedRefs;
-    this.listener = listener;
-    this.keyedWeakReferenceClassName = keyedWeakReferenceClassName;
-
-    this.reachabilityInspectors = new ArrayList<>();
-    for (Class<? extends Reachability.Inspector> reachabilityInspectorClass
-        : reachabilityInspectorClasses) {
-      try {
-        Constructor<? extends Reachability.Inspector> defaultConstructor =
-            reachabilityInspectorClass.getDeclaredConstructor();
-        reachabilityInspectors.add(defaultConstructor.newInstance());
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   *
-   * @deprecated Use {@link #checkForLeaks(File, boolean)} instead. We're keeping this only because
-   * our tests currently run with older heapdumps.
-   */
-  @Deprecated @TestOnly
-  public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
-      @NonNull String referenceKey,
-      boolean computeRetainedSize) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return AnalysisResult.Companion.failure(exception, since(analysisStartNanoTime));
-    }
-
-    try {
-      listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
-      DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      listener.onProgressUpdate(PARSING_HEAP_DUMP);
-      Snapshot snapshot = Snapshot.createSnapshot(buffer);
-      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
-      deduplicateGcRoots(snapshot);
-      listener.onProgressUpdate(FINDING_LEAKING_REF);
-      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return AnalysisResult.Companion.noLeak("UnknownNoKeyedWeakReference",
-            since(analysisStartNanoTime));
-      }
-      return findLeakTrace(referenceKey, "NAME_NOT_SUPPORTED", analysisStartNanoTime, snapshot,
-          leakingRef, computeRetainedSize, 0);
-    } catch (Throwable e) {
-      return AnalysisResult.Companion.failure(e, since(analysisStartNanoTime));
-    }
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public @NonNull List<AnalysisResult> checkForLeaks(@NonNull File heapDumpFile,
-      boolean computeRetainedSize) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return singletonList(
-          AnalysisResult.Companion.failure(exception, since(analysisStartNanoTime)));
-    }
-
-    try {
-      listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
-      DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      listener.onProgressUpdate(PARSING_HEAP_DUMP);
-      Snapshot snapshot = Snapshot.createSnapshot(buffer);
-      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
-      deduplicateGcRoots(snapshot);
-      listener.onProgressUpdate(FINDING_LEAKING_REFS);
-
-      ClassObj heapDumpMemoryStoreClass = snapshot.findClass(HeapDumpMemoryStore.class.getName());
-      ArrayInstance retainedKeysArray =
-          staticFieldValue(heapDumpMemoryStoreClass, "retainedKeysForHeapDump");
-      List<String> retainedKeys = asStringArray(retainedKeysArray);
-      long heapDumpUptimeMillis =
-          staticFieldValue(heapDumpMemoryStoreClass, "heapDumpUptimeMillis");
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (retainedKeys.size() == 0) {
-        IllegalStateException exception =
-            new IllegalStateException("No retained keys found in heap dump");
-        return singletonList(
-            AnalysisResult.Companion.failure(exception, since(analysisStartNanoTime)));
-      }
-
-      ClassObj refClass = snapshot.findClass(keyedWeakReferenceClassName);
-      if (refClass == null) {
-        throw new IllegalStateException(
-            "Could not find the "
-                + keyedWeakReferenceClassName
-                + " class in the heap dump.");
-      }
-      List<Instance> leakingWeakRefs = new ArrayList<>();
-      List<String> keysFound = new ArrayList<>();
-      for (Instance instance : refClass.getInstancesList()) {
-        List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-        Object keyFieldValue = fieldValue(values, "key");
-        if (keyFieldValue == null) {
-          keysFound.add(null);
-          continue;
-        }
-        String keyCandidate = asString(keyFieldValue);
-        boolean wasRetained = retainedKeys.remove(keyCandidate);
-        if (wasRetained) {
-          leakingWeakRefs.add(instance);
-        }
-        keysFound.add(keyCandidate);
-      }
-      if (retainedKeys.size() > 0) {
-        throw new IllegalStateException(
-            "Could not find weak references with keys " + retainedKeys + " in " + keysFound);
-      }
-
-      List<AnalysisResult> analysisResults = new ArrayList<>();
-      for (Instance leakingWeakRef : leakingWeakRefs) {
-        List<ClassInstance.FieldValue> values = classInstanceValues(leakingWeakRef);
-        Instance referent = fieldValue(values, "referent");
-        String key = asString(
-            fieldValue(values, "key"));
-        String name = asString(fieldValue(values, "name"));
-        long watchUptimeMillis = fieldValue(values, "watchUptimeMillis");
-        long watchDurationMillis = heapDumpUptimeMillis - watchUptimeMillis;
-        analysisResults.add(
-            findLeakTrace(key, name, analysisStartNanoTime, snapshot, referent,
-                computeRetainedSize, watchDurationMillis));
-      }
-      return analysisResults;
-    } catch (Throwable e) {
-      return singletonList(AnalysisResult.Companion.failure(e, since(analysisStartNanoTime)));
-    }
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  void deduplicateGcRoots(Snapshot snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
-
-    final Collection<RootObj> gcRoots = snapshot.getGCRoots();
-    for (RootObj root : gcRoots) {
-      String key = generateRootKey(root);
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap.put(key, root);
-      }
-    }
-
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
-    uniqueRootMap.forEach(new TObjectProcedure<String>() {
-      @Override public boolean execute(String key) {
-        return gcRoots.add(uniqueRootMap.get(key));
-      }
-    });
-  }
-
-  private String generateRootKey(RootObj root) {
-    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
-  }
-
-  private Instance findLeakingReference(String key, Snapshot snapshot) {
-    ClassObj refClass = snapshot.findClass(keyedWeakReferenceClassName);
-    if (refClass == null) {
-      throw new IllegalStateException(
-          "Could not find the " + keyedWeakReferenceClassName + " class in the heap dump.");
-    }
-    List<String> keysFound = new ArrayList<>();
-    for (Instance instance : refClass.getInstancesList()) {
-      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      Object keyFieldValue = fieldValue(values, "key");
-      if (keyFieldValue == null) {
-        keysFound.add(null);
-        continue;
-      }
-      String keyCandidate = asString(keyFieldValue);
-      if (keyCandidate.equals(key)) {
-        return fieldValue(values, "referent");
-      }
-      keysFound.add(keyCandidate);
-    }
-    throw new IllegalStateException(
-        "Could not find weak reference with key " + key + " in " + keysFound);
-  }
-
-  private AnalysisResult findLeakTrace(String referenceKey,
-      String referenceName, long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef, boolean computeRetainedSize, long watchDurationMs) {
-
-    listener.onProgressUpdate(FINDING_SHORTEST_PATH);
-    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
-    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
-
-    String className = leakingRef.getClassObj().getClassName();
-
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return AnalysisResult.Companion.noLeak(className, since(analysisStartNanoTime));
-    }
-
-    listener.onProgressUpdate(BUILDING_LEAK_TRACE);
-    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
-
-    long retainedSize;
-    if (computeRetainedSize) {
-
-      listener.onProgressUpdate(COMPUTING_DOMINATORS);
-      // Side effect: computes retained size.
-      snapshot.computeDominators();
-
-      Instance leakingInstance = result.leakingNode.getInstance();
-
-      retainedSize = leakingInstance.getTotalRetainedSize();
-    } else {
-      retainedSize = AnalysisResult.Companion.getRETAINED_HEAP_SKIPPED();
-    }
-
-    return AnalysisResult.Companion.leakDetected(referenceKey, referenceName,
-        result.excludingKnownLeaks, className, leakTrace,
-        retainedSize,
-        since(analysisStartNanoTime), watchDurationMs);
-  }
-
-  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null);
-    while (node != null) {
-      LeakTraceElement element = buildLeakElement(node);
-      if (element != null) {
-        elements.add(0, element);
-      }
-      node = node.getParent();
-    }
-
-    List<Reachability> expectedReachability =
-        computeExpectedReachability(elements);
-
-    return new LeakTrace(elements, expectedReachability);
-  }
-
-  private List<Reachability> computeExpectedReachability(
-      List<LeakTraceElement> elements) {
-    int lastReachableElementIndex = 0;
-    int lastElementIndex = elements.size() - 1;
-    int firstUnreachableElementIndex = lastElementIndex;
-
-    List<Reachability> expectedReachability = new ArrayList<>();
-
-    int index = 0;
-    for (LeakTraceElement element : elements) {
-      Reachability reachability = inspectElementReachability(element);
-      expectedReachability.add(reachability);
-      if (reachability.status == REACHABLE) {
-        lastReachableElementIndex = index;
-      } else if (firstUnreachableElementIndex == lastElementIndex
-          && reachability.status == UNREACHABLE) {
-        firstUnreachableElementIndex = index;
-      }
-      index++;
-    }
-
-    if (expectedReachability.get(0).status == Reachability.Status.UNKNOWN) {
-      expectedReachability.set(0, Reachability.reachable("it's a GC root"));
-    }
-
-    if (expectedReachability.get(lastElementIndex).status == Reachability.Status.UNKNOWN) {
-      expectedReachability.set(lastElementIndex,
-          Reachability.unreachable("it's the leaking instance"));
-    }
-
-    // First and last are always known.
-    for (int i = 1; i < lastElementIndex; i++) {
-      Reachability reachability = expectedReachability.get(i);
-      if (reachability.status == Reachability.Status.UNKNOWN) {
-        if (i <= lastReachableElementIndex) {
-          String lastReachableName = elements.get(lastReachableElementIndex).getSimpleClassName();
-          expectedReachability.set(i,
-              Reachability.reachable(lastReachableName + " is not leaking"));
-        } else if (i >= firstUnreachableElementIndex) {
-          String firstUnreachableName =
-              elements.get(firstUnreachableElementIndex).getSimpleClassName();
-          expectedReachability.set(i,
-              Reachability.unreachable(firstUnreachableName + " is leaking"));
-        }
-      }
-    }
-    return expectedReachability;
-  }
-
-  private Reachability inspectElementReachability(LeakTraceElement element) {
-    for (Reachability.Inspector reachabilityInspector : reachabilityInspectors) {
-      Reachability reachability = reachabilityInspector.expectedReachability(element);
-      if (reachability.status != Reachability.Status.UNKNOWN) {
-        return reachability;
-      }
-    }
-    return Reachability.unknown();
-  }
-
-  private LeakTraceElement buildLeakElement(LeakNode node) {
-    if (node.getParent() == null) {
-      // Ignore any root node.
-      return null;
-    }
-    Instance holder = node.getParent().getInstance();
-
-    if (holder instanceof RootObj) {
-      return null;
-    }
-    LeakTraceElement.Holder holderType;
-    String className;
-    String extra = null;
-    List<LeakReference> leakReferences = describeFields(holder);
-
-    className = getClassName(holder);
-
-    List<String> classHierarchy = new ArrayList<>();
-    classHierarchy.add(className);
-    String rootClassName = Object.class.getName();
-    if (holder instanceof ClassInstance) {
-      ClassObj classObj = holder.getClassObj();
-      while (!(classObj = classObj.getSuperClassObj()).getClassName().equals(rootClassName)) {
-        classHierarchy.add(classObj.getClassName());
-      }
-    }
-
-    if (holder instanceof ClassObj) {
-      holderType = CLASS;
-    } else if (holder instanceof ArrayInstance) {
-      holderType = ARRAY;
-    } else {
-      ClassObj classObj = holder.getClassObj();
-      if (extendsThread(classObj)) {
-        holderType = THREAD;
-        String threadName = threadName(holder);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (rootClassName.equals(parentClassName)) {
-          holderType = OBJECT;
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?>[] interfaces = actualClass.getInterfaces();
-            if (interfaces.length > 0) {
-              Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
-            } else {
-              extra = "(anonymous subclass of java.lang.Object)";
-            }
-          } catch (ClassNotFoundException ignored) {
-          }
-        } else {
-          holderType = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of " + parentClassName + ")";
-        }
-      } else {
-        holderType = OBJECT;
-      }
-    }
-    return new LeakTraceElement(node.getLeakReference(), holderType, classHierarchy, extra,
-        node.getExclusion(), leakReferences);
-  }
-
-  private List<LeakReference> describeFields(Instance instance) {
-    List<LeakReference> leakReferences = new ArrayList<>();
-    if (instance instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) instance;
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        String name = entry.getKey().getName();
-        String stringValue = valueAsString(entry.getValue());
-        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
-      }
-    } else if (instance instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) instance;
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          String name = Integer.toString(i);
-          String stringValue = valueAsString(values[i]);
-          leakReferences.add(new LeakReference(ARRAY_ENTRY, name, stringValue));
-        }
-      }
-    } else {
-      ClassObj classObj = instance.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        String name = entry.getKey().getName();
-        String stringValue = valueAsString(entry.getValue());
-        leakReferences.add(new LeakReference(STATIC_FIELD, name, stringValue));
-      }
-      ClassInstance classInstance = (ClassInstance) instance;
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        String name = field.getField().getName();
-        String stringValue = valueAsString(field.getValue());
-        leakReferences.add(new LeakReference(INSTANCE_FIELD, name, stringValue));
-      }
-    }
-    return leakReferences;
-  }
-
-  private String getClassName(Instance instance) {
-    String className;
-    if (instance instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) instance;
-      className = classObj.getClassName();
-    } else if (instance instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) instance;
-      className = arrayInstance.getClassObj().getClassName();
-    } else {
-      ClassObj classObj = instance.getClassObj();
-      className = classObj.getClassName();
-    }
-    return className;
-  }
-
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.kt
new file mode 100644
index 000000000..42db79397
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.kt
@@ -0,0 +1,517 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import com.android.tools.perflib.captures.MemoryMappedFileBuffer
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Instance
+import com.squareup.haha.perflib.RootObj
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
+import com.squareup.leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
+import com.squareup.leakcanary.HahaHelper.asString
+import com.squareup.leakcanary.HahaHelper.asStringArray
+import com.squareup.leakcanary.HahaHelper.classInstanceValues
+import com.squareup.leakcanary.HahaHelper.extendsThread
+import com.squareup.leakcanary.HahaHelper.fieldValue
+import com.squareup.leakcanary.HahaHelper.staticFieldValue
+import com.squareup.leakcanary.HahaHelper.threadName
+import com.squareup.leakcanary.HahaHelper.valueAsString
+import com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY
+import com.squareup.leakcanary.LeakTraceElement.Holder.CLASS
+import com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT
+import com.squareup.leakcanary.LeakTraceElement.Holder.THREAD
+import com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import com.squareup.leakcanary.Reachability.Status.REACHABLE
+import com.squareup.leakcanary.Reachability.Status.UNREACHABLE
+import gnu.trove.THashMap
+import gnu.trove.TObjectProcedure
+import leaksentry.KeyedWeakReference
+import org.jetbrains.annotations.TestOnly
+import java.io.File
+import java.util.ArrayList
+import java.util.concurrent.TimeUnit.NANOSECONDS
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+class HeapAnalyzer @TestOnly internal constructor(
+  private val excludedRefs: ExcludedRefs,
+  private val listener: AnalyzerProgressListener,
+  reachabilityInspectorClasses: List<Class<out Reachability.Inspector>>,
+  private val keyedWeakReferenceClassName: String
+) {
+  private val reachabilityInspectors: MutableList<Reachability.Inspector> = mutableListOf()
+
+  constructor(
+    excludedRefs: ExcludedRefs,
+    listener: AnalyzerProgressListener,
+    reachabilityInspectorClasses: List<Class<out Reachability.Inspector>>
+  ) : this(
+      excludedRefs, listener, reachabilityInspectorClasses, KeyedWeakReference::class.java.name
+  )
+
+  init {
+    for (reachabilityInspectorClass in reachabilityInspectorClasses) {
+      try {
+        val defaultConstructor = reachabilityInspectorClass.getDeclaredConstructor()
+        reachabilityInspectors.add(defaultConstructor.newInstance())
+      } catch (e: Exception) {
+        throw RuntimeException(e)
+      }
+
+    }
+  }
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   *
+   */
+  @TestOnly
+  @Deprecated(
+      "Use {@link #checkForLeaks(File, boolean)} instead. We're keeping this only because\n" +
+          "    our tests currently run with older heapdumps."
+  )
+  fun checkForLeak(
+    heapDumpFile: File,
+    referenceKey: String,
+    computeRetainedSize: Boolean
+  ): AnalysisResult {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      return AnalysisResult.failure(exception, since(analysisStartNanoTime))
+    }
+
+    try {
+      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+      val buffer = MemoryMappedFileBuffer(heapDumpFile)
+      listener.onProgressUpdate(PARSING_HEAP_DUMP)
+      val snapshot = Snapshot.createSnapshot(buffer)
+      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
+      deduplicateGcRoots(snapshot)
+      listener.onProgressUpdate(FINDING_LEAKING_REF)
+      val leakingRef = findLeakingReference(referenceKey, snapshot) ?: return AnalysisResult.noLeak(
+          "UnknownNoKeyedWeakReference",
+          since(analysisStartNanoTime)
+      )
+
+      // False alarm, weak reference was cleared in between key check and heap dump.
+      return findLeakTrace(
+          referenceKey, "NAME_NOT_SUPPORTED", analysisStartNanoTime, snapshot,
+          leakingRef, computeRetainedSize, 0
+      )
+    } catch (e: Throwable) {
+      return AnalysisResult.failure(e, since(analysisStartNanoTime))
+    }
+
+  }
+
+  /**
+   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
+   * and then computes the shortest strong reference path from that instance to the GC roots.
+   */
+  fun checkForLeaks(
+    heapDumpFile: File,
+    computeRetainedSize: Boolean
+  ): List<AnalysisResult> {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      return listOf(AnalysisResult.failure(exception, since(analysisStartNanoTime)))
+    }
+
+    try {
+      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
+      val buffer = MemoryMappedFileBuffer(heapDumpFile)
+      listener.onProgressUpdate(PARSING_HEAP_DUMP)
+      val snapshot = Snapshot.createSnapshot(buffer)
+      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
+      deduplicateGcRoots(snapshot)
+      listener.onProgressUpdate(FINDING_LEAKING_REFS)
+
+      val heapDumpMemoryStoreClass = snapshot.findClass(HeapDumpMemoryStore::class.java.name)
+      val retainedKeysArray =
+        staticFieldValue<ArrayInstance>(heapDumpMemoryStoreClass, "retainedKeysForHeapDump")
+      val retainedKeys = asStringArray(retainedKeysArray)
+      val heapDumpUptimeMillis =
+        staticFieldValue<Long>(heapDumpMemoryStoreClass, "heapDumpUptimeMillis")
+
+      if (retainedKeys.size == 0) {
+        val exception = IllegalStateException("No retained keys found in heap dump")
+        return listOf(AnalysisResult.failure(exception, since(analysisStartNanoTime)))
+      }
+
+      val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
+          "Could not find the "
+              + keyedWeakReferenceClassName
+              + " class in the heap dump."
+      )
+      val leakingWeakRefs = ArrayList<Instance>()
+      val keysFound = ArrayList<String?>()
+      for (instance in refClass.instancesList) {
+        val values = classInstanceValues(instance)
+        val keyFieldValue = fieldValue<Any>(values, "key")
+        if (keyFieldValue == null) {
+          keysFound.add(null)
+          continue
+        }
+        val keyCandidate = asString(keyFieldValue)
+        val wasRetained = retainedKeys.remove(keyCandidate)
+        if (wasRetained) {
+          leakingWeakRefs.add(instance)
+        }
+        keysFound.add(keyCandidate)
+      }
+      if (retainedKeys.size > 0) {
+        throw IllegalStateException(
+            "Could not find weak references with keys $retainedKeys in $keysFound"
+        )
+      }
+
+      val analysisResults = ArrayList<AnalysisResult>()
+      for (leakingWeakRef in leakingWeakRefs) {
+        val values = classInstanceValues(leakingWeakRef)
+        val referent = fieldValue<Instance>(values, "referent")
+        val name = asString(fieldValue<Any>(values, "name")!!)
+        if (referent != null) {
+          val key = asString(
+              fieldValue<Any>(values, "key")!!
+          )
+          val watchUptimeMillis = fieldValue<Long>(values, "watchUptimeMillis")!!
+          val watchDurationMillis = heapDumpUptimeMillis - watchUptimeMillis
+          analysisResults.add(
+              findLeakTrace(
+                  key, name, analysisStartNanoTime, snapshot, referent,
+                  computeRetainedSize, watchDurationMillis
+              )
+          )
+        } else {
+          analysisResults.add(AnalysisResult.noLeak(name, since(analysisStartNanoTime)))
+        }
+      }
+
+      return analysisResults
+    } catch (e: Throwable) {
+      return listOf(AnalysisResult.failure(e, since(analysisStartNanoTime)))
+    }
+
+  }
+
+  /**
+   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+   */
+  internal fun deduplicateGcRoots(snapshot: Snapshot) {
+    // THashMap has a smaller memory footprint than HashMap.
+    val uniqueRootMap = THashMap<String, RootObj>()
+
+    val gcRoots = snapshot.gcRoots
+    for (root in gcRoots) {
+      val key = generateRootKey(root)
+      if (!uniqueRootMap.containsKey(key)) {
+        uniqueRootMap[key] = root
+      }
+    }
+
+    // Repopulate snapshot with unique GC roots.
+    gcRoots.clear()
+    uniqueRootMap.forEach(TObjectProcedure { key -> gcRoots.add(uniqueRootMap[key]) })
+  }
+
+  private fun generateRootKey(root: RootObj): String {
+    return String.format("%s@0x%08x", root.rootType.getName(), root.id)
+  }
+
+  private fun findLeakingReference(
+    key: String,
+    snapshot: Snapshot
+  ): Instance? {
+    val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
+        "Could not find the $keyedWeakReferenceClassName class in the heap dump."
+    )
+    val keysFound = ArrayList<String?>()
+    for (instance in refClass.instancesList) {
+      val values = classInstanceValues(instance)
+      val keyFieldValue = fieldValue<Any>(values, "key")
+      if (keyFieldValue == null) {
+        keysFound.add(null)
+        continue
+      }
+      val keyCandidate = asString(keyFieldValue)
+      if (keyCandidate == key) {
+        return fieldValue<Instance>(values, "referent")
+      }
+      keysFound.add(keyCandidate)
+    }
+    throw IllegalStateException(
+        "Could not find weak reference with key $key in $keysFound"
+    )
+  }
+
+  private fun findLeakTrace(
+    referenceKey: String,
+    referenceName: String,
+    analysisStartNanoTime: Long,
+    snapshot: Snapshot,
+    leakingRef: Instance,
+    computeRetainedSize: Boolean,
+    watchDurationMs: Long
+  ): AnalysisResult {
+
+    listener.onProgressUpdate(FINDING_SHORTEST_PATH)
+    val pathFinder = ShortestPathFinder(excludedRefs)
+    val result = pathFinder.findPath(snapshot, leakingRef)
+
+    val className = leakingRef.classObj.className
+
+    // False alarm, no strong reference path to GC Roots.
+    if (result.leakingNode == null) {
+      return AnalysisResult.noLeak(className, since(analysisStartNanoTime))
+    }
+
+    listener.onProgressUpdate(BUILDING_LEAK_TRACE)
+    val leakTrace = buildLeakTrace(result.leakingNode)
+
+    val retainedSize = if (computeRetainedSize) {
+      listener.onProgressUpdate(COMPUTING_DOMINATORS)
+      // Side effect: computes retained size.
+      snapshot.computeDominators()
+
+      val leakingInstance = result.leakingNode.instance
+
+      leakingInstance!!.totalRetainedSize
+    } else {
+      AnalysisResult.RETAINED_HEAP_SKIPPED
+    }
+
+    return AnalysisResult.leakDetected(
+        referenceKey, referenceName,
+        result.excludingKnownLeaks, className, leakTrace,
+        retainedSize,
+        since(analysisStartNanoTime), watchDurationMs
+    )
+  }
+
+  private fun buildLeakTrace(leakingNode: LeakNode): LeakTrace {
+    val elements = ArrayList<LeakTraceElement>()
+    // We iterate from the leak to the GC root
+    var node: LeakNode? = LeakNode(null, null, leakingNode, null)
+    while (node != null) {
+      val element = buildLeakElement(node)
+      if (element != null) {
+        elements.add(0, element)
+      }
+      node = node.parent
+    }
+
+    val expectedReachability = computeExpectedReachability(elements)
+
+    return LeakTrace(elements, expectedReachability)
+  }
+
+  private fun computeExpectedReachability(
+    elements: List<LeakTraceElement>
+  ): List<Reachability> {
+    var lastReachableElementIndex = 0
+    val lastElementIndex = elements.size - 1
+    var firstUnreachableElementIndex = lastElementIndex
+
+    val expectedReachability = ArrayList<Reachability>()
+
+    for ((index, element) in elements.withIndex()) {
+      val reachability = inspectElementReachability(element)
+      expectedReachability.add(reachability)
+      if (reachability.status == REACHABLE) {
+        lastReachableElementIndex = index
+      } else if (firstUnreachableElementIndex == lastElementIndex && reachability.status == UNREACHABLE) {
+        firstUnreachableElementIndex = index
+      }
+    }
+
+    if (expectedReachability[0].status == Reachability.Status.UNKNOWN) {
+      expectedReachability[0] = Reachability.reachable("it's a GC root")
+    }
+
+    if (expectedReachability[lastElementIndex].status == Reachability.Status.UNKNOWN) {
+      expectedReachability[lastElementIndex] = Reachability.unreachable("it's the leaking instance")
+    }
+
+    // First and last are always known.
+    for (i in 1 until lastElementIndex) {
+      val reachability = expectedReachability[i]
+      if (reachability.status == Reachability.Status.UNKNOWN) {
+        if (i <= lastReachableElementIndex) {
+          val lastReachableName = elements[lastReachableElementIndex].getSimpleClassName()
+          expectedReachability[i] = Reachability.reachable("$lastReachableName is not leaking")
+        } else if (i >= firstUnreachableElementIndex) {
+          val firstUnreachableName = elements[firstUnreachableElementIndex].getSimpleClassName()
+          expectedReachability[i] = Reachability.unreachable("$firstUnreachableName is leaking")
+        }
+      }
+    }
+    return expectedReachability
+  }
+
+  private fun inspectElementReachability(element: LeakTraceElement): Reachability {
+    for (reachabilityInspector in reachabilityInspectors) {
+      val reachability = reachabilityInspector.expectedReachability(element)
+      if (reachability.status != Reachability.Status.UNKNOWN) {
+        return reachability
+      }
+    }
+    return Reachability.unknown()
+  }
+
+  private fun buildLeakElement(node: LeakNode): LeakTraceElement? {
+    if (node.parent == null) {
+      // Ignore any root node.
+      return null
+    }
+    val holder = node.parent.instance!!
+
+    if (holder is RootObj) {
+      return null
+    }
+    val holderType: LeakTraceElement.Holder
+    val className: String
+    var extra: String? = null
+    val leakReferences = describeFields(holder)
+
+    className = getClassName(holder)
+
+    val classHierarchy = ArrayList<String>()
+    classHierarchy.add(className)
+    val rootClassName = Any::class.java.name
+    if (holder is ClassInstance) {
+      var classObj = holder.classObj
+
+      do {
+        classObj = classObj.superClassObj
+        if (classObj.className != rootClassName) {
+          classHierarchy.add(classObj.className)
+        }
+      } while (classObj.className != rootClassName)
+    }
+
+    if (holder is ClassObj) {
+      holderType = CLASS
+    } else if (holder is ArrayInstance) {
+      holderType = ARRAY
+    } else {
+      val classObj = holder.classObj
+      if (extendsThread(classObj)) {
+        holderType = THREAD
+        val threadName = threadName(holder)
+        extra = "(named '$threadName')"
+      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN.toRegex())) {
+        val parentClassName = classObj.superClassObj.className
+        if (rootClassName == parentClassName) {
+          holderType = OBJECT
+          try {
+            // This is an anonymous class implementing an interface. The API does not give access
+            // to the interfaces implemented by the class. We check if it's in the class path and
+            // use that instead.
+            val actualClass = Class.forName(classObj.className)
+            val interfaces = actualClass.interfaces
+            extra = if (interfaces.isNotEmpty()) {
+              val implementedInterface = interfaces[0]
+              "(anonymous implementation of " + implementedInterface.name + ")"
+            } else {
+              "(anonymous subclass of java.lang.Object)"
+            }
+          } catch (ignored: ClassNotFoundException) {
+          }
+
+        } else {
+          holderType = OBJECT
+          // Makes it easier to figure out which anonymous class we're looking at.
+          extra = "(anonymous subclass of $parentClassName)"
+        }
+      } else {
+        holderType = OBJECT
+      }
+    }
+    return LeakTraceElement(
+        node.leakReference, holderType, classHierarchy, extra,
+        node.exclusion, leakReferences
+    )
+  }
+
+  private fun describeFields(instance: Instance?): List<LeakReference> {
+    val leakReferences = ArrayList<LeakReference>()
+    if (instance is ClassObj) {
+      val classObj = instance as ClassObj?
+      for ((key, value) in classObj!!.staticFieldValues) {
+        val name = key.name
+        val stringValue = valueAsString(value)
+        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
+      }
+    } else if (instance is ArrayInstance) {
+      val arrayInstance = instance as ArrayInstance?
+      if (arrayInstance!!.arrayType == Type.OBJECT) {
+        val values = arrayInstance.values
+        for (i in values.indices) {
+          val name = Integer.toString(i)
+          val stringValue = valueAsString(values[i])
+          leakReferences.add(LeakReference(ARRAY_ENTRY, name, stringValue))
+        }
+      }
+    } else {
+      val classObj = instance!!.classObj
+      for ((key, value) in classObj.staticFieldValues) {
+        val name = key.name
+        val stringValue = valueAsString(value)
+        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
+      }
+      val classInstance = instance as ClassInstance?
+      for (field in classInstance!!.values) {
+        val name = field.field.name
+        val stringValue = valueAsString(field.value)
+        leakReferences.add(LeakReference(INSTANCE_FIELD, name, stringValue))
+      }
+    }
+    return leakReferences
+  }
+
+  private fun getClassName(instance: Instance): String = when (instance) {
+    is ClassObj -> instance.className
+    is ArrayInstance -> instance.classObj.className
+    else -> instance.classObj.className
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+
+  companion object {
+
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java
deleted file mode 100644
index 824e329bc..000000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-/**
- * A single field in a {@link LeakTraceElement}.
- */
-public final class LeakReference implements Serializable {
-
-  public final LeakTraceElement.Type type;
-  public final String name;
-  public final String value;
-
-  public LeakReference(LeakTraceElement.Type type, String name, String value) {
-    this.type = type;
-    this.name = name;
-    this.value = value;
-  }
-
-  public String getDisplayName() {
-    switch (type) {
-      case ARRAY_ENTRY:
-        return "[" + name + "]";
-      case STATIC_FIELD:
-      case INSTANCE_FIELD:
-        return name;
-      case LOCAL:
-        return "<Java Local>";
-      default:
-        throw new IllegalStateException(
-            "Unexpected type " + type + " name = " + name + " value = " + value);
-    }
-  }
-
-  @Override public String toString() {
-    switch (type) {
-      case ARRAY_ENTRY:
-      case INSTANCE_FIELD:
-        return getDisplayName() + " = " + value;
-      case STATIC_FIELD:
-        return "static " + getDisplayName() + " = " + value;
-      case LOCAL:
-        return getDisplayName();
-      default:
-        throw new IllegalStateException(
-            "Unexpected type " + type + " name = " + name + " value = " + value);
-    }
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.kt
new file mode 100644
index 000000000..e76e58ba5
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakReference.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import java.io.Serializable
+
+/**
+ * A single field in a [LeakTraceElement].
+ */
+class LeakReference(
+  val type: LeakTraceElement.Type,
+  val name: String?,
+  val value: String?
+) : Serializable {
+
+  val displayName: String
+    get() {
+      return when (type) {
+        LeakTraceElement.Type.ARRAY_ENTRY -> "[$name]"
+        LeakTraceElement.Type.STATIC_FIELD, LeakTraceElement.Type.INSTANCE_FIELD -> name!!
+        LeakTraceElement.Type.LOCAL -> "<Java Local>"
+      }
+    }
+
+  override fun toString(): String {
+    return when (type) {
+      LeakTraceElement.Type.ARRAY_ENTRY, LeakTraceElement.Type.INSTANCE_FIELD -> "$displayName = $value"
+      LeakTraceElement.Type.STATIC_FIELD -> "static $displayName = $value"
+      LeakTraceElement.Type.LOCAL -> displayName
+    }
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.kt
index d5d0d3286..594e131c4 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.kt
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.kt
@@ -51,7 +51,7 @@ data class LeakTrace(
       UNKNOWN -> true
       REACHABLE -> {
         if (index < elements.lastIndex) {
-          val nextReachability = expectedReachability.get(index + 1);
+          val nextReachability = expectedReachability[index + 1]
           nextReachability.status != REACHABLE
         } else {
           true
@@ -63,7 +63,7 @@ data class LeakTrace(
   }
 
   private fun getReachabilityString(reachability: Reachability): String {
-    return DEFAULT_NEWLINE_SPACE + "Leaking: " + when (reachability.status!!) {
+    return DEFAULT_NEWLINE_SPACE + "Leaking: " + when (reachability.status) {
       UNKNOWN -> "UNKNOWN"
       REACHABLE -> "NO (${reachability.reason})"
       UNREACHABLE -> "YES (${reachability.reason})"
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.kt
index e5945a279..c7ca005b9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.kt
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.kt
@@ -32,22 +32,7 @@ data class LeakTraceElement(
   val fieldReferences: List<LeakReference>
 ) : Serializable {
 
-  @Deprecated(
-      "Use {@link #reference} and {@link LeakReference#getDisplayName()} instead.\n" +
-          "    Null if this is the last element in the leak trace, ie the leaking object."
-  )
-  val referenceName: String?
-
-  @Deprecated(
-      "Use {@link #reference} and {@link LeakReference#type} instead.\n" +
-          "    Null if this is the last element in the leak trace, ie the leaking object."
-  )
-  val type: Type?
-
-  val className: String
-
-  @Deprecated("Use {@link #fieldReferences} instead.")
-  val fields: List<String>
+  val className: String = classHierarchy[0]
 
   enum class Type {
     INSTANCE_FIELD,
@@ -64,14 +49,10 @@ data class LeakTraceElement(
   }
 
   init {
-    this.referenceName = reference?.displayName
-    this.type = reference?.type
-    this.className = classHierarchy[0]
     val stringFields = mutableListOf<String>()
     fieldReferences.forEach { leakReference ->
       stringFields.add(leakReference.toString())
     }
-    fields = stringFields.toList()
   }
 
   /**
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.java
deleted file mode 100644
index e431d3eb7..000000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-/** Result returned by {@link Inspector#expectedReachability(LeakTraceElement)}. */
-public final class Reachability implements Serializable {
-
-  private static final Reachability UNKNOWN_REACHABILITY = new Reachability(Status.UNKNOWN, "");
-
-  /** The instance was needed and therefore expected to be reachable. */
-  public static Reachability reachable(String reason) {
-    return new Reachability(Status.REACHABLE, reason);
-  }
-
-  /** The instance was no longer needed and therefore expected to be unreachable. */
-  public static Reachability unreachable(String reason) {
-    return new Reachability(Status.UNREACHABLE, reason);
-  }
-
-  /** No decision can be made about the provided instance. */
-  public static Reachability unknown() {
-    return UNKNOWN_REACHABILITY;
-  }
-
-  public enum Status {
-    REACHABLE,
-    UNREACHABLE,
-    UNKNOWN
-  }
-
-  public final String reason;
-  public final Status status;
-
-  private Reachability(Status status, String reason) {
-    this.reason = reason;
-    this.status = status;
-  }
-
-  /**
-   * Evaluates whether a {@link LeakTraceElement} should be reachable or not.
-   *
-   * Implementations should have a public zero argument constructor as instances will be created
-   * via reflection in the LeakCanary analysis process.
-   */
-  public interface Inspector {
-
-    Reachability expectedReachability(LeakTraceElement element);
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.kt
new file mode 100644
index 000000000..ee4d7208e
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/Reachability.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import com.squareup.leakcanary.Reachability.Inspector
+import java.io.Serializable
+
+/** Result returned by [Inspector.expectedReachability].  */
+class Reachability private constructor(
+  val status: Status,
+  val reason: String
+) : Serializable {
+
+  enum class Status {
+    REACHABLE,
+    UNREACHABLE,
+    UNKNOWN
+  }
+
+  /**
+   * Evaluates whether a [LeakTraceElement] should be reachable or not.
+   *
+   * Implementations should have a public zero argument constructor as instances will be created
+   * via reflection in the LeakCanary analysis process.
+   */
+  interface Inspector {
+
+    fun expectedReachability(element: LeakTraceElement): Reachability
+  }
+
+  companion object {
+
+    private val UNKNOWN_REACHABILITY = Reachability(Status.UNKNOWN, "")
+
+    /** The instance was needed and therefore expected to be reachable.  */
+    fun reachable(reason: String): Reachability {
+      return Reachability(Status.REACHABLE, reason)
+    }
+
+    /** The instance was no longer needed and therefore expected to be unreachable.  */
+    fun unreachable(reason: String): Reachability {
+      return Reachability(Status.UNREACHABLE, reason)
+    }
+
+    /** No decision can be made about the provided instance.  */
+    fun unknown(): Reachability {
+      return UNKNOWN_REACHABILITY
+    }
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
deleted file mode 100644
index da42751a3..000000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HahaSpyKt;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
-import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- */
-final class ShortestPathFinder {
-
-  private final ExcludedRefs excludedRefs;
-  private final Deque<LeakNode> toVisitQueue;
-  private final Deque<LeakNode> toVisitIfNoPathQueue;
-  private final LinkedHashSet<Instance> toVisitSet;
-  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
-  private final LinkedHashSet<Instance> visitedSet;
-  private boolean canIgnoreStrings;
-
-  ShortestPathFinder(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-    toVisitQueue = new ArrayDeque<>();
-    toVisitIfNoPathQueue = new ArrayDeque<>();
-    toVisitSet = new LinkedHashSet<>();
-    toVisitIfNoPathSet = new LinkedHashSet<>();
-    visitedSet = new LinkedHashSet<>();
-  }
-
-  static final class Result {
-    final LeakNode leakingNode;
-    final boolean excludingKnownLeaks;
-
-    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
-      this.leakingNode = leakingNode;
-      this.excludingKnownLeaks = excludingKnownLeaks;
-    }
-  }
-
-  Result findPath(Snapshot snapshot, Instance leakingRef) {
-    clearState();
-    canIgnoreStrings = !isString(leakingRef);
-
-    enqueueGcRoots(snapshot);
-
-    boolean excludingKnownLeaks = false;
-    LeakNode leakingNode = null;
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      LeakNode node;
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll();
-      } else {
-        node = toVisitIfNoPathQueue.poll();
-        if (node.getExclusion() == null) {
-          throw new IllegalStateException("Expected node to have an exclusion " + node);
-        }
-        excludingKnownLeaks = true;
-      }
-
-      // Termination
-      if (node.getInstance() == leakingRef) {
-        leakingNode = node;
-        break;
-      }
-
-      if (checkSeen(node)) {
-        continue;
-      }
-
-      if (node.getInstance() instanceof RootObj) {
-        visitRootObj(node);
-      } else if (node.getInstance() instanceof ClassObj) {
-        visitClassObj(node);
-      } else if (node.getInstance() instanceof ClassInstance) {
-        visitClassInstance(node);
-      } else if (node.getInstance() instanceof ArrayInstance) {
-        visitArrayInstance(node);
-      } else {
-        throw new IllegalStateException("Unexpected type for " + node.getInstance());
-      }
-    }
-    return new Result(leakingNode, excludingKnownLeaks);
-  }
-
-  private void clearState() {
-    toVisitQueue.clear();
-    toVisitIfNoPathQueue.clear();
-    toVisitSet.clear();
-    toVisitIfNoPathSet.clear();
-    visitedSet.clear();
-  }
-
-  private void enqueueGcRoots(Snapshot snapshot) {
-    for (RootObj rootObj : snapshot.getGCRoots()) {
-      switch (rootObj.getRootType()) {
-        case JAVA_LOCAL:
-          Instance thread = HahaSpyKt.allocatingThread(rootObj);
-          String threadName = HahaHelper.threadName(thread);
-          Exclusion params = excludedRefs.getThreadNames().get(threadName);
-          if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null);
-          }
-          break;
-        // Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
-        case THREAD_OBJECT:
-        case INTERNED_STRING:
-        case DEBUGGER:
-        case INVALID_TYPE:
-          // An object that is unreachable from any other root, but not a root itself.
-        case UNREACHABLE:
-        case UNKNOWN:
-          // An object that is in a queue, waiting for a finalizer to run.
-        case FINALIZING:
-          break;
-        case SYSTEM_CLASS:
-        case VM_INTERNAL:
-          // A local variable in native code.
-        case NATIVE_LOCAL:
-          // A global variable in native code.
-        case NATIVE_STATIC:
-          // An object that was referenced from an active thread block.
-        case THREAD_BLOCK:
-          // Everything that called the wait() or notify() methods, or that is synchronized.
-        case BUSY_MONITOR:
-        case NATIVE_MONITOR:
-        case REFERENCE_CLEANUP:
-          // Input or output parameters in native code.
-        case NATIVE_STACK:
-        case JAVA_STATIC:
-          enqueue(null, null, rootObj, null);
-          break;
-        default:
-          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
-      }
-    }
-  }
-
-  private boolean checkSeen(LeakNode node) {
-    return !visitedSet.add(node.getInstance());
-  }
-
-  private void visitRootObj(LeakNode node) {
-    RootObj rootObj = (RootObj) node.getInstance();
-    Instance child = rootObj.getReferredInstance();
-
-    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
-      Instance holder = HahaSpyKt.allocatingThread(rootObj);
-      // We switch the parent node with the thread instance that holds
-      // the local reference.
-      Exclusion exclusion = null;
-      if (node.getExclusion() != null) {
-        exclusion = node.getExclusion();
-      }
-      LeakNode parent = new LeakNode(null, holder, null, null);
-      enqueue(exclusion, parent, child, new LeakReference(LOCAL, null, null));
-    } else {
-      enqueue(null, node, child, null);
-    }
-  }
-
-  private void visitClassObj(LeakNode node) {
-    ClassObj classObj = (ClassObj) node.getInstance();
-    Map<String, Exclusion> ignoredStaticFields =
-        excludedRefs.getStaticFieldNameByClassName().get(classObj.getClassName());
-    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-      Field field = entry.getKey();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      String fieldName = field.getName();
-      if (fieldName.equals("$staticOverhead")) {
-        continue;
-      }
-      Instance child = (Instance) entry.getValue();
-      boolean visit = true;
-      String fieldValue = entry.getValue() == null ? "null" : entry.getValue().toString();
-      LeakReference leakReference = new LeakReference(STATIC_FIELD, fieldName, fieldValue);
-      if (ignoredStaticFields != null) {
-        Exclusion params = ignoredStaticFields.get(fieldName);
-        if (params != null) {
-          visit = false;
-          if (!params.alwaysExclude) {
-            enqueue(params, node, child, leakReference);
-          }
-        }
-      }
-      if (visit) {
-        enqueue(null, node, child, leakReference);
-      }
-    }
-  }
-
-  private void visitClassInstance(LeakNode node) {
-    ClassInstance classInstance = (ClassInstance) node.getInstance();
-    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
-    ClassObj superClassObj = classInstance.getClassObj();
-    Exclusion classExclusion = null;
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.getClassNames().get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (classExclusion == null || !classExclusion.alwaysExclude) {
-          classExclusion = params;
-        }
-      }
-      Map<String, Exclusion> classIgnoredFields =
-          excludedRefs.getFieldNameByClassName().get(superClassObj.getClassName());
-      if (classIgnoredFields != null) {
-        ignoredFields.putAll(classIgnoredFields);
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-
-    if (classExclusion != null && classExclusion.alwaysExclude) {
-      return;
-    }
-
-    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
-      Exclusion fieldExclusion = classExclusion;
-      Field field = fieldValue.getField();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      Instance child = (Instance) fieldValue.getValue();
-      String fieldName = field.getName();
-      Exclusion params = ignoredFields.get(fieldName);
-      // If we found a field exclusion and it's stronger than a class exclusion
-      if (params != null && (fieldExclusion == null || (params.alwaysExclude
-          && !fieldExclusion.alwaysExclude))) {
-        fieldExclusion = params;
-      }
-      String value = fieldValue.getValue() == null ? "null" : fieldValue.getValue().toString();
-      enqueue(fieldExclusion, node, child, new LeakReference(INSTANCE_FIELD, fieldName, value));
-    }
-  }
-
-  private void visitArrayInstance(LeakNode node) {
-    ArrayInstance arrayInstance = (ArrayInstance) node.getInstance();
-    Type arrayType = arrayInstance.getArrayType();
-    if (arrayType == Type.OBJECT) {
-      Object[] values = arrayInstance.getValues();
-      for (int i = 0; i < values.length; i++) {
-        Instance child = (Instance) values[i];
-        String name = Integer.toString(i);
-        String value = child == null ? "null" : child.toString();
-        enqueue(null, node, child, new LeakReference(ARRAY_ENTRY, name, value));
-      }
-    }
-  }
-
-  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child,
-      LeakReference leakReference) {
-    if (child == null) {
-      return;
-    }
-    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
-      return;
-    }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(child)) {
-      return;
-    }
-    boolean visitNow = exclusion == null;
-    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
-      return;
-    }
-    if (canIgnoreStrings && isString(child)) {
-      return;
-    }
-    if (visitedSet.contains(child)) {
-      return;
-    }
-    LeakNode childNode = new LeakNode(exclusion, child, parent, leakReference);
-    if (visitNow) {
-      toVisitSet.add(child);
-      toVisitQueue.add(childNode);
-    } else {
-      toVisitIfNoPathSet.add(child);
-      toVisitIfNoPathQueue.add(childNode);
-    }
-  }
-
-  private boolean isString(Instance instance) {
-    return instance.getClassObj() != null && instance.getClassObj()
-        .getClassName()
-        .equals(String.class.getName());
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.kt
new file mode 100644
index 000000000..e437c71a3
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.kt
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Instance
+import com.squareup.haha.perflib.RootObj
+import com.squareup.haha.perflib.RootType
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import com.squareup.haha.perflib.allocatingThread
+import com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray
+import com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper
+import com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
+import com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import com.squareup.leakcanary.LeakTraceElement.Type.LOCAL
+import com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import java.util.ArrayDeque
+import java.util.Deque
+import java.util.LinkedHashMap
+import java.util.LinkedHashSet
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
+ * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * found.
+ */
+internal class ShortestPathFinder(private val excludedRefs: ExcludedRefs) {
+  private val toVisitQueue: Deque<LeakNode>
+  private val toVisitIfNoPathQueue: Deque<LeakNode>
+  private val toVisitSet: LinkedHashSet<Instance>
+  private val toVisitIfNoPathSet: LinkedHashSet<Instance>
+  private val visitedSet: LinkedHashSet<Instance>
+  private var canIgnoreStrings: Boolean = false
+
+  init {
+    toVisitQueue = ArrayDeque()
+    toVisitIfNoPathQueue = ArrayDeque()
+    toVisitSet = LinkedHashSet()
+    toVisitIfNoPathSet = LinkedHashSet()
+    visitedSet = LinkedHashSet()
+  }
+
+  internal class Result(
+    val leakingNode: LeakNode?,
+    val excludingKnownLeaks: Boolean
+  )
+
+  fun findPath(
+    snapshot: Snapshot,
+    leakingRef: Instance
+  ): Result {
+    clearState()
+    canIgnoreStrings = !isString(leakingRef)
+
+    enqueueGcRoots(snapshot)
+
+    var excludingKnownLeaks = false
+    lateinit var leakingNode: LeakNode
+    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
+      val node: LeakNode
+      if (!toVisitQueue.isEmpty()) {
+        node = toVisitQueue.poll()
+      } else {
+        node = toVisitIfNoPathQueue.poll()
+        if (node.exclusion == null) {
+          throw IllegalStateException("Expected node to have an exclusion $node")
+        }
+        excludingKnownLeaks = true
+      }
+
+      // Termination
+      if (node.instance === leakingRef) {
+        leakingNode = node
+        break
+      }
+
+      if (checkSeen(node)) {
+        continue
+      }
+
+      when {
+        node.instance is RootObj -> visitRootObj(node)
+        node.instance is ClassObj -> visitClassObj(node)
+        node.instance is ClassInstance -> visitClassInstance(node)
+        node.instance is ArrayInstance -> visitArrayInstance(node)
+        else -> throw IllegalStateException("Unexpected type for " + node.instance!!)
+      }
+    }
+    return Result(leakingNode, excludingKnownLeaks)
+  }
+
+  private fun clearState() {
+    toVisitQueue.clear()
+    toVisitIfNoPathQueue.clear()
+    toVisitSet.clear()
+    toVisitIfNoPathSet.clear()
+    visitedSet.clear()
+  }
+
+  private fun enqueueGcRoots(snapshot: Snapshot) {
+    for (rootObj in snapshot.gcRoots) {
+      when (rootObj.rootType) {
+        RootType.JAVA_LOCAL -> {
+          val thread = rootObj.allocatingThread()
+          val threadName = HahaHelper.threadName(thread)
+          val params = excludedRefs.threadNames[threadName]
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null)
+          }
+        }
+        // Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+        RootType.THREAD_OBJECT, RootType.INTERNED_STRING, RootType.DEBUGGER, RootType.INVALID_TYPE,
+          // An object that is unreachable from any other root, but not a root itself.
+        RootType.UNREACHABLE, RootType.UNKNOWN,
+          // An object that is in a queue, waiting for a finalizer to run.
+        RootType.FINALIZING -> {
+        }
+        RootType.SYSTEM_CLASS, RootType.VM_INTERNAL,
+          // A local variable in native code.
+        RootType.NATIVE_LOCAL,
+          // A global variable in native code.
+        RootType.NATIVE_STATIC,
+          // An object that was referenced from an active thread block.
+        RootType.THREAD_BLOCK,
+          // Everything that called the wait() or notify() methods, or that is synchronized.
+        RootType.BUSY_MONITOR, RootType.NATIVE_MONITOR, RootType.REFERENCE_CLEANUP,
+          // Input or output parameters in native code.
+        RootType.NATIVE_STACK, RootType.JAVA_STATIC -> enqueue(null, null, rootObj, null)
+        else -> throw UnsupportedOperationException("Unknown root type:" + rootObj.rootType)
+      }
+    }
+  }
+
+  private fun checkSeen(node: LeakNode): Boolean {
+    return !visitedSet.add(node.instance!!)
+  }
+
+  private fun visitRootObj(node: LeakNode) {
+    val rootObj = node.instance as RootObj?
+    val child = rootObj!!.referredInstance
+
+    if (rootObj.rootType == RootType.JAVA_LOCAL) {
+      val holder = rootObj.allocatingThread()
+      // We switch the parent node with the thread instance that holds
+      // the local reference.
+      var exclusion: Exclusion? = null
+      if (node.exclusion != null) {
+        exclusion = node.exclusion
+      }
+      val parent = LeakNode(null, holder, null, null)
+      enqueue(exclusion, parent, child, LeakReference(LOCAL, null, null))
+    } else {
+      enqueue(null, node, child, null)
+    }
+  }
+
+  private fun visitClassObj(node: LeakNode) {
+    val classObj = node.instance as ClassObj?
+    val ignoredStaticFields = excludedRefs.staticFieldNameByClassName[classObj!!.className]
+    for ((field, value) in classObj.staticFieldValues) {
+      if (field.type != Type.OBJECT) {
+        continue
+      }
+      val fieldName = field.name
+      if (fieldName == "\$staticOverhead") {
+        continue
+      }
+      val child = value as Instance?
+      var visit = true
+      val fieldValue = value?.toString() ?: "null"
+      val leakReference = LeakReference(STATIC_FIELD, fieldName, fieldValue)
+      if (ignoredStaticFields != null) {
+        val params = ignoredStaticFields[fieldName]
+        if (params != null) {
+          visit = false
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, leakReference)
+          }
+        }
+      }
+      if (visit) {
+        enqueue(null, node, child, leakReference)
+      }
+    }
+  }
+
+  private fun visitClassInstance(node: LeakNode) {
+    val classInstance = node.instance as ClassInstance?
+    val ignoredFields = LinkedHashMap<String, Exclusion>()
+    var superClassObj: ClassObj? = classInstance!!.classObj
+    var classExclusion: Exclusion? = null
+    while (superClassObj != null) {
+      val params = excludedRefs.classNames[superClassObj.className]
+      if (params != null) {
+        // true overrides null or false.
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params
+        }
+      }
+      val classIgnoredFields = excludedRefs.fieldNameByClassName[superClassObj.className]
+      if (classIgnoredFields != null) {
+        ignoredFields.putAll(classIgnoredFields)
+      }
+      superClassObj = superClassObj.superClassObj
+    }
+
+    if (classExclusion != null && classExclusion.alwaysExclude) {
+      return
+    }
+
+    for (fieldValue in classInstance.values) {
+      var fieldExclusion = classExclusion
+      val field = fieldValue.field
+      if (field.type != Type.OBJECT) {
+        continue
+      }
+      val child = fieldValue.value as Instance?
+      val fieldName = field.name
+      val params = ignoredFields[fieldName]
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || params.alwaysExclude && !fieldExclusion.alwaysExclude)) {
+        fieldExclusion = params
+      }
+      val value = if (fieldValue.value == null) "null" else fieldValue.value.toString()
+      enqueue(fieldExclusion, node, child, LeakReference(INSTANCE_FIELD, fieldName, value))
+    }
+  }
+
+  private fun visitArrayInstance(node: LeakNode) {
+    val arrayInstance = node.instance as ArrayInstance?
+    val arrayType = arrayInstance!!.arrayType
+    if (arrayType == Type.OBJECT) {
+      val values = arrayInstance.values
+      for (i in values.indices) {
+        val child = values[i] as Instance?
+        val name = Integer.toString(i)
+        val value = child?.toString() ?: "null"
+        enqueue(null, node, child, LeakReference(ARRAY_ENTRY, name, value))
+      }
+    }
+  }
+
+  private fun enqueue(
+    exclusion: Exclusion?,
+    parent: LeakNode?,
+    child: Instance?,
+    leakReference: LeakReference?
+  ) {
+    if (child == null) {
+      return
+    }
+    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
+      return
+    }
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    if (toVisitSet.contains(child)) {
+      return
+    }
+    val visitNow = exclusion == null
+    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
+      return
+    }
+    if (canIgnoreStrings && isString(child)) {
+      return
+    }
+    if (visitedSet.contains(child)) {
+      return
+    }
+    val childNode = LeakNode(exclusion, child, parent, leakReference)
+    if (visitNow) {
+      toVisitSet.add(child)
+      toVisitQueue.add(childNode)
+    } else {
+      toVisitIfNoPathSet.add(child)
+      toVisitIfNoPathQueue.add(childNode)
+    }
+  }
+
+  private fun isString(instance: Instance): Boolean {
+    return instance.classObj != null && instance.classObj
+        .className == String::class.java.name
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
index b5f295c6d..65e3e7151 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.kt
@@ -49,9 +49,9 @@ internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
     assertThat(result.excludedLeak).isFalse()
     val gcRoot = result.leakTrace!!.elements[0]
     assertThat(ASYNC_TASK_CLASS).isEqualTo(gcRoot.className)
-    assertThat(STATIC_FIELD).isEqualTo(gcRoot.type)
+    assertThat(STATIC_FIELD).isEqualTo(gcRoot.reference!!.type)
     assertThat(
-        gcRoot.referenceName == EXECUTOR_FIELD_1 || gcRoot.referenceName == EXECUTOR_FIELD_2
+        gcRoot.reference!!.name == EXECUTOR_FIELD_1 || gcRoot.reference!!.name == EXECUTOR_FIELD_2
     ).isTrue()
   }
 
@@ -74,10 +74,10 @@ internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
   }
 
   companion object {
-    private val ASYNC_TASK_THREAD = "AsyncTask #1"
-    private val ASYNC_TASK_CLASS = "android.os.AsyncTask"
-    private val EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR"
-    private val EXECUTOR_FIELD_2 = "sDefaultExecutor"
+    private const val ASYNC_TASK_THREAD = "AsyncTask #1"
+    private const val ASYNC_TASK_CLASS = "android.os.AsyncTask"
+    private const val EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR"
+    private const val EXECUTOR_FIELD_2 = "sDefaultExecutor"
     @JvmStatic
     @Parameterized.Parameters
     fun data() = listOf(
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.kt
index e5fc94c11..882f7b72c 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.kt
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.kt
@@ -3,7 +3,7 @@ package com.squareup.leakcanary
 import com.android.tools.perflib.captures.DataBuffer
 import java.io.UnsupportedEncodingException
 
-class FakeDataBuffer(val stringCharset: String = PRE_O_CHARSET) : DataBuffer {
+class FakeDataBuffer(private val stringCharset: String = PRE_O_CHARSET) : DataBuffer {
 
   private var intsToRead: IntArray? = null
   private var intIndex = -1
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
deleted file mode 100644
index 0c7188355..000000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ /dev/null
@@ -1,160 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.android.tools.perflib.captures.DataBuffer;
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class HahaHelperTest {
-  private static final int STRING_CLASS_ID = 100;
-  private static final int CHAR_ARRAY_CLASS_ID = 101;
-  private static final int STRING_INSTANCE_ID = 102;
-  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
-  private static final int BYTE_ARRAY_CLASS_ID = 104;
-
-  private static final int VALUE_ARRAY_LENGTH = 6;
-  private static final int COUNT_VALUE = 5;
-  private static final int OFFSET_VALUE = 1;
-
-  private FakeDataBuffer buffer;
-  private Snapshot snapshot;
-
-  @Before
-  public void setUp() {
-    buffer = new FakeDataBuffer();
-    initSnapshot(buffer);
-  }
-
-  private void initSnapshot(DataBuffer buffer) {
-    snapshot = new Snapshot(buffer);
-    // set HPROF identifier size; required for Object instance field lookups
-    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
-    snapshot.setIdSize(4);
-  }
-
-  @Test public void readStringOffsetFromHeapDumpInstance_pre_O() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("bcdef"));
-  }
-
-  @Test public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
-    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test public void readStringAsByteArrayFromHeapDumpInstance_O() {
-    // O uses default charset UTF-8
-    buffer = new FakeDataBuffer("UTF-8");
-    initSnapshot(buffer);
-
-    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields_O(snapshot, new Field[]{
-        new Field(Type.INT, "count"),
-        new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createByteArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test public void throwExceptionWhenNotArrayValueForString() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createObjectValueInstance();
-
-    try {
-      HahaHelper.asString(stringInstance);
-      fail("this test should have thrown UnsupportedOperationException");
-    } catch (UnsupportedOperationException uoe) {
-      String message = uoe.getMessage();
-      assertTrue(message.equals("Could not find char array in " + stringInstance));
-    }
-  }
-
-  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
-    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
-    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
-
-    ClassObj stringClass = new ClassObj(0, null, "string", 0);
-    stringClass.setFields(fields);
-    snapshot.addClass(STRING_CLASS_ID, stringClass);
-  }
-
-  private void addStringClassToSnapshotWithFields_O(Snapshot snapshot, Field[] fields) {
-    ClassObj byteArrayClass = new ClassObj(0, null, "byte[]", 0);
-    snapshot.addClass(BYTE_ARRAY_CLASS_ID, byteArrayClass);
-
-    ClassObj stringClass = new ClassObj(0, null, "string", 0);
-    stringClass.setFields(fields);
-    snapshot.addClass(STRING_CLASS_ID, stringClass);
-  }
-
-  private void createCharArrayValueInstance() {
-    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
-  }
-
-  private void createByteArrayValueInstance() {
-    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.BYTE, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
-  }
-
-  private void createObjectValueInstance() {
-    ClassInstance valueInstance = new ClassInstance(0, null, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueInstance);
-  }
-
-  private ClassInstance createStringInstance() {
-    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
-    stringInstance.setClassId(STRING_CLASS_ID);
-    snapshot.addInstance(0, stringInstance);
-    return stringInstance;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.kt b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.kt
new file mode 100644
index 000000000..9d6b6347c
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.kt
@@ -0,0 +1,164 @@
+package com.squareup.leakcanary
+
+import com.android.tools.perflib.captures.DataBuffer
+import com.squareup.haha.perflib.ArrayInstance
+import com.squareup.haha.perflib.ClassInstance
+import com.squareup.haha.perflib.ClassObj
+import com.squareup.haha.perflib.Field
+import com.squareup.haha.perflib.Snapshot
+import com.squareup.haha.perflib.Type
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.JUnit4
+
+@RunWith(JUnit4::class)
+class HahaHelperTest {
+
+  private lateinit var buffer: FakeDataBuffer
+  private lateinit var snapshot: Snapshot
+
+  @Before
+  fun setUp() {
+    buffer = FakeDataBuffer()
+    initSnapshot(buffer)
+  }
+
+  private fun initSnapshot(buffer: DataBuffer) {
+    snapshot = Snapshot(buffer)
+    // set HPROF identifier size; required for Object instance field lookups
+    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
+    snapshot.setIdSize(4)
+  }
+
+  @Test fun readStringOffsetFromHeapDumpInstance_pre_O() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID)
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot,
+        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createCharArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "bcdef")
+  }
+
+  @Test fun defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID)
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createCharArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "abcde")
+  }
+
+  @Test fun readStringAsByteArrayFromHeapDumpInstance_O() {
+    // O uses default charset UTF-8
+    buffer = FakeDataBuffer("UTF-8")
+    initSnapshot(buffer)
+
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID)
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields_O(
+        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createByteArrayValueInstance()
+
+    val actual = HahaHelper.asString(stringInstance)
+    assertTrue(actual == "abcde")
+  }
+
+  @Test fun throwExceptionWhenNotArrayValueForString() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID)
+    buffer.setStringsToRead("abcdef")
+
+    addStringClassToSnapshotWithFields(
+        snapshot,
+        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
+    )
+
+    val stringInstance = createStringInstance()
+    createObjectValueInstance()
+
+    try {
+      HahaHelper.asString(stringInstance)
+      fail("this test should have thrown UnsupportedOperationException")
+    } catch (uoe: UnsupportedOperationException) {
+      val message = uoe.message
+      assertTrue(message == "Could not find char array in $stringInstance")
+    }
+
+  }
+
+  private fun addStringClassToSnapshotWithFields(
+    snapshot: Snapshot,
+    fields: Array<Field>
+  ) {
+    val charArrayClass = ClassObj(0, null, "char[]", 0)
+    snapshot.addClass(CHAR_ARRAY_CLASS_ID.toLong(), charArrayClass)
+
+    val stringClass = ClassObj(0, null, "string", 0)
+    stringClass.fields = fields
+    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
+  }
+
+  private fun addStringClassToSnapshotWithFields_O(
+    snapshot: Snapshot,
+    fields: Array<Field>
+  ) {
+    val byteArrayClass = ClassObj(0, null, "byte[]", 0)
+    snapshot.addClass(BYTE_ARRAY_CLASS_ID.toLong(), byteArrayClass)
+
+    val stringClass = ClassObj(0, null, "string", 0)
+    stringClass.fields = fields
+    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
+  }
+
+  private fun createCharArrayValueInstance() {
+    val valueArrayInstance = ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
+  }
+
+  private fun createByteArrayValueInstance() {
+    val valueArrayInstance = ArrayInstance(0, null, Type.BYTE, VALUE_ARRAY_LENGTH, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
+  }
+
+  private fun createObjectValueInstance() {
+    val valueInstance = ClassInstance(0, null, 0)
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueInstance)
+  }
+
+  private fun createStringInstance(): ClassInstance {
+    val stringInstance = ClassInstance(STRING_INSTANCE_ID.toLong(), null, 100)
+    stringInstance.setClassId(STRING_CLASS_ID.toLong())
+    snapshot.addInstance(0, stringInstance)
+    return stringInstance
+  }
+
+  companion object {
+    private const val STRING_CLASS_ID = 100
+    private const val CHAR_ARRAY_CLASS_ID = 101
+    private const val STRING_INSTANCE_ID = 102
+    private const val VALUE_ARRAY_INSTANCE_ID = 103
+    private const val BYTE_ARRAY_CLASS_ID = 104
+    private const val VALUE_ARRAY_LENGTH = 6
+    private const val COUNT_VALUE = 5
+    private const val OFFSET_VALUE = 1
+  }
+}
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index defc6f2cf..3ca8ab40c 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -76,10 +76,10 @@
 
     <receiver android:name="com.squareup.leakcanary.internal.LeakCanaryReceiver">
       <intent-filter>
-        <action android:name="leaksentry.LeakSentryReceiver.referenceRetained"/>
+        <action android:name="leaksentry.AbstractLeakSentryReceiver.referenceRetained"/>
       </intent-filter>
       <intent-filter>
-        <action android:name="leaksentry.LeakSentryReceiver.leakSentryInstalled"/>
+        <action android:name="leaksentry.AbstractLeakSentryReceiver.leakSentryInstalled"/>
       </intent-filter>
     </receiver>
   </application>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
deleted file mode 100644
index e0cf69502..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.content.Intent;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.core.content.ContextCompat;
-import com.squareup.leakcanary.internal.ForegroundService;
-import java.io.File;
-
-public abstract class AbstractAnalysisResultService extends ForegroundService {
-
-  private static final String ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra";
-
-  public static void sendResultToListener(@NonNull Context context,
-      @NonNull String listenerServiceClassName,
-      @NonNull HeapDump heapDump,
-      @NonNull AnalysisResult result) {
-    Class<?> listenerServiceClass;
-    try {
-      listenerServiceClass = Class.forName(listenerServiceClassName);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    Intent intent = new Intent(context, listenerServiceClass);
-
-    File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
-    if (analyzedHeapFile != null) {
-      intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
-    }
-    ContextCompat.startForegroundService(context, intent);
-  }
-
-  public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName(),
-        R.string.leak_canary_notification_reporting);
-  }
-
-  @Override protected final void onHandleIntentInForeground(@Nullable Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.");
-      return;
-    }
-    if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
-      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space));
-      return;
-    }
-    File analyzedHeapFile = new File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA));
-    AnalyzedHeap analyzedHeap = AnalyzedHeap.load(analyzedHeapFile);
-    if (analyzedHeap == null) {
-      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file));
-      return;
-    }
-    try {
-      onHeapAnalyzed(analyzedHeap);
-    } finally {
-      //noinspection ResultOfMethodCallIgnored
-      analyzedHeap.heapDump.getHeapDumpFile().delete();
-      //noinspection ResultOfMethodCallIgnored
-      analyzedHeap.selfFile.delete();
-    }
-  }
-
-  /**
-   * Called after a heap dump is analyzed, whether or not a leak was found.
-   * In {@link AnalyzedHeap#result} check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} to see if there was a leak and if it can be ignored.
-   * <p>
-   * This will be called from a background intent service thread.
-   * <p>
-   * It's OK to block here and wait for the heap dump to be uploaded.
-   * <p>
-   * The analyzed heap file and heap dump file will be deleted immediately after this callback
-   * returns.
-   */
-  protected void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
-    onHeapAnalyzed(analyzedHeap.heapDump, analyzedHeap.result);
-  }
-
-  /**
-   * @deprecated Maintained for backward compatibility. You should override {@link
-   * #onHeapAnalyzed(AnalyzedHeap)} instead.
-   */
-  @SuppressWarnings("DeprecatedIsStillUsed")
-  @Deprecated
-  protected void onHeapAnalyzed(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
-  }
-
-  /**
-   * Called when there was an error saving or loading the analysis result. This will be called from
-   * a background intent service thread.
-   */
-  protected void onAnalysisResultFailure(String failureMessage) {
-    CanaryLog.d(failureMessage);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.kt
new file mode 100644
index 000000000..d6a8feead
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.kt
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.content.Context
+import android.content.Intent
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.internal.ForegroundService
+import java.io.File
+
+abstract class AbstractAnalysisResultService : ForegroundService(
+    AbstractAnalysisResultService::class.java.name, R.string.leak_canary_notification_reporting
+) {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("AbstractAnalysisResultService received a null intent, ignoring.")
+      return
+    }
+    if (!intent.hasExtra(ANALYZED_HEAP_PATH_EXTRA)) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_disk_space))
+      return
+    }
+    val analyzedHeapFile = File(intent.getStringExtra(ANALYZED_HEAP_PATH_EXTRA))
+    val analyzedHeap = AnalyzedHeap.load(analyzedHeapFile)
+    if (analyzedHeap == null) {
+      onAnalysisResultFailure(getString(R.string.leak_canary_result_failure_no_file))
+      return
+    }
+    try {
+      onHeapAnalyzed(analyzedHeap)
+    } finally {
+
+      analyzedHeap.heapDump.heapDumpFile.delete()
+
+      analyzedHeap.selfFile.delete()
+    }
+  }
+
+  /**
+   * Called after a heap dump is analyzed, whether or not a leak was found.
+   * In [AnalyzedHeap.result] check [AnalysisResult.leakFound] and [AnalysisResult.excludedLeak] to
+   * see if there was a leak and if it can be ignored.
+   *
+   * This will be called from a background intent service thread.
+   *
+   * It's OK to block here and wait for the heap dump to be uploaded.
+   *
+   * The analyzed heap file and heap dump file will be deleted immediately after this callback
+   * returns.
+   */
+  protected open fun onHeapAnalyzed(analyzedHeap: AnalyzedHeap) {
+  }
+
+  /**
+   * Called when there was an error saving or loading the analysis result. This will be called from
+   * a background intent service thread.
+   */
+  protected open fun onAnalysisResultFailure(failureMessage: String) {
+    CanaryLog.d(failureMessage)
+  }
+
+  companion object {
+
+    private const val ANALYZED_HEAP_PATH_EXTRA = "analyzed_heap_path_extra"
+
+    fun sendResultToListener(
+      context: Context,
+      listenerServiceClassName: String,
+      heapDump: HeapDump,
+      result: AnalysisResult
+    ) {
+      val listenerServiceClass = Class.forName(listenerServiceClassName)
+
+      val intent = Intent(context, listenerServiceClass)
+
+      val analyzedHeapFile = AnalyzedHeap.save(heapDump, result)
+      if (analyzedHeapFile != null) {
+        intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.absolutePath)
+      }
+      ContextCompat.startForegroundService(context, intent)
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
deleted file mode 100644
index ab5f19151..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package com.squareup.leakcanary;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-
-/**
- * Wraps a {@link HeapDump} and corresponding {@link AnalysisResult}.
- */
-public final class AnalyzedHeap {
-
-  @Nullable public static File save(@NonNull HeapDump heapDump, @NonNull AnalysisResult result) {
-    File analyzedHeapfile = new File(heapDump.getHeapDumpFile().getParentFile(),
-        heapDump.getHeapDumpFile().getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(analyzedHeapfile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return analyzedHeapfile;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return null;
-  }
-
-  @Nullable public static AnalyzedHeap load(@NonNull File resultFile) {
-    FileInputStream fis = null;
-    try {
-      fis = new FileInputStream(resultFile);
-      ObjectInputStream ois = new ObjectInputStream(fis);
-      HeapDump heapDump = (HeapDump) ois.readObject();
-      AnalysisResult result = (AnalysisResult) ois.readObject();
-      return new AnalyzedHeap(heapDump, result, resultFile);
-    } catch (IOException | ClassNotFoundException e) {
-      // Likely a change in the serializable result class.
-      // Let's remove the files, we can't read them anymore.
-      boolean deleted = resultFile.delete();
-      if (deleted) {
-        CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-      } else {
-        CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-            resultFile);
-      }
-    } finally {
-      if (fis != null) {
-        try {
-          fis.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return null;
-  }
-
-  @NonNull public final HeapDump heapDump;
-  @NonNull public final AnalysisResult result;
-  @NonNull public final File selfFile;
-  public final boolean heapDumpFileExists;
-  public final long selfLastModified;
-
-  public AnalyzedHeap(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
-      @NonNull File analyzedHeapFile) {
-    this.heapDump = heapDump;
-    this.result = result;
-    this.selfFile = analyzedHeapFile;
-    heapDumpFileExists = heapDump.getHeapDumpFile().exists();
-    selfLastModified = analyzedHeapFile.lastModified();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.kt
new file mode 100644
index 000000000..af1607784
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AnalyzedHeap.kt
@@ -0,0 +1,91 @@
+package com.squareup.leakcanary
+
+import java.io.File
+import java.io.FileInputStream
+import java.io.FileOutputStream
+import java.io.IOException
+import java.io.ObjectInputStream
+import java.io.ObjectOutputStream
+
+/**
+ * Wraps a [HeapDump] and corresponding [AnalysisResult].
+ */
+class AnalyzedHeap(
+  val heapDump: HeapDump,
+  val result: AnalysisResult,
+  val selfFile: File
+) {
+  val heapDumpFileExists: Boolean = heapDump.heapDumpFile.exists()
+  val selfLastModified: Long = selfFile.lastModified()
+
+  companion object {
+
+    fun save(
+      heapDump: HeapDump,
+      result: AnalysisResult
+    ): File? {
+      val analyzedHeapfile = File(
+          heapDump.heapDumpFile.parentFile,
+          heapDump.heapDumpFile.name + ".result"
+      )
+      var fos: FileOutputStream? = null
+      try {
+        fos = FileOutputStream(analyzedHeapfile)
+        val oos = ObjectOutputStream(fos)
+        oos.writeObject(heapDump)
+        oos.writeObject(result)
+        return analyzedHeapfile
+      } catch (e: IOException) {
+        CanaryLog.d(e, "Could not save leak analysis result to disk.")
+      } finally {
+        if (fos != null) {
+          try {
+            fos.close()
+          } catch (ignored: IOException) {
+          }
+
+        }
+      }
+      return null
+    }
+
+    fun load(resultFile: File): AnalyzedHeap? {
+      var fis: FileInputStream? = null
+      try {
+        fis = FileInputStream(resultFile)
+        val ois = ObjectInputStream(fis)
+        val heapDump = ois.readObject() as HeapDump
+        val result = ois.readObject() as AnalysisResult
+        return AnalyzedHeap(heapDump, result, resultFile)
+      } catch (e: IOException) {
+        // Likely a change in the serializable result class.
+        // Let's remove the files, we can't read them anymore.
+        val deleted = resultFile.delete()
+        if (deleted) {
+          CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile)
+        } else {
+          CanaryLog.d(
+              e, "Could not read result file %s, could not delete it either.",
+              resultFile
+          )
+        }
+      } catch (e: ClassNotFoundException) {
+        val deleted = resultFile.delete()
+        if (deleted) {
+          CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile)
+        } else {
+          CanaryLog.d(e, "Could not read result file %s, could not delete it either.", resultFile)
+        }
+      } finally {
+        if (fis != null) {
+          try {
+            fis.close()
+          } catch (ignored: IOException) {
+          }
+
+        }
+      }
+      return null
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.kt
similarity index 73%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.kt
index 7c58b997b..d8ff67bc0 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.kt
@@ -13,12 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.squareup.leakcanary
 
-import android.os.Debug;
+import android.os.Debug
 
-public final class AndroidDebuggerControl implements DebuggerControl {
-  @Override public boolean isDebuggerAttached() {
-    return Debug.isDebuggerConnected();
-  }
+class AndroidDebuggerControl : DebuggerControl {
+  override val isDebuggerAttached: Boolean
+    get() = Debug.isDebuggerConnected()
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index 71e6a841c..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,632 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import androidx.annotation.NonNull;
-import java.lang.ref.PhantomReference;
-import java.lang.ref.SoftReference;
-import java.lang.ref.WeakReference;
-import java.util.EnumSet;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static android.os.Build.VERSION_CODES.M;
-import static android.os.Build.VERSION_CODES.N;
-import static android.os.Build.VERSION_CODES.N_MR1;
-import static android.os.Build.VERSION_CODES.O;
-import static android.os.Build.VERSION_CODES.O_MR1;
-import static android.os.Build.VERSION_CODES.P;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.HUAWEI;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LENOVO;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.MEIZU;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.VIVO;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
- * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
- * {@link #createBuilder(EnumSet)}
- */
-@SuppressWarnings({ "unused", "WeakerAccess" }) // Public API.
-public enum AndroidExcludedRefs {
-
-  // ######## Android SDK Excluded refs ########
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
-          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
-              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-              + " Not sure what's going on there, input welcome.");
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason =
-          "Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
-          .reason(reason);
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-              + " keeps a reference to the context it's given the first time"
-              + " MediaSessionLegacyHelper.getHelper() is called."
-              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-              + " calling context.getApplicationContext()."
-              + " Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-              + " in Application.onCreate() and pass it the application context.");
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-              + " at least two bugs that created memory leaks by not correctly clearing the"
-              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/893d6fe48d37f71e683f722457bea646994a10"
-              + " The second was fixed, not released yet:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-              + " To fix this, you could access TextLine.sCached and clear the pool every now"
-              + " and then (e.g. on activity destroy).");
-    }
-  },
-
-  BLOCKING_QUEUE() {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "A thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + " used, this won't be a problem, because these references are cleared when being"
-          + " recycled. However, dialogs create template Message instances to be copied when a"
-          + " message needs to be sent. These Message templates holds references to the dialog"
-          + " listeners, which most likely leads to holding a reference onto the activity in some"
-          + " way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + " that is widely used should consider doing this for its own handler threads. This leaks"
-          + " has been shown to happen in both Dalvik and ART.";
-      excluded.instanceField("android.os.Message", "obj").reason(reason);
-      excluded.instanceField("android.os.Message", "next").reason(reason);
-      excluded.instanceField("android.os.Message", "target").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= P) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
-              + " after the activity has been destroyed."
-              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-              + "#issuecomment-100579429"
-              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
-          .reason("LayoutTransition leaks parent ViewGroup through"
-              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-              + " window is destroyed. Tracked here:"
-              + " https://code.google.com/p/android/issues/detail?id=171830");
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-              + " SpellCheckerSession is closed before the service is connected."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
-    }
-  },
-
-  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
-          .reason("SpellChecker holds on to a detached view that points to a destroyed activity."
-              + " mSpellRunnable is being enqueued, and that callback should be removed when "
-              + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-              + " called after the view was detached.");
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy").reason(reason);
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason);
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
-          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-              + " class and leaked the SpeechRecognizer which leaked an activity context."
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + " /b37866db469e81aca534ff6186bdafd44352329b");
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
-          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
-              + " probably because the reference to the response in the other process hasn't been"
-              + " cleared."
-              + " AccountManager$AmsTask is holding on to the activity reference to use for"
-              + " launching a new sub- Activity."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-              + " with the returned future to to get the result and correctly start an activity"
-              + " when it's available.");
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
-              + " but the service might not disconnect after the activity has been destroyed."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-              + " application context. Call connect() and disconnect() manually.");
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN_MR2 && SDK_INT < O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason("UserManager has a static sInstance field that creates an instance and caches it"
-              + " the first time UserManager.get() is called. This instance is created with the"
-              + " outer context (which is an activity base context)."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-              + "/27db46850b708070452c0ce49daf5f79503fbde6"
-              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-              + " UserManager instance gets cached with a reference to the application context.");
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
-          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
-              + " code. The reference to the `mContext` was not being cleared, which caused the"
-              + " Callbacks instance to retain this reference"
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
-              + " never abandoned it, which leaks the Activity context through the AudioManager."
-              + " The root of the problem is that AudioManager uses whichever"
-              + " context it receives, which in the case of the VideoView example is an Activity,"
-              + " even though it only needs the application's context. The issue is fixed in"
-              + " Android M, and the AudioManager now uses the application's context."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.Editor$Blink", "this$0")
-          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
-              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-              + " contains a blinking cursor is detached, a message is posted with a delay after the"
-              + " dialog has been closed and as a result leaks the Activity."
-              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-              + " dismiss() method of the dialog."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
-    }
-  },
-
-  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
-          .reason("ConnectivityManager has a sInstance field that is set when the first"
-              + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-              + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-              + " ConnectivityManager instance is created with the activity context and stored in"
-              + " sInstance. That activity context then leaks forever."
-              + " Until this is fixed, app developers can prevent this leak by making sure the"
-              + " ConnectivityManager is first created with an App Context. E.g. in some static"
-              + " init do: context.getApplicationContext()"
-              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
-    }
-  },
-
-  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT >= O && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
-          .reason("AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
-              + " AccessibilityNodeInfo instances are released back in the pool,"
-              + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
-              + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
-              + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-              + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-              + "android/view/accessibility/AccessibilityNodeInfo.java");
-    }
-  },
-
-  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT >= N && SDK_INT <= O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
-          .reason("When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
-              + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-              + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
-              + " activity");
-    }
-  },
-
-  // ######## Manufacturer specific Excluded refs ########
-
-  INSTRUMENTATION_RECOMMEND_ACTIVITY(
-      MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
-          .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in"
-              + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-              + " above");
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
-      MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
-            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object.");
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
-              + " activity. Yes, a STATIC mContext field.");
-    }
-  },
-
-  GESTURE_BOOST_MANAGER(HUAWEI.equals(MANUFACTURER) && SDK_INT >= N && SDK_INT <= N_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
-          .reason("GestureBoostManager is a static singleton that leaks an activity context."
-              + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
-    }
-  },
-
-  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(
-      HUAWEI.equals(MANUFACTURER) && SDK_INT >= M && SDK_INT <= O_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "HUAWEI added a mLastSrvView field to InputMethodManager"
-          + " that leaks a reference to the last served view.";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
-          .reason(reason);
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
-              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-              + " application context. Example: https://gist.github.com/cypressious/"
-              + "91c4fb1455470d803a602838dfcd5774");
-    }
-  },
-
-  SEM_CLIPBOARD_MANAGER__MCONTEXT(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.samsung.android.content.clipboard.SemClipboardManager",
-          "mContext")
-          .reason("SemClipboardManager is held in memory by an anonymous inner class"
-              + " implementation of android.os.Binder, thereby leaking an activity context.");
-    }
-  },
-
-  SEM_EMERGENCY_MANAGER__MCONTEXT(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
-          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext."
-              + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d");
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(
-      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
-              + " focused view.");
-    }
-  },
-
-  LGCONTEXT__MCONTEXT(LG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
-          .reason("LGContext is a static singleton that leaks an activity context.");
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
-          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
-              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-              + " ControllerMapper.MapperClient which leaks the activity context.");
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= O) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
-              + " view.");
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason("android.app.LoadedApk.mResources has a reference to"
-              + " android.content.res.Resources.mPersonaManager which has a reference to"
-              + " android.os.PersonaManager.mContext which is an activity.");
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason("In AOSP the Resources class does not have a context."
-              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-              + " instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason("In AOSP the ViewConfiguration class does not have a context."
-              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-              + " ViewConfiguration instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues"
-              + "/1#issuecomment-100324683");
-    }
-  },
-
-  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL((LENOVO.equals(MANUFACTURER) && SDK_INT == KITKAT) //
-      || (VIVO.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1)) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
-          .reason("SystemSensorManager stores a reference to context"
-              + " in a static field in its constructor."
-              + " Fix: use application context to get SensorManager");
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/32");
-    }
-  },
-
-  ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.app.ActivityManager", "mContext")
-          .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
-    }
-  },
-
-  // ######## General Excluded refs ########
-
-  SOFT_REFERENCES {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
-      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
-      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
-      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
-      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
-    }
-  },
-
-  MAIN {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main").alwaysExclude();
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME).alwaysExclude();
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue").alwaysExclude();
-    }
-  },
-
-  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
-      // method.
-      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
-      // Bug report: https://issuetracker.google.com/issues/112792715
-      excluded.instanceField("android.view.ViewGroup$ViewLocationHolder",
-          "mRoot");
-    }
-  };
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static @NonNull ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(
-        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-            EVENT_RECEIVER__MMESSAGE_QUEUE));
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static @NonNull ExcludedRefs.Builder createAppDefaults() {
-    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
-  }
-
-  public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = ExcludedRefs.Companion.builder();
-    for (AndroidExcludedRefs ref : refs) {
-      if (ref.applies) {
-        ref.add(excluded);
-        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
-      }
-    }
-    return excluded;
-  }
-
-  final boolean applies;
-
-  AndroidExcludedRefs() {
-    this(true);
-  }
-
-  AndroidExcludedRefs(boolean applies) {
-    this.applies = applies;
-  }
-
-  abstract void add(ExcludedRefs.Builder excluded);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.kt
new file mode 100644
index 000000000..cf5b60219
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.kt
@@ -0,0 +1,713 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.os.Build.MANUFACTURER
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH
+import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.LOLLIPOP
+import android.os.Build.VERSION_CODES.LOLLIPOP_MR1
+import android.os.Build.VERSION_CODES.M
+import android.os.Build.VERSION_CODES.N
+import android.os.Build.VERSION_CODES.N_MR1
+import android.os.Build.VERSION_CODES.O
+import android.os.Build.VERSION_CODES.O_MR1
+import android.os.Build.VERSION_CODES.P
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.HUAWEI
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.LENOVO
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.LG
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.MEIZU
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.MOTOROLA
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.NVIDIA
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.SAMSUNG
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.VIVO
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [.createAppDefaults]. However, you can also pick the
+ * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
+ * [.createBuilder]
+ */
+// Public API.
+enum class AndroidExcludedRefs constructor(internal val applies: Boolean = true) {
+
+  // ######## Android SDK Excluded refs ########
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.app.ActivityThread\$ActivityClientRecord", "nextIdle")
+          .reason(
+              "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+                  + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+                  + " Not sure what's going on there, input welcome."
+          )
+    }
+  },
+
+  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason =
+        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+            + " NoCopySpan, which makes sure it gets dropped when creating a new"
+            + " SpannableStringBuilder from a given CharSequence."
+            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+            + " reference to the textview and therefore the entire view hierarchy & activity"
+            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+      excluded.instanceField("android.widget.Editor\$EasyEditSpanController", "this$0")
+          .reason(reason)
+      excluded.instanceField("android.widget.Editor\$SpanController", "this$0")
+          .reason(reason)
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason(
+              "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                  + " keeps a reference to the context it's given the first time"
+                  + " MediaSessionLegacyHelper.getHelper() is called."
+                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                  + " calling context.getApplicationContext()."
+                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                  + " in Application.onCreate() and pass it the application context."
+          )
+    }
+  },
+
+  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason(
+              "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+                  + " at least two bugs that created memory leaks by not correctly clearing the"
+                  + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+                  + " https://github.com/android/platform_frameworks_base/commit"
+                  + "/893d6fe48d37f71e683f722457bea646994a10"
+                  + " The second was fixed, not released yet:"
+                  + " https://github.com/android/platform_frameworks_base/commit"
+                  + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+                  + " To fix this, you could access TextLine.sCached and clear the pool every now"
+                  + " and then (e.g. on activity destroy)."
+          )
+    }
+  },
+
+  BLOCKING_QUEUE {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("A thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + " used, this won't be a problem, because these references are cleared when being"
+          + " recycled. However, dialogs create template Message instances to be copied when a"
+          + " message needs to be sent. These Message templates holds references to the dialog"
+          + " listeners, which most likely leads to holding a reference onto the activity in some"
+          + " way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + " that is widely used should consider doing this for its own handler threads. This leaks"
+          + " has been shown to happen in both Dalvik and ART.")
+      excluded.instanceField("android.os.Message", "obj")
+          .reason(reason)
+      excluded.instanceField("android.os.Message", "next")
+          .reason(reason)
+      excluded.instanceField("android.os.Message", "target")
+          .reason(reason)
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason)
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason)
+      excluded.instanceField(
+          "android.view.inputmethod.InputMethodManager",
+          "mServedInputConnection"
+      )
+          .reason(reason)
+    }
+  },
+
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..P) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason(
+              "The singleton InputMethodManager is holding a reference to mCurRootView long"
+                  + " after the activity has been destroyed."
+                  + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+                  + "#issuecomment-100579429"
+                  + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+          )
+    }
+  },
+
+  LAYOUT_TRANSITION(SDK_INT in ICE_CREAM_SANDWICH..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.animation.LayoutTransition$1", "val\$parent")
+          .reason(
+              "LayoutTransition leaks parent ViewGroup through"
+                  + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+                  + " window is destroyed. Tracked here:"
+                  + " https://code.google.com/p/android/issues/detail?id=171830"
+          )
+    }
+  },
+
+  SPELL_CHECKER_SESSION(SDK_INT in JELLY_BEAN..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason(
+              "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+                  + " SpellCheckerSession is closed before the service is connected."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+          )
+    }
+  },
+
+  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
+          .reason(
+              "SpellChecker holds on to a detached view that points to a destroyed activity."
+                  + " mSpellRunnable is being enqueued, and that callback should be removed when "
+                  + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+                  + " called after the view was detached."
+          )
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL(SDK_INT in ICE_CREAM_SANDWICH_MR1..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason = ("ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+      excluded.instanceField(
+          "android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy"
+      )
+          .reason(reason)
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason)
+    }
+  },
+
+  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.speech.SpeechRecognizer\$InternalListener", "this$0")
+          .reason(
+              "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+                  + " class and leaked the SpeechRecognizer which leaked an activity context."
+                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                  + " /b37866db469e81aca534ff6186bdafd44352329b"
+          )
+    }
+  },
+
+  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.accounts.AccountManager\$AmsTask\$Response", "this$1")
+          .reason(
+              "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+                  + " probably because the reference to the response in the other process hasn't been"
+                  + " cleared."
+                  + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+                  + " launching a new sub- Activity."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+                  + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+                  + " with the returned future to to get the result and correctly start an activity"
+                  + " when it's available."
+          )
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason(
+              "The static method MediaScannerConnection.scanFile() takes an activity context"
+                  + " but the service might not disconnect after the activity has been destroyed."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+                  + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+                  + " application context. Call connect() and disconnect() manually."
+          )
+    }
+  },
+
+  USER_MANAGER__SINSTANCE(SDK_INT in JELLY_BEAN_MR2..N_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason(
+              "UserManager has a static sInstance field that creates an instance and caches it"
+                  + " the first time UserManager.get() is called. This instance is created with the"
+                  + " outer context (which is an activity base context)."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+                  + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+                  + "/27db46850b708070452c0ce49daf5f79503fbde6"
+                  + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+                  + " UserManager instance gets cached with a reference to the application context."
+          )
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.appwidget.AppWidgetHost\$Callbacks", "this$0")
+          .reason(
+              "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+                  + " code. The reference to the `mContext` was not being cleared, which caused the"
+                  + " Callbacks instance to retain this reference"
+                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                  + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+          )
+    }
+  },
+
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason(
+              "Prior to Android M, VideoView required audio focus from AudioManager and"
+                  + " never abandoned it, which leaks the Activity context through the AudioManager."
+                  + " The root of the problem is that AudioManager uses whichever"
+                  + " context it receives, which in the case of the VideoView example is an Activity,"
+                  + " even though it only needs the application's context. The issue is fixed in"
+                  + " Android M, and the AudioManager now uses the application's context."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+                  + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+          )
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.widget.Editor\$Blink", "this$0")
+          .reason(
+              "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+                  + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+                  + " contains a blinking cursor is detached, a message is posted with a delay after the"
+                  + " dialog has been closed and as a result leaks the Activity."
+                  + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+                  + " dismiss() method of the dialog."
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+                  + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+                  + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+          )
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+          .reason(
+              "ConnectivityManager has a sInstance field that is set when the first"
+                  + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+                  + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+                  + " ConnectivityManager instance is created with the activity context and stored in"
+                  + " sInstance. That activity context then leaks forever."
+                  + " Until this is fixed, app developers can prevent this leak by making sure the"
+                  + " ConnectivityManager is first created with an App Context. E.g. in some static"
+                  + " init do: context.getApplicationContext()"
+                  + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+                  + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+                  + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+          )
+    }
+  },
+
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT in O..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
+          .reason(
+              "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+                  + " AccessibilityNodeInfo instances are released back in the pool,"
+                  + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+                  + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+                  + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+                  + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+                  + "android/view/accessibility/AccessibilityNodeInfo.java"
+          )
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT in N..O) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
+          .reason(
+              "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+                  + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+                  + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+                  + " activity"
+          )
+    }
+  },
+
+  // ######## Manufacturer specific Excluded refs ########
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU == MANUFACTURER && SDK_INT in LOLLIPOP..LOLLIPOP_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
+          .reason(
+              "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+                  + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+                  + " above"
+          )
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+      MOTOROLA == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      if (MOTOROLA == MANUFACTURER && SDK_INT == KITKAT) {
+        excluded.instanceField("android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0")
+            .reason(
+                "DevicePolicyManager keeps a reference to the context it has been created with"
+                    + " instead of extracting the application context. In this Motorola build,"
+                    + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                    + " observer, which is held into memory by a binder transport object."
+            )
+      }
+    }
+  },
+
+  SPEN_GESTURE_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason(
+              "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+          )
+    }
+  },
+
+  GESTURE_BOOST_MANAGER(HUAWEI == MANUFACTURER && SDK_INT in N..N_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
+          .reason(
+              "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+          )
+    }
+  },
+
+  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(HUAWEI == MANUFACTURER && SDK_INT in M..O_MR1) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      val reason =
+        "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
+          .reason(reason)
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason(
+              "ClipboardUIManager is a static singleton that leaks an activity context."
+                  + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+                  + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+                  + " application context. Example: https://gist.github.com/cypressious/"
+                  + "91c4fb1455470d803a602838dfcd5774"
+          )
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField(
+          "com.samsung.android.content.clipboard.SemClipboardManager",
+          "mContext"
+      )
+          .reason(
+              "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+          )
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
+          .reason(
+              "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+          )
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER(LG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason(
+              "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+          )
+    }
+  },
+
+  LGCONTEXT__MCONTEXT(LG == MANUFACTURER && SDK_INT == LOLLIPOP) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
+          .reason("LGContext is a static singleton that leaks an activity context.")
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources")
+    }
+  },
+
+  MAPPER_CLIENT(NVIDIA == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0")
+          .reason(
+              "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+                  + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+                  + " ControllerMapper.MapperClient which leaks the activity context."
+          )
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..O) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason(
+              "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+          )
+    }
+  },
+
+  PERSONA_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason(
+              "android.app.LoadedApk.mResources has a reference to"
+                  + " android.content.res.Resources.mPersonaManager which has a reference to"
+                  + " android.os.PersonaManager.mContext which is an activity."
+          )
+    }
+  },
+
+  RESOURCES__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason(
+              "In AOSP the Resources class does not have a context."
+                  + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+                  + " instance that has a context that is the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+          )
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT(
+      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason(
+              "In AOSP the ViewConfiguration class does not have a context."
+                  + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+                  + " ViewConfiguration instance that has a context that is the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues"
+                  + "/1#issuecomment-100324683"
+          )
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL(
+      LENOVO == MANUFACTURER && SDK_INT == KITKAT //
+          || VIVO == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
+          .reason(
+              "SystemSensorManager stores a reference to context"
+                  + " in a static field in its constructor."
+                  + " Fix: use application context to get SensorManager"
+          )
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC(
+      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason(
+              "Samsung added a static mContext_static field to AudioManager, holds a reference"
+                  + " to the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/32"
+          )
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT(
+      SAMSUNG == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
+  ) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.staticField("android.app.ActivityManager", "mContext")
+          .reason(
+              "Samsung added a static mContext field to ActivityManager, holds a reference"
+                  + " to the activity."
+                  + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+                  + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+          )
+    }
+  },
+
+  // ######## General Excluded refs ########
+
+  SOFT_REFERENCES {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.clazz(WeakReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz(SoftReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz(PhantomReference::class.java.name)
+          .alwaysExclude()
+      excluded.clazz("java.lang.ref.Finalizer")
+          .alwaysExclude()
+      excluded.clazz("java.lang.ref.FinalizerReference")
+          .alwaysExclude()
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      excluded.thread("FinalizerWatchdogDaemon")
+          .alwaysExclude()
+    }
+  },
+
+  MAIN {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      excluded.thread("main")
+          .alwaysExclude()
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      excluded.thread(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME)
+          .alwaysExclude()
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      excluded.instanceField(
+          "android.view.Choreographer\$FrameDisplayEventReceiver",
+          "mMessageQueue"
+      )
+          .alwaysExclude()
+    }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
+    override fun add(excluded: ExcludedRefs.Builder) {
+      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
+      // method.
+      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
+      // Bug report: https://issuetracker.google.com/issues/112792715
+      excluded.instanceField(
+          "android.view.ViewGroup\$ViewLocationHolder",
+          "mRoot"
+      )
+    }
+  };
+
+  internal abstract fun add(excluded: ExcludedRefs.Builder)
+
+  companion object {
+
+    /**
+     * This returns the references in the leak path that should be ignored by all on Android.
+     */
+    fun createAndroidDefaults(): ExcludedRefs.Builder {
+      return createBuilder(
+          EnumSet.of(
+              SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+              EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+    }
+
+    /**
+     * This returns the references in the leak path that can be ignored for app developers. This
+     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     */
+    fun createAppDefaults(): ExcludedRefs.Builder {
+      return createBuilder(EnumSet.allOf(AndroidExcludedRefs::class.java))
+    }
+
+    fun createBuilder(refs: EnumSet<AndroidExcludedRefs>): ExcludedRefs.Builder {
+      val excluded = ExcludedRefs.builder()
+      for (ref in refs) {
+        if (ref.applies) {
+          ref.add(excluded)
+          (excluded as ExcludedRefs.BuilderWithParams).named(ref.name)
+        }
+      }
+      return excluded
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index 45155c5c7..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.os.Debug;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.MessageQueue;
-import android.os.SystemClock;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.widget.Toast;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import leaksentry.internal.ActivityLifecycleCallbacksAdapter;
-import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
-import java.io.File;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private final Context context;
-  private final LeakDirectoryProvider leakDirectoryProvider;
-  private final Handler mainHandler;
-
-  private Activity resumedActivity;
-
-  public AndroidHeapDumper(@NonNull Context context,
-      @NonNull LeakDirectoryProvider leakDirectoryProvider) {
-    this.leakDirectoryProvider = leakDirectoryProvider;
-    this.context = context.getApplicationContext();
-    mainHandler = new Handler(Looper.getMainLooper());
-
-    Application application = (Application) context.getApplicationContext();
-    application.registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacksAdapter() {
-      @Override public void onActivityResumed(Activity activity) {
-        resumedActivity = activity;
-      }
-
-      @Override public void onActivityPaused(Activity activity) {
-        if (resumedActivity == activity) {
-          resumedActivity = null;
-        }
-      }
-    });
-  }
-
-  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
-  @Override @Nullable
-  public File dumpHeap() {
-    final File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
-
-    if (heapDumpFile == RETRY_LATER) {
-      return RETRY_LATER;
-    }
-
-    FutureResult<Toast> waitingForToast = new FutureResult<>();
-    showToast(waitingForToast);
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return RETRY_LATER;
-    }
-
-    Notification.Builder builder = new Notification.Builder(context)
-        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));
-    Notification notification = LeakCanaryInternals.buildNotification(context, builder);
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-    int notificationId = (int) SystemClock.uptimeMillis();
-    notificationManager.notify(notificationId, notification);
-
-    Toast toast = waitingForToast.get();
-
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      cancelToast(toast);
-      notificationManager.cancel(notificationId);
-      return heapDumpFile;
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not dump heap");
-      // Abort heap dump
-      return RETRY_LATER;
-    }
-  }
-
-  private void showToast(final FutureResult<Toast> waitingForToast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        if (resumedActivity == null) {
-          waitingForToast.set(null);
-          return;
-        }
-        final Toast toast = new Toast(resumedActivity);
-        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
-        toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(resumedActivity);
-        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
-        toast.show();
-        // Waiting for Idle to make sure Toast gets rendered.
-        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-          @Override public boolean queueIdle() {
-            waitingForToast.set(toast);
-            return false;
-          }
-        });
-      }
-    });
-  }
-
-  private void cancelToast(final Toast toast) {
-    if (toast == null) {
-      return;
-    }
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        toast.cancel();
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.kt
new file mode 100644
index 000000000..8529b3aea
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.kt
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.app.Notification
+import android.app.NotificationManager
+import android.content.Context
+import android.os.Debug
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import android.view.Gravity
+import android.view.LayoutInflater
+import android.widget.Toast
+import com.squareup.leakcanary.internal.FutureResult
+import com.squareup.leakcanary.internal.LeakCanaryInternals
+import leaksentry.internal.ActivityLifecycleCallbacksAdapter
+import java.io.File
+import java.util.concurrent.TimeUnit.SECONDS
+
+class AndroidHeapDumper(
+  context: Context,
+  private val leakDirectoryProvider: LeakDirectoryProvider
+) : HeapDumper {
+
+  private val context: Context = context.applicationContext
+  private val mainHandler: Handler = Handler(Looper.getMainLooper())
+
+  private var resumedActivity: Activity? = null
+
+  init {
+    val application = context.applicationContext as Application
+    application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+      override fun onActivityResumed(activity: Activity) {
+        resumedActivity = activity
+      }
+
+      override fun onActivityPaused(activity: Activity) {
+        if (resumedActivity === activity) {
+          resumedActivity = null
+        }
+      }
+    })
+  }
+
+  override// Explicitly checking for named null.
+  fun dumpHeap(): File? {
+    val heapDumpFile = leakDirectoryProvider.newHeapDumpFile()
+
+    if (heapDumpFile === HeapDumper.RETRY_LATER) {
+      return HeapDumper.RETRY_LATER
+    }
+
+    val waitingForToast = FutureResult<Toast?>()
+    showToast(waitingForToast)
+
+    if (!waitingForToast.wait(5, SECONDS)) {
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.")
+      return HeapDumper.RETRY_LATER
+    }
+
+    val builder = Notification.Builder(context)
+        .setContentTitle(context.getString(R.string.leak_canary_notification_dumping))
+    val notification = LeakCanaryInternals.buildNotification(context, builder)
+    val notificationManager =
+      context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+    val notificationId = SystemClock.uptimeMillis()
+        .toInt()
+    notificationManager.notify(notificationId, notification)
+
+    val toast = waitingForToast.get()
+
+    try {
+      Debug.dumpHprofData(heapDumpFile!!.absolutePath)
+      cancelToast(toast)
+      notificationManager.cancel(notificationId)
+      return heapDumpFile
+    } catch (e: Exception) {
+      CanaryLog.d(e, "Could not dump heap")
+      // Abort heap dump
+      return HeapDumper.RETRY_LATER
+    }
+
+  }
+
+  private fun showToast(waitingForToast: FutureResult<Toast?>) {
+    mainHandler.post(Runnable {
+      if (resumedActivity == null) {
+        waitingForToast.set(null)
+        return@Runnable
+      }
+      val toast = Toast(resumedActivity)
+      toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0)
+      toast.duration = Toast.LENGTH_LONG
+      val inflater = LayoutInflater.from(resumedActivity)
+      toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
+      toast.show()
+      // Waiting for Idle to make sure Toast gets rendered.
+      Looper.myQueue()
+          .addIdleHandler {
+            waitingForToast.set(toast)
+            false
+          }
+    })
+  }
+
+  private fun cancelToast(toast: Toast?) {
+    if (toast == null) {
+      return
+    }
+    mainHandler.post { toast.cancel() }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
deleted file mode 100644
index 0048661a7..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Activity;
-import android.app.Application;
-import android.app.Dialog;
-import android.app.Fragment;
-import android.os.MessageQueue;
-import androidx.annotation.NonNull;
-import android.view.View;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * A set of default {@link Reachability.Inspector}s that knows about common AOSP and library
- * classes.
- *
- * These are heuristics based on our experience and knownledge of AOSP and various library
- * internals. We only make a reachability decision if we're reasonably sure such reachability is
- * unlikely to be the result of a programmer mistake.
- *
- * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
- * will not be influenced by those mistakes.
- */
-public enum AndroidReachabilityInspectors {
-
-  VIEW(ViewInspector.class),
-
-  ACTIVITY(ActivityInspector.class),
-
-  DIALOG(DialogInspector.class),
-
-  APPLICATION(ApplicationInspector.class),
-
-  FRAGMENT(FragmentInspector.class),
-
-  SUPPORT_FRAGMENT(SupportFragmentInspector.class),
-
-  MESSAGE_QUEUE(MessageQueueInspector.class),
-
-  MORTAR_PRESENTER(MortarPresenterInspector.class),
-
-  VIEW_ROOT_IMPL(ViewImplInspector.class),
-
-  MAIN_THEAD(MainThreadInspector.class),
-
-  WINDOW(WindowInspector.class),
-
-  //
-  ;
-
-  private final Class<? extends Reachability.Inspector> inspectorClass;
-
-  AndroidReachabilityInspectors(Class<? extends Reachability.Inspector> inspectorClass) {
-    this.inspectorClass = inspectorClass;
-  }
-
-  public static @NonNull List<Class<? extends Reachability.Inspector>> defaultAndroidInspectors() {
-    List<Class<? extends Reachability.Inspector>> inspectorClasses = new ArrayList<>();
-    for (AndroidReachabilityInspectors enumValue : AndroidReachabilityInspectors.values()) {
-      inspectorClasses.add(enumValue.inspectorClass);
-    }
-    return inspectorClasses;
-  }
-
-  public static class ViewInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      if (!element.isInstanceOf(View.class)) {
-        return Reachability.unknown();
-      }
-      String mAttachInfo = element.getFieldReferenceValue("mAttachInfo");
-      if (mAttachInfo == null) {
-        return Reachability.unknown();
-      }
-      return unreachableWhen(element, View.class.getName(), "mAttachInfo", "null");
-    }
-  }
-
-  public static class ActivityInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, Activity.class.getName(), "mDestroyed", "true");
-    }
-  }
-
-  public static class DialogInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, Dialog.class.getName(), "mDecor", "null");
-    }
-  }
-
-  public static class ApplicationInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      if (element.isInstanceOf(Application.class)) {
-        return Reachability.reachable("the application class is a singleton");
-      }
-      return Reachability.unknown();
-    }
-  }
-
-  public static class FragmentInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, Fragment.class.getName(), "mDetached", "true");
-    }
-  }
-
-  public static class SupportFragmentInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, "android.support.v4.app.Fragment", "mDetached", "true");
-    }
-  }
-
-  public static class MessageQueueInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      if (!element.isInstanceOf(MessageQueue.class)) {
-        return Reachability.unknown();
-      }
-      String mQuitting = element.getFieldReferenceValue("mQuitting");
-      // If the queue is not quitting, maybe it should actually have been, we don't know.
-      // However, if it's quitting, it is very likely that's not a bug.
-      if ("true".equals(mQuitting)) {
-        return Reachability.unreachable("MessageQueue#mQuitting is true");
-      }
-      return Reachability.unknown();
-    }
-  }
-
-  public static class MortarPresenterInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      if (!element.isInstanceOf("mortar.Presenter")) {
-        return Reachability.unknown();
-      }
-      String view = element.getFieldReferenceValue("view");
-
-      // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
-      // should be a unreachable, so in that case we don't know their reachability status. However,
-      // when the view is null, we're pretty sure they should be unreachable.
-      if ("null".equals(view)) {
-        return Reachability.unreachable("Presenter#view is null");
-      }
-      return Reachability.unknown();
-    }
-  }
-
-  public static class ViewImplInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, "android.view.ViewRootImpl", "mView", "null");
-    }
-  }
-
-  public static class MainThreadInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      if (!element.isInstanceOf(Thread.class)) {
-        return Reachability.unknown();
-      }
-      String name = element.getFieldReferenceValue("name");
-      if ("main".equals(name)) {
-        return Reachability.reachable("the main thread always runs");
-      }
-      return Reachability.unknown();
-    }
-  }
-
-  public static class WindowInspector implements Reachability.Inspector {
-    @Override public @NonNull Reachability expectedReachability(@NonNull LeakTraceElement element) {
-      return unreachableWhen(element, "android.view.Window", "mDestroyed", "true");
-    }
-  }
-
-  private static Reachability unreachableWhen(LeakTraceElement element, String className,
-      String fieldName,
-      String unreachableValue) {
-    if (!element.isInstanceOf(className)) {
-      return Reachability.unknown();
-    }
-    String fieldValue = element.getFieldReferenceValue(fieldName);
-    if (fieldValue == null) {
-      return Reachability.unknown();
-    }
-    if (fieldValue.equals(unreachableValue)) {
-      return Reachability.unreachable(
-          simpleClassName(className) + "#" + fieldName + " is " + unreachableValue);
-    } else {
-      return Reachability.reachable(
-          simpleClassName(className) + "#" + fieldName + " is not " + unreachableValue);
-    }
-  }
-
-  private static String simpleClassName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.kt
new file mode 100644
index 000000000..8cdc31389
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidReachabilityInspectors.kt
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.app.Dialog
+import android.app.Fragment
+import android.os.MessageQueue
+import android.view.View
+import java.util.ArrayList
+
+/**
+ * A set of default [Reachability.Inspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knownledge of AOSP and various library
+ * internals. We only make a reachability decision if we're reasonably sure such reachability is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+enum class AndroidReachabilityInspectors(private val inspectorClass: Class<out Reachability.Inspector>) {
+
+  VIEW(ViewInspector::class.java),
+
+  ACTIVITY(ActivityInspector::class.java),
+
+  DIALOG(DialogInspector::class.java),
+
+  APPLICATION(ApplicationInspector::class.java),
+
+  FRAGMENT(FragmentInspector::class.java),
+
+  SUPPORT_FRAGMENT(SupportFragmentInspector::class.java),
+
+  MESSAGE_QUEUE(MessageQueueInspector::class.java),
+
+  MORTAR_PRESENTER(MortarPresenterInspector::class.java),
+
+  VIEW_ROOT_IMPL(ViewImplInspector::class.java),
+
+  MAIN_THEAD(MainThreadInspector::class.java),
+
+  WINDOW(WindowInspector::class.java);
+
+  class ViewInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(View::class.java)) {
+        return Reachability.unknown()
+      }
+      return unreachableWhen(element, View::class.java.name, "mAttachInfo", "null")
+    }
+  }
+
+  class ActivityInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, Activity::class.java.name, "mDestroyed", "true")
+    }
+  }
+
+  class DialogInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, Dialog::class.java.name, "mDecor", "null")
+    }
+  }
+
+  class ApplicationInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return if (element.isInstanceOf(Application::class.java)) {
+        Reachability.reachable("the application class is a singleton")
+      } else Reachability.unknown()
+    }
+  }
+
+  class FragmentInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, Fragment::class.java.name, "mDetached", "true")
+    }
+  }
+
+  class SupportFragmentInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, "android.support.v4.app.Fragment", "mDetached", "true")
+    }
+  }
+
+  class MessageQueueInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(MessageQueue::class.java)) {
+        return Reachability.unknown()
+      }
+      val mQuitting = element.getFieldReferenceValue("mQuitting")
+      // If the queue is not quitting, maybe it should actually have been, we don't know.
+      // However, if it's quitting, it is very likely that's not a bug.
+      return if ("true" == mQuitting) {
+        Reachability.unreachable("MessageQueue#mQuitting is true")
+      } else Reachability.unknown()
+    }
+  }
+
+  class MortarPresenterInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf("mortar.Presenter")) {
+        return Reachability.unknown()
+      }
+      val view = element.getFieldReferenceValue("view")
+
+      // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+      // should be a unreachable, so in that case we don't know their reachability status. However,
+      // when the view is null, we're pretty sure they should be unreachable.
+      return if ("null" == view) {
+        Reachability.unreachable("Presenter#view is null")
+      } else Reachability.unknown()
+    }
+  }
+
+  class ViewImplInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, "android.view.ViewRootImpl", "mView", "null")
+    }
+  }
+
+  class MainThreadInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      if (!element.isInstanceOf(Thread::class.java)) {
+        return Reachability.unknown()
+      }
+      val name = element.getFieldReferenceValue("name")
+      return if ("main" == name) {
+        Reachability.reachable("the main thread always runs")
+      } else Reachability.unknown()
+    }
+  }
+
+  class WindowInspector : Reachability.Inspector {
+    override fun expectedReachability(element: LeakTraceElement): Reachability {
+      return unreachableWhen(element, "android.view.Window", "mDestroyed", "true")
+    }
+  }
+
+  companion object {
+
+    fun defaultAndroidInspectors(): List<Class<out Reachability.Inspector>> {
+      val inspectorClasses = ArrayList<Class<out Reachability.Inspector>>()
+      for (enumValue in AndroidReachabilityInspectors.values()) {
+        inspectorClasses.add(enumValue.inspectorClass)
+      }
+      return inspectorClasses
+    }
+
+    private fun unreachableWhen(
+      element: LeakTraceElement,
+      className: String,
+      fieldName: String,
+      unreachableValue: String
+    ): Reachability {
+      if (!element.isInstanceOf(className)) {
+        return Reachability.unknown()
+      }
+      val fieldValue = element.getFieldReferenceValue(fieldName) ?: return Reachability.unknown()
+      return if (fieldValue == unreachableValue) {
+        Reachability.unreachable(
+            simpleClassName(className) + "#" + fieldName + " is " + unreachableValue
+        )
+      } else {
+        Reachability.reachable(
+            simpleClassName(className) + "#" + fieldName + " is not " + unreachableValue
+        )
+      }
+    }
+
+    private fun simpleClassName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
deleted file mode 100644
index f94775f19..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package com.squareup.leakcanary;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import android.util.Log;
-
-public final class CanaryLog {
-
-  private static volatile Logger logger = new DefaultLogger();
-
-  public interface Logger {
-    void d(@NonNull String message, @NonNull Object... args);
-
-    void d(@Nullable Throwable throwable, @NonNull String message, @NonNull Object... args);
-  }
-
-  private static class DefaultLogger implements Logger {
-    DefaultLogger() {
-    }
-
-    @Override public void d(@NonNull String message, @NonNull Object... args) {
-      String formatted = String.format(message, args);
-      if (formatted.length() < 4000) {
-        Log.d("LeakCanary", formatted);
-      } else {
-        String[] lines = formatted.split("\n", -1);
-        for (String line : lines) {
-          Log.d("LeakCanary", line);
-        }
-      }
-    }
-
-    @Override public void d(@Nullable Throwable throwable,
-        @NonNull String message,
-        @NonNull Object... args) {
-      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
-    }
-  }
-
-  public static void setLogger(@Nullable Logger logger) {
-    CanaryLog.logger = logger;
-  }
-
-  public static void d(@NonNull String message, @NonNull Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(message, args);
-  }
-
-  public static void d(@Nullable Throwable throwable,
-      @NonNull String message,
-      @NonNull Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(throwable, message, args);
-  }
-
-  private CanaryLog() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.kt
new file mode 100644
index 000000000..3b36d76df
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.kt
@@ -0,0 +1,78 @@
+package com.squareup.leakcanary
+
+import android.util.Log
+
+class CanaryLog private constructor() {
+
+  interface Logger {
+    fun d(
+      message: String,
+      vararg args: Any?
+    )
+
+    fun d(
+      throwable: Throwable?,
+      message: String,
+      vararg args: Any?
+    )
+  }
+
+  private class DefaultLogger internal constructor() : Logger {
+
+    override fun d(
+      message: String,
+      vararg args: Any?
+    ) {
+      val formatted = String.format(message, *args)
+      if (formatted.length < 4000) {
+        Log.d("LeakCanary", formatted)
+      } else {
+        val lines = formatted.split("\n".toRegex())
+            .toTypedArray()
+        for (line in lines) {
+          Log.d("LeakCanary", line)
+        }
+      }
+    }
+
+    override fun d(
+      throwable: Throwable?,
+      message: String,
+      vararg args: Any?
+    ) {
+      d(String.format(message, *args) + '\n'.toString() + Log.getStackTraceString(throwable))
+    }
+  }
+
+  init {
+    throw AssertionError()
+  }
+
+  companion object {
+
+    @Volatile private var logger: Logger? = DefaultLogger()
+
+    fun setLogger(logger: Logger?) {
+      CanaryLog.logger = logger
+    }
+
+    fun d(
+      message: String,
+      vararg args: Any?
+    ) {
+      // Local variable to prevent the ref from becoming null after the null check.
+      val logger = CanaryLog.logger ?: return
+      logger.d(message, *args)
+    }
+
+    fun d(
+      throwable: Throwable?,
+      message: String,
+      vararg args: Any?
+    ) {
+      // Local variable to prevent the ref from becoming null after the null check.
+      val logger = CanaryLog.logger ?: return
+      logger.d(throwable, message, *args)
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.kt
similarity index 76%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.kt
index 25b9bbc60..aefa8f20a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DebuggerControl.kt
@@ -13,18 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.squareup.leakcanary
 
 /**
  * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
  * An attached debugger might retain references and create false positives.
  */
-public interface DebuggerControl {
-  DebuggerControl NONE = new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      return false;
-    }
-  };
+interface DebuggerControl {
+
+  val isDebuggerAttached: Boolean
 
-  boolean isDebuggerAttached();
+  companion object {
+    val NONE: DebuggerControl = object : DebuggerControl {
+      override val isDebuggerAttached: Boolean
+        get() = false
+    }
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
deleted file mode 100644
index 21aacf406..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.os.Environment;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.UUID;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.M;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
-import static com.squareup.leakcanary.HeapDumper.RETRY_LATER;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
-
-  private static final int DEFAULT_MAX_STORED_HEAP_DUMPS = 7;
-
-  private static final String HPROF_SUFFIX = ".hprof";
-  private static final String PENDING_HEAPDUMP_SUFFIX = "_pending" + HPROF_SUFFIX;
-
-  /** 10 minutes */
-  private static final int ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000;
-
-  private final Context context;
-  private final int maxStoredHeapDumps;
-
-  private volatile boolean writeExternalStorageGranted;
-  private volatile boolean permissionNotificationDisplayed;
-
-  public DefaultLeakDirectoryProvider(@NonNull Context context) {
-    this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
-  }
-
-  public DefaultLeakDirectoryProvider(@NonNull Context context, int maxStoredHeapDumps) {
-    if (maxStoredHeapDumps < 1) {
-      throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
-    }
-    this.context = context.getApplicationContext();
-    this.maxStoredHeapDumps = maxStoredHeapDumps;
-  }
-
-  @Override public @NonNull List<File> listFiles(@NonNull FilenameFilter filter) {
-    if (!hasStoragePermission()) {
-      requestWritePermissionNotification();
-    }
-    List<File> files = new ArrayList<>();
-
-    File[] externalFiles = externalStorageDirectory().listFiles(filter);
-    if (externalFiles != null) {
-      files.addAll(Arrays.asList(externalFiles));
-    }
-
-    File[] appFiles = appStorageDirectory().listFiles(filter);
-    if (appFiles != null) {
-      files.addAll(Arrays.asList(appFiles));
-    }
-    return files;
-  }
-
-  @Override public boolean hasPendingHeapDump() {
-    List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
-      }
-    });
-    for (File file : pendingHeapDumps) {
-      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override public @Nullable File newHeapDumpFile() {
-    List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
-      }
-    });
-
-    // If a new heap dump file has been created recently and hasn't been processed yet, we skip.
-    // Otherwise we move forward and assume that the analyzer process crashes. The file will
-    // eventually be removed with heap dump file rotation.
-    for (File file : pendingHeapDumps) {
-      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
-        CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
-        return RETRY_LATER;
-      }
-    }
-
-    cleanupOldHeapDumps();
-
-    File storageDirectory = externalStorageDirectory();
-    if (!directoryWritableAfterMkdirs(storageDirectory)) {
-      if (!hasStoragePermission()) {
-        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted");
-        requestWritePermissionNotification();
-      } else {
-        String state = Environment.getExternalStorageState();
-        if (!Environment.MEDIA_MOUNTED.equals(state)) {
-          CanaryLog.d("External storage not mounted, state: %s", state);
-        } else {
-          CanaryLog.d("Could not create heap dump directory in external storage: [%s]",
-              storageDirectory.getAbsolutePath());
-        }
-      }
-      // Fallback to app storage.
-      storageDirectory = appStorageDirectory();
-      if (!directoryWritableAfterMkdirs(storageDirectory)) {
-        CanaryLog.d("Could not create heap dump directory in app storage: [%s]",
-            storageDirectory.getAbsolutePath());
-        return RETRY_LATER;
-      }
-    }
-    // If two processes from the same app get to this step at the same time, they could both
-    // create a heap dump. This is an edge case we ignore.
-    return new File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX);
-  }
-
-  @Override public void clearLeakDirectory() {
-    List<File> allFilesExceptPending = listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return !filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
-      }
-    });
-    for (File file : allFilesExceptPending) {
-      boolean deleted = file.delete();
-      if (!deleted) {
-        CanaryLog.d("Could not delete file %s", file.getPath());
-      }
-    }
-  }
-
-  @TargetApi(M) private boolean hasStoragePermission() {
-    if (SDK_INT < M) {
-      return true;
-    }
-    // Once true, this won't change for the life of the process so we can cache it.
-    if (writeExternalStorageGranted) {
-      return true;
-    }
-    writeExternalStorageGranted =
-        context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-    return writeExternalStorageGranted;
-  }
-
-  private void requestWritePermissionNotification() {
-    if (permissionNotificationDisplayed) {
-      return;
-    }
-    permissionNotificationDisplayed = true;
-
-    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
-    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
-    CharSequence packageName = context.getPackageName();
-    String contentText =
-        context.getString(R.string.leak_canary_permission_notification_text, packageName);
-    showNotification(context, contentTitle, contentText, pendingIntent, 0xDEAFBEEF);
-  }
-
-  private File externalStorageDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    return new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
-  }
-
-  private File appStorageDirectory() {
-    File appFilesDirectory = context.getFilesDir();
-    return new File(appFilesDirectory, "leakcanary");
-  }
-
-  private boolean directoryWritableAfterMkdirs(File directory) {
-    boolean success = directory.mkdirs();
-    return (success || directory.exists()) && directory.canWrite();
-  }
-
-  private void cleanupOldHeapDumps() {
-    List<File> hprofFiles = listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(HPROF_SUFFIX);
-      }
-    });
-    int filesToRemove = hprofFiles.size() - maxStoredHeapDumps;
-    if (filesToRemove > 0) {
-      CanaryLog.d("Removing %d heap dumps", filesToRemove);
-      // Sort with oldest modified first.
-      Collections.sort(hprofFiles, new Comparator<File>() {
-        @Override public int compare(File lhs, File rhs) {
-          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
-        }
-      });
-      for (int i = 0; i < filesToRemove; i++) {
-        boolean deleted = hprofFiles.get(i).delete();
-        if (!deleted) {
-          CanaryLog.d("Could not delete old hprof file %s", hprofFiles.get(i).getPath());
-        }
-      }
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.kt
new file mode 100644
index 000000000..f2c72b4fc
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.kt
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.annotation.TargetApi
+import android.content.Context
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.M
+import android.os.Environment
+import android.os.Environment.DIRECTORY_DOWNLOADS
+import com.squareup.leakcanary.HeapDumper.Companion.RETRY_LATER
+import com.squareup.leakcanary.internal.LeakCanaryInternals
+import com.squareup.leakcanary.internal.RequestStoragePermissionActivity
+import java.io.File
+import java.io.FilenameFilter
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.UUID
+
+class DefaultLeakDirectoryProvider @JvmOverloads constructor(
+  context: Context,
+  private val maxStoredHeapDumps: Int = DEFAULT_MAX_STORED_HEAP_DUMPS
+) : LeakDirectoryProvider {
+
+  private val context: Context
+
+  @Volatile private var writeExternalStorageGranted: Boolean = false
+  @Volatile private var permissionNotificationDisplayed: Boolean = false
+
+  init {
+    if (maxStoredHeapDumps < 1) {
+      throw IllegalArgumentException("maxStoredHeapDumps must be at least 1")
+    }
+    this.context = context.applicationContext
+  }
+
+  override fun listFiles(filter: FilenameFilter): MutableList<File> {
+    if (!hasStoragePermission()) {
+      requestWritePermissionNotification()
+    }
+    val files = ArrayList<File>()
+
+    val externalFiles = externalStorageDirectory().listFiles(filter)
+    if (externalFiles != null) {
+      files.addAll(Arrays.asList(*externalFiles))
+    }
+
+    val appFiles = appStorageDirectory().listFiles(filter)
+    if (appFiles != null) {
+      files.addAll(Arrays.asList(*appFiles))
+    }
+    return files
+  }
+
+  override fun hasPendingHeapDump(): Boolean {
+    val pendingHeapDumps =
+      listFiles(FilenameFilter { _, filename -> filename.endsWith(PENDING_HEAPDUMP_SUFFIX) })
+    for (file in pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        return true
+      }
+    }
+    return false
+  }
+
+  override fun newHeapDumpFile(): File? {
+    val pendingHeapDumps =
+      listFiles(FilenameFilter { _, filename -> filename.endsWith(PENDING_HEAPDUMP_SUFFIX) })
+
+    // If a new heap dump file has been created recently and hasn't been processed yet, we skip.
+    // Otherwise we move forward and assume that the analyzer process crashes. The file will
+    // eventually be removed with heap dump file rotation.
+    for (file in pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        CanaryLog.d("Could not dump heap, previous analysis still is in progress.")
+        return RETRY_LATER
+      }
+    }
+
+    cleanupOldHeapDumps()
+
+    var storageDirectory = externalStorageDirectory()
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted")
+        requestWritePermissionNotification()
+      } else {
+        val state = Environment.getExternalStorageState()
+        if (Environment.MEDIA_MOUNTED != state) {
+          CanaryLog.d("External storage not mounted, state: %s", state)
+        } else {
+          CanaryLog.d(
+              "Could not create heap dump directory in external storage: [%s]",
+              storageDirectory.absolutePath
+          )
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory()
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        CanaryLog.d(
+            "Could not create heap dump directory in app storage: [%s]",
+            storageDirectory.absolutePath
+        )
+        return RETRY_LATER
+      }
+    }
+    // If two processes from the same app get to this step at the same time, they could both
+    // create a heap dump. This is an edge case we ignore.
+    return File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX)
+  }
+
+  override fun clearLeakDirectory() {
+    val allFilesExceptPending =
+      listFiles(FilenameFilter { _, filename -> !filename.endsWith(PENDING_HEAPDUMP_SUFFIX) })
+    for (file in allFilesExceptPending) {
+      val deleted = file.delete()
+      if (!deleted) {
+        CanaryLog.d("Could not delete file %s", file.path)
+      }
+    }
+  }
+
+  @TargetApi(M) private fun hasStoragePermission(): Boolean {
+    if (SDK_INT < M) {
+      return true
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true
+    }
+    writeExternalStorageGranted =
+      context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+    return writeExternalStorageGranted
+  }
+
+  private fun requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed) {
+      return
+    }
+    permissionNotificationDisplayed = true
+
+    val pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context)
+    val contentTitle = context.getString(R.string.leak_canary_permission_notification_title)
+    val packageName = context.packageName
+    val contentText =
+      context.getString(R.string.leak_canary_permission_notification_text, packageName)
+    LeakCanaryInternals.showNotification(
+        context, contentTitle, contentText, pendingIntent, -0x21504111
+    )
+  }
+
+  private fun externalStorageDirectory(): File {
+    val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
+    return File(downloadsDirectory, "leakcanary-" + context.packageName)
+  }
+
+  private fun appStorageDirectory(): File {
+    val appFilesDirectory = context.filesDir
+    return File(appFilesDirectory, "leakcanary")
+  }
+
+  private fun directoryWritableAfterMkdirs(directory: File): Boolean {
+    val success = directory.mkdirs()
+    return (success || directory.exists()) && directory.canWrite()
+  }
+
+  private fun cleanupOldHeapDumps() {
+    val hprofFiles = listFiles(FilenameFilter { _, name -> name.endsWith(HPROF_SUFFIX) })
+    val filesToRemove = hprofFiles.size - maxStoredHeapDumps
+    if (filesToRemove > 0) {
+      CanaryLog.d("Removing %d heap dumps", filesToRemove)
+      // Sort with oldest modified first.
+      hprofFiles.sortWith(Comparator { lhs, rhs ->
+        java.lang.Long.valueOf(lhs.lastModified())
+            .compareTo(rhs.lastModified())
+      })
+      for (i in 0 until filesToRemove) {
+        val deleted = hprofFiles[i].delete()
+        if (!deleted) {
+          CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
+        }
+      }
+    }
+  }
+
+  companion object {
+
+    private const val DEFAULT_MAX_STORED_HEAP_DUMPS = 7
+
+    private const val HPROF_SUFFIX = ".hprof"
+    private const val PENDING_HEAPDUMP_SUFFIX = "_pending$HPROF_SUFFIX"
+
+    /** 10 minutes  */
+    private const val ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
deleted file mode 100644
index b30dedcf5..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.PendingIntent;
-import android.os.SystemClock;
-import androidx.annotation.NonNull;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
-import java.io.File;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-
-/**
- * Logs leak analysis results, and then shows a notification which will start {@link
- * DisplayLeakActivity}.
- * <p>
- * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
- * String)} to add custom behavior, e.g. uploading the heap dump.
- */
-public class DisplayLeakService extends AbstractAnalysisResultService {
-
-  @Override
-  protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
-    HeapDump heapDump = analyzedHeap.heapDump;
-    AnalysisResult result = analyzedHeap.result;
-
-    String leakInfo = LeakCanary.INSTANCE.leakInfo(this, heapDump, result, true);
-    CanaryLog.d("%s", leakInfo);
-
-    heapDump = renameHeapdump(heapDump);
-    boolean resultSaved = saveResult(heapDump, result);
-
-    String contentTitle;
-    if (resultSaved) {
-      PendingIntent pendingIntent =
-          DisplayLeakActivity.createPendingIntent(this, result.getReferenceKey());
-      if (result.getFailure() != null) {
-        contentTitle = getString(R.string.leak_canary_analysis_failed);
-      } else {
-        String className = classSimpleName(result.getClassName());
-        if (result.getLeakFound()) {
-          if (result.getRetainedHeapSize() == AnalysisResult.Companion.getRETAINED_HEAP_SKIPPED()) {
-            if (result.getExcludedLeak()) {
-              contentTitle = getString(R.string.leak_canary_leak_excluded, className);
-            } else {
-              contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
-            }
-          } else {
-            String size = formatShortFileSize(this, result.getRetainedHeapSize());
-            if (result.getExcludedLeak()) {
-              contentTitle =
-                  getString(R.string.leak_canary_leak_excluded_retaining, className, size);
-            } else {
-              contentTitle =
-                  getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
-            }
-          }
-        } else {
-          contentTitle = getString(R.string.leak_canary_class_no_leak, className);
-        }
-      }
-      String contentText = getString(R.string.leak_canary_notification_message);
-      showNotification(pendingIntent, contentTitle, contentText);
-    } else {
-      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
-    }
-
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  @Override protected final void onAnalysisResultFailure(String failureMessage) {
-    super.onAnalysisResultFailure(failureMessage);
-    String failureTitle = getString(R.string.leak_canary_result_failure_title);
-    showNotification(null, failureTitle, failureMessage);
-  }
-
-  private void showNotification(PendingIntent pendingIntent, String contentTitle,
-      String contentText) {
-    // New notification id every second.
-    int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
-    LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent,
-        notificationId);
-  }
-
-  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = AnalyzedHeap.save(heapDump, result);
-    return resultFile != null;
-  }
-
-  private HeapDump renameHeapdump(HeapDump heapDump) {
-    String fileName =
-        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
-
-    File newFile = new File(heapDump.getHeapDumpFile().getParent(), fileName);
-    boolean renamed = heapDump.getHeapDumpFile().renameTo(newFile);
-    if (!renamed) {
-      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.getHeapDumpFile().getPath(),
-          newFile.getPath());
-    }
-    return heapDump.buildUpon().heapDumpFile(newFile).build();
-  }
-
-  /**
-   * You can override this method and do a blocking call to a server to upload the leak trace and
-   * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} first.
-   */
-  protected void afterDefaultHandling(@NonNull HeapDump heapDump, @NonNull AnalysisResult result,
-      @NonNull String leakInfo) {
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.kt
new file mode 100644
index 000000000..d5b975157
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.kt
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+import android.app.PendingIntent
+import android.os.SystemClock
+import android.text.format.Formatter.formatShortFileSize
+import com.squareup.leakcanary.internal.DisplayLeakActivity
+import com.squareup.leakcanary.internal.LeakCanaryInternals
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.classSimpleName
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+
+/**
+ * Logs leak analysis results, and then shows a notification which will start [ ].
+ *
+ *
+ * You can extend this class and override [.afterDefaultHandling] to add custom behavior, e.g. uploading the heap dump.
+ */
+class DisplayLeakService : AbstractAnalysisResultService() {
+
+  override fun onHeapAnalyzed(analyzedHeap: AnalyzedHeap) {
+    var heapDump = analyzedHeap.heapDump
+    val result = analyzedHeap.result
+
+    val leakInfo = LeakCanary.leakInfo(this, heapDump, result, true)
+    CanaryLog.d("%s", leakInfo)
+
+    heapDump = renameHeapdump(heapDump)
+    val resultSaved = saveResult(heapDump, result)
+
+    val contentTitle: String
+    if (resultSaved) {
+      val pendingIntent = DisplayLeakActivity.createPendingIntent(this, result.referenceKey)
+      if (result.failure != null) {
+        contentTitle = getString(R.string.leak_canary_analysis_failed)
+      } else {
+        val className = classSimpleName(result.className!!)
+        if (result.leakFound) {
+          if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+            if (result.excludedLeak) {
+              contentTitle = getString(R.string.leak_canary_leak_excluded, className)
+            } else {
+              contentTitle = getString(R.string.leak_canary_class_has_leaked, className)
+            }
+          } else {
+            val size = formatShortFileSize(this, result.retainedHeapSize)
+            if (result.excludedLeak) {
+              contentTitle =
+                getString(R.string.leak_canary_leak_excluded_retaining, className, size)
+            } else {
+              contentTitle =
+                getString(R.string.leak_canary_class_has_leaked_retaining, className, size)
+            }
+          }
+        } else {
+          contentTitle = getString(R.string.leak_canary_class_no_leak, className)
+        }
+      }
+      val contentText = getString(R.string.leak_canary_notification_message)
+      showNotification(pendingIntent, contentTitle, contentText)
+    } else {
+      onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text))
+    }
+
+    afterDefaultHandling(heapDump, result, leakInfo)
+  }
+
+  override fun onAnalysisResultFailure(failureMessage: String) {
+    super.onAnalysisResultFailure(failureMessage)
+    val failureTitle = getString(R.string.leak_canary_result_failure_title)
+    showNotification(null, failureTitle, failureMessage)
+  }
+
+  private fun showNotification(
+    pendingIntent: PendingIntent?,
+    contentTitle: String,
+    contentText: String
+  ) {
+    // New notification id every second.
+    val notificationId = (SystemClock.uptimeMillis() / 1000).toInt()
+    LeakCanaryInternals.showNotification(
+        this, contentTitle, contentText, pendingIntent!!,
+        notificationId
+    )
+  }
+
+  private fun saveResult(
+    heapDump: HeapDump,
+    result: AnalysisResult
+  ): Boolean {
+    val resultFile = AnalyzedHeap.save(heapDump, result)
+    return resultFile != null
+  }
+
+  private fun renameHeapdump(heapDump: HeapDump): HeapDump {
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+
+    val newFile = File(heapDump.heapDumpFile.parent, fileName)
+    val renamed = heapDump.heapDumpFile.renameTo(newFile)
+    if (!renamed) {
+      CanaryLog.d(
+          "Could not rename heap dump file %s to %s", heapDump.heapDumpFile.path,
+          newFile.path
+      )
+    }
+    return heapDump.buildUpon()
+        .heapDumpFile(newFile)
+        .build()
+  }
+
+  /**
+   * You can override this method and do a blocking call to a server to upload the leak trace and
+   * the heap dump. Don't forget to check [AnalysisResult.leakFound] and [ ][AnalysisResult.excludedLeak] first.
+   */
+  protected fun afterDefaultHandling(
+    heapDump: HeapDump,
+    result: AnalysisResult,
+    leakInfo: String
+  ) {
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java
deleted file mode 100644
index eb9b2c801..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-/**
- * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the {@link
- * leaksentry.RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
- */
-public interface GcTrigger {
-  GcTrigger DEFAULT = new GcTrigger() {
-    @Override public void runGc() {
-      // Code taken from AOSP FinalizationTest:
-      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-      // java/lang/ref/FinalizationTester.java
-      // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perform a gc.
-      Runtime.getRuntime().gc();
-      enqueueReferences();
-      System.runFinalization();
-    }
-
-    private void enqueueReferences() {
-      // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
-      // references to the appropriate queues.
-      try {
-        Thread.sleep(100);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-    }
-  };
-
-  void runGc();
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.kt
new file mode 100644
index 000000000..acd36856d
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/GcTrigger.kt
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary
+
+/**
+ * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
+ * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
+ */
+interface GcTrigger {
+
+  fun runGc()
+
+  companion object {
+    val DEFAULT: GcTrigger = object : GcTrigger {
+      override fun runGc() {
+        // Code taken from AOSP FinalizationTest:
+        // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+        // java/lang/ref/FinalizationTester.java
+        // System.gc() does not garbage collect every time. Runtime.gc() is
+        // more likely to perform a gc.
+        Runtime.getRuntime()
+            .gc()
+        enqueueReferences()
+        System.runFinalization()
+      }
+
+      private fun enqueueReferences() {
+        // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
+        // references to the appropriate queues.
+        try {
+          Thread.sleep(100)
+        } catch (e: InterruptedException) {
+          throw AssertionError()
+        }
+
+      }
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
index f71391565..4841577cf 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumpTrigger.kt
@@ -26,16 +26,17 @@ class HeapDumpTrigger(
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
       if (!applicationVisible) {
-        scheduleTick()
+        scheduleTick("app became invisible")
       }
     }
   }
 
   fun onReferenceRetained() {
-    scheduleTick()
+    scheduleTick("found new reference retained")
   }
 
-  private fun tick() {
+  private fun tick(reason: String) {
+    CanaryLog.d("Checking retained references because %s", reason)
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
@@ -47,13 +48,13 @@ class HeapDumpTrigger(
     if (retainedKeys.size < minLeaks) {
       // No need to scheduleTick, new refs always schedule one.
       CanaryLog.d(
-          "Found %d potential leaks, which is less than the min of %d", retainedKeys.size, minLeaks
+          "Found %d retained references, which is less than the min of %d", retainedKeys.size, minLeaks
       )
       return
     }
 
     if (debuggerControl.isDebuggerAttached) {
-      scheduleTick(WAIT_FOR_DEBUG_MILLIS)
+      scheduleTick("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
       CanaryLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
           WAIT_FOR_DEBUG_MILLIS
@@ -66,7 +67,7 @@ class HeapDumpTrigger(
       CanaryLog.d(
           "Leak Analysis in progress, will retry in %d ms", WAIT_FOR_PENDING_ANALYSIS_MILLIS
       )
-      scheduleTick(WAIT_FOR_PENDING_ANALYSIS_MILLIS)
+      scheduleTick("had pending heap dump", WAIT_FOR_PENDING_ANALYSIS_MILLIS)
       return
     }
     val gcStartUptimeMillis = SystemClock.uptimeMillis()
@@ -77,7 +78,7 @@ class HeapDumpTrigger(
     retainedKeys = refWatcher.retainedKeys
     if (retainedKeys.size < minLeaks) {
       CanaryLog.d(
-          "Found %d potential leaks after GC, which is less than the min of %d", retainedKeys.size,
+          "Found %d retained references after GC, which is less than the min of %d", retainedKeys.size,
           minLeaks
       )
       return
@@ -85,6 +86,7 @@ class HeapDumpTrigger(
 
     HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
 
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
     HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
     val heapDumpFile = heapDumper.dumpHeap()
     val heapDumpDurationMillis =
@@ -94,13 +96,13 @@ class HeapDumpTrigger(
       CanaryLog.d(
           "Failed to dump heap, will retry in %d ms", WAIT_FOR_HEAP_DUMPER_MILLIS
       )
-      scheduleTick(WAIT_FOR_HEAP_DUMPER_MILLIS)
+      scheduleTick("failed to dump heap", WAIT_FOR_HEAP_DUMPER_MILLIS)
       return
     }
     refWatcher.removeRetainedKeys(retainedKeys)
 
     val heapDump = HeapDump.Builder()
-        .heapDumpFile(heapDumpFile)
+        .heapDumpFile(heapDumpFile!!)
         .excludedRefs(config.excludedRefs)
         .gcDurationMs(gcDurationMillis)
         .heapDumpDurationMs(heapDumpDurationMillis)
@@ -110,12 +112,16 @@ class HeapDumpTrigger(
     heapdumpListener.analyze(heapDump)
   }
 
-  private fun scheduleTick() {
-    backgroundHandler.post(this@HeapDumpTrigger::tick)
+  private fun scheduleTick(reason: String) {
+    backgroundHandler.post {
+      tick(reason)
+    }
   }
 
-  private fun scheduleTick(delayMillis: Long) {
-    backgroundHandler.postDelayed(this@HeapDumpTrigger::tick, delayMillis)
+  private fun scheduleTick(reason: String, delayMillis: Long) {
+    backgroundHandler.postDelayed({
+      tick(reason)
+    }, delayMillis)
   }
 
   companion object {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.kt
similarity index 61%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.kt
index 38354a73f..fede62f15 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/HeapDumper.kt
@@ -13,23 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.squareup.leakcanary
 
-import java.io.File;
+import java.io.File
 
-/** Dumps the heap into a file. */
-public interface HeapDumper {
-  HeapDumper NONE = new HeapDumper() {
-    @Override public File dumpHeap() {
-      return RETRY_LATER;
-    }
-  };
-
-  File RETRY_LATER = null;
+/** Dumps the heap into a file.  */
+interface HeapDumper {
 
   /**
-   * @return a {@link File} referencing the dumped heap, or {@link #RETRY_LATER} if the heap could
+   * @return a [File] referencing the dumped heap, or [.RETRY_LATER] if the heap could
    * not be dumped.
    */
-  File dumpHeap();
+  fun dumpHeap(): File?
+
+  companion object {
+    val NONE: HeapDumper = object : HeapDumper {
+      override fun dumpHeap(): File? {
+        return RETRY_LATER
+      }
+    }
+
+    val RETRY_LATER: File? = null
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.kt
similarity index 63%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.kt
index de459d673..6267dfc52 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.kt
@@ -13,31 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary;
+package com.squareup.leakcanary
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.List;
+import java.io.File
+import java.io.FilenameFilter
 
 /**
  * Provides access to where heap dumps and analysis results will be stored.
  */
-public interface LeakDirectoryProvider {
+interface LeakDirectoryProvider {
 
-  @NonNull List<File> listFiles(@NonNull FilenameFilter filter);
+  fun listFiles(filter: FilenameFilter): List<File>
 
   /**
-   * @return {@link HeapDumper#RETRY_LATER} if a new heap dump file could not be created.
+   * @return [HeapDumper.RETRY_LATER] if a new heap dump file could not be created.
    */
-  @Nullable File newHeapDumpFile();
+  fun newHeapDumpFile(): File?
 
-  boolean hasPendingHeapDump();
+  fun hasPendingHeapDump(): Boolean
 
   /**
    * Removes all heap dumps and analysis results, except for heap dumps that haven't been
    * analyzed yet.
    */
-  void clearLeakDirectory();
+  fun clearLeakDirectory()
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
deleted file mode 100644
index aaec9e3af..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ /dev/null
@@ -1,552 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.SuppressLint;
-import android.app.ActionBar;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.PendingIntent;
-import android.content.ClipData;
-import android.content.ClipboardManager;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.format.DateUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.Toast;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.AnalyzedHeap;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.LeakCanary;
-import com.squareup.leakcanary.LeakDirectoryProvider;
-import com.squareup.leakcanary.R;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
-import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
-import static android.text.format.Formatter.formatShortFileSize;
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-import static androidx.core.content.FileProvider.getUriForFile;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.getLeakDirectoryProvider;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-@SuppressWarnings("ConstantConditions")
-public final class DisplayLeakActivity extends Activity {
-
-  private static final String SHOW_LEAK_EXTRA = "show_latest";
-  private static final String STACKOVERFLOW_QUESTION_URL =
-      "http://stackoverflow.com/questions/ask?guided=false&tags=leakcanary";
-
-  // Public API.
-  @SuppressWarnings("unused")
-  public static PendingIntent createPendingIntent(Context context) {
-    return createPendingIntent(context, null);
-  }
-
-  public static PendingIntent createPendingIntent(Context context, String referenceKey) {
-    setEnabledBlocking(context, DisplayLeakActivity.class, true);
-    Intent intent = new Intent(context, DisplayLeakActivity.class);
-    intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  // null until it's been first loaded.
-  List<AnalyzedHeap> leaks;
-  String visibleLeakRefKey;
-
-  private ListView listView;
-  private TextView failureView;
-  private Button actionButton;
-  private Button shareButton;
-
-  @SuppressWarnings("unchecked")
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState != null) {
-      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
-    } else {
-      Intent intent = getIntent();
-      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
-        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
-      }
-    }
-
-    leaks = (List<AnalyzedHeap>) getLastNonConfigurationInstance();
-
-    setContentView(R.layout.leak_canary_display_leak);
-
-    listView = findViewById(R.id.leak_canary_display_leak_list);
-    failureView = findViewById(R.id.leak_canary_display_leak_failure);
-    actionButton = findViewById(R.id.leak_canary_action);
-    shareButton = findViewById(R.id.leak_canary_share);
-
-    updateUi();
-  }
-
-  @Override public Object onRetainNonConfigurationInstance() {
-    return leaks;
-  }
-
-  @Override protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putString("visibleLeakRefKey", visibleLeakRefKey);
-  }
-
-  @Override protected void onResume() {
-    super.onResume();
-    LoadLeaks.load(this, getLeakDirectoryProvider(this));
-  }
-
-  @Override public void setTheme(int resid) {
-    // We don't want this to be called with an incompatible theme.
-    // This could happen if you implement runtime switching of themes
-    // using ActivityLifecycleCallbacks.
-    if (resid != R.style.leak_canary_LeakCanary_Base) {
-      return;
-    }
-    super.setTheme(resid);
-  }
-
-  @Override protected void onDestroy() {
-    super.onDestroy();
-    LoadLeaks.forgetActivity();
-  }
-
-  @Override public boolean onCreateOptionsMenu(Menu menu) {
-    AnalyzedHeap visibleLeak = getVisibleLeak();
-    if (visibleLeak != null) {
-      menu.add(R.string.leak_canary_share_leak)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareLeak();
-              return true;
-            }
-          });
-      if (visibleLeak.heapDumpFileExists) {
-        menu.add(R.string.leak_canary_share_heap_dump)
-            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-              @Override public boolean onMenuItemClick(MenuItem item) {
-                shareHeapDump();
-                return true;
-              }
-            });
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override public boolean onOptionsItemSelected(MenuItem item) {
-    if (item.getItemId() == android.R.id.home) {
-      visibleLeakRefKey = null;
-      updateUi();
-    }
-    return true;
-  }
-
-  @Override public void onBackPressed() {
-    if (visibleLeakRefKey != null) {
-      visibleLeakRefKey = null;
-      updateUi();
-    } else {
-      super.onBackPressed();
-    }
-  }
-
-  void shareLeak() {
-    AnalyzedHeap visibleLeak = getVisibleLeak();
-    String leakInfo =
-        LeakCanary.INSTANCE.leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("text/plain");
-    intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  @SuppressLint("SetWorldReadable")
-  void shareHeapDump() {
-    AnalyzedHeap visibleLeak = getVisibleLeak();
-    final File heapDumpFile = visibleLeak.heapDump.getHeapDumpFile();
-    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
-      @Override public void run() {
-        //noinspection ResultOfMethodCallIgnored
-        heapDumpFile.setReadable(true, false);
-        final Uri heapDumpUri = getUriForFile(getBaseContext(),
-            "com.squareup.leakcanary.fileprovider." + getApplication().getPackageName(),
-            heapDumpFile);
-        runOnUiThread(new Runnable() {
-          @Override public void run() {
-            startShareIntentChooser(heapDumpUri);
-          }
-        });
-      }
-    });
-  }
-
-  private void startShareIntentChooser(Uri heapDumpUri) {
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, heapDumpUri);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void deleteVisibleLeak() {
-    final AnalyzedHeap visibleLeak = getVisibleLeak();
-    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
-      @Override public void run() {
-        File heapDumpFile = visibleLeak.heapDump.getHeapDumpFile();
-        File resultFile = visibleLeak.selfFile;
-        boolean resultDeleted = resultFile.delete();
-        if (!resultDeleted) {
-          CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-        }
-        boolean heapDumpDeleted = heapDumpFile.delete();
-        if (!heapDumpDeleted) {
-          CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-        }
-      }
-    });
-    visibleLeakRefKey = null;
-    leaks.remove(visibleLeak);
-    updateUi();
-  }
-
-  void deleteAllLeaks() {
-    final LeakDirectoryProvider leakDirectoryProvider = getLeakDirectoryProvider(this);
-    AsyncTask.SERIAL_EXECUTOR.execute(new Runnable() {
-      @Override public void run() {
-        leakDirectoryProvider.clearLeakDirectory();
-      }
-    });
-    leaks = Collections.emptyList();
-    updateUi();
-  }
-
-  void updateUi() {
-    if (leaks == null) {
-      setTitle("Loading leaks...");
-      return;
-    }
-    if (leaks.isEmpty()) {
-      visibleLeakRefKey = null;
-    }
-
-    final AnalyzedHeap visibleLeak = getVisibleLeak();
-    if (visibleLeak == null) {
-      visibleLeakRefKey = null;
-    }
-
-    ListAdapter listAdapter = listView.getAdapter();
-    // Reset to defaults
-    listView.setVisibility(VISIBLE);
-    failureView.setVisibility(GONE);
-
-    if (visibleLeak != null) {
-      AnalysisResult result = visibleLeak.result;
-      actionButton.setVisibility(VISIBLE);
-      actionButton.setText(R.string.leak_canary_delete);
-      actionButton.setOnClickListener(new View.OnClickListener() {
-        @Override public void onClick(View v) {
-          deleteVisibleLeak();
-        }
-      });
-      shareButton.setVisibility(VISIBLE);
-      shareButton.setText(getString(R.string.leak_canary_stackoverflow_share));
-      shareButton.setOnClickListener(new View.OnClickListener() {
-        @Override public void onClick(View v) {
-          shareLeakToStackOverflow();
-        }
-      });
-      invalidateOptionsMenu();
-      setDisplayHomeAsUpEnabled(true);
-
-      if (result.getLeakFound()) {
-        final DisplayLeakAdapter adapter = new DisplayLeakAdapter(getResources());
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            adapter.toggleRow(position);
-          }
-        });
-        adapter.update(result.getLeakTrace(), result.getReferenceKey(), result.getReferenceName());
-        if (result.getRetainedHeapSize() == AnalysisResult.Companion.getRETAINED_HEAP_SKIPPED()) {
-          String className = classSimpleName(result.getClassName());
-          setTitle(getString(R.string.leak_canary_class_has_leaked, className));
-        } else {
-          String size = formatShortFileSize(this, result.getRetainedHeapSize());
-          String className = classSimpleName(result.getClassName());
-          setTitle(getString(R.string.leak_canary_class_has_leaked_retaining, className, size));
-        }
-      } else {
-        listView.setVisibility(GONE);
-        failureView.setVisibility(VISIBLE);
-        listView.setAdapter(null);
-
-        String failureMessage;
-        if (result.getFailure() != null) {
-          setTitle(R.string.leak_canary_analysis_failed);
-          failureMessage = getString(R.string.leak_canary_failure_report)
-              + LIBRARY_VERSION
-              + " "
-              + GIT_SHA
-              + "\n"
-              + Log.getStackTraceString(result.getFailure());
-        } else {
-          String className = classSimpleName(result.getClassName());
-          setTitle(getString(R.string.leak_canary_class_no_leak, className));
-          failureMessage = getString(R.string.leak_canary_no_leak_details);
-        }
-        String path = visibleLeak.heapDump.getHeapDumpFile().getAbsolutePath();
-        failureMessage += "\n\n" + getString(R.string.leak_canary_download_dump, path);
-        failureView.setText(failureMessage);
-      }
-    } else {
-      if (listAdapter instanceof LeakListAdapter) {
-        ((LeakListAdapter) listAdapter).notifyDataSetChanged();
-      } else {
-        LeakListAdapter adapter = new LeakListAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            visibleLeakRefKey = leaks.get(position).result.getReferenceKey();
-            updateUi();
-          }
-        });
-        invalidateOptionsMenu();
-        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.leak_canary_delete_all);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            new AlertDialog.Builder(DisplayLeakActivity.this).setIcon(
-                android.R.drawable.ic_dialog_alert)
-                .setTitle(R.string.leak_canary_delete_all)
-                .setMessage(R.string.leak_canary_delete_all_leaks_title)
-                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
-                  @Override public void onClick(DialogInterface dialog, int which) {
-                    deleteAllLeaks();
-                  }
-                })
-                .setNegativeButton(android.R.string.cancel, null)
-                .show();
-          }
-        });
-      }
-      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
-      shareButton.setVisibility(GONE);
-    }
-  }
-
-  private void shareLeakToStackOverflow() {
-    AnalyzedHeap visibleLeak = getVisibleLeak();
-    final String leakInfo =
-        LeakCanary.INSTANCE.leakInfo(this, visibleLeak.heapDump, visibleLeak.result, false);
-    final ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
-    // AsyncTask was needed here due to setPrimaryClip making a disk write which
-    // violated StrictMode if on the main thread
-    AsyncTask.execute(new Runnable() {
-      @Override
-      public void run() {
-        clipboard.setPrimaryClip(
-            ClipData.newPlainText(getString(R.string.leak_canary_leak_clipdata_label),
-                "```\n" + leakInfo + "```"));
-      }
-    });
-    Toast.makeText(this, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG).show();
-    Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL));
-    startActivity(browserIntent);
-  }
-
-  private void setDisplayHomeAsUpEnabled(boolean enabled) {
-    ActionBar actionBar = getActionBar();
-    if (actionBar == null) {
-      // https://github.com/square/leakcanary/issues/967
-      return;
-    }
-    actionBar.setDisplayHomeAsUpEnabled(enabled);
-  }
-
-  AnalyzedHeap getVisibleLeak() {
-    if (leaks == null) {
-      return null;
-    }
-    for (AnalyzedHeap leak : leaks) {
-      if (leak.result.getReferenceKey().equals(visibleLeakRefKey)) {
-        return leak;
-      }
-    }
-    return null;
-  }
-
-  class LeakListAdapter extends BaseAdapter {
-
-    @Override public int getCount() {
-      return leaks.size();
-    }
-
-    @Override public AnalyzedHeap getItem(int position) {
-      return leaks.get(position);
-    }
-
-    @Override public long getItemId(int position) {
-      return position;
-    }
-
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.leak_canary_leak_row, parent, false);
-      }
-      TextView titleView = convertView.findViewById(R.id.leak_canary_row_text);
-      TextView timeView = convertView.findViewById(R.id.leak_canary_row_time);
-      AnalyzedHeap leak = getItem(position);
-
-      String index = (leaks.size() - position) + ". ";
-
-      String title;
-      if (leak.result.getFailure() != null) {
-        title = index
-            + leak.result.getFailure().getClass().getSimpleName()
-            + " "
-            + leak.result.getFailure().getMessage();
-      } else {
-        String className = classSimpleName(leak.result.getClassName());
-        if (leak.result.getLeakFound()) {
-          if (leak.result.getRetainedHeapSize() == AnalysisResult.Companion.getRETAINED_HEAP_SKIPPED()) {
-            title = getString(R.string.leak_canary_class_has_leaked, className);
-          } else {
-            String size = formatShortFileSize(DisplayLeakActivity.this,
-                leak.result.getRetainedHeapSize());
-            title = getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
-          }
-          if (leak.result.getExcludedLeak()) {
-            title = getString(R.string.leak_canary_excluded_row, title);
-          }
-          title = index + title;
-        } else {
-          title = index + getString(R.string.leak_canary_class_no_leak, className);
-        }
-      }
-      titleView.setText(title);
-      String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.selfLastModified,
-              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
-      timeView.setText(time);
-      return convertView;
-    }
-  }
-
-  static class LoadLeaks implements Runnable {
-
-    static final List<LoadLeaks> inFlight = new ArrayList<>();
-
-    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
-
-    static void load(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectoryProvider);
-      inFlight.add(loadLeaks);
-      backgroundExecutor.execute(loadLeaks);
-    }
-
-    static void forgetActivity() {
-      for (LoadLeaks loadLeaks : inFlight) {
-        loadLeaks.activityOrNull = null;
-      }
-      inFlight.clear();
-    }
-
-    DisplayLeakActivity activityOrNull;
-    private final LeakDirectoryProvider leakDirectoryProvider;
-    private final Handler mainHandler;
-
-    LoadLeaks(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
-      this.activityOrNull = activity;
-      this.leakDirectoryProvider = leakDirectoryProvider;
-      mainHandler = new Handler(Looper.getMainLooper());
-    }
-
-    @Override public void run() {
-      final List<AnalyzedHeap> leaks = new ArrayList<>();
-      List<File> files = leakDirectoryProvider.listFiles(new FilenameFilter() {
-        @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".result");
-        }
-      });
-      for (File resultFile : files) {
-        final AnalyzedHeap leak = AnalyzedHeap.load(resultFile);
-        if (leak != null) {
-          leaks.add(leak);
-        }
-      }
-      Collections.sort(leaks, new Comparator<AnalyzedHeap>() {
-        @Override public int compare(AnalyzedHeap lhs, AnalyzedHeap rhs) {
-          return Long.valueOf(rhs.selfFile.lastModified())
-              .compareTo(lhs.selfFile.lastModified());
-        }
-      });
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          inFlight.remove(LoadLeaks.this);
-          if (activityOrNull != null) {
-            activityOrNull.leaks = leaks;
-            activityOrNull.updateUi();
-          }
-        }
-      });
-    }
-  }
-
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.kt
new file mode 100644
index 000000000..bbae7c007
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.kt
@@ -0,0 +1,523 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.app.AlertDialog
+import android.app.PendingIntent
+import android.app.PendingIntent.FLAG_UPDATE_CURRENT
+import android.content.ClipData
+import android.content.ClipboardManager
+import android.content.Context
+import android.content.Intent
+import android.net.Uri
+import android.os.AsyncTask
+import android.os.Bundle
+import android.os.Handler
+import android.os.Looper
+import android.text.format.DateUtils
+import android.text.format.DateUtils.FORMAT_SHOW_DATE
+import android.text.format.DateUtils.FORMAT_SHOW_TIME
+import android.text.format.Formatter.formatShortFileSize
+import android.util.Log
+import android.view.LayoutInflater
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.view.View.GONE
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.AdapterView
+import android.widget.BaseAdapter
+import android.widget.Button
+import android.widget.ListView
+import android.widget.TextView
+import android.widget.Toast
+import androidx.core.content.FileProvider.getUriForFile
+import com.squareup.leakcanary.AnalysisResult
+import com.squareup.leakcanary.AnalyzedHeap
+import com.squareup.leakcanary.BuildConfig.GIT_SHA
+import com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION
+import com.squareup.leakcanary.CanaryLog
+import com.squareup.leakcanary.LeakCanary
+import com.squareup.leakcanary.LeakDirectoryProvider
+import com.squareup.leakcanary.R
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.getLeakDirectoryProvider
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.newSingleThreadExecutor
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.setEnabledBlocking
+import java.io.File
+import java.io.FilenameFilter
+import java.util.ArrayList
+import java.util.Comparator
+
+class DisplayLeakActivity : Activity() {
+
+  // null until it's been first loaded.
+  private var leaks: MutableList<AnalyzedHeap>? = null
+  private var visibleLeakRefKey: String? = null
+
+  private lateinit var listView: ListView
+  private lateinit var failureView: TextView
+  private lateinit var actionButton: Button
+  private lateinit var shareButton: Button
+
+  internal val visibleLeak: AnalyzedHeap?
+    get() {
+      if (leaks == null) {
+        return null
+      }
+      for (leak in leaks!!) {
+        if (leak.result.referenceKey == visibleLeakRefKey) {
+          return leak
+        }
+      }
+      return null
+    }
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+
+    if (savedInstanceState != null) {
+      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey")
+    } else {
+      val intent = intent
+      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
+        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA)
+      }
+    }
+
+    @Suppress("UNCHECKED_CAST")
+    leaks = lastNonConfigurationInstance as MutableList<AnalyzedHeap>?
+
+    setContentView(R.layout.leak_canary_display_leak)
+
+    listView = findViewById(R.id.leak_canary_display_leak_list)
+    failureView = findViewById(R.id.leak_canary_display_leak_failure)
+    actionButton = findViewById(R.id.leak_canary_action)
+    shareButton = findViewById(R.id.leak_canary_share)
+
+    updateUi()
+  }
+
+  override fun onRetainNonConfigurationInstance(): Any? {
+    return leaks
+  }
+
+  override fun onSaveInstanceState(outState: Bundle) {
+    super.onSaveInstanceState(outState)
+    outState.putString("visibleLeakRefKey", visibleLeakRefKey)
+  }
+
+  override fun onResume() {
+    super.onResume()
+    LoadLeaks.load(this, getLeakDirectoryProvider(this))
+  }
+
+  override fun setTheme(resid: Int) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return
+    }
+    super.setTheme(resid)
+  }
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LoadLeaks.forgetActivity()
+  }
+
+  override fun onCreateOptionsMenu(menu: Menu): Boolean {
+    val visibleLeak = visibleLeak
+    if (visibleLeak != null) {
+      menu.add(R.string.leak_canary_share_leak)
+          .setOnMenuItemClickListener {
+            shareLeak()
+            true
+          }
+      if (visibleLeak.heapDumpFileExists) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener {
+              shareHeapDump()
+              true
+            }
+      }
+      return true
+    }
+    return false
+  }
+
+  override fun onOptionsItemSelected(item: MenuItem): Boolean {
+    if (item.itemId == android.R.id.home) {
+      visibleLeakRefKey = null
+      updateUi()
+    }
+    return true
+  }
+
+  override fun onBackPressed() {
+    if (visibleLeakRefKey != null) {
+      visibleLeakRefKey = null
+      updateUi()
+    } else {
+      super.onBackPressed()
+    }
+  }
+
+  private fun shareLeak() {
+    val visibleLeak = visibleLeak
+    val leakInfo = LeakCanary.leakInfo(this, visibleLeak!!.heapDump, visibleLeak.result, true)
+    val intent = Intent(Intent.ACTION_SEND)
+    intent.type = "text/plain"
+    intent.putExtra(Intent.EXTRA_TEXT, leakInfo)
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)))
+  }
+
+  @SuppressLint("SetWorldReadable")
+  internal fun shareHeapDump() {
+    val visibleLeak = visibleLeak
+    val heapDumpFile = visibleLeak!!.heapDump.heapDumpFile
+    AsyncTask.SERIAL_EXECUTOR.execute {
+      heapDumpFile.setReadable(true, false)
+      val heapDumpUri = getUriForFile(
+          baseContext,
+          "com.squareup.leakcanary.fileprovider." + application.packageName,
+          heapDumpFile
+      )
+      runOnUiThread { startShareIntentChooser(heapDumpUri) }
+    }
+  }
+
+  private fun startShareIntentChooser(heapDumpUri: Uri) {
+    val intent = Intent(Intent.ACTION_SEND)
+    intent.type = "application/octet-stream"
+    intent.putExtra(Intent.EXTRA_STREAM, heapDumpUri)
+    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)))
+  }
+
+  private fun deleteVisibleLeak() {
+    val visibleLeak = visibleLeak
+    AsyncTask.SERIAL_EXECUTOR.execute {
+      val heapDumpFile = visibleLeak!!.heapDump.heapDumpFile
+      val resultFile = visibleLeak.selfFile
+      val resultDeleted = resultFile.delete()
+      if (!resultDeleted) {
+        CanaryLog.d("Could not delete result file %s", resultFile.path)
+      }
+      val heapDumpDeleted = heapDumpFile.delete()
+      if (!heapDumpDeleted) {
+        CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.path)
+      }
+    }
+    visibleLeakRefKey = null
+    leaks!!.remove(visibleLeak)
+    updateUi()
+  }
+
+  private fun deleteAllLeaks() {
+    val leakDirectoryProvider = getLeakDirectoryProvider(this)
+    AsyncTask.SERIAL_EXECUTOR.execute { leakDirectoryProvider.clearLeakDirectory() }
+    leaks = mutableListOf()
+    updateUi()
+  }
+
+  internal fun updateUi() {
+    if (leaks == null) {
+      title = "Loading leaks..."
+      return
+    }
+    if (leaks!!.isEmpty()) {
+      visibleLeakRefKey = null
+    }
+
+    val visibleLeak = visibleLeak
+    if (visibleLeak == null) {
+      visibleLeakRefKey = null
+    }
+
+    val listAdapter = listView.adapter
+    // Reset to defaults
+    listView.visibility = VISIBLE
+    failureView.visibility = GONE
+
+    if (visibleLeak != null) {
+      val result = visibleLeak.result
+      actionButton.visibility = VISIBLE
+      actionButton.setText(R.string.leak_canary_delete)
+      actionButton.setOnClickListener { deleteVisibleLeak() }
+      shareButton.visibility = VISIBLE
+      shareButton.text = getString(R.string.leak_canary_stackoverflow_share)
+      shareButton.setOnClickListener { shareLeakToStackOverflow() }
+      invalidateOptionsMenu()
+      setDisplayHomeAsUpEnabled(true)
+
+      if (result.leakFound) {
+        val adapter = DisplayLeakAdapter(resources)
+        listView.adapter = adapter
+        listView.onItemClickListener =
+          AdapterView.OnItemClickListener { parent, view, position, id ->
+            adapter.toggleRow(
+                position
+            )
+          }
+        adapter.update(result.leakTrace!!, result.referenceKey, result.referenceName)
+        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+          val className = classSimpleName(result.className!!)
+          title = getString(R.string.leak_canary_class_has_leaked, className)
+        } else {
+          val size = formatShortFileSize(this, result.retainedHeapSize)
+          val className = classSimpleName(result.className!!)
+          title = getString(R.string.leak_canary_class_has_leaked_retaining, className, size)
+        }
+      } else {
+        listView.visibility = GONE
+        failureView.visibility = VISIBLE
+        listView.adapter = null
+
+        var failureMessage: String
+        if (result.failure != null) {
+          setTitle(R.string.leak_canary_analysis_failed)
+          failureMessage = (getString(R.string.leak_canary_failure_report)
+              + LIBRARY_VERSION
+              + " "
+              + GIT_SHA
+              + "\n"
+              + Log.getStackTraceString(result.failure))
+        } else {
+          val className = classSimpleName(result.className!!)
+          title = getString(R.string.leak_canary_class_no_leak, className)
+          failureMessage = getString(R.string.leak_canary_no_leak_details)
+        }
+        val path = visibleLeak.heapDump.heapDumpFile.absolutePath
+        failureMessage += "\n\n" + getString(R.string.leak_canary_download_dump, path)
+        failureView.text = failureMessage
+      }
+    } else {
+      if (listAdapter is LeakListAdapter) {
+        listAdapter.notifyDataSetChanged()
+      } else {
+        val adapter = LeakListAdapter()
+        listView.adapter = adapter
+        listView.onItemClickListener =
+          AdapterView.OnItemClickListener { parent, view, position, id ->
+            visibleLeakRefKey = leaks!![position]
+                .result.referenceKey
+            updateUi()
+          }
+        invalidateOptionsMenu()
+        title = getString(R.string.leak_canary_leak_list_title, packageName)
+        setDisplayHomeAsUpEnabled(false)
+        actionButton.setText(R.string.leak_canary_delete_all)
+        actionButton.setOnClickListener {
+          AlertDialog.Builder(this@DisplayLeakActivity)
+              .setIcon(
+                  android.R.drawable.ic_dialog_alert
+              )
+              .setTitle(R.string.leak_canary_delete_all)
+              .setMessage(R.string.leak_canary_delete_all_leaks_title)
+              .setPositiveButton(android.R.string.ok) { dialog, which -> deleteAllLeaks() }
+              .setNegativeButton(android.R.string.cancel, null)
+              .show()
+        }
+      }
+      actionButton.visibility = if (leaks!!.size == 0) GONE else VISIBLE
+      shareButton.visibility = GONE
+    }
+  }
+
+  private fun shareLeakToStackOverflow() {
+    val visibleLeak = visibleLeak
+    val leakInfo = LeakCanary.leakInfo(this, visibleLeak!!.heapDump, visibleLeak.result, false)
+    val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+    // AsyncTask was needed here due to setPrimaryClip making a disk write which
+    // violated StrictMode if on the main thread
+    AsyncTask.execute {
+      clipboard.primaryClip = ClipData.newPlainText(
+          getString(R.string.leak_canary_leak_clipdata_label),
+          "```\n$leakInfo```"
+      )
+    }
+    Toast.makeText(this, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
+        .show()
+    val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL))
+    startActivity(browserIntent)
+  }
+
+  private fun setDisplayHomeAsUpEnabled(enabled: Boolean) {
+    val actionBar = actionBar
+        ?: // https://github.com/square/leakcanary/issues/967
+        return
+    actionBar.setDisplayHomeAsUpEnabled(enabled)
+  }
+
+  internal inner class LeakListAdapter : BaseAdapter() {
+
+    override fun getCount(): Int {
+      return leaks!!.size
+    }
+
+    override fun getItem(position: Int): AnalyzedHeap {
+      return leaks!![position]
+    }
+
+    override fun getItemId(position: Int): Long {
+      return position.toLong()
+    }
+
+    override fun getView(
+      position: Int,
+      convertView: View?,
+      parent: ViewGroup
+    ): View {
+      var convertView = convertView
+      if (convertView == null) {
+        convertView = LayoutInflater.from(this@DisplayLeakActivity)
+            .inflate(R.layout.leak_canary_leak_row, parent, false)
+      }
+      val titleView = convertView!!.findViewById<TextView>(R.id.leak_canary_row_text)
+      val timeView = convertView.findViewById<TextView>(R.id.leak_canary_row_time)
+      val leak = getItem(position)
+
+      val index = (leaks!!.size - position).toString() + ". "
+
+      var title: String
+      if (leak.result.failure != null) {
+        title = (index
+            + leak.result.failure!!.javaClass.simpleName
+            + " "
+            + leak.result.failure!!.message)
+      } else {
+        val className = classSimpleName(leak.result.className!!)
+        if (leak.result.leakFound) {
+          title = if (leak.result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
+            getString(R.string.leak_canary_class_has_leaked, className)
+          } else {
+            val size = formatShortFileSize(
+                this@DisplayLeakActivity,
+                leak.result.retainedHeapSize
+            )
+            getString(R.string.leak_canary_class_has_leaked_retaining, className, size)
+          }
+          if (leak.result.excludedLeak) {
+            title = getString(R.string.leak_canary_excluded_row, title)
+          }
+          title = index + title
+        } else {
+          title = index + getString(R.string.leak_canary_class_no_leak, className)
+        }
+      }
+      titleView.text = title
+      val time = DateUtils.formatDateTime(
+          this@DisplayLeakActivity, leak.selfLastModified,
+          FORMAT_SHOW_TIME or FORMAT_SHOW_DATE
+      )
+      timeView.text = time
+      return convertView
+    }
+  }
+
+  internal class LoadLeaks(
+    var activityOrNull: DisplayLeakActivity?,
+    private val leakDirectoryProvider: LeakDirectoryProvider
+  ) : Runnable {
+    private val mainHandler: Handler = Handler(Looper.getMainLooper())
+
+    override fun run() {
+      val leaks = ArrayList<AnalyzedHeap>()
+      val files = leakDirectoryProvider.listFiles(object : FilenameFilter {
+        override fun accept(
+          dir: File,
+          name: String
+        ): Boolean = name.endsWith(".result")
+
+      })
+      for (resultFile in files) {
+        val leak = AnalyzedHeap.load(resultFile)
+        if (leak != null) {
+          leaks.add(leak)
+        }
+      }
+      leaks.sortWith(Comparator { lhs, rhs ->
+        java.lang.Long.valueOf(rhs.selfFile.lastModified())
+            .compareTo(lhs.selfFile.lastModified())
+      })
+      mainHandler.post {
+        inFlight.remove(this@LoadLeaks)
+        if (activityOrNull != null) {
+          activityOrNull!!.leaks = leaks
+          activityOrNull!!.updateUi()
+        }
+      }
+    }
+
+    companion object {
+
+      val inFlight: MutableList<LoadLeaks> = ArrayList()
+
+      private val backgroundExecutor = newSingleThreadExecutor("LoadLeaks")
+
+      fun load(
+        activity: DisplayLeakActivity,
+        leakDirectoryProvider: LeakDirectoryProvider
+      ) {
+        val loadLeaks = LoadLeaks(activity, leakDirectoryProvider)
+        inFlight.add(loadLeaks)
+        backgroundExecutor.execute(loadLeaks)
+      }
+
+      fun forgetActivity() {
+        for (loadLeaks in inFlight) {
+          loadLeaks.activityOrNull = null
+        }
+        inFlight.clear()
+      }
+    }
+  }
+
+  companion object {
+
+    private const val SHOW_LEAK_EXTRA = "show_latest"
+    private const val STACKOVERFLOW_QUESTION_URL =
+      "http://stackoverflow.com/questions/ask?guided=false&tags=leakcanary"
+
+    // Public API.
+    fun createPendingIntent(context: Context): PendingIntent {
+      return createPendingIntent(context, null)
+    }
+
+    fun createPendingIntent(
+      context: Context,
+      referenceKey: String?
+    ): PendingIntent {
+      setEnabledBlocking(context, DisplayLeakActivity::class.java, true)
+      val intent = Intent(context, DisplayLeakActivity::class.java)
+      intent.putExtra(SHOW_LEAK_EXTRA, referenceKey)
+      intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT)
+    }
+
+    internal fun classSimpleName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
deleted file mode 100644
index e94359f37..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ /dev/null
@@ -1,320 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.text.Html;
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.TextView;
-import androidx.annotation.ColorRes;
-import com.squareup.leakcanary.Exclusion;
-import com.squareup.leakcanary.LeakTrace;
-import com.squareup.leakcanary.LeakTraceElement;
-import com.squareup.leakcanary.R;
-import com.squareup.leakcanary.Reachability;
-
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-final class DisplayLeakAdapter extends BaseAdapter {
-
-  private static final int TOP_ROW = 0;
-  private static final int NORMAL_ROW = 1;
-
-  private boolean[] opened = new boolean[0];
-
-  private LeakTrace leakTrace = null;
-  private String referenceKey;
-  private String referenceName = "";
-
-  private final String classNameColorHexString;
-  private final String leakColorHexString;
-  private final String referenceColorHexString;
-  private final String extraColorHexString;
-  private final String helpColorHexString;
-
-  DisplayLeakAdapter(Resources resources) {
-    classNameColorHexString = hexStringColor(resources, R.color.leak_canary_class_name);
-    leakColorHexString = hexStringColor(resources, R.color.leak_canary_leak);
-    referenceColorHexString = hexStringColor(resources, R.color.leak_canary_reference);
-    extraColorHexString = hexStringColor(resources, R.color.leak_canary_extra);
-    helpColorHexString = hexStringColor(resources, R.color.leak_canary_help);
-  }
-
-  // https://stackoverflow.com/a/6540378/703646
-  private static String hexStringColor(Resources resources, @ColorRes int colorResId) {
-    return String.format("#%06X", (0xFFFFFF & resources.getColor(colorResId)));
-  }
-
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    Context context = parent.getContext();
-    if (getItemViewType(position) == TOP_ROW) {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-      textView.setText(context.getPackageName());
-    } else {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
-      }
-
-      TextView titleView = findById(convertView, R.id.leak_canary_row_title);
-      TextView detailView = findById(convertView, R.id.leak_canary_row_details);
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-
-      connector.setType(getConnectorType(position));
-      moreDetailsView.setOpened(opened[position]);
-
-      if (opened[position]) {
-        detailView.setVisibility(View.VISIBLE);
-      } else {
-        detailView.setVisibility(View.GONE);
-      }
-
-      Resources resources = convertView.getResources();
-      if (position == 1) {
-        titleView.setText(Html.fromHtml("<font color='"
-            + helpColorHexString
-            + "'>"
-            + "<b>" + resources.getString(R.string.leak_canary_help_title) + "</b>"
-            + "</font>"));
-        SpannableStringBuilder detailText =
-            (SpannableStringBuilder) Html.fromHtml(
-                resources.getString(R.string.leak_canary_help_detail));
-        SquigglySpan.replaceUnderlineSpans(detailText, resources);
-        detailView.setText(detailText);
-      } else {
-        boolean isLeakingInstance = position == getCount() - 1;
-        LeakTraceElement element = getItem(position);
-
-        Reachability reachability = leakTrace.getExpectedReachability().get(elementIndex(position));
-        boolean maybeLeakCause;
-        if (isLeakingInstance || reachability.status == Reachability.Status.UNREACHABLE) {
-          maybeLeakCause = false;
-        } else {
-          Reachability nextReachability =
-              leakTrace.getExpectedReachability().get(elementIndex(position + 1));
-          maybeLeakCause = nextReachability.status != Reachability.Status.REACHABLE;
-        }
-
-        Spanned htmlTitle = htmlTitle(element, maybeLeakCause, resources);
-
-        titleView.setText(htmlTitle);
-
-        if (opened[position]) {
-          Spanned htmlDetail = htmlDetails(isLeakingInstance, element);
-          detailView.setText(htmlDetail);
-        }
-      }
-    }
-
-    return convertView;
-  }
-
-  private Spanned htmlTitle(LeakTraceElement element, boolean maybeLeakCause, Resources resources) {
-    String htmlString = "";
-
-    String simpleName = element.getSimpleClassName();
-    simpleName = simpleName.replace("[]", "[ ]");
-
-    String styledClassName =
-        "<font color='" + classNameColorHexString + "'>" + simpleName + "</font>";
-
-    if (element.getReference() != null) {
-      String referenceName = element.getReference().getDisplayName().replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;");
-
-      if (maybeLeakCause) {
-        referenceName =
-            "<u><font color='" + leakColorHexString + "'>" + referenceName + "</font></u>";
-      } else {
-        referenceName =
-            "<font color='" + referenceColorHexString + "'>" + referenceName + "</font>";
-      }
-
-      if (element.getReference().type == STATIC_FIELD) {
-        referenceName = "<i>" + referenceName + "</i>";
-      }
-
-      String classAndReference = styledClassName + "." + referenceName;
-
-      if (maybeLeakCause) {
-        classAndReference = "<b>" + classAndReference + "</b>";
-      }
-
-      htmlString += classAndReference;
-    } else {
-      htmlString += styledClassName;
-    }
-
-    Exclusion exclusion = element.getExclusion();
-    if (exclusion != null) {
-      htmlString += " (excluded)";
-    }
-    SpannableStringBuilder builder = (SpannableStringBuilder) Html.fromHtml(htmlString);
-    if (maybeLeakCause) {
-      SquigglySpan.replaceUnderlineSpans(builder, resources);
-    }
-
-    return builder;
-  }
-
-  private Spanned htmlDetails(boolean isLeakingInstance, LeakTraceElement element) {
-    String htmlString = "";
-    if (element.getExtra() != null) {
-      htmlString += " <font color='" + extraColorHexString + "'>" + element.getExtra() + "</font>";
-    }
-
-    Exclusion exclusion = element.getExclusion();
-    if (exclusion != null) {
-      htmlString += "<br/><br/>Excluded by rule";
-      if (exclusion.name != null) {
-        htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-      }
-      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-      if (exclusion.reason != null) {
-        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
-      }
-    }
-    htmlString += "<br>"
-        + "<font color='" + extraColorHexString + "'>"
-        + element.toDetailedString().replace("\n", "<br>")
-        + "</font>";
-
-    if (isLeakingInstance && !referenceName.equals("")) {
-      htmlString += " <font color='" + extraColorHexString + "'>" + referenceName + "</font>";
-    }
-
-    return Html.fromHtml(htmlString);
-  }
-
-  private DisplayLeakConnectorView.Type getConnectorType(int position) {
-    if (position == 1) {
-      return DisplayLeakConnectorView.Type.HELP;
-    } else if (position == 2) {
-      if (leakTrace.getExpectedReachability().size() == 1) {
-        return DisplayLeakConnectorView.Type.START_LAST_REACHABLE;
-      }
-      Reachability nextReachability =
-          leakTrace.getExpectedReachability().get(elementIndex(position + 1));
-      if (nextReachability.status != Reachability.Status.REACHABLE) {
-        return DisplayLeakConnectorView.Type.START_LAST_REACHABLE;
-      }
-      return DisplayLeakConnectorView.Type.START;
-    } else {
-      boolean isLeakingInstance = position == getCount() - 1;
-      if (isLeakingInstance) {
-        Reachability previousReachability =
-            leakTrace.getExpectedReachability().get(elementIndex(position - 1));
-        if (previousReachability.status != Reachability.Status.UNREACHABLE) {
-          return DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE;
-        }
-        return DisplayLeakConnectorView.Type.END;
-      } else {
-        Reachability reachability = leakTrace.getExpectedReachability().get(elementIndex(position));
-        switch (reachability.status) {
-          case UNKNOWN:
-            return DisplayLeakConnectorView.Type.NODE_UNKNOWN;
-          case REACHABLE:
-            Reachability nextReachability =
-                leakTrace.getExpectedReachability().get(elementIndex(position + 1));
-            if (nextReachability.status != Reachability.Status.REACHABLE) {
-              return DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE;
-            } else {
-              return DisplayLeakConnectorView.Type.NODE_REACHABLE;
-            }
-          case UNREACHABLE:
-            Reachability previousReachability =
-                leakTrace.getExpectedReachability().get(elementIndex(position - 1));
-            if (previousReachability.status != Reachability.Status.UNREACHABLE) {
-              return DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE;
-            } else {
-              return DisplayLeakConnectorView.Type.NODE_UNREACHABLE;
-            }
-          default:
-            throw new IllegalStateException("Unknown value: " + reachability.status);
-        }
-      }
-    }
-  }
-
-  public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
-    if (referenceKey.equals(this.referenceKey)) {
-      // Same data, nothing to change.
-      return;
-    }
-    this.referenceKey = referenceKey;
-    this.referenceName = referenceName;
-    this.leakTrace = leakTrace;
-    opened = new boolean[2 + leakTrace.getElements().size()];
-    notifyDataSetChanged();
-  }
-
-  public void toggleRow(int position) {
-    opened[position] = !opened[position];
-    notifyDataSetChanged();
-  }
-
-  @Override public int getCount() {
-    if (leakTrace == null) {
-      return 2;
-    }
-    return 2 + leakTrace.getElements().size();
-  }
-
-  @Override public LeakTraceElement getItem(int position) {
-    if (getItemViewType(position) == TOP_ROW) {
-      return null;
-    }
-    if (position == 1) {
-      return null;
-    }
-    return leakTrace.getElements().get(elementIndex(position));
-  }
-
-  private int elementIndex(int position) {
-    return position - 2;
-  }
-
-  @Override public int getViewTypeCount() {
-    return 2;
-  }
-
-  @Override public int getItemViewType(int position) {
-    if (position == 0) {
-      return TOP_ROW;
-    }
-    return NORMAL_ROW;
-  }
-
-  @Override public long getItemId(int position) {
-    return position;
-  }
-
-  @SuppressWarnings({ "unchecked", "TypeParameterUnusedInFormals" })
-  private static <T extends View> T findById(View view, int id) {
-    return (T) view.findViewById(id);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.kt
new file mode 100644
index 000000000..42f27652c
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.kt
@@ -0,0 +1,330 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.content.res.Resources
+import android.text.Html
+import android.text.SpannableStringBuilder
+import android.text.Spanned
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.TextView
+import androidx.annotation.ColorRes
+import com.squareup.leakcanary.LeakTrace
+import com.squareup.leakcanary.LeakTraceElement
+import com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import com.squareup.leakcanary.R
+import com.squareup.leakcanary.Reachability
+
+internal class DisplayLeakAdapter(resources: Resources) : BaseAdapter() {
+
+  private var opened = BooleanArray(0)
+
+  private var leakTrace: LeakTrace? = null
+  private var referenceKey: String? = null
+  private var referenceName = ""
+
+  private val classNameColorHexString: String
+  private val leakColorHexString: String
+  private val referenceColorHexString: String
+  private val extraColorHexString: String
+  private val helpColorHexString: String
+
+  init {
+    classNameColorHexString = hexStringColor(resources, R.color.leak_canary_class_name)
+    leakColorHexString = hexStringColor(resources, R.color.leak_canary_leak)
+    referenceColorHexString = hexStringColor(resources, R.color.leak_canary_reference)
+    extraColorHexString = hexStringColor(resources, R.color.leak_canary_extra)
+    helpColorHexString = hexStringColor(resources, R.color.leak_canary_help)
+  }
+
+  override fun getView(
+    position: Int,
+    convertView: View?,
+    parent: ViewGroup
+  ): View {
+    var convertView = convertView
+    val context = parent.context
+    if (getItemViewType(position) == TOP_ROW) {
+      if (convertView == null) {
+        convertView = LayoutInflater.from(context)
+            .inflate(R.layout.leak_canary_ref_top_row, parent, false)
+      }
+      val textView = findById<TextView>(convertView!!, R.id.leak_canary_row_text)
+      textView.text = context.packageName
+    } else {
+      if (convertView == null) {
+        convertView = LayoutInflater.from(context)
+            .inflate(R.layout.leak_canary_ref_row, parent, false)
+      }
+
+      val titleView = findById<TextView>(convertView!!, R.id.leak_canary_row_title)
+      val detailView = findById<TextView>(convertView, R.id.leak_canary_row_details)
+      val connector =
+        findById<DisplayLeakConnectorView>(convertView, R.id.leak_canary_row_connector)
+      val moreDetailsView = findById<MoreDetailsView>(convertView, R.id.leak_canary_row_more)
+
+      connector.setType(getConnectorType(position))
+      moreDetailsView.setOpened(opened[position])
+
+      if (opened[position]) {
+        detailView.visibility = View.VISIBLE
+      } else {
+        detailView.visibility = View.GONE
+      }
+
+      val resources = convertView.resources
+      if (position == 1) {
+        titleView.text = Html.fromHtml(
+            "<font color='"
+                + helpColorHexString
+                + "'>"
+                + "<b>" + resources.getString(R.string.leak_canary_help_title) + "</b>"
+                + "</font>"
+        )
+        val detailText = Html.fromHtml(
+            resources.getString(R.string.leak_canary_help_detail)
+        ) as SpannableStringBuilder
+        SquigglySpan.replaceUnderlineSpans(detailText, resources)
+        detailView.text = detailText
+      } else {
+        val isLeakingInstance = position == count - 1
+        val element = getItem(position)
+
+        val reachability = leakTrace!!.expectedReachability[elementIndex(position)]
+        val maybeLeakCause: Boolean
+        if (isLeakingInstance || reachability.status == Reachability.Status.UNREACHABLE) {
+          maybeLeakCause = false
+        } else {
+          val nextReachability = leakTrace!!.expectedReachability[elementIndex(position + 1)]
+          maybeLeakCause = nextReachability.status != Reachability.Status.REACHABLE
+        }
+
+        val htmlTitle = htmlTitle(element!!, maybeLeakCause, resources)
+
+        titleView.text = htmlTitle
+
+        if (opened[position]) {
+          val htmlDetail = htmlDetails(isLeakingInstance, element)
+          detailView.text = htmlDetail
+        }
+      }
+    }
+
+    return convertView
+  }
+
+  private fun htmlTitle(
+    element: LeakTraceElement,
+    maybeLeakCause: Boolean,
+    resources: Resources
+  ): Spanned {
+    var htmlString = ""
+
+    var simpleName = element.getSimpleClassName()
+    simpleName = simpleName.replace("[]", "[ ]")
+
+    val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
+
+    val reference = element.reference
+    if (reference != null) {
+      var referenceName = reference.displayName.replace("<".toRegex(), "&lt;")
+          .replace(">".toRegex(), "&gt;")
+
+      if (maybeLeakCause) {
+        referenceName = "<u><font color='$leakColorHexString'>$referenceName</font></u>"
+      } else {
+        referenceName = "<font color='$referenceColorHexString'>$referenceName</font>"
+      }
+
+      if (reference.type == STATIC_FIELD) {
+        referenceName = "<i>$referenceName</i>"
+      }
+
+      var classAndReference = "$styledClassName.$referenceName"
+
+      if (maybeLeakCause) {
+        classAndReference = "<b>$classAndReference</b>"
+      }
+
+      htmlString += classAndReference
+    } else {
+      htmlString += styledClassName
+    }
+
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += " (excluded)"
+    }
+    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
+    if (maybeLeakCause) {
+      SquigglySpan.replaceUnderlineSpans(builder, resources)
+    }
+
+    return builder
+  }
+
+  private fun htmlDetails(
+    isLeakingInstance: Boolean,
+    element: LeakTraceElement
+  ): Spanned {
+    var htmlString = ""
+    if (element.extra != null) {
+      htmlString += " <font color='" + extraColorHexString + "'>" + element.extra + "</font>"
+    }
+
+    val exclusion = element.exclusion
+    if (exclusion != null) {
+      htmlString += "<br/><br/>Excluded by rule"
+      if (exclusion.name != null) {
+        htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>"
+      }
+      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>"
+      if (exclusion.reason != null) {
+        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
+      }
+    }
+    htmlString += ("<br>"
+        + "<font color='" + extraColorHexString + "'>"
+        + element.toDetailedString().replace("\n", "<br>")
+        + "</font>")
+
+    if (isLeakingInstance && referenceName != "") {
+      htmlString += " <font color='$extraColorHexString'>$referenceName</font>"
+    }
+
+    return Html.fromHtml(htmlString)
+  }
+
+  private fun getConnectorType(position: Int): DisplayLeakConnectorView.Type {
+    if (position == 1) {
+      return DisplayLeakConnectorView.Type.HELP
+    } else if (position == 2) {
+      if (leakTrace!!.expectedReachability.size == 1) {
+        return DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+      }
+      val nextReachability = leakTrace!!.expectedReachability[elementIndex(position + 1)]
+      return if (nextReachability.status != Reachability.Status.REACHABLE) {
+        DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+      } else DisplayLeakConnectorView.Type.START
+    } else {
+      val isLeakingInstance = position == count - 1
+      if (isLeakingInstance) {
+        val previousReachability = leakTrace!!.expectedReachability[elementIndex(position - 1)]
+        return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+          DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
+        } else DisplayLeakConnectorView.Type.END
+      } else {
+        val reachability = leakTrace!!.expectedReachability[elementIndex(position)]
+        when (reachability.status) {
+          Reachability.Status.UNKNOWN -> return DisplayLeakConnectorView.Type.NODE_UNKNOWN
+          Reachability.Status.REACHABLE -> {
+            val nextReachability = leakTrace!!.expectedReachability[elementIndex(position + 1)]
+            return if (nextReachability.status != Reachability.Status.REACHABLE) {
+              DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE
+            } else {
+              DisplayLeakConnectorView.Type.NODE_REACHABLE
+            }
+          }
+          Reachability.Status.UNREACHABLE -> {
+            val previousReachability = leakTrace!!.expectedReachability[elementIndex(position - 1)]
+            return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+              DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE
+            } else {
+              DisplayLeakConnectorView.Type.NODE_UNREACHABLE
+            }
+          }
+          else -> throw IllegalStateException("Unknown value: " + reachability.status)
+        }
+      }
+    }
+  }
+
+  fun update(
+    leakTrace: LeakTrace,
+    referenceKey: String,
+    referenceName: String
+  ) {
+    if (referenceKey == this.referenceKey) {
+      // Same data, nothing to change.
+      return
+    }
+    this.referenceKey = referenceKey
+    this.referenceName = referenceName
+    this.leakTrace = leakTrace
+    opened = BooleanArray(2 + leakTrace.elements.size)
+    notifyDataSetChanged()
+  }
+
+  fun toggleRow(position: Int) {
+    opened[position] = !opened[position]
+    notifyDataSetChanged()
+  }
+
+  override fun getCount(): Int {
+    return if (leakTrace == null) {
+      2
+    } else 2 + leakTrace!!.elements.size
+  }
+
+  override fun getItem(position: Int): LeakTraceElement? {
+    if (getItemViewType(position) == TOP_ROW) {
+      return null
+    }
+    return if (position == 1) {
+      null
+    } else leakTrace!!.elements[elementIndex(position)]
+  }
+
+  private fun elementIndex(position: Int): Int {
+    return position - 2
+  }
+
+  override fun getViewTypeCount(): Int {
+    return 2
+  }
+
+  override fun getItemViewType(position: Int): Int {
+    return if (position == 0) {
+      TOP_ROW
+    } else NORMAL_ROW
+  }
+
+  override fun getItemId(position: Int): Long {
+    return position.toLong()
+  }
+
+  companion object {
+
+    private const val TOP_ROW = 0
+    private const val NORMAL_ROW = 1
+
+    // https://stackoverflow.com/a/6540378/703646
+    private fun hexStringColor(resources: Resources, @ColorRes colorResId: Int): String {
+      return String.format("#%06X", 0xFFFFFF and resources.getColor(colorResId))
+    }
+
+    private fun <T : View> findById(
+      view: View,
+      id: Int
+    ): T {
+      @Suppress("UNCHECKED_CAST")
+      return view.findViewById<View>(id) as T
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index 3a500da34..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.DashPathEffect;
-import android.graphics.Paint;
-import android.graphics.PorterDuffXfermode;
-import android.util.AttributeSet;
-import android.view.View;
-import com.squareup.leakcanary.R;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-public final class DisplayLeakConnectorView extends View {
-
-  private static final float SQRT_TWO = (float) Math.sqrt(2);
-  private static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  public enum Type {
-    HELP,
-    START,
-    START_LAST_REACHABLE,
-    NODE_UNKNOWN,
-    NODE_FIRST_UNREACHABLE,
-    NODE_UNREACHABLE,
-    NODE_REACHABLE,
-    NODE_LAST_REACHABLE,
-    END,
-    END_FIRST_UNREACHABLE,
-  }
-
-  private final Paint classNamePaint;
-  private final Paint leakPaint;
-  private final Paint clearPaint;
-  private final Paint referencePaint;
-  private final float strokeSize;
-  private final float circleY;
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    Resources resources = getResources();
-
-    type = Type.NODE_UNKNOWN;
-    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y);
-    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size);
-
-    classNamePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    classNamePaint.setColor(resources.getColor(R.color.leak_canary_class_name));
-    classNamePaint.setStrokeWidth(strokeSize);
-
-    leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    leakPaint.setColor(resources.getColor(R.color.leak_canary_leak));
-    leakPaint.setStyle(Paint.Style.STROKE);
-    leakPaint.setStrokeWidth(strokeSize);
-    float pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line);
-    float pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap);
-    leakPaint.setPathEffect(new DashPathEffect(new float[] { pathLines, pathGaps }, 0));
-
-    clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(CLEAR_XFER_MODE);
-
-    referencePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    referencePaint.setColor(resources.getColor(R.color.leak_canary_reference));
-    referencePaint.setStrokeWidth(strokeSize);
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getMeasuredWidth();
-    int height = getMeasuredHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      switch (type) {
-        case NODE_UNKNOWN:
-          drawItems(cacheCanvas, leakPaint, leakPaint);
-          break;
-        case NODE_UNREACHABLE:
-        case NODE_REACHABLE:
-          drawItems(cacheCanvas, referencePaint, referencePaint);
-          break;
-        case NODE_FIRST_UNREACHABLE:
-          drawItems(cacheCanvas, leakPaint, referencePaint);
-          break;
-        case NODE_LAST_REACHABLE:
-          drawItems(cacheCanvas, referencePaint, leakPaint);
-          break;
-        case START: {
-          drawStartLine(cacheCanvas);
-          drawItems(cacheCanvas, null, referencePaint);
-          break;
-        }
-        case START_LAST_REACHABLE:
-          drawStartLine(cacheCanvas);
-          drawItems(cacheCanvas, null, leakPaint);
-          break;
-        case END:
-          drawItems(cacheCanvas, referencePaint, null);
-          break;
-        case END_FIRST_UNREACHABLE:
-          drawItems(cacheCanvas, leakPaint, null);
-          break;
-        case HELP:
-          drawRoot(cacheCanvas);
-          break;
-        default:
-          throw new UnsupportedOperationException("Unknown type " + type);
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  private void drawStartLine(Canvas cacheCanvas) {
-    int width = getMeasuredWidth();
-    float halfWidth = width / 2f;
-    cacheCanvas.drawLine(halfWidth, 0, halfWidth, circleY, classNamePaint);
-  }
-
-  private void drawRoot(Canvas cacheCanvas) {
-    int width = getMeasuredWidth();
-    int height = getMeasuredHeight();
-    float halfWidth = width / 2f;
-    float radiusClear = halfWidth - strokeSize / 2f;
-    cacheCanvas.drawRect(0, 0, width, radiusClear, classNamePaint);
-    cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-    cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-    cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, classNamePaint);
-  }
-
-  private void drawItems(Canvas cacheCanvas, Paint arrowHeadPaint, Paint nextArrowPaint) {
-    if (arrowHeadPaint != null) {
-      drawArrowHead(cacheCanvas, arrowHeadPaint);
-    }
-    if (nextArrowPaint != null) {
-      drawNextArrowLine(cacheCanvas, nextArrowPaint);
-    }
-    drawInstanceCircle(cacheCanvas);
-  }
-
-  private void drawArrowHead(Canvas cacheCanvas, Paint paint) {
-    // Circle center is at half height
-    int width = getMeasuredWidth();
-    float halfWidth = width / 2f;
-    float centerX = halfWidth;
-    float circleRadius = width / 3f;
-    float arrowSideLength = halfWidth;
-    // Splitting the arrow head in two makes an isosceles right triangle.
-    // It's hypotenuse is side * sqrt(2)
-    float arrowHeight = (arrowSideLength / 2) * SQRT_TWO;
-    float halfStrokeSize = strokeSize / 2;
-    float translateY = circleY - arrowHeight - (circleRadius * 2) - strokeSize;
-
-    float lineYEnd = circleY - circleRadius - (strokeSize / 2);
-    cacheCanvas.drawLine(centerX, 0, centerX, lineYEnd, paint);
-    cacheCanvas.translate(centerX, translateY);
-    cacheCanvas.rotate(45);
-    cacheCanvas.drawLine(0, arrowSideLength, arrowSideLength + halfStrokeSize, arrowSideLength,
-        paint);
-    cacheCanvas.drawLine(arrowSideLength, 0, arrowSideLength, arrowSideLength, paint);
-    cacheCanvas.rotate(-45);
-    cacheCanvas.translate(-centerX, -translateY);
-  }
-
-  private void drawNextArrowLine(Canvas cacheCanvas, Paint paint) {
-    int height = getMeasuredHeight();
-    int width = getMeasuredWidth();
-    float centerX = width / 2f;
-    cacheCanvas.drawLine(centerX, circleY, centerX, height, paint);
-  }
-
-  private void drawInstanceCircle(Canvas cacheCanvas) {
-    int width = getMeasuredWidth();
-    float circleX = width / 2f;
-    float circleRadius = width / 3f;
-    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.kt
new file mode 100644
index 000000000..20b79c3a9
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.content.Context
+import android.graphics.Bitmap
+import android.graphics.Bitmap.Config.ARGB_8888
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.DashPathEffect
+import android.graphics.Paint
+import android.graphics.PorterDuff.Mode.CLEAR
+import android.graphics.PorterDuffXfermode
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.R
+
+class DisplayLeakConnectorView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  private val classNamePaint: Paint
+  private val leakPaint: Paint
+  private val clearPaint: Paint
+  private val referencePaint: Paint
+  private val strokeSize: Float
+  private val circleY: Float
+
+  private var type: Type? = null
+  private var cache: Bitmap? = null
+
+  enum class Type {
+    HELP,
+    START,
+    START_LAST_REACHABLE,
+    NODE_UNKNOWN,
+    NODE_FIRST_UNREACHABLE,
+    NODE_UNREACHABLE,
+    NODE_REACHABLE,
+    NODE_LAST_REACHABLE,
+    END,
+    END_FIRST_UNREACHABLE
+  }
+
+  init {
+
+    val resources = resources
+
+    type = Type.NODE_UNKNOWN
+    circleY = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_center_y)
+        .toFloat()
+    strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_stroke_size)
+        .toFloat()
+
+    classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    classNamePaint.color = resources.getColor(R.color.leak_canary_class_name)
+    classNamePaint.strokeWidth = strokeSize
+
+    leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    leakPaint.color = resources.getColor(R.color.leak_canary_leak)
+    leakPaint.style = Paint.Style.STROKE
+    leakPaint.strokeWidth = strokeSize
+    val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
+        .toFloat()
+    val pathGaps = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_gap)
+        .toFloat()
+    leakPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathGaps), 0f)
+
+    clearPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    clearPaint.color = Color.TRANSPARENT
+    clearPaint.xfermode = CLEAR_XFER_MODE
+
+    referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    referencePaint.color = resources.getColor(R.color.leak_canary_reference)
+    referencePaint.strokeWidth = strokeSize
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = measuredWidth
+    val height = measuredHeight
+
+    if (cache != null && (cache!!.width != width || cache!!.height != height)) {
+      cache!!.recycle()
+      cache = null
+    }
+
+    if (cache == null) {
+      cache = Bitmap.createBitmap(width, height, ARGB_8888)
+
+      val cacheCanvas = Canvas(cache!!)
+
+      when (type) {
+        DisplayLeakConnectorView.Type.NODE_UNKNOWN -> drawItems(cacheCanvas, leakPaint, leakPaint)
+        DisplayLeakConnectorView.Type.NODE_UNREACHABLE, DisplayLeakConnectorView.Type.NODE_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, referencePaint
+        )
+        DisplayLeakConnectorView.Type.NODE_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, referencePaint
+        )
+        DisplayLeakConnectorView.Type.NODE_LAST_REACHABLE -> drawItems(
+            cacheCanvas, referencePaint, leakPaint
+        )
+        DisplayLeakConnectorView.Type.START -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, referencePaint)
+        }
+        DisplayLeakConnectorView.Type.START_LAST_REACHABLE -> {
+          drawStartLine(cacheCanvas)
+          drawItems(cacheCanvas, null, leakPaint)
+        }
+        DisplayLeakConnectorView.Type.END -> drawItems(cacheCanvas, referencePaint, null)
+        DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE -> drawItems(
+            cacheCanvas, leakPaint, null
+        )
+        DisplayLeakConnectorView.Type.HELP -> drawRoot(cacheCanvas)
+        else -> throw UnsupportedOperationException("Unknown type " + type!!)
+      }
+    }
+    canvas.drawBitmap(cache!!, 0f, 0f, null)
+  }
+
+  private fun drawStartLine(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, circleY, classNamePaint)
+  }
+
+  private fun drawRoot(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val height = measuredHeight
+    val halfWidth = width / 2f
+    val radiusClear = halfWidth - strokeSize / 2f
+    cacheCanvas.drawRect(0f, 0f, width.toFloat(), radiusClear, classNamePaint)
+    cacheCanvas.drawCircle(0f, radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawCircle(width.toFloat(), radiusClear, radiusClear, clearPaint)
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, height.toFloat(), classNamePaint)
+  }
+
+  private fun drawItems(
+    cacheCanvas: Canvas,
+    arrowHeadPaint: Paint?,
+    nextArrowPaint: Paint?
+  ) {
+    if (arrowHeadPaint != null) {
+      drawArrowHead(cacheCanvas, arrowHeadPaint)
+    }
+    if (nextArrowPaint != null) {
+      drawNextArrowLine(cacheCanvas, nextArrowPaint)
+    }
+    drawInstanceCircle(cacheCanvas)
+  }
+
+  private fun drawArrowHead(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    // Circle center is at half height
+    val width = measuredWidth
+    val halfWidth = width / 2f
+    val circleRadius = width / 3f
+// Splitting the arrow head in two makes an isosceles right triangle.
+    // It's hypotenuse is side * sqrt(2)
+    val arrowHeight = halfWidth / 2 * SQRT_TWO
+    val halfStrokeSize = strokeSize / 2
+    val translateY = circleY - arrowHeight - circleRadius * 2 - strokeSize
+
+    val lineYEnd = circleY - circleRadius - strokeSize / 2
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, lineYEnd, paint)
+    cacheCanvas.translate(halfWidth, translateY)
+    cacheCanvas.rotate(45f)
+    cacheCanvas.drawLine(
+        0f, halfWidth, halfWidth + halfStrokeSize, halfWidth,
+        paint
+    )
+    cacheCanvas.drawLine(halfWidth, 0f, halfWidth, halfWidth, paint)
+    cacheCanvas.rotate(-45f)
+    cacheCanvas.translate(-halfWidth, -translateY)
+  }
+
+  private fun drawNextArrowLine(
+    cacheCanvas: Canvas,
+    paint: Paint
+  ) {
+    val height = measuredHeight
+    val width = measuredWidth
+    val centerX = width / 2f
+    cacheCanvas.drawLine(centerX, circleY, centerX, height.toFloat(), paint)
+  }
+
+  private fun drawInstanceCircle(cacheCanvas: Canvas) {
+    val width = measuredWidth
+    val circleX = width / 2f
+    val circleRadius = width / 3f
+    cacheCanvas.drawCircle(circleX, circleY, circleRadius, classNamePaint)
+  }
+
+  fun setType(type: Type) {
+    if (type != this.type) {
+      this.type = type
+      if (cache != null) {
+        cache!!.recycle()
+        cache = null
+      }
+      invalidate()
+    }
+  }
+
+  companion object {
+
+    private val SQRT_TWO = Math.sqrt(2.0)
+        .toFloat()
+    private val CLEAR_XFER_MODE = PorterDuffXfermode(CLEAR)
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
deleted file mode 100644
index b95b26704..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.IntentService;
-import android.app.Notification;
-import android.content.Intent;
-import android.os.IBinder;
-import android.os.SystemClock;
-import androidx.annotation.Nullable;
-import com.squareup.leakcanary.R;
-
-public abstract class ForegroundService extends IntentService {
-
-  private final int notificationContentTitleResId;
-  private final int notificationId;
-
-  public ForegroundService(String name, int notificationContentTitleResId) {
-    super(name);
-    this.notificationContentTitleResId = notificationContentTitleResId;
-    notificationId = (int) SystemClock.uptimeMillis();
-  }
-
-  @Override
-  public void onCreate() {
-    super.onCreate();
-    showForegroundNotification(100, 0, true,
-        getString(R.string.leak_canary_notification_foreground_text));
-  }
-
-  protected void showForegroundNotification(int max, int progress, boolean indeterminate,
-      String contentText) {
-    Notification.Builder builder = new Notification.Builder(this)
-        .setContentTitle(getString(notificationContentTitleResId))
-        .setContentText(contentText)
-        .setProgress(max, progress, indeterminate);
-    Notification notification = LeakCanaryInternals.buildNotification(this, builder);
-    startForeground(notificationId, notification);
-  }
-
-  @Override protected void onHandleIntent(@Nullable Intent intent) {
-    onHandleIntentInForeground(intent);
-  }
-
-  protected abstract void onHandleIntentInForeground(@Nullable Intent intent);
-
-  @Override public void onDestroy() {
-    super.onDestroy();
-    stopForeground(true);
-  }
-
-  @Override public IBinder onBind(Intent intent) {
-    return null;
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.kt
new file mode 100644
index 000000000..f4ae05517
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/ForegroundService.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.app.IntentService
+import android.app.Notification
+import android.content.Intent
+import android.os.IBinder
+import android.os.SystemClock
+import com.squareup.leakcanary.R
+
+abstract class ForegroundService(
+  name: String,
+  private val notificationContentTitleResId: Int
+) : IntentService(name) {
+  private val notificationId: Int = SystemClock.uptimeMillis()
+      .toInt()
+
+  override fun onCreate() {
+    super.onCreate()
+    showForegroundNotification(
+        max = 100, progress = 0, indeterminate = true,
+        contentText = getString(R.string.leak_canary_notification_foreground_text)
+    )
+  }
+
+  protected fun showForegroundNotification(
+    max: Int,
+    progress: Int,
+    indeterminate: Boolean,
+    contentText: String
+  ) {
+    val builder = Notification.Builder(this)
+        .setContentTitle(getString(notificationContentTitleResId))
+        .setContentText(contentText)
+        .setProgress(max, progress, indeterminate)
+    val notification = LeakCanaryInternals.buildNotification(this, builder)
+    startForeground(notificationId, notification)
+  }
+
+  override fun onHandleIntent(intent: Intent?) {
+    onHandleIntentInForeground(intent)
+  }
+
+  protected abstract fun onHandleIntentInForeground(intent: Intent?)
+
+  override fun onDestroy() {
+    super.onDestroy()
+    stopForeground(true)
+  }
+
+  override fun onBind(intent: Intent): IBinder? {
+    return null
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
deleted file mode 100644
index 8cd6b27f3..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-public final class FutureResult<T> {
-
-  private final AtomicReference<T> resultHolder;
-  private final CountDownLatch latch;
-
-  public FutureResult() {
-    resultHolder = new AtomicReference<>();
-    latch = new CountDownLatch(1);
-  }
-
-  public boolean wait(long timeout, TimeUnit unit) {
-    try {
-      return latch.await(timeout, unit);
-    } catch (InterruptedException e) {
-      throw new RuntimeException("Did not expect thread to be interrupted", e);
-    }
-  }
-
-  public T get() {
-    if (latch.getCount() > 0) {
-      throw new IllegalStateException("Call wait() and check its result");
-    }
-    return resultHolder.get();
-  }
-
-  public void set(T result) {
-    resultHolder.set(result);
-    latch.countDown();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.kt
new file mode 100644
index 000000000..7472e275e
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.kt
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.atomic.AtomicReference
+
+class FutureResult<T> {
+
+  private val resultHolder: AtomicReference<T> = AtomicReference()
+  private val latch: CountDownLatch = CountDownLatch(1)
+
+  fun wait(
+    timeout: Long,
+    unit: TimeUnit
+  ): Boolean {
+    try {
+      return latch.await(timeout, unit)
+    } catch (e: InterruptedException) {
+      throw RuntimeException("Did not expect thread to be interrupted", e)
+    }
+
+  }
+
+  fun get(): T {
+    if (latch.count > 0) {
+      throw IllegalStateException("Call wait() and check its result")
+    }
+    return resultHolder.get()
+  }
+
+  fun set(result: T) {
+    resultHolder.set(result)
+    latch.countDown()
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
deleted file mode 100644
index bce9e9467..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.Intent;
-import androidx.annotation.Nullable;
-import androidx.core.content.ContextCompat;
-import com.squareup.leakcanary.AbstractAnalysisResultService;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.AnalyzerProgressListener;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.HeapAnalyzer;
-import com.squareup.leakcanary.HeapDump;
-import com.squareup.leakcanary.R;
-import java.io.File;
-import java.io.IOException;
-import java.util.List;
-
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-/**
- * This service runs in a separate process to avoid slowing down the app process or making it run
- * out of memory.
- */
-public final class HeapAnalyzerService extends ForegroundService
-    implements AnalyzerProgressListener {
-
-  private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
-  private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-
-  public static void runAnalysis(Context context, HeapDump heapDump,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabledBlocking(context, HeapAnalyzerService.class, true);
-    setEnabledBlocking(context, listenerServiceClass, true);
-    Intent intent = new Intent(context, HeapAnalyzerService.class);
-    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
-    intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    ContextCompat.startForegroundService(context, intent);
-  }
-
-  public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName(), R.string.leak_canary_notification_analysing);
-  }
-
-  @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
-      return;
-    }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
-
-    HeapAnalyzer heapAnalyzer =
-        new HeapAnalyzer(heapDump.getExcludedRefs(), this,
-            heapDump.getReachabilityInspectorClasses());
-
-    List<AnalysisResult> analysisResults =
-        heapAnalyzer.checkForLeaks(heapDump.getHeapDumpFile(),
-            heapDump.getComputeRetainedHeapSize());
-
-    int i = 0;
-    for (AnalysisResult result : analysisResults) {
-      HeapDump fakeFileHeapDump;
-      if (i > 0) {
-        // TODO 1 analysis = many leaks, which is currently unsupported by the rest of the pipeline.
-        // We temporarily ignore this problem by replacing the heapdump file with a fake file for
-        // all heap dumps but the first one.
-        File newFile = new File(heapDump.getHeapDumpFile().getParentFile(),
-            i + heapDump.getHeapDumpFile().getName());
-        try {
-          boolean created = newFile.createNewFile();
-          if (!created) {
-            continue;
-          }
-        } catch (IOException e) {
-          continue;
-        }
-        fakeFileHeapDump = heapDump.buildUpon()
-            .heapDumpFile(
-                newFile)
-            .build();
-      } else {
-        fakeFileHeapDump = heapDump;
-      }
-      AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, fakeFileHeapDump,
-          result);
-      i++;
-    }
-  }
-
-  @Override public void onProgressUpdate(Step step) {
-    int percent = (int) ((100f * step.ordinal()) / Step.values().length);
-    CanaryLog.d("Analysis in progress, working on: %s", step.name());
-    String lowercase = step.name().replace("_", " ").toLowerCase();
-    String message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1);
-    showForegroundNotification(100, percent, false, message);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.kt
new file mode 100644
index 000000000..33099f9ee
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.content.Context
+import android.content.Intent
+import androidx.core.content.ContextCompat
+import com.squareup.leakcanary.AbstractAnalysisResultService
+import com.squareup.leakcanary.AnalyzerProgressListener
+import com.squareup.leakcanary.CanaryLog
+import com.squareup.leakcanary.HeapAnalyzer
+import com.squareup.leakcanary.HeapDump
+import com.squareup.leakcanary.R
+import com.squareup.leakcanary.internal.LeakCanaryInternals.Companion.setEnabledBlocking
+import java.io.File
+import java.io.IOException
+
+/**
+ * This service runs in a separate process to avoid slowing down the app process or making it run
+ * out of memory.
+ */
+class HeapAnalyzerService : ForegroundService(
+    HeapAnalyzerService::class.java.simpleName, R.string.leak_canary_notification_analysing
+), AnalyzerProgressListener {
+
+  override fun onHandleIntentInForeground(intent: Intent?) {
+    if (intent == null) {
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.")
+      return
+    }
+    val listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA)
+    val heapDump = intent.getSerializableExtra(HEAPDUMP_EXTRA) as HeapDump
+
+    val heapAnalyzer = HeapAnalyzer(
+        heapDump.excludedRefs, this,
+        heapDump.reachabilityInspectorClasses
+    )
+
+    val analysisResults = heapAnalyzer.checkForLeaks(
+        heapDump.heapDumpFile,
+        heapDump.computeRetainedHeapSize
+    )
+
+    var i = 0
+    for (result in analysisResults) {
+      val fakeFileHeapDump: HeapDump
+      if (i > 0) {
+        // TODO 1 analysis = many leaks, which is currently unsupported by the rest of the pipeline.
+        // We temporarily ignore this problem by replacing the heapdump file with a fake file for
+        // all heap dumps but the first one.
+        val newFile = File(
+            heapDump.heapDumpFile.parentFile,
+            i.toString() + heapDump.heapDumpFile.name
+        )
+        try {
+          val created = newFile.createNewFile()
+          if (!created) {
+            continue
+          }
+        } catch (e: IOException) {
+          continue
+        }
+
+        fakeFileHeapDump = heapDump.buildUpon()
+            .heapDumpFile(
+                newFile
+            )
+            .build()
+      } else {
+        fakeFileHeapDump = heapDump
+      }
+      AbstractAnalysisResultService.sendResultToListener(
+          this, listenerClassName, fakeFileHeapDump,
+          result
+      )
+      i++
+    }
+  }
+
+  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
+    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
+    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+    val lowercase = step.name.replace("_", " ")
+        .toLowerCase()
+    val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
+    showForegroundNotification(100, percent, false, message)
+  }
+
+  companion object {
+
+    private const val LISTENER_CLASS_EXTRA = "listener_class_extra"
+    private const val HEAPDUMP_EXTRA = "heapdump_extra"
+
+    fun runAnalysis(
+      context: Context,
+      heapDump: HeapDump,
+      listenerServiceClass: Class<out AbstractAnalysisResultService>
+    ) {
+      setEnabledBlocking(context, HeapAnalyzerService::class.java, true)
+      setEnabledBlocking(context, listenerServiceClass, true)
+      val intent = Intent(context, HeapAnalyzerService::class.java)
+      intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.name)
+      intent.putExtra(HEAPDUMP_EXTRA, heapDump)
+      ContextCompat.startForegroundService(context, intent)
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java
deleted file mode 100644
index 0b4c95836..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.squareup.leakcanary.internal;
-
-import androidx.core.content.FileProvider;
-
-/**
- * There can only be one {@link FileProvider} provider registered per app, so we extend that class
- * just to use a distinct name.
- */
-public class LeakCanaryFileProvider extends FileProvider {
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.kt
new file mode 100644
index 000000000..b477102ba
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -0,0 +1,9 @@
+package com.squareup.leakcanary.internal
+
+import androidx.core.content.FileProvider
+
+/**
+ * There can only be one [FileProvider] provider registered per app, so we extend that class
+ * just to use a distinct name.
+ */
+class LeakCanaryFileProvider : FileProvider()
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
deleted file mode 100644
index e26e8465a..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import android.os.AsyncTask;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
-import com.squareup.leakcanary.LeakDirectoryProvider;
-import com.squareup.leakcanary.R;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.O;
-
-public final class LeakCanaryInternals {
-
-  public static final String SAMSUNG = "samsung";
-  public static final String MOTOROLA = "motorola";
-  public static final String LENOVO = "LENOVO";
-  public static final String LG = "LGE";
-  public static final String NVIDIA = "NVIDIA";
-  public static final String MEIZU = "Meizu";
-  public static final String HUAWEI = "HUAWEI";
-  public static final String VIVO = "vivo";
-
-  private static volatile LeakDirectoryProvider leakDirectoryProvider;
-
-  private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
-
-  public static volatile Boolean isInAnalyzerProcess;
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  public static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-  public static void setEnabledAsync(Context context, final Class<?> componentClass,
-      final boolean enabled) {
-    final Context appContext = context.getApplicationContext();
-    AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {
-      @Override public void run() {
-        setEnabledBlocking(appContext, componentClass, enabled);
-      }
-    });
-  }
-
-  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
-      boolean enabled) {
-    ComponentName component = new ComponentName(appContext, componentClass);
-    PackageManager packageManager = appContext.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, PackageManager.GET_DISABLED_COMPONENTS);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName == null) {
-      CanaryLog.d("Did not expect service %s to have a null process name", serviceClass);
-      return false;
-    } else if (serviceInfo.processName.equals(mainProcess)) {
-      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses;
-    try {
-      runningProcesses = activityManager.getRunningAppProcesses();
-    } catch (SecurityException exception) {
-      // https://github.com/square/leakcanary/issues/948
-      CanaryLog.d("Could not get running app processes %d", exception);
-      return false;
-    }
-    if (runningProcesses != null) {
-      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
-        if (process.pid == myPid) {
-          myProcess = process;
-          break;
-        }
-      }
-    }
-    if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
-    Notification.Builder builder = new Notification.Builder(context)
-        .setContentText(contentText)
-        .setContentTitle(contentTitle)
-        .setAutoCancel(true)
-        .setContentIntent(pendingIntent);
-
-    Notification notification = buildNotification(context, builder);
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-    notificationManager.notify(notificationId, notification);
-  }
-
-  public static Notification buildNotification(Context context,
-      Notification.Builder builder) {
-    builder.setSmallIcon(R.drawable.leak_canary_notification)
-        .setWhen(System.currentTimeMillis())
-        .setOnlyAlertOnce(true);
-
-    if (SDK_INT >= O) {
-      NotificationManager notificationManager =
-          (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-      NotificationChannel notificationChannel =
-          notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);
-      if (notificationChannel == null) {
-        String channelName = context.getString(R.string.leak_canary_notification_channel);
-        notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
-            NotificationManager.IMPORTANCE_DEFAULT);
-        notificationManager.createNotificationChannel(notificationChannel);
-      }
-      builder.setChannelId(NOTIFICATION_CHANNEL_ID);
-    }
-
-    if (SDK_INT < JELLY_BEAN) {
-      return builder.getNotification();
-    } else {
-      return builder.build();
-    }
-  }
-
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
-  }
-
-  public static LeakDirectoryProvider getLeakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = LeakCanaryInternals.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    }
-    return leakDirectoryProvider;
-  }
-
-  private LeakCanaryInternals() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.kt
new file mode 100644
index 000000000..21fe038b6
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.kt
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.app.ActivityManager
+import android.app.Notification
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.app.PendingIntent
+import android.app.Service
+import android.content.ComponentName
+import android.content.Context
+import android.content.pm.PackageInfo
+import android.content.pm.PackageManager
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED
+import android.content.pm.PackageManager.DONT_KILL_APP
+import android.content.pm.PackageManager.GET_SERVICES
+import android.content.pm.ServiceInfo
+import android.os.AsyncTask
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.O
+import com.squareup.leakcanary.CanaryLog
+import com.squareup.leakcanary.DefaultLeakDirectoryProvider
+import com.squareup.leakcanary.LeakDirectoryProvider
+import com.squareup.leakcanary.R
+import java.util.concurrent.Executor
+import java.util.concurrent.Executors
+
+class LeakCanaryInternals private constructor() {
+
+  init {
+    throw AssertionError()
+  }
+
+  companion object {
+
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+
+    @Volatile private var leakDirectoryProvider: LeakDirectoryProvider? = null
+
+    fun getLeakDirectoryProvider(context: Context): LeakDirectoryProvider {
+      var leakDirectoryProvider = LeakCanaryInternals.leakDirectoryProvider
+      if (leakDirectoryProvider == null) {
+        leakDirectoryProvider = DefaultLeakDirectoryProvider(context)
+      }
+      return leakDirectoryProvider
+    }
+
+    private const val NOTIFICATION_CHANNEL_ID = "leakcanary"
+
+    @Volatile var isInAnalyzerProcess: Boolean? = null
+
+    /** Extracts the class simple name out of a string containing a fully qualified class name.  */
+    fun classSimpleName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+
+    fun setEnabledAsync(
+      context: Context,
+      componentClass: Class<*>,
+      enabled: Boolean
+    ) {
+      val appContext = context.applicationContext
+      AsyncTask.THREAD_POOL_EXECUTOR.execute {
+        setEnabledBlocking(
+            appContext, componentClass, enabled
+        )
+      }
+    }
+
+    fun setEnabledBlocking(
+      appContext: Context,
+      componentClass: Class<*>,
+      enabled: Boolean
+    ) {
+      val component = ComponentName(appContext, componentClass)
+      val packageManager = appContext.packageManager
+      val newState =
+        if (enabled) COMPONENT_ENABLED_STATE_ENABLED else COMPONENT_ENABLED_STATE_DISABLED
+      // Blocks on IPC.
+      packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP)
+    }
+
+    fun isInServiceProcess(
+      context: Context,
+      serviceClass: Class<out Service>
+    ): Boolean {
+      val packageManager = context.packageManager
+      val packageInfo: PackageInfo
+      try {
+        packageInfo = packageManager.getPackageInfo(context.packageName, GET_SERVICES)
+      } catch (e: Exception) {
+        CanaryLog.d(e, "Could not get package info for %s", context.packageName)
+        return false
+      }
+
+      val mainProcess = packageInfo.applicationInfo.processName
+
+      val component = ComponentName(context, serviceClass)
+      val serviceInfo: ServiceInfo
+      try {
+        serviceInfo =
+          packageManager.getServiceInfo(component, PackageManager.GET_DISABLED_COMPONENTS)
+      } catch (ignored: PackageManager.NameNotFoundException) {
+        // Service is disabled.
+        return false
+      }
+
+      if (serviceInfo.processName == null) {
+        CanaryLog.d("Did not expect service %s to have a null process name", serviceClass)
+        return false
+      } else if (serviceInfo.processName == mainProcess) {
+        CanaryLog.d(
+            "Did not expect service %s to run in main process %s", serviceClass, mainProcess
+        )
+        // Technically we are in the service process, but we're not in the service dedicated process.
+        return false
+      }
+
+      val myPid = android.os.Process.myPid()
+      val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
+      var myProcess: ActivityManager.RunningAppProcessInfo? = null
+      val runningProcesses: List<ActivityManager.RunningAppProcessInfo>?
+      try {
+        runningProcesses = activityManager.runningAppProcesses
+      } catch (exception: SecurityException) {
+        // https://github.com/square/leakcanary/issues/948
+        CanaryLog.d("Could not get running app processes %d", exception)
+        return false
+      }
+
+      if (runningProcesses != null) {
+        for (process in runningProcesses) {
+          if (process.pid == myPid) {
+            myProcess = process
+            break
+          }
+        }
+      }
+      if (myProcess == null) {
+        CanaryLog.d("Could not find running process for %d", myPid)
+        return false
+      }
+
+      return myProcess.processName == serviceInfo.processName
+    }
+
+    fun showNotification(
+      context: Context,
+      contentTitle: CharSequence,
+      contentText: CharSequence,
+      pendingIntent: PendingIntent,
+      notificationId: Int
+    ) {
+      val builder = Notification.Builder(context)
+          .setContentText(contentText)
+          .setContentTitle(contentTitle)
+          .setAutoCancel(true)
+          .setContentIntent(pendingIntent)
+
+      val notification = buildNotification(context, builder)
+      val notificationManager =
+        context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+      notificationManager.notify(notificationId, notification)
+    }
+
+    fun buildNotification(
+      context: Context,
+      builder: Notification.Builder
+    ): Notification {
+      builder.setSmallIcon(R.drawable.leak_canary_notification)
+          .setWhen(System.currentTimeMillis())
+          .setOnlyAlertOnce(true)
+
+      if (SDK_INT >= O) {
+        val notificationManager =
+          context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+        var notificationChannel: NotificationChannel? =
+          notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID)
+        if (notificationChannel == null) {
+          val channelName = context.getString(R.string.leak_canary_notification_channel)
+          notificationChannel = NotificationChannel(
+              NOTIFICATION_CHANNEL_ID, channelName,
+              NotificationManager.IMPORTANCE_DEFAULT
+          )
+          notificationManager.createNotificationChannel(notificationChannel)
+        }
+        builder.setChannelId(NOTIFICATION_CHANNEL_ID)
+      }
+
+      return if (SDK_INT < JELLY_BEAN) {
+        builder.notification
+      } else {
+        builder.build()
+      }
+    }
+
+    fun newSingleThreadExecutor(threadName: String): Executor {
+      return Executors.newSingleThreadExecutor(LeakCanarySingleThreadFactory(threadName))
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.kt
similarity index 63%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
rename to leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.kt
index 4eb3a3a0e..8b2e2a9dd 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.kt
@@ -13,22 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.leakcanary.internal;
+package com.squareup.leakcanary.internal
 
-import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadFactory
 
 /**
  * This is intended to only be used with a single thread executor.
  */
-final class LeakCanarySingleThreadFactory implements ThreadFactory {
+internal class LeakCanarySingleThreadFactory(threadName: String) : ThreadFactory {
 
-  private final String threadName;
+  private val threadName: String = "LeakCanary-$threadName"
 
-  LeakCanarySingleThreadFactory(String threadName) {
-    this.threadName = "LeakCanary-" + threadName;
-  }
-
-  @Override public Thread newThread(Runnable runnable) {
-    return new Thread(runnable, threadName);
+  override fun newThread(runnable: Runnable): Thread {
+    return Thread(runnable, threadName)
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
deleted file mode 100644
index c88e5dcf6..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-import com.squareup.leakcanary.R;
-
-public final class MoreDetailsView extends View {
-
-  private final Paint iconPaint;
-
-  public MoreDetailsView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    Resources resources = getResources();
-    iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    float strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width);
-    iconPaint.setStrokeWidth(strokeSize);
-
-    // This lint check doesn't work for libraries which have a common prefix.
-    @SuppressLint("CustomViewStyleable") //
-        TypedArray a =
-        context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView);
-    int plusColor =
-        a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK);
-    a.recycle();
-
-    iconPaint.setColor(plusColor);
-  }
-
-  private boolean opened;
-
-  @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-    int halfHeight = height / 2;
-    int halfWidth = width / 2;
-
-    if (opened) {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-    } else {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-      canvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-    }
-  }
-
-  public void setOpened(boolean opened) {
-    if (opened != this.opened) {
-      this.opened = opened;
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.kt
new file mode 100644
index 000000000..92cddaa3f
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.kt
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.graphics.Canvas
+import android.graphics.Color
+import android.graphics.Paint
+import android.util.AttributeSet
+import android.view.View
+import com.squareup.leakcanary.R
+
+class MoreDetailsView(
+  context: Context,
+  attrs: AttributeSet
+) : View(context, attrs) {
+
+  private val iconPaint: Paint
+
+  private var opened: Boolean = false
+
+  init {
+    val resources = resources
+    iconPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+    val strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width)
+        .toFloat()
+    iconPaint.strokeWidth = strokeSize
+
+    // This lint check doesn't work for libraries which have a common prefix.
+    @SuppressLint("CustomViewStyleable") //
+    val a = context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView)
+    val plusColor =
+      a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK)
+    a.recycle()
+
+    iconPaint.color = plusColor
+  }
+
+  override fun onDraw(canvas: Canvas) {
+    val width = width
+    val height = height
+    val halfHeight = height / 2
+    val halfWidth = width / 2
+
+    if (opened) {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+    } else {
+      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
+      canvas.drawLine(halfWidth.toFloat(), 0f, halfWidth.toFloat(), height.toFloat(), iconPaint)
+    }
+  }
+
+  fun setOpened(opened: Boolean) {
+    if (opened != this.opened) {
+      this.opened = opened
+      invalidate()
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
deleted file mode 100644
index 1146ac217..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.widget.Toast;
-import com.squareup.leakcanary.R;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION_CODES.M;
-import static android.widget.Toast.LENGTH_LONG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-@TargetApi(M) //
-public class RequestStoragePermissionActivity extends Activity {
-
-  public static PendingIntent createPendingIntent(Context context) {
-    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
-    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
-    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState == null) {
-      if (hasStoragePermission()) {
-        finish();
-        return;
-      }
-      String[] permissions = {
-          WRITE_EXTERNAL_STORAGE
-      };
-      requestPermissions(permissions, 42);
-    }
-  }
-
-  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-      int[] grantResults) {
-    if (!hasStoragePermission()) {
-      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
-          .show();
-    }
-    finish();
-  }
-
-  @Override public void finish() {
-    // Reset the animation to avoid flickering.
-    overridePendingTransition(0, 0);
-    super.finish();
-  }
-
-  private boolean hasStoragePermission() {
-    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.kt
new file mode 100644
index 000000000..544ac3742
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.PendingIntent
+import android.content.Context
+import android.content.Intent
+import android.os.Bundle
+import android.widget.Toast
+import com.squareup.leakcanary.R
+
+import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
+import android.app.PendingIntent.FLAG_UPDATE_CURRENT
+import android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP
+import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
+import android.content.pm.PackageManager.PERMISSION_GRANTED
+import android.os.Build.VERSION_CODES.M
+import android.widget.Toast.LENGTH_LONG
+
+@TargetApi(M) //
+class RequestStoragePermissionActivity : Activity() {
+
+  override fun onCreate(savedInstanceState: Bundle?) {
+    super.onCreate(savedInstanceState)
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish()
+        return
+      }
+      val permissions = arrayOf(WRITE_EXTERNAL_STORAGE)
+      requestPermissions(permissions, 42)
+    }
+  }
+
+  override fun onRequestPermissionsResult(
+    requestCode: Int,
+    permissions: Array<String>,
+    grantResults: IntArray
+  ) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(application, R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show()
+    }
+    finish()
+  }
+
+  override fun finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0)
+    super.finish()
+  }
+
+  private fun hasStoragePermission(): Boolean {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED
+  }
+
+  companion object {
+
+    fun createPendingIntent(context: Context): PendingIntent {
+      LeakCanaryInternals.setEnabledBlocking(
+          context, RequestStoragePermissionActivity::class.java, true
+      )
+      val intent = Intent(context, RequestStoragePermissionActivity::class.java)
+      intent.flags = FLAG_ACTIVITY_NEW_TASK or FLAG_ACTIVITY_CLEAR_TOP
+      return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT)
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
deleted file mode 100644
index f552716d3..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.util.AttributeSet;
-import android.view.View;
-import android.view.ViewGroup;
-import com.squareup.leakcanary.R;
-
-public class RowElementLayout extends ViewGroup {
-
-  private final int connectorWidth;
-  private final int rowMargins;
-  private final int moreSize;
-  private final int minHeight;
-  private final int titleMarginTop;
-  private final int moreMarginTop;
-
-  private View connector;
-  private View moreButton;
-  private View title;
-  private View details;
-
-  public RowElementLayout(Context context, AttributeSet attrs) {
-    super(context, attrs);
-    Resources resources = getResources();
-    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width);
-    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins);
-    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size);
-    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min);
-    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top);
-    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top);
-  }
-
-  @Override protected void onFinishInflate() {
-    super.onFinishInflate();
-    connector = findViewById(R.id.leak_canary_row_connector);
-    moreButton = findViewById(R.id.leak_canary_row_more);
-    title = findViewById(R.id.leak_canary_row_title);
-    details = findViewById(R.id.leak_canary_row_details);
-  }
-
-  @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-    int availableWidth = MeasureSpec.getSize(widthMeasureSpec);
-    int titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins;
-    int titleWidthSpec = MeasureSpec.makeMeasureSpec(titleWidth, MeasureSpec.AT_MOST);
-    int titleHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
-    title.measure(titleWidthSpec, titleHeightSpec);
-
-    int moreSizeSpec = MeasureSpec.makeMeasureSpec(moreSize, MeasureSpec.EXACTLY);
-    moreButton.measure(moreSizeSpec, moreSizeSpec);
-
-    int totalHeight = titleMarginTop + title.getMeasuredHeight();
-
-    int detailsWidth = availableWidth - connectorWidth - 3 * rowMargins;
-    int detailsWidthSpec = MeasureSpec.makeMeasureSpec(detailsWidth, MeasureSpec.AT_MOST);
-    int detailsHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
-    details.measure(detailsWidthSpec, detailsHeightSpec);
-    if (details.getVisibility() != GONE) {
-      totalHeight += details.getMeasuredHeight();
-    }
-    totalHeight = Math.max(totalHeight, minHeight);
-
-    int connectorWidthSpec = MeasureSpec.makeMeasureSpec(connectorWidth, MeasureSpec.EXACTLY);
-    int connectorHeightSpec = MeasureSpec.makeMeasureSpec(totalHeight, MeasureSpec.EXACTLY);
-
-    connector.measure(connectorWidthSpec, connectorHeightSpec);
-    setMeasuredDimension(availableWidth, totalHeight);
-  }
-
-  @Override protected void onLayout(boolean changed, int l, int t, int r, int b) {
-    int width = getMeasuredWidth();
-    int connectorRight = rowMargins + connector.getMeasuredWidth();
-    connector.layout(rowMargins, 0, connectorRight, connector.getMeasuredHeight());
-
-    moreButton.layout(width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
-        moreMarginTop + moreSize);
-
-    int titleLeft = connectorRight + rowMargins;
-    int titleBottom = titleMarginTop + title.getMeasuredHeight();
-    title.layout(titleLeft, titleMarginTop, titleLeft + title.getMeasuredWidth(), titleBottom);
-
-    if (details.getVisibility() != GONE) {
-      details.layout(titleLeft, titleBottom, width - rowMargins,
-          titleBottom + details.getMeasuredHeight());
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.kt
new file mode 100644
index 000000000..25121f566
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RowElementLayout.kt
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.content.Context
+import android.util.AttributeSet
+import android.view.View
+import android.view.ViewGroup
+import com.squareup.leakcanary.R
+
+class RowElementLayout(
+  context: Context,
+  attrs: AttributeSet
+) : ViewGroup(context, attrs) {
+
+  private val connectorWidth: Int
+  private val rowMargins: Int
+  private val moreSize: Int
+  private val minHeight: Int
+  private val titleMarginTop: Int
+  private val moreMarginTop: Int
+
+  private var connector: View? = null
+  private var moreButton: View? = null
+  private var title: View? = null
+  private var details: View? = null
+
+  init {
+    val resources = resources
+    connectorWidth = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_width)
+    rowMargins = resources.getDimensionPixelSize(R.dimen.leak_canary_row_margins)
+    moreSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_size)
+    minHeight = resources.getDimensionPixelSize(R.dimen.leak_canary_row_min)
+    titleMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_row_title_margin_top)
+    moreMarginTop = resources.getDimensionPixelSize(R.dimen.leak_canary_more_margin_top)
+  }
+
+  override fun onFinishInflate() {
+    super.onFinishInflate()
+    connector = findViewById(R.id.leak_canary_row_connector)
+    moreButton = findViewById(R.id.leak_canary_row_more)
+    title = findViewById(R.id.leak_canary_row_title)
+    details = findViewById(R.id.leak_canary_row_details)
+  }
+
+  override fun onMeasure(
+    widthMeasureSpec: Int,
+    heightMeasureSpec: Int
+  ) {
+    val availableWidth = View.MeasureSpec.getSize(widthMeasureSpec)
+    val titleWidth = availableWidth - connectorWidth - moreSize - 4 * rowMargins
+    val titleWidthSpec = View.MeasureSpec.makeMeasureSpec(titleWidth, View.MeasureSpec.AT_MOST)
+    val titleHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    title!!.measure(titleWidthSpec, titleHeightSpec)
+
+    val moreSizeSpec = View.MeasureSpec.makeMeasureSpec(moreSize, View.MeasureSpec.EXACTLY)
+    moreButton!!.measure(moreSizeSpec, moreSizeSpec)
+
+    var totalHeight = titleMarginTop + title!!.measuredHeight
+
+    val detailsWidth = availableWidth - connectorWidth - 3 * rowMargins
+    val detailsWidthSpec = View.MeasureSpec.makeMeasureSpec(detailsWidth, View.MeasureSpec.AT_MOST)
+    val detailsHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
+    details!!.measure(detailsWidthSpec, detailsHeightSpec)
+    if (details!!.visibility != View.GONE) {
+      totalHeight += details!!.measuredHeight
+    }
+    totalHeight = Math.max(totalHeight, minHeight)
+
+    val connectorWidthSpec =
+      View.MeasureSpec.makeMeasureSpec(connectorWidth, View.MeasureSpec.EXACTLY)
+    val connectorHeightSpec =
+      View.MeasureSpec.makeMeasureSpec(totalHeight, View.MeasureSpec.EXACTLY)
+
+    connector!!.measure(connectorWidthSpec, connectorHeightSpec)
+    setMeasuredDimension(availableWidth, totalHeight)
+  }
+
+  override fun onLayout(
+    changed: Boolean,
+    l: Int,
+    t: Int,
+    r: Int,
+    b: Int
+  ) {
+    val width = measuredWidth
+    val connectorRight = rowMargins + connector!!.measuredWidth
+    connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
+
+    moreButton!!.layout(
+        width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
+        moreMarginTop + moreSize
+    )
+
+    val titleLeft = connectorRight + rowMargins
+    val titleBottom = titleMarginTop + title!!.measuredHeight
+    title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
+
+    if (details!!.visibility != View.GONE) {
+      details!!.layout(
+          titleLeft, titleBottom, width - rowMargins,
+          titleBottom + details!!.measuredHeight
+      )
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
deleted file mode 100644
index 5a02c700b..000000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Path;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import android.text.SpannableStringBuilder;
-import android.text.style.ReplacementSpan;
-import android.text.style.UnderlineSpan;
-import com.squareup.leakcanary.R;
-
-/**
- * Inspired from https://github.com/flavienlaurent/spans and
- * https://github.com/andyxialm/WavyLineView
- */
-class SquigglySpan extends ReplacementSpan {
-
-
-  public static void replaceUnderlineSpans(SpannableStringBuilder builder, Resources resources) {
-    UnderlineSpan[] underlineSpans = builder.getSpans(0, builder.length(), UnderlineSpan.class);
-    for (UnderlineSpan span : underlineSpans) {
-      int start = builder.getSpanStart(span);
-      int end = builder.getSpanEnd(span);
-      builder.removeSpan(span);
-      builder.setSpan(new SquigglySpan(resources), start, end, 0);
-    }
-  }
-
-  private final Paint squigglyPaint;
-  private final Path path;
-  private final int referenceColor;
-  private final float halfStrokeWidth;
-  private final float amplitude;
-  private final float halfWaveHeight;
-  private final float periodDegrees;
-
-  private int width;
-
-  SquigglySpan(Resources resources) {
-    squigglyPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    squigglyPaint.setStyle(Paint.Style.STROKE);
-    squigglyPaint.setColor(resources.getColor(R.color.leak_canary_leak));
-    float strokeWidth =
-        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width);
-    squigglyPaint.setStrokeWidth(strokeWidth);
-
-    halfStrokeWidth = strokeWidth / 2;
-    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude);
-    periodDegrees =
-        resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees);
-    path = new Path();
-    float waveHeight = 2 * amplitude + strokeWidth;
-    halfWaveHeight = waveHeight / 2;
-    referenceColor = resources.getColor(R.color.leak_canary_reference);
-  }
-
-  @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end,
-      @Nullable Paint.FontMetricsInt fm) {
-    width = (int) paint.measureText(text, start, end);
-    return width;
-  }
-
-  @Override
-  public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top,
-      int y, int bottom, @NonNull Paint paint) {
-    squigglyHorizontalPath(path,
-        x + halfStrokeWidth,
-        x + width - halfStrokeWidth,
-        bottom - halfWaveHeight,
-        amplitude, periodDegrees);
-    canvas.drawPath(path, squigglyPaint);
-
-    paint.setColor(referenceColor);
-    canvas.drawText(text, start, end, x, y, paint);
-  }
-
-  private static void squigglyHorizontalPath(Path path, float left, float right, float centerY,
-      float amplitude,
-      float periodDegrees) {
-    path.reset();
-
-    float y;
-    path.moveTo(left, centerY);
-    float period = (float) (2 * Math.PI / periodDegrees);
-
-    for (float x = 0; x <= right - left; x += 1) {
-      y = (float) (amplitude * Math.sin(40 + period * x) + centerY);
-      path.lineTo(left + x, y);
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.kt b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.kt
new file mode 100644
index 000000000..3bcd20118
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/SquigglySpan.kt
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal
+
+import android.content.res.Resources
+import android.graphics.Canvas
+import android.graphics.Paint
+import android.graphics.Path
+import android.text.SpannableStringBuilder
+import android.text.style.ReplacementSpan
+import android.text.style.UnderlineSpan
+import com.squareup.leakcanary.R
+
+/**
+ * Inspired from https://github.com/flavienlaurent/spans and
+ * https://github.com/andyxialm/WavyLineView
+ */
+internal class SquigglySpan(resources: Resources) : ReplacementSpan() {
+
+  private val squigglyPaint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)
+  private val path: Path
+  private val referenceColor: Int
+  private val halfStrokeWidth: Float
+  private val amplitude: Float
+  private val halfWaveHeight: Float
+  private val periodDegrees: Float
+
+  private var width: Int = 0
+
+  init {
+    squigglyPaint.style = Paint.Style.STROKE
+    squigglyPaint.color = resources.getColor(R.color.leak_canary_leak)
+    val strokeWidth =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
+          .toFloat()
+    squigglyPaint.strokeWidth = strokeWidth
+
+    halfStrokeWidth = strokeWidth / 2
+    amplitude = resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_amplitude)
+        .toFloat()
+    periodDegrees =
+      resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_period_degrees)
+          .toFloat()
+    path = Path()
+    val waveHeight = 2 * amplitude + strokeWidth
+    halfWaveHeight = waveHeight / 2
+    referenceColor = resources.getColor(R.color.leak_canary_reference)
+  }
+
+  override fun getSize(
+    paint: Paint,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    fm: Paint.FontMetricsInt?
+  ): Int {
+    width = paint.measureText(text, start, end)
+        .toInt()
+    return width
+  }
+
+  override fun draw(
+    canvas: Canvas,
+    text: CharSequence,
+    start: Int,
+    end: Int,
+    x: Float,
+    top: Int,
+    y: Int,
+    bottom: Int,
+    paint: Paint
+  ) {
+    squigglyHorizontalPath(
+        path,
+        x + halfStrokeWidth,
+        x + width - halfStrokeWidth,
+        bottom - halfWaveHeight,
+        amplitude, periodDegrees
+    )
+    canvas.drawPath(path, squigglyPaint)
+
+    paint.color = referenceColor
+    canvas.drawText(text, start, end, x, y.toFloat(), paint)
+  }
+
+  companion object {
+
+    fun replaceUnderlineSpans(
+      builder: SpannableStringBuilder,
+      resources: Resources
+    ) {
+      val underlineSpans = builder.getSpans(0, builder.length, UnderlineSpan::class.java)
+      for (span in underlineSpans) {
+        val start = builder.getSpanStart(span)
+        val end = builder.getSpanEnd(span)
+        builder.removeSpan(span)
+        builder.setSpan(SquigglySpan(resources), start, end, 0)
+      }
+    }
+
+    private fun squigglyHorizontalPath(
+      path: Path,
+      left: Float,
+      right: Float,
+      centerY: Float,
+      amplitude: Float,
+      periodDegrees: Float
+    ) {
+      path.reset()
+
+      var y: Float
+      path.moveTo(left, centerY)
+      val period = (2 * Math.PI / periodDegrees).toFloat()
+
+      var x = 0f
+      while (x <= right - left) {
+        y = (amplitude * Math.sin((40 + period * x).toDouble()) + centerY).toFloat()
+        path.lineTo(left + x, y)
+        x += 1f
+      }
+    }
+  }
+}
\ No newline at end of file
