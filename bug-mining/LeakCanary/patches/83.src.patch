diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
index 7ce606bd7..0b0ab104a 100644
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
@@ -36,6 +36,7 @@ import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
 import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
 import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
 import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.Exclusion
 import leakcanary.ExclusionDescription
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisException
@@ -113,10 +114,11 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
       listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
       deduplicateGcRoots(snapshot)
       listener.onProgressUpdate(FINDING_LEAKING_REF)
-      val leakingRef = findLeakingReference(referenceKey, snapshot) ?: return PerflibAnalysisResult.noLeak(
-          "UnknownNoKeyedWeakReference",
-          since(analysisStartNanoTime)
-      )
+      val leakingRef =
+        findLeakingReference(referenceKey, snapshot) ?: return PerflibAnalysisResult.noLeak(
+            "UnknownNoKeyedWeakReference",
+            since(analysisStartNanoTime)
+        )
       return findLeakTrace(
           heapDump,
           excludedRefs,
@@ -322,7 +324,9 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
       }
       val leakDetected = LeakingInstance(
           weakReference.key, weakReference.name, weakReference.className,
-          weakReference.watchDurationMillis, pathResult.excludingKnownLeaks, leakTrace, retainedSize
+          weakReference.watchDurationMillis,
+          if (pathResult.excludingKnownLeaks) Exclusion.Status.WONT_FIX_LEAK else null, leakTrace,
+          retainedSize
       )
       analysisResults[weakReference.key] = leakDetected
     }
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
index b63cf7668..538657cba 100644
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
+++ b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
@@ -19,7 +19,7 @@ class HeapAnalyzerPerflibHeapDumpTest {
     val retainedInstance = findLeak(ASYNC_TASK_P)!!
     assertThat(retainedInstance).isInstanceOf(LeakingInstance::class.java)
     val leak = retainedInstance as LeakingInstance
-    assertThat(leak.excludedLeak).isFalse()
+    assertThat(leak.exclusionStatus).isNull()
     assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
index 140e8fa60..6cd53a4be 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
@@ -1,5 +1,6 @@
 package leakcanary
 
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import java.io.Serializable
 
 /**
@@ -18,21 +19,34 @@ import java.io.Serializable
 data class Exclusion(
   val type: ExclusionType,
   val reason: String? = null,
-  val alwaysExclude: Boolean = false
+  val status: Status = WONT_FIX_LEAK
 ) {
   val description
     get() = ExclusionDescription(type.matching, reason)
 
+  // Note: the enum order matters for shortest paths, do not reorder
+  enum class Status {
+    /**
+     * References matching this cannot create leaks.
+     * The shortest path finder will never go through references that match this exclusion.
+     */
+    NEVER_REACHABLE,
+    /**
+     * References matching this are known to create leaks, but those leaks will not be fixed.
+     * The shortest path finder will only go through references that match this exclusion after it
+     * has exhausted references that don't match any exclusion.
+     */
+    WONT_FIX_LEAK,
+    /**
+     * The shortest path finder will only go through references that match this exclusion after it
+     * has exhausted references that match known leak exclusions.
+     */
+    WEAKLY_REACHABLE
+  }
+
   sealed class ExclusionType {
     abstract val matching: String
 
-    class ClassExclusion(
-      val className: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "any subclass of $className"
-    }
-
     class ThreadExclusion(
       val threadName: String
     ) : ExclusionType() {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
index d51fe762c..609662bca 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -1,5 +1,6 @@
 package leakcanary
 
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.internal.createSHA1Hash
 import java.io.File
 import java.io.Serializable
@@ -75,7 +76,7 @@ data class LeakingInstance(
    * True if the only path to the leaking reference is through excluded references. Usually, that
    * means you can safely ignore this report.
    */
-  val excludedLeak: Boolean,
+  val exclusionStatus: Exclusion.Status?,
   /**
    * Shortest path to GC roots for the leaking instance.
    */
@@ -91,7 +92,7 @@ data class LeakingInstance(
   val groupHash = createGroupHash()
 
   private fun createGroupHash(): String {
-    val uniqueString = if (excludedLeak) {
+    val uniqueString = if (exclusionStatus == WONT_FIX_LEAK) {
       leakTrace.firstElementExclusion.matching
     } else {
       leakTrace.leakCauses
@@ -114,4 +115,4 @@ fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
 }
 
 fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
-  leakingInstances().filter { !it.excludedLeak }
\ No newline at end of file
+  leakingInstances().filter { it.exclusionStatus == null }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index 9bcfcb991..368dfd09a 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -285,7 +285,7 @@ class HeapAnalyzer constructor(
           key,
           parser.retrieveString(weakReference.name),
           parser.retrieveString(weakReference.className),
-          weakReference.watchDurationMillis, pathResult.excludingKnownLeaks, leakTrace, retainedSize
+          weakReference.watchDurationMillis, pathResult.exclusionStatus, leakTrace, retainedSize
       )
       analysisResults[key] = leakDetected
     }
@@ -315,7 +315,7 @@ class HeapAnalyzer constructor(
     // We iterate from the leak to the GC root
     val ignored = leakingNode.instance
 
-    val leafNode = ChildNode(ignored, null, leakingNode, null)
+    val leafNode = ChildNode(ignored, Int.MAX_VALUE, null, leakingNode, null)
     var node: LeakNode = leafNode
     val nodes = mutableListOf<LeakNode>()
     while (node is ChildNode) {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
index 59acbb99f..071071e3f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
@@ -92,20 +92,17 @@ interface Labeler {
     override fun computeLabels(
       parser: HprofParser,
       node: LeakNode
-    ): List<String> {
-      val objectId = node.instance
-      val record = parser.retrieveRecordById(objectId)
+    ): List<String> = with(parser) {
+      val record = node.instance.objectRecord
       if (record is InstanceDumpRecord) {
         val labels = mutableListOf<String>()
-        val instance = parser.hydrateInstance(record)
+        val instance = record.hydratedInstance
         val className = instance.classHierarchy[0].className
 
         if (instance.classHierarchy.any { it.className == Thread::class.java.name }) {
-          val nameField = instance.fieldValueOrNull<ObjectReference>("name")
           // Sometimes we can't find the String at the expected memory address in the heap dump.
           // See https://github.com/square/leakcanary/issues/417
-          val threadName =
-            if (nameField != null) parser.retrieveString(nameField) else "not available"
+          val threadName = instance["name"].reference.stringOrNull ?: "not available"
           labels.add("Thread name: '$threadName'")
         } else if (className.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
           val parentClassName = instance.classHierarchy[1].className
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
index 34cd2a127..0a59b875b 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -2,13 +2,19 @@ package leakcanary
 
 sealed class LeakNode {
   abstract val instance: Long
+  /** Used by the shortest path finder to create a segmented FIFO queue using a priority queue. */
+  abstract val visitOrder: Int
 
   class RootNode(
     override val instance: Long
-  ) : LeakNode()
+  ) : LeakNode() {
+    override val visitOrder
+      get() = 0
+  }
 
   class ChildNode(
     override val instance: Long,
+    override val visitOrder: Int,
     val exclusion: ExclusionDescription?,
     val parent: LeakNode,
     /**
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 5d5031ce4..23cdfb610 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -16,10 +16,11 @@
 package leakcanary.internal
 
 import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.ClassExclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.Status
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofParser
@@ -37,10 +38,9 @@ import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import java.util.ArrayDeque
-import java.util.Deque
 import java.util.LinkedHashMap
 import java.util.LinkedHashSet
+import java.util.PriorityQueue
 
 /**
  * Not thread safe.
@@ -53,27 +53,27 @@ import java.util.LinkedHashSet
  * never be found.
  */
 internal class ShortestPathFinder {
+
   /**
-   * TODO If this queue grows large we can optimize it by replacing LeakNode with just (long, long)
-   * and rebuild exclusion and leak reference after the analysis
+   * A segmented FIFO queue. The queue is segmented by [Status]. Within each segment the elements
+   * are ordered FIFO.
    */
-  private val toVisitQueue: Deque<LeakNode>
-  private val toVisitIfNoPathQueue: Deque<LeakNode>
-  private val toVisitSet: LinkedHashSet<Long>
-  private val toVisitIfNoPathSet: LinkedHashSet<Long>
-  private val visitedSet: LinkedHashSet<Long>
-
-  init {
-    toVisitQueue = ArrayDeque()
-    toVisitIfNoPathQueue = ArrayDeque()
-    toVisitSet = LinkedHashSet()
-    toVisitIfNoPathSet = LinkedHashSet()
-    visitedSet = LinkedHashSet()
-  }
+  private val toVisitQueue = PriorityQueue<LeakNode>(1024, Comparator { node1, node2 ->
+    val priorityComparison = toVisitMap[node1.instance]!!.compareTo(toVisitMap[node2.instance]!!)
+    if (priorityComparison != 0) {
+      priorityComparison
+    } else {
+      node1.visitOrder.compareTo(node2.visitOrder)
+    }
+  })
+  /** Set of instances to visit */
+  private val toVisitMap = LinkedHashMap<Long, Status>()
+  private val visitedSet = LinkedHashSet<Long>()
+  private var visitOrder = 0
 
   internal class Result(
     val leakingNode: LeakNode,
-    val excludingKnownLeaks: Boolean,
+    val exclusionStatus: Status?,
     val weakReference: KeyedWeakReferenceMirror
   )
 
@@ -89,15 +89,11 @@ internal class ShortestPathFinder {
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     // TODO Use thread name exclusions
     val threadNames = mutableMapOf<String, Exclusion>()
-    val classNames = mutableMapOf<String, Exclusion>()
 
     exclusionsFactory(parser)
         .forEach { exclusion ->
 
           when (exclusion.type) {
-            is ClassExclusion -> {
-              classNames[exclusion.type.className] = exclusion
-            }
             is ThreadExclusion -> {
               threadNames[exclusion.type.threadName] = exclusion
             }
@@ -128,33 +124,26 @@ internal class ShortestPathFinder {
     enqueueGcRoots(parser, gcRootIds)
     gcRootIds.clear()
 
-    var excludingKnownLeaks = false
+    var lowestPriority = ALWAYS_REACHABLE
     val results = mutableListOf<Result>()
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      val node: LeakNode
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll()
-        toVisitSet.remove(node.instance)
-      } else {
-        node = toVisitIfNoPathQueue.poll()
-        toVisitIfNoPathSet.remove(node.instance)
-        if (node is RootNode || (node is ChildNode && node.exclusion == null)) {
-          throw IllegalStateException("Expected node to have an exclusion $node")
-        }
-        excludingKnownLeaks = true
+    while (!toVisitQueue.isEmpty()) {
+      val node = toVisitQueue.poll()!!
+      val priority = toVisitMap[node.instance]!!
+      // Lowest priority has the highest value
+      if (priority > lowestPriority) {
+        lowestPriority = priority
       }
 
+      toVisitMap.remove(node.instance)
+
       if (checkSeen(node)) {
         continue
       }
 
       val weakReference = referentMap[node.instance]
       if (weakReference != null) {
-        results.add(
-            Result(
-                node, excludingKnownLeaks, weakReference
-            )
-        )
+        val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
+        results.add(Result(node, exclusionPriority, weakReference))
         // Found all refs, stop searching.
         if (results.size == leakingWeakRefs.size) {
           break
@@ -163,9 +152,7 @@ internal class ShortestPathFinder {
 
       when (val record = parser.retrieveRecordById(node.instance)) {
         is ClassDumpRecord -> visitClassRecord(parser, record, node, staticFieldNameByClassName)
-        is InstanceDumpRecord -> visitInstanceRecord(
-            parser, record, node, classNames, fieldNameByClassName
-        )
+        is InstanceDumpRecord -> visitInstanceRecord(parser, record, node, fieldNameByClassName)
         is ObjectArrayDumpRecord -> visitObjectArrayRecord(parser, record, node)
         else -> throw IllegalStateException("Unexpected type for $record")
       }
@@ -176,16 +163,15 @@ internal class ShortestPathFinder {
   }
 
   private fun checkSeen(node: LeakNode): Boolean {
-    val alreadySeen = visitedSet.add(node.instance)
-    return !alreadySeen
+    val neverSeen = visitedSet.add(node.instance)
+    return !neverSeen
   }
 
   private fun clearState() {
     toVisitQueue.clear()
-    toVisitIfNoPathQueue.clear()
-    toVisitSet.clear()
-    toVisitIfNoPathSet.clear()
+    toVisitMap.clear()
     visitedSet.clear()
+    visitOrder = 0
   }
 
   private fun enqueueGcRoots(
@@ -198,7 +184,7 @@ internal class ShortestPathFinder {
     // TODO java local: exclude specific threads,
     // TODO java local: parent should be set to the allocated thread
     gcRootIds.forEach {
-      enqueue(hprofParser, RootNode(it))
+      enqueue(hprofParser, RootNode(it), exclusionPriority = null)
     }
   }
 
@@ -223,9 +209,11 @@ internal class ShortestPathFinder {
 
       val exclusion = ignoredStaticFields[fieldName]
 
-      if (exclusion == null || !exclusion.alwaysExclude) {
-        enqueue(hprofParser, ChildNode(objectId, exclusion?.description, node, leakReference))
-      }
+      enqueue(
+          hprofParser,
+          ChildNode(objectId, visitOrder++, exclusion?.description, node, leakReference),
+          exclusion?.status
+      )
     }
   }
 
@@ -233,23 +221,10 @@ internal class ShortestPathFinder {
     hprofParser: HprofParser,
     record: InstanceDumpRecord,
     parent: LeakNode,
-    classNames: Map<String, Exclusion>,
     fieldNameByClassName: Map<String, Map<String, Exclusion>>
   ) {
     val instance = hprofParser.hydrateInstance(record)
 
-    val exclusions = instance.classHierarchy.map {
-      classNames[it.className]
-    }
-
-    if (exclusions.firstOrNull {
-          it != null && it.alwaysExclude
-        } != null) {
-      return
-    }
-
-    val classExclusion = exclusions.firstOrNull { it != null }
-
     val ignoredFields = LinkedHashMap<String, Exclusion>()
 
     instance.classHierarchy.forEach {
@@ -270,19 +245,13 @@ internal class ShortestPathFinder {
     fieldNamesAndValues.filter { (_, value) -> value is ObjectReference }
         .map { (name, reference) -> name to (reference as ObjectReference).value }
         .forEach { (fieldName, objectId) ->
-          val fieldExclusion = ignoredFields[fieldName]
-
-          val exclusion = if (classExclusion != null && classExclusion.alwaysExclude) {
-            classExclusion
-          } else if (fieldExclusion != null && fieldExclusion.alwaysExclude) {
-            fieldExclusion
-          } else classExclusion ?: fieldExclusion
+          val exclusion = ignoredFields[fieldName]
           enqueue(
               hprofParser, ChildNode(
               objectId,
-              exclusion?.description, parent,
+              visitOrder++, exclusion?.description, parent,
               LeakReference(INSTANCE_FIELD, fieldName, "object $objectId")
-          )
+          ), exclusion?.status
           )
         }
   }
@@ -295,27 +264,32 @@ internal class ShortestPathFinder {
     record.elementIds.forEachIndexed { index, elementId ->
       val name = Integer.toString(index)
       val reference = LeakReference(ARRAY_ENTRY, name, "object $elementId")
-      enqueue(hprofParser, ChildNode(elementId, null, parentNode, reference))
+      enqueue(hprofParser, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
     }
   }
 
   private fun enqueue(
     hprofParser: HprofParser,
-    node: LeakNode
+    node: LeakNode,
+    exclusionPriority: Status?
   ) {
+    // 0L is null
     if (node.instance == 0L) {
       return
     }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(node.instance)) {
+    if (visitedSet.contains(node.instance)) {
       return
     }
-    if (visitedSet.contains(node.instance)) {
+    if (exclusionPriority == NEVER_REACHABLE) {
       return
     }
 
-    val visitNow = node is RootNode || (node is ChildNode && node.exclusion == null)
-    if (!visitNow && toVisitIfNoPathSet.contains(node.instance)) {
+    val nodePriority = exclusionPriority ?: ALWAYS_REACHABLE
+
+    // Whether we want to visit now or later, we should skip if this is already to visit.
+    val existingPriority = toVisitMap[node.instance]
+
+    if (existingPriority != null && existingPriority <= nodePriority) {
       return
     }
 
@@ -324,17 +298,19 @@ internal class ShortestPathFinder {
       return
     }
 
-    if (visitNow) {
-      toVisitSet.add(node.instance)
-      toVisitQueue.add(node)
-    } else {
-      toVisitIfNoPathSet.add(node.instance)
-      toVisitIfNoPathQueue.add(node)
+    if (existingPriority != null) {
+      toVisitQueue.removeAll { it.instance == node.instance }
     }
+    toVisitMap[node.instance] = nodePriority
+    toVisitQueue.add(node)
   }
 
   companion object {
     private val SKIP_ENQUEUE =
       setOf(PRIMITIVE_WRAPPER, PRIMITIVE_ARRAY_OR_WRAPPER_ARRAY, STRING, EMPTY_INSTANCE)
+
+    // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
+    // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
+    private val ALWAYS_REACHABLE = NEVER_REACHABLE
   }
 }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index b94be3fb6..85bf545a5 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -1,9 +1,12 @@
 package leakcanary.internal
 
 import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.ClassExclusion
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.HprofParser
+import leakcanary.KeyedWeakReference
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -25,32 +28,71 @@ internal fun fileFromName(filename: String): File {
 val defaultExclusionFactory: (HprofParser) -> List<Exclusion> = {
   listOf(
       Exclusion(
-          type = ClassExclusion(WeakReference::class.java.name),
-          alwaysExclude = true
-      ),
+          type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+          status = WEAKLY_REACHABLE
+      )
+      ,
       Exclusion(
-          type = ClassExclusion(SoftReference::class.java.name),
-          alwaysExclude = true
-      ),
+          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
       Exclusion(
-          type = ClassExclusion(PhantomReference::class.java.name),
-          alwaysExclude = true
-      ),
+          type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
       Exclusion(
-          type = ClassExclusion("java.lang.ref.Finalizer"),
-          alwaysExclude = true
-      ),
+          type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      ,
       Exclusion(
-          type = ClassExclusion("java.lang.ref.FinalizerReference"),
-          alwaysExclude = true
-      ),
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
+          status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
+      )
+      ,
+      Exclusion(
+          type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
+      )
+      ,
+
       Exclusion(
           type = ThreadExclusion("FinalizerWatchdogDaemon"),
-          alwaysExclude = true
+          status = NEVER_REACHABLE
       ),
       Exclusion(
           type = ThreadExclusion("main"),
-          alwaysExclude = true
+          status = NEVER_REACHABLE
       )
   )
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
index c6fa9c21b..1151e4076 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -29,10 +29,11 @@ import android.os.Build.VERSION_CODES.O
 import android.os.Build.VERSION_CODES.O_MR1
 import android.os.Build.VERSION_CODES.P
 import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
-import leakcanary.Exclusion.ExclusionType.ClassExclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.internal.HeapDumpTrigger
 import leakcanary.internal.LeakCanaryUtils.HUAWEI
 import leakcanary.internal.LeakCanaryUtils.LENOVO
@@ -605,6 +606,28 @@ enum class AndroidExcludedRefs {
     }
   },
 
+  VIEWLOCATIONHOLDER_ROOT {
+    override fun add(
+      exclusions: MutableList<Exclusion>,
+      build: BuildMirror
+    ) {
+      if (build.sdkInt == P) {
+        exclusions.add(
+            Exclusion(
+                type = InstanceFieldExclusion(
+                    "android.view.ViewGroup\$ViewLocationHolder",
+                    "mRoot"
+                ),
+                reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared" +
+                    "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+                    "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+                    "report: https://issuetracker.google.com/issues/112792715"
+            )
+        )
+      }
+    }
+  },
+
   // ######## Manufacturer specific Excluded refs ########
 
   INSTRUMENTATION_RECOMMEND_ACTIVITY {
@@ -978,27 +1001,82 @@ enum class AndroidExcludedRefs {
     }
   },
 
-  // ######## General Excluded refs ########
+  // ######## General exclusions ########
 
-  SOFT_REFERENCES {
+  REFERENCES {
     override fun add(
       exclusions: MutableList<Exclusion>,
       build: BuildMirror
     ) {
       exclusions.add(
-          Exclusion(type = ClassExclusion(WeakReference::class.java.name), alwaysExclude = true)
+          Exclusion(
+              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+              status = WEAKLY_REACHABLE
+          )
       )
       exclusions.add(
-          Exclusion(type = ClassExclusion(SoftReference::class.java.name), alwaysExclude = true)
+          Exclusion(
+              type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
+              status = NEVER_REACHABLE
+          )
       )
       exclusions.add(
-          Exclusion(type = ClassExclusion(PhantomReference::class.java.name), alwaysExclude = true)
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
+              status = NEVER_REACHABLE
+          )
       )
       exclusions.add(
-          Exclusion(type = ClassExclusion("java.lang.ref.Finalizer"), alwaysExclude = true)
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
+              status = NEVER_REACHABLE
+          )
       )
       exclusions.add(
-          Exclusion(type = ClassExclusion("java.lang.ref.FinalizerReference"), alwaysExclude = true)
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
+              status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
+          )
+      )
+      exclusions.add(
+          Exclusion(
+              type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
+          )
       )
     }
   },
@@ -1013,7 +1091,7 @@ enum class AndroidExcludedRefs {
       exclusions.add(
           Exclusion(
               type = ThreadExclusion("FinalizerWatchdogDaemon"),
-              alwaysExclude = true
+              status = NEVER_REACHABLE
           )
       )
     }
@@ -1030,7 +1108,7 @@ enum class AndroidExcludedRefs {
       exclusions.add(
           Exclusion(
               type = ThreadExclusion("main"),
-              alwaysExclude = true
+              status = NEVER_REACHABLE
           )
       )
     }
@@ -1044,7 +1122,7 @@ enum class AndroidExcludedRefs {
       exclusions.add(
           Exclusion(
               type = ThreadExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
-              alwaysExclude = true
+              status = NEVER_REACHABLE
           )
       )
     }
@@ -1065,34 +1143,12 @@ enum class AndroidExcludedRefs {
                   "android.view.Choreographer\$FrameDisplayEventReceiver",
                   "mMessageQueue"
               ),
-              alwaysExclude = true
+              status = NEVER_REACHABLE
           )
       )
     }
   },
 
-  // TODO This should move to the top
-  // TODO Should also have a "reason" set.
-  VIEWLOCATIONHOLDER_ROOT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      // In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
-      // method.
-      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
-      // Bug report: https://issuetracker.google.com/issues/112792715
-      if (build.sdkInt == P) exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(
-                  "android.view.ViewGroup\$ViewLocationHolder",
-                  "mRoot"
-              ),
-              alwaysExclude = true
-          )
-      )
-    }
-  }
   ;
 
   protected abstract fun add(
@@ -1107,7 +1163,7 @@ enum class AndroidExcludedRefs {
      */
     val androidDefaults: EnumSet<AndroidExcludedRefs>
       get() = EnumSet.of(
-          SOFT_REFERENCES,
+          REFERENCES,
           FINALIZER_WATCHDOG_DAEMON,
           MAIN,
           LEAK_CANARY_THREAD,
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 0ca3f9bb0..72b631207 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -26,8 +26,6 @@ import android.widget.BaseAdapter
 import android.widget.TextView
 import androidx.annotation.ColorRes
 import com.squareup.leakcanary.core.R
-import com.squareup.leakcanary.core.R.id
-import com.squareup.leakcanary.core.R.string
 import leakcanary.LeakTrace
 import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
@@ -115,7 +113,7 @@ internal class DisplayLeakAdapter private constructor(
   }
 
   private fun bindTopRow(view: View) {
-    val textView = view.findViewById<TextView>(id.leak_canary_row_text)
+    val textView = view.findViewById<TextView>(R.id.leak_canary_row_text)
     textView.text = view.context.packageName
   }
 
@@ -158,13 +156,13 @@ internal class DisplayLeakAdapter private constructor(
         Html.fromHtml(
             """
               <font color='$helpColorHexString'>
-                <b>${resources.getString(string.leak_canary_help_title)}</b>
+                <b>${resources.getString(R.string.leak_canary_help_title)}</b>
               </font>
             """
         )
       }
       val detailText = Html.fromHtml(
-          resources.getString(string.leak_canary_help_detail)
+          resources.getString(R.string.leak_canary_help_detail)
       ) as SpannableStringBuilder
       SquigglySpan.replaceUnderlineSpans(detailText, resources)
       detailView.text = detailText
@@ -194,13 +192,13 @@ internal class DisplayLeakAdapter private constructor(
     view: View,
     position: Int
   ) {
-    val titleView = view.findViewById<TextView>(id.leak_canary_row_text)
-    val timeView = view.findViewById<TextView>(id.leak_canary_row_time)
+    val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+    val timeView = view.findViewById<TextView>(R.id.leak_canary_row_time)
 
     val projection = instanceProjections[position - TOP_ROW_COUNT - leakTrace.elements.size]
 
     titleView.text =
-      view.resources.getString(string.leak_canary_class_has_leaked, projection.classSimpleName)
+      view.resources.getString(R.string.leak_canary_class_has_leaked, projection.classSimpleName)
 
     timeView.text = DateUtils.formatDateTime(
         view.context, projection.createdAtTimeMillis,
@@ -298,31 +296,31 @@ internal class DisplayLeakAdapter private constructor(
         return START_LAST_REACHABLE
       }
       val nextReachability = leakTrace.expectedReachability[elementIndex(position + 1)]
-      return if (nextReachability.status != Reachability.Status.REACHABLE) {
+      return if (nextReachability.status != REACHABLE) {
         START_LAST_REACHABLE
       } else START
     } else {
       val isLeakingInstance = position == count - 1
       if (isLeakingInstance) {
         val previousReachability = leakTrace.expectedReachability[elementIndex(position - 1)]
-        return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+        return if (previousReachability.status != UNREACHABLE) {
           END_FIRST_UNREACHABLE
         } else END
       } else {
         val reachability = leakTrace.expectedReachability[elementIndex(position)]
         when (reachability.status) {
           Reachability.Status.UNKNOWN -> return NODE_UNKNOWN
-          Reachability.Status.REACHABLE -> {
+          REACHABLE -> {
             val nextReachability = leakTrace.expectedReachability[elementIndex(position + 1)]
-            return if (nextReachability.status != Reachability.Status.REACHABLE) {
+            return if (nextReachability.status != REACHABLE) {
               NODE_LAST_REACHABLE
             } else {
               NODE_REACHABLE
             }
           }
-          Reachability.Status.UNREACHABLE -> {
+          UNREACHABLE -> {
             val previousReachability = leakTrace.expectedReachability[elementIndex(position - 1)]
-            return if (previousReachability.status != Reachability.Status.UNREACHABLE) {
+            return if (previousReachability.status != UNREACHABLE) {
               NODE_FIRST_UNREACHABLE
             } else {
               NODE_UNREACHABLE
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index bad78f9ff..80a3c34ca 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -2,6 +2,8 @@ package leakcanary.internal.activity.db
 
 import android.content.ContentValues
 import android.database.sqlite.SQLiteDatabase
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.LeakTrace
 import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
@@ -187,7 +189,7 @@ internal object LeakingInstanceTable {
             val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(0))!!
             val leakTrace = leakingInstance.leakTrace
 
-            val groupLeakTrace = if (leakingInstance.excludedLeak) {
+            val groupLeakTrace = if (leakingInstance.exclusionStatus == WONT_FIX_LEAK) {
               val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
               LeakTrace(
                   elements = listOf(leakTrace.elements[index]),
@@ -259,12 +261,17 @@ internal object LeakingInstanceTable {
   }
 
   private fun LeakingInstance.createGroupDescription(): String {
-    return if (excludedLeak) {
-      "[Excluded] " + leakTrace.firstElementExclusion.matching
+    return if (exclusionStatus == WONT_FIX_LEAK) {
+      "[Won't Fix] ${leakTrace.firstElementExclusion.matching}"
     } else {
       val element = leakTrace.leakCauses.first()
       val referenceName = element.reference!!.groupingName
-      element.simpleClassName + "." + referenceName
+      val refDescription = element.simpleClassName + "." + referenceName
+      if (exclusionStatus == WEAKLY_REACHABLE) {
+        "[Weakly Reachable] $refDescription"
+      } else {
+        refDescription
+      }
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 4f4b773e2..28f7f40f6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for 2.0-alpha-2
-    private const val VERSION = 3
+    private const val VERSION = 4
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
index 37de4bd97..2c10e07d0 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
@@ -17,7 +17,7 @@ import java.util.concurrent.Executor
  * Instrumentation test that runs the two heap analyzer implementations on the same heap
  * dump and logs how they perform. This isn't meant to run as part of the test suite.
  */
-@Ignore
+//@Ignore
 class HeapAnalyzerComparisonTest {
 
   @Volatile
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index ab002ad75..77ec2531a 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -810,6 +810,16 @@ class HprofParser private constructor(
 
   val Long.objectRecord: ObjectRecord get() = retrieveRecordById(this)
 
+  val ObjectRecord.hydratedInstance: HydratedInstance
+    get() = hydrateInstance(
+        this as InstanceDumpRecord
+    )
+
+  val Long.hydratedInstance: HydratedInstance
+    get() = hydrateInstance(
+        retrieveRecordById(this) as InstanceDumpRecord
+    )
+
   val Long?.stringOrNull: String?
     get() = if (this == null) {
       null
