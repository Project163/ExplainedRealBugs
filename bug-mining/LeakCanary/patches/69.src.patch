diff --git a/CHANGELOG.md b/CHANGELOG.md
index 358dcafc1..bd60c8d25 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,10 @@
 # Change Log
 
-## Future release
+## Version 2.0
 
 * [#1186](https://github.com/square/leakcanary/issues/1186) Fix NPE when KeyedWeakReference was not found in heap dump.
+* [#1133](https://github.com/square/leakcanary/issues/1133) Updated to HAHA 2.1 (latest perflib from Android Studio)
+* [#1124](https://github.com/square/leakcanary/issues/1124) Fixed crash when heap dump has missing native threads.
 
 ## Version 1.6.3 (2019-01-10)
 
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index 8cb636a42..4edbbb6aa 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -1,7 +1,7 @@
 apply plugin: 'com.android.library'
 
 dependencies {
-  implementation 'com.squareup.haha:haha:2.0.4'
+  implementation 'com.squareup.haha:haha:2.1'
   api project(':leakcanary-watcher')
   testImplementation 'junit:junit:4.12'
   testImplementation 'org.assertj:assertj-core:3.9.1'
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
index b0644815a..ca6fe3a6d 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
@@ -16,8 +16,6 @@
 package com.squareup.haha.perflib;
 
 import android.support.annotation.NonNull;
-import java.util.HashSet;
-import java.util.Set;
 
 public final class HahaSpy {
 
@@ -33,18 +31,6 @@ public final class HahaSpy {
     return snapshot.findInstance(thread.mId);
   }
 
-  /**
-   * Returns the GC Roots for all heaps in the Snapshot. Unfortunately,
-   * {@link Snapshot#getGCRoots()} only returns the GC Roots of the first heap.
-   */
-  public static Set<RootObj> allGcRoots(Snapshot snapshot) {
-    Set<RootObj> allRoots = new HashSet<>();
-    for (Heap heap : snapshot.getHeaps()) {
-      allRoots.addAll(heap.mRoots);
-    }
-    return allRoots;
-  }
-
   private HahaSpy() {
     throw new AssertionError();
   }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
index 96e015fae..07dbffd2d 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalyzerProgressListener.java
@@ -18,7 +18,6 @@ public interface AnalyzerProgressListener {
     FINDING_SHORTEST_PATH,
     BUILDING_LEAK_TRACE,
     COMPUTING_DOMINATORS,
-    COMPUTING_BITMAP_SIZE,
   }
 
   void onProgressUpdate(@NonNull Step step);
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 0bc8cdede..bc1bfe56a 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -16,18 +16,16 @@
 package com.squareup.leakcanary;
 
 import android.support.annotation.NonNull;
+import com.android.tools.perflib.captures.DataBuffer;
+import com.android.tools.perflib.captures.MemoryMappedFileBuffer;
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
 import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HprofParser;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
-import com.squareup.haha.perflib.io.HprofBuffer;
-import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
 import gnu.trove.THashMap;
 import gnu.trove.TObjectProcedure;
 import java.io.File;
@@ -38,13 +36,10 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.N_MR1;
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
 import static com.squareup.leakcanary.AnalysisResult.noLeak;
 import static com.squareup.leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE;
-import static com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_BITMAP_SIZE;
 import static com.squareup.leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS;
 import static com.squareup.leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS;
 import static com.squareup.leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF;
@@ -113,9 +108,9 @@ public final class HeapAnalyzer {
       throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
     }
     try {
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      Snapshot snapshot = parser.parse();
+
+      DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      Snapshot snapshot = Snapshot.createSnapshot(buffer);
       deduplicateGcRoots(snapshot);
 
       ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
@@ -165,10 +160,9 @@ public final class HeapAnalyzer {
 
     try {
       listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
+      DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
       listener.onProgressUpdate(PARSING_HEAP_DUMP);
-      Snapshot snapshot = parser.parse();
+      Snapshot snapshot = Snapshot.createSnapshot(buffer);
       listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
       deduplicateGcRoots(snapshot);
       listener.onProgressUpdate(FINDING_LEAKING_REF);
@@ -263,12 +257,6 @@ public final class HeapAnalyzer {
       Instance leakingInstance = result.leakingNode.instance;
 
       retainedSize = leakingInstance.getTotalRetainedSize();
-
-      // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
-      if (SDK_INT <= N_MR1) {
-        listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);
-        retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
-      }
     } else {
       retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;
     }
@@ -277,60 +265,6 @@ public final class HeapAnalyzer {
         since(analysisStartNanoTime));
   }
 
-  /**
-   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
-   * in the retained size because their root dominator is a native gc root.
-   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
-   * add the bitmap size.
-   *
-   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
-   * accounted for, however bitmaps set in layouts are not.
-   */
-  private long computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    long bitmapRetainedSize = 0;
-    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
-
-    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
-      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
-        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
-        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
-        if (mBufferInstance == null) {
-          continue;
-        }
-        long bufferSize = mBufferInstance.getTotalRetainedSize();
-        long bitmapSize = bitmapInstance.getTotalRetainedSize();
-        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
-        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
-        if (bitmapSize < bufferSize) {
-          bitmapSize += bufferSize;
-        }
-        bitmapRetainedSize += bitmapSize;
-      }
-    }
-    return bitmapRetainedSize;
-  }
-
-  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
-    boolean foundNativeRoot = false;
-    while (true) {
-      Instance immediateDominator = instance.getImmediateDominator();
-      if (immediateDominator instanceof RootObj
-          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
-        // Ignore native roots
-        instance = instance.getNextInstanceToGcRoot();
-        foundNativeRoot = true;
-      } else {
-        instance = immediateDominator;
-      }
-      if (instance == null) {
-        return false;
-      }
-      if (instance == dominator) {
-        return foundNativeRoot;
-      }
-    }
-  }
-
   private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
index 5bccc0850..1a6076fbb 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -129,7 +129,7 @@ final class ShortestPathFinder {
   }
 
   private void enqueueGcRoots(Snapshot snapshot) {
-    for (RootObj rootObj : HahaSpy.allGcRoots(snapshot)) {
+    for (RootObj rootObj : snapshot.getGCRoots()) {
       switch (rootObj.getRootType()) {
         case JAVA_LOCAL:
           Instance thread = HahaSpy.allocatingThread(rootObj);
@@ -139,6 +139,8 @@ final class ShortestPathFinder {
             enqueue(params, null, rootObj, null);
           }
           break;
+        // Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+        case THREAD_OBJECT:
         case INTERNED_STRING:
         case DEBUGGER:
         case INVALID_TYPE:
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.java
similarity index 92%
rename from leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
rename to leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.java
index 59f1949c3..1395279a5 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeDataBuffer.java
@@ -1,11 +1,10 @@
 package com.squareup.leakcanary;
 
-import com.squareup.haha.perflib.io.HprofBuffer;
-
+import com.android.tools.perflib.captures.DataBuffer;
 import java.io.UnsupportedEncodingException;
 import java.util.List;
 
-public final class FakeHprofBuffer implements HprofBuffer {
+public final class FakeDataBuffer implements DataBuffer {
   private static final String PRE_O_CHARSET = "UTF-16BE";
 
   private final String stringCharset;
@@ -18,11 +17,11 @@ public final class FakeHprofBuffer implements HprofBuffer {
   private String[] stringsToRead;
   private int stringIndex = -1;
 
-  FakeHprofBuffer() {
+  FakeDataBuffer() {
     this(PRE_O_CHARSET);
   }
 
-  FakeHprofBuffer(String stringCharset) {
+  FakeDataBuffer(String stringCharset) {
     this.stringCharset = stringCharset;
   }
 
@@ -41,6 +40,9 @@ public final class FakeHprofBuffer implements HprofBuffer {
     throw new UnsupportedOperationException("no bytes to read");
   }
 
+  @Override public void dispose() {
+  }
+
   @Override
   public void read(byte[] bytes) {
     throw new UnsupportedOperationException("no bytes to read");
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
index bb9e5bc87..0c7188355 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
@@ -1,12 +1,12 @@
 package com.squareup.leakcanary;
 
+import com.android.tools.perflib.captures.DataBuffer;
 import com.squareup.haha.perflib.ArrayInstance;
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
 import com.squareup.haha.perflib.Field;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
-import com.squareup.haha.perflib.io.HprofBuffer;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,16 +27,16 @@ public class HahaHelperTest {
   private static final int COUNT_VALUE = 5;
   private static final int OFFSET_VALUE = 1;
 
-  private FakeHprofBuffer buffer;
+  private FakeDataBuffer buffer;
   private Snapshot snapshot;
 
   @Before
   public void setUp() {
-    buffer = new FakeHprofBuffer();
+    buffer = new FakeDataBuffer();
     initSnapshot(buffer);
   }
 
-  private void initSnapshot(HprofBuffer buffer) {
+  private void initSnapshot(DataBuffer buffer) {
     snapshot = new Snapshot(buffer);
     // set HPROF identifier size; required for Object instance field lookups
     // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
@@ -78,7 +78,7 @@ public class HahaHelperTest {
 
   @Test public void readStringAsByteArrayFromHeapDumpInstance_O() {
     // O uses default charset UTF-8
-    buffer = new FakeHprofBuffer("UTF-8");
+    buffer = new FakeDataBuffer("UTF-8");
     initSnapshot(buffer);
 
     buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.java
index d04c835f5..0d83ace7f 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerHeapDumpTest.java
@@ -8,6 +8,7 @@ import org.junit.runners.JUnit4;
 import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
 import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
 import static com.squareup.leakcanary.TestUtil.HeapDumpFile.GC_ROOT_IN_NON_PRIMARY_HEAP;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.MISSING_THREAD;
 import static com.squareup.leakcanary.TestUtil.analyze;
 import static com.squareup.leakcanary.TestUtil.findTrackedReferences;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -32,4 +33,9 @@ public class HeapAnalyzerHeapDumpTest {
     AnalysisResult result = analyze(GC_ROOT_IN_NON_PRIMARY_HEAP);
     assertThat(result.leakFound).isTrue();
   }
+
+  @Test public void heapDumpWithMissingNativeThread() {
+    AnalysisResult result = analyze(MISSING_THREAD);
+    assertThat(result.leakFound).isTrue();
+  }
 }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
index 73acaacef..2a95fc687 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
@@ -20,9 +20,9 @@ public class RetainedSizeTest {
 
   @Parameterized.Parameters public static Collection<Object[]> data() {
     return Arrays.asList(new Object[][] {
-        { ASYNC_TASK_PRE_M, 207_407 }, //
-        { ASYNC_TASK_M, 1_870 }, //
-        { ASYNC_TASK_O, 753 }, //
+        { ASYNC_TASK_PRE_M, 33367 }, //
+        { ASYNC_TASK_M, 49584 }, //
+        { ASYNC_TASK_O, 210978 }, //
     });
   }
 
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
index 41ca94249..30edbdff0 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -32,7 +32,8 @@ final class TestUtil {
     ASYNC_TASK_M("leak_asynctask_m.hprof", "25ae1778-7c1d-4ec7-ac50-5cce55424069"), //
     ASYNC_TASK_O("leak_asynctask_o.hprof", "0e8d40d7-8302-4493-93d5-962a4c176089"),
     GC_ROOT_IN_NON_PRIMARY_HEAP("gc_root_in_non_primary_heap.hprof",
-        "10a5bc66-e9cb-430c-930a-fc1dc4fc0f85");
+        "10a5bc66-e9cb-430c-930a-fc1dc4fc0f85"),
+    MISSING_THREAD("missing_thread.hprof", "c644e537-9abd-42e5-994d-032fc150feef");
 
     public final String filename;
     public final String referenceKey;
diff --git a/leakcanary-analyzer/src/test/resources/missing_thread.hprof b/leakcanary-analyzer/src/test/resources/missing_thread.hprof
new file mode 100644
index 000000000..4f37b45f4
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/missing_thread.hprof differ
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index 70b25c53a..f1cb561bc 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -16,8 +16,8 @@ android {
   compileSdkVersion versions.compileSdk
 
   compileOptions {
-    sourceCompatibility JavaVersion.VERSION_1_7
-    targetCompatibility JavaVersion.VERSION_1_7
+    sourceCompatibility JavaVersion.VERSION_1_8
+    targetCompatibility JavaVersion.VERSION_1_8
   }
 
   defaultConfig {
