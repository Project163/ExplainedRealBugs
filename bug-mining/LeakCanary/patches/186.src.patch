diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index c26336482..a4745cf65 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -391,18 +391,17 @@ class HeapAnalyzer constructor(
     }
 
     deduplicatedPaths.forEachIndexed { index, (retainedObjectNode, retainedSize) ->
-      val pathHeapObjects = mutableListOf<HeapObject>()
       val shortestChildPath = mutableListOf<ChildNode>()
-      var node: ReferencePathNode = retainedObjectNode
+      var node = retainedObjectNode
       while (node is ChildNode) {
         shortestChildPath.add(0, node)
-        pathHeapObjects.add(0, graph.findObjectById(node.objectId))
         node = node.parent
       }
       val rootNode = node as RootNode
-      pathHeapObjects.add(0, graph.findObjectById(rootNode.objectId))
 
-      val leakTraceObjects = buildLeakTraceObjects(objectInspectors, pathHeapObjects)
+      val shortestPath = listOf(rootNode) + shortestChildPath
+
+      val leakTraceObjects = buildLeakTraceObjects(objectInspectors, shortestPath)
 
       val referencePath = buildReferencePath(shortestChildPath, leakTraceObjects)
 
@@ -413,11 +412,8 @@ class HeapAnalyzer constructor(
           retainedHeapByteSize = if (retainedSizes == null) null else retainedSize
       )
 
-      val firstLibraryLeakNode = if (rootNode is LibraryLeakNode) {
-        rootNode
-      } else {
-        shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
-      }
+      val firstLibraryLeakNode =
+        shortestPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
 
       if (firstLibraryLeakNode != null) {
         val matcher = firstLibraryLeakNode.matcher
@@ -439,10 +435,12 @@ class HeapAnalyzer constructor(
     return applicationLeaks to libraryLeaks
   }
 
-  private fun buildLeakTraceObjects(
+  private fun FindLeakInput.buildLeakTraceObjects(
     objectInspectors: List<ObjectInspector>,
-    pathHeapObjects: List<HeapObject>
+    shortestPath: List<ReferencePathNode>
   ): List<LeakTraceObject> {
+    val pathHeapObjects = shortestPath.map { graph.findObjectById(it.objectId) }
+
     val leakReporters = pathHeapObjects.map { heapObject ->
       ObjectReporter(heapObject)
     }
@@ -458,6 +456,14 @@ class HeapAnalyzer constructor(
 
     return pathHeapObjects.mapIndexed { index, heapObject ->
       val leakReporter = leakReporters[index]
+      val nextNode = if (index + 1 < shortestPath.size) {
+        shortestPath[index + 1]
+      } else {
+        null
+      }
+      if (nextNode is LibraryLeakNode) {
+        leakReporter.labels += "Library leak match: ${nextNode.matcher.pattern}"
+      }
       val (leakStatus, leakStatusReason) = leakStatuses[index]
       val className = recordClassName(heapObject)
 
diff --git a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
index 9d4364780..a627d5d53 100644
--- a/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
+++ b/shark/src/test/java/shark/LeakTraceStringRenderingTest.kt
@@ -8,6 +8,7 @@ import org.junit.rules.TemporaryFolder
 import shark.FilteringLeakingObjectFinder.LeakingObjectFilter
 import shark.HeapObject.HeapInstance
 import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.StaticFieldPattern
 import java.io.File
 
 class LeakTraceStringRenderingTest {
@@ -187,6 +188,7 @@ class LeakTraceStringRenderingTest {
     │                    ~~~~~~~~~
     ├─ ClassA instance
     │    Leaking: UNKNOWN
+    │    Library leak match: instance field ClassA#leak
     │    ↓ ClassA.leak
     │             ~~~~
     ╰→ Leaking instance
@@ -197,6 +199,37 @@ class LeakTraceStringRenderingTest {
     """
   }
 
+  @Test fun rendersRootExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["leak"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          referenceMatchers = listOf(
+              LibraryLeakReferenceMatcher(pattern = StaticFieldPattern("GcRoot", "leak"))
+          )
+      )
+
+    analysis rendersLibraryLeak """
+    ┬───
+    │ GC Root: System class
+    │
+    ├─ GcRoot class
+    │    Leaking: UNKNOWN
+    │    Library leak match: static field GcRoot#leak
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking instance
+    ​     Leaking: YES (ObjectWatcher was watching this because its lifecycle has ended)
+    ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ​     watchDurationMillis = 25000
+    ​     retainedDurationMillis = 10000
+    """
+  }
+
   @Test fun rendersArray() {
     hprofFile.dump {
       "GcRoot" clazz {
