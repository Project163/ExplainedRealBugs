diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
index f837144eb..1326f4cd9 100644
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
+++ b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
@@ -17,12 +17,10 @@ package leakcanary.internal.perflib
 
 import com.android.tools.perflib.captures.MemoryMappedFileBuffer
 import com.squareup.haha.perflib.ArrayInstance
-import com.squareup.haha.perflib.ClassInstance
 import com.squareup.haha.perflib.ClassObj
 import com.squareup.haha.perflib.Instance
 import com.squareup.haha.perflib.RootObj
 import com.squareup.haha.perflib.Snapshot
-import com.squareup.haha.perflib.Type
 import gnu.trove.THashMap
 import gnu.trove.TObjectProcedure
 import leakcanary.AnalysisResult
@@ -45,7 +43,6 @@ import leakcanary.HeapAnalysisSuccess
 import leakcanary.HeapDump
 import leakcanary.HeapDumpMemoryStore
 import leakcanary.KeyedWeakReference
-import leakcanary.LeakReference
 import leakcanary.LeakTrace
 import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Holder
@@ -53,9 +50,6 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import leakcanary.Reachability
@@ -73,7 +67,6 @@ import leakcanary.internal.perflib.HahaHelper.extendsThread
 import leakcanary.internal.perflib.HahaHelper.fieldValue
 import leakcanary.internal.perflib.HahaHelper.staticFieldValue
 import leakcanary.internal.perflib.HahaHelper.threadName
-import leakcanary.internal.perflib.HahaHelper.valueAsString
 import leakcanary.internal.perflib.ShortestPathFinder.Result
 import org.jetbrains.annotations.TestOnly
 import java.util.ArrayList
@@ -460,8 +453,8 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
       }
     }
 
-    for ((index, element) in elements.withIndex()) {
-      val reachability = inspectElementReachability(reachabilityInspectors, element)
+    for ((index, _) in elements.withIndex()) {
+      val reachability = Reachability.unknown()
       expectedReachability.add(reachability)
       if (reachability.status == REACHABLE) {
         lastReachableElementIndex = index
@@ -487,11 +480,11 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
       val reachability = expectedReachability[i]
       if (reachability.status == UNKNOWN) {
         if (i < lastReachableElementIndex) {
-          val nextReachableName = elements[i + 1].getSimpleClassName()
+          val nextReachableName = elements[i + 1].simpleClassName
           expectedReachability[i] =
             Reachability.reachable("$nextReachableName↓ is not leaking")
         } else if (i > firstUnreachableElementIndex) {
-          val previousUnreachableName = elements[i - 1].getSimpleClassName()
+          val previousUnreachableName = elements[i - 1].simpleClassName
           expectedReachability[i] =
             Reachability.unreachable("$previousUnreachableName↑ is leaking")
         }
@@ -500,19 +493,6 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
     return expectedReachability
   }
 
-  private fun inspectElementReachability(
-    reachabilityInspectors: List<Inspector>,
-    element: LeakTraceElement
-  ): Reachability {
-    for (reachabilityInspector in reachabilityInspectors) {
-      val reachability = reachabilityInspector.expectedReachability(element)
-      if (reachability.status != UNKNOWN) {
-        return reachability
-      }
-    }
-    return Reachability.unknown()
-  }
-
   private fun buildLeakElement(node: LeakNode): LeakTraceElement? {
     if (node.parent == null) {
       // Ignore any root node.
@@ -526,24 +506,10 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
     val holderType: Holder
     val className: String
     var extra: String? = null
-    val leakReferences = describeFields(holder)
 
     className = getClassName(holder)
 
-    val classHierarchy = ArrayList<String>()
-    classHierarchy.add(className)
     val rootClassName = Any::class.java.name
-    if (holder is ClassInstance) {
-      var classObj = holder.classObj
-
-      do {
-        classObj = classObj.superClassObj
-        if (classObj.className != rootClassName) {
-          classHierarchy.add(classObj.className)
-        }
-      } while (classObj.className != rootClassName)
-    }
-
     if (holder is ClassObj) {
       holderType = CLASS
     } else if (holder is ArrayInstance) {
@@ -587,46 +553,10 @@ class PerflibHeapAnalyzer @TestOnly internal constructor(
     }
     val labels = if (extra == null) emptyList<String>() else mutableListOf(extra)
     return LeakTraceElement(
-        node.leakReference, holderType, classHierarchy, node.exclusion, leakReferences, labels
+        node.leakReference, holderType, className, node.exclusion, labels
     )
   }
 
-  private fun describeFields(instance: Instance?): List<LeakReference> {
-    val leakReferences = ArrayList<LeakReference>()
-    if (instance is ClassObj) {
-      val classObj = instance as ClassObj?
-      for ((key, value) in classObj!!.staticFieldValues) {
-        val name = key.name
-        val stringValue = valueAsString(value)
-        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
-      }
-    } else if (instance is ArrayInstance) {
-      val arrayInstance = instance as ArrayInstance?
-      if (arrayInstance!!.arrayType == Type.OBJECT) {
-        val values = arrayInstance.values
-        for (i in values.indices) {
-          val name = Integer.toString(i)
-          val stringValue = valueAsString(values[i])
-          leakReferences.add(LeakReference(ARRAY_ENTRY, name, stringValue))
-        }
-      }
-    } else {
-      val classObj = instance!!.classObj
-      for ((key, value) in classObj.staticFieldValues) {
-        val name = key.name
-        val stringValue = valueAsString(value)
-        leakReferences.add(LeakReference(STATIC_FIELD, name, stringValue))
-      }
-      val classInstance = instance as ClassInstance?
-      for (field in classInstance!!.values) {
-        val name = field.field.name
-        val stringValue = valueAsString(field.value)
-        leakReferences.add(LeakReference(INSTANCE_FIELD, name, stringValue))
-      }
-    }
-    return leakReferences
-  }
-
   private fun getClassName(instance: Instance): String = when (instance) {
     is ClassObj -> instance.className
     is ArrayInstance -> instance.classObj.className
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index afcb37ef0..9e3dc223e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -31,29 +31,17 @@ import leakcanary.GcRoot.NativeStack
 import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.Reachability.Status.REACHABLE
 import leakcanary.Reachability.Status.UNKNOWN
 import leakcanary.Reachability.Status.UNREACHABLE
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
@@ -62,6 +50,7 @@ import leakcanary.Record.StringRecord
 import leakcanary.internal.KeyedWeakReferenceMirror
 import leakcanary.internal.ShortestPathFinder
 import leakcanary.internal.ShortestPathFinder.Result
+import leakcanary.internal.lastSegment
 import java.util.ArrayList
 import java.util.concurrent.TimeUnit.NANOSECONDS
 
@@ -318,18 +307,21 @@ class HeapAnalyzer constructor(
     val elements = ArrayList<LeakTraceElement>()
     // We iterate from the leak to the GC root
     val ignored = leakingNode.instance
-    var node: LeakNode? =
-      ChildNode(ignored, null, leakingNode, null)
+
+    val leafNode = ChildNode(ignored, null, leakingNode, null)
+    var node: LeakNode = leafNode
+    val nodes = mutableListOf<LeakNode>()
     while (node is ChildNode) {
       val labels = mutableListOf<String>()
       for (labeler in labelers) {
         labels.addAll(labeler.computeLabels(parser, node.parent))
       }
       elements.add(0, buildLeakElement(parser, node, labels))
+      nodes.add(0, node.parent)
       node = node.parent
     }
-
-    val expectedReachability = computeExpectedReachability(parser, heapDump, elements)
+    // TODO Move reachability into leak element
+    val expectedReachability = computeExpectedReachability(parser, heapDump, nodes)
 
     return LeakTrace(elements, expectedReachability)
   }
@@ -337,10 +329,10 @@ class HeapAnalyzer constructor(
   private fun computeExpectedReachability(
     parser: HprofParser,
     heapDump: HeapDump,
-    elements: List<LeakTraceElement>
+    nodes: List<LeakNode>
   ): List<Reachability> {
     var lastReachableElementIndex = 0
-    val lastElementIndex = elements.size - 1
+    val lastElementIndex = nodes.size - 1
     var firstUnreachableElementIndex = lastElementIndex
 
     val expectedReachability = ArrayList<Reachability>()
@@ -355,8 +347,8 @@ class HeapAnalyzer constructor(
       }
     }
 
-    for ((index, element) in elements.withIndex()) {
-      val reachability = inspectElementReachability(parser, reachabilityInspectors, element)
+    for ((index, node) in nodes.withIndex()) {
+      val reachability = inspectElementReachability(reachabilityInspectors, parser, node)
       expectedReachability.add(reachability)
       if (reachability.status == REACHABLE) {
         lastReachableElementIndex = index
@@ -382,9 +374,16 @@ class HeapAnalyzer constructor(
       }
     }
 
-    if (expectedReachability[lastElementIndex].status == UNKNOWN) {
-      expectedReachability[lastElementIndex] =
-        Reachability.unreachable("RefWatcher was watching this")
+    val simpleClassNames = nodes.map { node ->
+      val record = parser.retrieveRecordById(node.instance)
+      val classId = when (record) {
+        is ClassDumpRecord -> record.id
+        is InstanceDumpRecord -> record.classId
+        is ObjectArrayDumpRecord -> record.arrayClassId
+        else -> throw IllegalStateException("Unexpected record type for $record")
+      }
+      parser.className(classId)
+          .lastSegment('.')
     }
 
     // First and last are always known.
@@ -392,10 +391,10 @@ class HeapAnalyzer constructor(
       val reachability = expectedReachability[i]
       if (reachability.status == UNKNOWN) {
         if (i < lastReachableElementIndex) {
-          val nextReachableName = elements[i + 1].getSimpleClassName()
+          val nextReachableName = simpleClassNames[i + 1]
           expectedReachability[i] = Reachability.reachable("$nextReachableName↓ is not leaking")
         } else if (i > firstUnreachableElementIndex) {
-          val previousUnreachableName = elements[i - 1].getSimpleClassName()
+          val previousUnreachableName = simpleClassNames[i - 1]
           expectedReachability[i] = Reachability.unreachable("$previousUnreachableName↑ is leaking")
         }
       }
@@ -404,12 +403,12 @@ class HeapAnalyzer constructor(
   }
 
   private fun inspectElementReachability(
-    parser: HprofParser,
     reachabilityInspectors: List<Reachability.Inspector>,
-    element: LeakTraceElement
+    parser: HprofParser,
+    node: LeakNode
   ): Reachability {
     for (reachabilityInspector in reachabilityInspectors) {
-      val reachability = reachabilityInspector.expectedReachability(element)
+      val reachability = reachabilityInspector.expectedReachability(parser, node)
       if (reachability.status != UNKNOWN) {
         return reachability
       }
@@ -426,95 +425,28 @@ class HeapAnalyzer constructor(
 
     val record = parser.retrieveRecordById(objectId)
 
-    val leakReferences = describeFields(parser, record)
-
-    val classHierarchy = when (record) {
-      is ClassDumpRecord -> listOf(parser.className(record.id))
-      is InstanceDumpRecord -> {
-        val instance = parser.hydrateInstance(record)
-        instance.classHierarchy.map { it.className }
-      }
-      is ObjectArrayDumpRecord -> listOf(parser.className(record.arrayClassId))
+    val classId = when (record) {
+      is ClassDumpRecord -> record.id
+      is InstanceDumpRecord -> record.classId
+      is ObjectArrayDumpRecord -> record.arrayClassId
       else -> throw IllegalStateException("Unexpected record type for $record")
     }
+    val className = parser.className(classId)
 
     val holderType = if (record is ClassDumpRecord) {
       CLASS
     } else if (record is ObjectArrayDumpRecord) {
       ARRAY
     } else {
-      if (classHierarchy.any { it == Thread::class.java.name }) {
+      record as InstanceDumpRecord
+      val classHierarchy = parser.hydrateClassHierarchy(record.classId)
+      if (classHierarchy.any { it.className == Thread::class.java.name }) {
         THREAD
       } else {
         OBJECT
       }
     }
-    return LeakTraceElement(
-        node.leakReference, holderType, classHierarchy, node.exclusion, leakReferences, labels
-    )
-  }
-
-  private fun describeFields(
-    parser: HprofParser,
-    record: ObjectRecord
-  ): List<LeakReference> {
-    val leakReferences = ArrayList<LeakReference>()
-    when (record) {
-      is ClassDumpRecord -> {
-        // TODO We're loading all classes but reading only one. All this should be removed
-        // it's only used by inspectors which should ask the parser for their needs.
-        val classHierarchy = parser.hydrateClassHierarchy(record.id)
-        val hydratedClass = classHierarchy[0]
-        hydratedClass.staticFieldNames.forEachIndexed { index, fieldName ->
-
-          val heapValue = hydratedClass.record.staticFields[index].value
-          leakReferences.add(
-              LeakReference(STATIC_FIELD, fieldName, heapValueAsString(heapValue))
-          )
-        }
-      }
-      is ObjectArrayDumpRecord -> record.elementIds.forEachIndexed { index, objectId ->
-        val name = Integer.toString(index)
-        leakReferences.add(LeakReference(ARRAY_ENTRY, name, "object $objectId"))
-      }
-      else -> {
-        val instance = parser.hydrateInstance(record as InstanceDumpRecord)
-        instance.classHierarchy[0].staticFieldNames.forEachIndexed { index, fieldName ->
-          val heapValue = instance.classHierarchy[0].record.staticFields[index].value
-          leakReferences.add(
-              LeakReference(
-                  STATIC_FIELD, fieldName,
-                  heapValueAsString(heapValue)
-              )
-          )
-        }
-        instance.fieldValues.forEachIndexed { classIndex, fieldValues ->
-          fieldValues.forEachIndexed { fieldIndex, heapValue ->
-            leakReferences.add(
-                LeakReference(
-                    INSTANCE_FIELD, instance.classHierarchy[classIndex].fieldNames[fieldIndex],
-                    heapValueAsString(heapValue)
-                )
-            )
-          }
-        }
-      }
-    }
-    return leakReferences
-  }
-
-  private fun heapValueAsString(heapValue: HeapValue): String {
-    return when (heapValue) {
-      is ObjectReference -> if (heapValue.value == 0L) "null" else "object ${heapValue.value}"
-      is BooleanValue -> heapValue.value.toString()
-      is CharValue -> heapValue.value.toString()
-      is FloatValue -> heapValue.value.toString()
-      is DoubleValue -> heapValue.value.toString()
-      is ByteValue -> heapValue.value.toString()
-      is ShortValue -> heapValue.value.toString()
-      is IntValue -> heapValue.value.toString()
-      is LongValue -> heapValue.value.toString()
-    }
+    return LeakTraceElement(node.leakReference, holderType, className, node.exclusion, labels)
   }
 
   private fun since(analysisStartNanoTime: Long): Long {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
index 3a3d7e99f..81613b3ae 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -11,6 +11,9 @@ sealed class LeakNode {
     override val instance: Long,
     val exclusion: Exclusion?,
     val parent: LeakNode,
+    /**
+     * The reference from the parent to this node
+     */
     val leakReference: LeakReference?
   ) : LeakNode()
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
index 0a5eb3b41..207f9040f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
@@ -12,19 +12,11 @@ data class LeakTraceElement(
 
   val holder: Holder,
 
-  /**
-   * Class hierarchy for that object. The first element is [.className]. [Object]
-   * is excluded. There is always at least one element.
-   */
-  val classHierarchy: List<String>,
+  val className: String,
 
   /** If not null, there was no path that could exclude this element.  */
   val exclusion: Exclusion?,
 
-  /** List of all fields (member and static) for that object.  */
-  @Deprecated("This field will be replaced with the parser itself")
-  val fieldReferences: List<LeakReference>,
-
   /**
    * Ordered labels that were computed during analysis. A label provides
    * extra information that helps understand the leak trace element.
@@ -32,8 +24,10 @@ data class LeakTraceElement(
   val labels: List<String>
 ) : Serializable {
 
-  val className: String
-    get() = classHierarchy[0]
+  /**
+   * Returns {@link #className} without the package.
+   */
+  val simpleClassName: String get() = className.lastSegment('.')
 
   enum class Type {
     INSTANCE_FIELD,
@@ -48,33 +42,4 @@ data class LeakTraceElement(
     THREAD,
     ARRAY
   }
-
-  /**
-   * Returns the string value of the first field reference that has the provided referenceName, or
-   * null if no field reference with that name was found.
-   */
-  fun getFieldReferenceValue(referenceName: String): String? {
-    return fieldReferences.find { fieldReference -> fieldReference.name == referenceName }
-        ?.value
-  }
-
-  /** @see [isInstanceOf][] */
-  fun isInstanceOf(expectedClass: Class<out Any>): Boolean {
-    return isInstanceOf(expectedClass.name)
-  }
-
-  /**
-   * Returns true if this element is an instance of the provided class name, false otherwise.
-   */
-  fun isInstanceOf(expectedClassName: String): Boolean {
-    return classHierarchy.contains(expectedClassName)
-  }
-
-  /**
-   * Returns {@link #className} without the package.
-   */
-  fun getSimpleClassName(): String {
-    return className.lastSegment('.')
-  }
-
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Reachability.kt b/leakcanary-analyzer/src/main/java/leakcanary/Reachability.kt
index 5443129b0..e3227b09e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Reachability.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Reachability.kt
@@ -41,7 +41,10 @@ class Reachability private constructor(
    */
   interface Inspector {
 
-    fun expectedReachability(element: LeakTraceElement): Reachability
+    fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability
   }
 
   companion object {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index 83d0b9657..855209ca5 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -54,7 +54,7 @@ private fun getNextElementString(
     if (element.holder == ARRAY || element.holder == THREAD) {
       "${element.holder.name.toLowerCase(Locale.US)} "
     } else ""
-  val simpleClassName = element.getSimpleClassName()
+  val simpleClassName = element.simpleClassName
   val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
   val exclusionString =
     if (element.exclusion != null) " , matching exclusion ${element.exclusion.matching}" else ""
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt
index 506db68f7..fbf8c2eb9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidReachabilityInspectors.kt
@@ -21,8 +21,10 @@ import android.app.Dialog
 import android.app.Fragment
 import android.os.MessageQueue
 import android.view.View
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import java.util.ArrayList
+import kotlin.reflect.KClass
 
 /**
  * A set of default [Reachability.Inspector]s that knows about common AOSP and library
@@ -64,135 +66,152 @@ enum class AndroidReachabilityInspectors(private val inspectorClass: Class<out R
   TOAST_TN(ToastTnInspector::class.java);
 
   class ViewInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      if (!element.isInstanceOf(View::class.java)) {
-        return Reachability.unknown()
-      }
-
-      val mParent = element.getFieldReferenceValue("mParent") ?: return Reachability.unknown()
-
-      // This skips edge cases like Toast$TN.mNextView holding on to an unattached and uparented
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(View::class) { instance ->
+      // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
       // next toast view
-      if (mParent == "null") {
-        return Reachability.unknown()
+      if (instance["mParent"].reference == null) {
+        Reachability.unknown()
+      } else if (!instance.hasField("mAttachInfo")) {
+        Reachability.unknown()
+      } else if (instance["mAttachInfo"].reference == null) {
+        Reachability.unreachable("View#mAttachInfo is null")
+      } else {
+        Reachability.reachable("View#mAttachInfo is not null")
       }
-
-      return unreachableWhen(
-          element, View::class.java.name, "mAttachInfo", "null"
-      )
     }
   }
 
   class ActivityInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return unreachableWhen(
-          element, Activity::class.java.name, "mDestroyed", "true"
-      )
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(Activity::class) { instance ->
+      instance.unreachableWhenTrue("mDestroyed")
     }
   }
 
   class DialogInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return unreachableWhen(
-          element, Dialog::class.java.name, "mDecor", "null"
-      )
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(Dialog::class) { instance ->
+      instance.unreachableWhenNull("mDecor")
     }
   }
 
   class ApplicationInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return if (element.isInstanceOf(Application::class.java)) {
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = with(parser) {
+      return if (node.instance.objectRecord.isInstanceOf(Application::class)) {
         Reachability.reachable("Application is a singleton")
       } else Reachability.unknown()
     }
   }
 
   class ClassloaderInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return if (element.isInstanceOf(ClassLoader::class.java)) {
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = with(parser) {
+      return if (node.instance.objectRecord.isInstanceOf(ClassLoader::class)) {
         Reachability.reachable("Classloader always reachable")
       } else Reachability.unknown()
     }
   }
 
   class ClassInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      val reference = element.reference
-      return if (reference != null && reference.type == STATIC_FIELD) {
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = with(parser) {
+      return if (node.instance.objectRecord is ClassDumpRecord) {
         Reachability.reachable("a class is always reachable")
       } else Reachability.unknown()
     }
   }
 
   class FragmentInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return unreachableWhen(
-          element, Fragment::class.java.name, "mFragmentManager", "null"
-      )
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(Fragment::class) { instance ->
+      instance.unreachableWhenNull("mFragmentManager")
     }
   }
 
   class SupportFragmentInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return unreachableWhen(
-          element, "android.support.v4.app.Fragment", "mFragmentManager", "null"
-      )
-    }
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability =
+      (parser to node).instanceOfOrUnknown("android.support.v4.app.Fragment") { instance ->
+        instance.unreachableWhenNull("mFragmentManager")
+      }
   }
 
   class MessageQueueInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      if (!element.isInstanceOf(MessageQueue::class.java)) {
-        return Reachability.unknown()
-      }
-      val mQuitting = element.getFieldReferenceValue("mQuitting")
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(MessageQueue::class) { instance ->
       // If the queue is not quitting, maybe it should actually have been, we don't know.
       // However, if it's quitting, it is very likely that's not a bug.
-      return if ("true" == mQuitting) {
-        Reachability.unreachable("MessageQueue#mQuitting is true")
-      } else Reachability.unknown()
+      when (instance["mQuitting"].boolean) {
+        true -> Reachability.unreachable("MessageQueue#mQuitting is true")
+        else -> Reachability.unknown()
+      }
     }
   }
 
   class MortarPresenterInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      if (!element.isInstanceOf("mortar.Presenter")) {
-        return Reachability.unknown()
-      }
-      val view = element.getFieldReferenceValue("view")
-
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown("mortar.Presenter") { instance ->
       // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
       // should be a unreachable, so in that case we don't know their reachability status. However,
       // when the view is null, we're pretty sure they should be unreachable.
-      return if ("null" == view) {
+      if (instance["view"].isNullReference) {
         Reachability.unreachable("Presenter#view is null")
-      } else Reachability.unknown()
+      } else {
+        Reachability.unknown()
+      }
     }
   }
 
   class MainThreadInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      if (!element.isInstanceOf(Thread::class.java)) {
-        return Reachability.unknown()
-      }
-      val name = element.getFieldReferenceValue("name")
-      return if ("main" == name) {
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown(Thread::class) { instance ->
+      if (instance["name"].reference.stringOrNull == "main") {
         Reachability.reachable("the main thread always runs")
-      } else Reachability.unknown()
+      } else {
+        Reachability.unknown()
+      }
     }
   }
 
   class WindowInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return unreachableWhen(
-          element, "android.view.Window", "mDestroyed", "true"
-      )
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = (parser to node).instanceOfOrUnknown("android.view.Window") { instance ->
+      instance.unreachableWhenTrue("mDestroyed")
     }
   }
 
   class ToastTnInspector : Reachability.Inspector {
-    override fun expectedReachability(element: LeakTraceElement): Reachability {
-      return if (element.isInstanceOf("android.widget.Toast\$TN")) {
+    override fun expectedReachability(
+      parser: HprofParser,
+      node: LeakNode
+    ): Reachability = with(parser) {
+      return if (node.instance.objectRecord.isInstanceOf("android.widget.Toast\$TN")) {
         Reachability.reachable("Toast.TN (Transient Notification) is always reachable")
       } else Reachability.unknown()
     }
@@ -207,36 +226,63 @@ enum class AndroidReachabilityInspectors(private val inspectorClass: Class<out R
       }
       return inspectorClasses
     }
+  }
+}
 
-    private fun unreachableWhen(
-      element: LeakTraceElement,
-      className: String,
-      fieldName: String,
-      unreachableValue: String
-    ): Reachability {
-      if (!element.isInstanceOf(className)) {
-        return Reachability.unknown()
-      }
-      val fieldValue = element.getFieldReferenceValue(fieldName) ?: return Reachability.unknown()
-      return if (fieldValue == unreachableValue) {
-        Reachability.unreachable(
-            simpleClassName(className) + "#" + fieldName + " is " + unreachableValue
-        )
-      } else {
-        Reachability.reachable(
-            simpleClassName(className) + "#" + fieldName + " is not " + unreachableValue
-        )
-      }
-    }
-
-    private fun simpleClassName(className: String): String {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) {
-        className
-      } else {
-        className.substring(separator + 1)
-      }
-    }
+inline fun Pair<HprofParser, LeakNode>.instanceOfOrUnknown(
+  expectedClass: KClass<out Any>,
+  block: HprofParser.(HydratedInstance) -> Reachability
+): Reachability = instanceOfOrUnknown(expectedClass.java.name, block)
+
+inline fun Pair<HprofParser, LeakNode>.instanceOfOrUnknown(
+  className: String,
+  block: HprofParser.(HydratedInstance) -> Reachability
+): Reachability = this.instanceOf(className)?.let { first.block(it) } ?: Reachability.unknown()
+
+fun Pair<HprofParser, LeakNode>.instanceOf(expectedClass: KClass<out Any>) =
+  instanceOf(expectedClass.java.name)
+
+fun Pair<HprofParser, LeakNode>.instanceOf(className: String): HydratedInstance? = with(first) {
+  val record = second.instance.objectRecord
+  if (!record.isInstanceOf(className)) {
+    null
+  } else {
+    hydrateInstance(record as InstanceDumpRecord)
   }
+}
 
+fun HydratedInstance.unreachableWhenNull(
+  fieldName: String
+): Reachability {
+  val className = classHierarchy[0].simpleClassName
+  if (!hasField(fieldName)) {
+    return Reachability.unknown()
+  }
+  val value = this[fieldName].reference
+
+  return if (value == null) {
+    Reachability.unreachable(
+        "$className#$fieldName is null"
+    )
+  } else {
+    Reachability.reachable(
+        "$className#$fieldName is not null"
+    )
+  }
 }
+
+fun HydratedInstance.unreachableWhenTrue(
+  fieldName: String
+): Reachability {
+  val className = classHierarchy[0].simpleClassName
+
+  return when (this[fieldName].boolean) {
+    null -> Reachability.unknown()
+    true -> Reachability.unreachable(
+        "$className#$fieldName is true"
+    )
+    false -> Reachability.reachable(
+        "$className#$fieldName is false"
+    )
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 298ff9493..89da8f5cf 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -216,7 +216,7 @@ internal class DisplayLeakAdapter private constructor(
   ): Spanned {
 
     val packageEnd = element.className.lastIndexOf('.')
-    var simpleName = element.getSimpleClassName()
+    var simpleName = element.simpleClassName
     simpleName = simpleName.replace("[]", "[ ]")
     val styledClassName = "<font color='$classNameColorHexString'>$simpleName</font>"
 
@@ -255,7 +255,7 @@ internal class DisplayLeakAdapter private constructor(
         referenceName = "<i>$referenceName</i>"
       }
 
-      htmlString +=  "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
+      htmlString += "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
     }
 
     val exclusion = element.exclusion
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index a2289f4b2..136702313 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -28,6 +28,9 @@ internal object HeapAnalysisTable {
         object BLOB
         )"""
 
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS heap_analysis"
+
   fun insert(
     db: SQLiteDatabase,
     heapAnalysis: HeapAnalysis
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index 6f331332d..bad78f9ff 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -33,6 +33,9 @@ internal object LeakingInstanceTable {
         on leaking_instance (group_hash)
     """
 
+  @Language("RoomSql")
+  const val drop = "DROP TABLE IF EXISTS leaking_instance"
+
   fun insert(
     db: SQLiteDatabase,
     heapAnalysisId: Long,
@@ -261,7 +264,7 @@ internal object LeakingInstanceTable {
     } else {
       val element = leakTrace.leakCauses.first()
       val referenceName = element.reference!!.groupingName
-      element.getSimpleClassName() + "." + referenceName
+      element.simpleClassName + "." + referenceName
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 37588cf9a..a3bdc884b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -5,7 +5,7 @@ import android.database.sqlite.SQLiteDatabase
 import android.database.sqlite.SQLiteOpenHelper
 
 internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
-    context, "leaks.db", null, 1
+    context, "leaks.db", null, VERSION
 ) {
 
   override fun onCreate(db: SQLiteDatabase) {
@@ -19,6 +19,13 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
     oldVersion: Int,
     newVersion: Int
   ) {
-    TODO("Upgrade not needed yet")
+    db.execSQL(HeapAnalysisTable.drop)
+    db.execSQL(LeakingInstanceTable.drop)
+    onCreate(db)
+  }
+
+  companion object {
+    // Last updated for 2.0-alpha-2
+    private const val VERSION = 2
   }
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
index 901ab2a37..3178c4795 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
@@ -1,5 +1,15 @@
 package leakcanary
 
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+
 sealed class HeapValue {
   data class ObjectReference(val value: Long) : HeapValue() {
     val isNull
@@ -14,4 +24,61 @@ sealed class HeapValue {
   data class ShortValue(val value: Short) : HeapValue()
   data class IntValue(val value: Int) : HeapValue()
   data class LongValue(val value: Long) : HeapValue()
-}
\ No newline at end of file
+}
+
+val HeapValue?.isNullReference
+  get() = this is ObjectReference && isNull
+
+val HeapValue?.reference
+  get() = if (this is ObjectReference && !isNull) {
+    this.value
+  } else
+    null
+
+val HeapValue?.boolean
+  get() = if (this is BooleanValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.char
+  get() = if (this is CharValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.float
+  get() = if (this is FloatValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.double
+  get() = if (this is DoubleValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.byte
+  get() = if (this is ByteValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.short
+  get() = if (this is ShortValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.int
+  get() = if (this is IntValue) {
+    this.value
+  } else
+    null
+
+val HeapValue?.long
+  get() = if (this is LongValue) {
+    this.value
+  } else
+    null
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index 1fc7003b4..ab6a0ca53 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -27,6 +27,7 @@ import leakcanary.HprofReader.Companion.SHORT_SIZE
 import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
 import leakcanary.ObjectIdMetadata.INSTANCE
 import leakcanary.ObjectIdMetadata.INTERNAL_MAYBE_EMPTY_INSTANCE
+import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpEndRecord
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
@@ -50,8 +51,8 @@ import okio.source
 import java.io.Closeable
 import java.io.File
 import java.nio.charset.Charset
-import kotlin.math.pow
 import kotlin.properties.Delegates.notNull
+import kotlin.reflect.KClass
 
 /**
  * A memory efficient heap dump parser.
@@ -807,6 +808,30 @@ class HprofParser private constructor(
     }
   }
 
+  val Long.objectRecord: ObjectRecord get() = retrieveRecordById(this)
+
+  val Long?.stringOrNull: String?
+    get() = if (this == null) {
+      null
+    } else {
+      val record = retrieveRecordById(this)
+      if (record is InstanceDumpRecord && objectIdMetadata(record.classId) == STRING) {
+        val instance = hydrateInstance(record)
+        instanceAsString(instance)
+      } else {
+        null
+      }
+    }
+
+  fun ObjectRecord.isInstanceOf(expectedClass: KClass<out Any>) =
+    isInstanceOf(expectedClass.java.name)
+
+  fun ObjectRecord.isInstanceOf(className: String): Boolean {
+    return if (this is InstanceDumpRecord) {
+      hydrateClassHierarchy(this.classId).any { it.className == className }
+    } else false
+  }
+
   companion object {
     const val STRING_IN_UTF8 = 0x01
     const val LOAD_CLASS = 0x02
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
index 383ed5c8d..d1e6fed73 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
@@ -43,4 +43,14 @@ class HydratedClass(
     }
     return false
   }
+
+  val simpleClassName: String
+    get() {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
index 31bc0adf6..87affe41f 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
@@ -21,15 +21,17 @@ class HydratedInstance(
       hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
         if (fieldName == name) {
           val fieldValue = fieldValues[classIndex][fieldIndex]
-          if (fieldValue is T) {
-            return fieldValue
-          } else return null
+          return if (fieldValue is T) {
+            fieldValue
+          } else null
         }
       }
     }
     return null
   }
 
+  operator fun get(name: String): HeapValue? = fieldValueOrNull(name)
+
   fun hasField(name: String): Boolean {
     classHierarchy.forEach { hydratedClass ->
       hydratedClass.fieldNames.forEach { fieldName ->
