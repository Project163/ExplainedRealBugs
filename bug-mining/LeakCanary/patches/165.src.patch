diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
deleted file mode 100644
index 404ea845f..000000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ /dev/null
@@ -1,124 +0,0 @@
-package leakcanary
-
-import android.app.Activity
-import android.app.Application
-import android.os.Bundle
-import android.os.Looper
-import android.os.MessageQueue
-import android.view.View
-import androidx.test.core.app.ApplicationProvider.getApplicationContext
-import androidx.test.rule.ActivityTestRule
-import leakcanary.TestUtils.assertLeak
-import org.junit.After
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
-import java.util.concurrent.CountDownLatch
-
-class FragmentLeakTest {
-
-  @get:Rule
-  var activityRule = ActivityTestRule(
-      TestActivity::class.java, !TOUCH_MODE, !LAUNCH_ACTIVITY
-  )
-
-  @Before fun setUp() {
-    AppWatcher.objectWatcher
-        .clearWatchedObjects()
-  }
-
-  @After fun tearDown() {
-    AppWatcher.objectWatcher
-        .clearWatchedObjects()
-  }
-
-  @Test
-  fun fragmentShouldLeak() {
-    startActivityAndWaitForCreate()
-
-    LeakingFragment.add(activityRule.activity)
-
-    val waitForFragmentDetach = activityRule.activity.waitForFragmentDetached()
-    val waitForActivityDestroy = waitForActivityDestroy()
-    activityRule.finishActivity()
-    waitForFragmentDetach.await()
-    waitForActivityDestroy.await()
-
-    assertLeak(LeakingFragment::class.java)
-  }
-
-  @Test
-  fun fragmentViewShouldLeak() {
-    startActivityAndWaitForCreate()
-    val activity = activityRule.activity
-
-    val waitForFragmentViewDestroyed = activity.waitForFragmentViewDestroyed()
-    // First, add a new fragment
-    ViewLeakingFragment.addToBackstack(activity)
-    // Then, add a new fragment again, which destroys the view of the previous fragment and puts
-    // that fragment in the backstack.
-    ViewLeakingFragment.addToBackstack(activity)
-    waitForFragmentViewDestroyed.await()
-
-    assertLeak(View::class.java)
-  }
-
-  private fun startActivityAndWaitForCreate() {
-    val waitForActivityOnCreate = CountDownLatch(1)
-    val app = getApplicationContext<Application>()
-    app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
-      override fun onActivityCreated(
-        activity: Activity,
-        savedInstanceState: Bundle?
-      ) {
-        app.unregisterActivityLifecycleCallbacks(this)
-        waitForActivityOnCreate.countDown()
-      }
-    })
-
-    activityRule.launchActivity(null)
-
-    try {
-      waitForActivityOnCreate.await()
-    } catch (e: InterruptedException) {
-      throw RuntimeException(e)
-    }
-  }
-
-  private fun waitForActivityDestroy(): CountDownLatch {
-    val latch = CountDownLatch(1)
-    val countDownOnIdle = MessageQueue.IdleHandler {
-      latch.countDown()
-      false
-    }
-    val testActivity = activityRule.activity
-    testActivity.application.registerActivityLifecycleCallbacks(
-        object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
-          override fun onActivityDestroyed(activity: Activity) {
-            if (activity == testActivity) {
-              activity.application.unregisterActivityLifecycleCallbacks(this)
-              Looper.myQueue()
-                  .addIdleHandler(countDownOnIdle)
-            }
-          }
-        })
-    return latch
-  }
-
-  companion object {
-    private const val TOUCH_MODE = true
-    private const val LAUNCH_ACTIVITY = true
-
-    inline fun <reified T : Any> noOpDelegate(): T {
-      val javaClass = T::class.java
-      val noOpHandler = InvocationHandler { _, _, _ ->
-        // no op
-      }
-      return Proxy.newProxyInstance(
-          javaClass.classLoader, arrayOf(javaClass), noOpHandler
-      ) as T
-    }
-  }
-}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
deleted file mode 100644
index 87af731ac..000000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Fragments.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-package leakcanary
-
-import androidx.fragment.app.Fragment
-import androidx.fragment.app.FragmentActivity
-import androidx.fragment.app.FragmentManager
-import java.util.concurrent.CountDownLatch
-
-internal fun FragmentActivity.waitForFragmentDetached(): CountDownLatch {
-  val latch = CountDownLatch(1)
-  val fragmentManager = supportFragmentManager
-  fragmentManager.registerFragmentLifecycleCallbacks(
-      object : FragmentManager.FragmentLifecycleCallbacks() {
-        override fun onFragmentDetached(
-          fm: FragmentManager,
-          f: Fragment
-        ) {
-          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
-          latch.countDown()
-        }
-      }, false
-  )
-  return latch
-}
-
-internal fun FragmentActivity.waitForFragmentViewDestroyed(): CountDownLatch {
-  val latch = CountDownLatch(1)
-  val fragmentManager = supportFragmentManager
-  fragmentManager.registerFragmentLifecycleCallbacks(
-      object : FragmentManager.FragmentLifecycleCallbacks() {
-        override fun onFragmentViewDestroyed(
-          fm: FragmentManager,
-          f: Fragment
-        ) {
-          fragmentManager.unregisterFragmentLifecycleCallbacks(this)
-          latch.countDown()
-        }
-      }, false
-  )
-  return latch
-}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
deleted file mode 100644
index 316d11f15..000000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LeakingFragment.kt
+++ /dev/null
@@ -1,21 +0,0 @@
-package leakcanary
-
-import androidx.fragment.app.Fragment
-
-import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
-
-class LeakingFragment : Fragment() {
-  companion object {
-    fun add(activity: TestActivity) {
-      getInstrumentation().runOnMainSync {
-        leakingFragment = LeakingFragment()
-        activity.supportFragmentManager
-            .beginTransaction()
-            .add(0, leakingFragment)
-            .commitNow()
-      }
-    }
-
-    private lateinit var leakingFragment: LeakingFragment
-  }
-}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt
new file mode 100644
index 000000000..36590f6bf
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleLeaksTest.kt
@@ -0,0 +1,142 @@
+package leakcanary
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.ViewModel
+import com.squareup.leakcanary.instrumentation.test.R
+import leakcanary.TestUtils.assertLeak
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+
+class LifecycleLeaksTest : HasActivityTestRule<TestActivity> {
+
+  class TestViewModel : ViewModel()
+
+  class TestFragment : Fragment() {
+    override fun onCreateView(
+      inflater: LayoutInflater,
+      container: ViewGroup?,
+      savedInstanceState: Bundle?
+    ): View? {
+      return View(context)
+    }
+  }
+
+  @get:Rule
+  override val activityRule = activityTestRule<TestActivity>(
+      initialTouchMode = false,
+      launchActivity = false
+  )
+
+  @Before fun setUp() {
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
+  }
+
+  @After fun tearDown() {
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
+  }
+
+  @Test fun activityLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    activity retained {
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      assertLeak(TestActivity::class.java)
+    }
+  }
+
+  @Test fun activityViewModelLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val viewModel = getOnMainSync {
+      activity.installViewModel(TestViewModel::class)
+    }
+
+    viewModel retained {
+      triggersOnActivityDestroyed {
+        activityRule.finishActivity()
+      }
+      assertLeak(TestViewModel::class.java)
+    }
+  }
+
+  @Test fun fragmentViewModelLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val viewModel = getOnMainSync {
+      val fragment = Fragment()
+      activity.addFragmentNow(fragment)
+      val viewModel = fragment.installViewModel(TestViewModel::class)
+      activity.removeFragmentNow(fragment)
+      viewModel
+    }
+
+    viewModel retained {
+      assertLeak(TestViewModel::class.java)
+    }
+  }
+
+  @Test
+  fun fragmentLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val fragment = getOnMainSync {
+      val fragment = Fragment()
+      activity.addFragmentNow(fragment)
+      activity.removeFragmentNow(fragment)
+      fragment
+    }
+
+    fragment retained {
+      assertLeak(Fragment::class.java)
+    }
+  }
+
+  @Test
+  fun fragmentViewLeakDetected() {
+    triggersOnActivityCreated {
+      activityRule.launchActivity(null)
+    }
+
+    val fragment = triggersOnFragmentCreated {
+      getOnMainSync {
+        val fragment = TestFragment()
+        activity.replaceWithBackStack(fragment, R.id.fragments)
+        fragment
+      }
+    }
+
+    val fragmentView = getOnMainSync {
+      fragment.view!!
+    }
+
+    triggersOnFragmentViewDestroyed {
+      runOnMainSync {
+        // Add a new fragment again, which destroys the view of the previous fragment and puts
+        // the first fragment in the backstack.
+        activity.replaceWithBackStack(Fragment(), R.id.fragments)
+      }
+    }
+
+    fragmentView retained {
+      assertLeak(View::class.java)
+    }
+  }
+}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
new file mode 100644
index 000000000..19340d5a4
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/LifecycleTestUtils.kt
@@ -0,0 +1,175 @@
+package leakcanary
+
+import android.app.Activity
+import android.app.Application
+import android.os.Bundle
+import android.os.Looper
+import androidx.annotation.IdRes
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentActivity
+import androidx.fragment.app.FragmentManager
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.ViewModelProvider.Factory
+import androidx.lifecycle.ViewModelStoreOwner
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.rule.ActivityTestRule
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.atomic.AtomicReference
+import kotlin.reflect.KClass
+
+interface HasActivityTestRule<T : Activity> {
+  val activityRule: ActivityTestRule<T>
+
+  val activity
+    get() = activityRule.activity!!
+}
+
+inline fun <reified T : Activity> activityTestRule(
+  initialTouchMode: Boolean,
+  launchActivity: Boolean
+): ActivityTestRule<T> = ActivityTestRule(
+    T::class.java, initialTouchMode, launchActivity
+)
+
+fun <R> triggersOnActivityCreated(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val app = ApplicationProvider.getApplicationContext<Application>()
+    app.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        app.unregisterActivityLifecycleCallbacks(this)
+        triggered()
+      }
+    })
+  }
+}
+
+infix fun Any.retained(block: () -> Unit) {
+  block()
+  "" + this
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnActivityDestroyed(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val testActivity = activity
+    testActivity.application.registerActivityLifecycleCallbacks(
+        object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+          override fun onActivityDestroyed(activity: Activity) {
+            if (activity == testActivity) {
+              activity.application.unregisterActivityLifecycleCallbacks(this)
+              Looper.myQueue()
+                  .addIdleHandler {
+                    triggered()
+                    false
+                  }
+            }
+          }
+        })
+  }
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnFragmentCreated(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val fragmentManager = activity.supportFragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(
+        object : FragmentManager.FragmentLifecycleCallbacks() {
+          override fun onFragmentCreated(
+            fm: FragmentManager,
+            fragment: Fragment,
+            savedInstanceState: Bundle?
+          ) {
+            fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+            triggered()
+          }
+        }, false
+    )
+  }
+}
+
+fun <T : FragmentActivity, R> HasActivityTestRule<T>.triggersOnFragmentViewDestroyed(block: () -> R): R {
+  return waitForTriggered(block) { triggered ->
+    val fragmentManager = activity.supportFragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(
+        object : FragmentManager.FragmentLifecycleCallbacks() {
+          override fun onFragmentViewDestroyed(
+            fm: FragmentManager,
+            fragment: Fragment
+          ) {
+            fragmentManager.unregisterFragmentLifecycleCallbacks(this)
+            triggered()
+          }
+        }, false
+    )
+  }
+}
+
+fun <R> waitForTriggered(
+  trigger: () -> R,
+  triggerListener: (triggered: () -> Unit) -> Unit
+): R {
+  val latch = CountDownLatch(1)
+  triggerListener {
+    latch.countDown()
+  }
+  val result = trigger()
+  latch.await()
+  return result
+}
+
+inline fun <reified T : Any> noOpDelegate(): T {
+  val javaClass = T::class.java
+  val noOpHandler = InvocationHandler { _, _, _ ->
+    // no op
+  }
+  return Proxy.newProxyInstance(
+      javaClass.classLoader, arrayOf(javaClass), noOpHandler
+  ) as T
+}
+
+fun <T> getOnMainSync(block: () -> T): T {
+  val resultHolder = AtomicReference<T>()
+  val latch = CountDownLatch(1)
+  InstrumentationRegistry.getInstrumentation()
+      .runOnMainSync {
+        resultHolder.set(block())
+        latch.countDown()
+      }
+  latch.await()
+  return resultHolder.get()
+}
+
+fun runOnMainSync(block: () -> Unit) = InstrumentationRegistry.getInstrumentation()
+    .runOnMainSync(block)
+
+fun <T : ViewModel> ViewModelStoreOwner.installViewModel(modelClass: KClass<T>): T =
+  ViewModelProvider(this, object : Factory {
+    override fun <T : ViewModel> create(modelClass: Class<T>): T = modelClass.newInstance()
+  }).get(modelClass.java)
+
+fun FragmentActivity.addFragmentNow(fragment: Fragment) {
+  supportFragmentManager
+      .beginTransaction()
+      .add(0, fragment)
+      .commitNow()
+}
+
+fun FragmentActivity.replaceWithBackStack(fragment: Fragment, @IdRes containerViewId: Int) {
+  supportFragmentManager
+      .beginTransaction()
+      .addToBackStack(null)
+      .replace(containerViewId, fragment)
+      .commit()
+}
+
+fun FragmentActivity.removeFragmentNow(fragment: Fragment) {
+  supportFragmentManager
+      .beginTransaction()
+      .remove(fragment)
+      .commitNow()
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
deleted file mode 100644
index 0ad9fd426..000000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ViewLeakingFragment.kt
+++ /dev/null
@@ -1,41 +0,0 @@
-package leakcanary
-
-import android.os.Bundle
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import androidx.fragment.app.Fragment
-import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
-import com.squareup.leakcanary.instrumentation.test.R
-
-class ViewLeakingFragment : Fragment() {
-
-  private var leakingView: View? = null
-
-  override fun onCreateView(
-    inflater: LayoutInflater,
-    container: ViewGroup?,
-    savedInstanceState: Bundle?
-  ) = View(container?.context)
-
-  override fun onViewCreated(
-    view: View,
-    savedInstanceState: Bundle?
-  ) {
-    // Leak: this fragment will stay in memory after being replaced, leakingView should be cleared
-    // onDestroyView()
-    leakingView = view
-  }
-
-  companion object {
-    fun addToBackstack(activity: TestActivity) {
-      getInstrumentation().runOnMainSync {
-        activity.supportFragmentManager
-            .beginTransaction()
-            .addToBackStack(null)
-            .replace(R.id.fragments, ViewLeakingFragment())
-            .commit()
-      }
-    }
-  }
-}
diff --git a/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
index 7f67c8b27..6160db8a9 100644
--- a/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
+++ b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
@@ -1,2 +1,4 @@
 # AndroidXFragmentDestroyWatcher is loaded via reflection
 -keep class leakcanary.internal.AndroidXFragmentDestroyWatcher { *; }
+# ViewModelClearedWatcher reaches into ViewModelStore using reflection.
+-keep class androidx.lifecycle.ViewModelStore { *; }
diff --git a/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index 892396b68..0792fe236 100644
--- a/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -16,6 +16,7 @@
 package leakcanary.internal
 
 import android.app.Activity
+import android.os.Bundle
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
@@ -29,6 +30,14 @@ internal class AndroidXFragmentDestroyWatcher(
 
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
+    override fun onFragmentCreated(
+      fm: FragmentManager,
+      fragment: Fragment,
+      savedInstanceState: Bundle?
+    ) {
+      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)
+    }
+
     override fun onFragmentViewDestroyed(
       fm: FragmentManager,
       fragment: Fragment
@@ -58,6 +67,7 @@ internal class AndroidXFragmentDestroyWatcher(
     if (activity is FragmentActivity) {
       val supportFragmentManager = activity.supportFragmentManager
       supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)
     }
   }
 }
diff --git a/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt
new file mode 100644
index 000000000..52a71299c
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/ViewModelClearedWatcher.kt
@@ -0,0 +1,64 @@
+package leakcanary.internal
+
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.ViewModelProvider.Factory
+import androidx.lifecycle.ViewModelStore
+import androidx.lifecycle.ViewModelStoreOwner
+import leakcanary.AppWatcher.Config
+import leakcanary.ObjectWatcher
+import leakcanary.internal.ViewModelClearedWatcher.Companion.install
+
+/**
+ * [AndroidXFragmentDestroyWatcher] calls [install] to add a spy [ViewModel] in every
+ * [ViewModelStoreOwner] instance (i.e. FragmentActivity and Fragment). [ViewModelClearedWatcher]
+ * holds on to the map of [ViewModel]s backing its store. When [ViewModelClearedWatcher] receives
+ * the [onCleared] callback, it adds each live [ViewModel] from the store to the [ObjectWatcher].
+ */
+internal class ViewModelClearedWatcher(
+  storeOwner: ViewModelStoreOwner,
+  private val objectWatcher: ObjectWatcher,
+  private val configProvider: () -> Config
+) : ViewModel() {
+
+  private val viewModelMap: Map<String, ViewModel>?
+
+  init {
+    // We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,
+    // however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0
+    // does not have ViewModelStore#keys. All versions currently have the mMap field.
+    viewModelMap = try {
+      val mMapField = ViewModelStore::class.java.getDeclaredField("mMap")
+      mMapField.isAccessible = true
+      @Suppress("UNCHECKED_CAST")
+      mMapField[storeOwner.viewModelStore] as Map<String, ViewModel>
+    } catch (ignored: Exception) {
+      null
+    }
+  }
+
+  override fun onCleared() {
+    if (viewModelMap != null && configProvider().watchViewModels) {
+      viewModelMap.values.forEach { viewModel ->
+        objectWatcher.watch(
+            viewModel, "${viewModel::class.java.name} received ViewModel#onCleared() callback"
+        )
+      }
+    }
+  }
+
+  companion object {
+    fun install(
+      storeOwner: ViewModelStoreOwner,
+      objectWatcher: ObjectWatcher,
+      configProvider: () -> Config
+    ) {
+      val provider = ViewModelProvider(storeOwner, object : Factory {
+        @Suppress("UNCHECKED_CAST")
+        override fun <T : ViewModel?> create(modelClass: Class<T>): T =
+          ViewModelClearedWatcher(storeOwner, objectWatcher, configProvider) as T
+      })
+      provider.get(ViewModelClearedWatcher::class.java)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
index bbac866ae..227406afd 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
@@ -43,6 +43,14 @@ object AppWatcher {
      */
     val watchFragmentViews: Boolean = true,
 
+    /**
+     * Whether AppWatcher should automatically watch cleared [androidx.lifecycle.ViewModel]
+     * instances.
+     *
+     * Defaults to true.
+     */
+    val watchViewModels: Boolean = true,
+
     /**
      * How long to wait before reporting a watched object as retained.
      *
