diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index a1c52b4f1..094f506f8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -53,7 +53,8 @@ internal class HeapAnalyzerService : ForegroundService(
     // Since we're running in the main process we should be careful not to impact it.
     Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
     val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File
-    val heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS, -1)
+    val heapDumpReason = intent.getStringExtra(HEAPDUMP_REASON_EXTRA)
+    val heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, -1)
 
     val config = LeakCanary.config
     val heapAnalysis = if (heapDumpFile.exists()) {
@@ -62,7 +63,10 @@ internal class HeapAnalyzerService : ForegroundService(
       missingFileFailure(heapDumpFile)
     }
     val fullHeapAnalysis = when (heapAnalysis) {
-      is HeapAnalysisSuccess -> heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)
+      is HeapAnalysisSuccess -> heapAnalysis.copy(
+        dumpDurationMillis = heapDumpDurationMillis,
+        metadata = heapAnalysis.metadata + ("Heap dump reason" to heapDumpReason)
+      )
       is HeapAnalysisFailure -> heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)
     }
     onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
@@ -118,18 +122,21 @@ internal class HeapAnalyzerService : ForegroundService(
 
   companion object {
     private const val HEAPDUMP_FILE_EXTRA = "HEAPDUMP_FILE_EXTRA"
-    private const val HEAPDUMP_DURATION_MILLIS = "HEAPDUMP_DURATION_MILLIS"
+    private const val HEAPDUMP_DURATION_MILLIS_EXTRA = "HEAPDUMP_DURATION_MILLIS_EXTRA"
+    private const val HEAPDUMP_REASON_EXTRA = "HEAPDUMP_REASON_EXTRA"
     private const val PROGUARD_MAPPING_FILE_NAME = "leakCanaryObfuscationMapping.txt"
 
     fun runAnalysis(
       context: Context,
       heapDumpFile: File,
-      heapDumpDurationMillis: Long? = null
+      heapDumpDurationMillis: Long? = null,
+      heapDumpReason: String = "Unknown"
     ) {
       val intent = Intent(context, HeapAnalyzerService::class.java)
       intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
+      intent.putExtra(HEAPDUMP_REASON_EXTRA, heapDumpReason)
       heapDumpDurationMillis?.let {
-        intent.putExtra(HEAPDUMP_DURATION_MILLIS, heapDumpDurationMillis)
+        intent.putExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, heapDumpDurationMillis)
       }
       startForegroundService(context, intent)
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 2f7464e16..c4421e96d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -146,12 +146,18 @@ internal class HeapDumpTrigger(
     }
 
     dismissRetainedCountNotification()
-    dumpHeap(retainedReferenceCount, retry = true)
+    val visibility = if (applicationVisible) "visible" else "not visible"
+    dumpHeap(
+      retainedReferenceCount = retainedReferenceCount,
+      retry = true,
+      reason = "$retainedReferenceCount retained objects, app is $visibility"
+    )
   }
 
   private fun dumpHeap(
     retainedReferenceCount: Int,
-    retry: Boolean
+    retry: Boolean,
+    reason: String
   ) {
     saveResourceIdNamesToMemory()
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
@@ -180,7 +186,8 @@ internal class HeapDumpTrigger(
         HeapAnalyzerService.runAnalysis(
           context = application,
           heapDumpFile = heapDumpResult.file,
-          heapDumpDurationMillis = heapDumpResult.durationMillis
+          heapDumpDurationMillis = heapDumpResult.durationMillis,
+          heapDumpReason = reason
         )
       }
     }
@@ -238,7 +245,7 @@ internal class HeapDumpTrigger(
       }
 
       SharkLog.d { "Dumping the heap because user requested it" }
-      dumpHeap(retainedReferenceCount, retry = false)
+      dumpHeap(retainedReferenceCount, retry = false, "user request")
     }
   }
 
diff --git a/shark-android/src/main/java/shark/AndroidResourceIdNames.kt b/shark-android/src/main/java/shark/AndroidResourceIdNames.kt
index c5e18a469..b60e50353 100644
--- a/shark-android/src/main/java/shark/AndroidResourceIdNames.kt
+++ b/shark-android/src/main/java/shark/AndroidResourceIdNames.kt
@@ -79,8 +79,14 @@ class AndroidResourceIdNames private constructor(
         holderClass?.let {
           val holderField = holderClass["holderField"]!!
           holderField.valueAsInstance?.let { instance ->
+            println(instance.instanceClassName)
+            instance.readFields().forEach {
+              println("${it.name}=${it.value.holder}")
+            }
+            val resourceIdsField = instance[className, "resourceIds"]!!
+            val resourceIdsArray = resourceIdsField.valueAsPrimitiveArray!!
             val resourceIds =
-              (instance[className, "resourceIds"]!!.valueAsPrimitiveArray!!.readRecord() as IntArrayDump).array
+              (resourceIdsArray.readRecord() as IntArrayDump).array
             val names = instance[className, "names"]!!.valueAsObjectArray!!.readElements()
               .map { it.readAsJavaString()!! }
               .toList()
