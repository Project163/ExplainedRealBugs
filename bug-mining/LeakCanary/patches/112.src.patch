diff --git a/build.gradle b/build.gradle
index fc5d06c7a..651eafbd5 100644
--- a/build.gradle
+++ b/build.gradle
@@ -66,10 +66,6 @@ subprojects {
 
   dokka {
     reportUndocumented = false
-    packageOptions {
-      prefix = "leakcanary.internal"
-      suppress = true
-    }
     // BuildConfig files
     packageOptions {
       prefix = "com.squareup.leakcanary"
diff --git a/docs/theme/main.html b/docs/theme/main.html
index 9843940bb..c7a685756 100644
--- a/docs/theme/main.html
+++ b/docs/theme/main.html
@@ -2,7 +2,11 @@
 
 {% block content %}
                 {% if page.edit_url %}
-				<span style="float: right">ðŸ¤”Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a> </span>
+				  {% if "/api/" in page.edit_url %}
+				<span style="float: right">ðŸ¤” Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report it</a></span>
+                  {% else %}
+				<span style="float: right">ðŸ¤” Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a></span>
+                  {% endif %}
                 {% endif %}
                 {% if not "\x3ch1" in page.content %}
                   <h1>{{ page.title | default(config.site_name, true)}}</h1>
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 17655635a..0c417b48a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -31,7 +31,7 @@ import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 290c12281..be4be031e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -17,10 +17,13 @@ import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
+import leakcanary.OnInstanceRetainedListener
 import leakcanary.internal.activity.LeakActivity
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.atomic.AtomicReference
 
-internal object InternalLeakCanary : LeakSentryListener {
+internal object InternalLeakCanary : (Application) -> Unit, OnInstanceRetainedListener {
 
   private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
 
@@ -47,7 +50,7 @@ internal object InternalLeakCanary : LeakSentryListener {
         dumpHeap = false, referenceMatchers = emptyList(), objectInspectors = emptyList()
     )
 
-  override fun onLeakSentryInstalled(application: Application) {
+  override fun invoke(application: Application) {
     this.application = application
 
     val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
@@ -217,5 +220,15 @@ internal object InternalLeakCanary : LeakSentryListener {
     }
   }
 
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
   private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
index ca214b51f..72dca8a30 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -2,7 +2,7 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index f8513a609..bb5beb058 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -9,11 +9,12 @@ import android.view.View
 import androidx.test.core.app.ApplicationProvider.getApplicationContext
 import androidx.test.rule.ActivityTestRule
 import leakcanary.TestUtils.assertLeak
-import leakcanary.internal.InternalHelper.noOpDelegate
 import org.junit.After
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.CountDownLatch
 
 class FragmentLeakTest {
@@ -109,5 +110,15 @@ class FragmentLeakTest {
   companion object {
     private const val TOUCH_MODE = true
     private const val LAUNCH_ACTIVITY = true
+
+    inline fun <reified T : Any> noOpDelegate(): T {
+      val javaClass = T::class.java
+      val noOpHandler = InvocationHandler { _, _, _ ->
+        // no op
+      }
+      return Proxy.newProxyInstance(
+          javaClass.classLoader, arrayOf(javaClass), noOpHandler
+      ) as T
+    }
   }
 }
diff --git a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index d12efa0ca..3c579c0b8 100644
--- a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
+++ b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -19,13 +19,13 @@ import android.app.Activity
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
+import leakcanary.RefWatcher
 
 internal class AndroidXFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
+) : (Activity) -> Unit {
 
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
@@ -49,7 +49,7 @@ internal class AndroidXFragmentDestroyWatcher(
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     if (activity is FragmentActivity) {
       val supportFragmentManager = activity.supportFragmentManager
       supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index aec2cc7c1..522b17855 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -19,7 +19,7 @@ import android.app.Activity
 import android.app.Application
 import leakcanary.LeakSentry.Config
 import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
   private val refWatcher: RefWatcher,
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index dd2f7d4aa..ba14af118 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -28,8 +28,7 @@ import leakcanary.RefWatcher
 internal class AndroidOFragmentDestroyWatcher(
   private val refWatcher: RefWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
-
+) : (Activity) -> Unit {
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
     override fun onFragmentViewDestroyed(
@@ -52,7 +51,7 @@ internal class AndroidOFragmentDestroyWatcher(
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     val fragmentManager = activity.fragmentManager
     fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 9cbe23e9d..a13093b4f 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -22,67 +22,63 @@ import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
 import leakcanary.LeakSentry
 import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 /**
  * Internal class used to watch for fragments leaks.
  */
-interface FragmentDestroyWatcher {
+internal object FragmentDestroyWatcher {
 
-  fun watchFragments(activity: Activity)
+  private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+    "leakcanary.internal.AndroidXFragmentDestroyWatcher"
 
-  companion object {
+  fun install(
+    application: Application,
+    refWatcher: RefWatcher,
+    configProvider: () -> LeakSentry.Config
+  ) {
+    val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
 
-    private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
-    private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
-      "leakcanary.internal.AndroidXFragmentDestroyWatcher"
+    if (SDK_INT >= O) {
+      fragmentDestroyWatchers.add(
+          AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+      )
+    }
 
-    fun install(
-      application: Application,
-      refWatcher: RefWatcher,
-      configProvider: () -> LeakSentry.Config
+    if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
+        classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
     ) {
-      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+      val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+          .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
+      @kotlin.Suppress("UNCHECKED_CAST")
+      fragmentDestroyWatchers.add(
+          watcherConstructor.newInstance(refWatcher, configProvider) as (Activity) -> Unit
+      )
+    }
 
-      if (SDK_INT >= O) {
-        fragmentDestroyWatchers.add(
-            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
-        )
-      }
+    if (fragmentDestroyWatchers.size == 0) {
+      return
+    }
 
-      if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
-          classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
       ) {
-        val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
-            .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
-        fragmentDestroyWatchers.add(
-            watcherConstructor.newInstance(refWatcher, configProvider) as FragmentDestroyWatcher
-        )
-      }
-
-      if (fragmentDestroyWatchers.size == 0) {
-        return
-      }
-
-      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
-        override fun onActivityCreated(
-          activity: Activity,
-          savedInstanceState: Bundle?
-        ) {
-          for (watcher in fragmentDestroyWatchers) {
-            watcher.watchFragments(activity)
-          }
+        for (watcher in fragmentDestroyWatchers) {
+          watcher(activity)
         }
-      })
-    }
-
-    private fun classAvailable(className: String): Boolean {
-      return try {
-        Class.forName(className)
-        true
-      } catch (e: ClassNotFoundException) {
-        false
       }
+    })
+  }
+
+  private fun classAvailable(className: String): Boolean {
+    return try {
+      Class.forName(className)
+      true
+    } catch (e: ClassNotFoundException) {
+      false
     }
   }
 }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
deleted file mode 100644
index 64e05ead0..000000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-package leakcanary.internal
-
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
-
-/** Visible across several internal modules. */
-object InternalHelper {
-  inline fun <reified T : Any> noOpDelegate(): T {
-    val javaClass = T::class.java
-    val noOpHandler = InvocationHandler { _, _, _ ->
-      // no op
-    }
-    return Proxy.newProxyInstance(
-        javaClass.classLoader, arrayOf(javaClass), noOpHandler
-    ) as T
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index d91fecaf1..414671102 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -8,7 +8,10 @@ import android.os.SystemClock
 import leakcanary.CanaryLog
 import leakcanary.Clock
 import leakcanary.LeakSentry
+import leakcanary.OnInstanceRetainedListener
 import leakcanary.RefWatcher
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.Executor
 
 internal object InternalLeakSentry {
@@ -16,7 +19,8 @@ internal object InternalLeakSentry {
   val isInstalled
     get() = ::application.isInitialized
 
-  private val listener: LeakSentryListener
+  private val onLeakSentryInstalled: (Application) -> Unit
+  private val onInstanceRetainedListener: OnInstanceRetainedListener
 
   val isDebuggableBuild by lazy {
     (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
@@ -33,12 +37,16 @@ internal object InternalLeakSentry {
   private val mainHandler = Handler(Looper.getMainLooper())
 
   init {
-    listener = try {
+    val internalLeakCanary = try {
       val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
-      leakCanaryListener.getDeclaredField("INSTANCE").get(null) as LeakSentryListener
+      leakCanaryListener.getDeclaredField("INSTANCE")
+          .get(null)
     } catch (ignored: Throwable) {
-      LeakSentryListener.None
+      NoLeakCanary
     }
+    @kotlin.Suppress("UNCHECKED_CAST")
+    onLeakSentryInstalled = internalLeakCanary as (Application) -> Unit
+    onInstanceRetainedListener = internalLeakCanary as OnInstanceRetainedListener
   }
 
   private val checkRetainedExecutor = Executor {
@@ -47,7 +55,7 @@ internal object InternalLeakSentry {
   val refWatcher = RefWatcher(
       clock = clock,
       checkRetainedExecutor = checkRetainedExecutor,
-      onInstanceRetained = { listener.onReferenceRetained() },
+      onInstanceRetainedListener = onInstanceRetainedListener,
       isEnabled = { LeakSentry.config.enabled }
   )
 
@@ -60,13 +68,19 @@ internal object InternalLeakSentry {
     InternalLeakSentry.application = application
 
     val configProvider = { LeakSentry.config }
-    ActivityDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    FragmentDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    listener.onLeakSentryInstalled(application)
+    ActivityDestroyWatcher.install(application, refWatcher, configProvider)
+    FragmentDestroyWatcher.install(application, refWatcher, configProvider)
+    onLeakSentryInstalled(application)
+  }
+
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
   }
 
   private fun checkMainThread() {
@@ -76,4 +90,12 @@ internal object InternalLeakSentry {
       )
     }
   }
+
+  object NoLeakCanary : (Application) -> Unit, OnInstanceRetainedListener {
+    override fun invoke(application: Application) {
+    }
+
+    override fun onReferenceRetained() {
+    }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
deleted file mode 100644
index 362550b15..000000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-package leakcanary.internal
-
-import android.app.Application
-
-interface LeakSentryListener {
-  fun onLeakSentryInstalled(application: Application)
-  fun onReferenceRetained()
-
-  object None : LeakSentryListener {
-    override fun onLeakSentryInstalled(application: Application) {
-    }
-
-    override fun onReferenceRetained() {
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt b/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt
new file mode 100644
index 000000000..e401bc5e5
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/OnInstanceRetainedListener.kt
@@ -0,0 +1,6 @@
+package leakcanary
+
+interface OnInstanceRetainedListener {
+
+  fun onReferenceRetained()
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index 0cd4e8f1c..20731ebd5 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -26,7 +26,7 @@ import java.util.concurrent.Executor
 class RefWatcher constructor(
   private val clock: Clock,
   private val checkRetainedExecutor: Executor,
-  private val onInstanceRetained: () -> Unit,
+  private val onInstanceRetainedListener: OnInstanceRetainedListener,
   /**
    * Calls to [watch] will be ignored when [isEnabled] returns false
    */
@@ -127,7 +127,7 @@ class RefWatcher constructor(
     val retainedRef = watchedInstances[key]
     if (retainedRef != null) {
       retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onInstanceRetained()
+      onInstanceRetainedListener.onReferenceRetained()
     }
   }
 
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
index 2d76440b7..04c5063ab 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
@@ -7,7 +7,8 @@ import java.util.concurrent.Executor
 
 class RefWatcherTest {
 
-  private val onRefRetained: () -> Unit = {
+  private val onInstanceRetained = object: OnInstanceRetainedListener {
+    override fun onReferenceRetained() {}
   }
 
   private val checkRetainedExecutor: Executor = Executor {
@@ -18,7 +19,7 @@ class RefWatcherTest {
     override fun uptimeMillis(): Long {
       return time
     }
-  }, checkRetainedExecutor, onRefRetained)
+  }, checkRetainedExecutor, onInstanceRetained)
   var time: Long = 0
 
   var ref: Any? = Any()
