diff --git a/shark-graph/src/main/java/shark/internal/hppc/HHPC.kt b/shark-graph/src/main/java/shark/internal/hppc/HPPC.kt
similarity index 99%
rename from shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
rename to shark-graph/src/main/java/shark/internal/hppc/HPPC.kt
index fa801af16..30356637c 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/HPPC.kt
@@ -21,7 +21,7 @@ import java.util.Locale
 /**
  * Code from https://github.com/carrotsearch/hppc copy pasted, inlined and converted to Kotlin.
  */
-internal object HHPC {
+internal object HPPC {
 
   private const val PHI_C64 = -0x61c8864680b583ebL
 
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
index 09b6bb69f..ca13a44bb 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -257,7 +257,7 @@ internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
     assigned = 0
     hasEmptyKey = false
 
-    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
   }
 
   val size: Int
@@ -269,7 +269,7 @@ internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
     if (expectedElements > resizeAt) {
       val prevKeys = this.keys
       val prevValues = this.values
-      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
       if (!isEmpty) {
         rehash(prevKeys, prevValues)
       }
@@ -277,7 +277,7 @@ internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
   }
 
   private fun hashKey(key: Long): Int {
-    return HHPC.mixPhi(key)
+    return HPPC.mixPhi(key)
   }
 
   /**
@@ -336,7 +336,7 @@ internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
       )
     }
 
-    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
     this.mask = arraySize - 1
   }
 
@@ -358,7 +358,7 @@ internal class LongLongScatterMap constructor(expectedElements: Int = 4) {
     // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
     val prevKeys = this.keys
     val prevValues = this.values
-    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size, loadFactor))
 
     // We have succeeded at allocating new data so insert the pending key/value at
     // the free slot in the old arrays before rehashing.
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
index 8173dbfd0..8dd99e792 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
@@ -202,7 +202,7 @@ internal class LongObjectScatterMap<T> {
     assigned = 0
     hasEmptyKey = false
 
-    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
   }
 
   val size: Int
@@ -214,7 +214,7 @@ internal class LongObjectScatterMap<T> {
     if (expectedElements > resizeAt) {
       val prevKeys = this.keys
       val prevValues = this.values
-      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
       if (!isEmpty) {
         rehash(prevKeys, prevValues)
       }
@@ -222,7 +222,7 @@ internal class LongObjectScatterMap<T> {
   }
 
   private fun hashKey(key: Long): Int {
-    return HHPC.mixPhi(key)
+    return HPPC.mixPhi(key)
   }
 
   /**
@@ -282,7 +282,7 @@ internal class LongObjectScatterMap<T> {
       )
     }
 
-    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
     this.mask = arraySize - 1
   }
 
@@ -304,7 +304,7 @@ internal class LongObjectScatterMap<T> {
     // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
     val prevKeys = this.keys
     val prevValues = this.values
-    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size, loadFactor))
 
     // We have succeeded at allocating new data so insert the pending key/value at
     // the free slot in the old arrays before rehashing.
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
index cc69801fa..b8ec45c07 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -61,7 +61,7 @@ internal class LongScatterSet(expectedElements: Int = 4) {
   }
 
   private fun hashKey(key: Long): Int {
-    return HHPC.mixPhi(key)
+    return HPPC.mixPhi(key)
   }
 
   operator fun plusAssign(key: Long) {
@@ -174,13 +174,13 @@ internal class LongScatterSet(expectedElements: Int = 4) {
   fun release() {
     assigned = 0
     hasEmptyKey = false
-    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+    allocateBuffers(HPPC.minBufferSize(4, loadFactor))
   }
 
   fun ensureCapacity(expectedElements: Int) {
     if (expectedElements > resizeAt) {
       val prevKeys = this.keys
-      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      allocateBuffers(HPPC.minBufferSize(expectedElements, loadFactor))
       if (size() != 0) {
         rehash(prevKeys)
       }
@@ -231,7 +231,7 @@ internal class LongScatterSet(expectedElements: Int = 4) {
       )
     }
 
-    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.resizeAt = HPPC.expandAtCount(arraySize, loadFactor)
     this.mask = arraySize - 1
   }
 
@@ -241,7 +241,7 @@ internal class LongScatterSet(expectedElements: Int = 4) {
   ) {
     // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
     val prevKeys = this.keys
-    allocateBuffers(HHPC.nextBufferSize(mask + 1, size(), loadFactor))
+    allocateBuffers(HPPC.nextBufferSize(mask + 1, size(), loadFactor))
 
     // We have succeeded at allocating new data so insert the pending key/value at
     // the free slot in the old arrays before rehashing.
diff --git a/shark-graph/src/test/java/shark/LongScatterSetTest.kt b/shark-graph/src/test/java/shark/LongScatterSetTest.kt
index 088313e2f..490d9f8b8 100644
--- a/shark-graph/src/test/java/shark/LongScatterSetTest.kt
+++ b/shark-graph/src/test/java/shark/LongScatterSetTest.kt
@@ -3,7 +3,7 @@ package shark
 import org.assertj.core.api.Assertions
 import org.junit.Test
 import shark.LongScatterSetAssertion.Companion.assertThat
-import shark.internal.hppc.HHPC.mixPhi
+import shark.internal.hppc.HPPC.mixPhi
 import shark.internal.hppc.LongScatterSet
 
 class LongScatterSetTest {
