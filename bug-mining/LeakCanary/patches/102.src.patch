diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
index 41a519759..8c24a7d1c 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
@@ -4,9 +4,8 @@ import android.app.Application
 import com.squareup.leakcanary.core.R
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.internal.LeakDirectoryProvider
-import leakcanary.internal.Notifications
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
+import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -15,10 +14,6 @@ import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
-import java.io.File
-import java.text.SimpleDateFormat
-import java.util.Date
-import java.util.Locale
 
 object DefaultAnalysisResultListener : AnalysisResultListener {
   override fun invoke(
@@ -29,16 +24,9 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
     // TODO better log that include leakcanary version, exclusions, etc.
     CanaryLog.d("%s", heapAnalysis)
 
-    val movedHeapDump = renameHeapdump(heapAnalysis.heapDumpFile)
-
-    val updatedHeapAnalysis = when (heapAnalysis) {
-      is HeapAnalysisFailure -> heapAnalysis.copy(heapDumpFile = movedHeapDump)
-      is HeapAnalysisSuccess -> heapAnalysis.copy(heapDumpFile = movedHeapDump)
-    }
-
     val (id, groupProjections) = LeaksDbHelper(application)
         .writableDatabase.use { db ->
-      val id = HeapAnalysisTable.insert(db, updatedHeapAnalysis)
+      val id = HeapAnalysisTable.insert(db, heapAnalysis)
       id to LeakingInstanceTable.retrieveAllByHeapAnalysisId(db, id)
     }
 
@@ -82,22 +70,4 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         LEAKCANARY_RESULT
     )
   }
-
-  private fun renameHeapdump(heapDumpFile: File): File {
-    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
-
-    val path = heapDumpFile.absolutePath
-    val newFile = File(heapDumpFile.parent, fileName)
-    val lastModified = heapDumpFile.lastModified()
-    val renamed = heapDumpFile.renameTo(newFile)
-    if (renamed) {
-     LeakDirectoryProvider.filesRenamedEndOfHeapAnalyzer += path
-    } else {
-      CanaryLog.d(
-          "Could not rename heap dump file %s to %s", heapDumpFile.path, newFile.path
-      )
-    }
-    newFile.setLastModified(lastModified)
-    return newFile
-  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index a13d0db91..4a1bc3761 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -25,7 +25,6 @@ import leakcanary.CanaryLog
 import leakcanary.HeapAnalyzer
 import leakcanary.LeakCanary
 import java.io.File
-import java.lang.IllegalStateException
 
 /**
  * This service runs in a main app process.
@@ -61,15 +60,7 @@ internal class HeapAnalyzerService : ForegroundService(
           config.leakInspectors, config.labelers
       )
 
-    try {
-      config.analysisResultListener(application, heapAnalysis)
-    } finally {
-      val path = heapAnalysis.heapDumpFile.absolutePath
-      val deleted = heapAnalysis.heapDumpFile.delete()
-      if (deleted) {
-        LeakDirectoryProvider.filesDeletedEndOfHeapAnalyzer += path
-      }
-    }
+    config.analysisResultListener(application, heapAnalysis)
   }
 
   override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index e9a9b5efd..a42d6fdc8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -28,9 +28,11 @@ import leakcanary.CanaryLog
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.io.FilenameFilter
+import java.text.SimpleDateFormat
 import java.util.ArrayList
 import java.util.Arrays
-import java.util.UUID
+import java.util.Date
+import java.util.Locale
 
 /**
  * Provides access to where heap dumps and analysis results will be stored.
@@ -97,17 +99,15 @@ internal class LeakDirectoryProvider constructor(
         return null
       }
     }
-    // If two processes from the same app get to this step at the same time, they could both
-    // create a heap dump. This is an edge case we ignore.
-    return File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX)
+
+    val fileName = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(Date())
+    return File(storageDirectory, fileName)
   }
 
   fun clearLeakDirectory() {
     val allFilesExceptPending =
       listFiles(FilenameFilter { _, filename ->
-        !filename.endsWith(
-            PENDING_HEAPDUMP_SUFFIX
-        )
+        true
       })
     for (file in allFilesExceptPending) {
       val path = file.absolutePath
@@ -205,11 +205,8 @@ internal class LeakDirectoryProvider constructor(
     private val filesDeletedTooOld = mutableListOf<String>()
     private val filesDeletedClearDirectory = mutableListOf<String>()
     val filesDeletedRemoveLeak = mutableListOf<String>()
-    val filesDeletedEndOfHeapAnalyzer = mutableListOf<String>()
-    val filesRenamedEndOfHeapAnalyzer = mutableListOf<String>()
 
     private const val HPROF_SUFFIX = ".hprof"
-    private const val PENDING_HEAPDUMP_SUFFIX = "_pending$HPROF_SUFFIX"
 
     fun hprofDeleteReason(file: File): String {
       val path = file.absolutePath
@@ -217,8 +214,6 @@ internal class LeakDirectoryProvider constructor(
         filesDeletedTooOld.contains(path) -> "Older than all other hprof files"
         filesDeletedClearDirectory.contains(path) -> "Hprof directory cleared"
         filesDeletedRemoveLeak.contains(path) -> "Leak manually removed"
-        filesDeletedEndOfHeapAnalyzer.contains(path) -> "Heap Analysis done & leak reported"
-        filesRenamedEndOfHeapAnalyzer.contains(path) -> "Heap Analysis done & hprof moved"
         else -> "Unknown"
       }
     }
