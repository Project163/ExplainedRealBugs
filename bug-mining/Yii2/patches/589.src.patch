diff --git a/framework/CHANGELOG.md b/framework/CHANGELOG.md
index ce2890fb8..590a7a117 100644
--- a/framework/CHANGELOG.md
+++ b/framework/CHANGELOG.md
@@ -4,7 +4,7 @@ Yii Framework 2 Change Log
 2.0.22 under development
 ------------------------
 
-- no changes in this release.
+- Enh #17382: Added `\yii\validators\DateValidator::$strictDateFormat` to enable strict validation (alexkart)
 
 
 2.0.21 June 18, 2019
diff --git a/framework/validators/DateValidator.php b/framework/validators/DateValidator.php
index 186fa17f0..3f2dccf13 100644
--- a/framework/validators/DateValidator.php
+++ b/framework/validators/DateValidator.php
@@ -8,6 +8,7 @@
 namespace yii\validators;
 
 use DateTime;
+use Exception;
 use IntlDateFormatter;
 use Yii;
 use yii\base\InvalidConfigException;
@@ -194,6 +195,13 @@ class DateValidator extends Validator
      * @since 2.0.4
      */
     public $minString;
+    /**
+     * @var bool set this parameter to true if you need strict date format validation (e.g. only such dates pass
+     * validation for the following format 'yyyy-MM-dd': '0011-03-25', '2019-04-30' etc. and not '18-05-15',
+     * '2017-Mar-14' etc. which pass validation if this parameter is set to false)
+     * @since 2.0.22
+     */
+    public $strictDateFormat = false;
 
     /**
      * @var array map of short format names to IntlDateFormatter constant values.
@@ -239,10 +247,10 @@ class DateValidator extends Validator
             $this->tooBig = Yii::t('yii', '{attribute} must be no greater than {max}.');
         }
         if ($this->maxString === null) {
-            $this->maxString = (string) $this->max;
+            $this->maxString = (string)$this->max;
         }
         if ($this->minString === null) {
-            $this->minString = (string) $this->min;
+            $this->minString = (string)$this->min;
         }
         if ($this->max !== null && is_string($this->max)) {
             $timestamp = $this->parseDateValue($this->max);
@@ -335,6 +343,7 @@ class DateValidator extends Validator
      * @param string $value string representing date
      * @param string $format expected date format
      * @return int|false a UNIX timestamp or `false` on failure.
+     * @throws InvalidConfigException
      */
     private function parseDateValueFormat($value, $format)
     {
@@ -364,21 +373,7 @@ class DateValidator extends Validator
      */
     private function parseDateValueIntl($value, $format)
     {
-        if (isset($this->_dateFormats[$format])) {
-            if ($this->type === self::TYPE_DATE) {
-                $formatter = new IntlDateFormatter($this->locale, $this->_dateFormats[$format], IntlDateFormatter::NONE, 'UTC');
-            } elseif ($this->type === self::TYPE_DATETIME) {
-                $formatter = new IntlDateFormatter($this->locale, $this->_dateFormats[$format], $this->_dateFormats[$format], $this->timeZone);
-            } elseif ($this->type === self::TYPE_TIME) {
-                $formatter = new IntlDateFormatter($this->locale, IntlDateFormatter::NONE, $this->_dateFormats[$format], $this->timeZone);
-            } else {
-                throw new InvalidConfigException('Unknown validation type set for DateValidator::$type: ' . $this->type);
-            }
-        } else {
-            // if no time was provided in the format string set time to 0 to get a simple date timestamp
-            $hasTimeInfo = (strpbrk($format, 'ahHkKmsSA') !== false);
-            $formatter = new IntlDateFormatter($this->locale, IntlDateFormatter::NONE, IntlDateFormatter::NONE, $hasTimeInfo ? $this->timeZone : 'UTC', null, $format);
-        }
+        $formatter = $this->getIntlDateFormatter($format);
         // enable strict parsing to avoid getting invalid date values
         $formatter->setLenient(false);
 
@@ -386,13 +381,52 @@ class DateValidator extends Validator
         // See https://github.com/yiisoft/yii2/issues/5962 and https://bugs.php.net/bug.php?id=68528
         $parsePos = 0;
         $parsedDate = @$formatter->parse($value, $parsePos);
-        if ($parsedDate === false || $parsePos !== mb_strlen($value, Yii::$app ? Yii::$app->charset : 'UTF-8')) {
+        $valueLength = mb_strlen($value, Yii::$app ? Yii::$app->charset : 'UTF-8');
+        if ($parsedDate === false || $parsePos !== $valueLength || ($this->strictDateFormat && $formatter->format($parsedDate) !== $value)) {
             return false;
         }
 
         return $parsedDate;
     }
 
+    /**
+     * Creates IntlDateFormatter
+     *
+     * @param $format string date format
+     * @return IntlDateFormatter
+     * @throws InvalidConfigException
+     */
+    private function getIntlDateFormatter($format)
+    {
+        if (!isset($this->_dateFormats[$format])) {
+            // if no time was provided in the format string set time to 0 to get a simple date timestamp
+            $hasTimeInfo = (strpbrk($format, 'ahHkKmsSA') !== false);
+            $formatter = new IntlDateFormatter($this->locale, IntlDateFormatter::NONE, IntlDateFormatter::NONE, $hasTimeInfo ? $this->timeZone : 'UTC', null, $format);
+
+            return $formatter;
+        }
+
+        if ($this->type === self::TYPE_DATE) {
+            $dateType = $this->_dateFormats[$format];
+            $timeType = IntlDateFormatter::NONE;
+            $timeZone = 'UTC';
+        } elseif ($this->type === self::TYPE_DATETIME) {
+            $dateType = $this->_dateFormats[$format];
+            $timeType = $this->_dateFormats[$format];
+            $timeZone = $this->timeZone;
+        } elseif ($this->type === self::TYPE_TIME) {
+            $dateType = IntlDateFormatter::NONE;
+            $timeType = $this->_dateFormats[$format];
+            $timeZone = $this->timeZone;
+        } else {
+            throw new InvalidConfigException('Unknown validation type set for DateValidator::$type: ' . $this->type);
+        }
+
+        $formatter = new IntlDateFormatter($this->locale, $dateType, $timeType, $timeZone);
+
+        return $formatter;
+    }
+
     /**
      * Parses a date value using the DateTime::createFromFormat().
      * @param string $value string representing date
@@ -406,7 +440,7 @@ class DateValidator extends Validator
 
         $date = DateTime::createFromFormat($format, $value, new \DateTimeZone($hasTimeInfo ? $this->timeZone : 'UTC'));
         $errors = DateTime::getLastErrors();
-        if ($date === false || $errors['error_count'] || $errors['warning_count']) {
+        if ($date === false || $errors['error_count'] || $errors['warning_count'] || ($this->strictDateFormat && $date->format($format) !== $value)) {
             return false;
         }
 
@@ -422,6 +456,7 @@ class DateValidator extends Validator
      * @param int $timestamp
      * @param string $format
      * @return string
+     * @throws Exception
      */
     private function formatTimestamp($timestamp, $format)
     {
diff --git a/tests/framework/validators/DateValidatorTest.php b/tests/framework/validators/DateValidatorTest.php
index ac2a6a89f..91b627b27 100644
--- a/tests/framework/validators/DateValidatorTest.php
+++ b/tests/framework/validators/DateValidatorTest.php
@@ -784,6 +784,143 @@ class DateValidatorTest extends TestCase
         $this->assertTrue($model->hasErrors('attr_date'));
     }
 
+    /**
+     * Test dates that don't pass strict intl validation
+     *
+     * @dataProvider provideTestStrictDateFormatIntlFail
+     * @param $format
+     * @param $date
+     * @param $strictDateFormat
+     */
+    public function testStrictDateFormatIntlFail($format, $date, $strictDateFormat)
+    {
+        $this->mockApplication([
+            'timeZone' => 'UTC',
+            'language' => 'en-US',
+        ]);
+        IntlTestHelper::$enableIntl = true;
+
+        $val = new DateValidator(['format' => $format, 'strictDateFormat' => $strictDateFormat]);
+        $model = new FakedValidationModel();
+        $model->attr_date = $date;
+        $val->validateAttribute($model, 'attr_date');
+        $this->assertTrue($model->hasErrors('attr_date'));
+    }
+
+    public function provideTestStrictDateFormatIntlFail()
+    {
+        return [
+            ['yyyy-MM-dd', '13-Mar-19', true],
+            ['yyyy-MM-dd', '13-March-19', true],
+            ['yyyy-MM-dd', '13-03-19', true],
+            ['yyyy-MM-dd', '13-3-19', true],
+            ['yyyy-MM-dd', '13-003-19', true],
+            ['yyyy-MM-dd', '0013-Mar-19', true],
+            ['yyyy-MM-dd', '13-Mar-00019', true],
+            ['yyyy-MM-dd', '0000-03-19', true],
+        ];
+    }
+
+    /**
+     * Test dates that pass strict intl validation
+     *
+     * @dataProvider provideTestStrictDateFormatIntlPass
+     * @param $format
+     * @param $date
+     * @param $strictDateFormat
+     */
+    public function testStrictDateFormatIntlPass($format, $date, $strictDateFormat)
+    {
+        $this->mockApplication([
+            'timeZone' => 'UTC',
+            'language' => 'en-US',
+        ]);
+        IntlTestHelper::$enableIntl = true;
+
+        $val = new DateValidator(['format' => $format, 'strictDateFormat' => $strictDateFormat]);
+        $model = new FakedValidationModel();
+        $model->attr_date = $date;
+        $val->validateAttribute($model, 'attr_date');
+        $this->assertFalse($model->hasErrors('attr_date'));
+    }
+
+    public function provideTestStrictDateFormatIntlPass()
+    {
+        return [
+            ['yyyy-MM-dd', '0013-03-19', true],
+            ['yyyy-MM-dd', '2013-03-19', true],
+            ['yyyy-MM-dd', '0001-03-19', true],
+        ];
+    }
+
+    /**
+     * Test dates that don't pass strict php validation
+     *
+     * @dataProvider provideTestStrictDateFormatPhpFail
+     * @param $format
+     * @param $date
+     * @param $strictDateFormat
+     */
+    public function testStrictDateFormatPhpFail($format, $date, $strictDateFormat)
+    {
+        $this->mockApplication([
+            'timeZone' => 'UTC',
+            'language' => 'en-US',
+        ]);
+        IntlTestHelper::$enableIntl = false;
+
+        $val = new DateValidator(['format' => $format, 'strictDateFormat' => $strictDateFormat]);
+        $model = new FakedValidationModel();
+        $model->attr_date = $date;
+        $val->validateAttribute($model, 'attr_date');
+        $this->assertTrue($model->hasErrors('attr_date'));
+    }
+
+    public function provideTestStrictDateFormatPhpFail()
+    {
+        return [
+            ['php:Y-m-d', '13-Mar-19', true],
+            ['php:Y-m-d', '13-March-19', true],
+            ['php:Y-m-d', '13-03-19', true],
+            ['php:Y-m-d', '13-3-19', true],
+            ['php:Y-m-d', '13-003-19', true],
+            ['php:Y-m-d', '0013-Mar-19', true],
+            ['php:Y-m-d', '13-Mar-00019', true],
+        ];
+    }
+
+    /**
+     * Test dates that pass strict php validation
+     *
+     * @dataProvider provideTestStrictDateFormatPhpPass
+     * @param $format
+     * @param $date
+     * @param $strictDateFormat
+     */
+    public function testStrictDateFormatPhpPass($format, $date, $strictDateFormat)
+    {
+        $this->mockApplication([
+            'timeZone' => 'UTC',
+            'language' => 'en-US',
+        ]);
+        IntlTestHelper::$enableIntl = false;
+
+        $val = new DateValidator(['format' => $format, 'strictDateFormat' => $strictDateFormat]);
+        $model = new FakedValidationModel();
+        $model->attr_date = $date;
+        $val->validateAttribute($model, 'attr_date');
+        $this->assertFalse($model->hasErrors('attr_date'));
+    }
+
+    public function provideTestStrictDateFormatPhpPass()
+    {
+        return [
+            ['php:Y-m-d', '0013-03-19', true],
+            ['php:Y-m-d', '2013-03-19', true],
+            ['php:Y-m-d', '0001-03-19', true],
+        ];
+    }
+
     /**
      * @depends testValidateAttributePHPFormat
      */
@@ -819,7 +956,7 @@ class DateValidatorTest extends TestCase
      */
     public function testIssue15628()
     {
-        $validator = new DateValidator(['format' => 'php:U' , 'type' => DateValidator::TYPE_DATETIME, 'timestampAttribute' => 'attr_date']);
+        $validator = new DateValidator(['format' => 'php:U', 'type' => DateValidator::TYPE_DATETIME, 'timestampAttribute' => 'attr_date']);
         $model = new FakedValidationModel();
         $value = 1518023610;
         $model->attr_date = $value;
