diff --git a/framework/CHANGELOG.md b/framework/CHANGELOG.md
index 1b06735ef..1e7e2d9b6 100644
--- a/framework/CHANGELOG.md
+++ b/framework/CHANGELOG.md
@@ -5,6 +5,7 @@ Yii Framework 2 Change Log
 --------------------------
 
 - Bug #13538: Fixed `yii\db\BaseActiveRecord::deleteAll()` changes method signature declared by `yii\db\ActiveRecordInterface::deleteAll()` (klimov-paul)
+- Enh #13278: `yii\caching\DbQueryDependency` created allowing specification of the cache dependency via `yii\db\QueryInterface` (klimov-paul)
 
 
 2.0.11.2 February 08, 2017
diff --git a/framework/caching/DbQueryDependency.php b/framework/caching/DbQueryDependency.php
new file mode 100644
index 000000000..35017ff8c
--- /dev/null
+++ b/framework/caching/DbQueryDependency.php
@@ -0,0 +1,109 @@
+<?php
+/**
+ * @link http://www.yiiframework.com/
+ * @copyright Copyright (c) 2008 Yii Software LLC
+ * @license http://www.yiiframework.com/license/
+ */
+
+namespace yii\caching;
+
+use yii\base\InvalidConfigException;
+use yii\db\QueryInterface;
+use yii\di\Instance;
+
+/**
+ * DbQueryDependency represents a dependency based on the query result of an [[QueryInterface]] instance.
+ *
+ * If the query result changes, the dependency is considered as changed.
+ * The query is specified via the [[query]] property.
+ *
+ * Object of any class which matches [[QueryInterface]] can be used, so this dependency can be used not only
+ * with regular relational databases but with MongoDB, Redis and so on as well.
+ *
+ * For more details and usage information on Cache, see the [guide article on caching](guide:caching-overview).
+ *
+ * @see QueryInterface
+ *
+ * @author Paul Klimov <klimov.paul@gmail.com>
+ * @since 2.0.12
+ */
+class DbQueryDependency extends Dependency
+{
+    /**
+     * @var string|array|object the application component ID of the database connection, connection object or
+     * its array configuration.
+     * This field can be left blank, allowing query to determine connection automatically.
+     */
+    public $db;
+    /**
+     * @var QueryInterface the query which result is used to determine if the dependency has been changed.
+     * Actual query method to be invoked is determined by [[method]].
+     */
+    public $query;
+    /**
+     * @var string|callable method which should be invoked in over the [[query]] object.
+     *
+     * If specified as a string an own query method with such name will be invoked, passing [[db]] value as its
+     * first argument. For example: `exists`, `all`.
+     *
+     * This field can be specified as a PHP callback of following signature:
+     *
+     * ```php
+     * function (QueryInterface $query, mixed $db) {
+     *     //return mixed;
+     * }
+     * ```
+     *
+     * If not set - [[QueryInterface::one()]] will be used.
+     */
+    public $method;
+
+
+    /**
+     * Generates the data needed to determine if dependency is changed.
+     * This method returns the query result
+     * @param Cache $cache the cache component that is currently evaluating this dependency
+     * @return mixed the data needed to determine if dependency has been changed.
+     * @throws InvalidConfigException on invalid configuration.
+     */
+    protected function generateDependencyData($cache)
+    {
+        $db = $this->db;
+        if ($db !== null) {
+            $db = Instance::ensure($db);
+        }
+
+        if (!$this->query instanceof QueryInterface) {
+            throw new InvalidConfigException('"' . get_class($this) . '::$query" should be an instance of "yii\db\QueryInterface".');
+        }
+
+        if (!empty($db->enableQueryCache)) {
+            // temporarily disable and re-enable query caching
+            $originEnableQueryCache = $db->enableQueryCache;
+            $db->enableQueryCache = false;
+            $result = $this->executeQuery($this->query, $db);
+            $db->enableQueryCache = $originEnableQueryCache;
+        } else {
+            $result = $this->executeQuery($this->query, $db);
+        }
+
+        return $result;
+    }
+
+    /**
+     * Executes the query according to [[method]] specification.
+     * @param QueryInterface $query query to be executed.
+     * @param mixed $db connection.
+     * @return mixed query result.
+     */
+    private function executeQuery($query, $db)
+    {
+        if ($this->method === null) {
+            return $query->one($db);
+        }
+        if (is_string($this->method)) {
+            return call_user_func([$query, $this->method], $db);
+        }
+        return call_user_func($this->method, $query, $db);
+    }
+}
\ No newline at end of file
diff --git a/tests/framework/caching/DbQueryDependencyTest.php b/tests/framework/caching/DbQueryDependencyTest.php
new file mode 100644
index 000000000..4f8a32396
--- /dev/null
+++ b/tests/framework/caching/DbQueryDependencyTest.php
@@ -0,0 +1,106 @@
+<?php
+
+namespace yiiunit\framework\caching;
+
+use yii\caching\ArrayCache;
+use yii\caching\DbQueryDependency;
+use yii\db\Query;
+use yiiunit\framework\db\DatabaseTestCase;
+
+class DbQueryDependencyTest extends DatabaseTestCase
+{
+    /**
+     * @inheritdoc
+     */
+    protected $driverName = 'sqlite';
+
+
+    /**
+     * @inheritdoc
+     */
+    protected function setUp()
+    {
+        parent::setUp();
+
+        $db = $this->getConnection(false);
+
+        $db->createCommand()->createTable('dependency_item', [
+            'id' => 'pk',
+            'value' => 'string',
+        ])->execute();
+
+        $db->createCommand()->insert('dependency_item', ['value' => 'initial'])->execute();
+    }
+
+    public function testIsChanged()
+    {
+        $db = $this->getConnection(false);
+        $cache = new ArrayCache();
+
+        $dependency = new DbQueryDependency();
+        $dependency->db = $db;
+        $dependency->query = (new Query())
+            ->select(['id'])
+            ->from('dependency_item')
+            ->orderBy(['id' => SORT_DESC])
+            ->limit(1);
+        $dependency->reusable = false;
+
+        $dependency->evaluateDependency($cache);
+        $this->assertFalse($dependency->isChanged($cache));
+
+        $db->createCommand()->insert('dependency_item', ['value' => 'new'])->execute();
+
+        $this->assertTrue($dependency->isChanged($cache));
+    }
+
+    /**
+     * @depends testIsChanged
+     */
+    public function testCustomMethod()
+    {
+        $db = $this->getConnection(false);
+        $cache = new ArrayCache();
+
+        $dependency = new DbQueryDependency();
+        $dependency->db = $db;
+        $dependency->query = (new Query())
+            ->from('dependency_item')
+            ->andWhere(['value' => 'active']);
+        $dependency->reusable = false;
+        $dependency->method = 'exists';
+
+        $dependency->evaluateDependency($cache);
+        $this->assertFalse($dependency->isChanged($cache));
+
+        $db->createCommand()->insert('dependency_item', ['value' => 'active'])->execute();
+
+        $this->assertTrue($dependency->isChanged($cache));
+    }
+
+    /**
+     * @depends testCustomMethod
+     */
+    public function testCustomMethodCallback()
+    {
+        $db = $this->getConnection(false);
+        $cache = new ArrayCache();
+
+        $dependency = new DbQueryDependency();
+        $dependency->db = $db;
+        $dependency->query = (new Query())
+            ->from('dependency_item')
+            ->andWhere(['value' => 'not exist']);
+        $dependency->reusable = false;
+        $dependency->method = function (Query $query, $db) {
+            return $query->orWhere(['value' => 'initial'])->exists($db);
+        };
+
+        $dependency->evaluateDependency($cache);
+        $this->assertFalse($dependency->isChanged($cache));
+
+        $db->createCommand()->delete('dependency_item')->execute();
+
+        $this->assertTrue($dependency->isChanged($cache));
+    }
+}
\ No newline at end of file
