{"url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692","repository_url":"https://api.github.com/repos/pytest-dev/pytest","labels_url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692/labels{/name}","comments_url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692/comments","events_url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692/events","html_url":"https://github.com/pytest-dev/pytest/issues/9692","id":1139143990,"node_id":"I_kwDOAjwLdc5D5fU2","number":9692,"title":"Current implementation of `pytest.approx()` cannot be used to compare sets","user":{"login":"griai","id":7665678,"node_id":"MDQ6VXNlcjc2NjU2Nzg=","avatar_url":"https://avatars.githubusercontent.com/u/7665678?v=4","gravatar_id":"","url":"https://api.github.com/users/griai","html_url":"https://github.com/griai","followers_url":"https://api.github.com/users/griai/followers","following_url":"https://api.github.com/users/griai/following{/other_user}","gists_url":"https://api.github.com/users/griai/gists{/gist_id}","starred_url":"https://api.github.com/users/griai/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/griai/subscriptions","organizations_url":"https://api.github.com/users/griai/orgs","repos_url":"https://api.github.com/users/griai/repos","events_url":"https://api.github.com/users/griai/events{/privacy}","received_events_url":"https://api.github.com/users/griai/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":659419768,"node_id":"MDU6TGFiZWw2NTk0MTk3Njg=","url":"https://api.github.com/repos/pytest-dev/pytest/labels/type:%20deprecation","name":"type: deprecation","color":"e99695","default":false,"description":"feature that will be removed in the future"},{"id":1087456003,"node_id":"MDU6TGFiZWwxMDg3NDU2MDAz","url":"https://api.github.com/repos/pytest-dev/pytest/labels/topic:%20approx","name":"topic: approx","color":"11d6a1","default":false,"description":"related to pytest.approx function"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2022-02-15T19:45:54Z","updated_at":"2022-02-24T13:17:34Z","closed_at":"2022-02-24T13:16:37Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"The current implementation of `pytest.approx()` yields incorrect results when used to compare sets.\r\n\r\nConsider the following self-explanatory code comparing two (equal as by `__eq__()`) sets:\r\n\r\n```\r\nimport numpy as np\r\nimport pytest\r\n\r\n\r\na = 2**np.arange(12)\r\nb = 2**np.arange(12)\r\nnp.random.shuffle(a)\r\n\r\nprint(a)\r\nprint(b)\r\n\r\nprint(*set(a))\r\nprint(*set(b))\r\n\r\nprint(set(a) == set(b))\r\nprint(set(a) == pytest.approx(set(b)))\r\n\r\n```\r\n\r\nAlthough the two sets are obviously the same, the last equality check using approx is failing.\r\n\r\nA quick view into the implementation of `approx()` makes it obvious why this is the case:\r\n\r\n```\r\nclass ApproxSequencelike(ApproxBase):\r\n    \"\"\"Perform approximate comparisons where the expected value is a sequence of numbers.\"\"\"\r\n\r\n    def __repr__(self) -> str:\r\n        seq_type = type(self.expected)\r\n        if seq_type not in (tuple, list, set):\r\n            seq_type = list\r\n        return \"approx({!r})\".format(\r\n            seq_type(self._approx_scalar(x) for x in self.expected)\r\n        )\r\n\r\n    def _yield_comparisons(self, actual):\r\n        return zip(actual, self.expected)\r\n```\r\n\r\nIn `_yield_comparisons()`, only `__iter__()` is used (in `zip()`), but since sets are unordered, so is the resulting iterator. This means, for sets such an implementation cannot work.\r\nWhat makes things worse is the confusion that seems to exist here between the different abstract base classes:\r\nIn the `__repr__()` method, clearly `set` is mentioned, explicitly. However, a set is not a sequence type, but only a collection type (because of the missing order). It is, however, iterable and since this is the only thing that is actually checked in the implementation, the code seems to work for sets, where, in fact, it does not. As a first step, I would suggest one could keep the current implementation, but explicitly check for sequence types (i.e. classes having a `__getitem__()` method) and delete all mentions of `set` in the code as well as on the documentation page and make it crystal clear that there is only an implementation for sequence types.\r\nBut what would be way better would, of course, be an implementation for arbitrary container comparisons.\r\n\r\nTested with pytest version 7.0.1.","closed_by":{"login":"nicoddemus","id":1085180,"node_id":"MDQ6VXNlcjEwODUxODA=","avatar_url":"https://avatars.githubusercontent.com/u/1085180?v=4","gravatar_id":"","url":"https://api.github.com/users/nicoddemus","html_url":"https://github.com/nicoddemus","followers_url":"https://api.github.com/users/nicoddemus/followers","following_url":"https://api.github.com/users/nicoddemus/following{/other_user}","gists_url":"https://api.github.com/users/nicoddemus/gists{/gist_id}","starred_url":"https://api.github.com/users/nicoddemus/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/nicoddemus/subscriptions","organizations_url":"https://api.github.com/users/nicoddemus/orgs","repos_url":"https://api.github.com/users/nicoddemus/repos","events_url":"https://api.github.com/users/nicoddemus/events{/privacy}","received_events_url":"https://api.github.com/users/nicoddemus/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pytest-dev/pytest/issues/9692/timeline","performed_via_github_app":null,"state_reason":"completed"}