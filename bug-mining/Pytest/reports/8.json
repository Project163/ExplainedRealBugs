{"url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979","repository_url":"https://api.github.com/repos/pytest-dev/pytest","labels_url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979/labels{/name}","comments_url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979/comments","events_url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979/events","html_url":"https://github.com/pytest-dev/pytest/issues/2979","id":277861923,"node_id":"MDU6SXNzdWUyNzc4NjE5MjM=","number":2979,"title":"pytest 3.3: fixture-related breakage","user":{"login":"cjw296","id":632049,"node_id":"MDQ6VXNlcjYzMjA0OQ==","avatar_url":"https://avatars.githubusercontent.com/u/632049?v=4","gravatar_id":"","url":"https://api.github.com/users/cjw296","html_url":"https://github.com/cjw296","followers_url":"https://api.github.com/users/cjw296/followers","following_url":"https://api.github.com/users/cjw296/following{/other_user}","gists_url":"https://api.github.com/users/cjw296/gists{/gist_id}","starred_url":"https://api.github.com/users/cjw296/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cjw296/subscriptions","organizations_url":"https://api.github.com/users/cjw296/orgs","repos_url":"https://api.github.com/users/cjw296/repos","events_url":"https://api.github.com/users/cjw296/events{/privacy}","received_events_url":"https://api.github.com/users/cjw296/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":224849198,"node_id":"MDU6TGFiZWwyMjQ4NDkxOTg=","url":"https://api.github.com/repos/pytest-dev/pytest/labels/type:%20question","name":"type: question","color":"cc317c","default":false,"description":"general question, might be closed after 2 weeks of inactivity"},{"id":315571544,"node_id":"MDU6TGFiZWwzMTU1NzE1NDQ=","url":"https://api.github.com/repos/pytest-dev/pytest/labels/type:%20regression","name":"type: regression","color":"f7c6c7","default":false,"description":"indicates a problem that was introduced in a release which was working previously"},{"id":604021555,"node_id":"MDU6TGFiZWw2MDQwMjE1NTU=","url":"https://api.github.com/repos/pytest-dev/pytest/labels/topic:%20fixtures","name":"topic: fixtures","color":"5319e7","default":false,"description":"anything involving fixtures directly or indirectly"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":9,"created_at":"2017-11-29T18:36:59Z","updated_at":"2017-11-30T15:58:29Z","closed_at":"2017-11-30T15:58:29Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"First spotted here:\r\nhttps://travis-ci.org/Simplistix/testfixtures/builds/308659341?utm_source=email&utm_medium=notification\r\n\r\nConfirmed as sybil, a pytest plugin, problem here:\r\nhttps://travis-ci.org/cjw296/sybil/builds/308116822?utm_source=email&utm_medium=notification\r\n\r\nHere's a short failure:\r\n\r\n```\r\n(sybil_35) tweedledee:sybil chris$ git remote -v\r\norigin\tgit@github.com:cjw296/sybil.git (fetch)\r\norigin\tgit@github.com:cjw296/sybil.git (push)\r\n(sybil_35) tweedledee:sybil chris$ pytest -x /Users/chris/vcs/git/sybil/tests/functional/pytest\r\n========================================================================= test session starts ==========================================================================\r\nplatform darwin -- Python 3.5.0, pytest-3.3.0, py-1.5.2, pluggy-0.6.0\r\nrootdir: /Users/chris/vcs/git/sybil/tests/functional/pytest, inifile: pytest.ini\r\ncollected 10 items                                                                                                                                                     \r\n\r\ntests/functional/pytest/fail.rst Emodule_fixture teardown\r\nsybil teardown 0\r\n\r\n\r\n================================================================================ ERRORS ================================================================================\r\n______________________________________________________________ ERROR at setup of fail.rst line=1 column=1 ______________________________________________________________\r\n\r\nself = <FixtureRequest for <SybilItem 'line:1,column:1'>>, fixturedef = <FixtureDef name='session_fixture' scope='session' baseid='' >\r\n\r\n    def _getfixturevalue(self, fixturedef):\r\n        # prepare a subrequest object before calling fixture function\r\n        # (latter managed by fixturedef)\r\n        argname = fixturedef.argname\r\n        funcitem = self._pyfuncitem\r\n        scope = fixturedef.scope\r\n        try:\r\n            param = funcitem.callspec.getparam(argname)\r\n        except (AttributeError, ValueError):\r\n            param = NOTSET\r\n            param_index = 0\r\n            if fixturedef.params is not None:\r\n                frame = inspect.stack()[3]\r\n                frameinfo = inspect.getframeinfo(frame[0])\r\n                source_path = frameinfo.filename\r\n                source_lineno = frameinfo.lineno\r\n                source_path = py.path.local(source_path)\r\n                if source_path.relto(funcitem.config.rootdir):\r\n                    source_path = source_path.relto(funcitem.config.rootdir)\r\n                msg = (\r\n                    \"The requested fixture has no parameter defined for the \"\r\n                    \"current test.\\n\\nRequested fixture '{0}' defined in:\\n{1}\"\r\n                    \"\\n\\nRequested here:\\n{2}:{3}\".format(\r\n                        fixturedef.argname,\r\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\r\n                        source_path,\r\n                        source_lineno,\r\n                    )\r\n                )\r\n                fail(msg)\r\n        else:\r\n            # indices might not be set if old-style metafunc.addcall() was used\r\n            param_index = funcitem.callspec.indices.get(argname, 0)\r\n            # if a parametrize invocation set a scope it will override\r\n            # the static scope defined with the fixture function\r\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\r\n            if paramscopenum is not None:\r\n                scope = scopes[paramscopenum]\r\n    \r\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\r\n    \r\n        # check if a higher-level scoped fixture accesses a lower level one\r\n        subrequest._check_scope(argname, self.scope, scope)\r\n    \r\n        # clear sys.exc_info before invoking the fixture (python bug?)\r\n        # if its not explicitly cleared it will leak into the call\r\n        exc_clear()\r\n        try:\r\n            # call the fixture function\r\n>           val = fixturedef.execute(request=subrequest)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:518: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <FixtureDef name='session_fixture' scope='session' baseid='' >, request = <SubRequest 'session_fixture' for <SybilItem 'line:1,column:1'>>\r\n\r\n    def execute(self, request):\r\n        # get required arguments and register our own finish()\r\n        # with their finalization\r\n        for argname in self.argnames:\r\n            fixturedef = request._get_active_fixturedef(argname)\r\n            if argname != \"request\":\r\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\r\n    \r\n        my_cache_key = request.param_index\r\n        cached_result = getattr(self, \"cached_result\", None)\r\n        if cached_result is not None:\r\n            result, cache_key, err = cached_result\r\n            if my_cache_key == cache_key:\r\n                if err is not None:\r\n                    py.builtin._reraise(*err)\r\n                else:\r\n                    return result\r\n            # we have a previous but differently parametrized fixture instance\r\n            # so we need to tear it down before creating a new one\r\n            self.finish(request)\r\n            assert not hasattr(self, \"cached_result\")\r\n    \r\n>       hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:790: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <SubRequest 'session_fixture' for <SybilItem 'line:1,column:1'>>\r\n\r\n    @property\r\n    def node(self):\r\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\r\n>       return self._getscopeitem(self.scope)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:285: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <SubRequest 'session_fixture' for <SybilItem 'line:1,column:1'>>, scope = 'session'\r\n\r\n    def _getscopeitem(self, scope):\r\n        if scope == \"function\":\r\n            # this might also be a non-function Item despite its attribute name\r\n            return self._pyfuncitem\r\n        node = get_scope_node(self._pyfuncitem, scope)\r\n        if node is None and scope == \"class\":\r\n            # fallback to function item itself\r\n            node = self._pyfuncitem\r\n>       assert node\r\nE       AssertionError\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:556: AssertionError\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\n>   return CallInfo(lambda: ihook(item=item, **kwds), when=when)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/runner.py:177: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <_HookCaller 'pytest_runtest_setup'>, args = (), kwargs = {'item': <SybilItem 'line:1,column:1'>}, notincall = set()\r\n\r\n    def __call__(self, *args, **kwargs):\r\n        if args:\r\n            raise TypeError(\"hook calling supports only keyword arguments\")\r\n        assert not self.is_historic()\r\n        if self.argnames:\r\n            notincall = set(self.argnames) - set(['__multicall__']) - set(\r\n                kwargs.keys())\r\n            if notincall:\r\n                warnings.warn(\r\n                    \"Argument(s) {} which are declared in the hookspec \"\r\n                    \"can not be found in this hook call\"\r\n                    .format(tuple(notincall)),\r\n                    stacklevel=2,\r\n                )\r\n>       return self._hookexec(self, self._nonwrappers + self._wrappers, kwargs)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/__init__.py:617: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <_pytest.config.PytestPluginManager object at 0x101c086d8>, hook = <_HookCaller 'pytest_runtest_setup'>\r\nmethods = [<pluggy.HookImpl object at 0x10325b5f8>, <pluggy.HookImpl object at 0x1030bf240>, <pluggy.HookImpl object at 0x10325b...uggy.HookImpl object at 0x103241a90>, <pluggy.HookImpl object at 0x10383a668>, <pluggy.HookImpl object at 0x103850048>]\r\nkwargs = {'item': <SybilItem 'line:1,column:1'>}\r\n\r\n    def _hookexec(self, hook, methods, kwargs):\r\n        # called from all hookcaller instances.\r\n        # enable_tracing will set its own wrapping function at self._inner_hookexec\r\n>       return self._inner_hookexec(hook, methods, kwargs)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/__init__.py:222: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nhook = <_HookCaller 'pytest_runtest_setup'>\r\nmethods = [<pluggy.HookImpl object at 0x10325b5f8>, <pluggy.HookImpl object at 0x1030bf240>, <pluggy.HookImpl object at 0x10325b...uggy.HookImpl object at 0x103241a90>, <pluggy.HookImpl object at 0x10383a668>, <pluggy.HookImpl object at 0x103850048>]\r\nkwargs = {'item': <SybilItem 'line:1,column:1'>}\r\n\r\n    self._inner_hookexec = lambda hook, methods, kwargs: \\\r\n        hook.multicall(\r\n            methods, kwargs,\r\n>           firstresult=hook.spec_opts.get('firstresult'),\r\n        )\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/__init__.py:216: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nhook_impls = [<pluggy.HookImpl object at 0x10325b5f8>, <pluggy.HookImpl object at 0x1030bf240>, <pluggy.HookImpl object at 0x10325b...uggy.HookImpl object at 0x103241a90>, <pluggy.HookImpl object at 0x10383a668>, <pluggy.HookImpl object at 0x103850048>]\r\ncaller_kwargs = {'item': <SybilItem 'line:1,column:1'>}, firstresult = False\r\n\r\n    def _multicall(hook_impls, caller_kwargs, firstresult=False):\r\n        \"\"\"Execute a call into multiple python functions/methods and return the\r\n        result(s).\r\n    \r\n        ``caller_kwargs`` comes from _HookCaller.__call__().\r\n        \"\"\"\r\n        __tracebackhide__ = True\r\n        results = []\r\n        excinfo = None\r\n        try:  # run impl and wrapper setup functions in a loop\r\n            teardowns = []\r\n            try:\r\n                for hook_impl in reversed(hook_impls):\r\n                    try:\r\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\r\n                    except KeyError:\r\n                        for argname in hook_impl.argnames:\r\n                            if argname not in caller_kwargs:\r\n                                raise HookCallError(\r\n                                    \"hook call must provide argument %r\" % (argname,))\r\n    \r\n                    if hook_impl.hookwrapper:\r\n                        try:\r\n                            gen = hook_impl.function(*args)\r\n                            next(gen)   # first yield\r\n                            teardowns.append(gen)\r\n                        except StopIteration:\r\n                            _raise_wrapfail(gen, \"did not yield\")\r\n                    else:\r\n                        res = hook_impl.function(*args)\r\n                        if res is not None:\r\n                            results.append(res)\r\n                            if firstresult:  # halt further impl calls\r\n                                break\r\n            except BaseException:\r\n                excinfo = sys.exc_info()\r\n        finally:\r\n            if firstresult:  # first result hooks return a single value\r\n                outcome = _Result(results[0] if results else None, excinfo)\r\n            else:\r\n                outcome = _Result(results, excinfo)\r\n    \r\n            # run all wrapper post-yield blocks\r\n            for gen in reversed(teardowns):\r\n                try:\r\n                    gen.send(outcome)\r\n                    _raise_wrapfail(gen, \"has second yield\")\r\n                except StopIteration:\r\n                    pass\r\n    \r\n>           return outcome.get_result()\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/callers.py:201: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <pluggy.callers._Result object at 0x103881ba8>\r\n\r\n    def get_result(self):\r\n        \"\"\"Get the result(s) for this hook call.\r\n    \r\n            If the hook was marked as a ``firstresult`` only a single value\r\n            will be returned otherwise a list of results.\r\n            \"\"\"\r\n        __tracebackhide__ = True\r\n        if self._excinfo is None:\r\n            return self._result\r\n        else:\r\n            ex = self._excinfo\r\n            if _py3:\r\n>               raise ex[1].with_traceback(ex[2])\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/callers.py:76: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nhook_impls = [<pluggy.HookImpl object at 0x10325b5f8>, <pluggy.HookImpl object at 0x1030bf240>, <pluggy.HookImpl object at 0x10325b...uggy.HookImpl object at 0x103241a90>, <pluggy.HookImpl object at 0x10383a668>, <pluggy.HookImpl object at 0x103850048>]\r\ncaller_kwargs = {'item': <SybilItem 'line:1,column:1'>}, firstresult = False\r\n\r\n    def _multicall(hook_impls, caller_kwargs, firstresult=False):\r\n        \"\"\"Execute a call into multiple python functions/methods and return the\r\n        result(s).\r\n    \r\n        ``caller_kwargs`` comes from _HookCaller.__call__().\r\n        \"\"\"\r\n        __tracebackhide__ = True\r\n        results = []\r\n        excinfo = None\r\n        try:  # run impl and wrapper setup functions in a loop\r\n            teardowns = []\r\n            try:\r\n                for hook_impl in reversed(hook_impls):\r\n                    try:\r\n                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]\r\n                    except KeyError:\r\n                        for argname in hook_impl.argnames:\r\n                            if argname not in caller_kwargs:\r\n                                raise HookCallError(\r\n                                    \"hook call must provide argument %r\" % (argname,))\r\n    \r\n                    if hook_impl.hookwrapper:\r\n                        try:\r\n                            gen = hook_impl.function(*args)\r\n                            next(gen)   # first yield\r\n                            teardowns.append(gen)\r\n                        except StopIteration:\r\n                            _raise_wrapfail(gen, \"did not yield\")\r\n                    else:\r\n>                       res = hook_impl.function(*args)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/pluggy/callers.py:180: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nitem = <SybilItem 'line:1,column:1'>\r\n\r\n    def pytest_runtest_setup(item):\r\n        _update_current_test_var(item, 'setup')\r\n>       item.session._setupstate.prepare(item)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/runner.py:101: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <_pytest.runner.SetupState object at 0x103858940>, colitem = <SybilItem 'line:1,column:1'>\r\n\r\n    def prepare(self, colitem):\r\n        \"\"\" setup objects along the collector chain to the test-method\r\n                and teardown previously setup objects.\"\"\"\r\n        needed_collectors = colitem.listchain()\r\n        self._teardown_towards(needed_collectors)\r\n    \r\n        # check if the last collection node has raised an error\r\n        for col in self.stack:\r\n            if hasattr(col, '_prepare_exc'):\r\n                py.builtin._reraise(*col._prepare_exc)\r\n        for col in needed_collectors[len(self.stack):]:\r\n            self.stack.append(col)\r\n            try:\r\n>               col.setup()\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/runner.py:495: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <SybilItem 'line:1,column:1'>\r\n\r\n    def setup(self):\r\n>       fixtures.fillfixtures(self)\r\n\r\nsybil/integration/pytest.py:61: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nfunction = <SybilItem 'line:1,column:1'>\r\n\r\n    def fillfixtures(function):\r\n        \"\"\" fill missing funcargs for a test function. \"\"\"\r\n        try:\r\n            request = function._request\r\n        except AttributeError:\r\n            # XXX this special code path is only expected to execute\r\n            # with the oejskit plugin.  It uses classes with funcargs\r\n            # and we thus have to work a bit to allow this.\r\n            fm = function.session._fixturemanager\r\n            fi = fm.getfixtureinfo(function.parent, function.obj, None)\r\n            function._fixtureinfo = fi\r\n            request = function._request = FixtureRequest(function)\r\n            request._fillfixtures()\r\n            # prune out funcargs for jstests\r\n            newfuncargs = {}\r\n            for name in fi.argnames:\r\n                newfuncargs[name] = function.funcargs[name]\r\n            function.funcargs = newfuncargs\r\n        else:\r\n>           request._fillfixtures()\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:242: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <FixtureRequest for <SybilItem 'line:1,column:1'>>\r\n\r\n    def _fillfixtures(self):\r\n        item = self._pyfuncitem\r\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\r\n        for argname in fixturenames:\r\n            if argname not in item.funcargs:\r\n>               item.funcargs[argname] = self.getfixturevalue(argname)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:385: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <FixtureRequest for <SybilItem 'line:1,column:1'>>, argname = 'session_fixture'\r\n\r\n    def getfixturevalue(self, argname):\r\n        \"\"\" Dynamically run a named fixture function.\r\n    \r\n            Declaring fixtures via function argument is recommended where possible.\r\n            But if you can only decide whether to use another fixture at test\r\n            setup time, you may use this function to retrieve it inside a fixture\r\n            or test function body.\r\n            \"\"\"\r\n>       return self._get_active_fixturedef(argname).cached_result[0]\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:427: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <FixtureRequest for <SybilItem 'line:1,column:1'>>, argname = 'session_fixture'\r\n\r\n    def _get_active_fixturedef(self, argname):\r\n        try:\r\n            return self._fixture_defs[argname]\r\n        except KeyError:\r\n            try:\r\n                fixturedef = self._getnextfixturedef(argname)\r\n            except FixtureLookupError:\r\n                if argname == \"request\":\r\n                    class PseudoFixtureDef:\r\n                        cached_result = (self, [0], None)\r\n                        scope = \"function\"\r\n                    return PseudoFixtureDef\r\n                raise\r\n        # remove indent to prevent the python3 exception\r\n        # from leaking into the call\r\n>       result = self._getfixturevalue(fixturedef)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:453: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <FixtureRequest for <SybilItem 'line:1,column:1'>>, fixturedef = <FixtureDef name='session_fixture' scope='session' baseid='' >\r\n\r\n    def _getfixturevalue(self, fixturedef):\r\n        # prepare a subrequest object before calling fixture function\r\n        # (latter managed by fixturedef)\r\n        argname = fixturedef.argname\r\n        funcitem = self._pyfuncitem\r\n        scope = fixturedef.scope\r\n        try:\r\n            param = funcitem.callspec.getparam(argname)\r\n        except (AttributeError, ValueError):\r\n            param = NOTSET\r\n            param_index = 0\r\n            if fixturedef.params is not None:\r\n                frame = inspect.stack()[3]\r\n                frameinfo = inspect.getframeinfo(frame[0])\r\n                source_path = frameinfo.filename\r\n                source_lineno = frameinfo.lineno\r\n                source_path = py.path.local(source_path)\r\n                if source_path.relto(funcitem.config.rootdir):\r\n                    source_path = source_path.relto(funcitem.config.rootdir)\r\n                msg = (\r\n                    \"The requested fixture has no parameter defined for the \"\r\n                    \"current test.\\n\\nRequested fixture '{0}' defined in:\\n{1}\"\r\n                    \"\\n\\nRequested here:\\n{2}:{3}\".format(\r\n                        fixturedef.argname,\r\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\r\n                        source_path,\r\n                        source_lineno,\r\n                    )\r\n                )\r\n                fail(msg)\r\n        else:\r\n            # indices might not be set if old-style metafunc.addcall() was used\r\n            param_index = funcitem.callspec.indices.get(argname, 0)\r\n            # if a parametrize invocation set a scope it will override\r\n            # the static scope defined with the fixture function\r\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\r\n            if paramscopenum is not None:\r\n                scope = scopes[paramscopenum]\r\n    \r\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\r\n    \r\n        # check if a higher-level scoped fixture accesses a lower level one\r\n        subrequest._check_scope(argname, self.scope, scope)\r\n    \r\n        # clear sys.exc_info before invoking the fixture (python bug?)\r\n        # if its not explicitly cleared it will leak into the call\r\n        exc_clear()\r\n        try:\r\n            # call the fixture function\r\n            val = fixturedef.execute(request=subrequest)\r\n        finally:\r\n            # if fixture function failed it might have registered finalizers\r\n            self.session._setupstate.addfinalizer(functools.partial(fixturedef.finish, request=subrequest),\r\n>                                                 subrequest.node)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:522: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <SubRequest 'session_fixture' for <SybilItem 'line:1,column:1'>>\r\n\r\n    @property\r\n    def node(self):\r\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\r\n>       return self._getscopeitem(self.scope)\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:285: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nself = <SubRequest 'session_fixture' for <SybilItem 'line:1,column:1'>>, scope = 'session'\r\n\r\n    def _getscopeitem(self, scope):\r\n        if scope == \"function\":\r\n            # this might also be a non-function Item despite its attribute name\r\n            return self._pyfuncitem\r\n        node = get_scope_node(self._pyfuncitem, scope)\r\n        if node is None and scope == \"class\":\r\n            # fallback to function item itself\r\n            node = self._pyfuncitem\r\n>       assert node\r\nE       AssertionError\r\n\r\n../../../virtualenvs/sybil_35/lib/python3.5/site-packages/_pytest/fixtures.py:556: AssertionError\r\n------------------------------------------------------------------------ Captured stdout setup -------------------------------------------------------------------------\r\nsybil setup function_fixture setup\r\nclass_fixture setup\r\nmodule_fixture setup\r\n======================================================================= 1 error in 0.29 seconds ========================================================================\r\n```\r\n","closed_by":{"login":"RonnyPfannschmidt","id":156838,"node_id":"MDQ6VXNlcjE1NjgzOA==","avatar_url":"https://avatars.githubusercontent.com/u/156838?v=4","gravatar_id":"","url":"https://api.github.com/users/RonnyPfannschmidt","html_url":"https://github.com/RonnyPfannschmidt","followers_url":"https://api.github.com/users/RonnyPfannschmidt/followers","following_url":"https://api.github.com/users/RonnyPfannschmidt/following{/other_user}","gists_url":"https://api.github.com/users/RonnyPfannschmidt/gists{/gist_id}","starred_url":"https://api.github.com/users/RonnyPfannschmidt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RonnyPfannschmidt/subscriptions","organizations_url":"https://api.github.com/users/RonnyPfannschmidt/orgs","repos_url":"https://api.github.com/users/RonnyPfannschmidt/repos","events_url":"https://api.github.com/users/RonnyPfannschmidt/events{/privacy}","received_events_url":"https://api.github.com/users/RonnyPfannschmidt/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/pytest-dev/pytest/issues/2979/timeline","performed_via_github_app":null,"state_reason":"completed"}