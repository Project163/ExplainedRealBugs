diff --git a/changelog/3936.removal.rst b/changelog/3936.removal.rst
new file mode 100644
index 000000000..bf0ba0897
--- /dev/null
+++ b/changelog/3936.removal.rst
@@ -0,0 +1,5 @@
+``@pytest.mark.filterwarnings`` second parameter is no longer regex-escaped,
+making it possible to actually use regular expressions to check the warning message.
+
+**Note**: regex-escaping the match string was an implementation oversight that might break test suites which depend
+on the old behavior.
diff --git a/src/_pytest/warnings.py b/src/_pytest/warnings.py
index 770d6b2a6..6c4b921fa 100644
--- a/src/_pytest/warnings.py
+++ b/src/_pytest/warnings.py
@@ -81,7 +81,7 @@ def catch_warnings_for_item(config, ihook, when, item):
         if item is not None:
             for mark in item.iter_markers(name="filterwarnings"):
                 for arg in mark.args:
-                    warnings._setoption(arg)
+                    _setoption(warnings, arg)
                     filters_configured = True
 
         if not filters_configured:
diff --git a/testing/test_warnings.py b/testing/test_warnings.py
index 11ca1e8f4..3f748d666 100644
--- a/testing/test_warnings.py
+++ b/testing/test_warnings.py
@@ -374,6 +374,22 @@ def test_collection_warnings(testdir):
     )
 
 
+@pytest.mark.filterwarnings("always")
+def test_mark_regex_escape(testdir):
+    """@pytest.mark.filterwarnings should not try to escape regex characters (#3936)"""
+    testdir.makepyfile(
+        r"""
+        import pytest, warnings
+
+        @pytest.mark.filterwarnings(r"ignore:some \(warning\)")
+        def test_foo():
+            warnings.warn(UserWarning("some (warning)"))
+    """
+    )
+    result = testdir.runpytest()
+    assert WARNINGS_SUMMARY_HEADER not in result.stdout.str()
+
+
 @pytest.mark.filterwarnings("default")
 @pytest.mark.parametrize("ignore_pytest_warnings", ["no", "ini", "cmdline"])
 def test_hide_pytest_internal_warnings(testdir, ignore_pytest_warnings):
