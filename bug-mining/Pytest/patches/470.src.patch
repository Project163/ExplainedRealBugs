diff --git a/changelog/9353.bugfix.rst b/changelog/9353.bugfix.rst
new file mode 100644
index 000000000..414f5a007
--- /dev/null
+++ b/changelog/9353.bugfix.rst
@@ -0,0 +1 @@
+:func:`pytest.approx` now uses strict equality when given booleans.
diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py
index af13c3dc9..4563b9972 100644
--- a/src/_pytest/python_api.py
+++ b/src/_pytest/python_api.py
@@ -259,19 +259,22 @@ class ApproxMapping(ApproxBase):
         ):
             if approx_value != other_value:
                 if approx_value.expected is not None and other_value is not None:
-                    max_abs_diff = max(
-                        max_abs_diff, abs(approx_value.expected - other_value)
-                    )
-                    if approx_value.expected == 0.0:
-                        max_rel_diff = math.inf
-                    else:
-                        max_rel_diff = max(
-                            max_rel_diff,
-                            abs(
-                                (approx_value.expected - other_value)
-                                / approx_value.expected
-                            ),
+                    try:
+                        max_abs_diff = max(
+                            max_abs_diff, abs(approx_value.expected - other_value)
                         )
+                        if approx_value.expected == 0.0:
+                            max_rel_diff = math.inf
+                        else:
+                            max_rel_diff = max(
+                                max_rel_diff,
+                                abs(
+                                    (approx_value.expected - other_value)
+                                    / approx_value.expected
+                                ),
+                            )
+                    except ZeroDivisionError:
+                        pass
                 different_ids.append(approx_key)
 
         message_data = [
@@ -395,8 +398,10 @@ class ApproxScalar(ApproxBase):
         # Don't show a tolerance for values that aren't compared using
         # tolerances, i.e. non-numerics and infinities. Need to call abs to
         # handle complex numbers, e.g. (inf + 1j).
-        if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(
-            abs(self.expected)
+        if (
+            isinstance(self.expected, bool)
+            or (not isinstance(self.expected, (Complex, Decimal)))
+            or math.isinf(abs(self.expected) or isinstance(self.expected, bool))
         ):
             return str(self.expected)
 
@@ -428,14 +433,17 @@ class ApproxScalar(ApproxBase):
             # numpy<1.13.  See #3748.
             return all(self.__eq__(a) for a in asarray.flat)
 
-        # Short-circuit exact equality.
-        if actual == self.expected:
+        # Short-circuit exact equality, except for bool
+        if isinstance(self.expected, bool) and not isinstance(actual, bool):
+            return False
+        elif actual == self.expected:
             return True
 
         # If either type is non-numeric, fall back to strict equality.
         # NB: we need Complex, rather than just Number, to ensure that __abs__,
-        # __sub__, and __float__ are defined.
-        if not (
+        # __sub__, and __float__ are defined. Also, consider bool to be
+        # nonnumeric, even though it has the required arithmetic.
+        if isinstance(self.expected, bool) or not (
             isinstance(self.expected, (Complex, Decimal))
             and isinstance(actual, (Complex, Decimal))
         ):
diff --git a/testing/python/approx.py b/testing/python/approx.py
index 21932059c..6de66d4f3 100644
--- a/testing/python/approx.py
+++ b/testing/python/approx.py
@@ -90,13 +90,26 @@ def assert_approx_raises_regex(pytestconfig):
     return do_assert
 
 
-SOME_FLOAT = r"[+-]?([0-9]*[.])?[0-9]+\s*"
+SOME_FLOAT = r"[+-]?((?:([0-9]*[.])?[0-9]+(e-?[0-9]+)?)|inf|nan)\s*"
 SOME_INT = r"[0-9]+\s*"
 SOME_TOLERANCE = rf"({SOME_FLOAT}|[+-]?[0-9]+(\.[0-9]+)?[eE][+-]?[0-9]+\s*)"
 
 
 class TestApprox:
     def test_error_messages_native_dtypes(self, assert_approx_raises_regex):
+        # Treat bool exactly.
+        assert_approx_raises_regex(
+            {"a": 1.0, "b": True},
+            {"a": 1.0, "b": False},
+            [
+                "",
+                "  comparison failed. Mismatched elements: 1 / 2:",
+                f"  Max absolute difference: {SOME_FLOAT}",
+                f"  Max relative difference: {SOME_FLOAT}",
+                r"  Index\s+\| Obtained\s+\| Expected",
+                r".*(True|False)\s+",
+            ],
+        )
         assert_approx_raises_regex(
             2.0,
             1.0,
@@ -596,6 +609,13 @@ class TestApprox:
             assert approx(x, rel=5e-6, abs=0) == a
             assert approx(x, rel=5e-7, abs=0) != a
 
+    def test_expecting_bool(self) -> None:
+        assert True == approx(True)  # noqa: E712
+        assert False == approx(False)  # noqa: E712
+        assert True != approx(False)  # noqa: E712
+        assert True != approx(False, abs=2)  # noqa: E712
+        assert 1 != approx(True)
+
     def test_list(self):
         actual = [1 + 1e-7, 2 + 1e-8]
         expected = [1, 2]
@@ -661,6 +681,7 @@ class TestApprox:
     def test_dict_nonnumeric(self):
         assert {"a": 1.0, "b": None} == pytest.approx({"a": 1.0, "b": None})
         assert {"a": 1.0, "b": 1} != pytest.approx({"a": 1.0, "b": None})
+        assert {"a": 1.0, "b": True} != pytest.approx({"a": 1.0, "b": False}, abs=2)
 
     def test_dict_vs_other(self):
         assert 1 != approx({"a": 0})
