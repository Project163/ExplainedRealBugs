diff --git a/changelog/13010.improvement.rst b/changelog/13010.improvement.rst
new file mode 100644
index 000000000..d6b814f09
--- /dev/null
+++ b/changelog/13010.improvement.rst
@@ -0,0 +1 @@
+:func:`pytest.approx` now can compare collections that contain numbers and non-numbers mixed.
diff --git a/src/_pytest/python_api.py b/src/_pytest/python_api.py
index 4563b9972..cbb2ff2b8 100644
--- a/src/_pytest/python_api.py
+++ b/src/_pytest/python_api.py
@@ -340,14 +340,18 @@ class ApproxSequenceLike(ApproxBase):
             zip(approx_side_as_map, other_side)
         ):
             if approx_value != other_value:
-                abs_diff = abs(approx_value.expected - other_value)
-                max_abs_diff = max(max_abs_diff, abs_diff)
-                if other_value == 0.0:
-                    max_rel_diff = math.inf
+                try:
+                    abs_diff = abs(approx_value.expected - other_value)
+                    max_abs_diff = max(max_abs_diff, abs_diff)
+                # Ignore non-numbers for the diff calculations (#13012).
+                except TypeError:
+                    pass
                 else:
-                    max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
+                    if other_value == 0.0:
+                        max_rel_diff = math.inf
+                    else:
+                        max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
                 different_ids.append(i)
-
         message_data = [
             (str(i), str(other_side[i]), str(approx_side_as_map[i]))
             for i in different_ids
diff --git a/testing/python/approx.py b/testing/python/approx.py
index 6de66d4f3..7eba4755c 100644
--- a/testing/python/approx.py
+++ b/testing/python/approx.py
@@ -390,6 +390,37 @@ class TestApprox:
 
         assert err.match(r"approx\(\) is not supported in a boolean context")
 
+    def test_mixed_sequence(self, assert_approx_raises_regex) -> None:
+        """Approx should work on sequences that also contain non-numbers (#13010)."""
+        assert_approx_raises_regex(
+            [1.1, 2, "word"],
+            [1.0, 2, "different"],
+            [
+                "",
+                r"  comparison failed. Mismatched elements: 2 / 3:",
+                rf"  Max absolute difference: {SOME_FLOAT}",
+                rf"  Max relative difference: {SOME_FLOAT}",
+                r"  Index \| Obtained\s+\| Expected\s+",
+                r"\s*0\s*\|\s*1\.1\s*\|\s*1\.0\s*±\s*1\.0e\-06\s*",
+                r"\s*2\s*\|\s*word\s*\|\s*different\s*",
+            ],
+            verbosity_level=2,
+        )
+        assert_approx_raises_regex(
+            [1.1, 2, "word"],
+            [1.0, 2, "word"],
+            [
+                "",
+                r"  comparison failed. Mismatched elements: 1 / 3:",
+                rf"  Max absolute difference: {SOME_FLOAT}",
+                rf"  Max relative difference: {SOME_FLOAT}",
+                r"  Index \| Obtained\s+\| Expected\s+",
+                r"\s*0\s*\|\s*1\.1\s*\|\s*1\.0\s*±\s*1\.0e\-06\s*",
+            ],
+            verbosity_level=2,
+        )
+        assert [1.1, 2, "word"] == pytest.approx([1.1, 2, "word"])
+
     def test_operator_overloading(self):
         assert 1 == approx(1, rel=1e-6, abs=1e-12)
         assert not (1 != approx(1, rel=1e-6, abs=1e-12))
