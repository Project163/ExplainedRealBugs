diff --git a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenLexer.java b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenLexer.java
index 17069aab6..ebb6cca02 100644
--- a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenLexer.java
+++ b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenLexer.java
@@ -1,3 +1,5 @@
+// $ANTLR 2.7.2: "ValidWhenParser.g" -> "ValidWhenLexer.java"$
+
 /*
  * $Id$
  *
@@ -18,928 +20,651 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+
 package org.apache.struts.validator.validwhen;
 
-import antlr.ANTLRHashString;
-import antlr.ByteBuffer;
-import antlr.CharBuffer;
+import java.util.Stack;
+import org.apache.commons.validator.util.ValidatorUtils;
+
+
+import java.io.InputStream;
+import antlr.TokenStreamException;
+import antlr.TokenStreamIOException;
+import antlr.TokenStreamRecognitionException;
 import antlr.CharStreamException;
 import antlr.CharStreamIOException;
+import antlr.ANTLRException;
+import java.io.Reader;
+import java.util.Hashtable;
+import antlr.CharScanner;
 import antlr.InputBuffer;
-import antlr.LexerSharedInputState;
-import antlr.NoViableAltForCharException;
-import antlr.RecognitionException;
+import antlr.ByteBuffer;
+import antlr.CharBuffer;
 import antlr.Token;
+import antlr.CommonToken;
+import antlr.RecognitionException;
+import antlr.NoViableAltForCharException;
+import antlr.MismatchedCharException;
 import antlr.TokenStream;
-import antlr.TokenStreamException;
-import antlr.TokenStreamIOException;
-import antlr.TokenStreamRecognitionException;
+import antlr.ANTLRHashString;
+import antlr.LexerSharedInputState;
 import antlr.collections.impl.BitSet;
+import antlr.SemanticException;
 
-import java.io.InputStream;
-import java.io.Reader;
-
-import java.util.Hashtable;
-
-public class ValidWhenLexer extends antlr.CharScanner
-    implements ValidWhenParserTokenTypes, TokenStream {
-    public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
-    public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
-
-    public ValidWhenLexer(InputStream in) {
-        this(new ByteBuffer(in));
-    }
-
-    public ValidWhenLexer(Reader in) {
-        this(new CharBuffer(in));
-    }
-
-    public ValidWhenLexer(InputBuffer ib) {
-        this(new LexerSharedInputState(ib));
-    }
-
-    public ValidWhenLexer(LexerSharedInputState state) {
-        super(state);
-        caseSensitiveLiterals = true;
-        setCaseSensitive(false);
-        literals = new Hashtable();
-        literals.put(new ANTLRHashString("null", this), new Integer(11));
-        literals.put(new ANTLRHashString("or", this), new Integer(16));
-        literals.put(new ANTLRHashString("and", this), new Integer(15));
-    }
-
-    public Token nextToken() throws TokenStreamException {
-        Token theRetToken = null;
+public class ValidWhenLexer extends antlr.CharScanner implements ValidWhenParserTokenTypes, TokenStream
+ {
+public ValidWhenLexer(InputStream in) {
+	this(new ByteBuffer(in));
+}
+public ValidWhenLexer(Reader in) {
+	this(new CharBuffer(in));
+}
+public ValidWhenLexer(InputBuffer ib) {
+	this(new LexerSharedInputState(ib));
+}
+public ValidWhenLexer(LexerSharedInputState state) {
+	super(state);
+	caseSensitiveLiterals = true;
+	setCaseSensitive(false);
+	literals = new Hashtable();
+	literals.put(new ANTLRHashString("null", this), new Integer(11));
+	literals.put(new ANTLRHashString("or", this), new Integer(16));
+	literals.put(new ANTLRHashString("and", this), new Integer(15));
+}
 
+public Token nextToken() throws TokenStreamException {
+	Token theRetToken=null;
 tryAgain:
-        for (;;) {
-            Token _token = null;
-            int _ttype = Token.INVALID_TYPE;
-
-            resetText();
-
-            try { // for char stream error handling
-
-                try { // for lexical error handling
-
-                    switch (LA(1)) {
-                    case '\t':
-                    case '\n':
-                    case '\r':
-                    case ' ': {
-                        mWS(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '-':
-                    case '1':
-                    case '2':
-                    case '3':
-                    case '4':
-                    case '5':
-                    case '6':
-                    case '7':
-                    case '8':
-                    case '9': {
-                        mDECIMAL_LITERAL(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '"':
-                    case '\'': {
-                        mSTRING_LITERAL(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '[': {
-                        mLBRACKET(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case ']': {
-                        mRBRACKET(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '(': {
-                        mLPAREN(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case ')': {
-                        mRPAREN(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '*': {
-                        mTHIS(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '.':
-                    case '_':
-                    case 'a':
-                    case 'b':
-                    case 'c':
-                    case 'd':
-                    case 'e':
-                    case 'f':
-                    case 'g':
-                    case 'h':
-                    case 'i':
-                    case 'j':
-                    case 'k':
-                    case 'l':
-                    case 'm':
-                    case 'n':
-                    case 'o':
-                    case 'p':
-                    case 'q':
-                    case 'r':
-                    case 's':
-                    case 't':
-                    case 'u':
-                    case 'v':
-                    case 'w':
-                    case 'x':
-                    case 'y':
-                    case 'z': {
-                        mIDENTIFIER(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '=': {
-                        mEQUALSIGN(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    case '!': {
-                        mNOTEQUALSIGN(true);
-                        theRetToken = _returnToken;
-
-                        break;
-                    }
-
-                    default:
-
-                        if ((LA(1) == '0') && (LA(2) == 'x')) {
-                            mHEX_LITERAL(true);
-                            theRetToken = _returnToken;
-                        } else if ((LA(1) == '<') && (LA(2) == '=')) {
-                            mLESSEQUALSIGN(true);
-                            theRetToken = _returnToken;
-                        } else if ((LA(1) == '>') && (LA(2) == '=')) {
-                            mGREATEREQUALSIGN(true);
-                            theRetToken = _returnToken;
-                        } else if ((LA(1) == '0') && (true)) {
-                            mOCTAL_LITERAL(true);
-                            theRetToken = _returnToken;
-                        } else if ((LA(1) == '<') && (true)) {
-                            mLESSTHANSIGN(true);
-                            theRetToken = _returnToken;
-                        } else if ((LA(1) == '>') && (true)) {
-                            mGREATERTHANSIGN(true);
-                            theRetToken = _returnToken;
-                        } else {
-                            if (LA(1) == EOF_CHAR) {
-                                uponEOF();
-                                _returnToken = makeToken(Token.EOF_TYPE);
-                            } else {
-                                throw new NoViableAltForCharException((char) LA(
-                                        1), getFilename(), getLine(),
-                                    getColumn());
-                            }
-                        }
-                    }
-
-                    if (_returnToken == null) {
-                        continue tryAgain; // found SKIP token
-                    }
-
-                    _ttype = _returnToken.getType();
-                    _ttype = testLiteralsTable(_ttype);
-                    _returnToken.setType(_ttype);
-
-                    return _returnToken;
-                } catch (RecognitionException e) {
-                    throw new TokenStreamRecognitionException(e);
-                }
-            } catch (CharStreamException cse) {
-                if (cse instanceof CharStreamIOException) {
-                    throw new TokenStreamIOException(
-                        ((CharStreamIOException) cse).io);
-                } else {
-                    throw new TokenStreamException(cse.getMessage());
-                }
-            }
-        }
-    }
-
-    public final void mWS(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = WS;
-
-        int _saveIndex;
-
-        {
-            int _cnt15 = 0;
-
-_loop15:
-            do {
-                switch (LA(1)) {
-                case ' ': {
-                    match(' ');
-
-                    break;
-                }
-
-                case '\t': {
-                    match('\t');
-
-                    break;
-                }
-
-                case '\n': {
-                    match('\n');
-
-                    break;
-                }
-
-                case '\r': {
-                    match('\r');
-
-                    break;
-                }
-
-                default: {
-                    if (_cnt15 >= 1) {
-                        break _loop15;
-                    } else {
-                        throw new NoViableAltForCharException((char) LA(1),
-                            getFilename(), getLine(), getColumn());
-                    }
-                }
-                }
-
-                _cnt15++;
-            } while (true);
-        }
-
-        _ttype = Token.SKIP;
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mDECIMAL_LITERAL(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = DECIMAL_LITERAL;
-
-        int _saveIndex;
-
-        switch (LA(1)) {
-        case '-': {
-            match('-');
-
-            break;
-        }
-
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-            break;
-
-        default:
-            throw new NoViableAltForCharException((char) LA(1), getFilename(),
-                getLine(), getColumn());
-        }
-
-        matchRange('1', '9');
-_loop20:
-        do {
-            if ((((LA(1) >= '0') && (LA(1) <= '9')))) {
-                matchRange('0', '9');
-            } else {
-                break _loop20;
-            }
-        } while (true);
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mHEX_LITERAL(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = HEX_LITERAL;
-
-        int _saveIndex;
-
-        match('0');
-        match('x');
-
-        {
-            int _cnt23 = 0;
-
-_loop23:
-            do {
-                switch (LA(1)) {
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9': {
-                    matchRange('0', '9');
-
-                    break;
-                }
-
-                case 'a':
-                case 'b':
-                case 'c':
-                case 'd':
-                case 'e':
-                case 'f': {
-                    matchRange('a', 'f');
-
-                    break;
-                }
-
-                default: {
-                    if (_cnt23 >= 1) {
-                        break _loop23;
-                    } else {
-                        throw new NoViableAltForCharException((char) LA(1),
-                            getFilename(), getLine(), getColumn());
-                    }
-                }
-                }
-
-                _cnt23++;
-            } while (true);
-        }
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mOCTAL_LITERAL(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = OCTAL_LITERAL;
-
-        int _saveIndex;
-
-        match('0');
-_loop26:
-        do {
-            if ((((LA(1) >= '0') && (LA(1) <= '7')))) {
-                matchRange('0', '7');
-            } else {
-                break _loop26;
-            }
-        } while (true);
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mSTRING_LITERAL(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = STRING_LITERAL;
-
-        int _saveIndex;
-
-        switch (LA(1)) {
-        case '\'': {
-            match('\'');
-
-            {
-                int _cnt30 = 0;
-
-_loop30:
-                do {
-                    if ((_tokenSet_0.member(LA(1)))) {
-                        matchNot('\'');
-                    } else {
-                        if (_cnt30 >= 1) {
-                            break _loop30;
-                        } else {
-                            throw new NoViableAltForCharException((char) LA(1),
-                                getFilename(), getLine(), getColumn());
-                        }
-                    }
-
-                    _cnt30++;
-                } while (true);
-            }
-
-            match('\'');
-
-            break;
-        }
-
-        case '"': {
-            match('\"');
-
-            {
-                int _cnt33 = 0;
-
-_loop33:
-                do {
-                    if ((_tokenSet_1.member(LA(1)))) {
-                        matchNot('\"');
-                    } else {
-                        if (_cnt33 >= 1) {
-                            break _loop33;
-                        } else {
-                            throw new NoViableAltForCharException((char) LA(1),
-                                getFilename(), getLine(), getColumn());
-                        }
-                    }
-
-                    _cnt33++;
-                } while (true);
-            }
-
-            match('\"');
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltForCharException((char) LA(1), getFilename(),
-                getLine(), getColumn());
-        }
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mLBRACKET(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = LBRACKET;
-
-        int _saveIndex;
-
-        match('[');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mRBRACKET(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = RBRACKET;
-
-        int _saveIndex;
-
-        match(']');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mLPAREN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = LPAREN;
-
-        int _saveIndex;
-
-        match('(');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mRPAREN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = RPAREN;
-
-        int _saveIndex;
-
-        match(')');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mTHIS(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = THIS;
-
-        int _saveIndex;
-
-        match("*this*");
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mIDENTIFIER(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = IDENTIFIER;
-
-        int _saveIndex;
-
-        switch (LA(1)) {
-        case 'a':
-        case 'b':
-        case 'c':
-        case 'd':
-        case 'e':
-        case 'f':
-        case 'g':
-        case 'h':
-        case 'i':
-        case 'j':
-        case 'k':
-        case 'l':
-        case 'm':
-        case 'n':
-        case 'o':
-        case 'p':
-        case 'q':
-        case 'r':
-        case 's':
-        case 't':
-        case 'u':
-        case 'v':
-        case 'w':
-        case 'x':
-        case 'y':
-        case 'z': {
-            matchRange('a', 'z');
-
-            break;
-        }
-
-        case '.': {
-            match('.');
-
-            break;
-        }
-
-        case '_': {
-            match('_');
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltForCharException((char) LA(1), getFilename(),
-                getLine(), getColumn());
-        }
-
-        {
-            int _cnt42 = 0;
-
-_loop42:
-            do {
-                switch (LA(1)) {
-                case 'a':
-                case 'b':
-                case 'c':
-                case 'd':
-                case 'e':
-                case 'f':
-                case 'g':
-                case 'h':
-                case 'i':
-                case 'j':
-                case 'k':
-                case 'l':
-                case 'm':
-                case 'n':
-                case 'o':
-                case 'p':
-                case 'q':
-                case 'r':
-                case 's':
-                case 't':
-                case 'u':
-                case 'v':
-                case 'w':
-                case 'x':
-                case 'y':
-                case 'z': {
-                    matchRange('a', 'z');
-
-                    break;
-                }
-
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9': {
-                    matchRange('0', '9');
-
-                    break;
-                }
-
-                case '.': {
-                    match('.');
-
-                    break;
-                }
-
-                case '_': {
-                    match('_');
-
-                    break;
-                }
-
-                default: {
-                    if (_cnt42 >= 1) {
-                        break _loop42;
-                    } else {
-                        throw new NoViableAltForCharException((char) LA(1),
-                            getFilename(), getLine(), getColumn());
-                    }
-                }
-                }
-
-                _cnt42++;
-            } while (true);
-        }
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mEQUALSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = EQUALSIGN;
-
-        int _saveIndex;
-
-        match('=');
-        match('=');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mNOTEQUALSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = NOTEQUALSIGN;
-
-        int _saveIndex;
-
-        match('!');
-        match('=');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mLESSTHANSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = LESSTHANSIGN;
-
-        int _saveIndex;
-
-        match('<');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mGREATERTHANSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = GREATERTHANSIGN;
-
-        int _saveIndex;
-
-        match('>');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mLESSEQUALSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = LESSEQUALSIGN;
-
-        int _saveIndex;
-
-        match('<');
-        match('=');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    public final void mGREATEREQUALSIGN(boolean _createToken)
-        throws RecognitionException, CharStreamException, TokenStreamException {
-        int _ttype;
-        Token _token = null;
-        int _begin = text.length();
-
-        _ttype = GREATEREQUALSIGN;
-
-        int _saveIndex;
-
-        match('>');
-        match('=');
-
-        if (_createToken && (_token == null) && (_ttype != Token.SKIP)) {
-            _token = makeToken(_ttype);
-            _token.setText(new String(text.getBuffer(), _begin,
-                    text.length() - _begin));
-        }
-
-        _returnToken = _token;
-    }
-
-    private static final long[] mk_tokenSet_0() {
-        long[] data = { 8358512713185371648L, 576460746532061184L, 0L, 0L };
-
-        return data;
-    }
-
-    private static final long[] mk_tokenSet_1() {
-        long[] data = { 8358513245761316352L, 576460746532061184L, 0L, 0L };
-
-        return data;
-    }
+	for (;;) {
+		Token _token = null;
+		int _ttype = Token.INVALID_TYPE;
+		resetText();
+		try {   // for char stream error handling
+			try {   // for lexical error handling
+				switch ( LA(1)) {
+				case '\t':  case '\n':  case '\r':  case ' ':
+				{
+					mWS(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '-':  case '1':  case '2':  case '3':
+				case '4':  case '5':  case '6':  case '7':
+				case '8':  case '9':
+				{
+					mDECIMAL_LITERAL(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '"':  case '\'':
+				{
+					mSTRING_LITERAL(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '[':
+				{
+					mLBRACKET(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case ']':
+				{
+					mRBRACKET(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '(':
+				{
+					mLPAREN(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case ')':
+				{
+					mRPAREN(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '*':
+				{
+					mTHIS(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '.':  case '_':  case 'a':  case 'b':
+				case 'c':  case 'd':  case 'e':  case 'f':
+				case 'g':  case 'h':  case 'i':  case 'j':
+				case 'k':  case 'l':  case 'm':  case 'n':
+				case 'o':  case 'p':  case 'q':  case 'r':
+				case 's':  case 't':  case 'u':  case 'v':
+				case 'w':  case 'x':  case 'y':  case 'z':
+				{
+					mIDENTIFIER(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '=':
+				{
+					mEQUALSIGN(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				case '!':
+				{
+					mNOTEQUALSIGN(true);
+					theRetToken=_returnToken;
+					break;
+				}
+				default:
+					if ((LA(1)=='0') && (LA(2)=='x')) {
+						mHEX_LITERAL(true);
+						theRetToken=_returnToken;
+					}
+					else if ((LA(1)=='<') && (LA(2)=='=')) {
+						mLESSEQUALSIGN(true);
+						theRetToken=_returnToken;
+					}
+					else if ((LA(1)=='>') && (LA(2)=='=')) {
+						mGREATEREQUALSIGN(true);
+						theRetToken=_returnToken;
+					}
+					else if ((LA(1)=='0') && (true)) {
+						mOCTAL_LITERAL(true);
+						theRetToken=_returnToken;
+					}
+					else if ((LA(1)=='<') && (true)) {
+						mLESSTHANSIGN(true);
+						theRetToken=_returnToken;
+					}
+					else if ((LA(1)=='>') && (true)) {
+						mGREATERTHANSIGN(true);
+						theRetToken=_returnToken;
+					}
+				else {
+					if (LA(1)==EOF_CHAR) {uponEOF(); _returnToken = makeToken(Token.EOF_TYPE);}
+				else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+				}
+				}
+				if ( _returnToken==null ) continue tryAgain; // found SKIP token
+				_ttype = _returnToken.getType();
+				_ttype = testLiteralsTable(_ttype);
+				_returnToken.setType(_ttype);
+				return _returnToken;
+			}
+			catch (RecognitionException e) {
+				throw new TokenStreamRecognitionException(e);
+			}
+		}
+		catch (CharStreamException cse) {
+			if ( cse instanceof CharStreamIOException ) {
+				throw new TokenStreamIOException(((CharStreamIOException)cse).io);
+			}
+			else {
+				throw new TokenStreamException(cse.getMessage());
+			}
+		}
+	}
 }
+
+	public final void mWS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = WS;
+		int _saveIndex;
+		
+		{
+		int _cnt15=0;
+		_loop15:
+		do {
+			switch ( LA(1)) {
+			case ' ':
+			{
+				match(' ');
+				break;
+			}
+			case '\t':
+			{
+				match('\t');
+				break;
+			}
+			case '\n':
+			{
+				match('\n');
+				break;
+			}
+			case '\r':
+			{
+				match('\r');
+				break;
+			}
+			default:
+			{
+				if ( _cnt15>=1 ) { break _loop15; } else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+			}
+			}
+			_cnt15++;
+		} while (true);
+		}
+		_ttype = Token.SKIP;
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mDECIMAL_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = DECIMAL_LITERAL;
+		int _saveIndex;
+		
+		{
+		switch ( LA(1)) {
+		case '-':
+		{
+			match('-');
+			break;
+		}
+		case '1':  case '2':  case '3':  case '4':
+		case '5':  case '6':  case '7':  case '8':
+		case '9':
+		{
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
+		}
+		}
+		}
+		{
+		matchRange('1','9');
+		}
+		{
+		_loop20:
+		do {
+			if (((LA(1) >= '0' && LA(1) <= '9'))) {
+				matchRange('0','9');
+			}
+			else {
+				break _loop20;
+			}
+			
+		} while (true);
+		}
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mHEX_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = HEX_LITERAL;
+		int _saveIndex;
+		
+		match('0');
+		match('x');
+		{
+		int _cnt23=0;
+		_loop23:
+		do {
+			switch ( LA(1)) {
+			case '0':  case '1':  case '2':  case '3':
+			case '4':  case '5':  case '6':  case '7':
+			case '8':  case '9':
+			{
+				matchRange('0','9');
+				break;
+			}
+			case 'a':  case 'b':  case 'c':  case 'd':
+			case 'e':  case 'f':
+			{
+				matchRange('a','f');
+				break;
+			}
+			default:
+			{
+				if ( _cnt23>=1 ) { break _loop23; } else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+			}
+			}
+			_cnt23++;
+		} while (true);
+		}
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mOCTAL_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = OCTAL_LITERAL;
+		int _saveIndex;
+		
+		match('0');
+		{
+		_loop26:
+		do {
+			if (((LA(1) >= '0' && LA(1) <= '7'))) {
+				matchRange('0','7');
+			}
+			else {
+				break _loop26;
+			}
+			
+		} while (true);
+		}
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mSTRING_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = STRING_LITERAL;
+		int _saveIndex;
+		
+		switch ( LA(1)) {
+		case '\'':
+		{
+			{
+			match('\'');
+			{
+			int _cnt30=0;
+			_loop30:
+			do {
+				if ((_tokenSet_0.member(LA(1)))) {
+					matchNot('\'');
+				}
+				else {
+					if ( _cnt30>=1 ) { break _loop30; } else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+				}
+				
+				_cnt30++;
+			} while (true);
+			}
+			match('\'');
+			}
+			break;
+		}
+		case '"':
+		{
+			{
+			match('\"');
+			{
+			int _cnt33=0;
+			_loop33:
+			do {
+				if ((_tokenSet_1.member(LA(1)))) {
+					matchNot('\"');
+				}
+				else {
+					if ( _cnt33>=1 ) { break _loop33; } else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+				}
+				
+				_cnt33++;
+			} while (true);
+			}
+			match('\"');
+			}
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
+		}
+		}
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mLBRACKET(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = LBRACKET;
+		int _saveIndex;
+		
+		match('[');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mRBRACKET(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = RBRACKET;
+		int _saveIndex;
+		
+		match(']');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mLPAREN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = LPAREN;
+		int _saveIndex;
+		
+		match('(');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mRPAREN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = RPAREN;
+		int _saveIndex;
+		
+		match(')');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mTHIS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = THIS;
+		int _saveIndex;
+		
+		match("*this*");
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mIDENTIFIER(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = IDENTIFIER;
+		int _saveIndex;
+		
+		{
+		switch ( LA(1)) {
+		case 'a':  case 'b':  case 'c':  case 'd':
+		case 'e':  case 'f':  case 'g':  case 'h':
+		case 'i':  case 'j':  case 'k':  case 'l':
+		case 'm':  case 'n':  case 'o':  case 'p':
+		case 'q':  case 'r':  case 's':  case 't':
+		case 'u':  case 'v':  case 'w':  case 'x':
+		case 'y':  case 'z':
+		{
+			matchRange('a','z');
+			break;
+		}
+		case '.':
+		{
+			match('.');
+			break;
+		}
+		case '_':
+		{
+			match('_');
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
+		}
+		}
+		}
+		{
+		int _cnt42=0;
+		_loop42:
+		do {
+			switch ( LA(1)) {
+			case 'a':  case 'b':  case 'c':  case 'd':
+			case 'e':  case 'f':  case 'g':  case 'h':
+			case 'i':  case 'j':  case 'k':  case 'l':
+			case 'm':  case 'n':  case 'o':  case 'p':
+			case 'q':  case 'r':  case 's':  case 't':
+			case 'u':  case 'v':  case 'w':  case 'x':
+			case 'y':  case 'z':
+			{
+				matchRange('a','z');
+				break;
+			}
+			case '0':  case '1':  case '2':  case '3':
+			case '4':  case '5':  case '6':  case '7':
+			case '8':  case '9':
+			{
+				matchRange('0','9');
+				break;
+			}
+			case '.':
+			{
+				match('.');
+				break;
+			}
+			case '_':
+			{
+				match('_');
+				break;
+			}
+			default:
+			{
+				if ( _cnt42>=1 ) { break _loop42; } else {throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());}
+			}
+			}
+			_cnt42++;
+		} while (true);
+		}
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mEQUALSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = EQUALSIGN;
+		int _saveIndex;
+		
+		match('=');
+		match('=');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mNOTEQUALSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = NOTEQUALSIGN;
+		int _saveIndex;
+		
+		match('!');
+		match('=');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mLESSTHANSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = LESSTHANSIGN;
+		int _saveIndex;
+		
+		match('<');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mGREATERTHANSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = GREATERTHANSIGN;
+		int _saveIndex;
+		
+		match('>');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mLESSEQUALSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = LESSEQUALSIGN;
+		int _saveIndex;
+		
+		match('<');
+		match('=');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	public final void mGREATEREQUALSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
+		int _ttype; Token _token=null; int _begin=text.length();
+		_ttype = GREATEREQUALSIGN;
+		int _saveIndex;
+		
+		match('>');
+		match('=');
+		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
+			_token = makeToken(_ttype);
+			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
+		}
+		_returnToken = _token;
+	}
+	
+	
+	private static final long[] mk_tokenSet_0() {
+		long[] data = { -554050771456L, 9223372036854775807L, 0L, 0L};
+		return data;
+	}
+	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
+	private static final long[] mk_tokenSet_1() {
+		long[] data = { -21474826752L, 9223372036854775807L, 0L, 0L};
+		return data;
+	}
+	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
+	
+	}
diff --git a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.g b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.g
index b2193aada..596b68de6 100644
--- a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.g
+++ b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.g
@@ -241,6 +241,7 @@ options {
  k=2;
 caseSensitive=false;
 defaultErrorHandler=false;
+charVocabulary='\40'..'\176';
 }
 tokens {
 ANDSIGN="and";
diff --git a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.java b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.java
index f3ab97631..e981c5ef1 100644
--- a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.java
+++ b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParser.java
@@ -1,3 +1,5 @@
+// $ANTLR 2.7.2: "ValidWhenParser.g" -> "ValidWhenParser.java"$
+
 /*
  * $Id$
  *
@@ -18,516 +20,519 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.apache.struts.validator.validwhen;
-
-import antlr.NoViableAltException;
-import antlr.ParserSharedInputState;
-import antlr.RecognitionException;
-import antlr.Token;
-import antlr.TokenBuffer;
-import antlr.TokenStream;
-import antlr.TokenStreamException;
-import antlr.collections.impl.BitSet;
 
-import org.apache.commons.validator.util.ValidatorUtils;
+package org.apache.struts.validator.validwhen;
 
 import java.util.Stack;
+import org.apache.commons.validator.util.ValidatorUtils;
 
-public class ValidWhenParser extends antlr.LLkParser
-    implements ValidWhenParserTokenTypes {
-    public static final String[] _tokenNames =
-        {
-            "<0>", "EOF", "<2>", "NULL_TREE_LOOKAHEAD", "DECIMAL_LITERAL",
-            "HEX_LITERAL", "OCTAL_LITERAL", "STRING_LITERAL", "IDENTIFIER",
-            "LBRACKET", "RBRACKET", "\"null\"", "THIS", "LPAREN", "RPAREN",
-            "\"and\"", "\"or\"", "EQUALSIGN", "GREATERTHANSIGN",
-            "GREATEREQUALSIGN", "LESSTHANSIGN", "LESSEQUALSIGN", "NOTEQUALSIGN",
-            "WS"
-        };
-    public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
-    public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
-    Stack argStack = new Stack();
-    Object form;
-    int index;
-    String value;
-    private final int LESS_EQUAL = 0;
-    private final int LESS_THAN = 1;
-    private final int EQUAL = 2;
-    private final int GREATER_THAN = 3;
-    private final int GREATER_EQUAL = 4;
-    private final int NOT_EQUAL = 5;
-    private final int AND = 6;
-    private final int OR = 7;
-
-    protected ValidWhenParser(TokenBuffer tokenBuf, int k) {
-        super(tokenBuf, k);
-        tokenNames = _tokenNames;
-    }
-
-    public ValidWhenParser(TokenBuffer tokenBuf) {
-        this(tokenBuf, 6);
-    }
-
-    protected ValidWhenParser(TokenStream lexer, int k) {
-        super(lexer, k);
-        tokenNames = _tokenNames;
-    }
 
-    public ValidWhenParser(TokenStream lexer) {
-        this(lexer, 6);
-    }
-
-    public ValidWhenParser(ParserSharedInputState state) {
-        super(state, 6);
-        tokenNames = _tokenNames;
-    }
-
-    public void setForm(Object f) {
-        form = f;
-    }
+import antlr.TokenBuffer;
+import antlr.TokenStreamException;
+import antlr.TokenStreamIOException;
+import antlr.ANTLRException;
+import antlr.LLkParser;
+import antlr.Token;
+import antlr.TokenStream;
+import antlr.RecognitionException;
+import antlr.NoViableAltException;
+import antlr.MismatchedTokenException;
+import antlr.SemanticException;
+import antlr.ParserSharedInputState;
+import antlr.collections.impl.BitSet;
 
-    public void setIndex(int i) {
-        index = i;
-    }
+public class ValidWhenParser extends antlr.LLkParser       implements ValidWhenParserTokenTypes
+ {
+Stack argStack = new Stack();
+Object form;
+int index;
+String value;
 
-    public void setValue(String v) {
-        value = v;
-    }
+    public void setForm(Object f) { form = f; };
+    public void setIndex (int i) { index = i; };
+    public void setValue (String v) { value = v; };
 
     public boolean getResult() {
-        return ((Boolean) argStack.peek()).booleanValue();
-    }
-
-    private boolean evaluateComparison(Object v1, Object compare, Object v2) {
-        boolean intCompare = true;
-
-        if ((v1 == null) || (v2 == null)) {
-            if (String.class.isInstance(v1)) {
-                if (((String) v1).length() == 0) {
-                    v1 = null;
-                }
-            }
-
-            if (String.class.isInstance(v2)) {
-                if (((String) v2).length() == 0) {
-                    v2 = null;
-                }
-            }
-
-            switch (((Integer) compare).intValue()) {
-            case LESS_EQUAL:
-            case GREATER_THAN:
-            case LESS_THAN:
-            case GREATER_EQUAL:
-                return false;
-
-            case EQUAL:
-                return (v1 == v2);
-
-            case NOT_EQUAL:
-                return (v1 != v2);
-            }
-        }
-
-        if ((Integer.class.isInstance(v1) || String.class.isInstance(v1))
-            && (Integer.class.isInstance(v2) || String.class.isInstance(v2))) {
-            intCompare = true;
-        } else {
-            intCompare = false;
-        }
-
-        if (intCompare) {
-            try {
-                int v1i = 0;
-                int v2i = 0;
-
-                if (Integer.class.isInstance(v1)) {
-                    v1i = ((Integer) v1).intValue();
-                } else {
-                    v1i = Integer.parseInt((String) v1);
-                }
-
-                if (Integer.class.isInstance(v2)) {
-                    v2i = ((Integer) v2).intValue();
-                } else {
-                    v2i = Integer.parseInt((String) v2);
-                }
-
-                switch (((Integer) compare).intValue()) {
-                case LESS_EQUAL:
-                    return (v1i <= v2i);
-
-                case LESS_THAN:
-                    return (v1i < v2i);
-
-                case EQUAL:
-                    return (v1i == v2i);
-
-                case GREATER_THAN:
-                    return (v1i > v2i);
-
-                case GREATER_EQUAL:
-                    return (v1i >= v2i);
-
-                case NOT_EQUAL:
-                    return (v1i != v2i);
-                }
-            } catch (NumberFormatException ex) {
-                ; // do nothing
-            }
-
-            ;
-        }
-
-        String v1s = "";
-        String v2s = "";
-
-        if (Integer.class.isInstance(v1)) {
-            v1s = ((Integer) v1).toString();
-        } else {
-            v1s = (String) v1;
-        }
-
-        if (Integer.class.isInstance(v2)) {
-            v2s = ((Integer) v2).toString();
-        } else {
-            v2s = (String) v2;
-        }
-
-        int res = v1s.compareTo(v2s);
-
-        switch (((Integer) compare).intValue()) {
-        case LESS_EQUAL:
-            return (res <= 0);
-
-        case LESS_THAN:
-            return (res < 0);
-
-        case EQUAL:
-            return (res == 0);
-
-        case GREATER_THAN:
-            return (res > 0);
-
-        case GREATER_EQUAL:
-            return (res >= 0);
-
-        case NOT_EQUAL:
-            return (res != 0);
-        }
-
-        return true;
+       return ((Boolean)argStack.peek()).booleanValue();
     }
 
-    public final void integer()
-        throws RecognitionException, TokenStreamException {
-        Token d = null;
-        Token h = null;
-        Token o = null;
-
-        switch (LA(1)) {
-        case DECIMAL_LITERAL: {
-            d = LT(1);
-            match(DECIMAL_LITERAL);
-            argStack.push(Integer.decode(d.getText()));
-
-            break;
-        }
-
-        case HEX_LITERAL: {
-            h = LT(1);
-            match(HEX_LITERAL);
-            argStack.push(Integer.decode(h.getText()));
+    private final int LESS_EQUAL=0;
+    private final int LESS_THAN=1;
+    private final int EQUAL=2;
+    private final int GREATER_THAN=3;
+    private final int GREATER_EQUAL=4;
+    private final int NOT_EQUAL=5;
+    private final int AND=6;
+    private final int OR=7;
 
-            break;
-        }
-
-        case OCTAL_LITERAL: {
-            o = LT(1);
-            match(OCTAL_LITERAL);
-            argStack.push(Integer.decode(o.getText()));
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
-
-    public final void string()
-        throws RecognitionException, TokenStreamException {
-        Token str = null;
-
-        str = LT(1);
-        match(STRING_LITERAL);
-        argStack.push(str.getText().substring(1, str.getText().length() - 1));
-    }
-
-    public final void identifier()
-        throws RecognitionException, TokenStreamException {
-        Token str = null;
-
-        str = LT(1);
-        match(IDENTIFIER);
-        argStack.push(str.getText());
-    }
-
-    public final void field()
-        throws RecognitionException, TokenStreamException {
-        if ((LA(1) == IDENTIFIER) && (LA(2) == LBRACKET) && (LA(3) == RBRACKET)
-            && (LA(4) == IDENTIFIER)) {
-            identifier();
-            match(LBRACKET);
-            match(RBRACKET);
-            identifier();
-
-            Object i2 = argStack.pop();
-            Object i1 = argStack.pop();
-
-            argStack.push(ValidatorUtils.getValueAsString(form,
-                    i1 + "[" + index + "]" + i2));
-        } else if ((LA(1) == IDENTIFIER) && (LA(2) == LBRACKET)
-            && ((LA(3) >= DECIMAL_LITERAL) && (LA(3) <= OCTAL_LITERAL))
-            && (LA(4) == RBRACKET) && (LA(5) == IDENTIFIER)) {
-            identifier();
-            match(LBRACKET);
-            integer();
-            match(RBRACKET);
-            identifier();
-
-            Object i5 = argStack.pop();
-            Object i4 = argStack.pop();
-            Object i3 = argStack.pop();
-
-            argStack.push(ValidatorUtils.getValueAsString(form,
-                    i3 + "[" + i4 + "]" + i5));
-        } else if ((LA(1) == IDENTIFIER) && (LA(2) == LBRACKET)
-            && ((LA(3) >= DECIMAL_LITERAL) && (LA(3) <= OCTAL_LITERAL))
-            && (LA(4) == RBRACKET) && (LA(5) == LBRACKET)) {
-            identifier();
-            match(LBRACKET);
-            integer();
-            match(RBRACKET);
-            match(LBRACKET);
-
-            Object i7 = argStack.pop();
-            Object i6 = argStack.pop();
-
-            argStack.push(ValidatorUtils.getValueAsString(form,
-                    i6 + "[" + i7 + "]"));
-        } else if ((LA(1) == IDENTIFIER) && (LA(2) == LBRACKET)
-            && (LA(3) == RBRACKET) && (_tokenSet_0.member(LA(4)))) {
-            identifier();
-            match(LBRACKET);
-            match(RBRACKET);
-
-            Object i8 = argStack.pop();
-
-            argStack.push(ValidatorUtils.getValueAsString(form,
-                    i8 + "[" + index + "]"));
-        } else if ((LA(1) == IDENTIFIER) && (_tokenSet_0.member(LA(2)))) {
-            identifier();
-
-            Object i9 = argStack.pop();
-
-            argStack.push(ValidatorUtils.getValueAsString(form, (String) i9));
-        } else {
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
-
-    public final void literal()
-        throws RecognitionException, TokenStreamException {
-        switch (LA(1)) {
-        case DECIMAL_LITERAL:
-        case HEX_LITERAL:
-        case OCTAL_LITERAL: {
-            integer();
-
-            break;
-        }
-
-        case STRING_LITERAL: {
-            string();
-
-            break;
-        }
-
-        case LITERAL_null: {
-            match(LITERAL_null);
-            argStack.push(null);
-
-            break;
-        }
-
-        case THIS: {
-            match(THIS);
-            argStack.push(value);
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
-
-    public final void value()
-        throws RecognitionException, TokenStreamException {
-        switch (LA(1)) {
-        case IDENTIFIER: {
-            field();
-
-            break;
-        }
-
-        case DECIMAL_LITERAL:
-        case HEX_LITERAL:
-        case OCTAL_LITERAL:
-        case STRING_LITERAL:
-        case LITERAL_null:
-        case THIS: {
-            literal();
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
-
-    public final void expression()
-        throws RecognitionException, TokenStreamException {
-        expr();
-        match(Token.EOF_TYPE);
-    }
-
-    public final void expr() throws RecognitionException, TokenStreamException {
-        if ((LA(1) == LPAREN) && (_tokenSet_1.member(LA(2)))) {
-            match(LPAREN);
-            comparisonExpression();
-            match(RPAREN);
-        } else if ((LA(1) == LPAREN) && (LA(2) == LPAREN)) {
-            match(LPAREN);
-            joinedExpression();
-            match(RPAREN);
-        } else {
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
-
-    public final void comparisonExpression()
-        throws RecognitionException, TokenStreamException {
-        value();
-        comparison();
-        value();
-
-        Object v2 = argStack.pop();
-        Object comp = argStack.pop();
-        Object v1 = argStack.pop();
-
-        argStack.push(new Boolean(evaluateComparison(v1, comp, v2)));
-    }
-
-    public final void joinedExpression()
-        throws RecognitionException, TokenStreamException {
-        expr();
-        join();
-        expr();
-
-        Boolean v1 = (Boolean) argStack.pop();
-        Integer join = (Integer) argStack.pop();
-        Boolean v2 = (Boolean) argStack.pop();
-
-        if (join.intValue() == AND) {
-            argStack.push(new Boolean(v1.booleanValue() && v2.booleanValue()));
-        } else {
-            argStack.push(new Boolean(v1.booleanValue() || v2.booleanValue()));
-        }
-    }
-
-    public final void join() throws RecognitionException, TokenStreamException {
-        switch (LA(1)) {
-        case ANDSIGN: {
-            match(ANDSIGN);
-            argStack.push(new Integer(AND));
-
-            break;
-        }
-
-        case ORSIGN: {
-            match(ORSIGN);
-            argStack.push(new Integer(OR));
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltException(LT(1), getFilename());
-        }
+    private  boolean evaluateComparison (Object v1, Object compare, Object v2) {
+        boolean intCompare = true;
+	if ((v1 == null) || (v2 == null)) {
+		if (String.class.isInstance(v1)) {
+			if (((String) v1).length() == 0) {
+				v1 = null;
+			}
+		}
+		if (String.class.isInstance(v2)) {
+			if (((String) v2).length() == 0) {
+				v2 = null;
+			}
+		}
+		switch (((Integer)compare).intValue()) {
+		case LESS_EQUAL:
+		case GREATER_THAN:
+		case LESS_THAN:
+		case GREATER_EQUAL:
+			return false;
+		case EQUAL:
+		    return (v1 == v2);
+		case NOT_EQUAL:
+		    return (v1 != v2);
+		}
+	}
+      if ((Integer.class.isInstance(v1) ||
+           String.class.isInstance(v1)) &&
+	    (Integer.class.isInstance(v2) ||
+           String.class.isInstance(v2))) {
+	    intCompare = true;
+      } else {
+	    intCompare = false;
+	}
+	if (intCompare) {
+	    try {
+		int v1i = 0, v2i = 0;
+		if (Integer.class.isInstance(v1)) {
+		    v1i = ((Integer)v1).intValue();
+		} else {
+		    v1i = Integer.parseInt((String) v1);
+		}
+		if (Integer.class.isInstance(v2)) {
+		    v2i = ((Integer)v2).intValue();
+		} else {
+		    v2i = Integer.parseInt((String) v2);
+		}
+		switch (((Integer)compare).intValue()) {
+		case LESS_EQUAL:
+		    return (v1i <= v2i);
+
+		case LESS_THAN:
+		    return (v1i < v2i);
+
+		case EQUAL:
+		    return (v1i == v2i);
+
+		case GREATER_THAN:
+		    return (v1i > v2i);
+
+		case GREATER_EQUAL:
+		    return (v1i >= v2i);
+
+		case NOT_EQUAL:
+		    return (v1i != v2i);
+		}
+	    } catch (NumberFormatException ex) {};
+	}
+	String v1s = "", v2s = "";
+
+	if (Integer.class.isInstance(v1)) {
+	    v1s = ((Integer)v1).toString();
+	} else {
+	    v1s = (String) v1;
+	}
+
+	if (Integer.class.isInstance(v2)) {
+	    v2s = ((Integer)v2).toString();
+	} else {
+	    v2s = (String) v2;
+	}
+
+	int res = v1s.compareTo(v2s);
+	switch (((Integer)compare).intValue()) {
+	case LESS_EQUAL:
+	    return (res <= 0);
+
+	case LESS_THAN:
+	    return (res < 0);
+
+	case EQUAL:
+	    return (res == 0);
+
+	case GREATER_THAN:
+	    return (res > 0);
+
+	case GREATER_EQUAL:
+	    return (res >= 0);
+
+	case NOT_EQUAL:
+	    return (res != 0);
+	}
+	return true;
     }
 
-    public final void comparison()
-        throws RecognitionException, TokenStreamException {
-        switch (LA(1)) {
-        case EQUALSIGN: {
-            match(EQUALSIGN);
-            argStack.push(new Integer(EQUAL));
-
-            break;
-        }
-
-        case GREATERTHANSIGN: {
-            match(GREATERTHANSIGN);
-            argStack.push(new Integer(GREATER_THAN));
 
-            break;
-        }
-
-        case GREATEREQUALSIGN: {
-            match(GREATEREQUALSIGN);
-            argStack.push(new Integer(GREATER_EQUAL));
-
-            break;
-        }
-
-        case LESSTHANSIGN: {
-            match(LESSTHANSIGN);
-            argStack.push(new Integer(LESS_THAN));
-
-            break;
-        }
-
-        case LESSEQUALSIGN: {
-            match(LESSEQUALSIGN);
-            argStack.push(new Integer(LESS_EQUAL));
-
-            break;
-        }
-
-        case NOTEQUALSIGN: {
-            match(NOTEQUALSIGN);
-            argStack.push(new Integer(NOT_EQUAL));
-
-            break;
-        }
-
-        default:
-            throw new NoViableAltException(LT(1), getFilename());
-        }
-    }
+protected ValidWhenParser(TokenBuffer tokenBuf, int k) {
+  super(tokenBuf,k);
+  tokenNames = _tokenNames;
+}
 
-    private static final long[] mk_tokenSet_0() {
-        long[] data = { 8273920L, 0L };
+public ValidWhenParser(TokenBuffer tokenBuf) {
+  this(tokenBuf,6);
+}
 
-        return data;
-    }
+protected ValidWhenParser(TokenStream lexer, int k) {
+  super(lexer,k);
+  tokenNames = _tokenNames;
+}
 
-    private static final long[] mk_tokenSet_1() {
-        long[] data = { 6640L, 0L };
+public ValidWhenParser(TokenStream lexer) {
+  this(lexer,6);
+}
 
-        return data;
-    }
+public ValidWhenParser(ParserSharedInputState state) {
+  super(state,6);
+  tokenNames = _tokenNames;
 }
+
+	public final void integer() throws RecognitionException, TokenStreamException {
+		
+		Token  d = null;
+		Token  h = null;
+		Token  o = null;
+		
+		switch ( LA(1)) {
+		case DECIMAL_LITERAL:
+		{
+			d = LT(1);
+			match(DECIMAL_LITERAL);
+			argStack.push(Integer.decode(d.getText()));
+			break;
+		}
+		case HEX_LITERAL:
+		{
+			h = LT(1);
+			match(HEX_LITERAL);
+			argStack.push(Integer.decode(h.getText()));
+			break;
+		}
+		case OCTAL_LITERAL:
+		{
+			o = LT(1);
+			match(OCTAL_LITERAL);
+			argStack.push(Integer.decode(o.getText()));
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		}
+	}
+	
+	public final void string() throws RecognitionException, TokenStreamException {
+		
+		Token  str = null;
+		
+		str = LT(1);
+		match(STRING_LITERAL);
+		argStack.push(str.getText().substring(1, str.getText().length()-1));
+	}
+	
+	public final void identifier() throws RecognitionException, TokenStreamException {
+		
+		Token  str = null;
+		
+		str = LT(1);
+		match(IDENTIFIER);
+		argStack.push(str.getText());
+	}
+	
+	public final void field() throws RecognitionException, TokenStreamException {
+		
+		
+		if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (LA(4)==IDENTIFIER)) {
+			identifier();
+			match(LBRACKET);
+			match(RBRACKET);
+			identifier();
+			
+			Object i2 = argStack.pop();
+			Object i1 = argStack.pop();
+			argStack.push(ValidatorUtils.getValueAsString(form, i1 + "[" + index + "]" + i2));
+			
+		}
+		else if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (LA(5)==IDENTIFIER)) {
+			identifier();
+			match(LBRACKET);
+			integer();
+			match(RBRACKET);
+			identifier();
+			
+			Object i5 = argStack.pop();
+			Object i4 = argStack.pop();
+			Object i3 = argStack.pop();
+			argStack.push(ValidatorUtils.getValueAsString(form, i3 + "[" + i4 + "]" + i5));
+			
+		}
+		else if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (LA(5)==LBRACKET)) {
+			identifier();
+			match(LBRACKET);
+			integer();
+			match(RBRACKET);
+			match(LBRACKET);
+			
+			Object i7 = argStack.pop();
+			Object i6 = argStack.pop();
+			argStack.push(ValidatorUtils.getValueAsString(form, i6 + "[" + i7 + "]"));
+			
+		}
+		else if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (_tokenSet_0.member(LA(4)))) {
+			identifier();
+			match(LBRACKET);
+			match(RBRACKET);
+			
+			Object i8 = argStack.pop();
+			argStack.push(ValidatorUtils.getValueAsString(form, i8 + "[" + index + "]"));
+			
+		}
+		else if ((LA(1)==IDENTIFIER) && (_tokenSet_0.member(LA(2)))) {
+			identifier();
+			
+			Object i9 = argStack.pop();
+			argStack.push(ValidatorUtils.getValueAsString(form, (String)i9));
+			
+		}
+		else {
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		
+	}
+	
+	public final void literal() throws RecognitionException, TokenStreamException {
+		
+		
+		switch ( LA(1)) {
+		case DECIMAL_LITERAL:
+		case HEX_LITERAL:
+		case OCTAL_LITERAL:
+		{
+			integer();
+			break;
+		}
+		case STRING_LITERAL:
+		{
+			string();
+			break;
+		}
+		case LITERAL_null:
+		{
+			match(LITERAL_null);
+			argStack.push(null);
+			break;
+		}
+		case THIS:
+		{
+			match(THIS);
+			argStack.push(value);
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		}
+	}
+	
+	public final void value() throws RecognitionException, TokenStreamException {
+		
+		
+		switch ( LA(1)) {
+		case IDENTIFIER:
+		{
+			field();
+			break;
+		}
+		case DECIMAL_LITERAL:
+		case HEX_LITERAL:
+		case OCTAL_LITERAL:
+		case STRING_LITERAL:
+		case LITERAL_null:
+		case THIS:
+		{
+			literal();
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		}
+	}
+	
+	public final void expression() throws RecognitionException, TokenStreamException {
+		
+		
+		expr();
+		match(Token.EOF_TYPE);
+	}
+	
+	public final void expr() throws RecognitionException, TokenStreamException {
+		
+		
+		if ((LA(1)==LPAREN) && (_tokenSet_1.member(LA(2)))) {
+			match(LPAREN);
+			comparisonExpression();
+			match(RPAREN);
+		}
+		else if ((LA(1)==LPAREN) && (LA(2)==LPAREN)) {
+			match(LPAREN);
+			joinedExpression();
+			match(RPAREN);
+		}
+		else {
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		
+	}
+	
+	public final void comparisonExpression() throws RecognitionException, TokenStreamException {
+		
+		
+		value();
+		comparison();
+		value();
+		
+			    Object v2 = argStack.pop();
+			    Object comp = argStack.pop();
+		Object v1 = argStack.pop();
+		argStack.push(new Boolean(evaluateComparison(v1, comp, v2)));
+		
+	}
+	
+	public final void joinedExpression() throws RecognitionException, TokenStreamException {
+		
+		
+		expr();
+		join();
+		expr();
+		
+		Boolean v1 = (Boolean) argStack.pop();
+		Integer join = (Integer) argStack.pop();
+		Boolean v2 = (Boolean) argStack.pop();
+		if (join.intValue() == AND) {
+		argStack.push(new Boolean(v1.booleanValue() && v2.booleanValue()));
+		} else {
+		argStack.push(new Boolean(v1.booleanValue() || v2.booleanValue()));
+		}
+		
+	}
+	
+	public final void join() throws RecognitionException, TokenStreamException {
+		
+		
+		switch ( LA(1)) {
+		case ANDSIGN:
+		{
+			match(ANDSIGN);
+			argStack.push(new Integer(AND));
+			break;
+		}
+		case ORSIGN:
+		{
+			match(ORSIGN);
+			argStack.push(new Integer(OR));
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		}
+	}
+	
+	public final void comparison() throws RecognitionException, TokenStreamException {
+		
+		
+		switch ( LA(1)) {
+		case EQUALSIGN:
+		{
+			match(EQUALSIGN);
+			argStack.push(new Integer(EQUAL));
+			break;
+		}
+		case GREATERTHANSIGN:
+		{
+			match(GREATERTHANSIGN);
+			argStack.push(new Integer(GREATER_THAN));
+			break;
+		}
+		case GREATEREQUALSIGN:
+		{
+			match(GREATEREQUALSIGN);
+			argStack.push(new Integer(GREATER_EQUAL));
+			break;
+		}
+		case LESSTHANSIGN:
+		{
+			match(LESSTHANSIGN);
+			argStack.push(new Integer(LESS_THAN));
+			break;
+		}
+		case LESSEQUALSIGN:
+		{
+			match(LESSEQUALSIGN);
+			argStack.push(new Integer(LESS_EQUAL));
+			break;
+		}
+		case NOTEQUALSIGN:
+		{
+			match(NOTEQUALSIGN);
+			argStack.push(new Integer(NOT_EQUAL));
+			break;
+		}
+		default:
+		{
+			throw new NoViableAltException(LT(1), getFilename());
+		}
+		}
+	}
+	
+	
+	public static final String[] _tokenNames = {
+		"<0>",
+		"EOF",
+		"<2>",
+		"NULL_TREE_LOOKAHEAD",
+		"DECIMAL_LITERAL",
+		"HEX_LITERAL",
+		"OCTAL_LITERAL",
+		"STRING_LITERAL",
+		"IDENTIFIER",
+		"LBRACKET",
+		"RBRACKET",
+		"\"null\"",
+		"THIS",
+		"LPAREN",
+		"RPAREN",
+		"\"and\"",
+		"\"or\"",
+		"EQUALSIGN",
+		"GREATERTHANSIGN",
+		"GREATEREQUALSIGN",
+		"LESSTHANSIGN",
+		"LESSEQUALSIGN",
+		"NOTEQUALSIGN",
+		"WS"
+	};
+	
+	private static final long[] mk_tokenSet_0() {
+		long[] data = { 8273920L, 0L};
+		return data;
+	}
+	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
+	private static final long[] mk_tokenSet_1() {
+		long[] data = { 6640L, 0L};
+		return data;
+	}
+	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
+	
+	}
diff --git a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.java b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.java
index 49793d035..744c591ad 100644
--- a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.java
+++ b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.java
@@ -1,3 +1,5 @@
+// $ANTLR 2.7.2: "ValidWhenParser.g" -> "ValidWhenParser.java"$
+
 /*
  * $Id$
  *
@@ -18,29 +20,34 @@
  * specific language governing permissions and limitations
  * under the License.
  */
+
 package org.apache.struts.validator.validwhen;
 
+import java.util.Stack;
+import org.apache.commons.validator.util.ValidatorUtils;
+
+
 public interface ValidWhenParserTokenTypes {
-    int EOF = 1;
-    int NULL_TREE_LOOKAHEAD = 3;
-    int DECIMAL_LITERAL = 4;
-    int HEX_LITERAL = 5;
-    int OCTAL_LITERAL = 6;
-    int STRING_LITERAL = 7;
-    int IDENTIFIER = 8;
-    int LBRACKET = 9;
-    int RBRACKET = 10;
-    int LITERAL_null = 11;
-    int THIS = 12;
-    int LPAREN = 13;
-    int RPAREN = 14;
-    int ANDSIGN = 15;
-    int ORSIGN = 16;
-    int EQUALSIGN = 17;
-    int GREATERTHANSIGN = 18;
-    int GREATEREQUALSIGN = 19;
-    int LESSTHANSIGN = 20;
-    int LESSEQUALSIGN = 21;
-    int NOTEQUALSIGN = 22;
-    int WS = 23;
+	int EOF = 1;
+	int NULL_TREE_LOOKAHEAD = 3;
+	int DECIMAL_LITERAL = 4;
+	int HEX_LITERAL = 5;
+	int OCTAL_LITERAL = 6;
+	int STRING_LITERAL = 7;
+	int IDENTIFIER = 8;
+	int LBRACKET = 9;
+	int RBRACKET = 10;
+	int LITERAL_null = 11;
+	int THIS = 12;
+	int LPAREN = 13;
+	int RPAREN = 14;
+	int ANDSIGN = 15;
+	int ORSIGN = 16;
+	int EQUALSIGN = 17;
+	int GREATERTHANSIGN = 18;
+	int GREATEREQUALSIGN = 19;
+	int LESSTHANSIGN = 20;
+	int LESSEQUALSIGN = 21;
+	int NOTEQUALSIGN = 22;
+	int WS = 23;
 }
diff --git a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.txt b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.txt
index d79d41075..50a81c65b 100644
--- a/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.txt
+++ b/core/src/main/java/org/apache/struts/validator/validwhen/ValidWhenParserTokenTypes.txt
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.2: validWhenParser.g -> ValidWhenParserTokenTypes.txt$
+// $ANTLR 2.7.2: ValidWhenParser.g -> ValidWhenParserTokenTypes.txt$
 ValidWhenParser    // output token vocab name
 DECIMAL_LITERAL=4
 HEX_LITERAL=5
diff --git a/core/src/test/java/org/apache/struts/validator/TestValidWhen.java b/core/src/test/java/org/apache/struts/validator/TestValidWhen.java
index 5e6455d1d..f03eb1877 100644
--- a/core/src/test/java/org/apache/struts/validator/TestValidWhen.java
+++ b/core/src/test/java/org/apache/struts/validator/TestValidWhen.java
@@ -141,6 +141,12 @@ public class TestValidWhen extends TestCase {
         // double quote
         doParse("(*this* == \"" + testValue + "\")", testValue, 0,
             "stringValue1", true);
+
+        // obscure characters
+        doParse("(*this* == \":\")", ":", 0,
+            "stringValue1", true);
+        doParse("(*this* == \"foo:bar\")", "foo:bar", 0,
+            "stringValue1", true);
     }
 
     /**
