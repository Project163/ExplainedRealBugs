diff --git a/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java b/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
index fd0fc8d2ad..d086fa4d6b 100644
--- a/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
+++ b/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
@@ -15,7 +15,7 @@ import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.nio.channels.FileLock;
 import java.nio.channels.OverlappingFileLockException;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.function.BiConsumer;
 import java.util.function.Supplier;
@@ -123,9 +123,25 @@ public class FileBasedHostnamePortLookupTable implements HostnamePortLookupTable
     private void readFromTable() {
         assert sharedTableWire.startUse();
         try {
-            allMappings.clear();
             ((YamlWire) sharedTableWire).reset();
-            sharedTableWire.readAllAsMap(String.class, ProcessScopedMapping.class, allMappings);
+
+            // Add new, update changed
+            Map<String, ProcessScopedMapping> readMappings = new HashMap<>();
+            sharedTableWire.readAllAsMap(String.class, ProcessScopedMapping.class, readMappings);
+            for (Map.Entry<String, ProcessScopedMapping> readMapping : readMappings.entrySet()) {
+                final ProcessScopedMapping existingMapping = allMappings.get(readMapping.getKey());
+                if (existingMapping == null || !existingMapping.equals(readMapping.getValue())) {
+                    allMappings.put(readMapping.getKey(), readMapping.getValue());
+                }
+            }
+
+            // Remove removed
+            Set<String> existingKeys = new HashSet<>(allMappings.keySet());
+            for (String key : existingKeys) {
+                if (!readMappings.containsKey(key)) {
+                    allMappings.remove(key);
+                }
+            }
         } finally {
             assert sharedTableWire.endUse();
         }
@@ -175,14 +191,14 @@ public class FileBasedHostnamePortLookupTable implements HostnamePortLookupTable
         }
     }
 
-    private static class ProcessScopedMapping implements ReadMarshallable, WriteMarshallable {
+    static class ProcessScopedMapping implements ReadMarshallable, WriteMarshallable {
         private int pid;
         private InetSocketAddress address;
 
         public ProcessScopedMapping() {
         }
 
-        private ProcessScopedMapping(int pid, InetSocketAddress address) {
+        public ProcessScopedMapping(int pid, InetSocketAddress address) {
             this.pid = pid;
             this.address = address;
         }
@@ -190,7 +206,7 @@ public class FileBasedHostnamePortLookupTable implements HostnamePortLookupTable
         @Override
         public void readMarshallable(@NotNull WireIn wire) throws IORuntimeException {
             pid = wire.read("pid").int32();
-            address = new InetSocketAddress(
+            address = InetSocketAddress.createUnresolved(
                     wire.read("hostname").text(),
                     wire.read("port").readInt());
         }
@@ -201,5 +217,26 @@ public class FileBasedHostnamePortLookupTable implements HostnamePortLookupTable
                     .write("hostname").text(address.getHostName())
                     .write("port").int32(address.getPort());
         }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            ProcessScopedMapping that = (ProcessScopedMapping) o;
+            return pid == that.pid &&
+                    (((address != null && that.address != null)
+                            && Objects.equals(address.getHostName(), that.address.getHostName())
+                            && Objects.equals(address.getPort(), that.address.getPort())))
+                    || (address == null && that.address == null);
+        }
+
+        @Override
+        public int hashCode() {
+            if (address == null) {
+                return Objects.hash(pid);
+            } else {
+                return Objects.hash(pid, address.getHostName(), address.getPort());
+            }
+        }
     }
 }
diff --git a/src/test/java/net/openhft/chronicle/network/FileBasedHostnamePortLookupTableTest.java b/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
similarity index 64%
rename from src/test/java/net/openhft/chronicle/network/FileBasedHostnamePortLookupTableTest.java
rename to src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
index b657f34b48..ae418c94c6 100644
--- a/src/test/java/net/openhft/chronicle/network/FileBasedHostnamePortLookupTableTest.java
+++ b/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
@@ -1,11 +1,9 @@
-package net.openhft.chronicle.network;
+package net.openhft.chronicle.network.internal.lookuptable;
 
 import net.openhft.chronicle.core.io.Closeable;
 import net.openhft.chronicle.core.io.IOTools;
-import net.openhft.chronicle.network.internal.lookuptable.FileBasedHostnamePortLookupTable;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.File;
@@ -75,7 +73,6 @@ public class FileBasedHostnamePortLookupTableTest {
         assertEquals(new HashSet<>(Arrays.asList("aaa", "bbb", "ccc")), allValues);
     }
 
-    @Ignore(/* https://github.com/OpenHFT/Chronicle-Network/issues/103 */)
     @Test(timeout = 20_000)
     public void shouldWorkConcurrently() {
         int para = doShouldWorkConcurrently(true);
@@ -107,4 +104,40 @@ public class FileBasedHostnamePortLookupTableTest {
             return allMyAliases.size();
         }).sum();
     }
+
+    @Test
+    public void mappingsAreEqualRegardlessOfResolution() {
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping unresolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, InetSocketAddress.createUnresolved("localhost", 456));
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping resolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, new InetSocketAddress("localhost", 456));
+        assertEquals(unresolved, resolved);
+    }
+
+    @Test
+    public void mappingsAreEqualWhenNeitherHasAddress() {
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping unresolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, null);
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping resolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, null);
+        assertEquals(unresolved, resolved);
+    }
+
+    @Test
+    public void mappingsHaveSameHashCodeRegardlessOfResolution() {
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping unresolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, InetSocketAddress.createUnresolved("localhost", 456));
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping resolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, new InetSocketAddress("localhost", 456));
+        assertEquals(unresolved.hashCode(), resolved.hashCode());
+    }
+
+    @Test
+    public void mappingsHaveSameHashCodeWhenAddressIsMissing() {
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping unresolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, null);
+        final FileBasedHostnamePortLookupTable.ProcessScopedMapping resolved
+                = new FileBasedHostnamePortLookupTable.ProcessScopedMapping(123, null);
+        assertEquals(unresolved.hashCode(), resolved.hashCode());
+    }
 }
\ No newline at end of file
