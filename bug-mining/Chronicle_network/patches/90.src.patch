diff --git a/src/main/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandler.java
index c4c59e7ceb..f39ebaa669 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandler.java
@@ -61,6 +61,11 @@ public class ClusterAcceptorEventHandler<C extends ClusterContext<C, T>, T exten
                 final T nc = context.networkContextFactory().apply(context);
                 nc.socketChannel(sc);
                 nc.isAcceptor(true);
+                if (context.networkStatsListenerFactory() != null) {
+                    final NetworkStatsListener<T> nsl = context.networkStatsListenerFactory().apply(context);
+                    nc.networkStatsListener(nsl);
+                    nsl.networkContext(nc);
+                }
                 final NetworkStatsListener<T> nl = nc.networkStatsListener();
                 notifyHostPort(sc, nl);
                 final TcpEventHandler<T> tcpEventHandler = context.tcpEventHandlerFactory().apply(nc);
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/VanillaClusteredNetworkContext.java b/src/main/java/net/openhft/chronicle/network/cluster/VanillaClusteredNetworkContext.java
index 72326cead4..b7617e5fb0 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/VanillaClusteredNetworkContext.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/VanillaClusteredNetworkContext.java
@@ -1,7 +1,6 @@
 package net.openhft.chronicle.network.cluster;
 
 import net.openhft.chronicle.core.threads.EventLoop;
-import net.openhft.chronicle.network.NetworkStatsListener;
 import net.openhft.chronicle.network.VanillaNetworkContext;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
@@ -22,12 +21,6 @@ public class VanillaClusteredNetworkContext<T extends VanillaClusteredNetworkCon
         this.eventLoop = clusterContext.eventLoop();
         heartbeatListener(this::logMissedHeartbeat);
         serverThreadingStrategy(clusterContext.serverThreadingStrategy());
-        // make sure network stats set for acceptor
-        if (clusterContext.networkStatsListenerFactory() != null) {
-            final NetworkStatsListener<T> networkStatsListener = clusterContext.networkStatsListenerFactory().apply(clusterContext);
-            this.networkStatsListener(networkStatsListener);
-            networkStatsListener.networkContext((T) this);
-        }
     }
 
     @Override
diff --git a/src/test/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandlerTest.java b/src/test/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandlerTest.java
new file mode 100644
index 0000000000..4d931c4d8f
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/cluster/ClusterAcceptorEventHandlerTest.java
@@ -0,0 +1,93 @@
+package net.openhft.chronicle.network.cluster;
+
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.threads.EventLoop;
+import net.openhft.chronicle.core.util.ThrowingFunction;
+import net.openhft.chronicle.network.*;
+import net.openhft.chronicle.network.connection.VanillaWireOutPublisher;
+import net.openhft.chronicle.threads.EventGroupBuilder;
+import net.openhft.chronicle.wire.WireType;
+import org.jetbrains.annotations.NotNull;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.junit.Assert.assertSame;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+public class ClusterAcceptorEventHandlerTest {
+
+    @Test
+    public void willPopulateNetworkStatsListenerWhenNetworkStatsListenerFactorySpecified() throws IOException {
+        TCPRegistry.createServerSocketChannelFor("testAcceptor");
+        final MyClusterContext acceptorContext = new MyClusterContext();
+        final NetworkStatsListener<MyClusteredNetworkContext> nsl = mock(NetworkStatsListener.class);
+        acceptorContext.networkStatsListenerFactory(clusterContext -> nsl);
+        final ClusterAcceptorEventHandler<MyClusterContext, MyClusteredNetworkContext> acceptorEventHandler
+                = new ClusterAcceptorEventHandler<>("testAcceptor", acceptorContext);
+        EventLoop eventLoop = EventGroupBuilder.builder().build();
+        eventLoop.addHandler(acceptorEventHandler);
+        eventLoop.start();
+        final MyClusterContext initiaitorContext = new MyClusterContext();
+        HostConnector<MyClusteredNetworkContext, MyClusterContext> connector
+                = new HostConnector<>(initiaitorContext, new RemoteConnector<>(initiaitorContext.tcpEventHandlerFactory()), 1, "testAcceptor");
+        connector.connect();
+        initiaitorContext.eventLoop().start();
+        while (acceptorContext.tcpEventHandlers.size() == 0) {
+            Jvm.pause(10);
+        }
+        assertSame(nsl, acceptorContext.tcpEventHandlers.get(0).nc.networkStatsListener());
+        verify(nsl).networkContext(any(MyClusteredNetworkContext.class));
+    }
+
+    static class MyClusterContext extends ClusterContext<MyClusterContext, MyClusteredNetworkContext> {
+
+        private final List<NetworkContextExposingTcpEventHandler> tcpEventHandlers = new ArrayList<>();
+
+        @Override
+        public @NotNull ThrowingFunction<MyClusteredNetworkContext, TcpEventHandler<MyClusteredNetworkContext>, IOException> tcpEventHandlerFactory() {
+            return this::createTcpEventHandler;
+        }
+
+        @NotNull
+        private TcpEventHandler<MyClusteredNetworkContext> createTcpEventHandler(MyClusteredNetworkContext clusteredNetworkContext) {
+            final NetworkContextExposingTcpEventHandler tcpEventHandler = new NetworkContextExposingTcpEventHandler(clusteredNetworkContext);
+            tcpEventHandlers.add(tcpEventHandler);
+            return tcpEventHandler;
+        }
+
+        @Override
+        protected void defaults() {
+            wireType(WireType.BINARY);
+            wireOutPublisherFactory(VanillaWireOutPublisher::new);
+            serverThreadingStrategy(ServerThreadingStrategy.SINGLE_THREADED);
+            networkContextFactory(MyClusteredNetworkContext::new);
+        }
+
+        @Override
+        protected String clusterNamePrefix() {
+            return "testAcceptor";
+        }
+    }
+
+    static class NetworkContextExposingTcpEventHandler extends TcpEventHandler<MyClusteredNetworkContext> {
+
+        private final MyClusteredNetworkContext nc;
+
+        public NetworkContextExposingTcpEventHandler(@NotNull MyClusteredNetworkContext nc) {
+            super(nc);
+            this.nc = nc;
+        }
+    }
+
+    static class MyClusteredNetworkContext extends VanillaClusteredNetworkContext<MyClusteredNetworkContext, MyClusterContext> {
+
+        public MyClusteredNetworkContext(@NotNull MyClusterContext clusterContext) {
+            super(clusterContext);
+        }
+    }
+}
\ No newline at end of file
