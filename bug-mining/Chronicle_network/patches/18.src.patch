diff --git a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
index 00d1c10d14..19aabbd293 100644
--- a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
@@ -17,7 +17,6 @@
 package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.bytes.Bytes;
-import net.openhft.chronicle.bytes.BytesUtil;
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.core.Maths;
 import net.openhft.chronicle.core.OS;
@@ -71,6 +70,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
     @Nullable
     private volatile TcpHandler tcpHandler;
     private long lastTickReadTime = System.currentTimeMillis();
+    private final AtomicBoolean bbbReleased = new AtomicBoolean();
     private volatile boolean closed;
     // monitoring
     private int socketPollCount;
@@ -111,9 +111,6 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
 
         inBBB = Bytes.elasticByteBuffer(TCP_BUFFER + OS.pageSize());
         outBBB = Bytes.elasticByteBuffer(TCP_BUFFER);
-        // TODO Fix tests so socket connections are closed cleanly.
-        BytesUtil.unregister(inBBB);
-        BytesUtil.unregister(outBBB);
 
         // must be set after we take a slice();
         outBBB.underlyingObject().limit(0);
@@ -196,8 +193,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
         Jvm.optionalSafepoint();
 
         if (closed) {
-            inBBB.release();
-            outBBB.release();
+            closeAndNfyTerminated();
             throw new InvalidEventHandlerException();
         }
 
@@ -206,8 +202,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
 
         if (!sc.isOpen()) {
             tcpHandler.onEndOfConnection(false);
-            Closeable.closeQuietly(nc);
-            // clear these to free up memory.
+            closeAndNfyTerminated();
             throw new InvalidEventHandlerException("socket is closed");
         }
 
@@ -253,7 +248,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
                             lastTickReadTime += heartbeatListener.lingerTimeBeforeDisconnect();
                         } else {
                             tcpHandler.onEndOfConnection(true);
-                            closeSC();
+                            closeAndNfyTerminated();
                             throw new InvalidEventHandlerException("heartbeat timeout");
                         }
                     }
@@ -262,29 +257,43 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
                 if (!busy)
                     monitorStats();
             } else {
-                close();
+                // read == -1, socketChannel has reached end-of-stream
+                closeAndNfyTerminated();
                 throw new InvalidEventHandlerException("socket closed " + sc);
             }
 
             return busy;
 
         } catch (ClosedChannelException e) {
-            close();
+            closeAndNfyTerminated();
             throw new InvalidEventHandlerException(e);
         } catch (IOException e) {
-            close();
+            closeAndNfyTerminated();
             handleIOE(e, tcpHandler.hasClientClosed(), nc.heartbeatListener());
             throw new InvalidEventHandlerException();
         } catch (InvalidEventHandlerException e) {
-            close();
+            closeAndNfyTerminated();
             throw e;
         } catch (Exception e) {
-            close();
+            closeAndNfyTerminated();
             Jvm.warn().on(getClass(), "", e);
             throw new InvalidEventHandlerException(e);
         }
     }
 
+    /**
+     * action can be called from BlockingEventLoop, VanillaEventLoop, or from anywhere. If we are
+     * about to throw an InvalidEventHandlerException then we know we are finished from the action method
+     */
+    private void closeAndNfyTerminated() {
+        close();
+        // can only release BBs when we are sure that action has terminated
+        if (bbbReleased.compareAndSet(false, true)) {
+            inBBB.release();
+            outBBB.release();
+        }
+    }
+
     public void onInBBFul() {
         LOG.trace("inBB is full, can't read from socketChannel");
     }
diff --git a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
index 61bb606c1a..3d45425934 100644
--- a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
+++ b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
@@ -23,26 +23,44 @@ public class TcpEventHandlerReleaseTest {
         TCPRegistry.createServerSocketChannelFor(hostPort);
     }
 
+    @After
+    public void checkRegisteredBytes() {
+        BytesUtil.checkRegisteredBytes();
+    }
+
     @Test
     public void testRelease() throws IOException {
+        TcpEventHandler t = createTcpEventHandler();
+        t.close();
+        // assume the handler has been added to an EventLoop.
         try {
-            BytesUtil.checkRegisteredBytes();
-        } catch (Throwable t) {
-            // just doing this to reset BytesUtil. TODO: fix other tests to not leak Bytes
+            t.action();
+            fail();
+        } catch (InvalidEventHandlerException e) {
+            // expected.
         }
-        NetworkContext nc = new VanillaNetworkContext();
-        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
-        TcpEventHandler t = new TcpEventHandler(nc);
+        // check second close OK
         t.close();
-        // assume the handle has been added to an EventLoop.
+    }
+
+    @Test
+    public void testBuffersReleasedWhenSocketChannelClosed() throws IOException {
+        TcpEventHandler t = createTcpEventHandler();
+        t.socketChannel().close();
         try {
             t.action();
             fail();
         } catch (InvalidEventHandlerException e) {
             // expected.
         }
-        // check second close OK
         t.close();
-        BytesUtil.checkRegisteredBytes();
+    }
+
+    public TcpEventHandler createTcpEventHandler() throws IOException {
+        NetworkContext nc = new VanillaNetworkContext();
+        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
+        TcpEventHandler tcpEventHandler = new TcpEventHandler(nc);
+        tcpEventHandler.tcpHandler((in, out, nc1) -> { });
+        return tcpEventHandler;
     }
 }
