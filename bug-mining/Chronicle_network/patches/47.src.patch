diff --git a/src/main/java/net/openhft/chronicle/network/AcceptorEventHandler.java b/src/main/java/net/openhft/chronicle/network/AcceptorEventHandler.java
index 71018fca1e..ca8b83c31d 100644
--- a/src/main/java/net/openhft/chronicle/network/AcceptorEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/AcceptorEventHandler.java
@@ -27,7 +27,6 @@ import net.openhft.chronicle.core.threads.InvalidEventHandlerException;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocket;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocketChannel;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.IOException;
@@ -90,11 +89,10 @@ public class AcceptorEventHandler<T extends NetworkContext<T>> extends AbstractC
                     throw new InvalidEventHandlerException("closed");
                 }
                 final T nc = ncFactory.get();
-                ISocketChannel isc = sc.toISocketChannel();
-                nc.socketChannel(isc);
+                nc.socketChannel(sc);
                 nc.isAcceptor(true);
                 NetworkStatsListener<T> nl = nc.networkStatsListener();
-                notifyHostPort(isc, nl);
+                notifyHostPort(sc, nl);
                 TcpEventHandler<T> apply = handlerFactory.apply(nc);
                 eventLoop.addHandler(apply);
             }
diff --git a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
index 89ba719983..19474947b5 100644
--- a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
@@ -20,7 +20,7 @@ package net.openhft.chronicle.network;
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.network.connection.FatalFailureMonitor;
 import net.openhft.chronicle.network.connection.SocketAddressSupplier;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.wire.SelfDescribingMarshallable;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -51,10 +51,10 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends SelfDescribingMarsha
 
     @Nullable
     @Override
-    public ISocketChannel connect(@NotNull String name,
-                                  @NotNull SocketAddressSupplier socketAddressSupplier,
-                                  boolean didLogIn,
-                                  @Nullable FatalFailureMonitor fatalFailureMonitor) throws InterruptedException {
+    public ChronicleSocketChannel connect(@NotNull String name,
+                                          @NotNull SocketAddressSupplier socketAddressSupplier,
+                                          boolean didLogIn,
+                                          @Nullable FatalFailureMonitor fatalFailureMonitor) throws InterruptedException {
 
         if (socketAddressSupplier.get() == null || didLogIn)
             socketAddressSupplier.resetToPrimary();
@@ -63,7 +63,7 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends SelfDescribingMarsha
 
         for (; ; ) {
 
-            ISocketChannel socketChannel = null;
+            ChronicleSocketChannel socketChannel = null;
             try {
 
                 @Nullable final InetSocketAddress socketAddress = socketAddressSupplier.get();
diff --git a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
index 7303723380..6d45c482a7 100644
--- a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
@@ -23,7 +23,6 @@ import net.openhft.chronicle.network.connection.SocketAddressSupplier;
 import net.openhft.chronicle.network.tcp.ChronicleSocket;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
 import net.openhft.chronicle.wire.Marshallable;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -41,7 +40,7 @@ import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
 public interface ConnectionStrategy extends Marshallable {
 
     @Nullable
-    static ISocketChannel socketChannel(@NotNull InetSocketAddress socketAddress, int tcpBufferSize, int socketConnectionTimeoutMs) throws IOException {
+    static ChronicleSocketChannel socketChannel(@NotNull InetSocketAddress socketAddress, int tcpBufferSize, int socketConnectionTimeoutMs) throws IOException {
 
         final ChronicleSocketChannel result = ChronicleSocketChannelFactory.wrap();
         @Nullable Selector selector = null;
@@ -77,7 +76,7 @@ public interface ConnectionStrategy extends Marshallable {
             }
 
             failed = false;
-            return result.toISocketChannel();
+            return result;
 
         } catch (Exception e) {
             return null;
@@ -98,13 +97,13 @@ public interface ConnectionStrategy extends Marshallable {
      * @return the SocketChannel
      * @throws InterruptedException if the channel is interrupted.
      */
-    ISocketChannel connect(@NotNull String name,
+    ChronicleSocketChannel connect(@NotNull String name,
                            @NotNull SocketAddressSupplier socketAddressSupplier,
                            boolean didLogIn,
                            @NotNull FatalFailureMonitor fatalFailureMonitor) throws InterruptedException;
 
     @Nullable
-    default ISocketChannel openSocketChannel(@NotNull InetSocketAddress socketAddress,
+    default ChronicleSocketChannel openSocketChannel(@NotNull InetSocketAddress socketAddress,
                                              int tcpBufferSize,
                                              long timeoutMs) throws IOException, InterruptedException {
 
@@ -118,13 +117,13 @@ public interface ConnectionStrategy extends Marshallable {
      * the reason for this method is that unlike the selector it uses tick time
      */
     @Nullable
-    default ISocketChannel openSocketChannel(@NotNull InetSocketAddress socketAddress,
-                                             int tcpBufferSize,
-                                             long timeoutMs,
-                                             int socketConnectionTimeoutMs) throws IOException, InterruptedException {
+    default ChronicleSocketChannel openSocketChannel(@NotNull InetSocketAddress socketAddress,
+                                                     int tcpBufferSize,
+                                                     long timeoutMs,
+                                                     int socketConnectionTimeoutMs) throws IOException, InterruptedException {
         assert timeoutMs > 0;
         long start = System.currentTimeMillis();
-        ISocketChannel sc = socketChannel(socketAddress, tcpBufferSize, socketConnectionTimeoutMs);
+        ChronicleSocketChannel sc = socketChannel(socketAddress, tcpBufferSize, socketConnectionTimeoutMs);
         if (sc != null)
             return sc;
 
diff --git a/src/main/java/net/openhft/chronicle/network/NetworkContext.java b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
index 6c069ec707..dc07d20e42 100644
--- a/src/main/java/net/openhft/chronicle/network/NetworkContext.java
+++ b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
@@ -25,7 +25,7 @@ import net.openhft.chronicle.network.api.session.SessionDetailsProvider;
 import net.openhft.chronicle.network.cluster.TerminationEventHandler;
 import net.openhft.chronicle.network.connection.ConnectionListeners;
 import net.openhft.chronicle.network.connection.WireOutPublisher;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.wire.WireType;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -40,9 +40,9 @@ public interface NetworkContext<T extends NetworkContext<T>> extends Closeable {
     boolean isAcceptor();
 
     @NotNull
-    T socketChannel(ISocketChannel sc);
+    T socketChannel(ChronicleSocketChannel sc);
 
-    ISocketChannel socketChannel();
+    ChronicleSocketChannel socketChannel();
 
     WireOutPublisher wireOutPublisher();
 
diff --git a/src/main/java/net/openhft/chronicle/network/NetworkLog.java b/src/main/java/net/openhft/chronicle/network/NetworkLog.java
index 93f69e8193..b22b581dea 100644
--- a/src/main/java/net/openhft/chronicle/network/NetworkLog.java
+++ b/src/main/java/net/openhft/chronicle/network/NetworkLog.java
@@ -19,7 +19,7 @@ package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.bytes.RandomDataInput;
 import net.openhft.chronicle.core.Jvm;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -34,7 +34,7 @@ class NetworkLog {
     private final String desc;
     private long lastOut = System.currentTimeMillis();
 
-    public NetworkLog(@NotNull ISocketChannel channel, String op) {
+    public NetworkLog(@NotNull ChronicleSocketChannel channel, String op) {
         if (channel.isOpen()) {
             String desc0 = "unknown";
             try {
diff --git a/src/main/java/net/openhft/chronicle/network/NetworkStatsListener.java b/src/main/java/net/openhft/chronicle/network/NetworkStatsListener.java
index 87ce931201..138b3733bf 100644
--- a/src/main/java/net/openhft/chronicle/network/NetworkStatsListener.java
+++ b/src/main/java/net/openhft/chronicle/network/NetworkStatsListener.java
@@ -18,7 +18,7 @@
 package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.core.io.Closeable;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -32,7 +32,7 @@ public interface NetworkStatsListener<N extends NetworkContext<N>> extends Close
      * @param sc SocketChannel
      * @param nl NetworkStatsListener
      */
-    static <N extends NetworkContext<N>> void notifyHostPort(@Nullable final ISocketChannel sc, @Nullable final NetworkStatsListener<N> nl) {
+    static <N extends NetworkContext<N>> void notifyHostPort(@Nullable final ChronicleSocketChannel sc, @Nullable final NetworkStatsListener<N> nl) {
         if (nl != null && sc != null && sc.socket() != null
                 && sc.socket().getRemoteSocketAddress() instanceof InetSocketAddress) {
             @NotNull final InetSocketAddress remoteSocketAddress = (InetSocketAddress) sc.socket()
diff --git a/src/main/java/net/openhft/chronicle/network/ReadWithFlowControl.java b/src/main/java/net/openhft/chronicle/network/ReadWithFlowControl.java
index eb668358c6..ead2b8106a 100644
--- a/src/main/java/net/openhft/chronicle/network/ReadWithFlowControl.java
+++ b/src/main/java/net/openhft/chronicle/network/ReadWithFlowControl.java
@@ -1,7 +1,7 @@
 package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.bytes.Bytes;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.IOException;
@@ -27,7 +27,7 @@ public final class ReadWithFlowControl implements TcpEventHandler.SocketReader {
     /**
      * reads just a single message from the socket
      */
-    public int read(@NotNull final ISocketChannel socketChannel, @NotNull final Bytes<ByteBuffer> bytes) throws IOException {
+    public int read(@NotNull final ChronicleSocketChannel socketChannel, @NotNull final Bytes<ByteBuffer> bytes) throws IOException {
         ByteBuffer bb = requireNonNull(bytes.underlyingObject());
         bb.limit(limit);
         bb.position(position);
diff --git a/src/main/java/net/openhft/chronicle/network/RemoteConnector.java b/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
index f81135d423..ed0be1f507 100644
--- a/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
+++ b/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
@@ -31,7 +31,6 @@ import net.openhft.chronicle.network.connection.TcpChannelHub;
 import net.openhft.chronicle.network.tcp.ChronicleSocket;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.IOException;
@@ -162,10 +161,9 @@ public class RemoteConnector<T extends NetworkContext<T>> extends AbstractClosea
                 if (sc == null)
                     return false;
 
-                ISocketChannel isc = sc.toISocketChannel();
-                nc.socketChannel(isc);
+                nc.socketChannel(sc);
                 nc.isAcceptor(false);
-                notifyHostPort(isc, nc.networkStatsListener());
+                notifyHostPort(sc, nc.networkStatsListener());
                 if (!nc.socketChannel().isOpen())
                     throw new InvalidEventHandlerException();
                 eventHandler = tcpHandlerSupplier.apply(nc);
diff --git a/src/main/java/net/openhft/chronicle/network/TCPRegistry.java b/src/main/java/net/openhft/chronicle/network/TCPRegistry.java
index c8dc1fd169..0717c8719c 100644
--- a/src/main/java/net/openhft/chronicle/network/TCPRegistry.java
+++ b/src/main/java/net/openhft/chronicle/network/TCPRegistry.java
@@ -178,11 +178,7 @@ public enum TCPRegistry {
     }
 
     public static ChronicleSocketChannel createSocketChannel(@NotNull String description) throws IOException {
-        return ChronicleSocketChannel.open(lookup(description));
-    }
-
-    public static ISocketChannel createISocketChannel(@NotNull String description) throws IOException {
-        return ChronicleSocketChannelFactory.wrap(lookup(description)).toISocketChannel();
+        return ChronicleSocketChannelFactory.wrap(lookup(description));
     }
 
     public static void dumpAllSocketChannels() {
diff --git a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
index fee135a45e..859fb4b066 100644
--- a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
@@ -31,7 +31,8 @@ import net.openhft.chronicle.core.threads.HandlerPriority;
 import net.openhft.chronicle.core.threads.InvalidEventHandlerException;
 import net.openhft.chronicle.network.api.TcpHandler;
 import net.openhft.chronicle.network.tcp.ChronicleSocket;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
 import net.openhft.chronicle.threads.MediumEventLoop;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -72,7 +73,7 @@ public class TcpEventHandler<T extends NetworkContext<T>>
     private TcpEventHandler.SocketReader reader = new DefaultSocketReader();
 
     @NotNull
-    private final ISocketChannel sc;
+    private final ChronicleSocketChannel sc;
     private final String scToString;
     @NotNull
     private final T nc;
@@ -103,7 +104,7 @@ public class TcpEventHandler<T extends NetworkContext<T>>
     }
 
     public TcpEventHandler(@NotNull final T nc, final TcpHandlerBias bias) {
-        this.sc = ISocketChannel.wrapUnsafe(nc.socketChannel().socketChannel());
+        this.sc = ChronicleSocketChannelFactory.wrapUnsafe(nc.socketChannel().socketChannel());
         this.scToString = sc.toString();
         this.nc = nc;
         this.bias = bias.get();
@@ -301,7 +302,7 @@ public class TcpEventHandler<T extends NetworkContext<T>>
         }
     }
 
-    public ISocketChannel socketChannel() {
+    public ChronicleSocketChannel socketChannel() {
         return sc;
     }
 
@@ -538,13 +539,13 @@ public class TcpEventHandler<T extends NetworkContext<T>>
          * @return the number of bytes read from the provided {@code socketChannel}.
          * @throws IOException if there is a problem reading form the provided {@code socketChannel}.
          */
-        int read(@NotNull ISocketChannel socketChannel, @NotNull Bytes<ByteBuffer> bytes) throws IOException;
+        int read(@NotNull ChronicleSocketChannel socketChannel, @NotNull Bytes<ByteBuffer> bytes) throws IOException;
     }
 
     public static final class DefaultSocketReader implements SocketReader {
 
         @Override
-        public int read(@NotNull final ISocketChannel socketChannel, @NotNull final Bytes<ByteBuffer> bytes) throws IOException {
+        public int read(@NotNull final ChronicleSocketChannel socketChannel, @NotNull final Bytes<ByteBuffer> bytes) throws IOException {
             return socketChannel.read(bytes.underlyingObject());
         }
     }
diff --git a/src/main/java/net/openhft/chronicle/network/VanillaNetworkContext.java b/src/main/java/net/openhft/chronicle/network/VanillaNetworkContext.java
index e3f65e5ae7..42cb0bbbcc 100644
--- a/src/main/java/net/openhft/chronicle/network/VanillaNetworkContext.java
+++ b/src/main/java/net/openhft/chronicle/network/VanillaNetworkContext.java
@@ -23,7 +23,7 @@ import net.openhft.chronicle.network.api.TcpHandler;
 import net.openhft.chronicle.network.api.session.SessionDetailsProvider;
 import net.openhft.chronicle.network.cluster.TerminationEventHandler;
 import net.openhft.chronicle.network.connection.WireOutPublisher;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.wire.WireType;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -32,7 +32,7 @@ public class VanillaNetworkContext<T extends VanillaNetworkContext<T>>
         extends AbstractCloseable
         implements NetworkContext<T> {
 
-    private ISocketChannel socketChannel;
+    private ChronicleSocketChannel socketChannel;
     private boolean isAcceptor = true;
     private HeartbeatListener heartbeatListener;
     private SessionDetailsProvider sessionDetails;
@@ -47,14 +47,14 @@ public class VanillaNetworkContext<T extends VanillaNetworkContext<T>>
     private ServerThreadingStrategy serverThreadingStrategy = ServerThreadingStrategy.SINGLE_THREADED;
 
     @Override
-    public ISocketChannel socketChannel() {
+    public ChronicleSocketChannel socketChannel() {
         return socketChannel;
     }
 
     @Override
     protected boolean performCloseInBackground() {
 
-        ISocketChannel socketChannel = this.socketChannel;
+        ChronicleSocketChannel socketChannel = this.socketChannel;
         if (socketChannel != null)
             socketChannel.close();
         return super.performCloseInBackground();
@@ -62,7 +62,7 @@ public class VanillaNetworkContext<T extends VanillaNetworkContext<T>>
 
     @NotNull
     @Override
-    public T socketChannel(ISocketChannel socketChannel) {
+    public T socketChannel(ChronicleSocketChannel socketChannel) {
         throwExceptionIfClosedInSetter();
 
         this.socketChannel = socketChannel;
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/HostConnector.java b/src/main/java/net/openhft/chronicle/network/cluster/HostConnector.java
index f7346ebcbf..d51617e51d 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/HostConnector.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/HostConnector.java
@@ -21,7 +21,7 @@ import net.openhft.chronicle.core.threads.EventLoop;
 import net.openhft.chronicle.network.NetworkStatsListener;
 import net.openhft.chronicle.network.RemoteConnector;
 import net.openhft.chronicle.network.connection.WireOutPublisher;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.wire.WireType;
 import net.openhft.chronicle.wire.WriteMarshallable;
 import org.jetbrains.annotations.NotNull;
@@ -70,7 +70,7 @@ public class HostConnector<T extends ClusteredNetworkContext<T>> implements Clos
     public synchronized void close() {
         WireOutPublisher wp = wireOutPublisher.getAndSet(null);
 
-        ISocketChannel socketChannel = nc.socketChannel();
+        ChronicleSocketChannel socketChannel = nc.socketChannel();
         if (socketChannel != null) {
             closeQuietly(socketChannel, socketChannel.socket());
         }
diff --git a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
index b6a3ff8248..2e9c7f1573 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
@@ -19,7 +19,7 @@ package net.openhft.chronicle.network.connection;
 
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.network.ConnectionStrategy;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -72,10 +72,10 @@ public class FatalFailureConnectionStrategy implements ConnectionStrategy {
 
     @Nullable
     @Override
-    public ISocketChannel connect(@NotNull String name,
-                                  @NotNull SocketAddressSupplier socketAddressSupplier,
-                                  boolean didLogIn,
-                                  @Nullable FatalFailureMonitor fatalFailureMonitor) throws InterruptedException {
+    public ChronicleSocketChannel connect(@NotNull String name,
+                                          @NotNull SocketAddressSupplier socketAddressSupplier,
+                                          boolean didLogIn,
+                                          @Nullable FatalFailureMonitor fatalFailureMonitor) throws InterruptedException {
 
         if (socketAddressSupplier.size() == 0 && !hasSentFatalFailure && fatalFailureMonitor != null) {
             hasSentFatalFailure = true;
@@ -102,7 +102,7 @@ public class FatalFailureConnectionStrategy implements ConnectionStrategy {
                 return null;
             }
 
-            ISocketChannel socketChannel = null;
+            ChronicleSocketChannel socketChannel = null;
             try {
                 @Nullable final InetSocketAddress socketAddress = socketAddressSupplier.get();
                 if (socketAddress == null) {
@@ -146,6 +146,6 @@ public class FatalFailureConnectionStrategy implements ConnectionStrategy {
                 LockSupport.parkNanos(PAUSE);
             }
         }
- }
+    }
 
 }
diff --git a/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java b/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
index e5fe0c53b2..b9b1620d5f 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
@@ -34,7 +34,7 @@ import net.openhft.chronicle.network.ConnectionStrategy;
 import net.openhft.chronicle.network.WanSimulator;
 import net.openhft.chronicle.network.api.session.SessionDetails;
 import net.openhft.chronicle.network.api.session.SessionProvider;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.threads.*;
 import net.openhft.chronicle.wire.*;
 import org.jetbrains.annotations.NotNull;
@@ -123,7 +123,7 @@ public final class TcpChannelHub extends AbstractCloseable {
     // private final String description;
     private long largestChunkSoFar = 0;
     @Nullable
-    private volatile ISocketChannel clientChannel;
+    private volatile ChronicleSocketChannel clientChannel;
     @NotNull
     private final CountDownLatch receivedClosedAcknowledgement = new CountDownLatch(1);
     // set up in the header
@@ -430,7 +430,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         return outBytesLock;
     }
 
-    void doHandShaking(@NotNull final ISocketChannel socketChannel) throws IOException {
+    void doHandShaking(@NotNull final ChronicleSocketChannel socketChannel) throws IOException {
 
         assert outBytesLock.isHeldByCurrentThread();
         @Nullable final SessionDetails sessionDetails = sessionDetails();
@@ -467,7 +467,7 @@ public final class TcpChannelHub extends AbstractCloseable {
      */
     synchronized void closeSocket() {
 
-        @Nullable final ISocketChannel clientChannel = this.clientChannel;
+        @Nullable final ChronicleSocketChannel clientChannel = this.clientChannel;
 
         if (clientChannel != null) {
 
@@ -619,7 +619,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
         try {
             assert wire.startUse();
-            @Nullable ISocketChannel clientChannel = this.clientChannel;
+            @Nullable ChronicleSocketChannel clientChannel = this.clientChannel;
 
             // wait for the channel to be non null
             if (clientChannel == null) {
@@ -694,7 +694,7 @@ public final class TcpChannelHub extends AbstractCloseable {
      * @param outWire the data that you wish to write
      * @throws IOException if the channel cannot be closed
      */
-    private void writeSocket1(@NotNull final WireOut outWire, @Nullable final ISocketChannel clientChannel) throws IOException {
+    private void writeSocket1(@NotNull final WireOut outWire, @Nullable final ChronicleSocketChannel clientChannel) throws IOException {
 
         if (LOG_TCP_MESSAGES && DEBUG_ENABLED)
             Jvm.debug().on(TcpChannelHub.class, "sending :" + Wires.fromSizePrefixedBlobs((Wire) outWire));
@@ -1053,7 +1053,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         return outWire.bytes().readRemaining() == 0;
     }
 
- 
+
     @Override
     protected boolean threadSafetyCheck(boolean isUsed) {
         // Assume it is thread safe.
@@ -1479,7 +1479,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                 processServerSystemMessage(header, messageSize);
                 return false;
             } else {
-                @Nullable final ISocketChannel c = clientChannel;
+                @Nullable final ChronicleSocketChannel c = clientChannel;
 
                 // this can occur if we received a shutdown
                 if (c == null)
@@ -1654,7 +1654,7 @@ public final class TcpChannelHub extends AbstractCloseable {
             //  long start = System.currentTimeMillis();
             boolean emptyRead = true;
             while (buffer.remaining() > 0) {
-                @Nullable final ISocketChannel clientChannel = TcpChannelHub.this.clientChannel;
+                @Nullable final ChronicleSocketChannel clientChannel = TcpChannelHub.this.clientChannel;
                 if (clientChannel == null)
                     throw new IOException("Disconnection to server=" + socketAddressSupplier +
                             " channel is closed, name=" + name);
@@ -1844,7 +1844,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                 else if (i >= socketAddressSupplier.all().size() && !isShuttingdown())
                     LOG.info("attemptConnect remoteAddress=" + socketAddressSupplier);
 
-                @Nullable ISocketChannel socketChannel;
+                @Nullable ChronicleSocketChannel socketChannel;
                 try {
 
                     if (isShuttingdown())
diff --git a/src/main/java/net/openhft/chronicle/network/ssl/SslDelegatingTcpHandler.java b/src/main/java/net/openhft/chronicle/network/ssl/SslDelegatingTcpHandler.java
index 71e2618380..4b8ab22926 100644
--- a/src/main/java/net/openhft/chronicle/network/ssl/SslDelegatingTcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/ssl/SslDelegatingTcpHandler.java
@@ -168,7 +168,7 @@ public final class SslDelegatingTcpHandler<N extends SslNetworkContext<N>>
 
     private void doHandshake(final N nc) {
         stateMachine = new SslEngineStateMachine(bufferHandler, nc.isAcceptor());
-        ChronicleSocketChannel socketChannel = nc.socketChannel().socketChannel();
+        ChronicleSocketChannel socketChannel = nc.socketChannel();
         stateMachine.initialise(nc.sslContext(), socketChannel);
     }
 }
\ No newline at end of file
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketFactory.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketFactory.java
index 595035608c..32364e1132 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketFactory.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketFactory.java
@@ -3,6 +3,6 @@ package net.openhft.chronicle.network.tcp;
 public class ChronicleServerSocketFactory {
 
     public static ChronicleServerSocketChannel open() {
-        return new ChronicleServerSocketChannelImpl();
+        return new VanillaChronicleServerSocketChannel();
     }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
index ea1b1a01fb..4d01f39053 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
@@ -1,24 +1,16 @@
 package net.openhft.chronicle.network.tcp;
 
+import net.openhft.chronicle.core.io.Closeable;
 
-
-import java.io.Closeable;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketOption;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
 
-public interface ChronicleSocketChannel extends Closeable, ISocketChannel {
-
-    static ChronicleSocketChannel open() throws IOException {
-        return ChronicleSocketChannelFactory.wrap();
-    }
-
-    static ChronicleSocketChannel open(InetSocketAddress inetSocketAddress) throws IOException {
-        return ChronicleSocketChannelFactory.wrap(inetSocketAddress);
-    }
+public interface ChronicleSocketChannel extends Closeable {
 
     int read(ByteBuffer byteBuffer) throws IOException;
 
@@ -46,5 +38,5 @@ public interface ChronicleSocketChannel extends Closeable, ISocketChannel {
 
     void setOption(SocketOption<Boolean> soReuseaddr, boolean b) throws IOException;
 
-    ISocketChannel toISocketChannel();
+    SocketChannel socketChannel();
 }
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelFactory.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelFactory.java
index e500e2b3c5..28d0889c29 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelFactory.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelFactory.java
@@ -1,18 +1,21 @@
 package net.openhft.chronicle.network.tcp;
 
-import net.openhft.chronicle.core.io.Closeable;
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.OS;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
-import java.net.SocketOption;
-import java.nio.ByteBuffer;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
 
 public enum ChronicleSocketChannelFactory {
     ;
+    public static boolean FAST_JAVA8_IO = isFastJava8IO();
+    private static boolean isFastJava8IO() {
+        boolean fastJava8IO = Jvm.getBoolean("fastJava8IO") && !Jvm.isJava9Plus() && OS.isLinux();
+        if (fastJava8IO) System.out.println("FastJava8IO: enabled");
+        return fastJava8IO;
+    }
 
     public static ChronicleSocketChannel wrap() throws IOException {
         return wrap(SocketChannel.open());
@@ -23,8 +26,26 @@ public enum ChronicleSocketChannelFactory {
     }
 
     public static ChronicleSocketChannel wrap(@NotNull final SocketChannel sc) {
-        return new ChronicleSocketChannelImpl(sc);
+        return FAST_JAVA8_IO ? newFastInstance(sc) : newInstance(sc);
+    }
+
+    public static ChronicleSocketChannel wrapUnsafe(@NotNull final SocketChannel sc) {
+        return FAST_JAVA8_IO ? newFastUnsafeInstance(sc) : newInstance(sc);
+    }
+
+    @NotNull
+    private static ChronicleSocketChannel newInstance(@NotNull final SocketChannel sc) {
+        return new VanillaSocketChannel(sc);
+    }
+
+    @NotNull
+    private static ChronicleSocketChannel newFastInstance(@NotNull final SocketChannel sc) {
+        return new FastJ8SocketChannel(sc);
     }
 
+    @NotNull
+    private static ChronicleSocketChannel newFastUnsafeInstance(@NotNull final SocketChannel sc) {
+        return new UnsafeFastJ8SocketChannel(sc);
+    }
 
 }
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelImpl.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelImpl.java
deleted file mode 100644
index b8baa4e452..0000000000
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannelImpl.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package net.openhft.chronicle.network.tcp;
-
-import net.openhft.chronicle.core.io.AbstractCloseable;
-import net.openhft.chronicle.core.io.Closeable;
-import org.jetbrains.annotations.NotNull;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.SocketOption;
-import java.nio.ByteBuffer;
-import java.nio.channels.ClosedChannelException;
-import java.nio.channels.Selector;
-import java.nio.channels.SocketChannel;
-
-public class ChronicleSocketChannelImpl  implements ChronicleSocketChannel {
-
-    private final SocketChannel sc;
-
-    ChronicleSocketChannelImpl(SocketChannel sc) {
-        this.sc = sc;
-    }
-
-
-
-    @Override
-    public @NotNull ChronicleSocketChannel socketChannel() {
-        return ChronicleSocketChannelFactory.wrap(sc);
-    }
-
-    @Override
-    public int read(final ByteBuffer byteBuffer) throws IOException {
-        return sc.read(byteBuffer);
-    }
-
-    @Override
-    public int write(final ByteBuffer byteBuffer) throws IOException {
-        return sc.write(byteBuffer);
-    }
-
-    @Override
-    public long write(final ByteBuffer[] byteBuffers) throws IOException {
-        return sc.write(byteBuffers);
-    }
-
-    @Override
-    public void configureBlocking(final boolean blocking) throws IOException {
-        SocketChannel sc1 = sc;
-        if (sc1 != null)
-            sc1.configureBlocking(blocking);
-    }
-
-    @Override
-    public boolean isClosed() {
-        return !isOpen();
-    }
-
-    @Override
-    public InetSocketAddress getLocalAddress() throws IOException {
-        return (InetSocketAddress) sc.getLocalAddress();
-    }
-
-    @Override
-    public InetSocketAddress getRemoteAddress() throws IOException {
-        return (InetSocketAddress) sc.getRemoteAddress();
-    }
-
-    @Override
-    public boolean isOpen() {
-        return sc.isOpen();
-    }
-
-    @Override
-    public boolean isBlocking() {
-        return sc.isBlocking();
-    }
-
-    @Override
-    public ChronicleSocket socket() {
-        SocketChannel sc1 = sc;
-        if (sc1 == null)
-            return null;
-        return ChronicleSocketFactory.toChronicleSocket(sc1.socket());
-    }
-
-    @Override
-    public void connect(final InetSocketAddress socketAddress) throws IOException {
-        sc.connect(socketAddress);
-    }
-
-    @Override
-    public void register(final Selector selector, final int opConnect) throws ClosedChannelException {
-        sc.register(selector, opConnect);
-    }
-
-    @Override
-    public boolean finishConnect() throws IOException {
-        return sc.finishConnect();
-    }
-
-    @Override
-    public void setOption(final SocketOption<Boolean> soReuseaddr, final boolean b) throws IOException {
-        sc.setOption(soReuseaddr, b);
-    }
-
-    @Override
-    public ISocketChannel toISocketChannel() {
-        return ISocketChannel.wrap(socketChannel());
-    }
-
-    @Override
-    public void close() {
-        Closeable.closeQuietly(sc);
-    }
-};
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/FastJ8SocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/FastJ8SocketChannel.java
index 77a8f0150a..81c2245a00 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/FastJ8SocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/FastJ8SocketChannel.java
@@ -25,6 +25,7 @@ import sun.nio.ch.IOStatus;
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.channels.SocketChannel;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public class FastJ8SocketChannel extends VanillaSocketChannel {
@@ -33,7 +34,7 @@ public class FastJ8SocketChannel extends VanillaSocketChannel {
     volatile boolean open;
     private volatile boolean blocking;
 
-    public FastJ8SocketChannel(ChronicleSocketChannel socketChannel) {
+    public FastJ8SocketChannel(SocketChannel socketChannel) {
         super(socketChannel);
         fd = Jvm.getValue(socketChannel, "fd");
         open = socketChannel.isOpen();
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ISocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/ISocketChannel.java
deleted file mode 100644
index da4fbd8c67..0000000000
--- a/src/main/java/net/openhft/chronicle/network/tcp/ISocketChannel.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2016-2020 Chronicle Software
- *
- * https://chronicle.software
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package net.openhft.chronicle.network.tcp;
-
-import net.openhft.chronicle.core.Jvm;
-import net.openhft.chronicle.core.OS;
-import net.openhft.chronicle.core.io.Closeable;
-import org.jetbrains.annotations.NotNull;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.nio.ByteBuffer;
-
-public interface ISocketChannel extends Closeable {
-
-    boolean FAST_JAVA8_IO = isFastJava8IO();
-
-    static boolean isFastJava8IO() {
-        boolean fastJava8IO = Jvm.getBoolean("fastJava8IO") && !Jvm.isJava9Plus() && OS.isLinux();
-        if (fastJava8IO) System.out.println("FastJava8IO: " + fastJava8IO);
-        return fastJava8IO;
-    }
-
-    @NotNull
-    static ISocketChannel wrap(ChronicleSocketChannel sc) {
-        assert sc != null;
-        return FAST_JAVA8_IO ? new FastJ8SocketChannel(sc) : new VanillaSocketChannel(sc);
-    }
-
-    @NotNull
-    static ISocketChannel wrapUnsafe(ChronicleSocketChannel sc) {
-        assert sc != null;
-        return FAST_JAVA8_IO ? new UnsafeFastJ8SocketChannel(sc) : new VanillaSocketChannel(sc);
-    }
-
-    @NotNull
-    ChronicleSocketChannel socketChannel();
-
-    int read(ByteBuffer byteBuffer) throws IOException;
-
-    int write(ByteBuffer byteBuffer) throws IOException;
-
-    long write(ByteBuffer[] byteBuffer) throws IOException;
-
-    @NotNull
-    ChronicleSocket socket();
-
-    void configureBlocking(boolean blocking) throws IOException;
-
-    @NotNull
-    InetSocketAddress getRemoteAddress() throws IOException;
-
-    @NotNull
-    InetSocketAddress getLocalAddress() throws IOException;
-
-    /**
-     * As this socket can be closed in a background thread it can be both isClosed() and isOpen() if close() has been called but it hasn't actually
-     * been closed
-     *
-     * @return is the underlying socket open
-     * @see net.openhft.chronicle.core.io.QueryCloseable
-     */
-    boolean isOpen();
-
-    /**
-     * As this socket can be closed in a background thread it can be both isClosed() and isOpen() if close() has been called but it hasn't actually
-     * been closed
-     *
-     * @return has close been called
-     */
-    // This breaks on Java 11
-    // @Override
-    // boolean isClosed();
-
-    boolean isBlocking();
-}
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/UnsafeFastJ8SocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/UnsafeFastJ8SocketChannel.java
index c81dd85d89..dab49d56ac 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/UnsafeFastJ8SocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/UnsafeFastJ8SocketChannel.java
@@ -24,12 +24,13 @@ import sun.nio.ch.IOStatus;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.SocketChannel;
 
 /**
  * Doesn't do any locking so can only be used in a single-threaded manner
  */
 public class UnsafeFastJ8SocketChannel extends FastJ8SocketChannel {
-    public UnsafeFastJ8SocketChannel(ChronicleSocketChannel socketChannel) {
+    public UnsafeFastJ8SocketChannel(SocketChannel socketChannel) {
         super(socketChannel);
     }
 
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketChannelImpl.java b/src/main/java/net/openhft/chronicle/network/tcp/VanillaChronicleServerSocketChannel.java
similarity index 96%
rename from src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketChannelImpl.java
rename to src/main/java/net/openhft/chronicle/network/tcp/VanillaChronicleServerSocketChannel.java
index cdb863a909..a84c3d2381 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleServerSocketChannelImpl.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/VanillaChronicleServerSocketChannel.java
@@ -10,7 +10,7 @@ import java.net.SocketOption;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
 
-public class ChronicleServerSocketChannelImpl implements ChronicleServerSocketChannel {
+public class VanillaChronicleServerSocketChannel implements ChronicleServerSocketChannel {
 
     ServerSocketChannel ssc;
 
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
index 3ca6a95d47..f8d101e7ed 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
@@ -23,17 +23,21 @@ import net.openhft.chronicle.core.io.IORuntimeException;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.net.SocketOption;
 import java.nio.ByteBuffer;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
 
-public class VanillaSocketChannel extends AbstractCloseable implements ISocketChannel {
-    protected final ChronicleSocketChannel socketChannel;
+public class VanillaSocketChannel extends AbstractCloseable implements ChronicleSocketChannel {
+    protected final SocketChannel socketChannel;
 
-    public VanillaSocketChannel(ChronicleSocketChannel socketChannel) {
+    public VanillaSocketChannel(SocketChannel socketChannel) {
         this.socketChannel = socketChannel;
     }
 
     @Override
-    public ChronicleSocketChannel socketChannel() {
+    public SocketChannel socketChannel() {
         return socketChannel;
     }
 
@@ -54,7 +58,7 @@ public class VanillaSocketChannel extends AbstractCloseable implements ISocketCh
 
     @Override
     public ChronicleSocket socket() {
-        return socketChannel.socket();
+        return ChronicleSocketFactory.toChronicleSocket(socketChannel.socket());
     }
 
     @Override
@@ -62,6 +66,26 @@ public class VanillaSocketChannel extends AbstractCloseable implements ISocketCh
         socketChannel.configureBlocking(blocking);
     }
 
+    @Override
+    public void connect(final InetSocketAddress socketAddress) throws IOException {
+        socketChannel.connect(socketAddress);
+    }
+
+    @Override
+    public void register(final Selector selector, final int opConnect) throws ClosedChannelException {
+        socketChannel.register(selector, opConnect);
+    }
+
+    @Override
+    public boolean finishConnect() throws IOException {
+        return socketChannel.finishConnect();
+    }
+
+    @Override
+    public void setOption(final SocketOption<Boolean> soReuseaddr, final boolean b) throws IOException {
+        socketChannel.setOption(soReuseaddr, b);
+    }
+
     @Override
     public InetSocketAddress getRemoteAddress() throws IORuntimeException {
         try {
diff --git a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
index 5b052c29a3..ff48cc7398 100644
--- a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
+++ b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
@@ -45,7 +45,7 @@ public class TcpEventHandlerReleaseTest extends NetworkTestCommon {
 
     public TcpEventHandler createTcpEventHandler() throws IOException {
         NetworkContext nc = new VanillaNetworkContext();
-        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort).toISocketChannel());
+        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
         TcpEventHandler tcpEventHandler = new TcpEventHandler(nc);
         tcpEventHandler.tcpHandler(NullTcpHandler.INSTANCE);
         return tcpEventHandler;
diff --git a/src/test/java/net/openhft/chronicle/network/ssl/NioSslIntegrationTest.java b/src/test/java/net/openhft/chronicle/network/ssl/NioSslIntegrationTest.java
index 1b9a17ab60..9538b62c80 100644
--- a/src/test/java/net/openhft/chronicle/network/ssl/NioSslIntegrationTest.java
+++ b/src/test/java/net/openhft/chronicle/network/ssl/NioSslIntegrationTest.java
@@ -6,6 +6,7 @@ import net.openhft.chronicle.network.NetworkTestCommon;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocketChannel;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocketFactory;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
 import net.openhft.chronicle.threads.NamedThreadFactory;
 import org.junit.After;
 import org.junit.Before;
@@ -50,7 +51,7 @@ public final class NioSslIntegrationTest extends NetworkTestCommon {
         serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
         serverChannel.configureBlocking(true);
 
-        final ChronicleSocketChannel channel = ChronicleSocketChannel.open();
+        final ChronicleSocketChannel channel = ChronicleSocketChannelFactory.wrap();
         channel.configureBlocking(false);
         channel.connect(new InetSocketAddress("127.0.0.1", serverChannel.socket().getLocalPort()));
 
diff --git a/src/test/java/net/openhft/chronicle/network/ssl/NonClusteredSslIntegrationTest.java b/src/test/java/net/openhft/chronicle/network/ssl/NonClusteredSslIntegrationTest.java
index b7ca889cc1..c44ed07219 100644
--- a/src/test/java/net/openhft/chronicle/network/ssl/NonClusteredSslIntegrationTest.java
+++ b/src/test/java/net/openhft/chronicle/network/ssl/NonClusteredSslIntegrationTest.java
@@ -5,7 +5,7 @@ import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.core.io.SimpleCloseable;
 import net.openhft.chronicle.network.*;
 import net.openhft.chronicle.network.api.TcpHandler;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
 import net.openhft.chronicle.threads.EventGroup;
 import net.openhft.chronicle.threads.Pauser;
 import org.jetbrains.annotations.NotNull;
@@ -247,7 +247,7 @@ public final class NonClusteredSslIntegrationTest extends NetworkTestCommon {
 
         @NotNull
         @Override
-        public StubNetworkContext socketChannel(final ISocketChannel socketChannel) {
+        public StubNetworkContext socketChannel(final ChronicleSocketChannel socketChannel) {
             return super.socketChannel(socketChannel);
         }
 
diff --git a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoClientMain.java b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoClientMain.java
index 5a53980dcc..25cbe52a1f 100644
--- a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoClientMain.java
+++ b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoClientMain.java
@@ -19,7 +19,7 @@ package net.openhft.performance.tests.vanilla.tcp;
 
 import net.openhft.affinity.Affinity;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.Closeable;
@@ -138,7 +138,7 @@ public class EchoClientMain {
         }
         @NotNull String[] hostnames = args.length > 0 ? args : "localhost".split(",");
 
-        @NotNull ISocketChannel[] sockets = new ISocketChannel[CLIENTS];
+        @NotNull ChronicleSocketChannel[] sockets = new ChronicleSocketChannel[CLIENTS];
         openConnections(hostnames, PORT, sockets);
         testThroughput(sockets);
         closeConnections(sockets);
@@ -148,40 +148,40 @@ public class EchoClientMain {
         closeConnections(sockets);
     }
 
-    private static void openConnections(@NotNull String[] hostname, int port, @NotNull ISocketChannel... sockets) throws IOException {
+    private static void openConnections(@NotNull String[] hostname, int port, @NotNull ChronicleSocketChannel... sockets) throws IOException {
         for (int j = 0; j < sockets.length; j++) {
-            sockets[j] = ChronicleSocketChannel.open(new InetSocketAddress(hostname[j % hostname.length], port)).toISocketChannel();
+            sockets[j] = ChronicleSocketChannelFactory.wrap(new InetSocketAddress(hostname[j % hostname.length], port));
             sockets[j].socket().setTcpNoDelay(true);
             sockets[j].configureBlocking(false);
         }
     }
 
-    private static void closeConnections(@NotNull ISocketChannel... sockets) throws IOException {
+    private static void closeConnections(@NotNull ChronicleSocketChannel... sockets) throws IOException {
         for (@NotNull Closeable socket : sockets)
             socket.close();
     }
 
-    private static void testThroughput(@NotNull ISocketChannel... sockets) throws IOException {
+    private static void testThroughput(@NotNull ChronicleSocketChannel... sockets) throws IOException {
         System.out.println("Starting throughput test, clients=" + CLIENTS);
         int bufferSize = 16 * 1024;
         ByteBuffer bb = ByteBuffer.allocateDirect(bufferSize).order(ByteOrder.LITTLE_ENDIAN);
         int count = 0, window = 8;
         long start = System.nanoTime();
         while (System.nanoTime() - start < 10e9) {
-            for (@NotNull ISocketChannel socket : sockets) {
+            for (@NotNull ChronicleSocketChannel socket : sockets) {
                 bb.clear();
                 bb.putInt(0, bb.limit());
                 if (socket.write(bb) < 0)
                     throw new AssertionError("Socket " + socket + " unable to write in one go.");
             }
             if (count >= window)
-                for (@NotNull ISocketChannel socket : sockets) {
+                for (@NotNull ChronicleSocketChannel socket : sockets) {
                     bb.clear();
                     while (socket.read(bb) >= 0 && bb.remaining() > 0) ;
                 }
             count++;
         }
-        for (@NotNull ISocketChannel socket : sockets) {
+        for (@NotNull ChronicleSocketChannel socket : sockets) {
             try {
                 do {
                     bb.clear();
@@ -194,7 +194,7 @@ public class EchoClientMain {
                 1e3 * count * bufferSize * sockets.length / time, CLIENTS);
     }
 
-    private static void testByteLatency(int targetThroughput, @NotNull ISocketChannel... sockets) throws IOException {
+    private static void testByteLatency(int targetThroughput, @NotNull ChronicleSocketChannel... sockets) throws IOException {
         System.out.println("Starting latency test rate: " + targetThroughput);
         int tests = Math.max(1000, Math.min(300 * targetThroughput, 5_000_000));
         @NotNull long[] times = new long[tests * sockets.length];
@@ -213,7 +213,7 @@ public class EchoClientMain {
                 ;
             long next = now;
             for (int j = 0; j < sockets.length; j++) {
-                ISocketChannel socket = sockets[j];
+                ChronicleSocketChannel socket = sockets[j];
                 start[j] = next;
                 long start0 = System.nanoTime();
                 bb.position(0);
@@ -224,7 +224,7 @@ public class EchoClientMain {
             }
 
             for (int j = 0; j < sockets.length; j++) {
-                ISocketChannel socket = sockets[j];
+                ChronicleSocketChannel socket = sockets[j];
                 bb.position(0);
                 while (bb.remaining() > 0)
                     if (socket.read(bb) < 0)
diff --git a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoReconnectingClientMain.java b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoReconnectingClientMain.java
index 7b5a015e14..42550a6652 100644
--- a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoReconnectingClientMain.java
+++ b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoReconnectingClientMain.java
@@ -19,7 +19,7 @@ package net.openhft.performance.tests.vanilla.tcp;
 
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.Closeable;
@@ -130,25 +130,25 @@ public class EchoReconnectingClientMain {
     public static void main(@NotNull String... args) throws IOException {
         @NotNull String[] hostnames = args.length > 0 ? args : "localhost".split(",");
 
-        @NotNull ISocketChannel[] sockets = new ISocketChannel[CLIENTS];
+        @NotNull ChronicleSocketChannel[] sockets = new ChronicleSocketChannel[CLIENTS];
         for (int i : new int[]{200,/* 200, 500, 1000, */2000, 3500, 5000})
             testByteLatency(hostnames, i, sockets);
     }
 
-    private static void openConnections(@NotNull String[] hostname, int port, @NotNull ISocketChannel... sockets) throws IOException {
+    private static void openConnections(@NotNull String[] hostname, int port, @NotNull ChronicleSocketChannel... sockets) throws IOException {
         for (int j = 0; j < sockets.length; j++) {
-            sockets[j] = ChronicleSocketChannel.open(new InetSocketAddress(hostname[j % hostname.length], port)).toISocketChannel();
+            sockets[j] = ChronicleSocketChannelFactory.wrap(new InetSocketAddress(hostname[j % hostname.length], port));
             sockets[j].socket().setTcpNoDelay(true);
             sockets[j].configureBlocking(false);
         }
     }
 
-    private static void closeConnections(@NotNull ISocketChannel... sockets) throws IOException {
+    private static void closeConnections(@NotNull ChronicleSocketChannel... sockets) throws IOException {
         for (@NotNull Closeable socket : sockets)
             socket.close();
     }
 
-    private static void testByteLatency(String[] hostnames, int targetThroughput, @NotNull ISocketChannel... sockets) throws IOException {
+    private static void testByteLatency(String[] hostnames, int targetThroughput, @NotNull ChronicleSocketChannel... sockets) throws IOException {
         System.out.println("Starting latency test rate: " + targetThroughput);
         int tests = Math.max(1000, Math.min(10 * targetThroughput, 20_000));
         @NotNull long[] times = new long[tests * sockets.length];
@@ -168,13 +168,13 @@ public class EchoReconnectingClientMain {
             long next = now;
             for (int j = 0; j < sockets.length; j++) {
                 String hostname = hostnames[j % hostnames.length];
-                sockets[j] = ChronicleSocketChannel.open(new InetSocketAddress(hostname, PORT)).toISocketChannel();
+                sockets[j] = ChronicleSocketChannelFactory.wrap(new InetSocketAddress(hostname, PORT));
                 sockets[j].socket().setTcpNoDelay(true);
                 sockets[j].configureBlocking(false);
                 start[j] = next;
                 long start0 = System.nanoTime();
                 bb.position(0);
-                ISocketChannel socket = sockets[j];
+                ChronicleSocketChannel socket = sockets[j];
                 while (bb.remaining() > 0)
                     if (socket.write(bb) < 0)
                         throw new EOFException();
@@ -182,7 +182,7 @@ public class EchoReconnectingClientMain {
             }
 
             for (int j = 0; j < sockets.length; j++) {
-                ISocketChannel socket = sockets[j];
+                ChronicleSocketChannel socket = sockets[j];
                 bb.position(0);
                 while (bb.remaining() > 0)
                     if (socket.read(bb) < 0)
diff --git a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoServerMain.java b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoServerMain.java
index 9173a1922c..bf50a4e9d6 100644
--- a/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoServerMain.java
+++ b/src/test/java/net/openhft/performance/tests/vanilla/tcp/EchoServerMain.java
@@ -21,7 +21,6 @@ import net.openhft.affinity.Affinity;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocketChannel;
 import net.openhft.chronicle.network.tcp.ChronicleServerSocketFactory;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.network.tcp.ISocketChannel;
 import org.jetbrains.annotations.NotNull;
 
 import java.io.IOException;
@@ -49,17 +48,17 @@ public class EchoServerMain {
 
             ByteBuffer bb = ByteBuffer.allocateDirect(32 * 1024);
             ByteBuffer bb2 = ByteBuffer.allocateDirect(32 * 1024);
-            @NotNull List<ISocketChannel> sockets = new ArrayList<>();
+            @NotNull List<ChronicleSocketChannel> sockets = new ArrayList<>();
             for (; ; ) {
                 if (sockets.isEmpty())
                     Thread.yield();
                 ChronicleSocketChannel sc = nextSocket.getAndSet(null);
                 if (sc != null) {
 //                    System.out.println("Connected " + sc);
-                    sockets.add(sc.toISocketChannel());
+                    sockets.add(sc);
                 }
                 for (int i = 0; i < sockets.size(); i++) {
-                    ISocketChannel socket = sockets.get(i);
+                    ChronicleSocketChannel socket = sockets.get(i);
                     try {
                         // simulate copying the data.
                         // obviously faster if you don't touch the data but no real service would do that.
