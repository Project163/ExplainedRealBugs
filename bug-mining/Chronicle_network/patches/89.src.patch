diff --git a/src/main/java/net/openhft/chronicle/network/NetworkContext.java b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
index 893f69a72f..8186d9b0a0 100644
--- a/src/main/java/net/openhft/chronicle/network/NetworkContext.java
+++ b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
@@ -99,6 +99,10 @@ public interface NetworkContext<T extends NetworkContext<T>> extends Closeable {
         // do nothing
     }
 
+    default void removeConnectionListener(ConnectionListener connectionListener) {
+        // do nothing
+    }
+
     default TimeProvider timeProvider() {
         return SystemTimeProvider.INSTANCE;
     }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/handlers/CspTcpHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/handlers/CspTcpHandler.java
index bc82b0573d..61a1bf3de8 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/handlers/CspTcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/handlers/CspTcpHandler.java
@@ -68,6 +68,12 @@ public abstract class CspTcpHandler<T extends NetworkContext<T>> extends WireTcp
         if (handler instanceof WritableSubHandler) {
             writers.remove(handler);
         }
+        if (handler instanceof Registerable) {
+            registry.remove(((Registerable<?>)handler).registryKey());
+        }
+        if (handler instanceof ConnectionListener) {
+            nc().removeConnectionListener((ConnectionListener) handler);
+        }
         if (this.handler == handler) {
             this.handler = null;
             this.lastCid = 0;
diff --git a/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java b/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
index ad57f006c8..5772c18f58 100644
--- a/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
+++ b/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
@@ -2,6 +2,8 @@ package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.bytes.Bytes;
 import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.io.AbstractCloseable;
+import net.openhft.chronicle.core.io.Closeable;
 import net.openhft.chronicle.core.io.IORuntimeException;
 import net.openhft.chronicle.core.threads.EventLoop;
 import net.openhft.chronicle.core.util.ThrowingFunction;
@@ -11,6 +13,7 @@ import net.openhft.chronicle.network.cluster.AbstractSubHandler;
 import net.openhft.chronicle.network.cluster.Cluster;
 import net.openhft.chronicle.network.cluster.HostDetails;
 import net.openhft.chronicle.network.cluster.VanillaClusteredNetworkContext;
+import net.openhft.chronicle.network.cluster.handlers.Registerable;
 import net.openhft.chronicle.network.cluster.handlers.RejectedHandlerException;
 import net.openhft.chronicle.network.cluster.handlers.UberHandler;
 import net.openhft.chronicle.network.connection.CoreFields;
@@ -18,6 +21,7 @@ import net.openhft.chronicle.network.connection.VanillaWireOutPublisher;
 import net.openhft.chronicle.threads.Pauser;
 import net.openhft.chronicle.threads.TimingPauser;
 import net.openhft.chronicle.wire.*;
+import org.apache.mina.util.IdentityHashSet;
 import org.jetbrains.annotations.NotNull;
 import org.junit.After;
 import org.junit.Before;
@@ -27,6 +31,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -37,6 +42,9 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 import java.util.stream.IntStream;
 
+import static net.openhft.chronicle.network.HeaderTcpHandler.HANDLER;
+import static net.openhft.chronicle.network.cluster.handlers.UberHandler.uberHandler;
+import static net.openhft.chronicle.network.connection.CoreFields.*;
 import static org.junit.Assert.*;
 
 public class UberHandlerTest extends NetworkTestCommon {
@@ -54,6 +62,8 @@ public class UberHandlerTest extends NetworkTestCommon {
     private static final Map<Long, Integer> COUNTERS_PER_CID = new ConcurrentHashMap<>();
     private static final AtomicBoolean REJECTED_HANDLER_ONREAD_CALLED = new AtomicBoolean(false);
     private static final AtomicBoolean REJECTED_HANDLER_ONWRITE_CALLED = new AtomicBoolean(false);
+    private static final AtomicBoolean REJECTING_SUB_HANDLER_SHOULD_REJECT = new AtomicBoolean(false);
+    private static final AtomicReference<Map<Object, RegisterableSubHandler>> REGISTRY = new AtomicReference<>();
 
     @Before
     public void before() {
@@ -64,6 +74,8 @@ public class UberHandlerTest extends NetworkTestCommon {
         STOPPED.set(0);
         MESSAGES_RECEIVED_CIDS.clear();
         SENDERS_INITIALIZED.set(0);
+        REJECTING_SUB_HANDLER_SHOULD_REJECT.set(false);
+        REGISTRY.set(null);
     }
 
     @After
@@ -105,7 +117,7 @@ public class UberHandlerTest extends NetworkTestCommon {
     @Test(expected = IllegalArgumentException.class)
     public void constructorWillThrowIfLocalAndRemoteIdentifiersAreTheSame() {
         Wire wire = new BinaryWire(Bytes.allocateElasticOnHeap());
-        UberHandler.uberHandler(123, 123, WireType.BINARY).writeMarshallable(wire);
+        uberHandler(123, 123, WireType.BINARY).writeMarshallable(wire);
     }
 
     private void stopAndWaitTillAllHandlersEnd() throws TimeoutException {
@@ -280,6 +292,89 @@ public class UberHandlerTest extends NetworkTestCommon {
         }
     }
 
+    @Test
+    public void addHandlerRegistersRegisterableHandlers() {
+        try (final UberHandlerTestHarness testHarness = new UberHandlerTestHarness()) {
+            testHarness.registerSubHandler(new RegisterableSubHandler());
+            assertEquals(REGISTRY.get().get(RegisterableSubHandler.REGISTRY_KEY).getClass(), RegisterableSubHandler.class);
+        }
+    }
+
+    @Test
+    public void removeHandlerUnregistersRegisterableHandlers() {
+        try (final UberHandlerTestHarness testHarness = new UberHandlerTestHarness()) {
+            testHarness.registerSubHandler(new RegisterableSubHandler());
+            assertEquals(REGISTRY.get().get(RegisterableSubHandler.REGISTRY_KEY).getClass(), RegisterableSubHandler.class);
+            REJECTING_SUB_HANDLER_SHOULD_REJECT.set(true);
+            expectException("Rejected in onRead");
+            testHarness.sendMessageToCurrentHandler();
+            assertTrue(REGISTRY.get().isEmpty());
+        }
+    }
+
+    @Test
+    public void addHandlerAddsConnectionListenerHandlersToNetworkContext() {
+        try (final UberHandlerTestHarness testHarness = new UberHandlerTestHarness()) {
+            testHarness.registerSubHandler(new ConnectionListenerSubHandler());
+            assertEquals(1, testHarness.nc().connectionListeners.size());
+        }
+    }
+
+    @Test
+    public void removeHandlerRemovesConnectionListenerHandlersFromNetworkContext() {
+        try (final UberHandlerTestHarness testHarness = new UberHandlerTestHarness()) {
+            testHarness.registerSubHandler(new ConnectionListenerSubHandler());
+            assertEquals(1, testHarness.nc().connectionListeners.size());
+            REJECTING_SUB_HANDLER_SHOULD_REJECT.set(true);
+            expectException("Rejected in onRead");
+            testHarness.sendMessageToCurrentHandler();
+            assertEquals(0, testHarness.nc().connectionListeners.size());
+        }
+    }
+
+    private static class ConnectionListenerSubHandler extends RejectingSubHandler implements ConnectionListener {
+
+        @Override
+        public void onConnected(int localIdentifier, int remoteIdentifier, boolean isAcceptor) {
+        }
+
+        @Override
+        public void onDisconnected(int localIdentifier, int remoteIdentifier, boolean isAcceptor) {
+        }
+    }
+
+    private static class RegisterableSubHandler extends RejectingSubHandler implements Registerable<RegisterableSubHandler> {
+
+        public static final String REGISTRY_KEY = "registryKey";
+
+        @Override
+        public Object registryKey() {
+            return REGISTRY_KEY;
+        }
+
+        @Override
+        public void registry(Map<Object, RegisterableSubHandler> registry) {
+            REGISTRY.set(registry);
+        }
+    }
+
+    private static class RejectingSubHandler extends AbstractSubHandler<MyClusteredNetworkContext> implements Marshallable {
+
+        @Override
+        public void onRead(@NotNull WireIn inWire, @NotNull WireOut outWire) {
+            if (REJECTING_SUB_HANDLER_SHOULD_REJECT.get()) {
+                throw new RejectedHandlerException("Rejected in onRead");
+            }
+        }
+
+        @Override
+        public void onInitialize(WireOut outWire) throws RejectedExecutionException {
+            if (REJECTING_SUB_HANDLER_SHOULD_REJECT.get()) {
+                throw new RejectedHandlerException("Rejected in onInitialize");
+            }
+        }
+    }
+
     private static class RejectingOnInitializeHandler extends AbstractSubHandler<MyClusteredNetworkContext>
             implements WritableSubHandler<MyClusteredNetworkContext>, Marshallable {
 
@@ -341,13 +436,13 @@ public class UberHandlerTest extends NetworkTestCommon {
     }
 
     private void sendHandler(WireOut wireOut, int cid, Marshallable handler) {
-        wireOut.writeEventName(CoreFields.csp).text(TEST_HANDLERS_CSP)
+        wireOut.writeEventName(csp).text(TEST_HANDLERS_CSP)
                 .writeEventName(CoreFields.cid).int64(cid)
                 .writeEventName(CoreFields.handler).typedMarshallable(handler);
     }
 
     private void sendMessageToHandler(WireOut wireOut, int cid) {
-        wireOut.writeEventName(CoreFields.csp).text(TEST_HANDLERS_CSP)
+        wireOut.writeEventName(csp).text(TEST_HANDLERS_CSP)
                 .writeEventName(CoreFields.cid).int64(cid);
     }
 
@@ -363,8 +458,22 @@ public class UberHandlerTest extends NetworkTestCommon {
     }
 
     static class MyClusteredNetworkContext extends VanillaClusteredNetworkContext<MyClusteredNetworkContext, MyClusterContext> {
+
+        public Set<ConnectionListener> connectionListeners = new IdentityHashSet<>();
+
         public MyClusteredNetworkContext(@NotNull MyClusterContext clusterContext) {
             super(clusterContext);
+            wireOutPublisher(new VanillaWireOutPublisher(clusterContext.wireType()));
+        }
+
+        @Override
+        public void addConnectionListener(ConnectionListener connectionListener) {
+            connectionListeners.add(connectionListener);
+        }
+
+        @Override
+        public void removeConnectionListener(ConnectionListener connectionListener) {
+            connectionListeners.remove(connectionListener);
         }
     }
 
@@ -400,6 +509,9 @@ public class UberHandlerTest extends NetworkTestCommon {
 
         @Override
         protected void defaults() {
+            if (this.wireType() == null)
+                this.wireType(WireType.BINARY);
+
             if (this.wireOutPublisherFactory() == null)
                 this.wireOutPublisherFactory(VanillaWireOutPublisher::new);
 
@@ -595,4 +707,57 @@ public class UberHandlerTest extends NetworkTestCommon {
             }
         }
     }
+
+    static class UberHandlerTestHarness extends AbstractCloseable {
+
+        private final MyClusterContext clusterContext;
+        private final MyClusteredNetworkContext nc;
+        private final UberHandler<MyClusteredNetworkContext> uberHandler;
+        private final Wire inWire;
+        private final Wire outWire;
+
+        public UberHandlerTestHarness() {
+            clusterContext = new MyClusterContext();
+            nc = new MyClusteredNetworkContext(clusterContext);
+            uberHandler = createHandler();
+            uberHandler.nc(nc);
+            inWire = WireType.BINARY.apply(Bytes.allocateElasticOnHeap());
+            outWire = WireType.BINARY.apply(Bytes.allocateElasticOnHeap());
+        }
+
+        private UberHandler<MyClusteredNetworkContext> createHandler() {
+            Wire wire = WireType.BINARY.apply(Bytes.allocateElasticOnHeap());
+            uberHandler(123, 456, WireType.BINARY).writeMarshallable(wire);
+            try (final DocumentContext documentContext = wire.readingDocument()) {
+                return wire.read(HANDLER).object(UberHandler.class);
+            }
+        }
+
+        private void registerSubHandler(WriteMarshallable subHandler) {
+            try (final DocumentContext documentContext = inWire.writingDocument(true)) {
+                final Wire documentWire = documentContext.wire();
+                documentWire.write(csp).text("12345");
+                documentWire.write(cid).int64(12345L);
+                documentWire.write(handler).typedMarshallable(subHandler);
+            }
+            uberHandler.process(inWire.bytes(), outWire.bytes(), nc);
+        }
+
+        private void sendMessageToCurrentHandler() {
+            try (final DocumentContext documentContext = inWire.writingDocument(false)) {
+                final Wire documentWire = documentContext.wire();
+                documentWire.write("junk").text("to trigger an onRead");
+            }
+            uberHandler.process(inWire.bytes(), outWire.bytes(), nc);
+        }
+
+        public MyClusteredNetworkContext nc() {
+            return nc;
+        }
+
+        @Override
+        protected void performClose() throws IllegalStateException {
+            Closeable.closeQuietly(clusterContext, nc, uberHandler, inWire, outWire);
+        }
+    }
 }
