diff --git a/src/main/java/net/openhft/chronicle/network/NetworkContext.java b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
index 993ae18b55..b1774a3462 100644
--- a/src/main/java/net/openhft/chronicle/network/NetworkContext.java
+++ b/src/main/java/net/openhft/chronicle/network/NetworkContext.java
@@ -83,6 +83,13 @@ public interface NetworkContext<T extends NetworkContext<T>> extends Closeable {
         return Jvm.isDebug() ? ConnectionListeners.LOGGING : ConnectionListeners.NONE;
     }
 
+    /**
+     * This should only ever be executed from {@link TcpEventHandler#closeAndStartReconnector()} if
+     * you're adding a call to it from somewhere else you're potentially
+     * re-introducing <a href="https://github.com/OpenHFT/Chronicle-Network/issues/240">this issue</a>
+     *
+     * @return the runnable that orchestrates reconnection
+     */
     Runnable socketReconnector();
 
     @NotNull
@@ -124,6 +131,7 @@ public interface NetworkContext<T extends NetworkContext<T>> extends Closeable {
     /**
      * Called when the outbound buffer becomes empty (edge-triggered)
      */
-    default void onFlushed() {}
+    default void onFlushed() {
+    }
 }
 
diff --git a/src/main/java/net/openhft/chronicle/network/RemoteConnector.java b/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
index b1eb1be5a7..cc4cdcd48a 100644
--- a/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
+++ b/src/main/java/net/openhft/chronicle/network/RemoteConnector.java
@@ -174,7 +174,7 @@ public class RemoteConnector<T extends NetworkContext<T>> extends SimpleCloseabl
                 eventHandler = tcpHandlerSupplier.apply(nc);
 
             } catch (ClosedIllegalStateException e) {
-                Jvm.debug().on(getClass(), "Already closed while connecting to " + address, e);
+                Jvm.warn().on(getClass(), "Already closed while connecting to " + address, e);
                 // may be already closed by socketReconnector in HostConnector
                 closeSocket(sc);
 
diff --git a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
index 8a9463336f..467223be9e 100644
--- a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
@@ -197,6 +197,11 @@ public class TcpEventHandler<T extends NetworkContext<T>>
         if (tcpHandler == null)
             return false;
 
+        if (tcpHandler.hasTimedOut()) {
+            closeAndStartReconnector();
+            return false;
+        }
+
         try {
             return action0();
         } catch (InvalidEventHandlerException t) {
@@ -321,6 +326,7 @@ public class TcpEventHandler<T extends NetworkContext<T>>
      * Closes the channel and triggers asynchronous reconnecting if it's a connector.
      */
     private void closeAndStartReconnector() {
+        Jvm.debug().on(TcpEventHandler.class, "Closing and starting reconnector");
         close();
         if (!nc.isAcceptor()) {
             final Runnable socketReconnector = nc.socketReconnector();
diff --git a/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java b/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
index 05d6dfc859..cc7b3e91a5 100644
--- a/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
@@ -58,4 +58,12 @@ public interface TcpHandler<N extends NetworkContext<N>> extends ClientClosedPro
      */
     default void performIdleWork() {
     }
+
+    /**
+     * Check if an application-layer timeout has occurred, if this returns true,
+     * the current connection will be dropped and a reconnection attempt will be made
+     */
+    default boolean hasTimedOut() {
+        return false;
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/HeartbeatEventHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/HeartbeatEventHandler.java
index b907d28de0..1f96b520a6 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/HeartbeatEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/HeartbeatEventHandler.java
@@ -20,4 +20,13 @@ package net.openhft.chronicle.network.cluster;
 @FunctionalInterface
 public interface HeartbeatEventHandler {
     void onMessageReceived();
+
+    /**
+     * Has a timeout been detected?
+     *
+     * @return true if a timeout has been detected, false otherwise
+     */
+    default boolean hasTimedOut() {
+        return false;
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java
index b840b038fa..89cafc767d 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/handlers/HeartbeatHandler.java
@@ -19,7 +19,6 @@ package net.openhft.chronicle.network.cluster.handlers;
 
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.core.annotation.UsedViaReflection;
-import net.openhft.chronicle.core.io.Closeable;
 import net.openhft.chronicle.core.threads.InvalidEventHandlerException;
 import net.openhft.chronicle.core.threads.Timer;
 import net.openhft.chronicle.core.threads.VanillaEventHandler;
@@ -48,6 +47,7 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
     private final AtomicBoolean hasHeartbeats = new AtomicBoolean();
     private final AtomicBoolean closed;
     private volatile long lastTimeMessageReceived;
+    private volatile boolean hasTimedOut = false;
     @Nullable
     private ConnectionListener connectionListener;
     @Nullable
@@ -145,10 +145,6 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
                 }
             }
             lastTimeMessageReceived = Long.MAX_VALUE;
-            Closeable closable = closable();
-            if (closable != null && !closable.isClosed()) {
-                Closeable.closeQuietly(closable);
-            }
         }
     }
 
@@ -157,6 +153,11 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
         lastTimeMessageReceived = System.currentTimeMillis();
     }
 
+    @Override
+    public boolean hasTimedOut() {
+        return hasTimedOut;
+    }
+
     private VanillaEventHandler heartbeatCheck() {
         return new HeartbeatCheckHandler();
     }
@@ -225,23 +226,16 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
         @Override
         public boolean action() throws InvalidEventHandlerException {
 
-            if (HeartbeatHandler.this.closable().isClosed())
-                throw newClosedInvalidEventHandlerException();
+            if (HeartbeatHandler.this.isClosed())
+                throw InvalidEventHandlerException.reusable();
 
             boolean hasHeartbeats = HeartbeatHandler.this.hasReceivedHeartbeat();
             boolean prev = HeartbeatHandler.this.hasHeartbeats.getAndSet(hasHeartbeats);
 
             if (hasHeartbeats != prev) {
                 if (!hasHeartbeats) {
-                    final Runnable socketReconnector = HeartbeatHandler.this.nc().socketReconnector();
-                    if (socketReconnector == null)
-                        Jvm.warn().on(getClass(), "socketReconnector == null");
-                    else
-                        socketReconnector.run();
-
-                    HeartbeatHandler.this.close();
-
-                    throw newClosedInvalidEventHandlerException();
+                    HeartbeatHandler.this.hasTimedOut = true;
+                    throw InvalidEventHandlerException.reusable();
                 } else
                     try {
                         if (connectionListener != null) {
@@ -272,7 +266,7 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
         @Override
         public boolean action() throws InvalidEventHandlerException {
             if (HeartbeatHandler.this.isClosed())
-                throw newClosedInvalidEventHandlerException();
+                throw InvalidEventHandlerException.reusable();
             // we will only publish a heartbeat if the wire out publisher is empty
             WireOutPublisher wireOutPublisher = HeartbeatHandler.this.nc().wireOutPublisher();
             if (wireOutPublisher.isEmpty())
@@ -298,9 +292,4 @@ public final class HeartbeatHandler<T extends ClusteredNetworkContext<T>> extend
             return "HeartbeatMessage{" + cid() + "}";
         }
     }
-
-    InvalidEventHandlerException newClosedInvalidEventHandlerException() {
-        return new InvalidEventHandlerException("closed");
-    }
-
 }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
index 4ccc08a6e5..06a146573a 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
@@ -265,6 +265,12 @@ public final class UberHandler<T extends ClusteredNetworkContext<T>> extends Csp
         }
     }
 
+    @Override
+    public boolean hasTimedOut() {
+        final HeartbeatEventHandler heartbeatEventHandler = heartbeatEventHandler();
+        return heartbeatEventHandler != null && heartbeatEventHandler.hasTimedOut();
+    }
+
     private void onMessageReceived() {
         final HeartbeatEventHandler heartbeatEventHandler = heartbeatEventHandler();
         if (heartbeatEventHandler != null)
diff --git a/src/test/java/net/openhft/chronicle/network/cluster/ClusterConnectivityTest.java b/src/test/java/net/openhft/chronicle/network/cluster/ClusterConnectivityTest.java
new file mode 100644
index 0000000000..c7c78b5527
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/cluster/ClusterConnectivityTest.java
@@ -0,0 +1,198 @@
+package net.openhft.chronicle.network.cluster;
+
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.util.ThrowingRunnable;
+import net.openhft.chronicle.network.ConnectionListener;
+import net.openhft.chronicle.network.NetworkTestCommon;
+import net.openhft.chronicle.network.TCPRegistry;
+import net.openhft.chronicle.network.test.TestCluster;
+import net.openhft.chronicle.network.test.TestClusterContext;
+import net.openhft.chronicle.testframework.internal.network.proxy.TcpProxy;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
+import static net.openhft.chronicle.network.util.TestUtil.getAvailablePortNumber;
+import static net.openhft.chronicle.testframework.ExecutorServiceUtil.shutdownAndWaitForTermination;
+import static net.openhft.chronicle.testframework.Waiters.waitForCondition;
+
+class ClusterConnectivityTest extends NetworkTestCommon {
+
+    private static final Consumer<TestClusterContext> NO_OP = cc -> {
+    };
+    private ExecutorService executorService;
+    private TcpProxy hostOneProxy;
+    private TcpProxy hostTwoProxy;
+    private boolean[][] connectedMatrix;
+
+    @BeforeEach
+    void setUp() throws IOException {
+        connectedMatrix = new boolean[3][3];
+        executorService = Executors.newCachedThreadPool();
+        TCPRegistry.createServerSocketChannelFor("host.one", "host.two", "host.three");
+        hostOneProxy = new TcpProxy(getAvailablePortNumber(), TCPRegistry.lookup("host.one"), executorService);
+        hostTwoProxy = new TcpProxy(getAvailablePortNumber(), TCPRegistry.lookup("host.two"), executorService);
+        executorService.submit(hostOneProxy);
+        executorService.submit(hostTwoProxy);
+    }
+
+    @AfterEach
+    void tearDown() {
+        closeQuietly(hostOneProxy, hostTwoProxy);
+        shutdownAndWaitForTermination(executorService);
+    }
+
+    @Test
+    void testNodesWillConnectToEachOther() {
+        startClusterAnd(() -> waitForCondition("All nodes didn't connect", this::everyoneIsConnected, 5_000));
+    }
+
+    @Test
+    void testNodesWillReconnectAfterDisconnection() {
+        startClusterAnd(() -> {
+            waitForCondition("All nodes didn't connect", this::everyoneIsConnected, 5_000);
+
+            // Simulate network event that breaks connectivity to 1
+            hostOneProxy.dropConnectionsAndPauseNewConnections();
+            waitForCondition("Some nodes are still connected to 1", () -> this.nobodyIsConnectedTo(1), 5_000);
+
+            // Allow connections again
+            hostOneProxy.acceptNewConnections();
+            waitForCondition("Connection wasn't restored", this::everyoneIsConnected, 5_000);
+        });
+    }
+
+    @Test
+    void testNodesWillReconnectAfterDisconnectionDueToTimeout() {
+        expectException("Missed heartbeat on network context");
+        startClusterAnd(() -> {
+            waitForCondition("All nodes didn't connect", this::everyoneIsConnected, 5_000);
+
+            // Simulate network event that interrupts traffic to 1
+            hostOneProxy.stopForwardingTrafficAndPauseNewConnections();
+            waitForCondition("Some nodes are still connected to 1", () -> this.nobodyIsConnectedTo(1), 5_000);
+
+            // Allow connections again
+            hostOneProxy.acceptNewConnections();
+            waitForCondition("Connection wasn't restored", this::everyoneIsConnected, 5_000);
+        }, cc -> cc.overrideNetworkContextTimeout(500));
+    }
+
+    @Test
+    void testNodesWillReconnectAfterDisconnectionDueToApplicationLayerTimeout() {
+        expectException("missed heartbeat, lastTimeMessageReceived");
+        ignoreException("Missed heartbeat on network context");
+        startClusterAnd(() -> {
+            waitForCondition("All nodes didn't connect", this::everyoneIsConnected, 5_000);
+
+            // Simulate network event that interrupts traffic to 1
+            hostOneProxy.stopForwardingTrafficAndPauseNewConnections();
+            waitForCondition("Some nodes are still connected to 1", () -> this.nobodyIsConnectedTo(1), 5_000);
+
+            // Allow connections again
+            hostOneProxy.acceptNewConnections();
+            waitForCondition("Connection wasn't restored: " + connectionStatuses().map(Object::toString).collect(Collectors.joining(", ")), this::everyoneIsConnected, 5_000);
+        }, cc -> cc.heartbeatTimeoutMs(1_000).heartbeatIntervalMs(500));
+    }
+
+    private <T extends Exception> void startClusterAnd(ThrowingRunnable<T> runnable) throws T {
+        startClusterAnd(runnable, NO_OP);
+    }
+
+    private <T extends Exception> void startClusterAnd(ThrowingRunnable<T> runnable, Consumer<TestClusterContext> clusterContextConfigurer) throws T {
+        try (TestCluster host1cluster = createCluster(1, clusterContextConfigurer);
+             TestCluster host2cluster = createCluster(2, clusterContextConfigurer);
+             TestCluster host3cluster = createCluster(3, clusterContextConfigurer)) {
+            ConnectionListener matrixUpdater = new MatrixUpdatingConnectionListener();
+            host1cluster.clusterContext().addConnectionListener(matrixUpdater);
+            host2cluster.clusterContext().addConnectionListener(matrixUpdater);
+            host3cluster.clusterContext().addConnectionListener(matrixUpdater);
+            host1cluster.start(1);
+            host2cluster.start(2);
+            host3cluster.start(3);
+
+            runnable.run();
+        }
+    }
+
+    private TestCluster createCluster(int forHost, Consumer<TestClusterContext> clusterContextConfigurer) {
+        final TestClusterContext clusterContext = new TestClusterContext();
+        clusterContextConfigurer.accept(clusterContext);
+        TestCluster cluster = new TestCluster(clusterContext);
+        cluster.hostDetails.put("host1", new HostDetails().hostId(1).connectUri("host.one"));
+        cluster.hostDetails.put("host2", new HostDetails().hostId(2).connectUri("host.two"));
+        cluster.hostDetails.put("host3", new HostDetails().hostId(3).connectUri("host.three"));
+        switch (forHost) {
+            case 3:
+                cluster.hostDetails.get("host2").connectUri("localhost:" + hostTwoProxy.socketAddress().getPort());
+                // fall through
+            case 2:
+                cluster.hostDetails.get("host1").connectUri("localhost:" + hostOneProxy.socketAddress().getPort());
+            default:
+        }
+        return cluster;
+    }
+
+    private class MatrixUpdatingConnectionListener implements ConnectionListener {
+
+        @Override
+        public void onConnected(int localIdentifier, int remoteIdentifier, boolean isAcceptor) {
+            Jvm.startup().on(MatrixUpdatingConnectionListener.class, localIdentifier + " connected to " + remoteIdentifier);
+            connectedMatrix[localIdentifier - 1][remoteIdentifier - 1] = true;
+        }
+
+        @Override
+        public void onDisconnected(int localIdentifier, int remoteIdentifier, boolean isAcceptor) {
+            Jvm.startup().on(MatrixUpdatingConnectionListener.class, localIdentifier + " disconnected from " + remoteIdentifier);
+            connectedMatrix[localIdentifier - 1][remoteIdentifier - 1] = false;
+        }
+    }
+
+    private boolean nobodyIsConnectedTo(int hostId) {
+        return connectionStatuses()
+                .filter(cs -> cs.localHostId == hostId || cs.remoteHostId == hostId)
+                .noneMatch(cs -> cs.connected);
+    }
+
+    private boolean everyoneIsConnected() {
+        return connectionStatuses().allMatch(cs -> cs.connected);
+    }
+
+    private Stream<ConnectionStatus> connectionStatuses() {
+        return IntStream.range(0, connectedMatrix.length)
+                .boxed()
+                .flatMap(i -> IntStream.range(0, connectedMatrix.length)
+                        .filter(j -> j != i)
+                        .mapToObj(j -> new ConnectionStatus(i + 1, j + 1, connectedMatrix[i][j])));
+    }
+
+    private static class ConnectionStatus {
+        final int localHostId;
+        final int remoteHostId;
+        final boolean connected;
+
+        private ConnectionStatus(int localHostId, int remoteHostId, boolean connected) {
+            this.localHostId = localHostId;
+            this.remoteHostId = remoteHostId;
+            this.connected = connected;
+        }
+
+        @Override
+        public String toString() {
+            return "ConnectionStatus{" +
+                    "localHostId=" + localHostId +
+                    ", remoteHostId=" + remoteHostId +
+                    ", connected=" + connected +
+                    '}';
+        }
+    }
+}
diff --git a/src/test/java/net/openhft/chronicle/network/test/TestClusterContext.java b/src/test/java/net/openhft/chronicle/network/test/TestClusterContext.java
index 1f9a1bcd20..eab989d2ab 100644
--- a/src/test/java/net/openhft/chronicle/network/test/TestClusterContext.java
+++ b/src/test/java/net/openhft/chronicle/network/test/TestClusterContext.java
@@ -47,6 +47,15 @@ public class TestClusterContext extends ClusterContext<TestClusterContext, TestC
         this.returnNullConnectionListener = true;
     }
 
+    /**
+     * This allows the configuration of a timeout that applies to the {@link NetworkContext} without it applying to the
+     * {@link net.openhft.chronicle.network.cluster.handlers.HeartbeatHandler}, to allow simulation of a timeout at the network layer.
+     * <p>
+     * Use {@link ClusterContext#heartbeatTimeoutMs()} to configure a timeout that applies to the both HeartbeatHandler and NetworkContext
+     *
+     * @param overrideNetworkContextTimeout The timeout in milliseconds to apply at the NetworkContext level
+     * @return this
+     */
     public TestClusterContext overrideNetworkContextTimeout(long overrideNetworkContextTimeout) {
         this.overrideNetworkContextTimeout = overrideNetworkContextTimeout;
         return this;
