diff --git a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
index a7ccad617c..c63cdb3e87 100644
--- a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
@@ -60,6 +60,10 @@ public class TcpEventHandler<T extends NetworkContext<T>>
         implements EventHandler, TcpEventHandlerManager<T> {
 
     public static final int TARGET_WRITE_SIZE = Integer.getInteger("TcpEventHandler.targetWriteSize", 1024);
+    /**
+     * Maximum number of iterations we can go without performing idle work (to prevent starvation in busy handlers)
+     */
+    private static final int MAX_ITERATIONS_BETWEEN_IDLE_WORK = 100;
     private static final boolean CALL_MISSED_HEARTBEAT_ON_DISCONNECT = Jvm.getBoolean("chronicle.network.callOnMissedHeartbeatOnDisconnect");
     private static final int MONITOR_POLL_EVERY_SEC = Integer.getInteger("tcp.event.monitor.secs", 10);
     private static final long NBR_WARNING_NANOS = Long.getLong("tcp.nbr.warning.nanos", 20_000_000);
@@ -90,6 +94,8 @@ public class TcpEventHandler<T extends NetworkContext<T>>
 
     private final boolean nbWarningEnabled;
     private final StatusMonitorEventHandler statusMonitorEventHandler;
+    // prevent starvation of idle actions
+    private int iterationsSinceIdle;
 
     @Nullable
     private volatile TcpHandler<T> tcpHandler;
@@ -283,9 +289,23 @@ public class TcpEventHandler<T extends NetworkContext<T>>
 
             throw new InvalidEventHandlerException("socket closed " + sc);
         }
+
+        performIdleWorkIfDue(busy);
+
         return busy;
     }
 
+    private void performIdleWorkIfDue(boolean busy) {
+        if (!busy || iterationsSinceIdle > MAX_ITERATIONS_BETWEEN_IDLE_WORK) {
+            if (tcpHandler != null) {
+                tcpHandler.performIdleWork();
+            }
+            iterationsSinceIdle = 0;
+        } else {
+            iterationsSinceIdle++;
+        }
+    }
+
     /**
      * Closes the channel and triggers asynchronous reconnecting if it's a connector.
      */
diff --git a/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java b/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
index 220291be61..4ab223bb33 100644
--- a/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/api/TcpHandler.java
@@ -54,4 +54,11 @@ public interface TcpHandler<N extends NetworkContext<N>> extends ClientClosedPro
 
     default void onReadComplete() {
     }
+
+    /**
+     * Perform any low priority work, called when the handler is not busy, or after it has been
+     * busy for a long time.
+     */
+    default void performIdleWork() {
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/ConnectionManager.java b/src/main/java/net/openhft/chronicle/network/cluster/ConnectionManager.java
index 33aa2026cc..cd46fcb212 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/ConnectionManager.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/ConnectionManager.java
@@ -19,39 +19,72 @@ package net.openhft.chronicle.network.cluster;
 
 import net.openhft.chronicle.network.NetworkContext;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.util.IdentityHashMap;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Function;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static java.util.Collections.newSetFromMap;
 
 public class ConnectionManager<T extends NetworkContext<T>> {
 
-    private final Set<ConnectionListener<T>> connectionListeners = newSetFromMap(new IdentityHashMap<>());
-
-    @NotNull
-    private final IdentityHashMap<T, AtomicBoolean> isConnected = new IdentityHashMap<>();
+    private static final int EMPTY_SEQUENCE = -1;
+    private final Set<ConnectionListenerHolder> connectionListeners = newSetFromMap(new IdentityHashMap<>());
+    private final AtomicInteger lastListenerAddedSequence = new AtomicInteger(EMPTY_SEQUENCE);
 
     public synchronized void addListener(@NotNull ConnectionListener<T> connectionListener) {
+        connectionListeners.add(new ConnectionListenerHolder(lastListenerAddedSequence.incrementAndGet(), connectionListener));
+    }
 
-        connectionListeners.add(connectionListener);
+    /**
+     * Execute any new connection listeners that have been added since the emitter last emitted
+     * a connection event.
+     *
+     * @param nc    The network context of the emitter
+     * @param token The event emitter token
+     */
+    public void executeNewListeners(@NotNull final T nc, @NotNull EventEmitterToken token) {
+        assert token != null : "Only emitters who've already emitted should call executeNewListeners";
+        if (lastListenerAddedSequence.get() > token.latestSequenceExecuted) {
+            executeListenersWithSequenceGreaterThan(token.latestSequenceExecuted, nc, token);
+        }
+    }
 
-        isConnected.forEach((wireOutPublisher, connected) -> connectionListener.onConnectionChange(wireOutPublisher, connected.get()));
+    /**
+     * The connection state of the network context changed, notify all listeners
+     * <p>
+     * Idempotent if the same emitter calls with the same state consecutively.
+     *
+     * @param isConnected The new connection state
+     * @param nc          The network context
+     * @param token       The event emitter token, or null if the event emitter is new
+     * @return The event emitter token that should be used going forward
+     */
+    public EventEmitterToken onConnectionChanged(boolean isConnected,
+                                                 @NotNull final T nc,
+                                                 @Nullable final EventEmitterToken token) {
+        final EventEmitterToken tokenToUse = (token == null ? new EventEmitterToken() : token);
+        if (tokenToUse.connected.compareAndSet(!isConnected, isConnected)) {
+            executeListenersWithSequenceGreaterThan(EMPTY_SEQUENCE, nc, tokenToUse);
+        }
+        return tokenToUse;
     }
 
-    public synchronized void onConnectionChanged(boolean isConnected, @NotNull final T nc) {
-        @NotNull final Function<T, AtomicBoolean> f = v -> new AtomicBoolean();
-        boolean wasConnected = this.isConnected.computeIfAbsent(nc, f).getAndSet(isConnected);
-        if (wasConnected != isConnected) connectionListeners.forEach(l -> {
-            try {
-                l.onConnectionChange(nc, isConnected);
-            } catch (IllegalStateException ignore) {
-                // this is already logged
+    private synchronized void executeListenersWithSequenceGreaterThan(int lowerSequenceLimit,
+                                                                      @NotNull final T nc,
+                                                                      @NotNull EventEmitterToken token) {
+        connectionListeners.forEach(l -> {
+            if (l.sequence > lowerSequenceLimit) {
+                try {
+                    l.connectionListener.onConnectionChange(nc, token.connected.get());
+                } catch (IllegalStateException ignore) {
+                    // this is already logged
+                }
+                token.latestSequenceExecuted = Math.max(token.latestSequenceExecuted, l.sequence);
             }
         });
-
     }
 
     @FunctionalInterface
@@ -64,4 +97,37 @@ public class ConnectionManager<T extends NetworkContext<T>> {
          */
         void onConnectionChange(T nc, boolean isConnected);
     }
+
+    /**
+     * A connection listener that knows when it was added
+     */
+    private static final class ConnectionListenerHolder<C extends NetworkContext<C>> {
+        private final int sequence;
+        private final ConnectionListener<C> connectionListener;
+
+        public ConnectionListenerHolder(int sequence, ConnectionListener<C> connectionListener) {
+            this.sequence = sequence;
+            this.connectionListener = connectionListener;
+        }
+    }
+
+    /**
+     * An <strong>opaque</strong> token that NetworkContext connection event emitters need to retain and
+     * provide when they dispatch events.
+     * <p>
+     * Keeps track of the listeners they have executed and what the connected state was
+     * on their previous call.
+     * <p>
+     * Allows this state to immediately available, and be garbage collected with the emitter.
+     */
+    public static final class EventEmitterToken {
+        private final AtomicBoolean connected = new AtomicBoolean(false);
+        private volatile int latestSequenceExecuted = Integer.MIN_VALUE;
+
+        /**
+         * These should only be created by the ConnectionManager
+         */
+        private EventEmitterToken() {
+        }
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
index 570aa3ff31..6372aa1bfb 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
@@ -44,6 +44,8 @@ public final class UberHandler<T extends ClusteredNetworkContext<T>> extends Csp
 
     private final int remoteIdentifier;
     private final int localIdentifier;
+    @Nullable
+    private ConnectionManager.EventEmitterToken eventEmitterToken;
 
     @Nullable
     private ConnectionManager<T> connectionChangedNotifier;
@@ -143,14 +145,14 @@ public final class UberHandler<T extends ClusteredNetworkContext<T>> extends Csp
     private void notifyConnectionListeners() {
         connectionChangedNotifier = nc().clusterContext().connectionManager(remoteIdentifier);
         if (connectionChangedNotifier != null)
-            connectionChangedNotifier.onConnectionChanged(true, nc());
+            eventEmitterToken = connectionChangedNotifier.onConnectionChanged(true, nc(), eventEmitterToken);
     }
 
     @Override
     protected void performClose() {
         T nc = nc();
         if (connectionChangedNotifier != null) {
-            connectionChangedNotifier.onConnectionChanged(false, nc);
+            eventEmitterToken = connectionChangedNotifier.onConnectionChanged(false, nc, eventEmitterToken);
         }
 
         try {
@@ -244,6 +246,13 @@ public final class UberHandler<T extends ClusteredNetworkContext<T>> extends Csp
         }
     }
 
+    @Override
+    public void performIdleWork() {
+        if (connectionChangedNotifier != null && eventEmitterToken != null) {
+            connectionChangedNotifier.executeNewListeners(nc(), eventEmitterToken);
+        }
+    }
+
     @Override
     protected void onBytesWritten() {
         onMessageReceivedOrWritten();
diff --git a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
index ff48cc7398..61e78742d2 100644
--- a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
+++ b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
@@ -8,7 +8,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
 
+import static junit.framework.TestCase.assertEquals;
 import static junit.framework.TestCase.fail;
 
 public class TcpEventHandlerReleaseTest extends NetworkTestCommon {
@@ -43,6 +45,34 @@ public class TcpEventHandlerReleaseTest extends NetworkTestCommon {
         }
     }
 
+    @Test
+    public void performIdleWorkIsOnlyCalledWhenHandlerIsBusyOrOneHundredIterations() throws IOException, InvalidEventHandlerException {
+        NetworkContext nc = new VanillaNetworkContext();
+        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
+        BusyTcpEventHandler tcpEventHandler = new BusyTcpEventHandler(nc);
+        final BusyTcpHandler tcpHandler = new BusyTcpHandler();
+        tcpEventHandler.tcpHandler(tcpHandler);
+
+        // not called when busy
+        tcpEventHandler.busy = true;
+        tcpEventHandler.action();
+        assertEquals(0, tcpHandler.performedIdleWorkCount.get());
+
+        // called when not busy
+        tcpEventHandler.busy = false;
+        tcpEventHandler.action();
+        assertEquals(1, tcpHandler.performedIdleWorkCount.get());
+
+        // called when not called for 101 iterations
+        tcpEventHandler.busy = true;
+        for (int i = 0; i < 101; i++) {
+            tcpEventHandler.action();
+        }
+        assertEquals(1, tcpHandler.performedIdleWorkCount.get());
+        tcpEventHandler.action();
+        assertEquals(2, tcpHandler.performedIdleWorkCount.get());
+    }
+
     public TcpEventHandler createTcpEventHandler() throws IOException {
         NetworkContext nc = new VanillaNetworkContext();
         nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
@@ -69,4 +99,44 @@ public class TcpEventHandlerReleaseTest extends NetworkTestCommon {
             return false;
         }
     }
+
+    /**
+     * This is nasty, but the TcpEventHandler is very hard to test
+     */
+    private static class BusyTcpEventHandler extends TcpEventHandler {
+
+        private boolean busy = true;
+
+        public BusyTcpEventHandler(@NotNull NetworkContext nc) {
+            super(nc, true);
+        }
+
+        @Override
+        public boolean writeAction() {
+            return busy;
+        }
+    }
+
+    private static class BusyTcpHandler implements TcpHandler {
+
+        private final AtomicInteger performedIdleWorkCount = new AtomicInteger();
+
+        @Override
+        public void process(@NotNull Bytes in, @NotNull Bytes out, NetworkContext nc) {
+        }
+
+        @Override
+        public void close() {
+        }
+
+        @Override
+        public boolean isClosed() {
+            return false;
+        }
+
+        @Override
+        public void performIdleWork() {
+            performedIdleWorkCount.incrementAndGet();
+        }
+    }
 }
diff --git a/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java b/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
index 910e22e1a2..3dadbc9576 100644
--- a/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
+++ b/src/test/java/net/openhft/chronicle/network/UberHandlerTest.java
@@ -3,6 +3,7 @@ package net.openhft.chronicle.network;
 import net.openhft.chronicle.bytes.Bytes;
 import net.openhft.chronicle.core.Jvm;
 import net.openhft.chronicle.core.io.IORuntimeException;
+import net.openhft.chronicle.core.threads.EventLoop;
 import net.openhft.chronicle.core.util.ThrowingFunction;
 import net.openhft.chronicle.network.api.TcpHandler;
 import net.openhft.chronicle.network.api.session.WritableSubHandler;
@@ -29,11 +30,11 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
 import java.util.stream.IntStream;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class UberHandlerTest extends NetworkTestCommon {
 
@@ -139,6 +140,48 @@ public class UberHandlerTest extends NetworkTestCommon {
         }
     }
 
+    @Test
+    public void newConnectionListenersAreExecutedOnEventLoopForExistingConnections() throws IOException, TimeoutException {
+        TCPRegistry.createServerSocketChannelFor("initiator", "acceptor");
+        HostDetails initiatorHost = new HostDetails().hostId(2).connectUri("initiator");
+        HostDetails acceptorHost = new HostDetails().hostId(1).connectUri("acceptor");
+
+        try (MyClusterContext acceptorCtx = clusterContext(acceptorHost, initiatorHost);
+             MyClusterContext initiatorCtx = clusterContext(initiatorHost, acceptorHost)) {
+
+            acceptorCtx.cluster().start(acceptorHost.hostId());
+            initiatorCtx.cluster().start(initiatorHost.hostId());
+
+            // Block until the connection is established
+            AtomicBoolean establishedConnection = new AtomicBoolean(false);
+            AtomicReference<NetworkContext<?>> networkContext = new AtomicReference<>();
+            initiatorCtx.connectionManager(acceptorHost.hostId()).addListener((nc, isConnected) -> {
+                if (isConnected) {
+                    establishedConnection.set(true);
+                    networkContext.set(nc);
+                }
+            });
+            TimingPauser pauser = Pauser.balanced();
+            while (!establishedConnection.get()) {
+                pauser.pause(3, TimeUnit.SECONDS);
+            }
+
+            // Add a new connection listener to the already established connection, ensure it executes on the event loop
+            AtomicBoolean executedOnEventLoop = new AtomicBoolean(false);
+            initiatorCtx.connectionManager(acceptorHost.hostId()).addListener((nc, isConnected) -> {
+                if (isConnected) {
+                    assertSame(networkContext.get(), nc);
+                    executedOnEventLoop.set(EventLoop.inEventLoop());
+                }
+            });
+
+            pauser.reset();
+            while (!executedOnEventLoop.get()) {
+                pauser.pause(3, TimeUnit.SECONDS);
+            }
+        }
+    }
+
     private void sendPingPong(WireOut wireOut, int cid) {
         wireOut.writeEventName(CoreFields.csp).text("pingpong")
                 .writeEventName(CoreFields.cid).int64(cid)
diff --git a/src/test/java/net/openhft/chronicle/network/cluster/ConnectionManagerTest.java b/src/test/java/net/openhft/chronicle/network/cluster/ConnectionManagerTest.java
new file mode 100644
index 0000000000..a021e6d8e2
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/cluster/ConnectionManagerTest.java
@@ -0,0 +1,119 @@
+package net.openhft.chronicle.network.cluster;
+
+import net.openhft.chronicle.core.io.Closeable;
+import net.openhft.chronicle.network.NetworkTestCommon;
+import net.openhft.chronicle.network.VanillaNetworkContext;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.*;
+
+@RunWith(MockitoJUnitRunner.class)
+public class ConnectionManagerTest extends NetworkTestCommon {
+
+    private ConnectionManager<TestNetworkContext> connectionManager;
+    private TestNetworkContext networkContext;
+
+    @Mock
+    private ConnectionManager.ConnectionListener<TestNetworkContext> listener1;
+    @Mock
+    private ConnectionManager.ConnectionListener<TestNetworkContext> listener2;
+
+    @Before
+    public void setUp() {
+        connectionManager = new ConnectionManager<>();
+        networkContext = new TestNetworkContext();
+    }
+
+    @After
+    public void tearDown() {
+        Closeable.closeQuietly(networkContext);
+    }
+
+    @Test
+    public void onConnectionChangedExecutesAllListeners() {
+        connectionManager.addListener(listener1);
+        connectionManager.addListener(listener2);
+        connectionManager.onConnectionChanged(true, networkContext, null);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+    }
+
+    @Test
+    public void onConnectionChangedOnlyExecutesListenersWhenConnectionStateChanges() {
+        connectionManager.addListener(listener1);
+        connectionManager.addListener(listener2);
+        ConnectionManager.EventEmitterToken token = connectionManager.onConnectionChanged(true, networkContext, null);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+        connectionManager.onConnectionChanged(true, networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+        connectionManager.onConnectionChanged(false, networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, false);
+        verify(listener2).onConnectionChange(networkContext, false);
+        verifyNoMoreInteractions(listener1, listener2);
+    }
+
+    @Test
+    public void executeNewListenersWillOnlyExecuteNonExecutedListeners() {
+        connectionManager.addListener(listener1);
+        ConnectionManager.EventEmitterToken token = connectionManager.onConnectionChanged(true, networkContext, null);
+        connectionManager.onConnectionChanged(true, networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, true);
+        connectionManager.addListener(listener2);
+        connectionManager.executeNewListeners(networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+        connectionManager.executeNewListeners(networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+        verifyNoMoreInteractions(listener1, listener2);
+    }
+
+    @Test
+    public void executeNewListenersWillExecuteAllListenersOnFirstCall() {
+        final ConnectionManager.EventEmitterToken eventEmitterToken = connectionManager.onConnectionChanged(true, networkContext, null);
+        connectionManager.addListener(listener1);
+        connectionManager.addListener(listener2);
+        connectionManager.executeNewListeners(networkContext, eventEmitterToken);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+    }
+
+    @Test
+    public void executeNewListenersWillNotExecuteListenersThatPreviouslyThrewIllegalStateException() {
+        doThrow(IllegalStateException.class).when(listener2).onConnectionChange(any(), anyBoolean());
+        final ConnectionManager.EventEmitterToken eventEmitterToken = connectionManager.onConnectionChanged(true, networkContext, null);
+        connectionManager.addListener(listener1);
+        connectionManager.addListener(listener2);
+        connectionManager.executeNewListeners(networkContext, eventEmitterToken);
+        verify(listener1).onConnectionChange(networkContext, true);
+        verify(listener2).onConnectionChange(networkContext, true);
+    }
+
+    @Test
+    public void onConnectionChangedWorksWhenThereAreNoListeners() {
+        final ConnectionManager.EventEmitterToken token = connectionManager.onConnectionChanged(true, networkContext, null);
+        connectionManager.addListener(listener1);
+        connectionManager.onConnectionChanged(false, networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, false);
+    }
+
+    @Test
+    public void executeNewListenersWorksWhenThereAreNoListeners() {
+        final ConnectionManager.EventEmitterToken token = connectionManager.onConnectionChanged(true, networkContext, null);
+        connectionManager.executeNewListeners(networkContext, token);
+        connectionManager.addListener(listener1);
+        connectionManager.executeNewListeners(networkContext, token);
+        verify(listener1).onConnectionChange(networkContext, true);
+    }
+
+    static class TestNetworkContext extends VanillaNetworkContext<TestNetworkContext> {
+    }
+}
\ No newline at end of file
