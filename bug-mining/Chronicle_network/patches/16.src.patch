diff --git a/README.md b/README.md
index 22da093214..87a0a42027 100755
--- a/README.md
+++ b/README.md
@@ -15,7 +15,8 @@ Network current support TCP only.
  
 Planned support for
 * Shared Memory
-* Unreliable UDP
+
+UDP support can be found in Chronicle Network Enterprise (commercial product - contact sales@chronicle.software)
 
 # Example
 ## TCP Client/Server : Echo Example
diff --git a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
index 9126456b4b..2c3347f3a7 100644
--- a/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/TcpEventHandler.java
@@ -108,16 +108,10 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
         } catch (IOException e) {
             Jvm.warn().on(getClass(), e);
         }
-        // allow these to be used by another thread.
-        // todo check that this can be commented out
 
         inBBB = Bytes.elasticByteBuffer(TCP_BUFFER + OS.pageSize());
         outBBB = Bytes.elasticByteBuffer(TCP_BUFFER);
 
-        // TODO FIX, these are not being released on close.
-        assert BytesUtil.unregister(inBBB);
-        assert BytesUtil.unregister(outBBB);
-
         // must be set after we take a slice();
         outBBB.underlyingObject().limit(0);
         readLog = new NetworkLog(this.sc, "read");
@@ -161,7 +155,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
         switch (sts) {
 
             case SINGLE_THREADED:
-                return HandlerPriority.MEDIUM;
+                return singleThreadedPriority();
             case CONCURRENT:
                 return HandlerPriority.CONCURRENT;
             default:
@@ -169,6 +163,11 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
         }
     }
 
+    @NotNull
+    public HandlerPriority singleThreadedPriority() {
+        return HandlerPriority.MEDIUM;
+    }
+
     @Nullable
     public TcpHandler tcpHandler() {
         return tcpHandler;
@@ -221,7 +220,7 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
             int read = inBB.remaining() > 0 ? sc.read(inBB) : Integer.MAX_VALUE;
 
             if (read == Integer.MAX_VALUE)
-                LOG.trace("inBB is full, can't read from socketChannel");
+                onInBBFul();
             if (read > 0) {
                 WanSimulator.dataRead(read);
                 tcpHandler.onReadTime(System.nanoTime(), inBB, start, inBB.position());
@@ -277,6 +276,10 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
         }
     }
 
+    public void onInBBFul() {
+        LOG.trace("inBB is full, can't read from socketChannel");
+    }
+
     private void monitorStats() {
         // TODO: consider installing this on EventLoop using Timer
         long now = System.currentTimeMillis();
@@ -398,9 +401,13 @@ public class TcpEventHandler implements EventHandler, Closeable, TcpEventHandler
 
     @Override
     public void close() {
+        if (closed)
+            return;
         closed = true;
         closeSC();
         clean();
+        inBBB.release();
+        outBBB.release();
     }
 
     @PackageLocal
diff --git a/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
new file mode 100644
index 0000000000..c3aa8bf037
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/TcpEventHandlerReleaseTest.java
@@ -0,0 +1,32 @@
+package net.openhft.chronicle.network;
+
+import net.openhft.chronicle.bytes.BytesUtil;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+
+public class TcpEventHandlerReleaseTest {
+    private static final String hostPort = "host.port";
+
+    @After
+    public void checkThreadDump() {
+        BytesUtil.checkRegisteredBytes();
+        TCPRegistry.reset();
+    }
+
+    @Before
+    public void setUp() throws IOException {
+        TCPRegistry.createServerSocketChannelFor(hostPort);
+    }
+
+    @Test
+    public void testRelease() throws IOException {
+        NetworkContext nc = new VanillaNetworkContext();
+        nc.socketChannel(TCPRegistry.createSocketChannel(hostPort));
+        TcpEventHandler t = new TcpEventHandler(nc);
+        t.close();
+        t.close();
+    }
+}
