diff --git a/pom.xml b/pom.xml
index 3b41d7018f..4655a0814f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -192,7 +192,7 @@
                         <configuration>
                             <referenceVersion>2.24ea0</referenceVersion>
                             <artifactsURI>https://teamcity.chronicle.software/repository/download</artifactsURI>
-                            <binaryCompatibilityPercentageRequired>100</binaryCompatibilityPercentageRequired>
+                            <binaryCompatibilityPercentageRequired>97.6</binaryCompatibilityPercentageRequired>
                         </configuration>
                     </execution>
                 </executions>
diff --git a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
index fdb24175dc..649055084e 100644
--- a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
@@ -18,11 +18,11 @@
 package net.openhft.chronicle.network;
 
 import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.network.connection.AbstractConnectionStrategy;
 import net.openhft.chronicle.network.connection.ClientConnectionMonitor;
 import net.openhft.chronicle.network.connection.FatalFailureMonitor;
 import net.openhft.chronicle.network.connection.SocketAddressSupplier;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.wire.AbstractMarshallableCfg;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -30,11 +30,9 @@ import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.LockSupport;
 
 import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
-import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
 
 /**
  * Loops through all the hosts:ports ( in order ) starting at the primary, till it finds a host that it can connect to.
@@ -42,24 +40,15 @@ import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
  * If all the host:ports have been attempted since the last connection was established, no successful connection can be found,
  * then null is returned, and the fatalFailureMonitor.onFatalFailure() is triggered
  */
-public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractMarshallableCfg implements ConnectionStrategy {
+public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractConnectionStrategy {
 
     private static final Logger LOG = LoggerFactory.getLogger(AlwaysStartOnPrimaryConnectionStrategy.class);
 
-    private final transient AtomicBoolean isClosed = new AtomicBoolean(false);
-    private int tcpBufferSize = Jvm.getInteger("tcp.client.buffer.size", TCP_BUFFER);
     private int pausePeriodMs = Jvm.getInteger("client.timeout", 500);
     private int socketConnectionTimeoutMs = Jvm.getInteger("connectionStrategy.socketConnectionTimeoutMs", 1);
     private long pauseMillisBeforeReconnect = Jvm.getInteger("connectionStrategy.pauseMillisBeforeReconnect", 500);
-    private ClientConnectionMonitor clientConnectionMonitor = new VanillaClientConnectionMonitor();
-    private long minPauseSec = ConnectionStrategy.super.minPauseSec();
-    private long maxPauseSec = ConnectionStrategy.super.maxPauseSec();
-
-    @Override
-    public AlwaysStartOnPrimaryConnectionStrategy open() {
-        isClosed.set(false);
-        return this;
-    }
+    private long minPauseSec = defaultMinPauseSec();
+    private long maxPauseSec = defaultMaxPauseSec();
 
     public AlwaysStartOnPrimaryConnectionStrategy clientConnectionMonitor(ClientConnectionMonitor fatalFailureMonitor) {
         this.clientConnectionMonitor = fatalFailureMonitor;
@@ -83,6 +72,9 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractMarshallable
         else
             socketAddressSupplier.failoverToNextAddress();
 
+        if (fatalFailureMonitor == null)
+            fatalFailureMonitor = FatalFailureMonitor.NO_OP;
+
         for (; ; ) {
             throwExceptionIfClosed();
             ChronicleSocketChannel socketChannel = null;
@@ -167,16 +159,6 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractMarshallable
         return this;
     }
 
-    @Override
-    public void close() {
-        isClosed.set(true);
-    }
-
-    @Override
-    public boolean isClosed() {
-        return isClosed.get();
-    }
-
     @Override
     public long minPauseSec() {
         return minPauseSec;
diff --git a/src/main/java/net/openhft/chronicle/network/ChronicleSocketChannelBuilder.java b/src/main/java/net/openhft/chronicle/network/ChronicleSocketChannelBuilder.java
new file mode 100644
index 0000000000..e2cca4752d
--- /dev/null
+++ b/src/main/java/net/openhft/chronicle/network/ChronicleSocketChannelBuilder.java
@@ -0,0 +1,131 @@
+package net.openhft.chronicle.network;
+
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.network.tcp.ChronicleSocket;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+
+import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
+
+public class ChronicleSocketChannelBuilder {
+
+    @NotNull
+    private final InetSocketAddress socketAddress;
+    private int tcpBufferSize = Jvm.getInteger("tcp.client.buffer.size", TCP_BUFFER);
+    private int socketConnectionTimeoutMs = Jvm.getInteger("client.timeout", 500);
+    @Nullable
+    private InetSocketAddress localBinding;
+    private boolean tcpNoDelay = !TcpEventHandler.DISABLE_TCP_NODELAY;
+
+    public ChronicleSocketChannelBuilder(@NotNull InetSocketAddress socketAddress) {
+        this.socketAddress = socketAddress;
+    }
+
+    /**
+     * Set the TCP buffer size
+     *
+     * @param tcpBufferSize The TCP buffer size in bytes
+     * @return this
+     */
+    public ChronicleSocketChannelBuilder tcpBufferSize(int tcpBufferSize) {
+        this.tcpBufferSize = tcpBufferSize;
+        return this;
+    }
+
+    /**
+     * Set the socket connection timeout
+     *
+     * @param socketConnectionTimeoutMs the socket connection timeout in milliseconds
+     * @return this
+     */
+    public ChronicleSocketChannelBuilder socketConnectionTimeoutMs(int socketConnectionTimeoutMs) {
+        this.socketConnectionTimeoutMs = socketConnectionTimeoutMs;
+        return this;
+    }
+
+    /**
+     * Set whether to enable/disable <a href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle's algorithm</a> for this socket
+     *
+     * @param tcpNoDelay
+     * @return
+     */
+    public ChronicleSocketChannelBuilder tcpNoDelay(boolean tcpNoDelay) {
+        this.tcpNoDelay = tcpNoDelay;
+        return this;
+    }
+
+    /**
+     * Set the local socket to bind to
+     *
+     * @param localBinding The local socket to bind to, or null to not bind to any local socket
+     * @return this
+     */
+    public ChronicleSocketChannelBuilder localBinding(InetSocketAddress localBinding) {
+        this.localBinding = localBinding;
+        return this;
+    }
+
+    /**
+     * Open a socket channel with the builder's current settings
+     *
+     * @return The opened channel, or null if no channel could be opened
+     * @throws IOException if something goes wrong opening the channel
+     */
+    @Nullable
+    public ChronicleSocketChannel open() throws IOException {
+        final ChronicleSocketChannel result = ChronicleSocketChannelFactory.wrap();
+        @Nullable Selector selector = null;
+        boolean failed = true;
+        try {
+            if (localBinding != null) {
+                result.bind(localBinding);
+            }
+            result.configureBlocking(false);
+            ChronicleSocket socket = result.socket();
+            socket.setTcpNoDelay(tcpNoDelay);
+            socket.setReceiveBufferSize(tcpBufferSize);
+            socket.setSendBufferSize(tcpBufferSize);
+            socket.setSoTimeout(0);
+            socket.setSoLinger(false, 0);
+            result.connect(socketAddress);
+
+            selector = Selector.open();
+            result.register(selector, SelectionKey.OP_CONNECT);
+
+            int select = selector.select(socketConnectionTimeoutMs);
+            if (select == 0) {
+                if (Jvm.isDebugEnabled(ConnectionStrategy.class))
+                    Jvm.debug().on(ConnectionStrategy.class, "Timed out attempting to connect to " + socketAddress);
+                return null;
+            } else {
+                try {
+                    if (!result.finishConnect())
+                        return null;
+
+                } catch (IOException e) {
+                    if (Jvm.isDebugEnabled(ConnectionStrategy.class))
+                        Jvm.debug().on(ConnectionStrategy.class, "Failed to connect to " + socketAddress + " " + e);
+                    return null;
+                }
+            }
+
+            failed = false;
+            return result;
+
+        } catch (Exception e) {
+            return null;
+        } finally {
+            closeQuietly(selector);
+            if (failed)
+                closeQuietly(result);
+        }
+    }
+}
diff --git a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
index ff81b4920c..6f3b7911e0 100644
--- a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
@@ -22,74 +22,34 @@ import net.openhft.chronicle.core.io.ClosedIllegalStateException;
 import net.openhft.chronicle.network.connection.ClientConnectionMonitor;
 import net.openhft.chronicle.network.connection.FatalFailureMonitor;
 import net.openhft.chronicle.network.connection.SocketAddressSupplier;
-import net.openhft.chronicle.network.tcp.ChronicleSocket;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.network.tcp.ChronicleSocketChannelFactory;
 import net.openhft.chronicle.wire.Marshallable;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.Selector;
+import java.net.SocketException;
+import java.net.UnknownHostException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.LockSupport;
 
-import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
-
 public interface ConnectionStrategy extends Marshallable, java.io.Closeable {
 
     default ClientConnectionMonitor clientConnectionMonitor() {
         return new VanillaClientConnectionMonitor();
     }
 
+    /**
+     * @deprecated Use {@link ChronicleSocketChannel#builder(InetSocketAddress)} instead
+     */
+    @Deprecated(/* To be removed in x.26 */)
     @Nullable
     static ChronicleSocketChannel socketChannel(@NotNull InetSocketAddress socketAddress, int tcpBufferSize, int socketConnectionTimeoutMs) throws IOException {
-
-        final ChronicleSocketChannel result = ChronicleSocketChannelFactory.wrap();
-        @Nullable Selector selector = null;
-        boolean failed = true;
-        try {
-            result.configureBlocking(false);
-            ChronicleSocket socket = result.socket();
-            if (!TcpEventHandler.DISABLE_TCP_NODELAY) socket.setTcpNoDelay(true);
-            socket.setReceiveBufferSize(tcpBufferSize);
-            socket.setSendBufferSize(tcpBufferSize);
-            socket.setSoTimeout(0);
-            socket.setSoLinger(false, 0);
-            result.connect(socketAddress);
-
-            selector = Selector.open();
-            result.register(selector, SelectionKey.OP_CONNECT);
-
-            int select = selector.select(socketConnectionTimeoutMs);
-            if (select == 0) {
-                if (Jvm.isDebugEnabled(ConnectionStrategy.class))
-                    Jvm.debug().on(ConnectionStrategy.class, "Timed out attempting to connect to " + socketAddress);
-                return null;
-            } else {
-                try {
-                    if (!result.finishConnect())
-                        return null;
-
-                } catch (IOException e) {
-                    if (Jvm.isDebugEnabled(ConnectionStrategy.class))
-                        Jvm.debug().on(ConnectionStrategy.class, "Failed to connect to " + socketAddress + " " + e);
-                    return null;
-                }
-            }
-
-            failed = false;
-            return result;
-
-        } catch (Exception e) {
-            return null;
-        } finally {
-            closeQuietly(selector);
-            if (failed)
-                closeQuietly(result);
-        }
+        return ChronicleSocketChannel.builder(socketAddress)
+                .tcpBufferSize(tcpBufferSize)
+                .socketConnectionTimeoutMs(socketConnectionTimeoutMs)
+                .open();
     }
 
     /**
@@ -128,7 +88,11 @@ public interface ConnectionStrategy extends Marshallable, java.io.Closeable {
                                                      int socketConnectionTimeoutMs) throws IOException, InterruptedException {
         assert timeoutMs > 0;
         long start = System.currentTimeMillis();
-        ChronicleSocketChannel sc = socketChannel(socketAddress, tcpBufferSize, socketConnectionTimeoutMs);
+        ChronicleSocketChannel sc = ChronicleSocketChannel.builder(socketAddress)
+                .tcpBufferSize(tcpBufferSize)
+                .socketConnectionTimeoutMs(socketConnectionTimeoutMs)
+                .localBinding(localSocketBinding())
+                .open();
         if (sc != null)
             return sc;
 
@@ -141,7 +105,11 @@ public interface ConnectionStrategy extends Marshallable, java.io.Closeable {
                 Jvm.warn().on(ConnectionStrategy.class, "Timed out attempting to connect to " + socketAddress);
                 return null;
             }
-            sc = socketChannel(socketAddress, tcpBufferSize, socketConnectionTimeoutMs);
+            sc = ChronicleSocketChannel.builder(socketAddress)
+                    .tcpBufferSize(tcpBufferSize)
+                    .socketConnectionTimeoutMs(socketConnectionTimeoutMs)
+                    .localBinding(localSocketBinding())
+                    .open();
             if (sc != null)
                 return sc;
             Thread.yield();
@@ -191,4 +159,17 @@ public interface ConnectionStrategy extends Marshallable, java.io.Closeable {
     default long maxPauseSec() {
         return Jvm.getInteger("connectionStrategy.pause.max.secs", 5);
     }
+
+    /**
+     * Get the local socket to bind the connection to
+     *
+     * @return the local socket to bind to or null to not bind to any local socket
+     * @throws SocketException If an I/O error occurs
+     * @throws UnknownHostException If an adddress cannot be resolved
+     * @throws IllegalStateException If a hostname or interface has no matching addresses
+     */
+    @Nullable
+    default InetSocketAddress localSocketBinding() throws SocketException, UnknownHostException, IllegalStateException {
+        return null;
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategy.java
new file mode 100644
index 0000000000..4695024bc5
--- /dev/null
+++ b/src/main/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategy.java
@@ -0,0 +1,180 @@
+package net.openhft.chronicle.network.connection;
+
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.network.ConnectionStrategy;
+import net.openhft.chronicle.network.VanillaClientConnectionMonitor;
+import net.openhft.chronicle.wire.AbstractMarshallableCfg;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.net.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.stream.Collectors;
+
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
+
+public abstract class AbstractConnectionStrategy extends AbstractMarshallableCfg implements ConnectionStrategy {
+    protected int tcpBufferSize = Jvm.getInteger("tcp.client.buffer.size", TCP_BUFFER);
+    private final transient AtomicBoolean isClosed = new AtomicBoolean(false);
+    protected ClientConnectionMonitor clientConnectionMonitor = new VanillaClientConnectionMonitor();
+    protected String localSocketBindingHost;
+    protected int localSocketBindingPort = 0;
+    protected String localBindingNetworkInterface;
+    protected ProtocolFamily localBindingProtocolFamily;
+
+    @Override
+    public @Nullable InetSocketAddress localSocketBinding() throws SocketException, UnknownHostException, IllegalStateException {
+        if (localSocketBindingHost != null && localBindingNetworkInterface != null) {
+            Jvm.warn().on(AbstractConnectionStrategy.class, "You have specified both localSocketBindingHost and localBindingNetworkInterface, using localSocketBindingHost");
+        }
+
+        if (localSocketBindingHost != null) {
+            return getSocketBindingForHostName();
+        }
+
+        if (localBindingNetworkInterface != null) {
+            return getSocketBindingForInterface();
+        }
+
+        return null;
+    }
+
+    @NotNull
+    private InetSocketAddress getSocketBindingForHostName() throws UnknownHostException {
+        final List<InetAddress> permittedAddresses = Arrays.stream(InetAddress.getAllByName(localSocketBindingHost))
+                .filter(this::addressPermittedByProtocolFamily)
+                .collect(Collectors.toList());
+        if (permittedAddresses.size() > 1) {
+            Jvm.warn().on(AbstractConnectionStrategy.class,
+                    "Multiple eligible addresses available for hostname/protocol "
+                            + localSocketBindingHost + "/" + protocolFamilyAsString()
+                            + " (" + permittedAddresses + "), using " + permittedAddresses.get(0));
+        } else if (permittedAddresses.isEmpty()) {
+            throw new IllegalStateException("None of addresses for hostname " + localSocketBindingHost +
+                    " available for binding for protocol " + protocolFamilyAsString());
+        }
+        return new InetSocketAddress(permittedAddresses.get(0), localSocketBindingPort);
+    }
+
+    @NotNull
+    private InetSocketAddress getSocketBindingForInterface() throws SocketException {
+        List<InetAddress> permittedAddresses = permittedAddressesForInterface();
+        if (permittedAddresses.size() > 1) {
+            Jvm.warn().on(AbstractConnectionStrategy.class,
+                    "Multiple eligible addresses available on interface/protocol "
+                            + localBindingNetworkInterface + "/" + protocolFamilyAsString()
+                            + " (" + permittedAddresses + "), using " + permittedAddresses.get(0));
+        } else if (permittedAddresses.isEmpty()) {
+            throw new IllegalStateException("None of addresses from interface " + localBindingNetworkInterface +
+                    " available for binding for protocol " + protocolFamilyAsString());
+        }
+        return new InetSocketAddress(permittedAddresses.get(0), localSocketBindingPort);
+    }
+
+    private String protocolFamilyAsString() {
+        return localBindingProtocolFamily != null ? localBindingProtocolFamily.toString() : "ANY";
+    }
+
+    private List<InetAddress> permittedAddressesForInterface() throws SocketException {
+        final NetworkInterface networkInterface = NetworkInterface.getByName(localBindingNetworkInterface);
+        if (networkInterface == null) {
+            throw new IllegalStateException("No matching interface found for name " + localBindingNetworkInterface + ", available interfaces: " + getAvailableInterfaceNames());
+        }
+        List<InetAddress> permittedAddresses = new ArrayList<>();
+        Enumeration<InetAddress> addressEnumeration = networkInterface.getInetAddresses();
+        while (addressEnumeration.hasMoreElements()) {
+            InetAddress address = addressEnumeration.nextElement();
+            if (addressPermittedByProtocolFamily(address))
+                permittedAddresses.add(address);
+        }
+        return permittedAddresses;
+    }
+
+    private String getAvailableInterfaceNames() throws SocketException {
+        StringBuilder stringBuilder = new StringBuilder();
+        final Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+        boolean first = true;
+        while (networkInterfaces.hasMoreElements()) {
+            if (!first) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(networkInterfaces.nextElement().getName());
+            first = false;
+        }
+        return stringBuilder.toString();
+    }
+
+    private boolean addressPermittedByProtocolFamily(InetAddress address) {
+        if (localBindingProtocolFamily == null)
+            return true;
+
+        if (localBindingProtocolFamily == StandardProtocolFamily.INET)
+            return address instanceof Inet4Address;
+
+        if (localBindingProtocolFamily == StandardProtocolFamily.INET6)
+            return address instanceof Inet6Address;
+
+        return false; // Unsupported family
+    }
+
+    /**
+     * Sets address for local connection sockets binding. Takes precedence over {@link #localBindingNetworkInterface(String)}
+     *
+     * @see #localBindingProtocolFamily(ProtocolFamily)
+     */
+    public void localSocketBindingHost(String localSocketBindingHost) {
+        this.localSocketBindingHost = localSocketBindingHost;
+    }
+
+    public void localSocketBindingPort(int localSocketBindingPort) {
+        this.localSocketBindingPort = localSocketBindingPort;
+    }
+
+    /**
+     * Sets network interface name whose first matching address will be used for local connection sockets binding.
+     *
+     * @param localBindingNetworkInterface Network interface to use
+     * @see #localBindingProtocolFamily(ProtocolFamily)
+     */
+    public void localBindingNetworkInterface(String localBindingNetworkInterface) {
+        this.localBindingNetworkInterface = localBindingNetworkInterface;
+    }
+
+    /**
+     * Sets protocol family to choose address from in case binding address or network interface correspond to more than
+     * one address.
+     *
+     * @param localBindingProtocolFamily Protocol family to use
+     */
+    public void localBindingProtocolFamily(ProtocolFamily localBindingProtocolFamily) {
+        this.localBindingProtocolFamily = localBindingProtocolFamily;
+    }
+
+    @Override
+    public AbstractConnectionStrategy open() {
+        isClosed.set(false);
+        return this;
+    }
+
+    @Override
+    public void close() {
+        isClosed.set(true);
+    }
+
+    @Override
+    public boolean isClosed() {
+        return isClosed.get();
+    }
+
+    protected long defaultMinPauseSec() {
+        return ConnectionStrategy.super.minPauseSec();
+    }
+
+    protected long defaultMaxPauseSec() {
+        return ConnectionStrategy.super.maxPauseSec();
+    }
+}
diff --git a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
index ac64332f49..1a4ae9b46f 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategy.java
@@ -18,22 +18,15 @@
 package net.openhft.chronicle.network.connection;
 
 import net.openhft.chronicle.core.Jvm;
-import net.openhft.chronicle.core.io.IORuntimeException;
-import net.openhft.chronicle.network.ConnectionStrategy;
-import net.openhft.chronicle.network.VanillaClientConnectionMonitor;
 import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
-import net.openhft.chronicle.wire.AbstractMarshallableCfg;
-import net.openhft.chronicle.wire.WireIn;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.net.InetSocketAddress;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.locks.LockSupport;
 
 import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
-import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
 
 /**
  * @author Rob Austin.
@@ -59,38 +52,26 @@ import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_BUFFER;
  * --h.     Connection attempt no 3 with DR1:  failed
  * --i.      Connection attempt no 3 with DR2:  failed   implies:   Attempt 3 finished. Fatal Failure is raised
  */
-public class FatalFailureConnectionStrategy extends AbstractMarshallableCfg implements ConnectionStrategy {
+public class FatalFailureConnectionStrategy extends AbstractConnectionStrategy {
     private static final long PAUSE = TimeUnit.MILLISECONDS.toNanos(300);
 
     private final int attempts;
     private final boolean blocking;
-    private int tcpBufferSize;
-    private ClientConnectionMonitor clientConnectionMonitor = new VanillaClientConnectionMonitor();
-    private transient AtomicBoolean isClosed;
     private transient boolean hasSentFatalFailure;
 
     /**
-     * @param attempts the number of attempts before a onFatalFailure() reported
+     * Needed in order for marshalling to work properly
      */
-    public FatalFailureConnectionStrategy(int attempts, boolean blocking) {
-        this.attempts = attempts;
-        this.blocking = blocking;
-
-        init();
+    FatalFailureConnectionStrategy() {
+        this(1, false);
     }
 
     /**
-     * Initializes missing optional and transient fields to default values.
+     * @param attempts the number of attempts before a onFatalFailure() reported
      */
-    private void init() {
-        if (tcpBufferSize == 0)
-            tcpBufferSize = Jvm.getInteger("tcp.client.buffer.size", TCP_BUFFER);
-
-        if (isClosed == null)
-            isClosed = new AtomicBoolean(false);
-
-        if (clientConnectionMonitor == null)
-            clientConnectionMonitor = new VanillaClientConnectionMonitor();
+    public FatalFailureConnectionStrategy(int attempts, boolean blocking) {
+        this.attempts = attempts;
+        this.blocking = blocking;
     }
 
     @Override
@@ -180,26 +161,4 @@ public class FatalFailureConnectionStrategy extends AbstractMarshallableCfg impl
             }
         }
     }
-
-    @Override
-    public void close() {
-        isClosed.set(true);
-    }
-
-    @Override
-    public boolean isClosed() {
-        return isClosed.get();
-    }
-
-    @Override
-    public FatalFailureConnectionStrategy open() {
-        isClosed.set(false);
-        return this;
-    }
-
-    @Override
-    public void readMarshallable(@NotNull WireIn wire) throws IORuntimeException {
-        super.readMarshallable(wire);
-        init();
-    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureMonitor.java b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureMonitor.java
index d3acb216ca..b3fa0eda4d 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/FatalFailureMonitor.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/FatalFailureMonitor.java
@@ -24,6 +24,16 @@ import org.slf4j.LoggerFactory;
 public interface FatalFailureMonitor {
     Logger LOG = LoggerFactory.getLogger(FatalFailureMonitor.class);
 
+    /**
+     * A no-op implementation
+     */
+    FatalFailureMonitor NO_OP = new FatalFailureMonitor() {
+        @Override
+        public void onFatalFailure(@Nullable String name, String message) {
+            // Do nothing
+        }
+    };
+
     /**
      * called if all the connection attempts/(and/or timeouts) determined by the connection strategy has been exhausted
      *
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocket.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocket.java
index 3d3ae9448c..5c568bb674 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocket.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocket.java
@@ -56,6 +56,8 @@ public interface ChronicleSocket {
 
     Object getRemoteSocketAddress();
 
+    Object getLocalSocketAddress();
+
     int getLocalPort();
 
 }
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
index b0a4cfe465..27c93cc7eb 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketChannel.java
@@ -19,6 +19,7 @@
 package net.openhft.chronicle.network.tcp;
 
 import net.openhft.chronicle.core.io.Closeable;
+import net.openhft.chronicle.network.ChronicleSocketChannelBuilder;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
@@ -30,6 +31,10 @@ import java.nio.channels.SocketChannel;
 
 public interface ChronicleSocketChannel extends Closeable {
 
+    static ChronicleSocketChannelBuilder builder(InetSocketAddress socketAddress) {
+        return new ChronicleSocketChannelBuilder(socketAddress);
+    }
+
     int read(ByteBuffer byteBuffer) throws IOException;
 
     int write(ByteBuffer byteBuffer) throws IOException;
@@ -40,6 +45,8 @@ public interface ChronicleSocketChannel extends Closeable {
 
     InetSocketAddress getLocalAddress() throws IOException;
 
+    void bind(InetSocketAddress localAddress) throws IOException;
+
     InetSocketAddress getRemoteAddress() throws IOException;
 
     boolean isOpen();
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketFactory.java b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketFactory.java
index 5038dc261c..46b8db411e 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketFactory.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/ChronicleSocketFactory.java
@@ -80,13 +80,15 @@ public enum ChronicleSocketFactory {
                 return socket.getRemoteSocketAddress();
             }
 
+            @Override
+            public Object getLocalSocketAddress() {
+                return socket.getLocalSocketAddress();
+            }
+
             @Override
             public int getLocalPort() {
                 return socket.getLocalPort();
             }
-
-        }
-
-                ;
+        };
     }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java b/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
index d819998d25..1acb843ecd 100644
--- a/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
+++ b/src/main/java/net/openhft/chronicle/network/tcp/VanillaSocketChannel.java
@@ -87,6 +87,11 @@ public class VanillaSocketChannel extends AbstractCloseable implements Chronicle
         socketChannel.setOption(soReuseaddr, b);
     }
 
+    @Override
+    public void bind(final InetSocketAddress localAddress) throws IOException {
+        socketChannel.bind(localAddress);
+    }
+
     @Override
     public InetSocketAddress getRemoteAddress() throws IORuntimeException {
         try {
diff --git a/src/test/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategyTest.java b/src/test/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategyTest.java
index d1ca268c42..ccfcac783f 100644
--- a/src/test/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategyTest.java
+++ b/src/test/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategyTest.java
@@ -18,17 +18,23 @@
 
 package net.openhft.chronicle.network;
 
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.OS;
 import net.openhft.chronicle.network.connection.FatalFailureMonitor;
 import net.openhft.chronicle.network.connection.SocketAddressSupplier;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import net.openhft.chronicle.network.util.TestServer;
 import net.openhft.chronicle.wire.JSONWire;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 
 import java.io.IOException;
+import java.net.InetSocketAddress;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.fail;
+import static net.openhft.chronicle.network.util.TestUtil.getAvailablePortNumber;
+import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assumptions.assumeFalse;
 
 class AlwaysStartOnPrimaryConnectionStrategyTest extends NetworkTestCommon {
     private static String uri;
@@ -42,12 +48,11 @@ class AlwaysStartOnPrimaryConnectionStrategyTest extends NetworkTestCommon {
 
     @Test
     @Timeout(1)
-    void connect_attempts_should_stop_when_thread_is_interrupted() throws InterruptedException {
+    void connectAttemptsShouldStopWhenThreadIsInterrupted() throws InterruptedException {
         Thread thread = new Thread(() -> {
             ConnectionStrategy strategy = new AlwaysStartOnPrimaryConnectionStrategy();
             try {
-                strategy.connect("unavailable_uri", SocketAddressSupplier.uri(uri), false, new FatalFailureMonitor() {
-                });
+                strategy.connect("unavailable_uri", SocketAddressSupplier.uri(uri), false, FatalFailureMonitor.NO_OP);
             } catch (InterruptedException e) {
                 fail("AlwaysStartOnPrimaryConnectionStrategy#connect should not have propagated the " + e.getClass());
             }
@@ -58,13 +63,33 @@ class AlwaysStartOnPrimaryConnectionStrategyTest extends NetworkTestCommon {
     }
 
     @Test
-    void test() {
+    void testIsSerializable() {
         TCPRegistry.reset();
         final AlwaysStartOnPrimaryConnectionStrategy alwaysStartOnPrimaryConnectionStrategy = new AlwaysStartOnPrimaryConnectionStrategy();
         JSONWire jsonWire = new JSONWire().useTypes(true);
         jsonWire.getValueOut().object(alwaysStartOnPrimaryConnectionStrategy);
         assertEquals("{\"@AlwaysStartOnPrimaryConnectionStrategy\":{}}", jsonWire.bytes().toString());
+    }
 
+    @Test
+    @Timeout(10)
+    void testLocalBinding() throws InterruptedException, IOException {
+        assumeFalse(OS.isMacOSX()); // doesn't work on mac?
+        final AlwaysStartOnPrimaryConnectionStrategy strategy = new AlwaysStartOnPrimaryConnectionStrategy();
+        final String localSocketBindingHost = "127.0.0.75";
+        int localPort = getAvailablePortNumber();
+        strategy.localSocketBindingHost(localSocketBindingHost);
+        strategy.localSocketBindingPort(localPort);
+        try (TestServer testServer = new TestServer("localBindingTestServer")) {
+            testServer.prepareToAcceptAConnection();
+            Jvm.pause(100);
+            try (final ChronicleSocketChannel channel = strategy.connect("local_server", SocketAddressSupplier.uri(testServer.uri()), false, null)) {
+                assertNotNull(channel);
+                final InetSocketAddress localSocketAddress = (InetSocketAddress) channel.socket().getLocalSocketAddress();
+                assertEquals(localPort, localSocketAddress.getPort());
+                assertEquals(localSocketBindingHost, localSocketAddress.getHostName());
+            }
+        }
     }
 
 }
diff --git a/src/test/java/net/openhft/chronicle/network/NetworkTestCommon.java b/src/test/java/net/openhft/chronicle/network/NetworkTestCommon.java
index f20b2367de..02f36b685a 100644
--- a/src/test/java/net/openhft/chronicle/network/NetworkTestCommon.java
+++ b/src/test/java/net/openhft/chronicle/network/NetworkTestCommon.java
@@ -56,7 +56,7 @@ public class NetworkTestCommon {
 
     @BeforeEach
     void recordExceptions() {
-        exceptionTracker = JvmExceptionTracker.create();
+        exceptionTracker = JvmExceptionTracker.create(false);
         exceptionTracker.ignoreException("unable to connect to any of the hosts");
         exceptionTracker.ignoreException("Warming up");
         exceptionTracker.ignoreException("warmed up");
diff --git a/src/test/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategyTest.java b/src/test/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategyTest.java
new file mode 100644
index 0000000000..8e19df1ad4
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/connection/AbstractConnectionStrategyTest.java
@@ -0,0 +1,166 @@
+package net.openhft.chronicle.network.connection;
+
+import net.openhft.chronicle.network.NetworkTestCommon;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.junit.jupiter.api.Test;
+
+import java.net.*;
+import java.util.Enumeration;
+import java.util.UUID;
+
+import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
+
+class AbstractConnectionStrategyTest extends NetworkTestCommon {
+
+    @Test
+    void testLocalBindingFailsWhenUnknownInterfaceSpecified() throws SocketException, UnknownHostException {
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localBindingNetworkInterface("nonExistentInterface");
+        try {
+            concreteConnectionStrategy.localSocketBinding();
+            fail("Should have thrown exception");
+        } catch (IllegalStateException e) {
+            // expected
+            assertTrue(e.getMessage().startsWith("No matching interface found for name nonExistentInterface, available interfaces:"));
+        }
+    }
+
+    @Test
+    void testLocalBindingFailsWhenUnknownHostnameSpecified() throws SocketException {
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localSocketBindingHost("nonExistentHostName-" + UUID.randomUUID());
+        try {
+            final InetSocketAddress binding = concreteConnectionStrategy.localSocketBinding();
+            fail("Didn't throw UnknownHostException, could be a DNS config issue, resolved to " + binding);
+        } catch (UnknownHostException e) {
+            // This is expected
+        }
+    }
+
+    @Test
+    void testLocalBindingWarnsWhenInterfaceAndHostnameAreSpecified() throws SocketException {
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localBindingNetworkInterface("nonExistentInterface" + UUID.randomUUID());
+        concreteConnectionStrategy.localSocketBindingHost("nonExistentHostName-" + UUID.randomUUID());
+        expectException("You have specified both localSocketBindingHost and localBindingNetworkInterface, using localSocketBindingHost");
+
+        try {
+            concreteConnectionStrategy.localSocketBinding();
+        } catch (UnknownHostException e) {
+            // ignore
+        }
+    }
+
+    @Test
+    void testWillWarnWhenInterfaceBindingIsAmbiguous() throws SocketException, UnknownHostException {
+        final NetworkInterface interfaceWithMultipleAddresses = findInterfaceWithMultipleAddresses();
+        assumeTrue(interfaceWithMultipleAddresses != null, "no interface with multiple addresses found");
+
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localBindingNetworkInterface(interfaceWithMultipleAddresses.getName());
+
+        assertNotNull(concreteConnectionStrategy.localSocketBinding());
+        expectException("Multiple eligible addresses available on interface/protocol");
+    }
+
+    @Test
+    void testWillWarnWhenHostnameBindingIsAmbiguous() throws SocketException, UnknownHostException {
+        assumeTrue(InetAddress.getAllByName("localhost").length > 1, "localhost only maps to a single address");
+
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localSocketBindingHost("localhost");
+
+        assertNotNull(concreteConnectionStrategy.localSocketBinding());
+        expectException("Multiple eligible addresses available for hostname/protocol localhost/ANY");
+    }
+
+    @Test
+    void testWillHonourLocalBindingProtocol() throws SocketException, UnknownHostException {
+        final NetworkInterface interfaceWithInet4AndInet6Addresses = findInterfaceWithInet4AndInet6Addresses();
+        assumeTrue(interfaceWithInet4AndInet6Addresses != null, "no interface with inet4 and inet6 addresses");
+        ignoreException("Multiple eligible addresses available on interface/protocol");
+
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localBindingNetworkInterface(interfaceWithInet4AndInet6Addresses.getName());
+
+        concreteConnectionStrategy.localBindingProtocolFamily(StandardProtocolFamily.INET);
+        final InetSocketAddress inet4Binding = concreteConnectionStrategy.localSocketBinding();
+        assertTrue(inet4Binding.getAddress() instanceof Inet4Address);
+
+        concreteConnectionStrategy.localBindingProtocolFamily(StandardProtocolFamily.INET6);
+        final InetSocketAddress inet6Binding = concreteConnectionStrategy.localSocketBinding();
+        assertTrue(inet6Binding.getAddress() instanceof Inet6Address);
+    }
+
+    @Test
+    void testWillReturnNullWhenNoHostnameOrInterfaceSpecified() throws SocketException, UnknownHostException {
+        assertNull(new ConcreteConnectionStrategy().localSocketBinding());
+    }
+
+    @Test
+    void testWillHonourConfiguredPort() throws SocketException, UnknownHostException {
+        assumeTrue(InetAddress.getAllByName("localhost").length > 0, "localhost not bound to any address?");
+        ignoreException("Multiple eligible addresses available for hostname/protocol");
+
+        final ConcreteConnectionStrategy concreteConnectionStrategy = new ConcreteConnectionStrategy();
+        concreteConnectionStrategy.localSocketBindingHost("localhost");
+        concreteConnectionStrategy.localSocketBindingPort(9876);
+
+        final InetSocketAddress binding = concreteConnectionStrategy.localSocketBinding();
+        assertNotNull(binding);
+        assertEquals(9876, binding.getPort());
+    }
+
+    @Nullable
+    private NetworkInterface findInterfaceWithInet4AndInet6Addresses() throws SocketException, UnknownHostException {
+        final Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+        while (networkInterfaces.hasMoreElements()) {
+            final NetworkInterface networkInterface = networkInterfaces.nextElement();
+            if (hasInet4AndInet6Bindings(networkInterface)) {
+                return networkInterface;
+            }
+        }
+        return null;
+    }
+
+    private boolean hasInet4AndInet6Bindings(NetworkInterface networkInterface) throws UnknownHostException {
+        boolean seenInet4 = false;
+        boolean seenInet6 = false;
+        final Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
+        while (inetAddresses.hasMoreElements()) {
+            final InetAddress inetAddress = inetAddresses.nextElement();
+            seenInet4 = seenInet4 || inetAddress instanceof Inet4Address;
+            seenInet6 = seenInet6 || inetAddress instanceof Inet6Address;
+        }
+        return seenInet4 && seenInet6;
+    }
+
+    private static class ConcreteConnectionStrategy extends AbstractConnectionStrategy {
+        @Override
+        public ChronicleSocketChannel connect(@NotNull String name, @NotNull SocketAddressSupplier socketAddressSupplier, boolean didLogIn, @NotNull FatalFailureMonitor fatalFailureMonitor) throws InterruptedException {
+            // Do nothing
+            return null;
+        }
+    }
+
+    @Nullable
+    private NetworkInterface findInterfaceWithMultipleAddresses() throws SocketException {
+        final Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
+        while (networkInterfaces.hasMoreElements()) {
+            final NetworkInterface networkInterface = networkInterfaces.nextElement();
+            final Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
+            int count = 0;
+            while (inetAddresses.hasMoreElements()) {
+                inetAddresses.nextElement();
+                count++;
+            }
+            if (count > 1) {
+                return networkInterface;
+            }
+        }
+        return null;
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategyTest.java b/src/test/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategyTest.java
index 022ed075f9..b4b6634382 100644
--- a/src/test/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategyTest.java
+++ b/src/test/java/net/openhft/chronicle/network/connection/FatalFailureConnectionStrategyTest.java
@@ -17,16 +17,27 @@
  */
 package net.openhft.chronicle.network.connection;
 
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.OS;
 import net.openhft.chronicle.network.TCPRegistry;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+import net.openhft.chronicle.network.util.TestServer;
 import net.openhft.chronicle.wire.Marshallable;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
 
+import java.io.IOException;
+import java.net.InetSocketAddress;
+
+import static net.openhft.chronicle.network.util.TestUtil.getAvailablePortNumber;
 import static org.junit.jupiter.api.Assertions.*;
+import static org.junit.jupiter.api.Assumptions.assumeFalse;
 
-/**
- * Checks that {@link FatalFailureConnectionStrategy} can be used in YAML config.
- */
 class FatalFailureConnectionStrategyTest {
+
+    /**
+     * Checks that {@link FatalFailureConnectionStrategy} can be used in YAML config.
+     */
     @Test
     void testFromYaml() {
         TCPRegistry.reset();
@@ -41,15 +52,17 @@ class FatalFailureConnectionStrategyTest {
         assertNotNull(strategyFromYaml);
 
         final String expectedToString = "!FatalFailureConnectionStrategy {\n" +
-                "  attempts: 3,\n" +
-                "  tcpBufferSize: " + TcpChannelHub.TCP_BUFFER + ",\n" +
-                "  clientConnectionMonitor: !VanillaClientConnectionMonitor {\n" +
-                "  }\n" +
+                "  attempts: 3\n" +
                 "}\n";
 
         assertEquals(expectedToString, strategy.toString());
         assertEquals(strategy.toString(), strategyFromYaml.toString());
 
+        assertEquals(TcpChannelHub.TCP_BUFFER, strategy.tcpBufferSize);
+        assertEquals(TcpChannelHub.TCP_BUFFER, strategyFromYaml.tcpBufferSize);
+        assertNotNull(strategy.clientConnectionMonitor);
+        assertNotNull(strategyFromYaml.clientConnectionMonitor);
+
         assertFalse(strategy.isClosed());
         assertFalse(strategyFromYaml.isClosed());
 
@@ -59,4 +72,25 @@ class FatalFailureConnectionStrategyTest {
         assertTrue(strategy.isClosed());
         assertTrue(strategyFromYaml.isClosed());
     }
+
+    @Test
+    @Timeout(10)
+    void testLocalBinding() throws InterruptedException, IOException {
+        assumeFalse(OS.isMacOSX()); // doesn't work on mac?
+        final FatalFailureConnectionStrategy strategy = new FatalFailureConnectionStrategy(1, true);
+        final String localSocketBindingHost = "127.0.0.75";
+        int localPort = getAvailablePortNumber();
+        strategy.localSocketBindingHost(localSocketBindingHost);
+        strategy.localSocketBindingPort(localPort);
+        try (TestServer testServer = new TestServer("localBindingTestServer")) {
+            testServer.prepareToAcceptAConnection();
+            Jvm.pause(100);
+            try (final ChronicleSocketChannel channel = strategy.connect("local_server", SocketAddressSupplier.uri(testServer.uri()), false, null)) {
+                assertNotNull(channel);
+                final InetSocketAddress localSocketAddress = (InetSocketAddress) channel.socket().getLocalSocketAddress();
+                assertEquals(localPort, localSocketAddress.getPort());
+                assertEquals(localSocketBindingHost, localSocketAddress.getHostName());
+            }
+        }
+    }
 }
diff --git a/src/test/java/net/openhft/chronicle/network/util/TestServer.java b/src/test/java/net/openhft/chronicle/network/util/TestServer.java
new file mode 100644
index 0000000000..10099bbec0
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/util/TestServer.java
@@ -0,0 +1,66 @@
+package net.openhft.chronicle.network.util;
+
+import net.openhft.chronicle.core.Jvm;
+import net.openhft.chronicle.core.io.AbstractCloseable;
+import net.openhft.chronicle.core.io.Closeable;
+import net.openhft.chronicle.network.TCPRegistry;
+import net.openhft.chronicle.network.tcp.ChronicleServerSocketChannel;
+import net.openhft.chronicle.network.tcp.ChronicleSocketChannel;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.concurrent.CountDownLatch;
+
+public class TestServer extends AbstractCloseable {
+
+    private final ChronicleServerSocketChannel serverSocketChannel;
+    private final String uri;
+    private Thread serverThread;
+
+    public TestServer(String registryHostName) throws IOException {
+        serverSocketChannel = TCPRegistry.createServerSocketChannelFor(registryHostName);
+        final InetSocketAddress localSocketAddress = (InetSocketAddress) serverSocketChannel.socket().getLocalSocketAddress();
+        uri = localSocketAddress.getHostName() + ":" + localSocketAddress.getPort();
+        Jvm.startup().on(TestServer.class, "Test server URI is " + uri);
+    }
+
+    public void prepareToAcceptAConnection() {
+        CountDownLatch latch = new CountDownLatch(2);
+        serverThread = new Thread(() -> {
+            waitAtLatch(latch);
+            try (final ChronicleSocketChannel accept = serverSocketChannel.accept()) {
+                Jvm.startup().on(TestServer.class, "Connected to " + accept.getRemoteAddress());
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        });
+        serverThread.start();
+        waitAtLatch(latch);
+    }
+
+    private void waitAtLatch(CountDownLatch latch) {
+        try {
+            latch.countDown();
+            latch.await();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    protected void performClose() {
+        Closeable.closeQuietly(serverSocketChannel);
+        try {
+            if (serverThread != null)
+                serverThread.join();
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String uri() {
+        return uri;
+    }
+}
diff --git a/src/test/java/net/openhft/chronicle/network/util/TestUtil.java b/src/test/java/net/openhft/chronicle/network/util/TestUtil.java
new file mode 100644
index 0000000000..95f727e7f0
--- /dev/null
+++ b/src/test/java/net/openhft/chronicle/network/util/TestUtil.java
@@ -0,0 +1,21 @@
+package net.openhft.chronicle.network.util;
+
+import java.io.IOException;
+import java.net.ServerSocket;
+
+public enum TestUtil {
+    ;
+
+    /**
+     * Get a port number that's most likely available
+     *
+     * @return a port number that's available
+     */
+    public static int getAvailablePortNumber() {
+        try (final ServerSocket serverSocket = new ServerSocket(0)) {
+            return serverSocket.getLocalPort();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
