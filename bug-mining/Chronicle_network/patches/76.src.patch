diff --git a/pom.xml b/pom.xml
index 93c087d7d3..ce50ea06b9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
     </parent>
 
     <artifactId>chronicle-network</artifactId>
-    <version>2.21ea83-SNAPSHOT</version>
+    <version>2.21ea84-SNAPSHOT</version>
     <name>OpenHFT/Chronicle-Network</name>
     <description>Chronicle-Network</description>
     <packaging>bundle</packaging>
diff --git a/src/main/java/net/openhft/chronicle/network/HeaderTcpHandler.java b/src/main/java/net/openhft/chronicle/network/HeaderTcpHandler.java
index d4da84265c..d84133b6bd 100644
--- a/src/main/java/net/openhft/chronicle/network/HeaderTcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/HeaderTcpHandler.java
@@ -30,6 +30,8 @@ import org.slf4j.LoggerFactory;
 
 import java.util.function.Function;
 
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
+
 public class HeaderTcpHandler<T extends NetworkContext<T>> extends SimpleCloseable implements TcpHandler<T> {
 
     public static final String HANDLER = "handler";
@@ -56,7 +58,7 @@ public class HeaderTcpHandler<T extends NetworkContext<T>> extends SimpleCloseab
 
         // the type of the header
         final Wire inWire = wireType.apply(in);
-        inWire.usePadding(false);
+        inWire.usePadding(TCP_USE_PADDING);
         final long start = in.readPosition();
 
         Object o = null;
diff --git a/src/main/java/net/openhft/chronicle/network/WireTcpHandler.java b/src/main/java/net/openhft/chronicle/network/WireTcpHandler.java
index 0f086eaa83..6f1955c180 100644
--- a/src/main/java/net/openhft/chronicle/network/WireTcpHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/WireTcpHandler.java
@@ -25,10 +25,9 @@ import net.openhft.chronicle.network.connection.WireOutPublisher;
 import net.openhft.chronicle.wire.*;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import static net.openhft.chronicle.network.connection.CoreFields.reply;
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
 import static net.openhft.chronicle.wire.WireType.BINARY;
 import static net.openhft.chronicle.wire.WireType.DELTA_BINARY;
 import static net.openhft.chronicle.wire.WriteMarshallable.EMPTY;
@@ -38,36 +37,35 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
         implements TcpHandler<T>, NetworkContextManager<T> {
 
     private static final int SIZE_OF_SIZE = 4;
-    private static final Logger LOG = LoggerFactory.getLogger(WireTcpHandler.class);
     // this is the point at which it is worth doing more work to get more data.
-
     protected Wire outWire;
+    @Nullable
+    protected WireType wireType;
     long lastWritePosition = 0;
     private Wire inWire;
     private boolean recreateWire;
-    @Nullable
-    protected WireType wireType;
     private WireOutPublisher publisher;
     private T nc;
     private boolean isAcceptor;
 
     private static void logYaml(@NotNull final DocumentContext dc) {
-        if (YamlLogging.showServerWrites() || YamlLogging.showServerReads())
-            try {
-                LOG.info("\nDocumentContext:\n" +
-                        Wires.fromSizePrefixedBlobs(dc));
+        try {
+            System.out.println(
+                    "Server Reads:\n" +
+                            Wires.fromSizePrefixedBlobs(dc));
 
-            } catch (Exception e) {
-                Jvm.warn().on(WireOutPublisher.class, "\nServer Sends ( corrupted ) :\n" +
-                        dc.wire().bytes().toDebugString());
-            }
+        } catch (Exception e) {
+            Jvm.warn().on(WireOutPublisher.class, "\nServer Reads ( corrupted ) :\n" +
+                    dc.wire().bytes().toDebugString());
+        }
     }
 
     private static void logYaml(@NotNull final WireOut outWire) {
         if (YamlLogging.showServerWrites())
             try {
-                LOG.info("\nServer Sends:\n" +
-                        Wires.fromSizePrefixedBlobs((Wire) outWire));
+                System.out.println(
+                        "Server Sends:\n" +
+                                Wires.fromSizePrefixedBlobs((Wire) outWire));
 
             } catch (Exception e) {
                 Jvm.warn().on(WireOutPublisher.class, "\nServer Sends ( corrupted ) :\n" +
@@ -116,7 +114,8 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
 
         // we assume that if any bytes were in lastOutBytesRemaining the sc.write() would have been
         // called and this will fail, if the other end has lost its connection
-        if (outWire.bytes().writePosition() != lastWritePosition)
+        Bytes<?> bytes = outWire.bytes();
+        if (bytes.writePosition() != lastWritePosition)
             onBytesWritten();
 
         if (publisher != null)
@@ -124,10 +123,19 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
 
         if (in.readRemaining() >= SIZE_OF_SIZE)
             onRead0();
-        else
+        else {
+            long remaining = bytes.readRemaining();
+            if (YamlLogging.showServerWrites() && remaining >= 4) {
+                int length = Wires.lengthOf(bytes.peekVolatileInt());
+                if (length <= remaining)
+                    System.out.println("sending from WTH: " + Wires.fromSizePrefixedBlobs(outWire));
+                else
+                    System.out.println("send remaining from WTH: " + remaining);
+            }
             onWrite(outWire);
+        }
 
-        lastWritePosition = outWire.bytes().writePosition();
+        lastWritePosition = bytes.writePosition();
     }
 
     protected void onBytesWritten() {
@@ -243,13 +251,13 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
 
     protected Wire initialiseOutWire(final Bytes<?> out, @NotNull final WireType wireType) {
         final Wire wire = wireType.apply(out);
-        wire.usePadding(false);
+        wire.usePadding(TCP_USE_PADDING);
         return outWire = wire;
     }
 
     protected Wire initialiseInWire(@NotNull final WireType wireType, final Bytes<?> in) {
         final Wire wire = wireType.apply(in);
-        wire.usePadding(false);
+        wire.usePadding(TCP_USE_PADDING);
         return inWire = wire;
     }
 
@@ -278,9 +286,8 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
                 c.writeMarshallable(outWire);
             } catch (Throwable t) {
                 inBytes.readPosition(readPosition);
-                if (LOG.isInfoEnabled())
-                    LOG.info("While reading " + inBytes.toDebugString(),
-                            " processing wire " + c, t);
+                Jvm.warn().on(WireTcpHandler.class,
+                        "While reading " + inBytes.toDebugString() + " processing wire " + c, t);
                 outWire.bytes().writePosition(position);
                 outWire.writeEventName("exception").throwable(t);
             }
@@ -308,9 +315,8 @@ public abstract class WireTcpHandler<T extends NetworkContext<T>>
                 c.writeMarshallable(outWire);
             } catch (Throwable t) {
                 inBytes.readPosition(readPosition);
-                if (LOG.isInfoEnabled())
-                    LOG.info("While reading " + inBytes.toDebugString(),
-                            " processing wire " + c, t);
+                Jvm.warn().on(WireTcpHandler.class,
+                        "While reading " + inBytes.toDebugString() + " processing wire " + c, t);
                 outWire.bytes().writePosition(position);
                 outWire.writeEventName("exception").throwable(t);
             }
diff --git a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
index d291e84d01..957b20519e 100644
--- a/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
+++ b/src/main/java/net/openhft/chronicle/network/cluster/handlers/UberHandler.java
@@ -254,6 +254,7 @@ public final class UberHandler<T extends ClusteredNetworkContext<T>> extends Csp
      */
     @Override
     protected void onWrite(@NotNull final WireOut outWire) {
+        super.onWrite(outWire);
         for (int i = 0; i < writers.size(); i++)
             try {
                 if (isClosing.get())
diff --git a/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java b/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
index c759a5a24d..3a38f26b09 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/TcpChannelHub.java
@@ -34,8 +34,6 @@ import net.openhft.chronicle.threads.*;
 import net.openhft.chronicle.wire.*;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.net.*;
@@ -68,9 +66,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
     public static final int TCP_BUFFER = getTcpBufferSize();
     public static final int TCP_SAFE_SIZE = Integer.getInteger("tcp.safe.size", 128 << 10);
-    private static final boolean LOG_TCP_MESSAGES = Jvm.getBoolean("log.tcp.messages");
-    private static final Logger LOG = LoggerFactory.getLogger(TcpChannelHub.class);
-    private static final boolean DEBUG_ENABLED = LOG.isDebugEnabled();
+    public static final boolean TCP_USE_PADDING = Jvm.getBoolean("tcp.use.padding", false);
     private static final boolean hasAssert = Jvm.isAssertEnabled();
     private static final int HEATBEAT_PING_PERIOD =
             getInteger("heartbeat.ping.period",
@@ -80,7 +76,6 @@ public final class TcpChannelHub extends AbstractCloseable {
                     Jvm.isDebug() ? 120_000 : 15_000);
     private static final int SIZE_OF_SIZE = 4;
     private static final Set<TcpChannelHub> hubs = new CopyOnWriteArraySet<>();
-
     final long timeoutMs;
     @NotNull
     private final String name;
@@ -106,16 +101,17 @@ public final class TcpChannelHub extends AbstractCloseable {
     private final ConnectionStrategy connectionStrategy;
     @NotNull
     private final Pauser pauser;
+    @NotNull
+    private final CountDownLatch receivedClosedAcknowledgement = new CountDownLatch(1);
+    private final boolean shouldSendCloseMessage;
+    private final HandlerPriority priority;
+    private final boolean debugEnabled = Jvm.isDebugEnabled(TcpChannelHub.class);
     // private final String description;
     private long largestChunkSoFar = 0;
     @Nullable
     private volatile ChronicleSocketChannel clientChannel;
-    @NotNull
-    private final CountDownLatch receivedClosedAcknowledgement = new CountDownLatch(1);
     // set up in the header
     private long limitOfLast = 0;
-    private final boolean shouldSendCloseMessage;
-    private final HandlerPriority priority;
 
     public TcpChannelHub(@Nullable final SessionProvider sessionProvider,
                          @NotNull final EventLoop eventLoop,
@@ -155,7 +151,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         this.eventLoop = eventLoop;
         this.tcpBufferSize = Integer.getInteger("tcp.client.buffer.size", TCP_BUFFER);
         this.outWire = wireType.apply(elasticByteBuffer());
-        outWire.usePadding(false);
+        outWire.usePadding(TCP_USE_PADDING);
         // this.inWire = wireType.apply(elasticByteBuffer());
         this.name = name.trim();
         this.timeoutMs = Integer.getInteger("tcp.client.timeout", 10_000);
@@ -164,7 +160,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         // we are always going to send the header as text wire, the server will
         // respond in the wire define by the wireType field, all subsequent types must be in wireType
         this.handShakingWire = WireType.TEXT.apply(Bytes.elasticByteBuffer());
-        this.handShakingWire.usePadding(false);
+        this.handShakingWire.usePadding(TCP_USE_PADDING);
 
         this.sessionProvider = sessionProvider;
         this.shouldSendCloseMessage = shouldSendCloseMessage;
@@ -221,7 +217,7 @@ public final class TcpChannelHub extends AbstractCloseable {
             if (hub.isClosed())
                 continue;
 
-            if (DEBUG_ENABLED)
+            if (hub.debugEnabled)
                 Jvm.debug().on(TcpChannelHub.class, "Closing " + hub);
             hub.close();
         }
@@ -239,11 +235,9 @@ public final class TcpChannelHub extends AbstractCloseable {
         try {
             try {
 
-                //         LOG.info("Bytes.toString(bytes)=" + Bytes.toString(bytes));
-                LOG.info("\nreceives:\n" +
-                        "```yaml\n" +
-                        Wires.fromSizePrefixedBlobs(wire) +
-                        "```\n");
+                System.out.println(
+                        "receives:\n" +
+                                Wires.fromSizePrefixedBlobs(wire));
                 YamlLogging.title = "";
                 YamlLogging.writeMessage("");
 
@@ -264,10 +258,9 @@ public final class TcpChannelHub extends AbstractCloseable {
         try {
             try {
 
-                LOG.info("\nreceives IN ERROR:\n" +
-                        "```yaml\n" +
-                        Wires.fromSizePrefixedBlobs(wire) +
-                        "```\n");
+                System.out.println(
+                        "\nreceives IN ERROR:\n" +
+                                Wires.fromSizePrefixedBlobs(wire));
                 YamlLogging.title = "";
                 YamlLogging.writeMessage("");
 
@@ -298,15 +291,6 @@ public final class TcpChannelHub extends AbstractCloseable {
         }
     }
 
-    void clear(@NotNull final Wire wire) {
-        assert wire.startUse();
-        try {
-            wire.clear();
-        } finally {
-            assert wire.endUse();
-        }
-    }
-
     public static void setTcpNoDelay(Socket socket, boolean tcpNoDelay) throws SocketException {
         for (int i = 10; i >= 0; i--) {
             try {
@@ -320,6 +304,16 @@ public final class TcpChannelHub extends AbstractCloseable {
         }
     }
 
+    void clear(@NotNull final Wire wire) {
+        assert wire.startUse();
+        try {
+            wire.clear();
+        } finally {
+            assert wire.endUse();
+        }
+    }
+
+    @Deprecated(/* remove in x.22 */)
     @Nullable
     SocketChannel openSocketChannel(final InetSocketAddress socketAddress) throws IOException {
         final SocketChannel result = SocketChannel.open();
@@ -348,7 +342,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                         return null;
 
                 } catch (IOException e) {
-                    if (DEBUG_ENABLED)
+                    if (debugEnabled)
                         Jvm.debug().on(TcpChannelHub.class, "Failed to connect to " + socketAddress + " " + e);
                     return null;
                 }
@@ -385,7 +379,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
     private void onDisconnected() {
 
-        if (DEBUG_ENABLED)
+        if (debugEnabled)
             Jvm.debug().on(TcpChannelHub.class, "disconnected to remoteAddress=" + socketAddressSupplier);
         tcpSocketConsumer.onConnectionClosed();
 
@@ -398,7 +392,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
     private void onConnected() {
 
-        if (DEBUG_ENABLED)
+        if (debugEnabled)
             Jvm.debug().on(TcpChannelHub.class, "connected to remoteAddress=" + socketAddressSupplier);
 
         if (clientConnectionMonitor != null) {
@@ -502,7 +496,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
             this.clientChannel = null;
 
-            if (DEBUG_ENABLED)
+            if (debugEnabled)
                 Jvm.debug().on(TcpChannelHub.class, "closing",
                         new StackTrace("only added for logging - please ignore !"));
 
@@ -549,12 +543,12 @@ public final class TcpChannelHub extends AbstractCloseable {
             awaitAckOfClosedMessage();
         }
 
-        if (DEBUG_ENABLED)
+        if (debugEnabled)
             Jvm.debug().on(TcpChannelHub.class, "closing connection to " + socketAddressSupplier);
         tcpSocketConsumer.stop();
 
         for (int i = 1; clientChannel != null; i++) {
-            if (DEBUG_ENABLED) {
+            if (debugEnabled) {
                 Jvm.debug().on(TcpChannelHub.class, "waiting for disconnect to " + socketAddressSupplier);
             }
             Jvm.pause(Math.min(100, i));
@@ -585,7 +579,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         try {
             final boolean await = receivedClosedAcknowledgement.await(25, MILLISECONDS);
             if (!await)
-                if (DEBUG_ENABLED)
+                if (debugEnabled)
                     Jvm.debug().on(TcpChannelHub.class, "SERVER IGNORED CLOSE REQUEST: shutting down the client anyway as the " +
                             "server did not respond to the close() request.");
         } catch (InterruptedException ignore) {
@@ -707,11 +701,12 @@ public final class TcpChannelHub extends AbstractCloseable {
      */
     private void writeSocket1(@NotNull final WireOut outWire, @Nullable final ChronicleSocketChannel clientChannel) throws IOException {
 
-        if (LOG_TCP_MESSAGES && DEBUG_ENABLED)
-            Jvm.debug().on(TcpChannelHub.class, "sending :" + Wires.fromSizePrefixedBlobs((Wire) outWire));
+        if (YamlLogging.showClientWrites())
+            System.out.println("sending from TCH: " + Wires.fromSizePrefixedBlobs((Wire) outWire));
 
         if (clientChannel == null) {
-            LOG.info("Connection Dropped");
+            Jvm.debug().on(TcpChannelHub.class,
+                    "Connection Dropped");
             throw new ConnectionDroppedException("Connection Dropped");
         }
 
@@ -766,7 +761,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                             tcpSocketConsumer.lastTimeMessageReceivedOrSent = start;
 
                     } else {
-                        if (!isOutBufferFull && Jvm.isDebug() && DEBUG_ENABLED)
+                        if (!isOutBufferFull && Jvm.isDebug() && debugEnabled)
                             Jvm.debug().on(TcpChannelHub.class, "----> TCP write buffer is FULL! " + outBuffer.remaining() + " bytes" +
                                     " remaining.");
                         isOutBufferFull = true;
@@ -827,14 +822,13 @@ public final class TcpChannelHub extends AbstractCloseable {
         try {
 
             if (bytes.readRemaining() > 0)
-                LOG.info(((!YamlLogging.title.isEmpty()) ? "### " + YamlLogging
-                        .title + "\n" : "") + "" +
-                        YamlLogging.writeMessage() + (YamlLogging.writeMessage().isEmpty() ?
-                        "" : "\n\n") +
-                        "sends:\n\n" +
-                        "```yaml\n" +
-                        Wires.fromSizePrefixedBlobs(bytes, false, false) +
-                        "```");
+                Jvm.debug().on(TcpChannelHub.class,
+                        ((!YamlLogging.title.isEmpty()) ? "### " + YamlLogging
+                                .title + "\n" : "") + "" +
+                                YamlLogging.writeMessage() + (YamlLogging.writeMessage().isEmpty() ?
+                                "" : "\n\n") +
+                                "sends:\n\n" +
+                                Wires.fromSizePrefixedBlobs(bytes, false, false));
             YamlLogging.title = "";
             YamlLogging.writeMessage("");
 
@@ -871,7 +865,7 @@ public final class TcpChannelHub extends AbstractCloseable {
     private void reflectServerHeartbeatMessage(@NotNull final ValueIn valueIn) {
 
         if (!outBytesLock().tryLock()) {
-            if (Jvm.isDebug() && DEBUG_ENABLED)
+            if (Jvm.isDebug() && debugEnabled)
                 Jvm.debug().on(TcpChannelHub.class, "skipped sending back heartbeat, because lock is held !" +
                         outBytesLock);
             return;
@@ -993,7 +987,7 @@ public final class TcpChannelHub extends AbstractCloseable {
             } else {
                 if (!lock.tryLock()) {
                     if (tryLock.equals(TryLock.TRY_LOCK_WARN))
-                        if (DEBUG_ENABLED)
+                        if (debugEnabled)
                             Jvm.debug().on(TcpChannelHub.class, "FAILED TO OBTAIN LOCK thread=" + Thread.currentThread() + " on " +
                                     lock, new IllegalStateException());
                     return false;
@@ -1008,7 +1002,8 @@ public final class TcpChannelHub extends AbstractCloseable {
 
                 assert checkWritesOnReadThread(tcpSocketConsumer);
 
-                writeSocket(outWire(), reconnectOnFailure, sessionMessage);
+                if (outWire.bytes().readRemaining() > 0)
+                    writeSocket(outWire(), reconnectOnFailure, sessionMessage);
 
             } catch (ConnectionDroppedException e) {
                 if (Jvm.isDebug())
@@ -1090,13 +1085,11 @@ public final class TcpChannelHub extends AbstractCloseable {
         private final ExecutorService service;
         @NotNull
         private final ThreadLocal<Wire> syncInWireThreadLocal = CleaningThreadLocal.withCleanup(this::createWire, w -> releaseWire(w));
-
+        private final Bytes serverHeartBeatHandler = Bytes.elasticByteBuffer();
+        private final TidReader tidReader = new TidReader();
         long lastheartbeatSentTime = 0;
         volatile long start = Long.MAX_VALUE;
         private long tid;
-        private final Bytes serverHeartBeatHandler = Bytes.elasticByteBuffer();
-        private final TidReader tidReader = new TidReader();
-
         private volatile long lastTimeMessageReceivedOrSent = System.currentTimeMillis();
         private volatile boolean isShutdown;
         @Nullable
@@ -1105,7 +1098,7 @@ public final class TcpChannelHub extends AbstractCloseable {
         private volatile Thread readThread;
 
         TcpSocketConsumer() {
-            if (DEBUG_ENABLED)
+            if (debugEnabled)
                 Jvm.debug().on(TcpChannelHub.class, "constructor remoteAddress=" + socketAddressSupplier);
 
             service = newCachedThreadPool(
@@ -1179,7 +1172,7 @@ public final class TcpChannelHub extends AbstractCloseable {
             //noinspection SynchronizationOnLocalVariableOrMethodParameter
             synchronized (bytes) {
 
-                if (DEBUG_ENABLED)
+                if (debugEnabled)
                     Jvm.debug().on(TcpChannelHub.class, "tid=" + tid + " of client request");
 
                 bytes.clear();
@@ -1238,7 +1231,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                     outBytesLock().isHeldByCurrentThread();
 
                     registerSubscribe(asyncSubscription.tid(), asyncSubscription);
-                    if (DEBUG_ENABLED)
+                    if (debugEnabled)
                         Jvm.debug().on(TcpChannelHub.class, "deferred subscription tid=" + asyncSubscription.tid() + "," +
                                 "asyncSubscription=" + asyncSubscription);
 
@@ -1259,7 +1252,8 @@ public final class TcpChannelHub extends AbstractCloseable {
                         while (!lock.tryLock(1, SECONDS)) {
                             if (isShuttingdown())
                                 throw new IllegalStateException("Shutting down");
-                            LOG.info("Waiting for lock " + Jvm.lockWithStack(lock));
+                            Jvm.warn().on(TcpChannelHub.class,
+                                    "Waiting for lock " + Jvm.lockWithStack(lock));
                         }
                     }
                 } catch (InterruptedException e) {
@@ -1331,8 +1325,8 @@ public final class TcpChannelHub extends AbstractCloseable {
                                 lastMsg = msg;
                             } else {
                                 if (lastMsg != null)
-                                    LOG.info(lastMsg);
-                                LOG.info(msg);
+                                    Jvm.debug().on(TcpChannelHub.class, lastMsg);
+                                Jvm.debug().on(TcpChannelHub.class, msg);
                                 lastMsg = null;
                             }
                         }
@@ -1353,7 +1347,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
         private void running() {
             final Wire inWire = wireType.apply(elasticByteBuffer());
-            inWire.usePadding(false);
+            inWire.usePadding(TCP_USE_PADDING);
 
             try {
                 assert inWire != null;
@@ -1384,7 +1378,8 @@ public final class TcpChannelHub extends AbstractCloseable {
                             long timeTaken = System.currentTimeMillis() - start;
                             start = Long.MAX_VALUE;
                             if (timeTaken > 100)
-                                LOG.info("Processing data=" + timeTaken + "ms");
+                                Jvm.perf().on(TcpChannelHub.class,
+                                        "Processing data=" + timeTaken + "ms");
 
                             if (clearTid)
                                 tid = -1;
@@ -1407,7 +1402,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                     } catch (Exception e) {
                         start = Long.MAX_VALUE;
 
-                        if (Jvm.isDebug() && DEBUG_ENABLED)
+                        if (Jvm.isDebug() && debugEnabled)
                             Jvm.debug().on(TcpChannelHub.class, e);
 
                         tid = -1;
@@ -1417,7 +1412,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                         } else {
                             final String message = e.getMessage();
                             if (e instanceof ConnectionDroppedException) {
-                                if (DEBUG_ENABLED)
+                                if (debugEnabled)
                                     Jvm.debug().on(TcpChannelHub.class, "reconnecting due to dropped connection " + ((message == null) ? "" : message));
                             } else if (e instanceof IOException && "Connection reset by peer".equals(message)) {
                                 Jvm.warn().on(TcpChannelHub.class, "reconnecting due to \"Connection reset by peer\" " + message);
@@ -1541,7 +1536,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                         blockingRead(inWire, messageSize);
                         logToStandardOutMessageReceived(inWire);
 
-                        if (DEBUG_ENABLED)
+                        if (debugEnabled)
                             Jvm.debug().on(TcpChannelHub.class, "unable to respond to tid=" + tid + ", given that we have " +
                                     "received a message we a tid which is unknown, this can occur " +
                                     "sometime if " +
@@ -1625,7 +1620,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
             final StringBuilder eventName = Wires.acquireStringBuilder();
             final Wire inWire = TcpChannelHub.this.wireType.apply(bytes);
-            inWire.usePadding(false);
+            inWire.usePadding(TCP_USE_PADDING);
             if (YamlLogging.showHeartBeats())
                 logToStandardOutMessageReceived(inWire);
             inWire.readDocument(null, d -> {
@@ -1685,7 +1680,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                     onMessageReceived();
                     emptyRead = false;
 
-                    if (DEBUG_ENABLED)
+                    if (debugEnabled)
                         Jvm.debug().on(TcpChannelHub.class, "R:" + numberOfBytesRead + ",socket=" + socketAddressSupplier.get());
                     pauser.reset();
 
@@ -1761,15 +1756,15 @@ public final class TcpChannelHub extends AbstractCloseable {
                 subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this, null, name) {
                     @Override
                     public void onSubscribe(@NotNull WireOut wireOut) {
-                        LOG.debug("sending heartbeat");
+                        Jvm.debug().on(TcpChannelHub.class, "sending heartbeat");
                         wireOut.writeEventName(EventId.heartbeat).int64(System.currentTimeMillis());
                     }
 
                     @Override
                     public void onConsumer(@NotNull WireIn inWire) {
                         long roundTipTimeMicros = NANOSECONDS.toMicros(System.nanoTime() - l);
-                        if (DEBUG_ENABLED)
-                            Jvm.debug().on(TcpChannelHub.class, "heartbeat round trip time=" + roundTipTimeMicros + "" +
+                        if (debugEnabled)
+                            Jvm.perf().on(TcpChannelHub.class, "heartbeat round trip time=" + roundTipTimeMicros + "" +
                                     " server=" + socketAddressSupplier);
 
                         inWire.clear();
@@ -1849,10 +1844,8 @@ public final class TcpChannelHub extends AbstractCloseable {
 
                 checkNotShuttingDown();
 
-                if (DEBUG_ENABLED)
+                if (debugEnabled || (i >= socketAddressSupplier.all().size() && !isShuttingdown()))
                     Jvm.debug().on(TcpChannelHub.class, "attemptConnect remoteAddress=" + socketAddressSupplier);
-                else if (i >= socketAddressSupplier.all().size() && !isShuttingdown())
-                    LOG.info("attemptConnect remoteAddress=" + socketAddressSupplier);
 
                 @Nullable ChronicleSocketChannel socketChannel;
                 try {
@@ -1880,7 +1873,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                         onMessageReceived();
 
                         synchronized (this) {
-                            LOG.info("connected to " + socketChannel);
+                            Jvm.debug().on(TcpChannelHub.class, "Connected to " + socketChannel);
                             clientChannel = socketChannel;
                         }
 
@@ -1889,7 +1882,7 @@ public final class TcpChannelHub extends AbstractCloseable {
                         doHandShaking(socketChannel);
 
                         eventLoop.addHandler(this);
-                        if (DEBUG_ENABLED)
+                        if (debugEnabled)
                             Jvm.debug().on(TcpChannelHub.class, "successfully connected to remoteAddress=" +
                                     socketAddressSupplier);
                         onReconnect();
@@ -1953,7 +1946,7 @@ public final class TcpChannelHub extends AbstractCloseable {
 
         private Wire createWire() {
             final Wire wire = wireType.apply(elasticByteBuffer());
-            wire.usePadding(false);
+            wire.usePadding(TCP_USE_PADDING);
             assert wire.startUse();
             return wire;
         }
diff --git a/src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java b/src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java
index 7e66485f6e..b1e0f8baf5 100644
--- a/src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java
+++ b/src/main/java/net/openhft/chronicle/network/connection/VanillaWireOutPublisher.java
@@ -28,6 +28,8 @@ import org.slf4j.LoggerFactory;
 
 import java.nio.ByteBuffer;
 
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
+
 public class VanillaWireOutPublisher extends AbstractCloseable implements WireOutPublisher {
 
     private static final Logger LOG = LoggerFactory.getLogger(VanillaWireOutPublisher.class);
@@ -40,7 +42,7 @@ public class VanillaWireOutPublisher extends AbstractCloseable implements WireOu
         bytes = Bytes.elasticByteBuffer(TcpChannelHub.TCP_BUFFER);
         final WireType wireType0 = wireType == WireType.DELTA_BINARY ? WireType.BINARY : wireType;
         wire = wireType0.apply(bytes);
-        wire.usePadding(false);
+        wire.usePadding(TCP_USE_PADDING);
     }
 
     @Override
@@ -174,7 +176,7 @@ public class VanillaWireOutPublisher extends AbstractCloseable implements WireOu
 
         synchronized (lock()) {
             wire = wireType0.apply(bytes);
-            wire.usePadding(false);
+            wire.usePadding(TCP_USE_PADDING);
         }
     }
 
diff --git a/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java b/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
index 64be31ae05..7ace456f4a 100644
--- a/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
+++ b/src/main/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTable.java
@@ -200,7 +200,7 @@ public class FileBasedHostnamePortLookupTable implements HostnamePortLookupTable
                         T t = supplier.get();
                         long elapsedMs = System.currentTimeMillis() - startMs;
                         if (elapsedMs > 100)
-                            Jvm.warn().on(getClass(), "Took " + elapsedMs / 1000.0 + " seconds to obtain the lock on " + sharedTableFile, lastThrown);
+                            Jvm.perf().on(getClass(), "Took " + elapsedMs / 1000.0 + " seconds to obtain the lock on " + sharedTableFile, lastThrown);
                         return t;
                     } catch (OverlappingFileLockException e) {
                         throw new RuntimeException("Attempted to resize the underlying bytes, increase the MINIMUM_INITIAL_FILE_SIZE_BYTES or make this work with resizing!", e);
diff --git a/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java b/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
index 5d699a31db..f209d01b5e 100644
--- a/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
+++ b/src/test/java/net/openhft/chronicle/network/internal/lookuptable/FileBasedHostnamePortLookupTableTest.java
@@ -84,8 +84,8 @@ public class FileBasedHostnamePortLookupTableTest {
 
     @Test(timeout = 20_000)
     public void doShouldWorkConcurrently() {
-        int para = doShouldWorkConcurrently(true);
         int seq = doShouldWorkConcurrently(false);
+        int para = doShouldWorkConcurrently(true);
         System.out.println(seq + " " + para);
         assertTrue(seq > para);
     }
diff --git a/src/test/java/net/openhft/performance/tests/network/SimpleServerAndClientTest.java b/src/test/java/net/openhft/performance/tests/network/SimpleServerAndClientTest.java
index 9add4c8d76..6f26a24946 100644
--- a/src/test/java/net/openhft/performance/tests/network/SimpleServerAndClientTest.java
+++ b/src/test/java/net/openhft/performance/tests/network/SimpleServerAndClientTest.java
@@ -44,6 +44,7 @@ import java.nio.ByteBuffer;
 import java.util.concurrent.TimeoutException;
 
 import static net.openhft.chronicle.network.connection.SocketAddressSupplier.uri;
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
 
 public class SimpleServerAndClientTest extends NetworkTestCommon {
     @Test
@@ -52,7 +53,7 @@ public class SimpleServerAndClientTest extends NetworkTestCommon {
         AbstractReferenceCounted.disableReferenceTracing();
         expectException("Reference tracing disabled");
 
-        YamlLogging.setAll(false);
+        YamlLogging.setAll(true);
 
         for (; ; ) {
             // this the name of a reference to the host name and port,
@@ -80,7 +81,7 @@ public class SimpleServerAndClientTest extends NetworkTestCommon {
 
                     // we will use a text wire backed by a elasticByteBuffer
                     @NotNull final Wire wire = new TextWire(bytes).useTextDocuments();
-                    wire.usePadding(false);
+                    wire.usePadding(TCP_USE_PADDING);
 
                     wire.writeDocument(true, w -> w.write("tid").int64(tid));
                     wire.writeDocument(false, w -> w.write("payload").text(expectedMessage));
diff --git a/src/test/java/net/openhft/performance/tests/network/VerySimpleClientTest.java b/src/test/java/net/openhft/performance/tests/network/VerySimpleClientTest.java
index d691681bf3..872af9633e 100644
--- a/src/test/java/net/openhft/performance/tests/network/VerySimpleClientTest.java
+++ b/src/test/java/net/openhft/performance/tests/network/VerySimpleClientTest.java
@@ -54,6 +54,8 @@ import org.junit.Test;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
+
 public class VerySimpleClientTest extends NetworkTestCommon {
 
     public static final WireType WIRE_TYPE = WireType.BINARY;
@@ -65,8 +67,8 @@ public class VerySimpleClientTest extends NetworkTestCommon {
     private ChronicleSocketChannel client;
 
     public VerySimpleClientTest() {
-        outWire.usePadding(false);
-        inWire.usePadding(false);
+        outWire.usePadding(TCP_USE_PADDING);
+        inWire.usePadding(TCP_USE_PADDING);
     }
 
     @Before
diff --git a/src/test/java/net/openhft/performance/tests/network/WireEchoRequestHandler.java b/src/test/java/net/openhft/performance/tests/network/WireEchoRequestHandler.java
index f8cc5a4d9c..a5d0a48a49 100644
--- a/src/test/java/net/openhft/performance/tests/network/WireEchoRequestHandler.java
+++ b/src/test/java/net/openhft/performance/tests/network/WireEchoRequestHandler.java
@@ -20,6 +20,7 @@ package net.openhft.performance.tests.network;
 import net.openhft.chronicle.network.NetworkContext;
 import net.openhft.chronicle.network.WireTcpHandler;
 import net.openhft.chronicle.wire.DocumentContext;
+import net.openhft.chronicle.wire.Wire;
 import net.openhft.chronicle.wire.WireOut;
 import org.jetbrains.annotations.NotNull;
 
@@ -43,12 +44,17 @@ public class WireEchoRequestHandler extends WireTcpHandler {
     protected void onRead(@NotNull DocumentContext in,
                           @NotNull WireOut outWire) {
 
-        if (in.isMetaData())
-            outWire.writeDocument(true, meta -> meta.write("tid")
-                    .int64(in.wire().read("tid").int64()));
-        else
-            outWire.writeDocument(false, data -> data.write("payloadResponse")
-                    .text(in.wire().read("payload").text()));
+        Wire wire = in.wire();
+        assert wire != null;
+        if (in.isMetaData()) {
+            long tid = wire.read("tid").int64();
+            outWire.writeDocument(true,
+                    meta -> meta.write("tid").int64(tid));
+        } else {
+            String payload = wire.read("payload").text();
+            outWire.writeDocument(false,
+                    data -> data.write("payloadResponse").text(payload));
+        }
 
     }
 
diff --git a/src/test/java/net/openhft/performance/tests/network/WireTcpHandlerTest.java b/src/test/java/net/openhft/performance/tests/network/WireTcpHandlerTest.java
index 2ff3b01f11..6c2eebd196 100644
--- a/src/test/java/net/openhft/performance/tests/network/WireTcpHandlerTest.java
+++ b/src/test/java/net/openhft/performance/tests/network/WireTcpHandlerTest.java
@@ -36,6 +36,7 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.function.Function;
 
+import static net.openhft.chronicle.network.connection.TcpChannelHub.TCP_USE_PADDING;
 import static net.openhft.performance.tests.network.LegacyHanderFactory.simpleTcpEventHandlerFactory;
 
 /*
@@ -75,7 +76,7 @@ public class WireTcpHandlerTest extends NetworkTestCommon {
         ByteBuffer out = ByteBuffer.allocateDirect(64 * 1024);
         Bytes outBytes = Bytes.wrapForWrite(out);
         Wire outWire = wireWrapper.apply(outBytes);
-        outWire.usePadding(false);
+        outWire.usePadding(TCP_USE_PADDING);
 
         ByteBuffer in = ByteBuffer.allocateDirect(64 * 1024);
         Bytes inBytes = Bytes.wrapForRead(in);
@@ -136,6 +137,8 @@ public class WireTcpHandlerTest extends NetworkTestCommon {
 
     @Test
     public void testProcess() throws IOException {
+        boolean logging = YamlLogging.showClientReads();
+        YamlLogging.setAll(false);
         expectException("Reference tracing disabled");
 // TODO FIX
         AbstractReferenceCounted.disableReferenceTracing();
@@ -157,6 +160,7 @@ public class WireTcpHandlerTest extends NetworkTestCommon {
             eg.stop();
             TcpChannelHub.closeAllHubs();
         }
+        YamlLogging.setAll(logging);
     }
 
     static class EchoRequestHandler extends WireTcpHandler {
