diff --git a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
index 83ab0e5c2c..b99cd1dd57 100644
--- a/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/AlwaysStartOnPrimaryConnectionStrategy.java
@@ -30,6 +30,7 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractMarshallable
     private int tcpBufferSize = Integer.getInteger("tcp.client.buffer.size", TCP_BUFFER);
     private int pausePeriodMs = Integer.getInteger("client.timeout", 500);
     private int socketConnectionTimeoutMs = Integer.getInteger("connectionStrategy.socketConnectionTimeoutMs", 1);
+    private long pauseMillisBeforeReconnect = Integer.getInteger("connectionStrategy.pauseMillisBeforeReconnect", 500);
 
     @Nullable
     @Override
@@ -101,4 +102,8 @@ public class AlwaysStartOnPrimaryConnectionStrategy extends AbstractMarshallable
         return socketAddressSupplier.size() - 1 == socketAddressSupplier.index();
     }
 
+    @Override
+    public long pauseMillisBeforeReconnect() {
+        return pauseMillisBeforeReconnect;
+    }
 }
diff --git a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
index 8a90065178..75c06ff249 100644
--- a/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
+++ b/src/main/java/net/openhft/chronicle/network/ConnectionStrategy.java
@@ -13,6 +13,8 @@ import java.net.Socket;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
 import java.nio.channels.SocketChannel;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.LockSupport;
 
 import static net.openhft.chronicle.core.io.Closeable.closeQuietly;
 
@@ -108,7 +110,8 @@ public interface ConnectionStrategy extends Marshallable {
         for (; ; ) {
             if (Thread.currentThread().isInterrupted())
                 throw new InterruptedException();
-            if (start + timeoutMs < System.currentTimeMillis()) {
+            long startMs = System.currentTimeMillis();
+            if (start + timeoutMs < startMs) {
                 Jvm.warn().on(ConnectionStrategy.class, "Timed out attempting to connect to " + socketAddress);
                 return null;
             }
@@ -116,6 +119,11 @@ public interface ConnectionStrategy extends Marshallable {
             if (sc != null)
                 return sc;
             Thread.yield();
+            // If nothing is listening, socketChannel returns pretty much immediately so we support a pause here
+            long pauseMillis = (startMs + pauseMillisBeforeReconnect()) - System.currentTimeMillis();
+            if (Jvm.isDebugEnabled(this.getClass()))
+                Jvm.debug().on(this.getClass(), "Waiting for reconnect "+pauseMillis+" ms");
+            LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(pauseMillis));
         }
     }
 
