[{"id":1233802052,"node_id":"MDExOkNsb3NlZEV2ZW50MTIzMzgwMjA1Mg==","url":"https://api.github.com/repos/vuejs/vue/issues/events/1233802052","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"closed","commit_id":"230c6ae7822347b9b2a659503291e45fcc58fe41","commit_url":"https://api.github.com/repos/vuejs/vue/commits/230c6ae7822347b9b2a659503291e45fcc58fe41","created_at":"2017-09-04T16:51:37Z","state_reason":null,"performed_via_github_app":null},{"id":1234419995,"node_id":"MDE1OlJlZmVyZW5jZWRFdmVudDEyMzQ0MTk5OTU=","url":"https://api.github.com/repos/vuejs/vue/issues/events/1234419995","actor":{"login":"FranklinTesla","id":16288340,"node_id":"MDQ6VXNlcjE2Mjg4MzQw","avatar_url":"https://avatars.githubusercontent.com/u/16288340?v=4","gravatar_id":"","url":"https://api.github.com/users/FranklinTesla","html_url":"https://github.com/FranklinTesla","followers_url":"https://api.github.com/users/FranklinTesla/followers","following_url":"https://api.github.com/users/FranklinTesla/following{/other_user}","gists_url":"https://api.github.com/users/FranklinTesla/gists{/gist_id}","starred_url":"https://api.github.com/users/FranklinTesla/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/FranklinTesla/subscriptions","organizations_url":"https://api.github.com/users/FranklinTesla/orgs","repos_url":"https://api.github.com/users/FranklinTesla/repos","events_url":"https://api.github.com/users/FranklinTesla/events{/privacy}","received_events_url":"https://api.github.com/users/FranklinTesla/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"811a24bf7302129936ac8a1ec5c74fd9829c4a06","commit_url":"https://api.github.com/repos/FranklinTesla/vue/commits/811a24bf7302129936ac8a1ec5c74fd9829c4a06","created_at":"2017-09-05T08:36:19Z","performed_via_github_app":null},{"id":1452165545,"node_id":"MDE1OlJlZmVyZW5jZWRFdmVudDE0NTIxNjU1NDU=","url":"https://api.github.com/repos/vuejs/vue/issues/events/1452165545","actor":{"login":"liuliangsir","id":8049878,"node_id":"MDQ6VXNlcjgwNDk4Nzg=","avatar_url":"https://avatars.githubusercontent.com/u/8049878?v=4","gravatar_id":"","url":"https://api.github.com/users/liuliangsir","html_url":"https://github.com/liuliangsir","followers_url":"https://api.github.com/users/liuliangsir/followers","following_url":"https://api.github.com/users/liuliangsir/following{/other_user}","gists_url":"https://api.github.com/users/liuliangsir/gists{/gist_id}","starred_url":"https://api.github.com/users/liuliangsir/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/liuliangsir/subscriptions","organizations_url":"https://api.github.com/users/liuliangsir/orgs","repos_url":"https://api.github.com/users/liuliangsir/repos","events_url":"https://api.github.com/users/liuliangsir/events{/privacy}","received_events_url":"https://api.github.com/users/liuliangsir/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"8e9fc149afdbc4a541061870700d7d2c7dc8ad07","commit_url":"https://api.github.com/repos/liuliangsir/vue/commits/8e9fc149afdbc4a541061870700d7d2c7dc8ad07","created_at":"2018-02-01T03:35:13Z","performed_via_github_app":null},{"id":1474454825,"node_id":"MDE1OlJlZmVyZW5jZWRFdmVudDE0NzQ0NTQ4MjU=","url":"https://api.github.com/repos/vuejs/vue/issues/events/1474454825","actor":{"login":"ztlevi","id":16655096,"node_id":"MDQ6VXNlcjE2NjU1MDk2","avatar_url":"https://avatars.githubusercontent.com/u/16655096?v=4","gravatar_id":"","url":"https://api.github.com/users/ztlevi","html_url":"https://github.com/ztlevi","followers_url":"https://api.github.com/users/ztlevi/followers","following_url":"https://api.github.com/users/ztlevi/following{/other_user}","gists_url":"https://api.github.com/users/ztlevi/gists{/gist_id}","starred_url":"https://api.github.com/users/ztlevi/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ztlevi/subscriptions","organizations_url":"https://api.github.com/users/ztlevi/orgs","repos_url":"https://api.github.com/users/ztlevi/repos","events_url":"https://api.github.com/users/ztlevi/events{/privacy}","received_events_url":"https://api.github.com/users/ztlevi/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"43b4a855e6c1cb981c4b76b6b8d2041e8767e68a","commit_url":"https://api.github.com/repos/ztlevi/vue/commits/43b4a855e6c1cb981c4b76b6b8d2041e8767e68a","created_at":"2018-02-14T18:49:52Z","performed_via_github_app":null},{"id":2096742966,"node_id":"MDE1OlJlZmVyZW5jZWRFdmVudDIwOTY3NDI5NjY=","url":"https://api.github.com/repos/vuejs/vue/issues/events/2096742966","actor":{"login":"f2009","id":28625332,"node_id":"MDQ6VXNlcjI4NjI1MzMy","avatar_url":"https://avatars.githubusercontent.com/u/28625332?v=4","gravatar_id":"","url":"https://api.github.com/users/f2009","html_url":"https://github.com/f2009","followers_url":"https://api.github.com/users/f2009/followers","following_url":"https://api.github.com/users/f2009/following{/other_user}","gists_url":"https://api.github.com/users/f2009/gists{/gist_id}","starred_url":"https://api.github.com/users/f2009/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/f2009/subscriptions","organizations_url":"https://api.github.com/users/f2009/orgs","repos_url":"https://api.github.com/users/f2009/repos","events_url":"https://api.github.com/users/f2009/events{/privacy}","received_events_url":"https://api.github.com/users/f2009/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"bcff2ff2493c86d187cd54769bc2c976e502e2c1","commit_url":"https://api.github.com/repos/f2009/vue/commits/bcff2ff2493c86d187cd54769bc2c976e502e2c1","created_at":"2019-01-25T09:52:50Z","performed_via_github_app":null},{"actor":{"login":"RED523","id":63771846,"node_id":"MDQ6VXNlcjYzNzcxODQ2","avatar_url":"https://avatars.githubusercontent.com/u/63771846?v=4","gravatar_id":"","url":"https://api.github.com/users/RED523","html_url":"https://github.com/RED523","followers_url":"https://api.github.com/users/RED523/followers","following_url":"https://api.github.com/users/RED523/following{/other_user}","gists_url":"https://api.github.com/users/RED523/gists{/gist_id}","starred_url":"https://api.github.com/users/RED523/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/RED523/subscriptions","organizations_url":"https://api.github.com/users/RED523/orgs","repos_url":"https://api.github.com/users/RED523/repos","events_url":"https://api.github.com/users/RED523/events{/privacy}","received_events_url":"https://api.github.com/users/RED523/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2024-01-13T15:36:23Z","updated_at":"2024-01-13T15:36:23Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/aooy/blog/issues/2","repository_url":"https://api.github.com/repos/aooy/blog","labels_url":"https://api.github.com/repos/aooy/blog/issues/2/labels{/name}","comments_url":"https://api.github.com/repos/aooy/blog/issues/2/comments","events_url":"https://api.github.com/repos/aooy/blog/issues/2/events","html_url":"https://github.com/aooy/blog/issues/2","id":215272776,"node_id":"MDU6SXNzdWUyMTUyNzI3NzY=","number":2,"title":"解析vue2.0的diff算法","user":{"login":"aooy","id":14580471,"node_id":"MDQ6VXNlcjE0NTgwNDcx","avatar_url":"https://avatars.githubusercontent.com/u/14580471?v=4","gravatar_id":"","url":"https://api.github.com/users/aooy","html_url":"https://github.com/aooy","followers_url":"https://api.github.com/users/aooy/followers","following_url":"https://api.github.com/users/aooy/following{/other_user}","gists_url":"https://api.github.com/users/aooy/gists{/gist_id}","starred_url":"https://api.github.com/users/aooy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aooy/subscriptions","organizations_url":"https://api.github.com/users/aooy/orgs","repos_url":"https://api.github.com/users/aooy/repos","events_url":"https://api.github.com/users/aooy/events{/privacy}","received_events_url":"https://api.github.com/users/aooy/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":576070514,"node_id":"MDU6TGFiZWw1NzYwNzA1MTQ=","url":"https://api.github.com/repos/aooy/blog/labels/javascript","name":"javascript","color":"0e8a16","default":false,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":53,"created_at":"2017-03-19T15:49:08Z","updated_at":"2024-01-13T15:36:23Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":85381152,"node_id":"MDEwOlJlcG9zaXRvcnk4NTM4MTE1Mg==","name":"blog","full_name":"aooy/blog","private":false,"owner":{"login":"aooy","id":14580471,"node_id":"MDQ6VXNlcjE0NTgwNDcx","avatar_url":"https://avatars.githubusercontent.com/u/14580471?v=4","gravatar_id":"","url":"https://api.github.com/users/aooy","html_url":"https://github.com/aooy","followers_url":"https://api.github.com/users/aooy/followers","following_url":"https://api.github.com/users/aooy/following{/other_user}","gists_url":"https://api.github.com/users/aooy/gists{/gist_id}","starred_url":"https://api.github.com/users/aooy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/aooy/subscriptions","organizations_url":"https://api.github.com/users/aooy/orgs","repos_url":"https://api.github.com/users/aooy/repos","events_url":"https://api.github.com/users/aooy/events{/privacy}","received_events_url":"https://api.github.com/users/aooy/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/aooy/blog","description":"杨敬卓的个人博客","fork":false,"url":"https://api.github.com/repos/aooy/blog","forks_url":"https://api.github.com/repos/aooy/blog/forks","keys_url":"https://api.github.com/repos/aooy/blog/keys{/key_id}","collaborators_url":"https://api.github.com/repos/aooy/blog/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/aooy/blog/teams","hooks_url":"https://api.github.com/repos/aooy/blog/hooks","issue_events_url":"https://api.github.com/repos/aooy/blog/issues/events{/number}","events_url":"https://api.github.com/repos/aooy/blog/events","assignees_url":"https://api.github.com/repos/aooy/blog/assignees{/user}","branches_url":"https://api.github.com/repos/aooy/blog/branches{/branch}","tags_url":"https://api.github.com/repos/aooy/blog/tags","blobs_url":"https://api.github.com/repos/aooy/blog/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/aooy/blog/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/aooy/blog/git/refs{/sha}","trees_url":"https://api.github.com/repos/aooy/blog/git/trees{/sha}","statuses_url":"https://api.github.com/repos/aooy/blog/statuses/{sha}","languages_url":"https://api.github.com/repos/aooy/blog/languages","stargazers_url":"https://api.github.com/repos/aooy/blog/stargazers","contributors_url":"https://api.github.com/repos/aooy/blog/contributors","subscribers_url":"https://api.github.com/repos/aooy/blog/subscribers","subscription_url":"https://api.github.com/repos/aooy/blog/subscription","commits_url":"https://api.github.com/repos/aooy/blog/commits{/sha}","git_commits_url":"https://api.github.com/repos/aooy/blog/git/commits{/sha}","comments_url":"https://api.github.com/repos/aooy/blog/comments{/number}","issue_comment_url":"https://api.github.com/repos/aooy/blog/issues/comments{/number}","contents_url":"https://api.github.com/repos/aooy/blog/contents/{+path}","compare_url":"https://api.github.com/repos/aooy/blog/compare/{base}...{head}","merges_url":"https://api.github.com/repos/aooy/blog/merges","archive_url":"https://api.github.com/repos/aooy/blog/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/aooy/blog/downloads","issues_url":"https://api.github.com/repos/aooy/blog/issues{/number}","pulls_url":"https://api.github.com/repos/aooy/blog/pulls{/number}","milestones_url":"https://api.github.com/repos/aooy/blog/milestones{/number}","notifications_url":"https://api.github.com/repos/aooy/blog/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/aooy/blog/labels{/name}","releases_url":"https://api.github.com/repos/aooy/blog/releases{/id}","deployments_url":"https://api.github.com/repos/aooy/blog/deployments","created_at":"2017-03-18T06:37:24Z","updated_at":"2025-11-06T01:35:28Z","pushed_at":"2017-05-02T04:22:03Z","git_url":"git://github.com/aooy/blog.git","ssh_url":"git@github.com:aooy/blog.git","clone_url":"https://github.com/aooy/blog.git","svn_url":"https://github.com/aooy/blog","homepage":"","size":5687,"stargazers_count":840,"watchers_count":840,"language":null,"has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":75,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":6,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":75,"open_issues":6,"watchers":840,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"**作者：杨敬卓**\r\n\r\n**转载请注明出处**\r\n\r\n# 目录\r\n\r\n* 前言\r\n* virtual dom\r\n* 分析diff\r\n* 总结\r\n\r\n# 前言\r\nvue2.0加入了virtual dom，有向react靠拢的意思。vue的diff位于[patch.js](https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js)文件中，我的一个小框架[aoy](https://github.com/aooy/aoy)也同样使用此算法，该算法来源于[snabbdom](https://github.com/snabbdom/snabbdom)，复杂度为O(n)。\r\n了解diff过程可以让我们更高效的使用框架。\r\n本文力求以图文并茂的方式来讲明这个diff的过程。\r\n\r\n# virtual dom\r\n如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用`document.CreateElement` 和 `document.CreateTextNode`创建的就是真实节点。\r\n\r\n我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。\r\n```js\r\nvar mydiv = document.createElement('div');\r\nfor(var k in mydiv ){\r\n  console.log(k)\r\n}\r\n```\r\nvirtual dom就是解决这个问题的一个思路，到底什么是virtual dom呢？通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。\r\n举个简单的例子，我们在body里插入一个class为a的div。\r\n```js\r\nvar mydiv = document.createElement('div');\r\nmydiv.className = 'a';\r\ndocument.body.appendChild(mydiv);\r\n```\r\n\r\n对于这个div我们可以用一个简单的对象`mydivVirtual`代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。\r\n```js\r\n//伪代码\r\nvar mydivVirtual = { \r\n  tagName: 'DIV',\r\n  className: 'a'\r\n};\r\nvar newmydivVirtual = {\r\n   tagName: 'DIV',\r\n   className: 'b'\r\n}\r\nif(mydivVirtual.tagName !== newmydivVirtual.tagName || mydivVirtual.className  !== newmydivVirtual.className){\r\n   change(mydiv)\r\n}\r\n\r\n// 会执行相应的修改 mydiv.className = 'b';\r\n//最后  <div class='b'></div>\r\n\r\n```\r\n#### 读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual dom呢？\r\n很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，**virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。** \r\n\r\nvirtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。\r\n\r\n# 分析diff\r\n一篇相当经典的文章[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)中的图，react的diff其实和vue的diff大同小异。所以这张图能很好的解释过程。**比较只会在同层级进行, 不会跨层级比较。** \r\n<div  align=center >\r\n<img  src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff.png?raw=true\" /></div>\r\n举个形象的例子。\r\n\r\n```js\r\n<!-- 之前 -->\r\n<div>           <!-- 层级1 -->\r\n  <p>            <!-- 层级2 -->\r\n    <b> aoy </b>   <!-- 层级3 -->   \r\n    <span>diff</Span>\r\n  </P> \r\n</div>\r\n\r\n<!-- 之后 -->\r\n<div>            <!-- 层级1 -->\r\n  <p>             <!-- 层级2 -->\r\n      <b> aoy </b>        <!-- 层级3 -->\r\n  </p>\r\n  <span>diff</Span>\r\n</div>\r\n```\r\n\r\n我们可能期望将`<span>`直接移动到`<p>`的后边，这是最优的操作。但是实际的diff操作是移除`<p>`里的`<span>`在创建一个新的`<span>`插到`<p>`的后边。\r\n因为新加的`<span>`在层级2，旧的在层级3，属于不同层级的比较。\r\n\r\n## 源码分析\r\n\r\n文中的代码位于[aoy-diff](https://github.com/aooy/aoy/blob/master/src/vdom/diff.js)中，已经精简了很多代码，留下最核心的部分。\r\n\r\ndiff的过程就是调用patch函数，就像打补丁一样修改真实dom。\r\n```js\r\nfunction patch (oldVnode, vnode) {\r\n\tif (sameVnode(oldVnode, vnode)) {\r\n\t\tpatchVnode(oldVnode, vnode)\r\n\t} else {\r\n\t\tconst oEl = oldVnode.el\r\n\t\tlet parentEle = api.parentNode(oEl)\r\n\t\tcreateEle(vnode)\r\n\t\tif (parentEle !== null) {\r\n\t\t\tapi.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\r\n\t\t\tapi.removeChild(parentEle, oldVnode.el)\r\n\t\t\toldVnode = null\r\n\t\t}\r\n\t}\r\n\treturn vnode\r\n}\r\n```\r\n`patch`函数有两个参数，`vnode`和`oldVnode`，也就是新旧两个虚拟节点。在这之前，我们先了解完整的vnode都有什么属性，举个一个简单的例子:\r\n```js\r\n// body下的 <div id=\"v\" class=\"classA\"><div> 对应的 oldVnode 就是\r\n\r\n{\r\n  el:  div  //对真实的节点的引用，本例中就是document.querySelector('#id.classA')\r\n  tagName: 'DIV',   //节点的标签\r\n  sel: 'div#v.classA'  //节点的选择器\r\n  data: null,       // 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style\r\n  children: [], //存储子节点的数组，每个子节点也是vnode结构\r\n  text: null,    //如果是文本节点，对应文本节点的textContent，否则为null\r\n}\r\n```\r\n\r\n需要注意的是，el属性引用的是此 virtual dom对应的真实dom，`patch`的`vnode`参数的`el`最初是null，因为`patch`之前它还没有对应的真实dom。\r\n\r\n来到`patch`的第一部分，\r\n```js\r\nif (sameVnode(oldVnode, vnode)) {\r\n\tpatchVnode(oldVnode, vnode)\r\n} \r\n```\r\n`sameVnode`函数就是看这两个节点是否值得比较，代码相当简单：\r\n```js\r\nfunction sameVnode(oldVnode, vnode){\r\n\treturn vnode.key === oldVnode.key && vnode.sel === oldVnode.sel\r\n}\r\n```\r\n两个vnode的key和sel相同才去比较它们，比如`p`和`span`，`div.classA`和`div.classB`都被认为是不同结构而不去比较它们。\r\n\r\n如果值得比较会执行`patchVnode(oldVnode, vnode)`，稍后会详细讲`patchVnode`函数。\r\n\r\n当节点不值得比较，进入else中\r\n```js\r\nelse {\r\n\t\tconst oEl = oldVnode.el\r\n\t\tlet parentEle = api.parentNode(oEl)\r\n\t\tcreateEle(vnode)\r\n\t\tif (parentEle !== null) {\r\n\t\t\tapi.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\r\n\t\t\tapi.removeChild(parentEle, oldVnode.el)\r\n\t\t\toldVnode = null\r\n\t\t}\r\n\t}\r\n```\r\n过程如下：\r\n* 取得`oldvnode.el`的父节点，`parentEle`是真实dom\r\n* `createEle(vnode)`会为`vnode`创建它的真实dom，令`vnode.el` =`真实dom`\r\n* `parentEle`将新的dom插入，移除旧的dom\r\n**当不值得比较时，新节点直接把老节点整个替换了**\r\n\r\n最后\r\n```js\r\nreturn vnode\r\n```\r\npatch最后会返回vnode，vnode和进入patch之前的不同在哪？\r\n没错，就是vnode.el，**唯一的改变就是之前vnode.el = null, 而现在它引用的是对应的真实dom。**\r\n```js\r\nvar oldVnode = patch (oldVnode, vnode)\r\n```\r\n至此完成一个patch过程。\r\n\r\n### patchVnode\r\n两个节点值得比较时，会调用`patchVnode`函数\r\n\r\n```JS\r\npatchVnode (oldVnode, vnode) {\r\n    const el = vnode.el = oldVnode.el\r\n    let i, oldCh = oldVnode.children, ch = vnode.children\r\n    if (oldVnode === vnode) return\r\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {\r\n        api.setTextContent(el, vnode.text)\r\n    }else {\r\n        updateEle(el, vnode, oldVnode)\r\n    \tif (oldCh && ch && oldCh !== ch) {\r\n\t    \tupdateChildren(el, oldCh, ch)\r\n\t    }else if (ch){\r\n\t    \tcreateEle(vnode) //create el's children dom\r\n\t    }else if (oldCh){\r\n\t    \tapi.removeChildren(el)\r\n\t    }\r\n    }\r\n}\r\n```\r\n`const el = vnode.el = oldVnode.el` 这是很重要的一步，让`vnode.el`引用到现在的真实dom，当`el`修改时，`vnode.el`会同步变化。\r\n\r\n节点的比较有5种情况\r\n1. `if (oldVnode === vnode)`，他们的引用一致，可以认为没有变化。\r\n\r\n2. `if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)`，文本节点的比较，需要修改，则会调用`Node.textContent = vnode.text`。\r\n\r\n3.  `if( oldCh && ch && oldCh !== ch )`, 两个节点都有子节点，而且它们不一样，这样我们会调用`updateChildren`函数比较子节点，这是diff的核心，后边会讲到。\r\n\r\n4.  `else if (ch)`，只有新的节点有子节点，调用`createEle(vnode)`，`vnode.el`已经引用了老的dom节点，`createEle`函数会在老dom节点上添加子节点。\r\n\r\n5.  `else if (oldCh)`，新节点没有子节点，老节点有子节点，直接删除老节点。\r\n\r\n### updateChildren\r\n\r\n```js\r\nupdateChildren (parentElm, oldCh, newCh) {\r\n    let oldStartIdx = 0, newStartIdx = 0\r\n    let oldEndIdx = oldCh.length - 1\r\n    let oldStartVnode = oldCh[0]\r\n    let oldEndVnode = oldCh[oldEndIdx]\r\n    let newEndIdx = newCh.length - 1\r\n    let newStartVnode = newCh[0]\r\n    let newEndVnode = newCh[newEndIdx]\r\n    let oldKeyToIdx\r\n    let idxInOld\r\n    let elmToMove\r\n    let before\r\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            if (oldStartVnode == null) {   //对于vnode.key的比较，会把oldVnode = null\r\n                oldStartVnode = oldCh[++oldStartIdx] \r\n            }else if (oldEndVnode == null) {\r\n                oldEndVnode = oldCh[--oldEndIdx]\r\n            }else if (newStartVnode == null) {\r\n                newStartVnode = newCh[++newStartIdx]\r\n            }else if (newEndVnode == null) {\r\n                newEndVnode = newCh[--newEndIdx]\r\n            }else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n                patchVnode(oldStartVnode, newStartVnode)\r\n                oldStartVnode = oldCh[++oldStartIdx]\r\n                newStartVnode = newCh[++newStartIdx]\r\n            }else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n                patchVnode(oldEndVnode, newEndVnode)\r\n                oldEndVnode = oldCh[--oldEndIdx]\r\n                newEndVnode = newCh[--newEndIdx]\r\n            }else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n                patchVnode(oldStartVnode, newEndVnode)\r\n                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\r\n                oldStartVnode = oldCh[++oldStartIdx]\r\n                newEndVnode = newCh[--newEndIdx]\r\n            }else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n                patchVnode(oldEndVnode, newStartVnode)\r\n                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\r\n                oldEndVnode = oldCh[--oldEndIdx]\r\n                newStartVnode = newCh[++newStartIdx]\r\n            }else {\r\n               // 使用key时的比较\r\n                if (oldKeyToIdx === undefined) {\r\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表\r\n                }\r\n                idxInOld = oldKeyToIdx[newStartVnode.key]\r\n                if (!idxInOld) {\r\n                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\r\n                    newStartVnode = newCh[++newStartIdx]\r\n                }\r\n                else {\r\n                    elmToMove = oldCh[idxInOld]\r\n                    if (elmToMove.sel !== newStartVnode.sel) {\r\n                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\r\n                    }else {\r\n                        patchVnode(elmToMove, newStartVnode)\r\n                        oldCh[idxInOld] = null\r\n                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\r\n                    }\r\n                    newStartVnode = newCh[++newStartIdx]\r\n                }\r\n            }\r\n        }\r\n        if (oldStartIdx > oldEndIdx) {\r\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el\r\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\r\n        }else if (newStartIdx > newEndIdx) {\r\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\r\n        }\r\n}\r\n```\r\n代码很密集，为了形象的描述这个过程，可以看看这张图。\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff2.png?raw=true\" /></div>\r\n\r\n过程可以概括为：`oldCh`和`newCh`各有两个头尾的变量`StartIdx`和`EndIdx`，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦`StartIdx>EndIdx`表明`oldCh`和`newCh`至少有一个已经遍历完了，就会结束比较。\r\n\r\n\r\n### 具体的diff分析\r\n\r\n设置key和不设置key的区别：\r\n**不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象`oldKeyToIdx`中查找匹配的节点，所以为节点设置key可以更高效的利用dom。**\r\n\r\ndiff的遍历过程中，只要是对dom进行的操作都调用`api.insertBefore`，`api.insertBefore`只是原生`insertBefore`的简单封装。\r\n比较分为两种，一种是有`vnode.key`的，一种是没有的。但这两种比较对真实dom的操作是一致的。\r\n\r\n对于与`sameVnode(oldStartVnode, newStartVnode)`和`sameVnode(oldEndVnode,newEndVnode)`为true的情况，不需要对dom进行移动。\r\n\r\n总结遍历过程，有3种dom操作：\r\n\r\n1. 当`oldStartVnode`，`newEndVnode`值得比较，说明`oldStartVnode.el`跑到`oldEndVnode.el`的后边了。\r\n\r\n图中假设startIdx遍历到1。\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff3.png?raw=true\" /></div>\r\n\r\n2. 当`oldEndVnode`，`newStartVnode`值得比较，说明 `oldEndVnode.el`跑到了`newStartVnode.el`的前边。（这里笔误，应该是“oldEndVnode.el跑到了oldStartVnode.el的前边”，准确的说应该是oldEndVnode.el需要移动到oldStartVnode.el的前边”）\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff4.png?raw=true\" /></div>\r\n\r\n3. newCh中的节点oldCh里没有， 将新节点插入到`oldStartVnode.el`的前边。\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff5.png?raw=true\" /></div>\r\n\r\n\r\n在结束时，分为两种情况：\r\n1. ` oldStartIdx > oldEndIdx`，可以认为`oldCh`先遍历完。当然也有可能`newCh`此时也正好完成了遍历，统一都归为此类。此时`newStartIdx`和`newEndIdx`之间的vnode是新增的，调用`addVnodes`，把他们全部插进`before`的后边，`before`很多时候是为null的。`addVnodes`调用的是`insertBefore`操作dom节点，我们看看`insertBefore`的文档：`parentElement.insertBefore(newElement, referenceElement)`\r\n如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。**所以`before`为null，newElement将被插入到子节点的末尾。**\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff6.png?raw=true\" /></div>\r\n\r\n2.  ` newStartIdx > newEndIdx`，可以认为`newCh`先遍历完。此时`oldStartIdx`和`oldEndIdx`之间的vnode在新的子节点里已经不存在了，调用`removeVnodes`将它们从dom里删除。\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff7.png?raw=true\" /></div>\r\n\r\n#### 下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出。\r\n\r\n1. a,b,c,d,e假设是4个不同的元素，我们没有设置key时，b没有复用，而是直接创建新的，删除旧的。\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff8.png?raw=true\" /></div>\r\n\r\n2. 当我们给4个元素加上唯一key时，b得到了的复用。\r\n\r\n<div  align=center >\r\n<img width='400' src=\"https://github.com/aooy/blog/blob/master/images/issues-2/diff9.png?raw=true\" /></div>\r\n\r\n这个例子如果我们使用手工优化，只需要3步就可以达到。\r\n\r\n# 总结\r\n\r\n* 尽量不要跨层级的修改dom\r\n* 设置key可以最大化的利用节点\r\n* diff的效率并不是每种情况下都是最优的\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","reactions":{"url":"https://api.github.com/repos/aooy/blog/issues/2/reactions","total_count":178,"+1":144,"-1":0,"laugh":12,"hooray":16,"confused":0,"heart":0,"rocket":6,"eyes":0},"timeline_url":"https://api.github.com/repos/aooy/blog/issues/2/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"}]