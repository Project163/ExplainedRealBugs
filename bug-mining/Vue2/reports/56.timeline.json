[{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249551828","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249551828","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249551828,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTU1MTgyOA==","user":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T12:06:50Z","updated_at":"2016-09-26T12:10:39Z","body":"Well, that's definitely a shame. Please follow the [Issue Reporting Guidelines](https://github.com/vuejs/vue/blob/dev/CONTRIBUTING.md#issue-reporting-guidelines) and provide a minimal JSFiddle or JSBin containing a set of reproducible steps that can lead to the behaviour you described.\n","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249551828/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":802170209,"node_id":"MDEyOkxhYmVsZWRFdmVudDgwMjE3MDIwOQ==","url":"https://api.github.com/repos/vuejs/vue/issues/events/802170209","actor":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2016-09-26T12:06:56Z","label":{"name":"need repro","color":"eb6420"},"performed_via_github_app":null},{"id":802175032,"node_id":"MDEyOkxhYmVsZWRFdmVudDgwMjE3NTAzMg==","url":"https://api.github.com/repos/vuejs/vue/issues/events/802175032","actor":{"login":"LinusBorg","id":1444526,"node_id":"MDQ6VXNlcjE0NDQ1MjY=","avatar_url":"https://avatars.githubusercontent.com/u/1444526?v=4","gravatar_id":"","url":"https://api.github.com/users/LinusBorg","html_url":"https://github.com/LinusBorg","followers_url":"https://api.github.com/users/LinusBorg/followers","following_url":"https://api.github.com/users/LinusBorg/following{/other_user}","gists_url":"https://api.github.com/users/LinusBorg/gists{/gist_id}","starred_url":"https://api.github.com/users/LinusBorg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LinusBorg/subscriptions","organizations_url":"https://api.github.com/users/LinusBorg/orgs","repos_url":"https://api.github.com/users/LinusBorg/repos","events_url":"https://api.github.com/users/LinusBorg/events{/privacy}","received_events_url":"https://api.github.com/users/LinusBorg/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2016-09-26T12:11:36Z","label":{"name":"2.0","color":"f9d0c4"},"performed_via_github_app":null},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249639021","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249639021","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249639021,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTYzOTAyMQ==","user":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T17:31:27Z","updated_at":"2016-09-26T17:31:27Z","body":"Looks like window.postMessage in chromium sometimes has random delays. The problem is it happens with about 10% chance on my project and i still havent found reliable way to reproduce it.\n","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249639021/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249645996","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249645996","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249645996,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY0NTk5Ng==","user":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T17:56:06Z","updated_at":"2016-09-26T17:56:06Z","body":"If that's the case, it may be a bug with chromium. Have you tried on a stable version of any other browser?\n","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249645996/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249655840","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249655840","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249655840,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY1NTg0MA==","user":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T18:30:06Z","updated_at":"2016-09-26T18:30:06Z","body":"Delays reproduce in chromium based browsers(chrome, opera). There is no delays in firefox. Have not tried IE yet.\n","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249655840/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249659332","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249659332","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249659332,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY1OTMzMg==","user":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T18:42:29Z","updated_at":"2016-09-26T18:42:29Z","body":"That's a starting point for a repro\n","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249659332/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"posva","id":664177,"node_id":"MDQ6VXNlcjY2NDE3Nw==","avatar_url":"https://avatars.githubusercontent.com/u/664177?v=4","gravatar_id":"","url":"https://api.github.com/users/posva","html_url":"https://github.com/posva","followers_url":"https://api.github.com/users/posva/followers","following_url":"https://api.github.com/users/posva/following{/other_user}","gists_url":"https://api.github.com/users/posva/gists{/gist_id}","starred_url":"https://api.github.com/users/posva/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/posva/subscriptions","organizations_url":"https://api.github.com/users/posva/orgs","repos_url":"https://api.github.com/users/posva/repos","events_url":"https://api.github.com/users/posva/events{/privacy}","received_events_url":"https://api.github.com/users/posva/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249663327","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249663327","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249663327,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY2MzMyNw==","user":{"login":"wonderful-panda","id":1205852,"node_id":"MDQ6VXNlcjEyMDU4NTI=","avatar_url":"https://avatars.githubusercontent.com/u/1205852?v=4","gravatar_id":"","url":"https://api.github.com/users/wonderful-panda","html_url":"https://github.com/wonderful-panda","followers_url":"https://api.github.com/users/wonderful-panda/followers","following_url":"https://api.github.com/users/wonderful-panda/following{/other_user}","gists_url":"https://api.github.com/users/wonderful-panda/gists{/gist_id}","starred_url":"https://api.github.com/users/wonderful-panda/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wonderful-panda/subscriptions","organizations_url":"https://api.github.com/users/wonderful-panda/orgs","repos_url":"https://api.github.com/users/wonderful-panda/repos","events_url":"https://api.github.com/users/wonderful-panda/events{/privacy}","received_events_url":"https://api.github.com/users/wonderful-panda/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T18:56:01Z","updated_at":"2016-09-26T18:56:01Z","body":"I faced similar problem too in Windows 10 / Chrome 53.0.2785.116 m (64-bit).\n\nrc6: https://jsfiddle.net/k6bgu2z6/4/\nrc7: https://jsfiddle.net/v9q9L0hw/2/\n\nIn the rc6's example, yellow square don't move when scrolling container element.\nIn the rc7's one, yellow square swings vertically when scrolling.\n\n1.0.27 has same problem.\n","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249663327/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"wonderful-panda","id":1205852,"node_id":"MDQ6VXNlcjEyMDU4NTI=","avatar_url":"https://avatars.githubusercontent.com/u/1205852?v=4","gravatar_id":"","url":"https://api.github.com/users/wonderful-panda","html_url":"https://github.com/wonderful-panda","followers_url":"https://api.github.com/users/wonderful-panda/followers","following_url":"https://api.github.com/users/wonderful-panda/following{/other_user}","gists_url":"https://api.github.com/users/wonderful-panda/gists{/gist_id}","starred_url":"https://api.github.com/users/wonderful-panda/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wonderful-panda/subscriptions","organizations_url":"https://api.github.com/users/wonderful-panda/orgs","repos_url":"https://api.github.com/users/wonderful-panda/repos","events_url":"https://api.github.com/users/wonderful-panda/events{/privacy}","received_events_url":"https://api.github.com/users/wonderful-panda/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249679170","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249679170","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249679170,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY3OTE3MA==","user":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T19:56:12Z","updated_at":"2016-09-26T19:56:12Z","body":"Well, that reproduction is only part of my problem(small lag), sometimes delay gets bigger. But its still same problem.\n","author_association":"NONE","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249679170/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false}},{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249692588","html_url":"https://github.com/vuejs/vue/issues/3771#issuecomment-249692588","issue_url":"https://api.github.com/repos/vuejs/vue/issues/3771","id":249692588,"node_id":"MDEyOklzc3VlQ29tbWVudDI0OTY5MjU4OA==","user":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2016-09-26T20:47:03Z","updated_at":"2016-09-26T22:22:09Z","body":"Sigh, we may need to revert this...\n\nThe primary reason I changed the implementation is because `MutationObserver` (which is the original implementation) is buggy in iOS UIWebView >= 9.3.3 - it simply breaks after scrolling the page for a bit. However in iOS10 sniffing it apart from other environments like WKWebView and native iOS Safari is extremely tricky.\n\n1.0.27 / 2.0.0-rc.7 uses a setImmediate shim using `window.postMessage`, which uses the macrotask queue instead of the microtask queue (used by `MutationObserver`). The difference being that macrotasks are queued after current browser rendering/IO jobs (e.g. repaint on scroll event) while microtasks are queued before that. This leads to the behavior seen in @wonderful-panda 's jsfiddles and the delays seen by @Xelia (most likely associated with heavy repaints on scroll).\n\nI guess we will have to revert to `MutationObserver` with more UIWebView sniffing...\n","author_association":"MEMBER","reactions":{"url":"https://api.github.com/repos/vuejs/vue/issues/comments/249692588/reactions","total_count":10,"+1":10,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null,"event":"commented","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false}},{"id":802906249,"node_id":"MDE0Ok1lbnRpb25lZEV2ZW50ODAyOTA2MjQ5","url":"https://api.github.com/repos/vuejs/vue/issues/events/802906249","actor":{"login":"wonderful-panda","id":1205852,"node_id":"MDQ6VXNlcjEyMDU4NTI=","avatar_url":"https://avatars.githubusercontent.com/u/1205852?v=4","gravatar_id":"","url":"https://api.github.com/users/wonderful-panda","html_url":"https://github.com/wonderful-panda","followers_url":"https://api.github.com/users/wonderful-panda/followers","following_url":"https://api.github.com/users/wonderful-panda/following{/other_user}","gists_url":"https://api.github.com/users/wonderful-panda/gists{/gist_id}","starred_url":"https://api.github.com/users/wonderful-panda/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wonderful-panda/subscriptions","organizations_url":"https://api.github.com/users/wonderful-panda/orgs","repos_url":"https://api.github.com/users/wonderful-panda/repos","events_url":"https://api.github.com/users/wonderful-panda/events{/privacy}","received_events_url":"https://api.github.com/users/wonderful-panda/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"mentioned","commit_id":null,"commit_url":null,"created_at":"2016-09-26T20:47:03Z","performed_via_github_app":null},{"id":802906250,"node_id":"MDE1OlN1YnNjcmliZWRFdmVudDgwMjkwNjI1MA==","url":"https://api.github.com/repos/vuejs/vue/issues/events/802906250","actor":{"login":"wonderful-panda","id":1205852,"node_id":"MDQ6VXNlcjEyMDU4NTI=","avatar_url":"https://avatars.githubusercontent.com/u/1205852?v=4","gravatar_id":"","url":"https://api.github.com/users/wonderful-panda","html_url":"https://github.com/wonderful-panda","followers_url":"https://api.github.com/users/wonderful-panda/followers","following_url":"https://api.github.com/users/wonderful-panda/following{/other_user}","gists_url":"https://api.github.com/users/wonderful-panda/gists{/gist_id}","starred_url":"https://api.github.com/users/wonderful-panda/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/wonderful-panda/subscriptions","organizations_url":"https://api.github.com/users/wonderful-panda/orgs","repos_url":"https://api.github.com/users/wonderful-panda/repos","events_url":"https://api.github.com/users/wonderful-panda/events{/privacy}","received_events_url":"https://api.github.com/users/wonderful-panda/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2016-09-26T20:47:03Z","performed_via_github_app":null},{"id":802906252,"node_id":"MDE0Ok1lbnRpb25lZEV2ZW50ODAyOTA2MjUy","url":"https://api.github.com/repos/vuejs/vue/issues/events/802906252","actor":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"mentioned","commit_id":null,"commit_url":null,"created_at":"2016-09-26T20:47:03Z","performed_via_github_app":null},{"id":802906253,"node_id":"MDE1OlN1YnNjcmliZWRFdmVudDgwMjkwNjI1Mw==","url":"https://api.github.com/repos/vuejs/vue/issues/events/802906253","actor":{"login":"xelia","id":3330700,"node_id":"MDQ6VXNlcjMzMzA3MDA=","avatar_url":"https://avatars.githubusercontent.com/u/3330700?v=4","gravatar_id":"","url":"https://api.github.com/users/xelia","html_url":"https://github.com/xelia","followers_url":"https://api.github.com/users/xelia/followers","following_url":"https://api.github.com/users/xelia/following{/other_user}","gists_url":"https://api.github.com/users/xelia/gists{/gist_id}","starred_url":"https://api.github.com/users/xelia/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/xelia/subscriptions","organizations_url":"https://api.github.com/users/xelia/orgs","repos_url":"https://api.github.com/users/xelia/repos","events_url":"https://api.github.com/users/xelia/events{/privacy}","received_events_url":"https://api.github.com/users/xelia/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"subscribed","commit_id":null,"commit_url":null,"created_at":"2016-09-26T20:47:03Z","performed_via_github_app":null},{"id":803116424,"node_id":"MDEyOkxhYmVsZWRFdmVudDgwMzExNjQyNA==","url":"https://api.github.com/repos/vuejs/vue/issues/events/803116424","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"labeled","commit_id":null,"commit_url":null,"created_at":"2016-09-27T00:24:59Z","label":{"name":"regression","color":"e11d21"},"performed_via_github_app":null},{"id":803116425,"node_id":"MDE0OlVubGFiZWxlZEV2ZW50ODAzMTE2NDI1","url":"https://api.github.com/repos/vuejs/vue/issues/events/803116425","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"unlabeled","commit_id":null,"commit_url":null,"created_at":"2016-09-27T00:24:59Z","label":{"name":"need repro","color":"eb6420"},"performed_via_github_app":null},{"id":803193909,"node_id":"MDE1OlJlZmVyZW5jZWRFdmVudDgwMzE5MzkwOQ==","url":"https://api.github.com/repos/vuejs/vue/issues/events/803193909","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"referenced","commit_id":"43b489b11f81956fc832ddee4121cfd59287cc39","commit_url":"https://api.github.com/repos/vuejs/vue/commits/43b489b11f81956fc832ddee4121cfd59287cc39","created_at":"2016-09-27T02:38:48Z","performed_via_github_app":null},{"id":803213067,"node_id":"MDExOkNsb3NlZEV2ZW50ODAzMjEzMDY3","url":"https://api.github.com/repos/vuejs/vue/issues/events/803213067","actor":{"login":"yyx990803","id":499550,"node_id":"MDQ6VXNlcjQ5OTU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/499550?v=4","gravatar_id":"","url":"https://api.github.com/users/yyx990803","html_url":"https://github.com/yyx990803","followers_url":"https://api.github.com/users/yyx990803/followers","following_url":"https://api.github.com/users/yyx990803/following{/other_user}","gists_url":"https://api.github.com/users/yyx990803/gists{/gist_id}","starred_url":"https://api.github.com/users/yyx990803/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/yyx990803/subscriptions","organizations_url":"https://api.github.com/users/yyx990803/orgs","repos_url":"https://api.github.com/users/yyx990803/repos","events_url":"https://api.github.com/users/yyx990803/events{/privacy}","received_events_url":"https://api.github.com/users/yyx990803/received_events","type":"User","user_view_type":"public","site_admin":false},"event":"closed","commit_id":null,"commit_url":null,"created_at":"2016-09-27T03:12:51Z","state_reason":null,"performed_via_github_app":null},{"actor":{"login":"Ma63d","id":7710875,"node_id":"MDQ6VXNlcjc3MTA4NzU=","avatar_url":"https://avatars.githubusercontent.com/u/7710875?v=4","gravatar_id":"","url":"https://api.github.com/users/Ma63d","html_url":"https://github.com/Ma63d","followers_url":"https://api.github.com/users/Ma63d/followers","following_url":"https://api.github.com/users/Ma63d/following{/other_user}","gists_url":"https://api.github.com/users/Ma63d/gists{/gist_id}","starred_url":"https://api.github.com/users/Ma63d/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ma63d/subscriptions","organizations_url":"https://api.github.com/users/Ma63d/orgs","repos_url":"https://api.github.com/users/Ma63d/repos","events_url":"https://api.github.com/users/Ma63d/events{/privacy}","received_events_url":"https://api.github.com/users/Ma63d/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2017-03-06T07:04:03Z","updated_at":"2017-03-06T07:04:03Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6","repository_url":"https://api.github.com/repos/Ma63d/vue-analysis","labels_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6/labels{/name}","comments_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6/comments","events_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6/events","html_url":"https://github.com/Ma63d/vue-analysis/issues/6","id":212039863,"node_id":"MDU6SXNzdWUyMTIwMzk4NjM=","number":6,"title":"Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！","user":{"login":"Ma63d","id":7710875,"node_id":"MDQ6VXNlcjc3MTA4NzU=","avatar_url":"https://avatars.githubusercontent.com/u/7710875?v=4","gravatar_id":"","url":"https://api.github.com/users/Ma63d","html_url":"https://github.com/Ma63d","followers_url":"https://api.github.com/users/Ma63d/followers","following_url":"https://api.github.com/users/Ma63d/following{/other_user}","gists_url":"https://api.github.com/users/Ma63d/gists{/gist_id}","starred_url":"https://api.github.com/users/Ma63d/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ma63d/subscriptions","organizations_url":"https://api.github.com/users/Ma63d/orgs","repos_url":"https://api.github.com/users/Ma63d/repos","events_url":"https://api.github.com/users/Ma63d/events{/privacy}","received_events_url":"https://api.github.com/users/Ma63d/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":25,"created_at":"2017-03-06T07:04:03Z","updated_at":"2024-01-12T03:03:40Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":82278154,"node_id":"MDEwOlJlcG9zaXRvcnk4MjI3ODE1NA==","name":"vue-analysis","full_name":"Ma63d/vue-analysis","private":false,"owner":{"login":"Ma63d","id":7710875,"node_id":"MDQ6VXNlcjc3MTA4NzU=","avatar_url":"https://avatars.githubusercontent.com/u/7710875?v=4","gravatar_id":"","url":"https://api.github.com/users/Ma63d","html_url":"https://github.com/Ma63d","followers_url":"https://api.github.com/users/Ma63d/followers","following_url":"https://api.github.com/users/Ma63d/following{/other_user}","gists_url":"https://api.github.com/users/Ma63d/gists{/gist_id}","starred_url":"https://api.github.com/users/Ma63d/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Ma63d/subscriptions","organizations_url":"https://api.github.com/users/Ma63d/orgs","repos_url":"https://api.github.com/users/Ma63d/repos","events_url":"https://api.github.com/users/Ma63d/events{/privacy}","received_events_url":"https://api.github.com/users/Ma63d/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/Ma63d/vue-analysis","description":"Vue 源码注释版 及 Vue 源码详细解析","fork":false,"url":"https://api.github.com/repos/Ma63d/vue-analysis","forks_url":"https://api.github.com/repos/Ma63d/vue-analysis/forks","keys_url":"https://api.github.com/repos/Ma63d/vue-analysis/keys{/key_id}","collaborators_url":"https://api.github.com/repos/Ma63d/vue-analysis/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/Ma63d/vue-analysis/teams","hooks_url":"https://api.github.com/repos/Ma63d/vue-analysis/hooks","issue_events_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/events{/number}","events_url":"https://api.github.com/repos/Ma63d/vue-analysis/events","assignees_url":"https://api.github.com/repos/Ma63d/vue-analysis/assignees{/user}","branches_url":"https://api.github.com/repos/Ma63d/vue-analysis/branches{/branch}","tags_url":"https://api.github.com/repos/Ma63d/vue-analysis/tags","blobs_url":"https://api.github.com/repos/Ma63d/vue-analysis/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/Ma63d/vue-analysis/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/Ma63d/vue-analysis/git/refs{/sha}","trees_url":"https://api.github.com/repos/Ma63d/vue-analysis/git/trees{/sha}","statuses_url":"https://api.github.com/repos/Ma63d/vue-analysis/statuses/{sha}","languages_url":"https://api.github.com/repos/Ma63d/vue-analysis/languages","stargazers_url":"https://api.github.com/repos/Ma63d/vue-analysis/stargazers","contributors_url":"https://api.github.com/repos/Ma63d/vue-analysis/contributors","subscribers_url":"https://api.github.com/repos/Ma63d/vue-analysis/subscribers","subscription_url":"https://api.github.com/repos/Ma63d/vue-analysis/subscription","commits_url":"https://api.github.com/repos/Ma63d/vue-analysis/commits{/sha}","git_commits_url":"https://api.github.com/repos/Ma63d/vue-analysis/git/commits{/sha}","comments_url":"https://api.github.com/repos/Ma63d/vue-analysis/comments{/number}","issue_comment_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/comments{/number}","contents_url":"https://api.github.com/repos/Ma63d/vue-analysis/contents/{+path}","compare_url":"https://api.github.com/repos/Ma63d/vue-analysis/compare/{base}...{head}","merges_url":"https://api.github.com/repos/Ma63d/vue-analysis/merges","archive_url":"https://api.github.com/repos/Ma63d/vue-analysis/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/Ma63d/vue-analysis/downloads","issues_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues{/number}","pulls_url":"https://api.github.com/repos/Ma63d/vue-analysis/pulls{/number}","milestones_url":"https://api.github.com/repos/Ma63d/vue-analysis/milestones{/number}","notifications_url":"https://api.github.com/repos/Ma63d/vue-analysis/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/Ma63d/vue-analysis/labels{/name}","releases_url":"https://api.github.com/repos/Ma63d/vue-analysis/releases{/id}","deployments_url":"https://api.github.com/repos/Ma63d/vue-analysis/deployments","created_at":"2017-02-17T09:04:21Z","updated_at":"2025-08-25T06:34:02Z","pushed_at":"2018-08-30T12:13:42Z","git_url":"git://github.com/Ma63d/vue-analysis.git","ssh_url":"git@github.com:Ma63d/vue-analysis.git","clone_url":"https://github.com/Ma63d/vue-analysis.git","svn_url":"https://github.com/Ma63d/vue-analysis","homepage":"","size":142,"stargazers_count":770,"watchers_count":770,"language":"JavaScript","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":100,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":7,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["code-analysis","source-code","vue","vuejs"],"visibility":"public","forks":100,"open_issues":7,"watchers":770,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"前面的文章已经详细记述了Vue的核心执行过程。相当于已经搞定了主线剧情。后续的文章都会对其中没有介绍的细节进行展开。\r\n\r\n现在我们就来讲讲其他支线任务:nextTick和microtask。\r\n\r\nVue的nextTick api的实现部分是Vue里比较好理解的一部分，与其他部分的代码也非常的解耦，因此这一块的相关源码解析文章很多。我本来也不准备单独写博客细说这部分，但是最近偶然在别人的文章中了解到：\r\n每轮次的event loop中，每次执行一个task，并执行完microtask队列中的所有microtask之后，就会进行UI的渲染。但是作者似乎对于这个结论也不是很肯定。而我第一反应就是Vue的$nextTick既然用到了MutationObserver（MO的回调放进的是microtask的任务队列中的），那么是不是也是出于这个考虑呢？于是我想研究了一遍Vue的$nextTick，就可以了解是不是出于这个目的，也同时看能不能佐证UI Render真的是在microtask队列清空后执行的。\r\n\r\n研究之后的结论：我之前对于$nextTick源码的理解完全是错的，以及每轮事件循环执行完所有的microtask，是会执行UI Render的。\r\n\r\n*task/macrotask和microtask的概念自从去年[知乎上有人提出这个问题](https://www.zhihu.com/question/36972010)之后，task和microtask已经被很多同学了解了，我也是当时看到了microtask的内容，现在已经有非常多的中文介绍博客在介绍这部分的知识，最近[这篇火遍掘金、SF和知乎的文章](https://zhuanlan.zhihu.com/p/25407758)，最后也是考了microtask的概念。如果你没有看过task/microtask的内容的话，我还是推荐这篇[英文博客](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)，是绝大多数国内博客的内容来源。*\r\n\r\n## 先说nextTick的具体实现\r\n先用120秒介绍MutationObserver: MO是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。\r\n调用过程很简单，但是有点不太寻常：你需要先给他绑回调：\r\n`var mo = new MutationObserver(callback)`\r\n通过给MO的构造函数传入一个回调，能得到一个MO实例，这个回调就会在MO实例监听到变动时触发。\r\n\r\n这个时候你只是给MO实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，你都还没有设置。而调用他的observer方法就可以完成这一步:\r\n```javascript\r\nvar domTarget = 你想要监听的dom节点\r\nmo.observe(domTarget, {\r\n      characterData: true //说明监听文本内容的修改。\r\n})\r\n```\r\n\r\n一个需要先说的细节是，MutationObserver的回调是放在microtask中执行的。\r\n\r\nok了，现在这个domTarget上发生的文本内容修改就会被mo监听到，mo就会触发你在`new MutationObserver(callback)`中传入的callback。\r\n\r\n现在我们来看Vue.nextTick的源码:\r\n```javascript\r\nexport const nextTick = (function () {\r\n  var callbacks = []\r\n  var pending = false\r\n  var timerFunc\r\n  function nextTickHandler () {\r\n    pending = false\r\n    // 之所以要slice复制一份出来是因为有的cb执行过程中又会往callbacks中加入内容\r\n    // 比如$nextTick的回调函数里又有$nextTick\r\n    // 这些是应该放入到下一个轮次的nextTick去执行的,\r\n    // 所以拷贝一份当前的,遍历执行完当前的即可,避免无休止的执行下去\r\n    var copies = callbacks.slice(0)\r\n    callbacks = []\r\n    for (var i = 0; i < copies.length; i++) {\r\n      copies[i]()\r\n    }\r\n  }\r\n\r\n  /* istanbul ignore if */\r\n  // ios9.3以上的WebView的MutationObserver有bug，\r\n  //所以在hasMutationObserverBug中存放了是否是这种情况\r\n  if (typeof MutationObserver !== 'undefined' && !hasMutationObserverBug) {\r\n    var counter = 1\r\n    // 创建一个MutationObserver,observer监听到dom改动之后后执行回调nextTickHandler\r\n    var observer = new MutationObserver(nextTickHandler)\r\n    var textNode = document.createTextNode(counter)\r\n    // 调用MutationObserver的接口,观测文本节点的字符内容\r\n    observer.observe(textNode, {\r\n      characterData: true\r\n    })\r\n    // 每次执行timerFunc都会让文本节点的内容在0/1之间切换,\r\n    // 不用true/false可能是有的浏览器对于文本节点设置内容为true/false有bug？\r\n    // 切换之后将新值赋值到那个我们MutationObserver观测的文本节点上去\r\n    timerFunc = function () {\r\n      counter = (counter + 1) % 2\r\n      textNode.data = counter\r\n    }\r\n  } else {\r\n    // webpack attempts to inject a shim for setImmediate\r\n    // if it is used as a global, so we have to work around that to\r\n    // avoid bundling unnecessary code.\r\n\t// webpack默认会在代码中插入setImmediate的垫片\r\n    // 没有MutationObserver就优先用setImmediate，不行再用setTimeout\r\n    const context = inBrowser\r\n      ? window\r\n      : typeof global !== 'undefined' ? global : {}\r\n    timerFunc = context.setImmediate || setTimeout\r\n  }\r\n  return function (cb, ctx) {\r\n    var func = ctx\r\n      ? function () { cb.call(ctx) }\r\n      : cb\r\n    callbacks.push(func)\r\n    // 如果pending为true, 就其实表明本轮事件循环中已经执行过timerFunc(nextTickHandler, 0)\r\n    if (pending) return\r\n    pending = true\r\n    timerFunc(nextTickHandler, 0)\r\n  }\r\n})()\r\n\r\n```\r\n\r\n上面这个函数执行过程后生成的那个函数才是nextTick。而这个函数的执行过程就是先初始化pending变量和cb变量，cb用来存放需要执行的回调，pending表示是否把清空回调的nextTickHandler函数加入到异步队列中。\r\n\r\n然后就是创建了一个MO，这个MO监听了一个新创建的文本节点的文本内容变化，同时监听到变化时的回调就是nextTickHandler。nextTickHandler遍历cb数组，把需要执行的cb给拿出来一个个执行了。\r\n\r\n而最后返回出去作为nextTick的那个函数就比较简单了：\r\n```javascript\r\nfunction (cb, ctx) {\r\n    var func = ctx\r\n      ? function () { cb.call(ctx) }\r\n      : cb\r\n    callbacks.push(func)\r\n    // 如果pending为true, 就其实表明本轮事件循环中已经执行过timerFunc(nextTickHandler, 0)\r\n    if (pending) return\r\n    pending = true\r\n    timerFunc(nextTickHandler, 0)\r\n  }\r\n}\r\n```\r\n也就是把传入的回调放入cb数组当中，然后执行`timerFunc(nextTickHandler, 0)`，其实是执行`timerFunc()`，后面传入的两参数没用，在浏览器不支持MO的情况timerFunc才回退到setTimeout，那俩参数才有效果。timerFunc就是把那个被MO监听的文本节点改一下它的内容，这样我改了文本内容，MO就会在当前的所有同步代码完成之后执行回调，从而执行数据更新到DOM上之后的任务。\r\n\r\n\r\n我一开始在看这一段代码时忘记了MutationObserver的回调是在microtask里执行的。而且当时也还没有看过Vue的其他源码，当时的我大体看懂nextTick代码流程之后，形成了如下的理解，而且觉得似乎完美的解释了代码逻辑:\r\nwatcher监听到数据变化之后，会立马去修改dom，接着用户书写的代码里的nextTick被执行，而nextTick内部也是去修改DOM(textNode)，当这个最后修改的textNode修改完成了，触发了MutationObserver的回调，那就意味着，前面的DOM修改也已经完成了，所以nextTick向用户保证的`DOM更新之后再执行用户的回调`就得以实现了。\r\n\r\nDamn，现在看了Batcher的代码和认真反思了以后，立马醒悟，上面的想法完完全全就是一坨狗屎，totally shit！\r\n\r\n首先，一个普遍的常识是DOM Tree的修改是实时的，而修改的Render到DOM上才是异步的。根本不存在什么所谓的等待DOM修改完成，任何时候我在上一行代码里往DOM中添加了一个元素、修改了一个DOM的textContent，你在下一行代码里一定能立马就读取到新的DOM，我知道这个理。但是我还是搞不懂我怎么会产生用`nextTick来保证DOM修改的完成`这样的怪念头。可能那天屎吃得有点多了。\r\n\r\n其次，我们来看看使用nextTick的真正原因：\r\n\r\nVue在两个地方用到了上述nextTick：\r\n* Vue.nextTick和Vue.prototype.$nextTick都是直接使用了这个nextTick\r\n* 在batcher中，也就是watcher观测到数据变化后执行的是`nextTick(flushBatcherQueue)`，`flushBatcherQueue`则负责执行完成所有的dom更新操作。\r\n\r\nBatcher的源码，我在[上一篇文章](http://chuckliu.me/#!/posts/58aefe61820ad92fbbe9a4e0)当中已经详细的分析了，在这里我用一张图来说明它和nextTick的详细处理过程吧。\r\n假设此时Vue实例的模板为:`<div id=\"a\">{{a}}</div>`\r\n\r\n![](http://oddbl4fim.bkt.clouddn.com/17-3-6/32014240-file_1488772702872_be41.png)\r\n\r\n仔细跟踪了代码执行过程我们会发现，真正的去遍历watcher，批处理更新是在microtask中执行的，而且用户在修改数据后自己执行的`nextTick(cb)`也会在此时执行cb，他们都是在同一个microtask中执行。根本就不是我最开始想的那样，把回调放在以后的事件循环中去执行。\r\n\r\n同时，上面这个过程也深切的揭露出Vue nextTick的本质，我不是想要MO来帮我真正监听DOM更改，我只是想要一个异步API，用来在当前的同步代码执行完毕后，执行我想执行的异步回调。\r\n\r\n之所以要这样，是因为用户的代码当中是可能多次修改数据的，而每次修改都会同步通知到所有订阅该数据的watcher，而立马执行将数据写到DOM上是肯定不行的，那就只是把watcher加入数组。等到当前task执行完毕，所有的同步代码已经完成，那么这一轮次的数据修改就已经结束了，这个时候我可以安安心心的去将对监听到依赖变动的watcher完成数据真正写入到DOM上的操作，这样即使你在之前的task里改了一个watcher的依赖100次，我最终只会计算一次value、改DOM一次。一方面省去了不必要的DOM修改，另一方面将DOM操作聚集，可以提升DOM Render效率。\r\n\r\n那为什么一定要用MutationObserver呢？不，并没有一定要用MO，只要是microtask都可以。在最新版的Vue源码里，优先使用的就是`Promise.resolve().then(nextTickHandler)`来将异步回调放入到microtask中（MO在IOS9.3以上的WebView中有bug），没有原生Promise才用MO。\r\n\r\n这充分说明了microtask才是nextTick的本质，MO什么的只是个备胎，要是有比MO优先级更高、浏览器兼容性更好的microtask，那可能就分分钟把MO拿下了。任何一个microtask类型的异步回调都是可以完成现有代码里MO的作用的。甚至脑洞开得大一点，要是现在所有的浏览器都支持yield和generator，那我可以把watcher yield出去，然后在协程里把这个watcher存放队列里，然后协程执行一个会触发microtask回调的函数，再然后协程把函数控制权交回generator，这样也是可以的。不扯了，意图就是告诉你，Vue用的只是microtask而已。\r\n\r\n那问题又来了，为什么一定要microtask？task可以吗？（macrotask和task是一回事哈，[HTML5标准里](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)甚至都没有macrotask这个词）。\r\n\r\n哈，现在刚好有个例子，Vue一开始曾经改过nextTick的实现。我们来看看这两个jsFiddle：[jsfiddle1](https://jsfiddle.net/k6bgu2z6/4/)和[jsfiddle2](https://jsfiddle.net/v9q9L0hw/2/)。\r\n\r\n两个fiddle的实现一模一样，就是让那个绝对定位的黄色元素起到一个fixed定位的效果：绑定scroll事件，每次滚动的时候，计算当前滚动的位置并更改到那个绝对定位元素的top属性上去。大家自己试试滚动几下，对比下效果，你就会发现第一个fiddle中的黄元素是稳定不动的，fixed很好。而后一个fiddle中就有问题了，黄色元素上下晃动，似乎跟不上我们scroll的节奏，总要慢一点，虽然最后停下滚动时位置是对的。\r\n\r\n上述两个例子其实是在这个[issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)中找到的，第一个jsfiddle使用的版本是Vue 2.0.0-rc.6，这个版本的nextTick实现是采用了MO，而后因为IOS9.3的WebView里的MO有bug，于是尤雨溪更改了实现，换成了`window.postMessage`，也就是后一个fiddle所使用的Vue 2.0.0-rc.7。后来尤雨溪了解到`window.postMessage`是将回调放入的macrotask 队列。这就是问题的根源了。\r\n\r\nHTML中的UI事件、网络事件、HTML Parsing等都是使用的task来完成，因此每次scroll事件触发后，在当前的task里只是完成了把watcher加入队列和把清空watcher的flushBatcherQueue作为异步回调传入nextTick。 \r\n\r\n如果nextTick使用的是microtask，那么在task执行完毕之后就会立即执行所有microtask，那么flushBatcherQueue（真正修改DOM）便得以在此时立即完成，而后，当前轮次的microtask全部清理完成时，执行UI rendering，把重排重绘等操作真正更新到DOM上（后文会细说）。（注意，页面的滚动效果并不需要重绘哈。重绘是当你修改了UI样式、DOM结构等等，页面将样式呈现出来，别晕了。）\r\n如果nextTick使用的是task，那么会在当前的task和所有microtask执行完毕之后才在以后的某一次task执行过程中处理flushBatcherQueue，那个时候才真正执行各个指令的修改DOM操作，但那时为时已晚，错过了多次触发重绘、渲染UI的时机。而且浏览器内部为了更快的响应用户UI，内部可能是有多个task queue的：\r\n> For example, a user agent could have one task queue for mouse and key events (the user interaction task source), and another for everything else. The user agent could then give keyboard and mouse events preference over other tasks three quarters of the time, keeping the interface responsive but not starving other task queues, and never processing events from any one task source out of order.\r\n\r\n而UI的task queue的优先级可能更高，因此对于尤雨溪采用的`window.postMessage`，甚至可能已经多次执行了UI的task，都没有执行`window.postMessage`的task，也就导致了我们更新DOM操作的延迟。在重CPU计算、UI渲染任务情况下，这一延迟达到issue观测到的100毫秒到1秒的级别是完全课可能的。因此，使用task来实现nextTick是不可行的，而尤雨溪也撤回了这一次的修改，后续的nextTick实现中，依然是使用的Promise.then和MO。\r\n\r\n## task microtask和每轮event loop之后的UI Render\r\n我最近认真阅读了一下HTML5规范，还是来说一说task和microtask处理完成之后的UI渲染过程，讲一下每次task执行和所有microtask执行完毕后使如何完成UI Render的。\r\n\r\n先上[HTML标准原文](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)：\r\n比较典型的task有如下这些\r\n> * Events\r\n> Dispatching an Event object at a particular EventTarget object is often done by a dedicated task.\r\n*Not all events are dispatched using the task queue, many are dispatched during other tasks.*\r\n> * Parsing\r\n> The HTML parser tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.\r\n> * Callbacks\r\nCalling a callback is often done by a dedicated task.\r\n> * Using a resource\r\nWhen an algorithm fetches a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.\r\n> * Reacting to DOM manipulation\r\nSome elements have tasks that trigger in response to DOM manipulation, e.g. when that element is inserted into the document.\r\n\r\n\r\n此外，还包括setTimeout, setInterval, window.postMessage等等。\r\n*上述Reacting to DOM manipulation并不是说你执行DOM操作时就会把这个DOM操作的执行当成一个task。是那些异步的reacting会被当做task。*\r\n\r\n[HTML5标准：task、microtask和UI render的具体执行过程如下](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)：\r\n> An event loop must continually run through the following steps for as long as it exists:\r\n> 1. Select the oldest task on one of the event loop's task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below.\r\n> 2. Set the event loop's currently running task to the task selected in the previous step.\r\n> 3. Run: Run the selected task.\r\n> 4. Set the event loop's currently running task back to null.\r\n> 5. Remove the task that was run in the run step above from its task queue.\r\n> 6. Microtasks: [Perform a microtask checkpoint.](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint) //这里会执行所有的microtask\r\n> 7. Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.\r\n> 7.1 Let now be the value that would be returned by the Performance object's now() method. \r\n> 7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:\r\n> 7.3 If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context's top-level browsing context is in B.\r\n> 7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.\r\n> 7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]\r\n> 7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]\r\n> 7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]\r\n> 7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]\r\n> 7.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]\r\n> 7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.\r\n> 7.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]\r\n> 7.12 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.\r\n> 8.  If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop's task queues and the WorkerGlobalScope object's closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.\r\n> 9. Return to the first step of the event loop.\r\n\r\n解释一下：第一步，从多个task queue中的一个queue里，挑出一个最老的task。（因为有多个task queue的存在，使得浏览器可以完成我们前面说的，优先、高频率的执行某些task queue中的任务，比如UI的task queue）。\r\n然后2到5步，执行这个task。\r\n第六步， [Perform a microtask checkpoint.](https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint) ，这里会执行完microtask queue中的所有的microtask，如果microtask执行过程中又添加了microtask，那么仍然会执行新添加的microtask，当然，这个机制好像有限制，一轮microtask的执行总量似乎有限制(1000?)，数量太多就执行一部分留下的以后再执行？这里我不太确定。\r\n\r\n第七步，Update the rendering：\r\n7.2到7.4，当前轮次的event loop中关联到的document对象会保持某些特定顺序，这些document对象都会执行需要执行UI render的，但是并不是所有关联到的document都需要更新UI，浏览器会判断这个document是否会从UI Render中获益，因为浏览器只需要保持60Hz的刷新率即可，而每轮event loop都是非常快的，所以没必要每个document都Render UI。\r\n7.5和7.6 run the resize steps/run the scroll steps不是说去执行resize和scroll。每次我们scoll的时候视口或者dom就已经立即scroll了，并把document或者dom加入到 pending scroll event targets中，而run the scroll steps具体做的则是遍历这些target，在target上触发scroll事件。run the resize steps也是相似的，这个步骤是触发resize事件。\r\n7.8和7.9 后续的media query, run CSS animations and send events等等也是相似的，都是触发事件，第10步和第11步则是执行我们熟悉的requestAnimationFrame回调和[IntersectionObserver](http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html?utm_source=tuicool&utm_medium=referral)回调（第十步还是挺关键的,raf就是在这执行的！）。\r\n7.12 渲染UI，关键就在这了。\r\n\r\n第九步 继续执行event loop，又去执行task，microtasks和UI render。\r\n\r\n更新：找到一张图，不过着重说明的是整个event loop，没有细说UI render。\r\n![](https://pic1.zhimg.com/v2-ad1a251cb91d37625185a4fb874494fc_b.png)","reactions":{"url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6/reactions","total_count":19,"+1":16,"-1":0,"laugh":0,"hooray":3,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/Ma63d/vue-analysis/issues/6/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"sl1673495","id":23615778,"node_id":"MDQ6VXNlcjIzNjE1Nzc4","avatar_url":"https://avatars.githubusercontent.com/u/23615778?v=4","gravatar_id":"","url":"https://api.github.com/users/sl1673495","html_url":"https://github.com/sl1673495","followers_url":"https://api.github.com/users/sl1673495/followers","following_url":"https://api.github.com/users/sl1673495/following{/other_user}","gists_url":"https://api.github.com/users/sl1673495/gists{/gist_id}","starred_url":"https://api.github.com/users/sl1673495/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sl1673495/subscriptions","organizations_url":"https://api.github.com/users/sl1673495/orgs","repos_url":"https://api.github.com/users/sl1673495/repos","events_url":"https://api.github.com/users/sl1673495/events{/privacy}","received_events_url":"https://api.github.com/users/sl1673495/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2020-05-21T11:02:30Z","updated_at":"2020-05-21T11:02:30Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/sl1673495/blogs/issues/47","repository_url":"https://api.github.com/repos/sl1673495/blogs","labels_url":"https://api.github.com/repos/sl1673495/blogs/issues/47/labels{/name}","comments_url":"https://api.github.com/repos/sl1673495/blogs/issues/47/comments","events_url":"https://api.github.com/repos/sl1673495/blogs/issues/47/events","html_url":"https://github.com/sl1673495/blogs/issues/47","id":622380785,"node_id":"MDU6SXNzdWU2MjIzODA3ODU=","number":47,"title":"深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调","user":{"login":"sl1673495","id":23615778,"node_id":"MDQ6VXNlcjIzNjE1Nzc4","avatar_url":"https://avatars.githubusercontent.com/u/23615778?v=4","gravatar_id":"","url":"https://api.github.com/users/sl1673495","html_url":"https://github.com/sl1673495","followers_url":"https://api.github.com/users/sl1673495/followers","following_url":"https://api.github.com/users/sl1673495/following{/other_user}","gists_url":"https://api.github.com/users/sl1673495/gists{/gist_id}","starred_url":"https://api.github.com/users/sl1673495/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sl1673495/subscriptions","organizations_url":"https://api.github.com/users/sl1673495/orgs","repos_url":"https://api.github.com/users/sl1673495/repos","events_url":"https://api.github.com/users/sl1673495/events{/privacy}","received_events_url":"https://api.github.com/users/sl1673495/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1525739022,"node_id":"MDU6TGFiZWwxNTI1NzM5MDIy","url":"https://api.github.com/repos/sl1673495/blogs/labels/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96","name":"性能优化","color":"4846af","default":false,"description":""},{"id":1525739587,"node_id":"MDU6TGFiZWwxNTI1NzM5NTg3","url":"https://api.github.com/repos/sl1673495/blogs/labels/%E5%AD%A6%E4%B9%A0","name":"学习","color":"d5e881","default":false,"description":""}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2020-05-21T09:43:04Z","updated_at":"2023-08-09T08:39:32Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":150785917,"node_id":"MDEwOlJlcG9zaXRvcnkxNTA3ODU5MTc=","name":"blogs","full_name":"sl1673495/blogs","private":false,"owner":{"login":"sl1673495","id":23615778,"node_id":"MDQ6VXNlcjIzNjE1Nzc4","avatar_url":"https://avatars.githubusercontent.com/u/23615778?v=4","gravatar_id":"","url":"https://api.github.com/users/sl1673495","html_url":"https://github.com/sl1673495","followers_url":"https://api.github.com/users/sl1673495/followers","following_url":"https://api.github.com/users/sl1673495/following{/other_user}","gists_url":"https://api.github.com/users/sl1673495/gists{/gist_id}","starred_url":"https://api.github.com/users/sl1673495/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/sl1673495/subscriptions","organizations_url":"https://api.github.com/users/sl1673495/orgs","repos_url":"https://api.github.com/users/sl1673495/repos","events_url":"https://api.github.com/users/sl1673495/events{/privacy}","received_events_url":"https://api.github.com/users/sl1673495/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/sl1673495/blogs","description":":book: 全网 100w+ 阅读量的进阶前端技术博客仓库，Vue 源码解析，React 深度实践，TypeScript 进阶艺术，工程化，性能优化实践……","fork":false,"url":"https://api.github.com/repos/sl1673495/blogs","forks_url":"https://api.github.com/repos/sl1673495/blogs/forks","keys_url":"https://api.github.com/repos/sl1673495/blogs/keys{/key_id}","collaborators_url":"https://api.github.com/repos/sl1673495/blogs/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/sl1673495/blogs/teams","hooks_url":"https://api.github.com/repos/sl1673495/blogs/hooks","issue_events_url":"https://api.github.com/repos/sl1673495/blogs/issues/events{/number}","events_url":"https://api.github.com/repos/sl1673495/blogs/events","assignees_url":"https://api.github.com/repos/sl1673495/blogs/assignees{/user}","branches_url":"https://api.github.com/repos/sl1673495/blogs/branches{/branch}","tags_url":"https://api.github.com/repos/sl1673495/blogs/tags","blobs_url":"https://api.github.com/repos/sl1673495/blogs/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/sl1673495/blogs/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/sl1673495/blogs/git/refs{/sha}","trees_url":"https://api.github.com/repos/sl1673495/blogs/git/trees{/sha}","statuses_url":"https://api.github.com/repos/sl1673495/blogs/statuses/{sha}","languages_url":"https://api.github.com/repos/sl1673495/blogs/languages","stargazers_url":"https://api.github.com/repos/sl1673495/blogs/stargazers","contributors_url":"https://api.github.com/repos/sl1673495/blogs/contributors","subscribers_url":"https://api.github.com/repos/sl1673495/blogs/subscribers","subscription_url":"https://api.github.com/repos/sl1673495/blogs/subscription","commits_url":"https://api.github.com/repos/sl1673495/blogs/commits{/sha}","git_commits_url":"https://api.github.com/repos/sl1673495/blogs/git/commits{/sha}","comments_url":"https://api.github.com/repos/sl1673495/blogs/comments{/number}","issue_comment_url":"https://api.github.com/repos/sl1673495/blogs/issues/comments{/number}","contents_url":"https://api.github.com/repos/sl1673495/blogs/contents/{+path}","compare_url":"https://api.github.com/repos/sl1673495/blogs/compare/{base}...{head}","merges_url":"https://api.github.com/repos/sl1673495/blogs/merges","archive_url":"https://api.github.com/repos/sl1673495/blogs/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/sl1673495/blogs/downloads","issues_url":"https://api.github.com/repos/sl1673495/blogs/issues{/number}","pulls_url":"https://api.github.com/repos/sl1673495/blogs/pulls{/number}","milestones_url":"https://api.github.com/repos/sl1673495/blogs/milestones{/number}","notifications_url":"https://api.github.com/repos/sl1673495/blogs/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/sl1673495/blogs/labels{/name}","releases_url":"https://api.github.com/repos/sl1673495/blogs/releases{/id}","deployments_url":"https://api.github.com/repos/sl1673495/blogs/deployments","created_at":"2018-09-28T19:28:09Z","updated_at":"2025-10-30T07:43:57Z","pushed_at":"2023-07-01T03:17:35Z","git_url":"git://github.com/sl1673495/blogs.git","ssh_url":"git@github.com:sl1673495/blogs.git","clone_url":"https://github.com/sl1673495/blogs.git","svn_url":"https://github.com/sl1673495/blogs","homepage":"https://ssh-blog.vercel.app","size":14818,"stargazers_count":3148,"watchers_count":3148,"language":"JavaScript","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":253,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":87,"license":{"key":"other","name":"Other","spdx_id":"NOASSERTION","url":null,"node_id":"MDc6TGljZW5zZTA="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["blog","frontend","javascript","react","typescript","vue","vue3","web"],"visibility":"public","forks":253,"open_issues":87,"watchers":3148,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"## 前言\r\n\r\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\r\n\r\n1. 每一轮 Event Loop 都会伴随着渲染吗？\r\n2. `requestAnimationFrame` 在哪个阶段执行，在渲染前还是后？在 `microTask` 的前还是后？\r\n3. `requestIdleCallback` 在哪个阶段执行？如何去执行？在渲染前还是后？在 `microTask` 的前还是后？\r\n4. `resize`、`scroll` 这些事件是何时去派发的。\r\n\r\n这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 `requestAnimationFrame`，你可能在做一些需求的时候想到了 `requestIdleCallback`，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。\r\n\r\n这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。\r\n\r\n## 事件循环\r\n\r\n我们先依据[HTML 官方规范](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。\r\n\r\n### 定义\r\n\r\n为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环。\r\n\r\n### 流程\r\n\r\n1. 从任务队列中取出一个**宏任务**并执行。\r\n\r\n2. 检查微任务队列，执行并清空**微任务**队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。\r\n\r\n3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 `rendering opportunity` 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）\r\n   - 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。\r\n   - 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。\r\n   - 如果满足以下条件，也会跳过渲染：\r\n     1. 浏览器判断更新渲染不会带来视觉上的改变。\r\n     2. `map of animation frame callbacks` 为空，也就是帧动画回调为空，可以通过 `requestAnimationFrame` 来请求帧动画。\r\n4. 如果上述的判断决定本轮**不需要渲染**，那么**下面的几步也不会继续运行**：\r\n\r\n   > This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.\r\n   > 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 `microTask`的执行，而不会穿插屏幕渲染相关的流程（比如`requestAnimationFrame`，下面会写一个例子）。\r\n\r\n5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 `resize` 方法。\r\n6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 方法。\r\n7. 对于需要渲染的文档，执行帧动画回调，也就是 **`requestAnimationFrame`** 的回调。（后文会详解）\r\n8. 对于需要渲染的文档， 执行 IntersectionObserver 的回调。\r\n9. 对于需要渲染的文档，**重新渲染**绘制用户界面。\r\n10. 判断 `task队列`和`microTask`队列是否都为空，如果是的话，则进行 `Idle` 空闲周期的算法，判断是否要执行 **`requestIdleCallback`** 的回调函数。（后文会详解）\r\n\r\n对于`resize` 和 `scroll`来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据[CSSOM 规范](https://drafts.csswg.org/cssom-view/#scrolling-events)所讲，浏览器会保存一个 `pending scroll event targets`，等到事件循环中的 `scroll`这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize`也是同理。\r\n\r\n可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。\r\n\r\n### 多任务队列\r\n\r\n`task` 队列并不是我们想象中的那样只有一个，根据规范里的描述：\r\n\r\n> An event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.\r\n\r\n事件循环中可能会有**一个或多个**任务队列，这些队列分别为了处理：\r\n\r\n1. 鼠标和键盘事件\r\n2. 其他的一些 Task\r\n\r\n浏览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 `Task`，并且保证不会“饿死”它们。\r\n\r\n这个规范也导致 Vue 2.0.0-rc.7 这个版本 `nextTick` 采用了从微任务 `MutationObserver` 更换成宏任务 `postMessage` 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)。\r\n\r\n目前由于一些“未知”的原因，jsfiddle 的案例打不开了。简单描述一下就是采用了 `task` 实现的 `nextTick`，在用户持续滚动的情况下 `nextTick` 任务被延后了很久才去执行，导致动画跟不上滚动了。\r\n\r\n迫于无奈，尤大还是改回了 `microTask` 去实现 `nextTick`，当然目前来说 `promise.then` 微任务已经比较稳定了，并且 Chrome 也已经实现了 `queueMicroTask` 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 `Promise` 在开销了。\r\n\r\n从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。\r\n\r\n下面的章节中咱们来详细聊聊 `requestIdleCallback` 和 `requestAnimationFrame`。\r\n\r\n## requestAnimationFrame\r\n\r\n> 以下内容中 `requestAnimationFrame`简称为`rAF`\r\n\r\n在解读规范的过程中，我们发现 `requestAnimationFrame` 的回调有两个特征：\r\n\r\n1. 在重新渲染前调用。\r\n2. 很可能在宏任务之后不调用。\r\n\r\n我们来分析一下，为什么要在重新渲染前去调用？因为 `rAF` 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。\r\n\r\n`rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 `setTimeout`的例子来对比。\r\n\r\n### 闪烁动画\r\n\r\n假设我们现在想要快速的让屏幕上闪烁 `红`、`蓝`两种颜色，保证用户可以观察到，如果我们用 `setTimeout` 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。\r\n\r\n```js\r\nsetTimeout(() => {\r\n  document.body.style.background = \"red\"\r\n  setTimeout(() => {\r\n    document.body.style.background = \"blue\"\r\n  })\r\n})\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/172368a480f5f3ef?w=1028&h=902&f=gif&s=269568)\r\n\r\n可以看出这个结果是非常不可控的，如果这两个 `Task` 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。\r\n\r\n如果你把延时调整到 `17ms` 那么重绘的概率会大很多，毕竟这个是一般情况下 `60fps` 的一个指标。但是也会出现很多不绘制的情况，所以并不稳定。\r\n\r\n如果你依赖这个 API 来做动画，那么就很可能会造成「掉帧」。\r\n\r\n接下来我们换成 `rAF` 试试？我们用一个递归函数来模拟 10 次颜色变化的动画。\r\n\r\n```js\r\nlet i = 10\r\nlet req = () => {\r\n  i--\r\n  requestAnimationFrame(() => {\r\n    document.body.style.background = \"red\"\r\n    requestAnimationFrame(() => {\r\n      document.body.style.background = \"blue\"\r\n      if (i > 0) {\r\n        req()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nreq()\r\n```\r\n\r\n这里由于颜色变化太快，`gif` 录制软件没办法截出这么高帧率的颜色变换，所以各位可以放到浏览器中自己执行一下试试，我这边直接抛结论，浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，可以看下 performance 面板记录的表现：\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/172369395743293b?w=792&h=170&f=png&s=36999)\r\n\r\n### 定时器合并\r\n\r\n在第一节解读规范的时候，第 4 点中提到了，定时器宏任务可能会直接跳过渲染。\r\n\r\n按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：\r\n\r\n```js\r\nsetTimeout(() => {\r\n  console.log(\"sto\")\r\n  requestAnimationFrame(() => console.log(\"rAF\"))\r\n})\r\nsetTimeout(() => {\r\n  console.log(\"sto\")\r\n  requestAnimationFrame(() => console.log(\"rAF\"))\r\n})\r\n\r\nqueueMicrotask(() => console.log(\"mic\"))\r\nqueueMicrotask(() => console.log(\"mic\"))\r\n```\r\n\r\n从直觉上来看，顺序是不是应该是：\r\n\r\n```\r\nmic\r\nmic\r\nsto\r\nrAF\r\nsto\r\nrAF\r\n```\r\n\r\n呢？也就是每一个宏任务之后都紧跟着一次渲染。\r\n\r\n实际上不会，浏览器会合并这两个定时器任务：\r\n\r\n```\r\nmic\r\nmic\r\nsto\r\nsto\r\nrAF\r\nrAF\r\n```\r\n\r\n## requestIdleCallback\r\n\r\n### 草案解读\r\n\r\n> 以下内容中 `requestIdleCallback`简称为`rIC`。\r\n\r\n我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。\r\n\r\nReact 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 `postMessage` 实现了一套。\r\n\r\n#### 渲染有序进行\r\n\r\n首先看一张图，很精确的描述了这个 API 的意图：\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/172362067212340f?w=737&h=139&f=png&s=19313)\r\n\r\n当然，这种有序的 `浏览器 -> 用户 -> 浏览器 -> 用户` 的调度基于一个前提，就是我们要把任务切分成比较小的片，不能说浏览器把空闲时间让给你了，你去执行一个耗时 `10s` 的任务，那肯定也会把浏览器给阻塞住的。这就要求我们去读取 `rIC` 提供给你的 `deadline` 里的时间，去动态的安排我们切分的小任务。浏览器信任了你，你也不能辜负它呀。\r\n\r\n#### 渲染长期空闲\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/17236209c86c248f?w=670&h=173&f=png&s=19531)\r\n还有一种情况，也有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，它也就不需要去绘制页面：\r\n这种情况下为什么还是会有 `50ms` 的 `deadline` 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。\r\n\r\nMDN 文档中的[幕后任务协作调度 API ](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API) 介绍的比较清楚，来根据里面的概念做个小实验：\r\n\r\n屏幕中间有个红色的方块，把 MDN 文档中[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的范例部分的动画代码直接复制过来。\r\n\r\n草案中还提到：\r\n\r\n1. 当浏览器判断这个页面对用户不可见时，这个回调执行的频率可能被降低到 10 秒执行一次，甚至更低。这点在解读 EventLoop 中也有提及。\r\n\r\n2. 如果浏览器的工作比较繁忙的时候，不能保证它会提供空闲时间去执行 `rIC` 的回调，而且可能会长期的推迟下去。所以如果你需要保证你的任务在一定时间内一定要执行掉，那么你可以给 `rIC` 传入第二个参数 `timeout`。  \r\n   这会强制浏览器不管多忙，都在超过这个时间之后去执行 `rIC` 的回调函数。所以要谨慎使用，因为它会打断浏览器本身优先级更高的工作。\r\n\r\n3. 最长期限为 50 毫秒，是根据研究得出的，研究表明，人们通常认为 100 毫秒内对用户输入的响应是瞬时的。 将闲置截止期限设置为 50ms 意味着即使在闲置任务开始后立即发生用户输入，浏览器仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。\r\n\r\n4. 每次调用 `timeRemaining()` 函数判断是否有剩余时间的时候，如果浏览器判断此时有优先级更高的任务，那么会动态的把这个值设置为 0，否则就是用预先设置好的 `deadline - now` 去计算。\r\n\r\n5. 这个 `timeRemaining()` 的计算非常动态，会根据很多因素去决定，所以不要指望这个时间是稳定的。\r\n\r\n### 动画例子\r\n\r\n#### 滚动\r\n\r\n如果我鼠标不做任何动作和交互，直接在控制台通过 `rIC` 去打印这次空闲任务的剩余时间，一般都稳定维持在 `49.xx` ms，因为此时浏览器没有什么优先级更高的任务要去处理。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/172367edc582db9c?w=1612&h=978&f=gif&s=460995)\r\n\r\n而如果我不停的滚动浏览器，不断的触发浏览器的重新绘制的话，这个时间就变的非常不稳定了。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/172368088eca1422?w=1612&h=978&f=gif&s=3952633)\r\n\r\n通过这个例子，你可以更加有体感的感受到什么样叫做「繁忙」，什么样叫做「空闲」。\r\n\r\n#### 动画\r\n\r\n这个动画的例子很简单，就是利用`rAF`在每帧渲染前的回调中把方块的位置向右移动 10px。\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\")\r\n      element.style.position = \"absolute\"\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp\r\n        var progress = timestamp - start\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\"\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step)\r\n        }\r\n      }\r\n      // 动画\r\n      window.requestAnimationFrame(step)\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback(() => {\r\n        alert(\"rIC\")\r\n      })\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n注意在最后我加了一个 `requestIdleCallback` 的函数，回调里会 `alert('rIC')`，来看一下演示效果：\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/17235e089ed53d75?w=928&h=432&f=gif&s=51770)\r\n\r\n`alert` 在最开始的时候就执行了，为什么会这样呢一下，想一下「空闲」的概念，我们每一帧仅仅是把 `left` 的值移动了一下，做了这一个简单的渲染，没有占满空闲时间，所以可能在最开始的时候，浏览器就找到机会去调用 `rIC` 的回调函数了。\r\n\r\n我们简单的修改一下 `step` 函数，在里面加一个很重的任务，1000 次循环打印。\r\n\r\n```js\r\nfunction step(timestamp) {\r\n  if (!start) start = timestamp\r\n  var progress = timestamp - start\r\n  element.style.left = Math.min(progress / 10, 200) + \"px\"\r\n  let i = 1000\r\n  while (i > 0) {\r\n    console.log(\"i\", i)\r\n    i--\r\n  }\r\n  if (progress < 2000) {\r\n    window.requestAnimationFrame(step)\r\n  }\r\n}\r\n```\r\n\r\n再来看一下它的表现：\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/17235e0b45c0bd6b?w=928&h=432&f=gif&s=124529)\r\n\r\n其实和我们预期的一样，由于浏览器的每一帧都\"太忙了\",导致它真的就无视我们的 `rIC` 函数了。\r\n\r\n如果给 `rIC` 函数加一个 `timeout` 呢：\r\n\r\n```js\r\n// 空闲调度\r\nwindow.requestIdleCallback(\r\n  () => {\r\n    alert(\"rID\")\r\n  },\r\n  { timeout: 500 },\r\n)\r\n```\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/5/21/17235e30289293f2?w=928&h=432&f=gif&s=89713)\r\n\r\n浏览器会在大概 `500ms` 的时候，不管有多忙，都去强制执行 `rIC` 函数，这个机制可以防止我们的空闲任务被“饿死”。\r\n\r\n## 总结\r\n\r\n通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。\r\n\r\n1. 事件循环**不一定**每轮都伴随着重渲染，但是如果有微任务，一定会伴随着**微任务执行**。\r\n2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。\r\n3. `requestAnimationFrame`在重新渲染屏幕**之前**执行，非常适合用来做动画。\r\n4. `requestIdleCallback`在渲染屏幕**之后**执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 `timeout`参数。\r\n5. `resize`和`scroll`事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 `EventTarget` 上。\r\n\r\n另外，本文也是对于规范的解读，规范里的一些术语比较晦涩难懂，所以我也结合了一些自己的理解去写这篇文章，如果有错误的地方欢迎各位小伙伴指出。\r\n\r\n## 参考资料\r\n\r\n[HTML 规范文档](https://html.spec.whatwg.org/multipage/webappapis.html#task-queue)\r\n\r\n[W3C 标准](https://w3c.github.io/requestidlecallback)\r\n\r\n[Vue 源码详解之 nextTick：MutationObserver 只是浮云，microtask 才是核心！](https://segmentfault.com/a/1190000008589736)（强烈推荐这篇文章）\r\n\r\n## ❤️ 感谢大家\r\n\r\n1.如果本文对你有帮助，就点个赞支持下吧，你的「赞」是我创作的动力。\r\n\r\n2.关注公众号「前端从进阶到入院」即可加我好友，我拉你进「前端进阶交流群」，大家一起共同交流和进步。\r\n\r\n![](https://user-gold-cdn.xitu.io/2020/4/5/17149cbcaa96ff26?w=910&h=436&f=jpeg&s=78195)\r\n","reactions":{"url":"https://api.github.com/repos/sl1673495/blogs/issues/47/reactions","total_count":2,"+1":2,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/sl1673495/blogs/issues/47/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"L-small","id":7886671,"node_id":"MDQ6VXNlcjc4ODY2NzE=","avatar_url":"https://avatars.githubusercontent.com/u/7886671?v=4","gravatar_id":"","url":"https://api.github.com/users/L-small","html_url":"https://github.com/L-small","followers_url":"https://api.github.com/users/L-small/followers","following_url":"https://api.github.com/users/L-small/following{/other_user}","gists_url":"https://api.github.com/users/L-small/gists{/gist_id}","starred_url":"https://api.github.com/users/L-small/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/L-small/subscriptions","organizations_url":"https://api.github.com/users/L-small/orgs","repos_url":"https://api.github.com/users/L-small/repos","events_url":"https://api.github.com/users/L-small/events{/privacy}","received_events_url":"https://api.github.com/users/L-small/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2020-05-23T06:23:14Z","updated_at":"2020-05-23T06:23:14Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/L-small/blog/issues/23","repository_url":"https://api.github.com/repos/L-small/blog","labels_url":"https://api.github.com/repos/L-small/blog/issues/23/labels{/name}","comments_url":"https://api.github.com/repos/L-small/blog/issues/23/comments","events_url":"https://api.github.com/repos/L-small/blog/issues/23/events","html_url":"https://github.com/L-small/blog/issues/23","id":613365682,"node_id":"MDU6SXNzdWU2MTMzNjU2ODI=","number":23,"title":"Vue2解析","user":{"login":"L-small","id":7886671,"node_id":"MDQ6VXNlcjc4ODY2NzE=","avatar_url":"https://avatars.githubusercontent.com/u/7886671?v=4","gravatar_id":"","url":"https://api.github.com/users/L-small","html_url":"https://github.com/L-small","followers_url":"https://api.github.com/users/L-small/followers","following_url":"https://api.github.com/users/L-small/following{/other_user}","gists_url":"https://api.github.com/users/L-small/gists{/gist_id}","starred_url":"https://api.github.com/users/L-small/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/L-small/subscriptions","organizations_url":"https://api.github.com/users/L-small/orgs","repos_url":"https://api.github.com/users/L-small/repos","events_url":"https://api.github.com/users/L-small/events{/privacy}","received_events_url":"https://api.github.com/users/L-small/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-05-06T14:29:37Z","updated_at":"2020-06-14T00:36:02Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":118333464,"node_id":"MDEwOlJlcG9zaXRvcnkxMTgzMzM0NjQ=","name":"blog","full_name":"L-small/blog","private":false,"owner":{"login":"L-small","id":7886671,"node_id":"MDQ6VXNlcjc4ODY2NzE=","avatar_url":"https://avatars.githubusercontent.com/u/7886671?v=4","gravatar_id":"","url":"https://api.github.com/users/L-small","html_url":"https://github.com/L-small","followers_url":"https://api.github.com/users/L-small/followers","following_url":"https://api.github.com/users/L-small/following{/other_user}","gists_url":"https://api.github.com/users/L-small/gists{/gist_id}","starred_url":"https://api.github.com/users/L-small/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/L-small/subscriptions","organizations_url":"https://api.github.com/users/L-small/orgs","repos_url":"https://api.github.com/users/L-small/repos","events_url":"https://api.github.com/users/L-small/events{/privacy}","received_events_url":"https://api.github.com/users/L-small/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/L-small/blog","description":"个人博客","fork":false,"url":"https://api.github.com/repos/L-small/blog","forks_url":"https://api.github.com/repos/L-small/blog/forks","keys_url":"https://api.github.com/repos/L-small/blog/keys{/key_id}","collaborators_url":"https://api.github.com/repos/L-small/blog/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/L-small/blog/teams","hooks_url":"https://api.github.com/repos/L-small/blog/hooks","issue_events_url":"https://api.github.com/repos/L-small/blog/issues/events{/number}","events_url":"https://api.github.com/repos/L-small/blog/events","assignees_url":"https://api.github.com/repos/L-small/blog/assignees{/user}","branches_url":"https://api.github.com/repos/L-small/blog/branches{/branch}","tags_url":"https://api.github.com/repos/L-small/blog/tags","blobs_url":"https://api.github.com/repos/L-small/blog/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/L-small/blog/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/L-small/blog/git/refs{/sha}","trees_url":"https://api.github.com/repos/L-small/blog/git/trees{/sha}","statuses_url":"https://api.github.com/repos/L-small/blog/statuses/{sha}","languages_url":"https://api.github.com/repos/L-small/blog/languages","stargazers_url":"https://api.github.com/repos/L-small/blog/stargazers","contributors_url":"https://api.github.com/repos/L-small/blog/contributors","subscribers_url":"https://api.github.com/repos/L-small/blog/subscribers","subscription_url":"https://api.github.com/repos/L-small/blog/subscription","commits_url":"https://api.github.com/repos/L-small/blog/commits{/sha}","git_commits_url":"https://api.github.com/repos/L-small/blog/git/commits{/sha}","comments_url":"https://api.github.com/repos/L-small/blog/comments{/number}","issue_comment_url":"https://api.github.com/repos/L-small/blog/issues/comments{/number}","contents_url":"https://api.github.com/repos/L-small/blog/contents/{+path}","compare_url":"https://api.github.com/repos/L-small/blog/compare/{base}...{head}","merges_url":"https://api.github.com/repos/L-small/blog/merges","archive_url":"https://api.github.com/repos/L-small/blog/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/L-small/blog/downloads","issues_url":"https://api.github.com/repos/L-small/blog/issues{/number}","pulls_url":"https://api.github.com/repos/L-small/blog/pulls{/number}","milestones_url":"https://api.github.com/repos/L-small/blog/milestones{/number}","notifications_url":"https://api.github.com/repos/L-small/blog/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/L-small/blog/labels{/name}","releases_url":"https://api.github.com/repos/L-small/blog/releases{/id}","deployments_url":"https://api.github.com/repos/L-small/blog/deployments","created_at":"2018-01-21T12:38:49Z","updated_at":"2022-05-19T08:08:28Z","pushed_at":"2022-05-19T08:08:25Z","git_url":"git://github.com/L-small/blog.git","ssh_url":"git@github.com:L-small/blog.git","clone_url":"https://github.com/L-small/blog.git","svn_url":"https://github.com/L-small/blog","homepage":"","size":92,"stargazers_count":6,"watchers_count":6,"language":"HTML","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":43,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":0,"open_issues":43,"watchers":6,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"* [Vue构建](#Vue构建)\r\n* [平台化包装](#平台化包装)\r\n* [Vue初始化和生命周期](#Vue初始化)\r\n* [options合并规则](#options合并)\r\n* [响应式原理](#Vue响应式)\r\n* [nextTick](#nextTick)\r\n* [watch](#watch)\r\n* [computed](#computed)\r\n* [组件和异步组件](#组件和异步组件)\r\n* [组件更新](#组件更新)\r\n* [Diff](#Diff)\r\n* [编译](#编译)\r\n* [虚拟DOM](#Vnode)\r\n* [event](#event)\r\n* [v-model](#v-model)\r\n* [slot](#slot)\r\n* [keep-alive](#keep-alive)\r\n* [动画](#动画)\r\n* [Vue和React区别](#20)\r\n* [Watch和computed的区别](#21)\r\n* [v-key作用](#22)\r\n* [v-if和v-show](#23)\r\n* [data为什么是函数](#24) \r\n* [Vue中slot和slot-scope原理](#25)\r\n\r\n\r\n## <span id=\"Vue构建\">Vue构建（Rollup构建）</span>\r\nVue构建入口都是web/entry-runtime.js，输出格式分为CommonJS、ES6module、UMD，CommonJS是为了browserify和webpack1、ES6module是为了Rollup和webpack2+、UMD是为了直接scriipt引入\r\n\r\nVue分为运行时版本和完整版（运行时版 + Compiler = 完整版）。因为Compiler（将字符串模板编译成Render函数）在构建时完成，拆分开提升运行时性能，又减少了体积。\r\n\r\n入口文件：web/entry-runtime-with-compiler.js\r\n最终输出：dist/vue.js\r\n\r\n\r\n## <span id=\"平台化包装\">Vue平台化包装</span>\r\n此时执行到platforms/web/runtime/index.js中，对Vue进行平台化包装。在原型和构造函数上添加属性和方法\r\n\r\n此时Vue.options已变成\r\n```\r\nVue.options = {\r\n\tcomponents: {\r\n\t\tKeepAlive,\r\n\t\tTransition,\r\n\t\tTransitionGroup\r\n\t},\r\n\tdirectives: {\r\n\t\tmodel,\r\n\t\tshow\r\n\t},\r\n\tfilters: Object.create(null),\r\n\t_base: Vue\r\n}\r\n```\r\n\r\n\r\n\r\n## <span id=\"Vue初始化\">Vue初始化和生命周期</span>\r\nnew Vue()，执行_init方法，并将options传入。\r\n### 初始化\r\n* **生成uid、合并options、initLifecycle**（绑定生命周期状态属性）、**initEvents**（绑定updateComponentListener）、**initRender**（绑定$createElement和_c）\r\n* **调用beforeCreated钩子**\r\n* **initInjections、initState、initProvide**\r\n* **调用created钩子**\r\n* web平台下**调用$mount**\r\n  * 取options的el，判断是否有template，有则将其template（还会判断一下是node节点还是字符串，取el的dom或者innerHTML）放到render中编译。没有template则取其外部outerHTML，如果也没有则外面创建一个div返回。\r\n* **编译**compileToFunctions进行\r\n* 调用核心$mount，**调用$mountComponent**\r\n  * _render给个空注释节点（Comment），**调用beforeMount钩子**\r\n  * 定义updateComponent（包含render和update）\r\n  * 新建渲染Watcher，将updateComponent传入，作为渲染watcher的get。并将包含breforeUpdate的钩子函数作为before放入nextTick任务队列中\r\n  * 新建Watcher时会立即调用get，所以就是调用updateComponent，然后参数中有_render（其中会设置父子关系，$node是父实例），则进行render.call()，渲染了一个空的vnode作为参数传入vm._update（会设置当前活跃的vm实例）。\r\n  * 调用_update，由于是根节点，调用__patch__（createPatchFunction引入不同平台的方法）\r\n  * __patch__中调用，首次没有老节点则createElm（子组件的一系列初始化）生成DOM。替换刚才的空注释点。\r\n* **调用mounted钩子**\r\n\r\n### 数据更新时\r\n* 由于创建渲染watcher的时候传入了before，并将渲染wathcer放入了nextTick任务队列，当数据变化的时候调用flushSchedulerQueue\r\n* 有before时运行before中的**beforeUpdate钩子**，\r\n* 调用wather.run()也就是调用watcher.get()，执行updateComponent那一套流程\r\n* 有keep-alive的激活activateChildComponent，**调用activated钩子**\r\n* **调用updated钩子**\r\n\r\n### 页面销毁时\r\n* 销毁其实是在patch是，当发现老的已经没了，则触发removeVnodes，递归调用的触发子组件的钩子\r\n* 触发组件的destroy方法。依次递归触发的，所以子组件销毁\r\n* 如果没有keep-alive则调用$destroy\r\n  * **调用beforeDestory钩子**\r\n  * 从父节点将组件删除，调用watcher.teardown依次销毁依赖和watcher\r\n  * **调用destoryed钩子**\r\n  * 调用$off\r\n* 有则调用deactivateChildComponent，递归调用，将其里面的子节点不断触发deactivated钩子函数。并不会真实销毁。\r\n\r\n\r\n\r\n### 监听子组件生命周期\r\n```\r\n可通过这种方式监听组件的生命周期\r\n<child\r\n  @hook:beforeCreate=\"handleChildBeforeCreate\"\r\n  @hook:created=\"handleChildCreated\"\r\n  @hook:mounted=\"handleChildMounted\"\r\n  @hook:生命周期钩子\r\n />\r\n```\r\n\r\n\r\n\r\n## <span id=\"options合并\">mergeOptions</span>\r\n主要作用：合并options，并返回一个新的options对象。\r\n\r\n钩子：Vue.config.optionMergeStrategies是一个合并选项的策略对象。给这个对象添加上与自定义选项同名的函数来处理选项合并就好。\r\n\r\n默认策略：子选项不是空则用子选项，否则用父选项\r\n\r\n* el、propsData合并策略：默认策略。\r\n* data合并策略：使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象。子的为基本和父的合并，子没有父有则通过set合并，当是对象则递归调用（防止对象存在新增属性）对象值合并。\r\n  * **为什么data处理成函数：通过函数返回数据对象，保证每个组件实例都有唯一的数据副本。避免组件间相互影响**\r\n  * **为什么不在合并阶段把数据合并好，而在初始化的时候再合并：因为初始化的时候inject和props初始化先于data，这样就可以用props或者inject中的值初始化data中的数据。data选项在初始化的时候才求值**\r\n  * data函数的参数就是当前实例对象\r\n* 生命周期钩子选项合并策略：通过mergeHook函数将合并成数组，使得父子选项中的钩子函数都能够被执行\r\n* direcctives、filters、components（资源assets）合并策略：使用mergeAssets合并。有子组件则通过原型模式合并到父组件的实例上，没有则返回父组件实例。\r\n  * **内置组件的实现方式：mergeAssets的时候，子组件合并的时候会有个__proto__指向父组件原型，上面有KeepAlive、Transition等组件。所以不用显式注册**\r\n* watch的合并策略：没有子类则返回父类实例的watch，有则判断父是否有，子有父有则返回合并函数后的数组（父子的观察者都能执行），子有父没有则返回子的watch函数\r\n* props、methods、inject、computed 的合并策略：返回一个对象。父没有则返回子的，父有子有则合并返回对象，相同建名子覆盖父\r\n* provide的合并策略：mergeDataOrFn函数，同data\r\n* 其他：都是默认策略\r\n\r\nextends和mixins则是递归调用，其中的属性合并根据上面的规则来。\r\n\r\n**mixins中的data、methods等同名会被实例的覆盖原因：data、methods等合并策略都是以子为基本，同名覆盖**\r\n\r\n\r\n\r\n### 规范化options\r\n\r\n由于为了开发方便，options很多属性和方法有多种写法，这就是将父类和子类的options进行合并和规范化。\r\n依次进行如下操作：\r\n* 校验组件名字是否符合要求（不是关键字）\r\n* 规范化props，统一规范为一个props对象，格式如下\r\n```\r\n原语句：\r\nprops: {\r\n  someData1: Number,\r\n  someData2: {\r\n    type: String,\r\n    default: ''\r\n  }\r\n}\r\n合并规范化为：\r\nprops: {\r\n  someData1: {\r\n    type: Number\r\n  },\r\n  someData2: {\r\n    type: String,\r\n    default: ''\r\n  }\r\n}\r\n```\r\n* 规范化inject，统一规范为一个inject对象，格式如下\r\n```\r\n原语句为：\r\ninject: {\r\n  data1: 'data1',\r\n  d2: 'data2',\r\n  data3: { someProperty: 'someValue' }\r\n}\r\n合并规范化：\r\ninject: {\r\n  'data1': { from: 'data1' },\r\n  'd2': { from: 'data2' },\r\n  'data3': { from: 'data3', someProperty: 'someValue' }\r\n}\r\n```\r\n* 规范化directives，\r\n```\r\n原语句为：\r\ndirectives: {\r\n    test1: {\r\n      bind: function () {\r\n        console.log('v-test1')\r\n      }\r\n    },\r\n    test2: function () {\r\n      console.log('v-test2')\r\n    }\r\n  }\r\n合并规范化为：\r\ndirectives: {\r\n  test1: {\r\n    bind: function () {\r\n      console.log('v-test1')\r\n    },\r\n    update: function() {\r\n      console.log('v-test1')\r\n    }\r\n  },\r\n  // ,,test2同上\r\n}\r\n```\r\n* 合并规范化extends，递归mergeOptions将子类options和父类合并\r\n* 合并规范化mixins，循环mixins，递归mergeOptions和父类合并\r\n\r\n\r\n\r\n\r\n## <span id=\"Vue响应式\">Vue响应式原理</span>\r\n前面初始化的时候有提到到initState方法时，有data、computed、watch等的初始化，其中会进行数据响应式绑定。先从initData开始。\r\n\r\n### 流程：\r\n* new Vue的时候经过前面一系列的流程\r\n* 执行initData，通过vm.$option.data拿到data函数返回的data对象\r\n* 校验data是否和props和methods名字冲突\r\n* 将data通过get、set代理到options._data上\r\n* **调用observe，实例化Dep，由于根组件没有Dep.target所以，不会进行依赖绑定，所以get函数只是返回值**。\r\n* 执行到new Watcher新建一个渲染watcher，此时调用watcher的get方法，将Dep.target = 渲染Watcher，push到栈中。\r\n* 渲染函数的get方法中执行getter。渲染watcher是updateComponent，然后执行_render时去初始化子组件。\r\n* 子组件会同样走以上的流程。调用observe，实例化Dep，每个数据都是个dep。直到在子组件的钩子init中调用$mount（keep-alive则用prepatch）\r\n* 此时会创建子组件的渲染watcher，此时又会调用get()，Dep.target = 渲染Watcher，然后将当前渲染Watcher放入栈中，此时再次调用getter。执行updateComponent\r\n* **再到_render，vdom读取值的时候触发数据的get方法，此时栈中有当前子组件的渲染Watcher，Dep.target不为空，然后将读取到的这个变量执行dep.depend()，然后调用子组件的渲染Watcher的addDep，将dep放入渲染Watcher的depIds和deps中，（depIds，newDepIds和deps、newDeps都是当前watcher持有的依赖）。此时同样将watcher放入dep的subs中**。此时渲染watcher和当前数据建立了双向绑定关系。\r\n* 其他子组件依次递归调用完，之后开始执行get后面的，此时再依次出栈，并将此次渲染中用不到的dep清除掉（cleanupDeps），将用到的newDeps再放入deps，newDepsId放入depIds中。\r\n\r\n### 修改时\r\n* 触发Set，然后调用dep的notify，notify将dep的subs中存储的watcher根据其id进行排序（父先子后）\r\n* 遍历触发watcher的update方法。然后添加到nextTick队列中\r\n* 并再次排一次序（父先子后）。然后如果是渲染Watcher则执行传入的before。触发beforeUpdate钩子\r\n* 执行watcher.run()函数，再次调用watcher的get方法，获取最新的值（同样也会对修改后的进行一次依赖的互相绑定）。\r\n* 比较新旧值，然后如果相同则结束，不相同则触发watcher的cb回调函数\r\n\r\n\r\n**同样computed Watcher还有用户Watcher同样也是这样来互相绑定。**\r\n![image](https://user-images.githubusercontent.com/7886671/82753351-75611100-9df7-11ea-9eaa-08fff45488ac.png)\r\n\r\n\r\n\r\n由于methods、data、props都是可以通过实例对象代理访问的。所以为了避免被覆盖所以是不允许重名的。所以属性和方法在实例中定义的优先级：props>data>methods\r\n\r\n通过proxy(vm, `_data`, key)将_data转为访问器属性\r\n\r\n### 基本思路\r\n通过observe(data, true /* asRootData */)将data数据转为响应式的。但被监测数据必须满足五个条件：\r\n* shouldObserve是true（一般是true）\r\n* 判断是否是服务端渲染，不是的时候才会观测\r\n* 数据对象是数组或者纯对象才观测\r\n* 数据对象可扩展\r\n* 不是Vue实例对象\r\n```\r\nconst data: {\r\n  a: 1\r\n}\r\n\r\nfunction walk(data) {\r\n  const dep = [];\r\n  for (const key in data) {\r\n    let val = data[key]\r\n    const nativeString = Object.prototype.toString.call(val);\r\n    // 当多层嵌套的对象时a.b.c，则递归添加依赖\r\n    if (val === '[object Object]') {\r\n      walk(val)\r\n    }\r\n    Object.defineProperties(data, 'a', {\r\n      get() {\r\n        // 收集依赖\r\n        dep.push(target)\r\n        // 返回对应的数据\r\n        return val\r\n      },\r\n      set(newVal) {\r\n        data[key] = newVal\r\n        // 触发所有依赖\r\n        dep.forEach(fn => fn())\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nlet target = null\r\nfunction watch((key, fn) => {\r\n  target = fn\r\n  let pathArr,\r\n      obj = data;\r\n  // 当render函数中有响应式数据时。\r\n  if (typeof key === 'function') {\r\n    key();\r\n    // 执行render函数触发了get，所以直接返回\r\n    return\r\n  }\r\n  // data.a.b多层监听的时候\r\n  if (key.indexOf('.') !== -1) {\r\n    pathArr = key.split('.');\r\n    pathArr.forEach(item => {\r\n      obj = obj[item]\r\n    })\r\n    // 循环读取到真正的值的时候因为已经触发了Get，所以直接return\r\n    return\r\n  }\r\n  // 'a'等一层的时候通过触发get函数来收集依赖\r\n  data[key]\r\n})\r\n```\r\n\r\n\r\n### 渲染函数的依赖收集\r\nupdateComponent渲染函数执行的时候会触发render的执行，渲染函数的执行触发数据的get拦截器，收集依赖（参考Vue响应式原理），当数据变化调用手机的watcher的update方法进行渲染。\r\n\r\n\r\n### 响应式对象\r\n数据对象data添加__ob__属性，__ob__就是创建的observe。__ob__和__ob__.dep的创建就是为了删除属性和添加属性有能力触发依赖\r\n\r\n* 对象：遍历递归，给每个属性都通过defineReactive来变成访问器属性\r\n* 数组：遍历递归，给数组每个元素都通过defineReactive来变成访问器属性\r\n\r\n**$attrs和$listeners不是深度观测**。\r\n```\r\ndata: {\r\n  a: 1\r\n  b: {\r\n    n:2\r\n    __ob__: {\r\n      value: b   指向数据本身\r\n      dep: dep实例对象\r\n      vmCount: 0\r\n    }\r\n  }\r\n  __ob__: {\r\n    value: data  指向数据本身\r\n    dep: dep实例对象\r\n    vmCount: 0\r\n  }\r\n}\r\n```\r\n\r\n### 数组的处理\r\n数组由于索引是非响应的。所以通过变异方法，重写原有的方法，然后通过替换数组的原型来实现。其中新增元素的时候特别根据新增的方法来对新增的数调用observe添加响应。当不支持__proto__这种方式的时候则，通过defineProperty来添加同名的属性，实现同样效果。\r\n```\r\nfunction hello(){\r\n  console.log(1)\r\n}\r\nconst hello1 = hello;\r\nhello = () => {\r\n  console.log('hi')\r\n  hello()\r\n}\r\n```\r\n### Vue.set和Vue.delete\r\n其实就是vm.$set和$delete。大致如下\r\n```\r\nfunction set(target, key, val) {\r\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\r\n    // 超过数组长度splice不生效\r\n    target.length = Math.max(target.length, key)\r\n    target.splice(key, 1, val)   // target.splice(key, 1) delete时\r\n    return val\r\n  }\r\n  if (key in target && !(key in Object.prototype)) {\r\n    // 已经存在该属性\r\n    target[key] = val\r\n    return val\r\n  }\r\n  // **根节点的data不是响应的是为了安全**\r\n  if (target._isVue || (target.__ob__) && target.__ob__).vmCount)) {\r\n    return val\r\n  }\r\n  // 当前目标不是响应的则直接赋值\r\n  if (!target.__ob__) {\r\n    target[key] = val;\r\n    return val\r\n  }\r\n  // 当前对象上没有该属性则新增并转成响应的\r\n  defineReactive(ob.value, key, val)\r\n  ob.dep.notify()\r\n  return  val\r\n}\r\n```\r\n\r\n## <span id=\"虚拟DOM和Diff\">虚拟DOM和Diff</span>\r\n### 虚拟DOM\r\n本质上是个JS对象，是对DOM的轻量级描述。由于DOM属性多，并且有很多操作方法，就比较乱。但是通过虚拟DOM封装一层后，我们只需要关心数据的变化，而不用关心具体的DOM操作。而且当有大量的DOM操作的时候，有时为了性能去做对比，然后复用，但是DOM属性多，很多都是没用的。通过轻量级的JS对象来代替复杂的DOM节点。diff操作就可以转移到JS对象上，可以避免大量的DOM查询。并将渲染过程抽象化，可以适配DOM之外的渲染目标。\r\n\r\n包含的属性（用来操作的一些属性，而不是DOM的属性）：\r\n* tag 当前节点的标签名\r\n* text 文本\r\n* data 当前节点的子节点\r\n* elm 当前节点对应的真实DOM节点\r\n* componentOptions 组件的options\r\n* componentInstance 节点对应的组件实例\r\n* context 编译作用域\r\n* key 节点的key\r\n* parent 父节点\r\n* isComment 是否是注释节点\r\n* isStatic 静态节点\r\n\r\n### Diff流程：\r\n* 当我们修改数据的时候触发Wather的update方法，触发_render()，调用patch\r\n* **patch**时，如果vnode不存在，则直接调用销毁钩子\r\n* 当旧节点没有定义时（其实就是root节点）则直接创建一个新的节点\r\n* sameNode判断是否是相同节点，是则patchVnode新旧节点。否则创建新的，移除旧的\r\n  * **sameNode**判断条件是，key、tag、isComment、定义或未定义的data、还有标签为input其type必须相同。才是相同节点\r\n* **patchVnode**时\r\n  * 如果俩节点相等则直接返回\r\n  * 新旧节点都是静态的，并且key相同并且标记了once或者clone则替换elm（当前虚拟节点对应的真实节点）和componentInstance（当前节点对应的组件的实例）返回\r\n  * 当没有text文本时\r\n    * 新老节点都有子节点时，对子节点进行diff，调用updateChildren\r\n    * 旧节点没有子节点，新的有子节点时。清空elm的文本内容，然后为当前节点加入子节点\r\n    * 当新节点没有子节点，旧节点有时，溢出所有的elm的子节点\r\n    * 当新旧节点都无子节点时，只是文本替换，移除elm中的文本\r\n  * 当新旧节点text不一样时，则替换elm这段文本\r\n* 当vnode有data时，postpatch\r\n  * **updateChildren**\r\n  * 没有oldStartVnode，oldStartIndex++\r\n  * 没有oldEndVnode，oldEndVnode--\r\n  * 判断oldStartVnode和newStartVnode是否是相同节点，是则patchVnode这两个节点，然后++\r\n  * 判断oldEndVnode和newEndVnode是否是相同节点，是则patchVnode这两个节点，然后++\r\n  * 判断oldStartVnode和newEndVnode是否是相同节点，是则patchVnode这两个节点，移动到右边节点。++，--\r\n  * 判断oldEndVnode和newStartVnode是否是相同节点，是则patchVnode这两个节点，移动到左边节点，++，--\r\n  * 没有找到时，根据key生成新旧节点，有key则是map结构，没有则是set。\r\n    * 当新的从老的中没有找到对应的key，则新建节点\r\n    * 当新的从老的中找到key，并取出（后面用完会置为undefined，如果后面此时发现取出的是undefined则证明有重复的key值，确保v-for有唯一的key值）判断是否是相同节点，则进行patchVnode并++，不是则创建新的节点++。\r\n  * 当oldStartInx > oldEndInx时，则老的对比完了，直接将剩下的新的节点放到后面\r\n  * 当newStartInx > newEndInx时，则新的对比完了，把老的剩下的删掉\r\n\r\n### DOM添加属性\r\n由于是虚拟DOM，最后通过一层适配层（各平台操作真实dom的一些方法）。将虚拟DOM变成了真实DOM，当给DOM添加attr、class、style等属性时，依赖虚拟DOM的生命钩子（create，activate，update，remove，destory）。像Attr属性只需要在create和update时更新DOM的属性即可。\r\n\r\n\r\n\r\n\r\n## <span id=\"编译\">编译</span>\r\n在mount的过程中，如果render函数不存在，则会将templeate进行complieToFunctions得到render以及staticRenderFns。render function运行后会返回VNode节点，供页面的渲染以及在update的时候patch。其中compileToFunctions会缓存之前生成的结果，查找时直接返回缓存，修改后也再次缓存。\r\n\r\n主要流程：\r\n* 创建AST，parse解析。通过正则，栈等将template模板中的指令、class、style转成AST。\r\n* 优化AST，optimize优化。标记静态节点，省去patchVnode时比较过程，优化patch性能。\r\n* 生成代码，generate生成。转化成render字符串和staticRenderFns字符串。\r\n最后装成new Funtion(str)执行\r\n\r\n### Parse\r\n* 通过正则表达式去匹配解析模板。通过栈来完成\r\n  * 先取开始标签位置<，执行对应的方法\r\n  * 文本处理\r\n  * 裁剪，完成的裁减掉，不断后移\r\n* 调用回调函数生成AST。\r\n  * start AST元素创建、AST树管理。看是否有XSS注入，各种指令处理\r\n  * end 树管理结束逻辑。取最外层标签\r\n  * chars 文本处理文本AST节点。解析文本中的变量表达式等\r\n  * comment 注释节点。\r\n\r\n### 节点类型\r\n* 1 元素节点\r\n```\r\n{\r\n  type: 1\r\n  attrList\r\n  arrtsMap（map方便查找）\r\n  parent\r\n  children\r\n}\r\n```\r\n* 2 表达式节点\r\n```\r\n{\r\n  type: 2\r\n  expression\r\n  tokens\r\n  text\r\n}\r\n```\r\n* 3 纯文本或注释节点\r\n```\r\n{\r\n  type: 3\r\n  text\r\n}\r\n\r\n{\r\n  type: 3\r\n  text\r\n  isComment: true\r\n}\r\n```\r\n### optimize优化\r\n标记静态节点和静态根\r\n* 判断type，2则是false，3则是true\r\n* 判断1不是bind、slot、component才返回true。并递归判断子节点是不是都是静态\r\n* 制度第1进行标记判断是不是静态根\r\n** 只有一个纯文本节点是不被标记为静态节点的。可能标记了消耗更大 **\r\n\r\n### generate\r\n把前面生成vnode转成代码字符串。然后通过with(this) {return _c('div', {....代码})}。（_c，_v等都是一些渲染、判断等方法，render函数最后返回一个VNode节点，在_update时，经过patch与之间的VNode进行对比，得出差异渲染到真实DOM上）\r\n\r\n\r\n\r\n\r\n## <span id=\"nextTick\">nextTick</span>\r\n![image](https://user-images.githubusercontent.com/7886671/82716311-7136d580-9cc9-11ea-8525-b2469a61b90e.png)\r\n### 异步更新视图的原因\r\n如果代码中出现比如循环触发setter，然后又去频繁操作DOM更新视图，非常消耗性能。而异步更新，将其加入队列时进行一次过滤相同id的watcher保证不会重复加入，提高了性能。\r\n\r\n### 使用微任务原因\r\n微任务早于宏任务，所以在微任务中完成数据更新，当微任务执行完成后开始渲染，可以马上看到UI。如果用宏任务的话，新建一个task做数据更新，那么渲染就会进行两次渲染，才看到UI。首次渲染并没有改变什么，第二次才会根据数据变化改变。\r\n\r\n### MutationObserver监听内容变化的原理\r\n通过创建一个TextNode节点，然后赋值了一个数字，然后监听数字的变化，每次执行的时候的都让数据变化。\r\n```\r\nlet counter = 1\r\nconst observer = new MutationObserver(flushCallbacks)\r\nconst textNode = document.createTextNode(String(counter))\r\nobserver.observe(textNode, {\r\n  characterData: true\r\n})\r\ntimerFunc = () => {\r\n  counter = (counter + 1) % 2\r\n  textNode.data = String(counter)\r\n}\r\n```\r\n\r\n### $nextTick中为什么可以取到DOM\r\n因为nextTick是优先微任务，并可以在回调中拿到更新后的DOM的原因，是因为DOM更新是同步的，如果要获取则会优先重排拿到最新DOM（线程暂时切出去更新完DOM，然后再回来）。可以马上拿到更新后DOM的信息，但是渲染到页面则是在微任务执行完之后的\r\n\r\n\r\n### 给queue排序的原因\r\n* 组件更新的顺序是从父组件到子组件，因为父组件总比子组件优先创建。\r\n* 组件的userWatcher比renderWatcher先运行。因为userWatcher（beforeCreated和create之间创建）比renderWatcher（beforeMounted和mounted之间创建）早创建\r\n* 如果一个组件在父组件watcher运行期间被销毁，他的watcher执行被跳过\r\n\r\n### $nextTick变更历史\r\n一开始用的mutationObserver（兼容性原因）IOS>=9.3.3在页面滚动一点后就中断了，然后用的MessageChannel（是宏任务又出现了显示问题），然后又换成了mutationObserver计数\r\n> [问题](https://github.com/vuejs/vue/issues/3771)\r\n\r\n### $nextTick实现\r\n```\r\nexport let isUsingMicroTask = false\r\nconst callback = []\r\nlet pending = false;\r\n\r\nlet timeFunc\r\n\r\nif (ypeof Promise !== 'undefined') {\r\n  timeFunc = () => {\r\n    Promise.resolve().then(flushCallback)\r\n    isUsingMicroTask = true\r\n  }\r\n} else if (!isIE && typeof MutationObserver !== 'undefined') {\r\n  const observer = new MutationObserver(flushCallbacks)\r\n  const textNode = document.createTextNode(String(counter))\r\n  observer.observe(textNode, {\r\n    characterData: true\r\n  })\r\n  timerFunc = () => {\r\n    counter = (counter + 1) % 2\r\n    textNode.data = String(counter)\r\n  }\r\n  isUsingMicroTask = true\r\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n  timerFunc = () => {\r\n    setImmediate(flushCallbacks)\r\n  }\r\n} else {\r\n  timerFunc = () => {\r\n    setTimeout(flushCallbacks, 0)\r\n  }\r\n}\r\n\r\nfunction flushCallback() {\r\n  pending = false;\r\n  const copies = callbacks.slice(0)\r\n  callbacks.length = 0\r\n  for (let i = 0; i < copies.length; i++) {\r\n    copies[i]()\r\n  }\r\n}\r\n\r\nfunction nextTick(cb, ctx) {\r\n  let _resolve\r\n  callback.push(() => {\r\n    if (cb) {\r\n      try {\r\n        cb.call(ctx)\r\n      } catch (e) {}\r\n    } else if (_resolve) {\r\n      _resolve(ctx)\r\n    }\r\n  })\r\n  if (!pending) {\r\n    pending = true\r\n    timeFunc();\r\n  }\r\n}\r\n```\r\n\r\n## <span id=\"watch\">watch</span>\r\n### 初始化流程：\r\n* initWatch\r\n* 遍历options中的watch，拿到handler（handler可以是数组，进行多个回调）调用createWatcher，其中如果handler是对象则取handler.handler，options改为handler，字符串则直接vm[读取]\r\n* 调用$watch，发现回调函数是对象（上步中的handler.handler）则调用createWatcher，直到handler是字符串\r\n  * user设置为true证明是用户watch\r\n  * new Watcher(vm, expOrFn, cb, options)，expOrFn是watch的data的key，会通过split['.']逐级取出data中数据的get，cb是回调，在wacther.run()中执行。options一般是deep、immediate属性。new Watcher会执行一次get，将userWather放入subs中。如果设置了deep属性，则递归收集此属性下所有依赖。\r\n  * 如果设定了immediate则立即执行回调，并传入vm和watcher.value（前面new Watcher的时候会执行一次get()获取value的值）\r\n\r\n### 修改数据后\r\n* 触发dep.notify，调用watcher的update\r\n* 添加到queueWatcher的nextTick队列\r\n* 执行时，执行watcher.run()\r\n* 先调用get()，判断新旧值是否相同（value是对象时也执行回调或者deep为true），不同则调用回调函数并传入(vm, newvalue, oldvalue)并将值更新为新值\r\n\r\n### watcher频繁变化，更新则只更新一次\r\n在加入queueWatcher时，会通过has对象将watcher的id加入，一旦后面有相同的id则都跳过。\r\n\r\n### watch避免重复求值\r\n调用的时候会求最新的值，然后和watcher保存的老值比较，不同才会触发回调函数\r\n\r\n\r\n\r\n### $watch实现\r\n```\r\nfunction $watch(expOrFn, cb, options) {\r\n  if (typeof cb === 'object') {\r\n    return createWathcer(vm, expOrFn, cb, options)\r\n  }\r\n  options = options || {}\r\n  options.user = true\r\n  const watcher = new Watcher(vm, expOrFn, cb, options)\r\n  if (options.immediate) {\r\n      try {\r\n        cb.call(vm, watcher.value)\r\n      } catch (error) {\r\n        handleError(error, vm, `callback for immediate watcher \"${watcher.expression}\"`)\r\n      }\r\n    }\r\n    // 删除观察\r\n    return function unwatchFn () {\r\n      watcher.teardown()\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n## <span id=\"computed\">computed</span>\r\n本质是通过watcher实现的。initState时调用initComputed\r\n\r\n\r\n### 流程：\r\n* initComputed\r\n* initComputed内部vm绑定一个_computedWatchers\r\n* 遍历options.computed，此时对象声明的则拿响应式绑定的get，函数声明的直接拿函数。\r\n* 实例化一个watcher，传入一个lazy:true。这个watcher则是computedWatcher\r\n* 判断属性是否在实例上已经。在则给提示，不在则调用defineComputed\r\n  * defineComputed判断是否是函数，是函数，则将computed响应式，其函数则为get。是对象则获取对象的get和set设置。这里的get则是处理过后的get，其里面后面会调用evaluate求值，并将执行get时的依赖收集，pushTarget应该就是以栈的形式将这些每级的依赖收集，然后将他们加入到当前wather的依赖中，创建过程并不会对computed求值。\r\n\r\n### render时求值：\r\n\r\nrender时触发computed的get，首次调用dirty为true，调用evaluate求值（求值后dirty为false，后面render再取值时则直接返回上次的值，直到依赖变化才dirty改为true才重新计算），并通过depend将渲染watcher订阅了这个computedWathcer，包含其他computedWatcher时也一样。在触发get时收集起get函数中的依赖（其他的computed和依赖的数据），建立get函数依赖的关联（比如computed依赖的数据，其他的computedWathcer）。\r\n\r\n\r\n### 依赖变化时\r\n\r\n当依赖的数据变化时，触发update，将dirty设置为true，再到render时则进行evaluate求值（dirty恢复false），返回新的computed值。\r\n\r\n### computed为什么可以依赖其他的computed\r\n因为在render时执行get建立了和其他依赖之间的订阅关系。\r\n\r\n\r\n\r\n## <span id=\"组件和异步组件\">组件和异步组件</span>\r\n全局注册组件流程：\r\n* Vue.component()全局注册\r\n* 调用initAssetRegisters\r\n* this.options._base.extend把组件继承，挂载到Vue.options.components上。子组件创建的的时候会合并到vm.$options.components，所以可以全局使用。\r\n* 调用createElement生成组件vnode\r\n\r\n局部注册组件流程：\r\n* Vue实例化时会有合并，将components合并到vm.$options.components上\r\n\r\n异步组件3种方式：\r\n* 工厂函数（require）\r\n```\r\nVue.component('xxx', function (resolve, reject) {\r\n  require(['xxx'], function (res) {\r\n    resolve(res)\r\n  })\r\n})\r\n```\r\n* Promise.then处理\r\n```\r\nVue.component('xxx', () => import('xxx'))\r\n```\r\n* 高级异步组件\r\n```\r\nconst asyncComp = () => {\r\n  component: import('xxx'),\r\n  loading: loadingComp, // 加载正式组件前的loading组件\r\n  error: errorComp,  // 加载出错展示的组件\r\n  delay:  200  // 渲染加载中组件前等待时间\r\n  timeout: 1000  // 加载超时\r\n}\r\n```\r\n\r\n一般异步组件流程：\r\n1、 createElement时，因为不是一个对象，所以不会进行Vue.extend，调用resolveAsyncComponent，此时先走到第2步，加载完成后到第3步\r\n2、 setTimeout异步加载组件，此时先生成一个空注释节点占位符。\r\n3、 加载完成，然后进行Vue.extend，由于Vue是数据驱动，但是没有数据变化，所以用forceUpdate一下，强制更新wathcer.update，让渲染watcher重新渲染一下（不能确保异步组件加载过程中是否发生变化，让组件重新渲染）\r\n\r\n高级组件流程（同上）：\r\n* 先loading组件展示\r\n* 如果成功则正式组件、失败则失败组件\r\n\r\n* 一般异步组件有2次渲染，依次是生成空的注释节点，另一次是加载完成后\r\n* 高级组件则是至少3次：首先生成注释节点、调用loading组件、正式组件或者错误组件\r\n\r\n\r\n## <span id=\"event\">event</span>\r\n解析：\r\n* 去掉事件修饰符，生成一个对象\r\n* 去掉v-on @ \r\n* 此时添加事件和修饰符，判断是自定义事件还是原生事件\r\n* 返回一个包含event的对象，包含事件描述\r\n\r\n### 事件中的$event\r\n因为包裹了一层返回，'function($event){clickHandle($event)}\r\n### 有修饰符\r\n比如prevent转成'$event.preventDefault(); function() {xxx}'\r\n### 最终返回\r\n整体包裹：function($event){修饰符转化后的代码;事件转化后的代码 }\r\nfunction ($event) { '$event.preventDefault(); function() {xxx} }\r\n\r\n### 原生事件\r\n解析出事件后用addEventListener添加事件，并让事件回调走宏任务。once修饰符执行完删除事件\r\n### 自定义事件\r\n将事件都放到$on('event', Array)中，event是事件、会判断_events中是否已经存在，Array则是执行的事件\r\n###  $emit 原理\r\n派发给子组件的其实是在父组件创建子组件是继承过去的vm._events，当执行$emit时回调函数的环境实际上是父组件中的，调用的是父实例中的_events\r\n\r\n\r\n## <span id=\"v-model\">v-model</span>\r\n原理：使用了表单的input事件和并通过props传入值value。并加上了compositionStart和compositionEnd事件（处理输入法）\r\n\r\n实际上给组件添加了一个vm.model属性，然后可以定义prop和event事件\r\n\r\n## <span id=\"v-model\">slot</span>\r\n父级模板的所有内容都是在父级作用域中编译的，子模板里的所有内容都是在子作用域中编译的\r\n### 普通插槽\r\n父编译和渲染时生成Vnode，所以作用域是父组件实例，子组件渲染是直接拿渲染好的vnode\r\n### 作用域插槽\r\n父组件编译渲染时不会直接生成vnode，而是在父节点的vnode中保留一个scopeslot对象，存储着不同名字的插槽以及他们的渲染函数，然后在子组件渲染时才执行渲染函数生成vnode\r\n### 父组件变化怎么触发子组件渲染\r\n通过$forceUpdate\r\n### 作用域插槽原理\r\n子节点生成并不是在父组件编译阶段，将其作为一个函数保留，在子组件创建时候才去执行这个函数，就可以获得子组件环境，slot-scope作为参数传入函数。\r\n\r\n## <span id=\"keep-alive\">keep-alive</span>\r\n是抽象组件，不会进入父子链中。渲染时直接render渲染。通过插槽实现的\r\n```\r\n{\r\n  name: keep-alive\r\n  abstract: true\r\n  created() {\r\n    this.cache 保存缓存\r\n    this.keys 缓存的key\r\n  }\r\n  props: { \r\n    include 需要缓存的\r\n    exclude 不需要缓存的\r\n    max 缓存最大值\r\n  },\r\n  mounted() {\r\n    this.$watch('include') 回调函数处理缓存\r\n    this.$watch('exclude')回调函数匹配到cache中有则去掉换内存\r\n  }\r\n  render() {\r\n    1、拿第一个组件节点\r\n    2、判断是否已经缓存，没有则把vnode加入缓存\r\n    3、当大于max时，对cache进行优化。不常用的去掉（队列）\r\n  }\r\n}\r\n```\r\n\r\n## <span id=\"动画\">动画</span>\r\n过渡动画通过在对应的钩子（beforeEnterHook）中修改class来实现\r\n\r\n\r\n\r\n### 渲染\r\n首次渲染：createComponent、缓存子组件\r\n二次：patch、prepatch、重新计算$slot、$forceUpdate、拿cache中的patch、插入（由于有缓存所以不走createComponent所以也不会执行mounted和created）\r\n\r\n\r\n## Vue性能追踪的四个场景\r\n* 组件初始化 component init\r\n* 编译compiler，将模板编译成渲染函数的性能\r\n* 渲染render，渲染函数执行生成虚拟DOM的性能\r\n* 打补丁patch，将虚拟DOM渲染为真实DOM的性能\r\n\r\n\r\n## <span id=\"20\">Vue和React的区别</span>\r\n相同点：\r\n* 都是单向数据流（vue的表单是双向数据绑定）\r\n* 都是虚拟DOM\r\n\r\nVue：声明式。Template。\r\n\r\nReact：函数式。JSX。\r\n\r\n## <span id=\"21\">watch和computed区别</span>\r\nWatch：当数据变化的时执行异步操作或者开销较大的操作时有价值。\r\n\r\ncomputed：计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生变化才重新求值。可解决一些模板中复杂的逻辑操作。\r\n\r\n## <span id=\"22\">v-key作用</span>\r\n在Vue虚拟DOM算法在新旧节点对比时识别VNode，如果不使用v-key，Vue会默认采用就地复用。使用key的时候会根据key值重新排列元素顺序，并且会移除key不存在的元素。当需要完整的触发组件的生命周期钩子或者transition时需要用key。\r\n\r\n## <span id=\"23\">v-if和v-show</span>\r\nv-if：有更高的切换开销。\r\n\r\nv-show：有更高的初始渲染开销。切换则只是简单的切换元素的display\r\n\r\n## <span id=\"24\">data为什么是函数</span>\r\n因为组件的复用，是函数每个实例可以维护一份被返回对象的独立拷贝。\r\n\r\n\r\n## <span id=\"25\">Vue中slot和slot-scope原理</span>\r\n* 在组件内部都被整合成了函数\r\n* 他们的渲染作用域都是子组件\r\n* 并且都能通过 this.$scopedSlots去访问\r\n\r\n```\r\n<test>\r\n  <template v-slot:bar>\r\n    <span>Hello</span>\r\n  </template>\r\n  <template v-slot:foo=\"prop\">\r\n    <span>{{prop.msg}}</span>\r\n  </template>\r\n</test>\r\n```\r\n编译完成后\r\n```\r\nwith (this) {\r\n  return _c(\"test\", {\r\n    scopedSlots: _u([\r\n      {\r\n        key: \"bar\",\r\n        fn: function () {\r\n          return [_c(\"span\", [_v(\"Hello\")])];\r\n        },\r\n      },\r\n      {\r\n        key: \"foo\",\r\n        fn: function (prop) {\r\n          return [_c(\"span\", [_v(_s(prop.msg))])];\r\n        },\r\n      },\r\n    ]),\r\n  });\r\n}\r\n```\r\ntest组件则会编译成\r\n```\r\nwith (this) {\r\n  return _c(\"div\", [_t(\"bar\"), _t(\"foo\", null, null, { msg })], 2);\r\n}\r\n```\r\n_t是renderSlot别名\r\n```\r\nexport function renderSlot (\r\n  name: string,\r\n  fallback: ?Array<VNode>,\r\n  props: ?Object,\r\n  bindObject: ?Object\r\n): ?Array<VNode> {\r\n  // 通过 name 拿到函数\r\n  const scopedSlotFn = this.$scopedSlots[name]\r\n  let nodes\r\n  if (scopedSlotFn) { // scoped slot\r\n    props = props || {}\r\n    // 执行函数返回 vnode\r\n    nodes = scopedSlotFn(props) || fallback\r\n  }\r\n  return nodes\r\n}\r\n```\r\n普通插槽则直接返回vnode，如果是作用域插槽则会带着props去生成vnode","reactions":{"url":"https://api.github.com/repos/L-small/blog/issues/23/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/L-small/blog/issues/23/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"HannibalKcc","id":26264400,"node_id":"MDQ6VXNlcjI2MjY0NDAw","avatar_url":"https://avatars.githubusercontent.com/u/26264400?v=4","gravatar_id":"","url":"https://api.github.com/users/HannibalKcc","html_url":"https://github.com/HannibalKcc","followers_url":"https://api.github.com/users/HannibalKcc/followers","following_url":"https://api.github.com/users/HannibalKcc/following{/other_user}","gists_url":"https://api.github.com/users/HannibalKcc/gists{/gist_id}","starred_url":"https://api.github.com/users/HannibalKcc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/HannibalKcc/subscriptions","organizations_url":"https://api.github.com/users/HannibalKcc/orgs","repos_url":"https://api.github.com/users/HannibalKcc/repos","events_url":"https://api.github.com/users/HannibalKcc/events{/privacy}","received_events_url":"https://api.github.com/users/HannibalKcc/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2020-07-01T10:33:58Z","updated_at":"2020-07-01T10:33:58Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17","repository_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io","labels_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17/labels{/name}","comments_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17/comments","events_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17/events","html_url":"https://github.com/HannibalKcc/HannibalKcc.github.io/issues/17","id":648870067,"node_id":"MDU6SXNzdWU2NDg4NzAwNjc=","number":17,"title":"2020/07-01——简单学习 vue 源码","user":{"login":"HannibalKcc","id":26264400,"node_id":"MDQ6VXNlcjI2MjY0NDAw","avatar_url":"https://avatars.githubusercontent.com/u/26264400?v=4","gravatar_id":"","url":"https://api.github.com/users/HannibalKcc","html_url":"https://github.com/HannibalKcc","followers_url":"https://api.github.com/users/HannibalKcc/followers","following_url":"https://api.github.com/users/HannibalKcc/following{/other_user}","gists_url":"https://api.github.com/users/HannibalKcc/gists{/gist_id}","starred_url":"https://api.github.com/users/HannibalKcc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/HannibalKcc/subscriptions","organizations_url":"https://api.github.com/users/HannibalKcc/orgs","repos_url":"https://api.github.com/users/HannibalKcc/repos","events_url":"https://api.github.com/users/HannibalKcc/events{/privacy}","received_events_url":"https://api.github.com/users/HannibalKcc/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2020-07-01T10:30:27Z","updated_at":"2020-07-01T10:33:58Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":176233298,"node_id":"MDEwOlJlcG9zaXRvcnkxNzYyMzMyOTg=","name":"HannibalKcc.github.io","full_name":"HannibalKcc/HannibalKcc.github.io","private":false,"owner":{"login":"HannibalKcc","id":26264400,"node_id":"MDQ6VXNlcjI2MjY0NDAw","avatar_url":"https://avatars.githubusercontent.com/u/26264400?v=4","gravatar_id":"","url":"https://api.github.com/users/HannibalKcc","html_url":"https://github.com/HannibalKcc","followers_url":"https://api.github.com/users/HannibalKcc/followers","following_url":"https://api.github.com/users/HannibalKcc/following{/other_user}","gists_url":"https://api.github.com/users/HannibalKcc/gists{/gist_id}","starred_url":"https://api.github.com/users/HannibalKcc/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/HannibalKcc/subscriptions","organizations_url":"https://api.github.com/users/HannibalKcc/orgs","repos_url":"https://api.github.com/users/HannibalKcc/repos","events_url":"https://api.github.com/users/HannibalKcc/events{/privacy}","received_events_url":"https://api.github.com/users/HannibalKcc/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/HannibalKcc/HannibalKcc.github.io","description":null,"fork":false,"url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io","forks_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/forks","keys_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/keys{/key_id}","collaborators_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/teams","hooks_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/hooks","issue_events_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/events{/number}","events_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/events","assignees_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/assignees{/user}","branches_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/branches{/branch}","tags_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/tags","blobs_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/git/refs{/sha}","trees_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/git/trees{/sha}","statuses_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/statuses/{sha}","languages_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/languages","stargazers_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/stargazers","contributors_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/contributors","subscribers_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/subscribers","subscription_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/subscription","commits_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/commits{/sha}","git_commits_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/git/commits{/sha}","comments_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/comments{/number}","issue_comment_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/comments{/number}","contents_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/contents/{+path}","compare_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/compare/{base}...{head}","merges_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/merges","archive_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/downloads","issues_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues{/number}","pulls_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/pulls{/number}","milestones_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/milestones{/number}","notifications_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/labels{/name}","releases_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/releases{/id}","deployments_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/deployments","created_at":"2019-03-18T08:07:03Z","updated_at":"2023-03-07T10:15:26Z","pushed_at":"2021-06-14T16:06:44Z","git_url":"git://github.com/HannibalKcc/HannibalKcc.github.io.git","ssh_url":"git@github.com:HannibalKcc/HannibalKcc.github.io.git","clone_url":"https://github.com/HannibalKcc/HannibalKcc.github.io.git","svn_url":"https://github.com/HannibalKcc/HannibalKcc.github.io","homepage":null,"size":387,"stargazers_count":2,"watchers_count":2,"language":null,"has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":true,"has_discussions":false,"forks_count":2,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":159,"license":{"key":"gpl-3.0","name":"GNU General Public License v3.0","spdx_id":"GPL-3.0","url":"https://api.github.com/licenses/gpl-3.0","node_id":"MDc6TGljZW5zZTk="},"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":2,"open_issues":159,"watchers":2,"default_branch":"jekyll","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"### vue dom 的批量更新\r\nvue dom 的批量更新早有耳闻，但尚未清楚具体实现的 API （setTimeout ?）\r\n查阅部分资料得知应该从 `Watcher` 下手  [Watcher](https://github.com/vuejs/vue/blob/ec78fc8b6d03e59da669be1adf4b4b5abf670a34/src/core/observer/watcher.js#L26)\r\n\r\n聚焦方法 update ，通过查询其引用—— `this.$watch` 、 `initComputed` 得知，默认情况下 `this.sync` 为 false。\r\n```\r\nupdate () {\r\n    /* istanbul ignore else */\r\n    if (this.lazy) {\r\n      this.dirty = true\r\n    } else if (this.sync) {\r\n      this.run()\r\n    } else {\r\n      queueWatcher(this)\r\n    }\r\n  }\r\n```\r\n\r\n然后深究 `ququeWatcher` 里面最终调用了\r\n```\r\n // xxx\r\nnextTick(flushSchedulerQueue); // vm.$nextTick 的底层实现，也是用的这个 nextTick 方法\r\n```\r\n\r\n**结论：vue 的批量更新使用的是 `nextTick` 方法（`nextTick` 的实现方法下节再说），这同时也解释了，为什么 `vm.$nextTick` 总能在 dom 更新之后正确的调用其回调函数**\r\n\r\n\r\n### nextTick 的具体实现\r\n[nextTick](https://github.com/vuejs/vue/blob/v2.6.11/src/core/util/next-tick.js)\r\n关注重点——`flushCallbacks` 、 `timerFunc`，后者是 `nextTick` 的具体实现方式，追踪其赋值地发现了所有 `nextTick` 的实现方式。顺序如下：\r\n\r\n1. promise.then()\r\n2. MutationObserver 没见过的 API 。看了下，很给力 [mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)\r\n3. setImmediate\r\n4. setTimeout\r\n\r\n### nextTick 2.6 小插曲\r\n因为某个 bug 2.6 决定重新使用微任务作为 `nextTick` 的首选实现方案\r\n[issue 3771](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)\r\n\r\n### 参考资料\r\n\r\n[代码](https://codesandbox.io/s/vue-yuanmachutan-y5z0v?file=/src/App.vue)\r\n[参考1](https://libin1991.github.io/2017/10/21/%E9%9D%A2%E8%AF%95%E4%B9%8BVue-nextTick%E5%8E%9F%E7%90%86/)\r\n[参考2](https://github.com/sl1673495/blogs/issues/47)\r\n","reactions":{"url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/HannibalKcc/HannibalKcc.github.io/issues/17/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2021-07-15T08:01:15Z","updated_at":"2021-07-15T08:01:15Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/54","id":939419432,"node_id":"MDU6SXNzdWU5Mzk0MTk0MzI=","number":54,"title":"安宁宝典","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":688950687,"node_id":"MDU6TGFiZWw2ODg5NTA2ODc=","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/blog","name":"blog","color":"1677ff","default":false,"description":"博客文章"},{"id":6552343574,"node_id":"LA_kwDOBiJZIc8AAAABhozUFg","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/interview","name":"interview","color":"79D677","default":false,"description":"分类-面试题相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":0,"created_at":"2021-07-08T03:00:08Z","updated_at":"2024-04-08T05:23:56Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":102914337,"node_id":"MDEwOlJlcG9zaXRvcnkxMDI5MTQzMzc=","name":"hankliu62.github.com","full_name":"hankliu62/hankliu62.github.com","private":false,"owner":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/hankliu62/hankliu62.github.com","description":"🥭 hankliu's blog ","fork":false,"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","forks_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/forks","keys_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/keys{/key_id}","collaborators_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/teams","hooks_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/hooks","issue_events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/events{/number}","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/events","assignees_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/assignees{/user}","branches_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/branches{/branch}","tags_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/tags","blobs_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/refs{/sha}","trees_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/trees{/sha}","statuses_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/statuses/{sha}","languages_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/languages","stargazers_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/stargazers","contributors_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/contributors","subscribers_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/subscribers","subscription_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/subscription","commits_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/commits{/sha}","git_commits_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/commits{/sha}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/comments{/number}","issue_comment_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/comments{/number}","contents_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/contents/{+path}","compare_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/compare/{base}...{head}","merges_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/merges","archive_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/downloads","issues_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues{/number}","pulls_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/pulls{/number}","milestones_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/milestones{/number}","notifications_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels{/name}","releases_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/releases{/id}","deployments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/deployments","created_at":"2017-09-09T00:13:03Z","updated_at":"2025-01-01T01:45:55Z","pushed_at":"2025-01-01T01:46:42Z","git_url":"git://github.com/hankliu62/hankliu62.github.com.git","ssh_url":"git@github.com:hankliu62/hankliu62.github.com.git","clone_url":"https://github.com/hankliu62/hankliu62.github.com.git","svn_url":"https://github.com/hankliu62/hankliu62.github.com","homepage":"http://hankliu62.github.io","size":5802,"stargazers_count":8,"watchers_count":8,"language":"JavaScript","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":true,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":132,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":0,"open_issues":132,"watchers":8,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"# 安宁宝典\r\n\r\n## 一、Event Loop\r\n\r\nEvent Loop即事件循环，是指浏览器或者Nodejs解决javascript单线程运行时不会阻塞的一种机制，使用异步的原理。\r\n\r\nEvent Loop是一个执行模型，不同的运行环境有不同的实现，浏览器和nodejs基于不同的技术实现自己的event loop。\r\n\r\n- 浏览器的Event Loop是在HTML5规范中明确定义。\r\n- Nodejs的Event Loop是libuv实现的。\r\n- libuv已经对Event Loop作出了实现，HTML5规范中只是定义的浏览器中Event Loop的模型，具体的实现交给了浏览器厂商。\r\n\r\n### 宏队列和微队列\r\n\r\n在javascript中，任务被分为两种，一种为宏任务(macrotask)，也称为task，一种为微任务(microtask)，也称为jobs。\r\n\r\n宏任务主要包括:\r\n\r\n- script全部代码\r\n- setTimeout\r\n- setInterval\r\n- setImmediate (Nodejs独有，浏览器暂时不支持，只有IE10支持)\r\n- requestAnimationFrame (浏览器独有)\r\n- I/O\r\n- UI rendering (浏览器独有)\r\n\r\n微任务主要包括:\r\n\r\n- process.nextTick (Nodejs独有)\r\n- Promise\r\n- Object.observe (废弃)\r\n- MutationObserver\r\n\r\n### 浏览器中的Event Loop\r\n\r\nJavascript 有一个主线程 main thread 和 一个调用栈(执行栈) call-stack，所有任务都会被放到调用栈等待主线程的执行。\r\n\r\nJS调用栈采用的是后进先出的规则，当函数执行时，会被添加到调用栈的顶部，当执行栈执行完后，就会从栈顶移除，直到栈内被清空。\r\n\r\nJavascript单线程任务可以分为同步任务和异步任务，同步任务会在调用栈内按照顺序依次被主线程执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空的时候），被读取到调用栈内等待主线程的执行\r\n\r\n任务队列 Task Queue, 是先进先出的数据结构。\r\n\r\n![浏览器事件循环的进程模型](https://user-images.githubusercontent.com/8088864/124855609-c2904a00-dfdb-11eb-9138-df80150fa3a3.jpg)\r\n\r\n浏览器Event Loop的具体流程:\r\n\r\n1. 执行全局Javascript的同步代码，可能包含一些同步语句，也可以是异步语句(setTimeout语句不执行回调函数里面的，Promise中.then之前的语句)\r\n2. 全局Javascript执行完毕后，调用栈call-stack会被清空\r\n3. 从微队列microtask queue中取出位于首部的回调函数，放入到调用栈call-stack中执行，执行完毕后从调用栈中删除，microtask queue的长度减1。\r\n4. 继续从微队列microtask queue的队首取出任务，放到调用栈中执行，依次循环往复，直至微任务队列microtask queue中的任务都被调用栈执行完毕。**特别注意，如果在执行微任务microtask过程中，又产生了微任务microtask，新产生的微任务也会追加到微任务队列microtask queue的尾部，新生成的微任务也会在当前周期中被执行完毕。**\r\n5. microtask queue中的任务都被执行完毕后，microtask queue为空队列，调用栈也处于空闲阶段\r\n6. 执行UI rendering\r\n7. 从宏队列macrotask queue的队首取出宏任务，放入调用栈中执行。\r\n8. 执行完后，调用栈为空闲状态\r\n9. 重复 3 - 8 的步骤，直至宏任务队列的任务都被执行完毕。\r\n...\r\n\r\n浏览器Event Loop的3个重点:\r\n\r\n1. 宏队列macrotask queue每次只从中取出一个任务放到调用栈中执行，执行完后去执行微任务队列中的所有任务\r\n2. 微任务队列中的所有任务都会依次取出来执行，只是微任务队列中的任务清空\r\n3. UI rendering 的执行节点在微任务队列执行完毕后，宏任务队列中取出任务执行之前执行\r\n\r\n### NodeJs中的Event Loop\r\n\r\nlibuv结构\r\n\r\n![libuv的事件循环模型](https://user-images.githubusercontent.com/8088864/125010304-d64db600-e098-11eb-824f-de433a12a095.png)\r\n\r\nNodeJs中的宏任务队列和微任务队列\r\n\r\nNodeJs的Event Loop中，执行宏任务队列的回调有6个阶段\r\n\r\n![NodeJS中的宏队列执行回调的6个阶段](https://user-images.githubusercontent.com/8088864/125010342-e9608600-e098-11eb-84e0-70a5bd5f5867.png)\r\n\r\nNode的Event Loop可以分为6个阶段，各个阶段执行的任务如下所示:\r\n\r\n- `timers`: 执行setTimeout和setInterval中到期的callback。\r\n- `I/O callbacks`: 执行几乎所有的回调，除了close callbacks以及timers调度的回调和setImmediate()调度的回调。\r\n- `idle, prepare`: 仅在内部使用。\r\n- `poll`: 最重要的阶段，检索新的I/O事件，在适当的情况下回阻塞在该阶段。\r\n- `check`: 执行setImmediate的callback(setImmediate()会将事件插入到事件队列的尾部，主线程和事件队列的任务执行完毕后会立即执行setImmediate中传入的回调函数)。\r\n- `close callbacks`: 执行`close`事件的callback，例如socket.on('close', fn)或则http.server.on('close', fn)等。\r\n\r\nNodeJs中的宏任务队列可以分为下列4个:\r\n\r\n  1. Timers Queue\r\n  2. I/O Callbacks Queue\r\n  3. Check Queue\r\n  4. Close Callbacks Queue\r\n\r\n在浏览器中只有一个宏任务队列，所有宏任务都会放入到宏任务队列中等待放入执行栈中被主线程执行，NodeJs中有4个宏任务队列，不同类型的宏任务会被放入到不同的宏任务队列中。\r\n\r\nNodeJs中的微任务队列可以分为下列2个:\r\n\r\n  1. `Next Tick Queue`: 放置process.nextTick(callback)的回调函数\r\n  2. `Other Micro Queue`: 其他microtask，例如Promise等\r\n\r\n在浏览器中只有一个微任务队列，所有微任务都会放入到微任务队列中等待放入执行栈中被主线程执行，NodeJs中有2个微任务队列，不同类型的微任务会被放入到不同的微任务队列中。\r\n\r\n![NodeJs事件循环](https://user-images.githubusercontent.com/8088864/125030923-71a55200-e0be-11eb-93be-95f1cbc456e3.png)\r\n\r\nNodeJs的Event Loop的具体流程:\r\n\r\n1. 执行全局Javascript的同步代码，可能包含一些同步语句，也可以是异步语句(setTimeout语句不执行回调函数里面的，Promise中.then之前的语句)。\r\n2. 执行微任务队列中的微任务，先执行Next Tick Queue队列中的所有的所有任务，再执行Other Micro Queue队列中的所有任务。\r\n3. 开始执行宏任务队列中的任务，共6个阶段，从第1个阶段开始执行每个阶段对应宏任务队列中的所有任务，**注意，这里执行的是该阶段宏任务队列中的所有的任务，浏览器Event Loop每次只会中宏任务队列中取出队首的任务执行，执行完后开始执行微任务队列中的任务，NodeJs的Event Loop会执行完该阶段中宏任务队列中的所有任务后，才开始执行微任务队列中的任务，也就是步骤2**。\r\n4. Timers Queue -> 步骤2 -> I/O Callbacks Queue -> 步骤2 -> Check Queue -> 步骤2 -> Close Callback Queue -> 步骤2 -> Timers Queue -> ......\r\n\r\nNodeJs的Event Loop的microtask queue和macrotask queue的执行顺序详情\r\n\r\n![NodeJS中的微任务队列执行顺序](https://user-images.githubusercontent.com/8088864/125032436-8aaf0280-e0c0-11eb-926a-30be5bf116f9.png)\r\n\r\n![NodeJS中的宏任务队列执行顺序](https://user-images.githubusercontent.com/8088864/125032451-8f73b680-e0c0-11eb-8349-d6c5f20bd11a.png)\r\n\r\n当setTimeout(fn, 0)和setImmediate(fn)放在同一同步代码中执行时，可能会出现下面两种情况：\r\n\r\n1. **第一种情况**: 同步代码执行完后，timer还没到期，setImmediate中注册的回调函数先放入到Check Queue的宏任务队列中，先执行微任务队列，然后开始执行宏任务队列，先从Timers Queue开始，由于在Timer Queue中未发现任何的回调函数，往下阶段走，直到Check Queue中发现setImmediate中注册的回调函数，先执行，然后timer到期，setTimeout注册的回调函数会放入到Timers Queue的宏任务队列中，下一轮后再次执行到Timers Queue阶段时，才会再Timers Queue中发现了setTimeout注册的回调函数，于是执行该timer的回调，所以，**setImmediate(fn)注册的回调函数会早于setTimeout(fn, 0)注册的回调函数执行**。\r\n2. **第二种情况**: 同步代码执行完之前，timer已经到期，setTimeout注册的回调函数会放入到Timers Queue的宏任务队列中，执行同步代码到setImmediate时，将其回调函数注册到Check Queue中，同步代码执行完后，先执行微任务队列，然后开始执行宏任务队列，先从Timers Queue开始，在Timers Queue发现了timer中注册的回调函数，取出执行，往下阶段走，到Check Queue中发现setImmediate中注册的回调函数，又执行，所以这种情况时，**setTimeout(fn, 0)注册的回调函数会早于setImmediate(fn)注册的回调函数执行**。\r\n\r\n3. 在同步代码中同时调setTimeout(fn, 0)和setImmediate执行顺序情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile('xx', function () {// ....})回调中，那么IO回调是在I/O Callbacks Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，I/O Callbacks Queue执行完到Check Queue，Timers Queue得到下个循环周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行。\r\n\r\n``` js\r\nsetImmediate(function A() {\r\n  console.log(1);\r\n  setImmediate(function B(){console.log(2);});\r\n});\r\n\r\nsetTimeout(function timeout() {\r\n  console.log('TIMEOUT FIRED');\r\n}, 0);\r\n\r\n// 执行结果: 会存在下面两种情况\r\n// 第一种情况:\r\n// 1\r\n// TIMEOUT FIRED\r\n// 2\r\n\r\n// 第二种情况:\r\n// TIMEOUT FIRED\r\n// 1\r\n// 2\r\n```\r\n\r\npoll 阶段详解:\r\n\r\npoll 阶段主要又两个功能:\r\n\r\n1. 当timers到达指定的时间后，执行指定的timer的回调(Executing scripts for timers whose threshold has elapsed, then)。\r\n2. 处理poll队列的事件(Processing events in the poll queue)。\r\n\r\n当进入到poll阶段，并且没有timers被调用的时候，会出现下面的情况:\r\n\r\n- 如果poll队列不为空，Event Loop将同步执行poll queue中的任务，直到poll queue队列为空或者执行的callback达到上限。\r\n- 如果poll队列为空，会发生下面的情况:\r\n  - 如果脚本执行过setImmediate代码，Event Loop会结束poll阶段，直接进入check阶段，执行Check Queue中调用setImmediate注册的回调函数。\r\n  - 如果脚本没有执行过setImmediate代码，poll阶段将等待callback被添加到队列中，然后立即执行。\r\n\r\n当进入到poll阶段，并且调用了timers的话，会发生下面的情况:\r\n\r\n- 一旦poll queue为空，Event Loop会检测Timers Queue中是否存在任务，如果存在任务的话，Event Loop会回到timer阶段并执行Timers Queue中timers注册的回调函数。**执行完后是进入check阶段，还是又重新进入I/O callbacks阶段?**\r\n\r\nsetTimeout 对比 setImmediate\r\n\r\n- setTimeout(fn, 0)在timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行\r\n- setImmediate(fn)在check阶段执行\r\n\r\n两者的执行顺序要根据当前的执行环境才能确定：\r\n\r\n- 如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机\r\n- 如果两者都不在主模块调用，即在一个I/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段\r\n\r\nsetImmediate 对比 process.nextTick\r\n\r\n- setImmediate(fn)的回调任务会插入到宏队列Check Queue中\r\n- process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中\r\n- process.nextTick(fn)调用深度有限制，上限是1000，而setImmediate则没有\r\n\r\n## 二、Fetch API使用的常见问题及其解决办法\r\n\r\nXMLHttpRequest在发送web请求时需要开发者配置相关请求信息和成功后的回调，尽管开发者只关心请求成功后的业务处理，但是也要配置其他繁琐内容，导致配置和调用比较混乱，也不符合关注分离的原则；fetch的出现正是为了解决XHR存在的这些问题。\r\n\r\n**fetch是基于Promise设计的**，让开发者只关注请求成功后的业务逻辑处理，其他的不用关心，相当简单，FetchAPI的优点如下:\r\n\r\n- 语法简单，更加语义化\r\n- 基于标准的Promise实现，支持async/await\r\n- 使用isomorphic-fetch可以方便同构\r\n\r\n使用fetch来进行项目开发时，也是有一些常见问题的，下面就来说说fetch使用的常见问题。\r\n\r\n### Fetch 兼容性问题\r\n\r\nfetch是相对较新的技术，当然就会存在浏览器兼容性的问题，借用上面应用文章的一幅图加以说明fetch在各种浏览器的原生支持情况：\r\n\r\n![Fetch兼容性](https://user-images.githubusercontent.com/8088864/125045722-e03edb80-e0cf-11eb-9457-f56b13350846.png)\r\n\r\n从上图可以看出各个浏览器的低版本都不支持fetch技术。\r\n\r\n如何在所有浏览器中通用fetch呢，当然就要考虑fetch的polyfill了。\r\n\r\nfetch是基于Promise来实现的，所以在低版本浏览器中Promise可能也未被原生支持，所以还需要Promise的polyfill；大多数情况下，实现fetch的polyfill需要涉及到的：\r\n\r\n- promise的polyfill，例如es6-promise、babel-polyfill提供的promise实现。\r\n- fetch的polyfill实现，例如isomorphic-fetch和whatwg-fetch\r\n\r\nIE浏览器中IE8/9还比较特殊：IE8它使用的是ES3，而IE9则对ES5部分支持。这种情况下还需要ES5的polyfill es5-shim支持了。\r\n\r\n上述有关promise的polyfill实现，需要说明的是：\r\n\r\nbabel-runtime是不能作为Promise的polyfill的实现的，否则在IE8/9下使用fetch会报Promise未定义。为什么？我想大家猜到了，因为babel-runtime实现的polyfill是局部实现而不是全局实现，fetch底层实现用到Promise就是从全局中去取的，拿不到这报上述错误。\r\n\r\nfetch的polyfill实现思路:\r\n\r\n首先判断浏览器是否原生支持fetch，否则结合Promise使用XMLHttpRequest的方式来实现；这正是whatwg-fetch的实现思路，而同构应用中使用的isomorphic-fetch，其客户端fetch的实现是直接require whatwg-fetch来实现的。\r\n\r\n### fetch默认不携带cookie\r\n\r\nfetch发送请求默认是不发送cookie的，不管是同域还是跨域；\r\n\r\n对于那些需要权限验证的请求就可能无法正常获取数据，可以配置其credentials项，其有3个值：\r\n\r\n- omit: 默认值，忽略cookie的发送\r\n- same-origin: 表示cookie只能同域发送，不能跨域发送\r\n- include: cookie既可以同域发送，也可以跨域发送\r\n\r\ncredentials所表达的含义，其实与XHR2中的withCredentials属性类似，表示请求是否携带cookie；\r\n\r\n若要fetch请求携带cookie信息，只需设置一下credentials选项即可，例如fetch(url, {credentials: 'include'});\r\n\r\nfetch默认对服务端通过Set-Cookie头设置的cookie也会忽略，若想选择接受来自服务端的cookie信息，也必须要配置credentials选项；\r\n\r\n### fetch请求对某些错误http状态不会reject\r\n\r\n主要是由fetch返回promise导致的，因为fetch返回的promise在某些错误的http状态下如400、500等不会reject，相反它会被resolve；只有网络错误会导致请求不能完成时，fetch 才会被 reject；所以一般会对fetch请求做一层封装。\r\n\r\n``` js\r\nfunction checkStatus(response) {\r\n  if (response.status >= 200 && response.status < 300) {\r\n    return response;\r\n  }\r\n  const error = new Error(response.statusText);\r\n  error.response = response;\r\n  throw error;\r\n}\r\n\r\nfunction parseJSON(response) {\r\n  return response.json();\r\n}\r\n\r\nexport default function request(url, options) {\r\n  let opt = options||{};\r\n  return fetch(url, {credentials: 'include', ...opt})\r\n    .then(checkStatus)\r\n    .then(parseJSON)\r\n    .then((data) => ( data ))\r\n    .catch((err) => ( err ));\r\n}\r\n```\r\n\r\n### fetch不支持超时timeout处理\r\n\r\nfetch不像大多数ajax库那样对请求设置超时timeout，它没有有关请求超时的功能，所以在fetch标准添加超时功能之前，都需要polyfill该特性。\r\n\r\n实际上，我们真正需要的是abort()， timeout可以通过timeout+abort方式来实现，起到真正超时丢弃当前的请求。\r\n\r\n目前的fetch指导规范中，fetch并不是一个具体实例，而只是一个方法；其返回的promise实例根据Promise指导规范标准是不能abort的，也不能手动改变promise实例的状态，只能由内部来根据请求结果来改变promise的状态。\r\n\r\n实现fetch的timeout功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现timeout的功能；\r\n\r\n根据github上[timeout handling](https://github.com/github/fetch/issues/175)上的讨论，目前可以有两种不同的解决方法：\r\n\r\n方法一: 单纯setTimeout方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    if (options.timeout) {\r\n      var timerId = setTimeout(function() {\r\n        reject(new Error('fetch timeout'));\r\n      }, options.timeout);\r\n    }\r\n\r\n    fetchOrigin(url, option).then(function(response) {\r\n      clearTimeout(timerId);\r\n      resolve(response);\r\n    }, function(error) {\r\n      clearTimeout(timerId);\r\n      reject(error);\r\n    });\r\n  });\r\n}\r\n```\r\n\r\n使用这种方式还可模拟XHR的abort方法\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  return new Promise(function(resolve, reject) {\r\n    var abort = function() {\r\n      reject(new Error('fetch abort'));\r\n    };\r\n\r\n    const p = fetchOrigin(url, option).then(resolve, reject);\r\n    p.abort = abort;\r\n\r\n    return p;\r\n  });\r\n}\r\n```\r\n\r\n方法二: 利用Promise.race方法\r\n\r\nPromise.race方法接受一个promise实例数组参数，表示多个promise实例中任何一个最先改变状态，那么race方法返回的promise实例状态就跟着改变\r\n\r\n``` js\r\nvar fetchOrigin = fetch;\r\nwindow.fetch = function(url, options) {\r\n  var abortFn = null;\r\n  var timeoutFn = null;\r\n\r\n  var timeoutPromise = new Promise(function(resolve, reject) {\r\n    timeoutFn = function () {\r\n      reject(new Error('fetch timeout'));\r\n    }\r\n  });\r\n\r\n  var abortPromise = new Promise(function(resolve, reject) {\r\n    abortFn = function () {\r\n      reject(new Error('fetch abort'));\r\n    }\r\n  });\r\n\r\n  const fetchPromise = fetchOrigin(url, option);\r\n\r\n  const promise = Promise.race(\r\n    timeoutPromise,\r\n    abortPromise,\r\n    fetchPromise,\r\n  );\r\n\r\n  promise.abort = abortFn;\r\n\r\n  return promise;\r\n}\r\n```\r\n\r\n对fetch的timeout的上述实现方式补充几点：\r\n\r\n- timeout不是请求连接超时的含义，它表示请求的response时间，包括请求的连接、服务器处理及服务器响应回来的时间。\r\n- fetch的timeout即使超时发生了，本次请求也不会被abort丢弃掉，它在后台仍然会发送到服务器端，只是本次请求的响应内容被丢弃而已。\r\n\r\n### fetch不支持JSONP\r\n\r\nfetch是与服务器端进行异步交互的，而JSONP是外链一个javascript资源，是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题，并不是真正ajax，所以fetch与JSONP没有什么直接关联，当然至少目前是不支持JSONP的。\r\n\r\n这里我们把JSONP与fetch关联在一起有点差强人意，fetch只是一个ajax库，我们不可能使fetch支持JSONP；只是我们要实现一个JSONP，只不过这个JSONP的实现要与fetch的实现类似，即基于Promise来实现一个JSONP；而其外在表现给人感觉是fetch支持JSONP一样；\r\n\r\n目前比较成熟的开源JSONP实现[fetch-jsonp](https://github.com/camsong/fetch-jsonp)给我们提供了解决方案，想了解可以自行前往。不过再次想唠叨一下其JSONP的实现步骤，因为在本人面试的前端候选人中大部分人对JSONP的实现语焉不详；\r\n\r\n使用它非常简单，首先需要用npm安装fetch-jsonp\r\n\r\n``` shell\r\nnpm install fetch-jsonp --save-dev\r\n```\r\n\r\n具体的使用方式:\r\n\r\n``` js\r\nfetchJsonp('/users.jsonp', {\r\n  timeout: 3000,\r\n  jsonpCallback: 'custom_callback'\r\n})\r\n.then(function(response) {\r\n  return response.json()\r\n}).catch(function(ex) {\r\n  console.log('parsing failed', ex)\r\n});\r\n```\r\n\r\n### fetch不支持progress事件\r\n\r\nXHR是原生支持progress事件的，例如下面代码这样：\r\n\r\n``` js\r\nvar xhr = new XMLHttpRequest();\r\nxhr.open('POST', '/uploads');\r\nxhr.onload = function() {}\r\nxhr.onerror = function() {}\r\nvar uploadProgress = function(event) {\r\n  if (event.lengthComputable) {\r\n    var percent = Math.round((event.loaded / event.total) * 100);\r\n    console.log(percent);\r\n  }\r\n};\r\n\r\n// 上传的progress事件\r\nxhr.upload.onprogress = uploadProgress;\r\n// 下载的progress事件\r\nxhr.onprogress = uploadProgress;\r\n```\r\n\r\n但是fetch是不支持有关progress事件的；不过可喜的是，根据fetch的指导规范标准，其内部设计实现了Request和Response类；其中Response封装一些方法和属性，通过Response实例可以访问这些方法和属性，例如response.json()、response.body等等；\r\n\r\n值得关注的地方是，response.body是一个可读字节流对象，其实现了一个getRender()方法，其具体作用是：\r\n\r\ngetRender()方法用于读取响应的原始字节流，该字节流是可以循环读取的，直至body内容传输完成；\r\n\r\n因此，利用到这点可以模拟出fetch的progress。\r\n\r\n代码实现如下:\r\n\r\n``` js\r\n// fetch() returns a promise that resolves once headers have been received\r\nfetch(url).then(response => {\r\n  // response.body is a readable stream.\r\n  // Calling getReader() gives us exclusive access to the stream's content\r\n  var reader = response.body.getReader();\r\n  var bytesReceived = 0;\r\n\r\n  // read() returns a promise that resolves when a value has been received\r\n  reader.read().then(function processResult(result) {\r\n    // Result objects contain two properties:\r\n    // done  - true if the stream has already given you all its data.\r\n    // value - some data. Always undefined when done is true.\r\n    if (result.done) {\r\n      console.log(\"Fetch complete\");\r\n      return;\r\n    }\r\n\r\n    // result.value for fetch streams is a Uint8Array\r\n    bytesReceived += result.value.length;\r\n    console.log('Received', bytesReceived, 'bytes of data so far');\r\n\r\n    // Read some more, and call this function again\r\n    return reader.read().then(processResult);\r\n  });\r\n});\r\n```\r\n\r\ngithub上也有使用Promise+XHR结合的方式实现类fetch的progress效果(当然这跟fetch完全不搭边）可以参考[这里](https://github.com/github/fetch/issues/89#issuecomment-256610849)，具体代码如下：\r\n\r\n``` js\r\nfunction fetchProgress(url, opts={}, onProgress) {\r\n  return new Promise((resolve, reject)=>{\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(opts.method || 'get', url);\r\n\r\n    for (var key in opts.headers||{}) {\r\n      xhr.setRequestHeader(key, opts.headers[key]);\r\n    }\r\n\r\n    xhr.onload = function(event) {\r\n      resolve(e.target.responseText)\r\n    };\r\n\r\n    xhr.onerror = reject;\r\n\r\n    if (xhr.upload && onProgress) {\r\n      xhr.upload.onprogress = onProgress; // event.loaded / event.total * 100 ; //event.lengthComputable\r\n    }\r\n\r\n    xhr.send(opts.body);\r\n  });\r\n}\r\n\r\nfetchProgress('/').then(console.log)\r\n```\r\n\r\n### fetch跨域问题\r\n\r\n既然是ajax库，就不可避免与跨域扯上关系；XHR2是支持跨域请求的，只不过要满足浏览器端支持CORS，服务器通过Access-Control-Allow-Origin来允许指定的源进行跨域，仅此一种方式。\r\n\r\n与XHR2一样，fetch也是支持跨域请求的，只不过其跨域请求做法与XHR2一样，需要客户端与服务端支持；另外，fetch还支持一种跨域，不需要服务器支持的形式，具体可以通过其mode的配置项来说明。\r\n\r\nfetch的mode配置项有3个值，如下：\r\n\r\n- same-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。\r\n- cors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为cors。\r\n- no-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为opaque。\r\n\r\n针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的no-cors跨域请求模式则较为陌生，该模式有一个比较明显的特点：\r\n\r\n该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。\r\n\r\n这与<img \\/>发送的请求类似，只是该模式不能访问响应的内容信息；但是它可以被其他APIs进行处理，例如ServiceWorker。另外，该模式返回的response可以在Cache API中被存储起来以便后续的对它的使用，这点对script、css和图片的CDN资源是非常合适的，因为这些资源响应头中都没有CORS头。\r\n\r\n总的来说，fetch的跨域请求是使用CORS方式，需要浏览器和服务端的支持。\r\n\r\n## 三、原型链和继承\r\n\r\nJavaScript是一门面向对象的设计语言，在JS里除了null和undefined，其余一切皆为对象。其中Array/Function/Date/RegExp是Object对象的特殊实例实现，Boolean/Number/String也都有对应的基本包装类型的对象（具有内置的方法）。传统语言是依靠class类来完成面向对象的继承和多态等特性，而JS使用原型链和构造器来实现继承，依靠参数arguments.length来实现多态。并且在ES6里也引入了class关键字来实现类。\r\n\r\n### 函数与对象的关系\r\n\r\n有时我们会好奇为什么能给一个函数添加属性，函数难道不应该就是一个执行过程的作用域吗？\r\n\r\n``` js\r\nvar name = 'Hank';\r\nfunction Person(name) {\r\n    this.name = name;\r\n    this.sayName = function() {\r\n        alert(this.name);\r\n    }\r\n}\r\nPerson.age = 10;\r\nconsole.log(Person.age);    // 10\r\nconsole.log(Person);\r\n/* 输出函数体：\r\nƒ Person(name) {\r\n    this.name = name;\r\n}\r\n*/\r\n```\r\n\r\n我们能够给函数赋一个属性值，当我们输出这个函数时这个属性却无影无踪了，这到底是怎么回事，这个属性又保存在哪里了呢？\r\n\r\n其实，在JS里，函数就是一个对象，这些属性自然就跟对象的属性一样被保存起来，函数名称指向这个对象的存储空间。\r\n\r\n函数调用过程没查到资料，个人理解为：这个对象内部拥有一个内部属性[\\[function]]保存有该函数体的字符串形式，当使用()来调用的时候，就会实时对其进行动态解析和执行，如同**eval()**一样。\r\n\r\n![内存栈和内存堆](https://user-images.githubusercontent.com/8088864/125233637-947b7480-e311-11eb-903e-73397c79b87e.png)\r\n\r\n上图是JS的具体内存分配方式，JS中分为值类型和引用类型，值类型的数据大小固定，我们将其分配在栈里，直接保存其数据。而引用类型是对象，会动态的增删属性，大小不固定，我们把它分配到内存堆里，并用一个指针指向这片地址，也就是Person其实保存的是一个指向这片地址的指针。这里的Person对象是个函数实例，所以拥有特殊的内部对象[\\[function]]用于调用。同时它也拥有内部属性arguments/this/name，因为不相关，这里我们没有绘出，而展示了我们为其添加的属性age。\r\n\r\n### 函数与原型的关系\r\n\r\n同时在JS里，我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个用于包含该对象所有实例的共享属性和方法的对象。而这个对象同时包含一个指针指向这个这个函数，这个指针就是**constructor**，这个函数也被成为构造函数。这样我们就完成了构造函数和原型对象的双向引用。\r\n\r\n而上面的代码实质也就是当我们创建了Person构造函数之后，同步开辟了一片空间创建了一个对象作为Person的原型对象，可以通过Person.prototype来访问这个对象，也可以通过Person.prototype.constructor来访问Person该构造函数。通过构造函数我们可以往实例对象里添加属性，如上面的例子里的name属性和sayName()方法。我们也可以通过prototype来添加原型属性，如：\r\n\r\n![函数原型](https://user-images.githubusercontent.com/8088864/125234076-7f531580-e312-11eb-9c55-3d760c70f5e7.png)\r\n\r\n要注意属性和原型属性不是同一个东西，也并不保存在同一个空间里：\r\n\r\n``` js\r\nPerson.age; // 10\r\nPerson.prototype.age; // 24\r\n```\r\n\r\n### 原型和实例的关系\r\n\r\n现在有了构造函数和原型对象，那我们接下来new一个实例出来，这样才能真正体现面向对象编程的思想，也就是**继承**：\r\n\r\n``` js\r\nvar person1 = new Person('Lee');\r\nvar person2 = new Person('Lucy');\r\n```\r\n\r\n我们新建了两个实例person1和person2，这些实例的内部都会包含一个指向其构造函数的原型对象的指针（内部属性），这个指针叫[\\[Prototype]]，在ES5的标准上没有规定访问这个属性，但是大部分浏览器实现了**__proto__**的属性来访问它，成为了实际的通用属性，于是在ES6的附录里写进了该属性。__proto__前后的双下划线说明其本质上是一个内部属性，而不是对外访问的API，因此官方建议新的代码应当避免使用该属性，转而使用Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。\r\n\r\n这里的prototype我们称为显示原型，__proto__我们称为隐式原型。\r\n\r\n``` js\r\nObject.getPrototypeOf({}) === Object.prototype; // true\r\n```\r\n\r\n同时由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。\r\n\r\n此时它们的关系是（为了清晰，忽略函数属性的指向，用(function)代指）：\r\n\r\n![构造函数实例的原型关系](https://user-images.githubusercontent.com/8088864/125234787-f89f3800-e313-11eb-8f2a-b1e346d904af.png)\r\n\r\n在这里我们可以看到两个实例指向了同一个原型对象，而在new的过程中调用了Person()方法，对每个实例分别初始化了name属性和sayName方法，属性值分别被保存，而方法作为引用对象也指向了不同的内存空间。\r\n\r\n我们可以用几种方法来验证实例的原型指针到底指向的是不是构造函数的原型对象：\r\n\r\n``` js\r\nperson1.__proto__ === Person.prototype // true\r\nPerson.prototype.isPrototypeOf(person1); // true\r\nObject.getPrototypeOf(person2) === Person.prototype; // true\r\nperson1 instanceof Person; // true\r\n```\r\n\r\n### 原型链\r\n\r\n现在我们访问实例person1的属性和方法了：\r\n\r\n``` js\r\nperson1.name; // Lee\r\nperson1.age; // 24\r\nperson1.toString(); // [object Object]\r\n```\r\n\r\n想下这个问题，我们的name值来自于person1的属性，那么age值来自于哪？toString( )方法又在哪定义的呢？\r\n\r\n这就是我们要说的原型链，原型链是实现继承的主要方法，其思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。如果我们让一个原型对象等于另一个类型的实例，那么该原型对象就会包含一个指向另一个原型的指针，而如果另一个原型对象又是另一个原型的实例，那么上述关系依然成立，层层递进，就构成了实例与原型的链条，这就是原型链的概念。\r\n\r\n上面代码的name来自于自身属性，age来自于原型属性，toString( )方法来自于Person原型对象的原型Object。当我们访问一个实例属性的时候，如果没有找到，我们就会继续搜索实例的原型，如果还没有找到，就递归搜索原型链直到原型链末端。我们可以来验证一下原型链的关系：\r\n\r\n``` js\r\nPerson.prototype.__proto__ === Object.prototype // true\r\n```\r\n\r\n同时让我们更加深入的验证一些东西：\r\n\r\n``` js\r\nPerson.__proto__ === Function.prototype // true\r\nFunction.prototype.__proto__ === Object.prototype // true\r\n```\r\n\r\n我们会发现Person是Function对象的实例，Function是Object对象的实例，Person原型是Object对象的实例。这证明了我们开篇的观点：JavaScript是一门面向对象的设计语言，在JS里除了null和undefined，其余一切皆为对象。\r\n\r\n下面祭出我们的原型链图：\r\n\r\n![原型链图](https://user-images.githubusercontent.com/8088864/125235100-7e22e800-e314-11eb-9dd0-bb6d0747ec99.jpg)\r\n\r\n根据我们上面讲述的关于prototype/constructor/__proto__的内容，我相信你可以完全看懂这张图的内容。需要注意两点：\r\n\r\n  1. 构造函数和对象原型一一对应，他们与实例一起作为三要素构成了三面这幅图。最左侧是实例，中间是构造函数，最右侧是对象原型。\r\n  2. 最最右侧的null告诉我们：Object.prototype.__proto__ = null，也就是Object.prototype是JS中一切对象的根源。其余的对象继承于它，并拥有自己的方法和属性。\r\n\r\n### 6种继承方法\r\n\r\n#### 第一种: 原型链继承\r\n\r\n利用原型链的特点进行继承\r\n\r\n``` js\r\nfunction Super(){\r\n  this.name = 'web前端';\r\n  this.type = ['JS','HTML','CSS'];\r\n}\r\nSuper.prototype.sayName=function(){\r\n  return this.name;\r\n}\r\nfunction Sub(){};\r\nSub.prototype = new Super();\r\nSub.prototype.constructor = Sub;\r\nvar sub1 = new Sub();\r\nsub1.sayName();\r\n```\r\n\r\n优点：\r\n\r\n- 可以实现继承。\r\n\r\n缺点:\r\n\r\n- 子类的原型属性集成了父类实例化对象，所有子类的实例化对象都共享原型对象的属性和方法\r\n\r\n``` js\r\nvar sub1 = new Son();\r\nvar sub2 = new Son();\r\nsub1.type.push('VUE');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nconsole.log(sub2.type); // ['JS','HTML','CSS','VUE']\r\n```\r\n\r\n- 子类构造函数实例化对象时，无法传递参数给父类\r\n\r\n#### 第二种: 构造函数继承\r\n\r\n通过构造函数call方法实现继承。\r\n\r\n``` js\r\nfunction Super(){\r\n  this.name = 'web前端';\r\n  this.type = ['JS','HTML','CSS'];\r\n\r\n  this.sayName = function() {\r\n    return this.name;\r\n  }\r\n}\r\nfunction Sub(){\r\n  Super.call(this);\r\n}\r\nvar sub1 = new Sub();\r\nsub1.type.push('VUE');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nvar sub2 = new Sub();\r\nconsole.log(sub2.type); // ['JS','HTML','CSS']\r\n```\r\n\r\n优点:\r\n\r\n- 实现父类实例化对象的独立性\r\n\r\n- 还可以给父类实例化对象添加参数\r\n\r\n缺点:\r\n\r\n- 方法都在构造函数中定义，每次实例化对象都得创建一遍方法，基本无法实现函数复用\r\n\r\n- call方法仅仅调用了父级构造函数的属性及方法，没有办法访问父级构造函数原型对象的属性和方法\r\n\r\n#### 第三种: 组合继承\r\n\r\n利用原型链继承和构造函数继承的各自优势进行组合使用\r\n\r\n``` js\r\n\r\nfunction Super(name){\r\n  this.name = name;\r\n  this.type = ['JS','HTML','CSS'];\r\n}\r\n\r\nSuper.prototype.sayName=function(){\r\n  return this.name;\r\n}\r\n\r\nfunction Sub(name){\r\n  Super.call(this, name);\r\n}\r\n\r\nSub.prototype = new Super();\r\nsub1 = new Sub('张三');\r\nsub2 = new Sub('李四');\r\nsub1.type.push('VUE');\r\nsub2.type.push('PHP');\r\nconsole.log(sub1.type); // ['JS','HTML','CSS','VUE']\r\nconsole.log(sub2.type); // ['JS','HTML','CSS','PHP']\r\nsub1.sayName(); // 张三\r\nsub2.sayName(); // 李四\r\n```\r\n\r\n优点:\r\n\r\n- 利用原型链继承，实现原型对象方法的继承，允许访问父级构造函数原型对象属性和方法，实现方法复用\r\n\r\n- 利用构造函数继承，实现属性的继承，而且可以传递参数\r\n\r\n缺点:\r\n\r\n- 创建子类实例对象时，无论什么情况下，都会调用两次父级构造函数：一次是在创建子级原型的时候，另一次是在子级构造函数内部(call)\r\n\r\n#### 第四种: 原型式继承\r\n\r\n创建一个函数，将参数作为一个对象的原型对象。\r\n\r\n``` js\r\nfunction create(obj) {\r\n  function Sub(){};\r\n  Sub.prototype = obj;\r\n  return new Sub();\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = create(parent);\r\nvar sub2 = create(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\nES5规范化了这个原型继承，新增了Object.create()方法，接收两个参数，第一个为原型对象，第二个为要混合进新对象的属性，格式与Object.defineProperties()相同。\r\n\r\n``` js\r\nObject.create(null, {name: {value: 'Greg', enumerable: true}});\r\n\r\n// 相当于\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = Object.create(parent);\r\nvar sub2 = Object.create(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\n优缺点：\r\n\r\n- 跟原型链类似\r\n\r\n#### 第五种: 寄生继承\r\n\r\n在原型式继承的基础上，在函数内部丰富对象\r\n\r\n``` js\r\nfunction create(obj) {\r\n  function Sub() {};\r\n  Sub.prototype = obj;\r\n  Sub.prototype.constructor = Sub;\r\n\r\n  return new Sub();\r\n}\r\n\r\nfunction Parasitic(obj) {\r\n  var clone = create(obj);\r\n  clone.sayHi = function() {\r\n    console.log('hi');\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar sub1 = Parasitic(parent);\r\nvar sub2 = Parasitic(parent);\r\n\r\nconsole.log(sub1.name); // 张三\r\nconsole.log(sub2.name); // 张三\r\n```\r\n\r\n如果使用ES5Object.create来代替create函数的话，可以简化成如下所示:\r\n\r\n``` js\r\nfunction Parasitic(obj) {\r\n  var clone = Object.create(obj);\r\n  clone.sayHi = function() {\r\n    console.log('hi');\r\n  };\r\n  return clone;\r\n}\r\n\r\nvar parent = {\r\n  name: '张三',\r\n  type: ['JS','HTML','CSS'];\r\n};\r\n\r\nvar son1 = Parasitic(parent);\r\nvar son2 = Parasitic(parent);\r\n\r\nconsole.log(son1.name); // 张三\r\nconsole.log(son2.name); // 张三\r\nson1.sayHi();\r\nson2.sayHi();\r\n```\r\n\r\n优缺点:\r\n\r\n- 跟构造函数继承类似，调用一次函数就得创建一遍方法，无法实现函数复用，效率较低\r\n\r\n#### 第六种: 寄生组合继承\r\n\r\n利用组合继承和寄生继承各自优势\r\n\r\n组合继承方法我们已经说了，它的缺点是两次调用父级构造函数，一次是在创建子级原型的时候，另一次是在子级构造函数内部，那么我们只需要优化这个问题就行了，即减少一次调用父级构造函数，正好利用寄生继承的特性，继承父级构造函数的原型来创建子级原型。\r\n\r\n``` js\r\nfunction Super(name) {\r\n  this.name = name;\r\n  this.type = ['JS','HTML','CSS'];\r\n};\r\n\r\nSuper.prototype.sayName = function () {\r\n  return this.name;\r\n};\r\n\r\nfunction Sub(name, age) {\r\n  Super.call(this, name);\r\n  this.age = age;\r\n}\r\n\r\n// 我们封装其继承过程\r\nfunction inheritPrototype(Sub, Super) {\r\n  // 以该对象为原型创建一个新对象\r\n  var prototype = Object.create(Super.prototype);\r\n  prototype.constructor = Sub;\r\n  Sub.prototype = prototype;\r\n}\r\n\r\ninheritPrototype(Sub, Super);\r\n\r\n// 必须定义在inheritPrototype方法之后\r\nSub.prototype.sayAge = function () {\r\n  return this.age;\r\n}\r\n\r\nvar instance = new Sub('张三', 40);\r\ninstance.sayName(); // 张三\r\ninstance.sayAge(); // 40\r\n```\r\n\r\n这种方式只调用了一次父类构造函数，只在子类上创建一次对象，同时保持原型链，还可以使用instanceof和isPrototypeOf()来判断原型，是我们最理想的继承方式。\r\n\r\n#### 第七种: ES6 Class类和extends关键字\r\n\r\nES6引进了class关键字，用于创建类，这里的类是作为**ES5构造函数和原型对象的语法糖**存在的，其功能大部分都可以被ES5实现，不过在语言层面上ES6也提供了部分支持。新的写法不过让对象原型看起来更加清晰，更像面向对象的语法而已。\r\n\r\n``` js\r\n//定义类\r\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  toString() {\r\n    return '(' + this.x + ', ' + this.y + ')';\r\n  }\r\n}\r\n\r\nvar point = new Point(10, 10);\r\n```\r\n\r\n我们看到其中的constructor方法就是之前的构造函数，this就是之前的原型对象，toString()就是定义在原型上的方法，只能使用new关键字来新建实例。语法差别在于我们不需要function关键字和逗号分割符。其中，所有的方法都直接定义在原型上，注意所有的方法都不可枚举。类的内部使用严格模式，并且不存在变量提升，其中的this指向类的实例。\r\n\r\nnew是从构造函数生成实例的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\r\n\r\n类存在静态方法，使用static关键字表示，其只能类和继承的子类来进行调用，不能被实例调用，也就是不能被实例继承，所以我们称它为静态方法。类不存在内部方法和内部属性。\r\n\r\n``` js\r\nclass Foo {\r\n  static classMethod() {\r\n    return 'hello';\r\n  }\r\n}\r\n\r\nFoo.classMethod() // 'hello'\r\n\r\nvar foo = new Foo();\r\nfoo.classMethod()\r\n// TypeError: foo.classMethod is not a function\r\n```\r\n\r\n类通过extends关键字来实现继承，在继承的子类的构造函数里我们使用super关键字来表示对父类构造函数的引用；在静态方法里，super指向父类；在其它函数体内，super表示对父类原型属性的引用。其中super必须在子类的构造函数体内调用一次，因为我们需要调用时来绑定子类的元素对象，否则会报错。\r\n\r\n``` js\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n```\r\n\r\n## 四、前端性能优化\r\n\r\n性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用。\r\n\r\n下面列出来了前端性能的24条建议:\r\n\r\n### 1. 减少 HTTP 请求\r\n\r\n一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。\r\n\r\n接下来看一个具体的例子帮助理解 HTTP ：\r\n\r\n![http请求瀑布图](https://user-images.githubusercontent.com/8088864/125281253-957bc880-e348-11eb-97bf-464d4531ce8e.png)\r\n\r\n这是一个 HTTP 请求，请求的文件大小为 28.4KB。\r\n\r\n名词解释：\r\n\r\n- Queueing: 在请求队列中的时间。\r\n- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。\r\n- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。\r\n- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。\r\n- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。\r\n- SSL: 完成SSL握手所花费的时间。\r\n- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。\r\n- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。\r\n- Content Download: 接收响应数据所花费的时间。\r\n\r\n从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。\r\n\r\n### 2. 使用 HTTP2\r\n\r\nHTTP2 相比 HTTP1.1 有如下几个优点：\r\n\r\n#### 解析速度快\r\n\r\n服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。\r\n\r\n#### 多路复用\r\n\r\nHTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。\r\n\r\n在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。\r\n\r\n#### 首部压缩\r\n\r\nHTTP2 提供了首部压缩功能。\r\n\r\n例如有如下两个请求：\r\n\r\n```\r\n// 请求1\r\n:authority: unpkg.zhimg.com\r\n:method: GET\r\n:path: /za-js-sdk@2.16.0/dist/zap.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n\r\n// 请求2\r\n:authority: zz.bdstatic.com\r\n:method: GET\r\n:path: /linksubmit/push.js\r\n:scheme: https\r\naccept: */*\r\naccept-encoding: gzip, deflate, br\r\naccept-language: zh-CN,zh;q=0.9\r\ncache-control: no-cache\r\npragma: no-cache\r\nreferer: https://www.zhihu.com/\r\nsec-fetch-dest: script\r\nsec-fetch-mode: no-cors\r\nsec-fetch-site: cross-site\r\nuser-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36\r\n```\r\n\r\n从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。\r\n\r\nHTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。\r\n\r\n下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：\r\n\r\n```\r\nHeader1:foo\r\nHeader2:bar\r\nHeader3:bat\r\n```\r\n\r\n当客户端发送请求时，它会根据首部值创建一张表：\r\n\r\n| 索引 | 首部名称 | 值 |\r\n| ---- | ---- | ---- |\r\n| 62 | Header1 | foo |\r\n| 63 | Header2 | bar |\r\n| 64 | Header3 | bar |\r\n\r\n如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：\r\n\r\n```\r\n62 63 64\r\n```\r\n\r\n服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。\r\n\r\n#### 优先级\r\n\r\nHTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。\r\n\r\n#### 流量控制\r\n\r\n由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。\r\n\r\n#### 服务器推送\r\n\r\nHTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。\r\n\r\n例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。\r\n\r\n现在有很多网站已经开始使用 HTTP2 了，例如知乎：\r\n\r\n![服务器推送](https://user-images.githubusercontent.com/8088864/125283274-d83ea000-e34a-11eb-95d5-7881c4af0403.jpg)\r\n\r\n其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。\r\n\r\n参考资料：\r\n\r\n- [半小时搞懂 HTTP、HTTPS和HTTP2](https://github.com/woai3c/Front-end-articles/blob/master/http-https-http2.md)\r\n\r\n### 3. 使用服务端渲染\r\n\r\n客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。\r\n\r\n服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。\r\n\r\n- 优点：首屏渲染快，SEO 好。\r\n- 缺点：配置麻烦，增加了服务器的计算压力。\r\n\r\n下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。\r\n\r\n#### 客户端渲染过程\r\n\r\n1. 访问客户端渲染的网站。\r\n2. 服务器返回一个包含了引入资源语句和 \\<div id=\"app\">\\</div> 的 HTML 文件。\r\n3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。\r\n\r\n#### 服务端渲染过程\r\n\r\n1. 访问服务端渲染的网站。\r\n2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。\r\n3. 当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。\r\n\r\n从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。\r\n\r\n这样做的好处是什么？是更快的内容到达时间 (time-to-content)。\r\n\r\n假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。\r\n\r\n这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。\r\n\r\n参考资料：\r\n\r\n- [vue-ssr-demo](https://github.com/woai3c/vue-ssr-demo)\r\n- [Vue.js 服务器端渲染指南](https://ssr.vuejs.org/zh/)\r\n\r\n### 4. 静态资源使用 CDN\r\n\r\n内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。\r\n\r\n#### CDN 原理\r\n\r\n当用户访问一个网站时，如果没有 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。\r\n3. 本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。\r\n\r\n![没有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125375921-8171ae80-e3bc-11eb-9d66-adb57433b67a.jpg)\r\n\r\n如果用户访问的网站部署了 CDN，过程是这样的：\r\n\r\n1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。\r\n2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。\r\n3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。\r\n4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。\r\n5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。\r\n6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器。\r\n7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。\r\n\r\n![有CDN的资源请求](https://user-images.githubusercontent.com/8088864/125376046-baaa1e80-e3bc-11eb-84ba-c86cd8d63a7f.jpg)\r\n\r\n参考资料：\r\n\r\n- [CDN是什么？使用CDN有什么优势？](https://www.zhihu.com/question/36514327/answer/193768864)\r\n- [CDN原理简析](https://juejin.cn/post/6844903873518239752)\r\n\r\n### 5. 将 CSS 放在文件头部，JavaScript 文件放在底部\r\n\r\n所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。\r\n\r\n那为什么 CSS 文件还要放在头部呢？\r\n\r\n因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。\r\n\r\n另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。\r\n\r\n### 6. 使用字体图标 iconfont 代替图片图标\r\n\r\n字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。\r\n\r\n#### 压缩字体文件\r\n\r\n使用 [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack) 插件对字体文件进行压缩。\r\n\r\n![fontmin-webpack](https://user-images.githubusercontent.com/8088864/125377089-efb77080-e3be-11eb-845b-d8992de47838.png)\r\n\r\n参考资料：\r\n\r\n- [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack)\r\n- [Iconfont-阿里巴巴矢量图标库](https://www.iconfont.cn/)\r\n\r\n### 7. 善用缓存，不重复加载相同的资源\r\n\r\n为了避免用户每次访问网站都得请求文件，我们可以通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。\r\n\r\n不过这样会产生一个问题，当文件更新了怎么办？怎么通知浏览器重新请求文件？\r\n\r\n可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。\r\n\r\n具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用[数据摘要要算法](https://cloud.tencent.com/developer/article/1584742)对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。\r\n\r\n参考资料：\r\n\r\n- [webpack + express 实现文件精确缓存](https://github.com/woai3c/node-blog/blob/master/doc/node-blog7.md)\r\n- [webpack-缓存](https://www.webpackjs.com/guides/caching/)\r\n- [张云龙--大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576/answer/32602154)\r\n\r\n### 8. 压缩文件\r\n\r\n压缩文件可以减少文件下载时间，让用户体验性更好。\r\n\r\n得益于 webpack 和 node 的发展，现在压缩文件已经非常方便了。\r\n\r\n在 webpack 可以使用如下插件进行压缩：\r\n\r\n- JavaScript：UglifyPlugin\r\n- CSS ：MiniCssExtractPlugin\r\n- HTML：HtmlWebpackPlugin\r\n\r\n其实，我们还可以做得更好。那就是使用 gzip 压缩。可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。\r\n\r\ngzip 是目前最流行和最有效的压缩方法。举个例子，我用 Vue 开发的项目构建后生成的 app.js 文件大小为 1.4MB，使用 gzip 压缩后只有 573KB，体积减少了将近 60%。\r\n\r\n附上 webpack 和 node 配置 gzip 的使用方法。\r\n\r\n下载插件\r\n\r\n``` shell\r\nnpm install compression-webpack-plugin --save-dev\r\nnpm install compression\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\nconst CompressionPlugin = require('compression-webpack-plugin');\r\n\r\nmodule.exports = {\r\n  plugins: [new CompressionPlugin()],\r\n}\r\n```\r\n\r\nnode 配置\r\n\r\n``` js\r\nconst compression = require('compression')\r\n// 在其他中间件前使用\r\napp.use(compression())\r\n```\r\n\r\n### 9. 图片优化\r\n\r\n#### (1). 图片延迟加载\r\n\r\n在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。\r\n\r\n首先可以将图片这样设置，在页面不可见时图片不会加载：\r\n\r\n``` html\r\n<img data-src=\"https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4\">\r\n```\r\n\r\n等页面可见时，使用 JS 加载图片：\r\n\r\n``` js\r\nconst img = document.querySelector('img')\r\nimg.src = img.dataset.src\r\n```\r\n\r\n这样图片就加载出来了，完整的代码可以看一下参考资料。\r\n\r\n参考资料：\r\n\r\n- [web 前端图片懒加载实现原理](https://juejin.cn/post/6844903482164510734)\r\n\r\n#### (2). 响应式图片\r\n\r\n响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。\r\n\r\n通过 picture 实现\r\n\r\n``` html\r\n<picture>\r\n  <source srcset=\"banner_w1000.jpg\" media=\"(min-width: 801px)\">\r\n  <source srcset=\"banner_w800.jpg\" media=\"(max-width: 800px)\">\r\n  <img src=\"banner_w800.jpg\" alt=\"\">\r\n</picture>\r\n```\r\n\r\n通过 @media 实现\r\n\r\n``` css\r\n@media (min-width: 769px) {\r\n  .bg {\r\n    background-image: url(bg1080.jpg);\r\n  }\r\n}\r\n@media (max-width: 768px) {\r\n  .bg {\r\n    background-image: url(bg768.jpg);\r\n  }\r\n}\r\n```\r\n\r\n#### (3). 调整图片大小\r\n\r\n例如，你有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间。\r\n\r\n所以，我们可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。还有一种办法，即对大图进行延迟加载，在所有元素都加载完成后手动更改大图的 src 进行下载。\r\n\r\n#### (4). 降低图片质量\r\n\r\n例如 JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。\r\n\r\n压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。\r\n\r\n以下附上 webpack 插件 image-webpack-loader 的用法。\r\n\r\n``` shell\r\nnpm install --save-dev image-webpack-loader\r\n```\r\n\r\nwebpack 配置\r\n\r\n``` js\r\n{\r\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\r\n  use:[\r\n    {\r\n    loader: 'url-loader',\r\n    options: {\r\n      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/\r\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\r\n      }\r\n    },\r\n    /*对图片进行压缩*/\r\n    {\r\n      loader: 'image-webpack-loader',\r\n      options: {\r\n        bypassOnDebug: true,\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [img图片在webpack中使用](https://juejin.cn/post/6844903816081457159)\r\n\r\n#### (5). 尽可能利用 CSS3 效果代替图片\r\n\r\n有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。\r\n\r\n#### (6). 使用 webp 格式的图片\r\n\r\nWebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。\r\n\r\n参考资料：\r\n\r\n- [WebP 相对于 PNG、JPG 有什么优势？](https://www.zhihu.com/question/27201061)\r\n\r\n### 10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码\r\n\r\n懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。\r\n\r\n#### 根据文件内容生成文件名，结合 import 动态引入组件实现按需加载\r\n\r\n通过配置 output 的 filename 属性可以实现这个需求。filename 属性的值选项中有一个 [contenthash]，它将根据文件内容创建出唯一 hash。当文件内容发生变化时，[contenthash] 也会发生变化。\r\n\r\n``` js\r\n{\r\n  output: {\r\n    filename: '[name].[contenthash].js',\r\n    chunkFilename: '[name].[contenthash].js',\r\n    path: path.resolve(__dirname, '../dist'),\r\n  },\r\n}\r\n```\r\n\r\n#### 提取第三方库\r\n\r\n由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。\r\n\r\n``` js\r\noptimization: {\r\n  runtimeChunk: {\r\n    name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。\r\n  },\r\n  splitChunks: {\r\n    cacheGroups: {\r\n      vendor: {\r\n        name: 'chunk-vendors',\r\n        test: /[\\\\/]node_modules[\\\\/]/,\r\n        priority: -10,\r\n        chunks: 'initial'\r\n      },\r\n      common: {\r\n        name: 'chunk-common',\r\n        minChunks: 2,\r\n        priority: -20,\r\n        chunks: 'initial',\r\n        reuseExistingChunk: true\r\n      }\r\n    },\r\n  }\r\n},\r\n```\r\n\r\n- **test**: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String和Function;\r\n- **priority**: 表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；\r\n- **reuseExistingChunk**: 表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。\r\n- **minChunks**(默认是1): 在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）\r\n- **chunks**(默认是async): initial、async和all\r\n- **name**(打包的chunks的名字): 字符串或者函数(函数可以根据条件自定义名字)\r\n\r\n#### 减少 ES6 转为 ES5 的冗余代码\r\n\r\nBabel 转化后的代码想要实现和原来代码一样的功能需要借助一些帮助函数，比如\r\n\r\n``` js\r\nclass Person {}\r\n```\r\n\r\n会被转换为：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nvar Person = function Person() {\r\n  _classCallCheck(this, Person);\r\n};\r\n```\r\n\r\n这里 `_classCallCheck` 就是一个 `helper` 函数，如果在很多文件里都声明了类，那么就会产生很多个这样的 `helper` 函数。\r\n\r\n这里的 `@babel/runtime` 包就声明了所有需要用到的帮助函数，而 `@babel/plugin-transform-runtime` 的作用就是将所有需要 `helper` 函数的文件，从 `@babel/runtime`包 引进来：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nvar _classCallCheck2 = require(\"@babel/runtime/helpers/classCallCheck\");\r\n\r\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\r\n\r\nfunction _interopRequireDefault(obj) {\r\n  return obj && obj.__esModule ? obj : { default: obj };\r\n}\r\n\r\nvar Person = function Person() {\r\n  (0, _classCallCheck3.default)(this, Person);\r\n};\r\n```\r\n\r\n这里就没有再编译出 helper 函数 classCallCheck 了，而是直接引用了 @babel/runtime 中的 helpers/classCallCheck。\r\n\r\n**安装**\r\n\r\n``` shell\r\nnpm install --save-dev @babel/plugin-transform-runtime @babel/runtime\r\n```\r\n\r\n**使用** 在 .babelrc 文件中\r\n\r\n``` json\r\n{\r\n  \"plugins\": [\r\n    \"@babel/plugin-transform-runtime\"\r\n  ]\r\n}\r\n```\r\n\r\n参考资料：\r\n\r\n- [Babel 7.1介绍 transform-runtime polyfill env](https://www.jianshu.com/p/d078b5f3036a)\r\n- [webpack 懒加载](https://webpack.docschina.org/guides/lazy-loading/)\r\n- [Vue 路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD)\r\n- [webpack 缓存](https://webpack.docschina.org/guides/caching/)\r\n- [一步一步的了解webpack4的splitChunk插件](https://juejin.cn/post/6844903614759043079)\r\n\r\n### 11. 减少重绘重排\r\n\r\n浏览器渲染过程\r\n\r\n1. 解析HTML生成DOM树。\r\n2. 解析CSS生成CSSOM规则树。\r\n3. 将DOM树与CSSOM规则树合并在一起生成渲染树。\r\n4. 遍历渲染树开始布局，计算每个节点的位置大小信息。\r\n5. 将渲染树每个节点绘制到屏幕。\r\n\r\n![渲染树生成](https://user-images.githubusercontent.com/8088864/125440124-9cc83d52-c342-4959-af1e-dc67cfe7d312.png)\r\n\r\n#### 重排\r\n\r\n当改变 DOM 元素位置或大小时，会导致浏览器重新生成渲染树，这个过程叫重排。\r\n\r\n#### 重绘\r\n\r\n当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕，这个过程叫重绘。不是所有的动作都会导致重排，例如改变字体颜色，只会导致重绘。记住，重排会导致重绘，重绘不会导致重排。\r\n\r\n重排和重绘这两个操作都是非常昂贵的，因为 **JavaScript** 引擎线程与 **GUI** 渲染线程是互斥，它们同时只能一个在工作。\r\n\r\n什么操作会导致重排？\r\n\r\n- 添加或删除可见的 **DOM** 元素\r\n- 元素位置改变\r\n- 元素尺寸改变\r\n- 内容改变\r\n- 浏览器窗口尺寸改变\r\n\r\n- 如何减少重排重绘？\r\n\r\n- 用 **JavaScript** 修改样式时，最好不要直接写样式，而是替换 **class** 来改变样式。\r\n- 如果要对 **DOM** 元素执行一系列操作，可以将 **DOM** 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（**display:none**）或文档碎片（**DocumentFragment**），都能很好的实现这个方案。\r\n\r\n### 12. 使用事件委托\r\n\r\n事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。\r\n\r\n``` html\r\n<ul>\r\n  <li>苹果</li>\r\n  <li>香蕉</li>\r\n  <li>凤梨</li>\r\n</ul>\r\n```\r\n\r\n``` js\r\n// good\r\ndocument.querySelector('ul').onclick = (event) => {\r\n  const target = event.target\r\n  if (target.nodeName === 'LI') {\r\n    console.log(target.innerHTML)\r\n  }\r\n}\r\n\r\n// bad\r\ndocument.querySelectorAll('li').forEach((e) => {\r\n  e.onclick = function() {\r\n    console.log(this.innerHTML)\r\n  }\r\n})\r\n```\r\n\r\n### 13. 注意程序的局部性\r\n\r\n一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用最近引用过的数据项附近的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。有良好局部性的程序比局部性差的程序运行得更快。\r\n\r\n**局部性通常有两种不同的形式：**\r\n\r\n- 时间局部性: 在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。\r\n- 空间局部性: 在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。\r\n\r\n时间局部性示例\r\n\r\n``` js\r\nfunction sum(arry) {\r\n  let i, sum = 0;\r\n  let len = arry.length;\r\n\r\n  for (i = 0; i < len; i++) {\r\n    sum += arry[i];\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n在这个例子中，变量sum在每次循环迭代中被引用一次，因此，对于sum来说，具有良好的时间局部性\r\n\r\n空间局部性示例\r\n\r\n**具有良好空间局部性的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i < rows; i++) {\r\n    for (j = 0; j < cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n**空间局部性差的程序**\r\n\r\n``` js\r\n// 二维数组\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j < cols; j++) {\r\n    for (i = 0; i < rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n```\r\n\r\n看一下上面的两个空间局部性示例，像示例中从每行开始按顺序访问数组每个元素的方式，称为具有步长为1的引用模式。 如果在数组中，每隔k个元素进行访问，就称为步长为k的引用模式。 一般而言，随着步长的增加，空间局部性下降。\r\n\r\n这两个例子有什么区别？区别在于第一个示例是按行扫描数组，每扫描完一行再去扫下一行；第二个示例是按列来扫描数组，扫完一行中的一个元素，马上就去扫下一行中的同一列元素。\r\n\r\n数组在内存中是按照行顺序来存放的，结果就是逐行扫描数组的示例得到了步长为 1 引用模式，具有良好的空间局部性；而另一个示例步长为 rows，空间局部性极差。\r\n\r\n**性能测试**\r\n\r\n运行环境：\r\n\r\n- cpu: i7-10510U\r\n- 浏览器: 83.0.4103.61\r\n\r\n对一个长度为9000的二维数组（子数组长度也为9000）进行10次空间局部性测试，时间（毫秒）取平均值，结果如下：\r\n\r\n``` js\r\nfunction sum2(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (j = 0; j < cols; j++) {\r\n    for (i = 0; i < rows; i++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\n// 二维数组\r\nfunction sum1(arry, rows, cols) {\r\n  let i, j, sum = 0;\r\n\r\n  for (i = 0; i < rows; i++) {\r\n    for (j = 0; j < cols; j++) {\r\n      sum += arry[i][j];\r\n    }\r\n  }\r\n\r\n  return sum;\r\n}\r\n\r\nvar arry = new Array(9000).fill(new Array(9000).fill(1));\r\n\r\nlet ts = 0;\r\nfor (let i = 0; i < 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum1(arry, 9000, 9000);\r\n  ts += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum1: ' + (ts / 10)); // 81.5ms\r\n\r\nlet ts2 = 0;\r\nfor (let i = 0; i < 10; i++) {\r\n  const startTime = new Date().valueOf();\r\n  sum2(arry, 9000, 9000);\r\n  ts2 += (new Date().valueOf() - startTime);\r\n}\r\n\r\nconsole.log('sum2: ' + (ts2 / 10)); // 167.3ms\r\n```\r\n\r\n所用示例为上述两个空间局部性示例\r\n\r\n| 步长为1(sum1) | 步长为9000(sum2) |\r\n| ---- | ---- |\r\n| 81.5ms | 167.3ms |\r\n\r\n从以上测试结果来看，步长为 1 的数组执行时间比步长为 9000 的数组快了一个数量级。\r\n\r\n总结：\r\n\r\n- 重复引用相同变量的程序具有良好的时间局部性\r\n- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好；而在内存中以大步长跳来跳去的程序空间局部性会很差\r\n\r\n参考资料：\r\n\r\n- [深入理解计算机系统](https://book.douban.com/subject/26912767/)\r\n\r\n### 14. if-else 对比 switch\r\n\r\n当判断条件数量越来越多时，越倾向于使用 switch 而不是 if-else。\r\n\r\n``` js\r\nif (color == 'blue') {\r\n\r\n} else if (color == 'yellow') {\r\n\r\n} else if (color == 'white') {\r\n\r\n} else if (color == 'black') {\r\n\r\n} else if (color == 'green') {\r\n\r\n} else if (color == 'orange') {\r\n\r\n} else if (color == 'pink') {\r\n\r\n}\r\n\r\nswitch (color) {\r\n  case 'blue':\r\n\r\n    break;\r\n  case 'yellow':\r\n\r\n    break;\r\n  case 'white':\r\n\r\n    break;\r\n  case 'black':\r\n\r\n    break;\r\n  case 'green':\r\n\r\n    break;\r\n  case 'orange':\r\n\r\n    break;\r\n  case 'pink':\r\n\r\n    break;\r\n}\r\n```\r\n\r\n像以上这种情况，使用 switch 是最好的。假设 color 的值为 pink，则 if-else 语句要进行 7 次判断，switch 只需要进行一次判断。 从可读性来说，switch 语句也更好。\r\n\r\n从使用时机来说，当条件值大于两个的时候，使用 switch 更好。不过 if-else 也有 switch 无法做到的事情，例如有多个判断条件的情况下，无法使用 switch。\r\n\r\n### 15. 查找表\r\n\r\n当条件语句特别多时，使用 switch 和 if-else 不是最佳的选择，这时不妨试一下查找表。查找表可以使用数组和对象来构建。\r\n\r\n``` js\r\nswitch (index) {\r\n  case '0':\r\n    return result0;\r\n  case '1':\r\n    return result1;\r\n  case '2':\r\n    return result2;\r\n  case '3':\r\n    return result3;\r\n  case '4':\r\n    return result4;\r\n  case '5':\r\n    return result5;\r\n  case '6':\r\n    return result6;\r\n  case '7':\r\n    return result7;\r\n  case '8':\r\n    return result8;\r\n  case '9':\r\n    return result9;\r\n  case '10':\r\n    return result10;\r\n  case '11':\r\n    return result11;\r\n}\r\n```\r\n\r\n可以将这个 switch 语句转换为查找表\r\n\r\n``` js\r\nconst results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11];\r\n\r\nreturn results[index];\r\n```\r\n\r\n如果条件语句不是数值而是字符串，可以用对象来建立查找表\r\n\r\n``` js\r\nconst map = {\r\n  red: result0,\r\n  green: result1,\r\n};\r\n\r\nreturn map[color];\r\n```\r\n\r\n### 16. 避免页面卡顿\r\n\r\n**60fps 与设备刷新率**\r\n\r\n目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果在页面中有一个动画或渐变效果，或者用户正在滚动页面，那么浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致。 其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\r\n\r\n![网页渲染流程](https://user-images.githubusercontent.com/8088864/125445172-29d132ea-e485-49c7-b32d-172956c4349b.jpeg)\r\n\r\n假如你用 JavaScript 修改了 DOM，并触发样式修改，经历重排重绘最后画到屏幕上。如果这其中任意一项的执行时间过长，都会导致渲染这一帧的时间过长，平均帧率就会下降。假设这一帧花了 50 ms，那么此时的帧率为 1s / 50ms = 20fps，页面看起来就像卡顿了一样。\r\n\r\n对于一些长时间运行的 JavaScript，我们可以使用定时器进行切分，延迟执行。\r\n\r\n``` js\r\nfor (let i = 0, len = arry.length; i < len; i++) {\r\n  process(arry[i]);\r\n}\r\n```\r\n\r\n假设上面的循环结构由于 process() 复杂度过高或数组元素太多，甚至两者都有，可以尝试一下切分。\r\n\r\n``` js\r\nconst todo = arry.concat();\r\nsetTimeout(function(){\r\n  process(todo.shift());\r\n  if (todo.length) {\r\n    setTimeout(arguments.callee, 25);\r\n  } else {\r\n    callback(arry);\r\n  }\r\n}, 25);\r\n```\r\n\r\n如果有兴趣了解更多，可以查看一下高性能JavaScript第 6 章和[高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)第 3 章。\r\n\r\n### 17. 使用 requestAnimationFrame 来实现视觉变化\r\n\r\n从第 16 点我们可以知道，大多数设备屏幕刷新率为 60 次/秒，也就是说每一帧的平均时间为 16.66 毫秒。在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 `requestAnimationFrame`。\r\n\r\n``` js\r\n/**\r\n * If run as a requestAnimationFrame callback, this\r\n * will be run at the start of the frame.\r\n */\r\nfunction updateScreen(time) {\r\n  // Make visual updates here.\r\n}\r\n\r\nrequestAnimationFrame(updateScreen);\r\n```\r\n\r\n如果采取 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿。\r\n\r\n![requestAnimationFrame执行点](https://user-images.githubusercontent.com/8088864/125448006-c889aac7-f5d6-4a21-a4fe-b4c6c0cdf197.jpg)\r\n\r\n### 18. 使用 Web Workers\r\n\r\nWeb Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。\r\n\r\nWeb Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。\r\n\r\n创建一个新的 worker 很简单，指定一个脚本的 URI 来执行 worker 线程（main.js）：\r\n\r\n``` js\r\nvar myWorker = new Worker('worker.js');\r\n// 你可以通过postMessage() 方法和onmessage事件向worker发送消息。\r\nfirst.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n\r\nsecond.onchange = function() {\r\n  myWorker.postMessage([first.value,second.value]);\r\n  console.log('Message posted to worker');\r\n}\r\n```\r\n\r\n在 worker 中接收到消息后，我们可以写一个事件处理函数代码作为响应（worker.js）：\r\n\r\n``` js\r\nonmessage = function(e) {\r\n  console.log('Message received from main script');\r\n  var workerResult = 'Result: ' + (e.data[0] * e.data[1]);\r\n  console.log('Posting message back to main script');\r\n  postMessage(workerResult);\r\n}\r\n```\r\n\r\nonmessage处理函数在接收到消息后马上执行，代码中消息本身作为事件的data属性进行使用。这里我们简单的对这2个数字作乘法处理并再次使用postMessage()方法，将结果回传给主线程。\r\n\r\n回到主线程，我们再次使用onmessage以响应worker回传的消息：\r\n\r\n``` js\r\nmyWorker.onmessage = function(e) {\r\n  result.textContent = e.data;\r\n  console.log('Message received from worker');\r\n}\r\n```\r\n\r\n在这里我们获取消息事件的data，并且将它设置为result的textContent，所以用户可以直接看到运算的结果。\r\n\r\n不过在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。然而你可以使用大量window对象之下的东西，包括WebSockets，IndexedDB以及FireFox OS专用的Data Store API等数据存储机制。\r\n\r\n参考资料：\r\n\r\n- [Web Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\r\n\r\n### 19. 使用位操作\r\n\r\nJavaScript 中的数字都使用 IEEE-754 标准以 64 位格式存储。但是在位操作中，数字被转换为有符号的 32 位格式。即使需要转换，位操作也比其他数学运算和布尔操作快得多。\r\n\r\n#### 取模\r\n\r\n由于偶数的最低位为 0，奇数为 1，所以取模运算可以用位操作来代替。\r\n\r\n``` js\r\nif (value % 2) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n// 位操作\r\nif (value & 1) {\r\n    // 奇数\r\n} else {\r\n    // 偶数\r\n}\r\n```\r\n\r\n#### 取整\r\n\r\n``` js\r\n~~10.12 // 10\r\n~~10 // 10\r\n~~'1.5' // 1\r\n~~undefined // 0\r\n~~null // 0\r\n```\r\n\r\n#### 位掩码\r\n\r\n``` js\r\nconst a = 1\r\nconst b = 2\r\nconst c = 4\r\nconst options = a | b | c\r\n```\r\n\r\n通过定义这些选项，可以用按位与操作来判断 a/b/c 是否在 options 中。\r\n\r\n``` js\r\n// 选项 b 是否在选项中\r\nif (b & options) {\r\n  // ...\r\n}\r\n```\r\n\r\n### 20. 不要覆盖原生方法\r\n\r\n无论你的 JavaScript 代码如何优化，都比不上原生方法。因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，成为浏览器的一部分。当原生方法可用时，尽量使用它们，特别是数学运算和 DOM 操作。\r\n\r\n### 21. 降低 CSS 选择器的复杂性\r\n\r\n#### (1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取\r\n\r\n看个示例\r\n\r\n``` css\r\n#block .text p {\r\n    color: red;\r\n}\r\n```\r\n\r\n1. 查找所有 P 元素。\r\n2. 查找结果 1 中的元素是否有类名为 text 的父元素\r\n3. 查找结果 2 中的元素是否有 id 为 block 的父元素\r\n\r\n#### (2). CSS 选择器优先级\r\n\r\n```\r\n内联 > ID选择器 > 类选择器 > 标签选择器\r\n```\r\n\r\n根据以上两个信息可以得出结论。\r\n\r\n1. 选择器越短越好。\r\n2. 尽量使用高优先级的选择器，例如 ID 和类选择器。\r\n3. 避免使用通配符 *。\r\n\r\n最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。\r\n\r\n### 22. 使用 flexbox 而不是较早的布局模型\r\n\r\n在早期的 CSS 布局方式中我们能对元素实行绝对定位、相对定位或浮动定位。而现在，我们有了新的布局方式 [flexbox](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox)，它比起早期的布局方式来说有个优势，那就是性能比较好。\r\n\r\n下面的截图显示了在 1300 个框上使用浮动的布局开销：\r\n\r\n![float布局的元素](https://user-images.githubusercontent.com/8088864/125547454-c911b26b-4a1c-44d8-9044-e83a09dc618d.jpg)\r\n\r\n然后我们用 flexbox 来重现这个例子：\r\n\r\n![flexbox布局的元素](https://user-images.githubusercontent.com/8088864/125547509-ecf25fd0-a9ef-438c-827a-987ea0bb9ae5.jpg)\r\n\r\n现在，对于相同数量的元素和相同的视觉外观，布局的时间要少得多（本例中为分别 3.5 毫秒和 14 毫秒）。\r\n\r\n不过 flexbox 兼容性还是有点问题，不是所有浏览器都支持它，所以要谨慎使用。\r\n\r\n各浏览器兼容性：\r\n\r\n- Chrome 29+\r\n- Firefox 28+\r\n- Internet Explorer 11\r\n- Opera 17+\r\n- Safari 6.1+ (prefixed with -webkit-)\r\n- Android 4.4+\r\n- iOS 7.1+ (prefixed with -webkit-)\r\n\r\n但是在可能的情况下，至少应研究布局模型对网站性能的影响，并且采用最大程度减少网页执行开销的模型。\r\n\r\n在任何情况下，不管是否选择 Flexbox，都应当在应用的高压力点期间尝试完全避免触发布局！\r\n\r\n### 23. 使用 transform 和 opacity 属性更改来实现动画\r\n\r\n在 CSS 中，transforms 和 opacity 这两个属性更改不会触发重排与重绘，它们是可以由合成器（composite）单独处理的属性。\r\n\r\n![使用 transform 和 opacity 属性更改来实现动画](https://user-images.githubusercontent.com/8088864/125547800-ab61c27b-23fb-45bd-9d6a-2585df8d804e.jpeg)\r\n\r\n### 24. 合理使用规则，避免过度优化\r\n\r\n性能优化主要分为两类：\r\n\r\n1. 加载时优化\r\n2. 运行时优化\r\n\r\n上述 23 条建议中，属于加载时优化的是前面 10 条建议，属于运行时优化的是后面 13 条建议。通常来说，没有必要 23 条性能优化规则都用上，根据网站用户群体来做针对性的调整是最好的，节省精力，节省时间。\r\n\r\n在解决问题之前，得先找出问题，否则无从下手。所以在做性能优化之前，最好先调查一下网站的加载性能和运行性能。\r\n\r\n#### 检查加载性能\r\n\r\n一个网站加载性能如何主要看白屏时间和首屏时间。\r\n\r\n- 白屏时间：指从输入网址，到页面开始显示内容的时间。\r\n- 首屏时间：指从输入网址，到页面完全渲染的时间。\r\n\r\n将以下脚本放在 \\</head> 前面就能获取白屏时间。\r\n\r\n``` html\r\n<script>\r\n  new Date() - performance.timing.navigationStart\r\n</script>\r\n```\r\n\r\n在 `window.onload` 事件里执行 `new Date() - performance.timing.navigationStart` 即可获取首屏时间。\r\n\r\n#### 检查运行性能\r\n\r\n配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。\r\n\r\n打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。\r\n\r\n通过检查加载和运行性能，相信你对网站性能已经有了大概了解。所以这时候要做的事情，就是使用上述 23 条建议尽情地去优化你的网站，加油！\r\n\r\n参考资料：\r\n\r\n- [performance.timing.navigationStart](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming/navigationStart)\r\n\r\n其他参考资料\r\n\r\n- 高性能网站建设指南\r\n- Web性能权威指南\r\n- 高性能JavaScript\r\n- [高效前端：Web高效编程与优化实践](https://book.douban.com/subject/30170670/)\r\n\r\n## 五、强缓存与协商缓存\r\n\r\n### 浏览器缓存\r\n\r\n当浏览器去请求某个文件的时候，服务端就在response header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制\r\n\r\n#### 缓存优点\r\n\r\n1. 减少了不必要的数据传输,节省带宽\r\n2. 减少服务器的负担,提升网站性能\r\n3. 加快了客户端加载网页的速度\r\n4. 用户体验友好\r\n\r\n#### 缓存缺点\r\n\r\n资源如果有更改,会导致客户端不及时更新就会造成用户获取信息滞后\r\n\r\n#### 缓存流程\r\n\r\n浏览器第一次请求时\r\n\r\n![浏览器缓存第一次请求](https://user-images.githubusercontent.com/8088864/125554789-a7d7d647-b89f-4c84-a326-5af87e6782f6.png)\r\n\r\n浏览器后续在进行请求时\r\n\r\n![浏览器缓存再次请求](https://user-images.githubusercontent.com/8088864/125554810-255dcfd2-a1f0-4e09-a329-56bacdee6d22.png)\r\n\r\n从上图可以知道,浏览器缓存包括两种类型,即强缓存(本地缓存)和协商缓存,浏览器在第一次请求发生后,再次请求时\r\n\r\n- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（`cache-control`和`expires`信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信。\r\n\r\n请求头信息\r\n\r\n```\r\nAccept: xxx\r\nAccept-Encoding: gzip,deflate\r\nAccept-Language: zh-cn\r\nConnection: keep-alive\r\nHost: xxx\r\nReferer: xxx\r\nUser-Agent: xxx\r\n```\r\n\r\n来自缓存的响应头的信息\r\n\r\n```\r\nAccept-Ranges: bytes\r\nCache-Control: max-age= xxxx\r\nContent-Encoding: gzip\r\nContent-length: 3333\r\nContent-Type: application/javascript\r\nDate: xxx\r\nExpires: xxx\r\nLast-Modified: xxx\r\nServer: 服务器\r\n```\r\n\r\n- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（`Last-Modified`/`If-Modified-Since`和`Etag`/`If-None-Match`），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。\r\n\r\n强缓存与协商缓存的区别，可以用下表来进行描述：\r\n\r\n|  | 获取资源形式 | 状态码 | 发送请求到服务器 |\r\n| ---- | ---- | ---- | ---- |\r\n| **强缓存** | 从缓存取 | 200（from cache） | 否，直接从缓存取 |\r\n| **协商缓存** | 从缓存取 |  304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |\r\n\r\n### 强缓存相关的header字段\r\n\r\n强缓存上面已经介绍了，直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个：\r\n\r\n1. **expires**: 这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如**Mon, 10 Jun 2015 21:31:12 GMT**，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。\r\n2. **cache-control：max-age=number**: 这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：\r\n\r\n- **no-cache**: 不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。\r\n- **no-store**: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\r\n- **public**: 可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\r\n- **private**: 只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\r\n\r\n**注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires。**\r\n\r\n### 协商缓存相关的header字段\r\n\r\n协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（`Last-Modified`或者`Etag`），则后续请求则会带上对应的请求字段（`If-Modified-Since`或者`If-None-Match`），若响应头没有`Last-Modified`或者`Etag`字段，则请求头也不会有对应的字段。\r\n\r\n#### 1. Last-Modified/If-Modified-Since\r\n\r\n二者的值都是GMT格式的时间字符串，具体过程：\r\n\r\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上`Last-Modified`的header，这个header表示这个资源在服务器上的最后修改时间\r\n\r\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上`If-Modified-Since`的header，这个header的值就是上一次请求时返回的Last-Modified的值\r\n\r\n- 服务器再次收到资源请求时，根据浏览器传过来`If-Modified-Since`和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回`304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回`304 Not Modified`的响应时，response header中不会再添加`Last-Modified`的header，因为既然资源没有变化，那么`Last-Modified`也就不会改变，这是服务器返回304时的response header\r\n\r\n- 浏览器收到304的响应后，就会从缓存中加载资源\r\n\r\n- 如果协商缓存没有命中，浏览器直接从服务器加载资源时，`Last-Modified`的Header在重新加载的时候会被更新，下次请求时，`If-Modified-Since`会启用上次返回的`Last-Modified`值\r\n\r\n#### 2. Etag/If-None-Match\r\n\r\n这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与**Last-Modified/If-Modified-Since**类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\r\n\r\n### 既生Last-Modified何生Etag\r\n\r\n你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\r\n\r\n- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\r\n\r\n- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\r\n\r\n- 某些服务器不能精确的得到文件的最后修改时间。\r\n\r\n这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\r\n\r\n**注意: Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。**\r\n\r\n### 用户的行为对缓存的影响\r\n\r\n| 用户操作 | Expires/Cache-Control | Last-Modified/ETag |\r\n| ---- | ---- | ---- |\r\n| 地址栏回车 | 有效 | 有效 |\r\n| 页面链接条状 | 有效 | 有效 |\r\n| 新开窗口 | 有效 | 有效 |\r\n| 前进后退 | 有效 | 有效 |\r\n| F5刷新 | 无效 | 有效 |\r\n| Ctrl + F5强制刷新 | 无效 | 无效 |\r\n\r\n### 强缓存如何重新加载缓存缓存过的资源\r\n\r\n使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\r\n\r\n**通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。**\r\n\r\n``` html\r\n<link rel=\"stylesheet\" href=\"a.css?a=1.0\" />\r\n...\r\n<div class=\"app\">app</div>\r\n```\r\n\r\n这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了。\r\n\r\n## 六、HTTP 各版本特点与区别\r\n\r\nHTTP协议到现在为止总共经历了3个版本的演化，第一个HTTP协议诞生于1989年3月。\r\n\r\n| 版本 | 功能 | 备注 |\r\n| ---- | ---- | ---- |\r\n| HTTP 0.9 | 仅支持 Get <br /> 仅能访问 HTML 格式资源 | 简单单一 |\r\n| HTTP 1.0 | 新增POST，DELETE，PUT，HEADER等方式 <br />  增加请求头和响应头概念，指定协议版本号，携带其他元信息（状态码、权限、缓存、内容编码）<br />  扩展传输内容格式（图片、音视频、二进制等都可以传输） | 存活时间短 |\r\n| HTTP 1.1 | 长连接：新增 Connection 字段,可以通过keep-alive保持长连接 <br /> 管道化：一次连接就形成一次管道，管道内进行多次有序响应。允许服务端发生多次请求，但是响应按序返回 <br /> 缓存处理：新增 cache-control <br /> 断点续传 <br /> 状态码增加 | 当前主流版本号 <br /> 存在Header 重复问题 |\r\n| HTTP 2.0 | 二进制分帧：数据体和头信息可以都是二进制，统称帧 <br /> 多路复用与数据流：能同时发送和响应多个请求，通过数据流来传输 <br /> 头部压缩：对 Header 进行压缩,避免重复浪费 <br /> 服务器推送：服务器可以向客户端主动发送资源 | 2005发布 |\r\n\r\n### 1、HTTP 0.9\r\n\r\nHTTP 0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP 0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。\r\n\r\nHTTP 0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP 0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。\r\n\r\n### 2、HTTP 1.0\r\n\r\nHTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP 0.9 增加了如下主要特性：\r\n\r\n- 请求与响应支持头域\r\n- 响应对象以一个响应状态行开始\r\n- 响应对象不只限于超文本\r\n- 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法\r\n- （短连接）每一个请求建立一个TCP连接，请求完成后立马断开连接。这将会导致2个问题：连接无法复用，head of line blocking。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。\r\n\r\n### 3、HTTP 1.1\r\n\r\nHTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 。HTTP 1.1是目前主流的HTTP协议版本，因此这里就多花一些笔墨介绍一下HTTP 1.1的特性。\r\n\r\nHTTP 1.1引入了许多关键性能优化：keepalive连接，chunked编码传输，字节范围请求，请求流水线等\r\n\r\n#### Persistent Connection（keepalive连接）\r\n\r\n允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接，直到客户端或服务器端决定将其关闭为止。在HTTP1.0中使用长连接需要添加请求头 `Connection: Keep-Alive`，而在HTTP 1.1 所有的连接默认都是长连接，除非特殊声明不支持（ HTTP请求报文首部加上`Connection: close` ）。服务器端按照FIFO原则来处理不同的Request。\r\n\r\n![长连接(keepalive连接)](https://user-images.githubusercontent.com/8088864/125572282-1b48362e-ed29-42a1-9882-3710ab106b76.jpg)\r\n\r\n#### chunked编码传输\r\n\r\n该编码将实体分块传送并逐块标明长度，直到长度为0块表示传输结束，这在实体长度未知时特别有用(比如由数据库动态产生的数据)\r\n\r\n#### 字节范围请求\r\n\r\nHTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。该功能通过在请求消息中引入了range头域来实现，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码206（Partial Content）\r\n\r\n#### 断点续传\r\n\r\nHeader 字段\r\n\r\n服务端\r\n\r\nAccept-Ranges:表示服务器支持断点续传，并且数据传输已字节为单位\r\n\r\nEtag:资源的唯一 tag 后端自定义，验证文件是否修改过。修改过就重新重头传输\r\n\r\nLast-Modified:文件上次修改时间\r\n\r\nContent-Range:返回数据范围\r\n\r\n客户端\r\n\r\nIf-Range:服务器给的 Etag 值\r\n\r\nRange:请求的数据范围\r\n\r\nIf-Modified-Since: 将服务器响应的 Last-Modified 保存， 下次发送可以携带，后台接受判断文件是否修改，没有可以返回 304状态码，叫客户端使用缓存数据，避免重复发出资源。\r\n\r\n流程\r\n\r\n![断点续传](https://user-images.githubusercontent.com/8088864/125573335-f1eda73b-ad4f-470a-808f-caa393e38b2e.png)\r\n\r\n**注意：断点续传后台返回状态码为 206。**\r\n\r\n#### Pipelining（请求流水线）\r\n\r\n#### 其他特性\r\n\r\n另外，HTTP 1.1还新增了如下特性：\r\n\r\n- 请求消息和响应消息都支持Host头域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。因此，Host头的引入就很有必要了。\r\n\r\n- 新增了一批Request method：HTTP1.1增加了OPTIONS, PUT, DELETE, TRACE, CONNECT方法\r\n\r\n- 缓存处理：HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。\r\n\r\n### 4、HTTP 2.0\r\n\r\nHTTP 2.0是下一代HTTP协议。主要特点有：\r\n\r\n#### 二进制分帧\r\n\r\nHTTP 2.0最大的特点：不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。\r\n\r\n![二进制分帧](https://user-images.githubusercontent.com/8088864/125574741-7645e5f9-3476-44f3-94eb-4a3aaebce2ae.jpg)\r\n\r\n#### 多路复用\r\n\r\nHTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。\r\n\r\n通过单一的 HTTP2.0连接连续发起多重请求-响应消息，即客户端和服务器可以同时发送多个请求和响应，而不用顺序一一对应。\r\n\r\n每个数据流以HTTP消息的形式发送，HTTP消息被分为独立的帧，然后由一或多个帧组成，这些帧可以乱序发送，接收端根据这些帧的标识符号和首部将信息重新组装起来。\r\n\r\n默认什么情况下使用同一个连接\r\n\r\n- 同一个域名下的资源\r\n- 不同域名但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书\r\n\r\n#### 头部压缩\r\n\r\n当一个客户端向相同服务器请求许多资源时，像来自同一个网页的图像，将会有大量的请求看上去几乎同样的，这就需要压缩技术对付这种几乎相同的信息。\r\n\r\n由于头信息使用文本，没有压缩，请求时候会来回重复传递，造成流量浪费。\r\n\r\n参考[HTTP2头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)\r\n\r\n头部压缩需要支持 HTTP2的浏览器和服务器之间：\r\n\r\n- 维护一份相同的静态字典（包含常见的头部名称，以及常见的头部名称与值的组合）\r\n- 维护一份相同的动态字典，动态添加内容（即实际的 Header 值）\r\n- 支持基于静态哈夫曼码表的哈夫曼编码（uffman Coding）\r\n\r\n原理图：\r\n\r\n![http头部压缩原理](https://user-images.githubusercontent.com/8088864/125578550-82fd62aa-eb21-4813-87d1-19904e1b42fc.png)\r\n\r\n总结： 通过映射表，传递对应编码和值来达到压缩。\r\n\r\n#### 随时复位\r\n\r\nHTTP1.1一个缺点是当HTTP信息有一定长度大小数据传输时，你不能方便地随时停止它，中断TCP连接的代价是昂贵的。使用HTTP2的RST_STREAM将能方便停止一个信息传输，启动新的信息，在不中断连接的情况下提高带宽利用效率。\r\n\r\n#### 服务器端推流\r\n\r\nServer Push。客户端请求一个资源X，服务器端判断也许客户端还需要资源Z，在无需事先询问客户端情况下将资源Z推送到客户端，客户端接受到后，可以缓存起来以备后用。\r\n\r\n#### 优先权和依赖\r\n\r\n每个流都有自己的优先级别，会表明哪个流是最重要的，客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。\r\n\r\n## 七、队头阻塞以及解决办法\r\n\r\n### 前言\r\n\r\n通常我们提到队头阻塞，指的可能是TCP协议中的队头阻塞，但是HTTP1.1中也有一个类似TCP队头阻塞的问题，下面各自介绍一下。\r\n\r\n### TCP队头阻塞\r\n\r\n队头阻塞（head-of-line blocking）发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种为了达到完全有序而引入的延迟机制非常有用，但也有不利之处。\r\n\r\n假设在单个TCP连接上发送语义独立的消息，比如说服务器可能发送3幅不同的图像供Web浏览器显示。为了营造这几幅图像在用户屏幕上并行显示的效果，服务器先发送第一幅图像的一个断片，再发送第二幅图像的一个断片，然后再发送第三幅图像的一个断片；服务器重复这个过程，直到这3幅图像全部成功地发送到浏览器为止。\r\n\r\n要是第一幅图像的某个断片内容的TCP分节丢失了，客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。\r\n\r\n### HTTP队头阻塞\r\n\r\n上面用浏览器请求图片资源举例子，但实际上HTTP自身也有类似TCP队头阻塞的情况。要介绍HTTP队头阻塞，就需要先讲讲HTTP的管道化（pipelining）。\r\n\r\n#### HTTP管道化是什么\r\n\r\nHTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。\r\n\r\n非管道化与管道化的区别示意图\r\n\r\n![HTTP非管道化与管道化](https://user-images.githubusercontent.com/8088864/125586316-36604fa7-fcc1-453b-9ae3-4c84b39690bd.png)\r\n\r\n#### HTTP管道化产生的背景\r\n\r\n在一般情况下，HTTP遵守“请求-响应”的模式，也就是客户端每次发送一个请求到服务端，服务端返回响应。这种模式非常容易理解，但是效率并不是那么高，为了提高速度和效率，人们做了很多尝试：\r\n\r\n- 最简单的情况下，服务端一旦返回响应后就会把对应的连接关闭，客户端的多个请求实际上是串行发送的。\r\n- 除此之外，客户端可以选择同时创建多个连接，在多个连接上并行的发送不同请求。但是创建更多连接也带来了更多的消耗，当前大部分浏览器都会限制对同一个域名的连接数。\r\n- 从HTTP1.0开始增加了持久连接的概念（HTTP1.0的Keep-Alive和HTTP1.1的persistent），可以使HTTP能够复用已经创建好的连接。客户端在收到服务端响应后，可以复用上次的连接发送下一个请求，而不用重新建立连接。\r\n- 现代浏览器大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。\r\n- 而在持久连接的基础上，HTTP1.1进一步地支持在持久连接上使用管道化（pipelining）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。但是因为HTTP管道化本身可能会导致队头阻塞的问题，以及一些其他的原因，现代浏览器默认都关闭了管道化。\r\n\r\n#### HTTP管道化的限制\r\n\r\n1. 管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。\r\n2. 客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。\r\n3. 只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果\r\n\r\n#### HTTP管道化引起的请求队头阻塞\r\n\r\n前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。\r\n\r\n### 如何解决队头阻塞\r\n\r\n#### 如何解决HTTP队头阻塞\r\n\r\n对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2解决。HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。\r\n\r\n当然，即使使用HTTP2，如果HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。\r\n\r\n#### 如何解决TCP队头阻塞\r\n\r\nTCP中的队头阻塞的产生是由TCP自身的实现机制决定的，无法避免。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。\r\n\r\n比如google推出的QUIC协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。\r\n\r\n此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。\r\n\r\n### 总结\r\n\r\n从TCP队头阻塞和HTTP队头阻塞的原因我们可以看到，出现队头阻塞的原因有两个：\r\n\r\n  1. 独立的消息数据都在一个链路上传输，也就是有一个“队列”。比如TCP只有一个流，多个HTTP请求共用一个TCP连接\r\n  2. 队列上传输的数据有严格的顺序约束。比如TCP要求数据严格按照序号顺序，HTTP管道化要求响应严格按照请求顺序返回\r\n\r\n所以要避免队头阻塞，就需要从以上两个方面出发，比如quic协议不使用TCP协议而是使用UDP协议，SCTP协议支持一个连接上存在多个数据流等等。\r\n\r\n## 八、QUIC\r\n\r\nQUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。\r\n\r\n### QUIC的由来：为什么是UDP而非TCP？\r\n\r\nUDP和TCP都属于传输层协议。TCP是面向连接的，更强调的是传输的可靠性，通过TCP连接传送的数据，无差错，不丢失，不重复，按序到达，但是因为TCP在传递数据之前会有三次握手来建立连接，所以效率低、占用系统的CPU、内存等硬件资源较高；而UDP的无连接的（即发送数据之前不需要建立连接），只需要知道对方地址即可发送数据，具有较好的实时性，工作效率比TCP高，占用系统资源比TCP少，但是在数据传递时，如果网络质量不好，就会很容易丢包。\r\n\r\n我们知道，大部分Web平台的数据传输都基于TCP协议。实际上，TCP在设计之初，网络环境复杂、丢包率高、网速差，所以TCP可以完美解决可靠性的问题。而如今的网络环境和网速都已经取得了巨大的改善，网络传输可靠性已经不再是棘手的问题。另外，TCP还有一个很大的问题是更新非常困难。这是因为：TCP网络协议栈的实现依赖于系统内核更新，一旦系统内核更新，终端设备、中间设备的系统更新都会非常缓慢，迭代需要花费几年甚至十几年的时间，这显然跟不上当今互联网的发展速度。所以现在解法就是，抛弃TCP而使用UDP，来实现低延迟的传输需求。\r\n\r\n![QUIC is very similar to TCP TLS HTTP 2 0 implemented on UDP](https://user-images.githubusercontent.com/8088864/125581409-742f54c2-93aa-4d3a-919e-d3710b318361.jpg)\r\n\r\n为了结合两者优点，谷歌公司推出了QUIC，它的升级不依赖于系统内核，只需要Client和Server端更新到指定版本。如此一来，基于UDP的QUIC就能月更甚至周更，很好的解决了TCP部署和更新的困难，更灵活地实现部署和更新。\r\n\r\n### 为什么要用QUIC？\r\n\r\n#### 1. 建连延迟低\r\n\r\n网民传统TCP三次握手+TLS1~2RTT握手+http数据，基于TCP的HTTPS一次建连至少需要2~3个RTT，而QUIC基于UDP，完整握手只需要1RTT乃至0RTT，可以显著降低延迟。\r\n\r\n![QUIC握手](https://user-images.githubusercontent.com/8088864/125584078-81044014-9ed7-47ba-93a4-24623b716b07.jpg)\r\n\r\n#### 2. 安全又可靠\r\n\r\nQUIC具备TCP、TLS、HTTPS/2等协议的安全、可靠性的特点，通过提供安全功能（如身份验证和加密）来实现加密传输，这些功能由传输协议本身的更高层协议（如TLS）来实现。\r\n\r\n#### 3. 改造灵活\r\n\r\nQUIC在应用程序层面就能实现不同的拥塞控制算法，不需要操作系统和内核支持，这相比于传统的TCP协议改造灵活性更好。\r\n\r\n#### 4. 改进的拥塞控制\r\n\r\nQUIC主要实现了TCP的慢启动、拥塞避免、快重传、快恢复。在这些拥塞控制算法的基础上改进，例如单调递增的 Packet Number，解决了重传的二义性，确保RTT准确性，减少重传次数。\r\n\r\n#### 5. 无队头阻塞的多路复用\r\n\r\nHTTP2实现了多路复用，可以在一条TCP流上并发多个HTTP请求，但基于TCP的HTTP2在传输层却有个问题，TCP无法识别不同的HTTP2流，实际收数据仍是一个队列，当后发的流先收到时，会因前面的流未到达而被阻塞。QUIC一个connection可以复用传输多个stream，每个stream之间都是独立的，一个stream的丢包不会影响到其他stream的接收和处理。\r\n\r\n![QUIC特点](https://user-images.githubusercontent.com/8088864/125585210-a874fcb0-87ab-46a5-b254-825c78034943.jpg)\r\n\r\n综上所述，QUIC具有众多优点，它融合了UDP协议的速度、性能与TCP的安全与可靠，大大优化了互联网传输体验。\r\n\r\n作为提升终端用户访问效率的CDN服务，其节点之间存在大量数据互通，节点之间的网络连接、传输架构等因素都会对CDN服务质量产生影响。而将QUIC应用在CDN系统中，CDN用户开启QUIC功能后，系统将遵循QUIC协议进行用户IP请求处理，既能满足安全传输的需求，也能提升传输效率。\r\n\r\n### QUIC对客户端的要求\r\n\r\n- 如果您使用Chrome浏览器，则只支持QUIC协议Q43版本。当前阿里云CDN的QUIC协议是Q39版本，不支持直接对阿里云CDN发起QUIC请求。\r\n- 如果您使用自研App，则App必须集成支持QUIC协议的网络库，例如：lsquic-client或cronet网络库。\r\n\r\n### QUIC应用场景\r\n\r\n1. 图片小文件：明显降低文件下载总耗时，提升效率\r\n2. 视频点播：提升首屏秒开率，降低卡顿率，提升用户观看体验\r\n3. 动态请求：适用于动态请求，提升访问速度，如网页登录、交易等交互体验提升\r\n4. 弱网环境：在丢包和网络延迟严重的情况下仍可提供可用的服务，并优化卡顿率、请求失败率、秒开率、提高连接成功率等传输指标\r\n5. 大并发连接：连接可靠性强，支持页面资源数较多、并发连接数较多情况下的访问速率提升\r\n6. 加密连接：具备安全、可靠的传输性能\r\n\r\n## 九、WebRTC的优缺点\r\n\r\n目前几乎所有主流浏览器都支持了 WebRTC，越来越多的公司正在使用 WebRTC 并且将其加到自己的应用程序中。在浏览器端，依赖于浏览器获取音视频的能力，以及强大的网页上的渲染能力，就能够为高清的通信体验打下基础。同时，相比移动端来说，屏幕比较大，视窗选择也比较灵活。\r\n\r\n### 优点\r\n\r\n1. 方便。对于用户来说，在WebRTC出现之前想要进行实时通信就需要安装插件和客户端，但是对于很多用户来说，插件的下载、软件的安装和更新这些操作是复杂而且容易出现问题的，现在WebRTC技术内置于浏览器中，用户不需要使用任何插件或者软件就能通过浏览器来实现实时通信。对于开发者来说，在Google将WebRTC开源之前，浏览器之间实现通信的技术是掌握在大企业手中，这项技术的开发是一个很困难的任务，现在开发者使用简单的HTML标签和JavaScript API就能够实现Web音/视频通信的功能。\r\n\r\n2. 免费。虽然WebRTC技术已经较为成熟，其集成了最佳的音/视频引擎，十分先进的codec，但是Google对于这些技术不收取任何费用。\r\n\r\n3. 强大的打洞能力。WebRTC技术包含了使用STUN、ICE、TURN、RTP-over-TCP的关键NAT和防火墙穿透技术，并支持代理。\r\n\r\n### 缺点\r\n\r\n1. 缺乏服务器方案的设计和部署。\r\n\r\n2. 传输质量难以保证。WebRTC的传输设计基于P2P，难以保障传输质量，优化手段也有限，只能做一些端到端的优化，难以应对复杂的互联网环境。比如对跨地区、跨运营商、低带宽、高丢包等场景下的传输质量基本是靠天吃饭，而这恰恰是国内互联网应用的典型场景。\r\n\r\n3. WebRTC比较适合一对一的单聊，虽然功能上可以扩展实现群聊，但是没有针对群聊，特别是超大群聊进行任何优化。\r\n\r\n4. 设备端适配，如回声、录音失败等问题层出不穷。这一点在安卓设备上尤为突出。由于安卓设备厂商众多，每个厂商都会在标准的安卓框架上进行定制化，导致很多可用性问题（访问麦克风失败）和质量问题（如回声、啸叫）。\r\n\r\n5. 对Native开发支持不够。WebRTC顾名思义，主要面向Web应用，虽然也可以用于Native开发，但是由于涉及到的领域知识（音视频采集、处理、编解码、实时传输等）较多，整个框架设计比较复杂，API粒度也比较细，导致连工程项目的编译都不是一件容易的事。\r\n\r\n## 十、EventSource和轮询的优缺点\r\n\r\n### EventSource\r\n\r\n#### 简介\r\n\r\nEventSource 是服务器推送的一个网络事件接口。一个EventSource实例会对HTTP服务开启一个持久化的连接，以text/event-stream 格式发送事件, 会一直保持开启直到被要求关闭。\r\n\r\n一旦连接开启，来自服务端传入的消息会以事件的形式分发至你代码中。如果接收消息中有一个事件字段，触发的事件与事件字段的值相同。如果没有事件字段存在，则将触发通用事件。\r\n\r\n与 WebSockets,不同的是，服务端推送是单向的。数据信息被单向从服务端到客户端分发. 当不需要以消息形式将数据从客户端发送到服务器时，这使它们成为绝佳的选择。例如，对于处理社交媒体状态更新，新闻提要或将数据传递到客户端存储机制（如IndexedDB或Web存储）之类的，EventSource无疑是一个有效方案。\r\n\r\n- `EventSource`（Server-sent events）简称SSE用于向服务端发送事件，它是基于http协议的单向通讯技术，以`text/event-stream`格式接受事件，如果不关闭会一直处于连接状态，直到调用`EventSource.close()`方法才能关闭连接；\r\n\r\n- `EvenSource`本质上也就是`XHR-streaming`只不过浏览器给它提供了标准的API封装和协议。\r\n\r\n- 由于`EventSource`是单向通讯，所以只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。\r\n\r\n- `EventSource`虽然不支持双向通讯，但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的等功能\r\n\r\n`EventSource`案例浏览器端代码如下所示:\r\n\r\n``` js\r\n// 实例化 EventSource 参数是服务端监听的路由\r\nvar source = new EventSource('sse.php');\r\n\r\nsource.onopen = function (event) { // 与服务器连接成功回调\r\n  console.log('成功与服务器连接');\r\n}\r\n\r\n// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)\r\nsource.onmessage = function (event) { // 监听未命名事件\r\n  console.log('未命名事件', event.data);\r\n}\r\n\r\nsource.onerror = function (error) { // 监听错误\r\n  console.log('错误');\r\n}\r\n\r\n// 监听指定类型的事件（可以监听多个）\r\nsource.addEventListener(\"myEve\", function (event) {\r\n  console.log(\"myEve\", event.data)\r\n})\r\n```\r\n\r\n#### EventSource规范字段\r\n\r\n- **event**: 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的EventSource对象上触发一个事件，事件类型就是该字段的字段值，你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件，如果该条消息没有event字段，则会触发onmessage属性上的事件处理函数。\r\n- **data**: 消息的数据字段，如果该消息包含多个data字段，则客户端会用换行符把他们连接成一个字符串来处理\r\n- **id**: 事件ID，会成为当前EventSource对象的内部属性“最后一个事件ID”的属性值；\r\n- **retry**: 一个整数值，指定了重新连接的时间（单位为毫秒），如果该字段不是整数，则会被忽略。\r\n\r\n#### EventSource属性\r\n\r\n- **EventSource.onerror**: 是一个 EventHandler，当发生错误时被调用，并且在此对象上派发 error 事件。\r\n- **EventSource.onmessage**: 是一个 EventHandler，当收到一个 message事件，即消息来自源头时被调用。\r\n- **EventSource.onopen**: 是一个 EventHandler，当收到一个 open 事件，即连接刚打开时被调用。\r\n- **EventSource.readyState**(只读): 一个 unsigned short 值，代表连接状态。可能值是CONNECTING (0), OPEN (1), 或者 CLOSED (2)。\r\n- **EventSource.url**(只读): 一个DOMString，代表源头的URL。\r\n\r\n#### EventSource 通讯过程\r\n\r\n![EventSource通讯过程](https://user-images.githubusercontent.com/8088864/125590756-ffd10207-83de-4166-a8b5-9fc848c191cc.png)\r\n\r\n#### 缺点\r\n\r\n1. 因为是服务器->客户端的，所以它不能处理客户端请求流\r\n2. 因为是明确指定用于传输UTF-8数据的，所以对于传输二进制流是低效率的，即使你转为base64的话，反而增加带宽的负载，得不偿失。\r\n\r\n### 轮询\r\n\r\n#### 短轮询(Polling)\r\n\r\n是一种简单粗暴，同样也是一种效率低下的实现“实时”通讯方案，这种方案的原理就是定期向服务器发送请求，主动拉取最新的消息队列。\r\n\r\n客户端代码：\r\n\r\n``` js\r\nfunction Polling() {\r\n  fetch(url).then(data => {\r\n    // somthing\r\n  }).catch(err => {\r\n    console.error(err);\r\n  });\r\n}\r\n\r\n//每5s执行一次\r\nsetInterval(polling, 5000);\r\n```\r\n\r\n![短轮询流程](https://user-images.githubusercontent.com/8088864/125591641-814c4239-47e3-41da-ad9e-a0c7e64dfe72.png)\r\n\r\n这种轮询方式比较适合服务器信息定期更新的场景，如天气预报股票行情等，每隔一段时间会进行更新，且轮询间隔的服务器更新频率保持一致是比较理想的方式，但很多多时候会因网络或者服务器出现阻塞早场事件间隔不一致。\r\n\r\n优点：\r\n\r\n- 可以看到实现非常简单，它的兼容性也比较好的只要支持http协议就可以用这种方式实现\r\n\r\n缺点：\r\n\r\n- 资源浪费: 比如轮询的间隔小于服务器信息跟新频率，会浪费很多HTTP请求，消耗宝贵的CPU时间和带宽。\r\n\r\n- 容易导致请求轰炸: 例如当服务器负载比较高时，第一个请求还没有处理完，这时第三、第四个请求接踵而来，无用的额外请求对服务器端进行了轰炸。\r\n\r\n#### 长轮询(Long Polling)\r\n\r\n这是一种优化的轮询方式，称为长轮询，sockjs就是使用的这种轮询方式，长轮询值的是浏览器发送一个请求到服务器，服务器只有在有可用的新数据时才会响应。\r\n\r\n客户端代码:\r\n\r\n``` js\r\nfunction LongPolling() {\r\n    fetch(url).then(data => {\r\n        LongPolling();\r\n    }).catch(err => {\r\n        LongPolling();\r\n        console.log(err);\r\n    });\r\n}\r\nLongPolling();\r\n```\r\n\r\n![长轮询流程](https://user-images.githubusercontent.com/8088864/125592542-e5c7fb6b-18b8-434f-a4ee-f986684dcbbf.png)\r\n\r\n客户端向服务器发送一个消息获取请求时，服务器会将当前的消息队列返回给客户端，然后关闭连接。当消息队列为空的时，服务器不会立即关闭连接，而是等待指定的时间间隔，如果在这个时间间隔内没有新的消息，则由客户端主动超时关闭连接。\r\n\r\n相比Polling，客户端的轮询请求只有在上一个请求连接关闭后才会重新发起。这就解决了Polling的请求轰炸问题。服务器可以控制的请求时序，因为在服务器未响应之前，客户端不会发送额为的请求。\r\n\r\n优点:\r\n\r\n- 长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。\r\n\r\n缺点:\r\n\r\n- 连接挂起也会导致资源的浪费。\r\n\r\n### EventSource VS 轮询\r\n\r\n|  | 轮询(Polling) | 长轮询(Long-Polling) | EventSource |\r\n| ---- | ---- | ---- | ---- |\r\n| 通信协议 | http | http | http |\r\n| 触发方式 | client(客户端) | client(客户端) | client、server(客户端、服务端) |\r\n| 优点 | 兼容性好容错性强，实现简单 | 比短轮询节约f服务器资源 | 实现简便，开发成本低 |\r\n| 缺点 | 安全性差，占较多的内存资源与请求数量，容易对服务器造成压力，请求时间间隔容易导致不一致 | 安全性差，占较多的内存资源与请求数，请求时间间隔容易导致不一致 | 只适用高级浏览器，老版本的浏览器不兼容 |\r\n| 延迟 | 非实时，延迟取决于请求间隔 | 非实时，延迟取决于请求间隔 | 非实时，默认3秒延迟，延迟可自定义 |\r\n\r\n### 总结\r\n\r\n通过对上面两种对通讯技术比较，可以从不同的角度考虑；\r\n\r\n- 兼容性: 短轮询 > 长轮询 > EventSource\r\n- 性能: EvenSource > 长轮询 > 短轮询\r\n- 服务端推送: EventSource > 长连接 （短轮询基本不考虑）\r\n\r\n## 十一、WebSocket 是什么原理？为什么可以实现持久连接？\r\n\r\n### WebSocket 机制\r\n\r\n以下简要介绍一下WebSocket的原理及运行机制。\r\n\r\nWebSocket是HTML5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与HTTP一样通过已建立的TCP连接来传输数据，但是它和HTTP最大不同是：\r\n\r\n- WebSocket是一种双向通信协议。在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，就像Socket一样；\r\n- WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信。\r\n\r\n传统HTTP客户端与服务器请求响应模式如下图所示：\r\n\r\n![传统HTTP客户端与服务器请求响应模型](https://user-images.githubusercontent.com/8088864/125600810-db0eaedf-6a66-4d71-b9c6-1a5d891a7b86.jpg)\r\n\r\nWebSocket模式客户端与服务器请求响应模式如下图：\r\n\r\n![WebSocket模式客户端与服务器请求响应模式](https://user-images.githubusercontent.com/8088864/125600954-0e796b1d-dd3a-482c-ab83-0d43f1abf610.jpg)\r\n\r\n上图对比可以看出，相对于传统HTTP每次请求-响应都需要客户端与服务端建立连接的模式，WebSocket是类似Socket的TCP长连接通讯模式。一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。\r\n\r\n相比HTTP长连接，WebSocket有以下特点：\r\n\r\n- 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。\r\n- HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）。此外还有 multiplexing、不同的URL可以复用同一个WebSocket连接等功能。这些都是HTTP长连接不能做到的。\r\n\r\n### WebSocket协议的原理\r\n\r\n与http协议一样，WebSocket协议也需要通过已建立的TCP连接来传输数据。具体实现上是通过http协议建立通道，然后在此基础上用真正的WebSocket协议进行通信，所以WebSocket协议和http协议是有一定的交叉关系的。\r\n\r\n![WebSocket协议原理流程图](https://user-images.githubusercontent.com/8088864/125603352-ba55e8bd-f554-4ef1-8c0c-add611f63023.jpg)\r\n\r\n下面是WebSocket协议请求头：\r\n\r\n![WebSocket协议请求头](https://user-images.githubusercontent.com/8088864/125603469-ef8dfb8e-988a-4bc6-a041-487f697cb72a.jpg)\r\n\r\n其中请求头中重要的字段：\r\n\r\n``` request header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Extensions:permessage-deflate; client_max_window_bits\r\n\r\nSec-WebSocket-Key:mg8LvEqrB2vLpyCNnCJV3Q==\r\n\r\nSec-WebSocket-Version:13\r\n```\r\n\r\n1. Connection和Upgrade字段告诉服务器，客户端发起的是WebSocket协议请求\r\n2. Sec-WebSocket-Extensions表示客户端想要表达的协议级的扩展\r\n3. Sec-WebSocket-Key是一个Base64编码值，由浏览器随机生成\r\n4. Sec-WebSocket-Version表明客户端所使用的协议版本\r\n\r\n而得到的响应头中重要的字段：\r\n\r\n``` response header\r\nConnection:Upgrade\r\n\r\nUpgrade:websocket\r\n\r\nSec-WebSocket-Accept:AYtwtwampsFjE0lu3kFQrmOCzLQ=\r\n```\r\n\r\n1. Connection和Upgrade字段与请求头中的作用相同\r\n\r\n2. Sec-WebSocket-Accept表明服务器接受了客户端的请求\r\n\r\n``` response header\r\nStatus Code:101 Switching Protocols\r\n```\r\n\r\n并且http请求完成后响应的状态码为101，表示切换了协议，说明WebSocket协议通过http协议来建立运输层的TCP连接，之后便与http协议无关了。\r\n\r\n### WebSocket协议的优缺点\r\n\r\n优点：\r\n\r\n- WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的\r\n- 服务器可以向客户端推送消息了\r\n\r\n缺点：\r\n\r\n- 少部分浏览器不支持，浏览器支持的程度与方式有区别\r\n\r\nWebSocket协议的应用场景\r\n\r\n- 即时聊天通信\r\n- 多玩家游戏\r\n- 在线协同编辑/编辑\r\n- 实时数据流的拉取与推送\r\n- 体育/游戏实况\r\n- 实时地图位置\r\n\r\n一个使用WebSocket应用于视频的业务思路如下：\r\n\r\n- 使用心跳维护websocket链路，探测客户端端的网红/主播是否在线\r\n- 设置负载均衡7层的proxy_read_timeout默认为60s\r\n- 设置心跳为50s，即可长期保持Websocket不断开\r\n\r\n## 十二、Sass\r\n\r\nSass (英文全称：Syntactically Awesome Stylesheets) 是一个最初由 Hampton Catlin 设计并由 Natalie Weizenbaum 开发的层叠样式表语言。\r\n\r\nSass 是一个 CSS 预处理器。\r\n\r\nSass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。\r\n\r\nSass 完全兼容所有版本的 CSS。\r\n\r\nSass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。\r\n\r\nSass 生成良好格式化的 CSS 代码，易于组织和维护。\r\n\r\nSass 文件后缀为 `.scss`。\r\n\r\n浏览器并不支持 Sass 代码。因此，你需要使用一个 Sass 预处理器将 Sass 代码转换为 CSS 代码。\r\n\r\n## 十三、三栏弹性布局的5种方法(绝对定位、圣杯、双飞翼、flex、grid)\r\n\r\n### 需求\r\n\r\n用css实现三栏布局，html结构代码如下，顺序不能变（main优先渲染），可以适当加元素，同时要求left宽度200px，right宽度300px，main宽度自适应。\r\n\r\n``` html\r\n<div class=\"container\">\r\n  <div class=\"main\">main 宽度自适应</div>\r\n  <div class=\"left\">left 宽200px</div>\r\n  <div class=\"right\">right 宽300px</div>\r\n</div>\r\n```\r\n\r\n![三栏布局](https://user-images.githubusercontent.com/8088864/125612523-d7b144ff-a0a3-4522-ad8b-c2a7179198c2.gif)\r\n\r\n### 5种具体实现和优缺点比较\r\n\r\n#### 1. 绝对定位布局\r\n\r\n原始的布局方法\r\n\r\n- 原理：container为相对定位并设置左右padding为left和right的宽度，left\\right绝对定位在左右两侧，main不用设置。\r\n\r\n- 优点：兼容好、原理简单\r\n\r\n- 缺点：left和right都为绝对定位，高度不能撑开container\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>绝对定位布局</title>\r\n</head>\r\n<style>\r\n  .container {\r\n    color: #fff;\r\n    position: relative;\r\n    padding: 0 300px 0 200px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    top: 0;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    position: absolute;\r\n    width: 200px;\r\n    background: blue;\r\n    left: 0;\r\n  }\r\n\r\n  .right {\r\n    position: absolute;\r\n    width: 300px;\r\n    background: red;\r\n    right: 0;\r\n  }\r\n\r\n  .main {\r\n    background: green;\r\n  }\r\n</style>\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"main\">main 宽度自适应</div>\r\n    <div class=\"left\">left 宽200px</div>\r\n    <div class=\"right\">right 宽300px</div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 2. 圣杯布局\r\n\r\n圣杯布局方法\r\n\r\n- 原理：container设置左右padding为left和right的宽度，left\\right\\main 浮动，left\\right相对定位并设置left、right、margin-left来偏移位置，main宽100%。\r\n- 优点：兼容好\r\n- 缺点：原理复制，left/right/main高度自适应情况下3者不能高度一致。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>圣杯布局</title>\r\n</head>\r\n<style>\r\n  .container {\r\n    color: #fff;\r\n    overflow: hidden;\r\n    padding: 0 300px 0 200px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    float: left;\r\n    position: relative;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    width: 200px;\r\n    background: blue;\r\n    margin-left: -100%;\r\n    left: -200px;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n    margin-left: -300px;\r\n    right: -300px;\r\n  }\r\n\r\n  .main {\r\n    width: 100%;\r\n    background: green;\r\n  }\r\n</style>\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"main\">main 宽度自适应</div>\r\n    <div class=\"left\">left 宽200px</div>\r\n    <div class=\"right\">right 宽300px</div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 3. 双飞翼布局\r\n\r\n圣杯布局改进方法\r\n\r\n- 原理：left\\right\\main 浮动，left\\right设置margin-left来偏移位置，main宽100%，main出入content，并设置content的左右边距为left\\right宽度\r\n- 优点：兼容好，原理简单\r\n- 缺点：left/right/main高度自适应情况下3者不能高度一致。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>双飞翼布局</title>\r\n</head>\r\n<style>\r\n  .container {\r\n    color: #fff;\r\n    overflow: hidden;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    float: left;\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    width: 200px;\r\n    background: blue;\r\n    margin-left: -100%;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n    margin-left: -300px;\r\n  }\r\n\r\n  .main {\r\n    width: 100%;\r\n    background: green;\r\n  }\r\n\r\n  .content {\r\n    margin: 0 300px 0 200px;\r\n  }\r\n</style>\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"main\">\r\n      <div class=\"content\">\r\n        main 宽度自适应\r\n      </div>\r\n    </div>\r\n    <div class=\"left\">left 宽200px</div>\r\n    <div class=\"right\">right 宽300px</div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 4. flex布局\r\n\r\ncss3新布局方式\r\n\r\n- 原理：container设置`display:flex`，left设置`order:-1`排在最前面，main设置`flex-grow:1`自适应宽度\r\n- 优点：原理简单，代码简洁，left/right/main高度自适应情况下3者能高度一致\r\n- 缺点：兼容性不够好，ie10+，chrome20+，正式使用要加各种前缀（-webkit--ms-）\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>flex布局</title>\r\n</head>\r\n<style>\r\n  .container {\r\n    color: #fff;\r\n    display: flex;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    order: -1;\r\n    width: 200px;\r\n    background: blue;\r\n  }\r\n\r\n  .right {\r\n    width: 300px;\r\n    background: red;\r\n  }\r\n\r\n  .main {\r\n    flex-grow: 1;\r\n    background: green;\r\n  }\r\n</style>\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"main\">main 宽度自适应</div>\r\n    <div class=\"left\">left 宽200px</div>\r\n    <div class=\"right\">right 宽300px</div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n#### 5. grid布局\r\n\r\ncss3新布局方式\r\n\r\n- 原理：container设置`display:grid` 和 `grid-template-columns:200px auto 300px`，left设置`order: -1`排在最前面\r\n- 优点：原理简单，代码简洁，left/right/main高度自适应情况下3者能高度一致\r\n- 缺点：兼容性较差，ie10+，Chrome57+，正式使用要加各种前缀（-webkit--ms-）\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>grid布局</title>\r\n</head>\r\n<style>\r\n  .container {\r\n    color: #fff;\r\n    display: grid;\r\n    grid-template-columns: 200px auto 300px;\r\n  }\r\n\r\n  .left,\r\n  .main,\r\n  .right {\r\n    min-height: 100px;\r\n  }\r\n\r\n  .left {\r\n    order: -1;\r\n    background: blue;\r\n  }\r\n\r\n  .right {\r\n    background: red;\r\n  }\r\n\r\n  .main {\r\n    background: green;\r\n  }\r\n</style>\r\n<body>\r\n  <div class=\"container\">\r\n    <div class=\"main\">main 宽度自适应</div>\r\n    <div class=\"left\">left 宽200px</div>\r\n    <div class=\"right\">right 宽300px</div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 十四、浅析CSS里的BFC和IFC的用法\r\n\r\n### BFC简介\r\n\r\n所谓的 Formatting Context(格式化上下文), 它是 W3C CSS2.1 规范中的一个概念。\r\n\r\n- 格式化上下文(FC)是页面中的一块渲染区域，并且有一套渲染规则。\r\n- 格式化上下文(FC)决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\r\n\r\nBlock Formatting Context (BFC，块级格式化上下文)，就是一个块级元素的渲染显示规则。通俗一点讲，可以把 BFC 理解为一个封闭的大箱子，容器里面的子元素不会影响到外面的元素，反之也如此。\r\n\r\nBFC的布局规则如下：\r\n\r\n1. 内部的盒子会在垂直方向，一个个地放置；\r\n2. BFC是页面上的一个隔离的独立容器；\r\n3. 属于同一个BFC的 两个相邻Box的 上下margin会发生重叠；\r\n4. 计算BFC的高度时，浮动元素也参与计算；\r\n5. 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；\r\n6. BFC的区域不会与float重叠。\r\n\r\n那么如何触发 BFC 呢？只要元素满足下面任一条件即可触发 BFC 特性：\r\n\r\n- body 根元素；\r\n- 浮动元素：float 不为none的属性值；\r\n- 绝对定位元素：position (absolute、fixed)；\r\n- display为： inline-block、table-cells、flex；\r\n- overflow 除了visible以外的值 (hidden、auto、scroll)。\r\n\r\n### BFC的特性及应用\r\n\r\n#### 同一个 BFC下外边距 会发生折叠\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    margin: 50px 0;\r\n    background-color: red;\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"p\"></div>\r\n  <div class=\"p\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示:\r\n\r\n![同一个 BFC 下两个相邻的普通流中的块元素垂直方向上的 margin会折叠](https://user-images.githubusercontent.com/8088864/125714340-57813f51-5cad-4844-9247-2ba5cc04ac8d.jpg)\r\n\r\n根据BFC规则的第3条：\r\n\r\n盒子垂直方向的距离由margin决定，\r\n\r\n属于 同一个BFC的 + 两个相邻Box的 + 上下margin 会发生重叠。\r\n\r\n上文的例子 之所以发生外边距折叠，是因为他们 同属于 body这个根元素， 所以我们需要让 它们 不属于同一个BFC，就能避免外边距折叠：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  .wrap {\r\n    overflow: hidden;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    margin: 50px 0;\r\n    background-color: red;\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"p\"></div>\r\n  <div class=\"wrap\">\r\n    <div class=\"p\"></div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示:\r\n\r\n![利用 BFC 下可以避免两个相邻的块元素垂直方向上的 margin折叠](https://user-images.githubusercontent.com/8088864/125714635-3ff51432-6415-40df-938d-c4c2fe654ca2.jpg)\r\n\r\n#### BFC可以包含浮动的元素(清除浮动)\r\n\r\n正常情况下，浮动的元素会脱离普通文档流，所以下面的代码里：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  .wrap {\r\n    border: 1px solid #000;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    background-color: #eee;\r\n    float: left;\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"wrap\">\r\n    <div class=\"p\"></div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n外层的div会无法包含 内部浮动的div。\r\n\r\n效果如下所示:\r\n\r\n![外层的div会无法包含内部浮动的div](https://user-images.githubusercontent.com/8088864/125714940-1de23469-a365-47f4-82ab-3a89fea5441b.jpg)\r\n\r\n但如果我们 触发外部容器的BFC，根据BFC规范中的第4条：计算BFC的高度时，浮动元素也参与计算，那么外部div容器就可以包裹着浮动元素，所以只要把代码修改如下：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  .wrap {\r\n    border: 1px solid #000;\r\n    overflow: hidden;\r\n  }\r\n\r\n  .p {\r\n    width: 200px;\r\n    height: 50px;\r\n    background-color: #eee;\r\n    float: left;\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"wrap\">\r\n    <div class=\"p\"></div>\r\n  </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示:\r\n\r\n![利用BFC外层的div会包含内部浮动的div](https://user-images.githubusercontent.com/8088864/125715066-4a11c8a9-caef-4258-acfb-87e3cc8b8302.jpg)\r\n\r\n#### BFC可以阻止元素被浮动元素覆盖\r\n\r\n正常情况下，浮动的元素会脱离普通文档流，会覆盖着普通文档流的元素上。所以下面的代码里：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n.aside {\r\n  width: 100px;\r\n  height: 150px;\r\n  float: left;\r\n  background: black;\r\n}\r\n\r\n.main {\r\n  width: 300px;\r\n  height: 200px;\r\n  background-color: red;\r\n}\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"aside\"></div>\r\n  <div class=\"main\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示:\r\n\r\n![浮动的元素会脱离普通文档流，会覆盖着普通文档流的元素上](https://user-images.githubusercontent.com/8088864/125716169-ccf5e6b4-f51e-431e-8aff-0b8e753b88a8.png)\r\n\r\n\r\n之所以是这样，是因为上文的 规则5： 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此；\r\n\r\n所以要想改变效果，使其互补干扰，就得利用规则6 ：BFC的区域不会与float重叠，让 \\<div class=\"main\"> 也能触发BFC的性质。\r\n\r\n将代码改成下列所示:\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n.aside {\r\n  width: 100px;\r\n  height: 150px;\r\n  float: left;\r\n  background: black;\r\n}\r\n\r\n.main {\r\n  width: 300px;\r\n  height: 200px;\r\n  background-color: red;\r\n  overflow: hidden;\r\n}\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"aside\"></div>\r\n  <div class=\"main\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示：\r\n\r\n![利用BFC可以阻止元素被浮动元素覆盖](https://user-images.githubusercontent.com/8088864/125716325-7b9fe487-9b6e-4d35-b8b7-33839bb9ebce.png)\r\n\r\n通过这种方法，就能 用来实现 两列的自适应布局。\r\n\r\n### 简要介绍IFC\r\n\r\n1. 框会从包含块的顶部开始，一个接一个地水平摆放。\r\n\r\n2. 摆放这些框时，它们在水平方向的 内外边距+边框 所占用的空间都会被考虑；\r\n    在垂直方向上，这些框可能会以不同形式来对齐；\r\n    水平的margin、padding、border有效，垂直无效，不能指定宽高。\r\n\r\n3. 行框的宽度是 由包含块和存在的浮动来决定;\r\n  行框的高度 由行高来决定。\r\n\r\n## 十五、浅析CSS的性能优化：transform与position区别、硬件加速工作原理及注意事项、强制使用GPU渲染的友好CSS属性\r\n\r\n在网上看到一个这样的问题： transform与position:absolute 有什么区别？查阅资料后发现这道题目其实不简单，涉及到重排、重绘、硬件加速等网页优化的知识。\r\n\r\n### 问题背景\r\n\r\n过去几年，我们常常会听说硬件加速给移动端带来了巨大的体验提升，但是即使对于很多经验丰富的开发者来说，恐怕对其背后的工作原理也是模棱两可，更不要合理地将其运用到网页的动画效果中了。\r\n\r\n#### 1. position + top/left 的效果\r\n\r\n下面让我们来看一个动画效果，在该动画中包含了几个堆叠在一起的球并让它们沿相同路径移动。最简单的方式就是实时调整它们的 left 和 top 属性，使用 css 动画实现。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  html,\r\n  body {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n\r\n  .ball-running {\r\n    animation: run-around 4s infinite;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n    position: absolute;\r\n  }\r\n\r\n  @keyframes run-around {\r\n    0%: {\r\n      top: 0;\r\n      left: 0;\r\n    }\r\n    25% {\r\n      top: 0;\r\n      left: 200px;\r\n    }\r\n    50% {\r\n      top: 200px;\r\n      left: 200px;\r\n    }\r\n    75% {\r\n      top: 200px;\r\n      left: 0;\r\n    }\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"ball-running\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n在运行的时候，即使是在电脑浏览器上也会隐约觉得动画的运行并不流畅，动画有些停顿的感觉，更不要提在移动端达到 60fps 的流畅效果了。这是因为top和left的改变会触发浏览器的 reflow 和 repaint ，整个动画过程都在不断触发浏览器的重新渲染，这个过程是很影响性能的。\r\n\r\n#### 2. transform 的效果\r\n\r\n为了解决这个问题，我们使用 transform 中的 translate() 来替换 top 和 left ，重写一下这个动画效果。\r\n\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<head>\r\n<style>\r\n  html,\r\n  body {\r\n    width: 100%;\r\n    height: 100%;\r\n  }\r\n\r\n  .ball-running {\r\n    animation: run-around 4s infinite;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n  }\r\n\r\n  @keyframes run-around {\r\n    0%: {\r\n      transform: translate(0, 0);\r\n    }\r\n    25% {\r\n      transform: translate(200px, 0);\r\n    }\r\n    50% {\r\n      transform: translate(200px, 200px);\r\n    }\r\n    75% {\r\n      transform: translate(0, 200px);\r\n    }\r\n  }\r\n</style>\r\n</head>\r\n<body>\r\n  <div class=\"ball-running\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n这时候会发现整个动画效果流畅了很多，在动画移动的过程中也没有发生repaint和reflow。\r\n\r\n那么，为什么 transform 没有触发 repaint 呢？原因就是：transform 动画由GPU控制，支持硬件加速，并不需要软件方面的渲染。\r\n\r\n### 硬件加速工作原理\r\n\r\n浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树，DOM树和CSS结合后形成浏览器构建页面的渲染树，渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，而图层在GPU中 transform 是不会触发 repaint 的，这一点非常类似3D绘图功能，最终这些使用transform的图层都会使用独立的合成器进程进行处理。\r\n\r\n在我们的示例中，CSS  transform  创建了一个新的复合图层，可以被GPU直接用来执行 transform 操作。在chrome开发者工具中开启“show layer borders”选项后，每个复合图层就会显示一条黄色的边界。示例中的球就处于一个独立的复合图层，移动时的变化也是独立的。\r\n\r\n此时，你也许会问：浏览器什么时候会创建一个独立的复合图层呢？事实上一般是在以下几种情况下：\r\n\r\n  1. 3D 或者 CSS transform\r\n  2. video或canvas标签\r\n  3. CSS filters\r\n  4. 元素覆盖时，比如使用了 z-index 属性\r\n\r\n等一下，上面的示例使用的是 2D transform 而不是 3D transform 啊？这个说法没错，所以在timeline中我们可以看到：动画开始和结束的时候发生了两次 repaint 操作。\r\n\r\n![CSS transform网页的重绘时间轴](https://user-images.githubusercontent.com/8088864/125720131-5776ac63-b267-4699-9cbf-06a86c80689b.png)\r\n\r\n3D 和 2D transform 的区别就在于，浏览器在页面渲染前为3D动画创建独立的复合图层，而在运行期间为2D动画创建。\r\n\r\n动画开始时，生成新的复合图层并加载为GPU的纹理用于初始化 repaint，然后由GPU的复合器操纵整个动画的执行，最后当动画结束时，再次执行 repaint 操作删除复合图层。\r\n\r\n### 使用 GPU 渲染元素\r\n\r\n#### 能触发GPU渲染的属性\r\n\r\n并不是所有的CSS属性都能触发GPU的硬件加速，实际上只有少数属性可以，比如下面的这些：\r\n\r\n1. transform\r\n2. opacity\r\n3. filter\r\n\r\n#### 强制使用GPU渲染\r\n\r\n为了避免 2D transform 动画在开始和结束时发生的 repaint 操作，我们可以硬编码一些样式来解决这个问题：\r\n\r\n``` css\r\n.exam1 {\r\n  transform: translateZ(0);\r\n}\r\n\r\n.exam2 {\r\n  transform: rotateZ(360deg);\r\n}\r\n```\r\n\r\n这段代码的作用就是让浏览器执行 3D transform，浏览器通过该样式创建了一个独立图层，图层中的动画则有GPU进行预处理并且触发了硬件加速。\r\n\r\n#### 使用硬件加速需要注意的事项\r\n\r\n使用硬件加速并不是十全十美的事情，比如：\r\n\r\n1. 内存。如果GPU加载了大量的纹理，那么很容易就会发生内存问题，这一点在移动端浏览器上尤为明显，所以，一定要牢记不要让页面的每个元素都使用硬件加速。\r\n2. 使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制，即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。\r\n\r\n#### will-change\r\n\r\n浏览器还提出了一个 will-change 属性，该属性允许开发者告知浏览器哪一个属性即将发生变化，从而为浏览器对该属性进行优化提供了时间。下面是一个使用 will-change 的示例\r\n\r\n``` css\r\n.exam3 {\r\n  will-change: transform;\r\n}\r\n```\r\n\r\n缺点在于其兼容性不大好。\r\n\r\n### 总结\r\n\r\n1. transform 会使用 GPU 硬件加速，性能更好；position + top/left 会触发大量的重绘和回流，性能影响较大。\r\n2. 硬件加速的工作原理是创建一个新的复合图层，然后使用合成线程进行渲染。\r\n3. 3D 动画 与 2D 动画的区别；2D动画会在动画开始和动画结束时触发2次重新渲染。\r\n4. 使用GPU可以优化动画效果，但是不要滥用，会有内存问题。\r\n5. 理解强制触发硬件加速的 transform 技巧，使用对GPU友好的CSS属性。\r\n\r\n## 十六、深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调\r\n\r\n### 前言\r\n\r\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\r\n\r\n1. 每一轮 Event Loop 都会伴随着渲染吗？\r\n2. requestAnimationFrame 在哪个阶段执行，在渲染前还是后？在 microTask 的前还是后？\r\n3. requestIdleCallback 在哪个阶段执行？如何去执行？在渲染前还是后？在 microTask 的前还是后？\r\n4. resize、scroll 这些事件是何时去派发的。\r\n\r\n这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 requestAnimationFrame，你可能在做一些需求的时候想到了 requestIdleCallback，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。\r\n\r\n这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。\r\n\r\n### 事件循环\r\n\r\n我们先依据HTML 官方规范从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。\r\n\r\n#### 定义\r\n\r\n为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环。\r\n\r\n#### 流程\r\n\r\n1. 从任务队列中取出一个宏任务并执行。\r\n\r\n2. 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。\r\n\r\n3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）\r\n\r\n  - 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。\r\n  - 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。\r\n  - 如果满足以下条件，也会跳过渲染：\r\n\r\n    1. 浏览器判断更新渲染不会带来视觉上的改变。\r\n    2. map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。\r\n\r\n4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：\r\n  This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask的执行，而不会穿插屏幕渲染相关的流程（比如requestAnimationFrame，下面会写一个例子）。\r\n\r\n5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 `resize` 方法。\r\n\r\n6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 方法。\r\n\r\n7. 对于需要渲染的文档，执行帧动画回调，也就是 `requestAnimationFrame` 的回调。（后文会详解）\r\n\r\n8. 对于需要渲染的文档， 执行 `IntersectionObserver` 的回调。\r\n\r\n9. 对于需要渲染的文档，**重新渲染**绘制用户界面。\r\n\r\n10. 判断 `task队列`和`microTask队列`是否都为空，如果是的话，则进行 `Idle` 空闲周期的算法，判断是否要执行 `requestIdleCallback` 的回调函数。（后文会详解）\r\n\r\n对于 `resize` 和 `scroll` 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据CSSOM 规范所讲，浏览器会保存一个 `pending scroll event targets`，等到事件循环中的 `scroll` 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize` 也是同理。\r\n可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。\r\n多任务队列\r\n\r\n#### 多任务队列\r\n\r\ntask 队列并不是我们想象中的那样只有一个，根据规范里的描述：\r\n\r\nAn event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.\r\n\r\n事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：\r\n\r\n1. 鼠标和键盘事件\r\n2. 其他的一些 Task\r\n\r\n览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。\r\n\r\n这个规范也导致 Vue 2.0.0-rc.7 这个版本 `nextTick` 采用了从微任务 `MutationObserver` 更换成宏任务 `postMessage` 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)。\r\n目前由于一些“未知”的原因，`jsfiddle` 的案例打不开了。简单描述一下就是采用了 `task` 实现的 `nextTick`，在用户持续滚动的情况下 `nextTick` 任务被延后了很久才去执行，导致动画跟不上滚动了。\r\n\r\n迫于无奈，尤大还是改回了 `microTask` 去实现 `nextTick`，当然目前来说 `promise.then` 微任务已经比较稳定了，并且 Chrome 也已经实现了 `queueMicroTask` 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 `Promise` 在开销了。\r\n\r\n从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。\r\n\r\n#### requestAnimationFrame\r\n\r\n在解读规范的过程中，我们发现 `requestAnimationFrame` 的回调有两个特征：\r\n\r\n1. 在重新渲染前调用。\r\n2. 很可能在宏任务之后不调用。\r\n\r\n我们来分析一下，为什么要在重新渲染前去调用？因为 `rAF` 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。\r\n\r\n`rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。\r\n\r\n##### 闪烁动画\r\n\r\n假设我们现在想要快速的让屏幕上闪烁 红、蓝两种颜色，保证用户可以观察到，如果我们用 `setTimeout` 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  document.body.style.background = \"red\";\r\n  setTimeout(() => {\r\n    document.body.style.background = \"blue\";\r\n  });\r\n});\r\n```\r\n\r\n![setTimeout闪烁动画](https://user-images.githubusercontent.com/8088864/125749050-c757f81e-6482-4262-a0d4-c455eb78d4f4.gif)\r\n\r\n以看出这个结果是非常不可控的，如果这两个 `Task` 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。\r\n\r\n如果你把延时调整到 17ms 那么重绘的概率会大很多，毕竟这个是一般情况下 60fps 的一个指标。但是也会出现很多不绘制的情况，所以并不稳定。\r\n如果你依赖这个 API 来做动画，那么就很可能会造成「掉帧」。\r\n\r\n接下来我们换成 rAF 试试？我们用一个递归函数来模拟 10 次颜色变化的动画。\r\n\r\n``` js\r\nlet i = 10;\r\nlet req = () => {\r\n  i--;\r\n  requestAnimationFrame(() => {\r\n    document.body.style.background = \"red\";\r\n    requestAnimationFrame(() => {\r\n      document.body.style.background = \"blue\";\r\n      if (i > 0) {\r\n        req();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nreq();\r\n```\r\n\r\n这里由于颜色变化太快，gif 录制软件没办法截出这么高帧率的颜色变换，所以各位可以放到浏览器中自己执行一下试试，我这边直接抛结论，浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，可以看下 performance 面板记录的表现：\r\n\r\n![requestAnimationFrame闪烁动画](https://user-images.githubusercontent.com/8088864/125750295-ab491df6-c612-4add-b2fe-8819fcf47ef1.png)\r\n\r\n##### 定时器合并\r\n\r\n在第一节解读规范的时候，第 4 点中提到了，定时器宏任务可能会直接跳过渲染。\r\n\r\n按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  console.log(\"sto1\")\r\n  requestAnimationFrame(() => console.log(\"rAF1\"))\r\n})\r\nsetTimeout(() => {\r\n  console.log(\"sto2\")\r\n  requestAnimationFrame(() => console.log(\"rAF2\"))\r\n})\r\n\r\nqueueMicrotask(() => console.log(\"mic1\"))\r\nqueueMicrotask(() => console.log(\"mic2\"))\r\n```\r\n\r\n从直觉上来看，顺序是不是应该是：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nrAF1\r\nsto2\r\nrAF2\r\n```\r\n\r\n呢？也就是每一个宏任务之后都紧跟着一次渲染。\r\n\r\n实际上不会，浏览器会合并这两个定时器任务：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nsto2\r\nrAF1\r\nrAF2\r\n```\r\n\r\n#### requestIdleCallback\r\n\r\n#### 草案解读\r\n\r\n我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。\r\n\r\nReact 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 postMessage 实现了一套。\r\n\r\n**渲染有序进行**\r\n\r\n首先看一张图，很精确的描述了这个 API 的意图：\r\n\r\n![浏览器渲染有序调度](https://user-images.githubusercontent.com/8088864/125756615-7bec3496-94cc-46ba-9298-5df48b99d2d8.png)\r\n\r\n当然，这种有序的 `浏览器 -> 用户 -> 浏览器 -> 用户` 的调度基于一个前提，就是我们要把任务切分成比较小的片，不能说浏览器把空闲时间让给你了，你去执行一个耗时 10s 的任务，那肯定也会把浏览器给阻塞住的。这就要求我们去读取 `rIC` 提供给你的 `deadline` 里的时间，去动态的安排我们切分的小任务。浏览器信任了你，你也不能辜负它呀。\r\n\r\n**渲染长期空闲**\r\n\r\n![浏览器渲染长期空闲调度](https://user-images.githubusercontent.com/8088864/125756805-79afd49b-e62d-45b9-bb7e-4a4b34eb7bd4.png)\r\n\r\n还有一种情况，也有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，它也就不需要去绘制页面：\r\n这种情况下为什么还是会有 50ms 的 deadline 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。\r\n\r\nMDN 文档中的[幕后任务协作调度 API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)  介绍的比较清楚，来根据里面的概念做个小实验：\r\n\r\n屏幕中间有个红色的方块，把 MDN 文档中[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的范例部分的动画代码直接复制过来。\r\n\r\n草案中还提到：\r\n\r\n1. 当浏览器判断这个页面对用户不可见时，这个回调执行的频率可能被降低到 10 秒执行一次，甚至更低。这点在解读 EventLoop 中也有提及。\r\n\r\n2. 如果浏览器的工作比较繁忙的时候，不能保证它会提供空闲时间去执行 rIC 的回调，而且可能会长期的推迟下去。所以如果你需要保证你的任务在一定时间内一定要执行掉，那么你可以给 rIC 传入第二个参数 timeout。\r\n这会强制浏览器不管多忙，都在超过这个时间之后去执行 rIC 的回调函数。所以要谨慎使用，因为它会打断浏览器本身优先级更高的工作。\r\n\r\n3. 最长期限为 50 毫秒，是根据研究得出的，研究表明，人们通常认为 100 毫秒内对用户输入的响应是瞬时的。 将闲置截止期限设置为 50ms 意味着即使在闲置任务开始后立即发生用户输入，浏览器仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。\r\n\r\n4. 每次调用 timeRemaining() 函数判断是否有剩余时间的时候，如果浏览器判断此时有优先级更高的任务，那么会动态的把这个值设置为 0，否则就是用预先设置好的 deadline - now 去计算。\r\n\r\n5. 这个 timeRemaining() 的计算非常动态，会根据很多因素去决定，所以不要指望这个时间是稳定的。\r\n\r\n#### 动画例子\r\n\r\n**滚动**\r\n\r\n如果我鼠标不做任何动作和交互，直接在控制台通过 rIC 去打印这次空闲任务的剩余时间，一般都稳定维持在 49.xx ms，因为此时浏览器没有什么优先级更高的任务要去处理。\r\n\r\n``` js\r\nrequestIdleCallback((deadline) => console.log(deadline.timeRemaining()))\r\n```\r\n\r\n![requetIdleCallback的timeRemaining时间1](https://user-images.githubusercontent.com/8088864/125778161-1e903c20-19a8-4340-83e9-af15ff16078a.gif)\r\n\r\n而如果我不停的滚动浏览器，不断的触发浏览器的重新绘制的话，这个时间就变的非常不稳定了。\r\n\r\n![requetIdleCallback的timeRemaining时间2](https://user-images.githubusercontent.com/8088864/125778195-dc9bc852-60e6-475d-a50e-441707e793ff.gif)\r\n\r\n通过这个例子，你可以更加有体感的感受到什么样叫做「繁忙」，什么样叫做「空闲」。\r\n\r\n\r\n**动画**\r\n\r\n这个动画的例子很简单，就是利用rAF在每帧渲染前的回调中把方块的位置向右移动 10px。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n注意在最后我加了一个 requestIdleCallback 的函数，回调里会 alert('rIC')，来看一下演示效果：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画](https://user-images.githubusercontent.com/8088864/125778813-19d6dde2-2b12-4754-bd4c-deba1209d3e6.gif)\r\n\r\nalert 在最开始的时候就执行了，为什么会这样呢一下，想一下「空闲」的概念，我们每一帧仅仅是把 left 的值移动了一下，做了这一个简单的渲染，没有占满空闲时间，所以可能在最开始的时候，浏览器就找到机会去调用 rIC 的回调函数了。\r\n\r\n我们简单的修改一下 step 函数，在里面加一个很重的任务，1000 次循环打印。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n再来看一下它的表现：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙](https://user-images.githubusercontent.com/8088864/125779688-be382539-51e0-4462-afee-ddb5db99b2bb.gif)\r\n\r\n其实和我们预期的一样，由于浏览器的每一帧都\"太忙了\",导致它真的就无视我们的 rIC 函数了。\r\n\r\n如果给 rIC 函数加一个 timeout 呢：\r\n\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      }, { timeout: 500 });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n效果如下：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙再加上timeout](https://user-images.githubusercontent.com/8088864/125779998-cf9201d8-707b-4d99-aece-9e40c4f7b2a2.gif)\r\n\r\n浏览器会在大概 500ms 的时候，不管有多忙，都去强制执行 `rIC` 函数，这个机制可以防止我们的空闲任务被“饿死”。\r\n\r\n### 总结\r\n\r\n通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。\r\n\r\n1. 事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行。\r\n2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。\r\n3. requestAnimationFrame在重新渲染屏幕之前执行，非常适合用来做动画。\r\n4. requestIdleCallback在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 timeout参数。\r\n5. resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上。\r\n\r\n## 十七、React Fiber架构中，迭代器和requestIdleCallback结合的优势\r\n\r\n### requestIdleCallback API\r\n\r\nrequestIdleCallback 是浏览器提供的 Web API，它是 React Fiber 中用到的核心 API。\r\n\r\n#### API 介绍\r\n\r\n[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 利用浏览器的空余时间执行任务，如果浏览器没有空余时间，可以随时终止这些任务。\r\n\r\n这样可以实现如果有更高优先级的任务要执行时，当前执行的任务可以被终止，优先执行高级别的任务。\r\n\r\n原理是该方法将 在浏览器的空闲时段内调用的函数 排队。\r\n\r\n这样使得开发者能够在主事件循环上 执行后台和低优先级的任务，而不会影响 像动画和用户交互 这些关键的延迟触发的事件。\r\n\r\n这里的“延迟”指的是大量计算导致运行时间较长。\r\n\r\n#### 浏览器空余时间\r\n\r\n页面是一帧一帧绘制出来的，当每秒绘制的帧数达到 60 时，页面时流畅的，小于这个值时，用户会感觉到卡顿。\r\n\r\n1秒60帧意思是1秒中60张画面在切换。\r\n\r\n当帧数低于人眼的捕捉频率（有说24帧或30帧，考虑到视觉残留现象，这个数值可能会更低）时，人脑会识别这是几张图片在切换，也就是静态的。\r\n\r\n当帧数高于人眼的捕捉频率，人脑会认为画面是连续的，也就是动态的动画。\r\n\r\n帧数越高画面就看起来更流畅。\r\n\r\n1秒60帧（大约 1000/60 ≈ 16ms 切换一个画面）差不多是人眼能识别卡顿的分界线。\r\n\r\n如果每一帧执行的时间小于 16 ms，就说明浏览器有空余时间。\r\n\r\n一帧时间内浏览器要做的事情包括：脚本执行、样式计算、布局、重绘、合成等。\r\n\r\n如果某一项内容执行时间过长，浏览器会推迟渲染，造成丢帧卡顿，就没有剩余时间。\r\n\r\n#### 应用场景\r\n\r\n比如现在有一项计算任务，这项任务需要花费比较长的时间(例如超过16ms）去执行。\r\n\r\n在执行任务的过程当中，浏览器的主线程会被一直占用。\r\n\r\n在主线程被占用的过程中，浏览器是被阻塞的，并不能执行其他的任务。\r\n\r\n如果此时用户想要操作页面，比如向下滑动页面查看其它内容，浏览器是不能响应用户的操作的，给用户的感觉就是页面卡死了，体验非常差。\r\n\r\n**如何解决呢？**\r\n\r\n可以将这项任务注册到 `requestIdleCallback` 中，利用浏览器的空余时间执行它。\r\n\r\n当用户操作页面时，就是**优先级比较高的任务**被执行时，此时计算任务会被终止，优先响应用户的操作，这样用户就不会感觉页面发生卡顿了。\r\n\r\n当高优先级的任务执行完成后，再继续执行计算任务。\r\n\r\n`requestIdleCallback` 的作用就是利用浏览器的空余时间执行这些需要大量计算的任务，当空余时间结束，会中断计算任务，执行高优先级的任务，以达到不阻塞主线程任务（例如浏览器 UI 渲染）的目的。\r\n\r\n#### 使用方式\r\n\r\n``` js\r\nvar handle = window.requestIdleCallback(callback[, options])\r\n```\r\n\r\n- callback：一个在空闲时间即将被调用的回调函数\r\n    - 该函数接收一个形参：IdleDeadline，它提供一个方法和一个属性：\r\n      - 方法：timeRemaining()\r\n        - 用于获取浏览器空闲期的剩余时间，也就是空余时间\r\n          - 返回值是毫秒数\r\n          - 如果闲置期结束，则返回 0\r\n        - 根据时间的多少可以来决定是否要执行任务\r\n      - 属性：didTimeout(Boolean，只读)\r\n        - 表示是否是上一次空闲期因为超时而没有执行的回调函数\r\n        - 超时时间由 requestIdleCallback 的参数options.timeout 定义\r\n- options：可选配置，目前只有一个配置项\r\n  - timeout：超时时间，如果设置了超时时间并超时，回调函数还没有被调用，则会在下一次空闲期强制被调用\r\n\r\n#### 功能体验\r\n\r\n页面中有两个按钮和一个 DIV，点击第一个按钮执行一项昂贵的计算，使其长期占用主线程，当计算任务执行的时候去点击第二个按钮更改页面中 DIV 的背景颜色。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>requestIdleCallback</title>\r\n    <style>\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"box\">playground</div>\r\n    <button id=\"btn1\">执行计算任务</button>\r\n    <button id=\"btn2\">更改背景颜色</button>\r\n\r\n    <script>\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc() {\r\n        while (number > 0) {\r\n          value = Math.random() < 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        calc();\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n![requestIdleCallback功能体验1](https://user-images.githubusercontent.com/8088864/125783134-1435e780-a620-4cbf-b8c3-c04fccd4b145.png)\r\n\r\n使用 requestIdleCallback可以完美解决这个卡顿问题：\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>requestIdleCallback</title>\r\n    <style>\r\n      #box {\r\n        background: palegoldenrod;\r\n        padding: 20px;\r\n        margin-bottom: 10px;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"box\">playground</div>\r\n    <button id=\"btn1\">执行计算任务</button>\r\n    <button id=\"btn2\">更改背景颜色</button>\r\n\r\n    <script>\r\n      var box = document.querySelector('#box');\r\n      var btn1 = document.querySelector('#btn1');\r\n      var btn2 = document.querySelector('#btn2');\r\n      var number = 100000000;\r\n      var value = 0;\r\n\r\n      function calc(IdleDeadline) {\r\n        while (number > 0 && IdleDeadline.timeRemaining() > 1) {\r\n          value = Math.random() < 0.5 ? Math.random() : Math.random();\r\n          number--;\r\n        }\r\n\r\n        if (number > 0) {\r\n          requestIdleCallback(calc);\r\n        } else {\r\n          console.log('计算结束');\r\n        }\r\n      }\r\n\r\n      btn1.onclick = function () {\r\n        requestIdleCallback(calc);\r\n      }\r\n\r\n      btn2.onclick = function () {\r\n        console.log(number); // 0：计算任务执行完\r\n        box.style.background = 'palegreen';\r\n      }\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n![requestIdleCallback功能体验2](https://user-images.githubusercontent.com/8088864/125783529-12c4da73-fe20-4757-b858-169f381efce4.png)\r\n\r\n- 浏览器在空余时间执行 calc 函数\r\n- 当空余时间小于 1ms 时，跳出while循环\r\n- calc 根据 number 判断计算任务是否执行完成，如果没有完成，则继续注册新的空闲期的任务\r\n- 当 btn2 点击事件触发，会等到当前空闲期任务执行完后执行“更改背景颜色”的任务\r\n- “更改背景颜色”任务执行完成后，继续进入空闲期，执行后面的任务\r\n\r\n由此可见，所谓执行优先级更高的任务，是手动将计算任务拆分到浏览器的空闲期，以实现每次进入空闲期之前优先执行主线程的任务。\r\n\r\n### Fiber 出现的目的\r\n\r\nFiber 其实是 React 16 新的 DOM 比对算法的名字，旧的 DOM 比对算法的名字是 Stack。\r\n\r\n#### React 16之前的版本存在的问题\r\n\r\nReact 16之前的版本对比更新 VirtualDOM 的过程是采用**循环加递归**实现的。\r\n\r\n这种对比方式有一个问题，就是一旦任务开始进行旧无法中断（由于递归需要一层一层的进入，一层一层的退出，所以过程不能中断）。\r\n\r\n如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树对比更新完成之后主线程才能被释放，主线程才能执行其它任务。\r\n\r\n这就会导致一些用户交互、动画等任务无法立即得到执行，页面就会产生卡顿，非常影响用户的体验。\r\n\r\n因为递归利用的 **JavaScript 自身的执行栈**，所以旧版 DOM 比对的算法称为 **Stack(堆栈)**。\r\n\r\n**核心问题：递归无法中断，执行重任务耗时长，JavaScript 又是单线程的，无法同时执行其它任务，导致在绘制页面的过程当中不能执行其它任务，比如元素动画、用户交互等任务必须延后，给用户的感觉就是页面变得卡顿，用户体验差。**\r\n\r\n### Stack 算法模拟\r\n\r\n模拟 React 16 之前将虚拟 DOM 转化成真实 DOM 的递归算法：\r\n\r\n``` jsx\r\n// 要渲染的 jsx\r\nconst jsx = (\r\n  <div id=\"a1\">\r\n    <div id=\"b1\">\r\n      <div id=\"c1\"></div>\r\n      <div id=\"c2\"></div>\r\n    </div>\r\n    <div id=\"b2\"></div>\r\n  </div>\r\n)\r\n```\r\n\r\njsx 会被 Babel 转化成 `React.createElement()` 的调用，最终返回一个虚拟 DOM 对象：\r\n\r\n``` js\r\n\"use strict\";\r\n\r\nconst jsx = /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"a1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b1\"\r\n}, /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c1\"\r\n}), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"c2\"\r\n})), /*#__PURE__*/React.createElement(\"div\", {\r\n  id: \"b2\"\r\n}));\r\n```\r\n\r\n去掉一些属性，打印结果：\r\n\r\n``` js\r\nconst jsx = {\r\n  type: 'div',\r\n  props: {\r\n    id: 'a1',\r\n    children: [\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b1',\r\n          children: [\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c1'\r\n              }\r\n            },\r\n            {\r\n              type: 'div',\r\n              props: {\r\n                id: 'c2'\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      },\r\n      {\r\n        type: 'div',\r\n        props: {\r\n          id: 'b2'\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n递归转化真实 DOM：\r\n\r\n``` js\r\nconst jsx = {...}\r\nfunction render(vdom, container) {\r\n  // 创建元素\r\n  const element = document.createElement(vdom.type);\r\n  // 为元素添加属性\r\n  Object.keys(vdom.props)\r\n    .filter(prop => prop !== 'children')\r\n    .forEach(prop => (element[prop] = vdom.props[prop]));\r\n  // 递归创建子元素\r\n  if (Array.isArray(vdom.props.children)) {\r\n    vdom.props.children.forEach(child => render(child, element));\r\n  }\r\n  // 将元素添加到页面中\r\n  container.appendChild(element);\r\n}\r\n\r\nrender(jsx, document.getElementById('root'));\r\n```\r\n\r\nDOM 更新就是在上面递归的过程中加入了 Virtual DOM 对比的过程。\r\n\r\n可以看到递归是无法中断的。\r\n\r\n### React 16 解决方案 - Fiber\r\n\r\n1. 利用浏览器空余时间执行任务，拒绝长时间占用主线程\r\n  - 在新版本的 React 版本中，使用了 requestIdleCallback API\r\n  - 利用浏览器空余时间执行 VirtualDOM 比对任务，也就表示 VirtualDOM 比对不会长期占用主线程\r\n  - 如果有高优先级的任务要执行，就会暂时终止 VirtualDOM 的比对过程，先去执行高优先级的任务\r\n  - 高优先级任务执行完成，再回来继续执行 VirtualDOM 比对任务\r\n  - 这样页面就不会出现卡顿现象\r\n2. 放弃递归，只采用循环，因为循环可以被中断\r\n  - 由于递归必须一层一层进入，一层一层退出，所以过程无法中断\r\n  - 所以要实现任务的终止再继续，就必须放弃递归，只采用循环的方式执行比对的过程\r\n  - 因为循环是可以终止的，只需要将循环的条件保存下来，下一次任务就可以从中断的地方执行了\r\n3. 任务拆分，将任务拆分成一个个的小任务\r\n  - 如果任务要实现终止再继续，任务的单元就必须要小\r\n  - 这样任务即使没有执行完就被终止，重新执行任务的代价就会小很多\r\n  - 所以要进行任务的拆分，将一个大的任务拆分成一个个小的任务\r\n  - VirtualDOM 比对任务如何拆分？\r\n    - 以前将整棵 VirtualDOM 树的比对看作一个任务\r\n    - 现在将树中每一个节点的比对看作一个任务\r\n\r\n新版 React 的解决方案核心就是第 1 点，第 2、3 点都是为了实现第 1 点而存在的，\r\n\r\nFiber 翻译过来是“纤维”，意思就是执行任务的颗粒度变得细腻，像纤维一样。\r\n\r\n可以通过这个 [Demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/) 查看 Stack 算法 和 Fiber 算法的效果区别。\r\n\r\n### 实现思路\r\n\r\n在 Fiber 方案中，为了实现任务的终止再继续，DOM 对比算法被拆分成了两阶段：\r\n\r\n1. render 阶段（可中断）\r\n  - VirtualDOM 的比对，构建 Fiber 对象，构建链表\r\n\r\n2. commit 阶段（不可中断）\r\n  - 根据构建的链表进行 DOM 操作\r\n\r\n过程就是：\r\n\r\n1. 在使用 React 编写用户界面的时候仍然使用 JSX 语法\r\n2. Babel 会将 JSX 语法转换成 `React.createElement()` 方法的调用\r\n3. `React.createElement()` 方法调用后会返回 VirtualDOM 对象\r\n4. 接下来就可以执行第一个阶段了：**构建 Fiber 对象**\r\n  - 采用循环的方式从 VirtualDOM 对象中，找到每一个内部的 VirtualDOM 对象\r\n  - 为每一个 VirtualDOM 对象构建 Fiber 对象\r\n  - Fiber 对象也是 JavaScript 对象，它是从 VirtualDOM 对象衍化来的，它除了 type、props、children以外还存储了更多节点的信息，其中包含的一个核心信息是：当前节点要进行的操作，例如删除、更新、新增\r\n  - 在构建 Fiber 的过程中还要构建链表\r\n5. 接着进行第二阶段的操作：**执行 DOM 操作**\r\n\r\n总结：\r\n\r\n- DOM 初始渲染：`根据 VirtualDOM --> 创建 Fiber 对象 及 构建链表 --> 将 Fiber 对象存储的操作应用到真实 DOM 中`\r\n- DOM 更新操作：`newFiber(重新获取所有 Fiber 对象) --> newFiber vs oldFiber(获取旧的 Fiber 对象，进行比对) 将差异操作追加到链表 --> 将 Fiber 对象应用到真实 DOM 中`\r\n\r\n### 什么是 Fiber\r\n\r\nFiber 有两层含义：\r\n\r\n- Fiber 是一个执行单元\r\n- Fiber 是一种数据结构\r\n\r\n#### 执行单元\r\n\r\n在 React 16 之前，将 Virtual DOM 树整体看成一个任务进行递归处理，任务整体庞大执行耗时且不能中断。\r\n\r\n在 React 16，将整个任务拆分成一个个小的任务进行处理，每个小的任务指的就是一个 Fiber 节点的构建。\r\n\r\n任务会在浏览器的空闲时间被执行，每个单元执行完成后，React 都会检查是否还有空余时间，如果有就交还主线程的控制权。\r\n\r\n![React Fiber 执行单元流程图](https://user-images.githubusercontent.com/8088864/125878368-317a2c5c-8b16-4877-981c-3883075423bc.png)\r\n\r\n#### 数据结构\r\n\r\nFiber 是一种数据机构，支撑 Fiber 构建任务的运转。\r\n\r\nFiber 其实就是 JavaScript 对象，对象中存储了当前节点的父节点、第一个子节点、下一个兄弟节点，以便在构建链表和执行 DOM 操作的时候知道它们的关系。\r\n\r\n在 render 阶段的时候，React 会从上（root）向下，再从下向上构建所有节点对应的 Fiber 对象，在从下向上的同时还会构建链表，最后将链头存储到 Root Fiber。\r\n\r\n- 从上向下\r\n  - 从 Root 节点开始构建，优先构建子节点\r\n\r\n- 从下向上\r\n  - 如果当前节点没有子节点，就会构建下一个兄弟节点\r\n  - 如果当前节点没有子节点，也没有下一个兄弟节点，就会返回父节点，构建父节点的兄弟节点\r\n  - 如果父节点的下一个兄弟节点有子节点，就继续向下构建\r\n  - 如果父节点没有下一个兄弟节点，就继续向上查找\r\n\r\n在第二阶段的时候，通过链表结构的属性（child、sibling、parent）准确构建出完整的 DOM 节点树，从而才能将 DOM 对象追加到页面当中。\r\n\r\n``` js\r\n// Fiber 对象\r\n{\r\n  type // 节点类型（元素、文本、组件）（具体的类型）\r\n  props // 节点属性（props中包含children属性，标识当前节点的子级 VirtualDOM）\r\n  stateNode // 节点的真实 DOM 对象 | 类组件实例对象 | 函数组件的定义方法\r\n  tag // 节点标记（对具体类型的分类 host_root[顶级节点root] || host_component[普通DOM节点] || class_component[类组件] || function_component[函数组件]）\r\n  effectTag // 当前 Fiber 在 commit 阶段需要被执行的副作用类型/操作（新增、删除、修改）\r\n  nextEffect // 单链表用来快速查找下一个 sideEffect\r\n  lastEffect // 存储最新副作用，用于构建链表的 nextEffect\r\n  firstEffect // 存储第一个要执行的副作用，用于向 root 传递第一个要操作的 DOM\r\n  parent // 当前 Fiber 的父级 Fiber（React 中是 `return`）\r\n  child // 当前 Fiber 的第一个子级 Fiber\r\n  sibling // 当前 Fiber 的下一个兄弟 Fiber\r\n  alternate // 当前节点对应的旧 Fiber 的备份，用于新旧 Fiber 比对\r\n}\r\n```\r\n\r\n以上面的示例为例：\r\n\r\n``` jsx\r\n<div id=\"a1\">\r\n  <div id=\"b1\">\r\n    <div id=\"c1\"></div>\r\n    <div id=\"c2\"></div>\r\n  </div>\r\n  <div id=\"b2\"></div>\r\n</div>\r\n```\r\n\r\n![React Fiber 数据结构](https://user-images.githubusercontent.com/8088864/125878754-89f402ab-cb4b-466a-bef3-c6f20b9e10f8.png)\r\n\r\n``` js\r\n// B1 的 Fiber 对象包含这几个属性：\r\n{\r\n  child: C1_Fiber,\r\n  sibling: B2_Fiber,\r\n  parent: A1_Fiber\r\n}\r\n```\r\n\r\n## 十八、canvas\r\n\r\nCanvas API 提供了一个通过JavaScript 和 HTML的`<canvas>`元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。\r\n\r\nCanvas API主要聚焦于2D图形。而同样使用`<canvas>`元素的 WebGL API 则用于绘制硬件加速的2D和3D图形。\r\n\r\n### 标签\r\n\r\n``` html\r\n<canvas width=\"600\" height=\"400\" id=\"canvas\"></canvas>\r\n```\r\n\r\n不给宽高的话默认是300+150\r\n\r\n### 怎么用\r\n\r\n``` js\r\n// 拿到canvas\r\nvar canvas = document.getElementById(\"canvas\");\r\n// 创建画图工具\r\nvar context = canvas.getContext(\"2d\");\r\n```\r\n\r\n### 相关的api及用法\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<canvas id=\"myCanvas\" width=\"600\" height=\"500\" style=\"border:1px solid #d3d3d3;\">\r\n  Your browser does not support the HTML5 canvas tag.\r\n</canvas>\r\n\r\n<script>\r\n\r\nvar canvas = document.getElementById(\"myCanvas\");\r\nvar context = canvas.getContext(\"2d\");\r\n\r\n// 画线\r\ncontext.moveTo(100, 100);\r\ncontext.lineTo(300, 100);\r\ncontext.lineTo(300, 200);\r\n\r\n// 画第二条线\r\n// 画第二条线\r\ncontext.moveTo(100, 300);\r\ncontext.lineTo(300, 300);\r\n\r\n// 最后要描边才会出效果\r\ncontext.stroke();\r\n\r\n// 创建一张新的玻璃纸\r\ncontext.beginPath();\r\n// 画第三条线\r\ncontext.moveTo(400, 100);\r\ncontext.lineTo(400, 300);\r\ncontext.lineTo(500, 300);\r\ncontext.lineTo(500, 200);\r\n\r\n// 只要执行stroke，都会玻璃纸上的图形重复印刷一次\r\ncontext.stroke();\r\n\r\n// 填充\r\ncontext.fill();\r\ncontext.fillStyle = \"gray\";\r\n\r\n// 设置描边色\r\ncontext.strokeStyle = \"red\"; // 颜色的写法和css写法是一样的\r\ncontext.stroke();\r\n\r\n//填充\r\n//设置填充色\r\ncontext.fillStyle = \"yellowgreen\";\r\ncontext.fill();\r\n\r\n//把路径闭合\r\ncontext.closePath();\r\n\r\n//设置线条的粗细， 不需要加px\r\ncontext.lineWidth = 15;\r\n//线条的头部的设置\r\ncontext.lineCap = \"round\"; //默认是butt， 记住round\r\n</script>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n效果如下所示:\r\n\r\n![Canvas LineTo 效果图](https://user-images.githubusercontent.com/8088864/125880740-1d667e65-6511-4fd1-96a2-c697fa62aba3.png)\r\n\r\n#### 画矩形\r\n\r\n``` js\r\n// 直接传入 x， y， width， height， 就可以绘制一个矩形\r\n// 画在玻璃纸上\r\n\r\ncontext.rect(100, 100, 200, 200);\r\ncontext.strokeStyle = \"red\";\r\ncontext.stroke();\r\ncontext.fillStyle = \"yellow\";\r\ncontext.fill();\r\n```\r\n\r\n``` js\r\n// 直接创建一个填充的矩形\r\n// 创建玻璃纸， 画矩形路径， 填充， 把玻璃纸销毁\r\ncontext.fillRect(100, 100, 200, 200);\r\n\r\n// 黄色的边不会显示，是因为上面那一句，画完之后，就把玻璃纸销毁了\r\ncontext.strokeStyle = \"yellow\";\r\ncontext.stroke();\r\n// 如果放在fillRect上面就可以实现\r\n```\r\n\r\n#### 圆形绘制\r\n\r\n``` js\r\n// x轴是0度开始\r\n// x, y: 圆心位置；radius： 半径的长度; startRadian, endRadian 代表的是起始弧度和结束弧度；dircetion代表的圆形的路径的方向，默认是顺时针（是否逆时针， 默认值是false），如果传true就是逆时针,最后一个参数是可以不传的， 默认就是顺时针\r\n\r\n// context.arc(x, y, radius, startRadian, endRadian, direction);\r\n\r\n// 从31度的地方，画到81度的地方\r\ncontext.arc(300, 200, 100, 31/180*Math.PI, 81/180*Math.PI);\r\n\r\ncontext.strokeStyle = \"yellow\";\r\ncontext.stroke();\r\n\r\ncontext.fillStyle = \"red\";\r\ncontext.fill();\r\n```\r\n\r\n#### 画飞镖转盘\r\n\r\n``` js\r\nfor (var i = 0; i < 10; i++) {\r\n    context.moveTo(320+i*20,200);\r\n    // i % 2代表是奇数还是偶数， 偶数就逆时针， 奇数就顺时针\r\n    context.arc(300, 200, 20 + i * 20, 0, 2*Math.PI, i%2==0);\r\n}\r\ncontext.fillStyle = \"green\";\r\ncontext.fill();\r\ncontext.stroke();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas arc 画飞镖转盘](https://user-images.githubusercontent.com/8088864/125925307-9fdd88ec-8569-412d-9245-37aceca560ba.png)\r\n\r\n#### 线性渐变\r\n\r\n``` js\r\n// 1. 需要创建出一个渐变对象\r\n//    var gradient = context.createLinearGradient(100, 100, 300, 100);\r\n// 参数代表哪个点到哪个点，这里写的是左上角到右下角的意思\r\nvar gradient = context.createLinearGradient(100, 100, 300, 380);\r\n\r\n// 2. 添加渐变颜色\r\ngradient.addColorStop(0, \"red\");\r\ngradient.addColorStop(0.5, \"hotpink\");\r\ngradient.addColorStop(1, \"yellowgreen\");\r\n\r\n// 3. 将渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n// 4. 画一个矩形\r\ncontext.fillRect(100, 100, 200, 280);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createLinearGradient 线性渐变](https://user-images.githubusercontent.com/8088864/125925678-c260361c-11cb-44cd-86f9-86156ea7033e.png)\r\n\r\n#### 径向渐变\r\n\r\n``` js\r\n// 1. 创建渐变对象\r\n// 内圆\r\nvar c1 = {x: 260, y: 160, r: 0};\r\n// 外圆\r\nvar c2 = {x: 300, y: 200, r: 120};\r\n\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(0, \"red\");\r\ngradient.addColorStop(0.3, \"yellow\");\r\ngradient.addColorStop(0.6, \"green\");\r\ngradient.addColorStop(1, \"orange\");\r\n\r\n// 2. 把渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n// 3. 画圆并填充\r\n// 内圆的部分是用0的位置填充的; 内圆的边到外圆的边所发生的渐变叫， 径向渐变\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变](https://user-images.githubusercontent.com/8088864/125926105-f8d0128c-fc71-4278-9c10-580d9dbf4d3c.png)\r\n\r\n#### 径向渐变画球\r\n\r\n``` js\r\n//1. 创建一个径向渐变\r\nvar c1 = {x: 240, y: 160, r: 0};\r\nvar c2 = {x: 300, y: 200, r: 120};\r\n\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(1, \"gray\");\r\ngradient.addColorStop(0, \"lightgray\");\r\n\r\n//2. 将渐变对象设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n//3. 画圆并填充\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变画球](https://user-images.githubusercontent.com/8088864/125926450-19a90cf2-1049-4d2c-a47d-1f22fad0cd58.png)\r\n\r\n#### 径向渐变画彩虹\r\n\r\n``` js\r\n//实现彩虹，给里面的圆一个半径80是关键\r\nvar c1 = {x: 300, y: 200, r: 80};\r\nvar c2 = {x: 300, y: 200, r: 150};\r\nvar gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\ngradient.addColorStop(1, \"red\");\r\ngradient.addColorStop(6/7, \"orange\");\r\ngradient.addColorStop(5/7, \"yellow\");\r\ngradient.addColorStop(4/7, \"green\");\r\ngradient.addColorStop(3/7, \"cyan\");\r\ngradient.addColorStop(2/7, \"skyblue\");\r\ngradient.addColorStop(1/7, \"purple\");\r\ngradient.addColorStop(0, \"white\");\r\n\r\n//设为填充色\r\ncontext.fillStyle = gradient;\r\n\r\n//画圆并填充\r\ncontext.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\ncontext.fill();\r\n\r\n//遮挡下半部分\r\ncontext.fillStyle = \"white\";\r\ncontext.fillRect(0, 200, 600, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas createRadialGradient 径向渐变画彩虹](https://user-images.githubusercontent.com/8088864/125926965-02866a67-5dd9-4be1-84f3-b0589696e7f7.png)\r\n\r\n#### 阴影效果\r\n\r\n``` js\r\n//和css3相比， 阴影只能设一个， 不能设内阴影\r\n//水平偏移， 垂直的偏移， 模糊程度， 阴影的颜色\r\n\r\n//设置阴影的参数\r\ncontext.shadowOffsetX = 10;\r\ncontext.shadowOffsetY = 10;\r\ncontext.shadowBlur = 10;\r\ncontext.shadowColor = \"yellowgreen\";\r\n\r\n//画一个矩形\r\ncontext.fillStyle = \"red\";\r\ncontext.fillRect(100, 100, 300, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas shadow 阴影效果](https://user-images.githubusercontent.com/8088864/125927364-e91bafb3-7e90-4173-bd39-4ee8ae7da746.png)\r\n\r\n#### 绘制文字api\r\n\r\n``` js\r\n//绘制文字\r\n//text就是要绘制的文字， x， y就是从什么地方开始绘制\r\n//context.strokeText(\"text\", x, y)\r\n\r\ncontext.font = \"60px 微软雅黑\";\r\n//context.strokeText(\"hello, world\", 100, 100);\r\ncontext.fillText(\"hello, world\", 100, 100);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 绘制文字](https://user-images.githubusercontent.com/8088864/125927573-fdaa09b5-93d7-4990-86ee-2fa9a453eab5.png)\r\n\r\n#### 文字对齐方式\r\n\r\n``` js\r\n//默认在left\r\n//关键api：context.textAlign = \"left\";\r\ncontext.textAlign = \"left\";\r\ncontext.fillText(\"left\", 300, 120);\r\n\r\ncontext.textAlign = \"center\";\r\ncontext.fillText(\"center\", 300, 190);\r\n\r\ncontext.textAlign = \"right\";\r\ncontext.fillText(\"right\", 300, 260);\r\n\r\n// 文字出现在canvas的右上方\r\n// 1. 先设置right\r\n// 2. 给canvas.width,0即可\r\ncontext.font = \"60px 微软雅黑\";\r\ncontext.textAlign = \"right\";\r\ncontext.textBaseline = \"top\";\r\ncontext.fillText(\"hello, world\", canvas.width, 0);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 水平对齐方式](https://user-images.githubusercontent.com/8088864/125934392-abf31a1e-2b7e-429f-90cc-8cef9fd516d0.png)\r\n\r\n\r\n#### 垂直方向\r\n\r\n``` js\r\n//默认是top\r\n//关键api：context.textBaseline = \"top\";\r\n\r\ncontext.fillText(\"default\", 50, 200);\r\n\r\ncontext.textBaseline = \"top\";\r\ncontext.fillText(\"top\", 150, 200);\r\n\r\ncontext.textBaseline = \"middle\";\r\ncontext.fillText(\"middle\", 251, 200);\r\n\r\ncontext.textBaseline = \"bottom\";\r\ncontext.fillText(\"bottom\", 400, 200);\r\n```\r\n\r\n效果图如下所示:\r\n\r\n![Canvas fillText 垂直对齐方式](https://user-images.githubusercontent.com/8088864/125935099-d0a918b3-25e8-4150-bd86-053a5e5cfa98.png)\r\n\r\n#### 图片的绘制\r\n\r\n3参模式： 将img从x, y的地方开始绘制， 图片有多大，就绘制多大，超出canvas的部分就不显示了\r\n\r\n``` js\r\n//context.drawImage(img, x, y)\r\n\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\n\r\n//必须要等到图片加载出来，才能进行绘制的操作\r\nimage.onload = function () {\r\n  context.drawImage(image, 100, 200);\r\n}\r\n```\r\n\r\n5参模式（缩放模式）, 就是将图片显示在画布上的某一块区域（x, y, w, h）,如果这个区域的宽高和图片不一至，会被压缩或放大\r\n\r\n``` js\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\n\r\nimage.onload = function () {\r\n  context.drawImage(image, 100, 100, 100, 100);\r\n}\r\n```\r\n\r\n图片绘制的9参模式， 就是把原图（img）中的某一块（imagex，imagey，imagew，imageh）截取出来， 显示在画布的某个区域(canvasx, canvasy, canvasw, canvash)\r\n\r\n``` js\r\n//理解关键：\r\n//（imagex，imagey，imagew，imageh）\r\n//(canvasx, canvasy, canvasw, canvash)\r\n\r\nvar image = new Image();\r\nimage.src = \"./img/gls.jpg\";\r\nimage.onload = function () {\r\n  /*\r\n    参数的解释：\r\n    image： 就是大图片本身\r\n    中间的四个参数， 代表从图片的150， 0的位置，截取 150 * 200的一块区域\r\n    后面的四个参数， 将刚才截取的小图， 显示画布上 100， 100， 150， 200的这个区域\r\n  */\r\n  context.drawImage(image, 150, 0, 150, 200, 100, 100, 150, 200);\r\n}\r\n```\r\n\r\n## 十九、WebWorker和postMessage\r\n\r\n### 概述\r\n\r\nJavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。\r\n\r\nWeb Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\r\n\r\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。\r\n\r\nWeb Worker 有以下几个使用注意点。\r\n\r\n#### （1）同源限制\r\n\r\n分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。\r\n\r\n#### （2）DOM 限制\r\n\r\nWorker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。\r\n\r\n#### （3）通信联系\r\n\r\nWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。(postMessage)\r\n\r\n#### （4）脚本限制\r\n\r\nWorker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。\r\n\r\n#### （5）文件限制\r\n\r\nWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。\r\n\r\n### 基本用法\r\n\r\n#### 主线程\r\n\r\n主线程采用`new`命令，调用`Worker()`构造函数，新建一个 `Worker` 线程。\r\n\r\n``` js\r\nvar worker = new Worker('work.js');\r\n```\r\n\r\n`Worker()`构造函数的参数是一个脚本文件，该文件就是 `Worker` 线程所要执行的任务。由于 `Worker` 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），`Worker` 就会默默地失败。\r\n\r\n然后，主线程调用`worker.postMessage()`方法，向 `Worker` 发消息。\r\n\r\n``` js\r\nworker.postMessage('Hello World');\r\nworker.postMessage({method: 'echo', args: ['Work']});\r\n// worker.postMessage() 方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。\r\n```\r\n\r\n接着，主线程通过`worker.onmessage`指定监听函数，接收子线程发回来的消息。\r\n\r\n``` js\r\nworker.onmessage = function (event) {\r\n  console.log('Received message ' + event.data);\r\n  doSomething();\r\n}\r\n\r\nfunction doSomething() {\r\n  // 执行任务\r\n  worker.postMessage('Work done!');\r\n}\r\n```\r\n\r\n上面代码中，事件对象的data属性可以获取 `Worker` 发来的数据。\r\n\r\n`Worker` 完成任务以后，主线程就可以把它关掉。\r\n\r\n``` js\r\nworker.terminate();\r\n```\r\n\r\n#### Worker 线程\r\n\r\n`Worker` 线程内部需要有一个监听函数，监听`message`事件。\r\n\r\n``` js\r\nself.addEventListener('message', function (e) {\r\n  self.postMessage('You said: ' + e.data);\r\n}, false);\r\n```\r\n\r\n上面代码中，`self`代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。\r\n\r\n```js\r\n// 写法一\r\nthis.addEventListener('message', function (e) {\r\n  this.postMessage('You said: ' + e.data);\r\n}, false);\r\n\r\n// 写法二\r\naddEventListener('message', function (e) {\r\n  postMessage('You said: ' + e.data);\r\n}, false);\r\n```\r\n\r\n除了使用`self.addEventListener()`指定监听函数，也可以使用`self.onmessage`指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。`self.postMessage()`方法用来向主线程发送消息。\r\n\r\n根据主线程发来的数据，`Worker` 线程可以调用不同的方法，下面是一个例子。\r\n\r\n``` js\r\nself.addEventListener('message', function (e) {\r\n  var data = e.data;\r\n  switch (data.cmd) {\r\n    case 'start':\r\n      self.postMessage('WORKER STARTED: ' + data.msg);\r\n      break;\r\n    case 'stop':\r\n      self.postMessage('WORKER STOPPED: ' + data.msg);\r\n      self.close(); // Terminates the worker.\r\n      break;\r\n    default:\r\n      self.postMessage('Unknown command: ' + data.msg);\r\n  };\r\n}, false);\r\n```\r\n\r\n上面代码中，`self.close()`用于在 Worker 内部关闭自身。\r\n\r\n#### Worker 加载脚本\r\n\r\nWorker 内部如果要加载其他脚本，有一个专门的方法`importScripts()`。\r\n\r\n``` js\r\nimportScripts('script1.js');\r\n```\r\n\r\n该方法可以同时加载多个脚本。\r\n\r\n``` js\r\nimportScripts('script1.js', 'script2.js');\r\n```\r\n\r\n#### Worker 错误处理\r\n\r\n主线程可以监听 `Worker` 是否发生错误。如果发生错误，`Worker` 会触发主线程的error事件。\r\n\r\n``` js\r\nworker.onerror(function (event) {\r\n  console.log([\r\n    'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message\r\n  ].join(''));\r\n});\r\n\r\n// 或者\r\nworker.addEventListener('error', function (event) {\r\n  // ...\r\n});\r\n```\r\n\r\n`Worker` 内部也可以监听error事件。\r\n\r\n#### 关闭 Worker\r\n\r\n使用完毕，为了节省系统资源，必须关闭 Worker。\r\n\r\n``` js\r\n// 主线程\r\nworker.terminate();\r\n\r\n// Worker 线程\r\nself.close();\r\n```\r\n\r\n### 数据通信\r\n\r\n前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。\r\n\r\n主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。\r\n\r\n``` js\r\n// 主线程\r\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\r\nfor (var i = 0; i < uInt8Array.length; ++i) {\r\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\r\n}\r\nworker.postMessage(uInt8Array);\r\n\r\n// Worker 线程\r\nself.onmessage = function (e) {\r\n  var uInt8Array = e.data;\r\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\r\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\r\n};\r\n```\r\n\r\n但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。\r\n\r\n如果要直接转移数据的控制权，就要使用下面的写法。\r\n\r\n``` js\r\n// Transferable Objects 格式\r\nworker.postMessage(arrayBuffer, [arrayBuffer]);\r\n\r\n// 例子\r\nvar ab = new ArrayBuffer(1);\r\nworker.postMessage(ab, [ab]);\r\n```\r\n\r\n### 同页面的 Web Worker\r\n\r\n通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n  <body>\r\n    <script id=\"worker\" type=\"app/worker\">\r\n      addEventListener('message', function () {\r\n        postMessage('some message');\r\n      }, false);\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n上面是一段嵌入网页的脚本，注意必须指定`<script>`标签的type属性是一个浏览器不认识的值，上例是`app/worker`。\r\n\r\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。\r\n\r\n``` js\r\nvar blob = new Blob([document.querySelector('#worker').textContent]);\r\nvar url = window.URL.createObjectURL(blob);\r\nvar worker = new Worker(url);\r\n\r\nworker.onmessage = function (e) {\r\n  // e.data === 'some message'\r\n};\r\n```\r\n\r\n上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。\r\n\r\n### Worker 线程完成轮询\r\n\r\n有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。\r\n\r\n``` js\r\nfunction createWorker(f) {\r\n  var blob = new Blob(['(' + f.toString() +')()']);\r\n  var url = window.URL.createObjectURL(blob);\r\n  var worker = new Worker(url);\r\n  return worker;\r\n}\r\n\r\nvar pollingWorker = createWorker(function (e) {\r\n  var cache;\r\n\r\n  function compare(new, old) { ... };\r\n\r\n  setInterval(function () {\r\n    fetch('/my-api-endpoint').then(function (res) {\r\n      var data = res.json();\r\n\r\n      if (!compare(data, cache)) {\r\n        cache = data;\r\n        self.postMessage(data);\r\n      }\r\n    })\r\n  }, 1000)\r\n});\r\n\r\npollingWorker.onmessage = function () {\r\n  // render data\r\n}\r\n\r\npollingWorker.postMessage('init');\r\n```\r\n\r\n上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。\r\n\r\n### Worker 新建 Worker\r\n\r\nWorker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。\r\n\r\n主线程代码如下。\r\n\r\n``` js\r\nvar worker = new Worker('worker.js');\r\nworker.onmessage = function (event) {\r\n  document.getElementById('result').textContent = event.data;\r\n};\r\n```\r\n\r\nWorker 线程代码如下。\r\n\r\n``` js\r\n// worker.js\r\n\r\n// settings\r\nvar num_workers = 10;\r\nvar items_per_worker = 1000000;\r\n\r\n// start the workers\r\nvar result = 0;\r\nvar pending_workers = num_workers;\r\nfor (var i = 0; i < num_workers; i += 1) {\r\n  var worker = new Worker('core.js');\r\n  worker.postMessage(i * items_per_worker);\r\n  worker.postMessage((i + 1) * items_per_worker);\r\n  worker.onmessage = storeResult;\r\n}\r\n\r\n// handle the results\r\nfunction storeResult(event) {\r\n  result += event.data;\r\n  pending_workers -= 1;\r\n  if (pending_workers <= 0)\r\n    postMessage(result); // finished!\r\n}\r\n```\r\n\r\n上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。\r\n\r\n``` js\r\n// core.js\r\nvar start;\r\nonmessage = getStart;\r\nfunction getStart(event) {\r\n  start = event.data;\r\n  onmessage = getEnd;\r\n}\r\n\r\nvar end;\r\nfunction getEnd(event) {\r\n  end = event.data;\r\n  onmessage = null;\r\n  work();\r\n}\r\n\r\nfunction work() {\r\n  var result = 0;\r\n  for (var i = start; i < end; i += 1) {\r\n    // perform some complex calculation here\r\n    result += 1;\r\n  }\r\n  postMessage(result);\r\n  close();\r\n}\r\n```\r\n\r\n### API\r\n\r\n#### 主线程\r\n\r\n浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。\r\n\r\n``` js\r\nvar myWorker = new Worker(jsUrl, options);\r\n```\r\n\r\nWorker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。\r\n\r\n``` js\r\n// 主线程\r\nvar myWorker = new Worker('worker.js', { name : 'myWorker' });\r\n\r\n// Worker 线程\r\nself.name // myWorker\r\n```\r\n\r\nWorker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。\r\n\r\n- Worker.onerror：指定 error 事件的监听函数。\r\n- Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。\r\n- Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\r\n- Worker.postMessage()：向 Worker 线程发送消息。\r\n- Worker.terminate()：立即终止 Worker 线程。\r\n\r\n#### Worker 线程\r\n\r\nWeb Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。\r\n\r\nWorker 线程有一些自己的全局属性和方法。\r\n\r\n- self.name： Worker 的名字。该属性只读，由构造函数指定。\r\n- self.onmessage：指定message事件的监听函数。\r\n- self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。\r\n- self.close()：关闭 Worker 线程。\r\n- self.postMessage()：向产生这个 Worker 线程发送消息。\r\n- self.importScripts()：加载 JS 脚本。\r\n\r\n## 二十、OffscreenCanvas 离屏Canvas — 使用Web Worker提高你的Canvas运行速度\r\n\r\nOffscreenCanvas提供了一个可以脱离屏幕渲染的canvas对象。\r\n\r\n有了离屏Canvas，你可以不用在你的主线程中绘制图像了！\r\n\r\nCanvas 是一个非常受欢迎的表现方式，同时也是WebGL的入口。它能绘制图形，图片，展示动画，甚至是处理视频内容。它经常被用来在富媒体web应用中创建炫酷的用户界面或者是制作在线（web）游戏。\r\n\r\n它是非常灵活的，这意味着绘制在Canvas的内容可以被编程。JavaScript就提供了Canvas的系列API。这些给了Canvas非常好的灵活度。\r\n\r\n但同时，在一些现代化的web站点，脚本解析运行是实现流畅用户反馈的最大的问题之一。因为Canvas计算和渲染和用户操作响应都发生在同一个线程中，在动画中（有时候很耗时）的计算操作将会导致App卡顿，降低用户体验。\r\n\r\n幸运的是, [OffscreenCanvas](https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas) 离屏Canvas可以非常棒的解决这个麻烦！\r\n\r\n到目前为止，Canvas的绘制功能都与`<canvas>`标签绑定在一起，这意味着Canvas API和DOM是耦合的。而OffscreenCanvas，正如它的名字一样，通过将Canvas移出屏幕来解耦了DOM和Canvas API。\r\n\r\n由于这种解耦，OffscreenCanvas的渲染与DOM完全分离了开来，并且比普通Canvas速度提升了一些，而这只是因为两者（Canvas和DOM）之间没有同步。但更重要的是，将两者分离后，Canvas将可以在Web Worker中使用，即使在Web Worker中没有DOM。这给Canvas提供了更多的可能性。\r\n\r\n### 兼容性\r\n\r\n这是一个实验中的功能\r\n此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。\r\n\r\n支持浏览器如下图所示：\r\n\r\n![OffscreenCanvas兼容性](https://user-images.githubusercontent.com/8088864/126027990-d476b78e-e6c9-4438-998d-7ccc4ae79f8b.png)\r\n\r\n### 在Worker中使用OffscreenCanvas\r\n\r\n它在窗口环境和web worker环境均有效。\r\n\r\n[Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API) 是一个Web版的线程——它允许你在幕后运行你的代码。将你的一部分代码放到Worker中可以给你的主线程更多的空闲时间，这可以提高你的用户体验度。就像其没有DOM一样，直到现在，在Worker中都没有Canvas API。\r\n\r\n而OffscreenCanvas并不依赖DOM，所以在Worker中Canvas API可以被某种方法来代替。下面是我在Worker中用OffscreenCanvas来计算渐变颜色的：\r\n\r\n``` js\r\n// file: worker.js\r\n\r\nfunction getGradientColor(percent) {\r\n    const canvas = new OffscreenCanvas(100, 1);\r\n    const ctx = canvas.getContext('2d');\r\n    const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\r\n    gradient.addColorStop(0, 'red');\r\n    gradient.addColorStop(1, 'blue');\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(0, 0, ctx.canvas.width, 1);\r\n    const imgd = ctx.getImageData(0, 0, ctx.canvas.width, 1);\r\n    const colors = imgd.data.slice(percent * 4, percent * 4 + 4);\r\n    return `rgba(${colors[0]}, ${colors[1]}, ${colors[2]}, ${colors[3]})`;\r\n}\r\n\r\ngetGradientColor(40);  // rgba(152, 0, 104, 255)\r\n```\r\n\r\n### 不要阻塞主线程\r\n\r\n当我们将大量的计算移到Worker中运行时，可以释放主线程上的资源，这很有意思。我们可以使用transferControlToOffscreen 方法将常规的Canvas映射到OffscreenCanvas实例上。之后所有应用于OffscreenCanvas的操作将自动呈现在在源Canvas上。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html>\r\n<body>\r\n<canvas id=\"myCanvas\" width=\"600\" height=\"500\" style=\"border:1px solid #d3d3d3;\">\r\n  Your browser does not support the HTML5 canvas tag.\r\n</canvas>\r\n<script>\r\nvar canvas = document.getElementById(\"myCanvas\");\r\n// var context = canvas.getContext(\"2d\");\r\n\r\n// // 画线\r\n// context.moveTo(100, 100);\r\n// context.lineTo(300, 100);\r\n// context.lineTo(300, 200);\r\n\r\n// // 画第二条线\r\n// // 画第二条线\r\n// context.moveTo(100, 300);\r\n// context.lineTo(300, 300);\r\n\r\n// // 最后要描边才会出效果\r\n// context.stroke();\r\n\r\n// // 创建一张新的玻璃纸\r\n// context.beginPath();\r\n// // 画第三条线\r\n// context.moveTo(400, 100);\r\n// context.lineTo(400, 300);\r\n// context.lineTo(500, 300);\r\n// context.lineTo(500, 200);\r\n\r\n// // 只要执行stroke，都会玻璃纸上的图形重复印刷一次\r\n// context.stroke();\r\n\r\n// // 填充\r\n// context.fill();\r\n// context.fillStyle = \"gray\";\r\n\r\n// // 设置描边色\r\n// context.strokeStyle = \"red\"; // 颜色的写法和css写法是一样的\r\n// context.stroke();\r\n\r\n// //填充\r\n// //设置填充色\r\n// context.fillStyle = \"yellowgreen\";\r\n// context.fill();\r\n\r\n// //把路径闭合\r\n// context.closePath();\r\n\r\n// //设置线条的粗细， 不需要加px\r\n// context.lineWidth = 15;\r\n// //线条的头部的设置\r\n// context.lineCap = \"round\"; //默认是butt， 记住round\r\n\r\n// 注: 如果将canvas转化成离屏canvas时，就不能使用原canvas的cantext来绘制图案，否则会报错，已经绘制了的canvas不同通过transferControlToOffscreen转换成OffscreenCanvas\r\n// Uncaught DOMException: Failed to execute 'transferControlToOffscreen' on 'HTMLCanvasElement': Cannot transfer control from a canvas that has a rendering context.\r\nconst offscreen = canvas.transferControlToOffscreen();\r\nconst worker = new Worker('worker.js');\r\nworker.postMessage({ canvas: offscreen }, [offscreen]);\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\nOffscreenCanvas 是可转移的，除了将其指定为传递信息中的字段之一以外，还需要将其作为postMessage（传递信息给Worker的方法）中的第二个参数传递出去，以便可以在Worker线程的context（上下文）中使用它。\r\n\r\n``` js\r\n// worker.js\r\n\r\nself.onmessage = function (event) {\r\n  // 获取传送过来的离屏Canvas(OffscreenCanvas)\r\n  var canvas = event.data.canvas;\r\n  var context = canvas.getContext('2d');\r\n\r\n  // 画一个曲径球体\r\n  var c1 = {x: 240, y: 160, r: 0};\r\n  var c2 = {x: 300, y: 200, r: 120};\r\n\r\n  var gradient = context.createRadialGradient(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);\r\n  gradient.addColorStop(1, \"gray\");\r\n  gradient.addColorStop(0, \"lightgray\");\r\n\r\n  //2. 将渐变对象设为填充色\r\n  context.fillStyle = gradient;\r\n\r\n  //3. 画圆并填充\r\n  context.arc(c2.x, c2.y, c2.r, 0, 2*Math.PI);\r\n  context.fill();\r\n}\r\n```\r\n\r\n效果如下所示:\r\n\r\n![WebWorker中OffscreenCanvas绘制径向渐变画球](https://user-images.githubusercontent.com/8088864/126027866-d78a65fc-8f0f-4a7e-9adf-7eb09a03b956.png)\r\n\r\n任务繁忙的主线程也不会影响在Worker上运行的动画。所以即使主线程非常繁忙，你也可以通过此功能来避免掉帧并保证流畅的动画\r\n\r\n### WebRTC的YUV媒体流数据的离屏渲染\r\n\r\n从 WebRTC 中拿到的是 YUV 的原始视频流，将原始的 YUV 视频帧直接转发过来，通过第三方库直接在 Cavans 上渲染。\r\n\r\n可以使用[yuv-canvas](https://github.com/brion/yuv-canvas)和[yuv-buffer](https://github.com/brion/yuv-buffer)第三方库来渲染YUV的原始视频流。\r\n\r\n主进程render.js\r\n\r\n``` js\r\n\"use strict\";\r\nexports.__esModule = true;\r\nvar isEqual = require('lodash.isequal');\r\nvar YUVBuffer = require('yuv-buffer');\r\nvar YUVCanvas = require('yuv-canvas');\r\nvar Renderer = /** @class */ (function () {\r\n    function Renderer(workSource) {\r\n        var _this = this;\r\n        this._sendCanvas = function () {\r\n            _this.canvasSent = true;\r\n            _this.worker && _this.worker.postMessage({\r\n                type: 'constructor',\r\n                data: {\r\n                    canvas: _this.offCanvas,\r\n                    id: (_this.element && _this.element.id) || (Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2))\r\n                }\r\n            }, [_this.offCanvas]);\r\n        };\r\n        /**\r\n         * 判断使用渲染的方式\r\n         */\r\n        this._checkRendererWay = function () {\r\n            if (_this.workerReady && _this.worker && _this.offCanvas && _this.enableWorker) {\r\n                return 'worker';\r\n            }\r\n            else {\r\n                return 'software';\r\n            }\r\n        };\r\n        // workerCanvas渲染\r\n        this._workDrawFrame = function (width, height, yUint8Array, uUint8Array, vUint8Array) {\r\n            if (_this.canvasWrapper && _this.canvasWrapper.style.display !== 'none') {\r\n                _this.canvasWrapper.style.display = 'none';\r\n            }\r\n            if (_this.workerCanvasWrapper && _this.workerCanvasWrapper.style.display === 'none') {\r\n                _this.workerCanvasWrapper.style.display = 'flex';\r\n            }\r\n            _this.worker && _this.worker.postMessage({\r\n                type: 'drawFrame',\r\n                data: {\r\n                    width: width,\r\n                    height: height,\r\n                    yUint8Array: yUint8Array,\r\n                    uUint8Array: uUint8Array,\r\n                    vUint8Array: vUint8Array\r\n                }\r\n            }, [yUint8Array, uUint8Array, vUint8Array]);\r\n        };\r\n        // 实际渲染Canvas\r\n        this._softwareDrawFrame = function (width, height, yUint8Array, uUint8Array, vUint8Array) {\r\n            if (_this.workerCanvasWrapper && _this.workerCanvasWrapper.style.display !== 'none') {\r\n                _this.workerCanvasWrapper.style.display = 'none';\r\n            }\r\n            if (_this.canvasWrapper && _this.canvasWrapper.style.display === 'none') {\r\n                _this.canvasWrapper.style.display = 'flex';\r\n            }\r\n            var format = YUVBuffer.format({\r\n                width: width,\r\n                height: height,\r\n                chromaWidth: width / 2,\r\n                chromaHeight: height / 2\r\n            });\r\n            var y = YUVBuffer.lumaPlane(format, yUint8Array);\r\n            var u = YUVBuffer.chromaPlane(format, uUint8Array);\r\n            var v = YUVBuffer.chromaPlane(format, vUint8Array);\r\n            var frame = YUVBuffer.frame(format, y, u, v);\r\n            _this.yuv.drawFrame(frame);\r\n        };\r\n        this.cacheCanvasOpts = {};\r\n        this.yuv = {};\r\n        this.ready = false;\r\n        this.contentMode = 0;\r\n        this.container = {};\r\n        this.canvasWrapper;\r\n        this.canvas = {};\r\n        this.element = {};\r\n        this.offCanvas = {};\r\n        this.enableWorker = !!workSource;\r\n        if (this.enableWorker) {\r\n            this.worker = new Worker(workSource);\r\n            this.workerReady = false;\r\n            this.canvasSent = false;\r\n            this.worker.onerror = function (evt) {\r\n                console.error('[WorkerRenderer]: the renderer worker catch error: ', evt);\r\n                _this.workerReady = false;\r\n                _this.enableWorker = false;\r\n            };\r\n            this.worker.onmessage = function (evt) {\r\n                var data = evt.data;\r\n                switch (data.type) {\r\n                    case 'ready': {\r\n                        console.log('[WorkerRenderer]: the renderer worker was ready');\r\n                        _this.workerReady = true;\r\n                        if (_this.offCanvas) {\r\n                            _this._sendCanvas();\r\n                        }\r\n                        break;\r\n                    }\r\n                    case 'exited': {\r\n                        console.log('[WorkerRenderer]: the renderer worker was exited');\r\n                        _this.workerReady = false;\r\n                        _this.enableWorker = false;\r\n                        break;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n    Renderer.prototype._calcZoom = function (vertical, contentMode, width, height, clientWidth, clientHeight) {\r\n        if (vertical === void 0) { vertical = false; }\r\n        if (contentMode === void 0) { contentMode = 0; }\r\n        var localRatio = clientWidth / clientHeight;\r\n        var tempRatio = width / height;\r\n        if (isNaN(localRatio) || isNaN(tempRatio)) {\r\n            return 1;\r\n        }\r\n        if (!contentMode) {\r\n            if (vertical) {\r\n                return localRatio > tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n            else {\r\n                return localRatio < tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n        }\r\n        else {\r\n            if (vertical) {\r\n                return localRatio < tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n            else {\r\n                return localRatio > tempRatio ?\r\n                    clientHeight / height : clientWidth / width;\r\n            }\r\n        }\r\n    };\r\n    Renderer.prototype.getBindingElement = function () {\r\n        return this.element;\r\n    };\r\n    Renderer.prototype.bind = function (element) {\r\n        // record element\r\n        this.element = element;\r\n        // create container\r\n        var container = document.createElement('div');\r\n        container.className += ' video-canvas-container';\r\n        Object.assign(container.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'relative'\r\n        });\r\n        this.container = container;\r\n        element && element.appendChild(this.container);\r\n        // 创建两个canvas，一个在主线程中渲染，如果web worker中的离屏canvas渲染进程出错了，还可以切换到主进程的canvas进行渲染\r\n        var canvasWrapper = document.createElement('div');\r\n        canvasWrapper.className += ' video-canvas-wrapper canvas-renderer';\r\n        Object.assign(canvasWrapper.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'absolute',\r\n            left: '0px',\r\n            right: '0px',\r\n            display: 'none'\r\n        });\r\n        this.canvasWrapper = canvasWrapper;\r\n        this.container.appendChild(this.canvasWrapper);\r\n        var workerCanvasWrapper = document.createElement('div');\r\n        workerCanvasWrapper.className += ' video-canvas-wrapper webworker-renderer';\r\n        Object.assign(workerCanvasWrapper.style, {\r\n            width: '100%',\r\n            height: '100%',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n            position: 'absolute',\r\n            left: '0px',\r\n            right: '0px',\r\n            display: 'none'\r\n        });\r\n        this.workerCanvasWrapper = workerCanvasWrapper;\r\n        this.container.appendChild(this.workerCanvasWrapper);\r\n        // create canvas\r\n        this.canvas = document.createElement('canvas');\r\n        this.workerCanvas = document.createElement('canvas');\r\n        this.canvasWrapper.appendChild(this.canvas);\r\n        this.workerCanvasWrapper.appendChild(this.workerCanvas);\r\n        // 创建 OffscreenCanvas 对象\r\n        this.offCanvas = this.workerCanvas.transferControlToOffscreen();\r\n        if (!this.canvasSent && this.offCanvas && this.worker && this.workerReady) {\r\n            this._sendCanvas();\r\n        }\r\n        this.yuv = YUVCanvas.attach(this.canvas, { webGL: false });\r\n    };\r\n    Renderer.prototype.unbind = function () {\r\n        this.canvasWrapper && this.canvasWrapper.removeChild(this.canvas);\r\n        this.workerCanvasWrapper && this.workerCanvasWrapper.removeChild(this.workerCanvas);\r\n        this.container && this.container.removeChild(this.canvasWrapper);\r\n        this.container && this.container.removeChild(this.workerCanvasWrapper);\r\n        this.element && this.element.removeChild(this.container);\r\n        this.worker && this.worker.terminate();\r\n        this.workerReady = false;\r\n        this.canvasSent = false;\r\n        this.yuv = null;\r\n        this.container = null;\r\n        this.workerCanvasWrapper = null;\r\n        this.canvasWrapper = null;\r\n        this.element = null;\r\n        this.canvas = null;\r\n        this.workerCanvas = null;\r\n        this.offCanvas = null;\r\n        this.worker = null;\r\n    };\r\n    Renderer.prototype.refreshCanvas = function () {\r\n        // Not implemented for software renderer\r\n    };\r\n    Renderer.prototype.updateCanvas = function (options) {\r\n        if (options === void 0) { options = {\r\n            width: 0,\r\n            height: 0,\r\n            rotation: 0,\r\n            mirrorView: false,\r\n            contentMode: 0,\r\n            clientWidth: 0,\r\n            clientHeight: 0\r\n        }; }\r\n        // check if display options changed\r\n        if (isEqual(this.cacheCanvasOpts, options)) {\r\n            return;\r\n        }\r\n        this.cacheCanvasOpts = Object.assign({}, options);\r\n        // check for rotation\r\n        if (options.rotation === 0 || options.rotation === 180) {\r\n            this.canvas.width = options.width;\r\n            this.canvas.height = options.height;\r\n            // canvas 调用 transferControlToOffscreen 方法后无法修改canvas的宽度和高度，只允许修改canvas的style属性\r\n            this.workerCanvas.style.width = options.width + \"px\";\r\n            this.workerCanvas.style.height = options.height + \"px\";\r\n        }\r\n        else if (options.rotation === 90 || options.rotation === 270) {\r\n            this.canvas.height = options.width;\r\n            this.canvas.width = options.height;\r\n            this.workerCanvas.style.height = options.width + \"px\";\r\n            this.workerCanvas.style.width = options.height + \"px\";\r\n        }\r\n        else {\r\n            throw new Error('Invalid value for rotation. Only support 0, 90, 180, 270');\r\n        }\r\n        var transformItems = [];\r\n        transformItems.push(\"rotateZ(\" + options.rotation + \"deg)\");\r\n        var scale = this._calcZoom(options.rotation === 90 || options.rotation === 270, options.contentMode, options.width, options.height, options.clientWidth, options.clientHeight);\r\n        // transformItems.push(`scale(${scale})`)\r\n        this.canvas.style.zoom = scale;\r\n        this.workerCanvas.style.zoom = scale;\r\n        // check for mirror\r\n        if (options.mirrorView) {\r\n            // this.canvas.style.transform = 'rotateY(180deg)';\r\n            transformItems.push('rotateY(180deg)');\r\n        }\r\n        if (transformItems.length > 0) {\r\n            var transform = \"\" + transformItems.join(' ');\r\n            this.canvas.style.transform = transform;\r\n            this.workerCanvas.style.transform = transform;\r\n        }\r\n    };\r\n    Renderer.prototype.drawFrame = function (imageData) {\r\n        if (!this.ready) {\r\n            this.ready = true;\r\n        }\r\n        var dv = new DataView(imageData.header);\r\n        // let format = dv.getUint8(0);\r\n        var mirror = dv.getUint8(1);\r\n        var contentWidth = dv.getUint16(2);\r\n        var contentHeight = dv.getUint16(4);\r\n        var left = dv.getUint16(6);\r\n        var top = dv.getUint16(8);\r\n        var right = dv.getUint16(10);\r\n        var bottom = dv.getUint16(12);\r\n        var rotation = dv.getUint16(14);\r\n        // let ts = dv.getUint32(16);\r\n        var width = contentWidth + left + right;\r\n        var height = contentHeight + top + bottom;\r\n        this.updateCanvas({\r\n            width: width, height: height, rotation: rotation,\r\n            mirrorView: !!mirror,\r\n            contentMode: this.contentMode,\r\n            clientWidth: this.container && this.container.clientWidth,\r\n            clientHeight: this.container && this.container.clientHeight\r\n        });\r\n        if (this._checkRendererWay() === 'software') {\r\n            // 实际渲染canvas\r\n            this._softwareDrawFrame(width, height, imageData.yUint8Array, imageData.uUint8Array, imageData.vUint8Array);\r\n        }\r\n        else {\r\n            this._workDrawFrame(width, height, imageData.yUint8Array, imageData.uUint8Array, imageData.vUint8Array);\r\n        }\r\n    };\r\n    /**\r\n     * 清空整个Canvas面板\r\n     *\r\n     * @memberof Renderer\r\n     */\r\n    Renderer.prototype.clearFrame = function () {\r\n        if (this._checkRendererWay() === 'software') {\r\n            this.yuv && this.yuv.clear();\r\n        }\r\n        else {\r\n            this.worker && this.worker.postMessage({\r\n                type: 'clearFrame'\r\n            });\r\n        }\r\n    };\r\n    Renderer.prototype.setContentMode = function (mode) {\r\n        if (mode === void 0) { mode = 0; }\r\n        this.contentMode = mode;\r\n    };\r\n    return Renderer;\r\n}());\r\n\r\nexports[\"default\"] = Renderer;\r\n```\r\n\r\n渲染Worker的代码如下所示:\r\n\r\n``` js\r\n// render worker\r\n\r\n(function() {\r\n  const dateFormat = function(date, formatter = 'YYYY-MM-DD hh:mm:ss SSS') {\r\n    if (!date) {\r\n      return date;\r\n    }\r\n\r\n    let time;\r\n\r\n    try {\r\n      time = new Date(date);\r\n    } catch (e) {\r\n      return date;\r\n    }\r\n\r\n    const oDate = {\r\n      Y: time.getFullYear(),\r\n      M: time.getMonth() + 1,\r\n      D: time.getDate(),\r\n      h: time.getHours(),\r\n      m: time.getMinutes(),\r\n      s: time.getSeconds(),\r\n      S: time.getMilliseconds()\r\n    };\r\n\r\n    return formatter.replace(/(Y|M|D|h|m|s|S)+/g, (res, key) => {\r\n      let len = 2;\r\n\r\n      switch (res.length) {\r\n        case 1:\r\n          len = res.slice(1, 0) === 'Y' ? 4 : 2;\r\n          break;\r\n        case 2:\r\n          len = 2;\r\n          break;\r\n        case 3:\r\n          len = 3;\r\n          break;\r\n        case 4:\r\n          len = 4;\r\n          break;\r\n        default:\r\n          len = 2;\r\n      }\r\n      return (`0${oDate[key]}`).slice(-len);\r\n    });\r\n  }\r\n\r\n  let yuv;\r\n\r\n  try {\r\n    importScripts('./yuv-buffer/yuv-buffer.js');\r\n    importScripts('./yuv-canvas/shaders.js');\r\n    importScripts('./yuv-canvas/depower.js');\r\n    importScripts('./yuv-canvas/YCbCr.js');\r\n    importScripts('./yuv-canvas/FrameSink.js');\r\n    importScripts('./yuv-canvas/SoftwareFrameSink.js');\r\n    importScripts('./yuv-canvas/WebGLFrameSink.js');\r\n    importScripts('./yuv-canvas/yuv-canvas.js');\r\n\r\n    self.addEventListener('message', function (e) {\r\n      const data = e.data;\r\n      switch (data.type) {\r\n        case 'constructor':\r\n          console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: received canvas: `, data.data.canvas, data.data.id);\r\n          yuv = YUVCanvas.attach(data.data.canvas, { webGL: false });\r\n          break;\r\n        case 'drawFrame':\r\n          // 考虑是否使用requestAnimationFrame进行渲染，控制每一帧显示的频率\r\n          const width = data.data.width;\r\n          const height = data.data.height;\r\n          const yUint8Array = data.data.yUint8Array;\r\n          const uUint8Array = data.data.uUint8Array;\r\n          const vUint8Array = data.data.vUint8Array;\r\n          const format = YUVBuffer.format({\r\n            width: width,\r\n            height: height,\r\n            chromaWidth: width / 2,\r\n            chromaHeight: height / 2\r\n          });\r\n          const y = YUVBuffer.lumaPlane(format, yUint8Array);\r\n          const u = YUVBuffer.chromaPlane(format, uUint8Array);\r\n          const v = YUVBuffer.chromaPlane(format, vUint8Array);\r\n          const frame = YUVBuffer.frame(format, y, u, v);\r\n          yuv && yuv.drawFrame(frame);\r\n          break;\r\n        case 'clearFrame': {\r\n          yuv && yuv.clear(frame);\r\n          break;\r\n        }\r\n        default:\r\n          console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: [RendererWorker]: Unknown message: `, data);\r\n      };\r\n    }, false);\r\n\r\n    self.postMessage({\r\n      type: 'ready',\r\n    });\r\n  } catch (error) {\r\n    self.postMessage({\r\n      type: 'exited',\r\n    });\r\n\r\n    console.log(`${dateFormat(new Date())} RENDER_WORKER [INFO]: [RendererWorker]: catch error`, error);\r\n  }\r\n})();\r\n\r\n```\r\n\r\n### 总结\r\n\r\n如果你对图像绘画使用得非常多，OffscreenCanvas可以有效的提高你APP的性能。它使得Worker可以处理canvas的渲染绘制，让你的APP更好地利用了多核系统。\r\n\r\nOffscreenCanvas在Chrome 69中已经不需要开启flag（实验性功能）就可以使用了。它也正在被 Firefox 实现。由于其API与普通canvas元素非常相似，所以你可以轻松地对其进行特征检测并循序渐进地使用它，而不会破坏现有的APP或库的运行逻辑。OffscreenCanvas在任何涉及到图形计算以及动画表现且与DOM关系并不密切（即依赖DOM API不多）的情况下，它都具有性能优势。\r\n\r\n## 二十一、Vue与React Virtual DOM对比\r\n\r\n### 相同点\r\n\r\n1. vue和react都采用了虚拟dom算法，以最小化更新真实DOM，从而减小不必要的性能损耗。\r\n\r\n2. 按颗粒度分为tree diff, component diff, element diff。 tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component元素， 就会重新tree diff流程。\r\n\r\n### 不同点\r\n\r\n#### dom的更新策略不同\r\n\r\nreact 会自顶向下全diff。\r\n\r\nvue 会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\r\n\r\n1. 在react中，当状态发生改变时，组件树就会自顶向下的全diff, 重新render页面， 重新生成新的虚拟dom tree, 新旧dom tree进行比较， 进行patch打补丁方式，局部跟新dom. 所以react为了避免父组件跟新而引起不必要的子组件更新， 可以在shouldComponentUpdate做逻辑判断，减少没必要的render， 以及重新生成虚拟dom，做差量对比过程。\r\n\r\n2. 在 vue中， 通过Object.defineProperty 把这些 data 属性 全部转为 getter/setter。同时watcher实例对象会在组件渲染时，将属性记录为dep, 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新。\r\n\r\nDiff 算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染。\r\n\r\n### 建议\r\n\r\n1. 基于tree diff\r\n\r\n  - 开发组件时，注意保持DOM结构的稳定；即尽可能少地动态操作DOM结构，尤其是移动操作。\r\n  - 当节点数过大或者页面更新次数过多时，页面卡顿的现象会比较明显。这时可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。\r\n\r\n2. 基于component diff\r\n\r\n  - 注意使用 shouldComponentUpdate() 来减少组件不必要的更新。\r\n  - 对于类似的结构应该尽量封装成组件，既减少代码量，又能减少component diff的性能消耗。\r\n\r\n3. 基于element diff：\r\n\r\n  - 对于列表结构，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响渲染性能。\r\n  - 循环渲染的必须加上key值，唯一标识节点。\r\n\r\n## 二十二、Vue2.0 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？\r\n\r\n在我看来，渐进式代表的含义是：主张最少。\r\n\r\n每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。\r\n\r\n比如说，Angular，它两个版本都是强主张的，如果你用它，必须接受以下东西：\r\n\r\n- 必须使用它的模块机制\r\n- 必须使用它的依赖注入\r\n- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免）\r\n\r\n所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。\r\n\r\n比如React，它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。\r\n\r\n你当然可以只用React的视图层，但几乎没有人这么用，为什么呢，因为你用了它，就会觉得其他东西都很别扭，于是你要引入Flux，Redux，Mobx之中的一个，于是你除了Redux，还要看saga，于是你要纠结业务开发过程中每个东西有没有副作用，纯不纯，甚至你连这个都可能不能忍：\r\n\r\n``` js\r\nconst getData = () => {\r\n  // 如果不存在，就在缓存中创建一个并返回\r\n  // 如果存在，就从缓存中拿\r\n}\r\n```\r\n\r\n因为你要纠结它有外部依赖，同样是不加参数调用，连续两次的结果是不一样的，于是不纯。\r\n\r\n为什么我一直不认同在中后台项目中使用React，原因就在这里，我反对的是整个业务应用的函数式倾向，很多人都是看到有很多好用的React组件，就会倾向于把它引入，然后，你知道怎么把自己的业务映射到函数式的那套理念上吗？\r\n\r\n函数式编程，无副作用，写出来的代码没有bug，这是真理没错，但是有两个问题需要考虑：\r\n\r\n1. JS本身，有太多特性与纯函数式的主张不适配，这一点，题叶能说得更多\r\n2. 业务系统里面的实体关系，如何组织业务逻辑，几十年来积累了无数的基于设计模式的场景经验，有太多的东西可以模仿，但是，没有人给你总结那么多如何把你的厚重业务映射到函数式理念的经验，这个地方很考验综合水平的，真的每个人都有能力去做这种映射吗？\r\n\r\n函数式编程无bug的根本就在于要把业务逻辑完全都依照这套理念搞好，你看看自己公司做中后台的员工，他们熟悉的是什么？是基于传统OO设计模式的这套东西，他们以为拿着你们给的组件库就得到了一切，但是可能还要被灌输函数式编程的一整套东西，而且又没人告诉他们在业务场景下，如何规划业务模型、组织代码，还要求快速开发，怎么能快起来？\r\n\r\n所以我真是心疼这些人，他们要的只是组件库，却不得不把业务逻辑的思考方式也作转换，这个事情没有一两年时间洗脑，根本洗不到能开发业务的程度。\r\n\r\n没有好组件库的时候，大家痛点在视图层，有了基于React的组件化，把原先没那么痛的业务逻辑部分搞得也痛起来了，原先大家按照设计模式教的东西，照猫画虎还能继续开发了，学了一套新理念之后，都不知道怎么写代码了，怎么写都怀疑自己不对，可怕。\r\n\r\n我宁可支持Angular也不支持React的原因也就在此，Angular至少在业务逻辑这块没有软主张，能够跟OO设计模式那套东西配合得很好。我面对过很多商务场景，都是前端很厚重的东西，不仅仅是管理控制台这种，这类东西里面，业务逻辑的占比要比视图大挺多的，如何组织这些东西，目前几个主流技术栈都没有解决方案，要靠业务架构师去摆平。\r\n\r\n如果你的场景不是这么厚重的，只是简单管理控制台，那当我没说好了。\r\n\r\n框架是不能解决业务问题的，只能作为工具，放在合适的人手里，合适的场景下。\r\n\r\n现在我要说说为什么我这么支持Vue了，没什么，可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。\r\n\r\n渐进式的含义，我的理解是：没有多做职责之外的事。\r\n\r\n","reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/54/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"MyPrototypeWhat","id":43230886,"node_id":"MDQ6VXNlcjQzMjMwODg2","avatar_url":"https://avatars.githubusercontent.com/u/43230886?v=4","gravatar_id":"","url":"https://api.github.com/users/MyPrototypeWhat","html_url":"https://github.com/MyPrototypeWhat","followers_url":"https://api.github.com/users/MyPrototypeWhat/followers","following_url":"https://api.github.com/users/MyPrototypeWhat/following{/other_user}","gists_url":"https://api.github.com/users/MyPrototypeWhat/gists{/gist_id}","starred_url":"https://api.github.com/users/MyPrototypeWhat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/MyPrototypeWhat/subscriptions","organizations_url":"https://api.github.com/users/MyPrototypeWhat/orgs","repos_url":"https://api.github.com/users/MyPrototypeWhat/repos","events_url":"https://api.github.com/users/MyPrototypeWhat/events{/privacy}","received_events_url":"https://api.github.com/users/MyPrototypeWhat/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2022-11-03T09:01:48Z","updated_at":"2022-11-03T09:01:48Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23","repository_url":"https://api.github.com/repos/MyPrototypeWhat/take-down","labels_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23/labels{/name}","comments_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23/comments","events_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23/events","html_url":"https://github.com/MyPrototypeWhat/take-down/issues/23","id":1184263365,"node_id":"I_kwDODMMobM5GlmzF","number":23,"title":"React-Scheduler","user":{"login":"MyPrototypeWhat","id":43230886,"node_id":"MDQ6VXNlcjQzMjMwODg2","avatar_url":"https://avatars.githubusercontent.com/u/43230886?v=4","gravatar_id":"","url":"https://api.github.com/users/MyPrototypeWhat","html_url":"https://github.com/MyPrototypeWhat","followers_url":"https://api.github.com/users/MyPrototypeWhat/followers","following_url":"https://api.github.com/users/MyPrototypeWhat/following{/other_user}","gists_url":"https://api.github.com/users/MyPrototypeWhat/gists{/gist_id}","starred_url":"https://api.github.com/users/MyPrototypeWhat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/MyPrototypeWhat/subscriptions","organizations_url":"https://api.github.com/users/MyPrototypeWhat/orgs","repos_url":"https://api.github.com/users/MyPrototypeWhat/repos","events_url":"https://api.github.com/users/MyPrototypeWhat/events{/privacy}","received_events_url":"https://api.github.com/users/MyPrototypeWhat/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2022-03-29T03:54:47Z","updated_at":"2024-05-29T10:23:54Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":214116460,"node_id":"MDEwOlJlcG9zaXRvcnkyMTQxMTY0NjA=","name":"take-down","full_name":"MyPrototypeWhat/take-down","private":false,"owner":{"login":"MyPrototypeWhat","id":43230886,"node_id":"MDQ6VXNlcjQzMjMwODg2","avatar_url":"https://avatars.githubusercontent.com/u/43230886?v=4","gravatar_id":"","url":"https://api.github.com/users/MyPrototypeWhat","html_url":"https://github.com/MyPrototypeWhat","followers_url":"https://api.github.com/users/MyPrototypeWhat/followers","following_url":"https://api.github.com/users/MyPrototypeWhat/following{/other_user}","gists_url":"https://api.github.com/users/MyPrototypeWhat/gists{/gist_id}","starred_url":"https://api.github.com/users/MyPrototypeWhat/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/MyPrototypeWhat/subscriptions","organizations_url":"https://api.github.com/users/MyPrototypeWhat/orgs","repos_url":"https://api.github.com/users/MyPrototypeWhat/repos","events_url":"https://api.github.com/users/MyPrototypeWhat/events{/privacy}","received_events_url":"https://api.github.com/users/MyPrototypeWhat/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/MyPrototypeWhat/take-down","description":"记一些平时的笔记 有笔记 有源码解析","fork":false,"url":"https://api.github.com/repos/MyPrototypeWhat/take-down","forks_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/forks","keys_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/keys{/key_id}","collaborators_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/teams","hooks_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/hooks","issue_events_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/events{/number}","events_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/events","assignees_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/assignees{/user}","branches_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/branches{/branch}","tags_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/tags","blobs_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/git/refs{/sha}","trees_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/git/trees{/sha}","statuses_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/statuses/{sha}","languages_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/languages","stargazers_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/stargazers","contributors_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/contributors","subscribers_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/subscribers","subscription_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/subscription","commits_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/commits{/sha}","git_commits_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/git/commits{/sha}","comments_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/comments{/number}","issue_comment_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/comments{/number}","contents_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/contents/{+path}","compare_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/compare/{base}...{head}","merges_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/merges","archive_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/downloads","issues_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues{/number}","pulls_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/pulls{/number}","milestones_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/milestones{/number}","notifications_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/labels{/name}","releases_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/releases{/id}","deployments_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/deployments","created_at":"2019-10-10T07:31:14Z","updated_at":"2024-05-24T08:31:08Z","pushed_at":"2024-05-24T08:31:05Z","git_url":"git://github.com/MyPrototypeWhat/take-down.git","ssh_url":"git@github.com:MyPrototypeWhat/take-down.git","clone_url":"https://github.com/MyPrototypeWhat/take-down.git","svn_url":"https://github.com/MyPrototypeWhat/take-down","homepage":"","size":445,"stargazers_count":9,"watchers_count":9,"language":null,"has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":false,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":22,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":["corejs","javascript","react","react-router-v6","tc39","vue-reactive","webpack"],"visibility":"public","forks":0,"open_issues":22,"watchers":9,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"<!-- [toc] -->\r\n\r\n- [React-Scheduler](#react-scheduler)\r\n  - [前言](#前言)\r\n  - [选择](#选择)\r\n  - [预备知识点](#预备知识点)\r\n    - [全局变量](#全局变量)\r\n    - [局部变量](#局部变量)\r\n  - [函数](#函数)\r\n    - [unstable\\_scheduleCallback](#unstable_schedulecallback)\r\n    - [requestHostTimeout](#requesthosttimeout)\r\n    - [handleTimeout](#handletimeout)\r\n    - [advanceTimers](#advancetimers)\r\n    - [requestHostCallback](#requesthostcallback)\r\n    - [schedulePerformWorkUntilDeadline](#scheduleperformworkuntildeadline)\r\n    - [performWorkUntilDeadline](#performworkuntildeadline)\r\n    - [flushWork](#flushwork)\r\n    - [workLoop](#workloop)\r\n  - [总结](#总结)\r\n\r\n# React-Scheduler\r\n\r\n> version@0.20.1\r\n\r\n## 前言\r\n\r\n`Scheduler`顾名思义就是一个调度器，负责`React`中**任务的调度**。众所周知 JS 是单线程，通过`task`和`micro task`来调度任务的执行。\r\n\r\n核心概念分为三个：**时间切片**、**任务切片**和**优先级调度**\r\n\r\n- 时间切片：将时间按帧切分**(默认 5ms)**执行任务，以达到不阻塞浏览器渲染。当页面有某处更新或者交互的时候，用户无感知阻塞或卡顿。\r\n- 任务切片：如果一个任务过长，在一帧内无法完成，将中断任务，在下一帧重新调用。\r\n- 优先级调度：通过不同优先级来决定某些任务优先调度。\r\n  - 为了尽快的找到最高优先级的任务，使用了`小顶堆`的数据结构（不过多介绍）\r\n\r\n## 选择\r\n\r\n熟悉 JS 的同学肯定知道跟浏览器渲染帧相关的两个`API`：`requestIdleCallback（浏览器空闲时调用，下文简称rIC）`和`requestAnimationFrame（每一帧绘制之前调用，下文简称rAF）`，两个 api 看似可以达到不占用主线程，优先浏览器渲染，不阻塞的效果，但是真的适用吗？很显然，都有缺陷。\r\n\r\n- `rIC`\r\n\r\n  1. 兼容性太差，`Safari`直接**不兼容**...\r\n\r\n     [can i use requestIdleCallback](https://caniuse.com/?search=requestIdleCallback)\r\n\r\n  2. **执行时间不一定：**浏览器空闲时执行间隔为**50ms**，也就是 20FPS，一秒执行 20 次，这显然间隔太长了。\r\n\r\n     - 例如：持续滚动页面，这时执行的间隔时间就会非常不稳定\r\n\r\n     - 还有一点，**当页面至于后台时，干脆不执行了**...\r\n\r\n- `rAF`\r\n\r\n  1. 执行顺序不一定，`rAF`是官方推荐用于做流畅动画的`api`，所以它的回调执行在页面**渲染更新前**。执行顺序可能在**宏任务**（`task`）**前或者后**（涉及到`EventLoop`，篇幅问题不过多介绍）。`rAF`在各个平台的浏览器表现不一。\r\n  2. `React`可能执行两次更新\r\n\r\n综上所述，React 团队打算自己实现一个策略，用于时间分片。最终使用`MessageChannel`实现\r\n\r\n- 执行顺序，`microTask > messageChannel > setTimeout`，`messageChannel`为`dom event`，所以优先级要大于`setTimeout`\r\n- 为什么用`task`而不用`microTask`？不用`microTask`的原因是，`microTask`将在页面更新前全部执行完，达不到将主线程还给浏览器的目的。\r\n\r\n  - 根据事件循环规则来看每次执行一个`task`就会执行所有`microTask`，并且在这个过程中新增的`microTask`都会一并执行，所以`React`的渲染如果在`microTask`中，无法中断，\r\n    - 因为`React`在中断渲染之后会检查是否还有任务，如果有就再次调度一个`performConcurrentWorkOnRoot`，根据事件循环来看这时再有`microTask`会立即执行，所以每次都会执行完全部任务，无法达到一个`tick`执行一个`task`的目的\r\n\r\n- 为什么不使用`setTimeout`？因为`setTimeout(_,0)`即使设置为`0`，还会有**`4ms`的问题**。在`MessageChannel`无法使用的时候，降级使用`setTimeout`\r\n- 为什么不使用`postMessage`？因为`postMessage`会因为持续的滚动等操作被阻塞住。浏览器会为了保证用户交互的响应，**将四分之三的优先权给了鼠标键盘事件**，其余的时间会交给其他的`task`，所以就导致了持续的滚动阻塞了`postMessage`，`Vue 2.0.0-rc.7`有个[issue](https://github.com/vuejs/vue/issues/3771)就是描述这个问题的。\r\n\r\n## 预备知识点\r\n\r\n`Scheduler`被单独拆成一个包，放在`React`项目中，目录为[react](https://github.com/facebook/react)/[packages](https://github.com/facebook/react/tree/main/packages)/[scheduler](https://github.com/facebook/react/tree/main/packages/scheduler)/[src](https://github.com/facebook/react/tree/main/packages/scheduler/src)/[forks](https://github.com/facebook/react/tree/main/packages/scheduler/src/forks)/Scheduler.js\r\n\r\n### 全局变量\r\n\r\n- 根据优先级对应不同`timeout`\r\n\r\n  ```js\r\n  var maxSigned31BitInt = 1073741823;\r\n  // Times out immediately\r\n  var IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n  // Eventually times out\r\n  var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\r\n  var NORMAL_PRIORITY_TIMEOUT = 5000;\r\n  var LOW_PRIORITY_TIMEOUT = 10000;\r\n  // Never times out\r\n  var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\r\n  ```\r\n\r\n- 全局函数\r\n\r\n  ```js\r\n  // 获取currentTime(当前时间)\r\n  let getCurrentTime = () => performance.now();\r\n  // 延时器\r\n  const localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\r\n  // 清除延时器\r\n  const localClearTimeout =\r\n    typeof clearTimeout === \"function\" ? clearTimeout : null;\r\n  // 环境支持的话\r\n  const isInputPending = navigator.scheduling.isInputPending.bind(\r\n    navigator.scheduling\r\n  );\r\n  ```\r\n\r\n- 任务相关变量\r\n\r\n  ```js\r\n  var taskQueue = [];\r\n  var timerQueue = [];\r\n  // 当前任务\r\n  var currentTask = null;\r\n  // 当前任务优先级\r\n  var currentPriorityLevel = NormalPriority;\r\n  // flushWork中设置为true，表示当前任务正在执行，防止再次进入\r\n  var isPerformingWork = false;\r\n  // 表示任务是否被调度,调用requestHostCallback函数前设置为false（触发postMessage之前），在flushWork中设置为false\r\n  var isHostCallbackScheduled = false;\r\n  // 表示是否有延时器正在执行,延时器执行完毕之后设置为false\r\n  var isHostTimeoutScheduled = false;\r\n  ...\r\n  // 代表当前postMessage触发的回调正在执行\r\n  let isMessageLoopRunning = false;\r\n  // scheduledHostCallback = flushWork\r\n  let scheduledHostCallback = null;\r\n  // 延时器id\r\n  let taskTimeoutID = -1;\r\n  ```\r\n\r\n- 简单来说，任务分为两个堆——`taskQueue`和`timerQueue`，两个变量都是`js数组形式`的`小顶堆`，`taskQueue`根据`expirationTime`（过期时间）由小到大排序，`timerQueue`根据`startTime`（开始时间）**由大到小排序**\r\n- `taskQueue`和`timerQueue`分别表示任务需要立刻执行和延迟执行，通过(`startTime`>`currentTime`)来判断任务是添加进`taskQueue`中还是`timerQueue`\r\n\r\n### 局部变量\r\n\r\n任务对象的属性\r\n\r\n```js\r\nvar newTask = {\r\n  // 自增的id，用来判断插入顺序，当sortIndex相同时，通过id判断优先级执行顺序\r\n  id: taskIdCounter++,\r\n  // performSyncWorkOnroot等，react render阶段的入口函数\r\n  callback,\r\n  // 优先级\r\n  priorityLevel,\r\n  // 开始时间 startTime=currentTime+delay(如果有的话)\r\n  startTime,\r\n  // 过期时间(startTime+timeout) timeout为不同优先级预设的时间\r\n  expirationTime,\r\n  // 堆排序的主要依据,timerQueue中为startTime，taskQueue中为expirationTime\r\n  sortIndex: -1,\r\n};\r\n```\r\n\r\n- 预备知识点完成，下面是函数部分\r\n\r\n## 函数\r\n\r\n### unstable_scheduleCallback\r\n\r\n- 入口函数，分成四个部分\r\n\r\n  - 第一部分，计算`startTime`，如果有`delay`就加上\r\n  - 第二部分，根据传入的优先级，计算对应优先级的`timeout`\r\n  - 第三部分，计算`expirationTime`，创建任务对象（`newTask`）\r\n  - 第四部分，根据`startTime > currentTime`来判断是`push`进`timerQueue`中还是`taskQueue`\r\n\r\n```js\r\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\r\n  // 第一部分\r\n  var currentTime = getCurrentTime();\r\n\r\n  var startTime;\r\n  if (typeof options === \"object\" && options !== null) {\r\n    var delay = options.delay;\r\n    if (typeof delay === \"number\" && delay > 0) {\r\n      startTime = currentTime + delay;\r\n    } else {\r\n      startTime = currentTime;\r\n    }\r\n  } else {\r\n    startTime = currentTime;\r\n  }\r\n  // 第二部分\r\n  var timeout;\r\n  switch (priorityLevel) {\r\n    case ImmediatePriority:\r\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case UserBlockingPriority:\r\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\r\n      break;\r\n    case IdlePriority:\r\n      timeout = IDLE_PRIORITY_TIMEOUT;\r\n      break;\r\n    case LowPriority:\r\n      timeout = LOW_PRIORITY_TIMEOUT;\r\n      break;\r\n    case NormalPriority:\r\n    default:\r\n      timeout = NORMAL_PRIORITY_TIMEOUT;\r\n      break;\r\n  }\r\n  // 第三部分\r\n  var expirationTime = startTime + timeout;\r\n\r\n  var newTask = {\r\n    id: taskIdCounter++,\r\n    callback,\r\n    priorityLevel,\r\n    startTime,\r\n    expirationTime,\r\n    sortIndex: -1,\r\n  };\r\n  if (enableProfiling) {\r\n    newTask.isQueued = false;\r\n  }\r\n  // 第四部分\r\n  if (startTime > currentTime) {\r\n    // 延迟任务.\r\n    newTask.sortIndex = startTime;\r\n    // push时会根据startTime进行排序\r\n    push(timerQueue, newTask);\r\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\r\n      // taskQueue中没有任务，并且timerQueue中有任务，拿到优先级最高的任务(当前任务)(startTime最小)\r\n      if (isHostTimeoutScheduled) {\r\n        // 如果当前有上一个被通过setTimeout延迟执行的任务就取消掉\r\n        cancelHostTimeout();\r\n      } else {\r\n        // 如果没有，就设置为true，代表当前有被调度的任务\r\n        isHostTimeoutScheduled = true;\r\n      }\r\n      // 将延迟任务通过setTimeout变为立即执行任务\r\n      requestHostTimeout(handleTimeout, startTime - currentTime);\r\n    }\r\n  } else {\r\n    newTask.sortIndex = expirationTime;\r\n    push(taskQueue, newTask);\r\n    // 如果当前没有正在调度的任务，并且没有正在执行的任务\r\n    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n      isHostCallbackScheduled = true;\r\n      // 立即执行\r\n      requestHostCallback(flushWork);\r\n    }\r\n  }\r\n\r\n  return newTask;\r\n}\r\n```\r\n\r\n### requestHostTimeout\r\n\r\n这部分代码很简单，就是一个延时器\r\n\r\n```js\r\nfunction requestHostTimeout(callback, ms) {\r\n  // callback = handleTimeout\r\n  taskTimeoutID = localSetTimeout(() => {\r\n    callback(getCurrentTime());\r\n  }, ms);\r\n}\r\n```\r\n\r\n### handleTimeout\r\n\r\n判断当前是否有被调度的任务，如果有就取出`timeQueue`第一位，继续等待执行，如果没有就直接调度该任务\r\n\r\n```js\r\nfunction handleTimeout(currentTime) {\r\n  // 当前延时器回调执行了，isHostTimeoutScheduled为false代表释放当前延时器，下一个延时任务可以被调度\r\n  isHostTimeoutScheduled = false;\r\n  // 将timerQueue中已经过期了的任务插入到taskQueue中\r\n  advanceTimers(currentTime);\r\n  // 判断当前是否有被调度的任务\r\n  if (!isHostCallbackScheduled) {\r\n    // 没有并且taskQueue中有任务\r\n    if (peek(taskQueue) !== null) {\r\n      // 开始调度taskQueue中的任务\r\n      isHostCallbackScheduled = true;\r\n      requestHostCallback(flushWork);\r\n    } else {\r\n      // 有则取出继续等待调度\r\n      const firstTimer = peek(timerQueue);\r\n      if (firstTimer !== null) {\r\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### advanceTimers\r\n\r\n将`timerQueue`中已经过期了的任务插入到`taskQueue`中\r\n\r\n```js\r\nfunction advanceTimers(currentTime) {\r\n  // 检查不再延迟的任务，并将其添加到队列中。\r\n  let timer = peek(timerQueue);\r\n  // 遍历timerQueue\r\n  while (timer !== null) {\r\n    if (timer.callback === null) {\r\n      // 任务被取消，出堆\r\n      pop(timerQueue);\r\n    } else if (timer.startTime <= currentTime) {\r\n      // 计时器响了。转移到任务队列。\r\n      pop(timerQueue);\r\n      // 因为要插进taskQueue，所以要重新计算sortIndex\r\n      timer.sortIndex = timer.expirationTime;\r\n      push(taskQueue, timer);\r\n    } else {\r\n      // 后面的任务的时间有剩余\r\n      return;\r\n    }\r\n    timer = peek(timerQueue);\r\n  }\r\n}\r\n```\r\n\r\n以上是调度`timerQueue`的过程，其中执行的函数和调度`taskQueue`中函数有重复，放在下面讲解\r\n\r\n---\r\n\r\n### requestHostCallback\r\n\r\n入参为`flushWork`，将`flushwork`赋值给全局变量，并且触发消息通知\r\n\r\n```js\r\nfunction requestHostCallback(callback) {\r\n  // callback = flushWork\r\n  scheduledHostCallback = callback;\r\n  if (!isMessageLoopRunning) {\r\n    isMessageLoopRunning = true;\r\n    // 执行postMessage\r\n    schedulePerformWorkUntilDeadline();\r\n  }\r\n}\r\n```\r\n\r\n### schedulePerformWorkUntilDeadline\r\n\r\n对于设备环境做了兼容\r\n\r\n```js\r\nlet schedulePerformWorkUntilDeadline;\r\nif (typeof localSetImmediate === \"function\") {\r\n  // Node.js 和 old IE.\r\n  schedulePerformWorkUntilDeadline = () => {\r\n    localSetImmediate(performWorkUntilDeadline);\r\n  };\r\n} else if (typeof MessageChannel !== \"undefined\") {\r\n  // DOM and Worker environments.\r\n  // 由于setTimeout的4ms延迟，所以使用MessageChannel\r\n  const channel = new MessageChannel();\r\n  const port = channel.port2;\r\n  channel.port1.onmessage = performWorkUntilDeadline;\r\n  schedulePerformWorkUntilDeadline = () => {\r\n    port.postMessage(null);\r\n  };\r\n} else {\r\n  // 非浏览器环境使用setTimeout\r\n  schedulePerformWorkUntilDeadline = () => {\r\n    localSetTimeout(performWorkUntilDeadline, 0);\r\n  };\r\n}\r\n```\r\n\r\n- 已`MessageChannel`为例，执行`schedulePerformWorkUntilDeadline`会触发`performWorkUntilDeadline`执行，**但是会放在下一轮事件循环中执行**\r\n\r\n### performWorkUntilDeadline\r\n\r\n作为`postMessage`触发的回调，主要负责执行全局变量`scheduledHostCallback`，通过返回值判定是否触发下一轮`postMessage`\r\n\r\n```js\r\nconst performWorkUntilDeadline = () => {\r\n  // scheduledHostCallback 在 requestHostCallback 中被赋值为 flushWork\r\n  if (scheduledHostCallback !== null) {\r\n    const currentTime = getCurrentTime();\r\n    // 获取函数真正执行的当前时间，提供给后续时间片判断(shouldYieldToHost函数)\r\n    startTime = currentTime;\r\n    const hasTimeRemaining = true;\r\n    // 故意不使用try-catch，因为这会使一些调试技术变得更加困难。\r\n    // 相反，如果'scheduledHostCallback'出现错误，\r\n    // 那么'hasMoreWork'将保持为true，我们将继续工作循环。\r\n    let hasMoreWork = true;\r\n    try {\r\n      // scheduledHostCallback = flushWork\r\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n    } finally {\r\n      if (hasMoreWork) {\r\n        // 代表当前任务没结束（返回一个函数、报错、）\r\n        schedulePerformWorkUntilDeadline();\r\n      } else {\r\n        // 重置全局变量\r\n        isMessageLoopRunning = false;\r\n        scheduledHostCallback = null;\r\n      }\r\n    }\r\n  } else {\r\n    isMessageLoopRunning = false;\r\n  }\r\n};\r\n```\r\n\r\n### flushWork\r\n\r\n**核心**，负责执行 workLoop 并且返回执行结果，在执行结束后重置全局变量\r\n\r\n```js\r\nfunction flushWork(hasTimeRemaining, initialTime) {\r\n  // 设为false，为了能够执行requestHostCallback，调度下次任务\r\n  isHostCallbackScheduled = false;\r\n  if (isHostTimeoutScheduled) {\r\n    // 如果当前有延时器就取消掉,当前任务优先级更高\r\n    // 因为接下来执行callback前后会再次执行advanceTimers，并且执行callback也是会有时间损耗的\r\n    isHostTimeoutScheduled = false;\r\n    cancelHostTimeout();\r\n  }\r\n  // 任务开始执行\r\n  isPerformingWork = true;\r\n  const previousPriorityLevel = currentPriorityLevel;\r\n  try {\r\n    // 直接看这里，返回值为外部函数作用域的hasMoreWork变量\r\n    return workLoop(hasTimeRemaining, initialTime);\r\n  } finally {\r\n    // 任务执行完成之后重置全局变量\r\n    currentTask = null;\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    isPerformingWork = false;\r\n  }\r\n}\r\n```\r\n\r\n### workLoop\r\n\r\n**核心**，任务循环，真正执行`callback`的地方。在执行`callback`前后都会执行`advanceTimers`，确保`taskQueue`中任务的优先级\r\n\r\n```js\r\nfunction workLoop(hasTimeRemaining, initialTime) {\r\n  // initialTime为 postMessage触发回调当时的时间\r\n  // hasTimeRemaining 始终为true\r\n  let currentTime = initialTime;\r\n  // 检测是否有过期的任务，放在taskQueue队列中\r\n  advanceTimers(currentTime);\r\n  currentTask = peek(taskQueue);\r\n  while (currentTask !== null) {\r\n    if (\r\n      currentTask.expirationTime > currentTime &&\r\n      (!hasTimeRemaining || shouldYieldToHost())\r\n    ) {\r\n      // 此判断代表任务还未过期，但是没时间了(5ms已过)，终止循环\r\n      // shouldYieldToHost 判断为\r\n      // if(getCurrentTime() - startTime < frameInterval(默认5ms)) return false ，执行到现在还没到5ms，不需要暂停\r\n\r\n      // shouldYieldToHost 还有对isInputPending情况的判断，兼容性不高不做考虑\r\n      // navigator.scheduling.isInputPending为react团队和chrome团队协商出的api，主要用于判断当前是否有input等事件正在执行，有兴趣可以了解下\r\n      break;\r\n    }\r\n    const callback = currentTask.callback;\r\n    if (typeof callback === \"function\") {\r\n      currentTask.callback = null;\r\n      currentPriorityLevel = currentTask.priorityLevel;\r\n      // 当前任务是否超时\r\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\r\n      // 拿到返回\r\n      // 任务切片\r\n      const continuationCallback = callback(didUserCallbackTimeout);\r\n      currentTime = getCurrentTime();\r\n      if (typeof continuationCallback === \"function\") {\r\n        // 如果是个函数，更新callback,作为下一轮事件循环使用\r\n        currentTask.callback = continuationCallback;\r\n      } else {\r\n        // 判断当前任务是否是最高优先级任务，是则pop\r\n        if (currentTask === peek(taskQueue)) {\r\n          pop(taskQueue);\r\n        }\r\n      }\r\n      // 检测是否有过期的任务，放在taskQueue队列中\r\n      advanceTimers(currentTime);\r\n    } else {\r\n      // 任务被取消，出堆\r\n      pop(taskQueue);\r\n    }\r\n    // 更新currentTask继续循环\r\n    currentTask = peek(taskQueue);\r\n  }\r\n  if (currentTask !== null) {\r\n    // 走到这个判断会有两种情况\r\n    // callback返回一个函数 或者 达到当前deadline(默认5ms的限制)\r\n    return true;\r\n  } else {\r\n    const firstTimer = peek(timerQueue);\r\n    if (firstTimer !== null) {\r\n      // taskQueue中已经没有可执行的任务了，取出timerQueue中的任务，进行调度\r\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\n## 总结\r\n\r\n总结下大致流程：通过将任务划分成`立即执行`和`延迟执行`两个堆，立即执行的堆中任务会通过`MessageChannel`触发，延迟执行的堆会通过`setTimeout`将任务延迟到对应事件后添加进`taskQueue`中触发。\r\n\r\n每次 workLoop 都会从`taskQueue`中取出任务，执行任务，如果任务执行完之后还有剩余时间，则继续执行，直到没有剩余时间或者任务队列为空。如果 `5ms` 到了，但是还有任务，则通过 `postMessage` 开启下一轮 `workLoop。`达到让出主线程的能力\r\n","reactions":{"url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/MyPrototypeWhat/take-down/issues/23/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"},{"actor":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2024-02-08T07:51:31Z","updated_at":"2024-02-08T07:51:31Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103","repository_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103/comments","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103/events","html_url":"https://github.com/hankliu62/hankliu62.github.com/issues/103","id":2124556566,"node_id":"I_kwDOBiJZIc5-oikW","number":103,"title":"深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":6536118829,"node_id":"LA_kwDOBiJZIc8AAAABhZVCLQ","url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels/javascript","name":"javascript","color":"383040","default":false,"description":"分类-Javascript相关"}],"state":"closed","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-08T07:51:31Z","updated_at":"2024-02-13T01:00:21Z","closed_at":"2024-02-13T01:00:21Z","author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":102914337,"node_id":"MDEwOlJlcG9zaXRvcnkxMDI5MTQzMzc=","name":"hankliu62.github.com","full_name":"hankliu62/hankliu62.github.com","private":false,"owner":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/hankliu62/hankliu62.github.com","description":"🥭 hankliu's blog ","fork":false,"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com","forks_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/forks","keys_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/keys{/key_id}","collaborators_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/teams","hooks_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/hooks","issue_events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/events{/number}","events_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/events","assignees_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/assignees{/user}","branches_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/branches{/branch}","tags_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/tags","blobs_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/refs{/sha}","trees_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/trees{/sha}","statuses_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/statuses/{sha}","languages_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/languages","stargazers_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/stargazers","contributors_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/contributors","subscribers_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/subscribers","subscription_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/subscription","commits_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/commits{/sha}","git_commits_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/git/commits{/sha}","comments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/comments{/number}","issue_comment_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/comments{/number}","contents_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/contents/{+path}","compare_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/compare/{base}...{head}","merges_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/merges","archive_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/downloads","issues_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues{/number}","pulls_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/pulls{/number}","milestones_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/milestones{/number}","notifications_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/labels{/name}","releases_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/releases{/id}","deployments_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/deployments","created_at":"2017-09-09T00:13:03Z","updated_at":"2025-01-01T01:45:55Z","pushed_at":"2025-01-01T01:46:42Z","git_url":"git://github.com/hankliu62/hankliu62.github.com.git","ssh_url":"git@github.com:hankliu62/hankliu62.github.com.git","clone_url":"https://github.com/hankliu62/hankliu62.github.com.git","svn_url":"https://github.com/hankliu62/hankliu62.github.com","homepage":"http://hankliu62.github.io","size":5802,"stargazers_count":8,"watchers_count":8,"language":"JavaScript","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":true,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":132,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":0,"open_issues":132,"watchers":8,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"### 前言\r\n\r\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\r\n\r\n1. 每一轮 Event Loop 都会伴随着渲染吗？\r\n2. requestAnimationFrame 在哪个阶段执行，在渲染前还是后？在 microTask 的前还是后？\r\n3. requestIdleCallback 在哪个阶段执行？如何去执行？在渲染前还是后？在 microTask 的前还是后？\r\n4. resize、scroll 这些事件是何时去派发的。\r\n\r\n这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 requestAnimationFrame，你可能在做一些需求的时候想到了 requestIdleCallback，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。\r\n\r\n这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。\r\n\r\n### 事件循环\r\n\r\n我们先依据HTML 官方规范从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。\r\n\r\n#### 定义\r\n\r\n为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环。\r\n\r\n#### 流程\r\n\r\n1. 从任务队列中取出一个宏任务并执行。\r\n\r\n2. 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。\r\n\r\n3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）\r\n\r\n  - 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。\r\n  - 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。\r\n  - 如果满足以下条件，也会跳过渲染：\r\n\r\n    1. 浏览器判断更新渲染不会带来视觉上的改变。\r\n    2. map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。\r\n\r\n4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：\r\n  This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask的执行，而不会穿插屏幕渲染相关的流程（比如requestAnimationFrame，下面会写一个例子）。\r\n\r\n5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 `resize` 方法。\r\n\r\n6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 方法。\r\n\r\n7. 对于需要渲染的文档，执行帧动画回调，也就是 `requestAnimationFrame` 的回调。（后文会详解）\r\n\r\n8. 对于需要渲染的文档，执行 `IntersectionObserver` 的回调。\r\n\r\n9. 对于需要渲染的文档，**重新渲染**绘制用户界面。\r\n\r\n10. 判断 `task队列`和`microTask队列`是否都为空，如果是的话，则进行 `Idle` 空闲周期的算法，判断是否要执行 `requestIdleCallback` 的回调函数。（后文会详解）\r\n\r\n对于 `resize` 和 `scroll` 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据CSSOM 规范所讲，浏览器会保存一个 `pending scroll event targets`，等到事件循环中的 `scroll` 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize` 也是同理。\r\n可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。\r\n多任务队列\r\n\r\n#### 多任务队列\r\n\r\ntask 队列并不是我们想象中的那样只有一个，根据规范里的描述：\r\n\r\nAn event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.\r\n\r\n事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：\r\n\r\n1. 鼠标和键盘事件\r\n2. 其他的一些 Task\r\n\r\n览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。\r\n\r\n这个规范也导致 Vue 2.0.0-rc.7 这个版本 `nextTick` 采用了从微任务 `MutationObserver` 更换成宏任务 `postMessage` 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)。\r\n目前由于一些“未知”的原因，`jsfiddle` 的案例打不开了。简单描述一下就是采用了 `task` 实现的 `nextTick`，在用户持续滚动的情况下 `nextTick` 任务被延后了很久才去执行，导致动画跟不上滚动了。\r\n\r\n迫于无奈，尤大还是改回了 `microTask` 去实现 `nextTick`，当然目前来说 `promise.then` 微任务已经比较稳定了，并且 Chrome 也已经实现了 `queueMicroTask` 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 `Promise` 在开销了。\r\n\r\n从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。\r\n\r\n#### requestAnimationFrame\r\n\r\n在解读规范的过程中，我们发现 `requestAnimationFrame` 的回调有两个特征：\r\n\r\n1. 在重新渲染前调用。\r\n2. 很可能在宏任务之后不调用。\r\n\r\n我们来分析一下，为什么要在重新渲染前去调用？因为 `rAF` 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。\r\n\r\n`rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。\r\n\r\n##### 闪烁动画\r\n\r\n假设我们现在想要快速的让屏幕上闪烁 红、蓝两种颜色，保证用户可以观察到，如果我们用 `setTimeout` 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  document.body.style.background = \"red\";\r\n  setTimeout(() => {\r\n    document.body.style.background = \"blue\";\r\n  });\r\n});\r\n```\r\n\r\n![setTimeout闪烁动画](https://user-images.githubusercontent.com/8088864/125749050-c757f81e-6482-4262-a0d4-c455eb78d4f4.gif)\r\n\r\n以看出这个结果是非常不可控的，如果这两个 `Task` 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。\r\n\r\n如果你把延时调整到 17ms 那么重绘的概率会大很多，毕竟这个是一般情况下 60fps 的一个指标。但是也会出现很多不绘制的情况，所以并不稳定。\r\n如果你依赖这个 API 来做动画，那么就很可能会造成「掉帧」。\r\n\r\n接下来我们换成 rAF 试试？我们用一个递归函数来模拟 10 次颜色变化的动画。\r\n\r\n``` js\r\nlet i = 10;\r\nlet req = () => {\r\n  i--;\r\n  requestAnimationFrame(() => {\r\n    document.body.style.background = \"red\";\r\n    requestAnimationFrame(() => {\r\n      document.body.style.background = \"blue\";\r\n      if (i > 0) {\r\n        req();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nreq();\r\n```\r\n\r\n这里由于颜色变化太快，gif 录制软件没办法截出这么高帧率的颜色变换，所以各位可以放到浏览器中自己执行一下试试，我这边直接抛结论，浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，可以看下 performance 面板记录的表现：\r\n\r\n![requestAnimationFrame闪烁动画](https://user-images.githubusercontent.com/8088864/125750295-ab491df6-c612-4add-b2fe-8819fcf47ef1.png)\r\n\r\n##### 定时器合并\r\n\r\n在第一节解读规范的时候，第 4 点中提到了，定时器宏任务可能会直接跳过渲染。\r\n\r\n按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  console.log(\"sto1\")\r\n  requestAnimationFrame(() => console.log(\"rAF1\"))\r\n})\r\nsetTimeout(() => {\r\n  console.log(\"sto2\")\r\n  requestAnimationFrame(() => console.log(\"rAF2\"))\r\n})\r\n\r\nqueueMicrotask(() => console.log(\"mic1\"))\r\nqueueMicrotask(() => console.log(\"mic2\"))\r\n```\r\n\r\n从直觉上来看，顺序是不是应该是：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nrAF1\r\nsto2\r\nrAF2\r\n```\r\n\r\n呢？也就是每一个宏任务之后都紧跟着一次渲染。\r\n\r\n实际上不会，浏览器会合并这两个定时器任务：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nsto2\r\nrAF1\r\nrAF2\r\n```\r\n\r\n#### requestIdleCallback\r\n\r\n#### 草案解读\r\n\r\n我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。\r\n\r\nReact 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 postMessage 实现了一套。\r\n\r\n**渲染有序进行**\r\n\r\n首先看一张图，很精确的描述了这个 API 的意图：\r\n\r\n![浏览器渲染有序调度](https://user-images.githubusercontent.com/8088864/125756615-7bec3496-94cc-46ba-9298-5df48b99d2d8.png)\r\n\r\n当然，这种有序的 `浏览器 -> 用户 -> 浏览器 -> 用户` 的调度基于一个前提，就是我们要把任务切分成比较小的片，不能说浏览器把空闲时间让给你了，你去执行一个耗时 10s 的任务，那肯定也会把浏览器给阻塞住的。这就要求我们去读取 `rIC` 提供给你的 `deadline` 里的时间，去动态的安排我们切分的小任务。浏览器信任了你，你也不能辜负它呀。\r\n\r\n**渲染长期空闲**\r\n\r\n![浏览器渲染长期空闲调度](https://user-images.githubusercontent.com/8088864/125756805-79afd49b-e62d-45b9-bb7e-4a4b34eb7bd4.png)\r\n\r\n还有一种情况，也有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，它也就不需要去绘制页面：\r\n这种情况下为什么还是会有 50ms 的 deadline 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。\r\n\r\nMDN 文档中的[幕后任务协作调度 API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)  介绍的比较清楚，来根据里面的概念做个小实验：\r\n\r\n屏幕中间有个红色的方块，把 MDN 文档中[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的范例部分的动画代码直接复制过来。\r\n\r\n草案中还提到：\r\n\r\n1. 当浏览器判断这个页面对用户不可见时，这个回调执行的频率可能被降低到 10 秒执行一次，甚至更低。这点在解读 EventLoop 中也有提及。\r\n\r\n2. 如果浏览器的工作比较繁忙的时候，不能保证它会提供空闲时间去执行 rIC 的回调，而且可能会长期的推迟下去。所以如果你需要保证你的任务在一定时间内一定要执行掉，那么你可以给 rIC 传入第二个参数 timeout。\r\n这会强制浏览器不管多忙，都在超过这个时间之后去执行 rIC 的回调函数。所以要谨慎使用，因为它会打断浏览器本身优先级更高的工作。\r\n\r\n3. 最长期限为 50 毫秒，是根据研究得出的，研究表明，人们通常认为 100 毫秒内对用户输入的响应是瞬时的。 将闲置截止期限设置为 50ms 意味着即使在闲置任务开始后立即发生用户输入，浏览器仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。\r\n\r\n4. 每次调用 timeRemaining() 函数判断是否有剩余时间的时候，如果浏览器判断此时有优先级更高的任务，那么会动态的把这个值设置为 0，否则就是用预先设置好的 deadline - now 去计算。\r\n\r\n5. 这个 timeRemaining() 的计算非常动态，会根据很多因素去决定，所以不要指望这个时间是稳定的。\r\n\r\n#### 动画例子\r\n\r\n**滚动**\r\n\r\n如果我鼠标不做任何动作和交互，直接在控制台通过 rIC 去打印这次空闲任务的剩余时间，一般都稳定维持在 49.xx ms，因为此时浏览器没有什么优先级更高的任务要去处理。\r\n\r\n``` js\r\nrequestIdleCallback((deadline) => console.log(deadline.timeRemaining()))\r\n```\r\n\r\n![requetIdleCallback的timeRemaining时间1](https://user-images.githubusercontent.com/8088864/125778161-1e903c20-19a8-4340-83e9-af15ff16078a.gif)\r\n\r\n而如果我不停的滚动浏览器，不断的触发浏览器的重新绘制的话，这个时间就变的非常不稳定了。\r\n\r\n![requetIdleCallback的timeRemaining时间2](https://user-images.githubusercontent.com/8088864/125778195-dc9bc852-60e6-475d-a50e-441707e793ff.gif)\r\n\r\n通过这个例子，你可以更加有体感的感受到什么样叫做「繁忙」，什么样叫做「空闲」。\r\n\r\n\r\n**动画**\r\n\r\n这个动画的例子很简单，就是利用rAF在每帧渲染前的回调中把方块的位置向右移动 10px。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n注意在最后我加了一个 requestIdleCallback 的函数，回调里会 alert('rIC')，来看一下演示效果：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画](https://user-images.githubusercontent.com/8088864/125778813-19d6dde2-2b12-4754-bd4c-deba1209d3e6.gif)\r\n\r\nalert 在最开始的时候就执行了，为什么会这样呢一下，想一下「空闲」的概念，我们每一帧仅仅是把 left 的值移动了一下，做了这一个简单的渲染，没有占满空闲时间，所以可能在最开始的时候，浏览器就找到机会去调用 rIC 的回调函数了。\r\n\r\n我们简单的修改一下 step 函数，在里面加一个很重的任务，1000 次循环打印。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n再来看一下它的表现：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙](https://user-images.githubusercontent.com/8088864/125779688-be382539-51e0-4462-afee-ddb5db99b2bb.gif)\r\n\r\n其实和我们预期的一样，由于浏览器的每一帧都\"太忙了\",导致它真的就无视我们的 rIC 函数了。\r\n\r\n如果给 rIC 函数加一个 timeout 呢：\r\n\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      }, { timeout: 500 });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n效果如下：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙再加上timeout](https://user-images.githubusercontent.com/8088864/125779998-cf9201d8-707b-4d99-aece-9e40c4f7b2a2.gif)\r\n\r\n浏览器会在大概 500ms 的时候，不管有多忙，都去强制执行 `rIC` 函数，这个机制可以防止我们的空闲任务被“饿死”。\r\n\r\n### 总结\r\n\r\n通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。\r\n\r\n1. 事件循环不一定每轮都伴随着重新渲染，但是如果有微任务，一定会伴随着微任务执行。\r\n2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。\r\n3. requestAnimationFrame在重新渲染屏幕之前执行，非常适合用来做动画。\r\n4. requestIdleCallback在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 timeout参数。\r\n5. resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上。","reactions":{"url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/hankliu62.github.com/issues/103/timeline","performed_via_github_app":null,"state_reason":"completed"}},"event":"cross-referenced"},{"actor":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"created_at":"2024-02-12T05:13:32Z","updated_at":"2024-02-12T05:13:32Z","source":{"type":"issue","issue":{"url":"https://api.github.com/repos/hankliu62/interview/issues/22","repository_url":"https://api.github.com/repos/hankliu62/interview","labels_url":"https://api.github.com/repos/hankliu62/interview/issues/22/labels{/name}","comments_url":"https://api.github.com/repos/hankliu62/interview/issues/22/comments","events_url":"https://api.github.com/repos/hankliu62/interview/issues/22/events","html_url":"https://github.com/hankliu62/interview/issues/22","id":2129434202,"node_id":"I_kwDOLNphd85-7JZa","number":22,"title":"深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调","user":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":6547468110,"node_id":"LA_kwDOLNphd88AAAABhkJvTg","url":"https://api.github.com/repos/hankliu62/interview/labels/javascript","name":"javascript","color":"383040","default":false,"description":"Javascript相关"}],"state":"open","locked":false,"assignee":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":0,"created_at":"2024-02-12T05:13:31Z","updated_at":"2024-03-04T14:15:12Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"repository":{"id":752509303,"node_id":"R_kgDOLNphdw","name":"interview","full_name":"hankliu62/interview","private":false,"owner":{"login":"hankliu62","id":8088864,"node_id":"MDQ6VXNlcjgwODg4NjQ=","avatar_url":"https://avatars.githubusercontent.com/u/8088864?v=4","gravatar_id":"","url":"https://api.github.com/users/hankliu62","html_url":"https://github.com/hankliu62","followers_url":"https://api.github.com/users/hankliu62/followers","following_url":"https://api.github.com/users/hankliu62/following{/other_user}","gists_url":"https://api.github.com/users/hankliu62/gists{/gist_id}","starred_url":"https://api.github.com/users/hankliu62/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/hankliu62/subscriptions","organizations_url":"https://api.github.com/users/hankliu62/orgs","repos_url":"https://api.github.com/users/hankliu62/repos","events_url":"https://api.github.com/users/hankliu62/events{/privacy}","received_events_url":"https://api.github.com/users/hankliu62/received_events","type":"User","user_view_type":"public","site_admin":false},"html_url":"https://github.com/hankliu62/interview","description":"🥭 前端复习巩固题网站","fork":false,"url":"https://api.github.com/repos/hankliu62/interview","forks_url":"https://api.github.com/repos/hankliu62/interview/forks","keys_url":"https://api.github.com/repos/hankliu62/interview/keys{/key_id}","collaborators_url":"https://api.github.com/repos/hankliu62/interview/collaborators{/collaborator}","teams_url":"https://api.github.com/repos/hankliu62/interview/teams","hooks_url":"https://api.github.com/repos/hankliu62/interview/hooks","issue_events_url":"https://api.github.com/repos/hankliu62/interview/issues/events{/number}","events_url":"https://api.github.com/repos/hankliu62/interview/events","assignees_url":"https://api.github.com/repos/hankliu62/interview/assignees{/user}","branches_url":"https://api.github.com/repos/hankliu62/interview/branches{/branch}","tags_url":"https://api.github.com/repos/hankliu62/interview/tags","blobs_url":"https://api.github.com/repos/hankliu62/interview/git/blobs{/sha}","git_tags_url":"https://api.github.com/repos/hankliu62/interview/git/tags{/sha}","git_refs_url":"https://api.github.com/repos/hankliu62/interview/git/refs{/sha}","trees_url":"https://api.github.com/repos/hankliu62/interview/git/trees{/sha}","statuses_url":"https://api.github.com/repos/hankliu62/interview/statuses/{sha}","languages_url":"https://api.github.com/repos/hankliu62/interview/languages","stargazers_url":"https://api.github.com/repos/hankliu62/interview/stargazers","contributors_url":"https://api.github.com/repos/hankliu62/interview/contributors","subscribers_url":"https://api.github.com/repos/hankliu62/interview/subscribers","subscription_url":"https://api.github.com/repos/hankliu62/interview/subscription","commits_url":"https://api.github.com/repos/hankliu62/interview/commits{/sha}","git_commits_url":"https://api.github.com/repos/hankliu62/interview/git/commits{/sha}","comments_url":"https://api.github.com/repos/hankliu62/interview/comments{/number}","issue_comment_url":"https://api.github.com/repos/hankliu62/interview/issues/comments{/number}","contents_url":"https://api.github.com/repos/hankliu62/interview/contents/{+path}","compare_url":"https://api.github.com/repos/hankliu62/interview/compare/{base}...{head}","merges_url":"https://api.github.com/repos/hankliu62/interview/merges","archive_url":"https://api.github.com/repos/hankliu62/interview/{archive_format}{/ref}","downloads_url":"https://api.github.com/repos/hankliu62/interview/downloads","issues_url":"https://api.github.com/repos/hankliu62/interview/issues{/number}","pulls_url":"https://api.github.com/repos/hankliu62/interview/pulls{/number}","milestones_url":"https://api.github.com/repos/hankliu62/interview/milestones{/number}","notifications_url":"https://api.github.com/repos/hankliu62/interview/notifications{?since,all,participating}","labels_url":"https://api.github.com/repos/hankliu62/interview/labels{/name}","releases_url":"https://api.github.com/repos/hankliu62/interview/releases{/id}","deployments_url":"https://api.github.com/repos/hankliu62/interview/deployments","created_at":"2024-02-04T03:32:25Z","updated_at":"2025-01-26T14:31:03Z","pushed_at":"2024-03-10T13:09:01Z","git_url":"git://github.com/hankliu62/interview.git","ssh_url":"git@github.com:hankliu62/interview.git","clone_url":"https://github.com/hankliu62/interview.git","svn_url":"https://github.com/hankliu62/interview","homepage":"https://hankliu62.github.io/interview/","size":48786,"stargazers_count":7,"watchers_count":7,"language":"JavaScript","has_issues":true,"has_projects":true,"has_downloads":true,"has_wiki":true,"has_pages":true,"has_discussions":false,"forks_count":0,"mirror_url":null,"archived":false,"disabled":false,"open_issues_count":1525,"license":null,"allow_forking":true,"is_template":false,"web_commit_signoff_required":false,"topics":[],"visibility":"public","forks":0,"open_issues":1525,"watchers":7,"default_branch":"master","permissions":{"admin":false,"maintain":false,"push":false,"triage":false,"pull":true}},"body":"### 前言\r\n\r\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\r\n\r\n1. 每一轮 Event Loop 都会伴随着渲染吗？\r\n2. requestAnimationFrame 在哪个阶段执行，在渲染前还是后？在 microTask 的前还是后？\r\n3. requestIdleCallback 在哪个阶段执行？如何去执行？在渲染前还是后？在 microTask 的前还是后？\r\n4. resize、scroll 这些事件是何时去派发的。\r\n\r\n这些问题并不是刻意想刁难你，如果你不知道这些，那你可能并不能在遇到一个动画需求的时候合理的选择 requestAnimationFrame，你可能在做一些需求的时候想到了 requestIdleCallback，但是你不知道它运行的时机，只是胆战心惊的去用它，祈祷不要出线上 bug。\r\n\r\n这也是本文想要从规范解读入手，深挖底层的动机之一。本文会酌情从规范中排除掉一些比较晦涩难懂，或者和主流程不太相关的概念。更详细的版本也可以直接去读这个规范，不过比较费时费力。\r\n\r\n### 事件循环\r\n\r\n我们先依据HTML 官方规范从浏览器的事件循环讲起，因为剩下的 API 都在这个循环中进行，它是浏览器调度任务的基础。\r\n\r\n#### 定义\r\n\r\n为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环。\r\n\r\n#### 流程\r\n\r\n1. 从任务队列中取出一个宏任务并执行。\r\n2. 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。\r\n3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）\r\n    - 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。\r\n    - 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。\r\n    - 如果满足以下条件，也会跳过渲染：\r\n        1. 浏览器判断更新渲染不会带来视觉上的改变。\r\n        2. map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。\r\n4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：\r\n  This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask的执行，而不会穿插屏幕渲染相关的流程（比如requestAnimationFrame，下面会写一个例子）。\r\n5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 `resize` 方法。\r\n6. 对于需要渲染的文档，如果页面发生了滚动，执行 `scroll` 方法。\r\n7. 对于需要渲染的文档，执行帧动画回调，也就是 `requestAnimationFrame` 的回调。（后文会详解）\r\n8. 对于需要渲染的文档，执行 `IntersectionObserver` 的回调。\r\n9. 对于需要渲染的文档，**重新渲染**绘制用户界面。\r\n10. 判断 `task队列`和`microTask队列`是否都为空，如果是的话，则进行 `Idle` 空闲周期的算法，判断是否要执行 `requestIdleCallback` 的回调函数。（后文会详解）\r\n\r\n对于 `resize` 和 `scroll` 来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多？浏览器当然会立刻帮你滚动视图，根据CSSOM 规范所讲，浏览器会保存一个 `pending scroll event targets`，等到事件循环中的 `scroll` 这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize` 也是同理。\r\n可以在这个流程中仔细看一下「宏任务」、「微任务」、「渲染」之间的关系。\r\n多任务队列\r\n\r\n#### 多任务队列\r\n\r\ntask 队列并不是我们想象中的那样只有一个，根据规范里的描述：\r\n\r\nAn event loop has one or more task queues. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.\r\n\r\n事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：\r\n\r\n1. 鼠标和键盘事件\r\n2. 其他的一些 Task\r\n\r\n览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他 Task，并且保证不会“饿死”它们。\r\n\r\n这个规范也导致 Vue 2.0.0-rc.7 这个版本 `nextTick` 采用了从微任务 `MutationObserver` 更换成宏任务 `postMessage` 而导致了一个 [Issue](https://github.com/vuejs/vue/issues/3771#issuecomment-249692588)。\r\n目前由于一些“未知”的原因，`jsfiddle` 的案例打不开了。简单描述一下就是采用了 `task` 实现的 `nextTick`，在用户持续滚动的情况下 `nextTick` 任务被延后了很久才去执行，导致动画跟不上滚动了。\r\n\r\n迫于无奈，尤大还是改回了 `microTask` 去实现 `nextTick`，当然目前来说 `promise.then` 微任务已经比较稳定了，并且 Chrome 也已经实现了 `queueMicroTask` 这个官方 API。不久的未来，我们想要调用微任务队列的话，也可以节省掉实例化 `Promise` 在开销了。\r\n\r\n从这个 Issue 的例子中我们可以看出，稍微去深入了解一下规范还是比较有好处的，以免在遇到这种比较复杂的 Bug 的时候一脸懵逼。\r\n\r\n#### requestAnimationFrame\r\n\r\n在解读规范的过程中，我们发现 `requestAnimationFrame` 的回调有两个特征：\r\n\r\n1. 在重新渲染前调用。\r\n2. 很可能在宏任务之后不调用。\r\n\r\n我们来分析一下，为什么要在重新渲染前去调用？因为 `rAF` 是官方推荐的用来做一些流畅动画所应该使用的 API，做动画不可避免的会去更改 DOM，而如果在渲染之后再去更改 DOM，那就只能等到下一轮渲染机会的时候才能去绘制出来了，这显然是不合理的。\r\n\r\n`rAF`在浏览器决定渲染之前给你最后一个机会去改变 DOM 属性，然后很快在接下来的绘制中帮你呈现出来，所以这是做流畅动画的不二选择。下面我用一个 setTimeout的例子来对比。\r\n\r\n##### 闪烁动画\r\n\r\n假设我们现在想要快速的让屏幕上闪烁 红、蓝两种颜色，保证用户可以观察到，如果我们用 `setTimeout` 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  document.body.style.background = \"red\";\r\n  setTimeout(() => {\r\n    document.body.style.background = \"blue\";\r\n  });\r\n});\r\n```\r\n\r\n![setTimeout闪烁动画](https://user-images.githubusercontent.com/8088864/125749050-c757f81e-6482-4262-a0d4-c455eb78d4f4.gif)\r\n\r\n以看出这个结果是非常不可控的，如果这两个 `Task` 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。\r\n\r\n如果你把延时调整到 17ms 那么重绘的概率会大很多，毕竟这个是一般情况下 60fps 的一个指标。但是也会出现很多不绘制的情况，所以并不稳定。\r\n如果你依赖这个 API 来做动画，那么就很可能会造成「掉帧」。\r\n\r\n接下来我们换成 rAF 试试？我们用一个递归函数来模拟 10 次颜色变化的动画。\r\n\r\n``` js\r\nlet i = 10;\r\nlet req = () => {\r\n  i--;\r\n  requestAnimationFrame(() => {\r\n    document.body.style.background = \"red\";\r\n    requestAnimationFrame(() => {\r\n      document.body.style.background = \"blue\";\r\n      if (i > 0) {\r\n        req();\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nreq();\r\n```\r\n\r\n这里由于颜色变化太快，gif 录制软件没办法截出这么高帧率的颜色变换，所以各位可以放到浏览器中自己执行一下试试，我这边直接抛结论，浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来，可以看下 performance 面板记录的表现：\r\n\r\n![requestAnimationFrame闪烁动画](https://user-images.githubusercontent.com/8088864/125750295-ab491df6-c612-4add-b2fe-8819fcf47ef1.png)\r\n\r\n##### 定时器合并\r\n\r\n在第一节解读规范的时候，第 4 点中提到了，定时器宏任务可能会直接跳过渲染。\r\n\r\n按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：\r\n\r\n``` js\r\nsetTimeout(() => {\r\n  console.log(\"sto1\")\r\n  requestAnimationFrame(() => console.log(\"rAF1\"))\r\n})\r\nsetTimeout(() => {\r\n  console.log(\"sto2\")\r\n  requestAnimationFrame(() => console.log(\"rAF2\"))\r\n})\r\n\r\nqueueMicrotask(() => console.log(\"mic1\"))\r\nqueueMicrotask(() => console.log(\"mic2\"))\r\n```\r\n\r\n从直觉上来看，顺序是不是应该是：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nrAF1\r\nsto2\r\nrAF2\r\n```\r\n\r\n呢？也就是每一个宏任务之后都紧跟着一次渲染。\r\n\r\n实际上不会，浏览器会合并这两个定时器任务：\r\n\r\n``` text\r\nmic1\r\nmic2\r\nsto1\r\nsto2\r\nrAF1\r\nrAF2\r\n```\r\n\r\n#### requestIdleCallback\r\n\r\n#### 草案解读\r\n\r\n我们都知道 `requestIdleCallback` 是浏览器提供给我们的空闲调度算法，关于它的简介可以看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，意图是让我们把一些计算量较大但是又没那么紧急的任务放到空闲时间去执行。不要去影响浏览器中优先级较高的任务，比如动画绘制、用户输入等等。\r\n\r\nReact 的时间分片渲染就想要用到这个 API，不过目前浏览器支持的不给力，他们是自己去用 postMessage 实现了一套。\r\n\r\n**渲染有序进行**\r\n\r\n首先看一张图，很精确的描述了这个 API 的意图：\r\n\r\n![浏览器渲染有序调度](https://user-images.githubusercontent.com/8088864/125756615-7bec3496-94cc-46ba-9298-5df48b99d2d8.png)\r\n\r\n当然，这种有序的 `浏览器 -> 用户 -> 浏览器 -> 用户` 的调度基于一个前提，就是我们要把任务切分成比较小的片，不能说浏览器把空闲时间让给你了，你去执行一个耗时 10s 的任务，那肯定也会把浏览器给阻塞住的。这就要求我们去读取 `rIC` 提供给你的 `deadline` 里的时间，去动态的安排我们切分的小任务。浏览器信任了你，你也不能辜负它呀。\r\n\r\n**渲染长期空闲**\r\n\r\n![浏览器渲染长期空闲调度](https://user-images.githubusercontent.com/8088864/125756805-79afd49b-e62d-45b9-bb7e-4a4b34eb7bd4.png)\r\n\r\n还有一种情况，也有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，它也就不需要去绘制页面：\r\n这种情况下为什么还是会有 50ms 的 deadline 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。\r\n\r\nMDN 文档中的[幕后任务协作调度 API](https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API)  介绍的比较清楚，来根据里面的概念做个小实验：\r\n\r\n屏幕中间有个红色的方块，把 MDN 文档中[requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)的范例部分的动画代码直接复制过来。\r\n\r\n草案中还提到：\r\n\r\n1. 当浏览器判断这个页面对用户不可见时，这个回调执行的频率可能被降低到 10 秒执行一次，甚至更低。这点在解读 EventLoop 中也有提及。\r\n2. 如果浏览器的工作比较繁忙的时候，不能保证它会提供空闲时间去执行 rIC 的回调，而且可能会长期的推迟下去。所以如果你需要保证你的任务在一定时间内一定要执行掉，那么你可以给 rIC 传入第二个参数 timeout。\r\n这会强制浏览器不管多忙，都在超过这个时间之后去执行 rIC 的回调函数。所以要谨慎使用，因为它会打断浏览器本身优先级更高的工作。\r\n3. 最长期限为 50 毫秒，是根据研究得出的，研究表明，人们通常认为 100 毫秒内对用户输入的响应是瞬时的。 将闲置截止期限设置为 50ms 意味着即使在闲置任务开始后立即发生用户输入，浏览器仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。\r\n4. 每次调用 timeRemaining() 函数判断是否有剩余时间的时候，如果浏览器判断此时有优先级更高的任务，那么会动态的把这个值设置为 0，否则就是用预先设置好的 deadline - now 去计算。\r\n5. 这个 timeRemaining() 的计算非常动态，会根据很多因素去决定，所以不要指望这个时间是稳定的。\r\n\r\n#### 动画例子\r\n\r\n**滚动**\r\n\r\n如果我鼠标不做任何动作和交互，直接在控制台通过 rIC 去打印这次空闲任务的剩余时间，一般都稳定维持在 49.xx ms，因为此时浏览器没有什么优先级更高的任务要去处理。\r\n\r\n``` js\r\nrequestIdleCallback((deadline) => console.log(deadline.timeRemaining()))\r\n```\r\n\r\n![requetIdleCallback的timeRemaining时间1](https://user-images.githubusercontent.com/8088864/125778161-1e903c20-19a8-4340-83e9-af15ff16078a.gif)\r\n\r\n而如果我不停的滚动浏览器，不断的触发浏览器的重新绘制的话，这个时间就变的非常不稳定了。\r\n\r\n![requetIdleCallback的timeRemaining时间2](https://user-images.githubusercontent.com/8088864/125778195-dc9bc852-60e6-475d-a50e-441707e793ff.gif)\r\n\r\n通过这个例子，你可以更加有体感的感受到什么样叫做「繁忙」，什么样叫做「空闲」。\r\n\r\n\r\n**动画**\r\n\r\n这个动画的例子很简单，就是利用rAF在每帧渲染前的回调中把方块的位置向右移动 10px。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n注意在最后我加了一个 requestIdleCallback 的函数，回调里会 alert('rIC')，来看一下演示效果：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画](https://user-images.githubusercontent.com/8088864/125778813-19d6dde2-2b12-4754-bd4c-deba1209d3e6.gif)\r\n\r\nalert 在最开始的时候就执行了，为什么会这样呢一下，想一下「空闲」的概念，我们每一帧仅仅是把 left 的值移动了一下，做了这一个简单的渲染，没有占满空闲时间，所以可能在最开始的时候，浏览器就找到机会去调用 rIC 的回调函数了。\r\n\r\n我们简单的修改一下 step 函数，在里面加一个很重的任务，1000 次循环打印。\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n再来看一下它的表现：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙](https://user-images.githubusercontent.com/8088864/125779688-be382539-51e0-4462-afee-ddb5db99b2bb.gif)\r\n\r\n其实和我们预期的一样，由于浏览器的每一帧都\"太忙了\",导致它真的就无视我们的 rIC 函数了。\r\n\r\n如果给 rIC 函数加一个 timeout 呢：\r\n\r\n\r\n``` html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Document</title>\r\n    <style>\r\n      #SomeElementYouWantToAnimate {\r\n        height: 200px;\r\n        width: 200px;\r\n        background: red;\r\n      }\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <div id=\"SomeElementYouWantToAnimate\"></div>\r\n    <script>\r\n      var start = null;\r\n      var element = document.getElementById(\"SomeElementYouWantToAnimate\");\r\n      element.style.position = \"absolute\";\r\n\r\n      function step(timestamp) {\r\n        if (!start) start = timestamp;\r\n        var progress = timestamp - start;\r\n        element.style.left = Math.min(progress / 10, 200) + \"px\";\r\n        let i = 1000;\r\n        while (i > 0) {\r\n          console.log(\"i\", i);\r\n          i--;\r\n        }\r\n        if (progress < 2000) {\r\n          window.requestAnimationFrame(step);\r\n        }\r\n      }\r\n\r\n      // 动画\r\n      window.requestAnimationFrame(step);\r\n\r\n      // 空闲调度\r\n      window.requestIdleCallback((deadline) => {\r\n        console.log(deadline.timeRemaining())\r\n        alert(\"rIC\");\r\n      }, { timeout: 500 });\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n效果如下：\r\n\r\n![requetIdleCallback和requestAnmationFrame动画很忙再加上timeout](https://user-images.githubusercontent.com/8088864/125779998-cf9201d8-707b-4d99-aece-9e40c4f7b2a2.gif)\r\n\r\n浏览器会在大概 500ms 的时候，不管有多忙，都去强制执行 `rIC` 函数，这个机制可以防止我们的空闲任务被“饿死”。\r\n\r\n### 总结\r\n\r\n通过本文的学习过程，我自己也打破了很多对于 Event Loop 以及 rAF、rIC 函数的固有错误认知，通过本文我们可以整理出以下的几个关键点。\r\n\r\n1. 事件循环不一定每轮都伴随着重新渲染，但是如果有微任务，一定会伴随着微任务执行。\r\n2. 决定浏览器视图是否渲染的因素很多，浏览器是非常聪明的。\r\n3. requestAnimationFrame在重新渲染屏幕之前执行，非常适合用来做动画。\r\n4. requestIdleCallback在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果你一定要它在某个时间内执行，请使用 timeout参数。\r\n5. resize和scroll事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上。","reactions":{"url":"https://api.github.com/repos/hankliu62/interview/issues/22/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hankliu62/interview/issues/22/timeline","performed_via_github_app":null,"state_reason":null}},"event":"cross-referenced"}]