diff --git a/main/pom.xml b/main/pom.xml
index 22973b3f1c..55fea38f2b 100644
--- a/main/pom.xml
+++ b/main/pom.xml
@@ -39,6 +39,7 @@
     </properties>
 
     <dependencies>
+        <!--
         <dependency>
             <groupId>org.eclipse</groupId>
             <artifactId>osgi</artifactId>
@@ -49,6 +50,7 @@
             <artifactId>org.apache.felix.framework</artifactId>
             <scope>provided</scope>
         </dependency>
+        -->
         <dependency>
             <groupId>org.apache.servicemix.bundles</groupId>
             <artifactId>org.apache.servicemix.bundles.junit</artifactId>
diff --git a/main/src/main/java/org/apache/karaf/main/Main.java b/main/src/main/java/org/apache/karaf/main/Main.java
index a5aa0eb8dd..c08052a122 100644
--- a/main/src/main/java/org/apache/karaf/main/Main.java
+++ b/main/src/main/java/org/apache/karaf/main/Main.java
@@ -295,6 +295,10 @@ public class Main {
         framework.start();
 
         ServerInfo serverInfo = new ServerInfoImpl(args, karafBase, karafData, karafHome, karafInstances);
+
+        URL url = framework.getClass().getClassLoader().getResource(framework.getClass().getName().replace(".", "/") + ".class");
+        System.err.println("Framework: " + url.toExternalForm());
+
         framework.getBundleContext().registerService(ServerInfo.class, serverInfo, null);
 
         // Start custom activators
diff --git a/main/src/main/java/org/osgi/framework/AdaptPermission.java b/main/src/main/java/org/osgi/framework/AdaptPermission.java
new file mode 100644
index 0000000000..f95c1fe11f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/AdaptPermission.java
@@ -0,0 +1,635 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.AccessController;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.PrivilegedAction;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A bundle's authority to adapt an object to a type.
+ * 
+ * <p>
+ * {@code AdaptPermission} has one action: {@code adapt}.
+ * 
+ * @ThreadSafe
+ * @version $Id: bc4c5d392d2534a7744f6fc00f4665502f82033c $
+ */
+public class AdaptPermission extends BasicPermission {
+
+	private static final long						serialVersionUID	= 1L;
+
+	/**
+	 * The action string {@code initiate}.
+	 */
+	public final static String						ADAPT				= "adapt";
+
+	private final static int						ACTION_ADAPT		= 0x00000001;
+	private final static int						ACTION_ALL			= ACTION_ADAPT;
+	final static int								ACTION_NONE			= 0;
+
+	/**
+	 * The actions mask.
+	 */
+	transient int									action_mask;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String							actions				= null;
+
+	/**
+	 * The bundle used by this AdaptPermission.
+	 */
+	transient final Bundle							bundle;
+
+	/**
+	 * This holds a Filter matching object used to evaluate the filter in
+	 * implies.
+	 */
+	transient Filter								filter;
+
+	/**
+	 * This map holds the properties of the permission, used to match a filter
+	 * in implies. This is not initialized until necessary, and then cached in
+	 * this object.
+	 */
+	private transient volatile Map<String, Object>	properties;
+
+	/**
+	 * Creates a new granted {@code AdaptPermission} object.
+	 * 
+	 * This constructor must only be used to create a permission that is going
+	 * to be checked.
+	 * <p>
+	 * Examples:
+	 * 
+	 * <pre>
+	 * (adaptClass=com.acme.*)
+	 * (&amp;(signer=\*,o=ACME,c=US)(adaptClass=com.acme.*))
+	 * (signer=\*,o=ACME,c=US)
+	 * </pre>
+	 * 
+	 * <p>
+	 * When a signer key is used within the filter expression the signer value
+	 * must escape the special filter chars ('*', '(', ')').
+	 * <p>
+	 * The name is specified as a filter expression. The filter gives access to
+	 * the following attributes:
+	 * <ul>
+	 * <li>signer - A Distinguished Name chain used to sign the exporting
+	 * bundle. Wildcards in a DN are not matched according to the filter string
+	 * rules, but according to the rules defined for a DN chain.</li>
+	 * <li>location - The location of the exporting bundle.</li>
+	 * <li>id - The bundle ID of the exporting bundle.</li>
+	 * <li>name - The symbolic name of the exporting bundle.</li>
+	 * <li>adaptClass - The name of the type to which an object can be adapted.</li>
+	 * </ul>
+	 * Filter attribute names are processed in a case sensitive manner.
+	 * 
+	 * @param filter A filter expression. Filter attribute names are processed
+	 *        in a case sensitive manner. A special value of {@code "*"} can be
+	 *        used to match all adaptations.
+	 * @param actions {@code adapt}.
+	 * @throws IllegalArgumentException If the filter has an invalid syntax.
+	 */
+	public AdaptPermission(String filter, String actions) {
+		this(parseFilter(filter), parseActions(actions));
+	}
+
+	/**
+	 * Creates a new requested {@code AdaptPermission} object to be used by the
+	 * code that must perform {@code checkPermission}. {@code AdaptPermission}
+	 * objects created with this constructor cannot be added to an
+	 * {@code AdaptPermission} permission collection.
+	 * 
+	 * @param adaptClass The name of the type to which an object can be adapted.
+	 * @param adaptableBundle The bundle associated with the object being
+	 *        adapted.
+	 * @param actions {@code adapt}.
+	 */
+	public AdaptPermission(String adaptClass, Bundle adaptableBundle,
+			String actions) {
+		super(adaptClass);
+		setTransients(null, parseActions(actions));
+		this.bundle = adaptableBundle;
+		if (adaptClass == null) {
+			throw new NullPointerException("adaptClass must not be null");
+		}
+		if (adaptableBundle == null) {
+			throw new NullPointerException("adaptableBundle must not be null");
+		}
+	}
+
+	/**
+	 * Package private constructor used by AdaptPermissionCollection.
+	 * 
+	 * @param filter name filter
+	 * @param mask action mask
+	 */
+	AdaptPermission(Filter filter, int mask) {
+		super((filter == null) ? "*" : filter.toString());
+		setTransients(filter, mask);
+		this.bundle = null;
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param filter Permission's filter or {@code null} for wildcard.
+	 * @param mask action mask
+	 */
+	private void setTransients(Filter filter, int mask) {
+		this.filter = filter;
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+		this.action_mask = mask;
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		boolean seencomma = false;
+
+		int mask = ACTION_NONE;
+
+		if (actions == null) {
+			return mask;
+		}
+
+		char[] a = actions.toCharArray();
+
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+
+		while (i != -1) {
+			char c;
+
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+
+			// check for the known strings
+			int matchlen;
+
+			if (i >= 4 && (a[i - 4] == 'a' || a[i - 4] == 'A')
+					&& (a[i - 3] == 'd' || a[i - 3] == 'D')
+					&& (a[i - 2] == 'a' || a[i - 2] == 'A')
+					&& (a[i - 1] == 'p' || a[i - 1] == 'P')
+					&& (a[i] == 't' || a[i] == 'T')) {
+				matchlen = 5;
+				mask |= ACTION_ADAPT;
+
+			}
+			else {
+				// parse error
+				throw new IllegalArgumentException("invalid actions: "
+						+ actions);
+			}
+
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfadapt". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+						/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+				}
+				i--;
+			}
+
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid actions: " + actions);
+		}
+
+		return mask;
+	}
+
+	/**
+	 * Parse filter string into a Filter object.
+	 * 
+	 * @param filterString The filter string to parse.
+	 * @return a Filter for this bundle.
+	 * @throws IllegalArgumentException If the filter syntax is invalid.
+	 */
+	private static Filter parseFilter(String filterString) {
+		filterString = filterString.trim();
+		if (filterString.equals("*")) {
+			return null;
+		}
+		try {
+			return FrameworkUtil.createFilter(filterString);
+		}
+		catch (InvalidSyntaxException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid filter");
+			iae.initCause(e);
+			throw iae;
+		}
+	}
+
+	/**
+	 * Determines if the specified permission is implied by this object.
+	 * 
+	 * <p>
+	 * This method checks that the filter of the target is implied by the adapt
+	 * class name of this object. The list of {@code AdaptPermission} actions
+	 * must either match or allow for the list of the target object to imply the
+	 * target {@code AdaptPermission} action.
+	 * <p>
+	 * 
+	 * @param p The requested permission.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof AdaptPermission)) {
+			return false;
+		}
+		AdaptPermission requested = (AdaptPermission) p;
+		if (bundle != null) {
+			return false;
+		}
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		return implies0(requested, ACTION_NONE);
+	}
+
+	/**
+	 * Internal implies method. Used by the implies and the permission
+	 * collection implies methods.
+	 * 
+	 * @param requested The requested AdaptPermission which has already be
+	 *        validated as a proper argument. The requested AdaptPermission must
+	 *        not have a filter expression.
+	 * @param effective The effective actions with which to start.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	boolean implies0(AdaptPermission requested, int effective) {
+		/* check actions first - much faster */
+		effective |= action_mask;
+		final int desired = requested.action_mask;
+		if ((effective & desired) != desired) {
+			return false;
+		}
+		/* Get filter */
+		Filter f = filter;
+		if (f == null) {
+			// it's "*"
+			return true;
+		}
+		return f.matches(requested.getProperties());
+	}
+
+	/**
+	 * Returns the canonical string representation of the
+	 * {@code AdaptPermission} actions.
+	 * 
+	 * <p>
+	 * Always returns present {@code AdaptPermission} actions in the following
+	 * order: {@code adapt}.
+	 * 
+	 * @return Canonical string representation of the {@code AdaptPermission}
+	 *         actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			actions = result = ADAPT;
+		}
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object suitable for storing
+	 * {@code AdaptPermission} objects.
+	 * 
+	 * @return A new {@code PermissionCollection} object.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new AdaptPermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two {@code AdaptPermission} objects.
+	 * 
+	 * This method checks that specified permission has the same name and
+	 * {@code AdaptPermission} actions as this {@code AdaptPermission} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code AdaptPermission} object.
+	 * @return {@code true} if {@code obj} is a {@code AdaptPermission}, and has
+	 *         the same name and actions as this {@code AdaptPermission} object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof AdaptPermission)) {
+			return false;
+		}
+
+		AdaptPermission cp = (AdaptPermission) obj;
+
+		return (action_mask == cp.action_mask)
+				&& getName().equals(cp.getName())
+				&& ((bundle == cp.bundle) || ((bundle != null) && bundle
+						.equals(cp.bundle)));
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		if (bundle != null) {
+			h = 31 * h + bundle.hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of this permission object to a
+	 * stream. The actions are serialized, and the superclass takes care of the
+	 * name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		if (bundle != null) {
+			throw new NotSerializableException("cannot serialize");
+		}
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of this permission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the action, then initialize the rest
+		s.defaultReadObject();
+		setTransients(parseFilter(getName()), parseActions(actions));
+	}
+
+	/**
+	 * Called by {@code <@link AdaptPermission#implies(Permission)>}. This
+	 * method is only called on a requested permission which cannot have a
+	 * filter set.
+	 * 
+	 * @return a map of properties for this permission.
+	 */
+	private Map<String, Object> getProperties() {
+		Map<String, Object> result = properties;
+		if (result != null) {
+			return result;
+		}
+		final Map<String, Object> map = new HashMap<String, Object>(5);
+		map.put("adaptClass", getName());
+		if (bundle != null) {
+			AccessController.doPrivileged(new PrivilegedAction<Object>() {
+				public Object run() {
+					map.put("id", new Long(bundle.getBundleId()));
+					map.put("location", bundle.getLocation());
+					String name = bundle.getSymbolicName();
+					if (name != null) {
+						map.put("name", name);
+					}
+					SignerProperty signer = new SignerProperty(bundle);
+					if (signer.isBundleSigned()) {
+						map.put("signer", signer);
+					}
+					return null;
+				}
+			});
+		}
+		return properties = map;
+	}
+}
+
+/**
+ * Stores a set of {@code AdaptPermission} permissions.
+ * 
+ * @see java.security.Permission
+ * @see java.security.Permissions
+ * @see java.security.PermissionCollection
+ */
+
+final class AdaptPermissionCollection extends PermissionCollection {
+	static final long						serialVersionUID	= -3350758995234427603L;
+	/**
+	 * Collection of permissions.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private Map<String, AdaptPermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean							all_allowed;
+
+	/**
+	 * Create an empty AdaptPermissions object.
+	 */
+	public AdaptPermissionCollection() {
+		permissions = new HashMap<String, AdaptPermission>();
+		all_allowed = false;
+	}
+
+	/**
+	 * Adds a permission to this permission collection.
+	 * 
+	 * @param permission The {@code AdaptPermission} object to add.
+	 * @throws IllegalArgumentException If the specified permission is not a
+	 *         {@code AdaptPermission} instance or was constructed with a Bundle
+	 *         object.
+	 * @throws SecurityException If this {@code AdaptPermissionCollection}
+	 *         object has been marked read-only.
+	 */
+	public void add(final Permission permission) {
+		if (!(permission instanceof AdaptPermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection");
+		}
+
+		final AdaptPermission ap = (AdaptPermission) permission;
+		if (ap.bundle != null) {
+			throw new IllegalArgumentException("cannot add to collection: "
+					+ ap);
+		}
+
+		final String name = ap.getName();
+		synchronized (this) {
+			Map<String, AdaptPermission> pc = permissions;
+			final AdaptPermission existing = pc.get(name);
+			if (existing != null) {
+				final int oldMask = existing.action_mask;
+				final int newMask = ap.action_mask;
+				if (oldMask != newMask) {
+					pc.put(name, new AdaptPermission(existing.filter, oldMask
+							| newMask));
+
+				}
+			}
+			else {
+				pc.put(name, ap);
+			}
+
+			if (!all_allowed) {
+				if (name.equals("*")) {
+					all_allowed = true;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Determines if the specified permissions implies the permissions expressed
+	 * in {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare with this
+	 *        {@code AdaptPermission} object.
+	 * @return {@code true} if {@code permission} is a proper subset of a
+	 *         permission in the set; {@code false} otherwise.
+	 */
+	public boolean implies(final Permission permission) {
+		if (!(permission instanceof AdaptPermission)) {
+			return false;
+		}
+		final AdaptPermission requested = (AdaptPermission) permission;
+		/* if requested permission has a filter, then it is an invalid argument */
+		if (requested.filter != null) {
+			return false;
+		}
+
+		int effective = AdaptPermission.ACTION_NONE;
+
+		Collection<AdaptPermission> perms;
+		synchronized (this) {
+			Map<String, AdaptPermission> pc = permissions;
+			/* short circuit if the "*" Permission was added */
+			if (all_allowed) {
+				AdaptPermission ap = pc.get("*");
+				if (ap != null) {
+					effective |= ap.action_mask;
+					final int desired = requested.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			perms = pc.values();
+		}
+		/* iterate one by one over filteredPermissions */
+		for (AdaptPermission perm : perms) {
+			if (perm.implies0(requested, effective)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns an enumeration of all {@code AdaptPermission} objects in the
+	 * container.
+	 * 
+	 * @return Enumeration of all {@code AdaptPermission} objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		return Collections.enumeration(all);
+	}
+
+	/* serialization logic */
+	private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", HashMap.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE)			};
+
+	private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", permissions);
+		pfields.put("all_allowed", all_allowed);
+		out.writeFields();
+	}
+
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException, ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		permissions = (HashMap<String, AdaptPermission>) gfields.get(
+				"permissions", null);
+		all_allowed = gfields.get("all_allowed", false);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/AdminPermission.java b/main/src/main/java/org/osgi/framework/AdminPermission.java
new file mode 100644
index 0000000000..fc7b1f4aab
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/AdminPermission.java
@@ -0,0 +1,1056 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.AccessController;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.PrivilegedAction;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A bundle's authority to perform specific privileged administrative operations
+ * on or to get sensitive information about a bundle. The actions for this
+ * permission are:
+ * 
+ * <pre>
+ *  Action               Methods
+ *  class                Bundle.loadClass
+ *  execute              Bundle.start
+ *                       Bundle.stop
+ *                       BundleStartLevel.setStartLevel
+ *  extensionLifecycle   BundleContext.installBundle for extension bundles
+ *                       Bundle.update for extension bundles
+ *                       Bundle.uninstall for extension bundles
+ *  lifecycle            BundleContext.installBundle
+ *                       Bundle.update
+ *                       Bundle.uninstall
+ *  listener             BundleContext.addBundleListener for SynchronousBundleListener
+ *                       BundleContext.removeBundleListener for SynchronousBundleListener
+ *  metadata             Bundle.getHeaders
+ *                       Bundle.getLocation
+ *  resolve              FrameworkWiring.refreshBundles
+ *                       FrameworkWiring.resolveBundles
+ *  resource             Bundle.getResource
+ *                       Bundle.getResources
+ *                       Bundle.getEntry
+ *                       Bundle.getEntryPaths
+ *                       Bundle.findEntries
+ *                       Bundle resource/entry URL creation
+ *  startlevel           FrameworkStartLevel.setStartLevel
+ *                       FrameworkStartLevel.setInitialBundleStartLevel 
+ *  context              Bundle.getBundleContext
+ *  weave                WovenClass.setBytes
+ *                       WovenClass.getDynamicImports for modification
+ * </pre>
+ * 
+ * <p>
+ * The special action &quot;*&quot; will represent all actions. The
+ * {@code resolve} action is implied by the {@code class}, {@code execute} and
+ * {@code resource} actions.
+ * <p>
+ * The name of this permission is a filter expression. The filter gives access
+ * to the following attributes:
+ * <ul>
+ * <li>signer - A Distinguished Name chain used to sign a bundle. Wildcards in a
+ * DN are not matched according to the filter string rules, but according to the
+ * rules defined for a DN chain.</li>
+ * <li>location - The location of a bundle.</li>
+ * <li>id - The bundle ID of the designated bundle.</li>
+ * <li>name - The symbolic name of a bundle.</li>
+ * </ul>
+ * Filter attribute names are processed in a case sensitive manner.
+ * 
+ * @ThreadSafe
+ * @version $Id: 43baf9a6d7ce5e6108507834e841e340fd91c513 $
+ */
+
+public final class AdminPermission extends BasicPermission {
+	static final long						serialVersionUID			= 307051004521261705L;
+
+	/**
+	 * The action string {@code class}. The {@code class} action
+	 * implies the {@code resolve} action.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	CLASS						= "class";
+	/**
+	 * The action string {@code execute}. The {@code execute} action
+	 * implies the {@code resolve} action.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	EXECUTE						= "execute";
+	/**
+	 * The action string {@code extensionLifecycle}.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	EXTENSIONLIFECYCLE			= "extensionLifecycle";
+	/**
+	 * The action string {@code lifecycle}.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	LIFECYCLE					= "lifecycle";
+	/**
+	 * The action string {@code listener}.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	LISTENER					= "listener";
+	/**
+	 * The action string {@code metadata}.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	METADATA					= "metadata";
+	/**
+	 * The action string {@code resolve}. The {@code resolve} action
+	 * is implied by the {@code class}, {@code execute} and
+	 * {@code resource} actions.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	RESOLVE						= "resolve";
+	/**
+	 * The action string {@code resource}. The {@code resource} action
+	 * implies the {@code resolve} action.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	RESOURCE					= "resource";
+	/**
+	 * The action string {@code startlevel}.
+	 * 
+	 * @since 1.3
+	 */
+	public final static String	STARTLEVEL					= "startlevel";
+
+	/**
+	 * The action string {@code context}.
+	 * 
+	 * @since 1.4
+	 */
+	public final static String	CONTEXT						= "context";
+
+	/**
+	 * The action string {@code weave}.
+	 * 
+	 * @since 1.6
+	 */
+	public final static String						WEAVE						= "weave";
+
+	private final static int	ACTION_CLASS				= 0x00000001;
+	private final static int	ACTION_EXECUTE				= 0x00000002;
+	private final static int	ACTION_LIFECYCLE			= 0x00000004;
+	private final static int	ACTION_LISTENER				= 0x00000008;
+	private final static int	ACTION_METADATA				= 0x00000010;
+	private final static int	ACTION_RESOLVE				= 0x00000040;
+	private final static int	ACTION_RESOURCE				= 0x00000080;
+	private final static int	ACTION_STARTLEVEL			= 0x00000100;
+	private final static int	ACTION_EXTENSIONLIFECYCLE	= 0x00000200;
+	private final static int	ACTION_CONTEXT				= 0x00000400;
+	private final static int						ACTION_WEAVE				= 0x00000800;
+	private final static int	ACTION_ALL					= ACTION_CLASS
+																	| ACTION_EXECUTE
+																	| ACTION_LIFECYCLE
+																	| ACTION_LISTENER
+																	| ACTION_METADATA
+																	| ACTION_RESOLVE
+																	| ACTION_RESOURCE
+																	| ACTION_STARTLEVEL
+																	| ACTION_EXTENSIONLIFECYCLE
+																						| ACTION_CONTEXT
+																						| ACTION_WEAVE;
+	final static int						ACTION_NONE					= 0;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String		actions						= null;
+
+	/**
+	 * The actions mask.
+	 */
+	transient int							action_mask;
+
+	/**
+	 * If this AdminPermission was constructed with a filter, this holds a
+	 * Filter matching object used to evaluate the filter in implies.
+	 */
+	transient Filter						filter;
+
+	/**
+	 * The bundle governed by this AdminPermission - only used if filter == null
+	 */
+	transient final Bundle					bundle;
+
+	/**
+	 * This map holds the properties of the permission, used to match a filter
+	 * in implies. This is not initialized until necessary, and then cached in
+	 * this object.
+	 */
+	private transient volatile Map<String, Object>	properties;
+
+	/**
+	 * ThreadLocal used to determine if we have recursively called
+	 * getProperties.
+	 */
+	private static final ThreadLocal<Bundle>	recurse						= new ThreadLocal<Bundle>();
+
+	/**
+	 * Creates a new {@code AdminPermission} object that matches all
+	 * bundles and has all actions. Equivalent to AdminPermission("*","*");
+	 */
+	public AdminPermission() {
+		this(null, ACTION_ALL); 
+	}
+
+	/**
+	 * Create a new AdminPermission.
+	 * 
+	 * This constructor must only be used to create a permission that is going
+	 * to be checked.
+	 * <p>
+	 * Examples:
+	 * 
+	 * <pre>
+	 * (signer=\*,o=ACME,c=US)   
+	 * (&amp;(signer=\*,o=ACME,c=US)(name=com.acme.*)(location=http://www.acme.com/bundles/*))
+	 * (id&gt;=1)
+	 * </pre>
+	 * 
+	 * <p>
+	 * When a signer key is used within the filter expression the signer value
+	 * must escape the special filter chars ('*', '(', ')').
+	 * <p>
+	 * Null arguments are equivalent to "*".
+	 * 
+	 * @param filter A filter expression that can use signer, location, id, and
+	 *        name keys. A value of &quot;*&quot; or {@code null} matches all
+	 *        bundle. Filter attribute names are processed in a case sensitive
+	 *        manner.
+	 * @param actions {@code class}, {@code execute}, {@code extensionLifecycle}
+	 *        , {@code lifecycle}, {@code listener}, {@code metadata},
+	 *        {@code resolve} , {@code resource}, {@code startlevel},
+	 *        {@code context} or {@code weave}. A value of "*" or {@code null}
+	 *        indicates all actions.
+	 * @throws IllegalArgumentException If the filter has an invalid syntax.
+	 */
+	public AdminPermission(String filter, String actions) {
+		// arguments will be null if called from a PermissionInfo defined with
+		// no args
+		this(parseFilter(filter), parseActions(actions));
+	}
+
+	/**
+	 * Creates a new requested {@code AdminPermission} object to be used by the
+	 * code that must perform {@code checkPermission}. {@code AdminPermission}
+	 * objects created with this constructor cannot be added to an
+	 * {@code AdminPermission} permission collection.
+	 * 
+	 * @param bundle A bundle.
+	 * @param actions {@code class}, {@code execute}, {@code extensionLifecycle}
+	 *        , {@code lifecycle}, {@code listener}, {@code metadata},
+	 *        {@code resolve} , {@code resource}, {@code startlevel},
+	 *        {@code context}, {@code weave}. A value of "*" or {@code null}
+	 *        indicates all actions.
+	 * @since 1.3
+	 */
+	public AdminPermission(Bundle bundle, String actions) {
+		super(createName(bundle));
+		setTransients(null, parseActions(actions));
+		this.bundle = bundle;
+	}
+
+	/**
+	 * Create a permission name from a Bundle
+	 * 
+	 * @param bundle Bundle to use to create permission name.
+	 * @return permission name.
+	 */
+	private static String createName(Bundle bundle) {
+		if (bundle == null) {
+			throw new IllegalArgumentException("bundle must not be null");
+		}
+		StringBuffer sb = new StringBuffer("(id=");
+		sb.append(bundle.getBundleId());
+		sb.append(")");
+		return sb.toString();
+	}
+
+	/**
+	 * Package private constructor used by AdminPermissionCollection.
+	 * 
+	 * @param filter name filter or {@code null} for wildcard.
+	 * @param mask action mask
+	 */
+	AdminPermission(Filter filter, int mask) {
+		super((filter == null) ? "*" : filter.toString());
+		setTransients(filter, mask);
+		this.bundle = null;
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param filter Permission's filter or {@code null} for wildcard.
+	 * @param mask action mask
+	 */
+	private void setTransients(Filter filter, int mask) {
+		this.filter = filter;
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+		this.action_mask = mask;
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		if ((actions == null) || actions.equals("*")) {
+			return ACTION_ALL;
+		}
+	
+		boolean seencomma = false;
+	
+		int mask = ACTION_NONE;
+
+		char[] a = actions.toCharArray();
+	
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+	
+		while (i != -1) {
+			char c;
+	
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+	
+			// check for the known strings
+			int matchlen;
+	
+			if (i >= 4 && (a[i - 4] == 'c' || a[i - 4] == 'C')
+					&& (a[i - 3] == 'l' || a[i - 3] == 'L')
+					&& (a[i - 2] == 'a' || a[i - 2] == 'A')
+					&& (a[i - 1] == 's' || a[i - 1] == 'S')
+					&& (a[i] == 's' || a[i] == 'S')) {
+				matchlen = 5;
+				mask |= ACTION_CLASS | ACTION_RESOLVE;
+	
+			}
+			else
+				if (i >= 6 && (a[i - 6] == 'e' || a[i - 6] == 'E')
+						&& (a[i - 5] == 'x' || a[i - 5] == 'X')
+						&& (a[i - 4] == 'e' || a[i - 4] == 'E')
+						&& (a[i - 3] == 'c' || a[i - 3] == 'C')
+						&& (a[i - 2] == 'u' || a[i - 2] == 'U')
+						&& (a[i - 1] == 't' || a[i - 1] == 'T')
+						&& (a[i] == 'e' || a[i] == 'E')) {
+					matchlen = 7;
+					mask |= ACTION_EXECUTE | ACTION_RESOLVE;
+	
+				}
+				else
+					if (i >= 17 && (a[i - 17] == 'e' || a[i - 17] == 'E')
+							&& (a[i - 16] == 'x' || a[i - 16] == 'X')
+							&& (a[i - 15] == 't' || a[i - 15] == 'T')
+							&& (a[i - 14] == 'e' || a[i - 14] == 'E')
+							&& (a[i - 13] == 'n' || a[i - 13] == 'N')
+							&& (a[i - 12] == 's' || a[i - 12] == 'S')
+							&& (a[i - 11] == 'i' || a[i - 11] == 'I')
+							&& (a[i - 10] == 'o' || a[i - 10] == 'O')
+							&& (a[i - 9] == 'n' || a[i - 9] == 'N')
+							&& (a[i - 8] == 'l' || a[i - 8] == 'L')
+							&& (a[i - 7] == 'i' || a[i - 7] == 'I')
+							&& (a[i - 6] == 'f' || a[i - 6] == 'F')
+							&& (a[i - 5] == 'e' || a[i - 5] == 'E')
+							&& (a[i - 4] == 'c' || a[i - 4] == 'C')
+							&& (a[i - 3] == 'y' || a[i - 3] == 'Y')
+							&& (a[i - 2] == 'c' || a[i - 2] == 'C')
+							&& (a[i - 1] == 'l' || a[i - 1] == 'L')
+							&& (a[i] == 'e' || a[i] == 'E')) {
+						matchlen = 18;
+						mask |= ACTION_EXTENSIONLIFECYCLE;
+	
+					}
+					else
+						if (i >= 8 && (a[i - 8] == 'l' || a[i - 8] == 'L')
+								&& (a[i - 7] == 'i' || a[i - 7] == 'I')
+								&& (a[i - 6] == 'f' || a[i - 6] == 'F')
+								&& (a[i - 5] == 'e' || a[i - 5] == 'E')
+								&& (a[i - 4] == 'c' || a[i - 4] == 'C')
+								&& (a[i - 3] == 'y' || a[i - 3] == 'Y')
+								&& (a[i - 2] == 'c' || a[i - 2] == 'C')
+								&& (a[i - 1] == 'l' || a[i - 1] == 'L')
+								&& (a[i] == 'e' || a[i] == 'E')) {
+							matchlen = 9;
+							mask |= ACTION_LIFECYCLE;
+	
+						}
+						else
+							if (i >= 7 && (a[i - 7] == 'l' || a[i - 7] == 'L')
+									&& (a[i - 6] == 'i' || a[i - 6] == 'I')
+									&& (a[i - 5] == 's' || a[i - 5] == 'S')
+									&& (a[i - 4] == 't' || a[i - 4] == 'T')
+									&& (a[i - 3] == 'e' || a[i - 3] == 'E')
+									&& (a[i - 2] == 'n' || a[i - 2] == 'N')
+									&& (a[i - 1] == 'e' || a[i - 1] == 'E')
+									&& (a[i] == 'r' || a[i] == 'R')) {
+								matchlen = 8;
+								mask |= ACTION_LISTENER;
+	
+							}
+							else
+								if (i >= 7
+										&& (a[i - 7] == 'm' || a[i - 7] == 'M')
+										&& (a[i - 6] == 'e' || a[i - 6] == 'E')
+										&& (a[i - 5] == 't' || a[i - 5] == 'T')
+										&& (a[i - 4] == 'a' || a[i - 4] == 'A')
+										&& (a[i - 3] == 'd' || a[i - 3] == 'D')
+										&& (a[i - 2] == 'a' || a[i - 2] == 'A')
+										&& (a[i - 1] == 't' || a[i - 1] == 'T')
+										&& (a[i] == 'a' || a[i] == 'A')) {
+									matchlen = 8;
+									mask |= ACTION_METADATA;
+	
+								}
+								else
+									if (i >= 6
+											&& (a[i - 6] == 'r' || a[i - 6] == 'R')
+											&& (a[i - 5] == 'e' || a[i - 5] == 'E')
+											&& (a[i - 4] == 's' || a[i - 4] == 'S')
+											&& (a[i - 3] == 'o' || a[i - 3] == 'O')
+											&& (a[i - 2] == 'l' || a[i - 2] == 'L')
+											&& (a[i - 1] == 'v' || a[i - 1] == 'V')
+											&& (a[i] == 'e' || a[i] == 'E')) {
+										matchlen = 7;
+										mask |= ACTION_RESOLVE;
+	
+									}
+									else
+										if (i >= 7
+												&& (a[i - 7] == 'r' || a[i - 7] == 'R')
+												&& (a[i - 6] == 'e' || a[i - 6] == 'E')
+												&& (a[i - 5] == 's' || a[i - 5] == 'S')
+												&& (a[i - 4] == 'o' || a[i - 4] == 'O')
+												&& (a[i - 3] == 'u' || a[i - 3] == 'U')
+												&& (a[i - 2] == 'r' || a[i - 2] == 'R')
+												&& (a[i - 1] == 'c' || a[i - 1] == 'C')
+												&& (a[i] == 'e' || a[i] == 'E')) {
+											matchlen = 8;
+											mask |= ACTION_RESOURCE
+													| ACTION_RESOLVE;
+	
+										}
+										else
+											if (i >= 9
+													&& (a[i - 9] == 's' || a[i - 9] == 'S')
+													&& (a[i - 8] == 't' || a[i - 8] == 'T')
+													&& (a[i - 7] == 'a' || a[i - 7] == 'A')
+													&& (a[i - 6] == 'r' || a[i - 6] == 'R')
+													&& (a[i - 5] == 't' || a[i - 5] == 'T')
+													&& (a[i - 4] == 'l' || a[i - 4] == 'L')
+													&& (a[i - 3] == 'e' || a[i - 3] == 'E')
+													&& (a[i - 2] == 'v' || a[i - 2] == 'V')
+													&& (a[i - 1] == 'e' || a[i - 1] == 'E')
+													&& (a[i] == 'l' || a[i] == 'L')) {
+												matchlen = 10;
+												mask |= ACTION_STARTLEVEL;
+	
+											}
+											else
+												if (i >= 6
+														&& (a[i - 6] == 'c' || a[i - 6] == 'C')
+														&& (a[i - 5] == 'o' || a[i - 5] == 'O')
+														&& (a[i - 4] == 'n' || a[i - 4] == 'N')
+														&& (a[i - 3] == 't' || a[i - 3] == 'T')
+														&& (a[i - 2] == 'e' || a[i - 2] == 'E')
+														&& (a[i - 1] == 'x' || a[i - 1] == 'X')
+														&& (a[i] == 't' || a[i] == 'T')) {
+													matchlen = 7;
+													mask |= ACTION_CONTEXT;
+	
+												}
+												else
+													if (i >= 4
+															&& (a[i - 4] == 'w' || a[i - 4] == 'W')
+															&& (a[i - 3] == 'e' || a[i - 3] == 'E')
+															&& (a[i - 2] == 'a' || a[i - 2] == 'A')
+															&& (a[i - 1] == 'v' || a[i - 1] == 'V')
+															&& (a[i] == 'e' || a[i] == 'E')) {
+														matchlen = 5;
+														mask |= ACTION_WEAVE;
+
+													}
+													else
+														if (i >= 0
+																&& (a[i] == '*')) {
+															matchlen = 1;
+															mask |= ACTION_ALL;
+
+														}
+														else {
+															// parse error
+															throw new IllegalArgumentException(
+																	"invalid permission: "
+																			+ actions);
+														}
+	
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfstartlevel". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+						/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions); 
+				}
+				i--;
+			}
+	
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+	
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid permission: " + 
+					actions);
+		}
+	
+		return mask;
+	}
+
+	/**
+	 * Parse filter string into a Filter object.
+	 * 
+	 * @param filterString The filter string to parse.
+	 * @return a Filter for this bundle. If the specified filterString is
+	 *         {@code null} or equals "*", then {@code null} is
+	 *         returned to indicate a wildcard.
+	 * @throws IllegalArgumentException If the filter syntax is invalid.
+	 */
+	private static Filter parseFilter(String filterString) {
+		if (filterString == null) {
+			return null;
+		}
+		filterString = filterString.trim();
+		if (filterString.equals("*")) {
+			return null;
+		}
+		
+		try {
+			return FrameworkUtil.createFilter(filterString);
+		}
+		catch (InvalidSyntaxException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid filter");
+			iae.initCause(e);
+			throw iae;
+		}
+	}
+
+	/**
+	 * Determines if the specified permission is implied by this object. This
+	 * method throws an exception if the specified permission was not
+	 * constructed with a bundle.
+	 * 
+	 * <p>
+	 * This method returns {@code true} if the specified permission is an
+	 * AdminPermission AND
+	 * <ul>
+	 * <li>this object's filter matches the specified permission's bundle ID,
+	 * bundle symbolic name, bundle location and bundle signer distinguished
+	 * name chain OR</li>
+	 * <li>this object's filter is "*"</li>
+	 * </ul>
+	 * AND this object's actions include all of the specified permission's
+	 * actions.
+	 * <p>
+	 * Special case: if the specified permission was constructed with "*"
+	 * filter, then this method returns {@code true} if this object's
+	 * filter is "*" and this object's actions include all of the specified
+	 * permission's actions
+	 * 
+	 * @param p The requested permission.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof AdminPermission)) {
+			return false;
+		}
+		AdminPermission requested = (AdminPermission) p;
+		if (bundle != null) {
+			return false;
+		}
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		return implies0(requested, ACTION_NONE);
+	}
+
+	/**
+	 * Internal implies method. Used by the implies and the permission
+	 * collection implies methods.
+	 * 
+	 * @param requested The requested AdminPermision which has already be
+	 *        validated as a proper argument. The requested AdminPermission must
+	 *        not have a filter expression.
+	 * @param effective The effective actions with which to start.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	boolean implies0(AdminPermission requested, int effective) {
+		/* check actions first - much faster */
+		effective |= action_mask;
+		final int desired = requested.action_mask;
+		if ((effective & desired) != desired) {
+			return false;
+		}
+	
+		/* Get our filter */
+		Filter f = filter;
+		if (f == null) {
+			// it's "*"
+			return true;
+		}
+		/* is requested a wildcard filter? */
+		if (requested.bundle == null) {
+			return false;
+		}
+		Map<String, Object> requestedProperties = requested
+				.getProperties();
+		if (requestedProperties == null) {
+			/*
+			 * If the requested properties are null, then we have detected a
+			 * recursion getting the bundle location. So we return true to
+			 * permit the bundle location request in the AdminPermission check
+			 * up the stack to succeed.
+			 */
+			return true;
+		}
+		return f.matches(requestedProperties);
+	}
+
+	/**
+	 * Returns the canonical string representation of the
+	 * {@code AdminPermission} actions.
+	 * 
+	 * <p>
+	 * Always returns present {@code AdminPermission} actions in the following
+	 * order: {@code class}, {@code execute}, {@code extensionLifecycle},
+	 * {@code lifecycle}, {@code listener}, {@code metadata}, {@code resolve},
+	 * {@code resource}, {@code startlevel}, {@code context}, {@code weave}.
+	 * 
+	 * @return Canonical string representation of the {@code AdminPermission}
+	 *         actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			StringBuffer sb = new StringBuffer();
+	
+			int mask = action_mask;
+			if ((mask & ACTION_CLASS) == ACTION_CLASS) {
+				sb.append(CLASS);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_EXECUTE) == ACTION_EXECUTE) {
+				sb.append(EXECUTE);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_EXTENSIONLIFECYCLE) == ACTION_EXTENSIONLIFECYCLE) {
+				sb.append(EXTENSIONLIFECYCLE);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_LIFECYCLE) == ACTION_LIFECYCLE) {
+				sb.append(LIFECYCLE);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_LISTENER) == ACTION_LISTENER) {
+				sb.append(LISTENER);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_METADATA) == ACTION_METADATA) {
+				sb.append(METADATA);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_RESOLVE) == ACTION_RESOLVE) {
+				sb.append(RESOLVE);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_RESOURCE) == ACTION_RESOURCE) {
+				sb.append(RESOURCE);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_STARTLEVEL) == ACTION_STARTLEVEL) {
+				sb.append(STARTLEVEL);
+				sb.append(',');
+			}
+	
+			if ((mask & ACTION_CONTEXT) == ACTION_CONTEXT) {
+				sb.append(CONTEXT);
+				sb.append(',');
+			}
+
+			if ((mask & ACTION_WEAVE) == ACTION_WEAVE) {
+				sb.append(WEAVE);
+				sb.append(',');
+			}
+	
+			// remove trailing comma
+			if (sb.length() > 0) {
+				sb.setLength(sb.length() - 1);
+			}
+	
+			actions = result = sb.toString();
+		}
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object suitable for
+	 * storing {@code AdminPermission}s.
+	 * 
+	 * @return A new {@code PermissionCollection} object.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new AdminPermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two {@code AdminPermission} objects.
+	 * 
+	 * @param obj The object being compared for equality with this object.
+	 * @return {@code true} if {@code obj} is equivalent to this
+	 *         {@code AdminPermission}; {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof AdminPermission)) {
+			return false;
+		}
+
+		AdminPermission ap = (AdminPermission) obj;
+
+		return (action_mask == ap.action_mask)
+				&& ((bundle == ap.bundle) || ((bundle != null) && bundle
+						.equals(ap.bundle)))
+				&& (filter == null ? ap.filter == null : filter
+						.equals(ap.filter));
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return Hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		if (bundle != null) {
+			h = 31 * h + bundle.hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of this permission object to a
+	 * stream. The actions are serialized, and the superclass takes care of the
+	 * name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		if (bundle != null) {
+			throw new NotSerializableException("cannot serialize");
+		}
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of this permission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the data, then initialize the transients
+		s.defaultReadObject();
+		setTransients(parseFilter(getName()), parseActions(actions));
+	}
+
+	/**
+	 * Called by {@code implies0} on an AdminPermission which was constructed
+	 * with a Bundle. This method loads a map with the filter-matchable
+	 * properties of this bundle. The map is cached so this lookup only happens
+	 * once.
+	 * 
+	 * This method should only be called on an AdminPermission which was
+	 * constructed with a bundle
+	 * 
+	 * @return a map of properties for this bundle
+	 */
+	private Map<String, Object> getProperties() {
+		Map<String, Object> result = properties;
+		if (result != null) {
+			return result;
+		}
+		/*
+		 * We may have recursed here due to the Bundle.getLocation call in the
+		 * doPrivileged below. If this is the case, return null to allow implies
+		 * to return true.
+		 */
+		final Object mark = recurse.get();
+		if (mark == bundle) {
+			return null;
+		}
+		recurse.set(bundle);
+		try {
+			final Map<String, Object> map = new HashMap<String, Object>(
+					4);
+			AccessController.doPrivileged(new PrivilegedAction<Object>() {
+				public Object run() {
+					map.put("id", new Long(bundle.getBundleId()));
+					map.put("location", bundle.getLocation());
+					String name = bundle.getSymbolicName();
+					if (name != null) {
+						map.put("name", name);
+					}
+					SignerProperty signer = new SignerProperty(bundle);
+					if (signer.isBundleSigned()) {
+						map.put("signer", signer);
+					}
+					return null;
+				}
+			});
+			return properties = map;
+		}
+		finally {
+			recurse.set(null);
+		}
+	}
+}
+
+/**
+ * Stores a collection of {@code AdminPermission}s.
+ */
+final class AdminPermissionCollection extends PermissionCollection {
+	private static final long	serialVersionUID	= 3906372644575328048L;
+	/**
+	 * Collection of permissions.
+	 * 
+	 * @GuardedBy this
+	 */
+	private transient Map<String, AdminPermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean				all_allowed;
+
+	/**
+	 * Create an empty AdminPermissions object.
+	 * 
+	 */
+	public AdminPermissionCollection() {
+		permissions = new HashMap<String, AdminPermission>();
+	}
+
+	/**
+	 * Adds a permission to this permission collection.
+	 * 
+	 * @param permission The {@code AdminPermission} object to add.
+	 * @throws IllegalArgumentException If the specified permission is not an
+	 *         {@code AdminPermission} instance or was constructed with a
+	 *         Bundle object.
+	 * @throws SecurityException If this {@code AdminPermissionCollection}
+	 *         object has been marked read-only.
+	 */
+	public void add(Permission permission) {
+		if (!(permission instanceof AdminPermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection"); 
+		}
+		final AdminPermission ap = (AdminPermission) permission;
+		if (ap.bundle != null) {
+			throw new IllegalArgumentException("cannot add to collection: "
+					+ ap);
+		}
+		final String name = ap.getName();
+		synchronized (this) {
+			Map<String, AdminPermission> pc = permissions;
+			AdminPermission existing = pc.get(name);
+			if (existing != null) {
+				int oldMask = existing.action_mask;
+				int newMask = ap.action_mask;
+
+				if (oldMask != newMask) {
+					pc.put(name, new AdminPermission(existing.filter, oldMask
+							| newMask));
+				}
+			}
+			else {
+				pc.put(name, ap);
+			}
+			if (!all_allowed) {
+				if (name.equals("*")) {
+					all_allowed = true;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Determines if the specified permissions implies the permissions expressed
+	 * in {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare with the
+	 *        {@code AdminPermission} objects in this collection.
+	 * @return {@code true} if {@code permission} is implied by an
+	 *         {@code AdminPermission} in this collection,
+	 *         {@code false} otherwise.
+	 */
+	public boolean implies(Permission permission) {
+		if (!(permission instanceof AdminPermission)) {
+			return false;
+		}
+
+		AdminPermission requested = (AdminPermission) permission;
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		int effective = AdminPermission.ACTION_NONE;
+		Collection<AdminPermission> perms;
+		synchronized (this) {
+			Map<String, AdminPermission> pc = permissions;
+			// short circuit if the "*" Permission was added
+			if (all_allowed) {
+				AdminPermission ap = pc.get("*");
+				if (ap != null) {
+					effective |= ap.action_mask;
+					final int desired = requested.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			perms = pc.values();
+		}
+
+		// just iterate one by one
+		for (AdminPermission perm : perms) {
+			if (perm.implies0(requested, effective)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns an enumeration of all {@code AdminPermission} objects in the
+	 * container.
+	 * 
+	 * @return Enumeration of all {@code AdminPermission} objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		return Collections.enumeration(all);
+	}
+	
+	/* serialization logic */
+    private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", Hashtable.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE)			};
+    
+    private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		Hashtable<String, AdminPermission> hashtable = new Hashtable<String, AdminPermission>(
+				permissions);
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", hashtable);
+		pfields.put("all_allowed", all_allowed);
+		out.writeFields();
+	}
+    
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException,
+			ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		Hashtable<String, AdminPermission> hashtable = (Hashtable<String, AdminPermission>) gfields
+				.get("permissions", null);
+		permissions = new HashMap<String, AdminPermission>(hashtable);
+		all_allowed = gfields.get("all_allowed", false);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/AllServiceListener.java b/main/src/main/java/org/osgi/framework/AllServiceListener.java
new file mode 100644
index 0000000000..9874a4b202
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/AllServiceListener.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A {@code ServiceEvent} listener that does not filter based upon
+ * package wiring. {@code AllServiceListener} is a listener interface
+ * that may be implemented by a bundle developer. When a
+ * {@code ServiceEvent} is fired, it is synchronously delivered to an
+ * {@code AllServiceListener}. The Framework may deliver
+ * {@code ServiceEvent} objects to an {@code AllServiceListener}
+ * out of order and may concurrently call and/or reenter an
+ * {@code AllServiceListener}.
+ * <p>
+ * An {@code AllServiceListener} object is registered with the Framework
+ * using the {@code BundleContext.addServiceListener} method.
+ * {@code AllServiceListener} objects are called with a
+ * {@code ServiceEvent} object when a service is registered, modified, or
+ * is in the process of unregistering.
+ * 
+ * <p>
+ * {@code ServiceEvent} object delivery to
+ * {@code AllServiceListener} objects is filtered by the filter specified
+ * when the listener was registered. If the Java Runtime Environment supports
+ * permissions, then additional filtering is done. {@code ServiceEvent}
+ * objects are only delivered to the listener if the bundle which defines the
+ * listener object's class has the appropriate {@code ServicePermission}
+ * to get the service using at least one of the named classes under which the
+ * service was registered.
+ * 
+ * <p>
+ * Unlike normal {@code ServiceListener} objects,
+ * {@code AllServiceListener} objects receive all
+ * {@code ServiceEvent} objects regardless of whether the package source
+ * of the listening bundle is equal to the package source of the bundle that
+ * registered the service. This means that the listener may not be able to cast
+ * the service object to any of its corresponding service interfaces if the
+ * service object is retrieved.
+ * 
+ * @see ServiceEvent
+ * @see ServicePermission
+ * @ThreadSafe
+ * @since 1.3
+ * @version $Id: 35cee8a49e89b7b222aa3f85e1af0b4a4b550ce6 $
+ */
+
+public interface AllServiceListener extends ServiceListener {
+	// This is a marker interface
+}
diff --git a/main/src/main/java/org/osgi/framework/Bundle.java b/main/src/main/java/org/osgi/framework/Bundle.java
new file mode 100644
index 0000000000..8f4002c9d0
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/Bundle.java
@@ -0,0 +1,1242 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.security.cert.X509Certificate;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+
+import org.osgi.framework.wiring.FrameworkWiring;
+
+/**
+ * An installed bundle in the Framework.
+ * 
+ * <p>
+ * A {@code Bundle} object is the access point to define the lifecycle of an
+ * installed bundle. Each bundle installed in the OSGi environment must have an
+ * associated {@code Bundle} object.
+ * 
+ * <p>
+ * A bundle must have a unique identity, a {@code long}, chosen by the
+ * Framework. This identity must not change during the lifecycle of a bundle,
+ * even when the bundle is updated. Uninstalling and then reinstalling the
+ * bundle must create a new unique identity.
+ * 
+ * <p>
+ * A bundle can be in one of six states:
+ * <ul>
+ * <li>{@link #UNINSTALLED}
+ * <li>{@link #INSTALLED}
+ * <li>{@link #RESOLVED}
+ * <li>{@link #STARTING}
+ * <li>{@link #STOPPING}
+ * <li>{@link #ACTIVE}
+ * </ul>
+ * <p>
+ * Values assigned to these states have no specified ordering; they represent
+ * bit values that may be ORed together to determine if a bundle is in one of
+ * the valid states.
+ * 
+ * <p>
+ * A bundle should only have active threads of execution when its state is one
+ * of {@code STARTING},{@code ACTIVE}, or {@code STOPPING}. An {@code
+ * UNINSTALLED} bundle can not be set to another state; it is a zombie and can
+ * only be reached because references are kept somewhere.
+ * 
+ * <p>
+ * The Framework is the only entity that is allowed to create {@code Bundle}
+ * objects, and these objects are only valid within the Framework that created
+ * them.
+ * 
+ * <p>
+ * Bundles have a natural ordering such that if two {@code Bundle}s have the
+ * same {@link #getBundleId() bundle id} they are equal. A {@code Bundle} is
+ * less than another {@code Bundle} if it has a lower {@link #getBundleId()
+ * bundle id} and is greater if it has a higher bundle id.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 239108e8d54ff493587b9cdfe1688bdefc5a714c $
+ */
+public interface Bundle extends Comparable<Bundle> {
+	/**
+	 * The bundle is uninstalled and may not be used.
+	 * 
+	 * <p>
+	 * The {@code UNINSTALLED} state is only visible after a bundle is
+	 * uninstalled; the bundle is in an unusable state but references to the
+	 * {@code Bundle} object may still be available and used for introspection.
+	 * <p>
+	 * The value of {@code UNINSTALLED} is 0x00000001.
+	 */
+	int	UNINSTALLED				= 0x00000001;
+
+	/**
+	 * The bundle is installed but not yet resolved.
+	 * 
+	 * <p>
+	 * A bundle is in the {@code INSTALLED} state when it has been installed in
+	 * the Framework but is not or cannot be resolved.
+	 * <p>
+	 * This state is visible if the bundle's code dependencies are not resolved.
+	 * The Framework may attempt to resolve an {@code INSTALLED} bundle's code
+	 * dependencies and move the bundle to the {@code RESOLVED} state.
+	 * <p>
+	 * The value of {@code INSTALLED} is 0x00000002.
+	 */
+	int	INSTALLED				= 0x00000002;
+
+	/**
+	 * The bundle is resolved and is able to be started.
+	 * 
+	 * <p>
+	 * A bundle is in the {@code RESOLVED} state when the Framework has
+	 * successfully resolved the bundle's code dependencies. These dependencies
+	 * include:
+	 * <ul>
+	 * <li>The bundle's class path from its {@link Constants#BUNDLE_CLASSPATH}
+	 * Manifest header.
+	 * <li>The bundle's package dependencies from its
+	 * {@link Constants#EXPORT_PACKAGE} and {@link Constants#IMPORT_PACKAGE}
+	 * Manifest headers.
+	 * <li>The bundle's required bundle dependencies from its
+	 * {@link Constants#REQUIRE_BUNDLE} Manifest header.
+	 * <li>A fragment bundle's host dependency from its
+	 * {@link Constants#FRAGMENT_HOST} Manifest header.
+	 * </ul>
+	 * <p>
+	 * Note that the bundle is not active yet. A bundle must be put in the
+	 * {@code RESOLVED} state before it can be started. The Framework may
+	 * attempt to resolve a bundle at any time.
+	 * <p>
+	 * The value of {@code RESOLVED} is 0x00000004.
+	 */
+	int	RESOLVED				= 0x00000004;
+
+	/**
+	 * The bundle is in the process of starting.
+	 * 
+	 * <p>
+	 * A bundle is in the {@code STARTING} state when its {@link #start(int)
+	 * start} method is active. A bundle must be in this state when the bundle's
+	 * {@link BundleActivator#start} is called. If the {@code
+	 * BundleActivator.start} method completes without exception, then the
+	 * bundle has successfully started and must move to the {@code ACTIVE}
+	 * state.
+	 * <p>
+	 * If the bundle has a {@link Constants#ACTIVATION_LAZY lazy activation
+	 * policy}, then the bundle may remain in this state for some time until the
+	 * activation is triggered.
+	 * <p>
+	 * The value of {@code STARTING} is 0x00000008.
+	 */
+	int	STARTING				= 0x00000008;
+
+	/**
+	 * The bundle is in the process of stopping.
+	 * 
+	 * <p>
+	 * A bundle is in the {@code STOPPING} state when its {@link #stop(int)
+	 * stop} method is active. A bundle must be in this state when the bundle's
+	 * {@link BundleActivator#stop} method is called. When the {@code
+	 * BundleActivator.stop} method completes the bundle is stopped and must
+	 * move to the {@code RESOLVED} state.
+	 * <p>
+	 * The value of {@code STOPPING} is 0x00000010.
+	 */
+	int	STOPPING				= 0x00000010;
+
+	/**
+	 * The bundle is now running.
+	 * 
+	 * <p>
+	 * A bundle is in the {@code ACTIVE} state when it has been successfully
+	 * started and activated.
+	 * <p>
+	 * The value of {@code ACTIVE} is 0x00000020.
+	 */
+	int	ACTIVE					= 0x00000020;
+
+	/**
+	 * The bundle start operation is transient and the persistent autostart
+	 * setting of the bundle is not modified.
+	 * 
+	 * <p>
+	 * This bit may be set when calling {@link #start(int)} to notify the
+	 * framework that the autostart setting of the bundle must not be modified.
+	 * If this bit is not set, then the autostart setting of the bundle is
+	 * modified.
+	 * 
+	 * @since 1.4
+	 * @see #start(int)
+	 */
+	int	START_TRANSIENT			= 0x00000001;
+
+	/**
+	 * The bundle start operation must activate the bundle according to the
+	 * bundle's declared {@link Constants#BUNDLE_ACTIVATIONPOLICY activation
+	 * policy}.
+	 * 
+	 * <p>
+	 * This bit may be set when calling {@link #start(int)} to notify the
+	 * framework that the bundle must be activated using the bundle's declared
+	 * activation policy.
+	 * 
+	 * @since 1.4
+	 * @see Constants#BUNDLE_ACTIVATIONPOLICY
+	 * @see #start(int)
+	 */
+	int	START_ACTIVATION_POLICY	= 0x00000002;
+
+	/**
+	 * The bundle stop is transient and the persistent autostart setting of the
+	 * bundle is not modified.
+	 * 
+	 * <p>
+	 * This bit may be set when calling {@link #stop(int)} to notify the
+	 * framework that the autostart setting of the bundle must not be modified.
+	 * If this bit is not set, then the autostart setting of the bundle is
+	 * modified.
+	 * 
+	 * @since 1.4
+	 * @see #stop(int)
+	 */
+	int	STOP_TRANSIENT			= 0x00000001;
+
+	/**
+	 * Request that all certificates used to sign the bundle be returned.
+	 * 
+	 * @since 1.5
+	 * @see #getSignerCertificates(int)
+	 */
+	int	SIGNERS_ALL				= 1;
+
+	/**
+	 * Request that only certificates used to sign the bundle that are trusted
+	 * by the framework be returned.
+	 * 
+	 * @since 1.5
+	 * @see #getSignerCertificates(int)
+	 */
+	int	SIGNERS_TRUSTED			= 2;
+
+	/**
+	 * Returns this bundle's current state.
+	 * 
+	 * <p>
+	 * A bundle can be in only one state at any time.
+	 * 
+	 * @return An element of {@code UNINSTALLED},{@code INSTALLED},
+	 *         {@code RESOLVED}, {@code STARTING}, {@code STOPPING},
+	 *         {@code ACTIVE}.
+	 */
+	int getState();
+
+	/**
+	 * Starts this bundle.
+	 * 
+	 * <p>
+	 * If this bundle's state is {@code UNINSTALLED} then an
+	 * {@code IllegalStateException} is thrown.
+	 * <p>
+	 * If the current start level is less than this bundle's start level:
+	 * <ul>
+	 * <li>If the {@link #START_TRANSIENT} option is set, then a
+	 * {@code BundleException} is thrown indicating this bundle cannot be
+	 * started due to the Framework's current start level.
+	 * 
+	 * <li>Otherwise, the Framework must set this bundle's persistent autostart
+	 * setting to <em>Started with declared activation</em> if the
+	 * {@link #START_ACTIVATION_POLICY} option is set or
+	 * <em>Started with eager activation</em> if not set.
+	 * </ul>
+	 * <p>
+	 * When the Framework's current start level becomes equal to or more than
+	 * this bundle's start level, this bundle will be started.
+	 * <p>
+	 * Otherwise, the following steps are required to start this bundle:
+	 * <ol>
+	 * <li>If this bundle is in the process of being activated or deactivated
+	 * then this method must wait for activation or deactivation to complete
+	 * before continuing. If this does not occur in a reasonable time, a
+	 * {@code BundleException} is thrown to indicate this bundle was unable to
+	 * be started.
+	 * 
+	 * <li>If this bundle's state is {@code ACTIVE} then this method returns
+	 * immediately.
+	 * 
+	 * <li>If the {@link #START_TRANSIENT} option is not set then set this
+	 * bundle's autostart setting to <em>Started with declared activation</em>
+	 * if the {@link #START_ACTIVATION_POLICY} option is set or
+	 * <em>Started with eager activation</em> if not set. When the Framework is
+	 * restarted and this bundle's autostart setting is not <em>Stopped</em>,
+	 * this bundle must be automatically started.
+	 * 
+	 * <li>If this bundle's state is not {@code RESOLVED}, an attempt is made to
+	 * resolve this bundle. If the Framework cannot resolve this bundle, a
+	 * {@code BundleException} is thrown.
+	 * 
+	 * <li>If the {@link #START_ACTIVATION_POLICY} option is set and this
+	 * bundle's declared activation policy is {@link Constants#ACTIVATION_LAZY
+	 * lazy} then:
+	 * <ul>
+	 * <li>If this bundle's state is {@code STARTING} then this method returns
+	 * immediately.
+	 * <li>This bundle's state is set to {@code STARTING}.
+	 * <li>A bundle event of type {@link BundleEvent#LAZY_ACTIVATION} is fired.
+	 * <li>This method returns immediately and the remaining steps will be
+	 * followed when this bundle's activation is later triggered.
+	 * </ul>
+	 * <i></i>
+	 * <li>This bundle's state is set to {@code STARTING}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#STARTING} is fired.
+	 * 
+	 * <li>The {@link BundleActivator#start} method of this bundle's
+	 * {@code BundleActivator}, if one is specified, is called. If the
+	 * {@code BundleActivator} is invalid or throws an exception then:
+	 * <ul>
+	 * <li>This bundle's state is set to {@code STOPPING}.
+	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
+	 * <li>Any services registered by this bundle must be unregistered.
+	 * <li>Any services used by this bundle must be released.
+	 * <li>Any listeners registered by this bundle must be removed.
+	 * <li>This bundle's state is set to {@code RESOLVED}.
+	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
+	 * <li>A {@code BundleException} is then thrown.
+	 * </ul>
+	 * <i></i>
+	 * <li>If this bundle's state is {@code UNINSTALLED}, because this bundle
+	 * was uninstalled while the {@code BundleActivator.start} method was
+	 * running, a {@code BundleException} is thrown.
+	 * 
+	 * <li>This bundle's state is set to {@code ACTIVE}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#STARTED} is fired.
+	 * </ol>
+	 * 
+	 * <b>Preconditions </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code INSTALLED}, {@code RESOLVED}
+	 * &#x007D; or &#x007B; {@code INSTALLED}, {@code RESOLVED},
+	 * {@code STARTING} &#x007D; if this bundle has a lazy activation policy.
+	 * </ul>
+	 * <b>Postconditions, no exceptions thrown </b>
+	 * <ul>
+	 * <li>Bundle autostart setting is modified unless the
+	 * {@link #START_TRANSIENT} option was set.
+	 * <li>{@code getState()} in &#x007B; {@code ACTIVE} &#x007D; unless the
+	 * lazy activation policy was used.
+	 * <li>{@code BundleActivator.start()} has been called and did not throw an
+	 * exception unless the lazy activation policy was used.
+	 * </ul>
+	 * <b>Postconditions, when an exception is thrown </b>
+	 * <ul>
+	 * <li>Depending on when the exception occurred, bundle autostart setting is
+	 * modified unless the {@link #START_TRANSIENT} option was set.
+	 * <li>{@code getState()} not in &#x007B; {@code STARTING}, {@code ACTIVE}
+	 * &#x007D;.
+	 * </ul>
+	 * 
+	 * @param options The options for starting this bundle. See
+	 *        {@link #START_TRANSIENT} and {@link #START_ACTIVATION_POLICY}. The
+	 *        Framework must ignore unrecognized options.
+	 * @throws BundleException If this bundle could not be started.
+	 *         BundleException types thrown by this method include:
+	 *         {@link BundleException#START_TRANSIENT_ERROR},
+	 *         {@link BundleException#NATIVECODE_ERROR},
+	 *         {@link BundleException#RESOLVE_ERROR},
+	 *         {@link BundleException#STATECHANGE_ERROR}, and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @since 1.4
+	 */
+	void start(int options) throws BundleException;
+
+	/**
+	 * Starts this bundle with no options.
+	 * 
+	 * <p>
+	 * This method performs the same function as calling {@code start(0)}.
+	 * 
+	 * @throws BundleException If this bundle could not be started.
+	 *         BundleException types thrown by this method include:
+	 *         {@link BundleException#NATIVECODE_ERROR},
+	 *         {@link BundleException#RESOLVE_ERROR},
+	 *         {@link BundleException#STATECHANGE_ERROR}, and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #start(int)
+	 */
+	void start() throws BundleException;
+
+	/**
+	 * Stops this bundle.
+	 * 
+	 * <p>
+	 * The following steps are required to stop a bundle:
+	 * <ol>
+	 * <li>If this bundle's state is {@code UNINSTALLED} then an
+	 * {@code IllegalStateException} is thrown.
+	 * 
+	 * <li>If this bundle is in the process of being activated or deactivated
+	 * then this method must wait for activation or deactivation to complete
+	 * before continuing. If this does not occur in a reasonable time, a
+	 * {@code BundleException} is thrown to indicate this bundle was unable to
+	 * be stopped.
+	 * <li>If the {@link #STOP_TRANSIENT} option is not set then then set this
+	 * bundle's persistent autostart setting to to <em>Stopped</em>. When the
+	 * Framework is restarted and this bundle's autostart setting is
+	 * <em>Stopped</em>, this bundle must not be automatically started.
+	 * 
+	 * <li>If this bundle's state is not {@code STARTING} or {@code ACTIVE} then
+	 * this method returns immediately.
+	 * 
+	 * <li>This bundle's state is set to {@code STOPPING}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#STOPPING} is fired.
+	 * 
+	 * <li>If this bundle's state was {@code ACTIVE} prior to setting the state
+	 * to {@code STOPPING}, the {@link BundleActivator#stop} method of this
+	 * bundle's {@code BundleActivator}, if one is specified, is called. If that
+	 * method throws an exception, this method must continue to stop this bundle
+	 * and a {@code BundleException} must be thrown after completion of the
+	 * remaining steps.
+	 * 
+	 * <li>Any services registered by this bundle must be unregistered.
+	 * <li>Any services used by this bundle must be released.
+	 * <li>Any listeners registered by this bundle must be removed.
+	 * 
+	 * <li>If this bundle's state is {@code UNINSTALLED}, because this bundle
+	 * was uninstalled while the {@code BundleActivator.stop} method was
+	 * running, a {@code BundleException} must be thrown.
+	 * 
+	 * <li>This bundle's state is set to {@code RESOLVED}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#STOPPED} is fired.
+	 * </ol>
+	 * 
+	 * <b>Preconditions </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code ACTIVE} &#x007D;.
+	 * </ul>
+	 * <b>Postconditions, no exceptions thrown </b>
+	 * <ul>
+	 * <li>Bundle autostart setting is modified unless the
+	 * {@link #STOP_TRANSIENT} option was set.
+	 * <li>{@code getState()} not in &#x007B; {@code ACTIVE}, {@code STOPPING}
+	 * &#x007D;.
+	 * <li>{@code BundleActivator.stop} has been called and did not throw an
+	 * exception.
+	 * </ul>
+	 * <b>Postconditions, when an exception is thrown </b>
+	 * <ul>
+	 * <li>Bundle autostart setting is modified unless the
+	 * {@link #STOP_TRANSIENT} option was set.
+	 * </ul>
+	 * 
+	 * @param options The options for stopping this bundle. See
+	 *        {@link #STOP_TRANSIENT}. The Framework must ignore unrecognized
+	 *        options.
+	 * @throws BundleException BundleException types thrown by this method
+	 *         include: {@link BundleException#STATECHANGE_ERROR} and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @since 1.4
+	 */
+	void stop(int options) throws BundleException;
+
+	/**
+	 * Stops this bundle with no options.
+	 * 
+	 * <p>
+	 * This method performs the same function as calling {@code stop(0)}.
+	 * 
+	 * @throws BundleException BundleException types thrown by this method
+	 *         include: {@link BundleException#STATECHANGE_ERROR} and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #start(int)
+	 */
+	void stop() throws BundleException;
+
+	/**
+	 * Updates this bundle from an {@code InputStream}.
+	 * 
+	 * <p>
+	 * If the specified {@code InputStream} is {@code null}, the Framework must
+	 * create the {@code InputStream} from which to read the updated bundle by
+	 * interpreting, in an implementation dependent manner, this bundle's
+	 * {@link Constants#BUNDLE_UPDATELOCATION Bundle-UpdateLocation} Manifest
+	 * header, if present, or this bundle's original location.
+	 * 
+	 * <p>
+	 * If this bundle's state is {@code ACTIVE}, it must be stopped before the
+	 * update and started after the update successfully completes.
+	 * 
+	 * <p>
+	 * If this bundle has exported any packages that are imported by another
+	 * bundle, these packages must remain exported until the
+	 * {@link FrameworkWiring#refreshBundles(java.util.Collection, FrameworkListener...)
+	 * FrameworkWiring.refreshBundles} method has been has been called or the
+	 * Framework is relaunched.
+	 * 
+	 * <p>
+	 * The following steps are required to update a bundle:
+	 * <ol>
+	 * <li>If this bundle's state is {@code UNINSTALLED} then an
+	 * {@code IllegalStateException} is thrown.
+	 * 
+	 * <li>If this bundle's state is {@code ACTIVE}, {@code STARTING} or
+	 * {@code STOPPING}, this bundle is stopped as described in the
+	 * {@code Bundle.stop} method. If {@code Bundle.stop} throws an exception,
+	 * the exception is rethrown terminating the update.
+	 * 
+	 * <li>The updated version of this bundle is read from the input stream and
+	 * installed. If the Framework is unable to install the updated version of
+	 * this bundle, the original version of this bundle must be restored and a
+	 * {@code BundleException} must be thrown after completion of the remaining
+	 * steps.
+	 * 
+	 * <li>This bundle's state is set to {@code INSTALLED}.
+	 * 
+	 * <li>If the updated version of this bundle was successfully installed, a
+	 * bundle event of type {@link BundleEvent#UPDATED} is fired.
+	 * 
+	 * <li>If this bundle's state was originally {@code ACTIVE}, the updated
+	 * bundle is started as described in the {@code Bundle.start} method. If
+	 * {@code Bundle.start} throws an exception, a Framework event of type
+	 * {@link FrameworkEvent#ERROR} is fired containing the exception.
+	 * </ol>
+	 * 
+	 * <b>Preconditions </b>
+	 * <ul>
+	 * <li>{@code getState()} not in &#x007B; {@code UNINSTALLED} &#x007D;.
+	 * </ul>
+	 * <b>Postconditions, no exceptions thrown </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code INSTALLED}, {@code RESOLVED},
+	 * {@code ACTIVE} &#x007D;.
+	 * <li>This bundle has been updated.
+	 * </ul>
+	 * <b>Postconditions, when an exception is thrown </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code INSTALLED}, {@code RESOLVED},
+	 * {@code ACTIVE} &#x007D;.
+	 * <li>Original bundle is still used; no update occurred.
+	 * </ul>
+	 * 
+	 * @param input The {@code InputStream} from which to read the new bundle or
+	 *        {@code null} to indicate the Framework must create the input
+	 *        stream from this bundle's {@link Constants#BUNDLE_UPDATELOCATION
+	 *        Bundle-UpdateLocation} Manifest header, if present, or this
+	 *        bundle's original location. The input stream must always be closed
+	 *        when this method completes, even if an exception is thrown.
+	 * @throws BundleException If this bundle could not be updated.
+	 *         BundleException types thrown by this method include:
+	 *         {@link BundleException#READ_ERROR},
+	 *         {@link BundleException#DUPLICATE_BUNDLE_ERROR},
+	 *         {@link BundleException#MANIFEST_ERROR},
+	 *         {@link BundleException#NATIVECODE_ERROR},
+	 *         {@link BundleException#RESOLVE_ERROR},
+	 *         {@link BundleException#STATECHANGE_ERROR}, and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]} for both the current
+	 *         bundle and the updated bundle, and the Java Runtime Environment
+	 *         supports permissions.
+	 * @see #stop()
+	 * @see #start()
+	 */
+	void update(InputStream input) throws BundleException;
+
+	/**
+	 * Updates this bundle.
+	 * 
+	 * <p>
+	 * This method performs the same function as calling
+	 * {@link #update(InputStream)} with a {@code null} InputStream.
+	 * 
+	 * @throws BundleException If this bundle could not be updated.
+	 *         BundleException types thrown by this method include:
+	 *         {@link BundleException#READ_ERROR},
+	 *         {@link BundleException#DUPLICATE_BUNDLE_ERROR},
+	 *         {@link BundleException#MANIFEST_ERROR},
+	 *         {@link BundleException#NATIVECODE_ERROR},
+	 *         {@link BundleException#RESOLVE_ERROR},
+	 *         {@link BundleException#STATECHANGE_ERROR}, and
+	 *         {@link BundleException#ACTIVATOR_ERROR}.
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]} for both the current
+	 *         bundle and the updated bundle, and the Java Runtime Environment
+	 *         supports permissions.
+	 * @see #update(InputStream)
+	 */
+	void update() throws BundleException;
+
+	/**
+	 * Uninstalls this bundle.
+	 * 
+	 * <p>
+	 * This method causes the Framework to notify other bundles that this bundle
+	 * is being uninstalled, and then puts this bundle into the
+	 * {@code UNINSTALLED} state. The Framework must remove any resources
+	 * related to this bundle that it is able to remove.
+	 * 
+	 * <p>
+	 * If this bundle has exported any packages, the Framework must continue to
+	 * make these packages available to their importing bundles until the
+	 * {@link FrameworkWiring#refreshBundles(java.util.Collection, FrameworkListener...)
+	 * FrameworkWiring.refreshBundles} method has been called or the Framework
+	 * is relaunched.
+	 * 
+	 * <p>
+	 * The following steps are required to uninstall a bundle:
+	 * <ol>
+	 * <li>If this bundle's state is {@code UNINSTALLED} then an
+	 * {@code IllegalStateException} is thrown.
+	 * 
+	 * <li>If this bundle's state is {@code ACTIVE}, {@code STARTING} or
+	 * {@code STOPPING}, this bundle is stopped as described in the
+	 * {@code Bundle.stop} method. If {@code Bundle.stop} throws an exception, a
+	 * Framework event of type {@link FrameworkEvent#ERROR} is fired containing
+	 * the exception.
+	 * 
+	 * <li>This bundle's state is set to {@code UNINSTALLED}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#UNINSTALLED} is fired.
+	 * 
+	 * <li>This bundle and any persistent storage area provided for this bundle
+	 * by the Framework are removed.
+	 * </ol>
+	 * 
+	 * <b>Preconditions </b>
+	 * <ul>
+	 * <li>{@code getState()} not in &#x007B; {@code UNINSTALLED} &#x007D;.
+	 * </ul>
+	 * <b>Postconditions, no exceptions thrown </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code UNINSTALLED} &#x007D;.
+	 * <li>This bundle has been uninstalled.
+	 * </ul>
+	 * <b>Postconditions, when an exception is thrown </b>
+	 * <ul>
+	 * <li>{@code getState()} not in &#x007B; {@code UNINSTALLED} &#x007D;.
+	 * <li>This Bundle has not been uninstalled.
+	 * </ul>
+	 * 
+	 * @throws BundleException If the uninstall failed. This can occur if
+	 *         another thread is attempting to change this bundle's state and
+	 *         does not complete in a timely manner. BundleException types
+	 *         thrown by this method include:
+	 *         {@link BundleException#STATECHANGE_ERROR}
+	 * @throws IllegalStateException If this bundle has been uninstalled or this
+	 *         bundle tries to change its own state.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #stop()
+	 */
+	void uninstall() throws BundleException;
+
+	/**
+	 * Returns this bundle's Manifest headers and values. This method returns
+	 * all the Manifest headers and values from the main section of this
+	 * bundle's Manifest file; that is, all lines prior to the first blank line.
+	 * 
+	 * <p>
+	 * Manifest header names are case-insensitive. The methods of the returned
+	 * {@code Dictionary} object must operate on header names in a
+	 * case-insensitive manner.
+	 * 
+	 * If a Manifest header value starts with &quot;%&quot;, it must be
+	 * localized according to the default locale. If no localization is found
+	 * for a header value, the header value without the leading &quot;%&quot; is
+	 * returned.
+	 * 
+	 * <p>
+	 * For example, the following Manifest headers and values are included if
+	 * they are present in the Manifest file:
+	 * 
+	 * <pre>
+	 *     Bundle-Name
+	 *     Bundle-Vendor
+	 *     Bundle-Version
+	 *     Bundle-Description
+	 *     Bundle-DocURL
+	 *     Bundle-ContactAddress
+	 * </pre>
+	 * 
+	 * <p>
+	 * This method must continue to return Manifest header information while
+	 * this bundle is in the {@code UNINSTALLED} state.
+	 * 
+	 * @return An unmodifiable {@code Dictionary} object containing this
+	 *         bundle's Manifest headers and values.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,METADATA]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see Constants#BUNDLE_LOCALIZATION
+	 */
+	Dictionary<String, String> getHeaders();
+
+	/**
+	 * Returns this bundle's unique identifier. This bundle is assigned a unique
+	 * identifier by the Framework when it was installed in the OSGi
+	 * environment.
+	 * 
+	 * <p>
+	 * A bundle's unique identifier has the following attributes:
+	 * <ul>
+	 * <li>Is unique and persistent.
+	 * <li>Is a {@code long}.
+	 * <li>Its value is not reused for another bundle, even after a bundle is
+	 * uninstalled.
+	 * <li>Does not change while a bundle remains installed.
+	 * <li>Does not change when a bundle is updated.
+	 * </ul>
+	 * 
+	 * <p>
+	 * This method must continue to return this bundle's unique identifier while
+	 * this bundle is in the {@code UNINSTALLED} state.
+	 * 
+	 * @return The unique identifier of this bundle.
+	 */
+	long getBundleId();
+
+	/**
+	 * Returns this bundle's location identifier.
+	 * 
+	 * <p>
+	 * The location identifier is the location passed to {@code
+	 * BundleContext.installBundle} when a bundle is installed. The location
+	 * identifier does not change while this bundle remains installed, even if
+	 * this bundle is updated.
+	 * 
+	 * <p>
+	 * This method must continue to return this bundle's location identifier
+	 * while this bundle is in the {@code UNINSTALLED} state.
+	 * 
+	 * @return The string representation of this bundle's location identifier.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,METADATA]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 */
+	String getLocation();
+
+	/**
+	 * Returns this bundle's {@code ServiceReference} list for all services it
+	 * has registered or {@code null} if this bundle has no registered services.
+	 * 
+	 * <p>
+	 * If the Java runtime supports permissions, a {@code ServiceReference}
+	 * object to a service is included in the returned list only if the caller
+	 * has the {@code ServicePermission} to get the service using at least one
+	 * of the named classes the service was registered under.
+	 * 
+	 * <p>
+	 * The list is valid at the time of the call to this method, however, as the
+	 * Framework is a very dynamic environment, services can be modified or
+	 * unregistered at anytime.
+	 * 
+	 * @return An array of {@code ServiceReference} objects or {@code null}.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @see ServiceRegistration
+	 * @see ServiceReference
+	 * @see ServicePermission
+	 */
+	ServiceReference< ? >[] getRegisteredServices();
+
+	/**
+	 * Returns this bundle's {@code ServiceReference} list for all services it
+	 * is using or returns {@code null} if this bundle is not using any
+	 * services. A bundle is considered to be using a service if its use count
+	 * for that service is greater than zero.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment supports permissions, a {@code
+	 * ServiceReference} object to a service is included in the returned list
+	 * only if the caller has the {@code ServicePermission} to get the service
+	 * using at least one of the named classes the service was registered under.
+	 * <p>
+	 * The list is valid at the time of the call to this method, however, as the
+	 * Framework is a very dynamic environment, services can be modified or
+	 * unregistered at anytime.
+	 * 
+	 * @return An array of {@code ServiceReference} objects or {@code null}.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @see ServiceReference
+	 * @see ServicePermission
+	 */
+	ServiceReference< ? >[] getServicesInUse();
+
+	/**
+	 * Determines if this bundle has the specified permissions.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment does not support permissions, this method
+	 * always returns {@code true}.
+	 * <p>
+	 * {@code permission} is of type {@code Object} to avoid referencing the
+	 * {@code java.security.Permission} class directly. This is to allow the
+	 * Framework to be implemented in Java environments which do not support
+	 * permissions.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment does support permissions, this bundle and
+	 * all its resources including embedded JAR files, belong to the same
+	 * {@code java.security.ProtectionDomain}; that is, they must share the same
+	 * set of permissions.
+	 * 
+	 * @param permission The permission to verify.
+	 * @return {@code true} if this bundle has the specified permission or the
+	 *         permissions possessed by this bundle imply the specified
+	 *         permission; {@code false} if this bundle does not have the
+	 *         specified permission or {@code permission} is not an {@code
+	 *         instanceof} {@code java.security.Permission}.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 */
+	boolean hasPermission(Object permission);
+
+	/**
+	 * Find the specified resource from this bundle's class loader.
+	 * 
+	 * This bundle's class loader is called to search for the specified
+	 * resource. If this bundle's state is {@code INSTALLED}, this method must
+	 * attempt to resolve this bundle before attempting to get the specified
+	 * resource. If this bundle cannot be resolved, then only this bundle must
+	 * be searched for the specified resource. Imported packages cannot be
+	 * searched when this bundle has not been resolved. If this bundle is a
+	 * fragment bundle then {@code null} is returned.
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * URLs to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param name The name of the resource. See {@code ClassLoader.getResource}
+	 *        for a description of the format of a resource name.
+	 * @return A URL to the named resource, or {@code null} if the resource
+	 *         could not be found or if this bundle is a fragment bundle or if
+	 *         the caller does not have the appropriate {@code
+	 *         AdminPermission[this,RESOURCE]}, and the Java Runtime Environment
+	 *         supports permissions.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @see #getEntry
+	 * @see #findEntries
+	 * @since 1.1
+	 */
+	URL getResource(String name);
+
+	/**
+	 * Returns this bundle's Manifest headers and values localized to the
+	 * specified locale.
+	 * 
+	 * <p>
+	 * This method performs the same function as {@code Bundle.getHeaders()}
+	 * except the manifest header values are localized to the specified locale.
+	 * 
+	 * <p>
+	 * If a Manifest header value starts with &quot;%&quot;, it must be
+	 * localized according to the specified locale. If a locale is specified and
+	 * cannot be found, then the header values must be returned using the
+	 * default locale. Localizations are searched for in the following order:
+	 * 
+	 * <pre>
+	 *   bn + &quot;_&quot; + Ls + &quot;_&quot; + Cs + &quot;_&quot; + Vs
+	 *   bn + &quot;_&quot; + Ls + &quot;_&quot; + Cs
+	 *   bn + &quot;_&quot; + Ls
+	 *   bn + &quot;_&quot; + Ld + &quot;_&quot; + Cd + &quot;_&quot; + Vd
+	 *   bn + &quot;_&quot; + Ld + &quot;_&quot; + Cd
+	 *   bn + &quot;_&quot; + Ld
+	 *   bn
+	 * </pre>
+	 * 
+	 * Where {@code bn} is this bundle's localization basename, {@code Ls},
+	 * {@code Cs} and {@code Vs} are the specified locale (language, country,
+	 * variant) and {@code Ld}, {@code Cd} and {@code Vd} are the default locale
+	 * (language, country, variant).
+	 * 
+	 * If {@code null} is specified as the locale string, the header values must
+	 * be localized using the default locale. If the empty string (&quot;&quot;)
+	 * is specified as the locale string, the header values must not be
+	 * localized and the raw (unlocalized) header values, including any leading
+	 * &quot;%&quot;, must be returned. If no localization is found for a header
+	 * value, the header value without the leading &quot;%&quot; is returned.
+	 * 
+	 * <p>
+	 * This method must continue to return Manifest header information while
+	 * this bundle is in the {@code UNINSTALLED} state, however the header
+	 * values must only be available in the raw and default locale values.
+	 * 
+	 * @param locale The locale name into which the header values are to be
+	 *        localized. If the specified locale is {@code null} then the locale
+	 *        returned by {@code java.util.Locale.getDefault} is used. If the
+	 *        specified locale is the empty string, this method will return the
+	 *        raw (unlocalized) manifest headers including any leading
+	 *        &quot;%&quot;.
+	 * @return An unmodifiable {@code Dictionary} object containing this
+	 *         bundle's Manifest headers and values.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,METADATA]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #getHeaders()
+	 * @see Constants#BUNDLE_LOCALIZATION
+	 * @since 1.3
+	 */
+	Dictionary<String, String> getHeaders(String locale);
+
+	/**
+	 * Returns the symbolic name of this bundle as specified by its {@code
+	 * Bundle-SymbolicName} manifest header. The bundle symbolic name should be
+	 * based on the reverse domain name naming convention like that used for
+	 * java packages.
+	 * 
+	 * <p>
+	 * This method must continue to return this bundle's symbolic name while
+	 * this bundle is in the {@code UNINSTALLED} state.
+	 * 
+	 * @return The symbolic name of this bundle or {@code null} if this bundle
+	 *         does not have a symbolic name.
+	 * @since 1.3
+	 */
+	String getSymbolicName();
+
+	/**
+	 * Loads the specified class using this bundle's class loader.
+	 * 
+	 * <p>
+	 * If this bundle is a fragment bundle then this method must throw a {@code
+	 * ClassNotFoundException}.
+	 * 
+	 * <p>
+	 * If this bundle's state is {@code INSTALLED}, this method must attempt to
+	 * resolve this bundle before attempting to load the class.
+	 * 
+	 * <p>
+	 * If this bundle cannot be resolved, a Framework event of type
+	 * {@link FrameworkEvent#ERROR} is fired containing a {@code
+	 * BundleException} with details of the reason this bundle could not be
+	 * resolved. This method must then throw a {@code ClassNotFoundException}.
+	 * 
+	 * <p>
+	 * If this bundle's state is {@code UNINSTALLED}, then an {@code
+	 * IllegalStateException} is thrown.
+	 * 
+	 * @param name The name of the class to load.
+	 * @return The Class object for the requested class.
+	 * @throws ClassNotFoundException If no such class can be found or if this
+	 *         bundle is a fragment bundle or if the caller does not have the
+	 *         appropriate {@code AdminPermission[this,CLASS]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @since 1.3
+	 */
+	Class< ? > loadClass(String name) throws ClassNotFoundException;
+
+	/**
+	 * Find the specified resources from this bundle's class loader.
+	 * 
+	 * This bundle's class loader is called to search for the specified
+	 * resources. If this bundle's state is {@code INSTALLED}, this method must
+	 * attempt to resolve this bundle before attempting to get the specified
+	 * resources. If this bundle cannot be resolved, then only this bundle must
+	 * be searched for the specified resources. Imported packages cannot be
+	 * searched when a bundle has not been resolved. If this bundle is a
+	 * fragment bundle then {@code null} is returned.
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * URLs to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param name The name of the resource. See {@code
+	 *        ClassLoader.getResources} for a description of the format of a
+	 *        resource name.
+	 * @return An enumeration of URLs to the named resources, or {@code null} if
+	 *         the resource could not be found or if this bundle is a fragment
+	 *         bundle or if the caller does not have the appropriate {@code
+	 *         AdminPermission[this,RESOURCE]}, and the Java Runtime Environment
+	 *         supports permissions.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @throws IOException If there is an I/O error.
+	 * @since 1.3
+	 */
+	Enumeration<URL> getResources(String name) throws IOException;
+
+	/**
+	 * Returns an Enumeration of all the paths ({@code String} objects) to
+	 * entries within this bundle whose longest sub-path matches the specified
+	 * path. This bundle's class loader is not used to search for entries. Only
+	 * the contents of this bundle are searched.
+	 * <p>
+	 * The specified path is always relative to the root of this bundle and may
+	 * begin with a &quot;/&quot;. A path value of &quot;/&quot; indicates the
+	 * root of this bundle.
+	 * <p>
+	 * Returned paths indicating subdirectory paths end with a &quot;/&quot;.
+	 * The returned paths are all relative to the root of this bundle and must
+	 * not begin with &quot;/&quot;.
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * Paths to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param path The path name for which to return entry paths.
+	 * @return An Enumeration of the entry paths ({@code String} objects) or
+	 *         {@code null} if no entry could be found or if the caller does not
+	 *         have the appropriate {@code AdminPermission[this,RESOURCE]} and
+	 *         the Java Runtime Environment supports permissions.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @since 1.3
+	 */
+	Enumeration<String> getEntryPaths(String path);
+
+	/**
+	 * Returns a URL to the entry at the specified path in this bundle. This
+	 * bundle's class loader is not used to search for the entry. Only the
+	 * contents of this bundle are searched for the entry.
+	 * <p>
+	 * The specified path is always relative to the root of this bundle and may
+	 * begin with &quot;/&quot;. A path value of &quot;/&quot; indicates the
+	 * root of this bundle.
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * URLs to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param path The path name of the entry.
+	 * @return A URL to the entry, or {@code null} if no entry could be found or
+	 *         if the caller does not have the appropriate {@code
+	 *         AdminPermission[this,RESOURCE]} and the Java Runtime Environment
+	 *         supports permissions.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @since 1.3
+	 */
+	URL getEntry(String path);
+
+	/**
+	 * Returns the time when this bundle was last modified. A bundle is
+	 * considered to be modified when it is installed, updated or uninstalled.
+	 * 
+	 * <p>
+	 * The time value is the number of milliseconds since January 1, 1970,
+	 * 00:00:00 GMT.
+	 * 
+	 * @return The time when this bundle was last modified.
+	 * @since 1.3
+	 */
+	long getLastModified();
+
+	/**
+	 * Returns entries in this bundle and its attached fragments. This bundle's
+	 * class loader is not used to search for entries. Only the contents of this
+	 * bundle and its attached fragments are searched for the specified entries.
+	 * 
+	 * If this bundle's state is {@code INSTALLED}, this method must attempt to
+	 * resolve this bundle before attempting to find entries.
+	 * 
+	 * <p>
+	 * This method is intended to be used to obtain configuration, setup,
+	 * localization and other information from this bundle. This method takes
+	 * into account that the &quot;contents&quot; of this bundle can be extended
+	 * with fragments. This &quot;bundle space&quot; is not a name space with
+	 * unique members; the same entry name can be present multiple times. This
+	 * method therefore returns an enumeration of URL objects. These URLs can
+	 * come from different JARs but have the same path name. This method can
+	 * either return only entries in the specified path or recurse into
+	 * subdirectories returning entries in the directory tree beginning at the
+	 * specified path. Fragments can be attached after this bundle is resolved,
+	 * possibly changing the set of URLs returned by this method. If this bundle
+	 * is not resolved, only the entries in the JAR file of this bundle are
+	 * returned.
+	 * <p>
+	 * Examples:
+	 * 
+	 * <pre>
+	 * // List all XML files in the OSGI-INF directory and below
+	 * Enumeration e = b.findEntries(&quot;OSGI-INF&quot;, &quot;*.xml&quot;, true);
+	 * 
+	 * // Find a specific localization file
+	 * Enumeration e = b
+	 * 		.findEntries(&quot;OSGI-INF/l10n&quot;, &quot;bundle_nl_DU.properties&quot;, false);
+	 * if (e.hasMoreElements())
+	 * 	return (URL) e.nextElement();
+	 * </pre>
+	 * 
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * URLs to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param path The path name in which to look. The path is always relative
+	 *        to the root of this bundle and may begin with &quot;/&quot;. A
+	 *        path value of &quot;/&quot; indicates the root of this bundle.
+	 * @param filePattern The file name pattern for selecting entries in the
+	 *        specified path. The pattern is only matched against the last
+	 *        element of the entry path. If the entry is a directory then the
+	 *        trailing &quot;/&quot; is not used for pattern matching. Substring
+	 *        matching is supported, as specified in the Filter specification,
+	 *        using the wildcard character (&quot;*&quot;). If null is
+	 *        specified, this is equivalent to &quot;*&quot; and matches all
+	 *        files.
+	 * @param recurse If {@code true}, recurse into subdirectories. Otherwise
+	 *        only return entries from the specified path.
+	 * @return An enumeration of URL objects for each matching entry, or
+	 *         {@code null} if no matching entry could not be found or if the
+	 *         caller does not have the appropriate
+	 *         {@code AdminPermission[this,RESOURCE]}, and the Java Runtime
+	 *         Environment supports permissions. The URLs are sorted such that
+	 *         entries from this bundle are returned first followed by the
+	 *         entries from attached fragments in attachment order. If this
+	 *         bundle is a fragment, then only matching entries in this fragment
+	 *         are returned.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @since 1.3
+	 */
+	Enumeration<URL> findEntries(String path, String filePattern,
+			boolean recurse);
+
+	/**
+	 * Returns this bundle's {@link BundleContext}. The returned {@code
+	 * BundleContext} can be used by the caller to act on behalf of this bundle.
+	 * 
+	 * <p>
+	 * If this bundle is not in the {@link #STARTING}, {@link #ACTIVE}, or
+	 * {@link #STOPPING} states or this bundle is a fragment bundle, then this
+	 * bundle has no valid {@code BundleContext}. This method will return
+	 * {@code null} if this bundle has no valid {@code BundleContext}.
+	 * 
+	 * @return A {@code BundleContext} for this bundle or {@code null} if this
+	 *         bundle has no valid {@code BundleContext}.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,CONTEXT]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @since 1.4
+	 */
+	BundleContext getBundleContext();
+
+	/**
+	 * Return the certificates for the signers of this bundle and the
+	 * certificate chains for those signers.
+	 * 
+	 * @param signersType If {@link #SIGNERS_ALL} is specified, then information
+	 *        on all signers of this bundle is returned. If
+	 *        {@link #SIGNERS_TRUSTED} is specified, then only information on
+	 *        the signers of this bundle trusted by the framework is returned.
+	 * @return The {@code X509Certificate}s for the signers of this bundle and
+	 *         the {@code X509Certificate} chains for those signers. The keys of
+	 *         the {@code Map} are the {@code X509Certificate}s of the signers
+	 *         of this bundle. The value for a key is a {@code List} containing
+	 *         the {@code X509Certificate} chain for the signer. The first item
+	 *         in the {@code List} is the signer's {@code X509Certificate} which
+	 *         is then followed by the rest of the {@code X509Certificate}
+	 *         chain. The returned {@code Map} will be empty if there are no
+	 *         signers. The returned {@code Map} is the property of the caller
+	 *         who is free to modify it.
+	 * @throws IllegalArgumentException If the specified {@code signersType} is
+	 *         not {@link #SIGNERS_ALL} or {@link #SIGNERS_TRUSTED}.
+	 * @since 1.5
+	 */
+	Map<X509Certificate, List<X509Certificate>> getSignerCertificates(
+			int signersType);
+
+	/**
+	 * Returns the version of this bundle as specified by its {@code
+	 * Bundle-Version} manifest header. If this bundle does not have a specified
+	 * version then {@link Version#emptyVersion} is returned.
+	 * 
+	 * <p>
+	 * This method must continue to return this bundle's version while this
+	 * bundle is in the {@code UNINSTALLED} state.
+	 * 
+	 * @return The version of this bundle.
+	 * @since 1.5
+	 */
+	Version getVersion();
+
+	/**
+	 * Adapt this bundle to the specified type.
+	 * 
+	 * <p>
+	 * Adapting this bundle to the specified type may require certain checks,
+	 * including security checks, to succeed. If a check does not succeed, then
+	 * this bundle cannot be adapted and {@code null} is returned.
+	 * 
+	 * @param <A> The type to which this bundle is to be adapted.
+	 * @param type Class object for the type to which this bundle is to be
+	 *        adapted.
+	 * @return The object, of the specified type, to which this bundle has been
+	 *         adapted or {@code null} if this bundle cannot be adapted to the
+	 *         specified type.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdaptPermission[type,this,ADAPT]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @since 1.6
+	 */
+	<A> A adapt(Class<A> type);
+
+	/**
+	 * Creates a {@code File} object for a file in the persistent storage area
+	 * provided for this bundle by the Framework. This method will return
+	 * {@code null} if the platform does not have file system support or this
+	 * bundle is a fragment bundle.
+	 * 
+	 * <p>
+	 * A {@code File} object for the base directory of the persistent storage
+	 * area provided for this bundle by the Framework can be obtained by calling
+	 * this method with an empty string as {@code filename}.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment supports permissions, the Framework will
+	 * ensure that this bundle has the {@code java.io.FilePermission} with
+	 * actions {@code read},{@code write},{@code delete} for all files
+	 * (recursively) in the persistent storage area provided for this bundle.
+	 * 
+	 * @param filename A relative name to the file to be accessed.
+	 * @return A {@code File} object that represents the requested file or
+	 *         {@code null} if the platform does not have file system support or
+	 *         this bundle is a fragment bundle.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @since 1.6
+	 */
+	File getDataFile(String filename);
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleActivator.java b/main/src/main/java/org/osgi/framework/BundleActivator.java
new file mode 100644
index 0000000000..aefb0360a3
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleActivator.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * Customizes the starting and stopping of a bundle.
+ * <p>
+ * {@code BundleActivator} is an interface that may be implemented when a
+ * bundle is started or stopped. The Framework can create instances of a
+ * bundle's {@code BundleActivator} as required. If an instance's
+ * {@code BundleActivator.start} method executes successfully, it is
+ * guaranteed that the same instance's {@code BundleActivator.stop}
+ * method will be called when the bundle is to be stopped. The Framework must
+ * not concurrently call a {@code BundleActivator} object.
+ * 
+ * <p>
+ * {@code BundleActivator} is specified through the
+ * {@code Bundle-Activator} Manifest header. A bundle can only specify a
+ * single {@code BundleActivator} in the Manifest file. Fragment bundles
+ * must not have a {@code BundleActivator}. The form of the Manifest
+ * header is:
+ * 
+ * <p>
+ * {@code Bundle-Activator: <i>class-name</i>}
+ * 
+ * <p>
+ * where {@code <i>class-name</i>} is a fully qualified Java classname.
+ * <p>
+ * The specified {@code BundleActivator} class must have a public
+ * constructor that takes no parameters so that a {@code BundleActivator}
+ * object can be created by {@code Class.newInstance()}.
+ * 
+ * @NotThreadSafe
+ * @version $Id: 1b73057bd270ab07f0a16430dba16e5132eea24f $
+ */
+
+public interface BundleActivator {
+	/**
+	 * Called when this bundle is started so the Framework can perform the
+	 * bundle-specific activities necessary to start this bundle. This method
+	 * can be used to register services or to allocate any resources that this
+	 * bundle needs.
+	 * 
+	 * <p>
+	 * This method must complete and return to its caller in a timely manner.
+	 * 
+	 * @param context The execution context of the bundle being started.
+	 * @throws Exception If this method throws an exception, this
+	 *         bundle is marked as stopped and the Framework will remove this
+	 *         bundle's listeners, unregister all services registered by this
+	 *         bundle, and release all services used by this bundle.
+	 */
+	public void start(BundleContext context) throws Exception;
+
+	/**
+	 * Called when this bundle is stopped so the Framework can perform the
+	 * bundle-specific activities necessary to stop the bundle. In general, this
+	 * method should undo the work that the {@code BundleActivator.start}
+	 * method started. There should be no active threads that were started by
+	 * this bundle when this bundle returns. A stopped bundle must not call any
+	 * Framework objects.
+	 * 
+	 * <p>
+	 * This method must complete and return to its caller in a timely manner.
+	 * 
+	 * @param context The execution context of the bundle being stopped.
+	 * @throws Exception If this method throws an exception, the
+	 *         bundle is still marked as stopped, and the Framework will remove
+	 *         the bundle's listeners, unregister all services registered by the
+	 *         bundle, and release all services used by the bundle.
+	 */
+	public void stop(BundleContext context) throws Exception;
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleContext.java b/main/src/main/java/org/osgi/framework/BundleContext.java
new file mode 100644
index 0000000000..c587d03c14
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleContext.java
@@ -0,0 +1,872 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.Collection;
+import java.util.Dictionary;
+
+/**
+ * A bundle's execution context within the Framework. The context is used to
+ * grant access to other methods so that this bundle can interact with the
+ * Framework.
+ * 
+ * <p>
+ * {@code BundleContext} methods allow a bundle to:
+ * <ul>
+ * <li>Subscribe to events published by the Framework.
+ * <li>Register service objects with the Framework service registry.
+ * <li>Retrieve {@code ServiceReferences} from the Framework service registry.
+ * <li>Get and release service objects for a referenced service.
+ * <li>Install new bundles in the Framework.
+ * <li>Get the list of bundles installed in the Framework.
+ * <li>Get the {@link Bundle} object for a bundle.
+ * <li>Create {@code File} objects for files in a persistent storage area
+ * provided for the bundle by the Framework.
+ * </ul>
+ * 
+ * <p>
+ * A {@code BundleContext} object will be created for a bundle when the bundle
+ * is started. The {@code Bundle} object associated with a {@code BundleContext}
+ * object is called the <em>context bundle</em>.
+ * 
+ * <p>
+ * The {@code BundleContext} object will be passed to the
+ * {@link BundleActivator#start} method during activation of the context bundle.
+ * The same {@code BundleContext} object will be passed to the
+ * {@link BundleActivator#stop} method when the context bundle is stopped. A
+ * {@code BundleContext} object is generally for the private use of its
+ * associated bundle and is not meant to be shared with other bundles in the
+ * OSGi environment.
+ * 
+ * <p>
+ * The {@code BundleContext} object is only valid during the execution of its
+ * context bundle; that is, during the period from when the context bundle is in
+ * the {@code STARTING}, {@code STOPPING}, and {@code ACTIVE} bundle states. If
+ * the {@code BundleContext} object is used subsequently, an
+ * {@code IllegalStateException} must be thrown. The {@code BundleContext}
+ * object must never be reused after its context bundle is stopped.
+ * 
+ * <p>
+ * Two {@code BundleContext} objects are equal if they both refer to the same
+ * execution context of a bundle. The Framework is the only entity that can
+ * create {@code BundleContext} objects and they are only valid within the
+ * Framework that created them.
+ * 
+ * <p>
+ * A {@link Bundle} can be {@link Bundle#adapt(Class) adapted} to its
+ * {@code BundleContext}. In order for this to succeed, the caller must have the
+ * appropriate {@code AdminPermission[bundle,CONTEXT]} if the Java Runtime
+ * Environment supports permissions.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 6d4b5967b9fe706b1dfbdd42b3d759028ed9826d $
+ */
+
+public interface BundleContext extends BundleReference {
+
+	/**
+	 * Returns the value of the specified property. If the key is not found in
+	 * the Framework properties, the system properties are then searched. The
+	 * method returns {@code null} if the property is not found.
+	 * 
+	 * <p>
+	 * All bundles must have permission to read properties whose names start
+	 * with &quot;org.osgi.&quot;.
+	 * 
+	 * @param key The name of the requested property.
+	 * @return The value of the requested property, or {@code null} if the
+	 *         property is undefined.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code PropertyPermission} to read the property, and the Java
+	 *         Runtime Environment supports permissions.
+	 */
+	String getProperty(String key);
+
+	/**
+	 * Returns the {@code Bundle} object associated with this
+	 * {@code BundleContext}. This bundle is called the context bundle.
+	 * 
+	 * @return The {@code Bundle} object associated with this
+	 *         {@code BundleContext}.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	Bundle getBundle();
+
+	/**
+	 * Installs a bundle from the specified {@code InputStream} object.
+	 * 
+	 * <p>
+	 * If the specified {@code InputStream} is {@code null}, the Framework must
+	 * create the {@code InputStream} from which to read the bundle by
+	 * interpreting, in an implementation dependent manner, the specified
+	 * {@code location}.
+	 * 
+	 * <p>
+	 * The specified {@code location} identifier will be used as the identity of
+	 * the bundle. Every installed bundle is uniquely identified by its location
+	 * identifier which is typically in the form of a URL.
+	 * 
+	 * <p>
+	 * The following steps are required to install a bundle:
+	 * <ol>
+	 * <li>If a bundle containing the same location identifier is already
+	 * installed, the {@code Bundle} object for that bundle is returned.
+	 * 
+	 * <li>The bundle's content is read from the input stream. If this fails, a
+	 * {@link BundleException} is thrown.
+	 * 
+	 * <li>The bundle's associated resources are allocated. The associated
+	 * resources minimally consist of a unique identifier and a persistent
+	 * storage area if the platform has file system support. If this step fails,
+	 * a {@code BundleException} is thrown.
+	 * 
+	 * <li>The bundle's state is set to {@code INSTALLED}.
+	 * 
+	 * <li>A bundle event of type {@link BundleEvent#INSTALLED} is fired.
+	 * 
+	 * <li>The {@code Bundle} object for the newly or previously installed
+	 * bundle is returned.
+	 * </ol>
+	 * 
+	 * <b>Postconditions, no exceptions thrown </b>
+	 * <ul>
+	 * <li>{@code getState()} in &#x007B; {@code INSTALLED}, {@code RESOLVED}
+	 * &#x007D;.
+	 * <li>Bundle has a unique ID.
+	 * </ul>
+	 * <b>Postconditions, when an exception is thrown </b>
+	 * <ul>
+	 * <li>Bundle is not installed. If there was an existing bundle for the
+	 * specified location, then that bundle must still be in the state it was
+	 * prior to calling this method.</li>
+	 * </ul>
+	 * 
+	 * @param location The location identifier of the bundle to install.
+	 * @param input The {@code InputStream} object from which this bundle will
+	 *        be read or {@code null} to indicate the Framework must create the
+	 *        input stream from the specified location identifier. The input
+	 *        stream must always be closed when this method completes, even if
+	 *        an exception is thrown.
+	 * @return The {@code Bundle} object of the installed bundle.
+	 * @throws BundleException If the installation failed. BundleException types
+	 *         thrown by this method include: {@link BundleException#READ_ERROR}
+	 *         , {@link BundleException#DUPLICATE_BUNDLE_ERROR},
+	 *         {@link BundleException#MANIFEST_ERROR}, and
+	 *         {@link BundleException#REJECTED_BY_HOOK}.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[installed bundle,LIFECYCLE]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	Bundle installBundle(String location, InputStream input)
+			throws BundleException;
+
+	/**
+	 * Installs a bundle from the specified {@code location} identifier.
+	 * 
+	 * <p>
+	 * This method performs the same function as calling
+	 * {@link #installBundle(String,InputStream)} with the specified
+	 * {@code location} identifier and a {@code null} InputStream.
+	 * 
+	 * @param location The location identifier of the bundle to install.
+	 * @return The {@code Bundle} object of the installed bundle.
+	 * @throws BundleException If the installation failed. BundleException types
+	 *         thrown by this method include: {@link BundleException#READ_ERROR}
+	 *         , {@link BundleException#DUPLICATE_BUNDLE_ERROR},
+	 *         {@link BundleException#MANIFEST_ERROR}, and
+	 *         {@link BundleException#REJECTED_BY_HOOK}.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[installed bundle,LIFECYCLE]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #installBundle(String, InputStream)
+	 */
+	Bundle installBundle(String location) throws BundleException;
+
+	/**
+	 * Returns the bundle with the specified identifier.
+	 * 
+	 * @param id The identifier of the bundle to retrieve.
+	 * @return A {@code Bundle} object or {@code null} if the identifier does
+	 *         not match any installed bundle.
+	 */
+	Bundle getBundle(long id);
+
+	/**
+	 * Returns a list of all installed bundles.
+	 * <p>
+	 * This method returns a list of all bundles installed in the OSGi
+	 * environment at the time of the call to this method. However, since the
+	 * Framework is a very dynamic environment, bundles can be installed or
+	 * uninstalled at anytime.
+	 * 
+	 * @return An array of {@code Bundle} objects, one object per installed
+	 *         bundle.
+	 */
+	Bundle[] getBundles();
+
+	/**
+	 * Adds the specified {@code ServiceListener} object with the specified
+	 * {@code filter} to the context bundle's list of listeners. See
+	 * {@link Filter} for a description of the filter syntax.
+	 * {@code ServiceListener} objects are notified when a service has a
+	 * lifecycle state change.
+	 * 
+	 * <p>
+	 * If the context bundle's list of listeners already contains a listener
+	 * {@code l} such that {@code (l==listener)}, then this method replaces that
+	 * listener's filter (which may be {@code null}) with the specified one
+	 * (which may be {@code null}).
+	 * 
+	 * <p>
+	 * The listener is called if the filter criteria is met. To filter based
+	 * upon the class of the service, the filter should reference the
+	 * {@link Constants#OBJECTCLASS} property. If {@code filter} is {@code null}
+	 * , all services are considered to match the filter.
+	 * 
+	 * <p>
+	 * When using a {@code filter}, it is possible that the {@code ServiceEvent}
+	 * s for the complete lifecycle of a service will not be delivered to the
+	 * listener. For example, if the {@code filter} only matches when the
+	 * property {@code x} has the value {@code 1}, the listener will not be
+	 * called if the service is registered with the property {@code x} not set
+	 * to the value {@code 1}. Subsequently, when the service is modified
+	 * setting property {@code x} to the value {@code 1}, the filter will match
+	 * and the listener will be called with a {@code ServiceEvent} of type
+	 * {@code MODIFIED}. Thus, the listener will not be called with a
+	 * {@code ServiceEvent} of type {@code REGISTERED}.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment supports permissions, the
+	 * {@code ServiceListener} object will be notified of a service event only
+	 * if the bundle that is registering it has the {@code ServicePermission} to
+	 * get the service using at least one of the named classes the service was
+	 * registered under.
+	 * 
+	 * @param listener The {@code ServiceListener} object to be added.
+	 * @param filter The filter criteria.
+	 * @throws InvalidSyntaxException If {@code filter} contains an invalid
+	 *         filter string that cannot be parsed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see ServiceEvent
+	 * @see ServiceListener
+	 * @see ServicePermission
+	 */
+	void addServiceListener(ServiceListener listener, String filter)
+			throws InvalidSyntaxException;
+
+	/**
+	 * Adds the specified {@code ServiceListener} object to the context bundle's
+	 * list of listeners.
+	 * 
+	 * <p>
+	 * This method is the same as calling
+	 * {@code BundleContext.addServiceListener(ServiceListener listener,
+	 * String filter)} with {@code filter} set to {@code null}.
+	 * 
+	 * @param listener The {@code ServiceListener} object to be added.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #addServiceListener(ServiceListener, String)
+	 */
+	void addServiceListener(ServiceListener listener);
+
+	/**
+	 * Removes the specified {@code ServiceListener} object from the context
+	 * bundle's list of listeners.
+	 * 
+	 * <p>
+	 * If {@code listener} is not contained in this context bundle's list of
+	 * listeners, this method does nothing.
+	 * 
+	 * @param listener The {@code ServiceListener} to be removed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	void removeServiceListener(ServiceListener listener);
+
+	/**
+	 * Adds the specified {@code BundleListener} object to the context bundle's
+	 * list of listeners if not already present. BundleListener objects are
+	 * notified when a bundle has a lifecycle state change.
+	 * 
+	 * <p>
+	 * If the context bundle's list of listeners already contains a listener
+	 * {@code l} such that {@code (l==listener)}, this method does nothing.
+	 * 
+	 * @param listener The {@code BundleListener} to be added.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @throws SecurityException If listener is a
+	 *         {@code SynchronousBundleListener} and the caller does not have
+	 *         the appropriate {@code AdminPermission[context bundle,LISTENER]},
+	 *         and the Java Runtime Environment supports permissions.
+	 * @see BundleEvent
+	 * @see BundleListener
+	 */
+	void addBundleListener(BundleListener listener);
+
+	/**
+	 * Removes the specified {@code BundleListener} object from the context
+	 * bundle's list of listeners.
+	 * 
+	 * <p>
+	 * If {@code listener} is not contained in the context bundle's list of
+	 * listeners, this method does nothing.
+	 * 
+	 * @param listener The {@code BundleListener} object to be removed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @throws SecurityException If listener is a
+	 *         {@code SynchronousBundleListener} and the caller does not have
+	 *         the appropriate {@code AdminPermission[context bundle,LISTENER]},
+	 *         and the Java Runtime Environment supports permissions.
+	 */
+	void removeBundleListener(BundleListener listener);
+
+	/**
+	 * Adds the specified {@code FrameworkListener} object to the context
+	 * bundle's list of listeners if not already present. FrameworkListeners are
+	 * notified of general Framework events.
+	 * 
+	 * <p>
+	 * If the context bundle's list of listeners already contains a listener
+	 * {@code l} such that {@code (l==listener)}, this method does nothing.
+	 * 
+	 * @param listener The {@code FrameworkListener} object to be added.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see FrameworkEvent
+	 * @see FrameworkListener
+	 */
+	void addFrameworkListener(FrameworkListener listener);
+
+	/**
+	 * Removes the specified {@code FrameworkListener} object from the context
+	 * bundle's list of listeners.
+	 * 
+	 * <p>
+	 * If {@code listener} is not contained in the context bundle's list of
+	 * listeners, this method does nothing.
+	 * 
+	 * @param listener The {@code FrameworkListener} object to be removed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	void removeFrameworkListener(FrameworkListener listener);
+
+	/**
+	 * Registers the specified service object with the specified properties
+	 * under the specified class names into the Framework. A
+	 * {@code ServiceRegistration} object is returned. The
+	 * {@code ServiceRegistration} object is for the private use of the bundle
+	 * registering the service and should not be shared with other bundles. The
+	 * registering bundle is defined to be the context bundle. Other bundles can
+	 * locate the service by using either the {@link #getServiceReferences} or
+	 * {@link #getServiceReference} method.
+	 * 
+	 * <p>
+	 * A bundle can register a service object that implements the
+	 * {@link ServiceFactory} interface to have more flexibility in providing
+	 * service objects to other bundles.
+	 * 
+	 * <p>
+	 * The following steps are required to register a service:
+	 * <ol>
+	 * <li>If {@code service} is not a {@code ServiceFactory}, an
+	 * {@code IllegalArgumentException} is thrown if {@code service} is not an
+	 * {@code instanceof} all the specified class names.
+	 * <li>The Framework adds the following service properties to the service
+	 * properties from the specified {@code Dictionary} (which may be
+	 * {@code null}): <br/>
+	 * A property named {@link Constants#SERVICE_ID} identifying the
+	 * registration number of the service <br/>
+	 * A property named {@link Constants#OBJECTCLASS} containing all the
+	 * specified classes. <br/>
+	 * Properties with these names in the specified {@code Dictionary} will be
+	 * ignored.
+	 * <li>The service is added to the Framework service registry and may now be
+	 * used by other bundles.
+	 * <li>A service event of type {@link ServiceEvent#REGISTERED} is fired.
+	 * <li>A {@code ServiceRegistration} object for this registration is
+	 * returned.
+	 * </ol>
+	 * 
+	 * @param clazzes The class names under which the service can be located.
+	 *        The class names in this array will be stored in the service's
+	 *        properties under the key {@link Constants#OBJECTCLASS}.
+	 * @param service The service object or a {@code ServiceFactory} object.
+	 * @param properties The properties for this service. The keys in the
+	 *        properties object must all be {@code String} objects. See
+	 *        {@link Constants} for a list of standard service property keys.
+	 *        Changes should not be made to this object after calling this
+	 *        method. To update the service's properties the
+	 *        {@link ServiceRegistration#setProperties} method must be called.
+	 *        The set of properties may be {@code null} if the service has no
+	 *        properties.
+	 * @return A {@code ServiceRegistration} object for use by the bundle
+	 *         registering the service to update the service's properties or to
+	 *         unregister the service.
+	 * @throws IllegalArgumentException If one of the following is true:
+	 *         <ul>
+	 *         <li>{@code service} is {@code null}. <li>{@code service} is not a
+	 *         {@code ServiceFactory} object and is not an instance of all the
+	 *         named classes in {@code clazzes}. <li> {@code properties}
+	 *         contains case variants of the same key name.
+	 *         </ul>
+	 * @throws SecurityException If the caller does not have the
+	 *         {@code ServicePermission} to register the service for all the
+	 *         named classes and the Java Runtime Environment supports
+	 *         permissions.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see ServiceRegistration
+	 * @see ServiceFactory
+	 */
+	ServiceRegistration< ? > registerService(String[] clazzes, Object service,
+			Dictionary<String, ? > properties);
+
+	/**
+	 * Registers the specified service object with the specified properties
+	 * under the specified class name with the Framework.
+	 * 
+	 * <p>
+	 * This method is otherwise identical to
+	 * {@link #registerService(String[], Object, Dictionary)} and is provided as
+	 * a convenience when {@code service} will only be registered under a single
+	 * class name. Note that even in this case the value of the service's
+	 * {@link Constants#OBJECTCLASS} property will be an array of string, rather
+	 * than just a single string.
+	 * 
+	 * @param clazz The class name under which the service can be located.
+	 * @param service The service object or a {@code ServiceFactory} object.
+	 * @param properties The properties for this service.
+	 * @return A {@code ServiceRegistration} object for use by the bundle
+	 *         registering the service to update the service's properties or to
+	 *         unregister the service.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #registerService(String[], Object, Dictionary)
+	 */
+	ServiceRegistration< ? > registerService(String clazz, Object service,
+			Dictionary<String, ? > properties);
+
+	/**
+	 * Registers the specified service object with the specified properties
+	 * under the specified class name with the Framework.
+	 * 
+	 * <p>
+	 * This method is otherwise identical to
+	 * {@link #registerService(String[], Object, Dictionary)} and is provided as
+	 * a convenience when {@code service} will only be registered under a single
+	 * class name. Note that even in this case the value of the service's
+	 * {@link Constants#OBJECTCLASS} property will be an array of string, rather
+	 * than just a single string.
+	 * 
+	 * @param <S> Type of Service.
+	 * @param clazz The class name under which the service can be located.
+	 * @param service The service object or a {@code ServiceFactory} object.
+	 * @param properties The properties for this service.
+	 * @return A {@code ServiceRegistration} object for use by the bundle
+	 *         registering the service to update the service's properties or to
+	 *         unregister the service.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #registerService(String[], Object, Dictionary)
+	 * @since 1.6
+	 */
+	<S> ServiceRegistration<S> registerService(Class<S> clazz, S service,
+			Dictionary<String, ? > properties);
+
+	/**
+	 * Returns an array of {@code ServiceReference} objects. The returned array
+	 * of {@code ServiceReference} objects contains services that were
+	 * registered under the specified class, match the specified filter
+	 * expression, and the packages for the class names under which the services
+	 * were registered match the context bundle's packages as defined in
+	 * {@link ServiceReference#isAssignableTo(Bundle, String)}.
+	 * 
+	 * <p>
+	 * The list is valid at the time of the call to this method. However since
+	 * the Framework is a very dynamic environment, services can be modified or
+	 * unregistered at any time.
+	 * 
+	 * <p>
+	 * The specified {@code filter} expression is used to select the registered
+	 * services whose service properties contain keys and values which satisfy
+	 * the filter expression. See {@link Filter} for a description of the filter
+	 * syntax. If the specified {@code filter} is {@code null}, all registered
+	 * services are considered to match the filter. If the specified
+	 * {@code filter} expression cannot be parsed, an
+	 * {@link InvalidSyntaxException} will be thrown with a human readable
+	 * message where the filter became unparsable.
+	 * 
+	 * <p>
+	 * The result is an array of {@code ServiceReference} objects for all
+	 * services that meet all of the following conditions:
+	 * <ul>
+	 * <li>If the specified class name, {@code clazz}, is not {@code null}, the
+	 * service must have been registered with the specified class name. The
+	 * complete list of class names with which a service was registered is
+	 * available from the service's {@link Constants#OBJECTCLASS objectClass}
+	 * property.
+	 * <li>If the specified {@code filter} is not {@code null}, the filter
+	 * expression must match the service.
+	 * <li>If the Java Runtime Environment supports permissions, the caller must
+	 * have {@code ServicePermission} with the {@code GET} action for at least
+	 * one of the class names under which the service was registered.
+	 * <li>For each class name with which the service was registered, calling
+	 * {@link ServiceReference#isAssignableTo(Bundle, String)} with the context
+	 * bundle and the class name on the service's {@code ServiceReference}
+	 * object must return {@code true}
+	 * </ul>
+	 * 
+	 * @param clazz The class name with which the service was registered or
+	 *        {@code null} for all services.
+	 * @param filter The filter expression or {@code null} for all services.
+	 * @return An array of {@code ServiceReference} objects or {@code null} if
+	 *         no services are registered which satisfy the search.
+	 * @throws InvalidSyntaxException If the specified {@code filter} contains
+	 *         an invalid filter expression that cannot be parsed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	ServiceReference< ? >[] getServiceReferences(String clazz, String filter)
+			throws InvalidSyntaxException;
+
+	/**
+	 * Returns an array of {@code ServiceReference} objects. The returned array
+	 * of {@code ServiceReference} objects contains services that were
+	 * registered under the specified class and match the specified filter
+	 * expression.
+	 * 
+	 * <p>
+	 * The list is valid at the time of the call to this method. However since
+	 * the Framework is a very dynamic environment, services can be modified or
+	 * unregistered at any time.
+	 * 
+	 * <p>
+	 * The specified {@code filter} expression is used to select the registered
+	 * services whose service properties contain keys and values which satisfy
+	 * the filter expression. See {@link Filter} for a description of the filter
+	 * syntax. If the specified {@code filter} is {@code null}, all registered
+	 * services are considered to match the filter. If the specified
+	 * {@code filter} expression cannot be parsed, an
+	 * {@link InvalidSyntaxException} will be thrown with a human readable
+	 * message where the filter became unparsable.
+	 * 
+	 * <p>
+	 * The result is an array of {@code ServiceReference} objects for all
+	 * services that meet all of the following conditions:
+	 * <ul>
+	 * <li>If the specified class name, {@code clazz}, is not {@code null}, the
+	 * service must have been registered with the specified class name. The
+	 * complete list of class names with which a service was registered is
+	 * available from the service's {@link Constants#OBJECTCLASS objectClass}
+	 * property.
+	 * <li>If the specified {@code filter} is not {@code null}, the filter
+	 * expression must match the service.
+	 * <li>If the Java Runtime Environment supports permissions, the caller must
+	 * have {@code ServicePermission} with the {@code GET} action for at least
+	 * one of the class names under which the service was registered.
+	 * </ul>
+	 * 
+	 * @param clazz The class name with which the service was registered or
+	 *        {@code null} for all services.
+	 * @param filter The filter expression or {@code null} for all services.
+	 * @return An array of {@code ServiceReference} objects or {@code null} if
+	 *         no services are registered which satisfy the search.
+	 * @throws InvalidSyntaxException If the specified {@code filter} contains
+	 *         an invalid filter expression that cannot be parsed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @since 1.3
+	 */
+	ServiceReference< ? >[] getAllServiceReferences(String clazz, String filter)
+			throws InvalidSyntaxException;
+
+	/**
+	 * Returns a {@code ServiceReference} object for a service that implements
+	 * and was registered under the specified class.
+	 * 
+	 * <p>
+	 * The returned {@code ServiceReference} object is valid at the time of the
+	 * call to this method. However as the Framework is a very dynamic
+	 * environment, services can be modified or unregistered at any time.
+	 * 
+	 * <p>
+	 * This method is the same as calling
+	 * {@link #getServiceReferences(String, String)} with a {@code null} filter
+	 * expression and then finding the reference with the highest priority. It
+	 * is provided as a convenience for when the caller is interested in any
+	 * service that implements the specified class.
+	 * <p>
+	 * If multiple such services exist, the service with the highest priority is
+	 * selected. This priority is defined as the service reference with the
+	 * highest ranking (as specified in its {@link Constants#SERVICE_RANKING}
+	 * property) is returned.
+	 * <p>
+	 * If there is a tie in ranking, the service with the lowest service ID (as
+	 * specified in its {@link Constants#SERVICE_ID} property); that is, the
+	 * service that was registered first is returned.
+	 * 
+	 * @param clazz The class name with which the service was registered.
+	 * @return A {@code ServiceReference} object, or {@code null} if no services
+	 *         are registered which implement the named class.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #getServiceReferences(String, String)
+	 */
+	ServiceReference< ? > getServiceReference(String clazz);
+
+	/**
+	 * Returns a {@code ServiceReference} object for a service that implements
+	 * and was registered under the specified class.
+	 * 
+	 * <p>
+	 * The returned {@code ServiceReference} object is valid at the time of the
+	 * call to this method. However as the Framework is a very dynamic
+	 * environment, services can be modified or unregistered at any time.
+	 * 
+	 * <p>
+	 * This method is the same as calling
+	 * {@link #getServiceReferences(Class, String)} with a {@code null} filter
+	 * expression. It is provided as a convenience for when the caller is
+	 * interested in any service that implements the specified class.
+	 * <p>
+	 * If multiple such services exist, the service with the highest ranking (as
+	 * specified in its {@link Constants#SERVICE_RANKING} property) is returned.
+	 * <p>
+	 * If there is a tie in ranking, the service with the lowest service ID (as
+	 * specified in its {@link Constants#SERVICE_ID} property); that is, the
+	 * service that was registered first is returned.
+	 * 
+	 * @param <S> Type of Service.
+	 * @param clazz The class name with which the service was registered.
+	 * @return A {@code ServiceReference} object, or {@code null} if no services
+	 *         are registered which implement the named class.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see #getServiceReferences(Class, String)
+	 * @since 1.6
+	 */
+	<S> ServiceReference<S> getServiceReference(Class<S> clazz);
+
+	/**
+	 * Returns a collection of {@code ServiceReference} objects. The returned
+	 * collection of {@code ServiceReference} objects contains services that
+	 * were registered under the specified class, match the specified filter
+	 * expression, and the packages for the class names under which the services
+	 * were registered match the context bundle's packages as defined in
+	 * {@link ServiceReference#isAssignableTo(Bundle, String)}.
+	 * 
+	 * <p>
+	 * The collection is valid at the time of the call to this method. However
+	 * since the Framework is a very dynamic environment, services can be
+	 * modified or unregistered at any time.
+	 * 
+	 * <p>
+	 * The specified {@code filter} expression is used to select the registered
+	 * services whose service properties contain keys and values which satisfy
+	 * the filter expression. See {@link Filter} for a description of the filter
+	 * syntax. If the specified {@code filter} is {@code null}, all registered
+	 * services are considered to match the filter. If the specified
+	 * {@code filter} expression cannot be parsed, an
+	 * {@link InvalidSyntaxException} will be thrown with a human readable
+	 * message where the filter became unparsable.
+	 * 
+	 * <p>
+	 * The result is a collection of {@code ServiceReference} objects for all
+	 * services that meet all of the following conditions:
+	 * <ul>
+	 * <li>If the specified class name, {@code clazz}, is not {@code null}, the
+	 * service must have been registered with the specified class name. The
+	 * complete list of class names with which a service was registered is
+	 * available from the service's {@link Constants#OBJECTCLASS objectClass}
+	 * property.
+	 * <li>If the specified {@code filter} is not {@code null}, the filter
+	 * expression must match the service.
+	 * <li>If the Java Runtime Environment supports permissions, the caller must
+	 * have {@code ServicePermission} with the {@code GET} action for at least
+	 * one of the class names under which the service was registered.
+	 * <li>For each class name with which the service was registered, calling
+	 * {@link ServiceReference#isAssignableTo(Bundle, String)} with the context
+	 * bundle and the class name on the service's {@code ServiceReference}
+	 * object must return {@code true}
+	 * </ul>
+	 * 
+	 * @param <S> Type of Service
+	 * @param clazz The class name with which the service was registered. Must
+	 *        not be {@code null}.
+	 * @param filter The filter expression or {@code null} for all services.
+	 * @return A collection of {@code ServiceReference} objects. May be empty if
+	 *         no services are registered which satisfy the search.
+	 * @throws InvalidSyntaxException If the specified {@code filter} contains
+	 *         an invalid filter expression that cannot be parsed.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @since 1.6
+	 */
+	<S> Collection<ServiceReference<S>> getServiceReferences(Class<S> clazz,
+			String filter) throws InvalidSyntaxException;
+
+	/**
+	 * Returns the service object referenced by the specified
+	 * {@code ServiceReference} object.
+	 * <p>
+	 * A bundle's use of a service is tracked by the bundle's use count of that
+	 * service. Each time a service's service object is returned by
+	 * {@link #getService(ServiceReference)} the context bundle's use count for
+	 * that service is incremented by one. Each time the service is released by
+	 * {@link #ungetService(ServiceReference)} the context bundle's use count
+	 * for that service is decremented by one.
+	 * <p>
+	 * When a bundle's use count for a service drops to zero, the bundle should
+	 * no longer use that service.
+	 * 
+	 * <p>
+	 * This method will always return {@code null} when the service associated
+	 * with this {@code reference} has been unregistered.
+	 * 
+	 * <p>
+	 * The following steps are required to get the service object:
+	 * <ol>
+	 * <li>If the service has been unregistered, {@code null} is returned.
+	 * <li>If the context bundle's use count for the service is currently zero
+	 * and the service was registered with an object implementing the
+	 * {@code ServiceFactory} interface, the
+	 * {@link ServiceFactory#getService(Bundle, ServiceRegistration)} method is
+	 * called to create a service object for the context bundle. If the service
+	 * object returned by the {@code ServiceFactory} object is {@code null}, not
+	 * an {@code instanceof} all the classes named when the service was
+	 * registered or the {@code ServiceFactory} object throws an exception or
+	 * will be recursively called for the context bundle, {@code null} is
+	 * returned and a Framework event of type {@link FrameworkEvent#ERROR}
+	 * containing a {@link ServiceException} describing the error is fired. <br>
+	 * This service object is cached by the Framework. While the context
+	 * bundle's use count for the service is greater than zero, subsequent calls
+	 * to get the services's service object for the context bundle will return
+	 * the cached service object.
+	 * <li>The context bundle's use count for this service is incremented by
+	 * one.
+	 * <li>The service object for the service is returned.
+	 * </ol>
+	 * 
+	 * @param <S> Type of Service.
+	 * @param reference A reference to the service.
+	 * @return A service object for the service associated with
+	 *         {@code reference} or {@code null} if the service is not
+	 *         registered, the service object returned by a
+	 *         {@code ServiceFactory} does not implement the classes under which
+	 *         it was registered or the {@code ServiceFactory} threw an
+	 *         exception.
+	 * @throws SecurityException If the caller does not have the
+	 *         {@code ServicePermission} to get the service using at least one
+	 *         of the named classes the service was registered under and the
+	 *         Java Runtime Environment supports permissions.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code ServiceReference} was not created by the same framework
+	 *         instance as this {@code BundleContext}.
+	 * @see #ungetService(ServiceReference)
+	 * @see ServiceFactory
+	 */
+	<S> S getService(ServiceReference<S> reference);
+
+	/**
+	 * Releases the service object referenced by the specified
+	 * {@code ServiceReference} object. If the context bundle's use count for
+	 * the service is zero, this method returns {@code false}. Otherwise, the
+	 * context bundle's use count for the service is decremented by one.
+	 * 
+	 * <p>
+	 * The service's service object should no longer be used and all references
+	 * to it should be destroyed when a bundle's use count for the service drops
+	 * to zero.
+	 * 
+	 * <p>
+	 * The following steps are required to unget the service object:
+	 * <ol>
+	 * <li>If the context bundle's use count for the service is zero or the
+	 * service has been unregistered, {@code false} is returned.
+	 * <li>The context bundle's use count for this service is decremented by
+	 * one.
+	 * <li>If the context bundle's use count for the service is currently zero
+	 * and the service was registered with a {@code ServiceFactory} object, the
+	 * {@link ServiceFactory#ungetService(Bundle, ServiceRegistration, Object)}
+	 * method is called to release the service object for the context bundle.
+	 * <li>{@code true} is returned.
+	 * </ol>
+	 * 
+	 * @param reference A reference to the service to be released.
+	 * @return {@code false} if the context bundle's use count for the service
+	 *         is zero or if the service has been unregistered; {@code true}
+	 *         otherwise.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code ServiceReference} was not created by the same framework
+	 *         instance as this {@code BundleContext}.
+	 * @see #getService
+	 * @see ServiceFactory
+	 */
+	boolean ungetService(ServiceReference< ? > reference);
+
+	/**
+	 * Creates a {@code File} object for a file in the persistent storage area
+	 * provided for the bundle by the Framework. This method will return
+	 * {@code null} if the platform does not have file system support.
+	 * 
+	 * <p>
+	 * A {@code File} object for the base directory of the persistent storage
+	 * area provided for the context bundle by the Framework can be obtained by
+	 * calling this method with an empty string as {@code filename}.
+	 * 
+	 * <p>
+	 * If the Java Runtime Environment supports permissions, the Framework will
+	 * ensure that the bundle has the {@code java.io.FilePermission} with
+	 * actions {@code read},{@code write},{@code delete} for all files
+	 * (recursively) in the persistent storage area provided for the context
+	 * bundle.
+	 * 
+	 * @param filename A relative name to the file to be accessed.
+	 * @return A {@code File} object that represents the requested file or
+	 *         {@code null} if the platform does not have file system support.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 */
+	File getDataFile(String filename);
+
+	/**
+	 * Creates a {@code Filter} object. This {@code Filter} object may be used
+	 * to match a {@code ServiceReference} object or a {@code Dictionary}
+	 * object.
+	 * 
+	 * <p>
+	 * If the filter cannot be parsed, an {@link InvalidSyntaxException} will be
+	 * thrown with a human readable message where the filter became unparsable.
+	 * 
+	 * @param filter The filter string.
+	 * @return A {@code Filter} object encapsulating the filter string.
+	 * @throws InvalidSyntaxException If {@code filter} contains an invalid
+	 *         filter string that cannot be parsed.
+	 * @throws NullPointerException If {@code filter} is null.
+	 * @throws IllegalStateException If this BundleContext is no longer valid.
+	 * @see "Framework specification for a description of the filter string syntax."
+	 * @see FrameworkUtil#createFilter(String)
+	 * @since 1.1
+	 */
+	Filter createFilter(String filter) throws InvalidSyntaxException;
+
+	/**
+	 * Returns the bundle with the specified location.
+	 * 
+	 * @param location The location of the bundle to retrieve.
+	 * @return A {@code Bundle} object or {@code null} if the location does not
+	 *         match any installed bundle.
+	 * @since 1.6
+	 */
+	Bundle getBundle(String location);
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleEvent.java b/main/src/main/java/org/osgi/framework/BundleEvent.java
new file mode 100644
index 0000000000..13c68bed26
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleEvent.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.EventObject;
+
+/**
+ * An event from the Framework describing a bundle lifecycle change.
+ * <p>
+ * {@code BundleEvent} objects are delivered to
+ * {@code SynchronousBundleListener}s and {@code BundleListener}s
+ * when a change occurs in a bundle's lifecycle. A type code is used to identify
+ * the event type for future extendability.
+ * 
+ * <p>
+ * OSGi Alliance reserves the right to extend the set of types.
+ * 
+ * @Immutable
+ * @see BundleListener
+ * @see SynchronousBundleListener
+ * @version $Id: ed3c40cd707bed45681cadce114a6cc5db27a844 $
+ */
+
+public class BundleEvent extends EventObject {
+	static final long		serialVersionUID	= 4080640865971756012L;
+	/**
+	 * Bundle that had a change occur in its lifecycle.
+	 */
+	private final Bundle	bundle;
+
+	/**
+	 * Type of bundle lifecycle change.
+	 */
+	private final int		type;
+
+	/**
+	 * The bundle has been installed.
+	 * 
+	 * @see BundleContext#installBundle(String)
+	 */
+	public final static int	INSTALLED			= 0x00000001;
+
+	/**
+	 * The bundle has been started.
+	 * <p>
+	 * The bundle's
+	 * {@link BundleActivator#start(BundleContext) BundleActivator start} method
+	 * has been executed if the bundle has a bundle activator class.
+	 * 
+	 * @see Bundle#start()
+	 */
+	public final static int	STARTED				= 0x00000002;
+
+	/**
+	 * The bundle has been stopped.
+	 * <p>
+	 * The bundle's
+	 * {@link BundleActivator#stop(BundleContext) BundleActivator stop} method
+	 * has been executed if the bundle has a bundle activator class.
+	 * 
+	 * @see Bundle#stop()
+	 */
+	public final static int	STOPPED				= 0x00000004;
+
+	/**
+	 * The bundle has been updated.
+	 * 
+	 * @see Bundle#update()
+	 */
+	public final static int	UPDATED				= 0x00000008;
+
+	/**
+	 * The bundle has been uninstalled.
+	 * 
+	 * @see Bundle#uninstall
+	 */
+	public final static int	UNINSTALLED			= 0x00000010;
+
+	/**
+	 * The bundle has been resolved.
+	 * 
+	 * @see Bundle#RESOLVED
+	 * @since 1.3
+	 */
+	public final static int	RESOLVED			= 0x00000020;
+
+	/**
+	 * The bundle has been unresolved.
+	 * 
+	 * @see Bundle#INSTALLED
+	 * @since 1.3
+	 */
+	public final static int	UNRESOLVED			= 0x00000040;
+
+	/**
+	 * The bundle is about to be activated.
+	 * <p>
+	 * The bundle's
+	 * {@link BundleActivator#start(BundleContext) BundleActivator start} method
+	 * is about to be called if the bundle has a bundle activator class. This
+	 * event is only delivered to {@link SynchronousBundleListener}s. It is not
+	 * delivered to {@code BundleListener}s.
+	 * 
+	 * @see Bundle#start()
+	 * @since 1.3
+	 */
+	public final static int	STARTING			= 0x00000080;
+
+	/**
+	 * The bundle is about to deactivated.
+	 * <p>
+	 * The bundle's
+	 * {@link BundleActivator#stop(BundleContext) BundleActivator stop} method
+	 * is about to be called if the bundle has a bundle activator class. This
+	 * event is only delivered to {@link SynchronousBundleListener}s. It is not
+	 * delivered to {@code BundleListener}s.
+	 * 
+	 * @see Bundle#stop()
+	 * @since 1.3
+	 */
+	public final static int	STOPPING			= 0x00000100;
+
+	/**
+	 * The bundle will be lazily activated.
+	 * <p>
+	 * The bundle has a {@link Constants#ACTIVATION_LAZY lazy activation policy}
+	 * and is waiting to be activated. It is now in the
+	 * {@link Bundle#STARTING STARTING} state and has a valid
+	 * {@code BundleContext}. This event is only delivered to
+	 * {@link SynchronousBundleListener}s. It is not delivered to
+	 * {@code BundleListener}s.
+	 * 
+	 * @since 1.4
+	 */
+	public final static int	LAZY_ACTIVATION		= 0x00000200;
+
+	/**
+	 * Bundle that was the origin of the event. For install event type, this is
+	 * the bundle whose context was used to install the bundle. Otherwise it is
+	 * the bundle itself.
+	 * 
+	 * @since 1.6
+	 */
+	private final Bundle	origin;
+
+	/**
+	 * Creates a bundle event of the specified type.
+	 * 
+	 * @param type The event type.
+	 * @param bundle The bundle which had a lifecycle change.
+	 * @param origin The bundle which is the origin of the event. For the event
+	 *        type {@link #INSTALLED}, this is the bundle whose context was used
+	 *        to install the bundle. Otherwise it is the bundle itself.
+	 * @since 1.6
+	 */
+	public BundleEvent(int type, Bundle bundle, Bundle origin) {
+		super(bundle);
+		if (origin == null) {
+			throw new IllegalArgumentException("null origin");
+		}
+		this.bundle = bundle;
+		this.type = type;
+		this.origin = origin;
+	}
+
+	/**
+	 * Creates a bundle event of the specified type.
+	 * 
+	 * @param type The event type.
+	 * @param bundle The bundle which had a lifecycle change. This bundle is
+	 *        used as the origin of the event.
+	 */
+	public BundleEvent(int type, Bundle bundle) {
+		super(bundle);
+		this.bundle = bundle;
+		this.type = type;
+		this.origin = bundle;
+	}
+
+	/**
+	 * Returns the bundle which had a lifecycle change. This bundle is the
+	 * source of the event.
+	 * 
+	 * @return The bundle that had a change occur in its lifecycle.
+	 */
+	public Bundle getBundle() {
+		return bundle;
+	}
+
+	/**
+	 * Returns the type of lifecyle event. The type values are:
+	 * <ul>
+	 * <li>{@link #INSTALLED}
+	 * <li>{@link #RESOLVED}
+	 * <li>{@link #LAZY_ACTIVATION}
+	 * <li>{@link #STARTING}
+	 * <li>{@link #STARTED}
+	 * <li>{@link #STOPPING}
+	 * <li>{@link #STOPPED}
+	 * <li>{@link #UPDATED}
+	 * <li>{@link #UNRESOLVED}
+	 * <li>{@link #UNINSTALLED}
+	 * </ul>
+	 * 
+	 * @return The type of lifecycle event.
+	 */
+	public int getType() {
+		return type;
+	}
+
+	/**
+	 * Returns the bundle that was the origin of the event.
+	 * 
+	 * <p>
+	 * For the event type {@link #INSTALLED}, this is the bundle whose context
+	 * was used to install the bundle. Otherwise it is the bundle itself.
+	 * 
+	 * @return The bundle that was the origin of the event.
+	 * @since 1.6
+	 */
+	public Bundle getOrigin() {
+		return origin;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleException.java b/main/src/main/java/org/osgi/framework/BundleException.java
new file mode 100644
index 0000000000..9cae61a776
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleException.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A Framework exception used to indicate that a bundle lifecycle problem
+ * occurred.
+ * 
+ * <p>
+ * A {@code BundleException} object is created by the Framework to denote
+ * an exception condition in the lifecycle of a bundle.
+ * {@code BundleException}s should not be created by bundle developers.
+ * A type code is used to identify the exception type for future extendability.
+ * 
+ * <p>
+ * OSGi Alliance reserves the right to extend the set of types.
+ * 
+ * <p>
+ * This exception conforms to the general purpose exception chaining mechanism.
+ * 
+ * @version $Id: 9e117ec9667b040f7752e342aa07d6c7d5bf0275 $
+ */
+
+public class BundleException extends Exception {
+	static final long		serialVersionUID		= 3571095144220455665L;
+	/**
+	 * Type of bundle exception.
+	 * 
+	 * @since 1.5
+	 */
+	private final int		type;
+
+	/**
+	 * No exception type is specified.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	UNSPECIFIED				= 0;
+	/**
+	 * The operation was unsupported. This type can be used anywhere a 
+	 * BundleException can be thrown.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	UNSUPPORTED_OPERATION	= 1;
+	/**
+	 * The operation was invalid.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	INVALID_OPERATION		= 2;
+	/**
+	 * The bundle manifest was in error.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	MANIFEST_ERROR			= 3;
+	/**
+	 * The bundle was not resolved.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	RESOLVE_ERROR			= 4;
+	/**
+	 * The bundle activator was in error.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	ACTIVATOR_ERROR			= 5;
+	/**
+	 * The operation failed due to insufficient permissions.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	SECURITY_ERROR			= 6;
+	/**
+	 * The operation failed to complete the requested lifecycle state change.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	STATECHANGE_ERROR		= 7;
+
+	/**
+	 * The bundle could not be resolved due to an error with the
+	 * Bundle-NativeCode header.
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	NATIVECODE_ERROR		= 8;
+
+	/**
+	 * The install or update operation failed because another already installed
+	 * bundle has the same symbolic name and version. This exception type will
+	 * only occur if the framework is configured to only allow a single bundle
+	 * to be installed for a given symbolic name and version.
+	 * 
+	 * @see Constants#FRAMEWORK_BSNVERSION
+	 * @since 1.5
+	 */
+	public static final int	DUPLICATE_BUNDLE_ERROR	= 9;
+	
+    /**
+	 * The start transient operation failed because the start level of the
+	 * bundle is greater than the current framework start level
+	 * 
+	 * @since 1.5
+	 */
+	public static final int	START_TRANSIENT_ERROR	= 10;
+
+	/**
+	 * The framework received an error while reading the input stream for a
+	 * bundle.
+	 * 
+	 * @since 1.6
+	 */
+	public static final int	READ_ERROR				= 11;
+
+	/**
+	 * A framework hook rejected the operation.
+	 * 
+	 * @since 1.6
+	 */
+	public static final int	REJECTED_BY_HOOK		= 12;
+
+	/**
+	 * Creates a {@code BundleException} with the specified message and
+	 * exception cause.
+	 * 
+	 * @param msg The associated message.
+	 * @param cause The cause of this exception.
+	 */
+	public BundleException(String msg, Throwable cause) {
+		this(msg, UNSPECIFIED, cause);
+	}
+
+	/**
+	 * Creates a {@code BundleException} with the specified message.
+	 * 
+	 * @param msg The message.
+	 */
+	public BundleException(String msg) {
+		this(msg, UNSPECIFIED);
+	}
+
+	/**
+	 * Creates a {@code BundleException} with the specified message, type
+	 * and exception cause.
+	 * 
+	 * @param msg The associated message.
+	 * @param type The type for this exception.
+	 * @param cause The cause of this exception.
+	 * @since 1.5
+	 */
+	public BundleException(String msg, int type, Throwable cause) {
+		super(msg, cause);
+		this.type = type;
+	}
+
+	/**
+	 * Creates a {@code BundleException} with the specified message and
+	 * type.
+	 * 
+	 * @param msg The message.
+	 * @param type The type for this exception.
+	 * @since 1.5
+	 */
+	public BundleException(String msg, int type) {
+		super(msg);
+		this.type = type;
+	}
+
+	/**
+	 * Returns the cause of this exception or {@code null} if no cause was
+	 * specified when this exception was created.
+	 * 
+	 * <p>
+	 * This method predates the general purpose exception chaining mechanism.
+	 * The {@code getCause()} method is now the preferred means of
+	 * obtaining this information.
+	 * 
+	 * @return The result of calling {@code getCause()}.
+	 */
+	public Throwable getNestedException() {
+		return getCause();
+	}
+
+	/**
+	 * Returns the cause of this exception or {@code null} if no cause was
+	 * set.
+	 * 
+	 * @return The cause of this exception or {@code null} if no cause was
+	 *         set.
+	 * @since 1.3
+	 */
+	public Throwable getCause() {
+		return super.getCause();
+	}
+
+	/**
+	 * Initializes the cause of this exception to the specified value.
+	 * 
+	 * @param cause The cause of this exception.
+	 * @return This exception.
+	 * @throws IllegalArgumentException If the specified cause is this
+	 *         exception.
+	 * @throws IllegalStateException If the cause of this exception has already
+	 *         been set.
+	 * @since 1.3
+	 */
+	public Throwable initCause(Throwable cause) {
+		return super.initCause(cause);
+	}
+
+	/**
+	 * Returns the type for this exception or {@code UNSPECIFIED} if the
+	 * type was unspecified or unknown.
+	 * 
+	 * @return The type of this exception.
+	 * @since 1.5
+	 */
+	public int getType() {
+		return type;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleListener.java b/main/src/main/java/org/osgi/framework/BundleListener.java
new file mode 100644
index 0000000000..d9bb54cf8c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleListener.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.EventListener;
+
+/**
+ * A {@code BundleEvent} listener. {@code BundleListener} is a
+ * listener interface that may be implemented by a bundle developer. When a
+ * {@code BundleEvent} is fired, it is asynchronously delivered to a
+ * {@code BundleListener}. The Framework delivers
+ * {@code BundleEvent} objects to a {@code BundleListener} in
+ * order and must not concurrently call a {@code BundleListener}.
+ * <p>
+ * A {@code BundleListener} object is registered with the Framework using
+ * the {@link BundleContext#addBundleListener} method.
+ * {@code BundleListener}s are called with a {@code BundleEvent}
+ * object when a bundle has been installed, resolved, started, stopped, updated,
+ * unresolved, or uninstalled.
+ * 
+ * @see BundleEvent
+ * @NotThreadSafe
+ * @version $Id: 77cdaebd3ac97c6798fc3043957abd1bd6d01ccb $
+ */
+
+public interface BundleListener extends EventListener {
+	/**
+	 * Receives notification that a bundle has had a lifecycle change.
+	 * 
+	 * @param event The {@code BundleEvent}.
+	 */
+	public void bundleChanged(BundleEvent event);
+}
diff --git a/main/src/main/java/org/osgi/framework/BundlePermission.java b/main/src/main/java/org/osgi/framework/BundlePermission.java
new file mode 100644
index 0000000000..e6f9356ad8
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundlePermission.java
@@ -0,0 +1,611 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A bundle's authority to require or provide a bundle or to receive or attach
+ * fragments.
+ * 
+ * <p>
+ * A bundle symbolic name defines a unique fully qualified name. Wildcards may
+ * be used.
+ * 
+ * <pre>
+ * name ::= &lt;symbolic name&gt; | &lt;symbolic name ending in &quot;.*&quot;&gt; | *
+ * </pre>
+ * 
+ * Examples:
+ * 
+ * <pre>
+ * org.osgi.example.bundle
+ * org.osgi.example.*
+ * *
+ * </pre>
+ * 
+ * <p>
+ * {@code BundlePermission} has four actions: {@code provide},
+ * {@code require},{@code host}, and {@code fragment}. The
+ * {@code provide} action implies the {@code require} action.
+ * 
+ * @since 1.3
+ * @ThreadSafe
+ * @version $Id: d30c9c987cc13007ed19d3a9fdd11b00739591c0 $
+ */
+
+public final class BundlePermission extends BasicPermission {
+
+	private static final long	serialVersionUID	= 3257846601685873716L;
+
+	/**
+	 * The action string {@code provide}. The {@code provide} action
+	 * implies the {@code require} action.
+	 */
+	public final static String	PROVIDE				= "provide";
+
+	/**
+	 * The action string {@code require}. The {@code require} action
+	 * is implied by the {@code provide} action.
+	 */
+	public final static String	REQUIRE				= "require";
+
+	/**
+	 * The action string {@code host}.
+	 */
+	public final static String	HOST				= "host";
+
+	/**
+	 * The action string {@code fragment}.
+	 */
+	public final static String	FRAGMENT			= "fragment";
+
+	private final static int	ACTION_PROVIDE		= 0x00000001;
+	private final static int	ACTION_REQUIRE		= 0x00000002;
+	private final static int	ACTION_HOST			= 0x00000004;
+	private final static int	ACTION_FRAGMENT		= 0x00000008;
+	private final static int	ACTION_ALL			= ACTION_PROVIDE
+															| ACTION_REQUIRE
+															| ACTION_HOST
+															| ACTION_FRAGMENT;
+	final static int			ACTION_NONE			= 0;
+	/**
+	 * The actions mask.
+	 */
+	private transient int		action_mask;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String		actions				= null;
+
+	/**
+	 * Defines the authority to provide and/or require and or specify a host
+	 * fragment symbolic name within the OSGi environment.
+	 * <p>
+	 * Bundle Permissions are granted over all possible versions of a bundle.
+	 * 
+	 * A bundle that needs to provide a bundle must have the appropriate
+	 * {@code BundlePermission} for the symbolic name; a bundle that
+	 * requires a bundle must have the appropriate {@code BundlePermssion}
+	 * for that symbolic name; a bundle that specifies a fragment host must have
+	 * the appropriate {@code BundlePermission} for that symbolic name.
+	 * 
+	 * @param symbolicName The bundle symbolic name.
+	 * @param actions {@code provide},{@code require},
+	 *        {@code host},{@code fragment} (canonical order).
+	 */
+	public BundlePermission(String symbolicName, String actions) {
+		this(symbolicName, parseActions(actions));
+	}
+
+	/**
+	 * Package private constructor used by BundlePermissionCollection.
+	 * 
+	 * @param symbolicName the bundle symbolic name
+	 * @param mask the action mask
+	 */
+	BundlePermission(String symbolicName, int mask) {
+		super(symbolicName);
+		setTransients(mask);
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param mask
+	 */
+	private synchronized void setTransients(int mask) {
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+
+		action_mask = mask;
+	}
+
+	/**
+	 * Returns the current action mask.
+	 * <p>
+	 * Used by the BundlePermissionCollection class.
+	 * 
+	 * @return Current action mask.
+	 */
+	synchronized int getActionsMask() {
+		return action_mask;
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		boolean seencomma = false;
+
+		int mask = ACTION_NONE;
+
+		if (actions == null) {
+			return mask;
+		}
+
+		char[] a = actions.toCharArray();
+
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+
+		while (i != -1) {
+			char c;
+
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+
+			// check for the known strings
+			int matchlen;
+
+			if (i >= 6 && (a[i - 6] == 'p' || a[i - 6] == 'P')
+					&& (a[i - 5] == 'r' || a[i - 5] == 'R')
+					&& (a[i - 4] == 'o' || a[i - 4] == 'O')
+					&& (a[i - 3] == 'v' || a[i - 3] == 'V')
+					&& (a[i - 2] == 'i' || a[i - 2] == 'I')
+					&& (a[i - 1] == 'd' || a[i - 1] == 'D')
+					&& (a[i] == 'e' || a[i] == 'E')) {
+				matchlen = 7;
+				mask |= ACTION_PROVIDE | ACTION_REQUIRE;
+			}
+			else
+				if (i >= 6 && (a[i - 6] == 'r' || a[i - 6] == 'R')
+						&& (a[i - 5] == 'e' || a[i - 5] == 'E')
+						&& (a[i - 4] == 'q' || a[i - 4] == 'Q')
+						&& (a[i - 3] == 'u' || a[i - 3] == 'U')
+						&& (a[i - 2] == 'i' || a[i - 2] == 'I')
+						&& (a[i - 1] == 'r' || a[i - 1] == 'R')
+						&& (a[i] == 'e' || a[i] == 'E')) {
+					matchlen = 7;
+					mask |= ACTION_REQUIRE;
+				}
+				else
+					if (i >= 3 && (a[i - 3] == 'h' || a[i - 3] == 'H')
+							&& (a[i - 2] == 'o' || a[i - 2] == 'O')
+							&& (a[i - 1] == 's' || a[i - 1] == 'S')
+							&& (a[i] == 't' || a[i] == 'T')) {
+						matchlen = 4;
+						mask |= ACTION_HOST;
+					}
+					else
+						if (i >= 7 && (a[i - 7] == 'f' || a[i - 7] == 'F')
+								&& (a[i - 6] == 'r' || a[i - 6] == 'R')
+								&& (a[i - 5] == 'a' || a[i - 5] == 'A')
+								&& (a[i - 4] == 'g' || a[i - 4] == 'G')
+								&& (a[i - 3] == 'm' || a[i - 3] == 'M')
+								&& (a[i - 2] == 'e' || a[i - 2] == 'E')
+								&& (a[i - 1] == 'n' || a[i - 1] == 'N')
+								&& (a[i] == 't' || a[i] == 'T')) {
+							matchlen = 8;
+							mask |= ACTION_FRAGMENT;
+						}
+						else {
+							// parse error
+							throw new IllegalArgumentException(
+									"invalid permission: " + actions);
+						}
+
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfrequire". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+						/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+				}
+				i--;
+			}
+
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid permission: " + actions);
+		}
+
+		return mask;
+	}
+
+	/**
+	 * Determines if the specified permission is implied by this object.
+	 * 
+	 * <p>
+	 * This method checks that the symbolic name of the target is implied by the
+	 * symbolic name of this object. The list of {@code BundlePermission}
+	 * actions must either match or allow for the list of the target object to
+	 * imply the target {@code BundlePermission} action.
+	 * <p>
+	 * The permission to provide a bundle implies the permission to require the
+	 * named symbolic name.
+	 * 
+	 * <pre>
+	 *       x.y.*,&quot;provide&quot; -&gt; x.y.z,&quot;provide&quot; is true
+	 *       *,&quot;require&quot; -&gt; x.y, &quot;require&quot;      is true
+	 *       *,&quot;provide&quot; -&gt; x.y, &quot;require&quot;      is true
+	 *       x.y,&quot;provide&quot; -&gt; x.y.z, &quot;provide&quot;  is false
+	 * </pre>
+	 * 
+	 * @param p The requested permission.
+	 * @return {@code true} if the specified {@code BundlePermission}
+	 *         action is implied by this object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof BundlePermission)) {
+			return false;
+		}
+		BundlePermission requested = (BundlePermission) p;
+
+		final int effective = getActionsMask();
+		final int desired = requested.getActionsMask();
+		return ((effective & desired) == desired)
+				&& super.implies(requested);
+	}
+
+	/**
+	 * Returns the canonical string representation of the
+	 * {@code BundlePermission} actions.
+	 * 
+	 * <p>
+	 * Always returns present {@code BundlePermission} actions in the
+	 * following order: {@code provide}, {@code require},
+	 * {@code host}, {@code fragment}.
+	 * 
+	 * @return Canonical string representation of the {@code BundlePermission
+	 *         } actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			StringBuffer sb = new StringBuffer();
+			boolean comma = false;
+
+			if ((action_mask & ACTION_PROVIDE) == ACTION_PROVIDE) {
+				sb.append(PROVIDE);
+				comma = true;
+			}
+
+			if ((action_mask & ACTION_REQUIRE) == ACTION_REQUIRE) {
+				if (comma)
+					sb.append(',');
+				sb.append(REQUIRE);
+				comma = true;
+			}
+
+			if ((action_mask & ACTION_HOST) == ACTION_HOST) {
+				if (comma)
+					sb.append(',');
+				sb.append(HOST);
+				comma = true;
+			}
+
+			if ((action_mask & ACTION_FRAGMENT) == ACTION_FRAGMENT) {
+				if (comma)
+					sb.append(',');
+				sb.append(FRAGMENT);
+			}
+
+			actions = result = sb.toString();
+		}
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object suitable for
+	 * storing {@code BundlePermission} objects.
+	 * 
+	 * @return A new {@code PermissionCollection} object.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new BundlePermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two {@code BundlePermission} objects.
+	 * 
+	 * This method checks that specified bundle has the same bundle symbolic
+	 * name and {@code BundlePermission} actions as this
+	 * {@code BundlePermission} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code BundlePermission} object.
+	 * @return {@code true} if {@code obj} is a
+	 *         {@code BundlePermission}, and has the same bundle symbolic
+	 *         name and actions as this {@code BundlePermission} object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof BundlePermission)) {
+			return false;
+		}
+
+		BundlePermission bp = (BundlePermission) obj;
+
+		return (getActionsMask() == bp.getActionsMask())
+				&& getName().equals(bp.getName());
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of the
+	 * {@code BundlePermission} object to a stream. The actions are
+	 * serialized, and the superclass takes care of the name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of the BundlePermission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the action, then initialize the rest
+		s.defaultReadObject();
+		setTransients(parseActions(actions));
+	}
+}
+
+/**
+ * Stores a set of {@code BundlePermission} permissions.
+ * 
+ * @see java.security.Permission
+ * @see java.security.Permissions
+ * @see java.security.PermissionCollection
+ */
+
+final class BundlePermissionCollection extends PermissionCollection {
+	private static final long	serialVersionUID	= 3258407326846433079L;
+
+	/**
+	 * Table of permissions.
+	 * 
+	 * @GuardedBy this
+	 */
+	private transient Map<String, BundlePermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean				all_allowed;
+
+	/**
+	 * Create an empty BundlePermissions object.
+	 * 
+	 */
+	public BundlePermissionCollection() {
+		permissions = new HashMap<String, BundlePermission>();
+		all_allowed = false;
+	}
+
+	/**
+	 * Add a permission to this permission collection.
+	 * 
+	 * @param permission The {@code BundlePermission} object to add.
+	 * @throws IllegalArgumentException If the permission is not a
+	 *         {@code BundlePermission} instance.
+	 * @throws SecurityException If this {@code BundlePermissionCollection}
+	 *         object has been marked read-only.
+	 */
+	public void add(final Permission permission) {
+		if (!(permission instanceof BundlePermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection");
+		}
+		final BundlePermission bp = (BundlePermission) permission;
+		final String name = bp.getName();
+		synchronized (this) {
+			Map<String, BundlePermission> pc = permissions;
+			BundlePermission existing = pc.get(name);
+			if (existing != null) {
+				final int oldMask = existing.getActionsMask();
+				final int newMask = bp.getActionsMask();
+				if (oldMask != newMask) {
+					pc.put(name, new BundlePermission(name, oldMask
+							| newMask));
+
+				}
+			}
+			else {
+				pc.put(name, bp);
+			}
+
+			if (!all_allowed) {
+				if (name.equals("*"))
+					all_allowed = true;
+			}
+		}
+	}
+
+	/**
+	 * Determines if the specified permissions implies the permissions expressed
+	 * in {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare with this
+	 *        {@code BundlePermission} object.
+	 * @return {@code true} if {@code permission} is a proper subset
+	 *         of a permission in the set; {@code false} otherwise.
+	 */
+	public boolean implies(final Permission permission) {
+		if (!(permission instanceof BundlePermission)) {
+			return false;
+		}
+		BundlePermission requested = (BundlePermission) permission;
+		String requestedName = requested.getName();
+		final int desired = requested.getActionsMask();
+		int effective = BundlePermission.ACTION_NONE;
+		BundlePermission bp;
+
+		synchronized (this) {
+			Map<String, BundlePermission> pc = permissions;
+			/* short circuit if the "*" Permission was added */
+			if (all_allowed) {
+				bp = pc.get("*");
+				if (bp != null) {
+					effective |= bp.getActionsMask();
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			bp = pc.get(requestedName);
+			// strategy:
+			// Check for full match first. Then work our way up the
+			// name looking for matches on a.b.*
+			if (bp != null) {
+				// we have a direct hit!
+				effective |= bp.getActionsMask();
+				if ((effective & desired) == desired) {
+					return true;
+				}
+			}
+			// work our way up the tree...
+			int last;
+			int offset = requestedName.length() - 1;
+			while ((last = requestedName.lastIndexOf(".", offset)) != -1) {
+				requestedName = requestedName.substring(0, last + 1) + "*";
+				bp = pc.get(requestedName);
+				if (bp != null) {
+					effective |= bp.getActionsMask();
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+				offset = last - 1;
+			}
+			// we don't have to check for "*" as it was already checked
+			// at the top (all_allowed), so we just return false
+			return false;
+		}
+	}
+
+	/**
+	 * Returns an enumeration of all {@code BundlePermission} objects in
+	 * the container.
+	 * 
+	 * @return Enumeration of all {@code BundlePermission} objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		return Collections.enumeration(all);
+	}
+	
+	/* serialization logic */
+	private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", Hashtable.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE)			};
+
+	private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		Hashtable<String, BundlePermission> hashtable = new Hashtable<String, BundlePermission>(
+				permissions);
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", hashtable);
+		pfields.put("all_allowed", all_allowed);
+		out.writeFields();
+	}
+
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException, ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		Hashtable<String, BundlePermission> hashtable = (Hashtable<String, BundlePermission>) gfields
+				.get("permissions", null);
+		permissions = new HashMap<String, BundlePermission>(hashtable);
+		all_allowed = gfields.get("all_allowed", false);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/BundleReference.java b/main/src/main/java/org/osgi/framework/BundleReference.java
new file mode 100644
index 0000000000..97340f7b47
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/BundleReference.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A reference to a Bundle.
+ * 
+ * @since 1.5
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: e61bd3e020264b04022a430fe09a85ee3aabf1a3 $
+ */
+public interface BundleReference {
+	/**
+	 * Returns the {@code Bundle} object associated with this
+	 * {@code BundleReference}.
+	 * 
+	 * @return The {@code Bundle} object associated with this
+	 *         {@code BundleReference}.
+	 */
+	public Bundle getBundle();
+}
diff --git a/main/src/main/java/org/osgi/framework/CapabilityPermission.java b/main/src/main/java/org/osgi/framework/CapabilityPermission.java
new file mode 100644
index 0000000000..bcac7906cd
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/CapabilityPermission.java
@@ -0,0 +1,807 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.AccessController;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.PrivilegedAction;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A bundle's authority to provide or require a capability.
+ * <ul>
+ * <li>The {@code provide} action allows a bundle to provide a capability
+ * matching the specified filter.
+ * <li>The {@code require} action allows a bundle to require a capability
+ * matching the specified filter.
+ * </ul>
+ * 
+ * @ThreadSafe
+ * @version $Id: bab1ac06b46613f6cff39b291295d8b3e51d58ce $
+ * @since 1.6
+ */
+
+public final class CapabilityPermission extends BasicPermission {
+	static final long								serialVersionUID	= -7662148639076511574L;
+	/**
+	 * The action string {@code require}.
+	 */
+	public final static String						REQUIRE				= "require";
+	/**
+	 * The action string {@code provide}.
+	 */
+	public final static String						PROVIDE				= "provide";
+
+	private final static int						ACTION_REQUIRE		= 0x00000001;
+	private final static int						ACTION_PROVIDE		= 0x00000002;
+	private final static int						ACTION_ALL			= ACTION_REQUIRE
+																				| ACTION_PROVIDE;
+	final static int								ACTION_NONE			= 0;
+
+	/**
+	 * The actions mask.
+	 */
+	transient int									action_mask;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String							actions				= null;
+
+	/**
+	 * The attributes of the requested capability. Must be null if not
+	 * constructed with attributes.
+	 */
+	transient final Map<String, Object>				attributes;
+
+	/**
+	 * The bundle of the requested capability. Must be null if not constructed
+	 * with bundle.
+	 */
+	transient final Bundle							bundle;
+
+	/**
+	 * If this CapabilityPermission was constructed with a filter, this holds a
+	 * Filter matching object used to evaluate the filter in implies.
+	 */
+	transient Filter								filter;
+
+	/**
+	 * This map holds the properties of the permission, used to match a filter
+	 * in implies. This is not initialized until necessary, and then cached in
+	 * this object.
+	 */
+	private transient volatile Map<String, Object>	properties;
+
+	/**
+	 * Create a new CapabilityPermission.
+	 * 
+	 * <p>
+	 * The name is specified as a dot-separated string. Wildcards may be used.
+	 * 
+	 * <pre>
+	 * name ::= &lt;namespace&gt; | &lt;namespace ending in &quot;.*&quot;&gt; | *
+	 * </pre>
+	 * 
+	 * Examples:
+	 * 
+	 * <pre>
+	 * com.acme.capability.*
+	 * org.foo.capability
+	 * *
+	 * </pre>
+	 * 
+	 * For the {@code require} action, the name can also be a filter expression.
+	 * The filter gives access to the capability attributes as well as the
+	 * following attributes:
+	 * <ul>
+	 * <li>signer - A Distinguished Name chain used to sign the bundle providing
+	 * the capability. Wildcards in a DN are not matched according to the filter
+	 * string rules, but according to the rules defined for a DN chain.</li>
+	 * <li>location - The location of the bundle providing the capability.</li>
+	 * <li>id - The bundle ID of the bundle providing the capability.</li>
+	 * <li>name - The symbolic name of the bundle providing the capability.</li>
+	 * <li>capability.namespace - The name space of the required capability.</li>
+	 * </ul>
+	 * Since the above attribute names may conflict with attribute names of a
+	 * capability, you can prefix an attribute name with '@' in the filter
+	 * expression to match against the capability attributes and not one of the
+	 * above attributes. Filter attribute names are processed in a case
+	 * sensitive manner.
+	 * 
+	 * <p>
+	 * There are two possible actions: {@code require} and {@code provide}. The
+	 * {@code require} permission allows the owner of this permission to require
+	 * a capability matching the attributes. The {@code provide} permission
+	 * allows the bundle to provide a capability in the specified capability
+	 * name space.
+	 * 
+	 * @param name The capability name space or a filter over the attributes.
+	 * @param actions {@code require},{@code provide} (canonical order)
+	 * @throws IllegalArgumentException If the specified name is a filter
+	 *         expression and either the specified action is not {@code require}
+	 *         or the filter has an invalid syntax.
+	 */
+	public CapabilityPermission(String name, String actions) {
+		this(name, parseActions(actions));
+		if ((this.filter != null)
+				&& ((action_mask & ACTION_ALL) != ACTION_REQUIRE)) {
+			throw new IllegalArgumentException(
+					"invalid action string for filter expression");
+		}
+	}
+
+	/**
+	 * Creates a new requested {@code CapabilityPermission} object to be used by
+	 * code that must perform {@code checkPermission} for the {@code require}
+	 * action. {@code CapabilityPermission} objects created with this
+	 * constructor cannot be added to a {@code CapabilityPermission} permission
+	 * collection.
+	 * 
+	 * @param namespace The requested capability name space.
+	 * @param attributes The requested capability attributes.
+	 * @param providingBundle The bundle providing the requested capability.
+	 * @param actions The action {@code require}.
+	 * @throws IllegalArgumentException If the specified action is not
+	 *         {@code require} or attributes or providingBundle are {@code null}
+	 *         .
+	 */
+	public CapabilityPermission(String namespace, Map<String, ? > attributes,
+			Bundle providingBundle, String actions) {
+		super(namespace);
+		setTransients(namespace, parseActions(actions));
+		if (attributes == null) {
+			throw new IllegalArgumentException("attributes must not be null");
+		}
+		if (providingBundle == null) {
+			throw new IllegalArgumentException("bundle must not be null");
+		}
+		this.attributes = new HashMap<String, Object>(attributes);
+		this.bundle = providingBundle;
+		if ((action_mask & ACTION_ALL) != ACTION_REQUIRE) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+	}
+
+	/**
+	 * Package private constructor used by CapabilityPermissionCollection.
+	 * 
+	 * @param name class name
+	 * @param mask action mask
+	 */
+	CapabilityPermission(String name, int mask) {
+		super(name);
+		setTransients(name, mask);
+		this.attributes = null;
+		this.bundle = null;
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param mask action mask
+	 */
+	private void setTransients(String name, int mask) {
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+		action_mask = mask;
+		filter = parseFilter(name);
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		boolean seencomma = false;
+
+		int mask = ACTION_NONE;
+
+		if (actions == null) {
+			return mask;
+		}
+
+		char[] a = actions.toCharArray();
+
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+
+		while (i != -1) {
+			char c;
+
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+
+			// check for the known strings
+			int matchlen;
+
+			if (i >= 6 && (a[i - 6] == 'r' || a[i - 6] == 'R')
+					&& (a[i - 5] == 'e' || a[i - 5] == 'E')
+					&& (a[i - 4] == 'q' || a[i - 4] == 'Q')
+					&& (a[i - 3] == 'u' || a[i - 3] == 'U')
+					&& (a[i - 2] == 'i' || a[i - 2] == 'I')
+					&& (a[i - 1] == 'r' || a[i - 1] == 'R')
+					&& (a[i] == 'e' || a[i] == 'E')) {
+				matchlen = 7;
+				mask |= ACTION_REQUIRE;
+			}
+			else
+				if (i >= 6 && (a[i - 6] == 'p' || a[i - 6] == 'P')
+						&& (a[i - 5] == 'r' || a[i - 5] == 'R')
+						&& (a[i - 4] == 'o' || a[i - 4] == 'O')
+						&& (a[i - 3] == 'v' || a[i - 3] == 'V')
+						&& (a[i - 2] == 'i' || a[i - 2] == 'I')
+						&& (a[i - 1] == 'd' || a[i - 1] == 'D')
+						&& (a[i] == 'e' || a[i] == 'E')) {
+					matchlen = 7;
+					mask |= ACTION_PROVIDE;
+				}
+				else {
+					// parse error
+					throw new IllegalArgumentException("invalid permission: "
+							+ actions);
+				}
+
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfprovide". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+						/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+				}
+				i--;
+			}
+
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid permission: " + actions);
+		}
+
+		return mask;
+	}
+
+	/**
+	 * Parse filter string into a Filter object.
+	 * 
+	 * @param filterString The filter string to parse.
+	 * @return a Filter for this bundle. If the specified filterString is not a
+	 *         filter expression, then {@code null} is returned.
+	 * @throws IllegalArgumentException If the filter syntax is invalid.
+	 */
+	private static Filter parseFilter(String filterString) {
+		filterString = filterString.trim();
+		if (filterString.charAt(0) != '(') {
+			return null;
+		}
+
+		try {
+			return FrameworkUtil.createFilter(filterString);
+		}
+		catch (InvalidSyntaxException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid filter");
+			iae.initCause(e);
+			throw iae;
+		}
+	}
+
+	/**
+	 * Determines if a {@code CapabilityPermission} object "implies" the
+	 * specified permission.
+	 * 
+	 * @param p The target permission to check.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof CapabilityPermission)) {
+			return false;
+		}
+		CapabilityPermission requested = (CapabilityPermission) p;
+		if (bundle != null) {
+			return false;
+		}
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		return implies0(requested, ACTION_NONE);
+	}
+
+	/**
+	 * Internal implies method. Used by the implies and the permission
+	 * collection implies methods.
+	 * 
+	 * @param requested The requested CapabilityPermission which has already be
+	 *        validated as a proper argument. The requested CapabilityPermission
+	 *        must not have a filter expression.
+	 * @param effective The effective actions with which to start.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	boolean implies0(CapabilityPermission requested, int effective) {
+		/* check actions first - much faster */
+		effective |= action_mask;
+		final int desired = requested.action_mask;
+		if ((effective & desired) != desired) {
+			return false;
+		}
+		/* Get filter if any */
+		Filter f = filter;
+		if (f == null) {
+			return super.implies(requested);
+		}
+		return f.matches(requested.getProperties());
+	}
+
+	/**
+	 * Returns the canonical string representation of the actions. Always
+	 * returns present actions in the following order: {@code require},
+	 * {@code provide}.
+	 * 
+	 * @return The canonical string representation of the actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			StringBuffer sb = new StringBuffer();
+			boolean comma = false;
+
+			int mask = action_mask;
+			if ((mask & ACTION_REQUIRE) == ACTION_REQUIRE) {
+				sb.append(REQUIRE);
+				comma = true;
+			}
+
+			if ((mask & ACTION_PROVIDE) == ACTION_PROVIDE) {
+				if (comma)
+					sb.append(',');
+				sb.append(PROVIDE);
+			}
+
+			actions = result = sb.toString();
+		}
+
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object for storing
+	 * {@code CapabilityPermission} objects.
+	 * 
+	 * @return A new {@code PermissionCollection} object suitable for storing
+	 *         {@code CapabilityPermission} objects.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new CapabilityPermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two CapabilityPermission objects.
+	 * 
+	 * Checks that specified object has the same name and action as this
+	 * {@code CapabilityPermission}.
+	 * 
+	 * @param obj The object to test for equality.
+	 * @return true if obj is a {@code CapabilityPermission}, and has the same
+	 *         name and actions as this {@code CapabilityPermission} object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof CapabilityPermission)) {
+			return false;
+		}
+
+		CapabilityPermission cp = (CapabilityPermission) obj;
+
+		return (action_mask == cp.action_mask)
+				&& getName().equals(cp.getName())
+				&& ((attributes == cp.attributes) || ((attributes != null) && (attributes
+						.equals(cp.attributes))))
+				&& ((bundle == cp.bundle) || ((bundle != null) && bundle
+						.equals(cp.bundle)));
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return Hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		if (attributes != null) {
+			h = 31 * h + attributes.hashCode();
+		}
+		if (bundle != null) {
+			h = 31 * h + bundle.hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of this permission to a stream.
+	 * The actions are serialized, and the superclass takes care of the name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		if (bundle != null) {
+			throw new NotSerializableException("cannot serialize");
+		}
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of this permission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the action, then initialize the rest
+		s.defaultReadObject();
+		setTransients(getName(), parseActions(actions));
+	}
+
+	/**
+	 * Called by {@code <@link CapabilityPermission#implies(Permission)>}. This
+	 * method is only called on a requested permission which cannot have a
+	 * filter set.
+	 * 
+	 * @return a map of properties for this permission.
+	 */
+	private Map<String, Object> getProperties() {
+		Map<String, Object> result = properties;
+		if (result != null) {
+			return result;
+		}
+		final Map<String, Object> props = new HashMap<String, Object>(5);
+		props.put("capability.namespace", getName());
+		if (bundle == null) {
+			return properties = props;
+		}
+		AccessController.doPrivileged(new PrivilegedAction<Object>() {
+			public Object run() {
+				props.put("id", new Long(bundle.getBundleId()));
+				props.put("location", bundle.getLocation());
+				String name = bundle.getSymbolicName();
+				if (name != null) {
+					props.put("name", name);
+				}
+				SignerProperty signer = new SignerProperty(bundle);
+				if (signer.isBundleSigned()) {
+					props.put("signer", signer);
+				}
+				return null;
+			}
+		});
+		return properties = new Properties(props, attributes);
+	}
+
+	static private final class Properties extends AbstractMap<String, Object> {
+		private final Map<String, Object>							properties;
+		private final Map<String, Object>							attributes;
+		private transient volatile Set<Map.Entry<String, Object>>	entries;
+
+		Properties(Map<String, Object> properties,
+				Map<String, Object> attributes) {
+			this.properties = properties;
+			this.attributes = attributes;
+			entries = null;
+		}
+
+		public Object get(Object k) {
+			if (!(k instanceof String)) {
+				return null;
+			}
+			String key = (String) k;
+			if (key.charAt(0) == '@') {
+				return attributes.get(key.substring(1));
+			}
+			Object value = properties.get(key);
+			if (value != null) { // fall back to service properties
+				return value;
+			}
+			return attributes.get(key);
+		}
+
+		public Set<Map.Entry<String, Object>> entrySet() {
+			if (entries != null) {
+				return entries;
+			}
+			Set<Map.Entry<String, Object>> all = new HashSet<Map.Entry<String, Object>>(
+					attributes.size() + properties.size());
+			all.addAll(attributes.entrySet());
+			all.addAll(properties.entrySet());
+			return entries = Collections.unmodifiableSet(all);
+		}
+	}
+}
+
+/**
+ * Stores a set of CapabilityPermission permissions.
+ * 
+ * @see java.security.Permission
+ * @see java.security.Permissions
+ * @see java.security.PermissionCollection
+ */
+final class CapabilityPermissionCollection extends PermissionCollection {
+	static final long							serialVersionUID	= -615322242639008920L;
+
+	/**
+	 * Table of permissions.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private Map<String, CapabilityPermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean								all_allowed;
+
+	/**
+	 * Table of permissions with filter expressions.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private Map<String, CapabilityPermission>	filterPermissions;
+
+	/**
+	 * Creates an empty CapabilityPermissionCollection object.
+	 */
+	public CapabilityPermissionCollection() {
+		permissions = new HashMap<String, CapabilityPermission>();
+		all_allowed = false;
+	}
+
+	/**
+	 * Adds a permission to this permission collection.
+	 * 
+	 * @param permission The Permission object to add.
+	 * @throws IllegalArgumentException If the specified permission is not a
+	 *         CapabilityPermission object.
+	 * @throws SecurityException If this {@code CapabilityPermissionCollection}
+	 *         object has been marked read-only.
+	 */
+	public void add(final Permission permission) {
+		if (!(permission instanceof CapabilityPermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection");
+		}
+
+		final CapabilityPermission cp = (CapabilityPermission) permission;
+		if (cp.bundle != null) {
+			throw new IllegalArgumentException("cannot add to collection: "
+					+ cp);
+		}
+
+		final String name = cp.getName();
+		final Filter f = cp.filter;
+		synchronized (this) {
+			/* select the bucket for the permission */
+			Map<String, CapabilityPermission> pc;
+			if (f != null) {
+				pc = filterPermissions;
+				if (pc == null) {
+					filterPermissions = pc = new HashMap<String, CapabilityPermission>();
+				}
+			}
+			else {
+				pc = permissions;
+			}
+			final CapabilityPermission existing = pc.get(name);
+
+			if (existing != null) {
+				final int oldMask = existing.action_mask;
+				final int newMask = cp.action_mask;
+				if (oldMask != newMask) {
+					pc.put(name, new CapabilityPermission(name, oldMask
+							| newMask));
+				}
+			}
+			else {
+				pc.put(name, cp);
+			}
+
+			if (!all_allowed) {
+				if (name.equals("*")) {
+					all_allowed = true;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Determines if a set of permissions implies the permissions expressed in
+	 * {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare.
+	 * @return {@code true} if {@code permission} is a proper subset of a
+	 *         permission in the set; {@code false} otherwise.
+	 */
+	public boolean implies(final Permission permission) {
+		if (!(permission instanceof CapabilityPermission)) {
+			return false;
+		}
+		final CapabilityPermission requested = (CapabilityPermission) permission;
+		/* if requested permission has a filter, then it is an invalid argument */
+		if (requested.filter != null) {
+			return false;
+		}
+
+		String requestedName = requested.getName();
+		final int desired = requested.action_mask;
+		int effective = CapabilityPermission.ACTION_NONE;
+
+		Collection<CapabilityPermission> perms;
+		synchronized (this) {
+			Map<String, CapabilityPermission> pc = permissions;
+			CapabilityPermission cp;
+			/* short circuit if the "*" Permission was added */
+			if (all_allowed) {
+				cp = pc.get("*");
+				if (cp != null) {
+					effective |= cp.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+
+			/*
+			 * strategy: Check for full match first. Then work our way up the
+			 * name looking for matches on a.b.*
+			 */
+			cp = pc.get(requestedName);
+			if (cp != null) {
+				/* we have a direct hit! */
+				effective |= cp.action_mask;
+				if ((effective & desired) == desired) {
+					return true;
+				}
+			}
+			/* work our way up the tree... */
+			int last;
+			int offset = requestedName.length() - 1;
+			while ((last = requestedName.lastIndexOf(".", offset)) != -1) {
+				requestedName = requestedName.substring(0, last + 1) + "*";
+				cp = pc.get(requestedName);
+				if (cp != null) {
+					effective |= cp.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+				offset = last - 1;
+			}
+			/*
+			 * we don't have to check for "*" as it was already checked before
+			 * we were called.
+			 */
+			pc = filterPermissions;
+			if (pc == null) {
+				return false;
+			}
+			perms = pc.values();
+		}
+		/* iterate one by one over filteredPermissions */
+		for (CapabilityPermission perm : perms) {
+			if (perm.implies0(requested, effective)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns an enumeration of all the {@code CapabilityPermission} objects in
+	 * the container.
+	 * 
+	 * @return Enumeration of all the CapabilityPermission objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		Map<String, CapabilityPermission> pc = filterPermissions;
+		if (pc != null) {
+			all.addAll(pc.values());
+		}
+		return Collections.enumeration(all);
+	}
+
+	/* serialization logic */
+	private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", HashMap.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE),
+			new ObjectStreamField("filterPermissions", HashMap.class)	};
+
+	private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", permissions);
+		pfields.put("all_allowed", all_allowed);
+		pfields.put("filterPermissions", filterPermissions);
+		out.writeFields();
+	}
+
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException, ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		HashMap<String, CapabilityPermission> p = (HashMap<String, CapabilityPermission>) gfields
+				.get("permissions", null);
+		permissions = p;
+		all_allowed = gfields.get("all_allowed", false);
+		HashMap<String, CapabilityPermission> fp = (HashMap<String, CapabilityPermission>) gfields
+				.get("filterPermissions", null);
+		filterPermissions = fp;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/Configurable.java b/main/src/main/java/org/osgi/framework/Configurable.java
new file mode 100644
index 0000000000..d82da9b3f2
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/Configurable.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * Supports a configuration object.
+ * 
+ * <p>
+ * {@code Configurable} is an interface that should be used by a bundle
+ * developer in support of a configurable service. Bundles that need to
+ * configure a service may test to determine if the service object is an
+ * {@code instanceof Configurable}.
+ * 
+ * @deprecated As of 1.2. Please use Configuration Admin service.
+ * @version $Id: 29705c0c238aa456cda1b1a13458079bf1542771 $
+ */
+public interface Configurable {
+	/**
+	 * Returns this service's configuration object.
+	 * 
+	 * <p>
+	 * Services implementing {@code Configurable} should take care when
+	 * returning a service configuration object since this object is probably
+	 * sensitive.
+	 * <p>
+	 * If the Java Runtime Environment supports permissions, it is recommended
+	 * that the caller is checked for some appropriate permission before
+	 * returning the configuration object.
+	 * 
+	 * @return The configuration object for this service.
+	 * @throws SecurityException If the caller does not have an
+	 *         appropriate permission and the Java Runtime Environment supports
+	 *         permissions.
+	 * @deprecated As of 1.2. Please use Configuration Admin service.
+	 */
+	public Object getConfigurationObject();
+}
diff --git a/main/src/main/java/org/osgi/framework/Constants.java b/main/src/main/java/org/osgi/framework/Constants.java
new file mode 100644
index 0000000000..b71a12dfdd
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/Constants.java
@@ -0,0 +1,1684 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2011). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import org.osgi.framework.launch.Framework;
+
+/**
+ * Defines standard names for the OSGi environment system properties, service
+ * properties, and Manifest header attribute keys.
+ * 
+ * <p>
+ * The values associated with these keys are of type {@code String}, unless
+ * otherwise indicated.
+ * 
+ * @since 1.1
+ * @noimplement
+ * @version $Id: 517c954ed7d34d2ee762933466f69fa03db7cd37 $
+ */
+
+public interface Constants {
+	/**
+	 * Location identifier of the OSGi <i>system bundle </i>, which is defined
+	 * to be &quot;System Bundle&quot;.
+	 */
+	String	SYSTEM_BUNDLE_LOCATION					= "System Bundle";
+
+	/**
+	 * Alias for the symbolic name of the OSGi <i>system bundle </i>. It is
+	 * defined to be &quot;system.bundle&quot;.
+	 * 
+	 * @since 1.3
+	 */
+	String	SYSTEM_BUNDLE_SYMBOLICNAME				= "system.bundle";
+
+	/**
+	 * Manifest header identifying the bundle's category.
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_CATEGORY							= "Bundle-Category";
+
+	/**
+	 * Manifest header identifying a list of directories and embedded JAR files,
+	 * which are bundle resources used to extend the bundle's classpath.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_CLASSPATH						= "Bundle-ClassPath";
+
+	/**
+	 * Manifest header identifying the bundle's copyright information.
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_COPYRIGHT						= "Bundle-Copyright";
+
+	/**
+	 * Manifest header containing a brief description of the bundle's
+	 * functionality.
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_DESCRIPTION						= "Bundle-Description";
+
+	/**
+	 * Manifest header identifying the bundle's name.
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_NAME								= "Bundle-Name";
+
+	/**
+	 * Manifest header identifying a number of hardware environments and the
+	 * native language code libraries that the bundle is carrying for each of
+	 * these environments.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_NATIVECODE						= "Bundle-NativeCode";
+
+	/**
+	 * Manifest header identifying the packages that the bundle offers to the
+	 * Framework for export.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	EXPORT_PACKAGE							= "Export-Package";
+
+	/**
+	 * Manifest header identifying the fully qualified class names of the
+	 * services that the bundle may register (used for informational purposes
+	 * only).
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @deprecated As of 1.2.
+	 */
+	String	EXPORT_SERVICE							= "Export-Service";
+
+	/**
+	 * Manifest header identifying the packages on which the bundle depends.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	IMPORT_PACKAGE							= "Import-Package";
+
+	/**
+	 * Manifest header identifying the packages that the bundle may dynamically
+	 * import during execution.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.2
+	 */
+	String	DYNAMICIMPORT_PACKAGE					= "DynamicImport-Package";
+
+	/**
+	 * Manifest header identifying the fully qualified class names of the
+	 * services that the bundle requires (used for informational purposes only).
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @deprecated As of 1.2.
+	 */
+	String	IMPORT_SERVICE							= "Import-Service";
+
+	/**
+	 * Manifest header identifying the bundle's vendor.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_VENDOR							= "Bundle-Vendor";
+
+	/**
+	 * Manifest header identifying the bundle's version.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_VERSION							= "Bundle-Version";
+
+	/**
+	 * Manifest header identifying the bundle's documentation URL, from which
+	 * further information about the bundle may be obtained.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_DOCURL							= "Bundle-DocURL";
+
+	/**
+	 * Manifest header identifying the contact address where problems with the
+	 * bundle may be reported; for example, an email address.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_CONTACTADDRESS					= "Bundle-ContactAddress";
+
+	/**
+	 * Manifest header attribute identifying the bundle's activator class.
+	 * 
+	 * <p>
+	 * If present, this header specifies the name of the bundle resource class
+	 * that implements the {@code BundleActivator} interface and whose
+	 * {@code start} and {@code stop} methods are called by the Framework when
+	 * the bundle is started and stopped, respectively.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_ACTIVATOR						= "Bundle-Activator";
+
+	/**
+	 * Manifest header identifying the location from which a new bundle version
+	 * is obtained during a bundle update operation.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 */
+	String	BUNDLE_UPDATELOCATION					= "Bundle-UpdateLocation";
+
+	/**
+	 * Manifest header attribute identifying the version of a package specified
+	 * in the Export-Package or Import-Package manifest header.
+	 * 
+	 * @deprecated As of 1.3. This has been replaced by
+	 *             {@link #VERSION_ATTRIBUTE}.
+	 */
+	String	PACKAGE_SPECIFICATION_VERSION			= "specification-version";
+
+	/**
+	 * Manifest header attribute identifying the processor required to run
+	 * native bundle code specified in the Bundle-NativeCode manifest header).
+	 * 
+	 * <p>
+	 * The attribute value is encoded in the Bundle-NativeCode manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-NativeCode: http.so ; processor=x86 ...
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_NATIVECODE
+	 */
+	String	BUNDLE_NATIVECODE_PROCESSOR				= "processor";
+
+	/**
+	 * Manifest header attribute identifying the operating system required to
+	 * run native bundle code specified in the Bundle-NativeCode manifest
+	 * header).
+	 * <p>
+	 * The attribute value is encoded in the Bundle-NativeCode manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-NativeCode: http.so ; osname=Linux ...
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_NATIVECODE
+	 */
+	String	BUNDLE_NATIVECODE_OSNAME				= "osname";
+
+	/**
+	 * Manifest header attribute identifying the operating system version
+	 * required to run native bundle code specified in the Bundle-NativeCode
+	 * manifest header).
+	 * <p>
+	 * The attribute value is encoded in the Bundle-NativeCode manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-NativeCode: http.so ; osversion=&quot;2.34&quot; ...
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_NATIVECODE
+	 */
+	String	BUNDLE_NATIVECODE_OSVERSION				= "osversion";
+
+	/**
+	 * Manifest header attribute identifying the language in which the native
+	 * bundle code is written specified in the Bundle-NativeCode manifest
+	 * header. See ISO 639 for possible values.
+	 * <p>
+	 * The attribute value is encoded in the Bundle-NativeCode manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-NativeCode: http.so ; language=nl_be ...
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_NATIVECODE
+	 */
+	String	BUNDLE_NATIVECODE_LANGUAGE				= "language";
+
+	/**
+	 * Manifest header identifying the required execution environment for the
+	 * bundle. The service platform may run this bundle if any of the execution
+	 * environments named in this header matches one of the execution
+	 * environments it implements.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.2
+	 * @deprecated As of 1.6. Replaced by the {@code osgi.ee} capability.
+	 */
+	String	BUNDLE_REQUIREDEXECUTIONENVIRONMENT		= "Bundle-RequiredExecutionEnvironment";
+
+	/**
+	 * Manifest header identifying the bundle's symbolic name.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	BUNDLE_SYMBOLICNAME						= "Bundle-SymbolicName";
+
+	/**
+	 * Manifest header directive identifying whether a bundle is a singleton.
+	 * The default value is {@code false}.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Bundle-SymbolicName manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-SymbolicName: com.acme.module.test; singleton:=true
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_SYMBOLICNAME
+	 * @since 1.3
+	 */
+	String	SINGLETON_DIRECTIVE						= "singleton";
+
+	/**
+	 * Manifest header directive identifying if and when a fragment may attach
+	 * to a host bundle. The default value is
+	 * {@link #FRAGMENT_ATTACHMENT_ALWAYS always}.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Bundle-SymbolicName manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=&quot;never&quot;
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_SYMBOLICNAME
+	 * @see #FRAGMENT_ATTACHMENT_ALWAYS
+	 * @see #FRAGMENT_ATTACHMENT_RESOLVETIME
+	 * @see #FRAGMENT_ATTACHMENT_NEVER
+	 * @since 1.3
+	 */
+	String	FRAGMENT_ATTACHMENT_DIRECTIVE			= "fragment-attachment";
+
+	/**
+	 * Manifest header directive value identifying a fragment attachment type of
+	 * always. A fragment attachment type of always indicates that fragments are
+	 * allowed to attach to the host bundle at any time (while the host is
+	 * resolved or during the process of resolving the host bundle).
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Bundle-SymbolicName manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=&quot;always&quot;
+	 * </pre>
+	 * 
+	 * @see #FRAGMENT_ATTACHMENT_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	FRAGMENT_ATTACHMENT_ALWAYS				= "always";
+
+	/**
+	 * Manifest header directive value identifying a fragment attachment type of
+	 * resolve-time. A fragment attachment type of resolve-time indicates that
+	 * fragments are allowed to attach to the host bundle only during the
+	 * process of resolving the host bundle.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Bundle-SymbolicName manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=&quot;resolve-time&quot;
+	 * </pre>
+	 * 
+	 * @see #FRAGMENT_ATTACHMENT_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	FRAGMENT_ATTACHMENT_RESOLVETIME			= "resolve-time";
+
+	/**
+	 * Manifest header directive value identifying a fragment attachment type of
+	 * never. A fragment attachment type of never indicates that no fragments
+	 * are allowed to attach to the host bundle at any time.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Bundle-SymbolicName manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Bundle-SymbolicName: com.acme.module.test; fragment-attachment:=&quot;never&quot;
+	 * </pre>
+	 * 
+	 * @see #FRAGMENT_ATTACHMENT_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	FRAGMENT_ATTACHMENT_NEVER				= "never";
+
+	/**
+	 * Manifest header identifying the base name of the bundle's localization
+	 * entries.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @see #BUNDLE_LOCALIZATION_DEFAULT_BASENAME
+	 * @since 1.3
+	 */
+	String	BUNDLE_LOCALIZATION						= "Bundle-Localization";
+
+	/**
+	 * Default value for the {@code Bundle-Localization} manifest header.
+	 * 
+	 * @see #BUNDLE_LOCALIZATION
+	 * @since 1.3
+	 */
+	String	BUNDLE_LOCALIZATION_DEFAULT_BASENAME	= "OSGI-INF/l10n/bundle";
+
+	/**
+	 * Manifest header identifying the symbolic names of other bundles required
+	 * by the bundle.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	REQUIRE_BUNDLE							= "Require-Bundle";
+
+	/**
+	 * Manifest header attribute identifying a range of versions for a bundle
+	 * specified in the {@code Require-Bundle} or {@code Fragment-Host} manifest
+	 * headers. The default value is {@code 0.0.0}.
+	 * 
+	 * <p>
+	 * The attribute value is encoded in the Require-Bundle manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Require-Bundle: com.acme.module.test; bundle-version=&quot;1.1&quot;
+	 *     Require-Bundle: com.acme.module.test; bundle-version=&quot;[1.0,2.0)&quot;
+	 * </pre>
+	 * 
+	 * <p>
+	 * The bundle-version attribute value uses a mathematical interval notation
+	 * to specify a range of bundle versions. A bundle-version attribute value
+	 * specified as a single version means a version range that includes any
+	 * bundle version greater than or equal to the specified version.
+	 * 
+	 * @see #REQUIRE_BUNDLE
+	 * @since 1.3
+	 */
+	String	BUNDLE_VERSION_ATTRIBUTE				= "bundle-version";
+
+	/**
+	 * Manifest header identifying the symbolic name of another bundle for which
+	 * that the bundle is a fragment.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	FRAGMENT_HOST							= "Fragment-Host";
+
+	/**
+	 * Manifest header attribute is used for selection by filtering based upon
+	 * system properties.
+	 * 
+	 * <p>
+	 * The attribute value is encoded in manifest headers like:
+	 * 
+	 * <pre>
+	 *     Bundle-NativeCode: libgtk.so; selection-filter=&quot;(ws=gtk)&quot;; ...
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_NATIVECODE
+	 * @since 1.3
+	 */
+	String	SELECTION_FILTER_ATTRIBUTE				= "selection-filter";
+
+	/**
+	 * Manifest header identifying the bundle manifest version. A bundle
+	 * manifest may express the version of the syntax in which it is written by
+	 * specifying a bundle manifest version. Bundles exploiting OSGi Release 4,
+	 * or later, syntax must specify a bundle manifest version.
+	 * <p>
+	 * The bundle manifest version defined by OSGi Release 4 or, more
+	 * specifically, by version 1.3 of the OSGi Core Specification is "2".
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	BUNDLE_MANIFESTVERSION					= "Bundle-ManifestVersion";
+
+	/**
+	 * Manifest header attribute identifying the version of a package specified
+	 * in the Export-Package or Import-Package manifest header.
+	 * 
+	 * <p>
+	 * The attribute value is encoded in the Export-Package or Import-Package
+	 * manifest header like:
+	 * 
+	 * <pre>
+	 *     Export-Package: org.osgi.framework; version=&quot;1.1&quot;
+	 * </pre>
+	 * 
+	 * @see #EXPORT_PACKAGE
+	 * @see #IMPORT_PACKAGE
+	 * @since 1.3
+	 */
+	String	VERSION_ATTRIBUTE						= "version";
+
+	/**
+	 * Manifest header attribute identifying the symbolic name of a bundle that
+	 * exports a package specified in the Import-Package manifest header.
+	 * 
+	 * <p>
+	 * The attribute value is encoded in the Import-Package manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Import-Package: org.osgi.framework; bundle-symbolic-name=&quot;com.acme.module.test&quot;
+	 * </pre>
+	 * 
+	 * @see #IMPORT_PACKAGE
+	 * @since 1.3
+	 */
+	String	BUNDLE_SYMBOLICNAME_ATTRIBUTE			= "bundle-symbolic-name";
+
+	/**
+	 * Manifest header directive identifying the resolution type in the
+	 * Import-Package, Require-Bundle or Require-Capability manifest header. The
+	 * default value is {@link #RESOLUTION_MANDATORY mandatory}.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Import-Package, Require-Bundle or
+	 * Require-Capability manifest header like:
+	 * 
+	 * <pre>
+	 *     Import-Package: org.osgi.framework; resolution:=&quot;optional&quot;
+	 *     Require-Bundle: com.acme.module.test; resolution:=&quot;optional&quot;
+	 *     Require-Capability: com.acme.capability; resolution:=&quot;optional&quot;
+	 * </pre>
+	 * 
+	 * @see #IMPORT_PACKAGE
+	 * @see #REQUIRE_BUNDLE
+	 * @see #REQUIRE_CAPABILITY
+	 * @see #RESOLUTION_MANDATORY
+	 * @see #RESOLUTION_OPTIONAL
+	 * @since 1.3
+	 */
+	String	RESOLUTION_DIRECTIVE					= "resolution";
+
+	/**
+	 * Manifest header directive value identifying a mandatory resolution type.
+	 * A mandatory resolution type indicates that the import package, require
+	 * bundle or require capability must be resolved when the bundle is
+	 * resolved. If such an import, require bundle or require capability cannot
+	 * be resolved, the module fails to resolve.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Import-Package, Require-Bundle or
+	 * Require-Capability manifest header like:
+	 * 
+	 * <pre>
+	 *     Import-Package: org.osgi.framework; resolution:=&quot;mandatory&quot;
+	 *     Require-Bundle: com.acme.module.test; resolution:=&quot;mandatory&quot;
+	 *     Require-Capability: com.acme.capability; resolution:=&quot;mandatory&quot;
+	 * </pre>
+	 * 
+	 * @see #RESOLUTION_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	RESOLUTION_MANDATORY					= "mandatory";
+
+	/**
+	 * Manifest header directive value identifying an optional resolution type.
+	 * An optional resolution type indicates that the import, require bundle or
+	 * require capability is optional and the bundle may be resolved without the
+	 * import, require bundle or require capability being resolved. If the
+	 * import, require bundle or require capability is not resolved when the
+	 * bundle is resolved, the import, require bundle or require capability may
+	 * not be resolved until the bundle is refreshed.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Import-Package, Require-Bundle or
+	 * Require-Capability manifest header like:
+	 * 
+	 * <pre>
+	 *     Import-Package: org.osgi.framework; resolution:=&quot;optional&quot;
+	 *     Require-Bundle: com.acme.module.test; resolution:=&quot;optional&quot;
+	 *     Require-Capability: com.acme.capability; resolution:=&quot;optional&quot;
+	 * </pre>
+	 * 
+	 * @see #RESOLUTION_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	RESOLUTION_OPTIONAL						= "optional";
+
+	/**
+	 * Manifest header directive identifying a list of packages that an exported
+	 * package or provided capability uses.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Export-Package or
+	 * Provide-Capability manifest header like:
+	 * 
+	 * <pre>
+	 *     Export-Package: org.osgi.util.tracker; uses:=&quot;org.osgi.framework&quot;
+	 *     Provide-Capability: com.acme.capability; uses:=&quot;com.acme.service&quot;
+	 * </pre>
+	 * 
+	 * @see #EXPORT_PACKAGE
+	 * @see #PROVIDE_CAPABILITY
+	 * @since 1.3
+	 */
+	String	USES_DIRECTIVE							= "uses";
+
+	/**
+	 * Manifest header directive identifying a list of classes to include in the
+	 * exported package.
+	 * 
+	 * <p>
+	 * This directive is used by the Export-Package manifest header to identify
+	 * a list of classes of the specified package which must be allowed to be
+	 * exported. The directive value is encoded in the Export-Package manifest
+	 * header like:
+	 * 
+	 * <pre>
+	 *     Export-Package: org.osgi.framework; include:=&quot;MyClass*&quot;
+	 * </pre>
+	 * 
+	 * <p>
+	 * This directive is also used by the Bundle-ActivationPolicy manifest
+	 * header to identify the packages from which class loads will trigger lazy
+	 * activation. The directive value is encoded in the Bundle-ActivationPolicy
+	 * manifest header like:
+	 * 
+	 * <pre>
+	 *     Bundle-ActivationPolicy: lazy; include:=&quot;org.osgi.framework&quot;
+	 * </pre>
+	 * 
+	 * @see #EXPORT_PACKAGE
+	 * @see #BUNDLE_ACTIVATIONPOLICY
+	 * @since 1.3
+	 */
+	String	INCLUDE_DIRECTIVE						= "include";
+
+	/**
+	 * Manifest header directive identifying a list of classes to exclude in the
+	 * exported package..
+	 * <p>
+	 * This directive is used by the Export-Package manifest header to identify
+	 * a list of classes of the specified package which must not be allowed to
+	 * be exported. The directive value is encoded in the Export-Package
+	 * manifest header like:
+	 * 
+	 * <pre>
+	 *     Export-Package: org.osgi.framework; exclude:=&quot;*Impl&quot;
+	 * </pre>
+	 * 
+	 * <p>
+	 * This directive is also used by the Bundle-ActivationPolicy manifest
+	 * header to identify the packages from which class loads will not trigger
+	 * lazy activation. The directive value is encoded in the
+	 * Bundle-ActivationPolicy manifest header like:
+	 * 
+	 * <pre>
+	 *     Bundle-ActivationPolicy: lazy; exclude:=&quot;org.osgi.framework&quot;
+	 * </pre>
+	 * 
+	 * @see #EXPORT_PACKAGE
+	 * @see #BUNDLE_ACTIVATIONPOLICY
+	 * @since 1.3
+	 */
+	String	EXCLUDE_DIRECTIVE						= "exclude";
+
+	/**
+	 * Manifest header directive identifying names of matching attributes which
+	 * must be specified by matching Import-Package statements in the
+	 * Export-Package manifest header.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Export-Package manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Export-Package: org.osgi.framework; mandatory:=&quot;bundle-symbolic-name&quot;
+	 * </pre>
+	 * 
+	 * @see #EXPORT_PACKAGE
+	 * @since 1.3
+	 */
+	String	MANDATORY_DIRECTIVE						= "mandatory";
+
+	/**
+	 * Manifest header directive identifying the visibility of a required bundle
+	 * in the Require-Bundle manifest header. The default value is
+	 * {@link #VISIBILITY_PRIVATE private}.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Require-Bundle manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Require-Bundle: com.acme.module.test; visibility:=&quot;reexport&quot;
+	 * </pre>
+	 * 
+	 * @see #REQUIRE_BUNDLE
+	 * @see #VISIBILITY_PRIVATE
+	 * @see #VISIBILITY_REEXPORT
+	 * @since 1.3
+	 */
+	String	VISIBILITY_DIRECTIVE					= "visibility";
+
+	/**
+	 * Manifest header directive value identifying a private visibility type. A
+	 * private visibility type indicates that any packages that are exported by
+	 * the required bundle are not made visible on the export signature of the
+	 * requiring bundle.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Require-Bundle manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Require-Bundle: com.acme.module.test; visibility:=&quot;private&quot;
+	 * </pre>
+	 * 
+	 * @see #VISIBILITY_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	VISIBILITY_PRIVATE						= "private";
+
+	/**
+	 * Manifest header directive value identifying a reexport visibility type. A
+	 * reexport visibility type indicates any packages that are exported by the
+	 * required bundle are re-exported by the requiring bundle. Any arbitrary
+	 * arbitrary matching attributes with which they were exported by the
+	 * required bundle are deleted.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Require-Bundle manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Require-Bundle: com.acme.module.test; visibility:=&quot;reexport&quot;
+	 * </pre>
+	 * 
+	 * @see #VISIBILITY_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	VISIBILITY_REEXPORT						= "reexport";
+
+	/**
+	 * Manifest header directive identifying the type of the extension fragment.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Fragment-Host manifest header like:
+	 * 
+	 * <pre>
+	 *     Fragment-Host: system.bundle; extension:=&quot;framework&quot;
+	 * </pre>
+	 * 
+	 * @see #FRAGMENT_HOST
+	 * @see #EXTENSION_FRAMEWORK
+	 * @see #EXTENSION_BOOTCLASSPATH
+	 * @since 1.3
+	 */
+	String	EXTENSION_DIRECTIVE						= "extension";
+
+	/**
+	 * Manifest header directive value identifying the type of extension
+	 * fragment. An extension fragment type of framework indicates that the
+	 * extension fragment is to be loaded by the framework's class loader.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Fragment-Host manifest header like:
+	 * 
+	 * <pre>
+	 *     Fragment-Host: system.bundle; extension:=&quot;framework&quot;
+	 * </pre>
+	 * 
+	 * @see #EXTENSION_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	EXTENSION_FRAMEWORK						= "framework";
+
+	/**
+	 * Manifest header directive value identifying the type of extension
+	 * fragment. An extension fragment type of bootclasspath indicates that the
+	 * extension fragment is to be loaded by the boot class loader.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Fragment-Host manifest header like:
+	 * 
+	 * <pre>
+	 *     Fragment-Host: system.bundle; extension:=&quot;bootclasspath&quot;
+	 * </pre>
+	 * 
+	 * @see #EXTENSION_DIRECTIVE
+	 * @since 1.3
+	 */
+	String	EXTENSION_BOOTCLASSPATH					= "bootclasspath";
+
+	/**
+	 * Manifest header identifying the bundle's activation policy.
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.4
+	 * @see #ACTIVATION_LAZY
+	 * @see #INCLUDE_DIRECTIVE
+	 * @see #EXCLUDE_DIRECTIVE
+	 */
+	String	BUNDLE_ACTIVATIONPOLICY					= "Bundle-ActivationPolicy";
+
+	/**
+	 * Bundle activation policy declaring the bundle must be activated when the
+	 * first class load is made from the bundle.
+	 * <p>
+	 * A bundle with the lazy activation policy that is started with the
+	 * {@link Bundle#START_ACTIVATION_POLICY START_ACTIVATION_POLICY} option
+	 * will wait in the {@link Bundle#STARTING STARTING} state until the first
+	 * class load from the bundle occurs. The bundle will then be activated
+	 * before the class is returned to the requester.
+	 * <p>
+	 * The activation policy value is specified as in the
+	 * Bundle-ActivationPolicy manifest header like:
+	 * 
+	 * <pre>
+	 *       Bundle-ActivationPolicy: lazy
+	 * </pre>
+	 * 
+	 * @see #BUNDLE_ACTIVATIONPOLICY
+	 * @see Bundle#start(int)
+	 * @see Bundle#START_ACTIVATION_POLICY
+	 * @since 1.4
+	 */
+	String	ACTIVATION_LAZY							= "lazy";
+
+	/**
+	 * Framework environment property identifying the Framework version.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_VERSION						= "org.osgi.framework.version";
+
+	/**
+	 * Framework environment property identifying the Framework implementation
+	 * vendor.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_VENDOR						= "org.osgi.framework.vendor";
+
+	/**
+	 * Framework launching property identifying the Framework implementation
+	 * language (see ISO 639 for possible values).
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_LANGUAGE						= "org.osgi.framework.language";
+
+	/**
+	 * Framework launching property identifying the Framework host-computer's
+	 * operating system.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_OS_NAME						= "org.osgi.framework.os.name";
+
+	/**
+	 * Framework launching property identifying the Framework host-computer's
+	 * operating system version number.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_OS_VERSION					= "org.osgi.framework.os.version";
+
+	/**
+	 * Framework launching property identifying the Framework host-computer's
+	 * processor name.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 */
+	String	FRAMEWORK_PROCESSOR						= "org.osgi.framework.processor";
+
+	/**
+	 * Framework launching property identifying execution environments provided
+	 * by the Framework.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.2
+	 * @deprecated As of 1.6. Replaced by the {@code osgi.ee} capability.
+	 */
+	String	FRAMEWORK_EXECUTIONENVIRONMENT			= "org.osgi.framework.executionenvironment";
+
+	/**
+	 * Framework launching property identifying packages for which the Framework
+	 * must delegate class loading to the parent class loader of the bundle.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @see #FRAMEWORK_BUNDLE_PARENT
+	 * @since 1.3
+	 */
+	String	FRAMEWORK_BOOTDELEGATION				= "org.osgi.framework.bootdelegation";
+
+	/**
+	 * Framework launching property identifying packages which the system bundle
+	 * must export.
+	 * 
+	 * <p>
+	 * If this property is not specified then the framework must calculate a
+	 * reasonable default value for the current execution environment.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	FRAMEWORK_SYSTEMPACKAGES				= "org.osgi.framework.system.packages";
+
+	/**
+	 * Framework launching property identifying extra packages which the system
+	 * bundle must export from the current execution environment.
+	 * 
+	 * <p>
+	 * This property is useful for configuring extra system packages in addition
+	 * to the system packages calculated by the framework.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @see #FRAMEWORK_SYSTEMPACKAGES
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_SYSTEMPACKAGES_EXTRA			= "org.osgi.framework.system.packages.extra";
+
+	/**
+	 * Framework environment property identifying whether the Framework supports
+	 * framework extension bundles.
+	 * 
+	 * <p>
+	 * As of version 1.4, the value of this property must be {@code true}. The
+	 * Framework must support framework extension bundles.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	SUPPORTS_FRAMEWORK_EXTENSION			= "org.osgi.supports.framework.extension";
+
+	/**
+	 * Framework environment property identifying whether the Framework supports
+	 * bootclasspath extension bundles.
+	 * 
+	 * <p>
+	 * If the value of this property is {@code true}, then the Framework
+	 * supports bootclasspath extension bundles. The default value is
+	 * {@code false}.
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	SUPPORTS_BOOTCLASSPATH_EXTENSION		= "org.osgi.supports.bootclasspath.extension";
+
+	/**
+	 * Framework environment property identifying whether the Framework supports
+	 * fragment bundles.
+	 * 
+	 * <p>
+	 * As of version 1.4, the value of this property must be {@code true}. The
+	 * Framework must support fragment bundles.
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	SUPPORTS_FRAMEWORK_FRAGMENT				= "org.osgi.supports.framework.fragment";
+
+	/**
+	 * Framework environment property identifying whether the Framework supports
+	 * the {@link #REQUIRE_BUNDLE Require-Bundle} manifest header.
+	 * 
+	 * <p>
+	 * As of version 1.4, the value of this property must be {@code true}. The
+	 * Framework must support the {@code Require-Bundle} manifest header.
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.3
+	 */
+	String	SUPPORTS_FRAMEWORK_REQUIREBUNDLE		= "org.osgi.supports.framework.requirebundle";
+
+	/**
+	 * Framework launching property specifying the type of security manager the
+	 * framework must use. If not specified then the framework will not set the
+	 * VM security manager.
+	 * 
+	 * @see #FRAMEWORK_SECURITY_OSGI
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_SECURITY						= "org.osgi.framework.security";
+
+	/**
+	 * Specifies that a security manager that supports all security aspects of
+	 * the OSGi core specification including postponed conditions must be
+	 * installed.
+	 * 
+	 * <p>
+	 * If this value is specified and there is a security manager already
+	 * installed, then a {@code SecurityException} must be thrown when the
+	 * Framework is initialized.
+	 * 
+	 * @see #FRAMEWORK_SECURITY
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_SECURITY_OSGI					= "osgi";
+
+	/**
+	 * Framework launching property specifying the persistent storage area used
+	 * by the framework. The value of this property must be a valid file path in
+	 * the file system to a directory. If the specified directory does not exist
+	 * then the framework will create the directory. If the specified path
+	 * exists but is not a directory or if the framework fails to create the
+	 * storage directory, then framework initialization must fail. The framework
+	 * is free to use this directory as it sees fit. This area can not be shared
+	 * with anything else.
+	 * <p>
+	 * If this property is not set, the framework should use a reasonable
+	 * platform default for the persistent storage area.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_STORAGE						= "org.osgi.framework.storage";
+
+	/**
+	 * Framework launching property specifying if and when the persistent
+	 * storage area for the framework should be cleaned. If this property is not
+	 * set, then the framework storage area must not be cleaned.
+	 * 
+	 * @see #FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_STORAGE_CLEAN					= "org.osgi.framework.storage.clean";
+
+	/**
+	 * Specifies that the framework storage area must be cleaned before the
+	 * framework is initialized for the first time. Subsequent inits, starts or
+	 * updates of the framework will not result in cleaning the framework
+	 * storage area.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT		= "onFirstInit";
+
+	/**
+	 * Framework launching property specifying a comma separated list of
+	 * additional library file extensions that must be used when a bundle's
+	 * class loader is searching for native libraries. If this property is not
+	 * set, then only the library name returned by
+	 * {@code System.mapLibraryName(String)} will be used to search. This is
+	 * needed for certain operating systems which allow more than one extension
+	 * for a library. For example, AIX allows library extensions of {@code .a}
+	 * and {@code .so}, but {@code System.mapLibraryName(String)} will only
+	 * return names with the {@code .a} extension.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_LIBRARY_EXTENSIONS			= "org.osgi.framework.library.extensions";
+
+	/**
+	 * Framework launching property specifying an optional OS specific command
+	 * to set file permissions on extracted native code. On some operating
+	 * systems, it is required that native libraries be set to executable. This
+	 * optional property allows you to specify the command. For example, on a
+	 * UNIX style OS, this property could have the following value.
+	 * 
+	 * <pre>
+	 * chmod +rx ${abspath}
+	 * </pre>
+	 * 
+	 * The <code>${abspath}</code> is used by the framework to substitute the
+	 * actual absolute file path.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_EXECPERMISSION				= "org.osgi.framework.command.execpermission";
+
+	/**
+	 * Specified the substitution string for the absolute path of a file.
+	 * 
+	 * @see #FRAMEWORK_EXECPERMISSION
+	 * @since 1.6
+	 */
+	String	FRAMEWORK_COMMAND_ABSPATH				= "abspath";
+
+	/**
+	 * Framework launching property specifying the trust repositories used by
+	 * the framework. The value is a {@code java.io.File.pathSeparator}
+	 * separated list of valid file paths to files that contain key stores of
+	 * type {@code JKS}. The framework will use the key stores as trust
+	 * repositories to authenticate certificates of trusted signers. The key
+	 * stores are only used as read-only trust repositories to access public
+	 * keys. No passwords are required to access the key stores' public keys.
+	 * <p>
+	 * Note that framework implementations are allowed to use other trust
+	 * repositories in addition to the trust repositories specified by this
+	 * property. How these other trust repositories are configured and populated
+	 * is implementation specific.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_TRUST_REPOSITORIES			= "org.osgi.framework.trust.repositories";
+
+	/**
+	 * Framework launching property specifying the current windowing system. The
+	 * framework should provide a reasonable default if this is not set.
+	 * 
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_WINDOWSYSTEM					= "org.osgi.framework.windowsystem";
+
+	/**
+	 * Framework launching property specifying the beginning start level of the
+	 * framework.
+	 * 
+	 * @see "Core Specification, Starting the Framework."
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_BEGINNING_STARTLEVEL			= "org.osgi.framework.startlevel.beginning";
+
+	/**
+	 * Framework launching property specifying the parent class loader type for
+	 * all bundle class loaders. Default value is
+	 * {@link #FRAMEWORK_BUNDLE_PARENT_BOOT boot}.
+	 * 
+	 * @see #FRAMEWORK_BUNDLE_PARENT_BOOT
+	 * @see #FRAMEWORK_BUNDLE_PARENT_EXT
+	 * @see #FRAMEWORK_BUNDLE_PARENT_APP
+	 * @see #FRAMEWORK_BUNDLE_PARENT_FRAMEWORK
+	 * @since 1.5
+	 */
+	String	FRAMEWORK_BUNDLE_PARENT					= "org.osgi.framework.bundle.parent";
+
+	/**
+	 * Specifies to use of the boot class loader as the parent class loader for
+	 * all bundle class loaders.
+	 * 
+	 * @since 1.5
+	 * @see #FRAMEWORK_BUNDLE_PARENT
+	 */
+	String	FRAMEWORK_BUNDLE_PARENT_BOOT			= "boot";
+
+	/**
+	 * Specifies to use the extension class loader as the parent class loader
+	 * for all bundle class loaders.
+	 * 
+	 * @since 1.5
+	 * @see #FRAMEWORK_BUNDLE_PARENT
+	 */
+	String	FRAMEWORK_BUNDLE_PARENT_EXT				= "ext";
+
+	/**
+	 * Specifies to use the application class loader as the parent class loader
+	 * for all bundle class loaders. Depending on how the framework is launched,
+	 * this may refer to the same class loader as
+	 * {@link #FRAMEWORK_BUNDLE_PARENT_FRAMEWORK}.
+	 * 
+	 * @since 1.5
+	 * @see #FRAMEWORK_BUNDLE_PARENT
+	 */
+	String	FRAMEWORK_BUNDLE_PARENT_APP				= "app";
+
+	/**
+	 * Specifies to use the framework class loader as the parent class loader
+	 * for all bundle class loaders. The framework class loader is the class
+	 * loader used to load the framework implementation. Depending on how the
+	 * framework is launched, this may refer to the same class loader as
+	 * {@link #FRAMEWORK_BUNDLE_PARENT_APP}.
+	 * 
+	 * @since 1.5
+	 * @see #FRAMEWORK_BUNDLE_PARENT
+	 */
+	String	FRAMEWORK_BUNDLE_PARENT_FRAMEWORK		= "framework";
+
+	/*
+	 * Service properties.
+	 */
+
+	/**
+	 * Service property identifying all of the class names under which a service
+	 * was registered in the Framework. The value of this property must be of
+	 * type {@code String[]}.
+	 * 
+	 * <p>
+	 * This property is set by the Framework when a service is registered.
+	 */
+	String	OBJECTCLASS								= "objectClass";
+
+	/**
+	 * Service property identifying a service's registration number. The value
+	 * of this property must be of type {@code Long}.
+	 * 
+	 * <p>
+	 * The value of this property is assigned by the Framework when a service is
+	 * registered. The Framework assigns a unique value that is larger than all
+	 * previously assigned values since the Framework was started. These values
+	 * are NOT persistent across restarts of the Framework.
+	 */
+	String	SERVICE_ID								= "service.id";
+
+	/**
+	 * Service property identifying a service's persistent identifier.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties}
+	 * {@code Dictionary} object passed to the
+	 * {@code BundleContext.registerService} method. The value of this property
+	 * must be of type {@code String}, {@code String[]}, or {@code Collection}
+	 * of {@code String}.
+	 * 
+	 * <p>
+	 * A service's persistent identifier uniquely identifies the service and
+	 * persists across multiple Framework invocations.
+	 * 
+	 * <p>
+	 * By convention, every bundle has its own unique name space, starting with
+	 * the bundle's identifier (see {@link Bundle#getBundleId}) and followed by
+	 * a dot (.). A bundle may use this as the prefix of the persistent
+	 * identifiers for the services it registers.
+	 */
+	String	SERVICE_PID								= "service.pid";
+
+	/**
+	 * Service property identifying a service's ranking number.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties
+	 * Dictionary} object passed to the {@code BundleContext.registerService}
+	 * method. The value of this property must be of type {@code Integer}.
+	 * 
+	 * <p>
+	 * The service ranking is used by the Framework to determine the <i>natural
+	 * order</i> of services, see {@link ServiceReference#compareTo}, and the
+	 * <i>default</i> service to be returned from a call to the
+	 * {@link BundleContext#getServiceReference} method.
+	 * 
+	 * <p>
+	 * The default ranking is zero (0). A service with a ranking of
+	 * {@code Integer.MAX_VALUE} is very likely to be returned as the default
+	 * service, whereas a service with a ranking of {@code Integer.MIN_VALUE} is
+	 * very unlikely to be returned.
+	 * 
+	 * <p>
+	 * If the supplied property value is not of type {@code Integer}, it is
+	 * deemed to have a ranking value of zero.
+	 */
+	String	SERVICE_RANKING							= "service.ranking";
+
+	/**
+	 * Service property identifying a service's vendor.
+	 * 
+	 * <p>
+	 * This property may be supplied in the properties {@code Dictionary} object
+	 * passed to the {@code BundleContext.registerService} method.
+	 */
+	String	SERVICE_VENDOR							= "service.vendor";
+
+	/**
+	 * Service property identifying a service's description.
+	 * 
+	 * <p>
+	 * This property may be supplied in the properties {@code Dictionary} object
+	 * passed to the {@code BundleContext.registerService} method.
+	 */
+	String	SERVICE_DESCRIPTION						= "service.description";
+
+	/**
+	 * Framework environment property identifying the Framework's universally
+	 * unique identifier (UUID). A UUID represents a 128-bit value. A new UUID
+	 * is generated by the {@link Framework#init()} method each time a framework
+	 * is initialized. The value of this property must conform to the UUID
+	 * string representation specified in <a
+	 * href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.6
+	 */
+	String	FRAMEWORK_UUID							= "org.osgi.framework.uuid";
+
+	/**
+	 * Service property identifying the configuration types supported by a
+	 * distribution provider. Registered by the distribution provider on one of
+	 * its services to indicate the supported configuration types.
+	 * 
+	 * <p>
+	 * The value of this property must be of type {@code String},
+	 * {@code String[]}, or {@code Collection} of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	REMOTE_CONFIGS_SUPPORTED				= "remote.configs.supported";
+
+	/**
+	 * Service property identifying the intents supported by a distribution
+	 * provider. Registered by the distribution provider on one of its services
+	 * to indicate the vocabulary of implemented intents.
+	 * 
+	 * <p>
+	 * The value of this property must be of type {@code String},
+	 * {@code String[]}, or {@code Collection} of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	REMOTE_INTENTS_SUPPORTED				= "remote.intents.supported";
+
+	/**
+	 * Service property identifying the configuration types that should be used
+	 * to export the service. Each configuration type represents the
+	 * configuration parameters for an endpoint. A distribution provider should
+	 * create an endpoint for each configuration type that it supports.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties}
+	 * {@code Dictionary} object passed to the
+	 * {@code BundleContext.registerService} method. The value of this property
+	 * must be of type {@code String}, {@code String[]}, or {@code Collection}
+	 * of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_EXPORTED_CONFIGS				= "service.exported.configs";
+
+	/**
+	 * Service property identifying the intents that the distribution provider
+	 * must implement to distribute the service. Intents listed in this property
+	 * are reserved for intents that are critical for the code to function
+	 * correctly, for example, ordering of messages. These intents should not be
+	 * configurable.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties}
+	 * {@code Dictionary} object passed to the
+	 * {@code BundleContext.registerService} method. The value of this property
+	 * must be of type {@code String}, {@code String[]}, or {@code Collection}
+	 * of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_EXPORTED_INTENTS				= "service.exported.intents";
+
+	/**
+	 * Service property identifying the extra intents that the distribution
+	 * provider must implement to distribute the service. This property is
+	 * merged with the {@code service.exported.intents} property before the
+	 * distribution provider interprets the listed intents; it has therefore the
+	 * same semantics but the property should be configurable so the
+	 * administrator can choose the intents based on the topology. Bundles
+	 * should therefore make this property configurable, for example through the
+	 * Configuration Admin service.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties}
+	 * {@code Dictionary} object passed to the
+	 * {@code BundleContext.registerService} method. The value of this property
+	 * must be of type {@code String}, {@code String[]}, or {@code Collection}
+	 * of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_EXPORTED_INTENTS_EXTRA			= "service.exported.intents.extra";
+
+	/**
+	 * Service property marking the service for export. It defines the
+	 * interfaces under which this service can be exported. This list must be a
+	 * subset of the types under which the service was registered. The single
+	 * value of an asterisk (&quot;*&quot;, &#92;u002A) indicates all the
+	 * interface types under which the service was registered excluding the
+	 * non-interface types. It is strongly recommended to only export interface
+	 * types and not concrete classes due to the complexity of creating proxies
+	 * for some type of concrete classes.
+	 * 
+	 * <p>
+	 * This property may be supplied in the {@code properties}
+	 * {@code Dictionary} object passed to the
+	 * {@code BundleContext.registerService} method. The value of this property
+	 * must be of type {@code String}, {@code String[]}, or {@code Collection}
+	 * of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_EXPORTED_INTERFACES				= "service.exported.interfaces";
+
+	/**
+	 * Service property identifying the service as imported. This service
+	 * property must be set by a distribution provider to any value when it
+	 * registers the endpoint proxy as an imported service. A bundle can use
+	 * this property to filter out imported services.
+	 * 
+	 * <p>
+	 * The value of this property may be of any type.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_IMPORTED						= "service.imported";
+
+	/**
+	 * Service property identifying the configuration types used to import the
+	 * service. Any associated properties for this configuration types must be
+	 * properly mapped to the importing system. For example, a URL in these
+	 * properties must point to a valid resource when used in the importing
+	 * framework. If multiple configuration types are listed in this property,
+	 * then they must be synonyms for exactly the same remote endpoint that is
+	 * used to export this service.
+	 * 
+	 * <p>
+	 * The value of this property must be of type {@code String},
+	 * {@code String[]}, or {@code Collection} of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 * @see #SERVICE_EXPORTED_CONFIGS
+	 */
+	String	SERVICE_IMPORTED_CONFIGS				= "service.imported.configs";
+
+	/**
+	 * Service property identifying the intents that this service implement.
+	 * This property has a dual purpose:
+	 * <ul>
+	 * <li>A bundle can use this service property to notify the distribution
+	 * provider that these intents are already implemented by the exported
+	 * service object.</li>
+	 * <li>A distribution provider must use this property to convey the combined
+	 * intents of: the exporting service, the intents that the exporting
+	 * distribution provider adds, and the intents that the importing
+	 * distribution provider adds.</li>
+	 * </ul>
+	 * 
+	 * To export a service, a distribution provider must expand any qualified
+	 * intents. Both the exporting and importing distribution providers must
+	 * recognize all intents before a service can be distributed.
+	 * 
+	 * <p>
+	 * The value of this property must be of type {@code String},
+	 * {@code String[]}, or {@code Collection} of {@code String}.
+	 * 
+	 * @since 1.6
+	 * @see "Remote Services Specification"
+	 */
+	String	SERVICE_INTENTS							= "service.intents";
+
+	/**
+	 * Manifest header identifying the capabilities that the bundle offers to
+	 * provide to other bundles.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.6
+	 */
+	String	PROVIDE_CAPABILITY						= "Provide-Capability";
+
+	/**
+	 * Manifest header identifying the capabilities on which the bundle depends.
+	 * 
+	 * <p>
+	 * The header value may be retrieved from the {@code Dictionary} object
+	 * returned by the {@code Bundle.getHeaders} method.
+	 * 
+	 * @since 1.6
+	 */
+	String	REQUIRE_CAPABILITY						= "Require-Capability";
+
+	/**
+	 * Manifest header directive identifying the effective time of the provided
+	 * capability. The default value is {@link #EFFECTIVE_RESOLVE resolve}.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Provide-Capability manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Provide-Capability: com.acme.capability; effective:=&quot;resolve&quot;
+	 * </pre>
+	 * 
+	 * @see #PROVIDE_CAPABILITY
+	 * @see #EFFECTIVE_RESOLVE
+	 * @see #EFFECTIVE_ACTIVE
+	 * @since 1.6
+	 */
+	String	EFFECTIVE_DIRECTIVE						= "effective";
+
+	/**
+	 * Manifest header directive value identifying a capability that is
+	 * effective at resolve time. Capabilities with an effective time of resolve
+	 * are the only capabilities which are processed by the resolver.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Provide-Capability manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Provide-Capability: com.acme.capability; effective:=&quot;resolve&quot;
+	 * </pre>
+	 * 
+	 * @see #EFFECTIVE_DIRECTIVE
+	 * @since 1.6
+	 */
+	String	EFFECTIVE_RESOLVE						= "resolve";
+
+	/**
+	 * Manifest header directive value identifying a capability that is
+	 * effective at active time. Capabilities with an effective time of active
+	 * are ignored by the resolver.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Provide-Capability manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Provide-Capability: com.acme.capability; effective:=&quot;active&quot;
+	 * </pre>
+	 * 
+	 * @see #EFFECTIVE_DIRECTIVE
+	 * @since 1.6
+	 */
+	String	EFFECTIVE_ACTIVE						= "active";
+
+	/**
+	 * Manifest header directive identifying the capability filter specified in
+	 * the Require-Capability manifest header.
+	 * 
+	 * <p>
+	 * The directive value is encoded in the Require-Capability manifest header
+	 * like:
+	 * 
+	 * <pre>
+	 *     Require-Capability: com.acme.capability; filter:=&quot;(someattr=somevalue)&quot;
+	 * </pre>
+	 * 
+	 * @see #REQUIRE_CAPABILITY
+	 * @since 1.6
+	 */
+	String	FILTER_DIRECTIVE						= "filter";
+
+	/**
+	 * Framework launching property identifying capabilities which the system
+	 * bundle must provide.
+	 * 
+	 * <p>
+	 * If this property is not specified then the framework must calculate a
+	 * reasonable default value for the current execution environment.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @since 1.6
+	 */
+	String	FRAMEWORK_SYSTEMCAPABILITIES			= "org.osgi.framework.system.capabilities";
+
+	/**
+	 * Framework launching property identifying extra capabilities which the
+	 * system bundle must additionally provide.
+	 * 
+	 * <p>
+	 * This property is useful for configuring extra system capabilities in
+	 * addition to the system capabilities calculated by the framework.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @see #FRAMEWORK_SYSTEMCAPABILITIES
+	 * @since 1.6
+	 */
+	String	FRAMEWORK_SYSTEMCAPABILITIES_EXTRA		= "org.osgi.framework.system.capabilities.extra";
+
+	/**
+	 * Framework launching property specifying whether multiple bundles having
+	 * the same {@link #BUNDLE_SYMBOLICNAME symbolic name} and
+	 * {@link #BUNDLE_VERSION version} may be installed.
+	 * 
+	 * <p>
+	 * Default value is {@link #FRAMEWORK_BSNVERSION_SINGLE single} in this
+	 * release of the specification. This default may change to
+	 * {@link #FRAMEWORK_BSNVERSION_MULTIPLE multiple} in a future specification
+	 * release. Therefore, code must not assume the default behavior is
+	 * {@code single} and should interrogate the value of this property to
+	 * determine the behavior.
+	 * 
+	 * <p>
+	 * The value of this property may be retrieved by calling the
+	 * {@code BundleContext.getProperty} method.
+	 * 
+	 * @see #FRAMEWORK_BSNVERSION_MULTIPLE
+	 * @see #FRAMEWORK_BSNVERSION_SINGLE
+	 * @since 1.6
+	 */
+	String	FRAMEWORK_BSNVERSION					= "org.osgi.framework.bsnversion";
+
+	/**
+	 * Specifies the framework will allow multiple bundles to be installed
+	 * having the same symbolic name and version.
+	 * 
+	 * @since 1.6
+	 * @see #FRAMEWORK_BSNVERSION
+	 */
+	String	FRAMEWORK_BSNVERSION_MULTIPLE			= "multiple";
+
+	/**
+	 * Specifies the framework will only allow a single bundle to be installed
+	 * for a given symbolic name and version. It will be an error to install a
+	 * bundle or update a bundle to have the same symbolic name and version as
+	 * another installed bundle.
+	 * 
+	 * @since 1.6
+	 * @see #FRAMEWORK_BSNVERSION
+	 */
+	String	FRAMEWORK_BSNVERSION_SINGLE				= "single";
+}
diff --git a/main/src/main/java/org/osgi/framework/Filter.java b/main/src/main/java/org/osgi/framework/Filter.java
new file mode 100644
index 0000000000..a9bb6c3a9e
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/Filter.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.framework;
+
+import java.util.Dictionary;
+import java.util.Map;
+
+/**
+ * An <a href="http://www.ietf.org/rfc/rfc1960.txt">RFC 1960</a>-based Filter.
+ * <p>
+ * {@code Filter}s can be created by calling {@link BundleContext#createFilter}
+ * or {@link FrameworkUtil#createFilter} with a filter string.
+ * <p>
+ * A {@code Filter} can be used numerous times to determine if the match
+ * argument matches the filter string that was used to create the {@code Filter}.
+ * <p>
+ * Some examples of LDAP filters are:
+ * 
+ * <pre>
+ *  &quot;(cn=Babs Jensen)&quot;
+ *  &quot;(!(cn=Tim Howes))&quot;
+ *  &quot;(&amp;(&quot; + Constants.OBJECTCLASS + &quot;=Person)(|(sn=Jensen)(cn=Babs J*)))&quot;
+ *  &quot;(o=univ*of*mich*)&quot;
+ * </pre>
+ * 
+ * @since 1.1
+ * @see "Core Specification, Filters, for a description of the filter string syntax."
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 4d21267f4b85d1912d73f7e2c049cc968c4237f9 $
+ */
+public interface Filter {
+	/**
+	 * Filter using a service's properties.
+	 * <p>
+	 * This {@code Filter} is executed using the keys and values of the
+	 * referenced service's properties. The keys are looked up in a case
+	 * insensitive manner.
+	 * 
+	 * @param reference The reference to the service whose properties are used
+	 *        in the match.
+	 * @return {@code true} if the service's properties match this
+	 *         {@code Filter}; {@code false} otherwise.
+	 */
+	boolean match(ServiceReference< ? > reference);
+
+	/**
+	 * Filter using a {@code Dictionary} with case insensitive key lookup. This
+	 * {@code Filter} is executed using the specified {@code Dictionary}'s keys
+	 * and values. The keys are looked up in a case insensitive manner.
+	 * 
+	 * @param dictionary The {@code Dictionary} whose key/value pairs are used
+	 *        in the match.
+	 * @return {@code true} if the {@code Dictionary}'s values match this
+	 *         filter; {@code false} otherwise.
+	 * @throws IllegalArgumentException If {@code dictionary} contains case
+	 *         variants of the same key name.
+	 */
+	boolean match(Dictionary<String, ? > dictionary);
+
+	/**
+	 * Returns this {@code Filter}'s filter string.
+	 * <p>
+	 * The filter string is normalized by removing whitespace which does not
+	 * affect the meaning of the filter.
+	 * 
+	 * @return This {@code Filter}'s filter string.
+	 */
+	String toString();
+
+	/**
+	 * Compares this {@code Filter} to another {@code Filter}.
+	 * 
+	 * <p>
+	 * This implementation returns the result of calling
+	 * {@code this.toString().equals(obj.toString())}.
+	 * 
+	 * @param obj The object to compare against this {@code Filter}.
+	 * @return If the other object is a {@code Filter} object, then returns
+	 *         the result of calling
+	 *         {@code this.toString().equals(obj.toString())};
+	 *         {@code false} otherwise.
+	 */
+	boolean equals(Object obj);
+
+	/**
+	 * Returns the hashCode for this {@code Filter}.
+	 * 
+	 * <p>
+	 * This implementation returns the result of calling
+	 * {@code this.toString().hashCode()}.
+	 * 
+	 * @return The hashCode of this {@code Filter}.
+	 */
+	int hashCode();
+
+	/**
+	 * Filter using a {@code Dictionary}. This {@code Filter} is executed using
+	 * the specified {@code Dictionary}'s keys and values. The keys are looked
+	 * up in a normal manner respecting case.
+	 * 
+	 * @param dictionary The {@code Dictionary} whose key/value pairs are used
+	 *        in the match.
+	 * @return {@code true} if the {@code Dictionary}'s values match this
+	 *         filter; {@code false} otherwise.
+	 * @since 1.3
+	 */
+	boolean matchCase(Dictionary<String, ? > dictionary);
+
+	/**
+	 * Filter using a {@code Map}. This {@code Filter} is executed using the
+	 * specified {@code Map}'s keys and values. The keys are looked up in a
+	 * normal manner respecting case.
+	 * 
+	 * @param map The {@code Map} whose key/value pairs are used in the match.
+	 *        Maps with {@code null} key or values are not supported. A
+	 *        {@code null} value is considered not present to the filter.
+	 * @return {@code true} if the {@code Map}'s values match this filter;
+	 *         {@code false} otherwise.
+	 * @since 1.6
+	 */
+	boolean matches(Map<String, ? > map);
+}
diff --git a/main/src/main/java/org/osgi/framework/FrameworkEvent.java b/main/src/main/java/org/osgi/framework/FrameworkEvent.java
new file mode 100644
index 0000000000..d309699784
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/FrameworkEvent.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.EventObject;
+
+import org.osgi.framework.startlevel.FrameworkStartLevel;
+import org.osgi.framework.wiring.FrameworkWiring;
+
+/**
+ * A general event from the Framework.
+ * 
+ * <p>
+ * {@code FrameworkEvent} objects are delivered to
+ * {@code FrameworkListener}s when a general event occurs within the OSGi
+ * environment. A type code is used to identify the event type for future
+ * extendability.
+ * 
+ * <p>
+ * OSGi Alliance reserves the right to extend the set of event types.
+ * 
+ * @Immutable
+ * @see FrameworkListener
+ * @version $Id: e05c6ffd542fa432835961882bf6b15b0620ffb6 $
+ */
+
+public class FrameworkEvent extends EventObject {
+	static final long		serialVersionUID				= 207051004521261705L;
+	/**
+	 * Bundle related to the event.
+	 */
+	private final Bundle	bundle;
+
+	/**
+	 * Exception related to the event.
+	 */
+	private final Throwable	throwable;
+
+	/**
+	 * Type of event.
+	 */
+	private final int		type;
+
+	/**
+	 * The Framework has started.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has started after all installed
+	 * bundles that are marked to be started have been started and the Framework
+	 * has reached the initial start level. The source of this event is the
+	 * System Bundle.
+	 * 
+	 * @see "The Start Level Specification"
+	 */
+	public final static int	STARTED							= 0x00000001;
+
+	/**
+	 * An error has occurred.
+	 * 
+	 * <p>
+	 * There was an error associated with a bundle.
+	 */
+	public final static int	ERROR							= 0x00000002;
+
+	/**
+	 * A FrameworkWiring.refreshBundles operation has completed.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has completed the refresh bundles
+	 * operation initiated by a call to the FrameworkWiring.refreshBundles
+	 * method. The source of this event is the System Bundle.
+	 * 
+	 * @since 1.2
+	 * @see FrameworkWiring#refreshBundles(java.util.Collection,
+	 *      FrameworkListener...)
+	 */
+	public final static int	PACKAGES_REFRESHED				= 0x00000004;
+
+	/**
+	 * A FrameworkStartLevel.setStartLevel operation has completed.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has completed changing the active
+	 * start level initiated by a call to the StartLevel.setStartLevel method.
+	 * The source of this event is the System Bundle.
+	 * 
+	 * @since 1.2
+	 * @see FrameworkStartLevel#setStartLevel(int, FrameworkListener...)
+	 */
+	public final static int	STARTLEVEL_CHANGED				= 0x00000008;
+
+	/**
+	 * A warning has occurred.
+	 * 
+	 * <p>
+	 * There was a warning associated with a bundle.
+	 * 
+	 * @since 1.3
+	 */
+	public final static int	WARNING							= 0x00000010;
+
+	/**
+	 * An informational event has occurred.
+	 * 
+	 * <p>
+	 * There was an informational event associated with a bundle.
+	 * 
+	 * @since 1.3
+	 */
+	public final static int	INFO							= 0x00000020;
+
+	/**
+	 * The Framework has stopped.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has been stopped because of a stop
+	 * operation on the system bundle. The source of this event is the System
+	 * Bundle.
+	 * 
+	 * @since 1.5
+	 */
+	public final static int	STOPPED							= 0x00000040;
+
+	/**
+	 * The Framework has stopped during update.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has been stopped because of an
+	 * update operation on the system bundle. The Framework will be restarted
+	 * after this event is fired. The source of this event is the System Bundle.
+	 * 
+	 * @since 1.5
+	 */
+	public final static int	STOPPED_UPDATE					= 0x00000080;
+
+	/**
+	 * The Framework has stopped and the boot class path has changed.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework has been stopped because of a stop
+	 * operation on the system bundle and a bootclasspath extension bundle has
+	 * been installed or updated. The source of this event is the System Bundle.
+	 * 
+	 * @since 1.5
+	 */
+	public final static int	STOPPED_BOOTCLASSPATH_MODIFIED	= 0x00000100;
+
+	/**
+	 * The Framework did not stop before the wait timeout expired.
+	 * 
+	 * <p>
+	 * This event is fired when the Framework did not stop before the wait
+	 * timeout expired. The source of this event is the System Bundle.
+	 * 
+	 * @since 1.5
+	 */
+	public final static int	WAIT_TIMEDOUT					= 0x00000200;
+
+	/**
+	 * Creates a Framework event.
+	 * 
+	 * @param type The event type.
+	 * @param source The event source object. This may not be {@code null}.
+	 * @deprecated As of 1.2. This constructor is deprecated in favor of using
+	 *             the other constructor with the System Bundle as the event
+	 *             source.
+	 */
+	public FrameworkEvent(int type, Object source) {
+		super(source);
+		this.type = type;
+		this.bundle = null;
+		this.throwable = null;
+	}
+
+	/**
+	 * Creates a Framework event regarding the specified bundle.
+	 * 
+	 * @param type The event type.
+	 * @param bundle The event source.
+	 * @param throwable The related exception. This argument may be
+	 *        {@code null} if there is no related exception.
+	 */
+	public FrameworkEvent(int type, Bundle bundle, Throwable throwable) {
+		super(bundle);
+		this.type = type;
+		this.bundle = bundle;
+		this.throwable = throwable;
+	}
+
+	/**
+	 * Returns the exception related to this event.
+	 * 
+	 * @return The related exception or {@code null} if none.
+	 */
+	public Throwable getThrowable() {
+		return throwable;
+	}
+
+	/**
+	 * Returns the bundle associated with the event. This bundle is also the
+	 * source of the event.
+	 * 
+	 * @return The bundle associated with the event.
+	 */
+	public Bundle getBundle() {
+		return bundle;
+	}
+
+	/**
+	 * Returns the type of framework event.
+	 * <p>
+	 * The type values are:
+	 * <ul>
+	 * <li>{@link #STARTED}
+	 * <li>{@link #ERROR}
+	 * <li>{@link #WARNING}
+	 * <li>{@link #INFO}
+	 * <li>{@link #PACKAGES_REFRESHED}
+	 * <li>{@link #STARTLEVEL_CHANGED}
+	 * <li>{@link #STOPPED}
+	 * <li>{@link #STOPPED_BOOTCLASSPATH_MODIFIED}
+	 * <li>{@link #STOPPED_UPDATE}
+	 * <li>{@link #WAIT_TIMEDOUT}
+	 * </ul>
+	 * 
+	 * @return The type of state change.
+	 */
+
+	public int getType() {
+		return type;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/FrameworkListener.java b/main/src/main/java/org/osgi/framework/FrameworkListener.java
new file mode 100644
index 0000000000..5d73fb904c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/FrameworkListener.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.EventListener;
+
+/**
+ * A {@code FrameworkEvent} listener. {@code FrameworkListener} is
+ * a listener interface that may be implemented by a bundle developer. When a
+ * {@code FrameworkEvent} is fired, it is asynchronously delivered to a
+ * {@code FrameworkListener}. The Framework delivers
+ * {@code FrameworkEvent} objects to a {@code FrameworkListener}
+ * in order and must not concurrently call a {@code FrameworkListener}.
+ * 
+ * <p>
+ * A {@code FrameworkListener} object is registered with the Framework
+ * using the {@link BundleContext#addFrameworkListener} method.
+ * {@code FrameworkListener} objects are called with a
+ * {@code FrameworkEvent} objects when the Framework starts and when
+ * asynchronous errors occur.
+ * 
+ * @see FrameworkEvent
+ * @NotThreadSafe
+ * @version $Id: a32e7599ea09d3510759d77e824cb8d9eff67f9d $
+ */
+
+public interface FrameworkListener extends EventListener {
+
+	/**
+	 * Receives notification of a general {@code FrameworkEvent} object.
+	 * 
+	 * @param event The {@code FrameworkEvent} object.
+	 */
+	public void frameworkEvent(FrameworkEvent event);
+}
diff --git a/main/src/main/java/org/osgi/framework/FrameworkUtil.java b/main/src/main/java/org/osgi/framework/FrameworkUtil.java
new file mode 100644
index 0000000000..0e89999bd7
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/FrameworkUtil.java
@@ -0,0 +1,2224 @@
+/*
+ * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.security.auth.x500.X500Principal;
+
+/**
+ * Framework Utility class.
+ * 
+ * <p>
+ * This class contains utility methods which access Framework functions that may
+ * be useful to bundles.
+ * 
+ * @since 1.3
+ * @ThreadSafe
+ * @version $Id: a902bc156ea997ed244831c7fab0f290a08ac0c1 $
+ */
+public class FrameworkUtil {
+	/**
+	 * FrameworkUtil objects may not be constructed.
+	 */
+	private FrameworkUtil() {
+		// private empty constructor to prevent construction
+	}
+
+	/**
+	 * Creates a {@code Filter} object. This {@code Filter} object may
+	 * be used to match a {@code ServiceReference} object or a
+	 * {@code Dictionary} object.
+	 * 
+	 * <p>
+	 * If the filter cannot be parsed, an {@link InvalidSyntaxException} will be
+	 * thrown with a human readable message where the filter became unparsable.
+	 * 
+	 * <p>
+	 * This method returns a Filter implementation which may not perform as well
+	 * as the framework implementation-specific Filter implementation returned
+	 * by {@link BundleContext#createFilter(String)}.
+	 * 
+	 * @param filter The filter string.
+	 * @return A {@code Filter} object encapsulating the filter string.
+	 * @throws InvalidSyntaxException If {@code filter} contains an invalid
+	 *         filter string that cannot be parsed.
+	 * @throws NullPointerException If {@code filter} is null.
+	 * 
+	 * @see Filter
+	 */
+	public static Filter createFilter(String filter)
+			throws InvalidSyntaxException {
+		return FilterImpl.newInstance(filter);
+	}
+
+	/**
+	 * Match a Distinguished Name (DN) chain against a pattern. DNs can be
+	 * matched using wildcards. A wildcard ('*' &#92;u002A) replaces all
+	 * possible values. Due to the structure of the DN, the comparison is more
+	 * complicated than string-based wildcard matching.
+	 * <p>
+	 * A wildcard can stand for zero or more DNs in a chain, a number of
+	 * relative distinguished names (RDNs) within a DN, or the value of a single
+	 * RDN. The DNs in the chain and the matching pattern are canonicalized
+	 * before processing. This means, among other things, that spaces must be
+	 * ignored, except in values.
+	 * <p>
+	 * The format of a wildcard match pattern is:
+	 * 
+	 * <pre>
+	 * matchPattern	::= dn-match ( ';' dn-match ) *
+	 * dn-match 	::= ( '*' | rdn-match ) ( ',' rdn-match ) * | '-'
+	 * rdn-match 	::= name '=' value-match
+	 * value-match 	::= '*' | value-star
+	 * value-star 	::= &lt; value, requires escaped '*' and '-' &gt;
+	 * </pre>
+	 * <p>
+	 * The most simple case is a single wildcard; it must match any DN. A
+	 * wildcard can also replace the first list of RDNs of a DN. The first RDNs
+	 * are the least significant. Such lists of matched RDNs can be empty.
+	 * <p>
+	 * For example, a match pattern with a wildcard that matches all DNs that
+	 * end with RDNs of o=ACME and c=US would look like this:
+	 * 
+	 * <pre>
+	 * *, o=ACME, c=US
+	 * </pre>
+	 * 
+	 * This match pattern would match the following DNs:
+	 * 
+	 * <pre>
+	 * cn = Bugs Bunny, o = ACME, c = US
+	 * ou = Carrots, cn=Daffy Duck, o=ACME, c=US
+	 * street = 9C\, Avenue St. Drzry, o=ACME, c=US
+	 * dc=www, dc=acme, dc=com, o=ACME, c=US
+	 * o=ACME, c=US
+	 * </pre>
+	 * 
+	 * The following DNs would not match:
+	 * 
+	 * <pre>
+	 * street = 9C\, Avenue St. Drzry, o=ACME, c=FR
+	 * dc=www, dc=acme, dc=com, c=US
+	 * </pre>
+	 * 
+	 * If a wildcard is used for a value of an RDN, the value must be exactly *.
+	 * The wildcard must match any value, and no substring matching must be
+	 * done. For example:
+	 * 
+	 * <pre>
+	 * cn=*,o=ACME,c=*
+	 * </pre>
+	 * 
+	 * This match pattern with wildcard must match the following DNs:
+	 * 
+	 * <pre>
+	 * cn=Bugs Bunny,o=ACME,c=US
+	 * cn = Daffy Duck , o = ACME , c = US
+	 * cn=Road Runner, o=ACME, c=NL
+	 * </pre>
+	 * 
+	 * But not:
+	 * 
+	 * <pre>
+	 * o=ACME, c=NL
+	 * dc=acme.com, cn=Bugs Bunny, o=ACME, c=US
+	 * </pre>
+	 * 
+	 * <p>
+	 * A match pattern may contain a chain of DN match patterns. The
+	 * semicolon(';' &#92;u003B) must be used to separate DN match patterns in a
+	 * chain. Wildcards can also be used to match against a complete DN within a
+	 * chain.
+	 * <p>
+	 * The following example matches a certificate signed by Tweety Inc. in the
+	 * US.
+	 * </p>
+	 * 
+	 * <pre>
+	 * * ; ou=S &amp; V, o=Tweety Inc., c=US
+	 * </pre>
+	 * <p>
+	 * The wildcard ('*') matches zero or one DN in the chain, however,
+	 * sometimes it is necessary to match a longer chain. The minus sign ('-'
+	 * &#92;u002D) represents zero or more DNs, whereas the asterisk only
+	 * represents a single DN. For example, to match a DN where the Tweety Inc.
+	 * is in the DN chain, use the following expression:
+	 * </p>
+	 * 
+	 * <pre>
+	 * - ; *, o=Tweety Inc., c=US
+	 * </pre>
+	 * 
+	 * @param matchPattern The pattern against which to match the DN chain.
+	 * @param dnChain The DN chain to match against the specified pattern. Each
+	 *        element of the chain must be of type {@code String} and use the
+	 *        format defined in <a
+	 *        href="http://www.ietf.org/rfc/rfc2253.txt">RFC 2253</a>.
+	 * @return {@code true} If the pattern matches the DN chain; otherwise
+	 *         {@code false} is returned.
+	 * @throws IllegalArgumentException If the specified match pattern or DN
+	 *         chain is invalid.
+	 * @since 1.5
+	 */
+	public static boolean matchDistinguishedNameChain(String matchPattern,
+			List<String> dnChain) {
+		return DNChainMatching.match(matchPattern, dnChain);
+	}
+
+	/**
+	 * Return a {@code Bundle} for the specified bundle class. The returned
+	 * {@code Bundle} is the bundle associated with the bundle class loader
+	 * which defined the specified class.
+	 * 
+	 * @param classFromBundle A class defined by a bundle class loader.
+	 * @return A {@code Bundle} for the specified bundle class or
+	 *         {@code null} if the specified class was not defined by a
+	 *         bundle class loader.
+	 * @since 1.5
+	 */
+	public static Bundle getBundle(final Class< ? > classFromBundle) {
+		// We use doPriv since the caller may not have permission
+		// to call getClassLoader.
+		Object cl = AccessController
+				.doPrivileged(new PrivilegedAction<Object>() {
+			public Object run() {
+				return classFromBundle.getClassLoader();
+			}
+		});
+
+		if (cl instanceof BundleReference) {
+			return ((BundleReference) cl).getBundle();
+		}
+		return null;
+	}
+
+	/**
+	 * RFC 1960-based Filter. Filter objects can be created by calling the
+	 * constructor with the desired filter string. A Filter object can be called
+	 * numerous times to determine if the match argument matches the filter
+	 * string that was used to create the Filter object.
+	 * 
+	 * <p>
+	 * The syntax of a filter string is the string representation of LDAP search
+	 * filters as defined in RFC 1960: <i>A String Representation of LDAP Search
+	 * Filters</i> (available at http://www.ietf.org/rfc/rfc1960.txt). It should
+	 * be noted that RFC 2254: <i>A String Representation of LDAP Search
+	 * Filters</i> (available at http://www.ietf.org/rfc/rfc2254.txt) supersedes
+	 * RFC 1960 but only adds extensible matching and is not applicable for this
+	 * API.
+	 * 
+	 * <p>
+	 * The string representation of an LDAP search filter is defined by the
+	 * following grammar. It uses a prefix format.
+	 * 
+	 * <pre>
+	 *   &lt;filter&gt; ::= '(' &lt;filtercomp&gt; ')'
+	 *   &lt;filtercomp&gt; ::= &lt;and&gt; | &lt;or&gt; | &lt;not&gt; | &lt;item&gt;
+	 *   &lt;and&gt; ::= '&amp;' &lt;filterlist&gt;
+	 *   &lt;or&gt; ::= '|' &lt;filterlist&gt;
+	 *   &lt;not&gt; ::= '!' &lt;filter&gt;
+	 *   &lt;filterlist&gt; ::= &lt;filter&gt; | &lt;filter&gt; &lt;filterlist&gt;
+	 *   &lt;item&gt; ::= &lt;simple&gt; | &lt;present&gt; | &lt;substring&gt;
+	 *   &lt;simple&gt; ::= &lt;attr&gt; &lt;filtertype&gt; &lt;value&gt;
+	 *   &lt;filtertype&gt; ::= &lt;equal&gt; | &lt;approx&gt; | &lt;greater&gt; | &lt;less&gt;
+	 *   &lt;equal&gt; ::= '='
+	 *   &lt;approx&gt; ::= '&tilde;='
+	 *   &lt;greater&gt; ::= '&gt;='
+	 *   &lt;less&gt; ::= '&lt;='
+	 *   &lt;present&gt; ::= &lt;attr&gt; '=*'
+	 *   &lt;substring&gt; ::= &lt;attr&gt; '=' &lt;initial&gt; &lt;any&gt; &lt;final&gt;
+	 *   &lt;initial&gt; ::= NULL | &lt;value&gt;
+	 *   &lt;any&gt; ::= '*' &lt;starval&gt;
+	 *   &lt;starval&gt; ::= NULL | &lt;value&gt; '*' &lt;starval&gt;
+	 *   &lt;final&gt; ::= NULL | &lt;value&gt;
+	 * </pre>
+	 * 
+	 * {@code &lt;attr&gt;} is a string representing an attribute, or key,
+	 * in the properties objects of the registered services. Attribute names are
+	 * not case sensitive; that is cn and CN both refer to the same attribute.
+	 * {@code &lt;value&gt;} is a string representing the value, or part of
+	 * one, of a key in the properties objects of the registered services. If a
+	 * {@code &lt;value&gt;} must contain one of the characters '
+	 * {@code *}' or '{@code (}' or '{@code )}', these characters
+	 * should be escaped by preceding them with the backslash '{@code \}'
+	 * character. Note that although both the {@code &lt;substring&gt;} and
+	 * {@code &lt;present&gt;} productions can produce the {@code 'attr=*'}
+	 * construct, this construct is used only to denote a presence filter.
+	 * 
+	 * <p>
+	 * Examples of LDAP filters are:
+	 * 
+	 * <pre>
+	 *   &quot;(cn=Babs Jensen)&quot;
+	 *   &quot;(!(cn=Tim Howes))&quot;
+	 *   &quot;(&amp;(&quot; + Constants.OBJECTCLASS + &quot;=Person)(|(sn=Jensen)(cn=Babs J*)))&quot;
+	 *   &quot;(o=univ*of*mich*)&quot;
+	 * </pre>
+	 * 
+	 * <p>
+	 * The approximate match ({@code ~=}) is implementation specific but
+	 * should at least ignore case and white space differences. Optional are
+	 * codes like soundex or other smart "closeness" comparisons.
+	 * 
+	 * <p>
+	 * Comparison of values is not straightforward. Strings are compared
+	 * differently than numbers and it is possible for a key to have multiple
+	 * values. Note that that keys in the match argument must always be strings.
+	 * The comparison is defined by the object type of the key's value. The
+	 * following rules apply for comparison:
+	 * 
+	 * <blockquote>
+	 * <TABLE BORDER=0>
+	 * <TR>
+	 * <TD><b>Property Value Type </b></TD>
+	 * <TD><b>Comparison Type</b></TD>
+	 * </TR>
+	 * <TR>
+	 * <TD>String</TD>
+	 * <TD>String comparison</TD>
+	 * </TR>
+	 * <TR valign=top>
+	 * <TD>Integer, Long, Float, Double, Byte, Short, BigInteger, BigDecimal</TD>
+	 * <TD>numerical comparison</TD>
+	 * </TR>
+	 * <TR>
+	 * <TD>Character</TD>
+	 * <TD>character comparison</TD>
+	 * </TR>
+	 * <TR>
+	 * <TD>Boolean</TD>
+	 * <TD>equality comparisons only</TD>
+	 * </TR>
+	 * <TR>
+	 * <TD>[] (array)</TD>
+	 * <TD>recursively applied to values</TD>
+	 * </TR>
+	 * <TR>
+	 * <TD>Collection</TD>
+	 * <TD>recursively applied to values</TD>
+	 * </TR>
+	 * </TABLE>
+	 * Note: arrays of primitives are also supported. </blockquote>
+	 * 
+	 * A filter matches a key that has multiple values if it matches at least
+	 * one of those values. For example,
+	 * 
+	 * <pre>
+	 * Dictionary d = new Hashtable();
+	 * d.put(&quot;cn&quot;, new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;});
+	 * </pre>
+	 * 
+	 * d will match {@code (cn=a)} and also {@code (cn=b)}
+	 * 
+	 * <p>
+	 * A filter component that references a key having an unrecognizable data
+	 * type will evaluate to {@code false} .
+	 */
+	static private final class FilterImpl implements Filter {
+		/* filter operators */
+		private static final int	EQUAL		= 1;
+		private static final int	APPROX		= 2;
+		private static final int	GREATER		= 3;
+		private static final int	LESS		= 4;
+		private static final int	PRESENT		= 5;
+		private static final int	SUBSTRING	= 6;
+		private static final int	AND			= 7;
+		private static final int	OR			= 8;
+		private static final int	NOT			= 9;
+
+		/** filter operation */
+		private final int			op;
+		/** filter attribute or null if operation AND, OR or NOT */
+		private final String		attr;
+		/** filter operands */
+		private final Object		value;
+
+		/* normalized filter string for Filter object */
+		private transient String	filterString;
+
+		/**
+		 * Constructs a {@link FilterImpl} object. This filter object may be
+		 * used to match a {@link ServiceReference} or a Dictionary.
+		 * 
+		 * <p>
+		 * If the filter cannot be parsed, an {@link InvalidSyntaxException}
+		 * will be thrown with a human readable message where the filter became
+		 * unparsable.
+		 * 
+		 * @param filterString the filter string.
+		 * @throws InvalidSyntaxException If the filter parameter contains an
+		 *            invalid filter string that cannot be parsed.
+		 */
+		static FilterImpl newInstance(String filterString)
+				throws InvalidSyntaxException {
+			return new Parser(filterString).parse();
+		}
+
+		FilterImpl(int operation, String attr, Object value) {
+			this.op = operation;
+			this.attr = attr;
+			this.value = value;
+			filterString = null;
+		}
+
+		/**
+		 * Filter using a service's properties.
+		 * <p>
+		 * This {@code Filter} is executed using the keys and values of the
+		 * referenced service's properties. The keys are looked up in a case
+		 * insensitive manner.
+		 * 
+		 * @param reference The reference to the service whose properties are
+		 *        used in the match.
+		 * @return {@code true} if the service's properties match this
+		 *         {@code Filter}; {@code false} otherwise.
+		 */
+		public boolean match(ServiceReference< ? > reference) {
+			return matches(new ServiceReferenceMap(reference));
+		}
+
+		/**
+		 * Filter using a {@code Dictionary} with case insensitive key lookup.
+		 * This {@code Filter} is executed using the specified
+		 * {@code Dictionary}'s keys and values. The keys are looked up in a
+		 * case insensitive manner.
+		 * 
+		 * @param dictionary The {@code Dictionary} whose key/value pairs are
+		 *        used in the match.
+		 * @return {@code true} if the {@code Dictionary}'s values match this
+		 *         filter; {@code false} otherwise.
+		 * @throws IllegalArgumentException If {@code dictionary} contains case
+		 *         variants of the same key name.
+		 */
+		public boolean match(Dictionary<String, ? > dictionary) {
+			return matches(new CaseInsensitiveMap(dictionary));
+		}
+
+		/**
+		 * Filter using a {@code Dictionary}. This {@code Filter} is executed
+		 * using the specified {@code Dictionary}'s keys and values. The keys
+		 * are looked up in a normal manner respecting case.
+		 * 
+		 * @param dictionary The {@code Dictionary} whose key/value pairs are
+		 *        used in the match.
+		 * @return {@code true} if the {@code Dictionary}'s values match this
+		 *         filter; {@code false} otherwise.
+		 * @since 1.3
+		 */
+		public boolean matchCase(Dictionary<String, ? > dictionary) {
+			switch (op) {
+				case AND : {
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						if (!f.matchCase(dictionary)) {
+							return false;
+						}
+					}
+					return true;
+				}
+
+				case OR : {
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						if (f.matchCase(dictionary)) {
+							return true;
+						}
+					}
+					return false;
+				}
+
+				case NOT : {
+					FilterImpl filter = (FilterImpl) value;
+					return !filter.matchCase(dictionary);
+				}
+
+				case SUBSTRING :
+				case EQUAL :
+				case GREATER :
+				case LESS :
+				case APPROX : {
+					Object prop = (dictionary == null) ? null : dictionary
+							.get(attr);
+					return compare(op, prop, value);
+				}
+
+				case PRESENT : {
+					Object prop = (dictionary == null) ? null : dictionary
+							.get(attr);
+					return prop != null;
+				}
+			}
+
+			return false;
+		}
+
+		/**
+		 * Filter using a {@code Map}. This {@code Filter} is executed using the
+		 * specified {@code Map}'s keys and values. The keys are looked up in a
+		 * normal manner respecting case.
+		 * 
+		 * @param map The {@code Map} whose key/value pairs are used in the
+		 *        match. Maps with {@code null} key or values are not supported.
+		 *        A {@code null} value is considered not present to the filter.
+		 * @return {@code true} if the {@code Map}'s values match this filter;
+		 *         {@code false} otherwise.
+		 * @since 1.6
+		 */
+		public boolean matches(Map<String, ? > map) {
+			switch (op) {
+				case AND : {
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						if (!f.matches(map)) {
+							return false;
+						}
+					}
+					return true;
+				}
+		
+				case OR : {
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						if (f.matches(map)) {
+							return true;
+						}
+					}
+					return false;
+				}
+		
+				case NOT : {
+					FilterImpl filter = (FilterImpl) value;
+					return !filter.matches(map);
+				}
+		
+				case SUBSTRING :
+				case EQUAL :
+				case GREATER :
+				case LESS :
+				case APPROX : {
+					Object prop = (map == null) ? null : map.get(attr);
+					return compare(op, prop, value);
+				}
+		
+				case PRESENT : {
+					Object prop = (map == null) ? null : map.get(attr);
+					return prop != null;
+				}
+			}
+		
+			return false;
+		}
+
+		/**
+		 * Returns this {@code Filter}'s filter string.
+		 * <p>
+		 * The filter string is normalized by removing whitespace which does not
+		 * affect the meaning of the filter.
+		 * 
+		 * @return This {@code Filter}'s filter string.
+		 */
+		public String toString() {
+			String result = filterString;
+			if (result == null) {
+				filterString = result = normalize().toString();
+			}
+			return result;
+		}
+
+		/**
+		 * Returns this {@code Filter}'s normalized filter string.
+		 * <p>
+		 * The filter string is normalized by removing whitespace which does not
+		 * affect the meaning of the filter.
+		 * 
+		 * @return This {@code Filter}'s filter string.
+		 */
+		private StringBuffer normalize() {
+			StringBuffer sb = new StringBuffer();
+			sb.append('(');
+
+			switch (op) {
+				case AND : {
+					sb.append('&');
+
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						sb.append(f.normalize());
+					}
+
+					break;
+				}
+
+				case OR : {
+					sb.append('|');
+
+					FilterImpl[] filters = (FilterImpl[]) value;
+					for (FilterImpl f : filters) {
+						sb.append(f.normalize());
+					}
+
+					break;
+				}
+
+				case NOT : {
+					sb.append('!');
+					FilterImpl filter = (FilterImpl) value;
+					sb.append(filter.normalize());
+
+					break;
+				}
+
+				case SUBSTRING : {
+					sb.append(attr);
+					sb.append('=');
+
+					String[] substrings = (String[]) value;
+
+					for (String substr : substrings) {
+						if (substr == null) /* * */{
+							sb.append('*');
+						}
+						else /* xxx */{
+							sb.append(encodeValue(substr));
+						}
+					}
+
+					break;
+				}
+				case EQUAL : {
+					sb.append(attr);
+					sb.append('=');
+					sb.append(encodeValue((String) value));
+
+					break;
+				}
+				case GREATER : {
+					sb.append(attr);
+					sb.append(">=");
+					sb.append(encodeValue((String) value));
+
+					break;
+				}
+				case LESS : {
+					sb.append(attr);
+					sb.append("<=");
+					sb.append(encodeValue((String) value));
+
+					break;
+				}
+				case APPROX : {
+					sb.append(attr);
+					sb.append("~=");
+					sb.append(encodeValue(approxString((String) value)));
+
+					break;
+				}
+
+				case PRESENT : {
+					sb.append(attr);
+					sb.append("=*");
+
+					break;
+				}
+			}
+
+			sb.append(')');
+
+			return sb;
+		}
+
+		/**
+		 * Compares this {@code Filter} to another {@code Filter}.
+		 * 
+		 * <p>
+		 * This implementation returns the result of calling
+		 * {@code this.toString().equals(obj.toString()}.
+		 * 
+		 * @param obj The object to compare against this {@code Filter}.
+		 * @return If the other object is a {@code Filter} object, then
+		 *         returns the result of calling
+		 *         {@code this.toString().equals(obj.toString()};
+		 *         {@code false} otherwise.
+		 */
+		public boolean equals(Object obj) {
+			if (obj == this) {
+				return true;
+			}
+
+			if (!(obj instanceof Filter)) {
+				return false;
+			}
+
+			return this.toString().equals(obj.toString());
+		}
+
+		/**
+		 * Returns the hashCode for this {@code Filter}.
+		 * 
+		 * <p>
+		 * This implementation returns the result of calling
+		 * {@code this.toString().hashCode()}.
+		 * 
+		 * @return The hashCode of this {@code Filter}.
+		 */
+		public int hashCode() {
+			return this.toString().hashCode();
+		}
+
+		/**
+		 * Encode the value string such that '(', '*', ')' and '\' are escaped.
+		 * 
+		 * @param value unencoded value string.
+		 * @return encoded value string.
+		 */
+		private static String encodeValue(String value) {
+			boolean encoded = false;
+			int inlen = value.length();
+			int outlen = inlen << 1; /* inlen 2 */
+
+			char[] output = new char[outlen];
+			value.getChars(0, inlen, output, inlen);
+
+			int cursor = 0;
+			for (int i = inlen; i < outlen; i++) {
+				char c = output[i];
+
+				switch (c) {
+					case '(' :
+					case '*' :
+					case ')' :
+					case '\\' : {
+						output[cursor] = '\\';
+						cursor++;
+						encoded = true;
+
+						break;
+					}
+				}
+
+				output[cursor] = c;
+				cursor++;
+			}
+
+			return encoded ? new String(output, 0, cursor) : value;
+		}
+
+		private boolean compare(int operation, Object value1, Object value2) {
+			if (value1 == null) {
+				return false;
+			}
+			if (value1 instanceof String) {
+				return compare_String(operation, (String) value1, value2);
+			}
+
+			Class< ? > clazz = value1.getClass();
+			if (clazz.isArray()) {
+				Class< ? > type = clazz.getComponentType();
+				if (type.isPrimitive()) {
+					return compare_PrimitiveArray(operation, type, value1,
+							value2);
+				}
+				return compare_ObjectArray(operation, (Object[]) value1, value2);
+			}
+			if (value1 instanceof Collection< ? >) {
+				return compare_Collection(operation, (Collection< ? >) value1,
+						value2);
+			}
+			if (value1 instanceof Integer) {
+				return compare_Integer(operation,
+						((Integer) value1).intValue(), value2);
+			}
+			if (value1 instanceof Long) {
+				return compare_Long(operation, ((Long) value1).longValue(),
+						value2);
+			}
+			if (value1 instanceof Byte) {
+				return compare_Byte(operation, ((Byte) value1).byteValue(),
+						value2);
+			}
+			if (value1 instanceof Short) {
+				return compare_Short(operation, ((Short) value1).shortValue(),
+						value2);
+			}
+			if (value1 instanceof Character) {
+				return compare_Character(operation, ((Character) value1)
+						.charValue(), value2);
+			}
+			if (value1 instanceof Float) {
+				return compare_Float(operation, ((Float) value1).floatValue(),
+						value2);
+			}
+			if (value1 instanceof Double) {
+				return compare_Double(operation, ((Double) value1)
+						.doubleValue(), value2);
+			}
+			if (value1 instanceof Boolean) {
+				return compare_Boolean(operation, ((Boolean) value1)
+						.booleanValue(), value2);
+			}
+			if (value1 instanceof Comparable< ? >) {
+				Comparable<Object> comparable = (Comparable<Object>) value1;
+				return compare_Comparable(operation, comparable, value2);
+			}
+			return compare_Unknown(operation, value1, value2);
+		}
+
+		private boolean compare_Collection(int operation,
+				Collection< ? > collection, Object value2) {
+			for (Object value1 : collection) {
+				if (compare(operation, value1, value2)) {
+					return true;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_ObjectArray(int operation, Object[] array,
+				Object value2) {
+			for (Object value1 : array) {
+				if (compare(operation, value1, value2)) {
+					return true;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_PrimitiveArray(int operation, Class< ? > type,
+				Object primarray, Object value2) {
+			if (Integer.TYPE.isAssignableFrom(type)) {
+				int[] array = (int[]) primarray;
+				for (int value1 : array) {
+					if (compare_Integer(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Long.TYPE.isAssignableFrom(type)) {
+				long[] array = (long[]) primarray;
+				for (long value1 : array) {
+					if (compare_Long(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Byte.TYPE.isAssignableFrom(type)) {
+				byte[] array = (byte[]) primarray;
+				for (byte value1 : array) {
+					if (compare_Byte(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Short.TYPE.isAssignableFrom(type)) {
+				short[] array = (short[]) primarray;
+				for (short value1 : array) {
+					if (compare_Short(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Character.TYPE.isAssignableFrom(type)) {
+				char[] array = (char[]) primarray;
+				for (char value1 : array) {
+					if (compare_Character(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Float.TYPE.isAssignableFrom(type)) {
+				float[] array = (float[]) primarray;
+				for (float value1 : array) {
+					if (compare_Float(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Double.TYPE.isAssignableFrom(type)) {
+				double[] array = (double[]) primarray;
+				for (double value1 : array) {
+					if (compare_Double(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			if (Boolean.TYPE.isAssignableFrom(type)) {
+				boolean[] array = (boolean[]) primarray;
+				for (boolean value1 : array) {
+					if (compare_Boolean(operation, value1, value2)) {
+						return true;
+					}
+				}
+				return false;
+			}
+			return false;
+		}
+
+		private boolean compare_String(int operation, String string,
+				Object value2) {
+			switch (operation) {
+				case SUBSTRING : {
+					String[] substrings = (String[]) value2;
+					int pos = 0;
+					for (int i = 0, size = substrings.length; i < size; i++) {
+						String substr = substrings[i];
+
+						if (i + 1 < size) /* if this is not that last substr */{
+							if (substr == null) /* * */{
+								String substr2 = substrings[i + 1];
+
+								if (substr2 == null) /* ** */
+									continue; /* ignore first star */
+								/* xxx */
+								int index = string.indexOf(substr2, pos);
+								if (index == -1) {
+									return false;
+								}
+
+								pos = index + substr2.length();
+								if (i + 2 < size) // if there are more
+									// substrings, increment
+									// over the string we just
+									// matched; otherwise need
+									// to do the last substr
+									// check
+									i++;
+							}
+							else /* xxx */{
+								int len = substr.length();
+								if (string.regionMatches(pos, substr, 0, len)) {
+									pos += len;
+								}
+								else {
+									return false;
+								}
+							}
+						}
+						else /* last substr */{
+							if (substr == null) /* * */{
+								return true;
+							}
+							/* xxx */
+							return string.endsWith(substr);
+						}
+					}
+
+					return true;
+				}
+				case EQUAL : {
+					return string.equals(value2);
+				}
+				case APPROX : {
+					string = approxString(string);
+					String string2 = approxString((String) value2);
+
+					return string.equalsIgnoreCase(string2);
+				}
+				case GREATER : {
+					return string.compareTo((String) value2) >= 0;
+				}
+				case LESS : {
+					return string.compareTo((String) value2) <= 0;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Integer(int operation, int intval, Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			int intval2;
+			try {
+				intval2 = Integer.parseInt(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return intval == intval2;
+				}
+				case GREATER : {
+					return intval >= intval2;
+				}
+				case LESS : {
+					return intval <= intval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Long(int operation, long longval, Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			long longval2;
+			try {
+				longval2 = Long.parseLong(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return longval == longval2;
+				}
+				case GREATER : {
+					return longval >= longval2;
+				}
+				case LESS : {
+					return longval <= longval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Byte(int operation, byte byteval, Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			byte byteval2;
+			try {
+				byteval2 = Byte.parseByte(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return byteval == byteval2;
+				}
+				case GREATER : {
+					return byteval >= byteval2;
+				}
+				case LESS : {
+					return byteval <= byteval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Short(int operation, short shortval,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			short shortval2;
+			try {
+				shortval2 = Short.parseShort(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return shortval == shortval2;
+				}
+				case GREATER : {
+					return shortval >= shortval2;
+				}
+				case LESS : {
+					return shortval <= shortval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Character(int operation, char charval,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			char charval2;
+			try {
+				charval2 = ((String) value2).charAt(0);
+			}
+			catch (IndexOutOfBoundsException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case EQUAL : {
+					return charval == charval2;
+				}
+				case APPROX : {
+					return (charval == charval2)
+							|| (Character.toUpperCase(charval) == Character
+									.toUpperCase(charval2))
+							|| (Character.toLowerCase(charval) == Character
+									.toLowerCase(charval2));
+				}
+				case GREATER : {
+					return charval >= charval2;
+				}
+				case LESS : {
+					return charval <= charval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Boolean(int operation, boolean boolval,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			boolean boolval2 = Boolean.valueOf(((String) value2).trim())
+					.booleanValue();
+			switch (operation) {
+				case APPROX :
+				case EQUAL :
+				case GREATER :
+				case LESS : {
+					return boolval == boolval2;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Float(int operation, float floatval,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			float floatval2;
+			try {
+				floatval2 = Float.parseFloat(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return Float.compare(floatval, floatval2) == 0;
+				}
+				case GREATER : {
+					return Float.compare(floatval, floatval2) >= 0;
+				}
+				case LESS : {
+					return Float.compare(floatval, floatval2) <= 0;
+				}
+			}
+			return false;
+		}
+
+		private boolean compare_Double(int operation, double doubleval,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			double doubleval2;
+			try {
+				doubleval2 = Double.parseDouble(((String) value2).trim());
+			}
+			catch (IllegalArgumentException e) {
+				return false;
+			}
+
+			switch (operation) {
+				case APPROX :
+				case EQUAL : {
+					return Double.compare(doubleval, doubleval2) == 0;
+				}
+				case GREATER : {
+					return Double.compare(doubleval, doubleval2) >= 0;
+				}
+				case LESS : {
+					return Double.compare(doubleval, doubleval2) <= 0;
+				}
+			}
+			return false;
+		}
+
+		private static final Class< ? >[]	constructorType	= new Class[] {String.class};
+
+		private boolean compare_Comparable(int operation,
+				Comparable<Object> value1, Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			Constructor< ? > constructor;
+			try {
+				constructor = value1.getClass().getConstructor(constructorType);
+			}
+			catch (NoSuchMethodException e) {
+				return false;
+			}
+			try {
+				if (!constructor.isAccessible())
+					AccessController.doPrivileged(new SetAccessibleAction(
+							constructor));
+				value2 = constructor
+						.newInstance(new Object[] {((String) value2).trim()});
+			}
+			catch (IllegalAccessException e) {
+				return false;
+			}
+			catch (InvocationTargetException e) {
+				return false;
+			}
+			catch (InstantiationException e) {
+				return false;
+			}
+
+			try {
+				switch (operation) {
+					case APPROX :
+					case EQUAL : {
+						return value1.compareTo(value2) == 0;
+					}
+					case GREATER : {
+						return value1.compareTo(value2) >= 0;
+					}
+					case LESS : {
+						return value1.compareTo(value2) <= 0;
+					}
+				}
+			}
+			catch (Exception e) {
+				// if the compareTo method throws an exception; return false
+				return false;
+			}
+			return false;
+		}
+
+		private boolean compare_Unknown(int operation, Object value1,
+				Object value2) {
+			if (operation == SUBSTRING) {
+				return false;
+			}
+			Constructor< ? > constructor;
+			try {
+				constructor = value1.getClass().getConstructor(constructorType);
+			}
+			catch (NoSuchMethodException e) {
+				return false;
+			}
+			try {
+				if (!constructor.isAccessible())
+					AccessController.doPrivileged(new SetAccessibleAction(
+							constructor));
+				value2 = constructor
+						.newInstance(new Object[] {((String) value2).trim()});
+			}
+			catch (IllegalAccessException e) {
+				return false;
+			}
+			catch (InvocationTargetException e) {
+				return false;
+			}
+			catch (InstantiationException e) {
+				return false;
+			}
+
+			try {
+				switch (operation) {
+					case APPROX :
+					case EQUAL :
+					case GREATER :
+					case LESS : {
+						return value1.equals(value2);
+					}
+				}
+			}
+			catch (Exception e) {
+				// if the equals method throws an exception; return false
+				return false;
+			}
+			return false;
+		}
+
+		/**
+		 * Map a string for an APPROX (~=) comparison.
+		 * 
+		 * This implementation removes white spaces. This is the minimum
+		 * implementation allowed by the OSGi spec.
+		 * 
+		 * @param input Input string.
+		 * @return String ready for APPROX comparison.
+		 */
+		private static String approxString(String input) {
+			boolean changed = false;
+			char[] output = input.toCharArray();
+			int cursor = 0;
+			for (char c : output) {
+				if (Character.isWhitespace(c)) {
+					changed = true;
+					continue;
+				}
+
+				output[cursor] = c;
+				cursor++;
+			}
+
+			return changed ? new String(output, 0, cursor) : input;
+		}
+
+		/**
+		 * Parser class for OSGi filter strings. This class parses the complete
+		 * filter string and builds a tree of Filter objects rooted at the
+		 * parent.
+		 */
+		static private final class Parser {
+			private final String	filterstring;
+			private final char[]	filterChars;
+			private int				pos;
+
+			Parser(String filterstring) {
+				this.filterstring = filterstring;
+				filterChars = filterstring.toCharArray();
+				pos = 0;
+			}
+
+			FilterImpl parse() throws InvalidSyntaxException {
+				FilterImpl filter;
+				try {
+					filter = parse_filter();
+				}
+				catch (ArrayIndexOutOfBoundsException e) {
+					throw new InvalidSyntaxException("Filter ended abruptly",
+							filterstring, e);
+				}
+
+				if (pos != filterChars.length) {
+					throw new InvalidSyntaxException(
+							"Extraneous trailing characters: "
+									+ filterstring.substring(pos), filterstring);
+				}
+				return filter;
+			}
+
+			private FilterImpl parse_filter() throws InvalidSyntaxException {
+				FilterImpl filter;
+				skipWhiteSpace();
+
+				if (filterChars[pos] != '(') {
+					throw new InvalidSyntaxException("Missing '(': "
+							+ filterstring.substring(pos), filterstring);
+				}
+
+				pos++;
+
+				filter = parse_filtercomp();
+
+				skipWhiteSpace();
+
+				if (filterChars[pos] != ')') {
+					throw new InvalidSyntaxException("Missing ')': "
+							+ filterstring.substring(pos), filterstring);
+				}
+
+				pos++;
+
+				skipWhiteSpace();
+
+				return filter;
+			}
+
+			private FilterImpl parse_filtercomp() throws InvalidSyntaxException {
+				skipWhiteSpace();
+
+				char c = filterChars[pos];
+
+				switch (c) {
+					case '&' : {
+						pos++;
+						return parse_and();
+					}
+					case '|' : {
+						pos++;
+						return parse_or();
+					}
+					case '!' : {
+						pos++;
+						return parse_not();
+					}
+				}
+				return parse_item();
+			}
+
+			private FilterImpl parse_and() throws InvalidSyntaxException {
+				int lookahead = pos;
+				skipWhiteSpace();
+
+				if (filterChars[pos] != '(') {
+					pos = lookahead - 1;
+					return parse_item();
+				}
+
+				List<FilterImpl> operands = new ArrayList<FilterImpl>(10);
+
+				while (filterChars[pos] == '(') {
+					FilterImpl child = parse_filter();
+					operands.add(child);
+				}
+
+				return new FilterImpl(FilterImpl.AND, null, operands
+						.toArray(new FilterImpl[operands.size()]));
+			}
+
+			private FilterImpl parse_or() throws InvalidSyntaxException {
+				int lookahead = pos;
+				skipWhiteSpace();
+
+				if (filterChars[pos] != '(') {
+					pos = lookahead - 1;
+					return parse_item();
+				}
+
+				List<FilterImpl> operands = new ArrayList<FilterImpl>(10);
+
+				while (filterChars[pos] == '(') {
+					FilterImpl child = parse_filter();
+					operands.add(child);
+				}
+
+				return new FilterImpl(FilterImpl.OR, null, operands
+						.toArray(new FilterImpl[operands.size()]));
+			}
+
+			private FilterImpl parse_not() throws InvalidSyntaxException {
+				int lookahead = pos;
+				skipWhiteSpace();
+
+				if (filterChars[pos] != '(') {
+					pos = lookahead - 1;
+					return parse_item();
+				}
+
+				FilterImpl child = parse_filter();
+
+				return new FilterImpl(FilterImpl.NOT, null, child);
+			}
+
+			private FilterImpl parse_item() throws InvalidSyntaxException {
+				String attr = parse_attr();
+
+				skipWhiteSpace();
+
+				switch (filterChars[pos]) {
+					case '~' : {
+						if (filterChars[pos + 1] == '=') {
+							pos += 2;
+							return new FilterImpl(FilterImpl.APPROX, attr,
+									parse_value());
+						}
+						break;
+					}
+					case '>' : {
+						if (filterChars[pos + 1] == '=') {
+							pos += 2;
+							return new FilterImpl(FilterImpl.GREATER, attr,
+									parse_value());
+						}
+						break;
+					}
+					case '<' : {
+						if (filterChars[pos + 1] == '=') {
+							pos += 2;
+							return new FilterImpl(FilterImpl.LESS, attr,
+									parse_value());
+						}
+						break;
+					}
+					case '=' : {
+						if (filterChars[pos + 1] == '*') {
+							int oldpos = pos;
+							pos += 2;
+							skipWhiteSpace();
+							if (filterChars[pos] == ')') {
+								return new FilterImpl(FilterImpl.PRESENT, attr,
+										null);
+							}
+							pos = oldpos;
+						}
+
+						pos++;
+						Object string = parse_substring();
+
+						if (string instanceof String) {
+							return new FilterImpl(FilterImpl.EQUAL, attr,
+									string);
+						}
+						return new FilterImpl(FilterImpl.SUBSTRING, attr,
+								string);
+					}
+				}
+
+				throw new InvalidSyntaxException("Invalid operator: "
+						+ filterstring.substring(pos), filterstring);
+			}
+
+			private String parse_attr() throws InvalidSyntaxException {
+				skipWhiteSpace();
+
+				int begin = pos;
+				int end = pos;
+
+				char c = filterChars[pos];
+
+				while (c != '~' && c != '<' && c != '>' && c != '=' && c != '('
+						&& c != ')') {
+					pos++;
+
+					if (!Character.isWhitespace(c)) {
+						end = pos;
+					}
+
+					c = filterChars[pos];
+				}
+
+				int length = end - begin;
+
+				if (length == 0) {
+					throw new InvalidSyntaxException("Missing attr: "
+							+ filterstring.substring(pos), filterstring);
+				}
+
+				return new String(filterChars, begin, length);
+			}
+
+			private String parse_value() throws InvalidSyntaxException {
+				StringBuffer sb = new StringBuffer(filterChars.length - pos);
+
+				parseloop: while (true) {
+					char c = filterChars[pos];
+
+					switch (c) {
+						case ')' : {
+							break parseloop;
+						}
+
+						case '(' : {
+							throw new InvalidSyntaxException("Invalid value: "
+									+ filterstring.substring(pos), filterstring);
+						}
+
+						case '\\' : {
+							pos++;
+							c = filterChars[pos];
+							/* fall through into default */
+						}
+
+						default : {
+							sb.append(c);
+							pos++;
+							break;
+						}
+					}
+				}
+
+				if (sb.length() == 0) {
+					throw new InvalidSyntaxException("Missing value: "
+							+ filterstring.substring(pos), filterstring);
+				}
+
+				return sb.toString();
+			}
+
+			private Object parse_substring() throws InvalidSyntaxException {
+				StringBuffer sb = new StringBuffer(filterChars.length - pos);
+
+				List<String> operands = new ArrayList<String>(10);
+
+				parseloop: while (true) {
+					char c = filterChars[pos];
+
+					switch (c) {
+						case ')' : {
+							if (sb.length() > 0) {
+								operands.add(sb.toString());
+							}
+
+							break parseloop;
+						}
+
+						case '(' : {
+							throw new InvalidSyntaxException("Invalid value: "
+									+ filterstring.substring(pos), filterstring);
+						}
+
+						case '*' : {
+							if (sb.length() > 0) {
+								operands.add(sb.toString());
+							}
+
+							sb.setLength(0);
+
+							operands.add(null);
+							pos++;
+
+							break;
+						}
+
+						case '\\' : {
+							pos++;
+							c = filterChars[pos];
+							/* fall through into default */
+						}
+
+						default : {
+							sb.append(c);
+							pos++;
+							break;
+						}
+					}
+				}
+
+				int size = operands.size();
+
+				if (size == 0) {
+					return "";
+				}
+
+				if (size == 1) {
+					Object single = operands.get(0);
+
+					if (single != null) {
+						return single;
+					}
+				}
+
+				return operands.toArray(new String[size]);
+			}
+
+			private void skipWhiteSpace() {
+				for (int length = filterChars.length; (pos < length)
+						&& Character.isWhitespace(filterChars[pos]);) {
+					pos++;
+				}
+			}
+		}
+	}
+
+	/**
+	 * This Map is used for case-insensitive key lookup during filter
+	 * evaluation. This Map implementation only supports the get operation using
+	 * a String key as no other operations are used by the Filter
+	 * implementation.
+	 */
+	static private final class CaseInsensitiveMap extends
+			AbstractMap<String, Object>
+			implements Map<String, Object> {
+		private final Dictionary<String, ? >	dictionary;
+		private final String[]		keys;
+
+		/**
+		 * Create a case insensitive map from the specified dictionary.
+		 * 
+		 * @param dictionary
+		 * @throws IllegalArgumentException If {@code dictionary} contains case
+		 *         variants of the same key name.
+		 */
+		CaseInsensitiveMap(Dictionary<String, ? > dictionary) {
+			if (dictionary == null) {
+				this.dictionary = null;
+				this.keys = new String[0];
+				return;
+			}
+			this.dictionary = dictionary;
+			List<String> keyList = new ArrayList<String>(dictionary.size());
+			for (Enumeration<?> e = dictionary.keys(); e.hasMoreElements();) {
+				Object k = e.nextElement();
+				if (k instanceof String) {
+					String key = (String) k;
+					for (String i : keyList) {
+						if (key.equalsIgnoreCase(i)) {
+							throw new IllegalArgumentException();
+						}
+					}
+					keyList.add(key);
+				}
+			}
+			this.keys = keyList.toArray(new String[keyList.size()]);
+		}
+
+		public Object get(Object o) {
+			String k = (String) o;
+			for (String key : keys) {
+				if (key.equalsIgnoreCase(k)) {
+					return dictionary.get(key);
+				}
+			}
+			return null;
+		}
+
+		public Set<java.util.Map.Entry<String, Object>> entrySet() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * This Map is used for key lookup from a ServiceReference during filter
+	 * evaluation. This Map implementation only supports the get operation using
+	 * a String key as no other operations are used by the Filter
+	 * implementation.
+	 */
+	static private final class ServiceReferenceMap extends
+			AbstractMap<String, Object> implements Map<String, Object> {
+		private final ServiceReference< ? >	reference;
+
+		ServiceReferenceMap(ServiceReference< ? > reference) {
+			this.reference = reference;
+		}
+
+		public Object get(Object key) {
+			if (reference == null) {
+				return null;
+			}
+			return reference.getProperty((String) key);
+		}
+
+		public Set<java.util.Map.Entry<String, Object>> entrySet() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	static private final class SetAccessibleAction implements
+			PrivilegedAction<Object> {
+		private final AccessibleObject	accessible;
+
+		SetAccessibleAction(AccessibleObject accessible) {
+			this.accessible = accessible;
+		}
+
+		public Object run() {
+			accessible.setAccessible(true);
+			return null;
+		}
+	}
+
+	/**
+	 * This class contains a method to match a distinguished name (DN) chain
+	 * against and DN chain pattern.
+	 * <p>
+	 * The format of DNs are given in RFC 2253. We represent a signature chain
+	 * for an X.509 certificate as a semicolon separated list of DNs. This is
+	 * what we refer to as the DN chain. Each DN is made up of relative
+	 * distinguished names (RDN) which in turn are made up of key value pairs.
+	 * For example:
+	 * 
+	 * <pre>
+	 *   cn=ben+ou=research,o=ACME,c=us;ou=Super CA,c=CA
+	 * </pre>
+	 * 
+	 * is made up of two DNs: "{@code cn=ben+ou=research,o=ACME,c=us}
+	 * " and " {@code ou=Super CA,c=CA}
+	 * ". The first DN is made of of three RDNs: "
+	 * {@code cn=ben+ou=research}" and "{@code o=ACME}" and "
+	 * {@code c=us}". The first RDN has two name value pairs: "
+	 * {@code cn=ben}" and "{@code ou=research}".
+	 * <p>
+	 * A chain pattern makes use of wildcards ('*' or '-') to match against DNs,
+	 * and wildcards ('*') to match againts DN prefixes, and value. If a DN in a
+	 * match pattern chain is made up of a wildcard ("*"), that wildcard will
+	 * match zero or one DNs in the chain. If a DN in a match pattern chain is
+	 * made up of a wildcard ("-"), that wildcard will match zero or more DNs in
+	 * the chain. If the first RDN of a DN is the wildcard ("*"), that DN will
+	 * match any other DN with the same suffix (the DN with the wildcard RDN
+	 * removed). If a value of a name/value pair is a wildcard ("*"), the value
+	 * will match any value for that name.
+	 */
+	static private final class DNChainMatching {
+		private static final String	MINUS_WILDCARD	= "-";
+		private static final String	STAR_WILDCARD	= "*";
+
+		/**
+		 * Check the name/value pairs of the rdn against the pattern.
+		 * 
+		 * @param rdn List of name value pairs for a given RDN.
+		 * @param rdnPattern List of name value pattern pairs.
+		 * @return true if the list of name value pairs match the pattern.
+		 */
+		private static boolean rdnmatch(List< ? > rdn, List< ? > rdnPattern) {
+			if (rdn.size() != rdnPattern.size()) {
+				return false;
+			}
+			for (int i = 0; i < rdn.size(); i++) {
+				String rdnNameValue = (String) rdn.get(i);
+				String patNameValue = (String) rdnPattern.get(i);
+				int rdnNameEnd = rdnNameValue.indexOf('=');
+				int patNameEnd = patNameValue.indexOf('=');
+				if (rdnNameEnd != patNameEnd
+						|| !rdnNameValue.regionMatches(0, patNameValue, 0,
+								rdnNameEnd)) {
+					return false;
+				}
+				String patValue = patNameValue.substring(patNameEnd);
+				String rdnValue = rdnNameValue.substring(rdnNameEnd);
+				if (!rdnValue.equals(patValue) && !patValue.equals("=*")
+						&& !patValue.equals("=#16012a")) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+		private static boolean dnmatch(List< ? > dn, List< ? > dnPattern) {
+			int dnStart = 0;
+			int patStart = 0;
+			int patLen = dnPattern.size();
+			if (patLen == 0) {
+				return false;
+			}
+			if (dnPattern.get(0).equals(STAR_WILDCARD)) {
+				patStart = 1;
+				patLen--;
+			}
+			if (dn.size() < patLen) {
+				return false;
+			}
+			else {
+				if (dn.size() > patLen) {
+					if (!dnPattern.get(0).equals(STAR_WILDCARD)) {
+						// If the number of rdns do not match we must have a
+						// prefix map
+						return false;
+					}
+					// The rdnPattern and rdn must have the same number of
+					// elements
+					dnStart = dn.size() - patLen;
+				}
+			}
+			for (int i = 0; i < patLen; i++) {
+				if (!rdnmatch((List< ? >) dn.get(i + dnStart),
+						(List< ? >) dnPattern
+						.get(i + patStart))) {
+					return false;
+				}
+			}
+			return true;
+		}
+
+		/**
+		 * Parses a distinguished name chain pattern and returns a List where
+		 * each element represents a distinguished name (DN) in the chain of
+		 * DNs. Each element will be either a String, if the element represents
+		 * a wildcard ("*" or "-"), or a List representing an RDN. Each element
+		 * in the RDN List will be a String, if the element represents a
+		 * wildcard ("*"), or a List of Strings, each String representing a
+		 * name/value pair in the RDN.
+		 * 
+		 * @param dnChain
+		 * @return a list of DNs.
+		 * @throws IllegalArgumentException
+		 */
+		private static List<Object> parseDNchainPattern(String dnChain) {
+			if (dnChain == null) {
+				throw new IllegalArgumentException(
+						"The DN chain must not be null.");
+			}
+			List<Object> parsed = new ArrayList<Object>();
+			int startIndex = 0;
+			startIndex = skipSpaces(dnChain, startIndex);
+			while (startIndex < dnChain.length()) {
+				int endIndex = startIndex;
+				boolean inQuote = false;
+				out: while (endIndex < dnChain.length()) {
+					char c = dnChain.charAt(endIndex);
+					switch (c) {
+						case '"' :
+							inQuote = !inQuote;
+							break;
+						case '\\' :
+							endIndex++; // skip the escaped char
+							break;
+						case ';' :
+							if (!inQuote)
+								break out;
+					}
+					endIndex++;
+				}
+				if (endIndex > dnChain.length()) {
+					throw new IllegalArgumentException("unterminated escape");
+				}
+				parsed.add(dnChain.substring(startIndex, endIndex));
+				startIndex = endIndex + 1;
+				startIndex = skipSpaces(dnChain, startIndex);
+			}
+
+			// Now we parse is a list of strings, lets make List of rdn out
+			// of them
+			for (int i = 0; i < parsed.size(); i++) {
+				String dn = (String) parsed.get(i);
+				if (dn.equals(STAR_WILDCARD) || dn.equals(MINUS_WILDCARD)) {
+					continue;
+				}
+				List<Object> rdns = new ArrayList<Object>();
+				if (dn.charAt(0) == '*') {
+					if (dn.charAt(1) != ',') {
+						throw new IllegalArgumentException(
+								"invalid wildcard prefix");
+					}
+					rdns.add(STAR_WILDCARD);
+					dn = new X500Principal(dn.substring(2))
+							.getName(X500Principal.CANONICAL);
+				}
+				else {
+					dn = new X500Principal(dn).getName(X500Principal.CANONICAL);
+				}
+				// Now dn is a nice CANONICAL DN
+				parseDN(dn, rdns);
+				parsed.set(i, rdns);
+			}
+			if (parsed.size() == 0) {
+				throw new IllegalArgumentException("empty DN chain");
+			}
+			return parsed;
+		}
+
+		private static List<Object> parseDNchain(List<String> chain) {
+			if (chain == null) {
+				throw new IllegalArgumentException("DN chain must not be null.");
+			}
+			List<Object> result = new ArrayList<Object>(chain.size());
+			// Now we parse is a list of strings, lets make List of rdn out
+			// of them
+			for (String dn : chain) {
+				dn = new X500Principal(dn).getName(X500Principal.CANONICAL);
+				// Now dn is a nice CANONICAL DN
+				List<Object> rdns = new ArrayList<Object>();
+				parseDN(dn, rdns);
+				result.add(rdns);
+			}
+			if (result.size() == 0) {
+				throw new IllegalArgumentException("empty DN chain");
+			}
+			return result;
+		}
+
+		/**
+		 * Increment startIndex until the end of dnChain is hit or until it is
+		 * the index of a non-space character.
+		 */
+		private static int skipSpaces(String dnChain, int startIndex) {
+			while (startIndex < dnChain.length()
+					&& dnChain.charAt(startIndex) == ' ') {
+				startIndex++;
+			}
+			return startIndex;
+		}
+
+		/**
+		 * Takes a distinguished name in canonical form and fills in the
+		 * rdnArray with the extracted RDNs.
+		 * 
+		 * @param dn the distinguished name in canonical form.
+		 * @param rdn the list to fill in with RDNs extracted from the dn
+		 * @throws IllegalArgumentException if a formatting error is found.
+		 */
+		private static void parseDN(String dn, List<Object> rdn) {
+			int startIndex = 0;
+			char c = '\0';
+			List<String> nameValues = new ArrayList<String>();
+			while (startIndex < dn.length()) {
+				int endIndex;
+				for (endIndex = startIndex; endIndex < dn.length(); endIndex++) {
+					c = dn.charAt(endIndex);
+					if (c == ',' || c == '+') {
+						break;
+					}
+					if (c == '\\') {
+						endIndex++; // skip the escaped char
+					}
+				}
+				if (endIndex > dn.length()) {
+					throw new IllegalArgumentException("unterminated escape "
+							+ dn);
+				}
+				nameValues.add(dn.substring(startIndex, endIndex));
+				if (c != '+') {
+					rdn.add(nameValues);
+					if (endIndex != dn.length()) {
+						nameValues = new ArrayList<String>();
+					}
+					else {
+						nameValues = null;
+					}
+				}
+				startIndex = endIndex + 1;
+			}
+			if (nameValues != null) {
+				throw new IllegalArgumentException("improperly terminated DN "
+						+ dn);
+			}
+		}
+
+		/**
+		 * This method will return an 'index' which points to a non-wildcard DN
+		 * or the end-of-list.
+		 */
+		private static int skipWildCards(List<Object> dnChainPattern,
+				int dnChainPatternIndex) {
+			int i;
+			for (i = dnChainPatternIndex; i < dnChainPattern.size(); i++) {
+				Object dnPattern = dnChainPattern.get(i);
+				if (dnPattern instanceof String) {
+					if (!dnPattern.equals(STAR_WILDCARD)
+							&& !dnPattern.equals(MINUS_WILDCARD)) {
+						throw new IllegalArgumentException(
+								"expected wildcard in DN pattern");
+					}
+					// otherwise continue skipping over wild cards
+				}
+				else {
+					if (dnPattern instanceof List< ? >) {
+						// if its a list then we have our 'non-wildcard' DN
+						break;
+					}
+					else {
+						// unknown member of the DNChainPattern
+						throw new IllegalArgumentException(
+								"expected String or List in DN Pattern");
+					}
+				}
+			}
+			// i either points to end-of-list, or to the first
+			// non-wildcard pattern after dnChainPatternIndex
+			return i;
+		}
+
+		/**
+		 * recursively attempt to match the DNChain, and the DNChainPattern
+		 * where DNChain is of the format: "DN;DN;DN;" and DNChainPattern is of
+		 * the format: "DNPattern;*;DNPattern" (or combinations of this)
+		 */
+		private static boolean dnChainMatch(List<Object> dnChain,
+				int dnChainIndex, List<Object> dnChainPattern,
+				int dnChainPatternIndex)
+				throws IllegalArgumentException {
+			if (dnChainIndex >= dnChain.size()) {
+				return false;
+			}
+			if (dnChainPatternIndex >= dnChainPattern.size()) {
+				return false;
+			}
+			// check to see what the pattern starts with
+			Object dnPattern = dnChainPattern.get(dnChainPatternIndex);
+			if (dnPattern instanceof String) {
+				if (!dnPattern.equals(STAR_WILDCARD)
+						&& !dnPattern.equals(MINUS_WILDCARD)) {
+					throw new IllegalArgumentException(
+							"expected wildcard in DN pattern");
+				}
+				// here we are processing a wild card as the first DN
+				// skip all wildcard DN's
+				if (dnPattern.equals(MINUS_WILDCARD)) {
+					dnChainPatternIndex = skipWildCards(dnChainPattern,
+							dnChainPatternIndex);
+				}
+				else {
+					dnChainPatternIndex++; // only skip the '*' wildcard
+				}
+				if (dnChainPatternIndex >= dnChainPattern.size()) {
+					// return true iff the wild card is '-' or if we are at the
+					// end of the chain
+					return dnPattern.equals(MINUS_WILDCARD) ? true : dnChain
+							.size() - 1 == dnChainIndex;
+				}
+				//
+				// we will now recursively call to see if the rest of the
+				// DNChainPattern matches increasingly smaller portions of the
+				// rest of the DNChain
+				//
+				if (dnPattern.equals(STAR_WILDCARD)) {
+					// '*' option: only wildcard on 0 or 1
+					return dnChainMatch(dnChain, dnChainIndex, dnChainPattern,
+							dnChainPatternIndex)
+							|| dnChainMatch(dnChain, dnChainIndex + 1,
+									dnChainPattern, dnChainPatternIndex);
+				}
+				for (int i = dnChainIndex; i < dnChain.size(); i++) {
+					// '-' option: wildcard 0 or more
+					if (dnChainMatch(dnChain, i, dnChainPattern,
+							dnChainPatternIndex)) {
+						return true;
+					}
+				}
+				// if we are here, then we didn't find a match.. fall through to
+				// failure
+			}
+			else {
+				if (dnPattern instanceof List< ? >) {
+					// here we have to do a deeper check for each DN in the
+					// pattern until we hit a wild card
+					do {
+						if (!dnmatch((List< ? >) dnChain.get(dnChainIndex),
+								(List< ? >) dnPattern)) {
+							return false;
+						}
+						// go to the next set of DN's in both chains
+						dnChainIndex++;
+						dnChainPatternIndex++;
+						// if we finished the pattern then it all matched
+						if ((dnChainIndex >= dnChain.size())
+								&& (dnChainPatternIndex >= dnChainPattern
+										.size())) {
+							return true;
+						}
+						// if the DN Chain is finished, but the pattern isn't
+						// finished then if the rest of the pattern is not
+						// wildcard then we are done
+						if (dnChainIndex >= dnChain.size()) {
+							dnChainPatternIndex = skipWildCards(dnChainPattern,
+									dnChainPatternIndex);
+							// return TRUE iff the pattern index moved past the
+							// list-size (implying that the rest of the pattern
+							// is all wildcards)
+							return dnChainPatternIndex >= dnChainPattern.size();
+						}
+						// if the pattern finished, but the chain continues then
+						// we have a mis-match
+						if (dnChainPatternIndex >= dnChainPattern.size()) {
+							return false;
+						}
+						// get the next DN Pattern
+						dnPattern = dnChainPattern.get(dnChainPatternIndex);
+						if (dnPattern instanceof String) {
+							if (!dnPattern.equals(STAR_WILDCARD)
+									&& !dnPattern.equals(MINUS_WILDCARD)) {
+								throw new IllegalArgumentException(
+										"expected wildcard in DN pattern");
+							}
+							// if the next DN is a 'wildcard', then we will
+							// recurse
+							return dnChainMatch(dnChain, dnChainIndex,
+									dnChainPattern, dnChainPatternIndex);
+						}
+						else {
+							if (!(dnPattern instanceof List< ? >)) {
+								throw new IllegalArgumentException(
+										"expected String or List in DN Pattern");
+							}
+						}
+						// if we are here, then we will just continue to the
+						// match the next set of DN's from the DNChain, and the
+						// DNChainPattern since both are lists
+					} while (true);
+					// should never reach here?
+				}
+				else {
+					throw new IllegalArgumentException(
+							"expected String or List in DN Pattern");
+				}
+			}
+			// if we get here, the the default return is 'mis-match'
+			return false;
+		}
+
+		/**
+		 * Matches a distinguished name chain against a pattern of a
+		 * distinguished name chain.
+		 * 
+		 * @param dnChain
+		 * @param pattern the pattern of distinguished name (DN) chains to match
+		 *        against the dnChain. Wildcards ("*" or "-") can be used in
+		 *        three cases:
+		 *        <ol>
+		 *        <li>As a DN. In this case, the DN will consist of just the "*"
+		 *        or "-". When "*" is used it will match zero or one DNs. When
+		 *        "-" is used it will match zero or more DNs. For example,
+		 *        "cn=me,c=US;*;cn=you" will match
+		 *        "cn=me,c=US";cn=you" and "cn=me,c=US;cn=her;cn=you". The
+		 *        pattern "cn=me,c=US;-;cn=you" will match "cn=me,c=US";cn=you"
+		 *        and "cn=me,c=US;cn=her;cn=him;cn=you".
+		 *        <li>As a DN prefix. In this case, the DN must start with "*,".
+		 *        The wild card will match zero or more RDNs at the start of a
+		 *        DN. For example, "*,cn=me,c=US;cn=you" will match
+		 *        "cn=me,c=US";cn=you" and
+		 *        "ou=my org unit,o=my org,cn=me,c=US;cn=you"</li>
+		 *        <li>As a value. In this case the value of a name value pair in
+		 *        an RDN will be a "*". The wildcard will match any value for
+		 *        the given name. For example, "cn=*,c=US;cn=you" will match
+		 *        "cn=me,c=US";cn=you" and "cn=her,c=US;cn=you", but it will not
+		 *        match "ou=my org unit,c=US;cn=you". If the wildcard does not
+		 *        occur by itself in the value, it will not be used as a
+		 *        wildcard. In other words, "cn=m*,c=US;cn=you" represents the
+		 *        common name of "m*" not any common name starting with "m".</li>
+		 *        </ol>
+		 * @return true if dnChain matches the pattern.
+		 * @throws IllegalArgumentException
+		 */
+		static boolean match(String pattern, List<String> dnChain) {
+			List<Object> parsedDNChain;
+			List<Object> parsedDNPattern;
+			try {
+				parsedDNChain = parseDNchain(dnChain);
+			}
+			catch (RuntimeException e) {
+				IllegalArgumentException iae = new IllegalArgumentException(
+						"Invalid DN chain: " + toString(dnChain));
+				iae.initCause(e);
+				throw iae;
+			}
+			try {
+				parsedDNPattern = parseDNchainPattern(pattern);
+			}
+			catch (RuntimeException e) {
+				IllegalArgumentException iae = new IllegalArgumentException(
+						"Invalid match pattern: " + pattern);
+				iae.initCause(e);
+				throw iae;
+			}
+			return dnChainMatch(parsedDNChain, 0, parsedDNPattern, 0);
+		}
+
+		private static String toString(List< ? > dnChain) {
+			if (dnChain == null) {
+				return null;
+			}
+			StringBuffer sb = new StringBuffer();
+			for (Iterator< ? > iChain = dnChain.iterator(); iChain.hasNext();) {
+				sb.append(iChain.next());
+				if (iChain.hasNext()) {
+					sb.append("; ");
+				}
+			}
+			return sb.toString();
+		}
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/InvalidSyntaxException.java b/main/src/main/java/org/osgi/framework/InvalidSyntaxException.java
new file mode 100644
index 0000000000..46d6d20d7c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/InvalidSyntaxException.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A Framework exception used to indicate that a filter string has an invalid
+ * syntax.
+ * 
+ * <p>
+ * An {@code InvalidSyntaxException} object indicates that a filter
+ * string parameter has an invalid syntax and cannot be parsed. See
+ * {@link Filter} for a description of the filter string syntax.
+ * 
+ * <p>
+ * This exception conforms to the general purpose exception chaining mechanism.
+ * 
+ * @version $Id: adb84e3bc0b82b842e4da84542057fdf53e2ca6a $
+ */
+
+public class InvalidSyntaxException extends Exception {
+	static final long		serialVersionUID	= -4295194420816491875L;
+	/**
+	 * The invalid filter string.
+	 */
+	private final String	filter;
+
+	/**
+	 * Creates an exception of type {@code InvalidSyntaxException}.
+	 * 
+	 * <p>
+	 * This method creates an {@code InvalidSyntaxException} object with
+	 * the specified message and the filter string which generated the
+	 * exception.
+	 * 
+	 * @param msg The message.
+	 * @param filter The invalid filter string.
+	 */
+	public InvalidSyntaxException(String msg, String filter) {
+		super(msg);
+		this.filter = filter;
+	}
+
+	/**
+	 * Creates an exception of type {@code InvalidSyntaxException}.
+	 * 
+	 * <p>
+	 * This method creates an {@code InvalidSyntaxException} object with
+	 * the specified message and the filter string which generated the
+	 * exception.
+	 * 
+	 * @param msg The message.
+	 * @param filter The invalid filter string.
+	 * @param cause The cause of this exception.
+	 * @since 1.3
+	 */
+	public InvalidSyntaxException(String msg, String filter, Throwable cause) {
+		super(msg, cause);
+		this.filter = filter;
+	}
+
+	/**
+	 * Returns the filter string that generated the
+	 * {@code InvalidSyntaxException} object.
+	 * 
+	 * @return The invalid filter string.
+	 * @see BundleContext#getServiceReferences
+	 * @see BundleContext#addServiceListener(ServiceListener,String)
+	 */
+	public String getFilter() {
+		return filter;
+	}
+
+	/**
+	 * Returns the cause of this exception or {@code null} if no cause was
+	 * set.
+	 * 
+	 * @return The cause of this exception or {@code null} if no cause was
+	 *         set.
+	 * @since 1.3
+	 */
+	public Throwable getCause() {
+		return super.getCause();
+	}
+
+	/**
+	 * Initializes the cause of this exception to the specified value.
+	 * 
+	 * @param cause The cause of this exception.
+	 * @return This exception.
+	 * @throws IllegalArgumentException If the specified cause is this
+	 *         exception.
+	 * @throws IllegalStateException If the cause of this exception has already
+	 *         been set.
+	 * @since 1.3
+	 */
+	public Throwable initCause(Throwable cause) {
+		return super.initCause(cause);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/PackagePermission.java b/main/src/main/java/org/osgi/framework/PackagePermission.java
new file mode 100644
index 0000000000..b6697a591c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/PackagePermission.java
@@ -0,0 +1,812 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.AccessController;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.PrivilegedAction;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A bundle's authority to import or export a package.
+ * 
+ * <p>
+ * A package is a dot-separated string that defines a fully qualified Java
+ * package.
+ * <p>
+ * For example:
+ * 
+ * <pre>
+ * org.osgi.service.http
+ * </pre>
+ * 
+ * <p>
+ * {@code PackagePermission} has three actions: {@code exportonly},
+ * {@code import} and {@code export}. The {@code export} action,
+ * which is deprecated, implies the {@code import} action.
+ * 
+ * @ThreadSafe
+ * @version $Id: a286af94405e583f8bedc2ff5d7c818198f8caaf $
+ */
+
+public final class PackagePermission extends BasicPermission {
+	static final long						serialVersionUID	= -5107705877071099135L;
+
+	/**
+	 * The action string {@code export}. The {@code export} action
+	 * implies the {@code import} action.
+	 * 
+	 * @deprecated Since 1.5. Use {@code exportonly} instead.
+	 */
+	public final static String				EXPORT				= "export";
+
+	/**
+	 * The action string {@code exportonly}. The {@code exportonly}
+	 * action does not imply the {@code import} action.
+	 * 
+	 * @since 1.5
+	 */
+	public final static String				EXPORTONLY			= "exportonly";
+
+	/**
+	 * The action string {@code import}.
+	 */
+	public final static String				IMPORT				= "import";
+
+	private final static int				ACTION_EXPORT		= 0x00000001;
+	private final static int				ACTION_IMPORT		= 0x00000002;
+	private final static int				ACTION_ALL			= ACTION_EXPORT
+																		| ACTION_IMPORT;
+	final static int						ACTION_NONE			= 0;
+
+	/**
+	 * The actions mask.
+	 */
+	transient int							action_mask;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String					actions				= null;
+
+	/**
+	 * The bundle used by this PackagePermission.
+	 */
+	transient final Bundle					bundle;
+
+	/**
+	 * If this PackagePermission was constructed with a filter, this holds a
+	 * Filter matching object used to evaluate the filter in implies.
+	 */
+	transient Filter						filter;
+
+	/**
+	 * This map holds the properties of the permission, used to match a filter
+	 * in implies. This is not initialized until necessary, and then cached in
+	 * this object.
+	 */
+	private transient volatile Map<String, Object>	properties;
+
+	/**
+	 * Creates a new {@code PackagePermission} object.
+	 * 
+	 * <p>
+	 * The name is specified as a normal Java package name: a dot-separated
+	 * string. Wildcards may be used.
+	 * 
+	 * <pre>
+	 * name ::= &lt;package name&gt; | &lt;package name ending in &quot;.*&quot;&gt; | *
+	 * </pre>
+	 * 
+	 * Examples:
+	 * 
+	 * <pre>
+	 * org.osgi.service.http
+	 * javax.servlet.*
+	 * *
+	 * </pre>
+	 * 
+	 * For the {@code import} action, the name can also be a filter
+	 * expression. The filter gives access to the following attributes:
+	 * <ul>
+	 * <li>signer - A Distinguished Name chain used to sign the exporting
+	 * bundle. Wildcards in a DN are not matched according to the filter string
+	 * rules, but according to the rules defined for a DN chain.</li>
+	 * <li>location - The location of the exporting bundle.</li>
+	 * <li>id - The bundle ID of the exporting bundle.</li>
+	 * <li>name - The symbolic name of the exporting bundle.</li>
+	 * <li>package.name - The name of the requested package.</li>
+	 * </ul>
+	 * Filter attribute names are processed in a case sensitive manner.
+	 * 
+	 * <p>
+	 * Package Permissions are granted over all possible versions of a package.
+	 * 
+	 * A bundle that needs to export a package must have the appropriate
+	 * {@code PackagePermission} for that package; similarly, a bundle that
+	 * needs to import a package must have the appropriate
+	 * {@code PackagePermssion} for that package.
+	 * <p>
+	 * Permission is granted for both classes and resources.
+	 * 
+	 * @param name Package name or filter expression. A filter expression can
+	 *        only be specified if the specified action is {@code import}.
+	 * @param actions {@code exportonly},{@code import} (canonical
+	 *        order).
+	 * @throws IllegalArgumentException If the specified name is a filter
+	 *         expression and either the specified action is not
+	 *         {@code import} or the filter has an invalid syntax.
+	 */
+	public PackagePermission(String name, String actions) {
+		this(name, parseActions(actions));
+		if ((filter != null)
+				&& ((action_mask & ACTION_ALL) != ACTION_IMPORT)) {
+			throw new IllegalArgumentException(
+					"invalid action string for filter expression");
+		}
+	}
+
+	/**
+	 * Creates a new requested {@code PackagePermission} object to be used
+	 * by code that must perform {@code checkPermission} for the
+	 * {@code import} action. {@code PackagePermission} objects
+	 * created with this constructor cannot be added to a
+	 * {@code PackagePermission} permission collection.
+	 * 
+	 * @param name The name of the requested package to import.
+	 * @param exportingBundle The bundle exporting the requested package.
+	 * @param actions The action {@code import}.
+	 * @throws IllegalArgumentException If the specified action is not
+	 *         {@code import} or the name is a filter expression.
+	 * @since 1.5
+	 */
+	public PackagePermission(String name, Bundle exportingBundle, String actions) {
+		super(name);
+		setTransients(name, parseActions(actions));
+		this.bundle = exportingBundle;
+		if (exportingBundle == null) {
+			throw new IllegalArgumentException("bundle must not be null");
+		}
+		if (filter != null) {
+			throw new IllegalArgumentException("invalid name");
+		}
+		if ((action_mask & ACTION_ALL) != ACTION_IMPORT) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+	}
+
+	/**
+	 * Package private constructor used by PackagePermissionCollection.
+	 * 
+	 * @param name package name
+	 * @param mask action mask
+	 */
+	PackagePermission(String name, int mask) {
+		super(name);
+		setTransients(name, mask);
+		this.bundle = null;
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param mask action mask
+	 */
+	private void setTransients(String name, int mask) {
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+		action_mask = mask;
+		filter = parseFilter(name);
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		boolean seencomma = false;
+
+		int mask = ACTION_NONE;
+
+		if (actions == null) {
+			return mask;
+		}
+
+		char[] a = actions.toCharArray();
+
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+
+		while (i != -1) {
+			char c;
+
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+
+			// check for the known strings
+			int matchlen;
+
+			if (i >= 5 && (a[i - 5] == 'i' || a[i - 5] == 'I')
+					&& (a[i - 4] == 'm' || a[i - 4] == 'M')
+					&& (a[i - 3] == 'p' || a[i - 3] == 'P')
+					&& (a[i - 2] == 'o' || a[i - 2] == 'O')
+					&& (a[i - 1] == 'r' || a[i - 1] == 'R')
+					&& (a[i] == 't' || a[i] == 'T')) {
+				matchlen = 6;
+				mask |= ACTION_IMPORT;
+
+			}
+			else
+				if (i >= 5 && (a[i - 5] == 'e' || a[i - 5] == 'E')
+						&& (a[i - 4] == 'x' || a[i - 4] == 'X')
+						&& (a[i - 3] == 'p' || a[i - 3] == 'P')
+						&& (a[i - 2] == 'o' || a[i - 2] == 'O')
+						&& (a[i - 1] == 'r' || a[i - 1] == 'R')
+						&& (a[i] == 't' || a[i] == 'T')) {
+					matchlen = 6;
+					mask |= ACTION_EXPORT | ACTION_IMPORT;
+
+				}
+				else {
+					if (i >= 9 && (a[i - 9] == 'e' || a[i - 9] == 'E')
+							&& (a[i - 8] == 'x' || a[i - 8] == 'X')
+							&& (a[i - 7] == 'p' || a[i - 7] == 'P')
+							&& (a[i - 6] == 'o' || a[i - 6] == 'O')
+							&& (a[i - 5] == 'r' || a[i - 5] == 'R')
+							&& (a[i - 4] == 't' || a[i - 4] == 'T')
+							&& (a[i - 3] == 'o' || a[i - 3] == 'O')
+							&& (a[i - 2] == 'n' || a[i - 2] == 'N')
+							&& (a[i - 1] == 'l' || a[i - 1] == 'L')
+							&& (a[i] == 'y' || a[i] == 'Y')) {
+						matchlen = 10;
+						mask |= ACTION_EXPORT;
+
+					}
+					else {
+						// parse error
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+					}
+				}
+
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfimport". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+						/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+				}
+				i--;
+			}
+
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid permission: " + actions);
+		}
+
+		return mask;
+	}
+
+	/**
+	 * Parse filter string into a Filter object.
+	 * 
+	 * @param filterString The filter string to parse.
+	 * @return a Filter for this bundle. If the specified filterString is not a
+	 *         filter expression, then {@code null} is returned.
+	 * @throws IllegalArgumentException If the filter syntax is invalid.
+	 */
+	private static Filter parseFilter(String filterString) {
+		filterString = filterString.trim();
+		if (filterString.charAt(0) != '(') {
+			return null;
+		}
+
+		try {
+			return FrameworkUtil.createFilter(filterString);
+		}
+		catch (InvalidSyntaxException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid filter");
+			iae.initCause(e);
+			throw iae;
+		}
+	}
+
+	/**
+	 * Determines if the specified permission is implied by this object.
+	 * 
+	 * <p>
+	 * This method checks that the package name of the target is implied by the
+	 * package name of this object. The list of {@code PackagePermission}
+	 * actions must either match or allow for the list of the target object to
+	 * imply the target {@code PackagePermission} action.
+	 * <p>
+	 * The permission to export a package implies the permission to import the
+	 * named package.
+	 * 
+	 * <pre>
+	 * x.y.*,&quot;export&quot; -&gt; x.y.z,&quot;export&quot; is true
+	 * *,&quot;import&quot; -&gt; x.y, &quot;import&quot;      is true
+	 * *,&quot;export&quot; -&gt; x.y, &quot;import&quot;      is true
+	 * x.y,&quot;export&quot; -&gt; x.y.z, &quot;export&quot;  is false
+	 * </pre>
+	 * 
+	 * @param p The requested permission.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof PackagePermission)) {
+			return false;
+		}
+		PackagePermission requested = (PackagePermission) p;
+		if (bundle != null) {
+			return false;
+		}
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		return implies0(requested, ACTION_NONE);
+	}
+
+	/**
+	 * Internal implies method. Used by the implies and the permission
+	 * collection implies methods.
+	 * 
+	 * @param requested The requested PackagePermission which has already be
+	 *        validated as a proper argument. The requested PackagePermission
+	 *        must not have a filter expression.
+	 * @param effective The effective actions with which to start.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	boolean implies0(PackagePermission requested, int effective) {
+		/* check actions first - much faster */
+		effective |= action_mask;
+		final int desired = requested.action_mask;
+		if ((effective & desired) != desired) {
+			return false;
+		}
+		/* Get filter if any */
+		Filter f = filter;
+		if (f == null) {
+			return super.implies(requested);
+		}
+		return f.matches(requested.getProperties());
+	}
+
+	/**
+	 * Returns the canonical string representation of the
+	 * {@code PackagePermission} actions.
+	 * 
+	 * <p>
+	 * Always returns present {@code PackagePermission} actions in the
+	 * following order: {@code EXPORTONLY},{@code IMPORT}.
+	 * 
+	 * @return Canonical string representation of the
+	 *         {@code PackagePermission} actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			StringBuffer sb = new StringBuffer();
+			boolean comma = false;
+
+			int mask = action_mask;
+			if ((mask & ACTION_EXPORT) == ACTION_EXPORT) {
+				sb.append(EXPORTONLY);
+				comma = true;
+			}
+
+			if ((mask & ACTION_IMPORT) == ACTION_IMPORT) {
+				if (comma)
+					sb.append(',');
+				sb.append(IMPORT);
+			}
+
+			actions = result = sb.toString();
+		}
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object suitable for
+	 * storing {@code PackagePermission} objects.
+	 * 
+	 * @return A new {@code PermissionCollection} object.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new PackagePermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two {@code PackagePermission} objects.
+	 * 
+	 * This method checks that specified package has the same package name and
+	 * {@code PackagePermission} actions as this
+	 * {@code PackagePermission} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code PackagePermission} object.
+	 * @return {@code true} if {@code obj} is a
+	 *         {@code PackagePermission}, and has the same package name and
+	 *         actions as this {@code PackagePermission} object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof PackagePermission)) {
+			return false;
+		}
+
+		PackagePermission pp = (PackagePermission) obj;
+
+		return (action_mask == pp.action_mask)
+				&& getName().equals(pp.getName())
+				&& ((bundle == pp.bundle) || ((bundle != null) && bundle
+						.equals(pp.bundle)));
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		if (bundle != null) {
+			h = 31 * h + bundle.hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of this permission object to a
+	 * stream. The actions are serialized, and the superclass takes care of the
+	 * name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		if (bundle != null) {
+			throw new NotSerializableException("cannot serialize");
+		}
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of this permission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the action, then initialize the rest
+		s.defaultReadObject();
+		setTransients(getName(), parseActions(actions));
+	}
+
+	/**
+	 * Called by {@code <@link PackagePermission#implies(Permission)>}. This
+	 * method is only called on a requested permission which cannot have a
+	 * filter set.
+	 * 
+	 * @return a map of properties for this permission.
+	 */
+	private Map<String, Object> getProperties() {
+		Map<String, Object> result = properties;
+		if (result != null) {
+			return result;
+		}
+		final Map<String, Object> map = new HashMap<String, Object>(5);
+		map.put("package.name", getName());
+		if (bundle != null) {
+			AccessController.doPrivileged(new PrivilegedAction<Object>() {
+				public Object run() {
+					map.put("id", new Long(bundle.getBundleId()));
+					map.put("location", bundle.getLocation());
+					String name = bundle.getSymbolicName();
+					if (name != null) {
+						map.put("name", name);
+					}
+					SignerProperty signer = new SignerProperty(bundle);
+					if (signer.isBundleSigned()) {
+						map.put("signer", signer);
+					}
+					return null;
+				}
+			});
+		}
+		return properties = map;
+	}
+}
+
+/**
+ * Stores a set of {@code PackagePermission} permissions.
+ * 
+ * @see java.security.Permission
+ * @see java.security.Permissions
+ * @see java.security.PermissionCollection
+ */
+
+final class PackagePermissionCollection extends PermissionCollection {
+	static final long		serialVersionUID	= -3350758995234427603L;
+	/**
+	 * Table of permissions with names.
+	 * 
+	 * @GuardedBy this
+	 */
+	private transient Map<String, PackagePermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean			all_allowed;
+
+	/**
+	 * Table of permissions with filter expressions.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private Map<String, PackagePermission>				filterPermissions;
+
+	/**
+	 * Create an empty PackagePermissions object.
+	 */
+	public PackagePermissionCollection() {
+		permissions = new HashMap<String, PackagePermission>();
+		all_allowed = false;
+	}
+
+	/**
+	 * Adds a permission to this permission collection.
+	 * 
+	 * @param permission The {@code PackagePermission} object to add.
+	 * @throws IllegalArgumentException If the specified permission is not a
+	 *         {@code PackagePermission} instance or was constructed with a
+	 *         Bundle object.
+	 * @throws SecurityException If this
+	 *         {@code PackagePermissionCollection} object has been marked
+	 *         read-only.
+	 */
+	public void add(final Permission permission) {
+		if (!(permission instanceof PackagePermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection");
+		}
+
+		final PackagePermission pp = (PackagePermission) permission;
+		if (pp.bundle != null) {
+			throw new IllegalArgumentException("cannot add to collection: "
+					+ pp);
+		}
+
+		final String name = pp.getName();
+		final Filter f = pp.filter;
+		synchronized (this) {
+			/* select the bucket for the permission */
+			Map<String, PackagePermission> pc;
+			if (f != null) {
+				pc = filterPermissions;
+				if (pc == null) {
+					filterPermissions = pc = new HashMap<String, PackagePermission>();
+				}
+			}
+			else {
+				pc = permissions;
+			}
+			
+			final PackagePermission existing = pc.get(name);
+			if (existing != null) {
+				final int oldMask = existing.action_mask;
+				final int newMask = pp.action_mask;
+				if (oldMask != newMask) {
+					pc
+							.put(name, new PackagePermission(name, oldMask
+									| newMask));
+
+				}
+			}
+			else {
+				pc.put(name, pp);
+			}
+
+			if (!all_allowed) {
+				if (name.equals("*")) {
+					all_allowed = true;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Determines if the specified permissions implies the permissions expressed
+	 * in {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare with this
+	 *        {@code PackagePermission} object.
+	 * @return {@code true} if {@code permission} is a proper subset
+	 *         of a permission in the set; {@code false} otherwise.
+	 */
+	public boolean implies(final Permission permission) {
+		if (!(permission instanceof PackagePermission)) {
+			return false;
+		}
+		final PackagePermission requested = (PackagePermission) permission;
+		/* if requested permission has a filter, then it is an invalid argument */
+		if (requested.filter != null) {
+			return false;
+		}
+		String requestedName = requested.getName();
+		final int desired = requested.action_mask;
+		int effective = PackagePermission.ACTION_NONE;
+
+		Collection<PackagePermission> perms;
+		synchronized (this) {
+			Map<String, PackagePermission> pc = permissions;
+			PackagePermission pp;
+			/* short circuit if the "*" Permission was added */
+			if (all_allowed) {
+				pp = pc.get("*");
+				if (pp != null) {
+					effective |= pp.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			/*
+			 * strategy: Check for full match first. Then work our way up the
+			 * name looking for matches on a.b.*
+			 */
+			pp = pc.get(requestedName);
+			if (pp != null) {
+				/* we have a direct hit! */
+				effective |= pp.action_mask;
+				if ((effective & desired) == desired) {
+					return true;
+				}
+			}
+			/* work our way up the tree... */
+			int last;
+			int offset = requestedName.length() - 1;
+			while ((last = requestedName.lastIndexOf(".", offset)) != -1) {
+				requestedName = requestedName.substring(0, last + 1) + "*";
+				pp = pc.get(requestedName);
+				if (pp != null) {
+					effective |= pp.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+				offset = last - 1;
+			}
+			/*
+			 * we don't have to check for "*" as it was already checked before
+			 * we were called.
+			 */
+			pc = filterPermissions;
+			if (pc == null) {
+				return false;
+			}
+			perms = pc.values();
+		}
+		/* iterate one by one over filteredPermissions */
+		for (PackagePermission perm : perms) {
+			if (perm.implies0(requested, effective)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns an enumeration of all {@code PackagePermission} objects in
+	 * the container.
+	 * 
+	 * @return Enumeration of all {@code PackagePermission} objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		Map<String, PackagePermission> pc = filterPermissions;
+		if (pc != null) {
+			all.addAll(pc.values());
+		}
+		return Collections.enumeration(all);
+	}
+
+	/* serialization logic */
+	private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", Hashtable.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE),
+			new ObjectStreamField("filterPermissions", HashMap.class)	};
+
+	private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		Hashtable<String, PackagePermission> hashtable = new Hashtable<String, PackagePermission>(
+				permissions);
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", hashtable);
+		pfields.put("all_allowed", all_allowed);
+		pfields.put("filterPermissions", filterPermissions);
+		out.writeFields();
+	}
+
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException, ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		Hashtable<String, PackagePermission> hashtable = (Hashtable<String, PackagePermission>) gfields
+				.get("permissions", null);
+		permissions = new HashMap<String, PackagePermission>(hashtable);
+		all_allowed = gfields.get("all_allowed", false);
+		HashMap<String, PackagePermission> fp = (HashMap<String, PackagePermission>) gfields
+				.get("filterPermissions", null);
+		filterPermissions = fp;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceEvent.java b/main/src/main/java/org/osgi/framework/ServiceEvent.java
new file mode 100644
index 0000000000..82ec899e77
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceEvent.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.Dictionary;
+import java.util.EventObject;
+
+/**
+ * An event from the Framework describing a service lifecycle change.
+ * <p>
+ * {@code ServiceEvent} objects are delivered to
+ * {@code ServiceListener}s and {@code AllServiceListener}s when a
+ * change occurs in this service's lifecycle. A type code is used to identify
+ * the event type for future extendability.
+ * 
+ * <p>
+ * OSGi Alliance reserves the right to extend the set of types.
+ * 
+ * @Immutable
+ * @see ServiceListener
+ * @see AllServiceListener
+ * @version $Id: 2b9458d90004411b6ca0cb4b361bc282b04c85eb $
+ */
+
+public class ServiceEvent extends EventObject {
+	static final long				serialVersionUID	= 8792901483909409299L;
+	/**
+	 * Reference to the service that had a change occur in its lifecycle.
+	 */
+	private final ServiceReference< ? >	reference;
+
+	/**
+	 * Type of service lifecycle change.
+	 */
+	private final int				type;
+
+	/**
+	 * This service has been registered.
+	 * <p>
+	 * This event is synchronously delivered <strong>after</strong> the service
+	 * has been registered with the Framework.
+	 * 
+	 * @see BundleContext#registerService(String[],Object,Dictionary)
+	 */
+	public final static int			REGISTERED			= 0x00000001;
+
+	/**
+	 * The properties of a registered service have been modified.
+	 * <p>
+	 * This event is synchronously delivered <strong>after</strong> the service
+	 * properties have been modified.
+	 * 
+	 * @see ServiceRegistration#setProperties
+	 */
+	public final static int			MODIFIED			= 0x00000002;
+
+	/**
+	 * This service is in the process of being unregistered.
+	 * <p>
+	 * This event is synchronously delivered <strong>before</strong> the service
+	 * has completed unregistering.
+	 * 
+	 * <p>
+	 * If a bundle is using a service that is {@code UNREGISTERING}, the
+	 * bundle should release its use of the service when it receives this event.
+	 * If the bundle does not release its use of the service when it receives
+	 * this event, the Framework will automatically release the bundle's use of
+	 * the service while completing the service unregistration operation.
+	 * 
+	 * @see ServiceRegistration#unregister
+	 * @see BundleContext#ungetService
+	 */
+	public final static int			UNREGISTERING		= 0x00000004;
+
+	/**
+	 * The properties of a registered service have been modified and the new
+	 * properties no longer match the listener's filter.
+	 * <p>
+	 * This event is synchronously delivered <strong>after</strong> the service
+	 * properties have been modified. This event is only delivered to listeners
+	 * which were added with a non-{@code null} filter where the filter
+	 * matched the service properties prior to the modification but the filter
+	 * does not match the modified service properties.
+	 * 
+	 * @see ServiceRegistration#setProperties
+	 * @since 1.5
+	 */
+	public final static int			MODIFIED_ENDMATCH	= 0x00000008;
+
+	/**
+	 * Creates a new service event object.
+	 * 
+	 * @param type The event type.
+	 * @param reference A {@code ServiceReference} object to the service
+	 * 	that had a lifecycle change.
+	 */
+	public ServiceEvent(int type, ServiceReference< ? > reference) {
+		super(reference);
+		this.reference = reference;
+		this.type = type;
+	}
+
+	/**
+	 * Returns a reference to the service that had a change occur in its
+	 * lifecycle.
+	 * <p>
+	 * This reference is the source of the event.
+	 * 
+	 * @return Reference to the service that had a lifecycle change.
+	 */
+	public ServiceReference< ? > getServiceReference() {
+		return reference;
+	}
+
+	/**
+	 * Returns the type of event. The event type values are:
+	 * <ul>
+	 * <li>{@link #REGISTERED} </li> 
+	 * <li>{@link #MODIFIED} </li> 
+	 * <li>{@link #MODIFIED_ENDMATCH} </li> 
+	 * <li>{@link #UNREGISTERING} </li>
+	 * </ul>
+	 * 
+	 * @return Type of service lifecycle change.
+	 */
+
+	public int getType() {
+		return type;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceException.java b/main/src/main/java/org/osgi/framework/ServiceException.java
new file mode 100644
index 0000000000..d8ed3bdd6c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceException.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) OSGi Alliance (2007, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A service exception used to indicate that a service problem occurred.
+ * 
+ * <p>
+ * A {@code ServiceException} object is created by the Framework or
+ * service implementation to denote an exception condition in the service. A
+ * type code is used to identify the exception type for future extendability.
+ * Service implementations may also create subclasses of
+ * {@code ServiceException}. When subclassing, the subclass should set
+ * the type to {@link #SUBCLASSED} to indicate that
+ * {@code ServiceException} has been subclassed.
+ * 
+ * <p>
+ * This exception conforms to the general purpose exception chaining mechanism.
+ * 
+ * @version $Id: 453b6021eed4543f754e20696b9f8b33a7e121ee $
+ * @since 1.5
+ */
+
+public class ServiceException extends RuntimeException {
+	static final long		serialVersionUID	= 3038963223712959631L;
+
+	/**
+	 * Type of service exception.
+	 */
+	private final int		type;
+
+	/**
+	 * No exception type is unspecified.
+	 */
+	public static final int	UNSPECIFIED			= 0;
+	/**
+	 * The service has been unregistered.
+	 */
+	public static final int	UNREGISTERED		= 1;
+	/**
+	 * The service factory produced an invalid service object.
+	 */
+	public static final int	FACTORY_ERROR		= 2;
+	/**
+	 * The service factory threw an exception.
+	 */
+	public static final int	FACTORY_EXCEPTION	= 3;
+	/**
+	 * The exception is a subclass of ServiceException. The subclass should be
+	 * examined for the type of the exception.
+	 */
+	public static final int	SUBCLASSED			= 4;
+	/**
+	 * An error occurred invoking a remote service.
+	 */
+	public static final int REMOTE 				= 5;
+	/**
+	 * The service factory resulted in a recursive call to itself for the
+	 * requesting bundle.
+	 * 
+	 * @since 1.6
+	 */
+	public static final int	FACTORY_RECURSION	= 6;
+
+	/**
+	 * Creates a {@code ServiceException} with the specified message and
+	 * exception cause.
+	 * 
+	 * @param msg The associated message.
+	 * @param cause The cause of this exception.
+	 */
+	public ServiceException(String msg, Throwable cause) {
+		this(msg, UNSPECIFIED, cause);
+	}
+
+	/**
+	 * Creates a {@code ServiceException} with the specified message.
+	 * 
+	 * @param msg The message.
+	 */
+	public ServiceException(String msg) {
+		this(msg, UNSPECIFIED);
+	}
+
+	/**
+	 * Creates a {@code ServiceException} with the specified message,
+	 * type and exception cause.
+	 * 
+	 * @param msg The associated message.
+	 * @param type The type for this exception.
+	 * @param cause The cause of this exception.
+	 */
+	public ServiceException(String msg, int type, Throwable cause) {
+		super(msg, cause);
+		this.type = type;
+	}
+
+	/**
+	 * Creates a {@code ServiceException} with the specified message and
+	 * type.
+	 * 
+	 * @param msg The message.
+	 * @param type The type for this exception.
+	 */
+	public ServiceException(String msg, int type) {
+		super(msg);
+		this.type = type;
+	}
+
+	/**
+	 * Returns the type for this exception or {@code UNSPECIFIED} if the
+	 * type was unspecified or unknown.
+	 * 
+	 * @return The type of this exception.
+	 */
+	public int getType() {
+		return type;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceFactory.java b/main/src/main/java/org/osgi/framework/ServiceFactory.java
new file mode 100644
index 0000000000..6383b22bb2
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceFactory.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * Allows services to provide customized service objects in the OSGi
+ * environment.
+ * 
+ * <p>
+ * When registering a service, a {@code ServiceFactory} object can be used
+ * instead of a service object, so that the bundle developer can gain control of
+ * the specific service object granted to a bundle that is using the service.
+ * 
+ * <p>
+ * When this happens, the {@code BundleContext.getService(ServiceReference)}
+ * method calls the {@code ServiceFactory.getService} method to create a service
+ * object specifically for the requesting bundle. The service object returned by
+ * the {@code ServiceFactory} is cached by the Framework until the bundle
+ * releases its use of the service.
+ * 
+ * <p>
+ * When the bundle's use count for the service is decremented to zero (including
+ * the bundle stopping or the service being unregistered), the
+ * {@code ServiceFactory.ungetService} method is called.
+ * 
+ * <p>
+ * {@code ServiceFactory} objects are only used by the Framework and are not
+ * made available to other bundles in the OSGi environment. The Framework may
+ * concurrently call a {@code ServiceFactory}.
+ * 
+ * @param <S> Type of Service
+ * @see BundleContext#getService
+ * @ThreadSafe
+ * @version $Id: 94cd1a0127aaad9beb484f557342a8fbd0be2322 $
+ */
+
+public interface ServiceFactory<S> {
+	/**
+	 * Creates a new service object.
+	 * 
+	 * <p>
+	 * The Framework invokes this method the first time the specified
+	 * {@code bundle} requests a service object using the
+	 * {@code BundleContext.getService(ServiceReference)} method. The service
+	 * factory can then return a specific service object for each bundle.
+	 * 
+	 * <p>
+	 * The Framework must check that the returned service object is valid. If
+	 * the returned service object is {@code null} or is not an
+	 * {@code instanceof} all the classes named when the service was registered,
+	 * a framework event of type {@link FrameworkEvent#ERROR} is fired
+	 * containing a service exception of type
+	 * {@link ServiceException#FACTORY_ERROR} and {@code null} is returned to
+	 * the bundle. If this method throws an exception, a framework event of type
+	 * {@link FrameworkEvent#ERROR} is fired containing a service exception of
+	 * type {@link ServiceException#FACTORY_EXCEPTION} with the thrown exception
+	 * as the cause and {@code null} is returned to the bundle. If this method
+	 * is recursively called for the specified bundle, a framework event of type
+	 * {@link FrameworkEvent#ERROR} is fired containing a service exception of
+	 * type {@link ServiceException#FACTORY_RECURSION} and {@code null} is
+	 * returned to the bundle.
+	 * 
+	 * <p>
+	 * The Framework caches the valid service object and will return the same
+	 * service object on any future call to {@code BundleContext.getService} for
+	 * the specified bundle. This means the Framework must not allow this method
+	 * to be concurrently called for the specified bundle.
+	 * 
+	 * @param bundle The bundle requesting the service.
+	 * @param registration The {@code ServiceRegistration} object for the
+	 *        requested service.
+	 * @return A service object that <strong>must</strong> be an instance of all
+	 *         the classes named when the service was registered.
+	 * @see BundleContext#getService
+	 */
+	public S getService(Bundle bundle, ServiceRegistration<S> registration);
+
+	/**
+	 * Releases a service object.
+	 * 
+	 * <p>
+	 * The Framework invokes this method when a service has been released by a
+	 * bundle. The service object may then be destroyed.
+	 * 
+	 * <p>
+	 * If this method throws an exception, a framework event of type
+	 * {@link FrameworkEvent#ERROR} is fired containing a service exception of
+	 * type {@link ServiceException#FACTORY_EXCEPTION} with the thrown exception
+	 * as the cause.
+	 * 
+	 * @param bundle The bundle releasing the service.
+	 * @param registration The {@code ServiceRegistration} object for the
+	 *        service being released.
+	 * @param service The service object returned by a previous call to the
+	 *        {@link #getService(Bundle, ServiceRegistration) getService}
+	 *        method.
+	 * @see BundleContext#ungetService
+	 */
+	public void ungetService(Bundle bundle, ServiceRegistration<S> registration,
+			S service);
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceListener.java b/main/src/main/java/org/osgi/framework/ServiceListener.java
new file mode 100644
index 0000000000..dc6a159c20
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceListener.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.EventListener;
+
+/**
+ * A {@code ServiceEvent} listener. {@code ServiceListener} is a
+ * listener interface that may be implemented by a bundle developer. When a
+ * {@code ServiceEvent} is fired, it is synchronously delivered to a
+ * {@code ServiceListener}. The Framework may deliver
+ * {@code ServiceEvent} objects to a {@code ServiceListener} out
+ * of order and may concurrently call and/or reenter a
+ * {@code ServiceListener}.
+ * 
+ * <p>
+ * A {@code ServiceListener} object is registered with the Framework
+ * using the {@code BundleContext.addServiceListener} method.
+ * {@code ServiceListener} objects are called with a
+ * {@code ServiceEvent} object when a service is registered, modified, or
+ * is in the process of unregistering.
+ * 
+ * <p>
+ * {@code ServiceEvent} object delivery to {@code ServiceListener}
+ * objects is filtered by the filter specified when the listener was registered.
+ * If the Java Runtime Environment supports permissions, then additional
+ * filtering is done. {@code ServiceEvent} objects are only delivered to
+ * the listener if the bundle which defines the listener object's class has the
+ * appropriate {@code ServicePermission} to get the service using at
+ * least one of the named classes under which the service was registered.
+ * 
+ * <p>
+ * {@code ServiceEvent} object delivery to {@code ServiceListener}
+ * objects is further filtered according to package sources as defined in
+ * {@link ServiceReference#isAssignableTo(Bundle, String)}.
+ * 
+ * @see ServiceEvent
+ * @see ServicePermission
+ * @ThreadSafe
+ * @version $Id: d73f8e9b4babc8b53b5d1cbe7b17b732f54bb2a3 $
+ */
+
+public interface ServiceListener extends EventListener {
+	/**
+	 * Receives notification that a service has had a lifecycle change.
+	 * 
+	 * @param event The {@code ServiceEvent} object.
+	 */
+	public void serviceChanged(ServiceEvent event);
+}
diff --git a/main/src/main/java/org/osgi/framework/ServicePermission.java b/main/src/main/java/org/osgi/framework/ServicePermission.java
new file mode 100644
index 0000000000..b7a9956f5a
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServicePermission.java
@@ -0,0 +1,946 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.security.AccessController;
+import java.security.BasicPermission;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.PrivilegedAction;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A bundle's authority to register or get a service.
+ * <ul>
+ * <li>The {@code register} action allows a bundle to register a service on
+ * the specified names.
+ * <li>The {@code get} action allows a bundle to detect a service and get
+ * it.
+ * </ul>
+ * Permission to get a service is required in order to detect events regarding
+ * the service. Untrusted bundles should not be able to detect the presence of
+ * certain services unless they have the appropriate
+ * {@code ServicePermission} to get the specific service.
+ * 
+ * @ThreadSafe
+ * @version $Id: 1b6ee9543f4cbc16add8dc8c40dfa9a6dfee7aa2 $
+ */
+
+public final class ServicePermission extends BasicPermission {
+	static final long			serialVersionUID	= -7662148639076511574L;
+	/**
+	 * The action string {@code get}.
+	 */
+	public final static String	GET					= "get";
+	/**
+	 * The action string {@code register}.
+	 */
+	public final static String	REGISTER			= "register";
+
+	private final static int	ACTION_GET			= 0x00000001;
+	private final static int	ACTION_REGISTER		= 0x00000002;
+	private final static int	ACTION_ALL			= ACTION_GET
+															| ACTION_REGISTER;
+	final static int						ACTION_NONE			= 0;
+
+	/**
+	 * The actions mask.
+	 */
+	transient int							action_mask;
+
+	/**
+	 * The actions in canonical form.
+	 * 
+	 * @serial
+	 */
+	private volatile String		actions				= null;
+
+	/**
+	 * The service used by this ServicePermission. Must be null if not
+	 * constructed with a service.
+	 */
+	transient final ServiceReference< ? >					service;
+
+	/**
+	 * The object classes for this ServicePermission. Must be null if not
+	 * constructed with a service.
+	 */
+	transient final String[]				objectClass;
+
+	/**
+	 * If this ServicePermission was constructed with a filter, this holds a
+	 * Filter matching object used to evaluate the filter in implies.
+	 */
+	transient Filter						filter;
+
+	/**
+	 * This map holds the properties of the permission, used to match a filter
+	 * in implies. This is not initialized until necessary, and then cached in
+	 * this object.
+	 */
+	private transient volatile Map<String, Object>	properties;
+
+	/**
+	 * True if constructed with a name and the name is "*" or ends with ".*".
+	 */
+	private transient boolean				wildcard;
+
+	/**
+	 * If constructed with a name and the name ends with ".*", this contains the
+	 * name without the final "*".
+	 */
+	private transient String				prefix;
+
+	/**
+	 * Create a new ServicePermission.
+	 * 
+	 * <p>
+	 * The name of the service is specified as a fully qualified class name.
+	 * Wildcards may be used.
+	 * 
+	 * <pre>
+	 * name ::= &lt;class name&gt; | &lt;class name ending in &quot;.*&quot;&gt; | *
+	 * </pre>
+	 * 
+	 * Examples:
+	 * 
+	 * <pre>
+	 * org.osgi.service.http.HttpService
+	 * org.osgi.service.http.*
+	 * *
+	 * </pre>
+	 * 
+	 * For the {@code get} action, the name can also be a filter
+	 * expression. The filter gives access to the service properties as well as
+	 * the following attributes:
+	 * <ul>
+	 * <li>signer - A Distinguished Name chain used to sign the bundle
+	 * publishing the service. Wildcards in a DN are not matched according to
+	 * the filter string rules, but according to the rules defined for a DN
+	 * chain.</li>
+	 * <li>location - The location of the bundle publishing the service.</li>
+	 * <li>id - The bundle ID of the bundle publishing the service.</li>
+	 * <li>name - The symbolic name of the bundle publishing the service.</li>
+	 * </ul>
+	 * Since the above attribute names may conflict with service property names
+	 * used by a service, you can prefix an attribute name with '@' in the
+	 * filter expression to match against the service property and not one of
+	 * the above attributes. Filter attribute names are processed in a case
+	 * sensitive manner unless the attribute references a service property.
+	 * Service properties names are case insensitive.
+	 * 
+	 * <p>
+	 * There are two possible actions: {@code get} and
+	 * {@code register}. The {@code get} permission allows the owner
+	 * of this permission to obtain a service with this name. The
+	 * {@code register} permission allows the bundle to register a service
+	 * under that name.
+	 * 
+	 * @param name The service class name
+	 * @param actions {@code get},{@code register} (canonical order)
+	 * @throws IllegalArgumentException If the specified name is a filter
+	 *         expression and either the specified action is not
+	 *         {@code get} or the filter has an invalid syntax.
+	 */
+	public ServicePermission(String name, String actions) {
+		this(name, parseActions(actions));
+		if ((filter != null)
+				&& ((action_mask & ACTION_ALL) != ACTION_GET)) {
+			throw new IllegalArgumentException(
+					"invalid action string for filter expression");
+		}
+	}
+
+	/**
+	 * Creates a new requested {@code ServicePermission} object to be used
+	 * by code that must perform {@code checkPermission} for the
+	 * {@code get} action. {@code ServicePermission} objects created
+	 * with this constructor cannot be added to a {@code ServicePermission}
+	 * permission collection.
+	 * 
+	 * @param reference The requested service.
+	 * @param actions The action {@code get}.
+	 * @throws IllegalArgumentException If the specified action is not
+	 *         {@code get} or reference is {@code null}.
+	 * @since 1.5
+	 */
+	public ServicePermission(ServiceReference< ? > reference, String actions) {
+		super(createName(reference));
+		setTransients(null, parseActions(actions));
+		this.service = reference;
+		this.objectClass = (String[]) reference
+				.getProperty(Constants.OBJECTCLASS);
+		if ((action_mask & ACTION_ALL) != ACTION_GET) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+	}
+
+	/**
+	 * Create a permission name from a ServiceReference
+	 * 
+	 * @param reference ServiceReference to use to create permission name.
+	 * @return permission name.
+	 */
+	private static String createName(ServiceReference< ? > reference) {
+		if (reference == null) {
+			throw new IllegalArgumentException("reference must not be null");
+		}
+		StringBuffer sb = new StringBuffer("(service.id=");
+		sb.append(reference.getProperty(Constants.SERVICE_ID));
+		sb.append(")");
+		return sb.toString();
+	}
+
+	/**
+	 * Package private constructor used by ServicePermissionCollection.
+	 * 
+	 * @param name class name
+	 * @param mask action mask
+	 */
+	ServicePermission(String name, int mask) {
+		super(name);
+		setTransients(parseFilter(name), mask);
+		this.service = null;
+		this.objectClass = null;
+	}
+
+	/**
+	 * Called by constructors and when deserialized.
+	 * 
+	 * @param mask action mask
+	 */
+	private void setTransients(Filter f, int mask) {
+		if ((mask == ACTION_NONE) || ((mask & ACTION_ALL) != mask)) {
+			throw new IllegalArgumentException("invalid action string");
+		}
+		action_mask = mask;
+		filter = f;
+		if (f == null) {
+			String name = getName();
+			int l = name.length();
+			/* if "*" or endsWith ".*" */
+			wildcard = ((name.charAt(l - 1) == '*') && ((l == 1) || (name
+					.charAt(l - 2) == '.')));
+			if (wildcard && (l > 1)) {
+				prefix = name.substring(0, l - 1);
+			}
+		}
+	}
+
+	/**
+	 * Parse action string into action mask.
+	 * 
+	 * @param actions Action string.
+	 * @return action mask.
+	 */
+	private static int parseActions(String actions) {
+		boolean seencomma = false;
+
+		int mask = ACTION_NONE;
+
+		if (actions == null) {
+			return mask;
+		}
+
+		char[] a = actions.toCharArray();
+
+		int i = a.length - 1;
+		if (i < 0)
+			return mask;
+
+		while (i != -1) {
+			char c;
+
+			// skip whitespace
+			while ((i != -1)
+					&& ((c = a[i]) == ' ' || c == '\r' || c == '\n'
+							|| c == '\f' || c == '\t'))
+				i--;
+
+			// check for the known strings
+			int matchlen;
+
+			if (i >= 2 && (a[i - 2] == 'g' || a[i - 2] == 'G')
+					&& (a[i - 1] == 'e' || a[i - 1] == 'E')
+					&& (a[i] == 't' || a[i] == 'T')) {
+				matchlen = 3;
+				mask |= ACTION_GET;
+
+			}
+			else
+				if (i >= 7 && (a[i - 7] == 'r' || a[i - 7] == 'R')
+						&& (a[i - 6] == 'e' || a[i - 6] == 'E')
+						&& (a[i - 5] == 'g' || a[i - 5] == 'G')
+						&& (a[i - 4] == 'i' || a[i - 4] == 'I')
+						&& (a[i - 3] == 's' || a[i - 3] == 'S')
+						&& (a[i - 2] == 't' || a[i - 2] == 'T')
+						&& (a[i - 1] == 'e' || a[i - 1] == 'E')
+						&& (a[i] == 'r' || a[i] == 'R')) {
+					matchlen = 8;
+					mask |= ACTION_REGISTER;
+
+				}
+				else {
+					// parse error
+					throw new IllegalArgumentException("invalid permission: "
+							+ actions);
+				}
+
+			// make sure we didn't just match the tail of a word
+			// like "ackbarfregister". Also, skip to the comma.
+			seencomma = false;
+			while (i >= matchlen && !seencomma) {
+				switch (a[i - matchlen]) {
+					case ',' :
+						seencomma = true;
+					/* FALLTHROUGH */
+					case ' ' :
+					case '\r' :
+					case '\n' :
+					case '\f' :
+					case '\t' :
+						break;
+					default :
+						throw new IllegalArgumentException(
+								"invalid permission: " + actions);
+				}
+				i--;
+			}
+
+			// point i at the location of the comma minus one (or -1).
+			i -= matchlen;
+		}
+
+		if (seencomma) {
+			throw new IllegalArgumentException("invalid permission: " + actions);
+		}
+
+		return mask;
+	}
+
+	/**
+	 * Parse filter string into a Filter object.
+	 * 
+	 * @param filterString The filter string to parse.
+	 * @return a Filter for this bundle. If the specified filterString is not a
+	 *         filter expression, then {@code null} is returned.
+	 * @throws IllegalArgumentException If the filter syntax is invalid.
+	 */
+	private static Filter parseFilter(String filterString) {
+		filterString = filterString.trim();
+		if (filterString.charAt(0) != '(') {
+			return null;
+		}
+
+		try {
+			return FrameworkUtil.createFilter(filterString);
+		}
+		catch (InvalidSyntaxException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid filter");
+			iae.initCause(e);
+			throw iae;
+		}
+	}
+
+	/**
+	 * Determines if a {@code ServicePermission} object "implies" the
+	 * specified permission.
+	 * 
+	 * @param p The target permission to check.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean implies(Permission p) {
+		if (!(p instanceof ServicePermission)) {
+			return false;
+		}
+		ServicePermission requested = (ServicePermission) p;
+		if (service != null) {
+			return false;
+		}
+		// if requested permission has a filter, then it is an invalid argument
+		if (requested.filter != null) {
+			return false;
+		}
+		return implies0(requested, ACTION_NONE);
+	}
+
+	/**
+	 * Internal implies method. Used by the implies and the permission
+	 * collection implies methods.
+	 * 
+	 * @param requested The requested ServicePermission which has already be
+	 *        validated as a proper argument. The requested ServicePermission
+	 *        must not have a filter expression.
+	 * @param effective The effective actions with which to start.
+	 * @return {@code true} if the specified permission is implied by this
+	 *         object; {@code false} otherwise.
+	 */
+	boolean implies0(ServicePermission requested, int effective) {
+		/* check actions first - much faster */
+		effective |= action_mask;
+		final int desired = requested.action_mask;
+		if ((effective & desired) != desired) {
+			return false;
+		}
+		/* we have name of "*" */
+		if (wildcard && (prefix == null)) {
+			return true;
+		}
+		/* if we have a filter */
+		Filter f = filter;
+		if (f != null) {
+			return f.matches(requested.getProperties());
+		}
+		/* if requested permission not created with ServiceReference */
+		String[] requestedNames = requested.objectClass;
+		if (requestedNames == null) {
+			return super.implies(requested);
+		}
+		/* requested permission created with ServiceReference */
+		if (wildcard) {
+			int pl = prefix.length();
+			for (int i = 0, l = requestedNames.length; i < l; i++) {
+				String requestedName = requestedNames[i];
+				if ((requestedName.length() > pl)
+						&& requestedName.startsWith(prefix)) {
+					return true;
+				}
+			}
+		}
+		else {
+			String name = getName();
+			for (int i = 0, l = requestedNames.length; i < l; i++) {
+				if (requestedNames[i].equals(name)) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns the canonical string representation of the actions. Always
+	 * returns present actions in the following order: {@code get},
+	 * {@code register}.
+	 * 
+	 * @return The canonical string representation of the actions.
+	 */
+	public String getActions() {
+		String result = actions;
+		if (result == null) {
+			StringBuffer sb = new StringBuffer();
+			boolean comma = false;
+
+			int mask = action_mask;
+			if ((mask & ACTION_GET) == ACTION_GET) {
+				sb.append(GET);
+				comma = true;
+			}
+
+			if ((mask & ACTION_REGISTER) == ACTION_REGISTER) {
+				if (comma)
+					sb.append(',');
+				sb.append(REGISTER);
+			}
+
+			actions = result = sb.toString();
+		}
+
+		return result;
+	}
+
+	/**
+	 * Returns a new {@code PermissionCollection} object for storing
+	 * {@code ServicePermission} objects.
+	 * 
+	 * @return A new {@code PermissionCollection} object suitable for storing
+	 *         {@code ServicePermission} objects.
+	 */
+	public PermissionCollection newPermissionCollection() {
+		return new ServicePermissionCollection();
+	}
+
+	/**
+	 * Determines the equality of two ServicePermission objects.
+	 * 
+	 * Checks that specified object has the same class name and action as this
+	 * {@code ServicePermission}.
+	 * 
+	 * @param obj The object to test for equality.
+	 * @return true if obj is a {@code ServicePermission}, and has the same
+	 *         class name and actions as this {@code ServicePermission}
+	 *         object; {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof ServicePermission)) {
+			return false;
+		}
+
+		ServicePermission sp = (ServicePermission) obj;
+
+		return (action_mask == sp.action_mask)
+				&& getName().equals(sp.getName())
+				&& ((service == sp.service) || ((service != null) && (service
+						.compareTo(sp.service) == 0)));
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return Hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + getName().hashCode();
+		h = 31 * h + getActions().hashCode();
+		if (service != null) {
+			h = 31 * h + service.hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * WriteObject is called to save the state of this permission to a stream.
+	 * The actions are serialized, and the superclass takes care of the name.
+	 */
+	private synchronized void writeObject(java.io.ObjectOutputStream s)
+			throws IOException {
+		if (service != null) {
+			throw new NotSerializableException("cannot serialize");
+		}
+		// Write out the actions. The superclass takes care of the name
+		// call getActions to make sure actions field is initialized
+		if (actions == null)
+			getActions();
+		s.defaultWriteObject();
+	}
+
+	/**
+	 * readObject is called to restore the state of this permission from a
+	 * stream.
+	 */
+	private synchronized void readObject(java.io.ObjectInputStream s)
+			throws IOException, ClassNotFoundException {
+		// Read in the action, then initialize the rest
+		s.defaultReadObject();
+		setTransients(parseFilter(getName()), parseActions(actions));
+	}
+
+	/**
+	 * Called by {@code <@link ServicePermission#implies(Permission)>}. This
+	 * method is only called on a requested permission which cannot have a
+	 * filter set.
+	 * 
+	 * @return a map of properties for this permission.
+	 */
+	private Map<String, Object> getProperties() {
+		Map<String, Object> result = properties;
+		if (result != null) {
+			return result;
+		}
+		if (service == null) {
+			result = new HashMap<String, Object>(1);
+			result.put(Constants.OBJECTCLASS, new String[] {getName()});
+			return properties = result;
+		}
+		final Map<String, Object> props = new HashMap<String, Object>(4);
+		final Bundle bundle = service.getBundle();
+		if (bundle != null) {
+			AccessController.doPrivileged(new PrivilegedAction<Object>() {
+				public Object run() {
+					props.put("id", new Long(bundle.getBundleId()));
+					props.put("location", bundle.getLocation());
+					String name = bundle.getSymbolicName();
+					if (name != null) {
+						props.put("name", name);
+					}
+					SignerProperty signer = new SignerProperty(bundle);
+					if (signer.isBundleSigned()) {
+						props.put("signer", signer);
+					}
+					return null;
+				}
+			});
+		}
+		return properties = new Properties(props, service);
+	}
+	
+	static private final class Properties extends AbstractMap<String, Object> {
+		private final Map<String, Object>	properties;
+		private final ServiceReference< ? >	service;
+		private transient volatile Set<Map.Entry<String, Object>>	entries;
+
+		Properties(Map<String, Object> properties, ServiceReference< ? > service) {
+			this.properties = properties;
+			this.service = service;
+			entries = null;
+		}
+
+		public Object get(Object k) {
+			if (!(k instanceof String)) {
+				return null;
+			}
+			String key = (String) k;
+			if (key.charAt(0) == '@') {
+				return service.getProperty(key.substring(1));
+			}
+			Object value = properties.get(key);
+			if (value != null) { // fall back to service properties
+				return value;
+			}
+			return service.getProperty(key);
+		}
+
+		public Set<Map.Entry<String, Object>> entrySet() {
+			if (entries != null) {
+				return entries;
+			}
+			Set<Map.Entry<String, Object>> all = new HashSet<Map.Entry<String, Object>>(
+					properties.entrySet());
+			add: for (String key : service.getPropertyKeys()) {
+				for (String k : properties.keySet()) {
+					if (key.equalsIgnoreCase(k)) {
+						continue add;
+					}
+				}
+				all.add(new Entry(key, service.getProperty(key)));
+			}
+			return entries = Collections.unmodifiableSet(all);
+		}
+		
+		static private final class Entry implements Map.Entry<String, Object> {
+			private final String	k;
+			private final Object	v;
+
+			Entry(String key, Object value) {
+				this.k = key;
+				this.v = value;
+			}
+			public String getKey() {
+				return k;
+			}
+			public Object getValue() {
+				return v;
+			}
+			public Object setValue(Object value) {
+				throw new UnsupportedOperationException();
+			}
+			public String toString() {
+				return k + "=" + v;
+			}
+			public int hashCode() {
+				return ((k == null) ? 0 : k.hashCode())
+						^ ((v == null) ? 0 : v.hashCode());
+			}
+			public boolean equals(Object obj) {
+				if (obj == this) {
+					return true;
+				}
+				if (!(obj instanceof Map.Entry)) {
+					return false;
+				}
+				Map.Entry< ? , ? > e = (Map.Entry< ? , ? >) obj;
+				final Object key = e.getKey();
+				if ((k == key) || ((k != null) && k.equals(key))) {
+					final Object value = e.getValue();
+					if ((v == value) || ((v != null) && v.equals(value))) {
+						return true;
+					}
+				}
+				return false;
+			}
+		}
+	}
+}
+
+/**
+ * Stores a set of ServicePermission permissions.
+ * 
+ * @see java.security.Permission
+ * @see java.security.Permissions
+ * @see java.security.PermissionCollection
+ */
+final class ServicePermissionCollection extends PermissionCollection {
+	static final long	serialVersionUID	= 662615640374640621L;
+	/**
+	 * Table of permissions.
+	 * 
+	 * @GuardedBy this
+	 */
+	private transient Map<String, ServicePermission>	permissions;
+
+	/**
+	 * Boolean saying if "*" is in the collection.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private boolean		all_allowed;
+
+	/**
+	 * Table of permissions with filter expressions.
+	 * 
+	 * @serial
+	 * @GuardedBy this
+	 */
+	private Map<String, ServicePermission>				filterPermissions;
+
+	/**
+	 * Creates an empty ServicePermissions object.
+	 */
+	public ServicePermissionCollection() {
+		permissions = new HashMap<String, ServicePermission>();
+		all_allowed = false;
+	}
+
+	/**
+	 * Adds a permission to this permission collection.
+	 * 
+	 * @param permission The Permission object to add.
+	 * @throws IllegalArgumentException If the specified permission is not a
+	 *         ServicePermission object.
+	 * @throws SecurityException If this
+	 *         {@code ServicePermissionCollection} object has been marked
+	 *         read-only.
+	 */
+	public void add(final Permission permission) {
+		if (!(permission instanceof ServicePermission)) {
+			throw new IllegalArgumentException("invalid permission: "
+					+ permission);
+		}
+		if (isReadOnly()) {
+			throw new SecurityException("attempt to add a Permission to a "
+					+ "readonly PermissionCollection");
+		}
+
+		final ServicePermission sp = (ServicePermission) permission;
+		if (sp.service != null) {
+			throw new IllegalArgumentException("cannot add to collection: "
+					+ sp);
+		}
+		
+		final String name = sp.getName();
+		final Filter f = sp.filter;
+		synchronized (this) {
+			/* select the bucket for the permission */
+			Map<String, ServicePermission> pc;
+			if (f != null) {
+				pc = filterPermissions;
+				if (pc == null) {
+					filterPermissions = pc = new HashMap<String, ServicePermission>();
+				}
+			}
+			else {
+				pc = permissions;
+			}
+			final ServicePermission existing = pc.get(name);
+			
+			if (existing != null) {
+				final int oldMask = existing.action_mask;
+				final int newMask = sp.action_mask;
+				if (oldMask != newMask) {
+					pc
+							.put(name, new ServicePermission(name, oldMask
+							| newMask));
+				}
+			}
+			else {
+				pc.put(name, sp);
+			}
+			
+			if (!all_allowed) {
+				if (name.equals("*")) {
+					all_allowed = true;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Determines if a set of permissions implies the permissions expressed in
+	 * {@code permission}.
+	 * 
+	 * @param permission The Permission object to compare.
+	 * @return {@code true} if {@code permission} is a proper
+	 *         subset of a permission in the set; {@code false}
+	 *         otherwise.
+	 */
+	public boolean implies(final Permission permission) {
+		if (!(permission instanceof ServicePermission)) {
+			return false;
+		}
+		final ServicePermission requested = (ServicePermission) permission;
+		/* if requested permission has a filter, then it is an invalid argument */
+		if (requested.filter != null) {
+			return false;
+		}
+
+		int effective = ServicePermission.ACTION_NONE;
+		Collection<ServicePermission> perms;
+		synchronized (this) {
+			final int desired = requested.action_mask;
+			/* short circuit if the "*" Permission was added */
+			if (all_allowed) {
+				ServicePermission sp = permissions.get("*");
+				if (sp != null) {
+					effective |= sp.action_mask;
+					if ((effective & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			
+			String[] requestedNames = requested.objectClass;
+			/* if requested permission not created with ServiceReference */
+			if (requestedNames == null) {
+				effective |= effective(requested.getName(), desired, effective);
+				if ((effective & desired) == desired) {
+					return true;
+				}
+			}
+			/* requested permission created with ServiceReference */
+			else {
+				for (int i = 0, l = requestedNames.length; i < l; i++) {
+					if ((effective(requestedNames[i], desired, effective) & desired) == desired) {
+						return true;
+					}
+				}
+			}
+			Map<String, ServicePermission> pc = filterPermissions;
+			if (pc == null) {
+				return false;
+			}
+			perms = pc.values();
+		}
+		
+		/* iterate one by one over filteredPermissions */
+		for (ServicePermission perm : perms) {
+			if (perm.implies0(requested, effective)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Consult permissions map to compute the effective permission for the
+	 * requested permission name.
+	 * 
+	 * @param requestedName The requested service name.
+	 * @param desired The desired actions.
+	 * @param effective The effective actions.
+	 * @return The new effective actions.
+	 */
+	private int effective(String requestedName, final int desired,
+			int effective) {
+		final Map<String, ServicePermission> pc = permissions;
+		ServicePermission sp = pc.get(requestedName);
+		// strategy:
+		// Check for full match first. Then work our way up the
+		// name looking for matches on a.b.*
+		if (sp != null) {
+			// we have a direct hit!
+			effective |= sp.action_mask;
+			if ((effective & desired) == desired) {
+				return effective;
+			}
+		}
+		// work our way up the tree...
+		int last;
+		int offset = requestedName.length() - 1;
+		while ((last = requestedName.lastIndexOf(".", offset)) != -1) {
+			requestedName = requestedName.substring(0, last + 1) + "*";
+			sp = pc.get(requestedName);
+			if (sp != null) {
+				effective |= sp.action_mask;
+				if ((effective & desired) == desired) {
+					return effective;
+				}
+			}
+			offset = last - 1;
+		}
+		/*
+		 * we don't have to check for "*" as it was already checked before we
+		 * were called.
+		 */
+		return effective;
+	}
+	
+	/**
+	 * Returns an enumeration of all the {@code ServicePermission}
+	 * objects in the container.
+	 * 
+	 * @return Enumeration of all the ServicePermission objects.
+	 */
+	public synchronized Enumeration<Permission> elements() {
+		List<Permission> all = new ArrayList<Permission>(permissions.values());
+		Map<String, ServicePermission> pc = filterPermissions;
+		if (pc != null) {
+			all.addAll(pc.values());
+		}
+		return Collections.enumeration(all);
+	}
+	
+	/* serialization logic */
+	private static final ObjectStreamField[]	serialPersistentFields	= {
+			new ObjectStreamField("permissions", Hashtable.class),
+			new ObjectStreamField("all_allowed", Boolean.TYPE),
+			new ObjectStreamField("filterPermissions", HashMap.class)	};
+
+	private synchronized void writeObject(ObjectOutputStream out)
+			throws IOException {
+		Hashtable<String, ServicePermission> hashtable = new Hashtable<String, ServicePermission>(
+				permissions);
+		ObjectOutputStream.PutField pfields = out.putFields();
+		pfields.put("permissions", hashtable);
+		pfields.put("all_allowed", all_allowed);
+		pfields.put("filterPermissions", filterPermissions);
+		out.writeFields();
+	}
+
+	private synchronized void readObject(java.io.ObjectInputStream in)
+			throws IOException, ClassNotFoundException {
+		ObjectInputStream.GetField gfields = in.readFields();
+		Hashtable<String, ServicePermission> hashtable = (Hashtable<String, ServicePermission>) gfields
+				.get("permissions", null);
+		permissions = new HashMap<String, ServicePermission>(hashtable);
+		all_allowed = gfields.get("all_allowed", false);
+		HashMap<String, ServicePermission> fp = (HashMap<String, ServicePermission>) gfields
+				.get("filterPermissions", null);
+		filterPermissions = fp;
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceReference.java b/main/src/main/java/org/osgi/framework/ServiceReference.java
new file mode 100644
index 0000000000..ad38df7507
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceReference.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.Dictionary;
+
+/**
+ * A reference to a service.
+ * 
+ * <p>
+ * The Framework returns {@code ServiceReference} objects from the
+ * {@code BundleContext.getServiceReference} and
+ * {@code BundleContext.getServiceReferences} methods.
+ * <p>
+ * A {@code ServiceReference} object may be shared between bundles and can
+ * be used to examine the properties of the service and to get the service
+ * object.
+ * <p>
+ * Every service registered in the Framework has a unique
+ * {@code ServiceRegistration} object and may have multiple, distinct
+ * {@code ServiceReference} objects referring to it.
+ * {@code ServiceReference} objects associated with a
+ * {@code ServiceRegistration} object have the same {@code hashCode}
+ * and are considered equal (more specifically, their {@code equals()}
+ * method will return {@code true} when compared).
+ * <p>
+ * If the same service object is registered multiple times,
+ * {@code ServiceReference} objects associated with different
+ * {@code ServiceRegistration} objects are not equal.
+ * 
+ * @param <S> Type of Service.
+ * @see BundleContext#getServiceReference
+ * @see BundleContext#getServiceReferences
+ * @see BundleContext#getService
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 771b9b4d4f65dbe593154d02912edba51a085b0c $
+ */
+
+public interface ServiceReference<S> extends Comparable<Object> {
+	/**
+	 * Returns the property value to which the specified property key is mapped
+	 * in the properties {@code Dictionary} object of the service
+	 * referenced by this {@code ServiceReference} object.
+	 * 
+	 * <p>
+	 * Property keys are case-insensitive.
+	 * 
+	 * <p>
+	 * This method must continue to return property values after the service has
+	 * been unregistered. This is so references to unregistered services (for
+	 * example, {@code ServiceReference} objects stored in the log) can
+	 * still be interrogated.
+	 * 
+	 * @param key The property key.
+	 * @return The property value to which the key is mapped; {@code null}
+	 *         if there is no property named after the key.
+	 */
+	public Object getProperty(String key);
+
+	/**
+	 * Returns an array of the keys in the properties {@code Dictionary}
+	 * object of the service referenced by this {@code ServiceReference}
+	 * object.
+	 * 
+	 * <p>
+	 * This method will continue to return the keys after the service has been
+	 * unregistered. This is so references to unregistered services (for
+	 * example, {@code ServiceReference} objects stored in the log) can
+	 * still be interrogated.
+	 * 
+	 * <p>
+	 * This method is <i>case-preserving </i>; this means that every key in the
+	 * returned array must have the same case as the corresponding key in the
+	 * properties {@code Dictionary} that was passed to the
+	 * {@link BundleContext#registerService(String[],Object,Dictionary)} or
+	 * {@link ServiceRegistration#setProperties} methods.
+	 * 
+	 * @return An array of property keys.
+	 */
+	public String[] getPropertyKeys();
+
+	/**
+	 * Returns the bundle that registered the service referenced by this
+	 * {@code ServiceReference} object.
+	 * 
+	 * <p>
+	 * This method must return {@code null} when the service has been
+	 * unregistered. This can be used to determine if the service has been
+	 * unregistered.
+	 * 
+	 * @return The bundle that registered the service referenced by this
+	 *         {@code ServiceReference} object; {@code null} if that
+	 *         service has already been unregistered.
+	 * @see BundleContext#registerService(String[],Object,Dictionary)
+	 */
+	public Bundle getBundle();
+
+	/**
+	 * Returns the bundles that are using the service referenced by this
+	 * {@code ServiceReference} object. Specifically, this method returns
+	 * the bundles whose usage count for that service is greater than zero.
+	 * 
+	 * @return An array of bundles whose usage count for the service referenced
+	 *         by this {@code ServiceReference} object is greater than
+	 *         zero; {@code null} if no bundles are currently using that
+	 *         service.
+	 * 
+	 * @since 1.1
+	 */
+	public Bundle[] getUsingBundles();
+
+	/**
+	 * Tests if the bundle that registered the service referenced by this
+	 * {@code ServiceReference} and the specified bundle use the same
+	 * source for the package of the specified class name.
+	 * <p>
+	 * This method performs the following checks:
+	 * <ol>
+	 * <li>Get the package name from the specified class name.</li>
+	 * <li>For the bundle that registered the service referenced by this
+	 * {@code ServiceReference} (registrant bundle); find the source for
+	 * the package. If no source is found then return {@code true} if the
+	 * registrant bundle is equal to the specified bundle; otherwise return
+	 * {@code false}.</li>
+	 * <li>If the package source of the registrant bundle is equal to the
+	 * package source of the specified bundle then return {@code true};
+	 * otherwise return {@code false}.</li>
+	 * </ol>
+	 * 
+	 * @param bundle The {@code Bundle} object to check.
+	 * @param className The class name to check.
+	 * @return {@code true} if the bundle which registered the service
+	 *         referenced by this {@code ServiceReference} and the
+	 *         specified bundle use the same source for the package of the
+	 *         specified class name. Otherwise {@code false} is returned.
+	 * @throws IllegalArgumentException If the specified {@code Bundle} was
+	 *         not created by the same framework instance as this
+	 *         {@code ServiceReference}.
+	 * @since 1.3
+	 */
+	public boolean isAssignableTo(Bundle bundle, String className);
+
+	/**
+	 * Compares this {@code ServiceReference} with the specified
+	 * {@code ServiceReference} for order.
+	 * 
+	 * <p>
+	 * If this {@code ServiceReference} and the specified
+	 * {@code ServiceReference} have the same {@link Constants#SERVICE_ID
+	 * service id} they are equal. This {@code ServiceReference} is less
+	 * than the specified {@code ServiceReference} if it has a lower
+	 * {@link Constants#SERVICE_RANKING service ranking} and greater if it has a
+	 * higher service ranking. Otherwise, if this {@code ServiceReference}
+	 * and the specified {@code ServiceReference} have the same
+	 * {@link Constants#SERVICE_RANKING service ranking}, this
+	 * {@code ServiceReference} is less than the specified
+	 * {@code ServiceReference} if it has a higher
+	 * {@link Constants#SERVICE_ID service id} and greater if it has a lower
+	 * service id.
+	 * 
+	 * @param reference The {@code ServiceReference} to be compared.
+	 * @return Returns a negative integer, zero, or a positive integer if this
+	 *         {@code ServiceReference} is less than, equal to, or greater
+	 *         than the specified {@code ServiceReference}.
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code ServiceReference} was not created by the same
+	 *         framework instance as this {@code ServiceReference}.
+	 * @since 1.4
+	 */
+	public int compareTo(Object reference);
+}
diff --git a/main/src/main/java/org/osgi/framework/ServiceRegistration.java b/main/src/main/java/org/osgi/framework/ServiceRegistration.java
new file mode 100644
index 0000000000..e4cfc0e644
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/ServiceRegistration.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) OSGi Alliance (2000, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.Dictionary;
+
+/**
+ * A registered service.
+ * 
+ * <p>
+ * The Framework returns a {@code ServiceRegistration} object when a
+ * {@code BundleContext.registerService} method invocation is successful.
+ * The {@code ServiceRegistration} object is for the private use of the
+ * registering bundle and should not be shared with other bundles.
+ * <p>
+ * The {@code ServiceRegistration} object may be used to update the
+ * properties of the service or to unregister the service.
+ * 
+ * @param <S> Type of Service.
+ * @see BundleContext#registerService(String[],Object,Dictionary)
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: dc742ff3749821529f9ae62e05d9bd5d8eca00d7 $
+ */
+
+public interface ServiceRegistration<S> {
+	/**
+	 * Returns a {@code ServiceReference} object for a service being
+	 * registered.
+	 * <p>
+	 * The {@code ServiceReference} object may be shared with other
+	 * bundles.
+	 * 
+	 * @throws IllegalStateException If this
+	 *         {@code ServiceRegistration} object has already been
+	 *         unregistered.
+	 * @return {@code ServiceReference} object.
+	 */
+	public ServiceReference<S> getReference();
+
+	/**
+	 * Updates the properties associated with a service.
+	 * 
+	 * <p>
+	 * The {@link Constants#OBJECTCLASS} and {@link Constants#SERVICE_ID} keys
+	 * cannot be modified by this method. These values are set by the Framework
+	 * when the service is registered in the OSGi environment.
+	 * 
+	 * <p>
+	 * The following steps are required to modify service properties:
+	 * <ol>
+	 * <li>The service's properties are replaced with the provided properties.
+	 * <li>A service event of type {@link ServiceEvent#MODIFIED} is fired.
+	 * </ol>
+	 * 
+	 * @param properties The properties for this service. See {@link Constants}
+	 *        for a list of standard service property keys. Changes should not
+	 *        be made to this object after calling this method. To update the
+	 *        service's properties this method should be called again.
+	 * 
+	 * @throws IllegalStateException If this {@code ServiceRegistration}
+	 *         object has already been unregistered.
+	 * @throws IllegalArgumentException If {@code properties} contains
+	 *         case variants of the same key name.
+	 */
+	public void setProperties(Dictionary<String, ? > properties);
+
+	/**
+	 * Unregisters a service. Remove a {@code ServiceRegistration} object
+	 * from the Framework service registry. All {@code ServiceReference}
+	 * objects associated with this {@code ServiceRegistration} object
+	 * can no longer be used to interact with the service once unregistration is
+	 * complete.
+	 * 
+	 * <p>
+	 * The following steps are required to unregister a service:
+	 * <ol>
+	 * <li>The service is removed from the Framework service registry so that
+	 * it can no longer be obtained.
+	 * <li>A service event of type {@link ServiceEvent#UNREGISTERING} is fired
+	 * so that bundles using this service can release their use of the service.
+	 * Once delivery of the service event is complete, the
+	 * {@code ServiceReference} objects for the service may no longer be
+	 * used to get a service object for the service.
+	 * <li>For each bundle whose use count for this service is greater than
+	 * zero: <br>
+	 * The bundle's use count for this service is set to zero. <br>
+	 * If the service was registered with a {@link ServiceFactory} object, the
+	 * {@code ServiceFactory.ungetService} method is called to release
+	 * the service object for the bundle.
+	 * </ol>
+	 * 
+	 * @throws IllegalStateException If this
+	 *         {@code ServiceRegistration} object has already been
+	 *         unregistered.
+	 * @see BundleContext#ungetService
+	 * @see ServiceFactory#ungetService
+	 */
+	public void unregister();
+}
diff --git a/main/src/main/java/org/osgi/framework/SignerProperty.java b/main/src/main/java/org/osgi/framework/SignerProperty.java
new file mode 100644
index 0000000000..8b357c1be1
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/SignerProperty.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Package private class used by permissions for filter matching on signer key
+ * during filter expression evaluation in the permission implies method.
+ * 
+ * @Immutable
+ * @version $Id: 3589831a7594cf36e645a51ab9b9ae5ebfd80beb $
+ */
+final class SignerProperty {
+	private final Bundle	bundle;
+	private final String	pattern;
+
+	/**
+	 * String constructor used by the filter matching algorithm to construct a
+	 * SignerProperty from the attribute value in a filter expression.
+	 * 
+	 * @param pattern Attribute value in the filter expression.
+	 */
+	public SignerProperty(String pattern) {
+		this.pattern = pattern;
+		this.bundle = null;
+	}
+
+	/**
+	 * Used by the permission implies method to build the properties for a
+	 * filter match.
+	 * 
+	 * @param bundle The bundle whose signers are to be matched.
+	 */
+	SignerProperty(Bundle bundle) {
+		this.bundle = bundle;
+		this.pattern = null;
+	}
+
+	/**
+	 * Used by the filter matching algorithm. This methods does NOT satisfy the
+	 * normal equals contract. Since the class is only used in filter expression
+	 * evaluations, it only needs to support comparing an instance created with
+	 * a Bundle to an instance created with a pattern string from the filter
+	 * expression.
+	 * 
+	 * @param o SignerProperty to compare against.
+	 * @return true if the DN name chain matches the pattern.
+	 */
+	public boolean equals(Object o) {
+		if (!(o instanceof SignerProperty))
+			return false;
+		SignerProperty other = (SignerProperty) o;
+		Bundle matchBundle = bundle != null ? bundle : other.bundle;
+		String matchPattern = bundle != null ? other.pattern : pattern;
+		Map<X509Certificate, List<X509Certificate>> signers = matchBundle
+				.getSignerCertificates(Bundle.SIGNERS_TRUSTED);
+		for (List<X509Certificate> signerCerts : signers.values()) {
+			List<String> dnChain = new ArrayList<String>(signerCerts.size());
+			for (X509Certificate signerCert : signerCerts) {
+				dnChain.add(signerCert.getSubjectDN().getName());
+			}
+			try {
+				if (FrameworkUtil.matchDistinguishedNameChain(matchPattern,
+						dnChain)) {
+					return true;
+				}
+			}
+			catch (IllegalArgumentException e) {
+				continue; // bad pattern
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Since the equals method does not obey the general equals contract, this
+	 * method cannot generate hash codes which obey the equals contract.
+	 */
+	public int hashCode() {
+		return 31;
+	}
+
+	/**
+	 * Check if the bundle is signed.
+	 * 
+	 * @return true if constructed with a bundle that is signed.
+	 */
+	boolean isBundleSigned() {
+		if (bundle == null) {
+			return false;
+		}
+		Map<X509Certificate, List<X509Certificate>> signers = bundle
+				.getSignerCertificates(Bundle.SIGNERS_TRUSTED);
+		return !signers.isEmpty();
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/SynchronousBundleListener.java b/main/src/main/java/org/osgi/framework/SynchronousBundleListener.java
new file mode 100644
index 0000000000..227dc59cc3
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/SynchronousBundleListener.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+/**
+ * A synchronous {@code BundleEvent} listener.
+ * {@code SynchronousBundleListener} is a listener interface that may be
+ * implemented by a bundle developer. When a {@code BundleEvent} is fired,
+ * it is synchronously delivered to a {@code SynchronousBundleListener}.
+ * The Framework may deliver {@code BundleEvent} objects to a
+ * {@code SynchronousBundleListener} out of order and may concurrently call
+ * and/or reenter a {@code SynchronousBundleListener}.
+ * 
+ * <p>
+ * For {@code BundleEvent} types {@link BundleEvent#STARTED STARTED} and
+ * {@link BundleEvent#LAZY_ACTIVATION LAZY_ACTIVATION}, the Framework must not
+ * hold the referenced bundle's &quot;state change&quot; lock when the
+ * {@code BundleEvent} is delivered to a
+ * {@code SynchronousBundleListener}. For the other
+ * {@code BundleEvent} types, the Framework must hold the referenced
+ * bundle's &quot;state change&quot; lock when the {@code BundleEvent} is
+ * delivered to a {@code SynchronousBundleListener}. A
+ * {@code SynchronousBundleListener} cannot directly call life cycle
+ * methods on the referenced bundle when the Framework is holding the referenced
+ * bundle's &quot;state change&quot; lock.
+ * 
+ * <p>
+ * A {@code SynchronousBundleListener} object is registered with the
+ * Framework using the {@link BundleContext#addBundleListener} method.
+ * {@code SynchronousBundleListener} objects are called with a
+ * {@code BundleEvent} object when a bundle has been installed, resolved,
+ * starting, started, stopping, stopped, updated, unresolved, or uninstalled.
+ * <p>
+ * Unlike normal {@code BundleListener} objects,
+ * {@code SynchronousBundleListener}s are synchronously called during
+ * bundle lifecycle processing. The bundle lifecycle processing will not proceed
+ * until all {@code SynchronousBundleListener}s have completed.
+ * {@code SynchronousBundleListener} objects will be called prior to
+ * {@code BundleListener} objects.
+ * <p>
+ * {@code AdminPermission[bundle,LISTENER]} is required to add or remove a
+ * {@code SynchronousBundleListener} object.
+ * 
+ * @since 1.1
+ * @see BundleEvent
+ * @ThreadSafe
+ * @version $Id: b22484f48ebdcb2141da9bba9eb65f5c40e0f520 $
+ */
+
+public interface SynchronousBundleListener extends BundleListener {
+	// This is a marker interface
+}
diff --git a/main/src/main/java/org/osgi/framework/Version.java b/main/src/main/java/org/osgi/framework/Version.java
new file mode 100644
index 0000000000..fd2484ee07
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/Version.java
@@ -0,0 +1,376 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework;
+
+import java.util.NoSuchElementException;
+import java.util.StringTokenizer;
+
+/**
+ * Version identifier for bundles and packages.
+ * 
+ * <p>
+ * Version identifiers have four components.
+ * <ol>
+ * <li>Major version. A non-negative integer.</li>
+ * <li>Minor version. A non-negative integer.</li>
+ * <li>Micro version. A non-negative integer.</li>
+ * <li>Qualifier. A text string. See {@code Version(String)} for the
+ * format of the qualifier string.</li>
+ * </ol>
+ * 
+ * <p>
+ * {@code Version} objects are immutable.
+ * 
+ * @since 1.3
+ * @Immutable
+ * @version $Id: a71e2e2d7685e65b5bbe375efdf97fda16eff0a5 $
+ */
+
+public class Version implements Comparable<Version> {
+	private final int			major;
+	private final int			minor;
+	private final int			micro;
+	private final String		qualifier;
+	private static final String	SEPARATOR		= ".";
+	private transient String	versionString;
+
+	/**
+	 * The empty version "0.0.0".
+	 */
+	public static final Version	emptyVersion	= new Version(0, 0, 0);
+
+	/**
+	 * Creates a version identifier from the specified numerical components.
+	 * 
+	 * <p>
+	 * The qualifier is set to the empty string.
+	 * 
+	 * @param major Major component of the version identifier.
+	 * @param minor Minor component of the version identifier.
+	 * @param micro Micro component of the version identifier.
+	 * @throws IllegalArgumentException If the numerical components are
+	 *         negative.
+	 */
+	public Version(int major, int minor, int micro) {
+		this(major, minor, micro, null);
+	}
+
+	/**
+	 * Creates a version identifier from the specified components.
+	 * 
+	 * @param major Major component of the version identifier.
+	 * @param minor Minor component of the version identifier.
+	 * @param micro Micro component of the version identifier.
+	 * @param qualifier Qualifier component of the version identifier. If
+	 *        {@code null} is specified, then the qualifier will be set to
+	 *        the empty string.
+	 * @throws IllegalArgumentException If the numerical components are negative
+	 *         or the qualifier string is invalid.
+	 */
+	public Version(int major, int minor, int micro, String qualifier) {
+		if (qualifier == null) {
+			qualifier = "";
+		}
+
+		this.major = major;
+		this.minor = minor;
+		this.micro = micro;
+		this.qualifier = qualifier;
+		versionString = null;
+		validate();
+	}
+
+	/**
+	 * Created a version identifier from the specified string.
+	 * 
+	 * <p>
+	 * Here is the grammar for version strings.
+	 * 
+	 * <pre>
+	 * version ::= major('.'minor('.'micro('.'qualifier)?)?)?
+	 * major ::= digit+
+	 * minor ::= digit+
+	 * micro ::= digit+
+	 * qualifier ::= (alpha|digit|'_'|'-')+
+	 * digit ::= [0..9]
+	 * alpha ::= [a..zA..Z]
+	 * </pre>
+	 * 
+	 * There must be no whitespace in version.
+	 * 
+	 * @param version String representation of the version identifier.
+	 * @throws IllegalArgumentException If {@code version} is improperly
+	 *         formatted.
+	 */
+	public Version(String version) {
+		int maj = 0;
+		int min = 0;
+		int mic = 0;
+		String qual = "";
+
+		try {
+			StringTokenizer st = new StringTokenizer(version, SEPARATOR, true);
+			maj = Integer.parseInt(st.nextToken());
+
+			if (st.hasMoreTokens()) { // minor
+				st.nextToken(); // consume delimiter
+				min = Integer.parseInt(st.nextToken());
+
+				if (st.hasMoreTokens()) { // micro
+					st.nextToken(); // consume delimiter
+					mic = Integer.parseInt(st.nextToken());
+
+					if (st.hasMoreTokens()) { // qualifier
+						st.nextToken(); // consume delimiter
+						qual = st.nextToken(""); // remaining string
+
+						if (st.hasMoreTokens()) { // fail safe
+							throw new IllegalArgumentException(
+									"invalid format: " + version);
+						}
+					}
+				}
+			}
+		}
+		catch (NoSuchElementException e) {
+			IllegalArgumentException iae = new IllegalArgumentException(
+					"invalid format: " + version);
+			iae.initCause(e);
+			throw iae;
+		}
+
+		major = maj;
+		minor = min;
+		micro = mic;
+		qualifier = qual;
+		versionString = null;
+		validate();
+	}
+
+	/**
+	 * Called by the Version constructors to validate the version components.
+	 * 
+	 * @throws IllegalArgumentException If the numerical components are negative
+	 *         or the qualifier string is invalid.
+	 */
+	private void validate() {
+		if (major < 0) {
+			throw new IllegalArgumentException("negative major");
+		}
+		if (minor < 0) {
+			throw new IllegalArgumentException("negative minor");
+		}
+		if (micro < 0) {
+			throw new IllegalArgumentException("negative micro");
+		}
+		char[] chars = qualifier.toCharArray();
+		for (int i = 0, length = chars.length; i < length; i++) {
+	        char ch = chars[i];
+			if (('A' <= ch) && (ch <= 'Z')) {
+				continue;
+			}
+			if (('a' <= ch) && (ch <= 'z')) {
+				continue;
+			}
+			if (('0' <= ch) && (ch <= '9')) {
+				continue;
+			}
+			if ((ch == '_') || (ch == '-')) {
+				continue;
+			}
+			throw new IllegalArgumentException("invalid qualifier: "
+					+ qualifier);
+		}
+	}
+
+	/**
+	 * Parses a version identifier from the specified string.
+	 * 
+	 * <p>
+	 * See {@code Version(String)} for the format of the version string.
+	 * 
+	 * @param version String representation of the version identifier. Leading
+	 *        and trailing whitespace will be ignored.
+	 * @return A {@code Version} object representing the version
+	 *         identifier. If {@code version} is {@code null} or
+	 *         the empty string then {@code emptyVersion} will be
+	 *         returned.
+	 * @throws IllegalArgumentException If {@code version} is improperly
+	 *         formatted.
+	 */
+	public static Version parseVersion(String version) {
+		if (version == null) {
+			return emptyVersion;
+		}
+
+		version = version.trim();
+		if (version.length() == 0) {
+			return emptyVersion;
+		}
+
+		return new Version(version);
+	}
+
+	/**
+	 * Returns the major component of this version identifier.
+	 * 
+	 * @return The major component.
+	 */
+	public int getMajor() {
+		return major;
+	}
+
+	/**
+	 * Returns the minor component of this version identifier.
+	 * 
+	 * @return The minor component.
+	 */
+	public int getMinor() {
+		return minor;
+	}
+
+	/**
+	 * Returns the micro component of this version identifier.
+	 * 
+	 * @return The micro component.
+	 */
+	public int getMicro() {
+		return micro;
+	}
+
+	/**
+	 * Returns the qualifier component of this version identifier.
+	 * 
+	 * @return The qualifier component.
+	 */
+	public String getQualifier() {
+		return qualifier;
+	}
+
+	/**
+	 * Returns the string representation of this version identifier.
+	 * 
+	 * <p>
+	 * The format of the version string will be {@code major.minor.micro}
+	 * if qualifier is the empty string or
+	 * {@code major.minor.micro.qualifier} otherwise.
+	 * 
+	 * @return The string representation of this version identifier.
+	 */
+	public String toString() {
+		if (versionString != null) {
+			return versionString;
+		}
+		int q = qualifier.length();
+		StringBuffer result = new StringBuffer(20 + q);
+		result.append(major);
+		result.append(SEPARATOR);
+		result.append(minor);
+		result.append(SEPARATOR);
+		result.append(micro);
+		if (q > 0) {
+			result.append(SEPARATOR);
+			result.append(qualifier);
+		}
+		return versionString = result.toString();
+	}
+
+	/**
+	 * Returns a hash code value for the object.
+	 * 
+	 * @return An integer which is a hash code value for this object.
+	 */
+	public int hashCode() {
+		return (major << 24) + (minor << 16) + (micro << 8)
+				+ qualifier.hashCode();
+	}
+
+	/**
+	 * Compares this {@code Version} object to another object.
+	 * 
+	 * <p>
+	 * A version is considered to be <b>equal to </b> another version if the
+	 * major, minor and micro components are equal and the qualifier component
+	 * is equal (using {@code String.equals}).
+	 * 
+	 * @param object The {@code Version} object to be compared.
+	 * @return {@code true} if {@code object} is a
+	 *         {@code Version} and is equal to this object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object object) {
+		if (object == this) { // quicktest
+			return true;
+		}
+
+		if (!(object instanceof Version)) {
+			return false;
+		}
+
+		Version other = (Version) object;
+		return (major == other.major) && (minor == other.minor)
+				&& (micro == other.micro) && qualifier.equals(other.qualifier);
+	}
+
+	/**
+	 * Compares this {@code Version} object to another {@code Version}.
+	 * 
+	 * <p>
+	 * A version is considered to be <b>less than </b> another version if its
+	 * major component is less than the other version's major component, or the
+	 * major components are equal and its minor component is less than the other
+	 * version's minor component, or the major and minor components are equal
+	 * and its micro component is less than the other version's micro component,
+	 * or the major, minor and micro components are equal and it's qualifier
+	 * component is less than the other version's qualifier component (using
+	 * {@code String.compareTo}).
+	 * 
+	 * <p>
+	 * A version is considered to be <b>equal to</b> another version if the
+	 * major, minor and micro components are equal and the qualifier component
+	 * is equal (using {@code String.compareTo}).
+	 * 
+	 * @param other The {@code Version} object to be compared.
+	 * @return A negative integer, zero, or a positive integer if this version
+	 *         is less than, equal to, or greater than the specified
+	 *         {@code Version} object.
+	 * @throws ClassCastException If the specified object is not a
+	 *         {@code Version} object.
+	 */
+	public int compareTo(Version other) {
+		if (other == this) { // quicktest
+			return 0;
+		}
+
+		int result = major - other.major;
+		if (result != 0) {
+			return result;
+		}
+
+		result = minor - other.minor;
+		if (result != 0) {
+			return result;
+		}
+
+		result = micro - other.micro;
+		if (result != 0) {
+			return result;
+		}
+
+		return qualifier.compareTo(other.qualifier);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/bundle/EventHook.java b/main/src/main/java/org/osgi/framework/hooks/bundle/EventHook.java
new file mode 100644
index 0000000000..4b50ab3ad7
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/bundle/EventHook.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.bundle;
+
+import java.util.Collection;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+
+/** 
+ * OSGi Framework Bundle Event Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework lifecycle
+ * (install, start, stop, update, and uninstall bundle) operations.
+ * 
+ * @ThreadSafe
+ * @version $Id: 18ea1ec1f14f47410a43e99be4da3b2583149722 $
+ */
+public interface EventHook {
+
+	/**
+	 * Bundle event hook method.  This method is called prior to bundle event
+	 * delivery when a bundle is installed, resolved, started, stopped, unresolved, or
+	 * uninstalled.  This method can filter the bundles which receive the event.
+	 * <p>
+	 * This method must be called by the framework one and only one time for each bundle 
+	 * event generated, this included bundle events which are generated when there are no 
+	 * bundle listeners registered.  This method must be called on the same thread that is 
+	 * performing the action which generated the specified event.  The specified 
+	 * collection includes bundle contexts with synchronous and asynchronous bundle 
+	 * listeners registered with them.
+	 * 
+	 * @param event The bundle event to be delivered
+	 * @param contexts A collection of Bundle Contexts for bundles which have
+	 *        listeners to which the specified event will be delivered. The
+	 *        implementation of this method may remove bundle contexts from the
+	 *        collection to prevent the event from being delivered to the
+	 *        associated bundles. The collection supports all the optional
+	 *        {@code Collection} operations except {@code add} and
+	 *        {@code addAll}. Attempting to add to the collection will
+	 *        result in an {@code UnsupportedOperationException}. The
+	 *        collection is not synchronized.
+	 */
+	void event(BundleEvent event, Collection<BundleContext> contexts);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/bundle/FindHook.java b/main/src/main/java/org/osgi/framework/hooks/bundle/FindHook.java
new file mode 100644
index 0000000000..e55ee3b86b
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/bundle/FindHook.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.framework.hooks.bundle;
+
+import java.util.Collection;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+
+/**
+ * OSGi Framework Bundle Context Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework bundle find
+ * (get bundles) operations.
+ * 
+ * @ThreadSafe
+ * @version $Id: 4492a677df650072fe6acaea9ea35571f31eb5a9 $
+ */
+public interface FindHook {
+	/**
+	 * Find hook method. This method is called for the following:
+	 * <ul>
+	 * <li>Bundle find operations using {@link BundleContext#getBundle(long)}
+	 * and {@link BundleContext#getBundles()} methods. The find method can
+	 * filter the result of the find operation. Note that a find operation using
+	 * the {@link BundleContext#getBundle(String)} method does not cause the
+	 * find method to be called.</li>
+	 * <li>Bundle install operations when an existing bundle is already
+	 * installed at a given location. In this case, the find method is called to
+	 * determine if the context performing the install operation is able to find
+	 * the bundle. If the context cannot find the existing bundle then the
+	 * install operation must fail with a
+	 * {@link BundleException#REJECTED_BY_HOOK} exception.</li>
+	 * </ul>
+	 * 
+	 * @param context
+	 *            The bundle context of the bundle performing the find
+	 *            operation.
+	 * @param bundles
+	 *            A collection of Bundles to be returned as a result of the find
+	 *            operation. The implementation of this method may remove
+	 *            bundles from the collection to prevent the bundles from being
+	 *            returned to the bundle performing the find operation. The
+	 *            collection supports all the optional {@code Collection}
+	 *            operations except {@code add} and {@code addAll}. Attempting
+	 *            to add to the collection will result in an
+	 *            {@code UnsupportedOperationException}. The collection is not
+	 *            synchronized.
+	 */
+	void find(BundleContext context, Collection<Bundle> bundles);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/bundle/package-info.java b/main/src/main/java/org/osgi/framework/hooks/bundle/package-info.java
new file mode 100644
index 0000000000..a195769e07
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/bundle/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Bundle Hooks Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.framework.hooks.bundle; version="[1.0,2.0)"}
+ * 
+ * @version $Id: a609772e6106eb5b93ec337740e48696417fc082 $
+ */
+
+package org.osgi.framework.hooks.bundle;
diff --git a/main/src/main/java/org/osgi/framework/hooks/bundle/packageinfo b/main/src/main/java/org/osgi/framework/hooks/bundle/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/bundle/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHook.java b/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHook.java
new file mode 100644
index 0000000000..bbde7ffb59
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHook.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.resolver;
+
+import java.util.Collection;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.wiring.BundleCapability;
+import org.osgi.framework.wiring.BundleRequirement;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.framework.wiring.FrameworkWiring;
+
+/**
+ * OSGi Framework Resolver Hook instances are obtained from the OSGi
+ * {@link ResolverHookFactory Framework Resolver Hook Factory} service.
+ * 
+ * <p>
+ * A Resolver Hook instance is called by the framework during a resolve process.
+ * A resolver hook may influence the outcome of a resolve process by removing
+ * entries from shrinkable collections that are passed to the hook during a
+ * resolve process. A shrinkable collection is a {@code Collection} that
+ * supports all remove operations. Any other attempts to modify a shrinkable
+ * collection will result in an {@code UnsupportedOperationException} being
+ * thrown.
+ * 
+ * <p>
+ * The following steps outline the way a framework uses the resolver hooks
+ * during a resolve process.
+ * <ol>
+ * <li>Collect a snapshot of registered resolver hook factories that will be
+ * called during the current resolve process. Any hook factories registered
+ * after the snapshot is taken must not be called during the current resolve
+ * process. A resolver hook factory contained in the snapshot may become
+ * unregistered during the resolve process. The framework should handle this and
+ * stop calling the resolver hook instance provided by the unregistered hook
+ * factory and the current resolve process must fail. If possible, an exception
+ * must be thrown to the caller of the API which triggered the resolve process.
+ * In cases where the the caller is not available a framework event of type
+ * error should be fired.</li>
+ * <li>For each registered hook factory call the
+ * {@link ResolverHookFactory#begin(Collection)} method to inform the hooks
+ * about a resolve process beginning and to obtain a Resolver Hook instance that
+ * will be used for the duration of the resolve process.</li>
+ * <li>Determine the collection of unresolved bundle revisions that may be
+ * considered for resolution during the current resolution process and place
+ * each of the bundle revisions in a shrinkable collection {@code R}. For each
+ * resolver hook call the {@link #filterResolvable(Collection)} method with the
+ * shrinkable collection {@code R}.</li>
+ * <li>The shrinkable collection {@code R} now contains all the unresolved
+ * bundle revisions that may end up as resolved at the end of the current
+ * resolve process. Any other bundle revisions that got removed from the
+ * shrinkable collection {@code R} must not end up as resolved at the end of the
+ * current resolve process.</li>
+ * <li>For each bundle revision {@code B} left in the shrinkable collection
+ * {@code R} that represents a singleton bundle do the following:<br/>
+ * Determine the collection of available capabilities that have a name space of
+ * {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle}, are singletons,
+ * and have the same symbolic name as the singleton bundle revision {@code B}
+ * and place each of the matching capabilities into a shrinkable collection
+ * {@code S}.
+ * 
+ * Remove the {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle}
+ * capability provided by bundle revision {@code B} from shrinkable collection
+ * {@code S}. A singleton bundle cannot collide with itself.
+ * 
+ * For each resolver hook call the
+ * {@link #filterSingletonCollisions(BundleCapability, Collection)} with the
+ * {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle} capability
+ * provided by bundle revision {@code B} and the shrinkable collection {@code S}
+ * 
+ * The shrinkable collection {@code S} now contains all singleton
+ * {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle} capabilities that
+ * can influence the ability of bundle revision {@code B} to resolve.</li>
+ * <li>During a resolve process a framework is free to attempt to resolve any or
+ * all bundles contained in shrinkable collection {@code R}. For each bundle
+ * revision {@code B} left in the shrinkable collection {@code R} which the
+ * framework attempts to resolve the following steps must be followed:
+ * <p/>
+ * For each requirement {@code T} specified by bundle revision {@code B}
+ * determine the collection of capabilities that satisfy (or match) the
+ * requirement and place each matching capability into a shrinkable collection
+ * {@code C}. A capability is considered to match a particular requirement if
+ * its attributes satisfy a specified requirement and the requirer bundle has
+ * permission to access the capability.
+ * 
+ * <p/>
+ * For each resolver hook call the
+ * {@link #filterMatches(BundleRequirement, Collection)} with the requirement
+ * {@code T} and the shrinkable collection {@code C}.
+ * 
+ * <p/>
+ * The shrinkable collection {@code C} now contains all the capabilities that
+ * may be used to satisfy the requirement {@code T}. Any other capabilities that
+ * got removed from the shrinkable collection {@code C} must not be used to
+ * satisfy requirement {@code T}.</li>
+ * <li>For each resolver hook call the {@link #end()} method to inform the hooks
+ * about a resolve process ending.</li>
+ * </ol>
+ * In all cases, the order in which the resolver hooks are called is the reverse
+ * compareTo ordering of their Service References. That is, the service with the
+ * highest ranking number must be called first. In cases where a shrinkable
+ * collection becomes empty the framework is required to call the remaining
+ * registered hooks.
+ * <p>
+ * Resolver hooks are low level. Implementations of the resolver hook must be
+ * careful not to create an unresolvable state which is very hard for a
+ * developer or a provisioner to diagnose. Resolver hooks also must not be
+ * allowed to start another synchronous resolve process (e.g. by calling
+ * {@link Bundle#start()} or {@link FrameworkWiring#resolveBundles(Collection)}
+ * ). The framework must detect this and throw an {@link IllegalStateException}.
+ * 
+ * @see ResolverHookFactory
+ * @NotThreadSafe
+ * @version $Id: ea23400257d780706250f8825ec886aaebb0e5d8 $
+ */
+public interface ResolverHook {
+	/**
+	 * Filter resolvable candidates hook method.  This method may be called
+	 * multiple times during a single resolve process.
+	 * This method can filter the collection of candidates by removing 
+	 * potential candidates.  Removing a candidate will prevent the candidate
+	 * from resolving during the current resolve process. 
+	 * 
+	 * @param candidates the collection of resolvable candidates available during
+	 * a resolve process. 
+	 */
+	void filterResolvable(Collection<BundleRevision> candidates);
+
+	/**
+	 * Filter singleton collisions hook method. This method is called during the
+	 * resolve process for the specified singleton. The specified singleton
+	 * represents a singleton capability and the specified collection represent
+	 * a collection of singleton capabilities which are considered collision
+	 * candidates. The singleton capability and the collection of collision
+	 * candidates must all use the same name space.
+	 * <p>
+	 * Currently only capabilities with the name space of
+	 * {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle} can be
+	 * singletons. In that case all the collision candidates have the name space
+	 * of {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle}, are
+	 * singletons, and have the same symbolic name as the specified singleton
+	 * capability.
+	 * <p>
+	 * In the future, capabilities in other name spaces may support the
+	 * singleton concept. Hook implementations should be prepared to receive
+	 * calls to this method for capabilities in name spaces other than
+	 * {@link BundleRevision#BUNDLE_NAMESPACE osgi.wiring.bundle}.
+	 * <p>
+	 * This method can filter the list of collision candidates by removing
+	 * potential collisions. Removing a collision candidate will allow the
+	 * specified singleton to resolve regardless of the resolution state of the
+	 * removed collision candidate.
+	 * 
+	 * @param singleton the singleton involved in a resolve process
+	 * @param collisionCandidates a collection of singleton collision candidates
+	 */
+	void filterSingletonCollisions(BundleCapability singleton, Collection<BundleCapability> collisionCandidates);
+
+	/**
+	 * Filter matches hook method. This method is called during the resolve process for the 
+	 * specified requirement.  The collection of candidates match the specified requirement.
+	 * This method can filter the collection of matching candidates by removing candidates from 
+	 * the collection.  Removing a candidate will prevent the resolve process from choosing the 
+	 * removed candidate to satisfy the requirement.
+	 * <p>
+	 * All of the candidates will have the same name space and will 
+	 * match the specified requirement.
+	 * <p>
+	 * If the Java Runtime Environment supports permissions then the collection of 
+	 * candidates will only contain candidates for which the requirer has permission to
+	 * access.
+	 * @param requirement the requirement to filter candidates for
+	 * @param candidates a collection of candidates that match the requirement
+	 */
+	void filterMatches(BundleRequirement requirement, Collection<BundleCapability> candidates);
+
+	/**
+	 * This method is called once at the end of the resolve process.
+	 * After the end method is called the resolve process has ended.
+	 * The framework must not hold onto this resolver hook instance
+	 * after end has been called.
+	 */
+	void end();
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHookFactory.java b/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHookFactory.java
new file mode 100644
index 0000000000..1d4edd43bd
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/resolver/ResolverHookFactory.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.resolver;
+
+import java.util.Collection;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.framework.wiring.FrameworkWiring;
+
+/** 
+ * OSGi Framework Resolver Hook Factory Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called by the framework during 
+ * a bundle resolver process to obtain a {@link ResolverHook resolver hook}
+ * instance which will be used for the duration of a resolve process.
+ * 
+ * @ThreadSafe
+ * @see ResolverHook
+ * @version $Id: 4023566367435f07c047a7ba571f3bedc53aa37a $
+ */
+public interface ResolverHookFactory {
+	/**
+	 * This method is called by the framework each time a resolve process begins
+	 * to obtain a {@link ResolverHook resolver hook} instance.  This resolver hook 
+	 * instance will be used for the duration of the resolve process.  At the end of 
+	 * the resolve process the method {@link ResolverHook#end()} must be called by 
+	 * the framework and the framework must not hold any references of the resolver 
+	 * hook instance.
+	 * <p>
+	 * The triggers represent the collection of bundles which triggered
+	 * the resolve process.  This collection may be empty if the triggers
+	 * cannot be determined by the framework.  In most cases the triggers 
+	 * can easily be determined.  Calling certain methods on 
+	 * {@link Bundle bundle} when a bundle is in the {@link Bundle#INSTALLED INSTALLED} 
+	 * state will cause the framework to begin a resolve process in order to resolve the 
+	 * bundle.  The following methods will start a resolve process in this case:
+	 * <ul>
+	 *   <li>{@link Bundle#start() start}</li>
+	 *   <li>{@link Bundle#loadClass(String) loadClass}</li>
+	 *   <li>{@link Bundle#findEntries(String, String, boolean) findEntries}</li>
+	 *   <li>{@link Bundle#getResource(String) getResource}</li>
+	 *   <li>{@link Bundle#getResources(String) getResources}</li>
+	 * </ul> 
+	 * In such cases the collection will contain the single bundle which the
+	 * framework is trying to resolve.  Other cases will cause multiple bundles to be
+	 * included in the trigger bundles collection.  When {@link FrameworkWiring#resolveBundles(Collection)
+	 * resolveBundles} is called the collection of triggers must include all the current bundle 
+	 * revisions for bundles passed to resolveBundles which are in the {@link Bundle#INSTALLED INSTALLED}
+	 * state.
+	 * <p>
+	 * When {@link FrameworkWiring#refreshBundles(Collection, org.osgi.framework.FrameworkListener...)}
+	 * is called the collection of triggers is determined with the following steps:
+	 * <ul>
+	 *   <li>If the collection of bundles passed is null then {@link FrameworkWiring#getRemovalPendingBundles()}
+	 *   is called to get the initial collection of bundles.</li>
+	 *   <li>The equivalent of calling {@link FrameworkWiring#getDependencyClosure(Collection)} is called with
+	 *   the initial collection of bundles to get the dependency closure collection of the bundles being refreshed.</li>
+	 *   <li>Remove any non-active bundles from the dependency closure collection.</li>
+	 *   <li>For each bundle remaining in the dependency closure collection get the current bundle revision
+	 *   and add it to the collection of triggers.</li> 
+	 * </ul>
+	 * <p>
+	 * As described above, a resolve process is typically initiated as a result of calling API that causes the 
+	 * framework to attempt to resolve one or more bundles.  
+	 * The framework is free to start a resolve process at any time for reasons other than calls to framework API.
+	 * For example, a resolve process may be used by the framework for diagnostic purposes and result in no
+	 * bundles actually becoming resolved at the end of the process.
+	 * Resolver hook implementations must be prepared for resolve processes that are initiated for other reasons
+	 * besides calls to framework API.
+	 * @param triggers an unmodifiable collection of bundles which triggered the resolve process.
+	 * This collection may be empty if the collection of trigger bundles cannot be
+	 * determined.
+	 * @return a resolver hook instance to be used for the duration of the resolve process.
+	 * A {@code null} value may be returned which indicates this resolver hook factory abstains from
+	 * the resolve process.
+	 */
+	ResolverHook begin(Collection<BundleRevision> triggers);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/resolver/package-info.java b/main/src/main/java/org/osgi/framework/hooks/resolver/package-info.java
new file mode 100644
index 0000000000..984c88cf7f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/resolver/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Resolver Hooks Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.framework.hooks.resolver; version="[1.0,2.0)"}
+ * 
+ * @version $Id: 93dc1d16f50055fd55daff71eb5df5eed3371957 $
+ */
+
+package org.osgi.framework.hooks.resolver;
diff --git a/main/src/main/java/org/osgi/framework/hooks/resolver/packageinfo b/main/src/main/java/org/osgi/framework/hooks/resolver/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/resolver/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/EventHook.java b/main/src/main/java/org/osgi/framework/hooks/service/EventHook.java
new file mode 100644
index 0000000000..fb2ab094a6
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/EventHook.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) OSGi Alliance (2008, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.service;
+
+import java.util.Collection;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceEvent;
+
+/**
+ * OSGi Framework Service Event Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework service
+ * (register, modify, and unregister service) operations.
+ * 
+ * @ThreadSafe
+ * @deprecated As of 1.1. Replaced by {@link EventListenerHook}.
+ * @version $Id: 8fb8cfa2c8847f99fd84711e12f02a57bf06932e $
+ */
+
+public interface EventHook {
+	/**
+	 * Event hook method. This method is called prior to service event delivery
+	 * when a publishing bundle registers, modifies or unregisters a service.
+	 * This method can filter the bundles which receive the event.
+	 * 
+	 * @param event The service event to be delivered.
+	 * @param contexts A collection of Bundle Contexts for bundles which have
+	 *        listeners to which the specified event will be delivered. The
+	 *        implementation of this method may remove bundle contexts from the
+	 *        collection to prevent the event from being delivered to the
+	 *        associated bundles. The collection supports all the optional
+	 *        {@code Collection} operations except {@code add} and
+	 *        {@code addAll}. Attempting to add to the collection will
+	 *        result in an {@code UnsupportedOperationException}. The
+	 *        collection is not synchronized.
+	 */
+	void event(ServiceEvent event, Collection<BundleContext> contexts);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/EventListenerHook.java b/main/src/main/java/org/osgi/framework/hooks/service/EventListenerHook.java
new file mode 100644
index 0000000000..6f2529172b
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/EventListenerHook.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.service;
+
+import java.util.Collection;
+import java.util.Map;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.hooks.service.ListenerHook.ListenerInfo;
+
+/**
+ * OSGi Framework Service Event Listener Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework service
+ * (register, modify, and unregister service) operations.
+ * 
+ * @ThreadSafe
+ * @since 1.1
+ * @version $Id: 61c6aa7e7d4c85b3e5a6a3a340155bcda0074505 $
+ */
+
+public interface EventListenerHook {
+	/**
+	 * Event listener hook method. This method is called prior to service event
+	 * delivery when a publishing bundle registers, modifies or unregisters a
+	 * service. This method can filter the listeners which receive the event.
+	 * 
+	 * @param event The service event to be delivered.
+	 * @param listeners A map of Bundle Contexts to a collection of Listener
+	 *        Infos for the bundle's listeners to which the specified event will
+	 *        be delivered. The implementation of this method may remove bundle
+	 *        contexts from the map and listener infos from the collection
+	 *        values to prevent the event from being delivered to the associated
+	 *        listeners. The map supports all the optional {@code Map}
+	 *        operations except {@code put} and {@code putAll}. Attempting to
+	 *        add to the map will result in an
+	 *        {@code UnsupportedOperationException}. The collection values in
+	 *        the map supports all the optional {@code Collection} operations
+	 *        except {@code add} and {@code addAll}. Attempting to add to a
+	 *        collection will result in an {@code UnsupportedOperationException}
+	 *        . The map and the collections are not synchronized.
+	 */
+	void event(ServiceEvent event,
+			Map<BundleContext, Collection<ListenerInfo>> listeners);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/FindHook.java b/main/src/main/java/org/osgi/framework/hooks/service/FindHook.java
new file mode 100644
index 0000000000..cb334c531e
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/FindHook.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) OSGi Alliance (2008, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.service;
+
+import java.util.Collection;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * OSGi Framework Service Find Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework service find
+ * (get service references) operations.
+ * 
+ * @ThreadSafe
+ * @version $Id: 4a939200fa6634a563379b057e11bd1b5d174b9d $
+ */
+
+public interface FindHook {
+	/**
+	 * Find hook method. This method is called during the service find operation
+	 * (for example, {@link BundleContext#getServiceReferences(String, String)}
+	 * ). This method can filter the result of the find operation.
+	 * 
+	 * @param context The bundle context of the bundle performing the find
+	 *        operation.
+	 * @param name The class name of the services to find or {@code null}
+	 *        to find all services.
+	 * @param filter The filter criteria of the services to find or
+	 *        {@code null} for no filter criteria.
+	 * @param allServices {@code true} if the find operation is the result
+	 *        of a call to
+	 *        {@link BundleContext#getAllServiceReferences(String, String)}
+	 * @param references A collection of Service References to be returned as a
+	 *        result of the find operation. The implementation of this method
+	 *        may remove service references from the collection to prevent the
+	 *        references from being returned to the bundle performing the find
+	 *        operation. The collection supports all the optional
+	 *        {@code Collection} operations except {@code add} and
+	 *        {@code addAll}. Attempting to add to the collection will
+	 *        result in an {@code UnsupportedOperationException}. The
+	 *        collection is not synchronized.
+	 */
+	void find(BundleContext context, String name, String filter,
+			boolean allServices, Collection<ServiceReference< ? >> references);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/ListenerHook.java b/main/src/main/java/org/osgi/framework/hooks/service/ListenerHook.java
new file mode 100644
index 0000000000..bdac7b590c
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/ListenerHook.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) OSGi Alliance (2008, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.service;
+
+import java.util.Collection;
+
+import org.osgi.framework.BundleContext;
+
+/**
+ * OSGi Framework Service Listener Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during service listener
+ * addition and removal.
+ * 
+ * @ThreadSafe
+ * @version $Id: c1687e95e568589cf3e6d927b7d372c9f88c5d16 $
+ */
+
+public interface ListenerHook {
+	/**
+	 * Added listeners hook method. This method is called to provide the hook
+	 * implementation with information on newly added service listeners. This
+	 * method will be called as service listeners are added while this hook is
+	 * registered. Also, immediately after registration of this hook, this
+	 * method will be called to provide the current collection of service
+	 * listeners which had been added prior to the hook being registered.
+	 * 
+	 * @param listeners A collection of {@link ListenerInfo}s for newly added
+	 *        service listeners which are now listening to service events.
+	 *        Attempting to add to or remove from the collection will result in
+	 *        an {@code UnsupportedOperationException}. The collection is
+	 *        not synchronized.
+	 */
+	void added(Collection<ListenerInfo> listeners);
+
+	/**
+	 * Removed listeners hook method. This method is called to provide the hook
+	 * implementation with information on newly removed service listeners. This
+	 * method will be called as service listeners are removed while this hook is
+	 * registered.
+	 * 
+	 * @param listeners A collection of {@link ListenerInfo}s for newly removed
+	 *        service listeners which are no longer listening to service events.
+	 *        Attempting to add to or remove from the collection will result in
+	 *        an {@code UnsupportedOperationException}. The collection is
+	 *        not synchronized.
+	 */
+	void removed(Collection<ListenerInfo> listeners);
+
+	/**
+	 * Information about a Service Listener. This interface describes the bundle
+	 * which added the Service Listener and the filter with which it was added.
+	 * 
+	 * @ThreadSafe
+	 * @noimplement
+	 */
+	public interface ListenerInfo {
+		/**
+		 * Return the context of the bundle which added the listener.
+		 * 
+		 * @return The context of the bundle which added the listener.
+		 */
+		BundleContext getBundleContext();
+
+		/**
+		 * Return the filter string with which the listener was added.
+		 * 
+		 * @return The filter string with which the listener was added. This may
+		 *         be {@code null} if the listener was added without a
+		 *         filter.
+		 */
+		String getFilter();
+
+		/**
+		 * Return the state of the listener for this addition and removal life
+		 * cycle. Initially this method will return {@code false}
+		 * indicating the listener has been added but has not been removed.
+		 * After the listener has been removed, this method must always return
+		 * {@code true}.
+		 * 
+		 * <p>
+		 * There is an extremely rare case in which removed notification to
+		 * {@link ListenerHook}s can be made before added notification if two
+		 * threads are racing to add and remove the same service listener.
+		 * Because {@link ListenerHook}s are called synchronously during service
+		 * listener addition and removal, the Framework cannot guarantee
+		 * in-order delivery of added and removed notification for a given
+		 * service listener. This method can be used to detect this rare
+		 * occurrence.
+		 * 
+		 * @return {@code false} if the listener has not been been removed,
+		 *         {@code true} otherwise.
+		 */
+		boolean isRemoved();
+
+		/**
+		 * Compares this {@code ListenerInfo} to another
+		 * {@code ListenerInfo}. Two {@code ListenerInfo}s are equals
+		 * if they refer to the same listener for a given addition and removal
+		 * life cycle. If the same listener is added again, it must have a
+		 * different {@code ListenerInfo} which is not equal to this
+		 * {@code ListenerInfo}.
+		 * 
+		 * @param obj The object to compare against this
+		 *        {@code ListenerInfo}.
+		 * @return {@code true} if the other object is a
+		 *         {@code ListenerInfo} object and both objects refer to
+		 *         the same listener for a given addition and removal life
+		 *         cycle.
+		 */
+		boolean equals(Object obj);
+
+		/**
+		 * Returns the hash code for this {@code ListenerInfo}.
+		 * 
+		 * @return The hash code of this {@code ListenerInfo}.
+		 */
+		int hashCode();
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/package-info.java b/main/src/main/java/org/osgi/framework/hooks/service/package-info.java
new file mode 100644
index 0000000000..6d3cc00aa2
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Service Hooks Package Version 1.1.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.framework.hooks.service; version="[1.1,2.0)"}
+ * 
+ * @version $Id: 85e3128f3e46c843539b124c9adc53da34cb3e0f $
+ */
+
+package org.osgi.framework.hooks.service;
diff --git a/main/src/main/java/org/osgi/framework/hooks/service/packageinfo b/main/src/main/java/org/osgi/framework/hooks/service/packageinfo
new file mode 100644
index 0000000000..3987f9c4e8
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/service/packageinfo
@@ -0,0 +1 @@
+version 1.1
diff --git a/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingException.java b/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingException.java
new file mode 100644
index 0000000000..8842797509
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingException.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.weaving;
+
+/**
+ * A weaving exception used to indicate that the class load should be failed but
+ * the weaving hook must not be blacklisted by the framework.
+ * 
+ * <p>
+ * This exception conforms to the general purpose exception chaining mechanism.
+ * 
+ * @version $Id: eb38b85f6ed66ec445fb2f0ee7143df021327a9a $
+ */
+
+public class WeavingException extends RuntimeException {
+	private static final long	serialVersionUID	= 1L;
+
+	/**
+	 * Creates a {@code WeavingException} with the specified message and
+	 * exception cause.
+	 * 
+	 * @param msg The associated message.
+	 * @param cause The cause of this exception.
+	 */
+	public WeavingException(String msg, Throwable cause) {
+		super(msg, cause);
+	}
+
+	/**
+	 * Creates a {@code WeavingException} with the specified message.
+	 * 
+	 * @param msg The message.
+	 */
+	public WeavingException(String msg) {
+		super(msg);
+	}
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingHook.java b/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingHook.java
new file mode 100644
index 0000000000..be57658ed8
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/weaving/WeavingHook.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.weaving;
+
+/**
+ * OSGi Framework Weaving Hook Service.
+ * 
+ * <p>
+ * Bundles registering this service will be called during framework class
+ * loading operations. Weaving hook services are called when a class is being
+ * loaded by the framework and have an opportunity to transform the class file
+ * bytes that represents the class being loaded. Weaving hooks may also ask the
+ * framework to wire in additional dynamic imports to the bundle.
+ * 
+ * <p>
+ * When a class is being loaded, the framework will create a {@link WovenClass}
+ * object for the class and pass it to each registered weaving hook service for
+ * possible modification. The first weaving hook called will see the original
+ * class file bytes. Subsequently called weaving hooks will see the class file
+ * bytes as modified by previously called weaving hooks.
+ * 
+ * @ThreadSafe
+ * @version $Id: d1985029024baba2db1c56aab1e06ee953fd6365 $
+ */
+
+public interface WeavingHook {
+	/**
+	 * Weaving hook method.
+	 * 
+	 * This method can modify the specified woven class object to weave the
+	 * class being defined.
+	 * 
+	 * <p>
+	 * If this method throws any exception, the framework must log the exception
+	 * and fail the class load in progress. This weaving hook service must be
+	 * blacklisted by the framework and must not be called again. The
+	 * blacklisting of this weaving hook service must expire when this weaving
+	 * hook service is unregistered. However, this method can throw a
+	 * {@link WeavingException} to deliberately fail the class load in progress
+	 * without being blacklisted by the framework.
+	 * 
+	 * @param wovenClass The {@link WovenClass} object that represents the data
+	 *        that will be used to define the class.
+	 * @throws WeavingException If this weaving hook wants to deliberately fail
+	 *         the class load in progress without being blacklisted by the
+	 *         framework
+	 */
+	public void weave(WovenClass wovenClass);
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/weaving/WovenClass.java b/main/src/main/java/org/osgi/framework/hooks/weaving/WovenClass.java
new file mode 100644
index 0000000000..34aa6d2f40
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/weaving/WovenClass.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.hooks.weaving;
+
+import java.security.ProtectionDomain;
+import java.util.List;
+
+import org.osgi.framework.wiring.BundleWiring;
+
+/**
+ * A class being woven.
+ * 
+ * This object represents a class being woven and is passed to each
+ * {@link WeavingHook} for possible modification. It allows access to the most
+ * recently transformed class file bytes and to any additional packages that
+ * should be added to the bundle as dynamic imports.
+ * 
+ * <p>
+ * After weaving is {@link #isWeavingComplete() complete}, this object becomes
+ * effectively immutable.
+ * 
+ * @NotThreadSafe
+ * @noimplement
+ * @version $Id: c689a4c27dc39af1bf5f51338f1a8eaca1dddc1a $
+ */
+public interface WovenClass {
+
+	/**
+	 * Returns the class file bytes to be used to define the
+	 * {@link WovenClass#getClassName() named} class.
+	 * 
+	 * <p>
+	 * While weaving is not {@link #isWeavingComplete() complete}, this method
+	 * returns a reference to the class files byte array contained in this
+	 * object. After weaving is {@link #isWeavingComplete() complete}, this
+	 * object becomes effectively immutable and a copy of the class file byte
+	 * array is returned.
+	 * 
+	 * @return The bytes to be used to define the
+	 *         {@link WovenClass#getClassName() named} class.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[bundle,WEAVE]} and the Java runtime
+	 *         environment supports permissions.
+	 */
+	public byte[] getBytes();
+
+	/**
+	 * Set the class file bytes to be used to define the
+	 * {@link WovenClass#getClassName() named} class. This method must not be
+	 * called outside invocations of the {@link WeavingHook#weave(WovenClass)
+	 * weave} method by the framework.
+	 * 
+	 * <p>
+	 * While weaving is not {@link #isWeavingComplete() complete}, this method
+	 * replaces the reference to the array contained in this object with the
+	 * specified array. After weaving is {@link #isWeavingComplete() complete},
+	 * this object becomes effectively immutable and this method will throw an
+	 * {@link IllegalStateException}.
+	 * 
+	 * @param newBytes The new classfile that will be used to define the
+	 *        {@link WovenClass#getClassName() named} class. The specified array
+	 *        is retained by this object and the caller must not modify the
+	 *        specified array.
+	 * @throws NullPointerException If newBytes is {@code null}.
+	 * @throws IllegalStateException If weaving is {@link #isWeavingComplete()
+	 *         complete}.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[bundle,WEAVE]} and the Java runtime
+	 *         environment supports permissions.
+	 */
+	public void setBytes(byte[] newBytes);
+
+	/**
+	 * Returns the list of dynamic import package descriptions to add to the
+	 * {@link #getBundleWiring() bundle wiring} for this woven class. Changes
+	 * made to the returned list will be visible to later {@link WeavingHook
+	 * weaving hooks} called with this object. The returned list must not be
+	 * modified outside invocations of the {@link WeavingHook#weave(WovenClass)
+	 * weave} method by the framework.
+	 * 
+	 * <p>
+	 * After weaving is {@link #isWeavingComplete() complete}, this object
+	 * becomes effectively immutable and the returned list will be unmodifiable.
+	 * 
+	 * <p>
+	 * If the Java runtime environment supports permissions, the caller must
+	 * have {@code AdminPermission[bundle,WEAVE]} to modify the returned list.
+	 * 
+	 * @return A list containing zero or more dynamic import package
+	 *         descriptions to add to the bundle wiring for this woven class.
+	 *         This list must throw {@code IllegalArgumentException} if a
+	 *         malformed dynamic import package description is added.
+	 * @see "Core Specification, Dynamic Import Package, for the syntax of a dynamic import package description."
+	 */
+	public List<String> getDynamicImports();
+
+	/**
+	 * Returns whether weaving is complete in this woven class. Weaving is
+	 * complete after the last {@link WeavingHook weaving hook} is called and
+	 * the class is defined.
+	 * 
+	 * <p>
+	 * After weaving is complete, this object becomes effectively immutable.
+	 * 
+	 * @return {@code true} weaving is complete, {@code false} otherwise.
+	 */
+	public boolean isWeavingComplete();
+
+	/**
+	 * Returns the fully qualified name of the class being woven.
+	 * 
+	 * @return The fully qualified name of the class being woven.
+	 */
+	public String getClassName();
+
+	/**
+	 * Returns the protection domain to which the woven class will be assigned
+	 * when it is defined.
+	 * 
+	 * @return The protection domain to which the woven class will be assigned
+	 *         when it is defined, or {@code null} if no protection domain will
+	 *         be assigned.
+	 */
+	public ProtectionDomain getProtectionDomain();
+
+	/**
+	 * Returns the class associated with this woven class. When loading a class
+	 * for the first time this method will return {@code null} until weaving is
+	 * {@link #isWeavingComplete() complete}. Once weaving is complete, this
+	 * method will return the class object.
+	 * 
+	 * @return The class associated with this woven class, or {@code null} if
+	 *         weaving is not complete or the class definition failed.
+	 */
+	public Class< ? > getDefinedClass();
+
+	/**
+	 * Returns the bundle wiring whose class loader will define the woven class.
+	 * 
+	 * @return The bundle wiring whose class loader will define the woven class.
+	 */
+	public BundleWiring getBundleWiring();
+}
diff --git a/main/src/main/java/org/osgi/framework/hooks/weaving/package-info.java b/main/src/main/java/org/osgi/framework/hooks/weaving/package-info.java
new file mode 100644
index 0000000000..3be9d823b7
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/weaving/package-info.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Weaving Hooks Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * </p>
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * </p>
+ * <p>
+ * {@code  Import-Package: org.osgi.framework.hooks.weaving; version="[1.0,2.0)"}
+ * </p>
+ * @version $Id: fb1848295893f5889dc0260aecfc1437132da157 $
+ */
+
+package org.osgi.framework.hooks.weaving;
diff --git a/main/src/main/java/org/osgi/framework/hooks/weaving/packageinfo b/main/src/main/java/org/osgi/framework/hooks/weaving/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/hooks/weaving/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/framework/launch/Framework.java b/main/src/main/java/org/osgi/framework/launch/Framework.java
new file mode 100644
index 0000000000..672db449bc
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/launch/Framework.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright (c) OSGi Alliance (2008, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.launch;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Enumeration;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.Constants;
+import org.osgi.framework.FrameworkEvent;
+
+/**
+ * A Framework instance. A Framework is also known as a System Bundle.
+ * 
+ * <p>
+ * Framework instances are created using a {@link FrameworkFactory}. The methods
+ * of this interface can be used to manage and control the created framework
+ * instance.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 2be857d06f3605a04f701b59f11e127c0f8940dc $
+ */
+public interface Framework extends Bundle {
+
+	/**
+	 * Initialize this Framework. After calling this method, this Framework
+	 * must:
+	 * <ul>
+	 * <li>Have generated a new {@link Constants#FRAMEWORK_UUID framework UUID}.
+	 * </li>
+	 * <li>Be in the {@link #STARTING} state.</li>
+	 * <li>Have a valid Bundle Context.</li>
+	 * <li>Be at start level 0.</li>
+	 * <li>Have event handling enabled.</li>
+	 * <li>Have reified Bundle objects for all installed bundles.</li>
+	 * <li>Have registered any framework services. For example,
+	 * {@code ConditionalPermissionAdmin}.</li>
+	 * <li>Be {@link #adapt(Class) adaptable} to the OSGi defined types to which
+	 * a system bundle can be adapted.</li>
+	 * </ul>
+	 * 
+	 * <p>
+	 * This Framework will not actually be started until {@link #start() start}
+	 * is called.
+	 * 
+	 * <p>
+	 * This method does nothing if called when this Framework is in the
+	 * {@link #STARTING}, {@link #ACTIVE} or {@link #STOPPING} states.
+	 * 
+	 * @throws BundleException If this Framework could not be initialized.
+	 * @throws SecurityException If the Java Runtime Environment supports
+	 *         permissions and the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]} or if there is a security
+	 *         manager already installed and the
+	 *         {@link Constants#FRAMEWORK_SECURITY} configuration property is
+	 *         set.
+	 * 
+	 */
+	void init() throws BundleException;
+
+	/**
+	 * Wait until this Framework has completely stopped. The {@code stop}
+	 * and {@code update} methods on a Framework performs an asynchronous
+	 * stop of the Framework. This method can be used to wait until the
+	 * asynchronous stop of this Framework has completed. This method will only
+	 * wait if called when this Framework is in the {@link #STARTING},
+	 * {@link #ACTIVE}, or {@link #STOPPING} states. Otherwise it will return
+	 * immediately.
+	 * <p>
+	 * A Framework Event is returned to indicate why this Framework has stopped.
+	 * 
+	 * @param timeout Maximum number of milliseconds to wait until this
+	 *        Framework has completely stopped. A value of zero will wait
+	 *        indefinitely.
+	 * @return A Framework Event indicating the reason this method returned. The
+	 *         following {@code FrameworkEvent} types may be returned by
+	 *         this method.
+	 *         <ul>
+	 *         <li>{@link FrameworkEvent#STOPPED STOPPED} - This Framework has
+	 *         been stopped. </li>
+	 * 
+	 *         <li>{@link FrameworkEvent#STOPPED_UPDATE STOPPED_UPDATE} - This
+	 *         Framework has been updated which has shutdown and will now
+	 *         restart.</li>
+	 * 
+	 *         <li> {@link FrameworkEvent#STOPPED_BOOTCLASSPATH_MODIFIED
+	 *         STOPPED_BOOTCLASSPATH_MODIFIED} - This Framework has been stopped
+	 *         and a bootclasspath extension bundle has been installed or
+	 *         updated. The VM must be restarted in order for the changed boot
+	 *         class path to take effect. </li>
+	 * 
+	 *         <li>{@link FrameworkEvent#ERROR ERROR} - The Framework
+	 *         encountered an error while shutting down or an error has occurred
+	 *         which forced the framework to shutdown. </li>
+	 * 
+	 *         <li> {@link FrameworkEvent#WAIT_TIMEDOUT WAIT_TIMEDOUT} - This
+	 *         method has timed out and returned before this Framework has
+	 *         stopped.</li>
+	 *         </ul>
+	 * @throws InterruptedException If another thread interrupted the current
+	 *         thread before or while the current thread was waiting for this
+	 *         Framework to completely stop. The <i>interrupted status</i> of
+	 *         the current thread is cleared when this exception is thrown.
+	 * @throws IllegalArgumentException If the value of timeout is negative.
+	 */
+	FrameworkEvent waitForStop(long timeout) throws InterruptedException;
+
+	/**
+	 * Start this Framework.
+	 * 
+	 * <p>
+	 * The following steps are taken to start this Framework:
+	 * <ol>
+	 * <li>If this Framework is not in the {@link #STARTING} state,
+	 * {@link #init() initialize} this Framework.</li>
+	 * <li>All installed bundles must be started in accordance with each
+	 * bundle's persistent <i>autostart setting</i>. This means some bundles
+	 * will not be started, some will be started with <i>eager activation</i>
+	 * and some will be started with their <i>declared activation</i> policy.
+	 * The start level of this Framework is moved to the start level specified
+	 * by the {@link Constants#FRAMEWORK_BEGINNING_STARTLEVEL beginning start
+	 * level} framework property, as described in the <i>Start Level
+	 * Specification</i>. If this framework property is not specified, then the
+	 * start level of this Framework is moved to start level one (1). Any
+	 * exceptions that occur during bundle starting must be wrapped in a
+	 * {@link BundleException} and then published as a framework event of type
+	 * {@link FrameworkEvent#ERROR}</li>
+	 * <li>This Framework's state is set to {@link #ACTIVE}.</li>
+	 * <li>A framework event of type {@link FrameworkEvent#STARTED} is fired</li>
+	 * </ol>
+	 * 
+	 * @throws BundleException If this Framework could not be started.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see "Start Level Specification"
+	 */
+	void start() throws BundleException;
+
+	/**
+	 * Start this Framework.
+	 * 
+	 * <p>
+	 * Calling this method is the same as calling {@link #start()}. There are no
+	 * start options for the Framework.
+	 * 
+	 * @param options Ignored. There are no start options for the Framework.
+	 * @throws BundleException If this Framework could not be started.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #start()
+	 */
+	void start(int options) throws BundleException;
+
+	/**
+	 * Stop this Framework.
+	 * 
+	 * <p>
+	 * The method returns immediately to the caller after initiating the
+	 * following steps to be taken on another thread.
+	 * <ol>
+	 * <li>This Framework's state is set to {@link #STOPPING}.</li>
+	 * <li>All installed bundles must be stopped without changing each bundle's
+	 * persistent <i>autostart setting</i>. The start level of this Framework is
+	 * moved to start level zero (0), as described in the <i>Start Level
+	 * Specification</i>. Any exceptions that occur during bundle stopping must
+	 * be wrapped in a {@link BundleException} and then published as a framework
+	 * event of type {@link FrameworkEvent#ERROR}</li>
+	 * <li>Unregister all services registered by this Framework.</li>
+	 * <li>Event handling is disabled.</li>
+	 * <li>This Framework's state is set to {@link #RESOLVED}.</li>
+	 * <li>All resources held by this Framework are released. This includes
+	 * threads, bundle class loaders, open files, etc.</li>
+	 * <li>Notify all threads that are waiting at {@link #waitForStop(long)
+	 * waitForStop} that the stop operation has completed.</li>
+	 * </ol>
+	 * <p>
+	 * After being stopped, this Framework may be discarded, initialized or
+	 * started.
+	 * 
+	 * @throws BundleException If stopping this Framework could not be
+	 *         initiated.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see "Start Level Specification"
+	 */
+	void stop() throws BundleException;
+
+	/**
+	 * Stop this Framework.
+	 * 
+	 * <p>
+	 * Calling this method is the same as calling {@link #stop()}. There are no
+	 * stop options for the Framework.
+	 * 
+	 * @param options Ignored. There are no stop options for the Framework.
+	 * @throws BundleException If stopping this Framework could not be
+	 *         initiated.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,EXECUTE]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see #stop()
+	 */
+	void stop(int options) throws BundleException;
+
+	/**
+	 * The Framework cannot be uninstalled.
+	 * 
+	 * <p>
+	 * This method always throws a BundleException.
+	 * 
+	 * @throws BundleException This Framework cannot be uninstalled.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 */
+	void uninstall() throws BundleException;
+
+	/**
+	 * Stop and restart this Framework.
+	 * 
+	 * <p>
+	 * The method returns immediately to the caller after initiating the
+	 * following steps to be taken on another thread.
+	 * <ol>
+	 * <li>Perform the steps in the {@link #stop()} method to stop this
+	 * Framework.</li>
+	 * <li>Perform the steps in the {@link #start()} method to start this
+	 * Framework.</li>
+	 * </ol>
+	 * 
+	 * @throws BundleException If stopping and restarting this Framework could
+	 *         not be initiated.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 */
+	void update() throws BundleException;
+
+	/**
+	 * Stop and restart this Framework.
+	 * 
+	 * <p>
+	 * Calling this method is the same as calling {@link #update()} except that
+	 * any provided InputStream is immediately closed.
+	 * 
+	 * @param in Any provided InputStream is immediately closed before returning
+	 *        from this method and otherwise ignored.
+	 * @throws BundleException If stopping and restarting this Framework could
+	 *         not be initiated.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,LIFECYCLE]}, and the Java
+	 *         Runtime Environment supports permissions.
+	 */
+	void update(InputStream in) throws BundleException;
+
+	/**
+	 * Returns the Framework unique identifier. This Framework is assigned the
+	 * unique identifier zero (0) since this Framework is also a System Bundle.
+	 * 
+	 * @return 0.
+	 * @see Bundle#getBundleId()
+	 */
+	long getBundleId();
+
+	/**
+	 * Returns the Framework location identifier. This Framework is assigned the
+	 * unique location &quot;{@code System Bundle}&quot; since this
+	 * Framework is also a System Bundle.
+	 * 
+	 * @return The string &quot;{@code System Bundle}&quot;.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code AdminPermission[this,METADATA]}, and the Java Runtime
+	 *         Environment supports permissions.
+	 * @see Bundle#getLocation()
+	 * @see Constants#SYSTEM_BUNDLE_LOCATION
+	 */
+	String getLocation();
+
+	/**
+	 * Returns the symbolic name of this Framework. The symbolic name is unique
+	 * for the implementation of the framework. However, the symbolic name
+	 * &quot;{@code system.bundle}&quot; must be recognized as an alias to
+	 * the implementation-defined symbolic name since this Framework is also a
+	 * System Bundle.
+	 * 
+	 * @return The symbolic name of this Framework.
+	 * @see Bundle#getSymbolicName()
+	 * @see Constants#SYSTEM_BUNDLE_SYMBOLICNAME
+	 */
+	String getSymbolicName();
+
+	/**
+	 * Returns {@code null} as a framework implementation does not have a
+	 * proper bundle from which to return entry paths.
+	 * 
+	 * @param path Ignored.
+	 * @return {@code null} as a framework implementation does not have a
+	 *         proper bundle from which to return entry paths.
+	 */
+	Enumeration<String> getEntryPaths(String path);
+
+	/**
+	 * Returns {@code null} as a framework implementation does not have a
+	 * proper bundle from which to return an entry.
+	 * 
+	 * @param path Ignored.
+	 * @return {@code null} as a framework implementation does not have a
+	 *         proper bundle from which to return an entry.
+	 */
+	URL getEntry(String path);
+
+	/**
+	 * Returns {@code null} as a framework implementation does not have a proper
+	 * bundle from which to return entries.
+	 * 
+	 * @param path Ignored.
+	 * @param filePattern Ignored.
+	 * @param recurse Ignored.
+	 * @return {@code null} as a framework implementation does not have a proper
+	 *         bundle from which to return entries.
+	 */
+	Enumeration<URL> findEntries(String path, String filePattern,
+			boolean recurse);
+
+	/**
+	 * Adapt this Framework to the specified type.
+	 * 
+	 * <p>
+	 * Adapting this Framework to the specified type may require certain checks,
+	 * including security checks, to succeed. If a check does not succeed, then
+	 * this Framework cannot be adapted and {@code null} is returned. If this
+	 * Framework is not {@link #init() initialized}, then {@code null} is
+	 * returned if the specified type is one of the OSGi defined types to which
+	 * a system bundle can be adapted.
+	 * 
+	 * @param <A> The type to which this Framework is to be adapted.
+	 * @param type Class object for the type to which this Framework is to be
+	 *        adapted.
+	 * @return The object, of the specified type, to which this Framework has
+	 *         been adapted or {@code null} if this Framework cannot be adapted
+	 */
+	<A> A adapt(Class<A> type);
+}
diff --git a/main/src/main/java/org/osgi/framework/launch/FrameworkFactory.java b/main/src/main/java/org/osgi/framework/launch/FrameworkFactory.java
new file mode 100644
index 0000000000..649ef4b43e
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/launch/FrameworkFactory.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.launch;
+
+import java.util.Map;
+
+import org.osgi.framework.Bundle;
+
+/**
+ * A factory for creating {@link Framework} instances.
+ * 
+ * <p>
+ * A framework implementation jar must contain the following resource:
+ * 
+ * <pre>
+ * /META-INF/services/org.osgi.framework.launch.FrameworkFactory
+ * </pre>
+ * 
+ * This UTF-8 encoded resource must contain the name of the framework
+ * implementation's FrameworkFactory implementation class. Space and tab
+ * characters, including blank lines, in the resource must be ignored. The
+ * number sign ('#' &#92;u0023) and all characters following it on each line are
+ * a comment and must be ignored.
+ * 
+ * <p>
+ * Launchers can find the name of the FrameworkFactory implementation class in
+ * the resource and then load and construct a FrameworkFactory object for the
+ * framework implementation. The FrameworkFactory implementation class must have
+ * a public, no-argument constructor. Java&#8482; SE 6 introduced the
+ * {@code ServiceLoader} class which can create a FrameworkFactory instance
+ * from the resource.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: c370e19dba77231f0dbf1601218ad97b20391ea0 $
+ */
+public interface FrameworkFactory {
+
+	/**
+	 * Create a new {@link Framework} instance.
+	 * 
+	 * @param configuration The framework properties to configure the new
+	 *        framework instance. If framework properties are not provided by
+	 *        the configuration argument, the created framework instance must
+	 *        use some reasonable default configuration appropriate for the
+	 *        current VM. For example, the system packages for the current
+	 *        execution environment should be properly exported. The specified
+	 *        configuration argument may be {@code null}. The created
+	 *        framework instance must copy any information needed from the
+	 *        specified configuration argument since the configuration argument
+	 *        can be changed after the framework instance has been created.
+	 * @return A new, configured {@link Framework} instance. The framework
+	 *         instance must be in the {@link Bundle#INSTALLED} state.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}, and the Java Runtime Environment
+	 *         supports permissions.
+	 */
+	Framework newFramework(Map<String, String> configuration);
+}
diff --git a/main/src/main/java/org/osgi/framework/launch/package-info.java b/main/src/main/java/org/osgi/framework/launch/package-info.java
new file mode 100644
index 0000000000..7c0fadeb9a
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/launch/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Launch Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.framework.launch; version="[1.0,2.0)"}
+ * 
+ * @version $Id: 4911f653268fd76aa6318f37f09f58e7ec43a733 $
+ */
+
+package org.osgi.framework.launch;
diff --git a/main/src/main/java/org/osgi/framework/launch/packageinfo b/main/src/main/java/org/osgi/framework/launch/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/launch/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/framework/package-info.java b/main/src/main/java/org/osgi/framework/package-info.java
new file mode 100644
index 0000000000..467b0c7c17
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Package Version 1.6.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.framework; version="[1.6,2.0)"}
+ * 
+ * @version $Id: d5e6bdc8efa522dd450cb631b0a13e1157e4a104 $
+ */
+
+package org.osgi.framework;
diff --git a/main/src/main/java/org/osgi/framework/packageinfo b/main/src/main/java/org/osgi/framework/packageinfo
new file mode 100644
index 0000000000..fec6063b13
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/packageinfo
@@ -0,0 +1 @@
+version 1.6
diff --git a/main/src/main/java/org/osgi/framework/startlevel/BundleStartLevel.java b/main/src/main/java/org/osgi/framework/startlevel/BundleStartLevel.java
new file mode 100644
index 0000000000..d22d3efb64
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/startlevel/BundleStartLevel.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.startlevel;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+
+/**
+ * Query and modify the start level information for a bundle. The start level
+ * object for a bundle can be obtained by calling {@link Bundle#adapt(Class)
+ * bundle.adapt(BundleStartLevel.class)} on the bundle.
+ * 
+ * <p>
+ * The bundle associated with this BundleStartLevel object can be obtained by
+ * calling {@link BundleReference#getBundle()}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 9a000be191fe3cb4ae82535a30940db0340d5356 $
+ */
+public interface BundleStartLevel extends BundleReference {
+	/**
+	 * Return the assigned start level value for the bundle.
+	 * 
+	 * @return The start level value of the bundle.
+	 * @see #setStartLevel(int)
+	 * @throws IllegalStateException If the bundle has been uninstalled.
+	 */
+	int getStartLevel();
+
+	/**
+	 * Assign a start level value to the bundle.
+	 * 
+	 * <p>
+	 * The bundle will be assigned the specified start level. The start level
+	 * value assigned to the bundle will be persistently recorded by the
+	 * Framework.
+	 * <p>
+	 * If the new start level for the bundle is lower than or equal to the
+	 * active start level of the Framework and the bundle's autostart setting
+	 * indicates this bundle must be started, the Framework will start the
+	 * bundle as described in the {@link Bundle#start(int)} method using the
+	 * {@link Bundle#START_TRANSIENT} option. The
+	 * {@link Bundle#START_ACTIVATION_POLICY} option must also be used if
+	 * {@link #isActivationPolicyUsed()} returns {@code true}. The actual
+	 * starting of the bundle must occur asynchronously.
+	 * <p>
+	 * If the new start level for the bundle is higher than the active start
+	 * level of the Framework, the Framework will stop the bundle as described
+	 * in the {@link Bundle#stop(int)} method using the
+	 * {@link Bundle#STOP_TRANSIENT} option. The actual stopping of the bundle
+	 * must occur asynchronously.
+	 * 
+	 * @param startlevel The new start level for the bundle.
+	 * @throws IllegalArgumentException If the specified start level is less
+	 *         than or equal to zero, or if the bundle is the system bundle.
+	 * @throws IllegalStateException If the bundle has been uninstalled.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[bundle,EXECUTE]} and the Java runtime
+	 *         environment supports permissions.
+	 */
+	void setStartLevel(int startlevel);
+
+	/**
+	 * Returns whether the bundle's autostart setting indicates it must be
+	 * started.
+	 * <p>
+	 * The autostart setting of a bundle indicates whether the bundle is to be
+	 * started when its start level is reached.
+	 * 
+	 * @return {@code true} if the autostart setting of the bundle indicates it
+	 *         is to be started. {@code false} otherwise.
+	 * @throws IllegalStateException If this bundle has been uninstalled.
+	 * @see Bundle#START_TRANSIENT
+	 */
+	boolean isPersistentlyStarted();
+
+	/**
+	 * Returns whether the bundle's autostart setting indicates that the
+	 * activation policy declared in the bundle manifest must be used.
+	 * <p>
+	 * The autostart setting of a bundle indicates whether the bundle's declared
+	 * activation policy is to be used when the bundle is started.
+	 * 
+	 * @return {@code true} if the bundle's autostart setting indicates the
+	 *         activation policy declared in the manifest must be used.
+	 *         {@code false} if the bundle must be eagerly activated.
+	 * @throws IllegalStateException If the bundle has been uninstalled.
+	 * @see Bundle#START_ACTIVATION_POLICY
+	 */
+	boolean isActivationPolicyUsed();
+}
diff --git a/main/src/main/java/org/osgi/framework/startlevel/FrameworkStartLevel.java b/main/src/main/java/org/osgi/framework/startlevel/FrameworkStartLevel.java
new file mode 100644
index 0000000000..adb51ecb29
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/startlevel/FrameworkStartLevel.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.startlevel;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+import org.osgi.framework.FrameworkListener;
+
+/**
+ * Query and modify the start level information for the framework. The start
+ * level object for the framework can be obtained by calling
+ * {@link Bundle#adapt(Class) bundle.adapt(FrameworkStartLevel.class)} on the
+ * system bundle. Only the system bundle can be adapted to a FrameworkStartLevel
+ * object.
+ * 
+ * <p>
+ * The system bundle associated with this FrameworkStartLevel object can be
+ * obtained by calling {@link BundleReference#getBundle()}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 2bca22671674ba50b8c6801d5d1df8e291fe2a9d $
+ */
+public interface FrameworkStartLevel extends BundleReference {
+	/**
+	 * Return the active start level value of the Framework.
+	 * 
+	 * If the Framework is in the process of changing the start level this
+	 * method must return the active start level if this differs from the
+	 * requested start level.
+	 * 
+	 * @return The active start level value of the Framework.
+	 */
+	int getStartLevel();
+
+	/**
+	 * Modify the active start level of the Framework and notify when complete.
+	 * 
+	 * <p>
+	 * The Framework will move to the requested start level. This method will
+	 * return immediately to the caller and the start level change will occur
+	 * asynchronously on another thread. The specified {@code FrameworkListener}
+	 * s are notified, in the order specified, when the start level change is
+	 * complete. When the start level change completes normally, each specified
+	 * {@code FrameworkListener} will be called with a Framework event of type
+	 * {@code FrameworkEvent.STARTLEVEL_CHANGED}. If the start level change does
+	 * not complete normally, each specified {@code FrameworkListener} will be
+	 * called with a Framework event of type {@code FrameworkEvent.ERROR}.
+	 * 
+	 * <p>
+	 * If the specified start level is higher than the active start level, the
+	 * Framework will continue to increase the start level until the Framework
+	 * has reached the specified start level.
+	 * 
+	 * At each intermediate start level value on the way to and including the
+	 * target start level, the Framework must:
+	 * <ol>
+	 * <li>Change the active start level to the intermediate start level value.
+	 * <li>Start bundles at the intermediate start level whose autostart setting
+	 * indicate they must be started. They are started as described in the
+	 * {@link Bundle#start(int)} method using the {@link Bundle#START_TRANSIENT}
+	 * option. The {@link Bundle#START_ACTIVATION_POLICY} option must also be
+	 * used if {@link BundleStartLevel#isActivationPolicyUsed()} returns
+	 * {@code true} for the bundle.
+	 * </ol>
+	 * When this process completes after the specified start level is reached,
+	 * the Framework will fire a Framework event of type
+	 * {@code FrameworkEvent.STARTLEVEL_CHANGED} to announce it has moved to the
+	 * specified start level.
+	 * 
+	 * <p>
+	 * If the specified start level is lower than the active start level, the
+	 * Framework will continue to decrease the start level until the Framework
+	 * has reached the specified start level.
+	 * 
+	 * At each intermediate start level value on the way to and including the
+	 * specified start level, the framework must:
+	 * <ol>
+	 * <li>Stop bundles at the intermediate start level as described in the
+	 * {@link Bundle#stop(int)} method using the {@link Bundle#STOP_TRANSIENT}
+	 * option.
+	 * <li>Change the active start level to the intermediate start level value.
+	 * </ol>
+	 * When this process completes after the specified start level is reached,
+	 * the Framework will fire a Framework event of type
+	 * {@code FrameworkEvent.STARTLEVEL_CHANGED} to announce it has moved to the
+	 * specified start level.
+	 * 
+	 * <p>
+	 * If the specified start level is equal to the active start level, then no
+	 * bundles are started or stopped, however, the Framework must fire a
+	 * Framework event of type {@code FrameworkEvent.STARTLEVEL_CHANGED} to
+	 * announce it has finished moving to the specified start level. This event
+	 * may arrive before this method returns.
+	 * 
+	 * @param startlevel The requested start level for the Framework.
+	 * @param listeners Zero or more listeners to be notified when the start
+	 *        level change has been completed. The specified listeners do not
+	 *        need to be otherwise registered with the framework. If a specified
+	 *        listener is already registered with the framework, it will be
+	 *        notified twice.
+	 * @throws IllegalArgumentException If the specified start level is less
+	 *         than or equal to zero.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,STARTLEVEL]} and the Java
+	 *         runtime environment supports permissions.
+	 */
+	void setStartLevel(int startlevel, FrameworkListener... listeners);
+
+	/**
+	 * Return the initial start level value that is assigned to a Bundle when it
+	 * is first installed.
+	 * 
+	 * @return The initial start level value for Bundles.
+	 * @see #setInitialBundleStartLevel
+	 */
+	int getInitialBundleStartLevel();
+
+	/**
+	 * Set the initial start level value that is assigned to a Bundle when it is
+	 * first installed.
+	 * 
+	 * <p>
+	 * The initial bundle start level will be set to the specified start level.
+	 * The initial bundle start level value will be persistently recorded by the
+	 * Framework.
+	 * 
+	 * <p>
+	 * When a Bundle is installed via {@code BundleContext.installBundle}, it is
+	 * assigned the initial bundle start level value.
+	 * 
+	 * <p>
+	 * The default initial bundle start level value is 1 unless this method has
+	 * been called to assign a different initial bundle start level value.
+	 * 
+	 * <p>
+	 * This method does not change the start level values of installed bundles.
+	 * 
+	 * @param startlevel The initial start level for newly installed bundles.
+	 * @throws IllegalArgumentException If the specified start level is less
+	 *         than or equal to zero.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,STARTLEVEL]} and the Java
+	 *         runtime environment supports permissions.
+	 */
+	void setInitialBundleStartLevel(int startlevel);
+}
diff --git a/main/src/main/java/org/osgi/framework/startlevel/package-info.java b/main/src/main/java/org/osgi/framework/startlevel/package-info.java
new file mode 100644
index 0000000000..f3cd695e6f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/startlevel/package-info.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Start Level Package Version 1.0.
+ * 
+ * <p>
+ * The Framework Start Level package allows management agents to manage a start
+ * level assigned to each bundle and the active start level of the Framework.
+ * This package is a replacement for the now deprecated
+ * {@code org.osgi.service.startlevel} package.
+ * 
+ * <p>
+ * A start level is defined to be a state of execution in which the Framework
+ * exists. Start level values are defined as unsigned integers with 0 (zero)
+ * being the state where the Framework is not launched. Progressively higher
+ * integral values represent progressively higher start levels. For example, 2
+ * is a higher start level than 1.
+ * 
+ * <p>
+ * {@code AdminPermission} is required to modify start level information.
+ * 
+ * <p>
+ * Start Level support in the Framework includes the ability to modify the
+ * active start level of the Framework and to assign a specific start level to a
+ * bundle. The beginning start level of a Framework is specified via the
+ * {@link org.osgi.framework.Constants#FRAMEWORK_BEGINNING_STARTLEVEL} framework
+ * property when configuring a framework.
+ * 
+ * <p>
+ * When the Framework is first started it must be at start level zero. In this
+ * state, no bundles are running. This is the initial state of the Framework
+ * before it is launched. When the Framework is launched, the Framework will
+ * enter start level one and all bundles which are assigned to start level one
+ * and whose autostart setting indicates the bundle should be started are
+ * started as described in the {@link org.osgi.framework.Bundle#start(int)}
+ * method. The Framework will continue to increase the start level, starting
+ * bundles at each start level, until the Framework has reached a beginning
+ * start level. At this point the Framework has completed starting bundles and
+ * will then fire a Framework event of type
+ * {@link org.osgi.framework.FrameworkEvent#STARTED} to announce it has
+ * completed its launch.
+ * 
+ * <p>
+ * Within a start level, bundles may be started in an order defined by the
+ * Framework implementation. This may be something like ascending
+ * {@link org.osgi.framework.Bundle#getBundleId()} order or an order based upon
+ * dependencies between bundles. A similar but reversed order may be used when
+ * stopping bundles within a start level.
+ * 
+ * <p>
+ * The Framework Start Level package can be used by management bundles to alter
+ * the active start level of the framework.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest. For example:
+ * 
+ * <pre>
+ * Import-Package: org.osgi.framework.startlevel; version=&quot;[1.0,2.0)&quot;
+ * </pre>
+ * 
+ * @version $Id: 270a001c55674ef419794fa4574472b09130af9e $
+ */
+package org.osgi.framework.startlevel;
+
diff --git a/main/src/main/java/org/osgi/framework/startlevel/packageinfo b/main/src/main/java/org/osgi/framework/startlevel/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/startlevel/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleCapability.java b/main/src/main/java/org/osgi/framework/wiring/BundleCapability.java
new file mode 100644
index 0000000000..c49f0acfae
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleCapability.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.util.Map;
+
+/**
+ * A capability that has been declared from a {@link BundleRevision bundle
+ * revision}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 0fde13c3228af1aa97872b37ccf0aa6e23123b11 $
+ */
+public interface BundleCapability {
+	/**
+	 * Returns the name space of this capability.
+	 * 
+	 * @return The name space of this capability.
+	 */
+	String getNamespace();
+
+	/**
+	 * Returns the directives of this capability.
+	 * 
+	 * @return An unmodifiable map of directive names to directive values for
+	 *         this capability, or an empty map if this capability has no
+	 *         directives.
+	 */
+	Map<String, String> getDirectives();
+
+	/**
+	 * Returns the attributes of this capability.
+	 * 
+	 * @return An unmodifiable map of attribute names to attribute values for
+	 *         this capability, or an empty map if this capability has no
+	 *         attributes.
+	 */
+	Map<String, Object> getAttributes();
+
+	/**
+	 * Returns the bundle revision declaring this capability.
+	 * 
+	 * @return The bundle revision declaring this capability.
+	 */
+	BundleRevision getRevision();
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleRequirement.java b/main/src/main/java/org/osgi/framework/wiring/BundleRequirement.java
new file mode 100644
index 0000000000..bd637e6180
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleRequirement.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.util.Map;
+
+/**
+ * A requirement that has been declared from a {@link BundleRevision bundle
+ * revision}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 659132c1fac7526240df377ead0e1bc8d4af2e77 $
+ */
+public interface BundleRequirement {
+	/**
+	 * Returns the name space of this requirement.
+	 * 
+	 * @return The name space of this requirement.
+	 */
+	String getNamespace();
+
+	/**
+	 * Returns the directives of this requirement.
+	 * 
+	 * @return An unmodifiable map of directive names to directive values for
+	 *         this requirement, or an empty map if this requirement has no
+	 *         directives.
+	 */
+	Map<String, String> getDirectives();
+
+	/**
+	 * Returns the attributes of this requirement.
+	 * 
+	 * @return An unmodifiable map of attribute names to attribute values for
+	 *         this requirement, or an empty map if this requirement has no
+	 *         attributes.
+	 */
+	Map<String, Object> getAttributes();
+
+	/**
+	 * Returns the bundle revision declaring this requirement.
+	 * 
+	 * @return The bundle revision declaring this requirement.
+	 */
+	BundleRevision getRevision();
+
+	/**
+	 * Returns whether the specified capability matches this requirement.
+	 * 
+	 * @param capability The capability to match to this requirement.
+	 * @return {@code true} if the specified capability has the same
+	 *         {@link #getNamespace() name space} as this requirement and the
+	 *         filter for this requirement matches the
+	 *         {@link BundleCapability#getAttributes() attributes of the
+	 *         specified capability}; {@code false} otherwise.
+	 */
+	boolean matches(BundleCapability capability);
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleRevision.java b/main/src/main/java/org/osgi/framework/wiring/BundleRevision.java
new file mode 100644
index 0000000000..5924dc1fec
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleRevision.java
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.util.List;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Version;
+
+/**
+ * Bundle Revision. When a bundle is installed and each time a bundle is
+ * updated, a new bundle revision of the bundle is created. Since a bundle
+ * update can change the entries in a bundle, different bundle wirings for the
+ * same bundle can be associated with different bundle revisions.
+ * 
+ * <p>
+ * For a bundle that has not been uninstalled, the most recent bundle revision
+ * is defined to be the current bundle revision. A bundle in the UNINSTALLED
+ * state does not have a current revision. The current bundle revision for a
+ * bundle can be obtained by calling {@link Bundle#adapt(Class) bundle.adapt}
+ * (BundleRevision.class). Since a bundle in the UNINSTALLED state does not have
+ * a current revision, adapting such a bundle returns {@code null}.
+ * 
+ * <p>
+ * The framework defines name spaces for {@link #PACKAGE_NAMESPACE package},
+ * {@link #BUNDLE_NAMESPACE bundle} and {@link #HOST_NAMESPACE host}
+ * capabilities and requirements. These name spaces are defined only to express
+ * wiring information by the framework. They must not be used in
+ * {@link Constants#PROVIDE_CAPABILITY Provide-Capability} and
+ * {@link Constants#REQUIRE_CAPABILITY Require-Capability} manifest headers.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 139b3046ebd46c48b03dda8d36f2f9d79e2e616d $
+ */
+public interface BundleRevision extends BundleReference {
+	/**
+	 * Returns the symbolic name for this bundle revision.
+	 * 
+	 * @return The symbolic name for this bundle revision.
+	 * @see Bundle#getSymbolicName()
+	 */
+	String getSymbolicName();
+
+	/**
+	 * Returns the version for this bundle revision.
+	 * 
+	 * @return The version for this bundle revision, or
+	 *         {@link Version#emptyVersion} if this bundle revision has no
+	 *         version information.
+	 * @see Bundle#getVersion()
+	 */
+	Version getVersion();
+
+	/**
+	 * Returns the capabilities declared by this bundle revision.
+	 * 
+	 * @param namespace The name space of the declared capabilities to return or
+	 *        {@code null} to return the declared capabilities from all name
+	 *        spaces.
+	 * @return A list containing a snapshot of the declared
+	 *         {@link BundleCapability}s, or an empty list if this bundle
+	 *         revision declares no capabilities in the specified name space.
+	 *         The list contains the declared capabilities in the order they are
+	 *         specified in the manifest.
+	 */
+	List<BundleCapability> getDeclaredCapabilities(String namespace);
+
+	/**
+	 * Returns the requirements declared by this bundle revision.
+	 * 
+	 * @param namespace The name space of the declared requirements to return or
+	 *        {@code null} to return the declared requirements from all name
+	 *        spaces.
+	 * @return A list containing a snapshot of the declared
+	 *         {@link BundleRequirement}s, or an empty list if this bundle
+	 *         revision declares no requirements in the specified name space.
+	 *         The list contains the declared requirements in the order they are
+	 *         specified in the manifest.
+	 */
+	List<BundleRequirement> getDeclaredRequirements(String namespace);
+
+	/**
+	 * Name space for package capabilities and requirements.
+	 * 
+	 * <p>
+	 * The name of the package is stored in the capability attribute of the same
+	 * name as this name space (osgi.wiring.package). The other
+	 * directives and attributes of the package, from the
+	 * {@link Constants#EXPORT_PACKAGE Export-Package} manifest header, can be
+	 * found in the cabability's {@link BundleCapability#getDirectives()
+	 * directives} and {@link BundleCapability#getAttributes() attributes}. The
+	 * {@link Constants#VERSION_ATTRIBUTE version} capability attribute must
+	 * contain the {@link Version} of the package if one is specified or
+	 * {@link Version#emptyVersion} if not specified. The
+	 * {@link Constants#BUNDLE_SYMBOLICNAME_ATTRIBUTE bundle-symbolic-name}
+	 * capability attribute must contain the
+	 * {@link BundleRevision#getSymbolicName() symbolic name} of the provider if
+	 * one is specified. The {@link Constants#BUNDLE_VERSION_ATTRIBUTE
+	 * bundle-version} capability attribute must contain the
+	 * {@link BundleRevision#getVersion() version} of the provider if one is
+	 * specified or {@link Version#emptyVersion} if not specified.
+	 * 
+	 * <p>
+	 * The package capabilities provided by the system bundle, that is the
+	 * bundle with id zero, must include the package specified by the
+	 * {@link Constants#FRAMEWORK_SYSTEMPACKAGES} and
+	 * {@link Constants#FRAMEWORK_SYSTEMPACKAGES_EXTRA} framework properties as
+	 * well as any other package exported by the framework implementation.
+	 * 
+	 * <p>
+	 * A bundle revision {@link BundleRevision#getDeclaredCapabilities(String)
+	 * declares} zero or more package capabilities (this is, exported packages)
+	 * and {@link BundleRevision#getDeclaredRequirements(String) declares} zero
+	 * or more package requirements.
+	 * <p>
+	 * A bundle wiring {@link BundleWiring#getCapabilities(String) provides}
+	 * zero or more resolved package capabilities (that is, exported packages)
+	 * and {@link BundleWiring#getRequiredWires(String) requires} zero or more
+	 * resolved package requirements (that is, imported packages). The number of
+	 * package wires required by a bundle wiring may change as the bundle wiring
+	 * may dynamically import additional packages.
+	 */
+	String	PACKAGE_NAMESPACE	= "osgi.wiring.package";
+
+	/**
+	 * Name space for bundle capabilities and requirements.
+	 * 
+	 * <p>
+	 * The bundle symbolic name of the bundle is stored in the capability
+	 * attribute of the same name as this name space (osgi.wiring.bundle).
+	 * The other directives and attributes of the bundle, from the
+	 * {@link Constants#BUNDLE_SYMBOLICNAME Bundle-SymbolicName} manifest
+	 * header, can be found in the cabability's
+	 * {@link BundleCapability#getDirectives() directives} and
+	 * {@link BundleCapability#getAttributes() attributes}. The
+	 * {@link Constants#BUNDLE_VERSION_ATTRIBUTE bundle-version} capability
+	 * attribute must contain the {@link Version} of the bundle from the
+	 * {@link Constants#BUNDLE_VERSION Bundle-Version} manifest header if one is
+	 * specified or {@link Version#emptyVersion} if not specified.
+	 * 
+	 * <p>
+	 * A non-fragment revision
+	 * {@link BundleRevision#getDeclaredCapabilities(String) declares} exactly
+	 * one<sup>&#8224;</sup> bundle capability (that is, the bundle can be
+	 * required by another bundle). A fragment revision must not declare a
+	 * bundle capability.
+	 * 
+	 * <p>
+	 * A bundle wiring for a non-fragment revision
+	 * {@link BundleWiring#getCapabilities(String) provides} exactly
+	 * one<sup>&#8224;</sup> bundle capability (that is, the bundle can be
+	 * required by another bundle) and
+	 * {@link BundleWiring#getRequiredWires(String) requires} zero or more
+	 * bundle capabilities (that is, requires other bundles).
+	 * 
+	 * <p>
+	 * &#8224; A bundle with no bundle symbolic name (that is, a bundle with
+	 * {@link Constants#BUNDLE_MANIFESTVERSION Bundle-ManifestVersion}
+	 * {@literal <} 2) must not provide a bundle capability.
+	 */
+	String	BUNDLE_NAMESPACE	= "osgi.wiring.bundle";
+
+	/**
+	 * Name space for host capabilities and requirements.
+	 * 
+	 * <p>
+	 * The bundle symbolic name of the bundle is stored in the capability
+	 * attribute of the same name as this name space (osgi.wiring.host).
+	 * The other directives and attributes of the bundle, from the
+	 * {@link Constants#BUNDLE_SYMBOLICNAME Bundle-SymbolicName} manifest
+	 * header, can be found in the cabability's
+	 * {@link BundleCapability#getDirectives() directives} and
+	 * {@link BundleCapability#getAttributes() attributes}. The
+	 * {@link Constants#BUNDLE_VERSION_ATTRIBUTE bundle-version} capability
+	 * attribute must contain the {@link Version} of the bundle from the
+	 * {@link Constants#BUNDLE_VERSION Bundle-Version} manifest header if one is
+	 * specified or {@link Version#emptyVersion} if not specified.
+	 * 
+	 * <p>
+	 * A non-fragment revision
+	 * {@link BundleRevision#getDeclaredCapabilities(String) declares} zero or
+	 * one<sup>&#8224;</sup> host capability if the bundle
+	 * {@link Constants#FRAGMENT_ATTACHMENT_DIRECTIVE allows fragments to be
+	 * attached}. A fragment revision must
+	 * {@link BundleRevision#getDeclaredRequirements(String) declare} exactly
+	 * one host requirement.
+	 * 
+	 * <p>
+	 * A bundle wiring for a non-fragment revision
+	 * {@link BundleWiring#getCapabilities(String) provides} zero or
+	 * one<sup>&#8224;</sup> host capability if the bundle
+	 * {@link Constants#FRAGMENT_ATTACHMENT_DIRECTIVE allows fragments to be
+	 * attached}. A bundle wiring for a fragment revision
+	 * {@link BundleWiring#getRequiredWires(String) requires} a host capability
+	 * for each host to which it is attached.
+	 * 
+	 * <p>
+	 * &#8224; A bundle with no bundle symbolic name (that is, a bundle with
+	 * {@link Constants#BUNDLE_MANIFESTVERSION Bundle-ManifestVersion}
+	 * {@literal <} 2) must not provide a host capability.
+	 */
+	String	HOST_NAMESPACE		= "osgi.wiring.host";
+
+	/**
+	 * Returns the special types of this bundle revision. The bundle revision
+	 * type values are:
+	 * <ul>
+	 * <li>{@link #TYPE_FRAGMENT}
+	 * </ul>
+	 * 
+	 * A bundle revision may be more than one type at a time. A type code is
+	 * used to identify the bundle revision type for future extendability.
+	 * 
+	 * <p>
+	 * If this bundle revision is not one or more of the defined types then 0 is
+	 * returned.
+	 * 
+	 * @return The special types of this bundle revision. The type values are
+	 *         ORed together.
+	 */
+	int getTypes();
+
+	/**
+	 * Bundle revision type indicating the bundle revision is a fragment.
+	 * 
+	 * @see #getTypes()
+	 */
+	int	TYPE_FRAGMENT	= 0x00000001;
+
+	/**
+	 * Returns the bundle wiring which is using this bundle revision.
+	 * 
+	 * @return The bundle wiring which is using this bundle revision or
+	 *         {@code null} if no bundle wiring is using this bundle revision.
+	 * @see BundleWiring#getRevision()
+	 */
+	BundleWiring getWiring();
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleRevisions.java b/main/src/main/java/org/osgi/framework/wiring/BundleRevisions.java
new file mode 100644
index 0000000000..a619dbb7cc
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleRevisions.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.util.List;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+
+/**
+ * The {@link BundleRevision bundle revisions} of a bundle. When a bundle is
+ * installed and each time a bundle is updated, a new bundle revision of the
+ * bundle is created. For a bundle that has not been uninstalled, the most
+ * recent bundle revision is defined to be the current bundle revision. A bundle
+ * in the UNINSTALLED state does not have a current revision. An in use bundle
+ * revision is associated with an {@link BundleWiring#isInUse() in use}
+ * {@link BundleWiring}. The current bundle revision, if there is one, and all
+ * in use bundle revisions are returned.
+ * 
+ * <p>
+ * The bundle revisions for a bundle can be obtained by calling
+ * {@link Bundle#adapt(Class) bundle.adapt}({@link BundleRevisions}.class).
+ * {@link #getRevisions()} on the bundle.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 1d95ad10f0f08b100f8ee2485bdd34120032c7af $
+ */
+public interface BundleRevisions extends BundleReference {
+	/**
+	 * Return the bundle revisions for the {@link BundleReference#getBundle()
+	 * referenced} bundle.
+	 * 
+	 * <p>
+	 * The result is a list containing the current bundle revision, if there is
+	 * one, and all in use bundle revisions. The list may also contain
+	 * intermediate bundle revisions which are not in use.
+	 * 
+	 * <p>
+	 * The list is ordered in reverse chronological order such that the first
+	 * item is the most recent bundle revision and last item is the oldest
+	 * bundle revision.
+	 * 
+	 * <p>
+	 * Generally the list will have at least one bundle revision for the bundle:
+	 * the current bundle revision. However, for an uninstalled bundle with no
+	 * in use bundle revisions, the list may be empty.
+	 * 
+	 * @return A list containing a snapshot of the {@link BundleRevision}s for
+	 *         the referenced bundle.
+	 */
+	List<BundleRevision> getRevisions();
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleWire.java b/main/src/main/java/org/osgi/framework/wiring/BundleWire.java
new file mode 100644
index 0000000000..1b19e4cbcd
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleWire.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) OSGi Alliance (2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+/**
+ * A wire connecting a {@link BundleCapability} to a {@link BundleRequirement}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 4f936a84065762ec3267a44f86ae01b0150e44ce $
+ */
+public interface BundleWire {
+	/**
+	 * Returns the {@link BundleCapability} for this wire.
+	 * 
+	 * @return The {@link BundleCapability} for this wire.
+	 */
+	BundleCapability getCapability();
+
+	/**
+	 * Return the {@link BundleRequirement} for this wire.
+	 * 
+	 * @return The {@link BundleRequirement} for this wire.
+	 */
+	BundleRequirement getRequirement();
+
+	/**
+	 * Returns the bundle wiring {@link BundleWiring#getProvidedWires(String)
+	 * providing} the {@link #getCapability() capability}.
+	 * 
+	 * <p>
+	 * The bundle revision referenced by the returned bundle wiring may differ
+	 * from the bundle revision reference by the {@link #getCapability()
+	 * capability}.
+	 * 
+	 * @return The bundle wiring providing the capability. If the bundle wiring
+	 *         providing the capability is not {@link BundleWiring#isInUse() in
+	 *         use}, {@code null} will be returned.
+	 */
+	BundleWiring getProviderWiring();
+
+	/**
+	 * Returns the bundle wiring who
+	 * {@link BundleWiring#getRequiredWires(String) requires} the
+	 * {@link #getCapability() capability}.
+	 * 
+	 * <p>
+	 * The bundle revision referenced by the returned bundle wiring may differ
+	 * from the bundle revision reference by the {@link #getRequirement()
+	 * requirement}.
+	 * 
+	 * @return The bundle wiring whose requirement is wired to the capability.
+	 *         If the bundle wiring requiring the capability is not
+	 *         {@link BundleWiring#isInUse() in use}, {@code null} will be
+	 *         returned.
+	 */
+	BundleWiring getRequirerWiring();
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/BundleWiring.java b/main/src/main/java/org/osgi/framework/wiring/BundleWiring.java
new file mode 100644
index 0000000000..8d8956a181
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/BundleWiring.java
@@ -0,0 +1,344 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.net.URL;
+import java.util.Collection;
+import java.util.List;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+
+/**
+ * A wiring for a bundle. Each time a bundle is resolved, a new bundle wiring
+ * for the bundle is created. A bundle wiring is associated with a bundle
+ * revision and represents the dependencies with other bundle wirings.
+ * 
+ * <p>
+ * The bundle wiring for a bundle is the {@link #isCurrent() current} bundle
+ * wiring if it is the most recent bundle wiring for the current bundle
+ * revision. A bundle wiring is {@link #isInUse() in use} if it is the current
+ * bundle wiring or if some other in use bundle wiring is dependent upon it. For
+ * example, another bundle wiring is wired to a capability provided by the
+ * bundle wiring. An in use bundle wiring for a non-fragment bundle has a class
+ * loader. All bundles with non-current, in use bundle wirings are considered
+ * removal pending. Once a bundle wiring is no longer in use, it is considered
+ * stale and is discarded by the framework.
+ * 
+ * <p>
+ * The current bundle wiring for a bundle can be obtained by calling
+ * {@link Bundle#adapt(Class) bundle.adapt}(BundleWiring.class). A bundle in the
+ * INSTALLED or UNINSTALLED state does not have a current wiring, adapting such
+ * a bundle returns {@code null}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 58b8ec3bb9649387d4ccba1070f034f217d06ea2 $
+ */
+public interface BundleWiring extends BundleReference {
+	/**
+	 * Returns {@code true} if this bundle wiring is the current bundle wiring.
+	 * The bundle wiring for a bundle is the current bundle wiring if it is the
+	 * most recent bundle wiring for the current bundle revision. All bundles
+	 * with non-current, in use bundle wirings are considered
+	 * {@link FrameworkWiring#getRemovalPendingBundles() removal pending}.
+	 * 
+	 * @return {@code true} if this bundle wiring is the current bundle wiring;
+	 *         {@code false} otherwise.
+	 */
+	boolean isCurrent();
+
+	/**
+	 * Returns {@code true} if this bundle wiring is in use. A bundle wiring is
+	 * in use if it is the {@link #isCurrent() current} wiring or if some other
+	 * in use bundle wiring is dependent upon it. Once a bundle wiring is no
+	 * longer in use, it is considered stale and is discarded by the framework.
+	 * 
+	 * @return {@code true} if this bundle wiring is in use; {@code false}
+	 *         otherwise.
+	 */
+	boolean isInUse();
+
+	/**
+	 * Returns the capabilities provided by this bundle wiring.
+	 * 
+	 * <p>
+	 * A capability may not be required by any bundle wiring and thus there may
+	 * be no {@link #getProvidedWires(String) wires} for the capability.
+	 * 
+	 * <p>
+	 * A bundle wiring for a non-fragment revision provides a subset of the
+	 * declared capabilities from the bundle revision and all attached fragment
+	 * revisions. Not all declared capabilities may be provided since some may
+	 * be discarded. For example, if a package is declared to be exported and
+	 * import, only one is selected and the other is discarded.
+	 * 
+	 * @param namespace The name space of the capabilities to return or
+	 *        {@code null} to return the capabilities from all name spaces.
+	 * @return A list containing a snapshot of the {@link BundleCapability}s, or
+	 *         an empty list if this bundle wiring provides no capabilities in
+	 *         the specified name space. If this bundle wiring is not
+	 *         {@link #isInUse() in use}, {@code null} will be returned. For a
+	 *         given name space, the list contains the wires in the order the
+	 *         capabilities were specified in the manifests of the
+	 *         {@link #getRevision() bundle revision} and the attached fragments
+	 *         of this bundle wiring. There is no ordering defined between
+	 *         capabilities in different name spaces.
+	 */
+	List<BundleCapability> getCapabilities(String namespace);
+
+	/**
+	 * Returns the requirements of this bundle wiring.
+	 * 
+	 * <p>
+	 * A bundle wiring for a non-fragment revision has a subset of the declared
+	 * requirements from the bundle revision and all attached fragment
+	 * revisions. Not all declared requirements may be present since some may be
+	 * discarded. For example, if a package is declared to be optionally
+	 * imported and is not actually imported, the requirement must be discarded.
+	 * 
+	 * @param namespace The name space of the requirements to return or
+	 *        {@code null} to return the requirements from all name spaces.
+	 * @return A list containing a snapshot of the {@link BundleRequirement}s,
+	 *         or an empty list if this bundle wiring uses no requirements in
+	 *         the specified name space. If this bundle wiring is not
+	 *         {@link #isInUse() in use}, {@code null} will be returned. For a
+	 *         given name space, the list contains the wires in the order the
+	 *         requirements were specified in the manifests of the
+	 *         {@link #getRevision() bundle revision} and the attached fragments
+	 *         of this bundle wiring. There is no ordering defined between
+	 *         requirements in different name spaces.
+	 */
+	List<BundleRequirement> getRequirements(String namespace);
+
+	/**
+	 * Returns the {@link BundleWire}s to the provided {@link BundleCapability
+	 * capabilities} of this bundle wiring.
+	 * 
+	 * @param namespace The name space of the capabilities for which to return
+	 *        wires or {@code null} to return the wires for the capabilities in
+	 *        all name spaces.
+	 * @return A list containing a snapshot of the {@link BundleWire}s for the
+	 *         {@link BundleCapability capabilities} of this bundle wiring, or
+	 *         an empty list if this bundle wiring has no capabilities in the
+	 *         specified name space. If this bundle wiring is not
+	 *         {@link #isInUse() in use}, {@code null} will be returned. For a
+	 *         given name space, the list contains the wires in the order the
+	 *         capabilities were specified in the manifests of the
+	 *         {@link #getRevision() bundle revision} and the attached fragments
+	 *         of this bundle wiring. There is no ordering defined between
+	 *         capabilities in different name spaces.
+	 */
+	List<BundleWire> getProvidedWires(String namespace);
+
+	/**
+	 * Returns the {@link BundleWire}s to the {@link BundleRequirement
+	 * requirements} in use by this bundle wiring.
+	 * 
+	 * <p>
+	 * This method may return different results if this bundle wiring adds wires
+	 * to more requirements. For example, dynamically importing a package will
+	 * establish a new wire to the dynamically imported package.
+	 * 
+	 * @param namespace The name space of the requirements for which to return
+	 *        wires or {@code null} to return the wires for the requirements in
+	 *        all name spaces.
+	 * @return A list containing a snapshot of the {@link BundleWire}s for the
+	 *         {@link BundleRequirement requirements} of this bundle wiring, or
+	 *         an empty list if this bundle wiring has no requirements in the
+	 *         specified name space. If this bundle wiring is not
+	 *         {@link #isInUse() in use}, {@code null} will be returned. For a
+	 *         given name space, the list contains the wires in the order the
+	 *         requirements were specified in the manifests of the
+	 *         {@link #getRevision() bundle revision} and the attached fragments
+	 *         of this bundle wiring. There is no ordering defined between
+	 *         requirements in different name spaces.
+	 */
+	List<BundleWire> getRequiredWires(String namespace);
+
+	/**
+	 * Returns the bundle revision for the bundle in this bundle wiring. Since a
+	 * bundle update can change the entries in a bundle, different bundle
+	 * wirings for the same bundle can have different bundle revisions.
+	 * 
+	 * <p>
+	 * The bundle object {@link BundleReference#getBundle() referenced} by the
+	 * returned {@code BundleRevision} may return different information than the
+	 * returned {@code BundleRevision} since the returned {@code BundleRevision}
+	 * may refer to an older revision of the bundle.
+	 * 
+	 * @return The bundle revision for this bundle wiring.
+	 * @see BundleRevision#getWiring()
+	 */
+	BundleRevision getRevision();
+
+	/**
+	 * Returns the class loader for this bundle wiring. Since a bundle refresh
+	 * creates a new bundle wiring for a bundle, different bundle wirings for
+	 * the same bundle will have different class loaders.
+	 * 
+	 * @return The class loader for this bundle wiring. If this bundle wiring is
+	 *         not {@link #isInUse() in use} or this bundle wiring is for a
+	 *         fragment revision, {@code null} will be returned.
+	 * @throws SecurityException If the caller does not have the appropriate
+	 *         {@code RuntimePermission("getClassLoader")}, and the Java Runtime
+	 *         Environment supports permissions.
+	 */
+	ClassLoader getClassLoader();
+
+	/**
+	 * Returns entries in this bundle wiring's {@link #getRevision() bundle
+	 * revision} and its attached fragment revisions. This bundle wiring's class
+	 * loader is not used to search for entries. Only the contents of this
+	 * bundle wiring's bundle revision and its attached fragment revisions are
+	 * searched for the specified entries.
+	 * 
+	 * <p>
+	 * This method takes into account that the &quot;contents&quot; of this
+	 * bundle wiring can have attached fragments. This &quot;bundle space&quot;
+	 * is not a name space with unique members; the same entry name can be
+	 * present multiple times. This method therefore returns a list of URL
+	 * objects. These URLs can come from different JARs but have the same path
+	 * name. This method can either return only entries in the specified path or
+	 * recurse into subdirectories returning entries in the directory tree
+	 * beginning at the specified path.
+	 * 
+	 * <p>
+	 * Note: Jar and zip files are not required to include directory entries.
+	 * URLs to directory entries will not be returned if the bundle contents do
+	 * not contain directory entries.
+	 * 
+	 * @param path The path name in which to look. The path is always relative
+	 *        to the root of this bundle wiring and may begin with
+	 *        &quot;/&quot;. A path value of &quot;/&quot; indicates the root of
+	 *        this bundle wiring.
+	 * @param filePattern The file name pattern for selecting entries in the
+	 *        specified path. The pattern is only matched against the last
+	 *        element of the entry path. If the entry is a directory then the
+	 *        trailing &quot;/&quot; is not used for pattern matching. Substring
+	 *        matching is supported, as specified in the Filter specification,
+	 *        using the wildcard character (&quot;*&quot;). If {@code null} is
+	 *        specified, this is equivalent to &quot;*&quot; and matches all
+	 *        files.
+	 * @param options The options for listing resource names. See
+	 *        {@link #FINDENTRIES_RECURSE}. The method must ignore unrecognized
+	 *        options.
+	 * @return An unmodifiable list of URL objects for each matching entry, or
+	 *         an empty list if no matching entry could be found, if this bundle
+	 *         wiring is for a fragment revision or if the caller does not have
+	 *         the appropriate {@code AdminPermission[bundle,RESOURCE]} and the
+	 *         Java Runtime Environment supports permissions. The list is
+	 *         ordered such that entries from the {@link #getRevision() bundle
+	 *         revision} are returned first followed by the entries from
+	 *         attached fragment revisions in attachment order. If this bundle
+	 *         wiring is not {@link #isInUse() in use}, {@code null} must be
+	 *         returned.
+	 * @see Bundle#findEntries(String, String, boolean)
+	 */
+	List<URL> findEntries(String path, String filePattern, int options);
+
+	/**
+	 * The find entries operation must recurse into subdirectories.
+	 * 
+	 * <p>
+	 * This bit may be set when calling
+	 * {@link #findEntries(String, String, int)} to specify the result must
+	 * include the matching entries from the specified path and its
+	 * subdirectories. If this bit is not set, then the result must only include
+	 * matching entries from the specified path.
+	 * 
+	 * @see #findEntries(String, String, int)
+	 */
+	int	FINDENTRIES_RECURSE	= 0x00000001;
+
+	/**
+	 * Returns the names of resources visible to this bundle wiring's
+	 * {@link #getClassLoader() class loader}. The returned names can be used to
+	 * access the resources via this bundle wiring's class loader.
+	 * 
+	 * <ul>
+	 * <li>Only the resource names for resources in bundle wirings will be
+	 * returned. The names of resources visible to a bundle wiring's parent
+	 * class loader, such as the bootstrap class loader, must not be included in
+	 * the result.
+	 * <li>Only established wires will be examined for resources. This method
+	 * must not cause new wires for dynamic imports to be established.
+	 * </ul>
+	 * 
+	 * @param path The path name in which to look. The path is always relative
+	 *        to the root of this bundle wiring's class loader and may begin
+	 *        with &quot;/&quot;. A path value of &quot;/&quot; indicates the
+	 *        root of this bundle wiring's class loader.
+	 * @param filePattern The file name pattern for selecting resource names in
+	 *        the specified path. The pattern is only matched against the last
+	 *        element of the resource path. If the resource is a directory then
+	 *        the trailing &quot;/&quot; is not used for pattern matching.
+	 *        Substring matching is supported, as specified in the Filter
+	 *        specification, using the wildcard character (&quot;*&quot;). If
+	 *        {@code null} is specified, this is equivalent to &quot;*&quot; and
+	 *        matches all files.
+	 * @param options The options for listing resource names. See
+	 *        {@link #LISTRESOURCES_LOCAL} and {@link #LISTRESOURCES_RECURSE}.
+	 *        This method must ignore unrecognized options.
+	 * @return An unmodifiable collection of resource names for each matching
+	 *         resource, or an empty collection if no matching resource could be
+	 *         found, if this bundle wiring is for a fragment revision or if the
+	 *         caller does not have the appropriate
+	 *         {@code AdminPermission[bundle,RESOURCE]} and the Java Runtime
+	 *         Environment supports permissions. The collection is unordered and
+	 *         must contain no duplicate resource names. If this bundle wiring
+	 *         is not {@link #isInUse() in use}, {@code null} must be returned.
+	 */
+	Collection<String> listResources(String path, String filePattern,
+			int options);
+
+	/**
+	 * The list resource names operation must recurse into subdirectories.
+	 * 
+	 * <p>
+	 * This bit may be set when calling
+	 * {@link #listResources(String, String, int)} to specify the result must
+	 * include the names of matching resources from the specified path and its
+	 * subdirectories. If this bit is not set, then the result must only include
+	 * names of matching resources from the specified path.
+	 * 
+	 * @see #listResources(String, String, int)
+	 */
+	int	LISTRESOURCES_RECURSE	= 0x00000001;
+
+	/**
+	 * The list resource names operation must limit the result to the names of
+	 * matching resources contained in this bundle wiring's
+	 * {@link #getRevision() bundle revision} and its attached fragment
+	 * revisions. The result must not include resource names for resources in
+	 * {@link BundleRevision#PACKAGE_NAMESPACE package} names which are
+	 * {@link #getRequiredWires(String) imported} by this wiring.
+	 * 
+	 * <p>
+	 * This bit may be set when calling
+	 * {@link #listResources(String, String, int)} to specify the result must
+	 * only include the names of matching resources contained in this bundle
+	 * wiring's bundle revision and its attached fragment revisions. If this bit
+	 * is not set, then the result must include the names of matching resources
+	 * reachable from this bundle wiring's class loader which may include the
+	 * names of matching resources contained in imported packages and required
+	 * bundles.
+	 * 
+	 * @see #listResources(String, String, int)
+	 */
+	int	LISTRESOURCES_LOCAL		= 0x00000002;
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/FrameworkWiring.java b/main/src/main/java/org/osgi/framework/wiring/FrameworkWiring.java
new file mode 100644
index 0000000000..046a6c2cff
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/FrameworkWiring.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.framework.wiring;
+
+import java.util.Collection;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+import org.osgi.framework.FrameworkListener;
+
+/**
+ * Query and modify wiring information for the framework. The framework wiring
+ * object for the framework can be obtained by calling
+ * {@link Bundle#adapt(Class) bundle.adapt(FrameworkWiring.class)} on the system
+ * bundle. Only the system bundle can be adapted to a FrameworkWiring object.
+ * 
+ * <p>
+ * The system bundle associated with this FrameworkWiring object can be obtained
+ * by calling {@link BundleReference#getBundle()}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: f9f3f89b5b8d369453d645a52a482a385a2bd520 $
+ */
+public interface FrameworkWiring extends BundleReference {
+	/**
+	 * Refreshes the specified bundles. This forces the update (replacement) or
+	 * removal of packages exported by the specified bundles.
+	 * 
+	 * <p>
+	 * The technique by which the framework refreshes bundles may vary among
+	 * different framework implementations. A permissible implementation is to
+	 * stop and restart the framework.
+	 * 
+	 * <p>
+	 * This method returns to the caller immediately and then performs the
+	 * following steps on a separate thread:
+	 * 
+	 * <ol>
+	 * <li>Compute the {@link #getDependencyClosure(Collection) dependency
+	 * closure} of the specified bundles. If no bundles are specified, compute
+	 * the dependency closure of the {@link #getRemovalPendingBundles() removal
+	 * pending} bundles.
+	 * 
+	 * <li>Each bundle in the dependency closure that is in the {@code ACTIVE}
+	 * state will be stopped as described in the {@code Bundle.stop} method.
+	 * 
+	 * <li>Each bundle in the dependency closure that is in the {@code RESOLVED}
+	 * state is unresolved and thus moved to the {@code INSTALLED} state. The
+	 * effect of this step is that bundles in the dependency closure are no
+	 * longer {@code RESOLVED}.
+	 * 
+	 * <li>Each bundle in the dependency closure that is in the
+	 * {@code UNINSTALLED} state is removed from the dependency closure and is
+	 * now completely removed from the Framework.
+	 * 
+	 * <li>Each bundle in the dependency closure that was in the {@code ACTIVE}
+	 * state prior to Step 2 is started as described in the {@code Bundle.start}
+	 * method, causing all bundles required for the restart to be resolved. It
+	 * is possible that, as a result of the previous steps, packages that were
+	 * previously exported no longer are. Therefore, some bundles may be
+	 * unresolvable until bundles satisfying the dependencies have been
+	 * installed in the Framework.
+	 * </ol>
+	 * 
+	 * <p>
+	 * For any exceptions that are thrown during any of these steps, a framework
+	 * event of type {@code FrameworkEvent.ERROR} is fired containing the
+	 * exception. The source bundle for these events should be the specific
+	 * bundle to which the exception is related. If no specific bundle can be
+	 * associated with the exception then the System Bundle must be used as the
+	 * source bundle for the event. All framework events fired by this method
+	 * are also delivered to the specified {@code FrameworkListener}s in the
+	 * order they are specified.
+	 * 
+	 * <p>
+	 * When this process completes after the bundles are refreshed, the
+	 * Framework will fire a Framework event of type
+	 * {@code FrameworkEvent.PACKAGES_REFRESHED} to announce it has completed
+	 * the bundle refresh. The specified {@code FrameworkListener}s are notified
+	 * in the order specified. Each specified {@code FrameworkListener} will be
+	 * called with a Framework event of type
+	 * {@code FrameworkEvent.PACKAGES_REFRESHED}.
+	 * 
+	 * @param bundles The bundles to be refreshed, or {@code null} to refresh
+	 *        the {@link #getRemovalPendingBundles() removal pending} bundles.
+	 * @param listeners Zero or more listeners to be notified when the bundle
+	 *        refresh has been completed. The specified listeners do not need to
+	 *        be otherwise registered with the framework. If a specified
+	 *        listener is already registered with the framework, it will be
+	 *        notified twice.
+	 * @throws IllegalArgumentException If the specified {@code Bundle}s were
+	 *         not created by the same framework instance associated with this
+	 *         FrameworkWiring.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,RESOLVE]} and the Java
+	 *         runtime environment supports permissions.
+	 */
+	void refreshBundles(Collection<Bundle> bundles,
+			FrameworkListener... listeners);
+
+	/**
+	 * Resolves the specified bundles. The Framework must attempt to resolve the
+	 * specified bundles that are unresolved. Additional bundles that are not
+	 * included in the specified bundles may be resolved as a result of calling
+	 * this method. A permissible implementation of this method is to attempt to
+	 * resolve all unresolved bundles installed in the framework.
+	 * 
+	 * <p>
+	 * If no bundles are specified, then the Framework will attempt to resolve
+	 * all unresolved bundles. This method must not cause any bundle to be
+	 * refreshed, stopped, or started. This method will not return until the
+	 * operation has completed.
+	 * 
+	 * @param bundles The bundles to resolve or {@code null} to resolve all
+	 *        unresolved bundles installed in the Framework.
+	 * @return {@code true} if all specified bundles are resolved; {@code false}
+	 *         otherwise.
+	 * @throws IllegalArgumentException If the specified {@code Bundle}s were
+	 *         not created by the same framework instance associated with this
+	 *         FrameworkWiring.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,RESOLVE]} and the Java
+	 *         runtime environment supports permissions.
+	 */
+	boolean resolveBundles(Collection<Bundle> bundles);
+
+	/**
+	 * Returns the bundles that have {@link BundleWiring#isCurrent()
+	 * non-current}, {@link BundleWiring#isInUse() in use} bundle wirings. This
+	 * is typically the bundles which have been updated or uninstalled since the
+	 * last call to {@link #refreshBundles(Collection, FrameworkListener...)}.
+	 * 
+	 * @return A collection containing a snapshot of the {@code Bundle}s which
+	 *         have non-current, in use {@code BundleWiring}s, or an empty
+	 *         collection if there are no such bundles.
+	 */
+	Collection<Bundle> getRemovalPendingBundles();
+
+	/**
+	 * Returns the dependency closure for the specified bundles.
+	 * 
+	 * <p>
+	 * A graph of bundles is computed starting with the specified bundles. The
+	 * graph is expanded by adding any bundle that is either wired to a package
+	 * that is currently exported by a bundle in the graph or requires a bundle
+	 * in the graph. The graph is fully constructed when there is no bundle
+	 * outside the graph that is wired to a bundle in the graph. The graph may
+	 * contain {@code UNINSTALLED} bundles that are
+	 * {@link #getRemovalPendingBundles() removal pending}.
+	 * 
+	 * @param bundles The initial bundles for which to generate the dependency
+	 *        closure.
+	 * @return A collection containing a snapshot of the dependency closure of
+	 *         the specified bundles, or an empty collection if there were no
+	 *         specified bundles.
+	 * @throws IllegalArgumentException If the specified {@code Bundle}s were
+	 *         not created by the same framework instance associated with this
+	 *         FrameworkWiring.
+	 */
+	Collection<Bundle> getDependencyClosure(Collection<Bundle> bundles);
+}
diff --git a/main/src/main/java/org/osgi/framework/wiring/package-info.java b/main/src/main/java/org/osgi/framework/wiring/package-info.java
new file mode 100644
index 0000000000..a157f2fdfc
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/package-info.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Framework Wiring Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest. For example:
+ * 
+ * <pre>
+ * Import-Package: org.osgi.framework.wiring; version=&quot;[1.0,2.0)&quot;
+ * </pre>
+ * 
+ * @version $Id: 05eacf0e84a34e2b2e5ddbe4b3fee3acd0d07cc6 $
+ */
+package org.osgi.framework.wiring;
+
diff --git a/main/src/main/java/org/osgi/framework/wiring/packageinfo b/main/src/main/java/org/osgi/framework/wiring/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/framework/wiring/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/BundleLocationCondition.java b/main/src/main/java/org/osgi/service/condpermadmin/BundleLocationCondition.java
new file mode 100644
index 0000000000..d058bcbe7f
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/BundleLocationCondition.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.InvalidSyntaxException;
+
+/**
+ * Condition to test if the location of a bundle matches or does not match a
+ * pattern. Since the bundle's location cannot be changed, this condition is
+ * immutable.
+ * 
+ * <p>
+ * Pattern matching is done according to the filter string matching rules.
+ * 
+ * @ThreadSafe
+ * @version $Id: 7b466c7103a708833c6ff1fa2a4c5cf21f757179 $
+ */
+public class BundleLocationCondition {
+	private static final String	CONDITION_TYPE	= "org.osgi.service.condpermadmin.BundleLocationCondition";
+
+	/**
+	 * Constructs a condition that tries to match the passed Bundle's location
+	 * to the location pattern.
+	 * 
+	 * @param bundle The Bundle being evaluated.
+	 * @param info The ConditionInfo from which to construct the condition. The
+	 *        ConditionInfo must specify one or two arguments. The first
+	 *        argument of the ConditionInfo specifies the location pattern
+	 *        against which to match the bundle location. Matching is done
+	 *        according to the filter string matching rules. Any '*' characters
+	 *        in the first argument are used as wildcards when matching bundle
+	 *        locations unless they are escaped with a '\' character. The
+	 *        Condition is satisfied if the bundle location matches the pattern.
+	 *        The second argument of the ConditionInfo is optional. If a second
+	 *        argument is present and equal to "!", then the satisfaction of the
+	 *        Condition is negated. That is, the Condition is satisfied if the
+	 *        bundle location does NOT match the pattern. If the second argument
+	 *        is present but does not equal "!", then the second argument is
+	 *        ignored.
+	 * @return Condition object for the requested condition.
+	 */
+	static public Condition getCondition(final Bundle bundle,
+			final ConditionInfo info) {
+		if (!CONDITION_TYPE.equals(info.getType()))
+			throw new IllegalArgumentException(
+					"ConditionInfo must be of type \"" + CONDITION_TYPE + "\"");
+		String[] args = info.getArgs();
+		if (args.length != 1 && args.length != 2)
+			throw new IllegalArgumentException("Illegal number of args: " + args.length);
+		String bundleLocation = AccessController
+				.doPrivileged(new PrivilegedAction<String>() {
+					public String run() {
+						return bundle.getLocation();
+					}
+				});
+		Filter filter = null;
+		try {
+			filter = FrameworkUtil.createFilter("(location="
+					+ escapeLocation(args[0]) + ")");
+		}
+		catch (InvalidSyntaxException e) {
+			// this should never happen, but just in case
+			throw new RuntimeException("Invalid filter: " + e.getFilter(), e);
+		}
+		Dictionary<String, String> matchProps = new Hashtable<String, String>(2);
+		matchProps.put("location", bundleLocation);
+		boolean negate = (args.length == 2) ? "!".equals(args[1]) : false;
+		return (negate ^ filter.match(matchProps)) ? Condition.TRUE
+				: Condition.FALSE;
+	}
+
+	private BundleLocationCondition() {
+		// private constructor to prevent objects of this type
+	}
+
+	/**
+	 * Escape the value string such that '(', ')' and '\' are escaped. The '\'
+	 * char is only escaped if it is not followed by a '*'.
+	 * 
+	 * @param value unescaped value string.
+	 * @return escaped value string.
+	 */
+	private static String escapeLocation(final String value) {
+		boolean escaped = false;
+		int inlen = value.length();
+		int outlen = inlen << 1; /* inlen * 2 */
+
+		char[] output = new char[outlen];
+		value.getChars(0, inlen, output, inlen);
+
+		int cursor = 0;
+		for (int i = inlen; i < outlen; i++) {
+			char c = output[i];
+			switch (c) {
+				case '\\' :
+					if (i + 1 < outlen && output[i + 1] == '*')
+						break;
+				case '(' :
+				case ')' :
+					output[cursor] = '\\';
+					cursor++;
+					escaped = true;
+					break;
+			}
+
+			output[cursor] = c;
+			cursor++;
+		}
+
+		return escaped ? new String(output, 0, cursor) : value;
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/BundleSignerCondition.java b/main/src/main/java/org/osgi/service/condpermadmin/BundleSignerCondition.java
new file mode 100644
index 0000000000..5e4a68908e
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/BundleSignerCondition.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.FrameworkUtil;
+
+/**
+ * Condition to test if the signer of a bundle matches or does not match a
+ * pattern. Since the bundle's signer can only change when the bundle is
+ * updated, this condition is immutable.
+ * <p>
+ * The condition expressed using a single String that specifies a Distinguished
+ * Name (DN) chain to match bundle signers against. DN's are encoded using IETF
+ * RFC 2253. Usually signers use certificates that are issued by certificate
+ * authorities, which also have a corresponding DN and certificate. The
+ * certificate authorities can form a chain of trust where the last DN and
+ * certificate is known by the framework. The signer of a bundle is expressed as
+ * signers DN followed by the DN of its issuer followed by the DN of the next
+ * issuer until the DN of the root certificate authority. Each DN is separated
+ * by a semicolon.
+ * <p>
+ * A bundle can satisfy this condition if one of its signers has a DN chain that
+ * matches the DN chain used to construct this condition. Wildcards (`*') can be
+ * used to allow greater flexibility in specifying the DN chains. Wildcards can
+ * be used in place of DNs, RDNs, or the value in an RDN. If a wildcard is used
+ * for a value of an RDN, the value must be exactly "*" and will match any value
+ * for the corresponding type in that RDN. If a wildcard is used for a RDN, it
+ * must be the first RDN and will match any number of RDNs (including zero
+ * RDNs).
+ * 
+ * @ThreadSafe
+ * @version $Id: 6e10febd6a8cfc31973ece0af29c352ed972b105 $
+ */
+public class BundleSignerCondition {
+	private static final String	CONDITION_TYPE	= "org.osgi.service.condpermadmin.BundleSignerCondition";
+
+	/**
+	 * Constructs a Condition that tries to match the passed Bundle's location
+	 * to the location pattern.
+	 * 
+	 * @param bundle The Bundle being evaluated.
+	 * @param info The ConditionInfo from which to construct the condition. The
+	 *        ConditionInfo must specify one or two arguments. The first
+	 *        argument of the ConditionInfo specifies the chain of distinguished
+	 *        names pattern to match against the signer of the bundle. The
+	 *        Condition is satisfied if the signer of the bundle matches the
+	 *        pattern. The second argument of the ConditionInfo is optional. If
+	 *        a second argument is present and equal to "!", then the
+	 *        satisfaction of the Condition is negated. That is, the Condition
+	 *        is satisfied if the signer of the bundle does NOT match the
+	 *        pattern. If the second argument is present but does not equal "!",
+	 *        then the second argument is ignored.
+	 * @return A Condition which checks the signers of the specified bundle.
+	 */
+	public static Condition getCondition(final Bundle bundle,
+			final ConditionInfo info) {
+		if (!CONDITION_TYPE.equals(info.getType()))
+			throw new IllegalArgumentException(
+					"ConditionInfo must be of type \"" + CONDITION_TYPE + "\"");
+		String[] args = info.getArgs();
+		if (args.length != 1 && args.length != 2)
+			throw new IllegalArgumentException("Illegal number of args: "
+					+ args.length);
+
+		Map<X509Certificate, List<X509Certificate>> signers = bundle
+				.getSignerCertificates(Bundle.SIGNERS_TRUSTED);
+		boolean match = false;
+		for (List<X509Certificate> signerCerts : signers.values()) {
+			List<String> dnChain = new ArrayList<String>(signerCerts.size());
+			for (X509Certificate signer : signerCerts) {
+				dnChain.add(signer.getSubjectDN().getName());
+			}
+			if (FrameworkUtil.matchDistinguishedNameChain(args[0], dnChain)) {
+				match = true;
+				break;
+			}
+		}
+
+		boolean negate = (args.length == 2) ? "!".equals(args[1]) : false;
+		return negate ^ match ? Condition.TRUE : Condition.FALSE;
+	}
+
+	private BundleSignerCondition() {
+		// private constructor to prevent objects of this type
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/Condition.java b/main/src/main/java/org/osgi/service/condpermadmin/Condition.java
new file mode 100644
index 0000000000..90f2778309
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/Condition.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.util.Dictionary;
+
+/**
+ * The interface implemented by a Condition. Conditions are bound to Permissions
+ * using Conditional Permission Info. The Permissions of a ConditionalPermission
+ * Info can only be used if the associated Conditions are satisfied.
+ * 
+ * @ThreadSafe
+ * @version $Id: 7e80cf578718db713c347568e7d3232010beac0a $
+ */
+public interface Condition {
+	/**
+	 * A Condition object that will always evaluate to true and that is never
+	 * postponed.
+	 */
+	public final static Condition	TRUE	= new BooleanCondition(true);
+
+	/**
+	 * A Condition object that will always evaluate to false and that is never
+	 * postponed.
+	 */
+	public final static Condition	FALSE	= new BooleanCondition(false);
+
+	/**
+	 * Returns whether the evaluation must be postponed until the end of the
+	 * permission check. If this method returns {@code false} (or this
+	 * Condition is immutable), then this Condition must be able to directly
+	 * answer the {@link #isSatisfied()} method. In other words, isSatisfied()
+	 * will return very quickly since no external sources, such as for example
+	 * users or networks, need to be consulted. <br/>
+	 * This method must always return the same value whenever it is called so
+	 * that the Conditional Permission Admin can cache its result.
+	 * 
+	 * @return {@code true} to indicate the evaluation must be postponed.
+	 *         Otherwise, {@code false} if the evaluation can be performed
+	 *         immediately.
+	 */
+	boolean isPostponed();
+
+	/**
+	 * Returns whether the Condition is satisfied. This method is only called
+	 * for immediate Condition objects or immutable postponed conditions, and
+	 * must always be called inside a permission check. Mutable postponed
+	 * Condition objects will be called with the grouped version
+	 * {@link #isSatisfied(Condition[],Dictionary)} at the end of the permission
+	 * check.
+	 * 
+	 * @return {@code true} to indicate the Conditions is satisfied.
+	 *         Otherwise, {@code false} if the Condition is not satisfied.
+	 */
+	boolean isSatisfied();
+
+	/**
+	 * Returns whether the Condition is mutable. A Condition can go from mutable
+	 * ({@code true}) to immutable ({@code false}) over time but never
+	 * from immutable ({@code false}) to mutable ({@code true}).
+	 * 
+	 * @return {@code true} {@link #isSatisfied()} can change. Otherwise,
+	 *         {@code false} if the value returned by
+	 *         {@link #isSatisfied()} will not change for this condition.
+	 */
+	boolean isMutable();
+
+	/**
+	 * Returns whether the specified set of Condition objects are satisfied.
+	 * Although this method is not static, it must be implemented as if it
+	 * were static. All of the passed Condition objects will be of the same
+	 * type and will correspond to the class type of the object on which this
+	 * method is invoked. This method must be called inside a permission check
+	 * only.
+	 * 
+	 * @param conditions The array of Condition objects, which must all be of
+	 *        the same class and mutable. The receiver must be one of those
+	 *        Condition objects.
+	 * @param context A Dictionary object that implementors can use to track
+	 *        state. If this method is invoked multiple times in the same
+	 *        permission check, the same Dictionary will be passed multiple
+	 *        times. The SecurityManager treats this Dictionary as an opaque
+	 *        object and simply creates an empty dictionary and passes it to
+	 *        subsequent invocations if multiple invocations are needed.
+	 * @return {@code true} if all the Condition objects are satisfied.
+	 *         Otherwise, {@code false} if one of the Condition objects is
+	 *         not satisfied.
+	 */
+	boolean isSatisfied(Condition conditions[],
+			Dictionary<Object, Object> context);
+}
+
+/**
+ * Package private class used to define the {@link Condition#FALSE} and
+ * {@link Condition#TRUE} constants.
+ * 
+ * @Immutable
+ */
+final class BooleanCondition implements Condition {
+	private final boolean	satisfied;
+
+	BooleanCondition(boolean satisfied) {
+		this.satisfied = satisfied;
+	}
+
+	public boolean isPostponed() {
+		return false;
+	}
+
+	public boolean isSatisfied() {
+		return satisfied;
+	}
+
+	public boolean isMutable() {
+		return false;
+	}
+
+	public boolean isSatisfied(Condition[] conds,
+			Dictionary<Object, Object> context) {
+		for (int i = 0, length = conds.length; i < length; i++) {
+			if (!conds[i].isSatisfied())
+				return false;
+		}
+		return true;
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/ConditionInfo.java b/main/src/main/java/org/osgi/service/condpermadmin/ConditionInfo.java
new file mode 100644
index 0000000000..055703aeb5
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/ConditionInfo.java
@@ -0,0 +1,344 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Condition representation used by the Conditional Permission Admin service.
+ * 
+ * <p>
+ * This class encapsulates two pieces of information: a Condition <i>type</i>
+ * (class name), which must implement {@code Condition}, and the
+ * arguments passed to its constructor.
+ * 
+ * <p>
+ * In order for a Condition represented by a {@code ConditionInfo} to be
+ * instantiated and considered during a permission check, its Condition class
+ * must be available from the system classpath.
+ * 
+ * <p>
+ * The Condition class must either:
+ * <ul>
+ * <li>Declare a public static {@code getCondition} method that takes a
+ * {@code Bundle} object and a {@code ConditionInfo} object as
+ * arguments. That method must return an object that implements the
+ * {@code Condition} interface.</li>
+ * <li>Implement the {@code Condition} interface and define a public
+ * constructor that takes a {@code Bundle} object and a
+ * {@code ConditionInfo} object as arguments.
+ * </ul>
+ * 
+ * @Immutable
+ * @version $Id: dd1d84aa3175b2a2dfec879d04c93887f05161be $
+ */
+public class ConditionInfo {
+	private final String	type;
+	private final String[]	args;
+
+	/**
+	 * Constructs a {@code ConditionInfo} from the specified type and args.
+	 * 
+	 * @param type The fully qualified class name of the Condition represented
+	 *        by this {@code ConditionInfo}.
+	 * @param args The arguments for the Condition. These arguments are
+	 *        available to the newly created Condition by calling the
+	 *        {@link #getArgs()} method.
+	 * @throws NullPointerException If {@code type} is {@code null}.
+	 */
+	public ConditionInfo(String type, String[] args) {
+		this.type = type;
+		this.args = (args != null) ? args.clone() : new String[0];
+		if (type == null) {
+			throw new NullPointerException("type is null");
+		}
+	}
+
+	/**
+	 * Constructs a {@code ConditionInfo} object from the specified encoded
+	 * {@code ConditionInfo} string. White space in the encoded
+	 * {@code ConditionInfo} string is ignored.
+	 * 
+	 * @param encodedCondition The encoded {@code ConditionInfo}.
+	 * @see #getEncoded
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code encodedCondition} is not properly formatted.
+	 */
+	public ConditionInfo(String encodedCondition) {
+		if (encodedCondition == null) {
+			throw new NullPointerException("missing encoded condition");
+		}
+		if (encodedCondition.length() == 0) {
+			throw new IllegalArgumentException("empty encoded condition");
+		}
+		try {
+			char[] encoded = encodedCondition.toCharArray();
+			int length = encoded.length;
+			int pos = 0;
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* the first character must be '[' */
+			if (encoded[pos] != '[') {
+				throw new IllegalArgumentException("expecting open bracket");
+			}
+			pos++;
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* type is not quoted or encoded */
+			int begin = pos;
+			while (!Character.isWhitespace(encoded[pos])
+					&& (encoded[pos] != ']')) {
+				pos++;
+			}
+			if (pos == begin || encoded[begin] == '"') {
+				throw new IllegalArgumentException("expecting type");
+			}
+			this.type = new String(encoded, begin, pos - begin);
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* type may be followed by args which are quoted and encoded */
+			List<String> argsList = new ArrayList<String>();
+			while (encoded[pos] == '"') {
+				pos++;
+				begin = pos;
+				while (encoded[pos] != '"') {
+					if (encoded[pos] == '\\') {
+						pos++;
+					}
+					pos++;
+				}
+				argsList.add(unescapeString(encoded, begin, pos));
+				pos++;
+
+				if (Character.isWhitespace(encoded[pos])) {
+					/* skip whitespace */
+					while (Character.isWhitespace(encoded[pos])) {
+						pos++;
+					}
+				}
+			}
+			this.args = argsList.toArray(new String[argsList.size()]);
+
+			/* the final character must be ']' */
+			char c = encoded[pos];
+			pos++;
+			while ((pos < length) && Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+			if ((c != ']') || (pos != length)) {
+				throw new IllegalArgumentException("expecting close bracket");
+			}
+		}
+		catch (ArrayIndexOutOfBoundsException e) {
+			throw new IllegalArgumentException("parsing terminated abruptly");
+		}
+	}
+
+	/**
+	 * Returns the string encoding of this {@code ConditionInfo} in a form
+	 * suitable for restoring this {@code ConditionInfo}.
+	 * 
+	 * <p>
+	 * The encoded format is:
+	 * 
+	 * <pre>
+	 *   [type &quot;arg0&quot; &quot;arg1&quot; ...]
+	 * </pre>
+	 * 
+	 * where <i>argN</i> are strings that must be encoded for proper parsing.
+	 * Specifically, the {@code &quot;}, {@code \}, carriage return,
+	 * and line feed characters must be escaped using {@code \&quot;},
+	 * {@code \\}, {@code \r}, and {@code \n}, respectively.
+	 * 
+	 * <p>
+	 * The encoded string contains no leading or trailing whitespace characters.
+	 * A single space character is used between type and &quot;<i>arg0</i>&quot;
+	 * and between the arguments.
+	 * 
+	 * @return The string encoding of this {@code ConditionInfo}.
+	 */
+	public final String getEncoded() {
+		StringBuffer output = new StringBuffer();
+		output.append('[');
+		output.append(type);
+
+		for (int i = 0; i < args.length; i++) {
+			output.append(" \"");
+			escapeString(args[i], output);
+			output.append('\"');
+		}
+
+		output.append(']');
+
+		return output.toString();
+	}
+
+	/**
+	 * Returns the string representation of this {@code ConditionInfo}.
+	 * The string is created by calling the {@code getEncoded} method on
+	 * this {@code ConditionInfo}.
+	 * 
+	 * @return The string representation of this {@code ConditionInfo}.
+	 */
+	public String toString() {
+		return getEncoded();
+	}
+
+	/**
+	 * Returns the fully qualified class name of the condition represented by
+	 * this {@code ConditionInfo}.
+	 * 
+	 * @return The fully qualified class name of the condition represented by
+	 *         this {@code ConditionInfo}.
+	 */
+	public final String getType() {
+		return type;
+	}
+
+	/**
+	 * Returns arguments of this {@code ConditionInfo}.
+	 * 
+	 * @return The arguments of this {@code ConditionInfo}. An empty
+	 *         array is returned if the {@code ConditionInfo} has no
+	 *         arguments.
+	 */
+	public final String[] getArgs() {
+		return args.clone();
+	}
+
+	/**
+	 * Determines the equality of two {@code ConditionInfo} objects.
+	 * 
+	 * This method checks that specified object has the same type and args as
+	 * this {@code ConditionInfo} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code ConditionInfo} object.
+	 * @return {@code true} if {@code obj} is a
+	 *         {@code ConditionInfo}, and has the same type and args as
+	 *         this {@code ConditionInfo} object; {@code false}
+	 *         otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+
+		if (!(obj instanceof ConditionInfo)) {
+			return false;
+		}
+
+		ConditionInfo other = (ConditionInfo) obj;
+
+		if (!type.equals(other.type) || args.length != other.args.length)
+			return false;
+
+		for (int i = 0; i < args.length; i++) {
+			if (!args[i].equals(other.args[i]))
+				return false;
+		}
+		return true;
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 */
+
+	public int hashCode() {
+		int h = 31 * 17 + type.hashCode();
+		for (int i = 0; i < args.length; i++) {
+			h = 31 * h + args[i].hashCode();
+		}
+		return h;
+	}
+
+	/**
+	 * This escapes the quotes, backslashes, \n, and \r in the string using a
+	 * backslash and appends the newly escaped string to a StringBuffer.
+	 */
+	private static void escapeString(String str, StringBuffer output) {
+		int len = str.length();
+		for (int i = 0; i < len; i++) {
+			char c = str.charAt(i);
+			switch (c) {
+				case '"' :
+				case '\\' :
+					output.append('\\');
+					output.append(c);
+					break;
+				case '\r' :
+					output.append("\\r");
+					break;
+				case '\n' :
+					output.append("\\n");
+					break;
+				default :
+					output.append(c);
+					break;
+			}
+		}
+	}
+
+	/**
+	 * Takes an encoded character array and decodes it into a new String.
+	 */
+	private static String unescapeString(char[] str, int begin, int end) {
+		StringBuffer output = new StringBuffer(end - begin);
+		for (int i = begin; i < end; i++) {
+			char c = str[i];
+			if (c == '\\') {
+				i++;
+				if (i < end) {
+					c = str[i];
+					switch (c) {
+						case '"' :
+						case '\\' :
+							break;
+						case 'r' :
+							c = '\r';
+							break;
+						case 'n' :
+							c = '\n';
+							break;
+						default :
+							c = '\\';
+							i--;
+							break;
+					}
+				}
+			}
+			output.append(c);
+		}
+
+		return output.toString();
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionAdmin.java b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionAdmin.java
new file mode 100644
index 0000000000..86cc3f3448
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionAdmin.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) OSGi Alliance (2005, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.security.AccessControlContext;
+import java.util.Enumeration;
+
+import org.osgi.service.permissionadmin.PermissionInfo;
+
+/**
+ * Framework service to administer Conditional Permissions. Conditional
+ * Permissions can be added to, retrieved from, and removed from the framework.
+ * Conditional Permissions are conceptually managed in an ordered table called
+ * the Conditional Permission Table.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 887450b65e453145d57197e2db75db0bb2918ef4 $
+ */
+public interface ConditionalPermissionAdmin {
+	/**
+	 * Create a new Conditional Permission Info in the Conditional Permission
+	 * Table.
+	 * <p>
+	 * The Conditional Permission Info will be given a unique, never reused
+	 * name. This entry will be added at the beginning of the Conditional
+	 * Permission Table with an access decision of
+	 * {@link ConditionalPermissionInfo#ALLOW ALLOW}.
+	 * <p>
+	 * Since this method changes the Conditional Permission Table any
+	 * {@link ConditionalPermissionUpdate}s that were created prior to calling
+	 * this method can no longer be committed.
+	 * 
+	 * @param conditions The conditions that need to be satisfied to enable the
+	 *        specified permissions. This argument can be {@code null} or
+	 *        an empty array indicating the specified permissions are not
+	 *        guarded by any conditions.
+	 * @param permissions The permissions that are enabled when the specified
+	 *        conditions, if any, are satisfied. This argument must not be
+	 *        {@code null} and must specify at least one permission.
+	 * @return The ConditionalPermissionInfo for the specified Conditions and
+	 *         Permissions.
+	 * @throws IllegalArgumentException If no permissions are specified.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 * @deprecated Since 1.1. Use {@link #newConditionalPermissionUpdate()}
+	 *             instead.
+	 */
+	ConditionalPermissionInfo addConditionalPermissionInfo(
+			ConditionInfo conditions[], PermissionInfo permissions[]);
+
+	/**
+	 * Set or create a Conditional Permission Info with a specified name in the
+	 * Conditional Permission Table.
+	 * <p>
+	 * If the specified name is {@code null}, a new Conditional Permission
+	 * Info must be created and will be given a unique, never reused name. If
+	 * there is currently no Conditional Permission Info with the specified
+	 * name, a new Conditional Permission Info must be created with the
+	 * specified name. Otherwise, the Conditional Permission Info with the
+	 * specified name must be updated with the specified Conditions and
+	 * Permissions. If a new entry was created in the Conditional Permission
+	 * Table it will be added at the beginning of the table with an access
+	 * decision of {@link ConditionalPermissionInfo#ALLOW ALLOW}.
+	 * <p>
+	 * Since this method changes the underlying permission table any
+	 * {@link ConditionalPermissionUpdate}s that were created prior to calling
+	 * this method can no longer be committed.
+	 * 
+	 * @param name The name of the Conditional Permission Info, or
+	 *        {@code null}.
+	 * @param conditions The conditions that need to be satisfied to enable the
+	 *        specified permissions. This argument can be {@code null} or
+	 *        an empty array indicating the specified permissions are not
+	 *        guarded by any conditions.
+	 * @param permissions The permissions that are enabled when the specified
+	 *        conditions, if any, are satisfied. This argument must not be
+	 *        {@code null} and must specify at least one permission.
+	 * @return The ConditionalPermissionInfo for the specified name, Conditions
+	 *         and Permissions.
+	 * @throws IllegalArgumentException If no permissions are specified.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 * @deprecated Since 1.1. Use {@link #newConditionalPermissionUpdate()}
+	 *             instead.
+	 */
+	ConditionalPermissionInfo setConditionalPermissionInfo(String name,
+			ConditionInfo conditions[], PermissionInfo permissions[]);
+
+	/**
+	 * Returns the Conditional Permission Infos from the Conditional Permission
+	 * Table.
+	 * <p>
+	 * The returned Enumeration will return elements in the order they are kept
+	 * in the Conditional Permission Table.
+	 * <p>
+	 * The Enumeration returned is based on a copy of the Conditional Permission
+	 * Table and therefore will not throw exceptions if the Conditional
+	 * Permission Table is changed during the course of reading elements from
+	 * the Enumeration.
+	 * 
+	 * @return An enumeration of the Conditional Permission Infos that are
+	 *         currently in the Conditional Permission Table.
+	 * @deprecated Since 1.1. Use {@link #newConditionalPermissionUpdate()}
+	 *             instead.
+	 */
+	Enumeration<ConditionalPermissionInfo> getConditionalPermissionInfos();
+
+	/**
+	 * Return the Conditional Permission Info with the specified name.
+	 * 
+	 * @param name The name of the Conditional Permission Info to be returned.
+	 * @return The Conditional Permission Info with the specified name or
+	 *         {@code null} if no Conditional Permission Info with the
+	 *         specified name exists in the Conditional Permission Table.
+	 * @deprecated Since 1.1. Use {@link #newConditionalPermissionUpdate()}
+	 *             instead.
+	 */
+	ConditionalPermissionInfo getConditionalPermissionInfo(String name);
+
+	/**
+	 * Returns the Access Control Context that corresponds to the specified
+	 * signers.
+	 * 
+	 * The returned Access Control Context must act as if its protection domain
+	 * came from a bundle that has the following characteristics:
+	 * <ul>
+	 * <li>It is signed by all of the given signers</li>
+	 * <li>It has a bundle id of -1</li>
+	 * <li>Its location is the empty string</li>
+	 * <li>Its state is UNINSTALLED</li>
+	 * <li>It has no headers</li>
+	 * <li>It has the empty version (0.0.0)</li>
+	 * <li>Its last modified time=0</li>
+	 * <li>Many methods will throw {@code IllegalStateException} because the state is UNINSTALLED</li>
+	 * <li>All other methods return a {@code null}</li>
+	 * </ul> 
+	 * @param signers The signers for which to return an Access Control Context.
+	 * @return An {@code AccessControlContext} that has the Permissions
+	 *         associated with the signer.
+	 */
+	AccessControlContext getAccessControlContext(String[] signers);
+
+	/**
+	 * Creates a new update for the Conditional Permission Table. The update is
+	 * a working copy of the current Conditional Permission Table. If the
+	 * running Conditional Permission Table is modified before commit is called
+	 * on the returned update, then the call to commit on the returned update
+	 * will fail. That is, the commit method will return false and no change
+	 * will be made to the running Conditional Permission Table. There is no
+	 * requirement that commit is eventually called on the returned update.
+	 * 
+	 * @return A new update for the Conditional Permission Table.
+	 * @since 1.1
+	 */
+	ConditionalPermissionUpdate newConditionalPermissionUpdate();
+
+	/**
+	 * Creates a new ConditionalPermissionInfo with the specified fields
+	 * suitable for insertion into a {@link ConditionalPermissionUpdate}. The
+	 * {@code delete} method on {@code ConditionalPermissionInfo}
+	 * objects created with this method must throw
+	 * UnsupportedOperationException.
+	 * 
+	 * @param name The name of the created
+	 *        {@code ConditionalPermissionInfo} or {@code null} to
+	 *        have a unique name generated when the returned
+	 *        {@code ConditionalPermissionInfo} is committed in an update
+	 *        to the Conditional Permission Table.
+	 * @param conditions The conditions that need to be satisfied to enable the
+	 *        specified permissions. This argument can be {@code null} or
+	 *        an empty array indicating the specified permissions are not
+	 *        guarded by any conditions.
+	 * @param permissions The permissions that are enabled when the specified
+	 *        conditions, if any, are satisfied. This argument must not be
+	 *        {@code null} and must specify at least one permission.
+	 * @param access Access decision. Must be one of the following values:
+	 *        <ul>
+	 *        <li>{@link ConditionalPermissionInfo#ALLOW allow}</li>
+	 *        <li>{@link ConditionalPermissionInfo#DENY deny}</li>
+	 *        </ul>
+	 *        The specified access decision value must be evaluated case
+	 *        insensitively.
+	 * @return A {@code ConditionalPermissionInfo} object suitable for
+	 *         insertion into a {@link ConditionalPermissionUpdate}.
+	 * @throws IllegalArgumentException If no permissions are specified or if
+	 *         the specified access decision is not a valid value.
+	 * @since 1.1
+	 */
+	ConditionalPermissionInfo newConditionalPermissionInfo(String name,
+			ConditionInfo conditions[], PermissionInfo permissions[],
+			String access);
+
+	/**
+	 * Creates a new {@code ConditionalPermissionInfo} from the specified
+	 * encoded {@code ConditionalPermissionInfo} string suitable for
+	 * insertion into a {@link ConditionalPermissionUpdate}. The
+	 * {@code delete} method on {@code ConditionalPermissionInfo}
+	 * objects created with this method must throw
+	 * UnsupportedOperationException.
+	 * 
+	 * @param encodedConditionalPermissionInfo The encoded
+	 *        {@code ConditionalPermissionInfo}. White space in the encoded
+	 *        {@code ConditionalPermissionInfo} is ignored. The access
+	 *        decision value in the encoded
+	 *        {@code ConditionalPermissionInfo} must be evaluated case
+	 *        insensitively. If the encoded
+	 *        {@code ConditionalPermissionInfo} does not contain the
+	 *        optional name, {@code null} must be used for the name and a
+	 *        unique name will be generated when the returned
+	 *        {@code ConditionalPermissionInfo} is committed in an update
+	 *        to the Conditional Permission Table.
+	 * @return A {@code ConditionalPermissionInfo} object suitable for
+	 *         insertion into a {@link ConditionalPermissionUpdate}.
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code encodedConditionalPermissionInfo} is not properly
+	 *         formatted.
+	 * @see ConditionalPermissionInfo#getEncoded
+	 * @since 1.1
+	 */
+	ConditionalPermissionInfo newConditionalPermissionInfo(
+			String encodedConditionalPermissionInfo);
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionInfo.java b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionInfo.java
new file mode 100644
index 0000000000..92e5aebc55
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionInfo.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import org.osgi.service.permissionadmin.PermissionInfo;
+
+/**
+ * A list of Permissions guarded by a list of conditions with an access
+ * decision. Instances of this interface are obtained from the Conditional
+ * Permission Admin service.
+ * 
+ * @Immutable
+ * @noimplement
+ * @version $Id: ca51e4dd6dfa350959bb2a2e420bdb2c996323e9 $
+ */
+public interface ConditionalPermissionInfo {
+	/**
+	 * This string is used to indicate that a row in the Conditional Permission
+	 * Table should return an access decision of &quot;allow&quot; if the
+	 * conditions are all satisfied and at least one of the permissions is
+	 * implied.
+	 * 
+	 * @since 1.1
+	 */
+	public final static String	ALLOW	= "allow";
+
+	/**
+	 * This string is used to indicate that a row in the Conditional Permission
+	 * Table should return an access decision of &quot;deny&quot; if the
+	 * conditions are all satisfied and at least one of the permissions is
+	 * implied.
+	 * 
+	 * @since 1.1
+	 */
+	public final static String	DENY	= "deny";
+
+	/**
+	 * Returns the Condition Infos for the Conditions that must be satisfied to
+	 * enable the Permissions.
+	 * 
+	 * @return The Condition Infos for the Conditions in this Conditional
+	 *         Permission Info.
+	 */
+	ConditionInfo[] getConditionInfos();
+
+	/**
+	 * Returns the Permission Infos for the Permissions in this Conditional
+	 * Permission Info.
+	 * 
+	 * @return The Permission Infos for the Permissions in this Conditional
+	 *         Permission Info.
+	 */
+	PermissionInfo[] getPermissionInfos();
+
+	/**
+	 * Removes this Conditional Permission Info from the Conditional Permission
+	 * Table.
+	 * <p>
+	 * Since this method changes the underlying permission table, any
+	 * {@link ConditionalPermissionUpdate}s that were created prior to calling
+	 * this method can no longer be committed.
+	 * 
+	 * @throws UnsupportedOperationException If this object was created by
+	 *         {@link ConditionalPermissionAdmin#newConditionalPermissionInfo}
+	 *         or obtained from a {@link ConditionalPermissionUpdate}. This
+	 *         method only functions if this object was obtained from one of the
+	 *         {@link ConditionalPermissionAdmin} methods deprecated in version
+	 *         1.1.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 * @deprecated Since 1.1. Use
+	 *             {@link ConditionalPermissionAdmin#newConditionalPermissionUpdate()}
+	 *             instead to manage the Conditional Permissions.
+	 */
+	void delete();
+
+	/**
+	 * Returns the name of this Conditional Permission Info.
+	 * 
+	 * @return The name of this Conditional Permission Info. This can be
+	 *         {@code null} if this Conditional Permission Info was created
+	 *         without a name.
+	 */
+	String getName();
+
+	/**
+	 * Returns the access decision for this Conditional Permission Info.
+	 * 
+	 * @return One of the following values:
+	 *         <ul>
+	 *         <li>{@link #ALLOW allow} - The access decision is
+	 *         &quot;allow&quot;.</li>
+	 *         <li>{@link #DENY deny} - The access decision is &quot;deny&quot;.
+	 *         </li>
+	 *         </ul>
+	 * @since 1.1
+	 */
+	String getAccessDecision();
+
+	/**
+	 * Returns the string encoding of this {@code ConditionalPermissionInfo} in
+	 * a form suitable for restoring this {@code ConditionalPermissionInfo}.
+	 * 
+	 * <p>
+	 * The encoded format is:
+	 * 
+	 * <pre>
+	 *   access {conditions permissions} name
+	 * </pre>
+	 * 
+	 * where <i>access</i> is the access decision, <i>conditions</i> is zero or
+	 * more {@link ConditionInfo#getEncoded() encoded conditions},
+	 * <i>permissions</i> is one or more {@link PermissionInfo#getEncoded()
+	 * encoded permissions} and <i>name</i> is the name of the
+	 * {@code ConditionalPermissionInfo}.
+	 * 
+	 * <p>
+	 * <i>name</i> is optional. If <i>name</i> is present in the encoded string,
+	 * it must quoted, beginning and ending with {@code &quot;}. The <i>name</i>
+	 * value must be encoded for proper parsing. Specifically, the
+	 * {@code &quot;}, {@code \}, carriage return, and line feed characters must
+	 * be escaped using {@code \&quot;}, {@code \\}, {@code \r}, and {@code \n},
+	 * respectively.
+	 * 
+	 * <p>
+	 * The encoded string contains no leading or trailing whitespace characters.
+	 * A single space character is used between <i>access</i> and <code>{</code>
+	 * and between <code>}</code> and <i>name</i>, if <i>name</i> is present.
+	 * All encoded conditions and permissions are separated by a single space
+	 * character.
+	 * 
+	 * @return The string encoding of this {@code ConditionalPermissionInfo}.
+	 * @since 1.1
+	 */
+	String getEncoded();
+
+	/**
+	 * Returns the string representation of this
+	 * {@code ConditionalPermissionInfo}. The string is created by calling
+	 * the {@code getEncoded} method on this
+	 * {@code ConditionalPermissionInfo}.
+	 * 
+	 * @return The string representation of this
+	 *         {@code ConditionalPermissionInfo}.
+	 * @since 1.1
+	 */
+	String toString();
+
+	/**
+	 * Determines the equality of two {@code ConditionalPermissionInfo}
+	 * objects.
+	 * 
+	 * This method checks that specified object has the same access decision,
+	 * conditions, permissions and name as this
+	 * {@code ConditionalPermissionInfo} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code ConditionalPermissionInfo} object.
+	 * @return {@code true} if {@code obj} is a
+	 *         {@code ConditionalPermissionInfo}, and has the same access
+	 *         decision, conditions, permissions and name as this
+	 *         {@code ConditionalPermissionInfo} object; {@code false}
+	 *         otherwise.
+	 * @since 1.1
+	 */
+	 boolean equals(Object obj);
+ 
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 * @since 1.1
+	 */
+	int hashCode();
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionUpdate.java b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionUpdate.java
new file mode 100644
index 0000000000..4ba86f3ad8
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/ConditionalPermissionUpdate.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) OSGi Alliance (2008, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.condpermadmin;
+
+import java.util.List;
+
+/**
+ * Update the Conditional Permission Table. There may be many update objects in
+ * the system at one time. If commit is called and the Conditional Permission
+ * Table has been modified since this update was created, then the call to
+ * commit will fail and this object should be discarded.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 3b16b47db71fa449d60d5acdcc9f7dddc7679a25 $
+ * @since 1.1
+ */
+public interface ConditionalPermissionUpdate {
+	/**
+	 * This method returns the list of {@link ConditionalPermissionInfo}s for
+	 * this update. This list is originally based on the Conditional Permission
+	 * Table at the time this update was created. The list returned by this
+	 * method will be replace the Conditional Permission Table if commit is
+	 * called and is successful.
+	 * <p>
+	 * The {@link ConditionalPermissionInfo#delete delete} method of the
+	 * ConditionalPermissionInfos in the list must throw
+	 * UnsupportedOperationException.
+	 * <p>
+	 * The list returned by this method is ordered and the most significant
+	 * table entry is the first entry in the list.
+	 * 
+	 * @return A {@code List} of the {@link ConditionalPermissionInfo}s
+	 *         which represent the Conditional Permissions maintained by this
+	 *         update. Modifications to this list will not affect the
+	 *         Conditional Permission Table until successfully committed. The
+	 *         list may be empty if the Conditional Permission Table was empty
+	 *         when this update was created.
+	 */
+	List<ConditionalPermissionInfo> getConditionalPermissionInfos();
+
+	/**
+	 * Commit this update. If no changes have been made to the Conditional
+	 * Permission Table since this update was created, then this method will
+	 * replace the Conditional Permission Table with this update's Conditional
+	 * Permissions. This method may only be successfully called once on this
+	 * object.
+	 * <p>
+	 * If any of the {@link ConditionalPermissionInfo}s in the update list has
+	 * {@code null} as a name it will be replaced with a new
+	 * {@link ConditionalPermissionInfo} object that has a generated name which
+	 * is unique within the list.
+	 * <p>
+	 * No two entries in this update's Conditional Permissions may have the same
+	 * name. Other consistency checks may also be performed. If this update's
+	 * Conditional Permissions are determined to be inconsistent in some way
+	 * then an {@code IllegalStateException} will be thrown.
+	 * <p>
+	 * This method returns {@code false} if the commit did not occur
+	 * because the Conditional Permission Table has been modified since the
+	 * creation of this update.
+	 * 
+	 * @return {@code true} if the commit was successful.
+	 *         {@code false} if the commit did not occur because the
+	 *         Conditional Permission Table has been modified since the creation
+	 *         of this update.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 * @throws IllegalStateException If this update's Conditional Permissions
+	 *         are not valid or inconsistent. For example, this update has two
+	 *         Conditional Permissions in it with the same name.
+	 */
+	boolean commit();
+}
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/package-info.java b/main/src/main/java/org/osgi/service/condpermadmin/package-info.java
new file mode 100644
index 0000000000..2109a311a5
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Conditional Permission Admin Package Version 1.1.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.service.condpermadmin; version="[1.1,2.0)"}
+ * 
+ * @version $Id: cb84fc1342d7f8863ec8eae2dd244843246b2fc1 $
+ */
+
+package org.osgi.service.condpermadmin;
diff --git a/main/src/main/java/org/osgi/service/condpermadmin/packageinfo b/main/src/main/java/org/osgi/service/condpermadmin/packageinfo
new file mode 100644
index 0000000000..bb27c604dd
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/condpermadmin/packageinfo
@@ -0,0 +1 @@
+version 1.1.1
diff --git a/main/src/main/java/org/osgi/service/packageadmin/ExportedPackage.java b/main/src/main/java/org/osgi/service/packageadmin/ExportedPackage.java
new file mode 100644
index 0000000000..abe1515420
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/packageadmin/ExportedPackage.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.packageadmin;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Version;
+
+/**
+ * An exported package.
+ * 
+ * Objects implementing this interface are created by the Package Admin service.
+ * 
+ * <p>
+ * The term <i>exported package</i> refers to a package that has been exported
+ * from a resolved bundle. This package may or may not be currently wired to
+ * other bundles.
+ * 
+ * <p>
+ * The information about an exported package provided by this object may change.
+ * An {@code ExportedPackage} object becomes stale if the package it
+ * references has been updated or removed as a result of calling
+ * {@code PackageAdmin.refreshPackages()}.
+ * 
+ * If this object becomes stale, its {@code getName()} and
+ * {@code getVersion()} methods continue to return their original values,
+ * {@code isRemovalPending()} returns {@code true}, and
+ * {@code getExportingBundle()} and {@code getImportingBundles()}
+ * return {@code null}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @deprecated The PackageAdmin service has been replaced by the
+ *             <code>org.osgi.framework.wiring</code> package.
+ * @version $Id: c56b99465e3f62a9808297a47de8cb7edb802119 $
+ */
+public interface ExportedPackage {
+	/**
+	 * Returns the name of the package associated with this exported package.
+	 * 
+	 * @return The name of this exported package.
+	 */
+	public String getName();
+
+	/**
+	 * Returns the bundle exporting the package associated with this exported
+	 * package.
+	 * 
+	 * @return The exporting bundle, or {@code null} if this
+	 *         {@code ExportedPackage} object has become stale.
+	 */
+	public Bundle getExportingBundle();
+
+	/**
+	 * Returns the resolved bundles that are currently wired to this exported
+	 * package.
+	 * 
+	 * <p>
+	 * Bundles which require the exporting bundle associated with this exported
+	 * package are considered to be wired to this exported package are included
+	 * in the returned array. See {@link RequiredBundle#getRequiringBundles()}.
+	 * 
+	 * @return The array of resolved bundles currently wired to this exported
+	 *         package, or {@code null} if this
+	 *         {@code ExportedPackage} object has become stale. The array
+	 *         will be empty if no bundles are wired to this exported package.
+	 */
+	public Bundle[] getImportingBundles();
+
+	/**
+	 * Returns the version of this exported package.
+	 * 
+	 * @return The version of this exported package, or {@code null} if
+	 *         no version information is available.
+	 * @deprecated As of 1.2, replaced by {@link #getVersion}.
+	 */
+	public String getSpecificationVersion();
+
+	/**
+	 * Returns the version of this exported package.
+	 * 
+	 * @return The version of this exported package, or
+	 *         {@link Version#emptyVersion} if no version information is
+	 *         available.
+	 * @since 1.2
+	 */
+	public Version getVersion();
+
+	/**
+	 * Returns {@code true} if the package associated with this
+	 * {@code ExportedPackage} object has been exported by a bundle that
+	 * has been updated or uninstalled.
+	 * 
+	 * @return {@code true} if the associated package is being exported
+	 *         by a bundle that has been updated or uninstalled, or if this
+	 *         {@code ExportedPackage} object has become stale;
+	 *         {@code false} otherwise.
+	 */
+	public boolean isRemovalPending();
+}
diff --git a/main/src/main/java/org/osgi/service/packageadmin/PackageAdmin.java b/main/src/main/java/org/osgi/service/packageadmin/PackageAdmin.java
new file mode 100644
index 0000000000..2c5789064f
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/packageadmin/PackageAdmin.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.packageadmin;
+
+import org.osgi.framework.Bundle;
+
+/**
+ * Framework service which allows bundle programmers to inspect the package
+ * wiring state of bundles in the Framework as well as other functions related
+ * to the class loader network among bundles.
+ * 
+ * <p>
+ * If present, there will only be a single instance of this service registered
+ * with the Framework.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: a268c3bdc986080fa16bdb2f56ba1d3800d030dd $
+ * @deprecated This service has been replaced by the
+ *             <code>org.osgi.framework.wiring</code> package.
+ * @see org.osgi.service.packageadmin.ExportedPackage
+ * @see org.osgi.service.packageadmin.RequiredBundle
+ */
+public interface PackageAdmin {
+	/**
+	 * Gets the exported packages for the specified bundle.
+	 * 
+	 * @param bundle The bundle whose exported packages are to be returned, or
+	 *        {@code null} if all exported packages are to be returned. If
+	 *        the specified bundle is the system bundle (that is, the bundle
+	 *        with id zero), this method returns all the packages known to be
+	 *        exported by the system bundle. This will include the package
+	 *        specified by the {@code org.osgi.framework.system.packages}
+	 *        system property as well as any other package exported by the
+	 *        framework implementation.
+	 * 
+	 * @return An array of exported packages, or {@code null} if the
+	 *         specified bundle has no exported packages.
+	 * @throws IllegalArgumentException If the specified {@code Bundle} was
+	 *         not created by the same framework instance that registered this
+	 *         {@code PackageAdmin} service.
+	 */
+	public ExportedPackage[] getExportedPackages(Bundle bundle);
+
+	/**
+	 * Gets the exported packages for the specified package name.
+	 * 
+	 * @param name The name of the exported packages to be returned.
+	 * 
+	 * @return An array of the exported packages, or {@code null} if no
+	 *         exported packages with the specified name exists.
+	 * @since 1.2
+	 */
+	public ExportedPackage[] getExportedPackages(String name);
+
+	/**
+	 * Gets the exported package for the specified package name.
+	 * 
+	 * <p>
+	 * If there are multiple exported packages with specified name, the exported
+	 * package with the highest version will be returned.
+	 * 
+	 * @param name The name of the exported package to be returned.
+	 * 
+	 * @return The exported package, or {@code null} if no exported
+	 *         package with the specified name exists.
+	 * @see #getExportedPackages(String)
+	 */
+	public ExportedPackage getExportedPackage(String name);
+
+	/**
+	 * Forces the update (replacement) or removal of packages exported by the
+	 * specified bundles.
+	 * 
+	 * <p>
+	 * If no bundles are specified, this method will update or remove any
+	 * packages exported by any bundles that were previously updated or
+	 * uninstalled since the last call to this method. The technique by which
+	 * this is accomplished may vary among different Framework implementations.
+	 * One permissible implementation is to stop and restart the Framework.
+	 * 
+	 * <p>
+	 * This method returns to the caller immediately and then performs the
+	 * following steps on a separate thread:
+	 * 
+	 * <ol>
+	 * <li>Compute a graph of bundles starting with the specified bundles. If no
+	 * bundles are specified, compute a graph of bundles starting with bundle
+	 * updated or uninstalled since the last call to this method. Add to the
+	 * graph any bundle that is wired to a package that is currently exported by
+	 * a bundle in the graph. The graph is fully constructed when there is no
+	 * bundle outside the graph that is wired to a bundle in the graph. The
+	 * graph may contain {@code UNINSTALLED} bundles that are currently
+	 * still exporting packages.
+	 * 
+	 * <li>Each bundle in the graph that is in the {@code ACTIVE} state
+	 * will be stopped as described in the {@code Bundle.stop} method.
+	 * 
+	 * <li>Each bundle in the graph that is in the {@code RESOLVED} state
+	 * is unresolved and thus moved to the {@code INSTALLED} state. The
+	 * effect of this step is that bundles in the graph are no longer
+	 * {@code RESOLVED}.
+	 * 
+	 * <li>Each bundle in the graph that is in the {@code UNINSTALLED}
+	 * state is removed from the graph and is now completely removed from the
+	 * Framework.
+	 * 
+	 * <li>Each bundle in the graph that was in the {@code ACTIVE} state
+	 * prior to Step 2 is started as described in the {@code Bundle.start}
+	 * method, causing all bundles required for the restart to be resolved. It
+	 * is possible that, as a result of the previous steps, packages that were
+	 * previously exported no longer are. Therefore, some bundles may be
+	 * unresolvable until another bundle offering a compatible package for
+	 * export has been installed in the Framework.
+	 * <li>A framework event of type
+	 * {@code FrameworkEvent.PACKAGES_REFRESHED} is fired.
+	 * </ol>
+	 * 
+	 * <p>
+	 * For any exceptions that are thrown during any of these steps, a
+	 * {@code FrameworkEvent} of type {@code ERROR} is fired
+	 * containing the exception. The source bundle for these events should be
+	 * the specific bundle to which the exception is related. If no specific
+	 * bundle can be associated with the exception then the System Bundle must
+	 * be used as the source bundle for the event.
+	 * 
+	 * @param bundles The bundles whose exported packages are to be updated or
+	 *        removed, or {@code null} for all bundles updated or
+	 *        uninstalled since the last call to this method.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,RESOLVE]} and the Java
+	 *         runtime environment supports permissions.
+	 * @throws IllegalArgumentException If the specified {@code Bundle}s
+	 *         were not created by the same framework instance that registered
+	 *         this {@code PackageAdmin} service.
+	 */
+	public void refreshPackages(Bundle[] bundles);
+
+	/**
+	 * Resolve the specified bundles. The Framework must attempt to resolve the
+	 * specified bundles that are unresolved. Additional bundles that are not
+	 * included in the specified bundles may be resolved as a result of calling
+	 * this method. A permissible implementation of this method is to attempt to
+	 * resolve all unresolved bundles installed in the framework.
+	 * 
+	 * <p>
+	 * If {@code null} is specified then the Framework will attempt to
+	 * resolve all unresolved bundles. This method must not cause any bundle to
+	 * be refreshed, stopped, or started. This method will not return until the
+	 * operation has completed.
+	 * 
+	 * @param bundles The bundles to resolve or {@code null} to resolve all
+	 *        unresolved bundles installed in the Framework.
+	 * @return {@code true} if all specified bundles are resolved;
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,RESOLVE]} and the Java
+	 *         runtime environment supports permissions.
+	 * @throws IllegalArgumentException If the specified {@code Bundle}s
+	 *         were not created by the same framework instance that registered
+	 *         this {@code PackageAdmin} service.
+	 * @since 1.2
+	 */
+	public boolean resolveBundles(Bundle[] bundles);
+
+	/**
+	 * Returns an array of required bundles having the specified symbolic name.
+	 * 
+	 * <p>
+	 * If {@code null} is specified, then all required bundles will be
+	 * returned.
+	 * 
+	 * @param symbolicName The bundle symbolic name or {@code null} for
+	 *        all required bundles.
+	 * @return An array of required bundles or {@code null} if no
+	 *         required bundles exist for the specified symbolic name.
+	 * @since 1.2
+	 */
+	public RequiredBundle[] getRequiredBundles(String symbolicName);
+
+	/**
+	 * Returns the bundles with the specified symbolic name whose bundle version
+	 * is within the specified version range. If no bundles are installed that
+	 * have the specified symbolic name, then {@code null} is returned.
+	 * If a version range is specified, then only the bundles that have the
+	 * specified symbolic name and whose bundle versions belong to the specified
+	 * version range are returned. The returned bundles are ordered by version
+	 * in descending version order so that the first element of the array
+	 * contains the bundle with the highest version.
+	 * 
+	 * @see org.osgi.framework.Constants#BUNDLE_VERSION_ATTRIBUTE
+	 * @param symbolicName The symbolic name of the desired bundles.
+	 * @param versionRange The version range of the desired bundles, or
+	 *        {@code null} if all versions are desired.
+	 * @return An array of bundles with the specified name belonging to the
+	 *         specified version range ordered in descending version order, or
+	 *         {@code null} if no bundles are found.
+	 * @since 1.2
+	 */
+	public Bundle[] getBundles(String symbolicName, String versionRange);
+
+	/**
+	 * Returns an array of attached fragment bundles for the specified bundle.
+	 * If the specified bundle is a fragment then {@code null} is returned.
+	 * If no fragments are attached to the specified bundle then
+	 * {@code null} is returned.
+	 * <p>
+	 * This method does not attempt to resolve the specified bundle. If the
+	 * specified bundle is not resolved then {@code null} is returned.
+	 * 
+	 * @param bundle The bundle whose attached fragment bundles are to be
+	 *        returned.
+	 * @return An array of fragment bundles or {@code null} if the bundle
+	 *         does not have any attached fragment bundles or the bundle is not
+	 *         resolved.
+	 * @throws IllegalArgumentException If the specified {@code Bundle} was
+	 *         not created by the same framework instance that registered this
+	 *         {@code PackageAdmin} service.
+	 * @since 1.2
+	 */
+	public Bundle[] getFragments(Bundle bundle);
+
+	/**
+	 * Returns the host bundles to which the specified fragment bundle is
+	 * attached.
+	 * 
+	 * @param bundle The fragment bundle whose host bundles are to be returned.
+	 * @return An array containing the host bundles to which the specified
+	 *         fragment is attached or {@code null} if the specified bundle
+	 *         is not a fragment or is not attached to any host bundles.
+	 * @throws IllegalArgumentException If the specified {@code Bundle} was
+	 *         not created by the same framework instance that registered this
+	 *         {@code PackageAdmin} service.
+	 * @since 1.2
+	 */
+	public Bundle[] getHosts(Bundle bundle);
+
+	/**
+	 * Returns the bundle from which the specified class is loaded. The class
+	 * loader of the returned bundle must have been used to load the specified
+	 * class. If the class was not loaded by a bundle class loader then
+	 * {@code null} is returned.
+	 * 
+	 * @param clazz The class object from which to locate the bundle.
+	 * @return The bundle from which the specified class is loaded or
+	 *         {@code null} if the class was not loaded by a bundle class
+	 *         loader created by the same framework instance that registered
+	 *         this {@code PackageAdmin} service.
+	 * @since 1.2
+	 */
+	public Bundle getBundle(Class clazz);
+
+	/**
+	 * Bundle type indicating the bundle is a fragment bundle.
+	 * 
+	 * <p>
+	 * The value of {@code BUNDLE_TYPE_FRAGMENT} is 0x00000001.
+	 * 
+	 * @since 1.2
+	 */
+	public static final int	BUNDLE_TYPE_FRAGMENT	= 0x00000001;
+
+	/**
+	 * Returns the special type of the specified bundle. The bundle type values
+	 * are:
+	 * <ul>
+	 * <li>{@link #BUNDLE_TYPE_FRAGMENT}
+	 * </ul>
+	 * 
+	 * A bundle may be more than one type at a time. A type code is used to
+	 * identify the bundle type for future extendability.
+	 * 
+	 * <p>
+	 * If a bundle is not one or more of the defined types then 0x00000000 is
+	 * returned.
+	 * 
+	 * @param bundle The bundle for which to return the special type.
+	 * @return The special type of the bundle.
+	 * @throws IllegalArgumentException If the specified {@code Bundle} was
+	 *         not created by the same framework instance that registered this
+	 *         {@code PackageAdmin} service.
+	 * @since 1.2
+	 */
+	public int getBundleType(Bundle bundle);
+}
diff --git a/main/src/main/java/org/osgi/service/packageadmin/RequiredBundle.java b/main/src/main/java/org/osgi/service/packageadmin/RequiredBundle.java
new file mode 100644
index 0000000000..34c0b080d1
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/packageadmin/RequiredBundle.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) OSGi Alliance (2004, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.packageadmin;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Version;
+
+/**
+ * A required bundle.
+ * 
+ * Objects implementing this interface are created by the Package Admin service.
+ * 
+ * <p>
+ * The term <i>required bundle</i> refers to a resolved bundle that has a bundle
+ * symbolic name and is not a fragment. That is, a bundle that may be required
+ * by other bundles. This bundle may or may not be currently required by other
+ * bundles.
+ * 
+ * <p>
+ * The information about a required bundle provided by this object may change. A
+ * {@code RequiredBundle} object becomes stale if an exported package of
+ * the bundle it references has been updated or removed as a result of calling
+ * {@code PackageAdmin.refreshPackages()}).
+ * 
+ * If this object becomes stale, its {@code getSymbolicName()} and
+ * {@code getVersion()} methods continue to return their original values,
+ * {@code isRemovalPending()} returns true, and {@code getBundle()}
+ * and {@code getRequiringBundles()} return {@code null}.
+ * 
+ * @since 1.2
+ * @ThreadSafe
+ * @noimplement
+ * @deprecated The PackageAdmin service has been replaced by the
+ *             <code>org.osgi.framework.wiring</code> package.
+ * @version $Id: 1606b0422cae6769b7eedc2d565df61841da1e22 $
+ */
+public interface RequiredBundle {
+	/**
+	 * Returns the symbolic name of this required bundle.
+	 * 
+	 * @return The symbolic name of this required bundle.
+	 */
+	public String getSymbolicName();
+
+	/**
+	 * Returns the bundle associated with this required bundle.
+	 * 
+	 * @return The bundle, or {@code null} if this
+	 *         {@code RequiredBundle} object has become stale.
+	 */
+	public Bundle getBundle();
+
+	/**
+	 * Returns the bundles that currently require this required bundle.
+	 * 
+	 * <p>
+	 * If this required bundle is required and then re-exported by another
+	 * bundle then all the requiring bundles of the re-exporting bundle are
+	 * included in the returned array.
+	 * 
+	 * @return An array of bundles currently requiring this required bundle, or
+	 *         {@code null} if this {@code RequiredBundle} object
+	 *         has become stale. The array will be empty if no bundles require
+	 *         this required package.
+	 */
+	public Bundle[] getRequiringBundles();
+
+	/**
+	 * Returns the version of this required bundle.
+	 * 
+	 * @return The version of this required bundle, or
+	 *         {@link Version#emptyVersion} if no version information is
+	 *         available.
+	 */
+	public Version getVersion();
+
+	/**
+	 * Returns {@code true} if the bundle associated with this
+	 * {@code RequiredBundle} object has been updated or uninstalled.
+	 * 
+	 * @return {@code true} if the required bundle has been updated or
+	 *         uninstalled, or if the {@code RequiredBundle} object has
+	 *         become stale; {@code false} otherwise.
+	 */
+	public boolean isRemovalPending();
+}
diff --git a/main/src/main/java/org/osgi/service/packageadmin/package-info.java b/main/src/main/java/org/osgi/service/packageadmin/package-info.java
new file mode 100644
index 0000000000..9d9804d228
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/packageadmin/package-info.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Package Admin Package Version 1.2.
+ * 
+ * <p>
+ * <b>Deprecated.</b>
+ * <i>This package is deprecated and has been replaced by the
+ * {@code org.osgi.framework.wiring} package.</i>
+ *
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.service.packageadmin; version="[1.2,2.0)"}
+ * 
+ * @version $Id: b1c7db22b9c84e48d3c6c711f0ed976e825053c9 $
+ */
+
+package org.osgi.service.packageadmin;
diff --git a/main/src/main/java/org/osgi/service/packageadmin/packageinfo b/main/src/main/java/org/osgi/service/packageadmin/packageinfo
new file mode 100644
index 0000000000..ef7df68cb0
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/packageadmin/packageinfo
@@ -0,0 +1 @@
+version 1.2
diff --git a/main/src/main/java/org/osgi/service/permissionadmin/PermissionAdmin.java b/main/src/main/java/org/osgi/service/permissionadmin/PermissionAdmin.java
new file mode 100644
index 0000000000..e7d1f806a7
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/permissionadmin/PermissionAdmin.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.permissionadmin;
+
+/**
+ * The Permission Admin service allows management agents to manage the
+ * permissions of bundles. There is at most one Permission Admin service present
+ * in the OSGi environment.
+ * <p>
+ * Access to the Permission Admin service is protected by corresponding
+ * {@code ServicePermission}. In addition {@code AdminPermission}
+ * is required to actually set permissions.
+ * 
+ * <p>
+ * Bundle permissions are managed using a permission table. A bundle's location
+ * serves as the key into this permission table. The value of a table entry is
+ * the set of permissions (of type {@code PermissionInfo}) granted to
+ * the bundle named by the given location. A bundle may have an entry in the
+ * permission table prior to being installed in the Framework.
+ * 
+ * <p>
+ * The permissions specified in {@code setDefaultPermissions} are used as
+ * the default permissions which are granted to all bundles that do not have an
+ * entry in the permission table.
+ * 
+ * <p>
+ * Any changes to a bundle's permissions in the permission table will take
+ * effect no later than when bundle's
+ * {@code java.security.ProtectionDomain} is next involved in a
+ * permission check, and will be made persistent.
+ * 
+ * <p>
+ * Only permission classes on the system classpath or from an exported package
+ * are considered during a permission check. Additionally, only permission
+ * classes that are subclasses of {@code java.security.Permission} and
+ * define a 2-argument constructor that takes a <i>name </i> string and an
+ * <i>actions </i> string can be used.
+ * <p>
+ * Permissions implicitly granted by the Framework (for example, a bundle's
+ * permission to access its persistent storage area) cannot be changed, and are
+ * not reflected in the permissions returned by {@code getPermissions}
+ * and {@code getDefaultPermissions}.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: 91132d707097c085fdb3fb7241c9599335427082 $
+ */
+public interface PermissionAdmin {
+	/**
+	 * Gets the permissions assigned to the bundle with the specified location.
+	 * 
+	 * @param location The location of the bundle whose permissions are to be
+	 *        returned.
+	 * 
+	 * @return The permissions assigned to the bundle with the specified
+	 *         location, or {@code null} if that bundle has not been
+	 *         assigned any permissions.
+	 */
+	PermissionInfo[] getPermissions(String location);
+
+	/**
+	 * Assigns the specified permissions to the bundle with the specified
+	 * location.
+	 * 
+	 * @param location The location of the bundle that will be assigned the
+	 *        permissions.
+	 * @param permissions The permissions to be assigned, or {@code null}
+	 *        if the specified location is to be removed from the permission
+	 *        table.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 */
+	void setPermissions(String location, PermissionInfo[] permissions);
+
+	/**
+	 * Returns the bundle locations that have permissions assigned to them, that
+	 * is, bundle locations for which an entry exists in the permission table.
+	 * 
+	 * @return The locations of bundles that have been assigned any permissions,
+	 *         or {@code null} if the permission table is empty.
+	 */
+	String[] getLocations();
+
+	/**
+	 * Gets the default permissions.
+	 * 
+	 * <p>
+	 * These are the permissions granted to any bundle that does not have
+	 * permissions assigned to its location.
+	 * 
+	 * @return The default permissions, or {@code null} if no default
+	 *         permissions are set.
+	 */
+	PermissionInfo[] getDefaultPermissions();
+
+	/**
+	 * Sets the default permissions.
+	 * 
+	 * <p>
+	 * These are the permissions granted to any bundle that does not have
+	 * permissions assigned to its location.
+	 * 
+	 * @param permissions The default permissions, or {@code null} if the
+	 *        default permissions are to be removed from the permission table.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AllPermission}.
+	 */
+	void setDefaultPermissions(PermissionInfo[] permissions);
+}
diff --git a/main/src/main/java/org/osgi/service/permissionadmin/PermissionInfo.java b/main/src/main/java/org/osgi/service/permissionadmin/PermissionInfo.java
new file mode 100644
index 0000000000..a0a91879a1
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/permissionadmin/PermissionInfo.java
@@ -0,0 +1,417 @@
+/*
+ * Copyright (c) OSGi Alliance (2001, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.permissionadmin;
+
+/**
+ * Permission representation used by the Permission Admin service.
+ * 
+ * <p>
+ * This class encapsulates three pieces of information: a Permission <i>type
+ * </i> (class name), which must be a subclass of
+ * {@code java.security.Permission}, and the <i>name</i> and <i>actions</i>
+ * arguments passed to its constructor.
+ * 
+ * <p>
+ * In order for a permission represented by a {@code PermissionInfo} to be
+ * instantiated and considered during a permission check, its Permission class
+ * must be available from the system classpath or an exported package. This
+ * means that the instantiation of a permission represented by a
+ * {@code PermissionInfo} may be delayed until the package containing its
+ * Permission class has been exported by a bundle.
+ * 
+ * @Immutable
+ * @version $Id: b9516d07ada162fb8fc750f09e1e3a686189c46b $
+ */
+public class PermissionInfo {
+	private final String	type;
+	private final String	name;
+	private final String	actions;
+
+	/**
+	 * Constructs a {@code PermissionInfo} from the specified type, name,
+	 * and actions.
+	 * 
+	 * @param type The fully qualified class name of the permission represented
+	 *        by this {@code PermissionInfo}. The class must be a subclass
+	 *        of {@code java.security.Permission} and must define a
+	 *        2-argument constructor that takes a <i>name</i> string and an
+	 *        <i>actions</i> string.
+	 * 
+	 * @param name The permission name that will be passed as the first argument
+	 *        to the constructor of the {@code Permission} class identified
+	 *        by {@code type}.
+	 * 
+	 * @param actions The permission actions that will be passed as the second
+	 *        argument to the constructor of the {@code Permission} class
+	 *        identified by {@code type}.
+	 * 
+	 * @throws NullPointerException If {@code type} is {@code null}.
+	 * @throws IllegalArgumentException If {@code action} is not
+	 *         {@code null} and {@code name} is {@code null}.
+	 */
+	public PermissionInfo(String type, String name, String actions) {
+		this.type = type;
+		this.name = name;
+		this.actions = actions;
+		if (type == null) {
+			throw new NullPointerException("type is null");
+		}
+		if ((name == null) && (actions != null)) {
+			throw new IllegalArgumentException("name missing");
+		}
+	}
+
+	/**
+	 * Constructs a {@code PermissionInfo} object from the specified
+	 * encoded {@code PermissionInfo} string. White space in the encoded
+	 * {@code PermissionInfo} string is ignored.
+	 * 
+	 * 
+	 * @param encodedPermission The encoded {@code PermissionInfo}.
+	 * @see #getEncoded
+	 * @throws IllegalArgumentException If the specified
+	 *         {@code encodedPermission} is not properly formatted.
+	 */
+	public PermissionInfo(String encodedPermission) {
+		if (encodedPermission == null) {
+			throw new NullPointerException("missing encoded permission");
+		}
+		if (encodedPermission.length() == 0) {
+			throw new IllegalArgumentException("empty encoded permission");
+		}
+		String parsedType = null;
+		String parsedName = null;
+		String parsedActions = null;
+		try {
+			char[] encoded = encodedPermission.toCharArray();
+			int length = encoded.length;
+			int pos = 0;
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* the first character must be '(' */
+			if (encoded[pos] != '(') {
+				throw new IllegalArgumentException("expecting open parenthesis");
+			}
+			pos++;
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* type is not quoted or encoded */
+			int begin = pos;
+			while (!Character.isWhitespace(encoded[pos])
+					&& (encoded[pos] != ')')) {
+				pos++;
+			}
+			if (pos == begin || encoded[begin] == '"') {
+				throw new IllegalArgumentException("expecting type");
+			}
+			parsedType = new String(encoded, begin, pos - begin);
+
+			/* skip whitespace */
+			while (Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+
+			/* type may be followed by name which is quoted and encoded */
+			if (encoded[pos] == '"') {
+				pos++;
+				begin = pos;
+				while (encoded[pos] != '"') {
+					if (encoded[pos] == '\\') {
+						pos++;
+					}
+					pos++;
+				}
+				parsedName = unescapeString(encoded, begin, pos);
+				pos++;
+
+				if (Character.isWhitespace(encoded[pos])) {
+					/* skip whitespace */
+					while (Character.isWhitespace(encoded[pos])) {
+						pos++;
+					}
+
+					/*
+					 * name may be followed by actions which is quoted and
+					 * encoded
+					 */
+					if (encoded[pos] == '"') {
+						pos++;
+						begin = pos;
+						while (encoded[pos] != '"') {
+							if (encoded[pos] == '\\') {
+								pos++;
+							}
+							pos++;
+						}
+						parsedActions = unescapeString(encoded, begin, pos);
+						pos++;
+
+						/* skip whitespace */
+						while (Character.isWhitespace(encoded[pos])) {
+							pos++;
+						}
+					}
+				}
+			}
+
+			/* the final character must be ')' */
+			char c = encoded[pos];
+			pos++;
+			while ((pos < length) && Character.isWhitespace(encoded[pos])) {
+				pos++;
+			}
+			if ((c != ')') || (pos != length)) {
+				throw new IllegalArgumentException(
+						"expecting close parenthesis");
+			}
+		}
+		catch (ArrayIndexOutOfBoundsException e) {
+			throw new IllegalArgumentException("parsing terminated abruptly");
+		}
+
+		type = parsedType;
+		name = parsedName;
+		actions = parsedActions;
+	}
+
+	/**
+	 * Returns the string encoding of this {@code PermissionInfo} in a form
+	 * suitable for restoring this {@code PermissionInfo}.
+	 * 
+	 * <p>
+	 * The encoded format is:
+	 * 
+	 * <pre>
+	 * (type)
+	 * </pre>
+	 * 
+	 * or
+	 * 
+	 * <pre>
+	 * (type &quot;name&quot;)
+	 * </pre>
+	 * 
+	 * or
+	 * 
+	 * <pre>
+	 * (type &quot;name&quot; &quot;actions&quot;)
+	 * </pre>
+	 * 
+	 * where <i>name</i> and <i>actions</i> are strings that must be encoded for
+	 * proper parsing. Specifically, the {@code &quot;},{@code \},
+	 * carriage return, and line feed characters must be escaped using
+	 * {@code \&quot;}, {@code \\},{@code \r}, and
+	 * {@code \n}, respectively.
+	 * 
+	 * <p>
+	 * The encoded string contains no leading or trailing whitespace characters.
+	 * A single space character is used between <i>type</i> and
+	 * &quot;<i>name</i>&quot; and between &quot;<i>name</i>&quot; and
+	 * &quot;<i>actions</i>&quot;.
+	 * 
+	 * @return The string encoding of this {@code PermissionInfo}.
+	 */
+	public final String getEncoded() {
+		StringBuffer output = new StringBuffer(
+				8
+						+ type.length()
+						+ ((((name == null) ? 0 : name.length()) + ((actions == null) ? 0
+								: actions.length())) << 1));
+		output.append('(');
+		output.append(type);
+		if (name != null) {
+			output.append(" \"");
+			escapeString(name, output);
+			if (actions != null) {
+				output.append("\" \"");
+				escapeString(actions, output);
+			}
+			output.append('\"');
+		}
+		output.append(')');
+		return output.toString();
+	}
+
+	/**
+	 * Returns the string representation of this {@code PermissionInfo}.
+	 * The string is created by calling the {@code getEncoded} method on
+	 * this {@code PermissionInfo}.
+	 * 
+	 * @return The string representation of this {@code PermissionInfo}.
+	 */
+	public String toString() {
+		return getEncoded();
+	}
+
+	/**
+	 * Returns the fully qualified class name of the permission represented by
+	 * this {@code PermissionInfo}.
+	 * 
+	 * @return The fully qualified class name of the permission represented by
+	 *         this {@code PermissionInfo}.
+	 */
+	public final String getType() {
+		return type;
+	}
+
+	/**
+	 * Returns the name of the permission represented by this
+	 * {@code PermissionInfo}.
+	 * 
+	 * @return The name of the permission represented by this
+	 *         {@code PermissionInfo}, or {@code null} if the
+	 *         permission does not have a name.
+	 */
+	public final String getName() {
+		return name;
+	}
+
+	/**
+	 * Returns the actions of the permission represented by this
+	 * {@code PermissionInfo}.
+	 * 
+	 * @return The actions of the permission represented by this
+	 *         {@code PermissionInfo}, or {@code null} if the
+	 *         permission does not have any actions associated with it.
+	 */
+	public final String getActions() {
+		return actions;
+	}
+
+	/**
+	 * Determines the equality of two {@code PermissionInfo} objects.
+	 * 
+	 * This method checks that specified object has the same type, name and
+	 * actions as this {@code PermissionInfo} object.
+	 * 
+	 * @param obj The object to test for equality with this
+	 *        {@code PermissionInfo} object.
+	 * @return {@code true} if {@code obj} is a
+	 *         {@code PermissionInfo}, and has the same type, name and
+	 *         actions as this {@code PermissionInfo} object;
+	 *         {@code false} otherwise.
+	 */
+	public boolean equals(Object obj) {
+		if (obj == this) {
+			return true;
+		}
+		if (!(obj instanceof PermissionInfo)) {
+			return false;
+		}
+		PermissionInfo other = (PermissionInfo) obj;
+		if (!type.equals(other.type) || ((name == null) ^ (other.name == null))
+				|| ((actions == null) ^ (other.actions == null))) {
+			return false;
+		}
+		if (name != null) {
+			if (actions != null) {
+				return name.equals(other.name) && actions.equals(other.actions);
+			}
+			else {
+				return name.equals(other.name);
+			}
+		}
+		else {
+			return true;
+		}
+	}
+
+	/**
+	 * Returns the hash code value for this object.
+	 * 
+	 * @return A hash code value for this object.
+	 */
+	public int hashCode() {
+		int h = 31 * 17 + type.hashCode();
+		if (name != null) {
+			h = 31 * h + name.hashCode();
+			if (actions != null) {
+				h = 31 * h + actions.hashCode();
+			}
+		}
+		return h;
+	}
+
+	/**
+	 * This escapes the quotes, backslashes, \n, and \r in the string using a
+	 * backslash and appends the newly escaped string to a StringBuffer.
+	 */
+	private static void escapeString(String str, StringBuffer output) {
+		int len = str.length();
+		for (int i = 0; i < len; i++) {
+			char c = str.charAt(i);
+			switch (c) {
+				case '"' :
+				case '\\' :
+					output.append('\\');
+					output.append(c);
+					break;
+				case '\r' :
+					output.append("\\r");
+					break;
+				case '\n' :
+					output.append("\\n");
+					break;
+				default :
+					output.append(c);
+					break;
+			}
+		}
+	}
+
+	/**
+	 * Takes an encoded character array and decodes it into a new String.
+	 */
+	private static String unescapeString(char[] str, int begin, int end) {
+		StringBuffer output = new StringBuffer(end - begin);
+		for (int i = begin; i < end; i++) {
+			char c = str[i];
+			if (c == '\\') {
+				i++;
+				if (i < end) {
+					c = str[i];
+					switch (c) {
+						case '"' :
+						case '\\' :
+							break;
+						case 'r' :
+							c = '\r';
+							break;
+						case 'n' :
+							c = '\n';
+							break;
+						default :
+							c = '\\';
+							i--;
+							break;
+					}
+				}
+			}
+			output.append(c);
+		}
+
+		return output.toString();
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/permissionadmin/package-info.java b/main/src/main/java/org/osgi/service/permissionadmin/package-info.java
new file mode 100644
index 0000000000..de90404853
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/permissionadmin/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Permission Admin Package Version 1.2.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.service.permissionadmin; version="[1.2,2.0)"}
+ * 
+ * @version $Id: 4e7435396ab10ff2d4f5cce1edbffc3b0ccd5e84 $
+ */
+
+package org.osgi.service.permissionadmin;
diff --git a/main/src/main/java/org/osgi/service/permissionadmin/packageinfo b/main/src/main/java/org/osgi/service/permissionadmin/packageinfo
new file mode 100644
index 0000000000..ef7df68cb0
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/permissionadmin/packageinfo
@@ -0,0 +1 @@
+version 1.2
diff --git a/main/src/main/java/org/osgi/service/startlevel/StartLevel.java b/main/src/main/java/org/osgi/service/startlevel/StartLevel.java
new file mode 100644
index 0000000000..5efb41ccc0
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/startlevel/StartLevel.java
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.startlevel;
+
+import org.osgi.framework.Bundle;
+
+/**
+ * The StartLevel service allows management agents to manage a start level
+ * assigned to each bundle and the active start level of the Framework. There is
+ * at most one StartLevel service present in the OSGi environment.
+ * 
+ * <p>
+ * A start level is defined to be a state of execution in which the Framework
+ * exists. StartLevel values are defined as unsigned integers with 0 (zero)
+ * being the state where the Framework is not launched. Progressively higher
+ * integral values represent progressively higher start levels. e.g. 2 is a
+ * higher start level than 1.
+ * <p>
+ * Access to the StartLevel service is protected by corresponding
+ * {@code ServicePermission}. In addition {@code AdminPermission}
+ * is required to actually modify start level information.
+ * <p>
+ * Start Level support in the Framework includes the ability to control the
+ * beginning start level of the Framework, to modify the active start level of
+ * the Framework and to assign a specific start level to a bundle. How the
+ * beginning start level of a Framework is specified is implementation
+ * dependent. It may be a command line argument when invoking the Framework
+ * implementation.
+ * <p>
+ * When the Framework is first started it must be at start level zero. In this
+ * state, no bundles are running. This is the initial state of the Framework
+ * before it is launched.
+ * 
+ * When the Framework is launched, the Framework will enter start level one and
+ * all bundles which are assigned to start level one and whose autostart setting
+ * indicates the bundle should be started are started as described in the
+ * {@code Bundle.start} method. The Framework will continue to increase
+ * the start level, starting bundles at each start level, until the Framework
+ * has reached a beginning start level. At this point the Framework has
+ * completed starting bundles and will then fire a Framework event of type
+ * {@code FrameworkEvent.STARTED} to announce it has completed its
+ * launch.
+ * 
+ * <p>
+ * Within a start level, bundles may be started in an order defined by the
+ * Framework implementation. This may be something like ascending
+ * {@code Bundle.getBundleId} order or an order based upon dependencies
+ * between bundles. A similar but reversed order may be used when stopping
+ * bundles within a start level.
+ * 
+ * <p>
+ * The StartLevel service can be used by management bundles to alter the active
+ * start level of the framework.
+ * 
+ * @ThreadSafe
+ * @noimplement
+ * @version $Id: bf1b71ed6c9f9d75785b26dccb34362017d93f4a $
+ * @deprecated This service has been replaced by the
+ *             <code>org.osgi.framework.startlevel</code> package.
+ */
+public interface StartLevel {
+	/**
+	 * Return the active start level value of the Framework.
+	 * 
+	 * If the Framework is in the process of changing the start level this
+	 * method must return the active start level if this differs from the
+	 * requested start level.
+	 * 
+	 * @return The active start level value of the Framework.
+	 */
+	public int getStartLevel();
+
+	/**
+	 * Modify the active start level of the Framework.
+	 * 
+	 * <p>
+	 * The Framework will move to the requested start level. This method will
+	 * return immediately to the caller and the start level change will occur
+	 * asynchronously on another thread.
+	 * 
+	 * <p>
+	 * If the specified start level is higher than the active start level, the
+	 * Framework will continue to increase the start level until the Framework
+	 * has reached the specified start level.
+	 * 
+	 * At each intermediate start level value on the way to and including the
+	 * target start level, the Framework must:
+	 * <ol>
+	 * <li>Change the active start level to the intermediate start level value.
+	 * <li>Start bundles at the intermediate start level whose autostart
+	 * setting indicate they must be started. They are started as described in
+	 * the {@link Bundle#start(int)} method using the
+	 * {@link Bundle#START_TRANSIENT} option. The
+	 * {@link Bundle#START_ACTIVATION_POLICY} option must also be used if
+	 * {@link #isBundleActivationPolicyUsed(Bundle)} returns {@code true}
+	 * for the bundle.
+	 * </ol>
+	 * When this process completes after the specified start level is reached,
+	 * the Framework will fire a Framework event of type
+	 * {@code FrameworkEvent.STARTLEVEL_CHANGED} to announce it has moved
+	 * to the specified start level.
+	 * 
+	 * <p>
+	 * If the specified start level is lower than the active start level, the
+	 * Framework will continue to decrease the start level until the Framework
+	 * has reached the specified start level.
+	 * 
+	 * At each intermediate start level value on the way to and including the
+	 * specified start level, the framework must:
+	 * <ol>
+	 * <li>Stop bundles at the intermediate start level as described in the
+	 * {@link Bundle#stop(int)} method using the {@link Bundle#STOP_TRANSIENT}
+	 * option.
+	 * <li>Change the active start level to the intermediate start level value.
+	 * </ol>
+	 * When this process completes after the specified start level is reached,
+	 * the Framework will fire a Framework event of type
+	 * {@code FrameworkEvent.STARTLEVEL_CHANGED} to announce it has moved
+	 * to the specified start level.
+	 * 
+	 * <p>
+	 * If the specified start level is equal to the active start level, then no
+	 * bundles are started or stopped, however, the Framework must fire a
+	 * Framework event of type {@code FrameworkEvent.STARTLEVEL_CHANGED}
+	 * to announce it has finished moving to the specified start level. This
+	 * event may arrive before this method return.
+	 * 
+	 * @param startlevel The requested start level for the Framework.
+	 * @throws IllegalArgumentException If the specified start level is less
+	 *         than or equal to zero.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,STARTLEVEL]} and the
+	 *         Java runtime environment supports permissions.
+	 */
+	public void setStartLevel(int startlevel);
+
+	/**
+	 * Return the assigned start level value for the specified Bundle.
+	 * 
+	 * @param bundle The target bundle.
+	 * @return The start level value of the specified Bundle.
+	 * @throws java.lang.IllegalArgumentException If the specified bundle has
+	 *         been uninstalled or if the specified bundle was not created by
+	 *         the same framework instance that registered this
+	 *         {@code StartLevel} service.
+	 */
+	public int getBundleStartLevel(Bundle bundle);
+
+	/**
+	 * Assign a start level value to the specified Bundle.
+	 * 
+	 * <p>
+	 * The specified bundle will be assigned the specified start level. The
+	 * start level value assigned to the bundle will be persistently recorded by
+	 * the Framework.
+	 * <p>
+	 * If the new start level for the bundle is lower than or equal to the
+	 * active start level of the Framework and the bundle's autostart setting
+	 * indicates the bundle must be started, the Framework will start the
+	 * specified bundle as described in the {@link Bundle#start(int)} method
+	 * using the {@link Bundle#START_TRANSIENT} option. The
+	 * {@link Bundle#START_ACTIVATION_POLICY} option must also be used if
+	 * {@link #isBundleActivationPolicyUsed(Bundle)} returns {@code true}
+	 * for the bundle. The actual starting of this bundle must occur
+	 * asynchronously.
+	 * <p>
+	 * If the new start level for the bundle is higher than the active start
+	 * level of the Framework, the Framework will stop the specified bundle as
+	 * described in the {@link Bundle#stop(int)} method using the
+	 * {@link Bundle#STOP_TRANSIENT} option. The actual stopping of this bundle
+	 * must occur asynchronously.
+	 * 
+	 * @param bundle The target bundle.
+	 * @param startlevel The new start level for the specified Bundle.
+	 * @throws IllegalArgumentException If the specified bundle has been
+	 *         uninstalled, or if the specified start level is less than or
+	 *         equal to zero, or if the specified bundle is the system bundle,
+	 *         or if the specified bundle was not created by the same framework
+	 *         instance that registered this {@code StartLevel} service.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[bundle,EXECUTE]} and the Java runtime
+	 *         environment supports permissions.
+	 */
+	public void setBundleStartLevel(Bundle bundle, int startlevel);
+
+	/**
+	 * Return the initial start level value that is assigned to a Bundle when it
+	 * is first installed.
+	 * 
+	 * @return The initial start level value for Bundles.
+	 * @see #setInitialBundleStartLevel
+	 */
+	public int getInitialBundleStartLevel();
+
+	/**
+	 * Set the initial start level value that is assigned to a Bundle when it is
+	 * first installed.
+	 * 
+	 * <p>
+	 * The initial bundle start level will be set to the specified start level.
+	 * The initial bundle start level value will be persistently recorded by the
+	 * Framework.
+	 * 
+	 * <p>
+	 * When a Bundle is installed via {@code BundleContext.installBundle},
+	 * it is assigned the initial bundle start level value.
+	 * 
+	 * <p>
+	 * The default initial bundle start level value is 1 unless this method has
+	 * been called to assign a different initial bundle start level value.
+	 * 
+	 * <p>
+	 * This method does not change the start level values of installed bundles.
+	 * 
+	 * @param startlevel The initial start level for newly installed bundles.
+	 * @throws IllegalArgumentException If the specified start level is less
+	 *         than or equal to zero.
+	 * @throws SecurityException If the caller does not have
+	 *         {@code AdminPermission[System Bundle,STARTLEVEL]} and the
+	 *         Java runtime environment supports permissions.
+	 */
+	public void setInitialBundleStartLevel(int startlevel);
+
+	/**
+	 * Returns whether the specified bundle's autostart setting indicates the
+	 * bundle must be started.
+	 * <p>
+	 * The autostart setting of a bundle indicates whether the bundle is to be
+	 * started when its start level is reached.
+	 * 
+	 * @param bundle The bundle whose autostart setting is to be examined.
+	 * @return {@code true} if the autostart setting of the bundle
+	 *         indicates the bundle is to be started. {@code false}
+	 *         otherwise.
+	 * @throws java.lang.IllegalArgumentException If the specified bundle has
+	 *         been uninstalled or if the specified bundle was not created by
+	 *         the same framework instance that registered this
+	 *         {@code StartLevel} service.
+	 * @see Bundle#START_TRANSIENT
+	 */
+	public boolean isBundlePersistentlyStarted(Bundle bundle);
+
+	/**
+	 * Returns whether the specified bundle's autostart setting indicates that
+	 * the activation policy declared in the bundle's manifest must be used.
+	 * <p>
+	 * The autostart setting of a bundle indicates whether the bundle's declared
+	 * activation policy is to be used when the bundle is started.
+	 * 
+	 * @param bundle The bundle whose autostart setting is to be examined.
+	 * @return {@code true} if the bundle's autostart setting indicates the
+	 *         activation policy declared in the manifest must be used.
+	 *         {@code false} if the bundle must be eagerly activated.
+	 * @throws java.lang.IllegalArgumentException If the specified bundle has
+	 *         been uninstalled or if the specified bundle was not created by
+	 *         the same framework instance that registered this
+	 *         {@code StartLevel} service.
+	 * @since 1.1
+	 * @see Bundle#START_ACTIVATION_POLICY
+	 */
+	public boolean isBundleActivationPolicyUsed(Bundle bundle);
+}
diff --git a/main/src/main/java/org/osgi/service/startlevel/package-info.java b/main/src/main/java/org/osgi/service/startlevel/package-info.java
new file mode 100644
index 0000000000..7e4a908318
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/startlevel/package-info.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Start Level Package Version 1.1.
+ * 
+ * <p>
+ * <b>Deprecated.</b>
+ * <i>This package is deprecated and has been replaced by the
+ * {@code org.osgi.framework.startlevel} package.</i>
+ *
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.service.startlevel; version="[1.1,2.0)"}
+ * 
+ * @version $Id: 6e311e6e404688d5f5f88cde403ca2066de7c20b $
+ */
+
+package org.osgi.service.startlevel;
diff --git a/main/src/main/java/org/osgi/service/startlevel/packageinfo b/main/src/main/java/org/osgi/service/startlevel/packageinfo
new file mode 100644
index 0000000000..3987f9c4e8
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/startlevel/packageinfo
@@ -0,0 +1 @@
+version 1.1
diff --git a/main/src/main/java/org/osgi/service/url/AbstractURLStreamHandlerService.java b/main/src/main/java/org/osgi/service/url/AbstractURLStreamHandlerService.java
new file mode 100644
index 0000000000..c20a05158b
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/AbstractURLStreamHandlerService.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.url;
+
+import java.net.*;
+
+/**
+ * Abstract implementation of the {@code URLStreamHandlerService}
+ * interface. All the methods simply invoke the corresponding methods on
+ * {@code java.net.URLStreamHandler} except for {@code parseURL}
+ * and {@code setURL}, which use the {@code URLStreamHandlerSetter}
+ * parameter. Subclasses of this abstract class should not need to override the
+ * {@code setURL} and {@code parseURL(URLStreamHandlerSetter,...)}
+ * methods.
+ * 
+ * @ThreadSafe
+ * @version $Id: 465a0ed86f5d49b338ffc6a13bb68f60f04e54d6 $
+ */
+public abstract class AbstractURLStreamHandlerService extends URLStreamHandler
+		implements URLStreamHandlerService {
+	/**
+	 * @see "java.net.URLStreamHandler.openConnection"
+	 */
+	public abstract URLConnection openConnection(URL u)
+			throws java.io.IOException;
+
+	/**
+	 * The {@code URLStreamHandlerSetter} object passed to the parseURL
+	 * method.
+	 */
+	protected volatile URLStreamHandlerSetter	realHandler;
+
+	/**
+	 * Parse a URL using the {@code URLStreamHandlerSetter} object. This
+	 * method sets the {@code realHandler} field with the specified
+	 * {@code URLStreamHandlerSetter} object and then calls
+	 * {@code parseURL(URL,String,int,int)}.
+	 * 
+	 * @param realHandler The object on which the {@code setURL} method
+	 *        must be invoked for the specified URL.
+	 * @see "java.net.URLStreamHandler.parseURL"
+	 */
+	public void parseURL(URLStreamHandlerSetter realHandler, URL u,
+			String spec, int start, int limit) {
+		this.realHandler = realHandler;
+		parseURL(u, spec, start, limit);
+	}
+
+	/**
+	 * This method calls {@code super.toExternalForm}.
+	 * 
+	 * @see "java.net.URLStreamHandler.toExternalForm"
+	 */
+	public String toExternalForm(URL u) {
+		return super.toExternalForm(u);
+	}
+
+	/**
+	 * This method calls {@code super.equals(URL,URL)}.
+	 * 
+	 * @see "java.net.URLStreamHandler.equals(URL,URL)"
+	 */
+	public boolean equals(URL u1, URL u2) {
+		return super.equals(u1, u2);
+	}
+
+	/**
+	 * This method calls {@code super.getDefaultPort}.
+	 * 
+	 * @see "java.net.URLStreamHandler.getDefaultPort"
+	 */
+	public int getDefaultPort() {
+		return super.getDefaultPort();
+	}
+
+	/**
+	 * This method calls {@code super.getHostAddress}.
+	 * 
+	 * @see "java.net.URLStreamHandler.getHostAddress"
+	 */
+	public InetAddress getHostAddress(URL u) {
+		return super.getHostAddress(u);
+	}
+
+	/**
+	 * This method calls {@code super.hashCode(URL)}.
+	 * 
+	 * @see "java.net.URLStreamHandler.hashCode(URL)"
+	 */
+	public int hashCode(URL u) {
+		return super.hashCode(u);
+	}
+
+	/**
+	 * This method calls {@code super.hostsEqual}.
+	 * 
+	 * @see "java.net.URLStreamHandler.hostsEqual"
+	 */
+	public boolean hostsEqual(URL u1, URL u2) {
+		return super.hostsEqual(u1, u2);
+	}
+
+	/**
+	 * This method calls {@code super.sameFile}.
+	 * 
+	 * @see "java.net.URLStreamHandler.sameFile"
+	 */
+	public boolean sameFile(URL u1, URL u2) {
+		return super.sameFile(u1, u2);
+	}
+
+	/**
+	 * This method calls
+	 * {@code realHandler.setURL(URL,String,String,int,String,String)}.
+	 * 
+	 * @see "java.net.URLStreamHandler.setURL(URL,String,String,int,String,String)"
+	 * @deprecated This method is only for compatibility with handlers written
+	 *             for JDK 1.1.
+	 */
+	protected void setURL(URL u, String proto, String host, int port,
+			String file, String ref) {
+		realHandler.setURL(u, proto, host, port, file, ref);
+	}
+
+	/**
+	 * This method calls
+	 * {@code realHandler.setURL(URL,String,String,int,String,String,String,String)}.
+	 * 
+	 * @see "java.net.URLStreamHandler.setURL(URL,String,String,int,String,String,String,String)"
+	 */
+	protected void setURL(URL u, String proto, String host, int port,
+			String auth, String user, String path, String query, String ref) {
+		realHandler.setURL(u, proto, host, port, auth, user, path, query, ref);
+	}
+}
diff --git a/main/src/main/java/org/osgi/service/url/URLConstants.java b/main/src/main/java/org/osgi/service/url/URLConstants.java
new file mode 100644
index 0000000000..fbf768bb76
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/URLConstants.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.url;
+
+/**
+ * Defines standard names for property keys associated with
+ * {@link URLStreamHandlerService} and {@code java.net.ContentHandler}
+ * services.
+ * 
+ * <p>
+ * The values associated with these keys are of type
+ * {@code java.lang.String[]} or {@code java.lang.String}, unless
+ * otherwise indicated.
+ * 
+ * @noimplement
+ * @version $Id: 5ec8db316249f4b956fe083b986c11153d0fa8fe $
+ */
+public interface URLConstants {
+	/**
+	 * Service property naming the protocols serviced by a
+	 * URLStreamHandlerService. The property's value is a protocol name or an
+	 * array of protocol names.
+	 */
+	public static final String	URL_HANDLER_PROTOCOL	= "url.handler.protocol";
+	/**
+	 * Service property naming the MIME types serviced by a
+	 * java.net.ContentHandler. The property's value is a MIME type or an array
+	 * of MIME types.
+	 */
+	public static final String	URL_CONTENT_MIMETYPE	= "url.content.mimetype";
+}
diff --git a/main/src/main/java/org/osgi/service/url/URLStreamHandlerService.java b/main/src/main/java/org/osgi/service/url/URLStreamHandlerService.java
new file mode 100644
index 0000000000..7cc5d6e16a
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/URLStreamHandlerService.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.url;
+
+import java.net.*;
+
+/**
+ * Service interface with public versions of the protected
+ * {@code java.net.URLStreamHandler} methods.
+ * <p>
+ * The important differences between this interface and the
+ * {@code URLStreamHandler} class are that the {@code setURL}
+ * method is absent and the {@code parseURL} method takes a
+ * {@link URLStreamHandlerSetter} object as the first argument. Classes
+ * implementing this interface must call the {@code setURL} method on the
+ * {@code URLStreamHandlerSetter} object received in the
+ * {@code parseURL} method instead of
+ * {@code URLStreamHandler.setURL} to avoid a
+ * {@code SecurityException}.
+ * 
+ * @see AbstractURLStreamHandlerService
+ * 
+ * @ThreadSafe
+ * @version $Id: 4982ef5b407669975afe2856a9702246d2d9c2ba $
+ */
+public interface URLStreamHandlerService {
+	/**
+	 * @see "java.net.URLStreamHandler.openConnection"
+	 */
+	public URLConnection openConnection(URL u) throws java.io.IOException;
+
+	/**
+	 * Parse a URL. This method is called by the {@code URLStreamHandler}
+	 * proxy, instead of {@code java.net.URLStreamHandler.parseURL},
+	 * passing a {@code URLStreamHandlerSetter} object.
+	 * 
+	 * @param realHandler The object on which {@code setURL} must be
+	 *        invoked for this URL.
+	 * @see "java.net.URLStreamHandler.parseURL"
+	 */
+	public void parseURL(URLStreamHandlerSetter realHandler, URL u,
+			String spec, int start, int limit);
+
+	/**
+	 * @see "java.net.URLStreamHandler.toExternalForm"
+	 */
+	public String toExternalForm(URL u);
+
+	/**
+	 * @see "java.net.URLStreamHandler.equals(URL, URL)"
+	 */
+	public boolean equals(URL u1, URL u2);
+
+	/**
+	 * @see "java.net.URLStreamHandler.getDefaultPort"
+	 */
+	public int getDefaultPort();
+
+	/**
+	 * @see "java.net.URLStreamHandler.getHostAddress"
+	 */
+	public InetAddress getHostAddress(URL u);
+
+	/**
+	 * @see "java.net.URLStreamHandler.hashCode(URL)"
+	 */
+	public int hashCode(URL u);
+
+	/**
+	 * @see "java.net.URLStreamHandler.hostsEqual"
+	 */
+	public boolean hostsEqual(URL u1, URL u2);
+
+	/**
+	 * @see "java.net.URLStreamHandler.sameFile"
+	 */
+	public boolean sameFile(URL u1, URL u2);
+}
diff --git a/main/src/main/java/org/osgi/service/url/URLStreamHandlerSetter.java b/main/src/main/java/org/osgi/service/url/URLStreamHandlerSetter.java
new file mode 100644
index 0000000000..dd2e0c2e70
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/URLStreamHandlerSetter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) OSGi Alliance (2002, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.service.url;
+
+import java.net.URL;
+
+/**
+ * Interface used by {@code URLStreamHandlerService} objects to call the
+ * {@code setURL} method on the proxy {@code URLStreamHandler}
+ * object.
+ * 
+ * <p>
+ * Objects of this type are passed to the
+ * {@link URLStreamHandlerService#parseURL} method. Invoking the
+ * {@code setURL} method on the {@code URLStreamHandlerSetter}
+ * object will invoke the {@code setURL} method on the proxy
+ * {@code URLStreamHandler} object that is actually registered with
+ * {@code java.net.URL} for the protocol.
+ * 
+ * @ThreadSafe
+ * @version $Id: f55d4c29678503c244f56dcb2b5621b3be11cc8d $
+ */
+public interface URLStreamHandlerSetter {
+	/**
+	 * @see "java.net.URLStreamHandler.setURL(URL,String,String,int,String,String)"
+	 * 
+	 * @deprecated This method is only for compatibility with handlers written
+	 *             for JDK 1.1.
+	 */
+	public void setURL(URL u, String protocol, String host, int port,
+			String file, String ref);
+
+	/**
+	 * @see "java.net.URLStreamHandler.setURL(URL,String,String,int,String,String,String,String)"
+	 */
+	public void setURL(URL u, String protocol, String host, int port,
+			String authority, String userInfo, String path, String query,
+			String ref);
+}
diff --git a/main/src/main/java/org/osgi/service/url/package-info.java b/main/src/main/java/org/osgi/service/url/package-info.java
new file mode 100644
index 0000000000..9480381c52
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/package-info.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) OSGi Alliance (2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * URL Stream and Content Handlers Package Version 1.0.
+ * 
+ * <p>
+ * Bundles wishing to use this package must list the package in the
+ * Import-Package header of the bundle's manifest.
+ * 
+ * <p>
+ * Example import for consumers using the API in this package:
+ * <p>
+ * {@code  Import-Package: org.osgi.service.url; version="[1.0,2.0)"}
+ * 
+ * @version $Id: 5eaeb551c53ee18d53480e5c03d2b7771f3e6aea $
+ */
+
+package org.osgi.service.url;
diff --git a/main/src/main/java/org/osgi/service/url/packageinfo b/main/src/main/java/org/osgi/service/url/packageinfo
new file mode 100644
index 0000000000..7c8de0324f
--- /dev/null
+++ b/main/src/main/java/org/osgi/service/url/packageinfo
@@ -0,0 +1 @@
+version 1.0
diff --git a/main/src/test/resources/test-karaf-home/etc/config.properties b/main/src/test/resources/test-karaf-home/etc/config.properties
index aa780b8e0f..36a1e4e01c 100755
--- a/main/src/test/resources/test-karaf-home/etc/config.properties
+++ b/main/src/test/resources/test-karaf-home/etc/config.properties
@@ -31,7 +31,7 @@ karaf.framework=felix
 #
 # Location of the OSGi frameworks
 #
-karaf.framework.felix=${karaf.default.repository}/org/apache/felix/org.apache.felix.framework/3.0.6/org.apache.felix.framework-3.0.6.jar
+karaf.framework.felix=${karaf.default.repository}/org/apache/felix/org.apache.felix.framework/4.0.2/org.apache.felix.framework-4.0.2.jar
 
 # To enable the use of the startup.properties file to control the start level:
 karaf.auto.start=
diff --git a/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/3.0.6/org.apache.felix.framework-3.0.6.jar b/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/3.0.6/org.apache.felix.framework-3.0.6.jar
deleted file mode 100755
index 41c382115f..0000000000
Binary files a/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/3.0.6/org.apache.felix.framework-3.0.6.jar and /dev/null differ
diff --git a/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/4.0.2/org.apache.felix.framework-4.0.2.jar b/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/4.0.2/org.apache.felix.framework-4.0.2.jar
new file mode 100644
index 0000000000..79bb774d6e
Binary files /dev/null and b/main/src/test/resources/test-karaf-home/system/org/apache/felix/org.apache.felix.framework/4.0.2/org.apache.felix.framework-4.0.2.jar differ
