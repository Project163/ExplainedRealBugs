{"url":"https://api.github.com/repos/playframework/playframework/issues/11507","repository_url":"https://api.github.com/repos/playframework/playframework","labels_url":"https://api.github.com/repos/playframework/playframework/issues/11507/labels{/name}","comments_url":"https://api.github.com/repos/playframework/playframework/issues/11507/comments","events_url":"https://api.github.com/repos/playframework/playframework/issues/11507/events","html_url":"https://github.com/playframework/playframework/issues/11507","id":1420703356,"node_id":"I_kwDOACO2xc5UrjZ8","number":11507,"title":"Provide API to validate HmacSHA256 signatures on incoming payloads","user":{"login":"phelps-sg","id":4571777,"node_id":"MDQ6VXNlcjQ1NzE3Nzc=","avatar_url":"https://avatars.githubusercontent.com/u/4571777?v=4","gravatar_id":"","url":"https://api.github.com/users/phelps-sg","html_url":"https://github.com/phelps-sg","followers_url":"https://api.github.com/users/phelps-sg/followers","following_url":"https://api.github.com/users/phelps-sg/following{/other_user}","gists_url":"https://api.github.com/users/phelps-sg/gists{/gist_id}","starred_url":"https://api.github.com/users/phelps-sg/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/phelps-sg/subscriptions","organizations_url":"https://api.github.com/users/phelps-sg/orgs","repos_url":"https://api.github.com/users/phelps-sg/repos","events_url":"https://api.github.com/users/phelps-sg/events{/privacy}","received_events_url":"https://api.github.com/users/phelps-sg/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":5,"created_at":"2022-10-24T11:48:26Z","updated_at":"2022-12-08T14:25:03Z","closed_at":"2022-12-08T14:25:03Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Discussed in https://github.com/orgs/playframework/discussions/11489\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **phelps-sg** October 16, 2022</sup>\r\n\r\nI have also discussed this issue on StackOverflow (https://stackoverflow.com/questions/73926931/in-scala-play-framework-is-there-a-simple-way-to-verify-signatures-on-form-requ), and the only answer so far suggests that there is currently no straightforward way to validate Hmac signatures when processing form data using the Play Framework.\r\n\r\nI am trying to write a Scala Play Framework action that will verify a HmacSHA256 signature on an incoming POST request containing form-url-encoded data.\r\n\r\nThis is not straightforward in the Play framework because: i) actions builders only have access to headers, but do not have access to the request body, and ii) in order to calculate the signature we have to treat the request body as `Array[ByteString]`, but when we come to process the form data we have to treat it as `Map[String, Seq[String]]`, the problem being that Play forces us to choose a single type for our request, and we cannot easily \"cast\" the request body to a different type.\r\n\r\nThe only solution I have been able to come up with is to use an `ActionRefiner` that returns a `WrappedRequest` that embeds a callback to validate the signature. The callback in turn reparses the data using `FormUrlEncodedParser.parse(new String(request.body.toArray))`. This approach is illustrated in the code below.  However, this is overly convoluted.   It would be a lot nicer if the ability to validate hmac signatures on incoming payloads was facilitated directly by the Play Framework API.\r\n\r\n~~~scala\r\npackage actions\r\n\r\nimport akka.util.ByteString\r\nimport com.google.inject.Inject\r\nimport play.api.Logging\r\nimport play.api.mvc.Results.Unauthorized\r\nimport play.api.mvc._\r\nimport play.core.parsers.FormUrlEncodedParser\r\nimport services.SlackSignatureVerifierService\r\n\r\nimport scala.concurrent.{ExecutionContext, Future}\r\nimport scala.util.Try\r\n\r\nclass SlackRequest[A](\r\n    val validateSignature: String => Try[String],\r\n    request: Request[A]\r\n) extends WrappedRequest[A](request)\r\n\r\nobject SlackSignatureVerifyAction {\r\n\r\n  implicit class SlackRequestByteStringValidator(\r\n      slackRequest: SlackRequest[ByteString]\r\n  ) {\r\n    def validateSignatureAgainstBody(): Try[Map[String, Seq[String]]] = {\r\n      val raw = slackRequest.body.utf8String\r\n      slackRequest.validateSignature(raw) map { _ =>\r\n        FormUrlEncodedParser.parse(new String(slackRequest.body.toArray))\r\n      }\r\n    }\r\n  }\r\n\r\n  val HEADERS_TIMESTAMP: String = \"X-Slack-Request-Timestamp\"\r\n  val HEADERS_SIGNATURE: String = \"X-Slack-Signature\"\r\n}\r\n\r\nclass SlackSignatureVerifyAction @Inject() (\r\n    val parser: BodyParsers.Default,\r\n    slackSignatureVerifierService: SlackSignatureVerifierService\r\n)(implicit ec: ExecutionContext)\r\n    extends ActionBuilder[SlackRequest, AnyContent]\r\n    with ActionRefiner[Request, SlackRequest]\r\n    with Logging {\r\n\r\n  override protected def executionContext: ExecutionContext = ec\r\n\r\n  override protected def refine[A](\r\n      request: Request[A]\r\n  ): Future[Either[Result, SlackRequest[A]]] = {\r\n\r\n    val timestamp =\r\n      request.headers.get(SlackSignatureVerifyAction.HEADERS_TIMESTAMP)\r\n\r\n    val signature =\r\n      request.headers.get(SlackSignatureVerifyAction.HEADERS_SIGNATURE)\r\n\r\n    (timestamp, signature) match {\r\n      case (Some(timestamp), Some(signature)) =>\r\n        Future.successful {\r\n          val validate = (body: String) =>\r\n            slackSignatureVerifierService.validate(timestamp, body, signature)\r\n          Right(new SlackRequest[A](validate, request))\r\n        }\r\n      case _ =>\r\n        Future { Left(Unauthorized(\"Invalid signature headers\")) }\r\n    }\r\n\r\n  }\r\n\r\n}\r\n~~~\r\n\r\nThe validation on the controller side looks like this:\r\n\r\n~~~scala\r\n  def slashCommand: Action[ByteString] = {\r\n    slackSignatureVerifyAction.async(parse.byteString) { request =>\r\n      logger.debug(\"received slash command\")\r\n      request\r\n        .validateSignatureAgainstBody()\r\n        .map(processForm) match {\r\n        case Success(result) => result\r\n        case Failure(ex) =>\r\n          ex.printStackTrace()\r\n          Future { Unauthorized(ex.getMessage) }\r\n      }\r\n    }\r\n  }\r\n~~~","closed_by":{"login":"mkurz","id":644927,"node_id":"MDQ6VXNlcjY0NDkyNw==","avatar_url":"https://avatars.githubusercontent.com/u/644927?v=4","gravatar_id":"","url":"https://api.github.com/users/mkurz","html_url":"https://github.com/mkurz","followers_url":"https://api.github.com/users/mkurz/followers","following_url":"https://api.github.com/users/mkurz/following{/other_user}","gists_url":"https://api.github.com/users/mkurz/gists{/gist_id}","starred_url":"https://api.github.com/users/mkurz/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mkurz/subscriptions","organizations_url":"https://api.github.com/users/mkurz/orgs","repos_url":"https://api.github.com/users/mkurz/repos","events_url":"https://api.github.com/users/mkurz/events{/privacy}","received_events_url":"https://api.github.com/users/mkurz/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/playframework/playframework/issues/11507/reactions","total_count":1,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":1,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/playframework/playframework/issues/11507/timeline","performed_via_github_app":null,"state_reason":"completed"}