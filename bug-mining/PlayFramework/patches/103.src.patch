diff --git a/framework/src/play-akka-http-server/src/main/resources/reference.conf b/framework/src/play-akka-http-server/src/main/resources/reference.conf
index 6def672998..e5361b6bc0 100644
--- a/framework/src/play-akka-http-server/src/main/resources/reference.conf
+++ b/framework/src/play-akka-http-server/src/main/resources/reference.conf
@@ -27,7 +27,7 @@ play {
       # bodies from outgoing responses.
       # Note that, even when this setting is off the server will never send
       # out message bodies on responses to HEAD requests.
-      transparent-head-requests = on
+      transparent-head-requests = off
 
       # If this setting is empty the server only accepts requests that carry a
       # non-empty `Host` header. Otherwise it responds with `400 Bad Request`.
diff --git a/framework/src/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala b/framework/src/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
index 1711e507a0..9e7ed7f9f2 100644
--- a/framework/src/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
+++ b/framework/src/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
@@ -26,7 +26,6 @@ import play.api.libs.streams.Accumulator
 import play.api.mvc._
 import play.api.routing.Router
 import play.core.{ ApplicationProvider, DefaultWebCommands, SourceMapper, WebCommands }
-import play.core.server._
 import play.core.server.akkahttp.{ AkkaModelConversion, HttpRequestDecoder }
 import play.core.server.common.{ ForwardedHeaderHandler, ServerResultUtils }
 import play.core.server.ssl.ServerSSLEngine
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
index bdddb323f3..5eef6880a7 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
@@ -7,13 +7,11 @@ package play.it.action
 import akka.stream.scaladsl.Source
 import play.shaded.ahc.io.netty.handler.codec.http.HttpHeaders
 import org.specs2.mutable.Specification
-import play.api.Play
 import play.api.http.HeaderNames._
 import play.api.http.Status._
 import play.api.libs.ws.{ WSClient, WSResponse }
 import play.api.mvc._
 import play.api.routing.Router.Routes
-import play.api.routing.Router.Tags._
 import play.api.routing.sird._
 import play.api.test._
 import play.core.server.Server
@@ -24,18 +22,23 @@ import scala.concurrent.ExecutionContext.Implicits.global
 import play.shaded.ahc.org.asynchttpclient.netty.NettyResponse
 import play.api.libs.typedmap.TypedKey
 
+import scala.concurrent.Future
+
 class NettyHeadActionSpec extends HeadActionSpec with NettyIntegrationSpecification
 class AkkaHttpHeadActionSpec extends HeadActionSpec with AkkaHttpIntegrationSpecification
 
 trait HeadActionSpec extends Specification with FutureAwaits with DefaultAwaitTimeout with ServerIntegrationSpecification {
 
-  private def route(verb: String, path: String)(handler: EssentialAction): PartialFunction[(String, String), Handler] = {
-    case (v, p) if v == verb && p == path => handler
-  }
   sequential
 
   "HEAD requests" should {
 
+    def webSocketResponse(implicit Action: DefaultActionBuilder): Routes = {
+      case GET(p"/ws") => WebSocket.acceptOrResult[String, String] { request =>
+        Future.successful(Left(Results.Forbidden))
+      }
+    }
+
     def chunkedResponse(implicit Action: DefaultActionBuilder): Routes = {
       case GET(p"/chunked") =>
         Action { request =>
@@ -51,6 +54,7 @@ trait HeadActionSpec extends Specification with FutureAwaits with DefaultAwaitTi
         .orElse(delete) // DELETE /delete
         .orElse(stream) // GET /stream/0
         .orElse(chunkedResponse) // GET /chunked
+        .orElse(webSocketResponse) // GET /ws
 
     def withServer[T](block: WSClient => T): T = {
       // Routes from HttpBinApplication
@@ -67,6 +71,11 @@ trait HeadActionSpec extends Specification with FutureAwaits with DefaultAwaitTi
       }
     }
 
+    "return 400 in response to a HEAD in a WebSocket handler" in withServer { client =>
+      val result = await(client.url("/ws").head())
+      result.status must_== BAD_REQUEST
+    }
+
     "return 200 in response to a URL with a GET handler" in withServer { client =>
       val result = await(client.url("/get").head())
 
diff --git a/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala b/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
index 674754c3f4..77538d1f07 100644
--- a/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
+++ b/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
@@ -109,6 +109,11 @@ class DefaultHttpRequestHandler(router: Router, errorHandler: HttpErrorHandler,
   }
 
   override def handlerForRequest(request: RequestHeader): (RequestHeader, Handler) = {
+
+    def handleWithStatus(status: Int) = ActionBuilder.ignoringBody.async(BodyParsers.utils.empty)(req =>
+      errorHandler.onClientError(req, status)
+    )
+
     /**
      * Call the router to get the handler, but with a couple of types of fallback.
      * First, if a HEAD request isn't explicitly routed try routing it as a GET
@@ -116,19 +121,31 @@ class DefaultHttpRequestHandler(router: Router, errorHandler: HttpErrorHandler,
      * error.
      */
     def routeWithFallback(request: RequestHeader): Handler = {
-      routeRequest(request) match {
-        case Some(handler) => handler
-        // We automatically permit HEAD requests against any GETs without the need to
-        // add an explicit mapping in Routes. Since we couldn't route the HEAD request,
-        // try to get a Handler for the equivalent GET request instead. Note: the handler
-        // returned will still be passed a HEAD request when it is actually evaluated.
-        case None if request.method == HttpVerbs.HEAD =>
-          routeWithFallback(request.withMethod(HttpVerbs.GET))
-        case None =>
-          // An Action for a 404 error
-          ActionBuilder.ignoringBody.async(BodyParsers.utils.empty)(req =>
-            errorHandler.onClientError(req, NOT_FOUND)
-          )
+      routeRequest(request).getOrElse {
+        request.method match {
+          // We automatically permit HEAD requests against any GETs without the need to
+          // add an explicit mapping in Routes. Since we couldn't route the HEAD request,
+          // try to get a Handler for the equivalent GET request instead. Notes:
+          // 1. The handler returned will still be passed a HEAD request when it is
+          //    actually evaluated.
+          // 2. When the endpoint is to a WebSocket connection, the handler returned
+          //    will result in a Bad Request. That is because, while we can translate
+          //    GET requests to HEAD, we can't do that for WebSockets, since there is
+          //    no way (or reason) to Upgrade the connection. For more information see
+          //    https://tools.ietf.org/html/rfc6455#section-1.3
+          case HttpVerbs.HEAD => {
+            routeRequest(request.withMethod(HttpVerbs.GET)) match {
+              case Some(handler: Handler) => handler match {
+                case ws: WebSocket => handleWithStatus(BAD_REQUEST)
+                case _ => handler
+              }
+              case None => handleWithStatus(NOT_FOUND)
+            }
+          }
+          case _ =>
+            // An Action for a 404 error
+            handleWithStatus(NOT_FOUND)
+        }
       }
     }
 
