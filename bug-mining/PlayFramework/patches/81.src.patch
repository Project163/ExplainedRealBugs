diff --git a/documentation/manual/Home.md b/documentation/manual/Home.md
index 1949cbf693..08cb163c4b 100644
--- a/documentation/manual/Home.md
+++ b/documentation/manual/Home.md
@@ -3,7 +3,7 @@
 
 > Play is a high-productivity Java and Scala web application framework that integrates the components and APIs you need for modern web application development. 
 >
-> Play is based on a lightweight, stateless, web-friendly architecture and features predictable and minimal resource consumption (CPU, memory, threads) for highly-scalable applications thanks to its reactive model, based on Akka streams.
+> Play is based on a lightweight, stateless, web-friendly architecture and features predictable and minimal resource consumption (CPU, memory, threads) for highly-scalable applications thanks to its reactive model, based on Akka Streams.
 
 ## Latest release
 
diff --git a/documentation/manual/experimental/AkkaHttpServer.md b/documentation/manual/experimental/AkkaHttpServer.md
index d833c89f41..919fc21a66 100644
--- a/documentation/manual/experimental/AkkaHttpServer.md
+++ b/documentation/manual/experimental/AkkaHttpServer.md
@@ -3,7 +3,7 @@
 
 > **Play experimental libraries are not ready for production use**. APIs may change. Features may not work properly.
 
-Play 2's main server is built on top of [Netty](http://netty.io/). In Play 2.4 we started experimenting with an experimental server based on [Akka HTTP](http://doc.akka.io/docs/akka-stream-and-http-experimental/current/). Akka HTTP is an HTTP library built on top of Akka. It is written by the authors of [Spray](http://spray.io/).
+Play 2's main server is built on top of [Netty](http://netty.io/). In Play 2.4 we started experimenting with an experimental server based on [Akka HTTP](http://doc.akka.io/docs/akka/2.4.3/scala/http/index.html). Akka HTTP is an HTTP library built on top of Akka. It is written by the authors of [Spray](http://spray.io/).
 
 The purpose of this backend is:
 
diff --git a/documentation/manual/releases/release22/Migration22.md b/documentation/manual/releases/release22/Migration22.md
index acdd9b28e1..49a3f4ff13 100644
--- a/documentation/manual/releases/release22/Migration22.md
+++ b/documentation/manual/releases/release22/Migration22.md
@@ -199,4 +199,4 @@ Please consult the [["Starting your application in production mode"|Production]]
 
 ## Upgrade from Akka 2.1 to 2.2
 
-The migration guide for upgrading from Akka 2.1 to 2.2 can be found [here](http://doc.akka.io/docs/akka/2.2.0/project/migration-guide-2.1.x-2.2.x.html).
+The migration guide for upgrading from Akka 2.1 to 2.2 can be found [here](http://doc.akka.io/docs/akka/2.4.3/project/migration-guide-2.1.x-2.2.x.html).
diff --git a/documentation/manual/releases/release24/ReactiveStreamsIntegration.md b/documentation/manual/releases/release24/ReactiveStreamsIntegration.md
index 92f6e5fcd9..6f9565602d 100644
--- a/documentation/manual/releases/release24/ReactiveStreamsIntegration.md
+++ b/documentation/manual/releases/release24/ReactiveStreamsIntegration.md
@@ -3,7 +3,7 @@
 
 > **Play experimental libraries are not ready for production use**. APIs may change. Features may not work properly.
 
-[Reactive Streams](http://www.reactive-streams.org/) is a new standard that gives a common API for asynchronous streams. Play 2.4 introduces some wrappers to convert Play's [[Iteratees and Enumerators|Iteratees]] into Reactive Streams objects. This means that Play can integrate with other software that supports Reactive Streams, e.g. [Akka Streams](http://doc.akka.io/docs/akka-stream-and-http-experimental/current/), [RxJava](https://github.com/ReactiveX/RxJavaReactiveStreams) and [others](http://www.reactive-streams.org/announce-1.0.0#implementations).
+[Reactive Streams](http://www.reactive-streams.org/) is a new standard that gives a common API for asynchronous streams. Play 2.4 introduces some wrappers to convert Play's [[Iteratees and Enumerators|Iteratees]] into Reactive Streams objects. This means that Play can integrate with other software that supports Reactive Streams, e.g. [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html), [RxJava](https://github.com/ReactiveX/RxJavaReactiveStreams) and [others](http://www.reactive-streams.org/announce-1.0.0#implementations).
 
 The purpose of the API is:
 
diff --git a/documentation/manual/releases/release25/Highlights25.md b/documentation/manual/releases/release25/Highlights25.md
index ab48b453f2..58b5bfaffe 100644
--- a/documentation/manual/releases/release25/Highlights25.md
+++ b/documentation/manual/releases/release25/Highlights25.md
@@ -5,7 +5,7 @@ This page highlights the new features of Play 2.5. If you want to learn about th
 
 ## New streaming API based on Akka Streams
 
-The main theme of Play 2.5 has been moving from Play's iteratee-based asynchronous IO API to [Akka Streams](http://doc.akka.io/docs/akka/2.4.2/scala/stream/stream-introduction.html).
+The main theme of Play 2.5 has been moving from Play's iteratee-based asynchronous IO API to [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/scala/stream/stream-introduction.html).
 
 At its heart, any time you communicate over the network, or write/read some data to the filesystem, some streaming is involved.  In many cases, this streaming is done at a low level, and the framework exposes the materialized values to your application as in-memory messages.  This is the case for many Play actions, a body parser converts the request body stream into an object such as a parsed JSON object, which the application consumes, and the returned result body is a JSON object that Play then turns back into a stream.
 
diff --git a/documentation/manual/releases/release25/migration25/StreamsMigration25.md b/documentation/manual/releases/release25/migration25/StreamsMigration25.md
index 40a9855969..c64f8638dc 100644
--- a/documentation/manual/releases/release25/migration25/StreamsMigration25.md
+++ b/documentation/manual/releases/release25/migration25/StreamsMigration25.md
@@ -185,7 +185,7 @@ return ok().chunked(EventSource.chunked(eventSource)).as("text/event-stream");
 
 * To migrate `EventSource.onConnected`, `EventSource.send`, etc to a `Source`, implement `org.reactivestreams.Publisher` on the class and use `Source.fromPublisher` to create a source from the callbacks.
 
-If you still want to use the same API as in Play 2.4 you can use the `LegacyEventSource` class. This class is the same as the Play 2.4 API, but it has been renamed and deprecated. If you want to use the new API, but retain the same feel as the old imperative API, you can try [`GraphStage`](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-customize.html#custom-processing-with-graphstage).
+If you still want to use the same API as in Play 2.4 you can use the `LegacyEventSource` class. This class is the same as the Play 2.4 API, but it has been renamed and deprecated. If you want to use the new API, but retain the same feel as the old imperative API, you can try [`GraphStage`](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-customize.html#custom-processing-with-graphstage).
 
 #### Migrating Scala Server-Sent events
 
@@ -275,24 +275,24 @@ This section explains how to migrate your byte arrays and streams to the new Akk
 
 Akka Streams is part of the Akka project. Play uses Akka Streams to provide streaming functionality: sending and receiving sequences of bytes and other objects. The Akka project has a lot of good documentation about Akka Streams. Before you start using Akka Streams in Play it is worth looking at the Akka Streams documentation to see what information is available.
 
-* [Documentation for Java](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html)
-* [Documentation for Scala](http://doc.akka.io/docs/akka/2.4.2/scala/stream/index.html)
+* [Documentation for Java](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html)
+* [Documentation for Scala](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html)
 
 The API documentation can be found under the `akka.stream` package in the main Akka API documentation:
 
-* [Akka Javadoc](http://doc.akka.io/japi/akka/2.4.2/)
-* [Akka Scala](http://doc.akka.io/api/akka/2.4.2/)
+* [Akka Javadoc](http://doc.akka.io/japi/akka/2.4.3/)
+* [Akka Scala](http://doc.akka.io/api/akka/2.4.3/)
 
 When you're first getting started with Akka Streams, the *Basics and working with Flows* section of the Akka documentation is worth a look. It will introduce you to the most important parts of the Akka Streams API.
 
-* [Basics for Java](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-flows-and-basics.html)
-* [Basics for Scala](http://doc.akka.io/docs/akka/2.4.2/scala/stream/stream-flows-and-basics.html)
+* [Basics for Java](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-flows-and-basics.html)
+* [Basics for Scala](http://doc.akka.io/docs/akka/2.4.3/scala/stream/stream-flows-and-basics.html)
 
 You don't need to convert your whole application in one go. Parts of your application can keep using iteratees while other parts use Akka Streams.  Akka Streams provides a [reactive streams](http://reactive-streams.org) implementation, and Play's iteratees library also provides a reactive streams implementation, consequently, Play's iteratees can easily be wrapped in Akka Streams and vice versa.
 
 ### Migrating byte arrays (`byte[]`/`Array[Byte]`) to `ByteString`s
 
-Refer to the [Java](http://doc.akka.io/japi/akka/2.4.2/index.html) and [Scala](http://doc.akka.io/api/akka/2.4.2/akka/util/ByteString.html) API documentation for `ByteString`.
+Refer to the [Java](http://doc.akka.io/japi/akka/2.4.3/index.html) and [Scala](http://doc.akka.io/api/akka/2.4.3/akka/util/ByteString.html) API documentation for `ByteString`.
 
 Examples:
 
@@ -322,9 +322,9 @@ ByteString.fromArray(arr);
 
 ### Migrating `*.Out`s to `Source`s
 
-Play now uses a `Source` to generate events instead of its old `WebSocket.Out`, `Chunks.Out` and `EventSource.Out` classes. These classes were simple to use, but they were inflexible and they didn't implement [back](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-flows-and-basics.html#back-pressure-explained) [pressure](http://doc.akka.io/docs/akka/2.4.2/scala/stream/stream-flows-and-basics.html#back-pressure-explained) properly.
+Play now uses a `Source` to generate events instead of its old `WebSocket.Out`, `Chunks.Out` and `EventSource.Out` classes. These classes were simple to use, but they were inflexible and they didn't implement [back](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-flows-and-basics.html#back-pressure-explained) [pressure](http://doc.akka.io/docs/akka/2.4.3/scala/stream/stream-flows-and-basics.html#back-pressure-explained) properly.
 
-You can replace your `*.Out` class with any `Source` that produces a stream. There are lots of ways to create `Source`s ([Java](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-flows-and-basics.html#Defining_sources__sinks_and_flows)/[Scala](http://doc.akka.io/docs/akka/2.4.2/scala/stream/stream-flows-and-basics.html#Defining_sources__sinks_and_flows).
+You can replace your `*.Out` class with any `Source` that produces a stream. There are lots of ways to create `Source`s ([Java](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-flows-and-basics.html#Defining_sources__sinks_and_flows)/[Scala](http://doc.akka.io/docs/akka/2.4.3/scala/stream/stream-flows-and-basics.html#Defining_sources__sinks_and_flows).
 
 If you want to replace your `*.Out` with a simple object that you can write messages to and then close, without worrying about back pressure, then you can use the `Source.actorRef` method:
 
@@ -360,7 +360,7 @@ If you use `Results.chunked` or `Results.feed` you can continue to use the exist
 
 **Step 2:** Convert `Enumerator` to `Source` with an adapter
 
-You can convert your existing `Enumerator` to a `Source` by first converting it to a reactive streams `Publisher` using `Streams.enumeratorToPublisher`, and then you can convert the publisher to a source using [`Source.fromPublisher`](http://doc.akka.io/api/akka/2.4.2/akka/stream/scaladsl/Source$.html#fromPublisher[T]\(Publisher[T]\):Source[T,NotUsed]), for example:
+You can convert your existing `Enumerator` to a `Source` by first converting it to a reactive streams `Publisher` using `Streams.enumeratorToPublisher`, and then you can convert the publisher to a source using [`Source.fromPublisher`](http://doc.akka.io/api/akka/2.4.3/akka/stream/scaladsl/Source$.html#fromPublisher[T]\(Publisher[T]\):Source[T,NotUsed]), for example:
 
 ```scala
 val enumerator: Enumerator[T] = ...
@@ -387,7 +387,7 @@ Here's a list of some common mappings for enumerator factory methods:
 
 **Step 1:** Convert using an adapter
 
-You can convert your existing `Iteratee` to a `Sink` by first converting it to a reactive streams `Subscriber` using `Streams.iterateeToSubscriber`, and then you can convert the subscriber to a sink using [`Sink.fromSubscriber`](http://doc.akka.io/api/akka/2.4.2/akka/stream/scaladsl/Sink$.html#fromSubscriber[T]\(Subscriber[T]\):Sink[T,NotUsed]), for example:
+You can convert your existing `Iteratee` to a `Sink` by first converting it to a reactive streams `Subscriber` using `Streams.iterateeToSubscriber`, and then you can convert the subscriber to a sink using [`Sink.fromSubscriber`](http://doc.akka.io/api/akka/2.4.3/akka/stream/scaladsl/Sink$.html#fromSubscriber[T]\(Subscriber[T]\):Sink[T,NotUsed]), for example:
 
 ```scala
 val iteratee: Iteratee[T, U] = ...
@@ -414,7 +414,7 @@ Here's a list of some common mappings for iteratee factory methods:
 
 **Step 1:** Convert using an adapter
 
-You can convert your existing `Enumeratee` to a `Flow` by first converting it to a reactive streams `Processor` using `Streams.enumerateeToProcessor`, and then you can convert the processor to a flow using [`Flow.fromProcessor`](http://doc.akka.io/api/akka/2.4.2/akka/stream/scaladsl/Flow$.html#fromProcessor[I,O]\(\(\)⇒Processor[I,O]\):Flow[I,O,NotUsed]), for example:
+You can convert your existing `Enumeratee` to a `Flow` by first converting it to a reactive streams `Processor` using `Streams.enumerateeToProcessor`, and then you can convert the processor to a flow using [`Flow.fromProcessor`](http://doc.akka.io/api/akka/2.4.3/akka/stream/scaladsl/Flow$.html#fromProcessor[I,O]\(\(\)⇒Processor[I,O]\):Flow[I,O,NotUsed]), for example:
 
 ```scala
 val enumeratee: Enumeratee[A, B] = ...
diff --git a/documentation/manual/working/commonGuide/configuration/ThreadPools.md b/documentation/manual/working/commonGuide/configuration/ThreadPools.md
index 3692276465..1d6efc16bf 100644
--- a/documentation/manual/working/commonGuide/configuration/ThreadPools.md
+++ b/documentation/manual/working/commonGuide/configuration/ThreadPools.md
@@ -43,7 +43,7 @@ In most situations, the appropriate execution context to use will be the **Play
 
 @[global-thread-pool](code/ThreadPools.scala)
 
-The Play thread pool connects directly to the Application's `ActorSystem` and uses the [default dispatcher](http://doc.akka.io/docs/akka/2.4.2/scala/dispatchers.html).
+The Play thread pool connects directly to the Application's `ActorSystem` and uses the [default dispatcher](http://doc.akka.io/docs/akka/2.4.3/scala/dispatchers.html).
 
 ### Configuring the default thread pool
 
@@ -57,7 +57,7 @@ You can also try the default Akka configuration:
 
 @[akka-default-config](code/ThreadPools.scala)
 
-The full configuration options available to you can be found [here](http://doc.akka.io/docs/akka/2.4.2/general/configuration.html#Listing_of_the_Reference_Configuration).
+The full configuration options available to you can be found [here](http://doc.akka.io/docs/akka/2.4.3/general/configuration.html#Listing_of_the_Reference_Configuration).
 
 ## Using other thread pools
 
diff --git a/documentation/manual/working/javaGuide/main/async/JavaComet.md b/documentation/manual/working/javaGuide/main/async/JavaComet.md
index 9627ceffb1..1513b3dd88 100644
--- a/documentation/manual/working/javaGuide/main/async/JavaComet.md
+++ b/documentation/manual/working/javaGuide/main/async/JavaComet.md
@@ -7,7 +7,7 @@ A common use of **chunked responses** is to create Comet sockets.
 
 A Comet socket is a chunked `text/html` response containing only `<script>` elements. For each chunk, we write a `<script>` tag containing JavaScript that is immediately executed by the web browser. This way we can send events live to the web browser from the server: for each message, wrap it into a `<script>` tag that calls a JavaScript callback function, and write it to the chunked response.
 
-Because `ok().chunked` leverages [Akka Streams](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html) to take a `Flow<ByteString>`, we can send a `Flow` of elements and transform it so that each element is escaped and wrapped in the Javascript method. The Comet helper automates Comet sockets, pushing an initial blank buffer data for browser compatibility, and supporting both String and JSON messages.  
+Because `ok().chunked` leverages [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html) to take a `Flow<ByteString>`, we can send a `Flow` of elements and transform it so that each element is escaped and wrapped in the Javascript method. The Comet helper automates Comet sockets, pushing an initial blank buffer data for browser compatibility, and supporting both String and JSON messages.
 
 ## Comet Imports
 
@@ -47,7 +47,7 @@ For an example of a Comet helper, see the [Play 2.5 Clock Template](https://gith
 
 ## Debugging Comet
 
-The easiest way to debug a Comet stream that is not working is to use the [`log()`](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-cookbook.html#Logging_elements_of_a_stream) operation to show any errors involved in mapping data through the stream.
+The easiest way to debug a Comet stream that is not working is to use the [`log()`](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-cookbook.html#Logging_elements_of_a_stream) operation to show any errors involved in mapping data through the stream.
 
 ## Legacy Comet Functionality
 
diff --git a/documentation/manual/working/javaGuide/main/async/JavaStream.md b/documentation/manual/working/javaGuide/main/async/JavaStream.md
index 952dda2494..c5d1afbcd8 100644
--- a/documentation/manual/working/javaGuide/main/async/JavaStream.md
+++ b/documentation/manual/working/javaGuide/main/async/JavaStream.md
@@ -68,4 +68,4 @@ bar
 
 We get three chunks and one final empty chunk that closes the response.
 
-For more information on using Akka Streams, you can reference the [Akka Streams documentation](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html).
+For more information on using Akka Streams, you can reference the [Akka Streams documentation](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html).
diff --git a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
index 924b5bb203..7a86b64d75 100644
--- a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
+++ b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
@@ -5,7 +5,7 @@
 
 An HTTP request is a header followed by a body.  The header is typically small - it can be safely buffered in memory, hence in Play it is modelled using the [`RequestHeader`](api/java/play/mvc/Http.RequestHeader.html) class.  The body however can be potentially very long, and so is not buffered in memory, but rather is modelled as a stream.  However, many request body payloads are small and can be modelled in memory, and so to map the body stream to an object in memory, Play provides a [`BodyParser`](api/java/play/mvc/BodyParser.html) abstraction.
 
-Since Play is an asynchronous framework, the traditional `InputStream` can't be used to read the request body - input streams are blocking, when you invoke `read`, the thread invoking it must wait for data to be available.  Instead, Play uses an asynchronous streaming library called [Akka Streams](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html).  Akka Streams is an implementation of [Reactive Streams](http://www.reactive-streams.org/), a SPI that allows many asynchronous streaming APIs to seamlessly work together, so though traditional `InputStream` based technologies are not suitable for use with Play, Akka Streams and the entire ecosystem of asynchronous libraries around Reactive Streams will provide you with everything you need.
+Since Play is an asynchronous framework, the traditional `InputStream` can't be used to read the request body - input streams are blocking, when you invoke `read`, the thread invoking it must wait for data to be available.  Instead, Play uses an asynchronous streaming library called [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html).  Akka Streams is an implementation of [Reactive Streams](http://www.reactive-streams.org/), a SPI that allows many asynchronous streaming APIs to seamlessly work together, so though traditional `InputStream` based technologies are not suitable for use with Play, Akka Streams and the entire ecosystem of asynchronous libraries around Reactive Streams will provide you with everything you need.
 
 ## Using the built in body parsers
 
@@ -72,9 +72,9 @@ The signature of this method may be a bit daunting at first, so let's break it d
 
 The method takes a [`RequestHeader`](api/java/play/mvc/Http.RequestHeader.html).  This can be used to check information about the request - most commonly, it is used to get the `Content-Type`, so that the body can be correctly parsed.
 
-The return type of the method is an [`Accumulator`](api/java/play/libs/streams/Accumulator.html).  An accumulator is a thin layer around an [Akka Streams](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html) [`Sink`](http://doc.akka.io/japi/akka/2.4.2/akka/stream/javadsl/Sink.html).  An accumulator asynchronously accumulates streams of elements into a result, it can be run by passing in an Akka Streams [`Source`](http://doc.akka.io/japi/akka/2.4.2/akka/stream/javadsl/Source.html), this will return a `CompletionStage` that will be redeemed when the accumulator is complete.  It is essentially the same thing as a `Sink<E, CompletionStage<A>>`, in fact it is nothing more than a wrapper around this type, but the big difference is that `Accumulator` provides convenient methods such as `map`, `mapFuture`, `recover` etc. for working with the result as if it were a promise, where `Sink` requires all such operations to be wrapped in a `mapMaterializedValue` call.
+The return type of the method is an [`Accumulator`](api/java/play/libs/streams/Accumulator.html).  An accumulator is a thin layer around an [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html) [`Sink`](http://doc.akka.io/japi/akka/2.4.3/akka/stream/javadsl/Sink.html).  An accumulator asynchronously accumulates streams of elements into a result, it can be run by passing in an Akka Streams [`Source`](http://doc.akka.io/japi/akka/2.4.3/akka/stream/javadsl/Source.html), this will return a `CompletionStage` that will be redeemed when the accumulator is complete.  It is essentially the same thing as a `Sink<E, CompletionStage<A>>`, in fact it is nothing more than a wrapper around this type, but the big difference is that `Accumulator` provides convenient methods such as `map`, `mapFuture`, `recover` etc. for working with the result as if it were a promise, where `Sink` requires all such operations to be wrapped in a `mapMaterializedValue` call.
 
-The accumulator that the `apply` method returns consumes elements of type [`ByteString`](http://doc.akka.io/japi/akka/2.4.2/akka/util/ByteString.html) - these are essentially arrays of bytes, but differ from `byte[]` in that `ByteString` is immutable, and many operations such as slicing and appending happen in constant time.
+The accumulator that the `apply` method returns consumes elements of type [`ByteString`](http://doc.akka.io/japi/akka/2.4.3/akka/util/ByteString.html) - these are essentially arrays of bytes, but differ from `byte[]` in that `ByteString` is immutable, and many operations such as slicing and appending happen in constant time.
 
 The return type of the accumulator is `F.Either<Result, A>`.  This says it will either return a `Result`, or it will return a body of type `A`.  A result is generally returned in the case of an error, for example, if the body failed to be parsed, if the `Content-Type` didn't match the type that the body parser accepts, or if an in memory buffer was exceeded.  When the body parser returns a result, this will short circuit the processing of the action - the body parsers result will be returned immediately, and the action will never be invoked.
 
@@ -112,6 +112,6 @@ In rare circumstances, it may be necessary to write a custom parser using Akka S
 
 However, when that's not feasible, for example when the body you need to parse is too long to fit in memory, then you may need to write a custom body parser.
 
-A full description of how to use Akka Streams is beyond the scope of this documentation - the best place to start is to read the [Akka Streams documentation](http://doc.akka.io/docs/akka/2.4.2/java/stream/index.html).  However, the following shows a CSV parser, which builds on the [Parsing lines from a stream of ByteStrings](http://doc.akka.io/docs/akka/2.4.2/java/stream/stream-cookbook.html#Parsing_lines_from_a_stream_of_ByteStrings) documentation from the Akka Streams cookbook:
+A full description of how to use Akka Streams is beyond the scope of this documentation - the best place to start is to read the [Akka Streams documentation](http://doc.akka.io/docs/akka/2.4.3/java/stream/index.html).  However, the following shows a CSV parser, which builds on the [Parsing lines from a stream of ByteStrings](http://doc.akka.io/docs/akka/2.4.3/java/stream/stream-cookbook.html#Parsing_lines_from_a_stream_of_ByteStrings) documentation from the Akka Streams cookbook:
 
 @[csv](code/javaguide/http/JavaBodyParsers.java)
diff --git a/documentation/manual/working/scalaGuide/main/async/ScalaComet.md b/documentation/manual/working/scalaGuide/main/async/ScalaComet.md
index 047df777c8..25996734f6 100644
--- a/documentation/manual/working/scalaGuide/main/async/ScalaComet.md
+++ b/documentation/manual/working/scalaGuide/main/async/ScalaComet.md
@@ -7,7 +7,7 @@ A common use of **chunked responses** is to create a Comet socket.
 
 A Comet socket is a chunked `text/html` response containing only `<script>` elements. For each chunk, we write a `<script>` tag containing JavaScript that is immediately executed by the web browser. This way we can send events live to the web browser from the server: for each message, wrap it into a `<script>` tag that calls a JavaScript callback function, and write it to the chunked response.
 
-Because `Ok.chunked` leverages [Akka Streams](http://doc.akka.io/docs/akka/2.4.2/scala/stream/index.html) to take a `Flow[ByteString]`, we can send a `Flow` of elements and transform it so that each element is escaped and wrapped in the Javascript method. The Comet helper automates Comet sockets, pushing an initial blank buffer data for browser compatibility, and supporting both String and JSON messages.  
+Because `Ok.chunked` leverages [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html) to take a `Flow[ByteString]`, we can send a `Flow` of elements and transform it so that each element is escaped and wrapped in the Javascript method. The Comet helper automates Comet sockets, pushing an initial blank buffer data for browser compatibility, and supporting both String and JSON messages.
 
 ## Comet Imports
 
@@ -15,7 +15,7 @@ To use the Comet helper, import the following classes:
 
 @[comet-imports](code/ScalaComet.scala)
 
-You will also need a materializer, which is best done by pulling `akka.stream.Materializer` from your [[DI system|ScalaDependencyInjection]].   
+You will also need a materializer, which is best done by pulling `akka.stream.Materializer` from your [[DI system|ScalaDependencyInjection]].
 
 ## Using Comet with String Flow
 
diff --git a/documentation/manual/working/scalaGuide/main/http/ScalaBodyParsers.md b/documentation/manual/working/scalaGuide/main/http/ScalaBodyParsers.md
index 28b1d0dee5..725135222c 100644
--- a/documentation/manual/working/scalaGuide/main/http/ScalaBodyParsers.md
+++ b/documentation/manual/working/scalaGuide/main/http/ScalaBodyParsers.md
@@ -5,7 +5,7 @@
 
 An HTTP request is a header followed by a body.  The header is typically small - it can be safely buffered in memory, hence in Play it is modelled using the [`RequestHeader`](api/scala/play/api/mvc/RequestHeader.html) class.  The body however can be potentially very long, and so is not buffered in memory, but rather is modelled as a stream.  However, many request body payloads are small and can be modelled in memory, and so to map the body stream to an object in memory, Play provides a [`BodyParser`](api/scala/play/api/mvc/BodyParser.html) abstraction.
 
-Since Play is an asynchronous framework, the traditional `InputStream` can't be used to read the request body - input streams are blocking, when you invoke `read`, the thread invoking it must wait for data to be available.  Instead, Play uses an asynchronous streaming library called [Akka Streams](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala.html).  Akka Streams is an implementation of [Reactive Streams](http://www.reactive-streams.org/), a SPI that allows many asynchronous streaming APIs to seamlessly work together, so though traditional `InputStream` based technologies are not suitable for use with Play, Akka Streams and the entire ecosystem of asynchronous libraries around Reactive Streams will provide you with everything you need.
+Since Play is an asynchronous framework, the traditional `InputStream` can't be used to read the request body - input streams are blocking, when you invoke `read`, the thread invoking it must wait for data to be available.  Instead, Play uses an asynchronous streaming library called [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html).  Akka Streams is an implementation of [Reactive Streams](http://www.reactive-streams.org/), a SPI that allows many asynchronous streaming APIs to seamlessly work together, so though traditional `InputStream` based technologies are not suitable for use with Play, Akka Streams and the entire ecosystem of asynchronous libraries around Reactive Streams will provide you with everything you need.
 
 ## More about Actions
 
@@ -98,9 +98,9 @@ The signature of this function may be a bit daunting at first, so let's break it
 
 The function takes a [`RequestHeader`](api/scala/play/api/mvc/RequestHeader.html).  This can be used to check information about the request - most commonly, it is used to get the `Content-Type`, so that the body can be correctly parsed.
 
-The return type of the function is an [`Accumulator`](api/scala/play/api/libs/streams/Accumulator.html).  An accumulator is a thin layer around an [Akka Streams](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala.html) [`Sink`](http://doc.akka.io/api/akka-stream-and-http-experimental/1.0/akka/stream/scaladsl/Sink.html).  An accumulator asynchronously accumulates streams of elements into a result, it can be run by passing in an Akka Streams [`Source`](http://doc.akka.io/api/akka-stream-and-http-experimental/1.0/akka/stream/scaladsl/Source.html), this will return a `Future` that will be redeemed when the accumulator is complete.  It is essentially the same thing as a `Sink[E, Future[A]]`, in fact it is nothing more than a wrapper around this type, but the big difference is that `Accumulator` provides convenient methods such as `map`, `mapFuture`, `recover` etc. for working with the result as if it were a promise, where `Sink` requires all such operations to be wrapped in a `mapMaterializedValue` call.
+The return type of the function is an [`Accumulator`](api/scala/play/api/libs/streams/Accumulator.html).  An accumulator is a thin layer around an [Akka Streams](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html) [`Sink`](http://doc.akka.io/api/akka/2.4.3/index.html#akka.stream.scaladsl.Sink).  An accumulator asynchronously accumulates streams of elements into a result, it can be run by passing in an Akka Streams [`Source`](http://doc.akka.io/api/akka/2.4.3/index.html#akka.stream.scaladsl.Source), this will return a `Future` that will be redeemed when the accumulator is complete.  It is essentially the same thing as a `Sink[E, Future[A]]`, in fact it is nothing more than a wrapper around this type, but the big difference is that `Accumulator` provides convenient methods such as `map`, `mapFuture`, `recover` etc. for working with the result as if it were a promise, where `Sink` requires all such operations to be wrapped in a `mapMaterializedValue` call.
 
-The accumulator that the `apply` method returns consumes elements of type [`ByteString`](http://doc.akka.io/api/akka/2.3.10/akka/util/ByteString.html) - these are essentially arrays of bytes, but differ from `byte[]` in that `ByteString` is immutable, and many operations such as slicing and appending happen in constant time.
+The accumulator that the `apply` method returns consumes elements of type [`ByteString`](http://doc.akka.io/api/akka/2.4.3/akka/util/ByteString.html) - these are essentially arrays of bytes, but differ from `byte[]` in that `ByteString` is immutable, and many operations such as slicing and appending happen in constant time.
 
 The return type of the accumulator is `Either[Result, A]` - it will either return a `Result`, or it will return a body of type `A`.  A result is generally returned in the case of an error, for example, if the body failed to be parsed, if the `Content-Type` didn't match the type that the body parser accepts, or if an in memory buffer was exceeded.  When the body parser returns a result, this will short circuit the processing of the action - the body parsers result will be returned immediately, and the action will never be invoked.
 
@@ -116,6 +116,6 @@ In rare circumstances, it may be necessary to write a custom parser using Akka S
 
 However, when that's not feasible, for example when the body you need to parse is too long to fit in memory, then you may need to write a custom body parser.
 
-A full description of how to use Akka Streams is beyond the scope of this documentation - the best place to start is to read the [Akka Streams documentation](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala.html).  However, the following shows a CSV parser, which builds on the [Parsing lines from a stream of ByteStrings](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/scala/stream-cookbook.html#Parsing_lines_from_a_stream_of_ByteStrings) documentation from the Akka Streams cookbook:
+A full description of how to use Akka Streams is beyond the scope of this documentation - the best place to start is to read the [Akka Streams documentation](http://doc.akka.io/docs/akka/2.4.3/scala/stream/index.html).  However, the following shows a CSV parser, which builds on the [Parsing lines from a stream of ByteStrings](http://doc.akka.io/docs/akka/2.4.3/scala/stream/stream-cookbook.html#Parsing_lines_from_a_stream_of_ByteStrings) documentation from the Akka Streams cookbook:
 
 @[csv](code/ScalaBodyParsers.scala)
diff --git a/framework/project/Dependencies.scala b/framework/project/Dependencies.scala
index 4263ab3c20..7701f2e675 100644
--- a/framework/project/Dependencies.scala
+++ b/framework/project/Dependencies.scala
@@ -6,7 +6,7 @@ import buildinfo.BuildInfo
 
 object Dependencies {
 
-  val akkaVersion = "2.4.2"
+  val akkaVersion = "2.4.3"
 
   val specsVersion = "3.6.6"
   val specsBuild = Seq(
diff --git a/framework/src/play/src/main/java/play/mvc/StatusHeader.java b/framework/src/play/src/main/java/play/mvc/StatusHeader.java
index 669c45d6e2..a760ab3883 100644
--- a/framework/src/play/src/main/java/play/mvc/StatusHeader.java
+++ b/framework/src/play/src/main/java/play/mvc/StatusHeader.java
@@ -3,6 +3,7 @@
  */
 package play.mvc;
 
+import akka.stream.javadsl.FileIO;
 import akka.stream.javadsl.Source;
 import akka.stream.javadsl.StreamConverters;
 import akka.util.ByteString;
@@ -153,7 +154,7 @@ public class StatusHeader extends Result {
         }
         try {
             return doSendResource(
-                    StreamConverters.fromInputStream(() -> Files.newInputStream(path)),
+                    FileIO.fromFile(path.toFile()),
                     Optional.of(Files.size(path)),
                     Optional.of(filename),
                     inline
@@ -184,7 +185,7 @@ public class StatusHeader extends Result {
             throw new NullPointerException("null file");
         }
         return doSendResource(
-                StreamConverters.fromInputStream(() -> Files.newInputStream(file.toPath())),
+                FileIO.fromFile(file),
                 Optional.of(file.length()),
                 Optional.of(file.getName()),
                 inline
@@ -203,7 +204,7 @@ public class StatusHeader extends Result {
             throw new NullPointerException("null file");
         }
         return doSendResource(
-                StreamConverters.fromInputStream(() -> Files.newInputStream(file.toPath())),
+                FileIO.fromFile(file),
                 Optional.of(file.length()),
                 Optional.of(fileName),
                 true
diff --git a/framework/src/play/src/main/scala/play/api/mvc/RangeResult.scala b/framework/src/play/src/main/scala/play/api/mvc/RangeResult.scala
index dac5127317..8ddcbd66ea 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/RangeResult.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/RangeResult.scala
@@ -4,7 +4,7 @@
 package play.api.mvc
 
 import akka.NotUsed
-import akka.stream.scaladsl.{ Flow, Source, StreamConverters }
+import akka.stream.scaladsl.{ FileIO, Flow, Source }
 import akka.stream.stage._
 import akka.util.ByteString
 import play.api.http.HeaderNames._
@@ -224,8 +224,7 @@ object RangeResult {
    * @param contentType The HTTP Content Type header for the response.
    */
   def ofPath(path: java.nio.file.Path, rangeHeader: Option[String], fileName: String, contentType: Option[String]): Result = {
-    // TODO use FileIO.fromFile after https://github.com/akka/akka/issues/20031 was released
-    val source = StreamConverters.fromInputStream(() => java.nio.file.Files.newInputStream(path))
+    val source = FileIO.fromFile(path.toFile)
     ofSource(path.toFile.length(), source, rangeHeader, Option(fileName), contentType)
   }
 
@@ -249,8 +248,7 @@ object RangeResult {
    * @param contentType The HTTP Content Type header for the response.
    */
   def ofFile(file: java.io.File, rangeHeader: Option[String], fileName: String, contentType: Option[String]): Result = {
-    // TODO use FileIO.fromFile after https://github.com/akka/akka/issues/20031 was released
-    val source = StreamConverters.fromInputStream(() => new java.io.FileInputStream(file))
+    val source = FileIO.fromFile(file)
     ofSource(file.length(), source, rangeHeader, Option(fileName), contentType)
   }
 
diff --git a/framework/src/play/src/main/scala/play/api/mvc/Results.scala b/framework/src/play/src/main/scala/play/api/mvc/Results.scala
index 85babd7478..3285fe62b7 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/Results.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/Results.scala
@@ -5,15 +5,15 @@ package play.api.mvc
 
 import java.nio.file.{ Files, Path }
 
-import akka.stream.scaladsl.{ StreamConverters, Source }
+import akka.stream.scaladsl.{ FileIO, Source, StreamConverters }
 import akka.util.ByteString
-import org.joda.time.{ DateTime, DateTimeZone }
 import org.joda.time.format.{ DateTimeFormat, DateTimeFormatter }
-import play.api.i18n.{ MessagesApi, Lang }
-import play.api.http._
+import org.joda.time.{ DateTime, DateTimeZone }
 import play.api.http.HeaderNames._
-
+import play.api.http._
+import play.api.i18n.{ Lang, MessagesApi }
 import play.core.utils.CaseInsensitiveOrdered
+
 import scala.collection.immutable.TreeMap
 
 /**
@@ -393,7 +393,7 @@ trait Results {
      * @param fileName Function to retrieve the file name. By default the name of the file is used.
      */
     def sendFile(content: java.io.File, inline: Boolean = false, fileName: java.io.File => String = _.getName, onClose: () => Unit = () => ()): Result = {
-      streamFile(StreamConverters.fromInputStream(() => Files.newInputStream(content.toPath)), fileName(content), content.length, inline)
+      streamFile(FileIO.fromFile(content), fileName(content), content.length, inline)
     }
 
     /**
@@ -404,8 +404,7 @@ trait Results {
      * @param fileName Function to retrieve the file name. By default the name of the file is used.
      */
     def sendPath(content: Path, inline: Boolean = false, fileName: Path => String = _.getFileName.toString, onClose: () => Unit = () => ()): Result = {
-      streamFile(StreamConverters.fromInputStream(() => Files.newInputStream(content)),
-        fileName(content), Files.size(content), inline)
+      streamFile(FileIO.fromFile(content.toFile), fileName(content), Files.size(content), inline)
     }
 
     /**
diff --git a/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala b/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
index 1e33ab2a2a..97ed9a2a36 100644
--- a/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
+++ b/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
@@ -119,7 +119,7 @@ object Multipart {
   def handleFilePartAsTemporaryFile: FilePartHandler[TemporaryFile] = {
     case FileInfo(partName, filename, contentType) =>
       val tempFile = TemporaryFile("multipartBody", "asTemporaryFile")
-      Accumulator(StreamConverters.fromOutputStream(() => new java.io.FileOutputStream(tempFile.file))).map { _ =>
+      Accumulator(FileIO.toFile(tempFile.file)).map { _ =>
         FilePart(partName, filename, contentType, tempFile)
       }
   }
diff --git a/framework/src/play/src/test/java/play/mvc/RangeResultsTest.java b/framework/src/play/src/test/java/play/mvc/RangeResultsTest.java
index 55f02ddd72..cd15440b34 100644
--- a/framework/src/play/src/test/java/play/mvc/RangeResultsTest.java
+++ b/framework/src/play/src/test/java/play/mvc/RangeResultsTest.java
@@ -10,13 +10,12 @@ import static play.mvc.Http.MimeTypes.*;
 import static play.mvc.Http.Status.*;
 
 import akka.stream.IOResult;
+import akka.stream.javadsl.FileIO;
 import akka.stream.javadsl.Source;
-import akka.stream.javadsl.StreamConverters;
 import akka.util.ByteString;
 import org.junit.*;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -135,27 +134,12 @@ public class RangeResultsTest {
 
     // -- Sources
 
-    @Test
-    public void shouldReturnRangeResultForStream() throws IOException {
-        this.mockRangeRequest();
-
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
-        Result result = RangeResults.ofSource(path.toFile().length(), source, path.toFile().getName(), BINARY);
-        closeStreamSilently(stream);
-
-        assertEquals(result.status(), PARTIAL_CONTENT);
-        assertEquals(BINARY, result.header(CONTENT_TYPE).orElse(""));
-    }
-
     @Test
     public void shouldNotReturnRangeResultForStreamWhenHeaderIsNotPresent() throws IOException {
         this.mockRegularRequest();
 
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
+        Source<ByteString, CompletionStage<IOResult>> source = FileIO.fromFile(path.toFile());
         Result result = RangeResults.ofSource(path.toFile().length(), source, path.toFile().getName(), BINARY);
-        closeStreamSilently(stream);
 
         assertEquals(result.status(), OK);
         assertEquals(BINARY, result.header(CONTENT_TYPE).orElse(""));
@@ -165,10 +149,8 @@ public class RangeResultsTest {
     public void shouldReturnRangeResultForStreamWhenHeaderIsPresentAndContentTypeWasSpecified() throws IOException {
         this.mockRangeRequest();
 
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
+        Source<ByteString, CompletionStage<IOResult>> source = FileIO.fromFile(path.toFile());
         Result result = RangeResults.ofSource(path.toFile().length(), source, path.toFile().getName(), TEXT);
-        closeStreamSilently(stream);
 
         assertEquals(result.status(), PARTIAL_CONTENT);
         assertEquals(TEXT, result.header(CONTENT_TYPE).orElse(""));
@@ -178,10 +160,8 @@ public class RangeResultsTest {
     public void shouldReturnRangeResultForStreamWithCustomFilename() throws IOException {
         this.mockRangeRequest();
 
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
+        Source<ByteString, CompletionStage<IOResult>> source = FileIO.fromFile(path.toFile());
         Result result = RangeResults.ofSource(path.toFile().length(), source, "file.txt", BINARY);
-        closeStreamSilently(stream);
 
         assertEquals(result.status(), PARTIAL_CONTENT);
         assertEquals(BINARY, result.header(CONTENT_TYPE).orElse(""));
@@ -192,10 +172,8 @@ public class RangeResultsTest {
     public void shouldNotReturnRangeResultForStreamWhenHeaderIsNotPresentWithCustomFilename() throws IOException {
         this.mockRegularRequest();
 
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
+        Source<ByteString, CompletionStage<IOResult>> source = FileIO.fromFile(path.toFile());
         Result result = RangeResults.ofSource(path.toFile().length(), source, "file.txt", BINARY);
-        closeStreamSilently(stream);
 
         assertEquals(result.status(), OK);
         assertEquals(BINARY, result.header(CONTENT_TYPE).orElse(""));
@@ -206,12 +184,9 @@ public class RangeResultsTest {
     public void shouldReturnPartialContentForSourceWithGivenEntityLength() throws IOException {
         this.mockRangeRequest();
 
-        InputStream stream = Files.newInputStream(path);
-        Source<ByteString, CompletionStage<IOResult>> source = StreamConverters.fromInputStream(() -> stream);
-
         long entityLength = path.toFile().length();
+        Source<ByteString, CompletionStage<IOResult>> source = FileIO.fromFile(path.toFile());
         Result result = RangeResults.ofSource(entityLength, source, "file.txt", TEXT);
-        closeStreamSilently(stream);
 
         assertEquals(result.status(), PARTIAL_CONTENT);
         assertEquals(TEXT, result.header(CONTENT_TYPE).orElse(""));
@@ -228,12 +203,4 @@ public class RangeResultsTest {
         when(request.getHeader(RANGE)).thenReturn("bytes=0-1");
         when(this.ctx.request()).thenReturn(request);
     }
-
-    private void closeStreamSilently(InputStream stream) {
-        try {
-            stream.close();
-        } catch (IOException e) {
-            // do nothing
-        }
-    }
 }
