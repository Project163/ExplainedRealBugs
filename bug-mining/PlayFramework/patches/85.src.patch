diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/BasicHttpClient.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/BasicHttpClient.scala
index 6f108b0f02..4fdc04440b 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/BasicHttpClient.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/BasicHttpClient.scala
@@ -89,6 +89,20 @@ class BasicHttpClient(port: Int, secure: Boolean) {
     }
   }
 
+  def sendRaw(data: Array[Byte], headers: Map[String, String]): BasicResponse = {
+    val outputStream = s.getOutputStream
+    outputStream.write("POST / HTTP/1.1\r\n".getBytes("UTF-8"))
+    outputStream.write("Host: localhost\r\n".getBytes("UTF-8"))
+    headers.foreach { header =>
+      outputStream.write(s"${header._1}: ${header._2}\r\n".getBytes("UTF-8"))
+    }
+    outputStream.flush()
+
+    outputStream.write("\r\n".getBytes("UTF-8"))
+    outputStream.write(data)
+    readResponse("0 continue")
+  }
+
   /**
    * Send a request
    *
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/RequestBodyHandlingSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/RequestBodyHandlingSpec.scala
index 2df3a512ef..cecdf7271b 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/RequestBodyHandlingSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/RequestBodyHandlingSpec.scala
@@ -3,6 +3,8 @@
  */
 package play.it.http
 
+import java.util.zip.Deflater
+
 import akka.stream.scaladsl.{ Flow, Sink }
 import akka.util.ByteString
 import play.api.inject.guice.GuiceApplicationBuilder
@@ -30,6 +32,24 @@ trait RequestBodyHandlingSpec extends PlaySpecification with ServerIntegrationSp
       }
     }
 
+    "handle gzip bodies" in withServer(Action { rh =>
+      Results.Ok(rh.body.asText.getOrElse(""))
+    }) { port =>
+      val bodyString = "Hello World"
+
+      // Compress the bytes
+      var output = new Array[Byte](100)
+      val compresser = new Deflater()
+      compresser.setInput(bodyString.getBytes("UTF-8"))
+      compresser.finish()
+      val compressedDataLength = compresser.deflate(output)
+
+      val client = new BasicHttpClient(port, false)
+      val response = client.sendRaw(output, Map("Content-Type" -> "text/plain", "Content-Length" -> compressedDataLength.toString, "Content-Encoding" -> "deflate"))
+      response.status must_== 200
+      response.body.left.get must_== bodyString
+    }.skipUntilAkkaHttpFixed
+
     "handle large bodies" in withServer(EssentialAction { rh =>
       Accumulator(Sink.ignore).map(_ => Results.Ok)
     }) { port =>
diff --git a/framework/src/play-netty-server/src/main/java/play/core/server/netty/PlayHttpContentDecompressor.java b/framework/src/play-netty-server/src/main/java/play/core/server/netty/PlayHttpContentDecompressor.java
new file mode 100644
index 0000000000..db50eaf646
--- /dev/null
+++ b/framework/src/play-netty-server/src/main/java/play/core/server/netty/PlayHttpContentDecompressor.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009-2016 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.core.server.netty;
+
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.*;
+
+import java.util.List;
+
+public class PlayHttpContentDecompressor extends HttpContentDecompressor {
+    private boolean contentLength = false;
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {
+        // This will fix https://github.com/playframework/playframework/issues/6152
+        // And could be removed if https://github.com/netty/netty/issues/5428 is fixed
+        if (msg instanceof HttpRequest) {
+            HttpRequest request = (HttpRequest)msg;
+            // This will check if there is a Content-Length header and if it is greater than zero
+            contentLength = HttpHeaders.getContentLength(request, 0) != 0;
+        }
+
+        // delegate to the original decode method
+        super.decode(ctx, msg, out);
+
+        if (msg instanceof HttpRequest) {
+            HttpRequest request = (HttpRequest)msg;
+            // if the request was gzipped and the Content-Length header was set, we check if it is still there
+            // since netty-reactive-stream needs to know if this message has a body which is determined
+            // by the Content-Length or Transfer-Encoding Header
+            if (contentLength && !HttpHeaders.isContentLengthSet(request)) {
+                HttpHeaders.setTransferEncodingChunked(request);
+            }
+        }
+    }
+
+}
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/NettyServer.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/NettyServer.scala
index 47cfa3a392..488e37f9d1 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/NettyServer.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/NettyServer.scala
@@ -172,7 +172,7 @@ class NettyServer(
       // Netty HTTP decoders/encoders/etc
       pipeline.addLast("decoder", new HttpRequestDecoder(maxInitialLineLength, maxHeaderSize, maxChunkSize))
       pipeline.addLast("encoder", new HttpResponseEncoder())
-      pipeline.addLast("decompressor", new HttpContentDecompressor())
+      pipeline.addLast("decompressor", new PlayHttpContentDecompressor())
       if (logWire) {
         pipeline.addLast("logging", new LoggingHandler(LogLevel.DEBUG))
       }
