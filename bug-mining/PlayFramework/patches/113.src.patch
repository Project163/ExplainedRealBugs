diff --git a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaModelConversion.scala b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaModelConversion.scala
index 0d99dbaa41..864a2176a0 100644
--- a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaModelConversion.scala
+++ b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaModelConversion.scala
@@ -228,13 +228,10 @@ private[server] class AkkaModelConversion(
   }
 
   def parseContentType(contentType: Option[String]): ContentType = {
-    // actually play allows content types to be not spec compliant
-    // so we can't rely on the parsed content type of akka
     contentType.fold(ContentTypes.NoContentType: ContentType) { ct =>
-      MediaType.custom(ct, binary = true) match {
-        case b: MediaType.Binary => ContentType(b)
-        case _ => ContentTypes.NoContentType
-      }
+      ContentType.parse(ct).left.map { errors =>
+        throw new RuntimeException(s"Error parsing response Content-Type: <$ct>: $errors")
+      }.merge
     }
   }
 
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
index 64aa2f8ec9..29518f10a2 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
@@ -99,6 +99,46 @@ trait ScalaResultsHandlingSpec extends PlaySpecification with WsTestClient with
         response.body must_== "abcdefghi"
       }
 
+    "support reponses with custom Content-Types" in {
+      makeRequest(
+        Results.Ok.sendEntity(HttpEntity.Strict(ByteString(0xff.toByte), Some("schmitch/foo; bar=bax")))
+      ) { response =>
+          response.header(CONTENT_TYPE) must beSome("schmitch/foo; bar=bax")
+          response.header(CONTENT_LENGTH) must beSome("1")
+          response.header(TRANSFER_ENCODING) must beNone
+          response.bodyAsBytes must_== ByteString(0xff.toByte)
+        }
+    }
+
+    "support multipart/mixed responses" in {
+      // Example taken from https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html
+      val contentType = "multipart/mixed; boundary=\"simple boundary\""
+      val body: String =
+        """|This is the preamble.  It is to be ignored, though it
+           |is a handy place for mail composers to include an
+           |explanatory note to non-MIME compliant readers.
+           |--simple boundary
+           |
+           |This is implicitly typed plain ASCII text.
+           |It does NOT end with a linebreak.
+           |--simple boundary
+           |Content-type: text/plain; charset=us-ascii
+           |
+           |This is explicitly typed plain ASCII text.
+           |It DOES end with a linebreak.
+           |
+           |--simple boundary--
+           |This is the epilogue.  It is also to be ignored.""".stripMargin
+      makeRequest(
+        Results.Ok.sendEntity(HttpEntity.Strict(ByteString(body), Some(contentType)))
+      ) { response =>
+          response.header(CONTENT_TYPE) must beSome(contentType)
+          response.header(CONTENT_LENGTH) must beSome(body.length.toString)
+          response.header(TRANSFER_ENCODING) must beNone
+          response.body must_== body
+        }
+    }
+
     "chunk results for chunked streaming strategy" in makeRequest(
       Results.Ok.chunked(Source(List("a", "b", "c")))
     ) { response =>
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
index 18eea359ad..12f983577e 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
@@ -62,7 +62,12 @@ trait AssetsSpec extends PlaySpecification
 
       result.status must_== OK
       result.body.trim must_== "{}"
-      result.header(CONTENT_TYPE) must beSome.which(_ == "application/json; charset=utf-8")
+      result.header(CONTENT_TYPE) must (
+        // There are many valid responses, but for simplicity just hardcode the two responses that
+        // the Netty and Akka HTTP backends actually return.
+        beSome("application/json; charset=utf-8") or
+        beSome("application/json")
+      )
       result.header(ETAG) must beSome(matching(etagPattern))
       result.header(LAST_MODIFIED) must beSome
       result.header(VARY) must beNone
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/libs/JavaWSSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/libs/JavaWSSpec.scala
index 0ce72c7be5..4761d22e27 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/libs/JavaWSSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/libs/JavaWSSpec.scala
@@ -7,6 +7,7 @@ import java.io.File
 import java.nio.ByteBuffer
 import java.nio.charset.{ Charset, StandardCharsets }
 import java.util
+import java.util.Optional
 import java.util.concurrent.{ CompletionStage, TimeUnit }
 
 import akka.stream.scaladsl.{ FileIO, Sink, Source }
@@ -24,7 +25,7 @@ import play.it.{ AkkaHttpIntegrationSpecification, NettyIntegrationSpecification
 import play.libs.ws.{ WSBodyReadables, WSBodyWritables, WSRequest, WSResponse }
 import play.mvc.Http
 
-import scala.compat.java8.FutureConverters
+import scala.compat.java8.{ FutureConverters, OptionConverters }
 import scala.concurrent.{ Await, Future }
 
 class NettyJavaWSSpec(val ee: ExecutionEnv) extends JavaWSSpec with NettyIntegrationSpecification
@@ -149,7 +150,13 @@ trait JavaWSSpec extends PlaySpecification with ServerIntegrationSpecification w
     }
 
     "response asXml with correct contentType" in withXmlServer { ws =>
-      val body = ws.url("/xml").get().toCompletableFuture.get().asXml()
+      val response: WSResponse = ws.url("/xml").get().toCompletableFuture.get()
+      OptionConverters.toScala(response.getSingleHeader("Content-Type")) must (
+        // There are many valid responses, but for simplicity just hardcode the two responses that
+        // the Netty and Akka HTTP backends actually return.
+        beSome("application/xml; charset=windows-1252") or beSome("application/xml;charset=Windows-1252")
+      )
+      val body = response.asXml()
       new String(body.getElementsByTagName("name").item(0).getTextContent.getBytes("Windows-1252")) must_== isoString
     }
 
