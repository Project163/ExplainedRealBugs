diff --git a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
index 2503eff196..a7277a36d4 100644
--- a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
+++ b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
@@ -159,6 +159,8 @@ private[akkahttp] object ModelConversion {
           contentType = convertedHeaders.contentType,
           data = dataSource(enum)
         ))
+      case ServerResultUtils.StreamWithNoBody =>
+        Right(HttpEntity.Empty)
       case ServerResultUtils.StreamWithKnownLength(enum) =>
         Right(HttpEntity.Default(
           contentType = convertedHeaders.contentType,
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
index cf875bf616..34ac90f9f7 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
@@ -283,6 +283,67 @@ trait ScalaResultsHandlingSpec extends PlaySpecification with WsTestClient with
       }
     }
 
+    "not have a message body even when a 204 response with a non-empty body is returned" in withServer(
+      Result(header = ResponseHeader(NO_CONTENT),
+        body = Enumerator("foo") &> Enumeratee.map[String](_.getBytes)(ec),
+        connection = HttpConnection.KeepAlive)
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("PUT", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+      }
+
+    "not have a message body even when a 304 response with a non-empty body is returned" in withServer(
+      Result(header = ResponseHeader(NOT_MODIFIED),
+        body = Enumerator("foo") &> Enumeratee.map[String](_.getBytes)(ec),
+        connection = HttpConnection.KeepAlive)
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("PUT", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+      }
+
+    "not have a message body, nor Content-Length, when a 204 response is returned" in withServer(
+      Results.NoContent
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("PUT", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+        response.headers.get(CONTENT_LENGTH) must beNone
+      }
+
+    "not have a message body, but do have a Content-Length, when a 204 response with an explicit Content-Lenght is returned" in withServer(
+      Results.NoContent.withHeaders("Content-Length" -> "0")
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("PUT", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+        response.headers.get(CONTENT_LENGTH) must beSome("0")
+      }
+
+    "not have a message body, nor a Content-Length, when a 304 response is returned" in withServer(
+      Results.NotModified
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("GET", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+        response.headers.get(CONTENT_LENGTH) must beNone
+      }
+
+    "not have a message body, but do have a Content-Length, when a 304 response with an explicit Content-Length is returned" in withServer(
+      Results.NotModified.withHeaders("Content-Length" -> "0")
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("GET", "/", "HTTP/1.1", Map(), "")
+        )(0)
+        response.body must beLeft("")
+        response.headers.get(CONTENT_LENGTH) must beSome("0")
+      }
   }
 
 }
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
index 65d6e4a8f3..d47a2e2593 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
@@ -51,6 +51,12 @@ object NettyResultStreamer {
           enum |>>> nettyStreamIteratee(createNettyResponse(result.header, true, httpVersion), startSequence, true)
         case ServerResultUtils.StreamWithKnownLength(enum) =>
           enum |>>> nettyStreamIteratee(createNettyResponse(result.header, closeConnection, httpVersion), startSequence, closeConnection)
+        case ServerResultUtils.StreamWithNoBody =>
+          // `StreamWithNoBody` won't add the Content-Length entity-header to the response (if not already present) 
+          val nettyResponse = createNettyResponse(result.header, closeConnection, httpVersion)
+          val future = sendDownstream(startSequence, !closeConnection, nettyResponse).toScala
+          val channelStatus = new ChannelStatus(closeConnection, startSequence)
+          future.map(_ => channelStatus).recover { case _ => channelStatus }
         case ServerResultUtils.StreamWithStrictBody(body) =>
           // We successfully buffered it, so set the content length and send the whole thing as one buffer
           val buffer = if (body.isEmpty) ChannelBuffers.EMPTY_BUFFER else ChannelBuffers.wrappedBuffer(body)
diff --git a/framework/src/play-server/src/main/scala/play/core/server/common/ServerResultUtils.scala b/framework/src/play-server/src/main/scala/play/core/server/common/ServerResultUtils.scala
index fe4b7e9b37..ebbe64537c 100644
--- a/framework/src/play-server/src/main/scala/play/core/server/common/ServerResultUtils.scala
+++ b/framework/src/play-server/src/main/scala/play/core/server/common/ServerResultUtils.scala
@@ -19,6 +19,7 @@ object ServerResultUtils {
   final case class StreamWithClose(enum: Enumerator[Array[Byte]]) extends ResultStreaming
   final case class StreamWithKnownLength(enum: Enumerator[Array[Byte]]) extends ResultStreaming
   final case class StreamWithStrictBody(body: Array[Byte]) extends ResultStreaming
+  final case object StreamWithNoBody extends ResultStreaming
   final case class UseExistingTransferEncoding(transferEncodedEnum: Enumerator[Array[Byte]]) extends ResultStreaming
   final case class PerformChunkedTransferEncoding(enum: Enumerator[Array[Byte]]) extends ResultStreaming
 
@@ -32,13 +33,15 @@ object ServerResultUtils {
    * Result headers.
    */
   def determineResultStreaming(result: Result, isHttp10: Boolean): Future[ResultStreaming] = {
-
+    def mustNotIncludeBody(result: Result): Boolean = result.header.status == 204 || result.header.status == 304
     result match {
       case _ if result.header.headers.exists(_._2 == null) =>
         Future.successful(CannotStream(
           "A header was set to null",
           Results.InternalServerError("")
         ))
+      case _ if mustNotIncludeBody(result) =>
+        Future.successful(StreamWithNoBody)
       case _ if (result.connection == HttpConnection.Close) =>
         Future.successful(StreamWithClose(result.body))
       case _ if (result.header.headers.contains(TRANSFER_ENCODING)) =>
