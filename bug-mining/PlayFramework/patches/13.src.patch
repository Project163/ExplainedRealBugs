diff --git a/framework/src/play-integration-test/src/test/resources/application.conf b/framework/src/play-integration-test/src/test/resources/application.conf
index d1482ce52f..767c0255db 100644
--- a/framework/src/play-integration-test/src/test/resources/application.conf
+++ b/framework/src/play-integration-test/src/test/resources/application.conf
@@ -1 +1,2 @@
-# Play sometimes gets grumpy if this file doesn't exist.
\ No newline at end of file
+# Play sometimes gets grumpy if this file doesn't exist.
+play.crypto.secret = "abc"
\ No newline at end of file
diff --git a/framework/src/play-integration-test/src/test/resources/logback.xml b/framework/src/play-integration-test/src/test/resources/logback.xml
new file mode 100644
index 0000000000..126d604324
--- /dev/null
+++ b/framework/src/play-integration-test/src/test/resources/logback.xml
@@ -0,0 +1,17 @@
+<!--
+  ~ Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
+  -->
+<!-- The default logback configuration that Play uses if no other configuration is provided -->
+<configuration>
+
+    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+        <encoder>
+            <pattern>%level %logger{15} - %message%n%xException</pattern>
+        </encoder>
+    </appender>
+
+    <root level="WARN">
+        <appender-ref ref="STDOUT" />
+    </root>
+
+</configuration>
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
index 37d95648d6..d1cf0662df 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/assets/AssetsSpec.scala
@@ -4,16 +4,13 @@
 package play.it.http.assets
 
 import controllers.Assets
-import controllers.Assets.Asset
+import play.api.libs.ws.WSClient
 import play.api.test._
 import org.apache.commons.io.IOUtils
-import java.util.zip.GZIPInputStream
 import java.io.ByteArrayInputStream
-import play.api.{ Configuration, Mode }
-import play.api.mvc.{ PathBindable, Handler }
+import play.api.Mode
+import play.core.server.{ ServerConfig, Server }
 import play.it._
-import play.utils.{ UriEncoding, Threads }
-import play.core.routing.ReverseRouteContext
 
 object NettyAssetsSpec extends AssetsSpec with NettyIntegrationSpecification
 object AkkaHttpAssetsSpec extends AssetsSpec with AkkaHttpIntegrationSpecification
@@ -21,32 +18,25 @@ object AkkaHttpAssetsSpec extends AssetsSpec with AkkaHttpIntegrationSpecificati
 trait AssetsSpec extends PlaySpecification
     with WsTestClient with ServerIntegrationSpecification {
 
+  sequential
+
   "Assets controller" should {
 
     val defaultCacheControl = Some("public, max-age=3600")
     val aggressiveCacheControl = Some("public, max-age=31536000")
 
-    implicit val port: Port = testServerPort
-
-    def withServer[T](block: => T): T = {
-      import Asset._
-      val routes: PartialFunction[(String, String), Handler] = {
-        case (_, path) => Assets.versioned("/testassets", path)
+    def withServer[T](block: WSClient => T): T = {
+      Server.withRouter(ServerConfig(mode = Mode.Prod, port = Some(0))) {
+        case req => Assets.versioned("/testassets", req.path)
+      } { implicit port =>
+        withClient(block)
       }
-      running(TestServer(port, new FakeApplication(withRoutes = routes) {
-        // setting prod mode ensures caching headers get set, gzip is turned on, etc
-        override val mode = Mode.Prod
-        // but we don't want to load config in prod mode
-        override lazy val configuration = Threads.withContextClassLoader(classloader) {
-          Configuration(Configuration.loadDev(path, Map.empty))
-        }
-      }))(block)
     }
 
     val etagPattern = """([wW]/)?"([^"]|\\")*""""
 
-    "serve an asset" in withServer {
-      val result = await(wsUrl("/bar.txt").get())
+    "serve an asset" in withServer { client =>
+      val result = await(client.url("/bar.txt").get())
 
       result.status must_== OK
       result.body must_== "This is a test asset."
@@ -58,8 +48,8 @@ trait AssetsSpec extends PlaySpecification
       result.header(CACHE_CONTROL) must_== defaultCacheControl
     }
 
-    "serve an asset in a subdirectory" in withServer {
-      val result = await(wsUrl("/subdir/baz.txt").get())
+    "serve an asset in a subdirectory" in withServer { client =>
+      val result = await(client.url("/subdir/baz.txt").get())
 
       result.status must_== OK
       result.body must_== "Content of baz.txt."
@@ -71,8 +61,8 @@ trait AssetsSpec extends PlaySpecification
       result.header(CACHE_CONTROL) must_== defaultCacheControl
     }
 
-    "serve an asset with spaces in the name" in withServer {
-      val result = await(wsUrl("/foo%20bar.txt").get())
+    "serve an asset with spaces in the name" in withServer { client =>
+      val result = await(client.url("/foo%20bar.txt").get())
 
       result.status must_== OK
       result.body must_== "This is a test asset with spaces."
@@ -84,16 +74,16 @@ trait AssetsSpec extends PlaySpecification
       result.header(CACHE_CONTROL) must_== defaultCacheControl
     }
 
-    "serve a non gzipped asset when gzip is available but not requested" in withServer {
-      val result = await(wsUrl("/foo.txt").get())
+    "serve a non gzipped asset when gzip is available but not requested" in withServer { client =>
+      val result = await(client.url("/foo.txt").get())
 
       result.body must_== "This is a test asset."
       result.header(VARY) must beSome(ACCEPT_ENCODING)
       result.header(CONTENT_ENCODING) must beNone
     }
 
-    "serve a gzipped asset" in withServer {
-      val result = await(wsUrl("/foo.txt")
+    "serve a gzipped asset" in withServer { client =>
+      val result = await(client.url("/foo.txt")
         .withHeaders(ACCEPT_ENCODING -> "gzip")
         .get())
 
@@ -107,9 +97,9 @@ trait AssetsSpec extends PlaySpecification
       success
     }
 
-    "return not modified when etag matches" in withServer {
-      val Some(etag) = await(wsUrl("/foo.txt").get()).header(ETAG)
-      val result = await(wsUrl("/foo.txt")
+    "return not modified when etag matches" in withServer { client =>
+      val Some(etag) = await(client.url("/foo.txt").get()).header(ETAG)
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_NONE_MATCH -> etag)
         get ())
 
@@ -120,9 +110,9 @@ trait AssetsSpec extends PlaySpecification
       result.header(LAST_MODIFIED) must beSome
     }
 
-    "return not modified when multiple etags supply and one matches" in withServer {
-      val Some(etag) = await(wsUrl("/foo.txt").get()).header(ETAG)
-      val result = await(wsUrl("/foo.txt")
+    "return not modified when multiple etags supply and one matches" in withServer { client =>
+      val Some(etag) = await(client.url("/foo.txt").get()).header(ETAG)
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_NONE_MATCH -> ("\"foo\", " + etag + ", \"bar\""))
         .get())
 
@@ -130,8 +120,8 @@ trait AssetsSpec extends PlaySpecification
       result.body must beEmpty
     }
 
-    "return asset when etag doesn't match" in withServer {
-      val result = await(wsUrl("/foo.txt")
+    "return asset when etag doesn't match" in withServer { client =>
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_NONE_MATCH -> "\"foobar\"")
         .get())
 
@@ -139,9 +129,9 @@ trait AssetsSpec extends PlaySpecification
       result.body must_== "This is a test asset."
     }
 
-    "return not modified when not modified since" in withServer {
-      val Some(timestamp) = await(wsUrl("/foo.txt").get()).header(LAST_MODIFIED)
-      val result = await(wsUrl("/foo.txt")
+    "return not modified when not modified since" in withServer { client =>
+      val Some(timestamp) = await(client.url("/foo.txt").get()).header(LAST_MODIFIED)
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_MODIFIED_SINCE -> timestamp)
         .get())
 
@@ -154,8 +144,8 @@ trait AssetsSpec extends PlaySpecification
       result.header(CACHE_CONTROL) must beNone
     }
 
-    "return asset when modified since" in withServer {
-      val result = await(wsUrl("/foo.txt")
+    "return asset when modified since" in withServer { client =>
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_MODIFIED_SINCE -> "Tue, 13 Mar 2012 13:08:36 GMT")
         .get())
 
@@ -163,8 +153,8 @@ trait AssetsSpec extends PlaySpecification
       result.body must_== "This is a test asset."
     }
 
-    "ignore if modified since header if if none match header is set" in withServer {
-      val result = await(wsUrl("/foo.txt")
+    "ignore if modified since header if if none match header is set" in withServer { client =>
+      val result = await(client.url("/foo.txt")
         .withHeaders(
           IF_NONE_MATCH -> "\"foobar\"",
           IF_MODIFIED_SINCE -> "Wed, 01 Jan 2113 00:00:00 GMT" // might break in 100 years, but I won't be alive, so :P
@@ -174,8 +164,8 @@ trait AssetsSpec extends PlaySpecification
       result.body must_== "This is a test asset."
     }
 
-    "return the asset if the if modified since header can't be parsed" in withServer {
-      val result = await(wsUrl("/foo.txt")
+    "return the asset if the if modified since header can't be parsed" in withServer { client =>
+      val result = await(client.url("/foo.txt")
         .withHeaders(IF_MODIFIED_SINCE -> "Not a date")
         .get())
 
@@ -183,22 +173,22 @@ trait AssetsSpec extends PlaySpecification
       result.body must_== "This is a test asset."
     }
 
-    "return 200 if the asset is empty" in withServer {
-      val result = await(wsUrl("/empty.txt").get())
+    "return 200 if the asset is empty" in withServer { client =>
+      val result = await(client.url("/empty.txt").get())
 
       result.status must_== OK
       result.body must beEmpty
     }
 
-    "return 404 for files that don't exist" in withServer {
-      val result = await(wsUrl("/nosuchfile.txt").get())
+    "return 404 for files that don't exist" in withServer { client =>
+      val result = await(client.url("/nosuchfile.txt").get())
 
       result.status must_== NOT_FOUND
       result.header(CONTENT_TYPE) must beSome.which(_.startsWith("text/html"))
     }
 
-    "serve a versioned asset" in withServer {
-      val result = await(wsUrl("/versioned/sub/12345678901234567890123456789012-foo.txt").get())
+    "serve a versioned asset" in withServer { client =>
+      val result = await(client.url("/versioned/sub/12345678901234567890123456789012-foo.txt").get())
 
       result.status must_== OK
       result.body must_== "This is a test asset."
@@ -209,5 +199,20 @@ trait AssetsSpec extends PlaySpecification
       result.header(CONTENT_ENCODING) must beNone
       result.header(CACHE_CONTROL) must_== aggressiveCacheControl
     }
+
+    "return not found when the path is a directory" in {
+      "if the directory is on the file system" in withServer { client =>
+        await(client.url("/subdir").get()).status must_== NOT_FOUND
+      }
+      "if the directory is a jar entry" in {
+        Server.withRouter() {
+          case req => Assets.versioned("/scala", req.path)
+        } { implicit port =>
+          withClient { client =>
+            await(client.url("/collection").get()).status must_== NOT_FOUND
+          }
+        }
+      }
+    }
   }
 }
diff --git a/framework/src/play-server/src/main/scala/play/core/server/Server.scala b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
index 2b509bd15d..550c893306 100644
--- a/framework/src/play-server/src/main/scala/play/core/server/Server.scala
+++ b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
@@ -110,7 +110,6 @@ object Server {
   def withApplication[T](application: Application, config: ServerConfig = ServerConfig(port = Some(0), mode = Mode.Test))(block: Port => T)(implicit provider: ServerProvider): T = {
     val server = provider.createServer(config, new TestApplication(application))
     try {
-      Play.start(application)
       block(new Port((server.httpPort orElse server.httpsPort).get))
     } finally {
       server.stop()
diff --git a/framework/src/play/src/main/scala/play/api/controllers/Assets.scala b/framework/src/play/src/main/scala/play/api/controllers/Assets.scala
index 72471f7d5b..12a488898b 100644
--- a/framework/src/play/src/main/scala/play/api/controllers/Assets.scala
+++ b/framework/src/play/src/main/scala/play/api/controllers/Assets.scala
@@ -11,7 +11,7 @@ import java.io._
 import java.net.{ URL, URLConnection, JarURLConnection }
 import org.joda.time.format.{ DateTimeFormatter, DateTimeFormat }
 import org.joda.time.DateTimeZone
-import play.utils.{ InvalidUriEncodingException, UriEncoding }
+import play.utils.{ Resources, InvalidUriEncodingException, UriEncoding }
 import scala.concurrent.{ ExecutionContext, Promise, Future, blocking }
 import scala.util.control.NonFatal
 import scala.util.{ Success, Failure }
@@ -170,7 +170,7 @@ private[controllers] class AssetInfo(
           try {
             f(urlConnection)
           } finally {
-            urlConnection.getInputStream.close()
+            Resources.closeUrlConnection(urlConnection)
           }
       }.filterNot(_ == -1).map(dateFormat.print)
     }
@@ -443,20 +443,29 @@ class AssetsBuilder(errorHandler: HttpErrorHandler) extends Controller {
       assetInfoForRequest(request, name)
     } getOrElse Future.successful(None)
 
+    def notFound = errorHandler.onClientError(request, NOT_FOUND, "Resource not found by Assets controller")
+
     val pendingResult: Future[Result] = assetInfoFuture.flatMap {
       case Some((assetInfo, gzipRequested)) =>
-        val stream = assetInfo.url(gzipRequested).openStream()
-        val length = stream.available
-        val resourceData = Enumerator.fromStream(stream)(Implicits.defaultExecutionContext)
-
-        Future.successful(maybeNotModified(request, assetInfo, aggressiveCaching).getOrElse {
-          cacheableResult(
-            assetInfo,
-            aggressiveCaching,
-            result(file, length, assetInfo.mimeType, resourceData, gzipRequested, assetInfo.gzipUrl.isDefined)
-          )
-        })
-      case None => errorHandler.onClientError(request, NOT_FOUND, "Resource not found by Assets controller")
+        val connection = assetInfo.url(gzipRequested).openConnection()
+        // Make sure it's not a directory
+        if (Resources.isUrlConnectionADirectory(connection)) {
+          Resources.closeUrlConnection(connection)
+          notFound
+        } else {
+          val stream = connection.getInputStream
+          val length = stream.available
+          val resourceData = Enumerator.fromStream(stream)(Implicits.defaultExecutionContext)
+
+          Future.successful(maybeNotModified(request, assetInfo, aggressiveCaching).getOrElse {
+            cacheableResult(
+              assetInfo,
+              aggressiveCaching,
+              result(file, length, assetInfo.mimeType, resourceData, gzipRequested, assetInfo.gzipUrl.isDefined)
+            )
+          })
+        }
+      case None => notFound
     }
 
     pendingResult.recoverWith {
diff --git a/framework/src/play/src/main/scala/play/utils/Resources.scala b/framework/src/play/src/main/scala/play/utils/Resources.scala
index 8955f7ee93..ea49500196 100644
--- a/framework/src/play/src/main/scala/play/utils/Resources.scala
+++ b/framework/src/play/src/main/scala/play/utils/Resources.scala
@@ -3,10 +3,12 @@
  */
 package play.utils
 
-import java.net.{ URI, URL }
+import java.net.{ JarURLConnection, URLConnection, URI, URL }
 import java.io.File
 import java.util.zip.ZipFile
 
+import sun.net.www.protocol.file.FileURLConnection
+
 /**
  * Provide resources helpers
  */
@@ -19,6 +21,47 @@ object Resources {
     case _ => throw new IllegalArgumentException(s"Cannot check isDirectory for a URL with protocol='${url.getProtocol}'")
   }
 
+  /**
+   * Tries to work out whether the given URL connection is a directory or not.
+   *
+   * Depends on the URL connection type whether it's accurate.  If it's unable to determine whether it's a directory,
+   * this returns false.
+   */
+  def isUrlConnectionADirectory(urlConnection: URLConnection) = urlConnection match {
+    case file: FileURLConnection => new File(file.getURL.toURI).isDirectory
+    case jar: JarURLConnection =>
+      if (jar.getJarEntry.isDirectory) {
+        true
+      } else {
+        // JarEntry.isDirectory is rubbish....
+        val is = jar.getJarFile.getInputStream(jar.getJarEntry)
+        if (is == null) {
+          true
+        } else {
+          is.close()
+          false
+        }
+      }
+    case other => false
+  }
+
+  /**
+   * Close a URL connection.
+   *
+   * This works around a JDK bug where if the URL connection is to a JAR file, and the entry is a directory, an NPE is
+   * thrown.
+   */
+  def closeUrlConnection(connection: URLConnection): Unit = {
+    connection match {
+      case jar: JarURLConnection =>
+        if (!jar.getUseCaches) {
+          jar.getJarFile.close()
+        }
+      case other =>
+        other.getInputStream.close()
+    }
+  }
+
   private def isBundleResourceDirectory(classLoader: ClassLoader, url: URL): Boolean = {
     /* ClassLoader within an OSGi container behave differently than the standard classloader.
      * One difference is how getResource returns when the resource's name end with a slash.
