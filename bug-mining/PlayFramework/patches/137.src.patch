diff --git a/framework/src/play-filters-helpers/src/main/scala/play/filters/cors/AbstractCORSPolicy.scala b/framework/src/play-filters-helpers/src/main/scala/play/filters/cors/AbstractCORSPolicy.scala
index f3a57c0bbb..0a73183c61 100644
--- a/framework/src/play-filters-helpers/src/main/scala/play/filters/cors/AbstractCORSPolicy.scala
+++ b/framework/src/play-filters-helpers/src/main/scala/play/filters/cors/AbstractCORSPolicy.scala
@@ -107,7 +107,10 @@ private[cors] trait AbstractCORSPolicy {
      * headers and terminate this set of steps.
      */
     if (!corsConfig.allowedOrigins(origin)) {
-      handleInvalidCORSRequest(request)
+      if (corsConfig.serveForbiddenOrigins)
+        next(request)
+      else
+        handleInvalidCORSRequest(request)
     } else {
       import play.core.Execution.Implicits.trampoline
 
diff --git a/framework/src/play-filters-helpers/src/test/scala/play/filters/cors/CORSCommonSpec.scala b/framework/src/play-filters-helpers/src/test/scala/play/filters/cors/CORSCommonSpec.scala
index 66d2fa46a5..a12e2a9ec2 100644
--- a/framework/src/play-filters-helpers/src/test/scala/play/filters/cors/CORSCommonSpec.scala
+++ b/framework/src/play-filters-helpers/src/test/scala/play/filters/cors/CORSCommonSpec.scala
@@ -74,13 +74,22 @@ trait CORSCommonSpec extends PlaySpecification {
       }
       "forbidden" in withApplication(conf = serveForbidden) { app =>
         val result = route(app, fakeRequest().withHeaders(
-          ORIGIN -> "http://www.example.com"
+          ORIGIN -> "http://www.notinwhitelistorhost.com"
         )).get
 
         status(result) must_== OK
         header(VARY, result) must beSome(ORIGIN)
         mustBeNoAccessControlResponseHeaders(result)
       }
+      "in the whitelist" in withApplication(conf = serveForbidden) { app =>
+        val result = route(app, fakeRequest().withHeaders(
+          ORIGIN -> "http://example.org"
+        )).get
+
+        status(result) must_== OK
+        header(ACCESS_CONTROL_ALLOW_ORIGIN, result) must beSome("http://example.org")
+        header(VARY, result) must beSome(ORIGIN)
+      }
     }
 
     "not consider sub domains to be the same origin" in withApplication() { app =>
