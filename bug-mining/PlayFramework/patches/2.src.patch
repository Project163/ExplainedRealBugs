diff --git a/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala b/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala
index d0e0eea528..7108eb3e20 100644
--- a/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala
+++ b/framework/src/play-json/src/main/scala/play/api/libs/json/JsValue.scala
@@ -220,66 +220,28 @@ case class JsObject(fields: Seq[(String, JsValue)]) extends JsValue {
 
   /**
    * merges everything in depth and doesn't stop at first level as ++
-   * TODO : improve because coding is nasty there
    */
   def deepMerge(other: JsObject): JsObject = {
-    def step(fields: Vector[(String, JsValue)], others: Vector[(String, JsValue)]): Seq[(String, JsValue)] = {
-      others match {
-        case Vector() => fields
-        case Vector(sv) =>
-          var found = false
-          val newFields = fields match {
-            case Vector() => Vector(sv)
-            case _ => fields.foldLeft(Vector[(String, JsValue)]()) { (acc, field) =>
-              field match {
-                case (key, obj: JsObject) if (key == sv._1) =>
-                  found = true
-                  acc :+ key -> {
-                    sv._2 match {
-                      case o @ JsObject(_) => obj.deepMerge(o)
-                      case js => js
-                    }
-                  }
-                case (key, value) if (key == sv._1) =>
-                  found = true
-                  acc :+ key -> sv._2
-                case (key, value) => acc :+ key -> value
-              }
-            }
-          }
 
-          if (!found) fields :+ sv
-          else newFields
-
-        case head +: tail =>
-          var found = false
-          val headFields = fields match {
-            case Vector() => Vector(head)
-            case _ => fields.foldLeft(Vector[(String, JsValue)]()) { (acc, field) =>
-              field match {
-                case (key, obj: JsObject) if (key == head._1) =>
-                  found = true
-                  acc :+ key -> {
-                    head._2 match {
-                      case o @ JsObject(_) => obj.deepMerge(o)
-                      case js => js
-                    }
-                  }
-                case (key, value) if (key == head._1) =>
-                  found = true
-                  acc :+ key -> head._2
-                case (key, value) => acc :+ key -> value
-              }
-            }
-          }
+    def deepMerge(existingObject: JsObject, otherObject: JsObject): JsObject = {
 
-          if (!found) step(fields :+ head, tail)
-          else step(headFields, tail)
+      val resultFields: mutable.Map[String, JsValue] = mutable.LinkedHashMap(existingObject.fields: _*)
 
+      otherObject.fields.foreach {
+        case (otherKey, otherValue) =>
+          val maybeExistingValue = resultFields.get(otherKey)
+
+          val newValue = (maybeExistingValue, otherValue) match {
+            case (Some(e: JsObject), o: JsObject) => deepMerge(e, o)
+            case (Some(e: JsArray), o: JsArray) => e ++ o
+            case _ => otherValue
+          }
+          resultFields.put(otherKey, newValue)
       }
+      JsObject(resultFields.toSeq)
     }
 
-    JsObject(step(fields.toVector, other.fields.toVector))
+    deepMerge(this, other)
   }
 
   override def equals(other: Any): Boolean =
diff --git a/framework/src/play-json/src/test/scala/play/api/libs/json/JsObjectSpec.scala b/framework/src/play-json/src/test/scala/play/api/libs/json/JsObjectSpec.scala
new file mode 100644
index 0000000000..c346f3402e
--- /dev/null
+++ b/framework/src/play-json/src/test/scala/play/api/libs/json/JsObjectSpec.scala
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2009-2013 Typesafe Inc. <http://www.typesafe.com>
+ */
+package play.api.libs.json
+
+import org.specs2.mutable._
+import play.api.libs.json.Json._
+
+object JsObjectSpec extends Specification {
+
+  "JsObject.deepMerge" should {
+
+    "not fail when the objects are empty" in {
+      Json.obj().deepMerge(Json.obj()) must beEqualTo(Json.obj())
+    }
+
+    "merge correctly when the source object is empty" in {
+      val populatedObj = Json.obj(
+        "field1" -> 123,
+        "field2" -> "abc",
+        "field3" -> JsNull
+      )
+      populatedObj.deepMerge(Json.obj()) must beEqualTo(populatedObj)
+    }
+
+    "merge correctly when the incoming object is empty" in {
+      val populatedObj = Json.obj(
+        "field1" -> 123,
+        "field2" -> "abc",
+        "field3" -> JsNull
+      )
+      Json.obj().deepMerge(populatedObj) must beEqualTo(populatedObj)
+    }
+  }
+
+  "JsObject.deepMerge should keep existing attributes where there is no collision and" should {
+
+    "overwrite existing attributes on collision when value is not a JsArray or JsObject" in {
+      Json.obj(
+        "field1" -> 123,
+        "field2" -> "abc",
+        "field3" -> JsNull,
+        "field4" -> 456,
+        "field5" -> "abc",
+        "field6" -> "def"
+      ).deepMerge(Json.obj(
+          "field4" -> 789,
+          "field5" -> "xyz",
+          "field6" -> JsNull
+        )) must beEqualTo(
+          Json.obj(
+            "field1" -> 123,
+            "field2" -> "abc",
+            "field3" -> JsNull,
+            "field4" -> 789,
+            "field5" -> "xyz",
+            "field6" -> JsNull
+          )
+        )
+    }
+
+    "recursively merge where elements are both of type JsArray or both of type JsObject" in {
+      Json.obj(
+        "field1" -> 123,
+        "field2" -> "abc",
+        "field3" -> Json.arr(
+          "abc", "def", "ghi"
+        ),
+        "field4" -> Json.obj(
+          "field1a" -> 888,
+          "field2b" -> "xxx",
+          "field3c" -> JsNull
+        )
+      ).deepMerge(Json.obj(
+          "field3" -> Json.arr(
+            "jkl", "mno", "pqr"
+          ),
+          "field4" -> Json.obj(
+            "field1a" -> 999,
+            "field2b" -> "yyy",
+            "field3c" -> "zzz"
+          )
+        )) must beEqualTo(
+          Json.obj(
+            "field1" -> 123,
+            "field2" -> "abc",
+            "field3" -> Json.arr(
+              "abc", "def", "ghi", "jkl", "mno", "pqr"
+            ),
+            "field4" -> Json.obj(
+              "field1a" -> 999,
+              "field2b" -> "yyy",
+              "field3c" -> "zzz"
+            )
+          )
+        )
+    }
+
+    "properly merge a deep structure" in {
+      Json.obj(
+        "field1a" -> Json.obj(
+          "field2a" -> Json.obj(
+            "field3a" -> Json.obj(
+              "field4a" -> Json.obj(
+                "field5a" -> "abc",
+                "field5b" -> Json.arr("111", "222"),
+                "field5d" -> Json.arr(Json.obj("a" -> 1), Json.obj("b" -> 2))
+              )
+            ),
+            "field2b" -> Json.arr("aaa", "bbb"),
+            "field2c" -> Json.obj(
+              "hello" -> "world"
+            )
+          ),
+          "field2b" -> "xxx",
+          "field2c" -> JsNull
+        )
+      ).deepMerge(Json.obj(
+          "field1a" -> Json.obj(
+            "field2a" -> Json.obj(
+              "field3a" -> Json.obj(
+                "field4a" -> Json.obj(
+                  "field5b" -> Json.arr("333", "444"),
+                  "field5c" -> "deep",
+                  "field5d" -> Json.arr(Json.obj("c" -> 3), Json.obj("d" -> 4))
+                )
+              ),
+              "field2b" -> Json.arr("ccc", "ddd"),
+              "field2c" -> Json.obj(
+                "hello" -> "new world"
+              )
+            ),
+            "field2b" -> "yyy",
+            "field2d" -> "zzz"
+          )
+        )) must beEqualTo(
+          Json.obj(
+            "field1a" -> Json.obj(
+              "field2a" -> Json.obj(
+                "field3a" -> Json.obj(
+                  "field4a" -> Json.obj(
+                    "field5a" -> "abc",
+                    "field5b" -> Json.arr("111", "222", "333", "444"),
+                    "field5c" -> "deep",
+                    "field5d" -> Json.arr(Json.obj("a" -> 1), Json.obj("b" -> 2), Json.obj("c" -> 3), Json.obj("d" -> 4))
+                  )
+                ),
+                "field2b" -> Json.arr("aaa", "bbb", "ccc", "ddd"),
+                "field2c" -> Json.obj(
+                  "hello" -> "new world"
+                )
+              ),
+              "field2b" -> "yyy",
+              "field2c" -> JsNull,
+              "field2d" -> "zzz"
+            )
+          )
+        )
+    }
+  }
+}
+
