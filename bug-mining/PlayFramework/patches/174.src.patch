diff --git a/core/play/src/main/java/play/mvc/BodyParser.java b/core/play/src/main/java/play/mvc/BodyParser.java
index 81ea2b3f32..ba9b697ecc 100644
--- a/core/play/src/main/java/play/mvc/BodyParser.java
+++ b/core/play/src/main/java/play/mvc/BodyParser.java
@@ -316,6 +316,9 @@ public interface BodyParser<A> {
       final Function<Charset, F.Either<Exception, String>> decode =
           (Charset encodingToTry) -> {
             try {
+              // Make sure we are at the beginning of the buffer - previous decoding attempts may
+              // have managed to advance through a part of the buffer before failing.
+              byteBuffer.rewind();
               CharsetDecoder decoder =
                   encodingToTry.newDecoder().onMalformedInput(CodingErrorAction.REPORT);
               return F.Either.Right(decoder.decode(byteBuffer).toString());
diff --git a/core/play/src/main/scala/play/api/mvc/BodyParsers.scala b/core/play/src/main/scala/play/api/mvc/BodyParsers.scala
index e327c84dba..8a861f0ff4 100644
--- a/core/play/src/main/scala/play/api/mvc/BodyParsers.scala
+++ b/core/play/src/main/scala/play/api/mvc/BodyParsers.scala
@@ -468,6 +468,9 @@ trait PlayBodyParsers extends BodyParserUtils {
         import java.nio.charset.CodingErrorAction
         val decoder = encodingToTry.newDecoder.onMalformedInput(CodingErrorAction.REPORT)
         try {
+          // Make sure we are at the beginning of the buffer - previous decoding attempts may have
+          // managed to advance through a part of the buffer before failing.
+          byteBuffer.rewind()
           Success(decoder.decode(byteBuffer).toString)
         } catch {
           case e: CharacterCodingException =>
diff --git a/core/play/src/test/scala/play/api/mvc/TextBodyParserSpec.scala b/core/play/src/test/scala/play/api/mvc/TextBodyParserSpec.scala
index 56eebaccd7..d75763419c 100644
--- a/core/play/src/test/scala/play/api/mvc/TextBodyParserSpec.scala
+++ b/core/play/src/test/scala/play/api/mvc/TextBodyParserSpec.scala
@@ -121,6 +121,14 @@ class TextBodyParserSpec extends Specification with AfterAll {
         }
       }
 
+      "as UTF-8 for undefined even if US-ASCII could parse a prefix" in {
+        val body        = ByteString("Oekra誰ene") // 'Oekra' can be decoded by US-ASCII
+        val postRequest = FakeRequest("POST", "/").withBody(body).withHeaders("Content-Type" -> "text/plain")
+        tolerantParse(postRequest, body) must beRight.like {
+          case text => text must beEqualTo("Oekra誰ene")
+        }
+      }
+
       "as UTF-8 even if the guessed encoding is utterly wrong" in {
         // This is not a full solution, so anything where we have a potentially valid encoding is seized on, even
         // when it's not the best one.
diff --git a/core/play/src/test/scala/play/mvc/TextBodyParserSpec.scala b/core/play/src/test/scala/play/mvc/TextBodyParserSpec.scala
index 5f0f16baf8..31973697f4 100644
--- a/core/play/src/test/scala/play/mvc/TextBodyParserSpec.scala
+++ b/core/play/src/test/scala/play/mvc/TextBodyParserSpec.scala
@@ -134,6 +134,15 @@ class TextBodyParserSpec extends Specification with AfterAll with MustMatchers {
         }
       }
 
+      "as UTF-8 for undefined even if US-ASCII could parse a prefix" in {
+        val body = ByteString("Oekra誰ene") // 'Oekra' can be decoded by US-ASCII
+        val postRequest =
+          new Http.RequestBuilder().method("POST").body(new RequestBody(body), "text/plain").req
+        tolerantParse(req(postRequest), body) must beRight.like {
+          case text => text must beEqualTo("Oekra誰ene")
+        }
+      }
+
       "as UTF-8 even if the guessed encoding is utterly wrong" in {
         // This is not a full solution, so anything where we have a potentially valid encoding is seized on, even
         // when it's not the best one.
