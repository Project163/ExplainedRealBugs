diff --git a/documentation/manual/working/javaGuide/main/ws/JavaWS.md b/documentation/manual/working/javaGuide/main/ws/JavaWS.md
index 4e271b411c..a613d9f2d1 100644
--- a/documentation/manual/working/javaGuide/main/ws/JavaWS.md
+++ b/documentation/manual/working/javaGuide/main/ws/JavaWS.md
@@ -107,11 +107,31 @@ Similarly, you can process the response as XML by calling `response.asXml()`.
 
 ### Processing large responses
 
-When you are downloading a large file or document, `WS` allows you to get the response body as an `InputStream` so you can process the data without loading the entire content into memory at once.
+Calling `get()`, `post()` or `execute()` will cause the body of the response to be loaded into memory before the response is made available.  When you are downloading a large, multi-gigabyte file, this may result in unwelcomed garbage collection or even out of memory errors.
 
-@[ws-response-input-stream](code/javaguide/ws/JavaWS.java)
+`WS` lets you consume the response's body incrementally by using an Akka Streams `Sink`.  The `stream()` method on `WSRequest` returns a `CompletionStage<StreamedResponse>`. A `StreamedResponse` is a simple container holding together the response's headers and body.
 
-This example will read the response body and write it to a file in buffered increments.
+Any controller or component that wants to levearge the WS streaming functionality will have to add the following imports and dependencies:
+
+@[ws-streams-controller](code/javaguide/ws/MyController.java)
+
+Here is a trivial example that uses a folding `Sink` to count the number of bytes returned by the response:
+
+@[stream-count-bytes](code/javaguide/ws/JavaWS.java)
+
+Alternatively, you could also stream the body out to another location. For example, a file:
+
+@[stream-to-file](code/javaguide/ws/JavaWS.java)
+
+Another common destination for response bodies is to stream them back from a controller's `Action`:
+
+@[stream-to-result](code/javaguide/ws/JavaWS.java)
+
+As you may have noticed, before calling `stream()` we need to set the HTTP method to use by calling `setMethod` on the request. Here follows another example that uses `PUT` instead of `GET`:
+
+@[stream-put](code/javaguide/ws/JavaWS.java)
+
+Of course, you can use any other valid HTTP verb.
 
 ## Common Patterns and Use Cases
 
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
index 4d71c6395c..ab124bf00e 100644
--- a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
@@ -15,8 +15,15 @@ import com.fasterxml.jackson.databind.JsonNode;
 import play.libs.Json;
 // #json-imports
 
+import scala.compat.java8.FutureConverters;
+
 import java.io.*;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
 import java.util.stream.*;
 
 import org.w3c.dom.Document;
@@ -24,6 +31,9 @@ import play.mvc.Result;
 
 import javax.inject.Inject;
 
+import play.http.HttpEntity;
+import play.mvc.Http.Status;
+
 // #ws-custom-client-imports
 import org.asynchttpclient.*;
 import play.api.libs.ws.WSClientConfig;
@@ -44,6 +54,7 @@ public class JavaWS {
     public static class Controller0 extends MockJavaAction {
 
         private WSClient ws;
+        private Materializer materializer;
 
         public void requestExamples() {
             // #ws-holder
@@ -113,7 +124,7 @@ public class JavaWS {
 
         public void responseExamples() {
 
-          String url = "http://example.com";
+            String url = "http://example.com";
 
             // #ws-response-json
             Promise<JsonNode> jsonPromise = ws.url(url).get().map(response -> {
@@ -126,31 +137,118 @@ public class JavaWS {
                 return response.asXml();
             });
             // #ws-response-xml
+        }
 
-            // #ws-response-input-stream
-            Promise<File> filePromise = ws.url(url).get().map(response -> {
-                // write the inputStream to a File
-                File file = new File("/tmp/response.txt");
+        public void streamSimpleRequest() {
+            String url = "http://example.com";
+            // #stream-count-bytes
+            // Make the request
+            CompletionStage<StreamedResponse> futureResponse = 
+                ws.url(url).setMethod("GET").stream();
 
-                try(
-                    InputStream inputStream = response.getBodyAsStream();
-                    OutputStream outputStream = new FileOutputStream(file)
-                ) {
-                    int read = 0;
-                    byte[] buffer = new byte[1024];
+            CompletionStage<Long> bytesReturned = futureResponse.thenCompose(res -> {
+                Source<ByteString, ?> responseBody = res.getBody();
 
-                    while ((read = inputStream.read(buffer)) != -1) {
-                        outputStream.write(buffer, 0, read);
-                    }
+                // Count the number of bytes returned
+                Sink<ByteString, scala.concurrent.Future<Long>> bytesSum =
+                    Sink.fold(0L, (total, bytes) -> total + bytes.length());
+
+                // Converts the materialized Scala Future into a Java8 `CompletionStage`
+                Sink<ByteString, CompletionStage<Long>> convertedBytesSum =
+                    bytesSum.mapMaterializedValue(FutureConverters::toJava);
+
+                return responseBody.runWith(convertedBytesSum, materializer);
+            });
+            // #stream-count-bytes
+        }
+
+        public void streamFile() throws IOException, FileNotFoundException, InterruptedException, ExecutionException {
+            String url = "http://example.com";
+            //#stream-to-file
+            File file = File.createTempFile("stream-to-file-", ".txt");
+            FileOutputStream outputStream = new FileOutputStream(file);
+
+            // Make the request
+            CompletionStage<StreamedResponse> futureResponse =
+                ws.url(url).setMethod("GET").stream();
+
+            CompletionStage<File> downloadedFile = futureResponse.thenCompose(res -> {
+                Source<ByteString, ?> responseBody = res.getBody();
+
+                // The sink that writes to the output stream
+                Sink<ByteString,scala.concurrent.Future<scala.runtime.BoxedUnit>> outputWriter = 
+                    Sink.<ByteString>foreach(bytes -> outputStream.write(bytes.toArray()));
+
+                // Converts the materialized Scala Future into a Java8 `CompletionStage`
+                Sink<ByteString, CompletionStage<?>> convertedOutputWriter =
+                    outputWriter.mapMaterializedValue(FutureConverters::toJava);
+
+                // materialize and run the stream
+                CompletionStage<File> result = responseBody.runWith(convertedOutputWriter, materializer)
+                    .whenComplete((value, error) -> {
+                        // Close the output stream whether there was an error or not
+                        try { outputStream.close(); }
+                        catch(IOException e) {}
+                    })
+                    .thenApply(v -> file);
+                return result;
+            });
+            //#stream-to-file
+            downloadedFile.toCompletableFuture().get();
+            file.delete();
+        }
 
-                    return file;
-                } catch(IOException e) {
-                    throw new RuntimeException(e);
+        public void streamResponse() {
+            String url = "http://example.com";
+            //#stream-to-result
+            // Make the request
+            CompletionStage<StreamedResponse> futureResponse = ws.url(url).setMethod("GET").stream();
+
+            CompletionStage<Result> result = futureResponse.thenApply(response -> {
+                WSResponseHeaders responseHeaders = response.getHeaders();
+                Source<ByteString, ?> body = response.getBody();
+                // Check that the response was successful
+                if (responseHeaders.getStatus() == 200) {
+                    // Get the content type
+                    String contentType =
+                        Optional.ofNullable(responseHeaders.getHeaders().get("Content-Type"))
+                        .map(contentTypes -> contentTypes.get(0)).
+                        orElse("application/octet-stream");
+
+                    // If there's a content length, send that, otherwise return the body chunked
+                    Optional<String> contentLength = Optional.ofNullable(responseHeaders.getHeaders()
+                        .get("Content-Length"))
+                        .map(contentLengths -> contentLengths.get(0));
+                    if(contentLength.isPresent()) {
+                        return ok().sendEntity(new HttpEntity.Streamed(
+                            body, 
+                            Optional.of(Long.parseLong(contentLength.get())), 
+                            Optional.of(contentType)
+                        ));
+                    }
+                    else {
+                        return ok().chunked(body).as(contentType);
+                    }
+                }
+                else {
+                    return new Result(Status.BAD_GATEWAY);
                 }
             });
-            // #ws-response-input-stream
+            // Your controller's action method should return a `Promise<Result>`, and here we 
+            // shows how the conversion from  `CompletionStage` to `Promise` can be done. This 
+            // won't be needed once https://github.com/playframework/playframework/issues/4691 
+            // is fixed.
+            Promise<Result> actionResult = Promise.wrap(FutureConverters.toScala(result));
+            //#stream-to-result
         }
 
+        public void streamPut() {
+            String url = "http://example.com";
+            //#stream-put
+            CompletionStage<StreamedResponse> futureResponse  =
+                ws.url(url).setMethod("PUT").setBody("some body").stream();
+            //#stream-put
+        }
         public void patternExamples() {
             String urlOne = "http://localhost:3333/one";
             // #ws-composition
@@ -196,7 +294,7 @@ public class JavaWS {
                             .setProxyServer(new org.asynchttpclient.proxy.ProxyServer("127.0.0.1", 38080))
                             .setCompressionEnforced(true)
                             .build();
-            Materializer materializer = play.api.Play.current().materializer();
+
             WSClient customClient = new play.libs.ws.ning.NingWSClient(customConfig, materializer);
 
             Promise<WSResponse> responsePromise = customClient.url("http://example.com/feed").get();
@@ -237,5 +335,4 @@ public class JavaWS {
         }
         // #composed-call
     }
-
-}
+}
\ No newline at end of file
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/MyController.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/MyController.java
new file mode 100644
index 0000000000..953e6de83d
--- /dev/null
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/MyController.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
+ */
+package javaguide.ws;
+
+// #ws-streams-controller
+import javax.inject.Inject;
+
+import akka.stream.Materializer;
+import akka.stream.javadsl.*;
+import akka.util.ByteString;
+
+import play.mvc.*;
+import play.libs.ws.*;
+import play.libs.F.Promise;
+
+import scala.compat.java8.FutureConverters;
+
+public class MyController extends Controller {
+
+    @Inject WSClient ws;
+    @Inject Materializer materializer;
+
+    // ...
+}
+// #ws-streams-controller
diff --git a/documentation/manual/working/scalaGuide/main/ws/ScalaWS.md b/documentation/manual/working/scalaGuide/main/ws/ScalaWS.md
index b86b37ee0c..d8787040d9 100644
--- a/documentation/manual/working/scalaGuide/main/ws/ScalaWS.md
+++ b/documentation/manual/working/scalaGuide/main/ws/ScalaWS.md
@@ -159,6 +159,8 @@ As you may have noticed, before calling `stream()` we need to set the HTTP metho
 
 @[stream-put](code/ScalaWSSpec.scala)
 
+Of course, you can use any other valid HTTP verb.
+
 ## Common Patterns and Use Cases
 
 ### Chaining WS calls
