diff --git a/.travis.yml b/.travis.yml
index 6f4ef8efc0..681955bed5 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,5 +1,12 @@
 language: scala
 sudo: false
+# This is needed as long as the travis build environment is JDK 1.8.0 < u40 (at time of writing it is u31)
+# Otherwise, FSpec fails due to deadlocks caused by CompletableFuture.thenCompose blocking in the trampoline 
+# executor.
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer
 jdk:
   - oraclejdk8
 env:
diff --git a/documentation/manual/detailedTopics/configuration/ThreadPools.md b/documentation/manual/detailedTopics/configuration/ThreadPools.md
index 8dde64cbaf..97243a17b5 100644
--- a/documentation/manual/detailedTopics/configuration/ThreadPools.md
+++ b/documentation/manual/detailedTopics/configuration/ThreadPools.md
@@ -84,7 +84,7 @@ Class loaders and thread locals need special handling in a multithreaded environ
 In a Play application the [thread context class loader](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#getContextClassLoader--) may not always be able to load application classes. You should explicitly use the application class loader to load classes.
 
 Java
-: @[using-app-classloader](code/ThreadPoolsJava.java)
+: @[using-app-classloader](code/detailedtopics/ThreadPoolsJava.java)
 
 Scala
 : @[using-app-classloader](code/ThreadPools.scala)
@@ -97,12 +97,13 @@ In some cases you may not be able to explicitly use the application classloader.
 
 Java code in Play uses a `ThreadLocal` to find out about contextual information such as the current HTTP request. Scala code doesn't need to use `ThreadLocal`s because it can use implicit parameters to pass context instead. `ThreadLocal`s are used in Java so that Java code can access contextual information without needing to pass context parameters everywhere.
 
-Java `ThreadLocal`s, along with the correct context `ClassLoader`, are propagated automatically by `ExecutionContextExecutor` objects provided through the `HttpExecution` class. (An `ExecutionContextExecutor` is both a Scala `ExecutionContext` and a Java `Executor`.) These special `ExecutionContextExecutor` objects are automatically created and used by Java actions and Java `Promise` methods. The default objects wrap the default user thread pool. If you want to do your own threading then you should use the `HttpExecution` class' helper methods to get an `ExecutionContextExecutor` object yourself.
+The problem with using thread locals however is that as soon as control switches to another thread, you lose thread local information. So if you were to map a `CompletionStage` using `thenApply`, and then try to access the HTTP context (eg, the session or request), it won't work.  To address this, Play provides an [`HttpExecutionContext`](api/java/play/libs/concurrent/HttpExecutionContext.html).  This allows you to capture the current context in an `Executor`, which you can then pass to the `CompletionStage` `*Async` methods such as `thenApplyAsync()`, and when the executor executes your callback, it will ensure the thread local context is setup so that you can access the request/session/flash/response objects.
 
-In the example below, a user thread pool is wrapped to create a new `ExecutionContext` that propagates thread locals correctly.
+To use the `HttpExecutionContext`, inject it into your component, and then pass the current context anytime a `CompletionStage` is interacted with.  For example:
 
-@[async-explicit-ec-imports](../../working/javaGuide/main/async/code/javaguide/async/controllers/Application.java)
-@[async-explicit-ec](../../working/javaGuide/main/async/code/javaguide/async/controllers/Application.java)
+@[http-execution-context](code/detailedtopics/httpec/MyController.java)
+
+If you have a custom executor, you can wrap it in an `HttpExecutionContext` simply by passing it to the `HttpExecutionContext`s constructor.
 
 ## Best practices
 
diff --git a/documentation/manual/detailedTopics/configuration/code/ThreadPoolsJava.java b/documentation/manual/detailedTopics/configuration/code/detailedtopics/ThreadPoolsJava.java
similarity index 94%
rename from documentation/manual/detailedTopics/configuration/code/ThreadPoolsJava.java
rename to documentation/manual/detailedTopics/configuration/code/detailedtopics/ThreadPoolsJava.java
index 310e34780c..3fc47dc21e 100644
--- a/documentation/manual/detailedTopics/configuration/code/ThreadPoolsJava.java
+++ b/documentation/manual/detailedTopics/configuration/code/detailedtopics/ThreadPoolsJava.java
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
  */
-package detailedtopics.configuration.threadpools;
+package detailedtopics;
 
 import org.junit.Test;
 import play.Play;
diff --git a/documentation/manual/detailedTopics/configuration/code/detailedtopics/httpec/MyController.java b/documentation/manual/detailedTopics/configuration/code/detailedtopics/httpec/MyController.java
new file mode 100644
index 0000000000..699266a0b2
--- /dev/null
+++ b/documentation/manual/detailedTopics/configuration/code/detailedtopics/httpec/MyController.java
@@ -0,0 +1,23 @@
+package detailedtopics.httpec;
+
+//#http-execution-context
+import play.libs.concurrent.HttpExecutionContext;
+import play.libs.ws.WSClient;
+import play.mvc.*;
+
+import javax.inject.Inject;
+import java.util.concurrent.CompletionStage;
+
+public class MyController extends Controller {
+    @Inject HttpExecutionContext ec;
+    @Inject WSClient ws;
+
+    public CompletionStage<Result> index() {
+        String checkUrl = request().getQueryString("url");
+        return ws.url(checkUrl).get().thenApplyAsync((response) -> {
+            session().put("lastStatus", Integer.toString(response.getStatus()));
+            return ok();
+        }, ec.current());
+    }
+}
+//#http-execution-context
diff --git a/documentation/manual/working/javaGuide/advanced/dependencyinjection/code/javaguide/advanced/di/MessageQueueConnection.java b/documentation/manual/working/javaGuide/advanced/dependencyinjection/code/javaguide/advanced/di/MessageQueueConnection.java
index 36caa12e57..e4a987cfe8 100644
--- a/documentation/manual/working/javaGuide/advanced/dependencyinjection/code/javaguide/advanced/di/MessageQueueConnection.java
+++ b/documentation/manual/working/javaGuide/advanced/dependencyinjection/code/javaguide/advanced/di/MessageQueueConnection.java
@@ -6,9 +6,9 @@ package javaguide.advanced.di;
 //#cleanup
 import javax.inject.*;
 import play.inject.ApplicationLifecycle;
-import play.libs.F;
 
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletableFuture;
 
 @Singleton
 public class MessageQueueConnection {
@@ -20,7 +20,7 @@ public class MessageQueueConnection {
 
         lifecycle.addStopHook(() -> {
             connection.stop();
-            return F.Promise.pure(null);
+            return CompletableFuture.completedFuture(null);
         });
     }
 
diff --git a/documentation/manual/working/javaGuide/advanced/embedding/code/javaguide/advanced/embedding/JavaEmbeddingPlay.java b/documentation/manual/working/javaGuide/advanced/embedding/code/javaguide/advanced/embedding/JavaEmbeddingPlay.java
index 0151cca2b3..5153b66149 100644
--- a/documentation/manual/working/javaGuide/advanced/embedding/code/javaguide/advanced/embedding/JavaEmbeddingPlay.java
+++ b/documentation/manual/working/javaGuide/advanced/embedding/code/javaguide/advanced/embedding/JavaEmbeddingPlay.java
@@ -6,18 +6,17 @@ package javaguide.advanced.embedding;
 import java.io.IOException;
 
 import org.asynchttpclient.AsyncHttpClientConfig;
-import org.junit.AfterClass;
-import org.junit.Before;
 import org.junit.Test;
 
-import play.libs.F;
 import play.libs.ws.WSClient;
 import play.libs.ws.WSResponse;
 import play.libs.ws.ning.NingWSClient;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.CompletionStage;
 import java.util.function.Consumer;
 
 //#imports
-import javax.inject.Inject;
 import play.api.Play;
 import play.Mode;
 import play.routing.RoutingDsl;
@@ -32,7 +31,7 @@ import static org.junit.Assert.*;
 public class JavaEmbeddingPlay {
 
     @Test
-    public void simple() throws IOException {
+    public void simple() throws Exception {
         //#simple
         Server server = Server.forRouter(new RoutingDsl()
             .GET("/hello/:to").routeTo(to ->
@@ -45,11 +44,15 @@ public class JavaEmbeddingPlay {
         try {
             withClient(ws -> {
                 //#http-port
-                F.Promise<WSResponse> response = ws.url(
+                CompletionStage<WSResponse> response = ws.url(
                     "http://localhost:" + server.httpPort() + "/hello/world"
                 ).get();
                 //#http-port
-                assertThat(response.get(10000).getBody(), equalTo("Hello world"));
+                try {
+                    assertThat(response.toCompletableFuture().get(10, TimeUnit.SECONDS).getBody(), equalTo("Hello world"));
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
             });
         } finally {
             //#stop
@@ -59,7 +62,7 @@ public class JavaEmbeddingPlay {
     }
 
     @Test
-    public void config() throws IOException {
+    public void config() throws Exception {
         //#config
         Server server = Server.forRouter(new RoutingDsl()
             .GET("/hello/:to").routeTo(to ->
@@ -71,8 +74,14 @@ public class JavaEmbeddingPlay {
         //#config
 
         try {
-            withClient(ws ->
-                assertThat(ws.url("http://localhost:19000/hello/world").get().get(10000).getBody(), equalTo("Hello world"))
+            withClient(ws -> {
+                    try {
+                        assertThat(ws.url("http://localhost:19000/hello/world").get().toCompletableFuture().get(10,
+                                TimeUnit.SECONDS).getBody(), equalTo("Hello world"));
+                    } catch (Exception e) {
+                        throw new RuntimeException(e);
+                    }
+                }
             );
         } finally {
             server.stop();
diff --git a/documentation/manual/working/javaGuide/advanced/extending/code/javaguide/advanced/extending/JavaPlugins.java b/documentation/manual/working/javaGuide/advanced/extending/code/javaguide/advanced/extending/JavaPlugins.java
index ff9598c80b..044aaba7a1 100644
--- a/documentation/manual/working/javaGuide/advanced/extending/code/javaguide/advanced/extending/JavaPlugins.java
+++ b/documentation/manual/working/javaGuide/advanced/extending/code/javaguide/advanced/extending/JavaPlugins.java
@@ -4,11 +4,11 @@ import akka.actor.ActorRef;
 import org.junit.Test;
 import play.Application;
 import play.Play;
-import play.libs.F;
-import play.test.*;
+import scala.compat.java8.FutureConverters;
 
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.Assert.*;
@@ -20,26 +20,26 @@ public class JavaPlugins {
     @Test
     public void pluginsShouldBeAccessible() {
         final AtomicReference<MyComponent> myComponentRef = new AtomicReference<MyComponent>();
-        Application app = fakeApplication(new HashMap<String, Object>(), Arrays.asList(MyPlugin.class.getName()));
-        running(app, new Runnable() {
-            public void run() {
-                //#access-plugin
-                MyComponent myComponent = Play.application().plugin(MyPlugin.class).getMyComponent();
-                //#access-plugin
-                assertTrue(myComponent.started);
-                myComponentRef.set(myComponent);
-            }
+        Application app = fakeApplication(new HashMap<>(), Arrays.asList(MyPlugin.class.getName()));
+        running(app, () -> {
+            //#access-plugin
+            MyComponent myComponent = Play.application().plugin(MyPlugin.class).getMyComponent();
+            //#access-plugin
+            assertTrue(myComponent.started);
+            myComponentRef.set(myComponent);
         });
         assertTrue(myComponentRef.get().stopped);
     }
 
     @Test
     public void actorExampleShouldWork() {
-        Application app = fakeApplication(new HashMap<String, Object>(), Arrays.asList(Actors.class.getName()));
-        running(app, new Runnable() {
-            public void run() {
-                ActorRef actor = Actors.getMyActor();
-                assertEquals("hi", F.Promise.wrap(ask(actor, "hi", 20000)).get(20000));
+        Application app = fakeApplication(new HashMap<>(), Arrays.asList(Actors.class.getName()));
+        running(app, () -> {
+            ActorRef actor = Actors.getMyActor();
+            try {
+                assertEquals("hi", FutureConverters.toJava(ask(actor, "hi", 20000)).toCompletableFuture().get(20, TimeUnit.SECONDS));
+            } catch (Exception e) {
+                throw new RuntimeException(e);
             }
         });
     }
diff --git a/documentation/manual/working/javaGuide/advanced/http/code/javaguide/RequestHandler.java b/documentation/manual/working/javaGuide/advanced/http/code/javaguide/RequestHandler.java
index 1c6edb0eff..ed0b6d120c 100644
--- a/documentation/manual/working/javaGuide/advanced/http/code/javaguide/RequestHandler.java
+++ b/documentation/manual/working/javaGuide/advanced/http/code/javaguide/RequestHandler.java
@@ -4,10 +4,10 @@
 
 //#default
 import play.http.HttpRequestHandler;
-import play.libs.F;
 import play.mvc.Action;
 import play.mvc.Http;
 import play.mvc.Result;
+import java.util.concurrent.CompletionStage;
 
 import java.lang.reflect.Method;
 
@@ -17,7 +17,7 @@ public class RequestHandler implements HttpRequestHandler {
     public Action createAction(Http.Request request, Method actionMethod) {
         return new Action.Simple() {
             @Override
-            public F.Promise<Result> call(Http.Context ctx) {
+            public CompletionStage<Result> call(Http.Context ctx) {
                 return delegate.call(ctx);
             }
         };
diff --git a/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java b/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
index f290eefab8..bfb71f23a1 100644
--- a/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
+++ b/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
@@ -8,7 +8,8 @@ import org.junit.Test;
 //#imports
 import play.api.routing.Router;
 import play.routing.RoutingDsl;
-import play.libs.F;
+import java.util.concurrent.CompletableFuture;
+
 import static play.mvc.Controller.*;
 //#imports
 
@@ -77,7 +78,7 @@ public class JavaRoutingDsl extends WithApplication {
         //#async
         Router router = new RoutingDsl()
             .GET("/api/items/:id").routeAsync((Integer id) ->
-                F.Promise.pure(ok("Getting item " + id))
+                CompletableFuture.completedFuture(ok("Getting item " + id))
             )
             .build();
         //#async
diff --git a/documentation/manual/working/javaGuide/code/MockJavaAction.scala b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
index 6b1faf045c..656ceb3cd1 100644
--- a/documentation/manual/working/javaGuide/code/MockJavaAction.scala
+++ b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
@@ -3,13 +3,14 @@
  */
 package javaguide.testhelpers {
 
+import java.util.concurrent.{CompletionStage, CompletableFuture}
+
 import akka.stream.Materializer
 import play.api.mvc.{Action, Request}
 import play.core.j.{JavaHandlerComponents, JavaHelpers, JavaActionAnnotations, JavaAction}
 import play.http.DefaultHttpRequestHandler
 import play.mvc.{Controller, Http, Result}
 import play.api.test.Helpers
-import play.libs.F
 import java.lang.reflect.Method
 
 abstract class MockJavaAction extends Controller with Action[Http.RequestBody] {
@@ -40,8 +41,8 @@ abstract class MockJavaAction extends Controller with Action[Http.RequestBody] {
 
   def invocation = {
     method.invoke(this) match {
-      case r: Result => F.Promise.pure(r)
-      case f: F.Promise[_] => f.asInstanceOf[F.Promise[Result]]
+      case r: Result => CompletableFuture.completedFuture(r)
+      case f: CompletionStage[_] => f.asInstanceOf[CompletionStage[Result]]
     }
   }
 }
diff --git a/documentation/manual/working/javaGuide/main/akka/JavaAkka.md b/documentation/manual/working/javaGuide/main/akka/JavaAkka.md
index a1bd78d7bd..7d610914a0 100644
--- a/documentation/manual/working/javaGuide/main/akka/JavaAkka.md
+++ b/documentation/manual/working/javaGuide/main/akka/JavaAkka.md
@@ -27,7 +27,7 @@ To create and/or use an actor, you need an `ActorSystem`.  This can be obtained
 
 The most basic thing that you can do with an actor is send it a message.  When you send a message to an actor, there is no response, it's fire and forget.  This is also known as the _tell_ pattern.
   
-In a web application however, the _tell_ pattern is often not useful, since HTTP is a protocol that has requests and responses.  In this case, it is much more likely that you will want to use the _ask_ pattern.  The ask pattern returns a Scala `Future`, which you can then wrap in a Play `Promise`, and then map to your own result type.
+In a web application however, the _tell_ pattern is often not useful, since HTTP is a protocol that has requests and responses.  In this case, it is much more likely that you will want to use the _ask_ pattern.  The ask pattern returns a Scala `Future`, which you can convert to a Java `CompletionStage` using `scala.compat.java8.FutureConverts.toJava`, and then map to your own result type.
 
 Below is an example of using our `HelloActor` with the ask pattern:
 
@@ -36,7 +36,7 @@ Below is an example of using our `HelloActor` with the ask pattern:
 A few things to notice:
 
 * The ask pattern needs to be imported, it's often most convenient to static import the `ask` method.
-* The returned future is wrapped in a `Promise`.  The resulting promise is a `Promise<Object>`, so when you access its value, you need to cast it to the type you are expecting back from the actor.
+* The returned future is converted to a `CompletionStage`.  The resulting promise is a `CompletionStage<Object>`, so when you access its value, you need to cast it to the type you are expecting back from the actor.
 * The ask pattern requires a timeout, we have supplied 1000 milliseconds.  If the actor takes longer than that to respond, the returned promise will be completed with a timeout error.
 * Since we're creating the actor in the constructor, we need to scope our controller as `Singleton`, so that a new actor isn't created every time this controller is used.
 
diff --git a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
index d2f4582fd8..f5813b6583 100644
--- a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
+++ b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
@@ -12,13 +12,11 @@ import org.junit.Test;
 
 import play.Application;
 import play.inject.guice.GuiceApplicationBuilder;
-import play.libs.F.Promise;
 import play.mvc.Result;
-import play.test.*;
+import scala.compat.java8.FutureConverters;
 import scala.concurrent.duration.Duration;
 
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
+import java.util.concurrent.*;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
@@ -40,8 +38,12 @@ public class JavaAkka {
         running(app, () -> {
             javaguide.akka.ask.Application controller = app.injector().instanceOf(javaguide.akka.ask.Application.class);
 
-            String message = contentAsString(controller.sayHello("world").get(1000));
-            assertThat(message, equalTo("Hello, world"));
+            try {
+                String message = contentAsString(controller.sayHello("world").toCompletableFuture().get(1, TimeUnit.SECONDS));
+                assertThat(message, equalTo("Hello, world"));
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
         });
     }
 
@@ -54,8 +56,12 @@ public class JavaAkka {
         running(app, () -> {
             javaguide.akka.inject.Application controller = app.injector().instanceOf(javaguide.akka.inject.Application.class);
 
-            String message = contentAsString(controller.getConfig().get(1000));
-            assertThat(message, equalTo("foo"));
+            try {
+                String message = contentAsString(controller.getConfig().toCompletableFuture().get(1, TimeUnit.SECONDS));
+                assertThat(message, equalTo("foo"));
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
         });
     }
 
@@ -68,11 +74,14 @@ public class JavaAkka {
         running(app, () -> {
             ActorRef parent = app.injector().instanceOf(play.inject.Bindings.bind(ActorRef.class).qualifiedWith("parent-actor"));
 
-            String message = (String) Promise.wrap(ask(parent, new ParentActorProtocol.GetChild("my.config"), 1000)).flatMap(child ->
-                    Promise.wrap(ask((ActorRef) child, new ConfiguredChildActorProtocol.GetConfig(), 1000))
-            ).get(5000);
-
-            assertThat(message, equalTo("foo"));
+            try {
+                String message = (String) FutureConverters.toJava(ask(parent, new ParentActorProtocol.GetChild("my.config"), 1000)).thenCompose(child ->
+                        FutureConverters.toJava(ask((ActorRef) child, new ConfiguredChildActorProtocol.GetConfig(), 1000))
+                ).toCompletableFuture().get(5, TimeUnit.SECONDS);
+                assertThat(message, equalTo("foo"));
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
         });
     }
 
@@ -87,7 +96,7 @@ public class JavaAkka {
         Application app = fakeApplication();
         running(app, () -> {
             Result result = MockJavaActionHelper.call(new MockJavaAction() {
-                public Promise<Result> index() {
+                public CompletionStage<Result> index() {
                     return new javaguide.akka.async.Application().index();
                 }
             }, fakeRequest(), app.getWrappedApplication().materializer());
diff --git a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/ask/Application.java b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/ask/Application.java
index 97a2dc25fb..5a21036a89 100644
--- a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/ask/Application.java
+++ b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/ask/Application.java
@@ -9,8 +9,9 @@ import javaguide.akka.HelloActorProtocol.SayHello;
 //#ask
 import akka.actor.*;
 import play.mvc.*;
-import play.libs.F.*;
+import scala.compat.java8.FutureConverters;
 import javax.inject.*;
+import java.util.concurrent.CompletionStage;
 
 import static akka.pattern.Patterns.ask;
 
@@ -23,9 +24,9 @@ public class Application extends Controller {
         helloActor = system.actorOf(HelloActor.props);
     }
 
-    public Promise<Result> sayHello(String name) {
-        return Promise.wrap(ask(helloActor, new SayHello(name), 1000))
-                .map(response -> ok((String) response));
+    public CompletionStage<Result> sayHello(String name) {
+        return FutureConverters.toJava(ask(helloActor, new SayHello(name), 1000))
+                .thenApply(response -> ok((String) response));
     }
 }
 //#ask
diff --git a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/async/Application.java b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/async/Application.java
index ae95308998..0e9cc74133 100644
--- a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/async/Application.java
+++ b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/async/Application.java
@@ -4,15 +4,15 @@
 package javaguide.akka.async;
 
 //#async
-import play.libs.F.Promise;
 import play.mvc.*;
 
-import static play.libs.F.Promise.promise;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 public class Application extends Controller {
-    public Promise<Result> index() {
-        return promise(() -> longComputation())
-                .map((Integer i) -> ok("Got " + i));
+    public CompletionStage<Result> index() {
+        return CompletableFuture.supplyAsync(this::longComputation)
+                .thenApply((Integer i) -> ok("Got " + i));
     }
     //###skip: 1
     public int longComputation() { return 2; }
diff --git a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/inject/Application.java b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/inject/Application.java
index 917994d479..4af06adc4e 100644
--- a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/inject/Application.java
+++ b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/inject/Application.java
@@ -6,11 +6,12 @@ import javaguide.akka.ConfiguredActorProtocol;
 
 //#inject
 import akka.actor.ActorRef;
-import play.libs.F;
 import play.mvc.*;
+import scala.compat.java8.FutureConverters;
 
 import javax.inject.Inject;
 import javax.inject.Named;
+import java.util.concurrent.CompletionStage;
 
 import static akka.pattern.Patterns.ask;
 
@@ -19,10 +20,10 @@ public class Application extends Controller {
     @Inject @Named("configured-actor")
     ActorRef configuredActor;
 
-    public F.Promise<Result> getConfig() {
-        return F.Promise.wrap(ask(configuredActor,
-            new ConfiguredActorProtocol.GetConfig(), 1000)
-        ).map(response -> ok((String) response));
+    public CompletionStage<Result> getConfig() {
+        return FutureConverters.toJava(ask(configuredActor,
+                        new ConfiguredActorProtocol.GetConfig(), 1000)
+        ).thenApply(response -> ok((String) response));
     }
 }
 //#inject
\ No newline at end of file
diff --git a/documentation/manual/working/javaGuide/main/async/JavaAsync.md b/documentation/manual/working/javaGuide/main/async/JavaAsync.md
index 19cb552147..00fd7ddf92 100644
--- a/documentation/manual/working/javaGuide/main/async/JavaAsync.md
+++ b/documentation/manual/working/javaGuide/main/async/JavaAsync.md
@@ -13,31 +13,31 @@ Although it's possible to increase the number of threads in the default executio
 
 Because of the way Play works, action code must be as fast as possible, i.e., non-blocking. So what should we return from our action if we are not yet able to compute the result? We should return the *promise* of a result!
 
-A `Promise<Result>` will eventually be redeemed with a value of type `Result`. By using a `Promise<Result>` instead of a normal `Result`, we are able to return from our action quickly without blocking anything. Play will then serve the result as soon as the promise is redeemed.
+Java 8 provides a generic promise API called [`CompletionStage`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html).  A `CompletionStage<Result>` will eventually be redeemed with a value of type `Result`. By using a `CompletionStage<Result>` instead of a normal `Result`, we are able to return from our action quickly without blocking anything. Play will then serve the result as soon as the promise is redeemed.
 
 The web client will be blocked while waiting for the response, but nothing will be blocked on the server, and server resources can be used to serve other clients.
 
-## How to create a `Promise<Result>`
+## How to create a `CompletionStage<Result>`
 
-To create a `Promise<Result>` we need another promise first: the promise that will give us the actual value we need to compute the result:
+To create a `CompletionStage<Result>` we need another promise first: the promise that will give us the actual value we need to compute the result:
 
 @[promise-pi](code/javaguide/async/JavaAsync.java)
 
-Play asynchronous API methods give you a `Promise`. This is the case when you are calling an external web service using the `play.libs.WS` API, or if you are using Akka to schedule asynchronous tasks or to communicate with Actors using `play.libs.Akka`.
+Play asynchronous API methods give you a `CompletionStage`. This is the case when you are calling an external web service using the `play.libs.WS` API, or if you are using Akka to schedule asynchronous tasks or to communicate with Actors using `play.libs.Akka`.
 
-A simple way to execute a block of code asynchronously and to get a `Promise` is to use the `promise()` helper:
+A simple way to execute a block of code asynchronously and to get a `CompletionStage` is to use the `CompletableFuture.supplyAsync()` helper:
 
 @[promise-async](code/javaguide/async/JavaAsync.java)
 
 > **Note:** It's important to understand which thread code runs on which promises. Here, the intensive computation will just be run on another thread.
 >
-> You can't magically turn synchronous IO into asynchronous by wrapping it in a `Promise`. If you can't change the application's architecture to avoid blocking operations, at some point that operation will have to be executed, and that thread is going to block. So in addition to enclosing the operation in a `Promise`, it's necessary to configure it to run in a separate execution context that has been configured with enough threads to deal with the expected concurrency. See [[Understanding Play thread pools|ThreadPools]] for more information.
+> You can't magically turn synchronous IO into asynchronous by wrapping it in a `CompletionStage`. If you can't change the application's architecture to avoid blocking operations, at some point that operation will have to be executed, and that thread is going to block. So in addition to enclosing the operation in a `CompletionStage`, it's necessary to configure it to run in a separate execution context that has been configured with enough threads to deal with the expected concurrency. See [[Understanding Play thread pools|ThreadPools]] for more information.
 >
 > It can also be helpful to use Actors for blocking operations. Actors provide a clean model for handling timeouts and failures, setting up blocking execution contexts, and managing any state that may be associated with the service. Also Actors provide patterns like `ScatterGatherFirstCompletedRouter` to address simultaneous cache and database requests and allow remote execution on a cluster of backend servers. But an Actor may be overkill depending on what you need.
 
 ## Async results
 
-We have been returning `Result` up until now. To send an asynchronous result our action needs to return a `Promise<Result>`:
+We have been returning `Result` up until now. To send an asynchronous result our action needs to return a `CompletionStage<Result>`:
 
 @[async](code/javaguide/async/controllers/Application.java)
 
@@ -47,4 +47,4 @@ Play [[actions|JavaActions]] are asynchronous by default. For instance, in the c
 
 @[simple-action](../http/code/javaguide/http/JavaActions.java)
 
-> **Note:** Whether the action code returns a `Result` or a `Promise<Result>`, both kinds of returned object are handled internally in the same way. There is a single kind of `Action`, which is asynchronous, and not two kinds (a synchronous one and an asynchronous one). Returning a `Promise` is a technique for writing non-blocking code.
+> **Note:** Whether the action code returns a `Result` or a `CompletionStage<Result>`, both kinds of returned object are handled internally in the same way. There is a single kind of `Action`, which is asynchronous, and not two kinds (a synchronous one and an asynchronous one). Returning a `CompletionStage` is a technique for writing non-blocking code.
diff --git a/documentation/manual/working/javaGuide/main/async/JavaWebSockets.md b/documentation/manual/working/javaGuide/main/async/JavaWebSockets.md
index 8d3e75b718..d99c9dfc7f 100644
--- a/documentation/manual/working/javaGuide/main/async/JavaWebSockets.md
+++ b/documentation/manual/working/javaGuide/main/async/JavaWebSockets.md
@@ -44,7 +44,7 @@ Sometimes you may wish to reject a WebSocket request, for example, if the user m
 
 ### Accepting a WebSocket asynchronously
 
-You may need to do some asynchronous processing before you are ready to create an actor or reject the WebSocket, if that's the case, you can simply return `Promise<WebSocket<A>>` instead of `WebSocket<A>`.
+You may need to do some asynchronous processing before you are ready to create an actor or reject the WebSocket, if that's the case, you can simply return `CompletionStage<WebSocket<A>>` instead of `WebSocket<A>`.
 
 ### Handling different types of messages
 
diff --git a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaAsync.java b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaAsync.java
index b6e961191f..24b05711c2 100644
--- a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaAsync.java
+++ b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaAsync.java
@@ -4,37 +4,39 @@
 package javaguide.async;
 
 import org.junit.Test;
-import play.libs.F.Promise;
 import play.mvc.Result;
 
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.TimeUnit;
+
 import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.*;
 import static play.mvc.Results.ok;
-import static play.test.Helpers.*;
 
 public class JavaAsync {
 
     @Test
-    public void promisePi() {
+    public void promisePi() throws Exception {
         //#promise-pi
-        Promise<Double> promiseOfPIValue = computePIAsynchronously();
-        Promise<Result> promiseOfResult = promiseOfPIValue.map(pi ->
+        CompletionStage<Double> promiseOfPIValue = computePIAsynchronously();
+        CompletionStage<Result> promiseOfResult = promiseOfPIValue.thenApply(pi ->
                         ok("PI value computed: " + pi)
         );
         //#promise-pi
-        assertThat(promiseOfResult.get(1000).status(), equalTo(200));
+        assertThat(promiseOfResult.toCompletableFuture().get(1, TimeUnit.SECONDS).status(), equalTo(200));
     }
 
     @Test
-    public void promiseAsync() {
+    public void promiseAsync() throws Exception {
         //#promise-async
-        Promise<Integer> promiseOfInt = Promise.promise(() -> intensiveComputation());
+        CompletionStage<Integer> promiseOfInt = CompletableFuture.supplyAsync(() -> intensiveComputation());
         //#promise-async
-        assertEquals(intensiveComputation(), promiseOfInt.get(1000));
+        assertEquals(intensiveComputation(), promiseOfInt.toCompletableFuture().get(1, TimeUnit.SECONDS));
     }
 
-    private static Promise<Double> computePIAsynchronously() {
-        return Promise.pure(Math.PI);
+    private static CompletionStage<Double> computePIAsynchronously() {
+        return CompletableFuture.completedFuture(Math.PI);
     }
 
     private static Integer intensiveComputation() {
diff --git a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/controllers/Application.java b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/controllers/Application.java
index 941680887f..267de11b5d 100644
--- a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/controllers/Application.java
+++ b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/controllers/Application.java
@@ -4,31 +4,33 @@
 package javaguide.async.controllers;
 
 import play.mvc.Result;
-import play.libs.F.Promise;
 import play.mvc.Controller;
 //#async-explicit-ec-imports
-import play.libs.HttpExecution;
-import scala.concurrent.ExecutionContext;
+import play.libs.concurrent.HttpExecution;
+import java.util.concurrent.Executor;
 //#async-explicit-ec-imports
 
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+
 public class Application extends Controller {
-  //#async
-  public Promise<Result> index() {
-    return Promise.promise(() -> intensiveComputation())
-            .map((Integer i) -> ok("Got result: " + i));
-  }
-  //#async
+    //#async
+    public CompletionStage<Result> index() {
+        return CompletableFuture.supplyAsync(() -> intensiveComputation())
+                .thenApply(i -> ok("Got result: " + i));
+    }
+    //#async
 
-  private ExecutionContext myThreadPool = null;
+    private Executor myThreadPool = null;
 
-  //#async-explicit-ec
-  public Promise<Result> index2() {
-    // Wrap an existing thread pool, using the context from the current thread
-    ExecutionContext myEc = HttpExecution.fromThread(myThreadPool);
-    return Promise.promise(() -> intensiveComputation(), myEc)
-            .map((Integer i) -> ok("Got result: " + i), myEc);
-  }
-  //#async-explicit-ec
+    //#async-explicit-ec
+    public CompletionStage<Result> index2() {
+        // Wrap an existing thread pool, using the context from the current thread
+        Executor myEc = HttpExecution.fromThread(myThreadPool);
+        return CompletableFuture.supplyAsync(() -> intensiveComputation(), myEc)
+                .thenApplyAsync(i -> ok("Got result: " + i), myEc);
+    }
+    //#async-explicit-ec
 
     public int intensiveComputation() { return 2;}
 }
diff --git a/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md b/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
index 78bb94991c..e78862d2f8 100644
--- a/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
+++ b/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
@@ -9,7 +9,7 @@ Previously, we said that an action is a Java method that returns a `play.mvc.Res
 
 ```java
 public abstract class Action {
-  public abstract Promise<Result> call(Context ctx) throws Throwable;
+  public abstract CompletionStage<Result> call(Context ctx) throws Throwable;
 }
 ```
 
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
index ac9a2cd8f7..9638abc011 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
@@ -4,12 +4,12 @@
 package javaguide.http;
 
 import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 import org.junit.Test;
-import play.libs.F;
 import play.mvc.Controller;
 import play.mvc.Result;
-import play.test.Helpers;
 
 import javaguide.testhelpers.MockJavaAction;
 import play.test.WithApplication;
@@ -49,8 +49,8 @@ public class JavaActions extends WithApplication {
             }
             //#params-action
 
-            public F.Promise<Result> invocation() {
-                return F.Promise.pure(index("world"));
+            public CompletionStage<Result> invocation() {
+                return CompletableFuture.completedFuture(index("world"));
             }
         }, fakeRequest(), mat);
         assertThat(result.status(), equalTo(200));
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
index 4aec26124e..cd3588a74e 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
@@ -2,7 +2,6 @@ package javaguide.http;
 
 import play.Logger;
 import play.cache.Cached;
-import play.libs.F;
 import play.libs.Json;
 import play.mvc.*;
 
@@ -11,6 +10,8 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import java.util.concurrent.CompletionStage;
+
 /**
  *
  */
@@ -18,7 +19,7 @@ public class JavaActionsComposition extends Controller {
 
     // #verbose-action
     public class VerboseAction extends play.mvc.Action.Simple {
-        public F.Promise<Result> call(Http.Context ctx) {
+        public CompletionStage<Result> call(Http.Context ctx) {
             Logger.info("Calling action for " + ctx);
             return delegate.call(ctx);
         }
@@ -58,7 +59,7 @@ public class JavaActionsComposition extends Controller {
 
     // #verbose-annotation-action
     public class VerboseAnnotationAction extends Action<VerboseAnnotation> {
-        public F.Promise<Result> call(Http.Context ctx) {
+        public CompletionStage<Result> call(Http.Context ctx) {
             if (configuration.value()) {
                 Logger.info("Calling action for " + ctx);
             }
@@ -73,7 +74,7 @@ public class JavaActionsComposition extends Controller {
 
     // #pass-arg-action
     public class PassArgAction extends play.mvc.Action.Simple {
-        public F.Promise<Result> call(Http.Context ctx) {
+        public CompletionStage<Result> call(Http.Context ctx) {
             ctx.args.put("user", User.findById(1234));
             return delegate.call(ctx);
         }
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/def/ErrorHandler.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/def/ErrorHandler.java
index d140667a41..15c1938dfd 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/def/ErrorHandler.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/def/ErrorHandler.java
@@ -9,11 +9,12 @@ import play.api.OptionalSourceMapper;
 import play.api.UsefulException;
 import play.api.routing.Router;
 import play.http.DefaultHttpErrorHandler;
-import play.libs.F.*;
 import play.mvc.Http.*;
 import play.mvc.*;
 
 import javax.inject.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 public class ErrorHandler extends DefaultHttpErrorHandler {
 
@@ -23,14 +24,14 @@ public class ErrorHandler extends DefaultHttpErrorHandler {
         super(configuration, environment, sourceMapper, routes);
     }
 
-    protected Promise<Result> onProdServerError(RequestHeader request, UsefulException exception) {
-        return Promise.<Result>pure(
+    protected CompletionStage<Result> onProdServerError(RequestHeader request, UsefulException exception) {
+        return CompletableFuture.completedFuture(
                 Results.internalServerError("A server error occurred: " + exception.getMessage())
         );
     }
 
-    protected Promise<Result> onForbidden(RequestHeader request, String message) {
-        return Promise.<Result>pure(
+    protected CompletionStage<Result> onForbidden(RequestHeader request, String message) {
+        return CompletableFuture.completedFuture(
                 Results.forbidden("You're not allowed to access this resource.")
         );
     }
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/root/ErrorHandler.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/root/ErrorHandler.java
index 73eefa94b9..06cc66fef4 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/root/ErrorHandler.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/root/ErrorHandler.java
@@ -7,18 +7,19 @@ package javaguide.http.root;
 import play.http.HttpErrorHandler;
 import play.mvc.*;
 import play.mvc.Http.*;
-import play.libs.F.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 public class ErrorHandler implements HttpErrorHandler {
-    public Promise<Result> onClientError(RequestHeader request, int statusCode, String message) {
-        return Promise.<Result>pure(
-            Results.status(statusCode, "A client error occurred: " + message)
+    public CompletionStage<Result> onClientError(RequestHeader request, int statusCode, String message) {
+        return CompletableFuture.completedFuture(
+                Results.status(statusCode, "A client error occurred: " + message)
         );
     }
 
-    public Promise<Result> onServerError(RequestHeader request, Throwable exception) {
-        return Promise.<Result>pure(
-            Results.internalServerError("A server error occurred: " + exception.getMessage())
+    public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) {
+        return CompletableFuture.completedFuture(
+                Results.internalServerError("A server error occurred: " + exception.getMessage())
         );
     }
 }
diff --git a/documentation/manual/working/javaGuide/main/logging/code/javaguide/logging/Application.java b/documentation/manual/working/javaGuide/main/logging/code/javaguide/logging/Application.java
index b5cd2fda9a..f97e08f548 100644
--- a/documentation/manual/working/javaGuide/main/logging/code/javaguide/logging/Application.java
+++ b/documentation/manual/working/javaGuide/main/logging/code/javaguide/logging/Application.java
@@ -3,13 +3,13 @@ package javaguide.logging;
 //#logging-pattern-mix
 import play.Logger;
 import play.Logger.ALogger;
-import play.libs.F;
 import play.mvc.Action;
 import play.mvc.Controller;
 import play.mvc.Http;
 import play.mvc.Http.Request;
 import play.mvc.Result;
 import play.mvc.With;
+import java.util.concurrent.CompletionStage;
 
 public class Application extends Controller {
   
@@ -36,7 +36,7 @@ class AccessLoggingAction extends Action.Simple {
   
   private ALogger accessLogger = Logger.of("access");
   
-  public F.Promise<Result> call(Http.Context ctx) {
+  public CompletionStage<Result> call(Http.Context ctx) {
     final Request request = ctx.request();
     accessLogger.info("method=" + request.method() + " uri=" + request.uri() + " remote-address=" + request.remoteAddress());
     
diff --git a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClient.java b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClient.java
index 654a4fcda0..37e1fcbb63 100644
--- a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClient.java
+++ b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClient.java
@@ -2,19 +2,19 @@ package javaguide.tests;
 
 //#client
 import java.util.*;
+import java.util.concurrent.CompletionStage;
 import java.util.stream.Collectors;
 import javax.inject.Inject;
 
 import com.fasterxml.jackson.databind.JsonNode;
 import play.libs.ws.WSClient;
-import play.libs.F;
 
 class GitHubClient {
     @Inject WSClient ws;
     String baseUrl = "https://api.github.com";
 
-    public F.Promise<List<String>> getRepositories() {
-        return ws.url(baseUrl + "/repositories").get().map(response ->
+    public CompletionStage<List<String>> getRepositories() {
+        return ws.url(baseUrl + "/repositories").get().thenApply(response ->
             response.asJson().findValues("full_name").stream()
                 .map(JsonNode::asText).collect(Collectors.toList())
         );
diff --git a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClientTest.java b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClientTest.java
index 311b0e6452..847ecf9688 100644
--- a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClientTest.java
+++ b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/GitHubClientTest.java
@@ -3,6 +3,7 @@ package javaguide.tests;
 //#content
 import java.io.IOException;
 import java.util.*;
+import java.util.concurrent.TimeUnit;
 import com.fasterxml.jackson.databind.node.*;
 import org.junit.*;
 import play.api.routing.Router;
@@ -50,8 +51,9 @@ public class GitHubClientTest {
     }
 
     @Test
-    public void repositories() {
-        List<String> repos = client.getRepositories().get(10000);
+    public void repositories() throws Exception {
+        List<String> repos = client.getRepositories()
+                .toCompletableFuture().get(10, TimeUnit.SECONDS);
         assertThat(repos, hasItem("octocat/Hello-World"));
     }
 }
diff --git a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/JavaTestingWebServiceClients.java b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/JavaTestingWebServiceClients.java
index c9e5b8d49f..f467926cba 100644
--- a/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/JavaTestingWebServiceClients.java
+++ b/documentation/manual/working/javaGuide/main/tests/code/javaguide/tests/JavaTestingWebServiceClients.java
@@ -1,7 +1,5 @@
 package javaguide.tests;
 
-import java.io.IOException;
-
 import com.fasterxml.jackson.databind.node.*;
 import org.junit.Test;
 import play.api.routing.Router;
@@ -12,6 +10,7 @@ import play.routing.RoutingDsl;
 import play.server.Server;
 
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 import static org.hamcrest.core.IsCollectionContaining.*;
 import static org.junit.Assert.*;
@@ -39,7 +38,7 @@ public class JavaTestingWebServiceClients {
     }
 
     @Test
-    public void sendResource() throws IOException {
+    public void sendResource() throws Exception {
         //#send-resource
         Router router = new RoutingDsl()
             .GET("/repositories").routeTo(() ->
@@ -56,7 +55,7 @@ public class JavaTestingWebServiceClients {
         client.ws = ws;
 
         try {
-            List<String> repos = client.getRepositories().get(10000);
+            List<String> repos = client.getRepositories().toCompletableFuture().get(10, TimeUnit.SECONDS);
             assertThat(repos, hasItem("octocat/Hello-World"));
         } finally {
             try {
diff --git a/documentation/manual/working/javaGuide/main/ws/JavaOpenID.md b/documentation/manual/working/javaGuide/main/ws/JavaOpenID.md
index 4e57cb749b..c59c8fa110 100644
--- a/documentation/manual/working/javaGuide/main/ws/JavaOpenID.md
+++ b/documentation/manual/working/javaGuide/main/ws/JavaOpenID.md
@@ -28,10 +28,9 @@ Now any controller or component that wants to use OpenID will have to declare a
 
 The OpenID API has two important functions:
 
-* `OpenIdClient.redirectURL` calculates the URL where you should redirect the user. It involves fetching the user's OpenID page asynchronously, this is why it returns a `Promise<String>`. If the OpenID is invalid, the returned `Promise` will be a `Thrown`.
-* `OpenIdClient.verifiedId` inspects the current request to establish the user information, including his verified OpenID. It will do a call to the OpenID server asynchronously to check the authenticity of the information, returning a promise of [UserInfo](api/java/play/libs/openid/UserInfo.html). If the information is not correct or if the server check is false (for example if the redirect URL has been forged), the returned `Promise` will be a `Thrown`.
-
-If the `Promise` fails, you can define a fallback, which redirects back the user to the login page or return a `BadRequest`.
+* `OpenIdClient.redirectURL` calculates the URL where you should redirect the user. It involves fetching the user's OpenID page asynchronously, this is why it returns a `CompletionStage<String>`. If the OpenID is invalid, the returned `CompletionStage` will be completed with an exception.
+* `OpenIdClient.verifiedId` inspects the current request to establish the user information, including his verified OpenID. It will do a call to the OpenID server asynchronously to check the authenticity of the information, returning a promise of [UserInfo](api/java/play/libs/openid/UserInfo.html). If the information is not correct or if the server check is false (for example if the redirect URL has been forged), the returned `CompletionStage` will be completed with an exception.
+If the `CompletionStage` fails, you can define a fallback, which redirects back the user to the login page or return a `BadRequest`.
 
 ### Example
 
diff --git a/documentation/manual/working/javaGuide/main/ws/JavaWS.md b/documentation/manual/working/javaGuide/main/ws/JavaWS.md
index a613d9f2d1..e330b318f6 100644
--- a/documentation/manual/working/javaGuide/main/ws/JavaWS.md
+++ b/documentation/manual/working/javaGuide/main/ws/JavaWS.md
@@ -31,7 +31,7 @@ You end by calling a method corresponding to the HTTP method you want to use.  T
 
 @[ws-get](code/javaguide/ws/JavaWS.java)
 
-This returns a [`Promise<WSResponse>`](api/java/play/libs/F.Promise.html) where the [`WSResponse`](api/java/play/libs/ws/WSResponse.html) contains the data returned from the server.
+This returns a [`CompletionStage<WSResponse>`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) where the [`WSResponse`](api/java/play/libs/ws/WSResponse.html) contains the data returned from the server.
 
 ### Request with authentication
 
@@ -91,7 +91,7 @@ The `largeImage` in the code snippet above is an Akka Streams `Source<ByteString
 
 ## Processing the Response
 
-Working with the [`WSResponse`](api/java/play/libs/ws/WSResponse.html) is done by mapping inside the `Promise`.
+Working with the [`WSResponse`](api/java/play/libs/ws/WSResponse.html) is done by applying transformations such as `thenApply` and `thenCompose` to the `CompletionStage`.
 
 ### Processing a response as JSON
 
@@ -148,7 +148,7 @@ If you want to recover from an exception in the call, you can use `recover` or `
 
 ### Using in a controller
 
-You can map a `Promise<WSResponse>` to a `Promise<Result>` that can be handled directly by the Play server, using the asynchronous action pattern defined in [[Handling Asynchronous Results|JavaAsync]].
+You can map a `CompletionStage<WSResponse>` to a `CompletionStage<Result>` that can be handled directly by the Play server, using the asynchronous action pattern defined in [[Handling Asynchronous Results|JavaAsync]].
 
 @[ws-action](code/javaguide/ws/JavaWS.java)
 
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/Application.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/Application.java
index 7b5e39578f..31ddc763f6 100644
--- a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/Application.java
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/Application.java
@@ -8,7 +8,7 @@ import javax.inject.Inject;
 
 import play.mvc.*;
 import play.libs.ws.*;
-import play.libs.F.Promise;
+import java.util.concurrent.CompletionStage;
 
 public class Application extends Controller {
 
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
index ab124bf00e..2b15f84e88 100644
--- a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/JavaWS.java
@@ -7,7 +7,8 @@ import javaguide.testhelpers.MockJavaAction;
 
 // #ws-imports
 import play.libs.ws.*;
-import play.libs.F.Promise;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 // #ws-imports
 
 // #json-imports
@@ -18,12 +19,10 @@ import play.libs.Json;
 import scala.compat.java8.FutureConverters;
 
 import java.io.*;
-import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
-import java.util.Iterator;
-import java.util.List;
 import java.util.Optional;
+import java.util.function.Function;
 import java.util.stream.*;
 
 import org.w3c.dom.Document;
@@ -68,7 +67,7 @@ public class JavaWS {
             // #ws-complex-holder
 
             // #ws-get
-            Promise<WSResponse> responsePromise = complexRequest.get();
+            CompletionStage<WSResponse> responsePromise = complexRequest.get();
             // #ws-get
 
             String url = "http://example.com";
@@ -118,7 +117,7 @@ public class JavaWS {
             Stream<ByteString> largeSource = IntStream.range(0,10).boxed().map(i -> seedValue);
             Source<ByteString, ?> largeImage = Source.from(largeSource.collect(Collectors.toList()));
             // #ws-stream-request
-            Promise<WSResponse> wsResponse = ws.url(url).setBody(largeImage).execute("PUT");
+            CompletionStage<WSResponse> wsResponse = ws.url(url).setBody(largeImage).execute("PUT");
             // #ws-stream-request
         }
 
@@ -127,15 +126,13 @@ public class JavaWS {
             String url = "http://example.com";
 
             // #ws-response-json
-            Promise<JsonNode> jsonPromise = ws.url(url).get().map(response -> {
-                return response.asJson();
-            });
+            CompletionStage<JsonNode> jsonPromise = ws.url(url).get()
+                    .thenApply(WSResponse::asJson);
             // #ws-response-json
 
             // #ws-response-xml
-            Promise<Document> documentPromise = ws.url(url).get().map(response -> {
-                return response.asXml();
-            });
+            CompletionStage<Document> documentPromise = ws.url(url).get()
+                    .thenApply(WSResponse::asXml);
             // #ws-response-xml
         }
 
@@ -211,34 +208,27 @@ public class JavaWS {
                 if (responseHeaders.getStatus() == 200) {
                     // Get the content type
                     String contentType =
-                        Optional.ofNullable(responseHeaders.getHeaders().get("Content-Type"))
-                        .map(contentTypes -> contentTypes.get(0)).
-                        orElse("application/octet-stream");
+                            Optional.ofNullable(responseHeaders.getHeaders().get("Content-Type"))
+                                    .map(contentTypes -> contentTypes.get(0)).
+                                    orElse("application/octet-stream");
 
                     // If there's a content length, send that, otherwise return the body chunked
                     Optional<String> contentLength = Optional.ofNullable(responseHeaders.getHeaders()
-                        .get("Content-Length"))
-                        .map(contentLengths -> contentLengths.get(0));
-                    if(contentLength.isPresent()) {
+                            .get("Content-Length"))
+                            .map(contentLengths -> contentLengths.get(0));
+                    if (contentLength.isPresent()) {
                         return ok().sendEntity(new HttpEntity.Streamed(
-                            body, 
-                            Optional.of(Long.parseLong(contentLength.get())), 
-                            Optional.of(contentType)
+                                body,
+                                Optional.of(Long.parseLong(contentLength.get())),
+                                Optional.of(contentType)
                         ));
-                    }
-                    else {
+                    } else {
                         return ok().chunked(body).as(contentType);
                     }
-                }
-                else {
+                } else {
                     return new Result(Status.BAD_GATEWAY);
                 }
             });
-            // Your controller's action method should return a `Promise<Result>`, and here we 
-            // shows how the conversion from  `CompletionStage` to `Promise` can be done. This 
-            // won't be needed once https://github.com/playframework/playframework/issues/4691 
-            // is fixed.
-            Promise<Result> actionResult = Promise.wrap(FutureConverters.toScala(result));
             //#stream-to-result
         }
 
@@ -252,16 +242,20 @@ public class JavaWS {
         public void patternExamples() {
             String urlOne = "http://localhost:3333/one";
             // #ws-composition
-            final Promise<WSResponse> responseThreePromise = ws.url(urlOne).get()
-                    .flatMap(responseOne -> ws.url(responseOne.getBody()).get())
-                    .flatMap(responseTwo -> ws.url(responseTwo.getBody()).get());
+            final CompletionStage<WSResponse> responseThreePromise = ws.url(urlOne).get()
+                    .thenCompose(responseOne -> ws.url(responseOne.getBody()).get())
+                    .thenCompose(responseTwo -> ws.url(responseTwo.getBody()).get());
             // #ws-composition
 
             // #ws-recover
-            Promise<WSResponse> responsePromise = ws.url("http://example.com").get();
-            Promise<WSResponse> recoverPromise = responsePromise.recoverWith(throwable ->
-                            ws.url("http://backup.example.com").get()
-            );
+            CompletionStage<WSResponse> responsePromise = ws.url("http://example.com").get();
+            CompletionStage<WSResponse> recoverPromise = responsePromise.handle((result, error) -> {
+                if (error != null) {
+                    return ws.url("http://backup.example.com").get();
+                } else {
+                    return CompletableFuture.completedFuture(result);
+                }
+            }).thenCompose(Function.identity());
             // #ws-recover
         }
 
@@ -297,7 +291,7 @@ public class JavaWS {
 
             WSClient customClient = new play.libs.ws.ning.NingWSClient(customConfig, materializer);
 
-            Promise<WSResponse> responsePromise = customClient.url("http://example.com/feed").get();
+            CompletionStage<WSResponse> responsePromise = customClient.url("http://example.com/feed").get();
             // #ws-custom-client
 
             // #ws-underlying-client
@@ -314,9 +308,9 @@ public class JavaWS {
         private WSClient ws;
 
         // #ws-action
-        public Promise<Result> index() {
-            return ws.url(feedUrl).get().map(response ->
-                            ok("Feed title: " + response.asJson().findPath("title").asText())
+        public CompletionStage<Result> index() {
+            return ws.url(feedUrl).get().thenApply(response ->
+                ok("Feed title: " + response.asJson().findPath("title").asText())
             );
         }
         // #ws-action
@@ -328,10 +322,10 @@ public class JavaWS {
         private WSClient ws;
 
         // #composed-call
-        public Promise<Result> index() {
+        public CompletionStage<Result> index() {
             return ws.url(feedUrl).get()
-                    .flatMap(response -> ws.url(response.asJson().findPath("commentsUrl").asText()).get())
-                    .map(response -> ok("Number of comments: " + response.asJson().findPath("count").asInt()));
+                    .thenCompose(response -> ws.url(response.asJson().findPath("commentsUrl").asText()).get())
+                    .thenApply(response -> ok("Number of comments: " + response.asJson().findPath("count").asInt()));
         }
         // #composed-call
     }
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/OpenIDController.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/OpenIDController.java
index 9574d799de..74757c4e10 100644
--- a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/OpenIDController.java
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/OpenIDController.java
@@ -4,9 +4,9 @@ import play.twirl.api.Html;
 
 //#ws-openid-controller
 import java.util.*;
+import java.util.concurrent.CompletionStage;
 
 import play.data.*;
-import play.libs.F.Promise;
 import play.libs.openid.*;
 import play.mvc.*;
 
@@ -14,74 +14,73 @@ import javax.inject.Inject;
 
 public class OpenIDController extends Controller {
 
-  @Inject OpenIdClient openIdClient;
+    @Inject
+    OpenIdClient openIdClient;
 
-  public Result login() {
-    return ok(views.html.login.render(""));
-  }
+    public Result login() {
+        return ok(views.html.login.render(""));
+    }
 
-  public Promise<Result> loginPost() {
+    public CompletionStage<Result> loginPost() {
 
-    // Form data
-    final DynamicForm requestData = Form.form().bindFromRequest();
-    final String openID = requestData.get("openID");
+        // Form data
+        DynamicForm requestData = Form.form().bindFromRequest();
+        String openID = requestData.get("openID");
 
-    final Promise<String> redirectUrlPromise =
-            openIdClient.redirectURL(openID, routes.OpenIDController.openIDCallback().absoluteURL(request()));
+        CompletionStage<String> redirectUrlPromise =
+                openIdClient.redirectURL(openID, routes.OpenIDController.openIDCallback().absoluteURL(request()));
 
-    final Promise<Result> resultPromise = redirectUrlPromise
-            .map(Controller::redirect)
-            .recover(throwable ->
-                    badRequest(views.html.login.render(throwable.getMessage()))
-            );
+        return redirectUrlPromise
+                .thenApply(Controller::redirect)
+                .exceptionally(throwable ->
+                                badRequest(views.html.login.render(throwable.getMessage()))
+                );
+    }
 
-    return resultPromise;
-  }
+    public CompletionStage<Result> openIDCallback() {
 
-  public Promise<Result> openIDCallback() {
+        CompletionStage<UserInfo> userInfoPromise = openIdClient.verifiedId();
 
-    final Promise<UserInfo> userInfoPromise = openIdClient.verifiedId();
+        CompletionStage<Result> resultPromise = userInfoPromise.thenApply(userInfo ->
+                        ok(userInfo.id() + "\n" + userInfo.attributes())
+        ).exceptionally(throwable ->
+                        badRequest(views.html.login.render(throwable.getMessage()))
+        );
 
-    final Promise<Result> resultPromise = userInfoPromise.map(userInfo ->
-            (Result) ok(userInfo.id() + "\n" + userInfo.attributes())
-    ).recover(throwable ->
-            badRequest(views.html.login.render(throwable.getMessage()))
-    );
+        return resultPromise;
+    }
 
-    return resultPromise;
-  }
-
-  public static class views {
-      public static class html {
-          public static class login {
-              public static Html render(String msg) {
-                  return javaguide.ws.html.login.render(msg);
-              }
-          }
-      }
-  }
+    public static class views {
+        public static class html {
+            public static class login {
+                public static Html render(String msg) {
+                    return javaguide.ws.html.login.render(msg);
+                }
+            }
+        }
+    }
 
 }
 //#ws-openid-controller
 
 class OpenIDSamples extends Controller {
 
-  static OpenIdClient openIdClient;
-
-  public static void extendedAttributes() {
-    
-    final String openID = "";
-    
-    //#ws-openid-extended-attributes
-    final Map<String, String> attributes = new HashMap<String, String>();
-    attributes.put("email", "http://schema.openid.net/contact/email");
-    
-    final Promise<String> redirectUrlPromise = openIdClient.redirectURL(
-      openID, 
-      routes.OpenIDController.openIDCallback().absoluteURL(request()), 
-      attributes
-    );
-    //#ws-openid-extended-attributes
-  }
-  
+    static OpenIdClient openIdClient;
+
+    public static void extendedAttributes() {
+
+        String openID = "";
+
+        //#ws-openid-extended-attributes
+        Map<String, String> attributes = new HashMap<>();
+        attributes.put("email", "http://schema.openid.net/contact/email");
+
+        CompletionStage<String> redirectUrlPromise = openIdClient.redirectURL(
+                openID,
+                routes.OpenIDController.openIDCallback().absoluteURL(request()),
+                attributes
+        );
+        //#ws-openid-extended-attributes
+    }
+
 }
\ No newline at end of file
diff --git a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/Twitter.java b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/Twitter.java
index f593237664..8ba6a7fe8a 100644
--- a/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/Twitter.java
+++ b/documentation/manual/working/javaGuide/main/ws/code/javaguide/ws/controllers/Twitter.java
@@ -1,14 +1,12 @@
 package javaguide.ws.controllers;
 
 //#ws-oauth-controller
-import play.libs.F.Promise;
 import play.libs.oauth.OAuth;
 import play.libs.oauth.OAuth.ConsumerKey;
 import play.libs.oauth.OAuth.OAuthCalculator;
 import play.libs.oauth.OAuth.RequestToken;
 import play.libs.oauth.OAuth.ServiceInfo;
 import play.libs.ws.WSClient;
-import play.libs.ws.WSResponse;
 import play.mvc.Controller;
 import play.mvc.Result;
 
@@ -16,61 +14,64 @@ import com.google.common.base.Strings;
 
 import javax.inject.Inject;
 import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 public class Twitter extends Controller {
-  static final ConsumerKey KEY = new ConsumerKey("...", "...");
+    static final ConsumerKey KEY = new ConsumerKey("...", "...");
 
-  private static final ServiceInfo SERVICE_INFO = new ServiceInfo("https://api.twitter.com/oauth/request_token",
-                                                                  "https://api.twitter.com/oauth/access_token",
-                                                                  "https://api.twitter.com/oauth/authorize", 
-                                                                  KEY);
-  
-  private static final OAuth TWITTER = new OAuth(SERVICE_INFO);
+    private static final ServiceInfo SERVICE_INFO =
+        new ServiceInfo("https://api.twitter.com/oauth/request_token",
+            "https://api.twitter.com/oauth/access_token",
+            "https://api.twitter.com/oauth/authorize",
+            KEY);
 
-  private final WSClient ws;
+    private static final OAuth TWITTER = new OAuth(SERVICE_INFO);
 
-  @Inject
-  public Twitter(WSClient ws) {
-    this.ws = ws;
-  }
+    private final WSClient ws;
 
-  public Promise<Result> homeTimeline() {
-    Optional<RequestToken> sessionTokenPair = getSessionTokenPair();
-    if (sessionTokenPair.isPresent()) {
-      return ws.url("https://api.twitter.com/1.1/statuses/home_timeline.json")
-          .sign(new OAuthCalculator(Twitter.KEY, sessionTokenPair.get()))
-          .get()
-          .map(result -> ok(result.asJson()));
+    @Inject
+    public Twitter(WSClient ws) {
+        this.ws = ws;
     }
-    return Promise.pure(redirect(routes.Twitter.auth()));
-  }
-  
-  public Result auth() {
-    String verifier = request().getQueryString("oauth_verifier");
-    if (Strings.isNullOrEmpty(verifier)) {
-      String url = routes.Twitter.auth().absoluteURL(request());
-      RequestToken requestToken = TWITTER.retrieveRequestToken(url);
-      saveSessionTokenPair(requestToken);
-      return redirect(TWITTER.redirectUrl(requestToken.token));
-    } else {
-      RequestToken requestToken = getSessionTokenPair().get();
-      RequestToken accessToken = TWITTER.retrieveAccessToken(requestToken, verifier);
-      saveSessionTokenPair(accessToken);
-      return redirect(routes.Twitter.homeTimeline());
+
+    public CompletionStage<Result> homeTimeline() {
+        Optional<RequestToken> sessionTokenPair = getSessionTokenPair();
+        if (sessionTokenPair.isPresent()) {
+            return ws.url("https://api.twitter.com/1.1/statuses/home_timeline.json")
+                    .sign(new OAuthCalculator(Twitter.KEY, sessionTokenPair.get()))
+                    .get()
+                    .thenApply(result -> ok(result.asJson()));
+        }
+        return CompletableFuture.completedFuture(redirect(routes.Twitter.auth()));
     }
-  }
 
-  private void saveSessionTokenPair(RequestToken requestToken) {
-    session("token", requestToken.token);
-    session("secret", requestToken.secret);
-  }
+    public Result auth() {
+        String verifier = request().getQueryString("oauth_verifier");
+        if (Strings.isNullOrEmpty(verifier)) {
+            String url = routes.Twitter.auth().absoluteURL(request());
+            RequestToken requestToken = TWITTER.retrieveRequestToken(url);
+            saveSessionTokenPair(requestToken);
+            return redirect(TWITTER.redirectUrl(requestToken.token));
+        } else {
+            RequestToken requestToken = getSessionTokenPair().get();
+            RequestToken accessToken = TWITTER.retrieveAccessToken(requestToken, verifier);
+            saveSessionTokenPair(accessToken);
+            return redirect(routes.Twitter.homeTimeline());
+        }
+    }
 
-  private Optional<RequestToken> getSessionTokenPair() {
-    if (session().containsKey("token")) {
-      return Optional.ofNullable(new RequestToken(session("token"), session("secret")));
+    private void saveSessionTokenPair(RequestToken requestToken) {
+        session("token", requestToken.token);
+        session("secret", requestToken.secret);
     }
-    return Optional.empty();
-  }
-  
+
+    private Optional<RequestToken> getSessionTokenPair() {
+        if (session().containsKey("token")) {
+            return Optional.ofNullable(new RequestToken(session("token"), session("secret")));
+        }
+        return Optional.empty();
+    }
+
 }
 //#ws-oauth-controller
\ No newline at end of file
diff --git a/framework/src/iteratees/src/test/scala/play/api/libs/iteratee/TestExecutionContext.scala b/framework/src/iteratees/src/test/scala/play/api/libs/iteratee/TestExecutionContext.scala
index b5787618df..e9b1f46877 100644
--- a/framework/src/iteratees/src/test/scala/play/api/libs/iteratee/TestExecutionContext.scala
+++ b/framework/src/iteratees/src/test/scala/play/api/libs/iteratee/TestExecutionContext.scala
@@ -10,7 +10,7 @@ object TestExecutionContext {
   /**
    * Create a `TestExecutionContext` that delegates to the iteratee package's default `ExecutionContext`.
    */
-  def apply(): TestExecutionContext = new TestExecutionContext(Execution.defaultExecutionContext)
+  def apply(): TestExecutionContext = new TestExecutionContext(Execution.trampoline)
 
 }
 
diff --git a/framework/src/play-cache/src/main/java/play/cache/CachedAction.java b/framework/src/play-cache/src/main/java/play/cache/CachedAction.java
index 5428b06cea..1926e7b67d 100644
--- a/framework/src/play-cache/src/main/java/play/cache/CachedAction.java
+++ b/framework/src/play-cache/src/main/java/play/cache/CachedAction.java
@@ -7,12 +7,14 @@ import play.libs.F;
 import play.mvc.*;
 import play.mvc.Http.*;
 
+import java.util.concurrent.CompletionStage;
+
 /**
  * Cache another action.
  */
 public class CachedAction extends Action<Cached> {
 
-    public F.Promise<Result> call(Context ctx) {
+    public CompletionStage<Result> call(Context ctx) {
         try {
             final String key = configuration.key();
             final Integer duration = configuration.duration();
@@ -20,7 +22,7 @@ public class CachedAction extends Action<Cached> {
             Result cacheResult = (Result) Cache.get(key);
 
             if (cacheResult == null) {
-                return delegate.call(ctx).map(result -> {
+                return delegate.call(ctx).thenApply(result -> {
                     Cache.set(key, result, duration);
                     return result;
                 });
diff --git a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/AddCSRFTokenAction.java b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/AddCSRFTokenAction.java
index f9caeb44e0..1359cc5f26 100644
--- a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/AddCSRFTokenAction.java
+++ b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/AddCSRFTokenAction.java
@@ -4,9 +4,10 @@
 package play.filters.csrf;
 
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletionStage;
+
 import play.api.mvc.RequestHeader;
 import play.api.mvc.Session;
-import play.libs.F;
 import play.libs.Scala;
 import play.mvc.Action;
 import play.mvc.Http;
@@ -31,7 +32,7 @@ public class AddCSRFTokenAction extends Action<AddCSRFToken> {
     private final CSRFAction$ CSRFAction = CSRFAction$.MODULE$;
 
     @Override
-    public F.Promise<Result> call(Http.Context ctx) {
+    public CompletionStage<Result> call(Http.Context ctx) {
         RequestHeader request = ctx._requestHeader();
 
         if (CSRFAction.getTokenFromHeader(request, config).isEmpty()) {
diff --git a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/CSRFErrorHandler.java b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/CSRFErrorHandler.java
index 4fd79a7b4c..1836268c4a 100644
--- a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/CSRFErrorHandler.java
+++ b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/CSRFErrorHandler.java
@@ -3,12 +3,13 @@
  */
 package play.filters.csrf;
 
-import play.libs.F;
 import play.mvc.Http;
 import play.mvc.Results;
 import play.mvc.Result;
+import scala.compat.java8.FutureConverters;
 
 import javax.inject.Inject;
+import java.util.concurrent.CompletionStage;
 
 /**
  * This interface handles the CSRF error.
@@ -22,7 +23,7 @@ public interface CSRFErrorHandler {
      * @param msg message is passed by framework.
      * @return Client gets this result.
      */
-    F.Promise<Result> handle(Http.RequestHeader req, String msg);
+    CompletionStage<Result> handle(Http.RequestHeader req, String msg);
 
     class DefaultCSRFErrorHandler extends Results implements CSRFErrorHandler {
 
@@ -34,8 +35,9 @@ public interface CSRFErrorHandler {
         }
 
         @Override
-        public F.Promise<Result> handle(Http.RequestHeader req, String msg) {
-            return F.Promise.wrap(errorHandler.handle(req._underlyingHeader(), msg)).map(play.api.mvc.Result::asJava);
+        public CompletionStage<Result> handle(Http.RequestHeader req, String msg) {
+            return FutureConverters.toJava(errorHandler.handle(req._underlyingHeader(), msg))
+                    .thenApply(play.api.mvc.Result::asJava);
         }
 
     }
diff --git a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
index f744a048ec..4a97d232bb 100644
--- a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
+++ b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
@@ -6,7 +6,6 @@ package play.filters.csrf;
 import play.api.mvc.RequestHeader;
 import play.api.mvc.Session;
 import play.inject.Injector;
-import play.libs.F;
 import play.mvc.Action;
 import play.mvc.Http;
 import play.mvc.Result;
@@ -14,6 +13,7 @@ import scala.Option;
 
 import javax.inject.Inject;
 import java.util.Map;
+import java.util.concurrent.CompletionStage;
 
 public class RequireCSRFCheckAction extends Action<RequireCSRFCheck> {
 
@@ -31,7 +31,7 @@ public class RequireCSRFCheckAction extends Action<RequireCSRFCheck> {
     private final CSRFAction$ CSRFAction = CSRFAction$.MODULE$;
 
     @Override
-    public F.Promise<Result> call(Http.Context ctx) {
+    public CompletionStage<Result> call(Http.Context ctx) {
         RequestHeader request = ctx._requestHeader();
         // Check for bypass
         if (CSRFAction.checkCsrfBypass(request, config)) {
@@ -78,7 +78,7 @@ public class RequireCSRFCheckAction extends Action<RequireCSRFCheck> {
         }
     }
 
-    private F.Promise<Result> handleTokenError(Http.Context ctx, RequestHeader request, String msg) {
+    private CompletionStage<Result> handleTokenError(Http.Context ctx, RequestHeader request, String msg) {
 
         if (CSRF.getToken(request).isEmpty()) {
             if (config.cookieName().isDefined()) {
diff --git a/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala b/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
index d6472d70d2..146f62ceed 100644
--- a/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
+++ b/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
@@ -11,6 +11,7 @@ import play.filters.csrf.CSRF.{ CSRFHttpErrorHandler, ErrorHandler }
 import play.mvc.Http
 import play.utils.Reflect
 
+import scala.compat.java8.FutureConverters
 import scala.concurrent.Future
 
 import play.api._
@@ -213,7 +214,7 @@ object CSRF {
     import play.api.libs.iteratee.Execution.Implicits.trampoline
 
     def handle(req: Http.RequestHeader, msg: String) =
-      play.libs.F.Promise.wrap(delegate.handle(req._underlyingHeader(), msg).map(_.asJava))
+      FutureConverters.toJava(delegate.handle(req._underlyingHeader(), msg).map(_.asJava))
   }
 
   object ErrorHandler {
diff --git a/framework/src/play-integration-test/src/test/java/play/it/http/ActionCompositionOrderTest.java b/framework/src/play-integration-test/src/test/java/play/it/http/ActionCompositionOrderTest.java
index 6fac18db28..fd7dac5c91 100644
--- a/framework/src/play-integration-test/src/test/java/play/it/http/ActionCompositionOrderTest.java
+++ b/framework/src/play-integration-test/src/test/java/play/it/http/ActionCompositionOrderTest.java
@@ -11,6 +11,7 @@ import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.util.concurrent.CompletionStage;
 
 public class ActionCompositionOrderTest {
 
@@ -21,8 +22,8 @@ public class ActionCompositionOrderTest {
 
     static class ControllerComposition extends Action<ControllerAnnotation> {
         @Override
-        public F.Promise<Result> call(Http.Context ctx) {
-            return delegate.call(ctx).map(result -> {
+        public CompletionStage<Result> call(Http.Context ctx) {
+            return delegate.call(ctx).thenApply(result -> {
                 String newContent = "controller" + Helpers.contentAsString(result);
                 return Results.ok(newContent);
             });
@@ -36,8 +37,8 @@ public class ActionCompositionOrderTest {
 
     static class ActionComposition extends Action<ControllerAnnotation> {
         @Override
-        public F.Promise<Result> call(Http.Context ctx) {
-            return delegate.call(ctx).map(result -> {
+        public CompletionStage<Result> call(Http.Context ctx) {
+            return delegate.call(ctx).thenApply(result -> {
                 String newContent = "action" + Helpers.contentAsString(result);
                 return Results.ok(newContent);
             });
@@ -53,7 +54,7 @@ public class ActionCompositionOrderTest {
 
     static class WithUsernameAction extends Action<WithUsername> {
         @Override
-        public F.Promise<Result> call(Http.Context ctx) {
+        public CompletionStage<Result> call(Http.Context ctx) {
             return delegate.call(ctx.withRequest(ctx.request().withUsername(configuration.value())));
         }
     }
diff --git a/framework/src/play-java-jpa/src/main/java/play/db/jpa/TransactionalAction.java b/framework/src/play-java-jpa/src/main/java/play/db/jpa/TransactionalAction.java
index 57a5a53b75..a2a96861db 100644
--- a/framework/src/play-java-jpa/src/main/java/play/db/jpa/TransactionalAction.java
+++ b/framework/src/play-java-jpa/src/main/java/play/db/jpa/TransactionalAction.java
@@ -3,16 +3,17 @@
  */
 package play.db.jpa;
 
-import play.libs.F;
 import play.mvc.*;
 import play.mvc.Http.*;
 
+import java.util.concurrent.CompletionStage;
+
 /**
  * Wraps an action in am JPA transaction.
  */
 public class TransactionalAction extends Action<Transactional> {
 
-    public F.Promise<Result> call(final Context ctx) {
+    public CompletionStage<Result> call(final Context ctx) {
         return JPA.withTransaction(
             configuration.value(),
             configuration.readOnly(),
diff --git a/framework/src/play-java/src/main/java/play/inject/DelegateApplicationLifecycle.java b/framework/src/play-java/src/main/java/play/inject/DelegateApplicationLifecycle.java
index 3024515865..14d920eb18 100644
--- a/framework/src/play-java/src/main/java/play/inject/DelegateApplicationLifecycle.java
+++ b/framework/src/play-java/src/main/java/play/inject/DelegateApplicationLifecycle.java
@@ -3,12 +3,10 @@
  */
 package play.inject;
 
-
-import play.libs.F;
-
 import javax.inject.Inject;
 import javax.inject.Singleton;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletionStage;
 
 @Singleton
 public class DelegateApplicationLifecycle implements ApplicationLifecycle {
@@ -20,7 +18,7 @@ public class DelegateApplicationLifecycle implements ApplicationLifecycle {
     }
 
     @Override
-    public void addStopHook(final Callable<F.Promise<?>> hook) {
+    public void addStopHook(final Callable<? extends CompletionStage<?>> hook) {
         delegate.addStopHook(hook);
     }
 }
diff --git a/framework/src/play-java/src/main/java/play/routing/RoutingDsl.java b/framework/src/play-java/src/main/java/play/routing/RoutingDsl.java
index 10d7e17391..61f6b7da5a 100644
--- a/framework/src/play-java/src/main/java/play/routing/RoutingDsl.java
+++ b/framework/src/play-java/src/main/java/play/routing/RoutingDsl.java
@@ -15,6 +15,7 @@ import scala.reflect.ClassTag$;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.*;
+import java.util.concurrent.CompletionStage;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.BiFunction;
@@ -336,7 +337,7 @@ public class RoutingDsl {
          * @param action The action to execute.
          * @return This router builder.
          */
-        public RoutingDsl routeAsync(Supplier<F.Promise<Result>> action) {
+        public RoutingDsl routeAsync(Supplier<? extends CompletionStage<Result>> action) {
             return build(0, action, Supplier.class);
         }
 
@@ -346,7 +347,7 @@ public class RoutingDsl {
          * @param action The action to execute.
          * @return This router builder.
          */
-        public <A1> RoutingDsl routeAsync(Function<A1, F.Promise<Result>> action) {
+        public <A1> RoutingDsl routeAsync(Function<A1, ? extends CompletionStage<Result>> action) {
             return build(1, action, Function.class);
         }
 
@@ -356,7 +357,7 @@ public class RoutingDsl {
          * @param action The action to execute.
          * @return This router builder.
          */
-        public <A1, A2> RoutingDsl routeAsync(BiFunction<A1, A2, F.Promise<Result>> action) {
+        public <A1, A2> RoutingDsl routeAsync(BiFunction<A1, A2, ? extends CompletionStage<Result>> action) {
             return build(2, action, BiFunction.class);
         }
 
@@ -366,7 +367,7 @@ public class RoutingDsl {
          * @param action The action to execute.
          * @return This router builder.
          */
-        public <A1, A2, A3> RoutingDsl routeAsync(F.Function3<A1, A2, A3, F.Promise<Result>> action) {
+        public <A1, A2, A3> RoutingDsl routeAsync(F.Function3<A1, A2, A3, ? extends CompletionStage<Result>> action) {
             return build(3, action, F.Function3.class);
         }
 
diff --git a/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala b/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
index 6c5f5aa2ea..634bdddecc 100644
--- a/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
+++ b/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
@@ -3,19 +3,21 @@
  */
 package play.routing
 
+import java.util.concurrent.CompletionStage
+
 import play.api.Play
 import play.api.http.{ JavaHttpErrorHandlerDelegate, HttpConfiguration }
-import play.api.mvc.{ BodyParser, Results, Action }
-import play.core.j.{ JavaParsers, JavaHelpers }
+import play.api.mvc.{ Results, Action }
+import play.core.j.JavaHelpers
 import play.core.routing.HandlerInvokerFactory
-import play.libs.F
-import play.mvc.Http.{ RequestBody, Context }
+import play.mvc.Http.Context
 import play.mvc.Result
 import play.utils.UriEncoding
 import scala.collection.JavaConversions._
 
 import play.api.libs.iteratee.Execution.Implicits.trampoline
 
+import scala.compat.java8.FutureConverters
 import scala.concurrent.Future
 
 private[routing] object RouterBuilderHelper {
@@ -75,7 +77,7 @@ private[routing] object RouterBuilderHelper {
                     Context.current.set(ctx)
                     route.actionMethod.invoke(route.action, params: _*) match {
                       case result: Result => Future.successful(result.asScala)
-                      case promise: F.Promise[Result] => promise.wrapped.map(_.asScala)
+                      case promise: CompletionStage[Result] => FutureConverters.toScala(promise).map(_.asScala)
                     }
                   } finally {
                     Context.current.remove()
diff --git a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
index 58402e4b7e..7304a45e20 100644
--- a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
+++ b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
@@ -91,46 +91,20 @@ public final class Accumulator<E, A> {
      * @return A new accumulator that has recovered from errors.
      */
     public Accumulator<E, A> recoverWith(Function<? super Throwable, ? extends CompletionStage<A>> f, Executor executor) {
-        // Below is the way that this *should* be implemented, but doesn't work due to
-        // https://github.com/scala/scala-java8-compat/issues/29
-        //        return new Accumulator<>(
-        //                sink.mapMaterializedValue(cs ->
-        //                        cs.handleAsync((a, error) -> {
-        //                            if (a != null) {
-        //                                return CompletableFuture.completedFuture(a);
-        //                            } else {
-        //                                if (error instanceof CompletionException) {
-        //                                    return f.apply(error.getCause());
-        //                                } else {
-        //                                    return f.apply(error);
-        //                                }
-        //                            }
-        //                        }, executor).thenCompose(Function.identity()))
-        //        );
         return new Accumulator<>(
-                sink.mapMaterializedValue(cs -> {
-                    CompletableFuture<A> future = new CompletableFuture<>();
-                    cs.whenCompleteAsync((a, error) -> {
-                        if (a != null) {
-                            future.complete(a);
-                        } else {
-                            try {
-                                CompletionStage<A> recovered;
+                sink.mapMaterializedValue(cs ->
+                        cs.handleAsync((a, error) -> {
+                            if (a != null) {
+                                return CompletableFuture.completedFuture(a);
+                            } else {
                                 if (error instanceof CompletionException) {
-                                    recovered = f.apply(error.getCause());
+                                    return f.apply(error.getCause());
                                 } else {
-                                    recovered = f.apply(error);
+                                    return f.apply(error);
                                 }
-                                recovered.thenAccept(future::complete);
-                            } catch (Exception e) {
-                                future.completeExceptionally(e);
                             }
-                        }
-                    }, executor);
-                    return future;
-                })
+                        }, executor).thenCompose(Function.identity()))
         );
-
     }
 
     /**
diff --git a/framework/src/play/src/main/java/play/GlobalSettings.java b/framework/src/play/src/main/java/play/GlobalSettings.java
index 8d8033c01e..2390a68407 100644
--- a/framework/src/play/src/main/java/play/GlobalSettings.java
+++ b/framework/src/play/src/main/java/play/GlobalSettings.java
@@ -3,12 +3,12 @@
  */
 package play;
 
-import play.libs.F;
 import play.mvc.*;
 import play.mvc.Http.*;
 
 import java.io.File;
 import java.lang.reflect.*;
+import java.util.concurrent.CompletionStage;
 
 /**
  * GlobalSettings is instantiated by the framework when an application starts, to let you perform specific tasks
@@ -48,7 +48,7 @@ public class GlobalSettings {
      * @param t is any throwable
      * @return null as the default implementation
      */
-    public F.Promise<Result> onError(RequestHeader request, Throwable t) {
+    public CompletionStage<Result> onError(RequestHeader request, Throwable t) {
         return null;
     }
 
@@ -63,7 +63,7 @@ public class GlobalSettings {
     @SuppressWarnings("rawtypes")
     public Action onRequest(Request request, Method actionMethod) {
         return new Action.Simple() {
-            public F.Promise<Result> call(Context ctx) {
+            public CompletionStage<Result> call(Context ctx) {
                 return delegate.call(ctx);
             }
         };
@@ -95,7 +95,7 @@ public class GlobalSettings {
      * @param request the HTTP request
      * @return null in the default implementation, you can return your own custom Result in your Global class.
      */
-    public F.Promise<Result> onHandlerNotFound(RequestHeader request) {
+    public CompletionStage<Result> onHandlerNotFound(RequestHeader request) {
         return null;
     }
 
@@ -110,7 +110,7 @@ public class GlobalSettings {
      * @param request the HTTP request
      * @return null in the default implementation, you can return your own custom Result in your Global class.
      */
-    public F.Promise<Result> onBadRequest(RequestHeader request, String error) {
+    public CompletionStage<Result> onBadRequest(RequestHeader request, String error) {
         return null;
     }
 
diff --git a/framework/src/play/src/main/java/play/http/DefaultHttpErrorHandler.java b/framework/src/play/src/main/java/play/http/DefaultHttpErrorHandler.java
index 86d0c93e83..fef6292dfc 100644
--- a/framework/src/play/src/main/java/play/http/DefaultHttpErrorHandler.java
+++ b/framework/src/play/src/main/java/play/http/DefaultHttpErrorHandler.java
@@ -8,8 +8,6 @@ import play.api.OptionalSourceMapper;
 import play.api.UsefulException;
 import play.api.http.HttpErrorHandlerExceptions;
 import play.api.routing.Router;
-import play.libs.F;
-import play.mvc.Http;
 import play.mvc.Http.*;
 import play.mvc.Result;
 import play.mvc.Results;
@@ -17,6 +15,8 @@ import scala.Option;
 import scala.Some;
 
 import javax.inject.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 /**
  * Default implementation of the http error handler.
@@ -48,7 +48,7 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param message The error message.
      */
     @Override
-    public F.Promise<Result> onClientError(RequestHeader request, int statusCode, String message) {
+    public CompletionStage<Result> onClientError(RequestHeader request, int statusCode, String message) {
         if (statusCode == 400) {
             return onBadRequest(request, message);
         } else if (statusCode == 403) {
@@ -68,8 +68,8 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param request The request that was bad.
      * @param message The error message.
      */
-    protected F.Promise<Result> onBadRequest(RequestHeader request, String message) {
-        return F.Promise.<Result>pure(Results.badRequest(views.html.defaultpages.badRequest.render(
+    protected CompletionStage<Result> onBadRequest(RequestHeader request, String message) {
+        return CompletableFuture.completedFuture(Results.badRequest(views.html.defaultpages.badRequest.render(
                 request.method(), request.uri(), message
         )));
     }
@@ -80,8 +80,8 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param request The forbidden request.
      * @param message The error message.
      */
-    protected F.Promise<Result> onForbidden(RequestHeader request, String message) {
-        return F.Promise.<Result>pure(Results.forbidden(views.html.defaultpages.unauthorized.render()));
+    protected CompletionStage<Result> onForbidden(RequestHeader request, String message) {
+        return CompletableFuture.completedFuture(Results.forbidden(views.html.defaultpages.unauthorized.render()));
     }
 
     /**
@@ -90,12 +90,12 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param request The request that no handler was found to handle.
      * @param message A message.
      */
-    protected F.Promise<Result> onNotFound(RequestHeader request, String message){
+    protected CompletionStage<Result> onNotFound(RequestHeader request, String message){
         if (environment.isProd()) {
-            return F.Promise.<Result>pure(Results.notFound(views.html.defaultpages.notFound.render(
+            return CompletableFuture.completedFuture(Results.notFound(views.html.defaultpages.notFound.render(
                     request.method(), request.uri())));
         } else {
-            return F.Promise.<Result>pure(Results.notFound(views.html.defaultpages.devNotFound.render(
+            return CompletableFuture.completedFuture(Results.notFound(views.html.defaultpages.devNotFound.render(
                     request.method(), request.uri(), Some.apply(routes.get())
             )));
         }
@@ -109,9 +109,9 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param statusCode The error status code.  Must be greater or equal to 400, and less than 500.
      * @param message The error message.
      */
-    protected F.Promise<Result> onOtherClientError(RequestHeader request, int statusCode, String message) {
-        return F.Promise.<Result>pure(Results.status(statusCode, views.html.defaultpages.badRequest.render(
-            request.method(), request.uri(), message
+    protected CompletionStage<Result> onOtherClientError(RequestHeader request, int statusCode, String message) {
+        return CompletableFuture.completedFuture(Results.status(statusCode, views.html.defaultpages.badRequest.render(
+                request.method(), request.uri(), message
         )));
     }
 
@@ -126,7 +126,7 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param exception The server error.
      */
     @Override
-    public F.Promise<Result> onServerError(RequestHeader request, Throwable exception) {
+    public CompletionStage<Result> onServerError(RequestHeader request, Throwable exception) {
         try {
             UsefulException usefulException = throwableToUsefulException(exception);
 
@@ -140,7 +140,7 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
             }
         } catch (Exception e) {
             Logger.error("Error while handling error", e);
-            return F.Promise.<Result>pure(Results.internalServerError());
+            return CompletableFuture.completedFuture(Results.internalServerError());
         }
     }
 
@@ -175,8 +175,8 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param request The request that triggered the error.
      * @param exception The exception.
      */
-    protected F.Promise<Result> onDevServerError(RequestHeader request, UsefulException exception) {
-        return F.Promise.<Result>pure(Results.internalServerError(views.html.defaultpages.devError.render(playEditor, exception)));
+    protected CompletionStage<Result> onDevServerError(RequestHeader request, UsefulException exception) {
+        return CompletableFuture.completedFuture(Results.internalServerError(views.html.defaultpages.devError.render(playEditor, exception)));
     }
 
     /**
@@ -188,8 +188,8 @@ public class DefaultHttpErrorHandler implements HttpErrorHandler {
      * @param request The request that triggered the error.
      * @param exception The exception.
      */
-    protected F.Promise<Result> onProdServerError(RequestHeader request, UsefulException exception) {
-        return F.Promise.<Result>pure(Results.internalServerError(views.html.defaultpages.error.render(exception)));
+    protected CompletionStage<Result> onProdServerError(RequestHeader request, UsefulException exception) {
+        return CompletableFuture.completedFuture(Results.internalServerError(views.html.defaultpages.error.render(exception)));
     }
 
 }
diff --git a/framework/src/play/src/main/java/play/http/DefaultHttpRequestHandler.java b/framework/src/play/src/main/java/play/http/DefaultHttpRequestHandler.java
index 7c65603be8..22ae3f30a7 100644
--- a/framework/src/play/src/main/java/play/http/DefaultHttpRequestHandler.java
+++ b/framework/src/play/src/main/java/play/http/DefaultHttpRequestHandler.java
@@ -3,12 +3,12 @@
  */
 package play.http;
 
-import play.libs.F;
 import play.mvc.Action;
 import play.mvc.Http;
 import play.mvc.Result;
 
 import java.lang.reflect.Method;
+import java.util.concurrent.CompletionStage;
 
 public class DefaultHttpRequestHandler implements HttpRequestHandler {
 
@@ -16,7 +16,7 @@ public class DefaultHttpRequestHandler implements HttpRequestHandler {
     public Action createAction(Http.Request request, Method actionMethod) {
         return new Action.Simple() {
             @Override
-            public F.Promise<Result> call(Http.Context ctx) {
+            public CompletionStage<Result> call(Http.Context ctx) {
                 return delegate.call(ctx);
             }
         };
diff --git a/framework/src/play/src/main/java/play/http/HttpErrorHandler.java b/framework/src/play/src/main/java/play/http/HttpErrorHandler.java
index e914a634f1..f66a42139a 100644
--- a/framework/src/play/src/main/java/play/http/HttpErrorHandler.java
+++ b/framework/src/play/src/main/java/play/http/HttpErrorHandler.java
@@ -3,10 +3,11 @@
  */
 package play.http;
 
-import play.libs.F;
 import play.mvc.Http.RequestHeader;
 import play.mvc.Result;
 
+import java.util.concurrent.CompletionStage;
+
 /**
  * Component for handling HTTP errors in Play.
  *
@@ -21,7 +22,7 @@ public interface HttpErrorHandler {
      * @param statusCode The error status code.  Must be greater or equal to 400, and less than 500.
      * @param message The error message.
      */
-    F.Promise<Result> onClientError(RequestHeader request, int statusCode, String message);
+    CompletionStage<Result> onClientError(RequestHeader request, int statusCode, String message);
 
     /**
      * Invoked when a server error occurs.
@@ -29,5 +30,5 @@ public interface HttpErrorHandler {
      * @param request The request that triggered the server error.
      * @param exception The server error.
      */
-    F.Promise<Result> onServerError(RequestHeader request, Throwable exception);
+    CompletionStage<Result> onServerError(RequestHeader request, Throwable exception);
 }
diff --git a/framework/src/play/src/main/java/play/inject/ApplicationLifecycle.java b/framework/src/play/src/main/java/play/inject/ApplicationLifecycle.java
index 2e9850edd4..8bbe022b58 100644
--- a/framework/src/play/src/main/java/play/inject/ApplicationLifecycle.java
+++ b/framework/src/play/src/main/java/play/inject/ApplicationLifecycle.java
@@ -3,9 +3,8 @@
  */
 package play.inject;
 
-import play.libs.F;
-
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletionStage;
 
 /**
  * Application lifecycle register.
@@ -25,5 +24,5 @@ public interface ApplicationLifecycle {
      * The stop hook should redeem the returned future when it is finished shutting down.  It is acceptable to stop
      * immediately and return a successful future.
      */
-    public void addStopHook(Callable<F.Promise<?>> hook);
+    void addStopHook(Callable<? extends CompletionStage<?>> hook);
 }
diff --git a/framework/src/play/src/main/java/play/libs/F.java b/framework/src/play/src/main/java/play/libs/F.java
index 6e90de9416..7f36efae98 100644
--- a/framework/src/play/src/main/java/play/libs/F.java
+++ b/framework/src/play/src/main/java/play/libs/F.java
@@ -4,15 +4,12 @@
 package play.libs;
 
 import java.util.*;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Consumer;
-import java.util.function.Predicate;
+import java.util.concurrent.*;
+import java.util.function.*;
 
-import java.util.function.Function;
-import java.util.function.Supplier;
-
-import akka.japi.JavaPartialFunction;
-import play.core.j.FPromiseHelper;
+import play.libs.concurrent.Futures;
+import play.libs.concurrent.HttpExecution;
+import scala.compat.java8.FutureConverters;
 import scala.concurrent.ExecutionContext;
 import scala.concurrent.Future;
 
@@ -30,28 +27,34 @@ public class F {
 
     /**
      * A promise to produce a result of type <code>A</code>.
+     *
+     * @deprecated Use the JDK8 {@link CompletionStage} instead. When migrating to CompletionStage, Promise implements
+     *             CompletionStage, so it may be easier to first migrate all the existing method calls on the promise,
+     *             such as map/flatMap, which are also deprecated but include migration instructions in the deprecation
+     *             message.
      */
-    public static class Promise<A> {
+    @Deprecated
+    public static class Promise<A> implements CompletionStage<A> {
 
-        private final Future<A> future;
+        private final CompletionStage<A> wrapped;
 
-        /**
-         * Creates a Promise that wraps a Scala Future.
-         *
-         * @param future The Scala Future to wrap
-         */
-        private Promise(Future<A> future) {
-            this.future = future;
+        private Promise(CompletionStage<A> wrapped) {
+            this.wrapped = wrapped;
+        }
+
+        public static <A> Promise<A> wrap(CompletionStage<A> future) {
+            return new Promise<>(future);
         }
 
         /**
          * Creates a Promise that wraps a Scala Future.
          *
          * @param future The Scala Future to wrap
+         * @deprecated Use {@link FutureConverters#toJava(Future)} instead.
          */
-        @SuppressWarnings("deprecation")
+        @Deprecated
         public static <A> Promise<A> wrap(Future<A> future) {
-            return new Promise<A>(future);
+            return new Promise<>(FutureConverters.toJava(future));
         }
 
         /**
@@ -61,9 +64,11 @@ public class F {
          *
          * @param promises The promises to combine
          * @return A single promise whose methods act on the list of redeemed promises
+         * @deprecated Use {@link Futures#sequence(CompletionStage[])} instead.
          */
-        public static <A> Promise<List<A>> sequence(Promise<A>... promises){
-            return FPromiseHelper.<A>sequence(java.util.Arrays.asList(promises), HttpExecution.defaultContext());
+        @Deprecated
+        public static <A> Promise<List<A>> sequence(Promise<A>... promises) {
+            return Futures.sequence(Arrays.asList(promises));
         }
 
         /**
@@ -72,9 +77,11 @@ public class F {
          * @param ec Used to execute the sequencing operations.
          * @param promises The promises to combine
          * @return A single promise whose methods act on the list of redeemed promises
+         * @deprecated Use {@link Futures#sequence(CompletionStage[])} instead.
          */
-        public static <A> Promise<List<A>> sequence(ExecutionContext ec, Promise<A>... promises){
-            return FPromiseHelper.<A>sequence(java.util.Arrays.asList(promises), ec);
+        @Deprecated
+        public static <A> Promise<List<A>> sequence(ExecutionContext ec, Promise<A>... promises) {
+            return sequence(Arrays.asList(promises), ec);
         }
 
         /**
@@ -83,9 +90,11 @@ public class F {
          * @param message The message to use to redeem the Promise.
          * @param delay The delay (expressed with the corresponding unit).
          * @param unit The Unit.
+         * @deprecated Use {@link Futures#timeout(Object, long, TimeUnit)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> timeout(A message, long delay, TimeUnit unit) {
-            return FPromiseHelper.timeout(message, delay, unit);
+            return Futures.timeout(message, delay, unit);
         }
 
         /**
@@ -93,9 +102,11 @@ public class F {
          *
          * @param message The message to use to redeem the Promise.
          * @param delay The delay expressed in milliseconds.
+         * @deprecated Use {@link Futures#timeout(Object, long, TimeUnit)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> timeout(A message, long delay) {
-            return timeout(message, delay, TimeUnit.MILLISECONDS);
+            return Futures.timeout(message, delay, TimeUnit.MILLISECONDS);
         }
 
         /**
@@ -106,9 +117,11 @@ public class F {
          *
          * @return a promise without a real value
          * @param delay The delay expressed in milliseconds.
+         * @deprecated Use {@link Futures#timeout(long, TimeUnit)} instead.
          */
-        public static Promise<scala.Unit> timeout(long delay) {
-            return timeout(delay, TimeUnit.MILLISECONDS);
+        @Deprecated
+        public static Promise<Void> timeout(long delay) {
+            return Futures.timeout(delay, TimeUnit.MILLISECONDS);
         }
 
         /**
@@ -120,9 +133,11 @@ public class F {
          * @param delay The delay (expressed with the corresponding unit).
          * @param unit The Unit.
          * @return a promise without a real value
+         * @deprecated Use {@link Futures#timeout(long, TimeUnit)} instead.
          */
-        public static Promise<scala.Unit> timeout(long delay, TimeUnit unit) {
-            return FPromiseHelper.timeout(delay, unit);
+        @Deprecated
+        public static Promise<Void> timeout(long delay, TimeUnit unit) {
+            return Futures.timeout(delay, unit);
         }
 
         /**
@@ -132,9 +147,11 @@ public class F {
          *
          * @param promises The promises to combine
          * @return A single promise whose methods act on the list of redeemed promises
+         * @deprecated Use {@link Futures#sequence(Iterable)} instead.
          */
-        public static <A> Promise<List<A>> sequence(Iterable<Promise<A>> promises){
-            return FPromiseHelper.sequence(promises, HttpExecution.defaultContext());
+        @Deprecated
+        public static <A> Promise<List<A>> sequence(Iterable<Promise<A>> promises) {
+            return Futures.sequence(promises);
         }
 
         /**
@@ -143,26 +160,42 @@ public class F {
          * @param promises The promises to combine
          * @param ec Used to execute the sequencing operations.
          * @return A single promise whose methods act on the list of redeemed promises
+         * @deprecated Use {@link Futures#sequence(Iterable)} instead.
          */
+        @Deprecated
         public static <A> Promise<List<A>> sequence(Iterable<Promise<A>> promises, ExecutionContext ec){
-            return FPromiseHelper.sequence(promises, ec);
+            CompletableFuture<List<A>> result = CompletableFuture.completedFuture(new ArrayList<>());
+            for (Promise<A> promise: promises) {
+                result = result.thenCombineAsync(promise, (list, a) -> {
+                    list.add(a);
+                    return list;
+                }, toExecutor(ec));
+            }
+            return new Promise<>(result);
         }
 
         /**
          * Create a new pure promise, that is, a promise with a constant value from the start.
          *
          * @param a the value for the promise
+         * @deprecated Use {@link CompletableFuture#completedFuture(Object)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> pure(final A a) {
-            return FPromiseHelper.pure(a);
+            return new Promise<>(CompletableFuture.completedFuture(a));
         }
 
         /**
          * Create a new promise throwing an exception.
          * @param throwable Value to throw
+         * @deprecated Construct a new {@link CompletableFuture} and use
+         *             {@link CompletableFuture#completeExceptionally(Throwable)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> throwing(Throwable throwable) {
-            return FPromiseHelper.throwing(throwable);
+            CompletableFuture<A> future = new CompletableFuture<>();
+            future.completeExceptionally(throwable);
+            return new Promise<>(future);
         }
 
         /**
@@ -171,9 +204,11 @@ public class F {
          * The Function0 will be run in the default ExecutionContext.
          *
          * @param function Used to fulfill the Promise.
+         * @deprecated Use {@link CompletableFuture#supplyAsync(Supplier, Executor)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> promise(Supplier<A> function) {
-            return FPromiseHelper.promise(function, HttpExecution.defaultContext());
+            return new Promise<>(CompletableFuture.supplyAsync(function, HttpExecution.defaultContext()));
         }
 
         /**
@@ -181,9 +216,11 @@ public class F {
          *
          * @param function Used to fulfill the Promise.
          * @param ec The ExecutionContext to run the function in.
+         * @deprecated Use {@link CompletableFuture#supplyAsync(Supplier, Executor)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> promise(Supplier<A> function, ExecutionContext ec) {
-            return FPromiseHelper.promise(function, ec);
+            return new Promise<>(CompletableFuture.supplyAsync(function, toExecutor(ec)));
         }
 
         /**
@@ -195,9 +232,12 @@ public class F {
          * @param function The function to call to fulfill the Promise.
          * @param delay The time to wait.
          * @param unit The units to use for the delay.
+         * @deprecated Use {@link Futures#delayed(Supplier, long, TimeUnit, Executor)} with
+         *             {@link HttpExecution#defaultContext()} instead.
          */
+        @Deprecated
         public static <A> Promise<A> delayed(Supplier<A> function, long delay, TimeUnit unit) {
-            return FPromiseHelper.delayed(function, delay, unit, HttpExecution.defaultContext());
+            return Futures.delayed(function, delay, unit, HttpExecution.defaultContext());
         }
 
         /**
@@ -207,10 +247,11 @@ public class F {
          * @param function The function to call to fulfill the Promise.
          * @param delay The time to wait.
          * @param unit The units to use for the delay.
-         * @param ec The ExecutionContext to run the Function0 in.
+         * @deprecated Use {@link Futures#delayed(Supplier, long, TimeUnit, Executor)} instead.
          */
+        @Deprecated
         public static <A> Promise<A> delayed(Supplier<A> function, long delay, TimeUnit unit, ExecutionContext ec) {
-            return FPromiseHelper.delayed(function, delay, unit, ec);
+            return Futures.delayed(function, delay, unit, toExecutor(ec));
         }
 
         /**
@@ -221,10 +262,30 @@ public class F {
          * @param unit timeout for timeout
          * @throws PromiseTimeoutException when the promise did timeout.
          * @return The promised result
-         *
+         * @deprecated Calling get on a promise is a blocking operation and so introduces the risk of deadlocks
+         *      and has serious performance implications.
          */
+        @Deprecated
         public A get(long timeout, TimeUnit unit) {
-            return FPromiseHelper.get(this, timeout, unit);
+            // This rather complex exception matching is to ensure that the existing (quite comprehensive)
+            // tests still pass. CompletableFuture does a lot of wrapping of exceptions, and doesn't unwrap
+            // them, but this API did unwrap things, so to ensure the same exceptions are thrown from the
+            // existing APIs, this needed to be done.
+            try {
+                return this.toCompletableFuture().get(timeout, unit);
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            } catch (TimeoutException e) {
+                throw new PromiseTimeoutException(e.getMessage(), e);
+            } catch (ExecutionException e) {
+                if (e.getCause() instanceof RuntimeException) {
+                    throw (RuntimeException) e.getCause();
+                } else if (e.getCause() instanceof TimeoutException) {
+                    throw new PromiseTimeoutException(e.getCause().getMessage(), e.getCause());
+                } else {
+                    throw new RuntimeException(e.getCause());
+                }
+            }
         }
 
         /**
@@ -234,18 +295,24 @@ public class F {
          * @param timeout A user defined timeout in milliseconds
          * @throws PromiseTimeoutException when the promise did timeout.
          * @return The promised result
+         * @deprecated Calling get on a promise is a blocking operation and so introduces the risk of deadlocks
+         *      and has serious performance implications.
          */
+        @Deprecated
         public A get(long timeout) {
-            return FPromiseHelper.get(this, timeout, TimeUnit.MILLISECONDS);
+            return get(timeout, TimeUnit.MILLISECONDS);
         }
 
         /**
          * Combines the current promise with <code>another</code> promise using `or`.
          *
          * @param another promise that will be combined
+         * @deprecated Use {@link #applyToEither(CompletionStage, Function)} instead.
          */
+        @Deprecated
         public <B> Promise<Either<A,B>> or(Promise<B> another) {
-            return FPromiseHelper.or(this, another);
+            return new Promise<>(wrapped.thenApply(Either::<A, B>Left)
+                    .applyToEither(another.thenApply(Either::<A, B>Right), Function.identity()));
         }
 
         /**
@@ -254,9 +321,11 @@ public class F {
          * The callback will be run in the default execution context.
          *
          * @param action The action to perform.
+         * @deprecated Use {@link #thenAcceptAsync(Consumer, Executor)} with {@link HttpExecution#defaultContext()} instead.
          */
-        public void onRedeem(final Consumer<A> action) {
-            FPromiseHelper.onRedeem(this, action, HttpExecution.defaultContext());
+        @Deprecated
+        public void onRedeem(final Consumer<? super A> action) {
+            wrapped.thenAcceptAsync(action, HttpExecution.defaultContext());
         }
 
         /**
@@ -264,9 +333,11 @@ public class F {
          *
          * @param action The action to perform.
          * @param ec The ExecutionContext to execute the action in.
+         * @deprecated Use {@link #thenAcceptAsync(Consumer, Executor)} instead.
          */
-        public void onRedeem(final Consumer<A> action, ExecutionContext ec) {
-            FPromiseHelper.onRedeem(this, action, ec);
+        @Deprecated
+        public void onRedeem(final Consumer<? super A> action, ExecutionContext ec) {
+            wrapped.thenAcceptAsync(action, toExecutor(ec));
         }
 
         /**
@@ -277,9 +348,12 @@ public class F {
          *
          * @param function The function to map <code>A</code> to <code>B</code>.
          * @return A wrapped promise that maps the type from <code>A</code> to <code>B</code>.
+         * @deprecated Use {@link #thenApplyAsync(Function, Executor)} with {@link HttpExecution#defaultContext()} if
+         *             you want to capture the current context.
          */
-        public <B> Promise<B> map(final Function<? super A, B> function) {
-            return FPromiseHelper.map(this, function, HttpExecution.defaultContext());
+        @Deprecated
+        public <B> Promise<B> map(final Function<? super A, ? extends B> function) {
+            return new Promise<>(wrapped.thenApplyAsync(function, HttpExecution.defaultContext()));
         }
 
         /**
@@ -289,9 +363,11 @@ public class F {
          * @param function The function to map <code>A</code> to <code>B</code>.
          * @param ec The ExecutionContext to execute the function in.
          * @return A wrapped promise that maps the type from <code>A</code> to <code>B</code>.
+         * @deprecated Use {@link #thenApplyAsync(Function, Executor)}
          */
-        public <B> Promise<B> map(final Function<? super A, B> function, ExecutionContext ec) {
-            return FPromiseHelper.map(this, function, ec);
+        @Deprecated
+        public <B> Promise<B> map(final Function<? super A, ? extends B> function, ExecutionContext ec) {
+            return new Promise<>(wrapped.thenApplyAsync(function, toExecutor(ec)));
         }
 
         /**
@@ -303,9 +379,19 @@ public class F {
          *      of type <code>T</code>, or it may throw another exception, or it may do some other handling.
          * @return A wrapped promise that will only throw an exception if the supplied <code>function</code> throws an
          *      exception.
+         * @deprecated Use {@link #exceptionally(Function)} if you don't need the current context captured,
+         *             or {@link #handleAsync(BiFunction, Executor)} with {@link HttpExecution#defaultContext()} if
+         *             you do.
          */
-        public Promise<A> recover(final Function<Throwable,A> function) {
-            return FPromiseHelper.recover(this, function, HttpExecution.defaultContext());
+        @Deprecated
+        public Promise<A> recover(final Function<Throwable, ? extends A> function) {
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    return function.apply(error);
+                } else {
+                    return a;
+                }
+            }, HttpExecution.defaultContext()));
         }
 
         /**
@@ -316,9 +402,17 @@ public class F {
          * @param ec The ExecutionContext to execute the function in.
          * @return A wrapped promise that will only throw an exception if the supplied <code>function</code> throws an
          *      exception.
+         * @deprecated Use {@link #handleAsync(BiFunction, Executor)} instead.
          */
-        public Promise<A> recover(final Function<Throwable,A> function, ExecutionContext ec) {
-            return FPromiseHelper.recover(this, function, ec);
+        @Deprecated
+        public Promise<A> recover(final Function<Throwable, ? extends A> function, ExecutionContext ec) {
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    return function.apply(error);
+                } else {
+                    return a;
+                }
+            }, toExecutor(ec)));
         }
 
         /**
@@ -328,9 +422,19 @@ public class F {
          *
          * @param function The function to handle the exception, and which returns another promise
          * @return A promise that will delegate to another promise on failure
+         * @deprecated Use {@link #exceptionally(Function)} if you don't need the current context captured,
+         *             or {@link #handleAsync(BiFunction, Executor)} with {@link HttpExecution#defaultContext()} if
+         *             you do, then use {@link #thenCompose(Function)} with the identity function to flatten the result.
          */
-        public Promise<A> recoverWith(final Function<Throwable, Promise<A>> function) {
-            return FPromiseHelper.recoverWith(this, function, HttpExecution.defaultContext());
+        @Deprecated
+        public Promise<A> recoverWith(final Function<Throwable, ? extends CompletionStage<A>> function) {
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    return function.apply(error);
+                } else {
+                    return CompletableFuture.completedFuture(a);
+                }
+            }, HttpExecution.defaultContext()).thenCompose(Function.identity()));
         }
 
         /**
@@ -339,9 +443,18 @@ public class F {
          * @param function The function to handle the exception, and which returns another promise
          * @param ec The ExecutionContext to execute the function in
          * @return A promise that will delegate to another promise on failure
+         * @deprecated Use {@link #handleAsync(BiFunction, Executor)} instead, followed by {@link #thenCompose(Function)}
+         *             with the identity function.
          */
+        @Deprecated
         public Promise<A> recoverWith(final Function<Throwable, Promise<A>> function, ExecutionContext ec) {
-            return FPromiseHelper.recoverWith(this, function, ec);
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    return function.apply(error);
+                } else {
+                    return CompletableFuture.completedFuture(a);
+                }
+            }, toExecutor(ec)).thenCompose(Function.identity()));
         }
 
         /**
@@ -351,9 +464,26 @@ public class F {
          *
          * @param fallback The promise to fallback to if this promise has failed
          * @return A promise that will delegate to another promise on failure
+         * @deprecated Use {@link #handleAsync(BiFunction)} followed by {@link #thenCompose(Function)}
+         *             with the identity function.
          */
+        @Deprecated
         public Promise<A> fallbackTo(final Promise<A> fallback) {
-            return FPromiseHelper.fallbackTo(this, fallback);
+            return new Promise<>(wrapped.handle((a, error) -> {
+               if (error != null) {
+                   return fallback.handle((fallbackA, fallbackError) -> {
+                       if (fallbackError != null) {
+                           CompletableFuture<A> failed = new CompletableFuture<>();
+                           failed.completeExceptionally(error);
+                           return failed;
+                       } else {
+                           return CompletableFuture.completedFuture(fallbackA);
+                       }
+                   }).thenCompose(Function.identity());
+               } else {
+                   return CompletableFuture.completedFuture(a);
+               }
+            }).thenCompose(Function.identity()));
         }
 
         /**
@@ -362,9 +492,16 @@ public class F {
          * This action will be run in the default exceution context.
          *
          * @param action The action to perform.
+         * @deprecated Use {@link #whenCompleteAsync(BiConsumer, Executor)} with {@link HttpExecution#defaultContext()} if
+         *             you want to capture the current context.
          */
+        @Deprecated
         public void onFailure(final Consumer<Throwable> action) {
-            FPromiseHelper.onFailure(this, action, HttpExecution.defaultContext());
+            wrapped.whenCompleteAsync((a, error) -> {
+                if (error != null) {
+                    action.accept(error);
+                }
+            }, HttpExecution.defaultContext());
         }
 
         /**
@@ -372,9 +509,15 @@ public class F {
          *
          * @param action The action to perform.
          * @param ec The ExecutionContext to execute the callback in.
+         * @deprecated Use {@link #whenCompleteAsync(BiConsumer, Executor)}.
          */
+        @Deprecated
         public void onFailure(final Consumer<Throwable> action, ExecutionContext ec) {
-            FPromiseHelper.onFailure(this, action, ec);
+            wrapped.whenCompleteAsync((a, error) -> {
+                if (error != null) {
+                    action.accept(error);
+                }
+            }, toExecutor(ec));
         }
 
         /**
@@ -385,9 +528,12 @@ public class F {
          *
          * @param function The function to map <code>A</code> to a promise for <code>B</code>.
          * @return A wrapped promise for a result of type <code>B</code>
+         * @deprecated Use {@link #thenComposeAsync(Function, Executor)} with {@link HttpExecution#defaultContext()} if
+         *             you want to capture the current context.
          */
-        public <B> Promise<B> flatMap(final Function<? super A,Promise<B>> function) {
-            return FPromiseHelper.flatMap(this, function, HttpExecution.defaultContext());
+        @Deprecated
+        public <B> Promise<B> flatMap(final Function<? super A, ? extends CompletionStage<B>> function) {
+            return new Promise<>(wrapped.thenComposeAsync(function, HttpExecution.defaultContext()));
         }
 
         /**
@@ -397,9 +543,11 @@ public class F {
          * @param function The function to map <code>A</code> to a promise for <code>B</code>.
          * @param ec The ExecutionContext to execute the function in.
          * @return A wrapped promise for a result of type <code>B</code>
+         * @deprecated Use {@link #thenComposeAsync(Function, Executor)}.
          */
-        public <B> Promise<B> flatMap(final Function<? super A,Promise<B>> function, ExecutionContext ec) {
-            return FPromiseHelper.flatMap(this, function, ec);
+        @Deprecated
+        public <B> Promise<B> flatMap(final Function<? super A, ? extends CompletionStage<B>> function, ExecutionContext ec) {
+            return new Promise<>(wrapped.thenComposeAsync(function, toExecutor(ec)));
         }
 
         /**
@@ -408,9 +556,17 @@ public class F {
          *
          * @param predicate The predicate to test the current value.
          * @return A new promise with the current value, if the predicate is satisfied.
+         * @deprecated Use {@link #thenApplyAsync(Function, Executor)} to implement the filter manually.
          */
+        @Deprecated
         public Promise<A> filter(final Predicate<? super A> predicate) {
-            return FPromiseHelper.filter(this, predicate, HttpExecution.defaultContext());
+            return new Promise<>(wrapped.thenApplyAsync(a -> {
+                if (predicate.test(a)) {
+                    return a;
+                } else {
+                    throw new NoSuchElementException("Promise.filter predicate is not satisfied");
+                }
+            }, HttpExecution.defaultContext()));
         }
 
         /**
@@ -420,9 +576,17 @@ public class F {
          * @param predicate The predicate to test the current value.
          * @param ec The ExecutionContext to execute the filtering in.
          * @return A new promise with the current value, if the predicate is satisfied.
+         * @deprecated Use {@link #thenApplyAsync(Function, Executor)} to implement the filter manually.
          */
+        @Deprecated
         public Promise<A> filter(final Predicate<? super A> predicate, ExecutionContext ec) {
-            return FPromiseHelper.filter(this, predicate, ec);
+            return new Promise<>(wrapped.thenApplyAsync(a -> {
+                if (predicate.test(a)) {
+                    return a;
+                } else {
+                    throw new NoSuchElementException("Promise.filter predicate is not satisfied");
+                }
+            }, toExecutor(ec)));
         }
 
         /**
@@ -434,9 +598,17 @@ public class F {
          * @param onSuccess The function to map a successful result from {@code A} to {@code B}
          * @param onFailure The function to map the {@code Throwable} when failed
          * @return A new promise mapped by either the {@code onSuccess} or {@code onFailure} functions
+         * @deprecated Use {@link #handleAsync(BiFunction, Executor)} instead.
          */
-        public <B> Promise<B> transform(final Function<? super A, B> onSuccess, final Function<Throwable, Throwable> onFailure) {
-            return FPromiseHelper.transform(this, onSuccess, onFailure, HttpExecution.defaultContext());
+        @Deprecated
+        public <B> Promise<B> transform(final Function<? super A, ? extends B> onSuccess, final Function<Throwable, Throwable> onFailure) {
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    throw error instanceof CompletionException ? (CompletionException) error : new CompletionException(onFailure.apply(error));
+                } else {
+                    return onSuccess.apply(a);
+                }
+            }, HttpExecution.defaultContext()));
         }
 
         /**
@@ -447,34 +619,243 @@ public class F {
          * @param onFailure The function to map the {@code Throwable} when failed
          * @param ec The ExecutionContext to execute functions in
          * @return A new promise mapped by either the {@code onSuccess} or {@code onFailure} functions
+         * @deprecated Use {@link #handleAsync(BiFunction, Executor)} instead.
          */
-        public <B> Promise<B> transform(final Function<? super A, B> onSuccess, final Function<Throwable, Throwable> onFailure, ExecutionContext ec) {
-            return FPromiseHelper.transform(this, onSuccess, onFailure, ec);
+        @Deprecated
+        public <B> Promise<B> transform(final Function<? super A, ? extends B> onSuccess, final Function<Throwable, Throwable> onFailure, ExecutionContext ec) {
+            return new Promise<>(wrapped.handleAsync((a, error) -> {
+                if (error != null) {
+                    throw error instanceof CompletionException ? (CompletionException) error : new CompletionException(onFailure.apply(error));
+                } else {
+                    return onSuccess.apply(a);
+                }
+            }, toExecutor(ec)));
         }
 
         /**
          * Zips the values of this promise with <code>another</code>, and creates a new promise holding the tuple of their results
          * @param another
+         * @deprecated Use {@link #thenCombine(CompletionStage, BiFunction)} instead.
          */
-        public <B> Promise<Tuple<A, B>> zip(Promise<B> another) {
-            return wrap(wrapped().zip(another.wrapped())).map(
-                new Function<scala.Tuple2<A, B>, Tuple<A, B>>() {
-                    public Tuple<A, B> apply(scala.Tuple2<A, B> scalaTuple) {
-                        return new Tuple(scalaTuple._1, scalaTuple._2);
-                    }
-                }
-            );
+        @Deprecated
+        public <B> Promise<Tuple<A, B>> zip(CompletionStage<B> another) {
+            return thenCombine(another, (a, b) -> new Tuple(a, b));
         }
 
         /**
          * Gets the Scala Future wrapped by this Promise.
          *
          * @return The Scala Future
+         * @deprecated Promise no longer wraps a Scala Future, use asScala instead.
          */
+        @Deprecated
         public Future<A> wrapped() {
-            return future;
+            return asScala();
+        }
+
+        /**
+         * Convert this promise to a Scala future.
+         *
+         * This is equivalent to FutureConverters.toScala(this), however, it converts the wrapped completion stage to
+         * a future rather than this, which means if the wrapped completion stage itself wraps a Scala future, it will
+         * simply return that wrapped future.
+         *
+         * @return A Scala future that is completed when this promise is completed.
+         */
+        public Future<A> asScala() {
+            return FutureConverters.toScala(wrapped);
+        }
+
+        // delegate methods
+        @Override
+        public <U> Promise<U> thenApply(Function<? super A, ? extends U> fn) {
+            return new Promise<>(wrapped.thenApply(fn));
+        }
+
+        @Override
+        public <U> Promise<U> thenApplyAsync(Function<? super A, ? extends U> fn) {
+            return new Promise<>(wrapped.thenApplyAsync(fn));
+        }
+
+        @Override
+        public <U> Promise<U> thenApplyAsync(Function<? super A, ? extends U> fn, Executor executor) {
+            return new Promise<>(wrapped.thenApplyAsync(fn, executor));
+        }
+
+        @Override
+        public Promise<Void> thenAccept(Consumer<? super A> action) {
+            return new Promise<>(wrapped.thenAccept(action));
+        }
+
+        @Override
+        public Promise<Void> thenAcceptAsync(Consumer<? super A> action) {
+            return new Promise<>(wrapped.thenAcceptAsync(action));
+        }
+
+        @Override
+        public Promise<Void> thenAcceptAsync(Consumer<? super A> action, Executor executor) {
+            return new Promise<>(wrapped.thenAcceptAsync(action, executor));
+        }
+
+        @Override
+        public Promise<Void> thenRun(Runnable action) {
+            return new Promise<>(wrapped.thenRun(action));
+        }
+
+        @Override
+        public Promise<Void> thenRunAsync(Runnable action) {
+            return new Promise<>(wrapped.thenRunAsync(action));
+        }
+
+        @Override
+        public Promise<Void> thenRunAsync(Runnable action, Executor executor) {
+            return new Promise<>(wrapped.thenRunAsync(action, executor));
+        }
+
+        @Override
+        public <U, V> Promise<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super A, ? super U, ? extends V> fn) {
+            return new Promise<>(wrapped.thenCombine(other, fn));
+        }
+
+        @Override
+        public <U, V> Promise<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super A, ? super U, ? extends V> fn) {
+            return new Promise<>(wrapped.thenCombineAsync(other, fn));
+        }
+
+        @Override
+        public <U, V> Promise<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super A, ? super U, ? extends V> fn, Executor executor) {
+            return new Promise<>(wrapped.thenCombineAsync(other, fn, executor));
+        }
+
+        @Override
+        public <U> Promise<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super A, ? super U> action) {
+            return new Promise<>(wrapped.thenAcceptBoth(other, action));
+        }
+
+        @Override
+        public <U> Promise<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super A, ? super U> action) {
+            return new Promise<>(wrapped.thenAcceptBothAsync(other, action));
+        }
+
+        @Override
+        public <U> Promise<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super A, ? super U> action, Executor executor) {
+            return new Promise<>(wrapped.thenAcceptBothAsync(other, action, executor));
+        }
+
+        @Override
+        public Promise<Void> runAfterBoth(CompletionStage<?> other, Runnable action) {
+            return new Promise<>(wrapped.runAfterBoth(other, action));
         }
 
+        @Override
+        public Promise<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action) {
+            return new Promise<>(wrapped.runAfterBothAsync(other, action));
+        }
+
+        @Override
+        public Promise<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor) {
+            return new Promise<>(wrapped.runAfterBothAsync(other, action, executor));
+        }
+
+        @Override
+        public <U> Promise<U> applyToEither(CompletionStage<? extends A> other, Function<? super A, U> fn) {
+            return new Promise<>(wrapped.applyToEither(other, fn));
+        }
+
+        @Override
+        public <U> Promise<U> applyToEitherAsync(CompletionStage<? extends A> other, Function<? super A, U> fn) {
+            return new Promise<>(wrapped.applyToEitherAsync(other, fn));
+        }
+
+        @Override
+        public <U> Promise<U> applyToEitherAsync(CompletionStage<? extends A> other, Function<? super A, U> fn, Executor executor) {
+            return new Promise<>(wrapped.applyToEitherAsync(other, fn, executor));
+        }
+
+        @Override
+        public Promise<Void> acceptEither(CompletionStage<? extends A> other, Consumer<? super A> action) {
+            return new Promise<>(wrapped.acceptEither(other, action));
+        }
+
+        @Override
+        public Promise<Void> acceptEitherAsync(CompletionStage<? extends A> other, Consumer<? super A> action) {
+            return new Promise<>(wrapped.acceptEitherAsync(other, action));
+        }
+
+        @Override
+        public Promise<Void> acceptEitherAsync(CompletionStage<? extends A> other, Consumer<? super A> action, Executor executor) {
+            return new Promise<>(wrapped.acceptEitherAsync(other, action, executor));
+        }
+
+        @Override
+        public Promise<Void> runAfterEither(CompletionStage<?> other, Runnable action) {
+            return new Promise<>(wrapped.runAfterEither(other, action));
+        }
+
+        @Override
+        public Promise<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action) {
+            return new Promise<>(wrapped.runAfterEitherAsync(other, action));
+        }
+
+        @Override
+        public Promise<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor) {
+            return new Promise<>(wrapped.runAfterEitherAsync(other, action, executor));
+        }
+
+        @Override
+        public <U> Promise<U> thenCompose(Function<? super A, ? extends CompletionStage<U>> fn) {
+            return new Promise<>(wrapped.thenCompose(fn));
+        }
+
+        @Override
+        public <U> Promise<U> thenComposeAsync(Function<? super A, ? extends CompletionStage<U>> fn) {
+            return new Promise<>(wrapped.thenComposeAsync(fn));
+        }
+
+        @Override
+        public <U> Promise<U> thenComposeAsync(Function<? super A, ? extends CompletionStage<U>> fn, Executor executor) {
+            return new Promise<>(wrapped.thenComposeAsync(fn, executor));
+        }
+
+        @Override
+        public Promise<A> exceptionally(Function<Throwable, ? extends A> fn) {
+            return new Promise<>(wrapped.exceptionally(fn));
+        }
+
+        @Override
+        public Promise<A> whenComplete(BiConsumer<? super A, ? super Throwable> action) {
+            return new Promise<>(wrapped.whenComplete(action));
+        }
+
+        @Override
+        public Promise<A> whenCompleteAsync(BiConsumer<? super A, ? super Throwable> action) {
+            return new Promise<>(wrapped.whenCompleteAsync(action));
+        }
+
+        @Override
+        public Promise<A> whenCompleteAsync(BiConsumer<? super A, ? super Throwable> action, Executor executor) {
+            return new Promise<>(wrapped.whenCompleteAsync(action, executor));
+        }
+
+        @Override
+        public <U> Promise<U> handle(BiFunction<? super A, Throwable, ? extends U> fn) {
+            return new Promise<>(wrapped.handle(fn));
+        }
+
+        @Override
+        public <U> Promise<U> handleAsync(BiFunction<? super A, Throwable, ? extends U> fn) {
+            return new Promise<>(wrapped.handleAsync(fn));
+        }
+
+        @Override
+        public <U> Promise<U> handleAsync(BiFunction<? super A, Throwable, ? extends U> fn, Executor executor) {
+            return new Promise<>(wrapped.handleAsync(fn, executor));
+        }
+
+        @Override
+        public CompletableFuture<A> toCompletableFuture() {
+            return wrapped.toCompletableFuture();
+        }
     }
 
     /**
@@ -495,23 +876,24 @@ public class F {
      * someFutureInt.success(42);
      * }
      * </pre>
+     * @deprecated Use {@link CompletableFuture} instead.
      */
-    public static class RedeemablePromise<A> extends Promise<A>{
+    @Deprecated
+    public static class RedeemablePromise<A> extends Promise<A> {
 
-        private final scala.concurrent.Promise<A> promise;
+        private final CompletableFuture<A> future;
 
-        private RedeemablePromise(scala.concurrent.Promise<A> promise) {
-            super(FPromiseHelper.getFuture(promise));
+        private RedeemablePromise(CompletableFuture<A> future) {
+            super(future);
 
-            this.promise = promise;
+            this.future = future;
         }
 
         /**
          * Creates a new Promise with no value
          */
         public static <A> RedeemablePromise<A> empty() {
-            scala.concurrent.Promise<A> p = FPromiseHelper.empty();
-            return new RedeemablePromise(p);
+            return new RedeemablePromise<>(new CompletableFuture<>());
         }
 
         /**
@@ -520,7 +902,9 @@ public class F {
          * @param a The value to complete with
          */
         public void success(A a) {
-            this.promise.success(a);
+            if (!future.complete(a)) {
+                throw new IllegalStateException("RedeemablePromise already completed.");
+            }
         }
 
         /**
@@ -529,7 +913,9 @@ public class F {
          * @param t The exception to fail the promise with
          */
         public void failure(Throwable t) {
-            this.promise.failure(t);
+            if (!future.completeExceptionally(t)) {
+                throw new IllegalStateException("RedeemablePromise already completed.");
+            }
         }
 
         /**
@@ -540,8 +926,20 @@ public class F {
          *         promise. If the completion was successful then the result will be a null value,
          *         if the completion failed then the result will be an IllegalStateException.
          */
-        public Promise<Void> completeWith(Promise other) {
-            return this.completeWith(other, HttpExecution.defaultContext());
+        public Promise<Void> completeWith(CompletionStage<? extends A> other) {
+            return new Promise<>(other.handle((a, error) -> {
+                boolean completed;
+                if (error != null) {
+                    completed = future.completeExceptionally(error);
+                } else {
+                    completed = future.complete(a);
+                }
+                if (!completed) {
+                    throw new IllegalStateException("RedeemablePromise already completed.");
+                } else {
+                    return null;
+                }
+            }));
         }
 
         /**
@@ -553,8 +951,20 @@ public class F {
          *         promise. If the completion was successful then the result will be a null value,
          *         if the completion failed then the result will be an IllegalStateException.
          */
-        public Promise<Void> completeWith(Promise other, ExecutionContext ec) {
-            return Promise.wrap(FPromiseHelper.completeWith(this.promise, other.future, ec));
+        public Promise<Void> completeWith(CompletionStage<? extends A> other, ExecutionContext ec) {
+            return new Promise<>(other.handleAsync((a, error) -> {
+                boolean completed;
+                if (error != null) {
+                    completed = future.completeExceptionally(error);
+                } else {
+                    completed = future.complete(a);
+                }
+                if (!completed) {
+                    throw new IllegalStateException("RedeemablePromise already completed.");
+                } else {
+                    return null;
+                }
+            }, toExecutor(ec)));
         }
 
         /**
@@ -565,8 +975,14 @@ public class F {
          *         promise. If the completion was successful then the result will be true, if the
          *         completion couldn't occur then the result will be false.
          */
-        public Promise<Boolean> tryCompleteWith(Promise other) {
-            return this.tryCompleteWith(other, HttpExecution.defaultContext());
+        public Promise<Boolean> tryCompleteWith(Promise<? extends A> other) {
+            return new Promise<>(other.handle((a, error) -> {
+                if (error != null) {
+                    return future.completeExceptionally(error);
+                } else {
+                    return future.complete(a);
+                }
+            }));
         }
 
         /**
@@ -578,8 +994,14 @@ public class F {
          *         promise. If the completion was successful then the result will be true, if the
          *         completion couldn't occur then the result will be false.
          */
-        public Promise<Boolean> tryCompleteWith(Promise other, ExecutionContext ec) {
-            return Promise.wrap(FPromiseHelper.tryCompleteWith(this.promise, other.future, ec));
+        public Promise<Boolean> tryCompleteWith(Promise<? extends A> other, ExecutionContext ec) {
+            return new Promise<>(other.handleAsync((a, error) -> {
+                if (error != null) {
+                    return future.completeExceptionally(error);
+                } else {
+                    return future.complete(a);
+                }
+            }, toExecutor(ec)));
         }
     }
 
@@ -883,4 +1305,16 @@ public class F {
         return new Tuple5<A, B, C, D, E>(a, b, c, d, e);
     }
 
+    /**
+     * Converts the execution context to an executor, preparing it first.
+     */
+    private static Executor toExecutor(ExecutionContext ec) {
+        ExecutionContext prepared = ec.prepare();
+        if (prepared instanceof Executor) {
+            return (Executor) prepared;
+        } else {
+            return prepared::execute;
+        }
+    }
+
 }
diff --git a/framework/src/play/src/main/java/play/libs/concurrent/Futures.java b/framework/src/play/src/main/java/play/libs/concurrent/Futures.java
new file mode 100644
index 0000000000..9fbdb12ef7
--- /dev/null
+++ b/framework/src/play/src/main/java/play/libs/concurrent/Futures.java
@@ -0,0 +1,104 @@
+package play.libs.concurrent;
+
+import play.libs.F;
+import play.libs.F.Promise;
+
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+
+/**
+ * Utilities for creating {@link java.util.concurrent.CompletionStage}.
+ */
+public class Futures {
+
+    private static Timer timer = new Timer(true);
+
+    /**
+     * Combine the given promises into a single promise for the list of results.
+     *
+     * The sequencing operations are performed in the default ExecutionContext.
+     *
+     * @param promises The promises to combine
+     * @return A single promise whose methods act on the list of redeemed promises
+     */
+    public static <A> Promise<List<A>> sequence(Iterable<? extends CompletionStage<A>> promises) {
+        CompletableFuture<List<A>> result = CompletableFuture.completedFuture(new ArrayList<>());
+        for (CompletionStage<A> promise: promises) {
+            result = result.thenCombine(promise, (list, a) -> {
+                list.add(a);
+                return list;
+            });
+        }
+        return Promise.wrap(result);
+    }
+
+    /**
+     * Combine the given promises into a single promise for the list of results.
+     *
+     * The sequencing operations are performed in the default ExecutionContext.
+     *
+     * @param promises The promises to combine
+     * @return A single promise whose methods act on the list of redeemed promises
+     */
+    public static <A> Promise<List<A>> sequence(CompletionStage<A>... promises) {
+        return sequence(Arrays.asList(promises));
+    }
+
+    /**
+     * Create a Promise that is redeemed after a timeout.
+     *
+     * @param message The message to use to redeem the Promise.
+     * @param delay The delay (expressed with the corresponding unit).
+     * @param unit The Unit.
+     */
+    public static <A> Promise<A> timeout(A message, long delay, TimeUnit unit) {
+        CompletableFuture<A> future = new CompletableFuture<>();
+        timer.schedule(new TimerTask() {
+            @Override
+            public void run() {
+                future.complete(message);
+            }
+        }, unit.toMillis(delay));
+        return Promise.wrap(future);
+    }
+
+    /**
+     * Create a Promise timer that throws a PromiseTimeoutException after
+     * a given timeout.
+     *
+     * The returned Promise is usually combined with other Promises.
+     *
+     * @param delay The delay (expressed with the corresponding unit).
+     * @param unit The Unit.
+     * @return a promise without a real value
+     */
+    public static Promise<Void> timeout(long delay, TimeUnit unit) {
+        return timeout(null, delay, unit).thenApply(n -> {
+            throw new F.PromiseTimeoutException("Timeout in promise");
+        });
+    }
+
+    /**
+     * Create a Promise which, after a delay, will be redeemed with the result of a
+     * given supplier. The supplier will be called after the delay.
+     *
+     * @param supplier The supplier to call to fulfill the Promise.
+     * @param delay The time to wait.
+     * @param unit The units to use for the delay.
+     * @param executor The executor to run the supplier in.
+     */
+    public static <A> Promise<A> delayed(Supplier<A> supplier, long delay, TimeUnit unit, Executor executor) {
+        CompletableFuture<A> future = new CompletableFuture<>();
+        timer.schedule(new TimerTask() {
+            @Override
+            public void run() {
+                executor.execute(() -> future.complete(supplier.get()));
+            }
+        }, unit.toMillis(delay));
+        return Promise.wrap(future);
+    }
+}
diff --git a/framework/src/play/src/main/java/play/libs/HttpExecution.java b/framework/src/play/src/main/java/play/libs/concurrent/HttpExecution.java
similarity index 72%
rename from framework/src/play/src/main/java/play/libs/HttpExecution.java
rename to framework/src/play/src/main/java/play/libs/concurrent/HttpExecution.java
index 3fd1ead53f..e843c582ff 100644
--- a/framework/src/play/src/main/java/play/libs/HttpExecution.java
+++ b/framework/src/play/src/main/java/play/libs/concurrent/HttpExecution.java
@@ -1,13 +1,15 @@
 /*
  * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
  */
-package play.libs;
+package play.libs.concurrent;
 
 import play.core.Execution;
 import play.core.j.HttpExecutionContext;
 import scala.concurrent.ExecutionContext;
 import scala.concurrent.ExecutionContextExecutor;
 
+import java.util.concurrent.Executor;
+
 /**
  * ExecutionContexts that preserve the current thread's context ClassLoader and
  * Http.Context.
@@ -23,6 +25,15 @@ public class HttpExecution {
         return HttpExecutionContext.fromThread(delegate);
     }
 
+    /**
+     * An ExecutionContext that executes work on the given ExecutionContext. The
+     * current thread's context ClassLoader and Http.Context are captured when
+     * this method is called and preserved for all executed tasks.
+     */
+    public static ExecutionContextExecutor fromThread(Executor delegate) {
+        return HttpExecutionContext.fromThread(delegate);
+    }
+
     /**
      * An ExecutionContext that executes work on the application's internal
      * ActorSystem dispatcher. The current thread's context ClassLoader and
diff --git a/framework/src/play/src/main/java/play/libs/concurrent/HttpExecutionContext.java b/framework/src/play/src/main/java/play/libs/concurrent/HttpExecutionContext.java
new file mode 100644
index 0000000000..3085886113
--- /dev/null
+++ b/framework/src/play/src/main/java/play/libs/concurrent/HttpExecutionContext.java
@@ -0,0 +1,47 @@
+package play.libs.concurrent;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import java.util.concurrent.Executor;
+
+/**
+ * Execution context for managing Play Java HTTP thread local state.
+ *
+ * This is essentially a factory for getting an executor for the current HTTP context.  Tasks executed by that executor
+ * will have the HTTP context setup in them.
+ *
+ * For example, it may be used in combination with <code>CompletionStage.thenApplyAsync</code>, to ensure the callbacks
+ * executed when the completion stage is redeemed have the correct context:
+ *
+ * <pre>
+ *     CompletionStage&lt;WSResponse&gt; response = ws.url(...).get();
+ *     CompletionStage&lt;Result&gt; result = response.thenApplyAsync(response -&gt; {
+ *         return ok("Got response body " + ws.body() + " while executing request " + request().uri());
+ *     }, httpExecutionContext.current());
+ * </pre>
+ *
+ * Note, this is not a Scala execution context, and is not intended to be used where Scala execution contexts are
+ * required.
+ */
+@Singleton
+public class HttpExecutionContext {
+
+    private final Executor delegate;
+
+    @Inject
+    public HttpExecutionContext(Executor delegate) {
+        this.delegate = delegate;
+    }
+
+    /**
+     * Get the current executor associated with the current HTTP context.
+     *
+     * Note that the returned executor is only valid for the current context.  It should be used in a transient
+     * fashion, long lived references to it should not be kept.
+     *
+     * @return An executor that will execute its tasks in the current HTTP context.
+     */
+    public Executor current() {
+        return HttpExecution.fromThread(delegate);
+    }
+}
diff --git a/framework/src/play/src/main/java/play/mvc/Action.java b/framework/src/play/src/main/java/play/mvc/Action.java
index 885a2c6897..77beffc341 100644
--- a/framework/src/play/src/main/java/play/mvc/Action.java
+++ b/framework/src/play/src/main/java/play/mvc/Action.java
@@ -4,7 +4,8 @@
 package play.mvc;
 
 import play.mvc.Http.*;
-import static play.libs.F.Promise;
+
+import java.util.concurrent.CompletionStage;
 
 /**
  * An action acts as decorator for the action method call.
@@ -24,7 +25,7 @@ public abstract class Action<T> extends Results {
     /**
      * Executes this action with the given HTTP context and returns the result.
      */
-    public abstract Promise<Result> call(Context ctx);
+    public abstract CompletionStage<Result> call(Context ctx);
     
     /**
      * A simple action with no configuration.
diff --git a/framework/src/play/src/main/java/play/mvc/BodyParser.java b/framework/src/play/src/main/java/play/mvc/BodyParser.java
index dd7dd75b32..a218363746 100644
--- a/framework/src/play/src/main/java/play/mvc/BodyParser.java
+++ b/framework/src/play/src/main/java/play/mvc/BodyParser.java
@@ -359,9 +359,8 @@ public interface BodyParser<A> {
                             .transform(() -> new BodyParsers$.TakeUpTo(maxLength))
             ).recoverWith(exception -> {
                 if (exception instanceof play.api.mvc.BodyParsers$.MaxLengthLimitAttained) {
-                    return FutureConverters.toJava(
-                            errorHandler.onClientError(request, Status$.MODULE$.REQUEST_ENTITY_TOO_LARGE(), "Request entity too large")
-                                    .map(F.Either::<Result, A>Left).wrapped());
+                    return errorHandler.onClientError(request, Status$.MODULE$.REQUEST_ENTITY_TOO_LARGE(), "Request entity too large")
+                            .thenApply(F.Either::<Result, A>Left);
                 } else {
                     CompletableFuture<F.Either<Result, A>> cf = new CompletableFuture<>();
                     cf.completeExceptionally(exception);
@@ -400,7 +399,7 @@ public interface BodyParser<A> {
                 try {
                     return CompletableFuture.completedFuture(F.Either.Right(parse(request, bytes)));
                 } catch (Exception e) {
-                    return FutureConverters.toJava(errorHandler.onClientError(request, Status$.MODULE$.BAD_REQUEST(), errorMessage + ": " + e.getMessage()).wrapped())
+                    return errorHandler.onClientError(request, Status$.MODULE$.BAD_REQUEST(), errorMessage + ": " + e.getMessage())
                             .thenApply(F.Either::<Result, A>Left);
                 }
             }, JavaParsers.trampoline());
diff --git a/framework/src/play/src/main/java/play/mvc/BodyParsers.java b/framework/src/play/src/main/java/play/mvc/BodyParsers.java
index 65daa7e2ab..bd5b0a5f64 100644
--- a/framework/src/play/src/main/java/play/mvc/BodyParsers.java
+++ b/framework/src/play/src/main/java/play/mvc/BodyParsers.java
@@ -34,9 +34,8 @@ public class BodyParsers {
         if (request.contentType().map(validate).orElse(false)) {
             return parser.apply(request);
         } else {
-            CompletionStage<Result> result = FutureConverters.toJava(
-                    errorHandler.onClientError(request, Status$.MODULE$.UNSUPPORTED_MEDIA_TYPE(), errorMessage).wrapped()
-            );
+            CompletionStage<Result> result =
+                    errorHandler.onClientError(request, Status$.MODULE$.UNSUPPORTED_MEDIA_TYPE(), errorMessage);
             return Accumulator.done(result.thenApply(F.Either::Left));
         }
     }
diff --git a/framework/src/play/src/main/java/play/mvc/Security.java b/framework/src/play/src/main/java/play/mvc/Security.java
index 112017f951..d55def0179 100644
--- a/framework/src/play/src/main/java/play/mvc/Security.java
+++ b/framework/src/play/src/main/java/play/mvc/Security.java
@@ -8,6 +8,7 @@ import play.libs.F;
 import play.mvc.Http.*;
 
 import java.lang.annotation.*;
+import java.util.concurrent.CompletionStage;
 import javax.inject.Inject;
 
 /**
@@ -40,7 +41,7 @@ public class Security {
             this.injector = injector;
         }
 
-        public F.Promise<Result> call(final Context ctx) {
+        public CompletionStage<Result> call(final Context ctx) {
             try {
                 Authenticator authenticator = injector.instanceOf(configuration.value());
                 String username = authenticator.getUsername(ctx);
@@ -50,15 +51,8 @@ public class Security {
                 } else {
                     try {
                         ctx.request().setUsername(username);
-                        return delegate.call(ctx).transform(
-                            result -> {
-                                ctx.request().setUsername(null);
-                                return result;
-                            },
-                            throwable -> {
-                                ctx.request().setUsername(null);
-                                return throwable;
-                            }
+                        return delegate.call(ctx).whenComplete(
+                                (result, error) -> ctx.request().setUsername(null)
                         );
                     } catch(Exception e) {
                         ctx.request().setUsername(null);
diff --git a/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala b/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
index 66cbb4fbc2..beda3dee71 100644
--- a/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
+++ b/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
@@ -16,6 +16,7 @@ import play.core.SourceMapper
 import play.mvc.Http
 import play.utils.{ Reflect, PlayIO }
 
+import scala.compat.java8.FutureConverters
 import scala.concurrent._
 import scala.util.control.NonFatal
 
@@ -303,8 +304,8 @@ private[play] class JavaHttpErrorHandlerDelegate @Inject() (delegate: HttpErrorH
   import play.api.libs.iteratee.Execution.Implicits.trampoline
 
   def onClientError(request: Http.RequestHeader, statusCode: Int, message: String) =
-    play.libs.F.Promise.wrap(delegate.onClientError(request._underlyingHeader(), statusCode, message).map(_.asJava))
+    FutureConverters.toJava(delegate.onClientError(request._underlyingHeader(), statusCode, message).map(_.asJava))
 
   def onServerError(request: Http.RequestHeader, exception: Throwable) =
-    play.libs.F.Promise.wrap(delegate.onServerError(request._underlyingHeader(), exception).map(_.asJava))
+    FutureConverters.toJava(delegate.onServerError(request._underlyingHeader(), exception).map(_.asJava))
 }
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/inject/ApplicationLifecycle.scala b/framework/src/play/src/main/scala/play/api/inject/ApplicationLifecycle.scala
index 443c917b87..69ad467386 100644
--- a/framework/src/play/src/main/scala/play/api/inject/ApplicationLifecycle.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/ApplicationLifecycle.scala
@@ -3,12 +3,12 @@
  */
 package play.api.inject
 
-import java.util.concurrent.Callable
+import java.util.concurrent.{ CompletionStage, Callable }
 
 import javax.inject.Singleton
 import play.api.Logger
-import play.libs.F
 
+import scala.compat.java8.FutureConverters
 import scala.concurrent.Future
 
 /**
@@ -62,8 +62,9 @@ trait ApplicationLifecycle {
    * The stop hook should redeem the returned future when it is finished shutting down.  It is acceptable to stop
    * immediately and return a successful future.
    */
-  def addStopHook(hook: Callable[F.Promise[_]]): Unit =
-    addStopHook(() => hook.call().wrapped())
+  def addStopHook(hook: Callable[_ <: CompletionStage[_]]): Unit = {
+    addStopHook(() => FutureConverters.toScala(hook.call().asInstanceOf[CompletionStage[_]]))
+  }
 }
 
 /**
diff --git a/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala b/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
index e3a654b7dc..a06609b0a8 100644
--- a/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
@@ -14,6 +14,7 @@ import play.api.libs.Files.{ DefaultTemporaryFileCreator, TemporaryFileCreator }
 import play.api.libs.{ CryptoConfig, Crypto, CryptoConfigParser }
 import play.api.libs.concurrent.{ MaterializerProvider, ExecutionContextProvider, ActorSystemProvider }
 import play.api.routing.Router
+import play.libs.concurrent.HttpExecutionContext
 
 import scala.concurrent.ExecutionContext
 
@@ -48,6 +49,7 @@ class BuiltinModule extends Module {
       bind[Materializer].toProvider[MaterializerProvider],
       bind[ExecutionContext].toProvider[ExecutionContextProvider],
       bind[Executor].toProvider[ExecutionContextProvider],
+      bind[HttpExecutionContext].toSelf,
       bind[Plugins].toProvider[PluginsProvider],
 
       bind[CryptoConfig].toProvider[CryptoConfigParser],
diff --git a/framework/src/play/src/main/scala/play/api/inject/guice/GuiceApplicationBuilder.scala b/framework/src/play/src/main/scala/play/api/inject/guice/GuiceApplicationBuilder.scala
index f732dafa1a..b135595fac 100644
--- a/framework/src/play/src/main/scala/play/api/inject/guice/GuiceApplicationBuilder.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/guice/GuiceApplicationBuilder.scala
@@ -3,9 +3,12 @@
  */
 package play.api.inject.guice
 
+import javax.inject.{ Provider, Inject }
+
 import com.google.inject.{ Module => GuiceModule }
+import play.api.routing.Router
 import play.api.{ Application, Configuration, Environment, GlobalSettings, Logger, OptionalSourceMapper }
-import play.api.inject.{ bind, Injector => PlayInjector }
+import play.api.inject.{ Injector => PlayInjector, RoutesProvider, bind }
 import play.core.{ DefaultWebCommands, WebCommands }
 
 /**
@@ -61,6 +64,19 @@ final class GuiceApplicationBuilder(
   def load(modules: GuiceableModule*): GuiceApplicationBuilder =
     load((env, conf) => modules)
 
+  /**
+   * Override the router with the given router.
+   */
+  def router(router: Router): GuiceApplicationBuilder =
+    overrides(bind[Router].toInstance(router))
+
+  /**
+   * Override the router with a router that first tries to route to the passed in additional router, before falling
+   * back to the default router.
+   */
+  def additionalRouter(router: Router): GuiceApplicationBuilder =
+    overrides(bind[Router].to(new AdditionalRouterProvider(router)))
+
   /**
    * Create a new Play application Module for an Application using this configured builder.
    */
@@ -120,3 +136,8 @@ final class GuiceApplicationBuilder(
     eagerly: Boolean): GuiceApplicationBuilder =
     copy(environment, configuration, modules, overrides, disabled, eagerly)
 }
+
+private class AdditionalRouterProvider(additional: Router) extends Provider[Router] {
+  @Inject private var fallback: RoutesProvider = _
+  lazy val get = Router.from(additional.routes.orElse(fallback.get.routes))
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/core/j/FPromiseHelper.scala b/framework/src/play/src/main/scala/play/core/j/FPromiseHelper.scala
deleted file mode 100644
index e20e7ed356..0000000000
--- a/framework/src/play/src/main/scala/play/core/j/FPromiseHelper.scala
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
- */
-package play.core.j
-
-import java.lang.{ Iterable => JIterable }
-import java.util.{ List => JList, Timer, TimerTask }
-import java.util.concurrent.{ Callable, TimeoutException, TimeUnit }
-import java.util.function.{ Consumer, Function => JFunction, Predicate, Supplier }
-import play.api.libs.concurrent.{ Promise => DeprecatedPlayPromise }
-import play.api.libs.iteratee.Execution
-import play.libs.F
-import scala.collection.JavaConverters
-import scala.concurrent.{ Await, ExecutionContext, Future, Promise }
-import scala.concurrent.duration.{ Duration, MILLISECONDS }
-import scala.util.{ Failure, Success, Try }
-import play.core.Execution.internalContext
-
-/**
- * Support code for the play.libs.F.Promise class. All public methods of this
- * object are used by F.Promise to implement its methods.
- */
-private[play] object FPromiseHelper {
-
-  private val timer = new Timer(true)
-
-  def pure[A](a: A): F.Promise[A] = F.Promise.wrap(Future.successful(a))
-
-  def throwing[A](t: Throwable): F.Promise[A] = F.Promise.wrap(Future.failed(t))
-
-  // For deprecated method in play.libs.Akka
-  def promise[A](callable: Callable[A], ec: ExecutionContext): F.Promise[A] =
-    F.Promise.wrap(Future(callable.call())(ec.prepare()))
-
-  def promise[A](function: Supplier[A], ec: ExecutionContext): F.Promise[A] =
-    F.Promise.wrap(Future(function.get())(ec.prepare()))
-
-  private def delayedWith[A](f: => A, delay: Long, unit: TimeUnit, ec: ExecutionContext): F.Promise[A] = {
-    val pec = ec.prepare()
-    val p = Promise[A]()
-    timer.schedule(new TimerTask {
-      def run() { p.completeWith(Future(f)(pec)) }
-    }, unit.toMillis(delay))
-    F.Promise.wrap[A](p.future)
-  }
-
-  def delayed[A](callable: Callable[A], duration: Long, unit: TimeUnit, ec: ExecutionContext): F.Promise[A] =
-    delayedWith(callable.call(), duration, unit, ec)
-
-  def delayed[A](function: Supplier[A], duration: Long, unit: TimeUnit, ec: ExecutionContext): F.Promise[A] =
-    delayedWith(function.get(), duration, unit, ec)
-
-  def get[A](promise: F.Promise[A], timeout: Long, unit: TimeUnit): A = {
-    try {
-      Await.result(promise.wrapped(), Duration(timeout, unit))
-    } catch {
-      case ex: TimeoutException => throw new F.PromiseTimeoutException(ex.getMessage, ex)
-    }
-  }
-
-  def or[A, B](left: F.Promise[A], right: F.Promise[B]): F.Promise[F.Either[A, B]] = {
-    import Execution.Implicits.trampoline
-    val p = Promise[F.Either[A, B]]
-    left.wrapped.onComplete {
-      case tryA => p.tryComplete(tryA.map(F.Either.Left[A, B](_)))
-    }
-    right.wrapped.onComplete {
-      case tryB => p.tryComplete(tryB.map(F.Either.Right[A, B](_)))
-    }
-    F.Promise.wrap(p.future)
-  }
-
-  def zip[A, B](pa: F.Promise[A], pb: F.Promise[B]): F.Promise[F.Tuple[A, B]] = {
-    import Execution.Implicits.trampoline
-    val future = pa.wrapped.zip(pb.wrapped).map { case (a, b) => new F.Tuple(a, b) }
-    F.Promise.wrap(future)
-  }
-
-  def sequence[A](promises: JIterable[F.Promise[A]], ec: ExecutionContext): F.Promise[JList[A]] = {
-    val futures = JavaConverters.iterableAsScalaIterableConverter(promises).asScala.toBuffer.map((_: F.Promise[A]).wrapped)
-    implicit val pec = ec.prepare() // Easiest to provide implicitly so don't need to provide other implicit arg to sequence method
-    F.Promise.wrap(Future.sequence(futures).map(az => JavaConverters.bufferAsJavaListConverter(az).asJava))
-  }
-
-  private def timeoutWith[A](result: Try[A], delay: Long, unit: TimeUnit): F.Promise[A] = {
-    val p = Promise[A]()
-    timer.schedule(new TimerTask {
-      def run() { p.complete(result) }
-    }, unit.toMillis(delay))
-    F.Promise.wrap[A](p.future)
-  }
-
-  def timeout[A](message: A, delay: Long, unit: TimeUnit): F.Promise[A] =
-    timeoutWith(Success(message), delay, unit)
-
-  def timeout[A](delay: Long, unit: TimeUnit): F.Promise[A] =
-    timeoutWith(Failure(new F.PromiseTimeoutException("Timeout in promise")), delay, unit)
-
-  def onRedeem[A](promise: F.Promise[A], action: Consumer[A], ec: ExecutionContext): Unit =
-    promise.wrapped().onSuccess { case a => action.accept(a) }(ec.prepare())
-
-  def map[A, B, T >: A](promise: F.Promise[A], function: JFunction[T, B], ec: ExecutionContext): F.Promise[B] =
-    F.Promise.wrap[B](promise.wrapped().map((a: A) => function.apply(a))(ec.prepare()))
-
-  def flatMap[A, B, T >: A](promise: F.Promise[A], function: JFunction[T, F.Promise[B]], ec: ExecutionContext): F.Promise[B] =
-    F.Promise.wrap[B](promise.wrapped().flatMap((a: A) => function.apply(a).wrapped())(ec.prepare()))
-
-  def filter[A, T >: A](promise: F.Promise[A], predicate: Predicate[T], ec: ExecutionContext): F.Promise[A] =
-    F.Promise.wrap[A](promise.wrapped().filter(predicate.test)(ec.prepare()))
-
-  def recover[A](promise: F.Promise[A], function: JFunction[Throwable, A], ec: ExecutionContext): F.Promise[A] =
-    F.Promise.wrap[A](promise.wrapped().recover { case t => function.apply(t) }(ec.prepare()))
-
-  def recoverWith[A](promise: F.Promise[A], function: JFunction[Throwable, F.Promise[A]], ec: ExecutionContext): F.Promise[A] =
-    F.Promise.wrap[A](promise.wrapped().recoverWith { case t => function.apply(t).wrapped() }(ec.prepare()))
-
-  def fallbackTo[A](promise: F.Promise[A], fallback: F.Promise[A]): F.Promise[A] =
-    F.Promise.wrap[A](promise.wrapped.fallbackTo(fallback.wrapped))
-
-  def onFailure[A](promise: F.Promise[A], action: Consumer[Throwable], ec: ExecutionContext) {
-    promise.wrapped().onFailure { case t => action.accept(t) }(ec.prepare())
-  }
-
-  def transform[A, B, T >: A](promise: F.Promise[A], s: JFunction[T, B], f: JFunction[Throwable, Throwable], ec: ExecutionContext): F.Promise[B] =
-    F.Promise.wrap[B](promise.wrapped.transform(s.apply, f.apply)(ec.prepare()))
-
-  def empty[A]() = {
-    Promise[A]()
-  }
-
-  def getFuture[A](promise: Promise[A]): Future[A] = promise.future
-
-  def completeWith[T](promise: Promise[T], other: Future[T], ec: ExecutionContext): Future[Void] = {
-    val p = Promise[Unit]
-    other.onComplete { x =>
-      p.complete(Try(promise complete x))
-    }(ec)
-    p.future.map(_ => null)(ec)
-  }
-
-  def tryCompleteWith[T](promise: Promise[T], other: Future[T], ec: ExecutionContext): Future[Boolean] = {
-    val p = Promise[Boolean]
-    other.onComplete { x =>
-      p.complete(Try(promise tryComplete x))
-    }(ec)
-    p.future
-  }
-}
-
diff --git a/framework/src/play/src/main/scala/play/core/j/HttpExecutionContext.scala b/framework/src/play/src/main/scala/play/core/j/HttpExecutionContext.scala
index bc3ff177c3..6f8fb1dae8 100644
--- a/framework/src/play/src/main/scala/play/core/j/HttpExecutionContext.scala
+++ b/framework/src/play/src/main/scala/play/core/j/HttpExecutionContext.scala
@@ -3,7 +3,10 @@
  */
 package play.core.j
 
+import java.util.concurrent.Executor
+
 import play.mvc.Http
+import scala.compat.java8.FutureConverters
 import scala.concurrent.{ ExecutionContext, ExecutionContextExecutor }
 
 object HttpExecutionContext {
@@ -14,6 +17,19 @@ object HttpExecutionContext {
   def fromThread(delegate: ExecutionContext): ExecutionContextExecutor =
     new HttpExecutionContext(Thread.currentThread().getContextClassLoader(), Http.Context.current.get(), delegate)
 
+  /**
+   * Create an HttpExecutionContext with values from the current thread.
+   *
+   * This method is necessary to prevent ambiguous method compile errors since ExecutionContextExecutor
+   */
+  def fromThread(delegate: ExecutionContextExecutor): ExecutionContextExecutor = fromThread(delegate: ExecutionContext)
+
+  /**
+   * Create an HttpExecutionContext with values from the current thread.
+   */
+  def fromThread(delegate: Executor): ExecutionContextExecutor =
+    new HttpExecutionContext(Thread.currentThread().getContextClassLoader(), Http.Context.current.get(), FutureConverters.fromExecutor(delegate))
+
   /**
    * Create an ExecutionContext that will, when prepared, be created with values from that thread.
    */
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaAction.scala b/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
index 73cc8a66d4..cce9a5ddd2 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
@@ -3,18 +3,19 @@
  */
 package play.core.j
 
+import java.util.concurrent.CompletionStage
 import javax.inject.Inject
 
-import play.api.http.{ HttpConfiguration, HttpRequestHandler }
-import play.api.inject.{ Injector, NewInstanceInjector }
+import play.api.http.HttpConfiguration
+import play.api.inject.Injector
 
+import scala.compat.java8.FutureConverters
 import scala.language.existentials
 
 import play.api.libs.iteratee.Execution.trampoline
 import play.api.mvc._
 import play.mvc.{ Action => JAction, Result => JResult, BodyParser => JBodyParser }
 import play.mvc.Http.{ Context => JContext }
-import play.libs.F.{ Promise => JPromise }
 import scala.concurrent.{ ExecutionContext, Future }
 
 /**
@@ -35,9 +36,9 @@ class JavaActionAnnotations(val controller: Class[_], val method: java.lang.refl
 
   val actionMixins = {
     val allDeclaredAnnotations: Seq[java.lang.annotation.Annotation] = if (HttpConfiguration.current.actionComposition.controllerAnnotationsFirst) {
-      (controllerAnnotations ++ method.getDeclaredAnnotations)
+      controllerAnnotations ++ method.getDeclaredAnnotations
     } else {
-      (method.getDeclaredAnnotations ++ controllerAnnotations)
+      method.getDeclaredAnnotations ++ controllerAnnotations
     }
     allDeclaredAnnotations.collect {
       case a: play.mvc.With => a.value.map(c => (a, c)).toSeq
@@ -52,7 +53,7 @@ class JavaActionAnnotations(val controller: Class[_], val method: java.lang.refl
  */
 abstract class JavaAction(components: JavaHandlerComponents) extends Action[play.mvc.Http.RequestBody] with JavaHelpers {
 
-  def invocation: JPromise[JResult]
+  def invocation: CompletionStage[JResult]
   val annotations: JavaActionAnnotations
 
   def apply(req: Request[play.mvc.Http.RequestBody]): Future[Result] = {
@@ -60,7 +61,7 @@ abstract class JavaAction(components: JavaHandlerComponents) extends Action[play
     val javaContext: JContext = createJavaContext(req)
 
     val rootAction = new JAction[Any] {
-      def call(ctx: JContext): JPromise[JResult] = {
+      def call(ctx: JContext): CompletionStage[JResult] = {
         // The context may have changed, set it again
         val oldContext = JContext.current.get()
         try {
@@ -89,7 +90,7 @@ abstract class JavaAction(components: JavaHandlerComponents) extends Action[play
       val javaClassLoader = Thread.currentThread.getContextClassLoader
       new HttpExecutionContext(javaClassLoader, javaContext, trampoline)
     }
-    val actionFuture: Future[Future[JResult]] = Future { finalAction.call(javaContext).wrapped }(trampolineWithContext)
+    val actionFuture: Future[Future[JResult]] = Future { FutureConverters.toScala(finalAction.call(javaContext)) }(trampolineWithContext)
     val flattenedActionFuture: Future[JResult] = actionFuture.flatMap(identity)(trampoline)
     val resultFuture: Future[Result] = flattenedActionFuture.map(createResult(javaContext, _))(trampoline)
     resultFuture
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
index afd4a5c61e..175170656e 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
@@ -3,14 +3,15 @@
  */
 package play.core.j
 
-import play.libs.F
+import java.util.concurrent.CompletionStage
+
 import play.api.libs.iteratee.Execution.trampoline
 import play.api.mvc._
 import play.mvc.{ Result => JResult }
 import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestImpl => JRequestImpl, RequestHeader => JRequestHeader, Cookies => JCookies, Cookie => JCookie }
 import play.mvc.Http.RequestBody
 
-import scala.compat.java8.OptionConverters
+import scala.compat.java8.{ FutureConverters, OptionConverters }
 import scala.concurrent.Future
 import collection.JavaConverters._
 
@@ -115,11 +116,11 @@ trait JavaHelpers {
    * @param f The function to invoke
    * @return The result
    */
-  def invokeWithContextOpt(request: RequestHeader, f: JRequest => F.Promise[JResult]): Option[Future[Result]] = {
+  def invokeWithContextOpt(request: RequestHeader, f: JRequest => CompletionStage[JResult]): Option[Future[Result]] = {
     val javaContext = createJavaContext(request)
     try {
       JContext.current.set(javaContext)
-      Option(f(javaContext.request())).map(_.wrapped.map(createResult(javaContext, _))(trampoline))
+      Option(f(javaContext.request())).map(cs => FutureConverters.toScala(cs).map(createResult(javaContext, _))(trampoline))
     } finally {
       JContext.current.remove()
     }
@@ -136,9 +137,9 @@ trait JavaHelpers {
    * @param f The function to invoke
    * @return The result
    */
-  def invokeWithContext(request: RequestHeader, f: JRequest => F.Promise[JResult]): Future[Result] = {
+  def invokeWithContext(request: RequestHeader, f: JRequest => CompletionStage[JResult]): Future[Result] = {
     withContext(request) { javaContext =>
-      f(javaContext.request()).wrapped.map(createResult(javaContext, _))(trampoline)
+      FutureConverters.toScala(f(javaContext.request())).map(createResult(javaContext, _))(trampoline)
     }
   }
 
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala b/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
index e95860c5b0..6943a41ad2 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
@@ -3,6 +3,8 @@
  */
 package play.core.j
 
+import java.util.concurrent.{ CompletableFuture, CompletionStage }
+
 import akka.actor.Status
 import akka.stream.OverflowStrategy
 import akka.stream.scaladsl.{ Keep, Source, Flow, Sink }
@@ -11,10 +13,9 @@ import play.api.mvc.WebSocket.MessageFlowTransformer
 import play.api.mvc._
 import play.mvc.Http.{ Context => JContext }
 import play.mvc.{ WebSocket => JWebSocket, LegacyWebSocket }
-import play.libs.F.{ Promise => JPromise }
 import scala.collection.JavaConverters._
+import scala.compat.java8.FutureConverters
 
-import scala.concurrent.Future
 import com.fasterxml.jackson.databind.JsonNode
 import play.api.libs.concurrent.Akka
 
@@ -26,13 +27,13 @@ import play.core.Execution.Implicits.internalContext
  */
 object JavaWebSocket extends JavaHelpers {
 
-  def webSocketWrapper[A](retrieveWebSocket: => Future[LegacyWebSocket[A]])(implicit transformer: MessageFlowTransformer[A, A]): WebSocket = WebSocket { request =>
+  def webSocketWrapper[A](retrieveWebSocket: => CompletionStage[LegacyWebSocket[A]])(implicit transformer: MessageFlowTransformer[A, A]): WebSocket = WebSocket { request =>
 
     val javaContext = createJavaContext(request)
 
     val javaWebSocket = try {
       JContext.current.set(javaContext)
-      retrieveWebSocket
+      FutureConverters.toScala(retrieveWebSocket)
     } finally {
       JContext.current.remove()
     }
@@ -85,18 +86,18 @@ object JavaWebSocket extends JavaHelpers {
   // -- Bytes
 
   def ofBytes(retrieveWebSocket: => LegacyWebSocket[Array[Byte]]): WebSocket =
-    webSocketWrapper[Array[Byte]](Future.successful(retrieveWebSocket))
+    webSocketWrapper[Array[Byte]](CompletableFuture.completedFuture(retrieveWebSocket))
 
-  def promiseOfBytes(retrieveWebSocket: => JPromise[LegacyWebSocket[Array[Byte]]]): WebSocket =
-    webSocketWrapper[Array[Byte]](retrieveWebSocket.wrapped())
+  def promiseOfBytes(retrieveWebSocket: => CompletionStage[LegacyWebSocket[Array[Byte]]]): WebSocket =
+    webSocketWrapper[Array[Byte]](retrieveWebSocket)
 
   // -- String
 
   def ofString(retrieveWebSocket: => LegacyWebSocket[String]): WebSocket =
-    webSocketWrapper[String](Future.successful(retrieveWebSocket))
+    webSocketWrapper[String](CompletableFuture.completedFuture(retrieveWebSocket))
 
-  def promiseOfString(retrieveWebSocket: => JPromise[LegacyWebSocket[String]]): WebSocket =
-    webSocketWrapper[String](retrieveWebSocket.wrapped())
+  def promiseOfString(retrieveWebSocket: => CompletionStage[LegacyWebSocket[String]]): WebSocket =
+    webSocketWrapper[String](retrieveWebSocket)
 
   // -- Json (JsonNode)
 
@@ -105,8 +106,8 @@ object JavaWebSocket extends JavaHelpers {
   )
 
   def ofJson(retrieveWebSocket: => LegacyWebSocket[JsonNode]): WebSocket =
-    webSocketWrapper[JsonNode](Future.successful(retrieveWebSocket))
+    webSocketWrapper[JsonNode](CompletableFuture.completedFuture(retrieveWebSocket))
 
-  def promiseOfJson(retrieveWebSocket: => JPromise[LegacyWebSocket[JsonNode]]): WebSocket =
-    webSocketWrapper[JsonNode](retrieveWebSocket.wrapped())
+  def promiseOfJson(retrieveWebSocket: => CompletionStage[LegacyWebSocket[JsonNode]]): WebSocket =
+    webSocketWrapper[JsonNode](retrieveWebSocket)
 }
diff --git a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
index 050d8e61e0..5e08fd290a 100644
--- a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
+++ b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
@@ -4,10 +4,10 @@
 package play.core.routing
 
 import java.util.Optional
+import java.util.concurrent.{CompletableFuture, CompletionStage}
 
 import akka.stream.scaladsl.Flow
 import org.apache.commons.lang3.reflect.MethodUtils
-import play.api.inject.Injector
 import play.api.mvc._
 import play.core.j
 import play.core.j.{ JavaHandlerComponents, JavaHandler, JavaActionAnnotations }
@@ -20,7 +20,7 @@ import scala.util.control.NonFatal
  * An object that, when invoked with a thunk, produces a `Handler` that wraps
  * that thunk. Constructed by a `HandlerInvokerFactory`.
  */
-trait HandlerInvoker[T] {
+trait HandlerInvoker[-T] {
   /**
    * Create a `Handler` that wraps the given thunk. The thunk won't be called
    * until the `Handler` is applied. The returned Handler will be used by
@@ -32,7 +32,7 @@ trait HandlerInvoker[T] {
 /**
  * An invoker that wraps another invoker, ensuring the request is tagged appropriately.
  */
-private class TaggingInvoker[A](underlyingInvoker: HandlerInvoker[A], handlerDef: HandlerDef) extends HandlerInvoker[A] {
+private class TaggingInvoker[-A](underlyingInvoker: HandlerInvoker[A], handlerDef: HandlerDef) extends HandlerInvoker[A] {
   import HandlerInvokerFactory._
   val cachedHandlerTags = handlerTags(handlerDef)
   def call(call: => A): Handler = {
@@ -57,7 +57,7 @@ private class TaggingInvoker[A](underlyingInvoker: HandlerInvoker[A], handlerDef
  * for an implicit `HandlerInvokerFactory` and uses that to create a `HandlerInvoker`.
  */
 @scala.annotation.implicitNotFound("Cannot use a method returning ${T} as a Handler for requests")
-trait HandlerInvokerFactory[T] {
+trait HandlerInvokerFactory[-T] {
   /**
    * Create an invoker for the given thunk that is never called.
    * @param fakeCall A simulated call to the controller method. Needed to
@@ -69,7 +69,6 @@ trait HandlerInvokerFactory[T] {
 
 object HandlerInvokerFactory {
 
-  import play.libs.F.{ Promise => JPromise }
   import play.mvc.{ Result => JResult, LegacyWebSocket, WebSocket => JWebSocket }
   import play.core.j.JavaWebSocket
   import com.fasterxml.jackson.databind.JsonNode
@@ -134,12 +133,12 @@ object HandlerInvokerFactory {
             val javaParser = components.injector.instanceOf(cachedAnnotations.parser)
             javaBodyParserToScala(javaParser)
           }
-          def invocation: JPromise[JResult] = resultCall(call)
+          def invocation: CompletionStage[JResult] = resultCall(call)
           def tagRequest(rh: RequestHeader) = taggedRequest(rh, cachedHandlerTags)
         }
       }
     }
-    def resultCall(call: => A): JPromise[JResult]
+    def resultCall(call: => A): CompletionStage[JResult]
   }
 
   private[play] def javaBodyParserToScala(parser: play.mvc.BodyParser[_]): BodyParser[RequestBody] = BodyParser { request =>
@@ -155,10 +154,10 @@ object HandlerInvokerFactory {
   }
 
   implicit def wrapJava: HandlerInvokerFactory[JResult] = new JavaActionInvokerFactory[JResult] {
-    def resultCall(call: => JResult) = JPromise.pure(call)
+    def resultCall(call: => JResult) = CompletableFuture.completedFuture(call)
   }
-  implicit def wrapJavaPromise: HandlerInvokerFactory[JPromise[JResult]] = new JavaActionInvokerFactory[JPromise[JResult]] {
-    def resultCall(call: => JPromise[JResult]) = call
+  implicit def wrapJavaPromise: HandlerInvokerFactory[CompletionStage[JResult]] = new JavaActionInvokerFactory[CompletionStage[JResult]] {
+    def resultCall(call: => CompletionStage[JResult]) = call
   }
 
   /**
@@ -184,16 +183,16 @@ object HandlerInvokerFactory {
     def webSocketCall(call: => LegacyWebSocket[JsonNode]) = JavaWebSocket.ofJson(call)
   }
 
-  implicit def javaBytesPromiseWebSocket: HandlerInvokerFactory[JPromise[LegacyWebSocket[Array[Byte]]]] = new JavaWebSocketInvokerFactory[JPromise[LegacyWebSocket[Array[Byte]]], Array[Byte]] {
-    def webSocketCall(call: => JPromise[LegacyWebSocket[Array[Byte]]]) = JavaWebSocket.promiseOfBytes(call)
+  implicit def javaBytesPromiseWebSocket: HandlerInvokerFactory[CompletionStage[LegacyWebSocket[Array[Byte]]]] = new JavaWebSocketInvokerFactory[CompletionStage[LegacyWebSocket[Array[Byte]]], Array[Byte]] {
+    def webSocketCall(call: => CompletionStage[LegacyWebSocket[Array[Byte]]]) = JavaWebSocket.promiseOfBytes(call)
   }
 
-  implicit def javaStringPromiseWebSocket: HandlerInvokerFactory[JPromise[LegacyWebSocket[String]]] = new JavaWebSocketInvokerFactory[JPromise[LegacyWebSocket[String]], String] {
-    def webSocketCall(call: => JPromise[LegacyWebSocket[String]]) = JavaWebSocket.promiseOfString(call)
+  implicit def javaStringPromiseWebSocket: HandlerInvokerFactory[CompletionStage[LegacyWebSocket[String]]] = new JavaWebSocketInvokerFactory[CompletionStage[LegacyWebSocket[String]], String] {
+    def webSocketCall(call: => CompletionStage[LegacyWebSocket[String]]) = JavaWebSocket.promiseOfString(call)
   }
 
-  implicit def javaJsonPromiseWebSocket: HandlerInvokerFactory[JPromise[LegacyWebSocket[JsonNode]]] = new JavaWebSocketInvokerFactory[JPromise[LegacyWebSocket[JsonNode]], JsonNode] {
-    def webSocketCall(call: => JPromise[LegacyWebSocket[JsonNode]]) = JavaWebSocket.promiseOfJson(call)
+  implicit def javaJsonPromiseWebSocket: HandlerInvokerFactory[CompletionStage[LegacyWebSocket[JsonNode]]] = new JavaWebSocketInvokerFactory[CompletionStage[LegacyWebSocket[JsonNode]], JsonNode] {
+    def webSocketCall(call: => CompletionStage[LegacyWebSocket[JsonNode]]) = JavaWebSocket.promiseOfJson(call)
   }
 
   implicit def javaWebSocket: HandlerInvokerFactory[JWebSocket] = new HandlerInvokerFactory[JWebSocket] {
diff --git a/framework/src/play/src/test/java/play/PromiseTest.java b/framework/src/play/src/test/java/play/PromiseTest.java
index fe2e361ef2..d475426c8e 100644
--- a/framework/src/play/src/test/java/play/PromiseTest.java
+++ b/framework/src/play/src/test/java/play/PromiseTest.java
@@ -286,7 +286,7 @@ public class PromiseTest extends ExecutionTest {
             filtered.get(t);
             fail("Expected filtered promise to throw NoSuchElementException on get");
         } catch (NoSuchElementException e){
-            assertThat(e).hasMessage("Future.filter predicate is not satisfied");
+            assertThat(e).hasMessage("Promise.filter predicate is not satisfied");
         }
     }
 
@@ -299,7 +299,7 @@ public class PromiseTest extends ExecutionTest {
                 filtered.get(t);
                 fail("Expected filtered promise to throw NoSuchElementException on get");
             } catch (NoSuchElementException e){
-                assertThat(e).hasMessage("Future.filter predicate is not satisfied");
+                assertThat(e).hasMessage("Promise.filter predicate is not satisfied");
             }
         });
     }
@@ -443,7 +443,7 @@ public class PromiseTest extends ExecutionTest {
 
         // And we should get an exception !
         exception.expect(IllegalStateException.class);
-        exception.expectMessage("Promise already completed.");
+        exception.expectMessage("RedeemablePromise already completed.");
         d.get(t);
     }
 
diff --git a/framework/src/play/src/test/java/play/mvc/SecurityTest.java b/framework/src/play/src/test/java/play/mvc/SecurityTest.java
index 31f186c5f5..64f650494d 100644
--- a/framework/src/play/src/test/java/play/mvc/SecurityTest.java
+++ b/framework/src/play/src/test/java/play/mvc/SecurityTest.java
@@ -2,6 +2,9 @@ package play.mvc;
 
 import com.google.common.collect.ImmutableMap;
 import java.lang.annotation.Annotation;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -51,12 +54,12 @@ public class SecurityTest {
         }
 
         @Test
-        public void testDontSetUsernameToNullUntilDelegateFinishes() {
+        public void testDontSetUsernameToNullUntilDelegateFinishes() throws Exception {
             runSetUsernameToNullInCallback(false);
         }
 
         @Test
-        public void testDontSetUsernameToNullUntilDelegateRaisesException() {
+        public void testDontSetUsernameToNullUntilDelegateRaisesException() throws Exception {
             runSetUsernameToNullInCallback(true);
         }
 
@@ -79,7 +82,7 @@ public class SecurityTest {
             verify(req).setUsername(null);
         }
 
-        private void runSetUsernameToNullInCallback(final boolean shouldRaiseException) {
+        private void runSetUsernameToNullInCallback(final boolean shouldRaiseException) throws Exception {
             action.delegate = new Action<Object>() {
                 @Override
                 public F.Promise<Result> call(Http.Context ctx) {
@@ -95,12 +98,12 @@ public class SecurityTest {
 
             if (shouldRaiseException) {
                 try {
-                    action.call(ctx).get(1000);
-                } catch (Exception e) {
-                    Assert.assertEquals(exception, e);
+                    action.call(ctx).toCompletableFuture().get(1, TimeUnit.SECONDS);
+                } catch (ExecutionException e) {
+                    Assert.assertEquals(exception, e.getCause());
                 }
             } else {
-                Assert.assertEquals(ok, action.call(ctx).get(1000));
+                Assert.assertEquals(ok, action.call(ctx).toCompletableFuture().get(1, TimeUnit.SECONDS));
             }
 
             verify(req).setUsername("test_user");
diff --git a/framework/src/play/src/test/scala/play/core/j/HttpExecutionContextSpec.scala b/framework/src/play/src/test/scala/play/core/j/HttpExecutionContextSpec.scala
index 103394fb8d..b1ad42c194 100644
--- a/framework/src/play/src/test/scala/play/core/j/HttpExecutionContextSpec.scala
+++ b/framework/src/play/src/test/scala/play/core/j/HttpExecutionContextSpec.scala
@@ -17,29 +17,27 @@ object HttpExecutionContextSpec extends Specification
   "HttpExecutionContext" should {
 
     "propagate the context ClassLoader and Http.Context" in {
-      mustExecute(2) { ec =>
-        val classLoader = new ClassLoader() {}
-        val httpContext = new Http.Context(1, null, null, Map.empty.asJava, Map.empty.asJava, Map.empty.asJava)
-        val hec = new HttpExecutionContext(classLoader, httpContext, ec).prepare
+      val classLoader = new ClassLoader() {}
+      val httpContext = new Http.Context(1, null, null, Map.empty.asJava, Map.empty.asJava, Map.empty.asJava)
+      val hec = new HttpExecutionContext(classLoader, httpContext, ExecutionContext.global)
 
-        val hecFromThread = new LinkedBlockingQueue[ExecutionContext]()
-        hec.execute(new Runnable {
-          def run() = {
-            hecFromThread.offer(HttpExecutionContext.fromThread(ec).prepare)
-          }
-        })
+      val hecFromThread = new LinkedBlockingQueue[ExecutionContext]()
+      hec.execute(new Runnable {
+        def run() = {
+          hecFromThread.offer(HttpExecutionContext.fromThread(ExecutionContext.global))
+        }
+      })
 
-        val actualClassLoader = new LinkedBlockingQueue[ClassLoader]()
-        val actualHttpContext = new LinkedBlockingQueue[Http.Context]()
-        hecFromThread.poll(5, SECONDS).execute(new Runnable {
-          def run() = {
-            actualClassLoader.offer(Thread.currentThread().getContextClassLoader())
-            actualHttpContext.offer(Http.Context.current.get())
-          }
-        })
-        actualClassLoader.poll(5, SECONDS) must equalTo(classLoader)
-        actualHttpContext.poll(5, SECONDS) must equalTo(httpContext)
-      }
+      val actualClassLoader = new LinkedBlockingQueue[ClassLoader]()
+      val actualHttpContext = new LinkedBlockingQueue[Http.Context]()
+      hecFromThread.poll(5, SECONDS).execute(new Runnable {
+        def run() = {
+          actualClassLoader.offer(Thread.currentThread().getContextClassLoader())
+          actualHttpContext.offer(Http.Context.current.get())
+        }
+      })
+      actualClassLoader.poll(5, SECONDS) must equalTo(classLoader)
+      actualHttpContext.poll(5, SECONDS) must equalTo(httpContext)
     }
   }
 
diff --git a/framework/src/play/src/test/scala/play/libs/FSpec.scala b/framework/src/play/src/test/scala/play/libs/FSpec.scala
index 792c380d7d..cd22b0c8e0 100644
--- a/framework/src/play/src/test/scala/play/libs/FSpec.scala
+++ b/framework/src/play/src/test/scala/play/libs/FSpec.scala
@@ -15,6 +15,8 @@ import java.util.function.{ Consumer, Function, Predicate, Supplier }
 object FSpec extends Specification
     with ExecutionSpecification {
 
+  sequential
+
   "An F.Promise" should {
 
     "wrap a Scala Future" in {
@@ -269,7 +271,7 @@ object FSpec extends Specification
     }
 
     "transform its failed throwable (with default ExecutionContext)" in {
-      val p = F.Promise.throwing(new RuntimeException("1"))
+      val p = F.Promise.throwing[Int](new RuntimeException("1"))
       val mapped = p.transform(
         new Function[Int, Int] {
           def apply(x: Int) = x
@@ -282,7 +284,7 @@ object FSpec extends Specification
     }
 
     "transform its failed throwable (with explicit ExecutionContext)" in {
-      val p = F.Promise.throwing(new RuntimeException("1"))
+      val p = F.Promise.throwing[Int](new RuntimeException("1"))
       mustExecute(1) { ec =>
         val mapped = p.transform(
           new Function[Int, Int] {
@@ -309,14 +311,14 @@ object FSpec extends Specification
     }
 
     "combine a sequence of promises from a vararg" in {
-      mustExecute(8) { ec =>
+      mustExecute(3) { ec =>
         import F.Promise.pure
         F.Promise.sequence[Int](ec, pure(1), pure(2), pure(3)).get(5, SECONDS) must equalTo(Arrays.asList(1, 2, 3))
       }
     }
 
     "combine a sequence of promises from an iterable" in {
-      mustExecute(8) { ec =>
+      mustExecute(3) { ec =>
         import F.Promise.pure
         F.Promise.sequence[Int](Arrays.asList(pure(1), pure(2), pure(3)), ec).get(5, SECONDS) must equalTo(Arrays.asList(1, 2, 3))
       }
