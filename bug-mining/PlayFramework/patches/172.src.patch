diff --git a/documentation/manual/working/commonGuide/shutdown/Shutdown.md b/documentation/manual/working/commonGuide/shutdown/Shutdown.md
index 51dc9d5a0c..d58ff82cd2 100644
--- a/documentation/manual/working/commonGuide/shutdown/Shutdown.md
+++ b/documentation/manual/working/commonGuide/shutdown/Shutdown.md
@@ -1,9 +1,13 @@
 <!--- Copyright (C) Lightbend Inc. <https://www.lightbend.com> -->
 # Coordinated Shutdown
 
-Play 2.6 incorporated the use of Akka's [Coordinated Shutdown](https://doc.akka.io/docs/akka/2.6/actors.html?language=scala#coordinated-shutdown) but still didn't rely on it completely. Since Play 2.7, Coordinated Shutdown is responsible for the complete shutdown of Play. In production, the trigger to invoke the clean shutdown could be a `SIGTERM` or, if your Play process is part of an Akka Cluster, a [`Downing`](https://doc.akka.io/docs/akka/2.6/cluster-usage.html) event.
+Play incorporates the use of Akka's [Coordinated Shutdown](https://doc.akka.io/docs/akka/2.6/actors.html?language=scala#coordinated-shutdown) but still didn't rely on it completely. While Coordinated Shutdown is responsible for the complete shutdown of Play, there is still the `ApplicationLifecycle` API, and it is Play's responsibility to exit the JVM.
 
-> **Note**: If you are using Play embedded or if you manually handle `Application`'s and `Server`'s on your tests, the migration to Coordinated Shutdown inside Play can affect your shutdown process since using Coordinated Shutdown introduces small changes on the dependent lifecycles of the `Application` and the `Server`: 1) invoking `Server#stop` MUST stop the `Server` and MUST also stop the `Application` running on that `Server`; and 2) invoking `Application#stop` MUST stop the `Application` and MAY also stop the `Server` where the application is running.
+In production, the trigger to invoke the clean shutdown could be a `SIGTERM` or, if your Play process is part of an Akka Cluster, a [`Downing`](https://doc.akka.io/docs/akka/2.6/cluster-usage.html) event.
+
+> **Note**: If you are using Play embedded or if you manually handle `Application`'s and `Server`'s on your tests, the migration to Coordinated Shutdown inside Play can affect your shutdown process since using Coordinated Shutdown introduces small changes on the dependent lifecycles of the `Application` and the `Server`:
+> 1. Invoking `Server#stop` MUST stop the `Server` and MUST also stop the `Application` running on that `Server`
+> 2. Invoking `Application#stop` MUST stop the `Application` and MAY also stop the `Server` where the application is running.
 
 ## How does it compare to `ApplicationLifecycle`?
 
@@ -46,10 +50,21 @@ Java
 
 A Play process is usually terminated via a `SIGTERM` signal. When the Play process receives the signal, a JVM shutdown hook is run causing the server to stop via invoking Coordinated Shutdown.
 
-Other possible triggers differ from `SIGTERM` slightly. While `SIGTERM` is handled in an outside-in fashion, you may trigger a shutdown from your code (or a library may detect a cause to trigger the shutdown). For example when running your Play process as part of an Akka Cluster or adding an endpoint on your API that would allow an admin or an orchestrator to trigger a programmatic shutdown. In these scenarios the shutdown is inside out: all the phases of the Coordinated Shutdown list are run in the appropriate order, but the Actor System will terminate before the JVM shutdown hook runs.
+Other possible triggers differ from `SIGTERM` slightly. While `SIGTERM` is handled in an outside-in fashion, you may trigger a shutdown from your code (or a library may detect a cause to trigger the shutdown). For example when running your Play process as part of an Akka Cluster or adding an endpoint on your API that would allow an admin or an orchestrator to trigger a programmatic shutdown. In these scenarios the shutdown is inside out: all the phases of the Coordinated Shutdown list run in the appropriate order, but the Actor System will terminate before the JVM shutdown hook runs.
 
 When developing your Play application, you should consider all the termination triggers and what steps and in which order they will run.
 
 ## Limitations
 
 Akka Coordinated Shutdown ships with some settings making it very configurable. Despite that, using Akka Coordinated Shutdown within Play lifecycle makes some of these settings invalid. One such setting is `akka.coordinated-shutdown.exit-jvm`. Enabling `akka.coordinated-shutdown.exit-jvm` in a Play project will cause a deadlock at shutdown preventing your process to ever complete. In general, the default values tuning Akka Coordinated Shutdown should be fine in all Production, Development and Test modes.
+
+## Gracefully shutdown the server
+
+When using Akka HTTP server backend, the server shutdown happens gracefully, and it follows the steps described in [Akka HTTP documentation](https://doc.akka.io/docs/akka-http/10.1.11/server-side/graceful-termination.html). To summarize:
+
+1. First, the server port is unbound and no new connections will be accepted
+2. If a request is "in-flight" (being handled by user code), it is given hard deadline time to complete. For Akka HTTP, it is possible to configure the deadline using `play.server.akka.terminateTimeout` (see [[Akka HTTP Settings|SettingsAkkaHttp]] for more details).
+3. If a connection has no “in-flight” request, it is terminated immediately
+4. If user code emits a response within the timeout, then this response is sent to the client with a `Connection: close` header and connection is closed.
+5. If it is a streaming response, it is also mandated that it shall complete within the deadline, and if it does not the connection will be terminated regardless of status of the streaming response.
+6. If user code does not reply with a response within the deadline, an automatic response is sent with a status configured by `akka.http.server.termination-deadline-exceeded-response`. The value must be a valid [HTTP status code](https://doc.akka.io/api/akka-http/10.1.11/akka/http/scaladsl/model/StatusCodes$.html).
\ No newline at end of file
diff --git a/transport/server/play-akka-http-server/src/main/resources/reference.conf b/transport/server/play-akka-http-server/src/main/resources/reference.conf
index 47504795fb..eb21863011 100644
--- a/transport/server/play-akka-http-server/src/main/resources/reference.conf
+++ b/transport/server/play-akka-http-server/src/main/resources/reference.conf
@@ -14,6 +14,12 @@ play {
       # How long a request takes until it times out. Set to null or "infinite" to disable the timeout.
       requestTimeout = infinite
 
+      # Timeout after which all requests and connections shall be forcefully terminated
+      # when shutting down the server. It will default to Coordinated Shutdown service-unbind
+      # phase timeout. Value must be a duration, for example:
+      # play.server.akka.terminationTimeout = 10 seconds
+      terminationTimeout = null
+
       # Enables/disables automatic handling of HEAD requests.
       # If this setting is enabled the server dispatches HEAD requests as GET
       # requests to the application and automatically strips off all message
diff --git a/transport/server/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala b/transport/server/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
index 3e047914ab..71da87e6e7 100644
--- a/transport/server/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
+++ b/transport/server/play-akka-http-server/src/main/scala/play/core/server/AkkaHttpServer.scala
@@ -63,7 +63,6 @@ import scala.util.Try
  * Starts a Play server using Akka HTTP.
  */
 class AkkaHttpServer(context: AkkaHttpServer.Context) extends Server {
-  registerShutdownTasks()
 
   import AkkaHttpServer._
 
@@ -87,6 +86,8 @@ class AkkaHttpServer(context: AkkaHttpServer.Context) extends Server {
 
   private val akkaServerConfigReader = new AkkaServerConfigReader(akkaServerConfig)
 
+  private val terminationTimeout = akkaServerConfig.getOptional[FiniteDuration]("terminationTimeout")
+
   private val maxContentLength =
     Server.getPossiblyInfiniteBytes(serverConfig.underlying, "max-content-length", "akka.max-content-length")
   private val maxHeaderValueLength =
@@ -440,32 +441,39 @@ class AkkaHttpServer(context: AkkaHttpServer.Context) extends Server {
 
   override def stop(): Unit = CoordinatedShutdownSupport.syncShutdown(context.actorSystem, ServerStoppedReason)
 
+
   // Using CoordinatedShutdown means that instead of invoking code imperatively in `stop`
   // we have to register it as early as possible as CoordinatedShutdown tasks and
   // then `stop` runs CoordinatedShutdown.
+  registerShutdownTasks()
   private def registerShutdownTasks(): Unit = {
     implicit val exCtx: ExecutionContext = context.actorSystem.dispatcher
 
     // Register all shutdown tasks
     val cs = CoordinatedShutdown(context.actorSystem)
     cs.addTask(CoordinatedShutdown.PhaseBeforeServiceUnbind, "trace-server-stop-request") { () =>
-      mode match {
-        case Mode.Test =>
-        case _         => logger.info("Stopping server...")
-      }
+      if (mode != Mode.Test) logger.info("Stopping Akka HTTP server...")
       Future.successful(Done)
     }
 
-    // Stop listening.
-    // TODO: this can be improved so unbind is deferred until `service-stop`. We could
-    // respond 503 in the meantime.
+    // The termination hard-deadline is either what was configured by the user
+    // or defaults to `service-unbind` phase timeout.
+    val serverTerminateTimeout = terminationTimeout.getOrElse(cs.timeout(CoordinatedShutdown.PhaseServiceUnbind))
     cs.addTask(CoordinatedShutdown.PhaseServiceUnbind, "akka-http-server-unbind") { () =>
-      def unbind(binding: Option[Http.ServerBinding]): Future[Done] =
-        binding.map(_.unbind()).getOrElse(Future.successful(Done))
+      def terminate(binding: Option[Http.ServerBinding]): Future[Done] = {
+        binding
+          .map { binding =>
+            logger.info(s"Terminating server binding for ${binding.localAddress}")
+            binding.terminate(serverTerminateTimeout).map(_ => Done)
+          }
+          .getOrElse {
+            Future.successful(Done)
+          }
+      }
 
       for {
-        _ <- unbind(httpServerBinding)
-        _ <- unbind(httpsServerBinding)
+        _ <- terminate(httpServerBinding)
+        _ <- terminate(httpsServerBinding)
       } yield Done
     }
 
@@ -473,6 +481,7 @@ class AkkaHttpServer(context: AkkaHttpServer.Context) extends Server {
     // Do this last because the hooks were created before the server,
     // so the server might need them to run until the last moment.
     cs.addTask(CoordinatedShutdown.PhaseBeforeActorSystemTerminate, "user-provided-server-stop-hook") { () =>
+      logger.info("Running provided shutdown stop hooks")
       context.stopHook().map(_ => Done)
     }
     cs.addTask(CoordinatedShutdown.PhaseBeforeActorSystemTerminate, "shutdown-logger") { () =>
