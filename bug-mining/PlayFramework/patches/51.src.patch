diff --git a/documentation/manual/working/scalaGuide/main/async/code/ScalaWebSockets.scala b/documentation/manual/working/scalaGuide/main/async/code/ScalaWebSockets.scala
index f095f39165..898ce0eefa 100644
--- a/documentation/manual/working/scalaGuide/main/async/code/ScalaWebSockets.scala
+++ b/documentation/manual/working/scalaGuide/main/async/code/ScalaWebSockets.scala
@@ -3,47 +3,55 @@
  */
 package scalaguide.async.websockets
 
+import akka.stream.Materializer
+import akka.stream.scaladsl._
+import play.api.http.websocket.{ TextMessage, Message }
+import play.api.mvc.WebSocket.MessageFlowTransformer
 import play.api.test._
-import scala.concurrent.{Promise, Future}
+import scala.concurrent.{ Future, Promise }
 
 object ScalaWebSockets extends PlaySpecification {
 
   import java.io.Closeable
-  import play.api.libs.iteratee._
   import play.api.mvc.{Result, WebSocket}
-  import play.api.libs.json.{Json, JsValue}
-  import play.api.Application
+  import play.api.libs.json.Json
 
   "Scala WebSockets" should {
 
-    "support actors" in {
-
-      def runWebSocket[In, Out](webSocket: WebSocket[In, Out], in: Enumerator[In]): Either[Result, List[Out]] = {
-        await(webSocket.f(FakeRequest())).right.map { f =>
-          val consumed = Promise[List[Out]]()
-          def getChunks(chunks: List[Out]): Iteratee[Out, Unit] = Cont {
-            case Input.El(out) => getChunks(out :: chunks)
-            case Input.EOF => Done(consumed.success(chunks.reverse))
-            case Input.Empty => getChunks(chunks)
+    def runWebSocket[In, Out](webSocket: WebSocket, in: Source[Message, _], expectOut: Int)(implicit mat: Materializer): Either[Result, List[Message]] = {
+      await(webSocket(FakeRequest())).right.map { flow =>
+
+        // When running in the real world, if the flow cancels upstream, Play's WebSocket protocol implementation will
+        // handle this and close the WebSocket, but here, that won't happen, so we redeem the future when we receive
+        // enough.
+        val promise = Promise[List[Message]]()
+        if (expectOut == 0) promise.success(Nil)
+        val flowResult = in via flow runWith Sink.fold[(List[Message], Int), Message]((Nil, expectOut)) { (state, out) =>
+          val (result, remaining) = state
+          if (remaining == 1) {
+            promise.success(result :+ out)
           }
-          f(in, getChunks(Nil))
-          await(consumed.future)
+          (result :+ out, remaining - 1)
         }
-
+        import play.api.libs.iteratee.Execution.Implicits.trampoline
+        await(Future.firstCompletedOf(Seq(promise.future, flowResult.map(_._1))))
       }
+    }
+
+    "support actors" in {
 
       import akka.actor._
 
       "allow creating a simple echoing actor" in new WithApplication() {
-        runWebSocket(Samples.Controller1.socket, Enumerator("foo") >>> Enumerator.eof) must beRight.like {
-          case list => list must_== List("I received your message: foo")
+        runWebSocket(Samples.Controller1.socket, Source.single(TextMessage("foo")), 1) must beRight.like {
+          case list => list must_== List(TextMessage("I received your message: foo"))
         }
       }
 
       "allow cleaning up" in new WithApplication() {
-        @volatile var closed = false
+        val closed = Promise[Unit]()
         val someResource = new Closeable() {
-          def close() = closed = true
+          def close() = closed.success(())
         }
         class MyActor extends Actor {
           def receive = PartialFunction.empty
@@ -56,9 +64,9 @@ object ScalaWebSockets extends PlaySpecification {
         }
 
         runWebSocket(
-          WebSocket.acceptWithActor[String, String](req => out => Props(new MyActor)), Enumerator.eof
-        ) must beRight[List[String]]
-        closed must beTrue
+          WebSocket.acceptWithActor[String, String](req => out => Props(new MyActor)), Source.empty, 0
+        ) must beRight[List[Message]]
+        await(closed.future) must_== ()
       }
 
       "allow closing the WebSocket" in new WithApplication() {
@@ -73,29 +81,30 @@ object ScalaWebSockets extends PlaySpecification {
         }
 
         runWebSocket(
-          WebSocket.acceptWithActor[String, String](req => out => Props(new MyActor)), Enumerator.empty
-        ) must beRight[List[String]]
+          WebSocket.acceptWithActor[String, String](req => out => Props(new MyActor)), Source(Promise[Message]().future), 0
+        ) must beRight[List[Message]]
       }
 
       "allow rejecting the WebSocket" in new WithApplication() {
-        runWebSocket(Samples.Controller2.socket, Enumerator.empty) must beLeft.which { result =>
+        runWebSocket(Samples.Controller2.socket, Source.empty, 0) must beLeft.which { result =>
           result.header.status must_== FORBIDDEN
         }
       }
 
       "allow creating a json actor" in new WithApplication() {
         val json = Json.obj("foo" -> "bar")
-        runWebSocket(Samples.Controller4.socket, Enumerator[JsValue](json) >>> Enumerator.eof) must beRight.which { out =>
-          out must_== List(json)
+        runWebSocket(Samples.Controller4.socket, Source.single(TextMessage(Json.stringify(json))), 1) must beRight.which { out =>
+          out must_== List(TextMessage(Json.stringify(json)))
         }
       }
 
       "allow creating a higher level object actor" in new WithApplication() {
         runWebSocket(
           Samples.Controller5.socket,
-          Enumerator(Samples.Controller5.InEvent("blah")) >>> Enumerator.eof
+          Source.single(TextMessage(Json.stringify(Json.toJson(Samples.Controller5.InEvent("blah"))))),
+          1
         ) must beRight.which { out =>
-          out must_== List(Samples.Controller5.OutEvent("blah"))
+          out must_== List(TextMessage(Json.stringify(Json.toJson(Samples.Controller5.OutEvent("blah")))))
         }
       }
 
@@ -103,49 +112,32 @@ object ScalaWebSockets extends PlaySpecification {
 
     "support iteratees" in {
 
-      def runWebSocket[In, Out](app: Application, webSocket: WebSocket[In, Out], in: Enumerator[In]): Either[Result, List[Out]] = {
-        await(webSocket.f(FakeRequest())).right.map { f =>
-          val consumed = Promise[List[Out]]()
-          @volatile var chunks = List.empty[Out]
-          def getChunks: Iteratee[Out, Unit] = Cont {
-            case Input.El(out) =>
-              chunks = out :: chunks
-              getChunks
-            case Input.EOF => Done(consumed.trySuccess(chunks.reverse))
-            case Input.Empty => getChunks
-          }
-
-          import scala.concurrent.ExecutionContext.Implicits.global
-          import scala.concurrent.duration._
-          f(in.onDoneEnumerating {
-            // Yeah, ugly, but it makes a race condition unlikely.
-            akka.pattern.after(100.milliseconds, app.actorSystem.scheduler)(Future(consumed.trySuccess(chunks)))
-          }, getChunks)
-          await(consumed.future)
-        }
-      }
-
       "iteratee1" in new WithApplication() {
-        runWebSocket(app, Samples.Controller6.socket, Enumerator.eof) must beRight.which { out =>
-          out must_== List("Hello!")
+        runWebSocket(Samples.Controller6.socket, Source.empty, 1) must beRight.which { out =>
+          out must_== List(TextMessage("Hello!"))
         }
       }
 
       "iteratee2" in new WithApplication() {
-        runWebSocket(app, Samples.Controller7.socket, Enumerator.empty) must beRight.which { out =>
-          out must_== List("Hello!")
+        runWebSocket(Samples.Controller7.socket, Source(Promise[Message]().future), 1) must beRight.which { out =>
+          out must_== List(TextMessage("Hello!"))
         }
       }
 
       "iteratee3" in new WithApplication() {
-        runWebSocket(app, Samples.Controller8.socket, Enumerator("foo") >>> Enumerator.eof) must beRight.which { out =>
-          out must_== List("I received your message: foo")
+        runWebSocket(Samples.Controller8.socket, Source.single(TextMessage("foo")), 1) must beRight.which { out =>
+          out must_== List(TextMessage("I received your message: foo"))
         }
       }
 
     }
   }
 
+  /**
+   * The default await timeout.  Override this to change it.
+   */
+  import scala.concurrent.duration._
+  override implicit def defaultAwaitTimeout = 2.seconds
 }
 
 object Samples {
@@ -155,6 +147,7 @@ object Samples {
     //#actor-accept
     import play.api.mvc._
     import play.api.Play.current
+    import play.api.Play.materializer
 
     def socket = WebSocket.acceptWithActor[String, String] { request => out =>
       MyWebSocketActor.props(out)
@@ -187,6 +180,7 @@ object Samples {
     import scala.concurrent.Future
     import play.api.mvc._
     import play.api.Play.current
+    import play.api.Play.materializer
 
     def socket = WebSocket.tryAcceptWithActor[String, String] { request =>
       Future.successful(request.session.get("user") match {
@@ -216,6 +210,7 @@ object Samples {
     import play.api.mvc._
     import play.api.libs.json._
     import play.api.Play.current
+    import play.api.Play.materializer
 
     def socket = WebSocket.acceptWithActor[JsValue, JsValue] { request => out =>
       MyWebSocketActor.props(out)
@@ -251,13 +246,13 @@ object Samples {
     //#actor-json-frames
     import play.api.mvc.WebSocket.FrameFormatter
 
-    implicit val inEventFrameFormatter = FrameFormatter.jsonFrame[InEvent]
-    implicit val outEventFrameFormatter = FrameFormatter.jsonFrame[OutEvent]
+    implicit val messageFlowTransformer = MessageFlowTransformer.jsonMessageFlowTransformer[InEvent, OutEvent]
     //#actor-json-frames
 
     //#actor-json-in-out
     import play.api.mvc._
     import play.api.Play.current
+    import play.api.Play.materializer
 
     def socket = WebSocket.acceptWithActor[InEvent, OutEvent] { request => out =>
       MyWebSocketActor.props(out)
diff --git a/framework/project/Dependencies.scala b/framework/project/Dependencies.scala
index 8bf9435f43..9a3117fb60 100644
--- a/framework/project/Dependencies.scala
+++ b/framework/project/Dependencies.scala
@@ -253,7 +253,7 @@ object Dependencies {
 
   val scalacheckDependencies = Seq(
     "org.specs2"     %% "specs2-scalacheck" % specsVersion % Test,
-    "org.scalacheck" %% "scalacheck"        % "1.12.4"     % Test
+    "org.scalacheck" %% "scalacheck"        % "1.12.2"     % Test
   )
 
   val playServerDependencies = Seq(
diff --git a/framework/src/play-akka-http-server/src/main/scala/akka/http/play/WebSocketHandler.scala b/framework/src/play-akka-http-server/src/main/scala/akka/http/play/WebSocketHandler.scala
new file mode 100644
index 0000000000..09ede19c9d
--- /dev/null
+++ b/framework/src/play-akka-http-server/src/main/scala/akka/http/play/WebSocketHandler.scala
@@ -0,0 +1,211 @@
+package akka.http.play
+
+import akka.http.scaladsl.model.HttpResponse
+import akka.http.scaladsl.model.ws.UpgradeToWebsocket
+import akka.http.impl.engine.ws._
+import akka.stream.scaladsl._
+import akka.stream.stage.{ Context, Stage, PushStage }
+import akka.util.ByteString
+import play.api.http.websocket._
+import play.api.libs.streams.AkkaStreams
+import play.core.server.common.WebSocketFlowHandler
+
+object WebSocketHandler {
+
+  /**
+   * Handle a WebSocket
+   */
+  def handleWebSocket(upgrade: UpgradeToWebsocket, flow: Flow[Message, Message, _], bufferLimit: Int): HttpResponse = upgrade match {
+    case lowLevel: UpgradeToWebsocketLowLevel =>
+      lowLevel.handleFrames(messageFlowToFrameFlow(flow, bufferLimit))
+    case other => throw new IllegalArgumentException("UpgradeToWebsocket is not an Akka HTTP UpgradeToWebsocketLowLevel")
+  }
+
+  /**
+   * Convert a flow of messages to a flow of frame events.
+   *
+   * This implements the WebSocket control logic, including handling ping frames and closing the connection in a spec
+   * compliant manner.
+   */
+  def messageFlowToFrameFlow(flow: Flow[Message, Message, _], bufferLimit: Int): Flow[FrameEvent, FrameEvent, _] = {
+    // Each of the stages here transforms frames to an Either[Message, ?], where Message is a close message indicating
+    // some sort of protocol failure. The handleProtocolFailures function then ensures that these messages skip the
+    // flow that we are wrapping, are sent to the client and the close procedure is implemented.
+    Flow[FrameEvent]
+      .transform(() => aggregateFrames(bufferLimit))
+      .transform(() => aggregateMessages(bufferLimit))
+      .transform(() => framesToMessages())
+      .via(handleProtocolFailures(WebSocketFlowHandler.webSocketProtocol(flow)))
+      .map(messageToFrameEvent)
+  }
+
+  /**
+   * Akka HTTP potentially splits frames into multiple frame events.
+   *
+   * This stage aggregates them so each frame is a full frame.
+   *
+   * @param bufferLimit The maximum size of frame data that should be buffered.
+   */
+  private def aggregateFrames(bufferLimit: Int): Stage[FrameEvent, Either[Message, Frame]] = {
+    new PushStage[FrameEvent, Either[Message, Frame]] {
+
+      var currentFrameData: ByteString = null
+      var currentFrameHeader: FrameHeader = null
+
+      def onPush(elem: FrameEvent, ctx: Context[Either[Message, Frame]]) = elem match {
+        // FrameData error handling first
+        case unexpectedData: FrameData if currentFrameHeader == null =>
+          // Technically impossible, this indicates a bug in Akka HTTP,
+          // since it has sent the start of a frame before finishing
+          // the previous frame.
+          ctx.push(close(Protocol.CloseCodes.UnexpectedCondition, "Server error"))
+        case FrameData(data, _) if currentFrameData.size + data.size > bufferLimit =>
+          ctx.push(close(Protocol.CloseCodes.TooBig))
+
+        // FrameData handling
+        case FrameData(data, false) =>
+          currentFrameData ++= data
+          ctx.pull()
+        case FrameData(data, true) =>
+          val frame = Frame(currentFrameHeader, currentFrameData ++ data)
+          currentFrameHeader = null
+          currentFrameData = null
+          ctx.push(Right(frame))
+
+        // Frame start error handling
+        case FrameStart(header, data) if currentFrameHeader != null =>
+          // Technically impossible, this indicates a bug in Akka HTTP,
+          // since it has sent the start of a frame before finishing
+          // the previous frame.
+          ctx.push(close(Protocol.CloseCodes.UnexpectedCondition, "Server error"))
+
+        // Frame start
+        case fs @ FrameStart(header, data) if fs.lastPart =>
+          ctx.push(Right(Frame(header, data)))
+
+        case FrameStart(header, data) =>
+          currentFrameHeader = header
+          currentFrameData = data
+          ctx.pull()
+      }
+
+    }
+  }
+
+  /**
+   * The WebSocket protocol allows messages to be fragmented across multiple frames.
+   *
+   * This stage aggregates them so each frame is a full message. It also unmasks frames.
+   *
+   * @param bufferLimit The maximum size of frame data that should be buffered.
+   */
+  private def aggregateMessages(bufferLimit: Int): Stage[Either[Message, Frame], Either[Message, Frame]] = {
+
+    new PushStage[Either[Message, Frame], Either[Message, Frame]] {
+
+      var currentMessageData: ByteString = null
+      var currentMessageHeader: FrameHeader = null
+
+      def onPush(elem: Either[Message, Frame], ctx: Context[Either[Message, Frame]]) = elem match {
+        case close @ Left(_) => ctx.push(close)
+        case Right(frame) =>
+          // Protocol checks
+          if (frame.header.mask.isEmpty) {
+            ctx.push(close(Protocol.CloseCodes.ProtocolError, "Unmasked client frame"))
+          } else if (frame.header.opcode == Protocol.Opcode.Continuation) {
+            if (currentMessageHeader == null) {
+              ctx.push(close(Protocol.CloseCodes.ProtocolError, "Unexpected continuation frame"))
+            } else if (currentMessageData.size + frame.data.size > bufferLimit) {
+              ctx.push(close(Protocol.CloseCodes.TooBig))
+            } else if (frame.header.fin) {
+              val currentFrame = Frame(currentMessageHeader, currentMessageData ++ frame.unmaskedData)
+              currentMessageHeader = null
+              currentMessageData = null
+              ctx.push(Right(currentFrame))
+            } else {
+              currentMessageData ++= frame.unmaskedData
+              ctx.pull()
+            }
+          } else if (currentMessageHeader != null) {
+            ctx.push(close(Protocol.CloseCodes.ProtocolError, "Received non continuation frame when previous message wasn't finished"))
+          } else if (frame.header.fin) {
+            ctx.push(Right(Frame(frame.header, frame.unmaskedData)))
+          } else {
+            currentMessageHeader = frame.header
+            currentMessageData = frame.unmaskedData
+            ctx.pull()
+          }
+      }
+    }
+  }
+
+  /**
+   * Converts frames to Play messages.
+   */
+  private def framesToMessages(): Stage[Either[Message, Frame], Either[Message, Message]] = new PushStage[Either[Message, Frame], Either[Message, Message]] {
+
+    def onPush(elem: Either[Message, Frame], ctx: Context[Either[Message, Message]]) = elem match {
+      case Left(close) => ctx.push(Left(close))
+      case Right(frame) =>
+        frame.header.opcode match {
+          case Protocol.Opcode.Binary =>
+            ctx.push(Right(BinaryMessage(frame.data)))
+          case Protocol.Opcode.Text =>
+            ctx.push(Right(TextMessage(frame.data.utf8String)))
+          case Protocol.Opcode.Close =>
+            val statusCode = FrameEventParser.parseCloseCode(frame.data)
+            val reason = frame.data.drop(2).utf8String
+            ctx.push(Right(CloseMessage(statusCode, reason)))
+          case Protocol.Opcode.Ping =>
+            ctx.push(Right(PingMessage(frame.data)))
+          case Protocol.Opcode.Pong =>
+            ctx.push(Right(PongMessage(frame.data)))
+          case other =>
+            ctx.push(close(Protocol.CloseCodes.PolicyViolated))
+        }
+    }
+  }
+
+  /**
+   * Converts Play messages to Akka HTTP frame events.
+   */
+  private def messageToFrameEvent(message: Message): FrameEvent = {
+    def frameEvent(opcode: Protocol.Opcode, data: ByteString) =
+      FrameEvent.fullFrame(opcode, None, data, fin = true)
+    message match {
+      case TextMessage(data) => frameEvent(Protocol.Opcode.Text, ByteString(data))
+      case BinaryMessage(data) => frameEvent(Protocol.Opcode.Binary, data)
+      case PingMessage(data) => frameEvent(Protocol.Opcode.Ping, data)
+      case PongMessage(data) => frameEvent(Protocol.Opcode.Pong, data)
+      case CloseMessage(Some(statusCode), reason) => FrameEvent.closeFrame(statusCode, reason)
+      case CloseMessage(None, _) => frameEvent(Protocol.Opcode.Close, ByteString.empty)
+    }
+  }
+
+  /**
+   * Handles the protocol failures by gracefully closing the connection.
+   */
+  private def handleProtocolFailures: Flow[Message, Message, _] => Flow[Either[Message, Message], Message, _] = {
+    AkkaStreams.bypassWith(Flow[Either[Message, Message]].transform(() => new PushStage[Either[Message, Message], Either[Message, Message]] {
+      var closing = false
+      def onPush(elem: Either[Message, Message], ctx: Context[Either[Message, Message]]) = elem match {
+        case _ if closing =>
+          ctx.finish()
+        case Right(message) =>
+          ctx.push(Left(message))
+        case Left(close) =>
+          closing = true
+          ctx.push(Right(close))
+      }
+    }), AkkaStreams.EagerFinishMerge(2))
+  }
+
+  private case class Frame(header: FrameHeader, data: ByteString) {
+    def unmaskedData = FrameEventParser.mask(data, header.mask)
+  }
+
+  private def close(status: Int, message: String = "") = {
+    Left(new CloseMessage(Some(status), message))
+  }
+
+}
diff --git a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaHttpServer.scala b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaHttpServer.scala
index 19ab53b094..6f2fda7cba 100644
--- a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaHttpServer.scala
+++ b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/AkkaHttpServer.scala
@@ -1,9 +1,11 @@
 package play.core.server.akkahttp
 
 import akka.actor.ActorSystem
+import akka.http.play.WebSocketHandler
 import akka.http.scaladsl.Http
 import akka.http.scaladsl.model._
 import akka.http.scaladsl.model.headers.Expect
+import akka.http.scaladsl.model.ws.UpgradeToWebsocket
 import akka.stream.Materializer
 import akka.stream.scaladsl._
 import java.net.InetSocketAddress
@@ -111,17 +113,37 @@ class AkkaHttpServer(
     request: HttpRequest,
     taggedRequestHeader: RequestHeader,
     requestBodySource: Source[ByteString, _],
-    handler: Handler): Future[HttpResponse] = handler match {
-    //execute normal action
-    case action: EssentialAction =>
-      val actionWithErrorHandling = EssentialAction { rh =>
+    handler: Handler): Future[HttpResponse] = {
+
+    val upgradeToWebSocket = request.header[UpgradeToWebsocket]
+
+    (handler, upgradeToWebSocket) match {
+      //execute normal action
+      case (action: EssentialAction, _) =>
+        val actionWithErrorHandling = EssentialAction { rh =>
+          import play.api.libs.iteratee.Execution.Implicits.trampoline
+          action(rh).recoverWith {
+            case error => handleHandlerError(tryApp, taggedRequestHeader, error)
+          }
+        }
+        executeAction(tryApp, request, taggedRequestHeader, requestBodySource, actionWithErrorHandling)
+
+      case (websocket: WebSocket, Some(upgrade)) =>
         import play.api.libs.iteratee.Execution.Implicits.trampoline
-        action(rh).recoverWith {
-          case error => handleHandlerError(tryApp, taggedRequestHeader, error)
+
+        websocket(taggedRequestHeader).map {
+          case Left(result) =>
+            modelConversion.convertResult(taggedRequestHeader, result, request.protocol)
+          case Right(flow) =>
+            WebSocketHandler.handleWebSocket(upgrade, flow, 16384)
         }
-      }
-      executeAction(tryApp, request, taggedRequestHeader, requestBodySource, actionWithErrorHandling)
-    case unhandled => sys.error(s"AkkaHttpServer doesn't handle Handlers of this type: $unhandled")
+
+      case (websocket: WebSocket, None) =>
+        // WebSocket handler for non WebSocket request
+        sys.error(s"WebSocket returned for non WebSocket request")
+      case (unhandled, _) => sys.error(s"AkkaHttpServer doesn't handle Handlers of this type: $unhandled")
+
+    }
   }
 
   /** Error handling to use during execution of a handler (e.g. an action) */
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketClient.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketClient.scala
index dcc6991c40..1435cf14f9 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketClient.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketClient.scala
@@ -130,15 +130,28 @@ object WebSocketClient {
         case _ => throw new WebSocketException("Unexpected event: " + e)
       }
     }
+
+    override def exceptionCaught(ctx: ChannelHandlerContext, e: ExceptionEvent) {
+      disconnected.tryFailure(e.getCause)
+      ctx.getChannel.close()
+      ctx.sendDownstream(e)
+    }
   }
 
   private class WebSocketClientHandler(out: Channel, disconnected: Promise[Unit]) extends SimpleChannelUpstreamHandler {
 
+    @volatile var clientInitiatedClose = false
     val (enumerator, in) = Concurrent.broadcast[WebSocketFrame]
 
     val iteratee: Iteratee[WebSocketFrame, _] = Cont {
-      case Input.El(wsf) => Iteratee.flatten(out.write(wsf).toScala.map(_ => iteratee))
-      case Input.EOF => Iteratee.flatten(out.close().toScala.map(_ => Done((), Input.EOF)))
+      case Input.El(wsf) =>
+        if (wsf.isInstanceOf[CloseWebSocketFrame]) {
+          clientInitiatedClose = true
+        }
+        Iteratee.flatten(out.write(wsf).toScala.map(_ => iteratee))
+      case Input.EOF =>
+        disconnected.trySuccess(())
+        Iteratee.flatten(out.close().toScala.map(_ => Done((), Input.EOF)))
       case Input.Empty => iteratee
     }
 
@@ -146,8 +159,9 @@ object WebSocketClient {
       e.getMessage match {
         case close: CloseWebSocketFrame =>
           in.push(close)
-          in.end()
-          out.close()
+          if (!clientInitiatedClose) {
+            out.write(close)
+          }
         case wsf: WebSocketFrame =>
           in.push(wsf)
         case _ => throw new WebSocketException("Unexpected event: " + e)
@@ -181,4 +195,4 @@ object WebSocketClient {
     def this(s: String) = this(s, null)
   }
 
-}
\ No newline at end of file
+}
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketSpec.scala
index faacc9af37..d5150b8725 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/websocket/WebSocketSpec.scala
@@ -4,6 +4,9 @@
 package play.it.http.websocket
 
 import java.nio.charset.Charset
+import akka.stream.scaladsl.{ Source, Flow, Sink }
+import akka.stream.stage.{ Context, PushStage }
+import akka.util.Timeout
 import play.api.test._
 import play.api.Application
 import scala.concurrent.{ Future, Promise }
@@ -14,7 +17,7 @@ import play.it._
 import java.net.URI
 import org.jboss.netty.handler.codec.http.websocketx._
 import org.specs2.matcher.Matcher
-import akka.actor.{ ActorRef, PoisonPill, Actor, Props }
+import akka.actor._
 import play.mvc.WebSocket.{ Out, In }
 import play.core.routing.HandlerDef
 import java.util.concurrent.atomic.AtomicReference
@@ -43,13 +46,13 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
   }
 
   def runWebSocket[A](handler: (Enumerator[WebSocketFrame], Iteratee[WebSocketFrame, _]) => Future[A]): A = {
-    val innerResult = Promise[A]()
     WebSocketClient { client =>
+      val innerResult = Promise[A]()
       await(client.connect(URI.create("ws://localhost:" + testServerPort + "/stream")) { (in, out) =>
         innerResult.completeWith(handler(in, out))
       })
+      await(innerResult.future)
     }
-    await(innerResult.future)
   }
 
   def pongFrame(matcher: Matcher[String]): Matcher[WebSocketFrame] = beLike {
@@ -85,7 +88,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
     val consumed = Promise[List[String]]()
     withServer(app => webSocket(app)(consumed)) {
       val result = runWebSocket { (in, out) =>
-        Enumerator(new TextWebSocketFrame("a"), new TextWebSocketFrame("b"), new CloseWebSocketFrame(1000, "")) |>>> out
+        Enumerator(new TextWebSocketFrame("a"), new TextWebSocketFrame("b"), new CloseWebSocketFrame(1000, "")) |>> out
         consumed.future
       }
       result must_== Seq("a", "b")
@@ -118,7 +121,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
   def closeWhenTheConsumerIsDone(webSocket: Application => Handler) = {
     withServer(app => webSocket(app)) {
       val frames = runWebSocket { (in, out) =>
-        Enumerator[WebSocketFrame](new TextWebSocketFrame("foo")) |>> out
+        Enumerator[WebSocketFrame](new TextWebSocketFrame("a")) |>> out
         in |>>> Iteratee.getChunks[WebSocketFrame]
       }
       frames must contain(exactly(
@@ -132,7 +135,10 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
       implicit val port = testServerPort
       await(wsUrl("/stream").withHeaders(
         "Upgrade" -> "websocket",
-        "Connection" -> "upgrade"
+        "Connection" -> "upgrade",
+        "Sec-WebSocket-Version" -> "13",
+        "Sec-WebSocket-Key" -> "x3JJHMbDL1EzLkh9GBhXDw==",
+        "Origin" -> "http://example.com"
       ).get()).status must_== FORBIDDEN
     }
   }
@@ -143,34 +149,36 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
         WebSocket.using[String] { req =>
           (getChunks[String](Nil, consumed.success _), Enumerator.empty)
         }
-    }.pendingUntilAkkaHttpFixed // All tests in this class are waiting on https://github.com/akka/akka/issues/16848
+    }
 
     "allow sending messages" in allowSendingMessages { _ =>
       messages =>
         WebSocket.using[String] { req =>
           (Iteratee.ignore, Enumerator.enumerate(messages) >>> Enumerator.eof)
         }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "close when the consumer is done" in closeWhenTheConsumerIsDone { _ =>
       WebSocket.using[String] { req =>
-        (Iteratee.head, Enumerator.empty)
+        (Done(()), Enumerator.empty)
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "clean up when closed" in cleanUpWhenClosed { _ =>
       cleanedUp =>
         WebSocket.using[String] { req =>
-          (Iteratee.ignore, Enumerator.empty[String].onDoneEnumerating(cleanedUp.success(true)))
+          (Iteratee.ignore, Enumerator.repeat("foo").onDoneEnumerating {
+            cleanedUp.success(true)
+          })
         }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "allow rejecting a websocket with a result" in allowRejectingTheWebSocketWithAResult { _ =>
       statusCode =>
         WebSocket.tryAccept[String] { req =>
           Future.successful(Left(Results.Status(statusCode)))
         }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "aggregate text frames" in {
       val consumed = Promise[List[String]]()
@@ -184,13 +192,12 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
             new ContinuationWebSocketFrame(false, 0, "co"),
             new ContinuationWebSocketFrame(true, 0, "nd"),
             new TextWebSocketFrame("third"),
-            new CloseWebSocketFrame(1000, "")) |>>> out
+            new CloseWebSocketFrame(1000, "")) |>> out
           consumed.future
         }
         result must_== Seq("first", "second", "third")
       }
-
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "aggregate binary frames" in {
       val consumed = Promise[List[Array[Byte]]]()
@@ -205,12 +212,12 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
             new ContinuationWebSocketFrame(false, 0, binaryBuffer("co")),
             new ContinuationWebSocketFrame(true, 0, binaryBuffer("nd")),
             new BinaryWebSocketFrame(binaryBuffer("third")),
-            new CloseWebSocketFrame(1000, "")) |>>> out
+            new CloseWebSocketFrame(1000, "")) |>> out
           consumed.future
         }
         result.map(b => b.toSeq) must_== Seq("first".getBytes("utf-8").toSeq, "second".getBytes("utf-8").toSeq, "third".getBytes("utf-8").toSeq)
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "close the websocket when the buffer limit is exceeded" in {
       withServer(app => WebSocket.using[String] { req =>
@@ -227,7 +234,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
           closeFrame(1009)
         ))
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "close the websocket when the wrong type of frame is received" in {
       withServer(app => WebSocket.using[Array[Byte]] { req =>
@@ -243,7 +250,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
           closeFrame(1003)
         ))
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "respond to pings" in {
       withServer(app => WebSocket.using[String] { req =>
@@ -261,7 +268,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
           closeFrame()
         ))
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "not respond to pongs" in {
       withServer(app => WebSocket.using[String] { req =>
@@ -278,12 +285,13 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
           closeFrame()
         ))
       }
-    }.pendingUntilAkkaHttpFixed
+    }
 
     "allow handling a WebSocket with an actor" in {
 
       "allow consuming messages" in allowConsumingMessages { implicit app =>
         consumed =>
+          import app.materializer
           WebSocket.acceptWithActor[String, String] { req =>
             out =>
               Props(new Actor() {
@@ -297,34 +305,37 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
                 }
               })
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "allow sending messages" in allowSendingMessages { implicit app =>
         messages =>
+          import app.materializer
           WebSocket.acceptWithActor[String, String] { req =>
             out =>
               Props(new Actor() {
                 messages.foreach { msg =>
                   out ! msg
                 }
-                out ! PoisonPill
+                out ! Status.Success(())
                 def receive = PartialFunction.empty
               })
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "close when the consumer is done" in closeWhenTheConsumerIsDone { implicit app =>
+        import app.materializer
         WebSocket.acceptWithActor[String, String] { req =>
           out =>
             Props(new Actor() {
-              out ! PoisonPill
+              out ! Status.Success(())
               def receive = PartialFunction.empty
             })
         }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "clean up when closed" in cleanUpWhenClosed { implicit app =>
         cleanedUp =>
+          import app.materializer
           WebSocket.acceptWithActor[String, String] { req =>
             out =>
               Props(new Actor() {
@@ -334,14 +345,15 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
                 }
               })
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "allow rejecting a websocket with a result" in allowRejectingTheWebSocketWithAResult { implicit app =>
         statusCode =>
+          import app.materializer
           WebSocket.tryAcceptWithActor[String, String] { req =>
             Future.successful(Left(Results.Status(statusCode)))
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
     }
 
@@ -350,7 +362,6 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
       import play.core.routing.HandlerInvokerFactory
       import play.core.routing.HandlerInvokerFactory._
       import play.mvc.{ WebSocket => JWebSocket, Results => JResults }
-      import play.libs.F
 
       implicit def toHandler[J <: AnyRef](javaHandler: J)(implicit factory: HandlerInvokerFactory[J]): Handler = {
         val invoker = factory.createInvoker(
@@ -373,7 +384,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
               })
             }
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "allow sending messages" in allowSendingMessages { _ =>
         messages =>
@@ -385,7 +396,7 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
               out.close()
             }
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "clean up when closed" in cleanUpWhenClosed { _ =>
         cleanedUp =>
@@ -396,12 +407,12 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
               })
             }
           }
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "allow rejecting a websocket with a result" in allowRejectingTheWebSocketWithAResult { _ =>
         statusCode =>
           JWebSocket.reject[String](JResults.status(statusCode))
-      }.pendingUntilAkkaHttpFixed
+      }
 
       "allow handling a websocket with an actor" in allowSendingMessages { _ =>
         messages =>
@@ -411,13 +422,12 @@ trait WebSocketSpec extends PlaySpecification with WsTestClient with ServerInteg
                 messages.foreach { msg =>
                   out ! msg
                 }
-                out ! PoisonPill
+                out ! Status.Success(())
                 def receive = PartialFunction.empty
               })
             }
-          }
-          )
-      }.pendingUntilAkkaHttpFixed
+          })
+      }
     }
   }
 }
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayDefaultUpstreamHandler.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayDefaultUpstreamHandler.scala
index d84ae8ab65..ae9c4a25a9 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayDefaultUpstreamHandler.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayDefaultUpstreamHandler.scala
@@ -9,28 +9,28 @@ import org.jboss.netty.buffer.ChannelBuffers
 import org.jboss.netty.channel._
 import org.jboss.netty.handler.codec.http._
 import org.jboss.netty.handler.codec.http.HttpHeaders._
-import org.jboss.netty.handler.codec.http.websocketx.{ WebSocketFrame, TextWebSocketFrame, BinaryWebSocketFrame }
+import org.jboss.netty.handler.codec.http.websocketx._
 import org.jboss.netty.handler.codec.frame.TooLongFrameException
 import org.jboss.netty.handler.ssl._
 
 import org.jboss.netty.channel.group._
+import org.reactivestreams.{ Subscription, Subscriber, Publisher }
 import play.api._
+import play.api.http.websocket._
 import play.api.http.{ HttpErrorHandler, DefaultHttpErrorHandler }
 import play.api.libs.streams.{ Streams, Accumulator }
 import play.api.mvc._
 import play.api.libs.iteratee._
 import play.api.libs.iteratee.Input._
-import play.core.server.{ NettyServer, Server }
-import play.core.server.common.{ ForwardedHeaderHandler, ServerRequestUtils, ServerResultUtils }
+import play.core.server.NettyServer
+import play.core.server.common.{ WebSocketFlowHandler, ForwardedHeaderHandler, ServerRequestUtils, ServerResultUtils }
 import play.core.system.RequestIdProvider
-import play.core.websocket._
 import scala.collection.JavaConverters._
-import scala.util.control.Exception
+import scala.util.control.{ NonFatal, Exception }
 import com.typesafe.netty.http.pipelining.{ OrderedDownstreamChannelEvent, OrderedUpstreamMessageEvent }
 import scala.concurrent.Future
 import java.net.{ InetSocketAddress, URI }
 import java.io.IOException
-import org.jboss.netty.handler.codec.http.websocketx.CloseWebSocketFrame
 
 private[play] class PlayDefaultUpstreamHandler(server: NettyServer, allChannels: DefaultChannelGroup) extends SimpleChannelUpstreamHandler with WebSocketHandler with RequestBodyHandler {
 
@@ -161,10 +161,10 @@ private[play] class PlayDefaultUpstreamHandler(server: NettyServer, allChannels:
             }
             handleAction(a, Some(app))
 
-          case Right((ws @ WebSocket(f), app)) if websocketableRequest.check =>
-            logger.trace("Serving this request with: " + ws)
+          case Right((websocket: WebSocket, app)) if websocketableRequest.check =>
+            logger.trace("Serving this request with: " + websocket)
 
-            val executed = Future(f(requestHeader))(play.api.libs.concurrent.Execution.defaultContext)
+            val executed = Future(websocket(requestHeader))(play.api.libs.concurrent.Execution.defaultContext)
 
             import play.api.libs.iteratee.Execution.Implicits.trampoline
             executed.flatMap(identity).map {
@@ -175,8 +175,18 @@ private[play] class PlayDefaultUpstreamHandler(server: NettyServer, allChannels:
               case Right(socket) =>
                 val bufferLimit = app.configuration.getBytes("play.websocket.buffer.limit").getOrElse(65536L)
 
-                val enumerator = websocketHandshake(ctx, nettyHttpRequest, e, bufferLimit)(ws.inFormatter)
-                socket(enumerator, socketOut(ctx)(ws.outFormatter))
+                val webSocketFlow = WebSocketFlowHandler.webSocketProtocol(socket)
+                import app.materializer
+                val webSocketProcessor = webSocketFlow.toProcessor.run()
+                val webSocketIteratee = Streams.subscriberToIteratee(webSocketProcessor)
+                val webSocketEnumerator = Streams.publisherToEnumerator(webSocketProcessor)
+
+                websocketHandshake(ctx, nettyHttpRequest, e, bufferLimit)(webSocketIteratee).onFailure {
+                  case NonFatal(e) => e.printStackTrace()
+                }
+                webSocketEnumerator(socketOut(ctx)).onFailure {
+                  case NonFatal(e) => e.printStackTrace()
+                }
             }.recover {
               case error =>
                 app.errorHandler.onServerError(requestHeader, error).map { result =>
@@ -186,7 +196,7 @@ private[play] class PlayDefaultUpstreamHandler(server: NettyServer, allChannels:
             }
 
           //handle bad websocket request
-          case Right((WebSocket(_), app)) =>
+          case Right((ws: WebSocket, app)) =>
             logger.trace("Bad websocket request")
             val a = EssentialAction(_ => Accumulator.done(Results.BadRequest))
             handleAction(a, Some(app))
@@ -296,33 +306,29 @@ private[play] class PlayDefaultUpstreamHandler(server: NettyServer, allChannels:
 
   private def errorHandler(app: Option[Application]) = app.fold[HttpErrorHandler](DefaultHttpErrorHandler)(_.errorHandler)
 
-  def socketOut[A](ctx: ChannelHandlerContext)(frameFormatter: play.api.mvc.WebSocket.FrameFormatter[A]): Iteratee[A, Unit] = {
+  def socketOut(ctx: ChannelHandlerContext): Iteratee[Message, Unit] = {
     import play.api.libs.iteratee.Execution.Implicits.trampoline
 
     val channel = ctx.getChannel
-    val basicFrameFormatter = frameFormatter.asInstanceOf[BasicFrameFormatter[A]]
-
     import NettyFuture._
 
-    def iteratee: Iteratee[A, _] = Cont {
-      case El(e) =>
-        val basicFrame: BasicFrame = basicFrameFormatter.toFrame(e)
-        val nettyFrame: WebSocketFrame = basicFrame match {
-          case TextFrame(text) => new TextWebSocketFrame(true, 0, text)
-          case BinaryFrame(bytes) => new BinaryWebSocketFrame(true, 0, ChannelBuffers.wrappedBuffer(bytes))
+    def iteratee: Iteratee[Message, _] = Cont {
+      case El(message) =>
+        val nettyFrame: WebSocketFrame = message match {
+          case TextMessage(text) => new TextWebSocketFrame(text)
+          case BinaryMessage(bytes) => new BinaryWebSocketFrame(ChannelBuffers.wrappedBuffer(bytes.asByteBuffer))
+          case PingMessage(data) => new PingWebSocketFrame(ChannelBuffers.wrappedBuffer(data.asByteBuffer))
+          case PongMessage(data) => new PongWebSocketFrame(ChannelBuffers.wrappedBuffer(data.asByteBuffer))
+          case CloseMessage(status, reason) => new CloseWebSocketFrame(status.getOrElse(1000), reason)
         }
         Iteratee.flatten(channel.write(nettyFrame).toScala.map(_ => iteratee))
-      case e @ EOF =>
-        if (channel.isOpen) {
-          Iteratee.flatten(for {
-            _ <- channel.write(new CloseWebSocketFrame(WebSocketNormalClose, "")).toScala
-            _ <- channel.close().toScala
-          } yield Done((), e))
-        } else Done((), e)
+      case EOF => Done(())
       case Empty => iteratee
     }
 
-    iteratee.map(_ => ())
+    iteratee.mapM { _ =>
+      channel.close().toScala
+    }.map(_ => ())
   }
 
   def getHeaders(nettyRequest: HttpRequest): Headers = {
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/WebSocketHandler.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/WebSocketHandler.scala
index 537e2e1a77..d480c6ee87 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/WebSocketHandler.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/WebSocketHandler.scala
@@ -3,16 +3,20 @@
  */
 package play.core.server.netty
 
+import java.io.IOException
+
+import akka.util.ByteString
+import play.api.http.websocket.Message
+
 import scala.language.reflectiveCalls
 
 import org.jboss.netty.channel._
 import org.jboss.netty.handler.codec.http._
 import org.jboss.netty.handler.codec.http.websocketx._
 import play.core._
-import play.core.websocket._
 import play.core.server.websocket.WebSocketHandshake
 import play.api._
-import play.api.mvc.WebSocket.FrameFormatter
+import play.api.http.websocket._
 import play.api.libs.iteratee._
 import play.api.libs.iteratee.Input._
 import scala.concurrent.{ Future, Promise }
@@ -37,26 +41,22 @@ private[server] trait WebSocketHandler {
    */
   private val MaxInFlight = 3
 
-  def newWebSocketInHandler[A](frameFormatter: FrameFormatter[A], bufferLimit: Long): (Enumerator[A], ChannelHandler) = {
-
-    val basicFrameFormatter = frameFormatter.asInstanceOf[BasicFrameFormatter[A]]
+  def newWebSocketInHandler(bufferLimit: Long): (Enumerator[Message], ChannelHandler) = {
 
-    def fromNettyFrame(nettyFrame: WebSocketFrame): A = nettyFrame match {
+    def fromNettyFrame(nettyFrame: WebSocketFrame): Message = nettyFrame match {
       case nettyTextFrame: TextWebSocketFrame =>
-        val basicFrame = TextFrame(nettyTextFrame.getText)
-        basicFrameFormatter.fromFrame(basicFrame)
+        TextMessage(nettyTextFrame.getText)
       case nettyBinaryFrame: BinaryWebSocketFrame =>
-        val bytes = channelBufferToArray(nettyBinaryFrame.getBinaryData)
-        val basicFrame = BinaryFrame(bytes)
-        basicFrameFormatter.fromFrame(basicFrame)
-    }
-    def definedForNettyFrame(nettyFrame: WebSocketFrame): Boolean = nettyFrame match {
-      case _: TextWebSocketFrame => basicFrameFormatter.fromFrameDefined(classOf[TextFrame])
-      case _: BinaryWebSocketFrame => basicFrameFormatter.fromFrameDefined(classOf[BinaryFrame])
-      case _ => false
+        BinaryMessage(ByteString(nettyBinaryFrame.getBinaryData.toByteBuffer))
+      case nettyPingFrame: PingWebSocketFrame =>
+        PingMessage(ByteString(nettyPingFrame.getBinaryData.toByteBuffer))
+      case nettyPongFrame: PongWebSocketFrame =>
+        PongMessage(ByteString(nettyPongFrame.getBinaryData.toByteBuffer))
+      case nettyCloseFrame: CloseWebSocketFrame =>
+        CloseMessage(Some(nettyCloseFrame.getStatusCode).filter(_ > 0), nettyCloseFrame.getReasonText)
     }
 
-    val enumerator = new WebSocketEnumerator[A]
+    val enumerator = new WebSocketEnumerator
 
     (enumerator,
       new SimpleChannelUpstreamHandler {
@@ -64,6 +64,7 @@ private[server] trait WebSocketHandler {
         type FrameCreator = ChannelBuffer => WebSocketFrame
 
         private var continuationBuffer: Option[(FrameCreator, ChannelBuffer)] = None
+        private var sentClose = false
 
         override def messageReceived(ctx: ChannelHandlerContext, e: MessageEvent) {
 
@@ -83,36 +84,27 @@ private[server] trait WebSocketHandler {
               buffer.writeBytes(frame.getBinaryData)
               continuationBuffer = None
               val finalFrame = creator(buffer)
-              val basicFrame = finalFrame
               enumerator.frameReceived(ctx, El(fromNettyFrame(finalFrame)))
 
             // fragmented text
-            case (frame: TextWebSocketFrame, None) if !frame.isFinalFragment && definedForNettyFrame(frame) =>
+            case (frame: TextWebSocketFrame, None) if !frame.isFinalFragment =>
               val buffer = ChannelBuffers.dynamicBuffer(Math.min(frame.getBinaryData.readableBytes() * 2, bufferLimit.asInstanceOf[Int]))
               buffer.writeBytes(frame.getBinaryData)
               continuationBuffer = Some((b => new TextWebSocketFrame(true, frame.getRsv, buffer), buffer))
 
             // fragmented binary
-            case (frame: BinaryWebSocketFrame, None) if !frame.isFinalFragment && definedForNettyFrame(frame) =>
+            case (frame: BinaryWebSocketFrame, None) if !frame.isFinalFragment =>
               val buffer = ChannelBuffers.dynamicBuffer(Math.min(frame.getBinaryData.readableBytes() * 2, bufferLimit.asInstanceOf[Int]))
               buffer.writeBytes(frame.getBinaryData)
               continuationBuffer = Some((b => new BinaryWebSocketFrame(true, frame.getRsv, buffer), buffer))
 
+            case (close: CloseWebSocketFrame, None) if sentClose =>
+              e.getChannel.close()
+
             // full handleable frame
-            case (frame: WebSocketFrame, None) if definedForNettyFrame(frame) =>
+            case (frame: WebSocketFrame, None) =>
               enumerator.frameReceived(ctx, El(fromNettyFrame(frame)))
 
-            // client initiated close
-            case (frame: CloseWebSocketFrame, _) =>
-              closeWebSocket(ctx, frame.getStatusCode, "")
-
-            // ping!
-            case (frame: PingWebSocketFrame, _) =>
-              ctx.getChannel.write(new PongWebSocketFrame(frame.getBinaryData))
-
-            // pong!
-            case (frame: PongWebSocketFrame, _) => // ignore
-
             // unacceptable frame
             case (frame: WebSocketFrame, _) =>
               closeWebSocket(ctx, WebSocketUnacceptable, "This WebSocket does not handle frames of that type")
@@ -122,11 +114,16 @@ private[server] trait WebSocketHandler {
         }
 
         override def exceptionCaught(ctx: ChannelHandlerContext, e: ExceptionEvent) {
-          e.getCause.printStackTrace()
+          e.getCause match {
+            case e: IOException =>
+              logger.trace("IO exception in WebSocket", e)
+            case other =>
+              logger.error("Exception caught while processing WebSocket", other)
+          }
           e.getChannel.close()
         }
 
-        override def channelDisconnected(ctx: ChannelHandlerContext, e: ChannelStateEvent) {
+        override def channelClosed(ctx: ChannelHandlerContext, e: ChannelStateEvent) {
           enumerator.frameReceived(ctx, EOF)
           logger.trace("disconnected socket")
         }
@@ -138,7 +135,6 @@ private[server] trait WebSocketHandler {
           if (ctx.getChannel.isOpen) {
             for {
               _ <- ctx.getChannel.write(new CloseWebSocketFrame(status, reason)).toScala
-              _ <- ctx.getChannel.close().toScala
             } yield {
               enumerator.frameReceived(ctx, EOF)
             }
@@ -149,13 +145,13 @@ private[server] trait WebSocketHandler {
 
   }
 
-  private class WebSocketEnumerator[A] extends Enumerator[A] {
+  private class WebSocketEnumerator extends Enumerator[Message] {
 
-    val eventuallyIteratee = Promise[Iteratee[A, Any]]()
+    val eventuallyIteratee = Promise[Iteratee[Message, Any]]()
 
-    val iterateeRef = Ref[Iteratee[A, Any]](Iteratee.flatten(eventuallyIteratee.future))
+    val iterateeRef = Ref[Iteratee[Message, Any]](Iteratee.flatten(eventuallyIteratee.future))
 
-    private val promise: scala.concurrent.Promise[Iteratee[A, Any]] = Promise[Iteratee[A, Any]]()
+    private val promise: scala.concurrent.Promise[Iteratee[Message, Any]] = Promise[Iteratee[Message, Any]]()
 
     /**
      * The number of in flight messages.  Incremented every time we receive a message, decremented every time a
@@ -163,9 +159,9 @@ private[server] trait WebSocketHandler {
      */
     private val inFlight = new AtomicInteger(0)
 
-    def apply[R](i: Iteratee[A, R]) = {
+    def apply[R](i: Iteratee[Message, R]) = {
       eventuallyIteratee.success(i)
-      promise.asInstanceOf[scala.concurrent.Promise[Iteratee[A, R]]].future
+      promise.asInstanceOf[scala.concurrent.Promise[Iteratee[Message, R]]].future
     }
 
     def setReadable(channel: Channel, readable: Boolean) {
@@ -174,14 +170,14 @@ private[server] trait WebSocketHandler {
       }
     }
 
-    def frameReceived(ctx: ChannelHandlerContext, input: Input[A]) {
+    def frameReceived(ctx: ChannelHandlerContext, input: Input[Message]) {
       val channel = ctx.getChannel
 
       if (inFlight.incrementAndGet() >= MaxInFlight) {
         setReadable(channel, false)
       }
 
-      val eventuallyNext = Promise[Iteratee[A, Any]]()
+      val eventuallyNext = Promise[Iteratee[Message, Any]]()
       val current = iterateeRef.single.swap(Iteratee.flatten(eventuallyNext.future))
       val next = current.flatFold(
         (a, e) => {
@@ -198,7 +194,6 @@ private[server] trait WebSocketHandler {
               promise.success(next)
               if (channel.isOpen) {
                 for {
-                  _ <- channel.write(new CloseWebSocketFrame(WebSocketNormalClose, "")).toScala
                   _ <- channel.close().toScala
                 } yield next
               } else {
@@ -233,9 +228,9 @@ private[server] trait WebSocketHandler {
     }
   }
 
-  def websocketHandshake[A](ctx: ChannelHandlerContext, req: HttpRequest, e: MessageEvent, bufferLimit: Long)(frameFormatter: FrameFormatter[A]): Enumerator[A] = {
+  def websocketHandshake[A](ctx: ChannelHandlerContext, req: HttpRequest, e: MessageEvent, bufferLimit: Long): Enumerator[Message] = {
 
-    val (enumerator, handler) = newWebSocketInHandler(frameFormatter, bufferLimit)
+    val (enumerator, handler) = newWebSocketInHandler(bufferLimit)
     val p: ChannelPipeline = ctx.getChannel.getPipeline
     p.replace("handler", "handler", handler)
 
diff --git a/framework/src/play-server/src/main/scala/play/core/server/common/WebSocketFlowHandler.scala b/framework/src/play-server/src/main/scala/play/core/server/common/WebSocketFlowHandler.scala
new file mode 100644
index 0000000000..9090b89be3
--- /dev/null
+++ b/framework/src/play-server/src/main/scala/play/core/server/common/WebSocketFlowHandler.scala
@@ -0,0 +1,186 @@
+package play.core.server.common
+
+import java.util.concurrent.atomic.AtomicReference
+
+import akka.stream.AbruptTerminationException
+import akka.stream.scaladsl._
+import akka.stream.stage._
+import play.api.Logger
+import play.api.libs.streams.AkkaStreams
+import AkkaStreams.OnlyFirstCanFinishMerge
+import play.api.http.websocket._
+
+object WebSocketFlowHandler {
+
+  /**
+   * Implements the WebSocket protocol, including correctly handling the closing of the WebSocket, as well as
+   * other control frames like ping/pong.
+   */
+  def webSocketProtocol(flow: Flow[Message, Message, _]): Flow[Message, Message, Unit] = {
+    Flow() { implicit builder =>
+      import FlowGraph.Implicits._
+
+      /**
+       * This is used to track whether the client or the server initiated the close.
+       */
+      val state = new AtomicReference[State](Open)
+
+      /**
+       * Handles incoming control messages, specifically ping and close, and responds to them if necessary,
+       * otherwise ignores them.
+       *
+       * This is the only place that will close the connection, either by responding to client initiated closed
+       * by acking the close message and then terminating, or be receiving a client close ack, and then closing.
+       *
+       * In either case, the connection can only be closed after a client close message has been seen, which is
+       * why this is the only place that actually closes connections.
+       */
+      val handleClientControlMessages = Flow[Message].transform(() => new PushStage[Message, Message] {
+        def onPush(elem: Message, ctx: Context[Message]) = {
+          elem match {
+            case PingMessage(data) =>
+              ctx.push(PongMessage(data))
+            // If we receive a close message from the client, we must send it back before closing
+            case close: CloseMessage if state.compareAndSet(Open, ClientInitiatedClose) =>
+              ctx.pushAndFinish(close)
+            // Otherwise, this must be a clients reply to a server initiated close, we can now close
+            // the TCP connection
+            case close: CloseMessage =>
+              ctx.finish()
+
+            case other => ctx.pull()
+          }
+        }
+      })
+
+      /**
+       * Handles server initiated close.
+       *
+       * The events that can trigger a server initiated close include terminating the stream, failing, or manually
+       * sending a close message.
+       *
+       * This stage will send finish after sending a close message
+       */
+      val handleServerInitiatedClose = new PushPullStage[Message, Message] {
+        var closeToSend: CloseMessage = null
+
+        def onPush(elem: Message, ctx: Context[Message]) = {
+          elem match {
+            case close: CloseMessage if state.compareAndSet(Open, ServerInitiatedClose) =>
+              ctx.pushAndFinish(close)
+            case other => ctx.push(other)
+          }
+        }
+
+        def onPull(ctx: Context[Message]) = {
+          if (closeToSend != null) {
+            val toSend = closeToSend
+            closeToSend = null
+            ctx.pushAndFinish(toSend)
+          } else {
+            ctx.pull()
+          }
+        }
+
+        override def onUpstreamFinish(ctx: Context[Message]) = {
+          if (state.compareAndSet(Open, ServerInitiatedClose)) {
+            closeToSend = CloseMessage(Some(CloseCodes.Regular))
+            ctx.absorbTermination()
+          } else {
+            // Just finish, we must already be finishing.
+            ctx.finish()
+          }
+        }
+
+        override def onUpstreamFailure(cause: Throwable, ctx: Context[Message]) = {
+          if (state.compareAndSet(Open, ServerInitiatedClose)) {
+            cause match {
+              case WebSocketCloseException(close) =>
+                closeToSend = close
+              case ignore: AbruptTerminationException =>
+                // Since the flow handling the WebSocket is usually a disconnected sink/source, if the sink
+                // cancels, then the source will generally never terminate. Eventually when Akka shuts the
+                // actor handling it down, it will fail with an abrupt termination exception. This can generally
+                // be ignored, but we handle it just in case. The closeToSend will never be sent in this
+                // situation, since the Actor is shutting down.
+                logger.trace("WebSocket flow did not complete its downstream, this is probably ok", ignore)
+                closeToSend = CloseMessage(Some(CloseCodes.UnexpectedCondition))
+              case other =>
+                logger.warn("WebSocket flow threw exception, closing WebSocket", other)
+                closeToSend = CloseMessage(Some(CloseCodes.UnexpectedCondition))
+            }
+            ctx.absorbTermination()
+          } else {
+            // Just fail, we must already be finishing.
+            ctx.fail(cause)
+          }
+        }
+      }
+
+      val serverCancellationState = new AtomicReference[Either[AsyncCallback[Message], Message]](null)
+
+      val handleServerCancellation = AkkaStreams.blockCancel[Message] { () =>
+        if (state.compareAndSet(Open, ServerInitiatedClose)) {
+          val close = CloseMessage(Some(CloseCodes.Regular))
+          if (!serverCancellationState.compareAndSet(null, Right(close))) {
+            val Left(callback) = serverCancellationState.get()
+            callback.invoke(close)
+          }
+        }
+      }
+
+      val propagateServerCancellation = Flow[Message].transform(() => new AsyncStage[Message, Message, Message] {
+        def onAsyncInput(event: Message, ctx: AsyncContext[Message, Message]) = {
+          ctx.pushAndFinish(event)
+        }
+        def onPush(elem: Message, ctx: AsyncContext[Message, Message]) = ctx.holdUpstream()
+        def onPull(ctx: AsyncContext[Message, Message]) = {
+          if (!serverCancellationState.compareAndSet(null, Left(ctx.getAsyncCallback()))) {
+            val Right(closeToSend) = serverCancellationState.get()
+            ctx.pushAndFinish(closeToSend)
+          } else {
+            ctx.holdDownstream()
+          }
+        }
+      })
+
+      /**
+       * Blocks all messages after a close message has been sent, in accordance with the WebSocket spec.
+       */
+      val blockAllMessagesAfterClose: Flow[Message, Message, _] = Flow[Message].transform(() => new PushPullStage[Message, Message] {
+        var closeSeen = false
+        def onPush(elem: Message, ctx: Context[Message]) = {
+          if (closeSeen) {
+            ctx.pull()
+          } else {
+            if (elem.isInstanceOf[CloseMessage]) {
+              closeSeen = true
+            }
+            ctx.push(elem)
+          }
+        }
+
+        def onPull(ctx: Context[Message]) = {
+          ctx.pull()
+        }
+      })
+
+      val broadcast = builder.add(Broadcast[Message](2))
+      val merge = builder.add(OnlyFirstCanFinishMerge[Message](3))
+
+      broadcast.out(0) ~> handleClientControlMessages ~> merge.in(0)
+      broadcast.out(1) ~> handleServerCancellation ~> flow.transform(() => handleServerInitiatedClose) ~> merge.in(1)
+      Source.lazyEmpty ~> propagateServerCancellation ~> merge.in(2)
+
+      (broadcast.in, (merge.out ~> blockAllMessagesAfterClose).outlet)
+    }
+
+  }
+
+  private sealed trait State
+  private case object Open extends State
+  private case object ServerInitiatedClose extends State
+  private case object ClientInitiatedClose extends State
+
+  private val logger = Logger("play.core.server.common.WebSocketFlowHandler")
+}
diff --git a/framework/src/play-streams/src/main/scala/play/api/libs/streams/ActorFlow.scala b/framework/src/play-streams/src/main/scala/play/api/libs/streams/ActorFlow.scala
new file mode 100644
index 0000000000..985d345438
--- /dev/null
+++ b/framework/src/play-streams/src/main/scala/play/api/libs/streams/ActorFlow.scala
@@ -0,0 +1,55 @@
+package play.api.libs.streams
+
+import akka.actor._
+import akka.stream.{ Materializer, OverflowStrategy }
+import akka.stream.scaladsl.{ Sink, Keep, Source, Flow }
+
+/**
+ * Provides a flow that is handled by an actor.
+ *
+ * See https://github.com/akka/akka/issues/16985.
+ */
+object ActorFlow {
+
+  /**
+   * Create a flow that is handled by an actor.
+   *
+   * Messages can be sent downstream by sending them to the actor passed into the props function.  This actor meets
+   * the contract of the actor returned by [[Source.actorRef()]].
+   *
+   * The props function should return the props for an actor to handle the flow. This actor will be created using the
+   * passed in [[ActorRefFactory]]. Each message received will be sent to the actor - there is no back pressure,
+   * if the actor is unable to process the messages, they will queue up in the actors mailbox. The upstream can be
+   * cancelled by the actor terminating itself.
+   *
+   * @param props A function that creates the props for actor to handle the flow.
+   * @param bufferSize The maximum number of elements to buffer.
+   * @param overflowStrategy The strategy for how to handle a buffer overflow.
+   */
+  def actorRef[In, Out](props: ActorRef => Props, bufferSize: Int = 16, overflowStrategy: OverflowStrategy = OverflowStrategy.dropNew)(implicit factory: ActorRefFactory, mat: Materializer): Flow[In, Out, Unit] = {
+
+    val (outActor, publisher) = Source.actorRef[Out](bufferSize, overflowStrategy)
+      .toMat(Sink.publisher)(Keep.both).run()
+
+    Flow.wrap(
+      Sink.actorRef(factory.actorOf(Props(new Actor {
+        val flowActor = context.watch(context.actorOf(props(outActor), "flowActor"))
+
+        def receive = {
+          case Status.Success(_) | Status.Failure(_) => flowActor ! PoisonPill
+          case Terminated =>
+            println("Child terminated, stopping")
+            context.stop(self)
+          case other => flowActor ! other
+        }
+
+        override def supervisorStrategy = OneForOneStrategy() {
+          case _ =>
+            println("Stopping actor due to exception")
+            SupervisorStrategy.Stop
+        }
+      })), Status.Success(())),
+      Source(publisher)
+    )(Keep.none)
+  }
+}
diff --git a/framework/src/play-streams/src/main/scala/play/api/libs/streams/AkkaStreams.scala b/framework/src/play-streams/src/main/scala/play/api/libs/streams/AkkaStreams.scala
new file mode 100644
index 0000000000..9c649a4842
--- /dev/null
+++ b/framework/src/play-streams/src/main/scala/play/api/libs/streams/AkkaStreams.scala
@@ -0,0 +1,119 @@
+package play.api.libs.streams
+
+import akka.stream.scaladsl.FlexiMerge.{ MergeLogic, ReadAny }
+import akka.stream.scaladsl._
+import akka.stream.{ Attributes, UniformFanInShape }
+import play.api.libs.iteratee._
+
+import scala.util.{ Failure, Success }
+
+/**
+ * Utilities for
+ */
+object AkkaStreams {
+
+  /**
+   * Bypass the given flow using the given splitter function.
+   *
+   * If the splitter function returns Left, they will go through the flow.  If it returns Right, they will bypass the
+   * flow.
+   */
+  def bypassWith[In, FlowIn, Out](splitter: In => Either[FlowIn, Out]): Flow[FlowIn, Out, _] => Flow[In, Out, _] = {
+    bypassWith(Flow[In].map(splitter))
+  }
+
+  /**
+   * Using the given splitter flow, allow messages to bypass a flow.
+   *
+   * If the splitter flow produces Left, they will be fed into the flow. If it produces Right, they will bypass the
+   * flow.
+   */
+  def bypassWith[In, FlowIn, Out](splitter: Flow[In, Either[FlowIn, Out], _],
+    mergeStrategy: FlexiMerge[Out, UniformFanInShape[Out, Out]] = OnlyFirstCanFinishMerge[Out](2)): Flow[FlowIn, Out, _] => Flow[In, Out, _] = { flow =>
+
+    splitter via Flow[Either[FlowIn, Out], Out]() { implicit builder =>
+      import FlowGraph.Implicits._
+
+      // Eager cancel must be true so that if the flow cancels, that will be propagated upstream.
+      // However, that means the bypasser must block cancel, since when this flow finishes, the merge
+      // will result in a cancel flowing up through the bypasser, which could lead to dropped messages.
+      val broadcast = builder.add(Broadcast[Either[FlowIn, Out]](2, eagerCancel = true))
+      val merge = builder.add(mergeStrategy)
+
+      // Normal flow
+      broadcast.out(0) ~> Flow[Either[FlowIn, Out]].collect {
+        case Left(in) => in
+      } ~> flow ~> merge.in(0)
+
+      // Bypass flow, need to ignore downstream finish
+      broadcast.out(1) ~> blockCancel[Either[FlowIn, Out]](() => ()) ~> Flow[Either[FlowIn, Out]].collect {
+        case Right(out) => out
+      } ~> merge.in(1)
+
+      broadcast.in -> merge.out
+    }
+  }
+
+  /**
+   * Can be replaced if https://github.com/akka/akka/issues/18175 ever gets implemented.
+   */
+  case class EagerFinishMerge[T](inputPorts: Int) extends FlexiMerge[T, UniformFanInShape[T, T]](new UniformFanInShape[T, T](inputPorts), Attributes.name("EagerFinishMerge")) {
+    def createMergeLogic(s: UniformFanInShape[T, T]): MergeLogic[T] =
+      new MergeLogic[T] {
+        def initialState: State[T] = State[T](ReadAny(s.inSeq)) {
+          case (ctx, port, in) =>
+            ctx.emit(in)
+            SameState
+        }
+        override def initialCompletionHandling: CompletionHandling = eagerClose
+      }
+  }
+
+  /**
+   * A merge that only allows the first inlet to finish downstream.
+   */
+  case class OnlyFirstCanFinishMerge[T](inputPorts: Int) extends FlexiMerge[T, UniformFanInShape[T, T]](new UniformFanInShape[T, T](inputPorts), Attributes.name("EagerFinishMerge")) {
+    def createMergeLogic(s: UniformFanInShape[T, T]): MergeLogic[T] =
+      new MergeLogic[T] {
+        def initialState: State[T] = State[T](ReadAny(s.inSeq)) {
+          case (ctx, port, in) =>
+            ctx.emit(in)
+            SameState
+        }
+        override def initialCompletionHandling: CompletionHandling = CompletionHandling(
+          onUpstreamFinish = { (ctx, port) =>
+            if (port == s.in(0)) {
+              ctx.finish()
+            }
+            SameState
+          }, onUpstreamFailure = { (ctx, port, error) =>
+            if (port == s.in(0)) {
+              ctx.fail(error)
+            }
+            SameState
+          }
+        )
+      }
+  }
+
+  /**
+   * Because https://github.com/akka/akka/issues/18189
+   */
+  private[play] def blockCancel[T](onCancel: () => Unit): Flow[T, T, Unit] = {
+    import play.api.libs.iteratee.Execution.Implicits.trampoline
+    val (enum, channel) = Concurrent.broadcast[T]
+    val sink = Sink.foreach[T](channel.push).mapMaterializedValue(_.onComplete {
+      case Success(_) => channel.end()
+      case Failure(t) => channel.end(t)
+    })
+    // This enumerator ignores cancel by flatmapping the iteratee to an Iteratee.ignore
+    val cancelIgnoring = new Enumerator[T] {
+      def apply[A](i: Iteratee[T, A]) =
+        enum(i.flatMap { a =>
+          onCancel()
+          Iteratee.ignore[T].map(_ => a)
+        })
+    }
+    Flow.wrap(sink, Source(Streams.enumeratorToPublisher(cancelIgnoring)))(Keep.none)
+  }
+}
diff --git a/framework/src/play-streams/src/main/scala/play/api/libs/streams/impl/IterateeSubscriber.scala b/framework/src/play-streams/src/main/scala/play/api/libs/streams/impl/IterateeSubscriber.scala
index de114dcc21..ae61b2b2a1 100644
--- a/framework/src/play-streams/src/main/scala/play/api/libs/streams/impl/IterateeSubscriber.scala
+++ b/framework/src/play-streams/src/main/scala/play/api/libs/streams/impl/IterateeSubscriber.scala
@@ -165,20 +165,22 @@ private[streams] class IterateeSubscriber[T, R, S](iter0: Iteratee[T, R])
    * Called when the iteratee folds to a Cont step. We may want to feed
    * an Input to the Iteratee.
    */
-  private def onContStep(cont: Step.Cont[T, R]): Unit = exclusive {
-    case NotSubscribedNoStep(result) =>
-      state = NotSubscribedWithCont(cont, result)
-    case SubscribedNoStep(subs, result) =>
-      subs.request(1)
-      state = SubscribedWithCont(subs, cont, result)
-    case NotSubscribedWithCont(cont, result) =>
-      throw new IllegalStateException("Can't get cont twice")
-    case SubscribedWithCont(subs, cont, result) =>
-      throw new IllegalStateException("Can't get cont twice")
-    case CompletedNoStep(result) =>
-      finishWithCompletedCont(cont, result)
-    case Finished(resultIteratee) =>
-      ()
+  private def onContStep(cont: Step.Cont[T, R]): Unit = {
+    exclusive {
+      case NotSubscribedNoStep(result) =>
+        state = NotSubscribedWithCont(cont, result)
+      case SubscribedNoStep(subs, result) =>
+        subs.request(1)
+        state = SubscribedWithCont(subs, cont, result)
+      case NotSubscribedWithCont(cont, result) =>
+        throw new IllegalStateException("Can't get cont twice")
+      case SubscribedWithCont(subs, cont, result) =>
+        throw new IllegalStateException("Can't get cont twice")
+      case CompletedNoStep(result) =>
+        finishWithCompletedCont(cont, result)
+      case Finished(resultIteratee) =>
+        ()
+    }
   }
 
   /**
diff --git a/framework/src/play/src/main/scala/play/api/Play.scala b/framework/src/play/src/main/scala/play/api/Play.scala
index 5a5d0136de..f98536da56 100644
--- a/framework/src/play/src/main/scala/play/api/Play.scala
+++ b/framework/src/play/src/main/scala/play/api/Play.scala
@@ -3,6 +3,7 @@
  */
 package play.api
 
+import akka.stream.Materializer
 import play.api.i18n.MessagesApi
 import play.utils.Threads
 
@@ -236,4 +237,9 @@ object Play {
    */
   def langCookieHttpOnly(implicit messagesApi: MessagesApi): Boolean =
     messagesApi.langCookieHttpOnly
+
+  /**
+   * A convenient function for getting an implicit materializer from the current application
+   */
+  implicit def materializer(implicit app: Application): Materializer = app.materializer
 }
diff --git a/framework/src/play/src/main/scala/play/api/http/websocket/CloseCodes.scala b/framework/src/play/src/main/scala/play/api/http/websocket/CloseCodes.scala
new file mode 100644
index 0000000000..a3666fb3e1
--- /dev/null
+++ b/framework/src/play/src/main/scala/play/api/http/websocket/CloseCodes.scala
@@ -0,0 +1,18 @@
+package play.api.http.websocket
+
+/**
+ * WebSocket close codes
+ */
+object CloseCodes {
+  val Regular = 1000
+  val GoingAway = 1001
+  val ProtocolError = 1002
+  val Unacceptable = 1003
+  val ConnectionAbort = 1006
+  val InconsistentData = 1007
+  val PolicyViolated = 1008
+  val TooBig = 1009
+  val ClientRejectsExtension = 1010
+  val UnexpectedCondition = 1011
+  val TLSHandshakeFailure = 1015
+}
diff --git a/framework/src/play/src/main/scala/play/api/http/websocket/Message.scala b/framework/src/play/src/main/scala/play/api/http/websocket/Message.scala
new file mode 100644
index 0000000000..cf00802543
--- /dev/null
+++ b/framework/src/play/src/main/scala/play/api/http/websocket/Message.scala
@@ -0,0 +1,54 @@
+package play.api.http.websocket
+
+import akka.util.ByteString
+
+/**
+ * A WebSocket message.
+ *
+ * This is a high level API intended for common simple use cases.  It allows handling and sending of full
+ * WebSocket messages, as well as close and ping/pong messages.  It will buffer fragmented messages up until
+ * a limit, and does not allow streaming in fragments.
+ */
+sealed trait Message
+
+/**
+ * A text message.
+ *
+ * @param data The data of the text message.
+ */
+case class TextMessage(data: String) extends Message
+
+/**
+ * A binary message.
+ *
+ * @param data The data of the binary message.
+ */
+case class BinaryMessage(data: ByteString) extends Message
+
+/**
+ * A close message.
+ *
+ * @param statusCode The close status code.
+ * @param reason The reason it was closed.
+ */
+case class CloseMessage(statusCode: Option[Int] = Some(CloseCodes.Regular), reason: String = "") extends Message
+/**
+ * A ping message.
+ *
+ * @param data The application data.
+ */
+case class PingMessage(data: ByteString) extends Message
+
+/**
+ * A pong message.
+ *
+ * @param data The application data.
+ */
+case class PongMessage(data: ByteString) extends Message
+
+/**
+ * An exception that, if thrown by a WebSocket source, will cause the WebSocket to be closed with the given close
+ * message. This is a convenience that allows the WebSocket to close with a particular close code without having
+ * to produce generic Messages.
+ */
+case class WebSocketCloseException(message: CloseMessage) extends RuntimeException(message.reason, null, false, false)
diff --git a/framework/src/play/src/main/scala/play/api/mvc/WebSocket.scala b/framework/src/play/src/main/scala/play/api/mvc/WebSocket.scala
index 4e9e9a7ebc..ca4f2dd113 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/WebSocket.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/WebSocket.scala
@@ -3,38 +3,36 @@
  */
 package play.api.mvc
 
-import play.api.libs.json._
+import akka.stream.Materializer
+import akka.stream.scaladsl.{ Keep, Source, Sink, Flow }
+import akka.util.ByteString
+import play.api.http.websocket._
 import play.api.libs.iteratee._
-import play.api.libs.concurrent._
+import play.api.libs.json._
+import play.api.libs.concurrent.Akka
+import play.api.libs.streams.{ AkkaStreams, ActorFlow, Streams }
 
-import scala.concurrent.Future
+import scala.concurrent.{ ExecutionContext, Promise, Future }
 
-import play.core.Execution.Implicits.internalContext
+import play.api.libs.iteratee.Execution.Implicits.trampoline
 import akka.actor.{ Props, ActorRef }
 import play.api.Application
 import scala.reflect.ClassTag
-import play.core.actors.WebSocketActor._
-import play.core.websocket.BasicFrameFormatter
+
+import scala.util.control.NonFatal
 
 /**
  * A WebSocket handler.
- *
- * @tparam In the type of messages coming in
- * @tparam Out the type of messages going out
- * @param f the socket messages generator
  */
-case class WebSocket[In, Out](f: RequestHeader => Future[Either[Result, (Enumerator[In], Iteratee[Out, Unit]) => Unit]])(implicit val inFormatter: WebSocket.FrameFormatter[In], val outFormatter: WebSocket.FrameFormatter[Out]) extends Handler {
-
-  type FramesIn = In
-  type FramesOut = Out
+trait WebSocket extends Handler {
 
   /**
-   * Returns itself, for better support in the routes file.
+   * Execute the WebSocket.
    *
-   * @return itself
+   * The return value is either a result to reject the WebSocket with (or otherwise respond in a different way), or
+   * a flow to handle the WebSocket messages.
    */
-  def apply() = this
-
+  def apply(request: RequestHeader): Future[Either[Result, Flow[Message, Message, _]]]
 }
 
 /**
@@ -42,79 +40,211 @@ case class WebSocket[In, Out](f: RequestHeader => Future[Either[Result, (Enumera
  */
 object WebSocket {
 
+  def apply(f: RequestHeader => Future[Either[Result, Flow[Message, Message, _]]]): WebSocket = {
+    new WebSocket {
+      def apply(request: RequestHeader) = f(request)
+    }
+  }
+
   /**
-   * Typeclass to handle WebSocket frames format.
+   * Transforms WebSocket message flows into message flows of another type.
+   *
+   * The transformation may be more than just converting from one message to another, it may also produce messages, such
+   * as close messages with an appropriate error code if the message can't be consumed.
    */
-  trait FrameFormatter[A] {
+  trait MessageFlowTransformer[+In, -Out] { self =>
 
     /**
-     * Transform a FrameFormatter[A] to a FrameFormatter[B]
+     * Transform the flow of In/Out messages into a flow of WebSocket messages.
      */
-    def transform[B](fba: B => A, fab: A => B): FrameFormatter[B]
+    def transform(flow: Flow[In, Out, _]): Flow[Message, Message, _]
 
+    /**
+     * Contramap the out type of this transformer.
+     */
+    def contramap[NewOut](f: NewOut => Out): MessageFlowTransformer[In, NewOut] = {
+      new MessageFlowTransformer[In, NewOut] {
+        def transform(flow: Flow[In, NewOut, _]) = {
+          self.transform(
+            flow map f
+          )
+        }
+      }
+    }
+
+    /**
+     * Map the in type of this transformer.
+     */
+    def map[NewIn](f: In => NewIn): MessageFlowTransformer[NewIn, Out] = {
+      new MessageFlowTransformer[NewIn, Out] {
+        def transform(flow: Flow[NewIn, Out, _]) = {
+          self.transform(
+            Flow[In] map f via flow
+          )
+        }
+      }
+    }
+
+    /**
+     * Map the in type and contramap the out type of this transformer.
+     */
+    def map[NewIn, NewOut](f: In => NewIn, g: NewOut => Out): MessageFlowTransformer[NewIn, NewOut] = {
+      new MessageFlowTransformer[NewIn, NewOut] {
+        def transform(flow: Flow[NewIn, NewOut, _]) = {
+          self.transform(
+            Flow[In] map f via flow map g
+          )
+        }
+      }
+    }
   }
 
-  /**
-   * Defaults frame formatters.
-   */
-  object FrameFormatter {
+  object MessageFlowTransformer {
 
     /**
-     * String WebSocket frames.
+     * Converts text messages to/from Strings.
      */
-    implicit val stringFrame: FrameFormatter[String] = BasicFrameFormatter.textFrame
+    implicit val stringMessageFlowTransformer: MessageFlowTransformer[String, String] = {
+      new MessageFlowTransformer[String, String] {
+        def transform(flow: Flow[String, String, _]) = {
+          AkkaStreams.bypassWith[Message, String, Message](Flow[Message] collect {
+            case TextMessage(text) => Left(text)
+            case BinaryMessage(_) =>
+              Right(CloseMessage(Some(CloseCodes.Unacceptable),
+                "This WebSocket only supports text frames"))
+          })(flow map TextMessage.apply)
+        }
+      }
+    }
 
     /**
-     * Array[Byte] WebSocket frames.
+     * Converts binary messages to/from ByteStrings.
      */
-    implicit val byteArrayFrame: FrameFormatter[Array[Byte]] = BasicFrameFormatter.binaryFrame
+    implicit val byteStringMessageFlowTransformer: MessageFlowTransformer[ByteString, ByteString] = {
+      new MessageFlowTransformer[ByteString, ByteString] {
+        def transform(flow: Flow[ByteString, ByteString, _]) = {
+          AkkaStreams.bypassWith[Message, ByteString, Message](Flow[Message] collect {
+            case BinaryMessage(data) => Left(data)
+            case TextMessage(_) =>
+              Right(CloseMessage(Some(CloseCodes.Unacceptable),
+                "This WebSocket only supports binary frames"))
+          })(flow map BinaryMessage.apply)
+        }
+      }
+    }
 
     /**
-     * Either String or Array[Byte] WebSocket frames.
+     * Converts binary messages to/from byte arrays.
      */
-    implicit val mixedFrame: FrameFormatter[Either[String, Array[Byte]]] = BasicFrameFormatter.mixedFrame
+    implicit val byteArrayMessageFlowTransformer: MessageFlowTransformer[Array[Byte], Array[Byte]] = {
+      byteStringMessageFlowTransformer.map(_.toArray, ByteString.apply)
+    }
 
     /**
-     * Json WebSocket frames.
+     * Converts messages to/from JsValue
      */
-    implicit val jsonFrame: FrameFormatter[JsValue] = stringFrame.transform(Json.stringify, Json.parse)
+    implicit val jsonMessageFlowTransformer: MessageFlowTransformer[JsValue, JsValue] = {
+      def closeOnException[T](block: => T) = try {
+        Left(block)
+      } catch {
+        case NonFatal(e) => Right(CloseMessage(Some(CloseCodes.Unacceptable),
+          "Unable to parse json message"))
+      }
+
+      new MessageFlowTransformer[JsValue, JsValue] {
+        def transform(flow: Flow[JsValue, JsValue, _]) = {
+          AkkaStreams.bypassWith[Message, JsValue, Message](Flow[Message].collect {
+            case BinaryMessage(data) => closeOnException(Json.parse(data.iterator.asInputStream))
+            case TextMessage(text) => closeOnException(Json.parse(text))
+          })(flow map { json => TextMessage(Json.stringify(json)) })
+        }
+      }
+    }
+
+    /**
+     * Converts messages to/from a JSON high level object.
+     *
+     * If the input messages fail to be parsed, the WebSocket will be closed with an 1003 close code and the parse error
+     * serialised to JSON.
+     */
+    def jsonMessageFlowTransformer[In: Reads, Out: Writes]: MessageFlowTransformer[In, Out] = {
+      jsonMessageFlowTransformer.map(json => Json.fromJson[In](json).fold({ errors =>
+        throw WebSocketCloseException(CloseMessage(Some(CloseCodes.Unacceptable), Json.stringify(JsError.toJson(errors))))
+      }, identity), out => Json.toJson(out))
+    }
+  }
+
+  @deprecated("Use MessageFlowTransformer instead", "2.5.0")
+  type FrameFormatter[A] = MessageFlowTransformer[A, A]
+
+  /**
+   * Defaults frame formatters.
+   */
+  object FrameFormatter {
 
     /**
      * Json WebSocket frames, parsed into/formatted from objects of type A.
      */
-    def jsonFrame[A: Format]: FrameFormatter[A] = jsonFrame.transform[A](
-      out => Json.toJson(out),
-      in => Json.fromJson[A](in).fold(
-        error => throw new RuntimeException("Error parsing JSON: " + error),
-        a => a
-      )
-    )
+    @deprecated("Use MessageFlowTransformer.jsonMessageFlowTransformer instead", "2.5.0")
+    def jsonFrame[A: Format]: MessageFlowTransformer[A, A] = MessageFlowTransformer.jsonMessageFlowTransformer[A, A]
   }
 
   /**
    * Accepts a WebSocket using the given inbound/outbound channels.
    */
-  def using[A](f: RequestHeader => (Iteratee[A, _], Enumerator[A]))(implicit frameFormatter: FrameFormatter[A]): WebSocket[A, A] = {
+  @deprecated("Use accept with an Akka streams flow instead", "2.5.0")
+  def using[A](f: RequestHeader => (Iteratee[A, _], Enumerator[A]))(implicit frameFormatter: MessageFlowTransformer[A, A]): WebSocket = {
     tryAccept[A](f.andThen(handler => Future.successful(Right(handler))))
   }
 
   /**
    * Creates a WebSocket that will adapt the incoming stream and send it back out.
    */
-  def adapter[A](f: RequestHeader => Enumeratee[A, A])(implicit frameFormatter: FrameFormatter[A]): WebSocket[A, A] = {
-    WebSocket[A, A](h => Future.successful(Right((in, out) => { in &> f(h) |>> out })))
+  @deprecated("Use accept with an Akka streams flow instead", "2.5.0")
+  def adapter[A](f: RequestHeader => Enumeratee[A, A])(implicit transformer: MessageFlowTransformer[A, A]): WebSocket = {
+    using(f.andThen { enumeratee =>
+      val (iteratee, enumerator) = Concurrent.joined[A]
+      (enumeratee &> iteratee, enumerator)
+    })
   }
 
   /**
    * Creates an action that will either reject the websocket with the given result, or will be handled by the given
    * inbound and outbound channels, asynchronously
    */
-  def tryAccept[A](f: RequestHeader => Future[Either[Result, (Iteratee[A, _], Enumerator[A])]])(implicit frameFormatter: FrameFormatter[A]): WebSocket[A, A] = {
-    WebSocket[A, A](f.andThen(_.map { resultOrSocket =>
-      resultOrSocket.right.map {
-        case (readIn, writeOut) => (e, i) => { e |>> readIn; writeOut |>> i }
-      }
-    }))
+  @deprecated("Use acceptOrResult with an Akka streams flow instead", "2.5.0")
+  def tryAccept[A](f: RequestHeader => Future[Either[Result, (Iteratee[A, _], Enumerator[A])]])(implicit transformer: MessageFlowTransformer[A, A]): WebSocket = {
+    acceptOrResult[A, A](f.andThen(_.map(_.right.map {
+      case (iteratee, enumerator) =>
+        // Play 2.4 and earlier only closed the WebSocket if the enumerator specifically fed EOF. So, you could
+        // return an empty enumerator, and it would never close the socket. Converting an empty enumerator to a
+        // publisher however will close the socket, so, we need to ensure the enumerator only completes if EOF
+        // is sent.
+        val enumeratorCompletion = Promise[Enumerator[A]]()
+        val nonCompletingEnumerator = onEOF(enumerator, () => {
+          enumeratorCompletion.success(Enumerator.empty)
+        }) >>> Enumerator.flatten(enumeratorCompletion.future)
+        val publisher = Streams.enumeratorToPublisher(nonCompletingEnumerator)
+        val (subscriber, _) = Streams.iterateeToSubscriber(iteratee)
+        Flow.wrap(Sink(subscriber), Source(publisher))(Keep.none)
+    })))
+  }
+
+  /**
+   * Accepts a WebSocket using the given flow.
+   */
+  def accept[In, Out](f: RequestHeader => Flow[In, Out, _])(implicit transformer: MessageFlowTransformer[In, Out]): WebSocket = {
+    acceptOrResult(f.andThen(flow => Future.successful(Right(flow))))
+  }
+
+  /**
+   * Creates an action that will either accept the websocket, using the given flow to handle the in and out stream, or
+   * return a result to reject the Websocket.
+   */
+  def acceptOrResult[In, Out](f: RequestHeader => Future[Either[Result, Flow[In, Out, _]]])(implicit transformer: MessageFlowTransformer[In, Out]): WebSocket = {
+    WebSocket { request =>
+      f(request).map(_.right.map(transformer.transform))
+    }
   }
 
   /**
@@ -137,8 +267,9 @@ object WebSocket {
    *   }
    * }}}
    */
-  def acceptWithActor[In, Out](f: RequestHeader => HandlerProps)(implicit in: FrameFormatter[In],
-    out: FrameFormatter[Out], app: Application, outMessageType: ClassTag[Out]): WebSocket[In, Out] = {
+  @deprecated("Use accept with a flow that wraps a Sink.actorRef and Source.actorRef, or play.api.libs.Streams.actorFlow", "2.5.0")
+  def acceptWithActor[In, Out](f: RequestHeader => HandlerProps)(implicit transformer: MessageFlowTransformer[In, Out],
+    app: Application, mat: Materializer): WebSocket = {
     tryAcceptWithActor { req =>
       Future.successful(Right((actorRef) => f(req)(actorRef)))
     }
@@ -165,17 +296,33 @@ object WebSocket {
    *   }
    * }}}
    */
-  def tryAcceptWithActor[In, Out](f: RequestHeader => Future[Either[Result, HandlerProps]])(implicit in: FrameFormatter[In],
-    out: FrameFormatter[Out], app: Application, outMessageType: ClassTag[Out]): WebSocket[In, Out] = {
-    WebSocket[In, Out] { request =>
-      f(request).map { resultOrProps =>
-        resultOrProps.right.map { props =>
-          (enumerator, iteratee) =>
-            WebSocketsExtension(Akka.system).actor !
-              WebSocketsActor.Connect(request.id, enumerator, iteratee, props)
-        }
-      }
-    }
+  @deprecated("Use acceptOrResult with a flow that wraps a Sink.actorRef and Source.actorRef, or play.api.libs.Streams.actorFlow", "2.5.0")
+  def tryAcceptWithActor[In, Out](f: RequestHeader => Future[Either[Result, HandlerProps]])(implicit transformer: MessageFlowTransformer[In, Out],
+    app: Application, mat: Materializer): WebSocket = {
+
+    implicit val system = Akka.system
+
+    acceptOrResult(f.andThen(_.map(_.right.map { props =>
+      ActorFlow.actorRef(props)
+    })))
   }
 
+  /**
+   * Like Enumeratee.onEOF, however enumeratee.onEOF always gets fed an EOF (by the enumerator if nothing else).
+   */
+  private def onEOF[E](enumerator: Enumerator[E], action: () => Unit): Enumerator[E] = new Enumerator[E] {
+    def apply[A](i: Iteratee[E, A]) = enumerator(wrap(i))
+
+    def wrap[A](i: Iteratee[E, A]): Iteratee[E, A] = new Iteratee[E, A] {
+      def fold[B](folder: (Step[E, A]) => Future[B])(implicit ec: ExecutionContext) = i.fold {
+        case Step.Cont(k) => folder(Step.Cont {
+          case eof @ Input.EOF =>
+            action()
+            wrap(k(eof))
+          case other => wrap(k(other))
+        })
+        case other => folder(other)
+      }(ec)
+    }
+  }
 }
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala b/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
index 9ca207fde3..820edc47c5 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaWebSocket.scala
@@ -3,6 +3,11 @@
  */
 package play.core.j
 
+import akka.actor.Status
+import akka.stream.OverflowStrategy
+import akka.stream.scaladsl.{ Keep, Source, Flow, Sink }
+import play.api.libs.streams.ActorFlow
+import play.api.mvc.WebSocket.MessageFlowTransformer
 import play.api.mvc._
 import play.mvc.Http.{ Context => JContext }
 import play.mvc.{ WebSocket => JWebSocket }
@@ -11,19 +16,17 @@ import scala.collection.JavaConverters._
 
 import scala.concurrent.Future
 import com.fasterxml.jackson.databind.JsonNode
-import play.core.actors.WebSocketActor._
 import play.api.libs.concurrent.Akka
 
 import play.api.Play.current
 import play.core.Execution.Implicits.internalContext
-import scala.reflect.ClassTag
 
 /**
  * handles a scala websocket in a Java Context
  */
 object JavaWebSocket extends JavaHelpers {
 
-  def webSocketWrapper[A](retrieveWebSocket: => Future[JWebSocket[A]])(implicit frameFormatter: WebSocket.FrameFormatter[A], mt: ClassTag[A]): WebSocket[A, A] = WebSocket[A, A] { request =>
+  def webSocketWrapper[A](retrieveWebSocket: => Future[JWebSocket[A]])(implicit transformer: MessageFlowTransformer[A, A]): WebSocket = WebSocket { request =>
 
     val javaContext = createJavaContext(request)
 
@@ -42,70 +45,68 @@ object JavaWebSocket extends JavaHelpers {
 
       } getOrElse {
 
-        Right((in, out) => {
+        implicit val system = Akka.system
+        implicit val mat = current.materializer
 
-          if (jws.isActor) {
-
-            WebSocketsExtension(Akka.system).actor !
-              WebSocketsActor.Connect(request.id, in, out, actorRef => jws.actorProps(actorRef))
+        Right(
 
+          if (jws.isActor) {
+            transformer.transform(ActorFlow.actorRef(jws.actorProps))
           } else {
 
-            import play.api.libs.iteratee._
-
-            val (enumerator, channel) = Concurrent.broadcast[A]
-
-            val socketOut = new play.mvc.WebSocket.Out[A] {
-              def write(frame: A) {
-                channel.push(frame)
-              }
-              def close() {
-                channel.eofAndEnd()
-              }
-            }
-
             val socketIn = new play.mvc.WebSocket.In[A]
 
-            enumerator |>> out
-
-            jws.onReady(socketIn, socketOut)
-
-            in |>> {
-              Iteratee.foreach[A](msg => socketIn.callbacks.asScala.foreach(_.accept(msg))).map { _ =>
-                socketIn.closeCallbacks.asScala.foreach(_.run())
+            val sink = Flow[A].map { msg =>
+              socketIn.callbacks.asScala.foreach(_.accept(msg))
+            }.to(Sink.onComplete { _ =>
+              socketIn.closeCallbacks.asScala.foreach(_.run())
+            })
+
+            val source = Source.actorRef[A](256, OverflowStrategy.dropNew).mapMaterializedValue { actor =>
+              val socketOut = new play.mvc.WebSocket.Out[A] {
+                def write(frame: A) = {
+                  actor ! frame
+                }
+                def close() = {
+                  actor ! Status.Success(())
+                }
               }
+
+              jws.onReady(socketIn, socketOut)
             }
+
+            transformer.transform(Flow.wrap(sink, source)(Keep.none))
           }
-        })
+        )
       }
     }
   }
 
   // -- Bytes
 
-  def ofBytes(retrieveWebSocket: => JWebSocket[Array[Byte]]): WebSocket[Array[Byte], Array[Byte]] =
+  def ofBytes(retrieveWebSocket: => JWebSocket[Array[Byte]]): WebSocket =
     webSocketWrapper[Array[Byte]](Future.successful(retrieveWebSocket))
 
-  def promiseOfBytes(retrieveWebSocket: => JPromise[JWebSocket[Array[Byte]]]): WebSocket[Array[Byte], Array[Byte]] =
+  def promiseOfBytes(retrieveWebSocket: => JPromise[JWebSocket[Array[Byte]]]): WebSocket =
     webSocketWrapper[Array[Byte]](retrieveWebSocket.wrapped())
 
   // -- String
 
-  def ofString(retrieveWebSocket: => JWebSocket[String]): WebSocket[String, String] =
+  def ofString(retrieveWebSocket: => JWebSocket[String]): WebSocket =
     webSocketWrapper[String](Future.successful(retrieveWebSocket))
 
-  def promiseOfString(retrieveWebSocket: => JPromise[JWebSocket[String]]): WebSocket[String, String] =
+  def promiseOfString(retrieveWebSocket: => JPromise[JWebSocket[String]]): WebSocket =
     webSocketWrapper[String](retrieveWebSocket.wrapped())
 
   // -- Json (JsonNode)
 
-  implicit val jsonFrame = WebSocket.FrameFormatter.stringFrame.transform(
-    play.libs.Json.stringify, play.libs.Json.parse
+  implicit val jsonFrame = MessageFlowTransformer.stringMessageFlowTransformer.map(
+    play.libs.Json.parse, play.libs.Json.stringify
   )
 
-  def ofJson(retrieveWebSocket: => JWebSocket[JsonNode]): WebSocket[JsonNode, JsonNode] =
+  def ofJson(retrieveWebSocket: => JWebSocket[JsonNode]): WebSocket =
     webSocketWrapper[JsonNode](Future.successful(retrieveWebSocket))
 
-  def promiseOfJson(retrieveWebSocket: => JPromise[JWebSocket[JsonNode]]): WebSocket[JsonNode, JsonNode] =
+  def promiseOfJson(retrieveWebSocket: => JPromise[JWebSocket[JsonNode]]): WebSocket =
     webSocketWrapper[JsonNode](retrieveWebSocket.wrapped())
 }
diff --git a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
index 2a3b580150..1f7fd5c3da 100644
--- a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
+++ b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
@@ -37,8 +37,8 @@ private class TaggingInvoker[A](underlyingInvoker: HandlerInvoker[A], handlerDef
         def apply(rh: RequestHeader) = action(rh)
         def tagRequest(rh: RequestHeader) = taggedRequest(rh, cachedHandlerTags)
       }
-      case ws @ WebSocket(f) =>
-        WebSocket[ws.FramesIn, ws.FramesOut](rh => ws.f(taggedRequest(rh, cachedHandlerTags)))(ws.inFormatter, ws.outFormatter)
+      case ws: WebSocket =>
+        WebSocket(rh => ws(taggedRequest(rh, cachedHandlerTags)))
       case other => other
     }
   }
@@ -143,10 +143,10 @@ object HandlerInvokerFactory {
    * Create a `HandlerInvokerFactory` for a Java WebSocket.
    */
   private abstract class JavaWebSocketInvokerFactory[A, B] extends HandlerInvokerFactory[A] {
-    def webSocketCall(call: => A): WebSocket[B, B]
+    def webSocketCall(call: => A): WebSocket
     def createInvoker(fakeCall: => A, handlerDef: HandlerDef): HandlerInvoker[A] = new HandlerInvoker[A] {
       val cachedHandlerTags = handlerTags(handlerDef)
-      def call(call: => A): WebSocket[B, B] = webSocketCall(call)
+      def call(call: => A): WebSocket = webSocketCall(call)
     }
   }
 
diff --git a/framework/src/play/src/main/scala/play/core/websocket/BasicFrame.scala b/framework/src/play/src/main/scala/play/core/websocket/BasicFrame.scala
deleted file mode 100644
index 9f98254a5d..0000000000
--- a/framework/src/play/src/main/scala/play/core/websocket/BasicFrame.scala
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
- */
-package play.core.websocket
-
-import play.api.mvc.WebSocket.FrameFormatter
-
-/**
- * A type of WebSocket frame.
- */
-sealed trait BasicFrame
-
-/**
- * A text WebSocket frame.
- */
-final case class TextFrame(text: String) extends BasicFrame
-
-/**
- * A binary WebSocket frame.
- */
-final case class BinaryFrame(bytes: Array[Byte]) extends BasicFrame
diff --git a/framework/src/play/src/main/scala/play/core/websocket/BasicFrameFormatter.scala b/framework/src/play/src/main/scala/play/core/websocket/BasicFrameFormatter.scala
deleted file mode 100644
index d10409b063..0000000000
--- a/framework/src/play/src/main/scala/play/core/websocket/BasicFrameFormatter.scala
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
- */
-package play.core.websocket
-
-import play.api.mvc.WebSocket.FrameFormatter
-
-/**
- * A FrameFormatter that produces BasicFrames.
- *
- * @param toFrame Function to convert to a BasicFrame.
- * @param fromFrame PartialFunction to convert from a BasicFrame.
- * @param handlesFromFrameClass Function to check if fromFrame would
- * handle a given BasicFrame class. Can be used instead of calling
- * fromFrame.isDefinedAt. The benefit of calling this function is that
- * it can avoid the need to construct a BasicFrame object, which can
- * save copying buffers.
- */
-trait BasicFrameFormatter[A] extends FrameFormatter[A] {
-  top =>
-
-  def toFrame(value: A): BasicFrame
-  /** Throws IllegalArgumentException if it can't handle the BasicFrame class */
-  def fromFrame(frame: BasicFrame): A
-  def fromFrameDefined(clazz: Class[_]): Boolean
-
-  def transform[B](fba: B => A, fab: A => B): FrameFormatter[B] = new BasicFrameFormatter[B] {
-    def toFrame(value: B): BasicFrame = top.toFrame(fba(value))
-    def fromFrame(frame: BasicFrame): B = fab(top.fromFrame(frame))
-    def fromFrameDefined(clazz: Class[_]): Boolean = top.fromFrameDefined(clazz)
-  }
-
-}
-
-object BasicFrameFormatter {
-
-  private val textFrameClass = classOf[TextFrame]
-  private val binaryFrameClass = classOf[BinaryFrame]
-
-  object textFrame extends BasicFrameFormatter[String] {
-    def toFrame(text: String): BasicFrame = TextFrame(text)
-    /** Throws IllegalArgumentException */
-    def fromFrame(frame: BasicFrame): String = frame match {
-      case TextFrame(text) => text
-      case invalid => throw new IllegalArgumentException(s"Can only handle TextFrame; can't handle frame: $invalid")
-    }
-    def fromFrameDefined(clazz: Class[_]): Boolean = clazz match {
-      case `textFrameClass` => true
-      case _ => false
-    }
-  }
-
-  object binaryFrame extends BasicFrameFormatter[Array[Byte]] {
-    def toFrame(bytes: Array[Byte]): BasicFrame = BinaryFrame(bytes)
-    def fromFrame(frame: BasicFrame): Array[Byte] = frame match {
-      case BinaryFrame(bytes) => bytes
-      case invalid => throw new IllegalArgumentException(s"Can only handle BinaryFrame; can't handle frame: $invalid")
-    }
-    def fromFrameDefined(clazz: Class[_]): Boolean = clazz match {
-      case `binaryFrameClass` => true
-      case _ => false
-    }
-  }
-
-  object mixedFrame extends BasicFrameFormatter[Either[String, Array[Byte]]] {
-    def toFrame(either: Either[String, Array[Byte]]): BasicFrame = either match {
-      case Left(text) => TextFrame(text)
-      case Right(bytes) => BinaryFrame(bytes)
-    }
-    def fromFrame(frame: BasicFrame): Either[String, Array[Byte]] = frame match {
-      case TextFrame(text) => Left(text)
-      case BinaryFrame(bytes) => Right(bytes)
-    }
-    def fromFrameDefined(clazz: Class[_]): Boolean = clazz match {
-      case `textFrameClass` => true
-      case `binaryFrameClass` => true
-      case _ => false // shouldn't be reachable
-    }
-  }
-
-}
diff --git a/framework/src/play/src/test/scala/play/core/websocket/BasicFrameFormatterSpec.scala b/framework/src/play/src/test/scala/play/core/websocket/BasicFrameFormatterSpec.scala
deleted file mode 100644
index a146edffb3..0000000000
--- a/framework/src/play/src/test/scala/play/core/websocket/BasicFrameFormatterSpec.scala
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
- */
-package play.core.websocket
-
-import org.specs2.mutable.Specification
-
-object BasicFrameFormatterSpec extends Specification {
-
-  "BasicFrameFormatter.textFrame" should {
-    "translate strings to TextFrames" in {
-      BasicFrameFormatter.textFrame.toFrame("hello") must_== TextFrame("hello")
-    }
-    "translate TextFrames to strings" in {
-      BasicFrameFormatter.textFrame.fromFrame(TextFrame("hello")) must_== "hello"
-    }
-    "not translate BinaryFrames" in {
-      BasicFrameFormatter.textFrame.fromFrame(BinaryFrame(Array[Byte](1, 2, 3))) must throwAn[IllegalArgumentException]
-    }
-    "say that it handles TextFrames" in {
-      BasicFrameFormatter.textFrame.fromFrameDefined(classOf[TextFrame]) must beTrue
-    }
-    "say that it doesn't handle BinaryFrames" in {
-      BasicFrameFormatter.textFrame.fromFrameDefined(classOf[BinaryFrame]) must beFalse
-    }
-  }
-
-  "BasicFrameFormatter.binaryFrame" should {
-    "translate byte arrays to BinaryFrames" in {
-      BasicFrameFormatter.binaryFrame.toFrame(Array[Byte](1, 2, 3)) must beLike {
-        case BinaryFrame(bytes) => bytes.to[Seq] must_== Seq[Byte](1, 2, 3)
-      }
-    }
-    "translate BinaryFrames to byte arrays" in {
-      BasicFrameFormatter.binaryFrame.fromFrame(BinaryFrame(Array[Byte](1, 2, 3))).to[Seq] must_== Seq[Byte](1, 2, 3)
-    }
-    "not translate TextFrames" in {
-      BasicFrameFormatter.binaryFrame.fromFrame(TextFrame("foo")) must throwAn[IllegalArgumentException]
-    }
-    "say that it handles BinaryFrames" in {
-      BasicFrameFormatter.binaryFrame.fromFrameDefined(classOf[BinaryFrame]) must beTrue
-    }
-    "say that it doesn't handle TextFrames" in {
-      BasicFrameFormatter.binaryFrame.fromFrameDefined(classOf[TextFrame]) must beFalse
-    }
-  }
-
-  "BasicFrameFormatter.mixedFrame" should {
-    "translate strings to TextFrames" in {
-      BasicFrameFormatter.mixedFrame.toFrame(Left("banana")) must_== TextFrame("banana")
-    }
-    "translate byte arrays to BinaryFrames" in {
-      BasicFrameFormatter.mixedFrame.toFrame(Right(Array[Byte](1, 2, 3))) must beLike {
-        case BinaryFrame(bytes) => bytes.to[Seq] must_== Seq[Byte](1, 2, 3)
-      }
-    }
-    "translate TextFrames to strings" in {
-      BasicFrameFormatter.mixedFrame.fromFrame(TextFrame("elephant")) must_== Left("elephant")
-    }
-    "translate BinaryFrames to byte arrays" in {
-      BasicFrameFormatter.mixedFrame.fromFrame(BinaryFrame(Array[Byte](1, 2, 3))) must beRight.like {
-        case bytes => bytes.to[Seq] must_== Seq[Byte](1, 2, 3)
-      }
-    }
-    "say that it handles BinaryFrames" in {
-      BasicFrameFormatter.mixedFrame.fromFrameDefined(classOf[BinaryFrame]) must beTrue
-    }
-    "say that it handles TextFrames" in {
-      BasicFrameFormatter.mixedFrame.fromFrameDefined(classOf[TextFrame]) must beTrue
-    }
-  }
-
-}
