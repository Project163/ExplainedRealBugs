diff --git a/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md b/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
index b603ccf288..fcd0c2a4e6 100644
--- a/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
+++ b/documentation/manual/working/javaGuide/main/http/JavaActionsComposition.md
@@ -5,15 +5,7 @@ This chapter introduces several ways to define generic action functionality.
 
 ## Reminder about actions
 
-Previously, we said that an action is a Java method that returns a `play.mvc.Result` value. Actually, Play manages internally actions as functions. Because Java doesn't yet support first class functions, an action provided by the Java API is an instance of [`play.mvc.Action`](api/java/play/mvc/Action.html):
-
-```java
-public abstract class Action {
-  public abstract CompletionStage<Result> call(Context ctx);
-}
-```
-
-Play builds a root action for you that just calls the proper action method. This allows for more complicated action composition.
+Previously, we said that an action is a Java method that returns a `play.mvc.Result` value. Actually, Play manages internally actions as functions. An action provided by the Java API is an instance of [`play.mvc.Action`](api/java/play/mvc/Action.html). Play builds a root action for you that just calls the proper action method. This allows for more complicated action composition.
 
 ## Composing actions
 
@@ -21,7 +13,7 @@ Here is the definition of the `VerboseAction`:
 
 @[verbose-action](code/javaguide/http/JavaActionsComposition.java)
 
-You can compose the code provided by the action method with another `play.mvc.Action`, using the `@With` annotation:
+You can compose the code provided by the action method with another `play.mvc.Action`, using the [`@With`](api/java/play/mvc/With.html) annotation:
 
 @[verbose-index](code/javaguide/http/JavaActionsComposition.java)
 
@@ -31,9 +23,9 @@ You also mix several actions by using custom action annotations:
 
 @[authenticated-cached-index](code/javaguide/http/JavaActionsComposition.java)
 
-> **Note:**  ```play.mvc.Security.Authenticated``` and ```play.cache.Cached``` annotations and the corresponding predefined Actions are shipped with Play. See the relevant API documentation for more information.
+> **Note:**  Every request **must** be served by a distinct instance of your `play.mvc.Action`. If a singleton pattern is used, requests will be routed incorrectly during multiple request scenarios. For example, if you are using Spring as a DI container for Play, you need to make sure that your action beans are prototype scoped.
 
-> **Note:**  Every request must be served by a distinct instance of your `play.mvc.Action`. If a singleton pattern is used, requests will be routed incorrectly during multiple request scenarios. For example, if you are using Spring as a DI container for Play, you need to make sure that your action beans are prototype scoped.
+> **Note:**  [`play.mvc.Security.Authenticated`](api/java/play/mvc/Security.Authenticated.html) and [`play.cache.Cached`](api/java/play/cache/Cached.html) annotations and the corresponding predefined Actions are shipped with Play. See the relevant API documentation for more information.
 
 ## Defining custom action annotations
 
@@ -55,7 +47,7 @@ You can also put any action composition annotation directly on the `Controller`
 
 @[annotated-controller](code/javaguide/http/JavaActionsComposition.java)
 
-> **Note:** If you want the action composition annotation(s) put on a ```Controller``` class to be executed before the one(s) put on action methods set ```play.http.actionComposition.controllerAnnotationsFirst = true``` in ```application.conf```. However, be aware that if you use a third party module in your project it may rely on a certain execution order of its annotations.
+> **Note:** If you want the action composition annotation(s) put on a `Controller` class to be executed before the one(s) put on action methods set `play.http.actionComposition.controllerAnnotationsFirst = true` in `application.conf`. However, be aware that if you use a third party module in your project it may rely on a certain execution order of its annotations.
 
 ## Passing objects from action to controller
 
@@ -66,3 +58,15 @@ You can pass an object from an action to a controller by utilizing the context a
 Then in an action you can get the arg like this:
 
 @[pass-arg-action-index](code/javaguide/http/JavaActionsComposition.java)
+
+## Using Dependency Injection
+
+You can use [[Dependency Injection|JavaDependencyInjection]] together with action composition. For example, if you want to define your own result cache solution, first define the annotation:
+
+@[action-composition-dependency-injection-annotation](code/javaguide/http/JavaActionsComposition.java)
+
+And then you can define your action with the dependencies injected:
+
+@[action-composition-dependency-injection](code/javaguide/http/JavaActionsComposition.java)
+
+As stated above, every request **must** be served by a distinct instance of your `play.mvc.Action` and you **must not** annotate your action as a `@Singleton`.
\ No newline at end of file
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
index 0fe823d877..267e516d25 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActionsComposition.java
@@ -4,10 +4,12 @@
 package javaguide.http;
 
 import play.Logger;
+import play.cache.AsyncCacheApi;
 import play.cache.Cached;
 import play.libs.Json;
 import play.mvc.*;
 
+import javax.inject.Inject;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -96,4 +98,31 @@ public class JavaActionsComposition extends Controller {
 
     }
     // #annotated-controller
+
+    // #action-composition-dependency-injection-annotation
+    @With(MyOwnCachedAction.class)
+    @Target({ElementType.TYPE, ElementType.METHOD})
+    @Retention(RetentionPolicy.RUNTIME)
+    public @interface WithCache {
+        String key();
+    }
+    // #action-composition-dependency-injection-annotation
+
+    // #action-composition-dependency-injection
+    public class MyOwnCachedAction extends Action<WithCache> {
+
+        private final AsyncCacheApi cacheApi;
+
+        @Inject
+        public MyOwnCachedAction(AsyncCacheApi cacheApi) {
+            this.cacheApi = cacheApi;
+        }
+
+        @Override
+        public CompletionStage<Result> call(Http.Context ctx) {
+            return cacheApi.getOrElseUpdate(configuration.key(), () -> delegate.call(ctx));
+        }
+    }
+    // #action-composition-dependency-injection
+
 }
diff --git a/documentation/manual/working/scalaGuide/main/http/ScalaActionsComposition.md b/documentation/manual/working/scalaGuide/main/http/ScalaActionsComposition.md
index 6449618e04..552c0598c0 100644
--- a/documentation/manual/working/scalaGuide/main/http/ScalaActionsComposition.md
+++ b/documentation/manual/working/scalaGuide/main/http/ScalaActionsComposition.md
@@ -7,7 +7,7 @@ This chapter introduces several ways of defining generic action functionality.
 
 We saw [[previously|ScalaActions]] that there are multiple ways to declare an action - with a request parameter, without a request parameter, with a body parser etc.  In fact there are more than this, as we'll see in the chapter on [[asynchronous programming|ScalaAsync]].
 
-These methods for building actions are actually all defined by a trait called [`ActionBuilder`](api/scala/play/api/mvc/ActionBuilder.html) and the [`Action`](api/scala/play/api/mvc/Action$.html) object that we use to declare our actions is just an instance of this trait.  By implementing your own `ActionBuilder`, you can declare reusable action stacks, that can then be used to build actions.
+These methods for building actions are actually all defined by a trait called [`ActionBuilder`](api/scala/play/api/mvc/ActionBuilder.html) and the [`Action`](api/scala/play/api/mvc/Action.html) object that we use to declare our actions is just an instance of this trait.  By implementing your own `ActionBuilder`, you can declare reusable action stacks, that can then be used to build actions.
 
 Letâ€™s start with the simple example of a logging decorator, we want to log each call to this action.
 
@@ -15,7 +15,7 @@ The first way is to implement this functionality in the `invokeBlock` method, wh
 
 @[basic-logging](code/ScalaActionsComposition.scala)
 
-Now we can use it the same way we use `Action`:
+Now we can use [[Dependency Injection|ScalaDependencyInjection]] in your controller to get an instance of the `LoggingAction` and use it the same way we use `Action`:
 
 @[basic-logging-index](code/ScalaActionsComposition.scala)
  
diff --git a/documentation/manual/working/scalaGuide/main/http/code/ScalaActionsComposition.scala b/documentation/manual/working/scalaGuide/main/http/code/ScalaActionsComposition.scala
index 21b45579fb..fa5b03e181 100644
--- a/documentation/manual/working/scalaGuide/main/http/code/ScalaActionsComposition.scala
+++ b/documentation/manual/working/scalaGuide/main/http/code/ScalaActionsComposition.scala
@@ -53,12 +53,14 @@ class ScalaActionsCompositionSpec extends Specification with Controller {
       val loggingAction = new LoggingAction(parser)
 
       //#basic-logging-index
-      def index = loggingAction {
-        Ok("Hello World")
+      class MyController @Inject()(loggingAction: LoggingAction) extends Controller {
+        def index = loggingAction {
+          Ok("Hello World")
+        }
       }
       //#basic-logging-index
 
-      testAction(index)
+      testAction(new MyController(loggingAction).index)
 
       //#basic-logging-parse
       def submit = loggingAction(parse.text) { request =>
@@ -67,7 +69,7 @@ class ScalaActionsCompositionSpec extends Specification with Controller {
       //#basic-logging-parse
 
       val request = FakeRequest().withTextBody("hello with the parse")
-      testAction(index, request)
+      testAction(new MyController(loggingAction).index, request)
     }
 
     "Wrapping existing actions" in {
@@ -82,8 +84,8 @@ class ScalaActionsCompositionSpec extends Specification with Controller {
           action(request)
         }
 
-        lazy val parser = action.parser
-        lazy val executionContext = action.executionContext
+        override def parser = action.parser
+        override def executionContext = action.executionContext
       }
       //#actions-class-wrapping
 
diff --git a/framework/src/play-cache/src/main/java/play/cache/Cached.java b/framework/src/play-cache/src/main/java/play/cache/Cached.java
index e022fae331..07bef0a510 100644
--- a/framework/src/play-cache/src/main/java/play/cache/Cached.java
+++ b/framework/src/play-cache/src/main/java/play/cache/Cached.java
@@ -8,6 +8,8 @@ import java.lang.annotation.*;
 
 /**
  * Mark an action to be cached on server side.
+ *
+ * @see CachedAction
  */
 @With(CachedAction.class)
 @Target({ElementType.TYPE, ElementType.METHOD})
diff --git a/framework/src/play/src/main/java/play/mvc/Security.java b/framework/src/play/src/main/java/play/mvc/Security.java
index aa0b534472..3f8e3760b6 100644
--- a/framework/src/play/src/main/java/play/mvc/Security.java
+++ b/framework/src/play/src/main/java/play/mvc/Security.java
@@ -20,7 +20,7 @@ public class Security {
     public static final TypedKey<String> USERNAME = TypedKey.create("username");
 
     /**
-     * Wraps the annotated action in an <code>AuthenticatedAction</code>.
+     * Wraps the annotated action in an {@link AuthenticatedAction}.
      */
     @With(AuthenticatedAction.class)
     @Target({ElementType.TYPE, ElementType.METHOD})
