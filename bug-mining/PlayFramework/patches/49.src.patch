diff --git a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
index dd10350a24..786e24ee92 100644
--- a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
+++ b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
@@ -11,6 +11,7 @@ import java.io._
 
 import org.junit.runner.RunWith
 import org.specs2.runner.JUnitRunner
+import org.specs2.specification.AfterAll
 
 //#dependency
 import javax.inject.Inject
@@ -20,6 +21,10 @@ import scala.concurrent.duration._
 import play.api.mvc._
 import play.api.libs.ws._
 
+import akka.actor.ActorSystem
+import akka.stream.ActorMaterializer
+import akka.stream.scaladsl._
+
 class Application @Inject() (ws: WSClient) extends Controller {
 
 }
@@ -35,7 +40,15 @@ case class Person(name: String, age: Int)
  * JVM implementation issue.
  */
 @RunWith(classOf[JUnitRunner])
-class ScalaWSSpec extends PlaySpecification with Results {
+class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
+
+  // This needs to be removed when https://github.com/playframework/playframework/issues/4688 is fixed.
+  import play.api.libs.iteratee._
+  implicit def source2enumerator[T](source: Source[T, _]): Enumerator[T] = {
+    import play.api.libs.streams.Streams
+    val publisher = source.runWith(Sink.publisher)
+    Streams.publisherToEnumerator(publisher)
+  }
 
   val url = s"http://localhost:$testServerPort/"
 
@@ -43,6 +56,11 @@ class ScalaWSSpec extends PlaySpecification with Results {
   implicit val context = play.api.libs.concurrent.Execution.Implicits.defaultContext
   // #scalaws-context
 
+  val system = ActorSystem()
+  implicit val materializer = ActorMaterializer()(system)
+
+  def afterAll(): Unit = system.shutdown()
+
   def withSimpleServer[T](block: WSClient => T): T = withServer {
     case _ => Action(Ok)
   }(block)
@@ -265,18 +283,16 @@ class ScalaWSSpec extends PlaySpecification with Results {
         case ("GET", "/") => Action(Ok.chunked(largeEnumerator))
       } { ws =>
         //#stream-count-bytes
-        import play.api.libs.iteratee._
-
         // Make the request
-        val futureResponse: Future[(WSResponseHeaders, Enumerator[Array[Byte]])] =
+        val futureResponse: Future[(WSResponseHeaders, Source[Array[Byte], _])] =
           ws.url(url).getStream()
 
         val bytesReturned: Future[Long] = futureResponse.flatMap {
           case (headers, body) =>
             // Count the number of bytes returned
-            body |>>> Iteratee.fold(0l) { (total, bytes) =>
+            body.runWith(Sink.fold[Long, Array[Byte]](0L){ (total, bytes) =>
               total + bytes.length
-            }
+            })
         }
         //#stream-count-bytes
         await(bytesReturned) must_== 10000l
@@ -288,23 +304,21 @@ class ScalaWSSpec extends PlaySpecification with Results {
         val file = File.createTempFile("stream-to-file-", ".txt")
         try {
           //#stream-to-file
-          import play.api.libs.iteratee._
-
           // Make the request
-          val futureResponse: Future[(WSResponseHeaders, Enumerator[Array[Byte]])] =
+          val futureResponse: Future[(WSResponseHeaders, Source[Array[Byte], _])] =
             ws.url(url).getStream()
 
           val downloadedFile: Future[File] = futureResponse.flatMap {
             case (headers, body) =>
               val outputStream = new FileOutputStream(file)
 
-              // The iteratee that writes to the output stream
-              val iteratee = Iteratee.foreach[Array[Byte]] { bytes =>
+              // The sink that writes to the output stream
+              val sink = Sink.foreach[Array[Byte]] { bytes =>
                 outputStream.write(bytes)
               }
 
               // Feed the body into the iteratee
-              (body |>>> iteratee).andThen {
+              body.runWith(sink).andThen {
                 case result =>
                   // Close the output stream whether there was an error or not
                   outputStream.close()
@@ -324,8 +338,6 @@ class ScalaWSSpec extends PlaySpecification with Results {
         case ("GET", "/") => Action(Ok.chunked(largeEnumerator))
       } { ws =>
         val file = File.createTempFile("stream-to-file-", ".txt")
-        implicit val actorSystem = ActorSystem()
-        implicit val mat = ActorMaterializer()
         try {
           //#stream-to-result
           def downloadFile = Action.async {
@@ -361,7 +373,6 @@ class ScalaWSSpec extends PlaySpecification with Results {
 
         } finally {
           file.delete()
-          actorSystem.shutdown()
         }
       }
 
@@ -371,15 +382,15 @@ class ScalaWSSpec extends PlaySpecification with Results {
         import play.api.libs.iteratee._
 
         //#stream-put
-        val futureResponse: Future[(WSResponseHeaders, Enumerator[Array[Byte]])] =
+        val futureResponse: Future[(WSResponseHeaders, Source[Array[Byte], _])] =
           ws.url(url).withMethod("PUT").withBody("some body").stream()
         //#stream-put
 
         val bytesReturned: Future[Long] = futureResponse.flatMap {
           case (headers, body) =>
-            body |>>> Iteratee.fold(0l) { (total, bytes) =>
+            body.runWith(Sink.fold[Long, Array[Byte]](0L){ (total, bytes) =>
               total + bytes.length
-            }
+            })
         }
         //#stream-count-bytes
         await(bytesReturned) must_== 10000l
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
index 4065f62a35..9e7f3e3980 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
@@ -19,6 +19,9 @@ import scala.concurrent.duration._
 import play.api.libs.iteratee._
 import java.io.IOException
 
+import akka.stream.scaladsl.Source
+import akka.stream.scaladsl.Sink
+
 object NettyWSSpec extends WSSpec with NettyIntegrationSpecification
 
 object AkkaHttpWSSpec extends WSSpec with AkkaHttpIntegrationSpecification
@@ -134,6 +137,14 @@ trait WSSpec extends PlaySpecification with ServerIntegrationSpecification {
   "WS@scala" should {
     import play.api.libs.ws.WSSignatureCalculator
 
+    implicit val materializer = app.materializer
+
+    implicit def source2enumerator[T](source: Source[T, Unit]): Enumerator[T] = {
+      import play.api.libs.streams.Streams
+      val publisher = source.runWith(Sink.publisher)
+      Streams.publisherToEnumerator(publisher)
+    }
+
     def withServer[T](block: play.api.libs.ws.WSClient => T) = {
       Server.withApplication(app) { implicit port =>
         WsTestClient.withClient(block)
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
index 9710dd3b86..f563002409 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
@@ -3,20 +3,21 @@
  */
 package play.api.libs.ws
 
+import java.io.File
 import java.net.URI
 
-import akka.util.ByteString
-
-import scala.concurrent.{ Future, ExecutionContext }
+import scala.concurrent.ExecutionContext
+import scala.concurrent.Future
 import scala.concurrent.duration.Duration
+import scala.xml.Elem
 
-import java.io.File
+import akka.stream.Materializer
+import akka.stream.scaladsl.Sink
+import akka.stream.scaladsl.Source
+import akka.util.ByteString
 
+import play.api.Application
 import play.api.http.Writeable
-import play.api.libs.iteratee._
-
-import play.api._
-import scala.xml.Elem
 import play.api.libs.json.JsValue
 
 /**
@@ -248,9 +249,9 @@ case class InMemoryBody(bytes: ByteString) extends WSBody
 /**
  * A streamed body
  *
- * @param bytes An enumerator of the bytes of the body
+ * @param bytes A flow of the bytes of the body
  */
-case class StreamedBody(bytes: Enumerator[Array[Byte]]) extends WSBody {
+case class StreamedBody(bytes: Source[Array[Byte], Unit]) extends WSBody {
   throw new NotImplementedError("A streaming request body is not yet implemented")
 }
 
@@ -409,109 +410,113 @@ trait WSRequest {
   /**
    * performs a get
    */
-  def get() = withMethod("GET").execute()
+  def get(): Future[WSResponse] = withMethod("GET").execute()
 
   /**
    * performs a get
    * @param consumer that's handling the response
    */
-  def get[A](consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
-    getStream().flatMap {
-      case (response, enumerator) =>
-        enumerator(consumer(response))
-    }
+  @deprecated("2.5.0", "Use `WS.get()` or `WS.getStream()`")
+  def get[A](consumer: WSResponseHeaders => Sink[Array[Byte], A])(implicit mat: Materializer): Future[A] = {
+    getStream().map {
+      case (response, source) =>
+        source.runWith(consumer(response))
+    }(mat.executionContext)
   }
 
   /**
    * performs a get
    */
-  def getStream(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
+  def getStream(): Future[(WSResponseHeaders, Source[Array[Byte], Unit])] = {
     withMethod("GET").stream()
   }
 
   /**
    * Perform a PATCH on the request asynchronously.
    */
-  def patch[T](body: T)(implicit wrt: Writeable[T]) =
+  def patch[T](body: T)(implicit wrt: Writeable[T]): Future[WSResponse] =
     withMethod("PATCH").withBody(body).execute()
 
   /**
    * Perform a PATCH on the request asynchronously.
    * Request body won't be chunked
    */
-  def patch(body: File) = withMethod("PATCH").withBody(FileBody(body)).execute()
+  def patch(body: File): Future[WSResponse] = withMethod("PATCH").withBody(FileBody(body)).execute()
 
   /**
    * performs a POST with supplied body
    * @param consumer that's handling the response
    */
-  def patchAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
-    withMethod("PATCH").withBody(body).stream().flatMap {
-      case (response, enumerator) =>
-        enumerator(consumer(response))
-    }
+  @deprecated("2.5.0", "Use `WS.patch(body)`.")
+  def patchAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[Array[Byte], A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
+    withMethod("PATCH").withBody(body).stream().map {
+      case (response, source) =>
+        source.runWith(consumer(response))
+    }(mat.executionContext)
   }
 
   /**
    * Perform a POST on the request asynchronously.
    */
-  def post[T](body: T)(implicit wrt: Writeable[T]) =
+  def post[T](body: T)(implicit wrt: Writeable[T]): Future[WSResponse] =
     withMethod("POST").withBody(body).execute()
 
   /**
    * Perform a POST on the request asynchronously.
    * Request body won't be chunked
    */
-  def post(body: File) = withMethod("POST").withBody(FileBody(body)).execute()
+  def post(body: File): Future[WSResponse] = withMethod("POST").withBody(FileBody(body)).execute()
 
   /**
    * performs a POST with supplied body
    * @param consumer that's handling the response
    */
-  def postAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
-    withMethod("POST").withBody(body).stream().flatMap {
-      case (response, enumerator) =>
-        enumerator(consumer(response))
-    }
+  @deprecated("2.5.0", "Use `WS.post(body)`.")
+  def postAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[Array[Byte], A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
+    withMethod("POST").withBody(body).stream().map {
+      case (response, source) =>
+        source.runWith(consumer(response))
+    }(mat.executionContext)
   }
 
   /**
    * Perform a PUT on the request asynchronously.
    */
-  def put[T](body: T)(implicit wrt: Writeable[T]) =
+  def put[T](body: T)(implicit wrt: Writeable[T]): Future[WSResponse] =
     withMethod("PUT").withBody(body).execute()
 
   /**
    * Perform a PUT on the request asynchronously.
    * Request body won't be chunked
    */
-  def put(body: File) = withMethod("PUT").withBody(FileBody(body)).execute()
+  def put(body: File): Future[WSResponse] = withMethod("PUT").withBody(FileBody(body)).execute()
 
   /**
    * performs a PUT with supplied body
    * @param consumer that's handling the response
    */
-  def putAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
-    withMethod("PUT").withBody(body).stream().flatMap {
-      case (response, enumerator) =>
-        enumerator(consumer(response))
-    }
+  @deprecated("2.5.0", "Use `WS.put(body)`.")
+  def putAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[Array[Byte], A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
+    withMethod("PUT").withBody(body).stream().map {
+      case (response, source) =>
+        source.runWith(consumer(response))
+    }(mat.executionContext)
   }
 
   /**
    * Perform a DELETE on the request asynchronously.
    */
-  def delete() = withMethod("DELETE").execute()
+  def delete(): Future[WSResponse] = withMethod("DELETE").execute()
 
   /**
    * Perform a HEAD on the request asynchronously.
    */
-  def head() = withMethod("HEAD").execute()
+  def head(): Future[WSResponse] = withMethod("HEAD").execute()
 
   /**
    * Perform a OPTIONS on the request asynchronously.
    */
-  def options() = withMethod("OPTIONS").execute()
+  def options(): Future[WSResponse] = withMethod("OPTIONS").execute()
 
   def execute(method: String): Future[WSResponse] = withMethod(method).execute()
 
@@ -521,9 +526,9 @@ trait WSRequest {
   def execute(): Future[WSResponse]
 
   /**
-   * Execute this request and stream the response body in an enumerator
+   * Execute this request and stream the response body.
    */
-  def stream(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])]
+  def stream(): Future[(WSResponseHeaders, Source[Array[Byte], Unit])]
 }
 
 /**
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
index 3b9f64b881..29f877c0e9 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
@@ -6,8 +6,6 @@ package play.api.libs.ws.ning
 import java.io.UnsupportedEncodingException
 import java.nio.charset.{ Charset, StandardCharsets }
 import javax.inject.{ Inject, Provider, Singleton }
-
-import akka.util.ByteString
 import com.ning.http.client.{ Response => AHCResponse, ProxyServer => AHCProxyServer, _ }
 import com.ning.http.client.cookie.{ Cookie => AHCCookie }
 import com.ning.http.client.Realm.{ RealmBuilder, AuthScheme }
@@ -15,23 +13,21 @@ import com.ning.http.util.AsyncHttpProviderUtils
 import org.jboss.netty.handler.codec.http.HttpHeaders
 import play.api.inject.{ ApplicationLifecycle, Module }
 import play.core.parsers.FormUrlEncodedParser
-
 import collection.immutable.TreeMap
-
 import scala.concurrent.{ Future, Promise }
 import scala.concurrent.duration.Duration
-
 import play.api.libs.ws._
 import play.api.libs.ws.ssl._
-
 import play.api.libs.iteratee._
 import play.api._
 import play.core.utils.CaseInsensitiveOrdered
 import play.api.libs.ws.DefaultWSResponseHeaders
 import play.api.libs.iteratee.Input.El
 import play.api.libs.ws.ssl.debug._
-
 import scala.collection.JavaConverters._
+import akka.stream.scaladsl.Source
+import java.io.IOException
+import akka.util.ByteString
 
 /**
  * A WS client backed by a Ning AsyncHttpClient.
@@ -136,7 +132,7 @@ case class NingWSRequest(client: NingWSClient,
 
   def execute(): Future[WSResponse] = execute(buildRequest())
 
-  def stream(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = executeStream(buildRequest())
+  def stream(): Future[(WSResponseHeaders, Source[Array[Byte], Unit])] = executeStream(buildRequest())
 
   /**
    * Returns the current headers of the request, using the request builder.  This may be signed,
@@ -324,7 +320,7 @@ case class NingWSRequest(client: NingWSClient,
     result.future
   }
 
-  private[libs] def executeStream(request: Request): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
+  private[libs] def executeStream(request: Request): Future[(WSResponseHeaders, Source[Array[Byte], Unit])] = {
 
     import com.ning.http.client.AsyncHandler
 
@@ -342,12 +338,14 @@ case class NingWSRequest(client: NingWSClient,
 
       import com.ning.http.client.AsyncHandler.STATE
 
-      override def onStatusReceived(status: HttpResponseStatus) = {
+      @throws(classOf[Exception])
+      override def onStatusReceived(status: HttpResponseStatus): STATE = {
         statusCode = status.getStatusCode
         STATE.CONTINUE
       }
 
-      override def onHeadersReceived(h: HttpResponseHeaders) = {
+      @throws(classOf[Exception])
+      override def onHeadersReceived(h: HttpResponseHeaders): STATE = {
         val headers = h.getHeaders
 
         val responseHeader = DefaultWSResponseHeaders(statusCode, ningHeadersToMap(headers))
@@ -386,7 +384,8 @@ case class NingWSRequest(client: NingWSClient,
         STATE.CONTINUE
       }
 
-      override def onBodyPartReceived(bodyPart: HttpResponseBodyPart) = {
+      @throws(classOf[Exception])
+      override def onBodyPartReceived(bodyPart: HttpResponseBodyPart): STATE = {
         if (!doneOrError) {
           import play.api.libs.concurrent.Execution.Implicits.defaultContext
           current = current.pureFlatFold {
@@ -411,16 +410,23 @@ case class NingWSRequest(client: NingWSClient,
         }
       }
 
-      override def onCompleted() = {
+      @throws(classOf[Exception])
+      override def onCompleted(): Unit = {
         Option(current).foreach(_.run)
       }
 
-      override def onThrowable(t: Throwable) = {
+      override def onThrowable(t: Throwable): Unit = {
         result.tryFailure(t)
         errorInStream.tryFailure(t)
       }
     })
-    result.future
+    import play.core.Execution.Implicits.internalContext
+    result.future.map {
+      case (response, enumerator) =>
+        import play.api.libs.streams.Streams
+        val publisher = Streams.enumeratorToPublisher(enumerator)
+        (response, Source(publisher))
+    }
   }
 
   private[libs] def createProxy(wsProxyServer: WSProxyServer): AHCProxyServer = {
@@ -628,6 +634,7 @@ case class NingWSResponse(ahcResponse: AHCResponse) extends WSResponse {
   /**
    * The response body as a byte array.
    */
+  @throws(classOf[IOException])
   def bodyAsBytes: Array[Byte] = ahcResponse.getResponseBodyAsBytes
 
   override def toString: String = {
