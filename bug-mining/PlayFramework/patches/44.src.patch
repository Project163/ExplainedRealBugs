diff --git a/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala b/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
index f19cd378fc..46f495e0ba 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
@@ -3,12 +3,10 @@
  */
 package play.api.mvc
 
-import akka.stream.FlowMaterializer
 import akka.util.ByteString
 import play.api.data.Form
 import play.api.libs.streams.{ Streams, Accumulator }
 import play.core.parsers.Multipart
-
 import scala.language.reflectiveCalls
 import java.io._
 import scala.concurrent.Future
@@ -24,6 +22,9 @@ import scala.util.control.NonFatal
 import play.api.http.{ LazyHttpErrorHandler, ParserConfiguration, HttpConfiguration, HttpVerbs }
 import play.utils.PlayIO
 import play.api.http.Status._
+import akka.stream.FlowMaterializer
+import akka.stream.scaladsl.{ Keep, Flow, Sink }
+import akka.stream.stage.{ Context, PushStage, SyncDirective, TerminationDirective }
 
 /**
  * A request body that adapts automatically according the request Content-Type.
@@ -342,15 +343,18 @@ trait BodyParsers {
      * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
      */
     def raw(memoryThreshold: Int = DefaultMaxTextLength, maxLength: Long = DefaultMaxDiskLength): BodyParser[RawBuffer] =
-      BodyParser.iteratee("raw, memoryThreshold=" + memoryThreshold) { request =>
-        import play.core.Execution.Implicits.internalContext // Cannot run on same thread as may need to write to a file
-        val buffer = RawBuffer(memoryThreshold)
-        Traversable.takeUpTo[ByteString](maxLength).transform(
-          Iteratee.foreach[ByteString](bytes => buffer.push(bytes)).map { _ =>
-            buffer.close()
-            buffer
+      BodyParser("raw, memoryThreshold=" + memoryThreshold) { request =>
+        Accumulator {
+          val buffer = RawBuffer(memoryThreshold)
+          val takeUpToFlow = Flow[ByteString].transform { () => new BodyParsers.TakeUpTo(maxLength) }
+          val sink: Sink[ByteString, Future[RawBuffer]] = takeUpToFlow.toMat(
+            Sink.fold(buffer) { (bf, bs) => bf.push(bs); bf }
+          )(Keep.right)
+          sink.mapMaterializedValue { f: Future[RawBuffer] =>
+            import play.core.Execution.Implicits.internalContext
+            checkForMaxLengthAttained(request, f andThen { case b => buffer.close() })
           }
-        ).flatMap(checkForEof(request))
+        }
       }
 
     /**
@@ -739,6 +743,15 @@ trait BodyParsers {
       cont
     }
 
+    private def checkForMaxLengthAttained[A](request: RequestHeader, materializationRes: Future[A]): Future[Either[Result, A]] = {
+      import play.core.Execution.Implicits.internalContext
+      materializationRes.map(Right(_)).recoverWith {
+        case _: BodyParsers.MaxLengthLimitAttained =>
+          val badResult = createBadResult("Request Entity Too Large", REQUEST_ENTITY_TOO_LARGE)(request)
+          badResult.map(Left(_))
+      }
+    }
+
     private def tolerantBodyParser[A](name: String, maxLength: Long, errorMessage: String)(parser: (RequestHeader, ByteString) => A): BodyParser[A] =
       BodyParser.iteratee(name + ", maxLength=" + maxLength) { request =>
         import play.api.libs.iteratee.Execution.Implicits.trampoline
@@ -774,6 +787,18 @@ object BodyParsers extends BodyParsers {
   private val logger = Logger(this.getClass)
 
   private val hcCache = Application.instanceCache[HttpConfiguration]
+
+  private class TakeUpTo(maxLength: Long) extends PushStage[ByteString, ByteString] {
+    private var pushedBytes: Long = 0
+
+    override def onPush(chunk: ByteString, ctx: Context[ByteString]): SyncDirective = {
+      pushedBytes += chunk.size
+      if (pushedBytes > maxLength) ctx.fail(new MaxLengthLimitAttained)
+      else ctx.push(chunk)
+    }
+  }
+
+  private class MaxLengthLimitAttained extends RuntimeException(null, null, false, false)
 }
 
 /**
diff --git a/framework/src/play/src/test/scala/play/api/mvc/RawBodyParserSpec.scala b/framework/src/play/src/test/scala/play/api/mvc/RawBodyParserSpec.scala
new file mode 100644
index 0000000000..9a7ce62fda
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/api/mvc/RawBodyParserSpec.scala
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
+ */
+package play.api.mvc
+
+import akka.util.ByteString
+import akka.stream.scaladsl.Source
+import akka.actor.ActorSystem
+import akka.stream.ActorFlowMaterializer
+
+import java.io.IOException
+
+import org.specs2.mutable.Specification
+import org.specs2.specification.AfterAll
+
+import play.api.http.ParserConfiguration
+import play.core.test.FakeRequest
+
+import scala.concurrent.Future
+import scala.concurrent.Await
+import scala.concurrent.duration.Duration
+
+object RawBodyParserSpec extends Specification with AfterAll {
+
+  val system = ActorSystem("content-types-spec")
+  implicit val materializer = ActorFlowMaterializer()(system)
+
+  def afterAll(): Unit = system.shutdown()
+
+  val config = ParserConfiguration()
+
+  def parse(body: ByteString, memoryThreshold: Int = config.maxMemoryBuffer, maxLength: Long = config.maxDiskBuffer): Either[Result, RawBuffer] = {
+    val request = FakeRequest(method = "GET", "/x")
+    val bodyParser = new BodyParsers {}
+    val parser = bodyParser.parse.raw(memoryThreshold, maxLength)
+    Await.result(parser(request).run(Source.single(body)), Duration.Inf)
+  }
+
+  "Raw Body Parser" should {
+    "parse a simple body" in {
+      val body = ByteString("lorem ipsum")
+      parse(body) must beRight.like {
+        case rawBuffer => rawBuffer.asBytes() must beSome.like {
+          case outBytes =>
+            outBytes mustEqual body
+        }
+      }
+    }
+
+    "close the raw buffer after parsing the body" in {
+      val body = ByteString("lorem ipsum")
+      parse(body, memoryThreshold = 1) must beRight.like {
+        case rawBuffer =>
+          rawBuffer.push(ByteString("This fails because the stream was closed!")) must throwA[IOException]
+      }
+    }
+
+    "fail to parse longer than allowed body" in {
+      val msg = ByteString("lorem ipsum")
+      parse(msg, maxLength = 1) must beLeft
+    }
+  }
+}
\ No newline at end of file
