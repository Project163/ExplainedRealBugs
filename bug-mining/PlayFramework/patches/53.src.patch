diff --git a/documentation/manual/working/javaGuide/code/MockJavaAction.scala b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
index c5ed779701..6b1faf045c 100644
--- a/documentation/manual/working/javaGuide/code/MockJavaAction.scala
+++ b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
@@ -22,9 +22,11 @@ abstract class MockJavaAction extends Controller with Action[Http.RequestBody] {
   private lazy val action = new JavaAction(components) {
     val annotations = new JavaActionAnnotations(controller, method)
 
-    def parser = play.HandlerInvokerFactoryAccessor.javaBodyParserToScala(
-      components.injector.instanceOf(annotations.parser)
-    )
+    def parser = {
+      play.HandlerInvokerFactoryAccessor.javaBodyParserToScala(
+        components.injector.instanceOf(annotations.parser)
+      )
+    }
 
     def invocation = self.invocation
   }
@@ -48,8 +50,13 @@ object MockJavaActionHelper {
 
   import Helpers.defaultAwaitTimeout
 
-  def call(action: Action[Http.RequestBody], requestBuilder: play.mvc.Http.RequestBuilder): Result = {
-    Helpers.await(action.apply(requestBuilder.build()._underlyingRequest)).asJava
+  def call(action: Action[Http.RequestBody], requestBuilder: play.mvc.Http.RequestBuilder)(implicit mat: Materializer): Result = {
+    Helpers.await(requestBuilder.body() match {
+      case null =>
+        action.apply(requestBuilder.build()._underlyingRequest)
+      case other =>
+        Helpers.call(action, requestBuilder.build()._underlyingRequest, other.asBytes())
+    }).asJava
   }
 
   def callWithStringBody(action: Action[Http.RequestBody], requestBuilder: play.mvc.Http.RequestBuilder, body: String)(implicit mat: Materializer): Result = {
diff --git a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
index ba2d759a06..d2f4582fd8 100644
--- a/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
+++ b/documentation/manual/working/javaGuide/main/akka/code/javaguide/akka/JavaAkka.java
@@ -90,7 +90,7 @@ public class JavaAkka {
                 public Promise<Result> index() {
                     return new javaguide.akka.async.Application().index();
                 }
-            }, fakeRequest());
+            }, fakeRequest(), app.getWrappedApplication().materializer());
             assertThat(contentAsString(result), equalTo("Got 2"));
         });
     }
diff --git a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaComet.java b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaComet.java
index dbfb758c15..b4cbfe671a 100644
--- a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaComet.java
+++ b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaComet.java
@@ -19,7 +19,7 @@ public class JavaComet extends WithApplication {
 
     @Test
     public void manual() {
-        String content = contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest()), mat);
+        String content = contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest(), mat), mat);
         assertThat(content, containsString("<script>console.log('kiki')</script>"));
         assertThat(content, containsString("<script>console.log('foo')</script>"));
         assertThat(content, containsString("<script>console.log('bar')</script>"));
@@ -44,7 +44,7 @@ public class JavaComet extends WithApplication {
 
     @Test
     public void comet() {
-        String content = contentAsString(MockJavaActionHelper.call(new Controller2(), fakeRequest()), mat);
+        String content = contentAsString(MockJavaActionHelper.call(new Controller2(), fakeRequest(), mat), mat);
         assertThat(content, containsString("<script type=\"text/javascript\">console.log('kiki');</script>"));
         assertThat(content, containsString("<script type=\"text/javascript\">console.log('foo');</script>"));
         assertThat(content, containsString("<script type=\"text/javascript\">console.log('bar');</script>"));
@@ -65,7 +65,7 @@ public class JavaComet extends WithApplication {
 
     @Test
     public void foreverIframe() {
-        String content = contentAsString(MockJavaActionHelper.call(new Controller3(), fakeRequest()), mat);
+        String content = contentAsString(MockJavaActionHelper.call(new Controller3(), fakeRequest(), mat), mat);
         assertThat(content, containsString("<script type=\"text/javascript\">parent.cometMessage('kiki');</script>"));
         assertThat(content, containsString("<script type=\"text/javascript\">parent.cometMessage('foo');</script>"));
         assertThat(content, containsString("<script type=\"text/javascript\">parent.cometMessage('bar');</script>"));
diff --git a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaStream.java b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaStream.java
index 9ac2140f6a..bb8cd5a436 100644
--- a/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaStream.java
+++ b/documentation/manual/working/javaGuide/main/async/code/javaguide/async/JavaStream.java
@@ -23,7 +23,7 @@ public class JavaStream extends WithApplication {
 
     @Test
     public void byDefault() {
-        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest())), equalTo("Hello World"));
+        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest(), mat)), equalTo("Hello World"));
     }
 
     public static class Controller1 extends MockJavaAction {
@@ -41,7 +41,7 @@ public class JavaStream extends WithApplication {
         try (OutputStream os = new FileOutputStream(file)) {
             IOUtils.write("hi", os);
         }
-        Result result = MockJavaActionHelper.call(new Controller2(), fakeRequest());
+        Result result = MockJavaActionHelper.call(new Controller2(), fakeRequest(), mat);
         assertThat(contentAsString(result, mat), equalTo("hi"));
         assertThat(result.body().contentLength(), equalTo(Optional.of(2L)));
         file.delete();
@@ -57,7 +57,7 @@ public class JavaStream extends WithApplication {
 
     @Test
     public void inputStream() {
-        String content = contentAsString(MockJavaActionHelper.call(new Controller3(), fakeRequest()), mat);
+        String content = contentAsString(MockJavaActionHelper.call(new Controller3(), fakeRequest(), mat), mat);
         // Wait until results refactoring is merged, then this will work
         // assertThat(content, containsString("hello"));
     }
@@ -77,7 +77,7 @@ public class JavaStream extends WithApplication {
 
     @Test
     public void chunked() {
-        String content = contentAsString(MockJavaActionHelper.call(new Controller4(), fakeRequest()), mat);
+        String content = contentAsString(MockJavaActionHelper.call(new Controller4(), fakeRequest(), mat), mat);
         assertThat(content, equalTo("kikifoobar"));
     }
 
diff --git a/documentation/manual/working/javaGuide/main/cache/code/javaguide/cache/JavaCache.java b/documentation/manual/working/javaGuide/main/cache/code/javaguide/cache/JavaCache.java
index ef6e0f515a..7820193ebd 100644
--- a/documentation/manual/working/javaGuide/main/cache/code/javaguide/cache/JavaCache.java
+++ b/documentation/manual/working/javaGuide/main/cache/code/javaguide/cache/JavaCache.java
@@ -80,9 +80,9 @@ public class JavaCache extends WithApplication {
     public void http() {
         CacheApi cache = app.injector().instanceOf(CacheApi.class);
 
-        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest())), equalTo("Hello world"));
+        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest(), mat)), equalTo("Hello world"));
         assertThat(cache.get("homePage"), notNullValue());
         cache.set("homePage", Results.ok("something else"));
-        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest())), equalTo("something else"));
+        assertThat(contentAsString(MockJavaActionHelper.call(new Controller1(), fakeRequest(), mat)), equalTo("something else"));
     }
 }
diff --git a/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaCsrf.java b/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaCsrf.java
index 695bc35662..4cd869fc5a 100644
--- a/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaCsrf.java
+++ b/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaCsrf.java
@@ -24,6 +24,7 @@ import javaguide.testhelpers.MockJavaAction;
 import javaguide.testhelpers.MockJavaActionHelper;
 import javaguide.forms.html.form;
 
+import java.util.Collections;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.Optional;
@@ -44,7 +45,7 @@ public class JavaCsrf extends WithApplication {
                 //#get-token
                 return ok(token.map(CSRF.Token::value).orElse(""));
             }
-        }, fakeRequest("GET", "/").session("csrfToken", token)));
+        }, fakeRequest("GET", "/").session("csrfToken", token), mat));
 
         assertTrue(crypto().compareSignedTokens(body, token));
     }
@@ -56,7 +57,7 @@ public class JavaCsrf extends WithApplication {
             public Result index() {
                 return ok(javaguide.forms.html.csrf.render());
             }
-        }, fakeRequest("GET", "/").session("csrfToken", token)));
+        }, fakeRequest("GET", "/").session("csrfToken", token), mat));
 
         Matcher matcher = Pattern.compile("action=\"/items\\?csrfToken=[a-f0-9]+-\\d+-([a-f0-9]+)\"")
                 .matcher(body);
@@ -72,7 +73,7 @@ public class JavaCsrf extends WithApplication {
     @Test
     public void csrfCheck() {
         assertThat(MockJavaActionHelper.call(new Controller1(), fakeRequest("POST", "/")
-                .header(CONTENT_TYPE, "application/x-www-form-urlencoded")).status(), equalTo(FORBIDDEN));
+            .bodyForm(Collections.singletonMap("foo", "bar")), mat).status(), equalTo(FORBIDDEN));
     }
 
     public static class Controller1 extends MockJavaAction {
@@ -88,7 +89,7 @@ public class JavaCsrf extends WithApplication {
     @Test
     public void csrfAddToken() {
         assertThat(crypto().extractSignedToken(contentAsString(
-                MockJavaActionHelper.call(new Controller2(), fakeRequest("GET", "/"))
+                MockJavaActionHelper.call(new Controller2(), fakeRequest("GET", "/"), mat)
         )), notNullValue());
     }
 
diff --git a/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaForms.java b/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaForms.java
index 9d53aa0b2e..84d1eac514 100644
--- a/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaForms.java
+++ b/documentation/manual/working/javaGuide/main/forms/code/javaguide/forms/JavaForms.java
@@ -51,7 +51,7 @@ public class JavaForms extends WithApplication {
     @Test
     public void bindFromRequest() {
         Result result = MockJavaActionHelper.call(new Controller1(),
-                fakeRequest().bodyForm(ImmutableMap.of("email", "e", "password", "p")));
+                fakeRequest("POST", "/").bodyForm(ImmutableMap.of("email", "e", "password", "p")), mat);
         assertThat(contentAsString(result), equalTo("e"));
     }
 
@@ -127,7 +127,8 @@ public class JavaForms extends WithApplication {
 
     @Test
     public void handleErrors() {
-        Result result = MockJavaActionHelper.call(new Controller2(), fakeRequest());
+        Result result = MockJavaActionHelper.call(new Controller2(), fakeRequest("POST", "/")
+            .bodyForm(ImmutableMap.of("email", "e")), mat);
         assertThat(contentAsString(result), startsWith("Got user"));
     }
 
@@ -146,7 +147,7 @@ public class JavaForms extends WithApplication {
         }
 
         public Result index() {
-            Form<User> userForm = Form.form(User.class).bind(ImmutableMap.of("email", "e"));
+            Form<User> userForm = Form.form(User.class).bindFromRequest();
             //#handle-errors
             if (userForm.hasErrors()) {
                 return badRequest(views.html.form.render(userForm));
@@ -178,7 +179,7 @@ public class JavaForms extends WithApplication {
     @Test
     public void dynamicForm() {
         Result result = MockJavaActionHelper.call(new Controller3(),
-                fakeRequest().bodyForm(ImmutableMap.of("firstname", "a", "lastname", "b")));
+                fakeRequest("POST", "/").bodyForm(ImmutableMap.of("firstname", "a", "lastname", "b")), mat);
         assertThat(contentAsString(result), equalTo("Hello a b"));
     }
 
diff --git a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
index ccb2ace691..745f0a7e64 100644
--- a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
+++ b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
@@ -3,55 +3,115 @@
 
 ## What is a body parser?
 
-An HTTP request (at least for those using the POST and PUT operations) contains a body. This body can be formatted with any format specified in the Content-Type header. A **body parser** transforms this request body into a Java value. 
+An HTTP request is a header followed by a body.  The header is typically small - it can be safely buffered in memory, hence in Play it is modelled using the [`RequestHeader`](api/java/play/mvc/Http.RequestHeader.html) class.  The body however can be potentially very long, and so is not buffered in memory, but rather is modelled as a stream.  However, many request body payloads are small and can be modelled in memory, and so to map the body stream to an object in memory, Play provides a [`BodyParser`](api/java/play/mvc/BodyParser.html) abstraction.
 
-> **Note:** You can't write `BodyParser` implementation directly using Java. Because a Play `BodyParser` must handle the body content incrementally using an `Iteratee[Array[Byte], A]` it must be implemented in Scala.
->
-> However Play provides default `BodyParser`s that should fit most use cases (parsing Json, Xml, Text, uploading files). And you can reuse these default parsers to create your own directly in Java; for example you can provide an RDF parsers based on the Text one.
+Since Play is an asynchronous framework, the traditional `InputStream` can't be used to read the request body - input streams are blocking, when you invoke `read`, the thread invoking it must wait for data to be available.  Instead, Play uses an asynchronous streaming library called [Akka streams](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/java.html).  Akka streams is an implementation of [Reactive Streams](http://www.reactive-streams.org/), a SPI that allows many asynchronous streaming APIs to seamlessly work together, so though traditional `InputStream` based technologies are not suitable for use with Play, Akka streams and the entire ecosystem of asynchronous libraries around Reactive Streams will provide you with everything you need.
 
-## The `BodyParser` Java API
+## Using the built in body parsers
 
-When working with request bodies, ensure that have the following imports in your controller:
+Most typical web apps will not need to use custom body parsers, they can simply work with Play's built in body parsers.  These include parsers for JSON, XML, forms, as well as handling plain text bodies as Strings and byte bodies as `ByteString`.
 
-@[imports](code/javaguide/http/JavaBodyParsers.java)
+### The default body parser
 
-In the Java API, all body parsers must generate a `play.mvc.Http.RequestBody` value. This value computed by the body parser can then be retrieved via `request().body()`:
+The default body parser that's used if you do not explicitly select a body parser will look at the incoming `Content-Type` header, and parses the body accordingly.  So for example, a `Content-Type` of type `application/json` will be parsed as a `JsonNode`, while a `Content-Type` of `application/x-form-www-urlencoded` will be parsed as a `Map<String, String[]>`.
 
-@[request-body](code/javaguide/http/JavaBodyParsers.java)
+The request body can be accessed through the `body()` method on [`Request`](api/java/play/mvc/Http.Request.html), and is wrapped in a [`RequestBody`](api/java/play/mvc/Http.RequestBody.html) object, which provides convenient accessors to the various types that the body could be.  For example, to access a JSON body:
 
-You can specify the `BodyParser` to use for a particular action using the `@BodyParser.Of` annotation:
+@[access-json-body](code/javaguide/http/JavaBodyParsers.java)
+
+The following is a mapping of types supported by the default body parser:
+
+- **text/plain**: `String`, accessible via `asText()`.
+- **application/json**: `com.fasterxml.jackson.databind.JsonNode`, accessible via `asJson()`.
+- **application/xml**, **text/xml** or **application/XXX+xml**: `org.w3c.Document`, accessible via `asXml()`.
+- **application/form-url-encoded**: `Map<String, String[]>`, accessible via `asFormUrlEncoded()`.
+- **multipart/form-data**: [`MultipartFormData`](api/java/play/mvc/Http.MultipartFormData.html), accessible via `asMultipartFormData()`.
+- Any other content type: [`RawBuffer`](api/java/play/mvc/Http.RawBuffer.html), accessible via `asRaw()`.
+
+The default body parser, for performance reasons, won't attempt to parse the body if the request method is not defined to have a meaningful body, as defined by the HTTP spec.  This means it only parses bodies of `POST`, `PUT` and `PATCH` requests, but not `GET`, `HEAD` or `DELETE`.  If you would like to parse request bodies for these methods, you can use the `AnyContent` body parser, described [below](#Choosing-an-explicit-body-parser).
+
+### Choosing an explicit body parser
+
+If you want to explicitly select a body parser, this can be done using the [`@BodyParser.Of`](api/java/play/mvc/BodyParser.Of.html) annotation, for example:
 
 @[particular-body-parser](code/javaguide/http/JavaBodyParsers.java)
 
-## The `Http.RequestBody` API
+The body parsers that Play provides out of the box are all inner classes of the [`BodyParser`](api/java/play/mvc/BodyParser.html) class.  Briefly, they are:
+
+- [`Default`](api/java/play/mvc/BodyParser.Default.html): The default body parser.
+- [`AnyContent`](api/java/play/mvc/BodyParser.AnyContent.html): Like the default body parser, but will parse bodies of `GET`, `HEAD` and `DELETE` requests.
+- [`Json`](api/java/play/mvc/BodyParser.Json.html): Parses the body as JSON.
+- [`TolerantJson`](api/java/play/mvc/BodyParser.TolerantJson.html): Like `Json`, but does not validate that the `Content-Type` header is JSON.
+- [`Xml`](api/java/play/mvc/BodyParser.Xml.html): Parses the body as XML.
+- [`TolerantXml`](api/java/play/mvc/BodyParser.TolerantXml.html): Like `Xml`, but does not validate that the `Content-Type` header is XML.
+- [`Text`](api/java/play/mvc/BodyParser.Text.html): Parses the body as a String.
+- [`TolerantText`](api/java/play/mvc/BodyParser.TolerantText.html): Like `Text`, but does not validate that the `Content-Type` is `text/plain`.
+- [`Bytes`](api/java/play/mvc/BodyParser.Bytes.html): Parses the body as a `ByteString`.
+- [`Raw`](api/java/play/mvc/BodyParser.Raw.html): Parses the body as a `RawBuffer`.  This will attempt to store the body in memory, up to Play's configured memory buffer size, but fallback to writing it out to a `File` if that's exceeded.
+- [`FormUrlEncoded`](api/java/play/mvc/BodyParser.FormUrlEncoded.html): Parses the body as a form.
+- [`MultipartFormData`](api/java/play/mvc/BodyParser.MultipartFormData.html): Parses the body as a multipart form, storing file parts to files.
+- [`Empty`](api/java/play/mvc/BodyParser.Empty.html): Does not parse the body, rather it ignores it.
+
+### Content length limits
+
+Most of the built in body parsers buffer the body in memory, and some buffer it on disk.  If the buffering was unbounded, this would open up a potential vulnerability to malicious or careless use of the application.  For this reason, Play has two configured buffer limits, one for in memory buffering, and one for disk buffering.
+
+The memory buffer limit is configured using `play.http.parser.maxMemoryBuffer`, and defaults to 100KB, while the disk buffer limit is configured using `play.http.parser.maxDiskBuffer`, and defaults to 10MB.  These can both be configured in `application.conf`, for example, to increase the memory buffer limit to 256KB:
+
+    play.http.parser.maxMemoryBuffer = 256kb
+    
+You can also limit the amount of memory used on a per action basis by writing a custom body parser, see [below](#Writing-a-custom-max-length-body-parser) for details.
+
+## Writing a custom body parser
+
+A custom body parser can be made by implementing the [`BodyParser`](api/java/play/mvc/BodyParser.html) class.  This class has one abstract method:
 
-As we just said all body parsers in the Java API will give you a `play.mvc.Http.RequestBody` value. From this body object you can retrieve the request body content in the most appropriate Java type.
+@[body-parser-apply](code/javaguide/http/JavaBodyParsers.java)
 
-> **Note:** The `RequestBody` methods like `asText()` or `asJson()` will return `null` if the parser used to compute this request body doesn't support this content type. For example in an action method annotated with `@BodyParser.Of(BodyParser.Json.class)`, calling `asXml()` on the generated body will return `null`.
+The signature of this method may be a bit daunting at first, so let's break it down.
 
-## Default body parser: AnyContent
+The method takes a [`RequestHeader`](api/java/play/mvc/Http.RequestHeader.html).  This can be used to check information about the request - most commonly, it is used to get the `Content-Type`, so that the body can be correctly parsed.
 
-If you don't specify your own body parser, Play will use the default one guessing the most appropriate content type from the `Content-Type` header:
+The return type of the method is an [`Accumulator`](api/java/play/libs/streams/Accumulator.html).  An accumulator is a thin layer around an [Akka streams](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/java.html) [`Sink`](http://doc.akka.io/japi/akka-stream-and-http-experimental/1.0/akka/stream/javadsl/Sink.html).  An accumulator asynchronously accumulates streams of elements into a result, it can be run by passing in an Akka streams [`Source`](http://doc.akka.io/japi/akka-stream-and-http-experimental/1.0/akka/stream/javadsl/Source.html), this will return a `CompletionStage` that will be redeemed when the accumulator is complete.  It is essentially the same thing as a `Sink<E, CompletionStage<A>>`, in fact it is nothing more than a wrapper around this type, but the big difference is that `Accumulator` provides convenient methods such as `map`, `mapFuture`, `recover` etc. for working with the result as if it were a promise, where `Sink` requires all such operations to be wrapped in a `mapMaterializedValue` call.
 
-- **text/plain**: `String`, accessible via `asText()`
-- **application/json**: `JsonNode`, accessible via `asJson()`
-- **application/xml**, **text/xml** or **application/XXX+xml**: `org.w3c.Document`, accessible via `asXml()`
-- **application/form-url-encoded**: `Map<String, String[]>`, accessible via `asFormUrlEncoded()`
-- **multipart/form-data**: `Http.MultipartFormData`, accessible via `asMultipartFormData()`
-- Any other content type: `Http.RawBuffer`, accessible via `asRaw()`
+The accumulator that the `apply` method returns consumes elements of type [`ByteString`](http://doc.akka.io/japi/akka/2.3.10/akka/util/ByteString.html) - these are essentially arrays of bytes, but differ from `byte[]` in that `ByteString` is immutable, and many operations such as slicing and appending happen in constant time.
 
-For example:
+The return type of the accumulator is `F.Either<Result, A>`.  This says it will either return a `Result`, or it will return a body of type `A`.  A result is generally returned in the case of an error, for example, if the body failed to be parsed, if the `Content-Type` didn't match the type that the body parser accepts, or if an in memory buffer was exceeded.  When the body parser returns a result, this will short circuit the processing of the action - the body parsers result will be returned immediately, and the action will never be invoked.
 
-@[default-parser](code/javaguide/http/JavaBodyParsers.java)
+### Composing an existing body parser
 
-## Max content length
+As a first example, we'll show how to compose an existing body parser.  Let's say you want to parse some incoming JSON into a class that you have defined, called `Item`.
 
-Text based body parsers (such as **text**, **json**, **xml** or **formUrlEncoded**) use a max content length because they have to load all the content into memory.  By default, the maximum content length that they will parse is 100KB.  It can be overridden by specifying the `play.http.parser.maxMemoryBuffer` property in `application.conf`:
+First we'll define a new body parser that depends on the JSON body parser:
 
-    play.http.parser.maxMemoryBuffer=128K
+@[composing-class](code/javaguide/http/JavaBodyParsers.java)
 
-For parsers that buffer content on disk, such as the raw parser or `multipart/form-data`, the maximum content length is specified using the `play.http.parser.maxDiskBuffer` property, it defaults to 10MB.  The `multipart/form-data` parser also enforces the text max length property for the aggregate of the data fields.
+Now, in our implementation of the `apply` method, we'll invoke the JSON body parser, which will give us back the `Accumulator<ByteString, F.Either<Result, JsonNode>>` to consume the body.  We can then map that like a promise, to convert the parsed `JsonNode` body to a `User` body.  If the conversion fails, we return a `Left` of a `Result` saying what the error was:
 
-You can also override the default maximum content length for a given action by defining a custom body parser that defines the maximum length.  For example:
+@[composing-apply](code/javaguide/http/JavaBodyParsers.java)
+
+The returned body will be wrapped in a `RequestBody`, and can be accessed using the `as` method:
+
+@[composing-access](code/javaguide/http/JavaBodyParsers.java)
+
+### Writing a custom max length body parser
+
+Another use case may be to define a body parser that uses a custom maximum length for buffering.  Many of the built in Play body parsers are designed to be extended to allow overriding the buffer length in this way, for example, this is how the text body parser can be extended:
 
 @[max-length](code/javaguide/http/JavaBodyParsers.java)
+
+### Directing the body elsewhere
+
+So far we've shown extending and composing the existing body parsers.  Sometimes you may not actually want to parse the body, you simply want to forward it elsewhere.  For example, if you want to upload the request body to another service, you could do this by defining a custom body parser:
+
+@[forward-body](code/javaguide/http/JavaBodyParsers.java)
+
+### Custom parsing using Akka streams
+
+In rare circumstances, it may be necessary to write a custom parser using Akka streams.  In most cases it will suffice to buffer the body in a `ByteString` first, by composing the `Bytes` parser as described [above](#Composing-an-existing-body-parser), this will typically offer a far simpler way of parsing since you can use imperative methods and random access on the body.
+
+However, when that's not feasible, for example when the body you need to parse is too long to fit in memory, then you may need to write a custom body parser.
+
+A full description of how to use Akka streams is beyond the scope of this documentation - the best place to start is to read the [Akka streams documentation](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/java.html).  However, the following shows a CSV parser, which builds on the [Parsing lines from a stream of ByteStrings](http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0/java/stream-cookbook.html#Parsing_lines_from_a_stream_of_ByteStrings) documentation from the Akka streams cookbook:
+
+@[csv](code/javaguide/http/JavaBodyParsers.java)
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
index 317d1fa687..ac9a2cd8f7 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaActions.java
@@ -28,7 +28,7 @@ public class JavaActions extends WithApplication {
                 return ok("Got request " + request() + "!");
             }
             //#simple-action
-        }, fakeRequest()).status(), equalTo(200));
+        }, fakeRequest(), mat).status(), equalTo(200));
     }
 
     @Test
@@ -37,7 +37,7 @@ public class JavaActions extends WithApplication {
             public Result index() {
                 return new javaguide.http.full.Application().index();
             }
-        }, fakeRequest()).status(), equalTo(200));
+        }, fakeRequest(), mat).status(), equalTo(200));
     }
 
     @Test
@@ -52,7 +52,7 @@ public class JavaActions extends WithApplication {
             public F.Promise<Result> invocation() {
                 return F.Promise.pure(index("world"));
             }
-        }, fakeRequest());
+        }, fakeRequest(), mat);
         assertThat(result.status(), equalTo(200));
         assertThat(contentAsString(result), equalTo("Hello world"));
     }
@@ -65,7 +65,7 @@ public class JavaActions extends WithApplication {
                 return ok("Hello world!");
             }
             //#simple-result
-        }, fakeRequest()).status(), equalTo(200));
+        }, fakeRequest(), mat).status(), equalTo(200));
     }
 
     @Test
@@ -110,7 +110,7 @@ public class JavaActions extends WithApplication {
                 return redirect("/user/home");
             }
             //#redirect-action
-        }, fakeRequest());
+        }, fakeRequest(), mat);
         assertThat(result.status(), equalTo(SEE_OTHER));
         assertThat(result.header(LOCATION), equalTo(Optional.of("/user/home")));
     }
@@ -123,7 +123,7 @@ public class JavaActions extends WithApplication {
                 return temporaryRedirect("/user/home");
             }
             //#temporary-redirect-action
-        }, fakeRequest());
+        }, fakeRequest(), mat);
         assertThat(result.status(), equalTo(TEMPORARY_REDIRECT));
         assertThat(result.header(LOCATION), equalTo(Optional.of("/user/home")));
     }
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
index af04688128..f8bb3ce6a0 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
@@ -4,19 +4,29 @@
 package javaguide.http;
 
 import akka.stream.Materializer;
+import akka.stream.io.Framing;
+import akka.util.ByteString;
 import org.junit.Before;
 import org.junit.Test;
 import play.http.HttpErrorHandler;
+import play.libs.F;
 import play.libs.Json;
+import play.libs.streams.Accumulator;
+import play.libs.ws.WSClient;
+import play.libs.ws.WSResponse;
 import play.test.WithApplication;
 import javaguide.testhelpers.MockJavaAction;
+import javax.inject.Inject;
+import com.fasterxml.jackson.databind.JsonNode;
 
-//#imports
+import akka.stream.javadsl.*;
 import play.mvc.*;
 import play.mvc.Http.*;
-//#imports
+import java.util.concurrent.Executor;
 
-import javax.inject.Inject;
+import scala.compat.java8.FutureConverters;
+
+import java.util.*;
 
 import static javaguide.testhelpers.MockJavaActionHelper.*;
 import static org.hamcrest.CoreMatchers.*;
@@ -28,46 +38,82 @@ public class JavaBodyParsers extends WithApplication {
     @Test
     public void accessRequestBody() {
         assertThat(contentAsString(call(new MockJavaAction() {
-            //#request-body
+            //#access-json-body
             public Result index() {
-                RequestBody body = request().body();
-                return ok("Got body: " + body.asText());
+                JsonNode json = request().body().asJson();
+                return ok("Got name: " + json.get("name").asText());
             }
-            //#request-body
-        }, fakeRequest().bodyText("foo"))), containsString("foo"));
+            //#access-json-body
+        }, fakeRequest("POST", "/").bodyJson(Json.toJson(Collections.singletonMap("name", "foo"))), mat)), containsString("foo"));
     }
 
     @Test
     public void particularBodyParser() {
         assertThat(contentAsString(call(new MockJavaAction() {
                     //#particular-body-parser
-                    @BodyParser.Of(BodyParser.Json.class)
+                    @BodyParser.Of(BodyParser.Text.class)
                     public Result index() {
                         RequestBody body = request().body();
-                        return ok("Got json: " + body.asJson());
+                        return ok("Got text: " + body.asText());
                     }
                     //#particular-body-parser
-                }, fakeRequest().bodyJson(Json.toJson("foo")))),
-                containsString("\"foo\""));
+                }, fakeRequest().bodyText("foo"), mat)),
+                containsString("foo"));
+    }
+
+    public static abstract class BodyParserApply<A> implements BodyParser<A> {
+        // Override the method with another abstract method - if the signature changes, we get a compile error
+        @Override
+        //#body-parser-apply
+        public abstract Accumulator<ByteString, F.Either<Result, A>> apply(RequestHeader request);
+        //#body-parser-apply
+    }
+
+    public static class User {
+        public String name;
+    }
+
+    //#composing-class
+    public static class UserBodyParser implements BodyParser<User> {
+        @Inject BodyParser.Json jsonParser;
+        @Inject Executor executor;
+    //#composing-class
+
+        //#composing-apply
+        public Accumulator<ByteString, F.Either<Result, User>> apply(RequestHeader request) {
+            Accumulator<ByteString, F.Either<Result, JsonNode>> jsonAccumulator = jsonParser.apply(request);
+            return jsonAccumulator.map(resultOrJson -> {
+               if (resultOrJson.left.isPresent()) {
+                   return F.Either.Left(resultOrJson.left.get());
+               } else {
+                   JsonNode json = resultOrJson.right.get();
+                   try {
+                       User user = play.libs.Json.fromJson(json, User.class);
+                       return F.Either.Right(user);
+                   } catch (Exception e) {
+                       return F.Either.Left(Results.badRequest(
+                           "Unable to read User from json: " + e.getMessage()));
+                   }
+               }
+            }, executor);
+        }
+        //#composing-apply
     }
 
     @Test
-    public void defaultParser() {
-        assertThat(call(new MockJavaAction() {
-                    //#default-parser
-                    public Result save() {
-                        RequestBody body = request().body();
-                        String textBody = body.asText();
+    public void composingBodyParser() {
+        assertThat(contentAsString(call(new MockJavaAction() {
+                //#composing-access
+                @BodyParser.Of(UserBodyParser.class)
+                public Result save() {
+                    RequestBody body = request().body();
+                    User user = body.as(User.class);
 
-                        if(textBody != null) {
-                            return ok("Got: " + textBody);
-                        } else {
-                            return badRequest("Expecting text/plain request body");
-                        }
-                    }
-                    //#default-parser
-                }, fakeRequest().bodyJson(Json.toJson("foo"))).status(),
-                equalTo(400));
+                    return ok("Got: " + user.name);
+                }
+                //#composing-access
+            }, fakeRequest().bodyJson(Json.toJson(Collections.singletonMap("name", "foo"))), mat)),
+                equalTo("Got: foo"));
     }
 
     @Test
@@ -76,7 +122,6 @@ public class JavaBodyParsers extends WithApplication {
         for (int i = 0; i < 1100; i++) {
             body.append("1234567890");
         }
-        Materializer mat = app.injector().instanceOf(Materializer.class);
         assertThat(callWithStringBody(new MaxLengthAction(), fakeRequest(), body.toString(), mat).status(),
                 equalTo(413));
     }
@@ -97,4 +142,67 @@ public class JavaBodyParsers extends WithApplication {
         }
         //#max-length
     }
+
+    //#forward-body
+    public static class ForwardingBodyParser implements BodyParser<WSResponse> {
+        @Inject WSClient ws;
+        @Inject Executor executor;
+        String url = "http://example.com";
+
+        public Accumulator<ByteString, F.Either<Result, WSResponse>> apply(RequestHeader request) {
+            Accumulator<ByteString, Source<ByteString, ?>> forwarder = Accumulator.source();
+
+            return forwarder.mapFuture(source -> {
+                // TODO: when streaming upload has been implemented, pass the source as the body
+                return FutureConverters.toJava(ws.url(url)
+                        .setMethod("POST")
+                            // .setBody(source)
+                        .execute()
+                        .wrapped()
+                ).thenApply(F.Either::Right);
+            }, executor);
+        }
+    }
+    //#forward-body
+    // no test for forwarding yet because it doesn't actually work yet
+
+    //#csv
+    public static class CsvBodyParser implements BodyParser<List<List<String>>> {
+        @Inject Executor executor;
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, List<List<String>>>> apply(RequestHeader request) {
+            // A flow that splits the stream into CSV lines
+            Sink<ByteString, scala.concurrent.Future<List<List<String>>>> sink = Flow.<ByteString>create()
+                // We split by the new line character, allowing a maximum of 1000 characters per line
+                .via(Framing.delimiter(ByteString.fromString("\n"), 1000, true))
+                // Turn each line to a String and split it by commas
+                .map(bytes -> {
+                    String[] values = bytes.utf8String().trim().split(",");
+                    return Arrays.asList(values);
+                })
+                // Now we fold it into a list
+                .toMat(Sink.<List<List<String>>, List<String>>fold(
+                    new ArrayList<>(), (list, values) -> {
+                        list.add(values);
+                        return list;
+                    }), Keep.right());
+
+            // Convert the body to a Right either
+            return Accumulator.fromSink(sink).map(F.Either::Right, executor);
+        }
+    }
+    //#csv
+
+    @Test
+    public void testCsv() {
+        assertThat(contentAsString(call(new MockJavaAction() {
+                @BodyParser.Of(CsvBodyParser.class)
+                public Result uploadCsv() {
+                    String value = ((List<List<String>>) request().body().as(List.class)).get(1).get(2);
+                    return ok("Got: " + value);
+                }
+            }, fakeRequest().bodyText("1,2\n3,4,foo\n5,6"), mat)),
+            equalTo("Got: foo"));
+    }
 }
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaContentNegotiation.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaContentNegotiation.java
index 7d49d0747b..0f305a5a57 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaContentNegotiation.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaContentNegotiation.java
@@ -32,7 +32,7 @@ public class JavaContentNegotiation extends WithApplication {
                         }
                     }
                     //#negotiate-content
-                }, fakeRequest().header("Accept", "text/html"))),
+                }, fakeRequest().header("Accept", "text/html"), mat)),
                 equalTo("html list of items"));
     }
 
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaResponse.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaResponse.java
index e80d769cf6..4f5f2e8e7f 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaResponse.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaResponse.java
@@ -62,7 +62,7 @@ public class JavaResponse extends WithApplication {
                 return ok("<h1>Hello World!</h1>");
             }
             //#response-headers
-        }, fakeRequest()).headers();
+        }, fakeRequest(), mat).headers();
         assertThat(headers.get(CACHE_CONTROL), equalTo("max-age=3600"));
         assertThat(headers.get(ETAG), equalTo("xxx"));
     }
@@ -124,7 +124,7 @@ public class JavaResponse extends WithApplication {
                         return ok("<h1>Hello World!</h1>", "iso-8859-1").as("text/html; charset=iso-8859-1");
                     }
                     //#charset
-                }, fakeRequest()).charset().get(),
+                }, fakeRequest(), mat).charset().get(),
                 equalTo("iso-8859-1"));
     }
 
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaSessionFlash.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaSessionFlash.java
index 3df2492b13..7b6bbfe383 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaSessionFlash.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaSessionFlash.java
@@ -35,7 +35,7 @@ public class JavaSessionFlash extends WithApplication {
                         }
                     }
                     //#read-session
-                }, fakeRequest().session("connected", "foo"))),
+                }, fakeRequest().session("connected", "foo"), mat)),
                 equalTo("Hello foo"));
     }
 
@@ -48,7 +48,7 @@ public class JavaSessionFlash extends WithApplication {
                 return ok("Welcome!");
             }
             //#store-session
-        }, fakeRequest()).session();
+        }, fakeRequest(), mat).session();
         assertThat(session.get("connected"), equalTo("user@gmail.com"));
     }
 
@@ -61,7 +61,7 @@ public class JavaSessionFlash extends WithApplication {
                 return ok("Bye");
             }
             //#remove-from-session
-        }, fakeRequest().session("connected", "foo")).session();
+        }, fakeRequest().session("connected", "foo"), mat).session();
         assertThat(session.get("connected"), nullValue());
     }
 
@@ -74,7 +74,7 @@ public class JavaSessionFlash extends WithApplication {
                 return ok("Bye");
             }
             //#discard-whole-session
-        }, fakeRequest().session("connected", "foo")).session();
+        }, fakeRequest().session("connected", "foo"), mat).session();
         assertThat(session.get("connected"), nullValue());
     }
 
@@ -90,7 +90,7 @@ public class JavaSessionFlash extends WithApplication {
                         return ok(message);
                     }
                     //#read-flash
-                }, fakeRequest().flash("success", "hi"))),
+                }, fakeRequest().flash("success", "hi"), mat)),
                 equalTo("hi"));
     }
 
@@ -103,7 +103,7 @@ public class JavaSessionFlash extends WithApplication {
                 return redirect("/home");
             }
             //#store-flash
-        }, fakeRequest()).flash();
+        }, fakeRequest(), mat).flash();
         assertThat(flash.get("success"), equalTo("The item has been created"));
     }
 
@@ -114,7 +114,7 @@ public class JavaSessionFlash extends WithApplication {
                 return ok(javaguide.http.views.html.index.render());
             }
         };
-        assertThat(contentAsString(call(index, fakeRequest())).trim(), equalTo("Welcome!"));
-        assertThat(contentAsString(call(index, fakeRequest().flash("success", "Flashed!"))).trim(), equalTo("Flashed!"));
+        assertThat(contentAsString(call(index, fakeRequest(), mat)).trim(), equalTo("Welcome!"));
+        assertThat(contentAsString(call(index, fakeRequest().flash("success", "Flashed!"), mat)).trim(), equalTo("Flashed!"));
     }
 }
diff --git a/documentation/manual/working/javaGuide/main/i18n/code/javaguide/i18n/JavaI18N.java b/documentation/manual/working/javaGuide/main/i18n/code/javaguide/i18n/JavaI18N.java
index 043b6aa005..ad1e19792f 100644
--- a/documentation/manual/working/javaGuide/main/i18n/code/javaguide/i18n/JavaI18N.java
+++ b/documentation/manual/working/javaGuide/main/i18n/code/javaguide/i18n/JavaI18N.java
@@ -45,7 +45,7 @@ public class JavaI18N extends WithApplication {
 
     @Test
     public void checkDefaultHello() {
-        Result result = MockJavaActionHelper.call(new DefaultLangController(), fakeRequest("GET", "/"));
+        Result result = MockJavaActionHelper.call(new DefaultLangController(), fakeRequest("GET", "/"), mat);
         assertThat(contentAsString(result), containsString("hello"));
     }
 
@@ -59,7 +59,7 @@ public class JavaI18N extends WithApplication {
 
     @Test
     public void checkDefaultScalaHello() {
-        Result result = MockJavaActionHelper.call(new DefaultScalaLangController(), fakeRequest("GET", "/"));
+        Result result = MockJavaActionHelper.call(new DefaultScalaLangController(), fakeRequest("GET", "/"), mat);
         assertThat(contentAsString(result), containsString("hello"));
     }
 
@@ -71,7 +71,7 @@ public class JavaI18N extends WithApplication {
 
     @Test
     public void checkChangeLangHello() {
-        Result result = MockJavaActionHelper.call(new ChangeLangController(), fakeRequest("GET", "/"));
+        Result result = MockJavaActionHelper.call(new ChangeLangController(), fakeRequest("GET", "/"), mat);
         assertThat(contentAsString(result), containsString("bonjour"));
     }
 
@@ -86,7 +86,7 @@ public class JavaI18N extends WithApplication {
 
     @Test
     public void checkSetTransientLangHello() {
-        Result result = MockJavaActionHelper.call(new SetTransientLangController(), fakeRequest("GET", "/"));
+        Result result = MockJavaActionHelper.call(new SetTransientLangController(), fakeRequest("GET", "/"), mat);
         assertThat(contentAsString(result), containsString("howdy"));
     }
 
diff --git a/documentation/manual/working/javaGuide/main/json/code/javaguide/json/JavaJsonActions.java b/documentation/manual/working/javaGuide/main/json/code/javaguide/json/JavaJsonActions.java
index 030ab240e8..6681b1b2e9 100644
--- a/documentation/manual/working/javaGuide/main/json/code/javaguide/json/JavaJsonActions.java
+++ b/documentation/manual/working/javaGuide/main/json/code/javaguide/json/JavaJsonActions.java
@@ -80,28 +80,28 @@ public class JavaJsonActions extends WithApplication {
     @Test
     public void requestAsAnyContentAction() {
         assertThat(contentAsString(
-            call(new JsonRequestAsJsonAction(), fakeRequest().bodyJson(Json.parse("{\"name\":\"Greg\"}")))
+            call(new JsonRequestAsJsonAction(), fakeRequest().bodyJson(Json.parse("{\"name\":\"Greg\"}")), mat)
         ), equalTo("Hello Greg"));
     }
 
     @Test
     public void requestAsJsonAction() {
         assertThat(contentAsString(
-            call(new JsonRequestAsJsonAction(), fakeRequest().bodyJson(Json.parse("{\"name\":\"Greg\"}")))
+            call(new JsonRequestAsJsonAction(), fakeRequest().bodyJson(Json.parse("{\"name\":\"Greg\"}")), mat)
         ), equalTo("Hello Greg"));
     }
 
     @Test
     public void responseAction() {
         assertThat(contentAsString(
-            call(new JsonResponseAction(), fakeRequest())
+            call(new JsonResponseAction(), fakeRequest(), mat)
         ), equalTo("{\"exampleField1\":\"foobar\",\"exampleField2\":\"Hello world!\"}"));
     }
 
     @Test
     public void responseDaoAction() {
         assertThat(contentAsString(
-            call(new JsonResponseDaoAction(), fakeRequest())
+            call(new JsonResponseDaoAction(), fakeRequest(), mat)
         ), equalTo("[{\"firstName\":\"Foo\",\"lastName\":\"Bar\",\"age\":30}]"));
     }
 
diff --git a/framework/src/play-specs2/src/main/scala/play/api/test/Specs.scala b/framework/src/play-specs2/src/main/scala/play/api/test/Specs.scala
index dcfee23b57..6c2ca69ded 100644
--- a/framework/src/play-specs2/src/main/scala/play/api/test/Specs.scala
+++ b/framework/src/play-specs2/src/main/scala/play/api/test/Specs.scala
@@ -35,7 +35,7 @@ abstract class WithApplicationLoader(applicationLoader: ApplicationLoader = new
  */
 abstract class WithApplication(val app: Application = FakeApplication()) extends Around with Scope {
   implicit def implicitApp = app
-  implicit def implicitFlowMaterializer = app.materializer
+  implicit def implicitMaterializer = app.materializer
   override def around[T: AsResult](t: => T): Result = {
     Helpers.running(app)(AsResult.effectively(t))
   }
@@ -53,6 +53,7 @@ abstract class WithServer(
     val app: Application = FakeApplication(),
     val port: Int = Helpers.testServerPort,
     val serverProvider: Option[ServerProvider] = None) extends Around with Scope {
+  implicit def implicitMaterializer = app.materializer
   implicit def implicitApp = app
   implicit def implicitPort: Port = port
 
diff --git a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
index e47612fb0e..58402e4b7e 100644
--- a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
+++ b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
@@ -5,6 +5,7 @@ import akka.stream.javadsl.Flow;
 import akka.stream.javadsl.Keep;
 import akka.stream.javadsl.Sink;
 import akka.stream.javadsl.Source;
+import org.reactivestreams.Publisher;
 import scala.compat.java8.FutureConverters;
 import scala.concurrent.Future;
 
@@ -194,6 +195,24 @@ public final class Accumulator<E, A> {
         return new Accumulator<>(sink.mapMaterializedValue(FutureConverters::toJava));
     }
 
+    /**
+     * Create an accumulator that forwards the stream fed into it to the source it produces.
+     *
+     * This is useful for when you want to send the consumed stream to another API that takes a Source as input.
+     *
+     * Extreme care must be taken when using this accumulator - the source *must always* be materialized and consumed.
+     * If it isn't, this could lead to resource leaks and deadlocks upstream.
+     *
+     * @return An accumulator that forwards the stream to the produced source.
+     */
+    public static <E> Accumulator<E, Source<E, ?>> source() {
+        // If Akka streams ever provides Sink.source(), we should use that instead.
+        // https://github.com/akka/akka/issues/18406
+        return new Accumulator<>(Sink.<E>publisher().mapMaterializedValue(publisher ->
+                        CompletableFuture.completedFuture(Source.from(publisher))
+        ));
+    }
+
     /**
      * Create a done accumulator with the given value.
      *
diff --git a/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala b/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
index 27ad046c73..842d86ae4c 100644
--- a/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
+++ b/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
@@ -124,6 +124,22 @@ object Accumulator {
    */
   def done[A](a: Future[A]): Accumulator[Any, A] = new Accumulator(Sink.cancelled[Any].mapMaterializedValue(_ => a))
 
+  /**
+   * Create an accumulator that forwards the stream fed into it to the source it produces.
+   *
+   * This is useful for when you want to send the consumed stream to another API that takes a Source as input.
+   *
+   * Extreme care must be taken when using this accumulator - the source *must always* be materialized and consumed.
+   * If it isn't, this could lead to resource leaks and deadlocks upstream.
+   *
+   * @return An accumulator that forwards the stream to the produced source.
+   */
+  def source[E]: Accumulator[E, Source[E, _]] = {
+    // If Akka streams ever provides Sink.source(), we should use that instead.
+    // https://github.com/akka/akka/issues/18406
+    Accumulator(Sink.publisher[E].mapMaterializedValue(publisher => Future.successful(Source(publisher))))
+  }
+
   /**
    * Flatten a future of an accumulator to an accumulator.
    */
diff --git a/framework/src/play/src/main/java/play/mvc/Http.java b/framework/src/play/src/main/java/play/mvc/Http.java
index 0b92e52efa..d7ea82e2b2 100644
--- a/framework/src/play/src/main/java/play/mvc/Http.java
+++ b/framework/src/play/src/main/java/play/mvc/Http.java
@@ -1450,6 +1450,10 @@ public class Http {
             }
         }
 
+        public String toString() {
+            return "RequestBody of " + (body == null ? "null" : body.getClass());
+        }
+
     }
 
     /**
diff --git a/framework/src/play/src/main/scala/play/api/inject/Binding.scala b/framework/src/play/src/main/scala/play/api/inject/Binding.scala
index 4dff9ae957..1f5c7c34e5 100644
--- a/framework/src/play/src/main/scala/play/api/inject/Binding.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/Binding.scala
@@ -205,8 +205,8 @@ final case class BindingKey[T](clazz: Class[T], qualifier: Option[QualifierAnnot
    * The dependency injection framework will instantiate and inject this provider, and then invoke its `get` method
    * whenever an instance of the class is needed.
    */
-  def toProvider[P <: Provider[T]](provider: Class[P]): Binding[T] =
-    Binding(this, Some(ProviderConstructionTarget(provider)), None, false, SourceLocator.source)
+  def toProvider[P <: Provider[_ <: T]](provider: Class[P]): Binding[T] =
+    Binding(this, Some(ProviderConstructionTarget[T](provider)), None, false, SourceLocator.source)
 
   /**
    * Bind this binding key to the given provider class.
@@ -214,7 +214,7 @@ final case class BindingKey[T](clazz: Class[T], qualifier: Option[QualifierAnnot
    * The dependency injection framework will instantiate and inject this provider, and then invoke its `get` method
    * whenever an instance of the class is needed.
    */
-  def toProvider[P <: Provider[T]: ClassTag]: Binding[T] =
+  def toProvider[P <: Provider[_ <: T]: ClassTag]: Binding[T] =
     toProvider(implicitly[ClassTag[P]].runtimeClass.asInstanceOf[Class[P]])
 
   /**
@@ -253,7 +253,7 @@ final case class ProviderTarget[T](provider: Provider[_ <: T]) extends BindingTa
  *
  * @see The [[Module]] class for information on how to provide bindings.
  */
-final case class ProviderConstructionTarget[T](provider: Class[_ <: Provider[T]]) extends BindingTarget[T]
+final case class ProviderConstructionTarget[T](provider: Class[_ <: Provider[_ <: T]]) extends BindingTarget[T]
 
 /**
  * A binding target that is provided by a class.
diff --git a/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala b/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
index b621e3005e..e3a654b7dc 100644
--- a/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/BuiltinModule.scala
@@ -3,12 +3,14 @@
  */
 package play.api.inject
 
+import java.util.concurrent.Executor
+
 import akka.actor.ActorSystem
 import javax.inject.{ Singleton, Inject, Provider }
 import akka.stream.Materializer
 import play.api._
 import play.api.http._
-import play.api.libs.Files.{ DefaultTemporaryFileCreator, TemporaryFileCreator, TemporaryFile }
+import play.api.libs.Files.{ DefaultTemporaryFileCreator, TemporaryFileCreator }
 import play.api.libs.{ CryptoConfig, Crypto, CryptoConfigParser }
 import play.api.libs.concurrent.{ MaterializerProvider, ExecutionContextProvider, ActorSystemProvider }
 import play.api.routing.Router
@@ -45,6 +47,7 @@ class BuiltinModule extends Module {
       bind[ActorSystem].toProvider[ActorSystemProvider],
       bind[Materializer].toProvider[MaterializerProvider],
       bind[ExecutionContext].toProvider[ExecutionContextProvider],
+      bind[Executor].toProvider[ExecutionContextProvider],
       bind[Plugins].toProvider[PluginsProvider],
 
       bind[CryptoConfig].toProvider[CryptoConfigParser],
diff --git a/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala b/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
index 715f369ced..910cf077f6 100644
--- a/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
+++ b/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
@@ -10,13 +10,13 @@ import com.google.inject.util.Types
 import com.google.inject.{ Binder, Key, AbstractModule }
 import com.google.inject.assistedinject.FactoryModuleBuilder
 import com.typesafe.config.Config
-import java.util.concurrent.TimeoutException
+import java.util.concurrent.{Executor, TimeoutException}
 import javax.inject.{ Provider, Inject, Singleton }
 import play.api._
 import play.api.inject.{ Binding, Injector, ApplicationLifecycle, bind }
 import play.core.ClosableLazy
 import akka.actor._
-import scala.concurrent.{ ExecutionContext, Future }
+import scala.concurrent.{ExecutionContextExecutor, ExecutionContext, Future}
 import scala.concurrent.duration._
 import scala.reflect.ClassTag
 
@@ -273,7 +273,7 @@ class MaterializerProvider @Inject() (actorSystem: ActorSystem) extends Provider
  * Provider for the default execution context
  */
 @Singleton
-class ExecutionContextProvider @Inject() (actorSystem: ActorSystem) extends Provider[ExecutionContext] {
+class ExecutionContextProvider @Inject() (actorSystem: ActorSystem) extends Provider[ExecutionContextExecutor] {
   def get = actorSystem.dispatcher
 }
 
