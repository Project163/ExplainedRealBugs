diff --git a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
index ade213c250..ac559024e5 100644
--- a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
+++ b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
@@ -285,13 +285,13 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
       } { ws =>
         //#stream-count-bytes
         // Make the request
-        val futureResponse: Future[(WSResponseHeaders, Source[ByteString, _])] =
-          ws.url(url).getStream()
+        val futureResponse: Future[StreamedResponse] =
+          ws.url(url).withMethod("GET").stream()
 
         val bytesReturned: Future[Long] = futureResponse.flatMap {
-          case (headers, body) =>
+          res =>
             // Count the number of bytes returned
-            body.runWith(Sink.fold[Long, ByteString](0L){ (total, bytes) =>
+            res.body.runWith(Sink.fold[Long, ByteString](0L){ (total, bytes) =>
               total + bytes.length
             })
         }
@@ -306,11 +306,11 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
         try {
           //#stream-to-file
           // Make the request
-          val futureResponse: Future[(WSResponseHeaders, Source[ByteString, _])] =
-            ws.url(url).getStream()
+          val futureResponse: Future[StreamedResponse] =
+            ws.url(url).withMethod("GET").stream()
 
           val downloadedFile: Future[File] = futureResponse.flatMap {
-            case (headers, body) =>
+            res =>
               val outputStream = new FileOutputStream(file)
 
               // The sink that writes to the output stream
@@ -319,7 +319,7 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
               }
 
               // Feed the body into the iteratee
-              body.runWith(sink).andThen {
+              res.body.runWith(sink).andThen {
                 case result =>
                   // Close the output stream whether there was an error or not
                   outputStream.close()
@@ -344,8 +344,8 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
           def downloadFile = Action.async {
 
             // Make the request
-            ws.url(url).getStream().map {
-              case (response, body) =>
+            ws.url(url).withMethod("GET").stream().map {
+              case StreamedResponse(response, body) =>
 
                 // Check that the response was successful
                 if (response.status == 200) {
@@ -383,13 +383,13 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
         import play.api.libs.iteratee._
 
         //#stream-put
-        val futureResponse: Future[(WSResponseHeaders, Source[ByteString, _])] =
+        val futureResponse: Future[StreamedResponse] =
           ws.url(url).withMethod("PUT").withBody("some body").stream()
         //#stream-put
 
         val bytesReturned: Future[Long] = futureResponse.flatMap {
-          case (headers, body) =>
-            body.runWith(Sink.fold[Long, ByteString](0L){ (total, bytes) =>
+          res =>
+            res.body.runWith(Sink.fold[Long, ByteString](0L){ (total, bytes) =>
               total + bytes.length
             })
         }
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
index 61051f7b49..ac4933caa9 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/libs/WSSpec.scala
@@ -35,6 +35,8 @@ trait WSSpec extends PlaySpecification with ServerIntegrationSpecification {
 
   def app = HttpBinApplication.app
 
+  val foldingSink = Sink.fold[ByteString, ByteString](ByteString.empty)((state, bs) => state ++ bs)
+
   "WS@java" should {
 
     def withServer[T](block: play.libs.ws.WSClient => T) = {
@@ -114,6 +116,14 @@ trait WSSpec extends PlaySpecification with ServerIntegrationSpecification {
         bar.asJson.path("args").path("foo").textValue() must_== "bar")
     }
 
+    "get a streamed response" in withResult(
+      Results.Ok.chunked(Source(List("a", "b", "c")))) { ws =>
+        val res = ws.url("/get").stream().toCompletableFuture.get()
+
+        await(res.getBody().runWith(foldingSink, app.materializer)).decodeString("utf-8").
+          aka("streamed response") must_== "abc"
+      }
+
     class CustomSigner extends WSSignatureCalculator with com.ning.http.client.SignatureCalculator {
       def calculateAndAddSignature(request: com.ning.http.client.Request, requestBuilder: com.ning.http.client.RequestBuilderBase[_]) = {
         // do nothing
@@ -139,12 +149,6 @@ trait WSSpec extends PlaySpecification with ServerIntegrationSpecification {
 
     implicit val materializer = app.materializer
 
-    implicit def source2enumerator[T](source: Source[T, Unit]): Enumerator[T] = {
-      import play.api.libs.streams.Streams
-      val publisher = source.runWith(Sink.publisher)
-      Streams.publisherToEnumerator(publisher)
-    }
-
     def withServer[T](block: play.api.libs.ws.WSClient => T) = {
       Server.withApplication(app) { implicit port =>
         WsTestClient.withClient(block)
@@ -172,12 +176,12 @@ trait WSSpec extends PlaySpecification with ServerIntegrationSpecification {
     }
 
     "get a streamed response" in withResult(
-      Results.Ok.chunked(Enumerator("a", "b", "c"))) { ws =>
+      Results.Ok.chunked(Source(List("a", "b", "c")))) { ws =>
 
         val res = ws.url("/get").stream()
-        val (_, body) = await(res)
+        val body = await(res).body
 
-        await(body |>>> Iteratee.consume[ByteString]()).decodeString("utf-8").
+        await(body.runWith(foldingSink)).decodeString("utf-8").
           aka("streamed response") must_== "abc"
       }
 
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/StreamedResponse.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/StreamedResponse.java
new file mode 100644
index 0000000000..2c20b60f8f
--- /dev/null
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/StreamedResponse.java
@@ -0,0 +1,49 @@
+package play.libs.ws;
+
+import java.util.concurrent.CompletionStage;
+
+import akka.stream.javadsl.Source;
+import akka.util.ByteString;
+import play.libs.ws.util.CollectionUtil;
+import scala.Tuple2;
+import scala.compat.java8.FutureConverters;
+import scala.concurrent.Future;
+
+/**
+ * A streamed response containing a response header and a streamable body. 
+ */
+public class StreamedResponse {
+
+	private final WSResponseHeaders headers;
+	private final Source<ByteString, ?> body;
+
+	private StreamedResponse(WSResponseHeaders headers, Source<ByteString, ?> body) {
+		this.headers = headers;
+		this.body = body;
+	}
+
+	public WSResponseHeaders getHeaders() {
+		return headers;
+	}
+
+	public Source<ByteString, ?> getBody() {
+		return body;
+	}
+	
+	public static CompletionStage<StreamedResponse> from(Future<play.api.libs.ws.StreamedResponse> from) {
+		CompletionStage<play.api.libs.ws.StreamedResponse> res = FutureConverters.toJava(from);
+		java.util.function.Function<play.api.libs.ws.StreamedResponse, StreamedResponse> mapper = response -> {
+			WSResponseHeaders headers = toJavaHeaders(response.headers());
+			Source<ByteString, ?> source = toJavaSource(response.body());
+			return new StreamedResponse(headers, source);
+	    };
+	    return res.thenApply(mapper);	
+	}
+
+	private static WSResponseHeaders toJavaHeaders(play.api.libs.ws.WSResponseHeaders from) {
+		return new DefaultWSResponseHeaders(from.status(), CollectionUtil.convert(from.headers()));
+	}
+	private static Source<ByteString, ?> toJavaSource(akka.stream.scaladsl.Source<ByteString, ?> source) {
+		return Source.adapt(source);
+	}	
+}
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSAPI.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSAPI.java
index bbad8a47f7..02fa9c1f54 100644
--- a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSAPI.java
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSAPI.java
@@ -6,8 +6,8 @@ package play.libs.ws;
 
 public interface WSAPI {
 
-    public WSClient client();
+    WSClient client();
 
-    public WSRequest url(String url);
+    WSRequest url(String url);
 
 }
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSClient.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSClient.java
index 5f0f7aeac2..472619288c 100644
--- a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSClient.java
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSClient.java
@@ -8,7 +8,11 @@ package play.libs.ws;
  */
 public interface WSClient extends java.io.Closeable {
 
-    public Object getUnderlying();
+    /**
+     * The underlying implementation of the client, if any.  You must cast the returned value to the type you want.
+     * @return the backing class.
+     */
+    Object getUnderlying();
 
     /**
      * Returns a WSRequest object representing the URL.  You can append additional
@@ -24,5 +28,5 @@ public interface WSClient extends java.io.Closeable {
      *
      * Use this for manually instantiated clients.
      */
-    public void close();
+    void close();
 }
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSRequest.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSRequest.java
index 33a78850d7..ab7d9a2991 100644
--- a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSRequest.java
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSRequest.java
@@ -11,6 +11,7 @@ import java.io.File;
 import java.io.InputStream;
 import java.util.Collection;
 import java.util.Map;
+import java.util.concurrent.CompletionStage;
 
 /**
  * This is the main interface to building a WS request in Java.
@@ -157,6 +158,11 @@ public interface WSRequest {
      */
     F.Promise<WSResponse> execute();
 
+    /**
+     * Execute this request and stream the response body.
+     */
+    CompletionStage<StreamedResponse> stream(); 
+
     //-------------------------------------------------------------------------
     // Setters
     //-------------------------------------------------------------------------
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/WSResponseHeaders.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSResponseHeaders.java
new file mode 100644
index 0000000000..140c2ab5ce
--- /dev/null
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/WSResponseHeaders.java
@@ -0,0 +1,61 @@
+package play.libs.ws;
+
+import java.util.List;
+import java.util.Map;
+
+public interface WSResponseHeaders {
+    int getStatus();
+
+    Map<String, List<String>> getHeaders();
+}
+
+class DefaultWSResponseHeaders implements WSResponseHeaders {
+
+    private final int status;
+    private final Map<String, List<String>> headers;
+
+    public DefaultWSResponseHeaders(int status, Map<String, List<String>> headers) {
+        this.status = status;
+        this.headers = headers;
+    }
+
+    @Override
+    public int getStatus() {
+        return status;
+    }
+
+    @Override
+    public Map<String, List<String>> getHeaders() {
+        return headers;
+    }
+
+    // hashcode and equals impl were generated with Eclipse
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((headers == null) ? 0 : headers.hashCode());
+        result = prime * result + status;
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        DefaultWSResponseHeaders other = (DefaultWSResponseHeaders) obj;
+        if (headers == null) {
+            if (other.headers != null)
+                return false;
+        } else if (!headers.equals(other.headers))
+            return false;
+        if (status != other.status)
+            return false;
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSClient.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSClient.java
index 0c178e787c..c55003043f 100644
--- a/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSClient.java
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSClient.java
@@ -6,19 +6,26 @@ package play.libs.ws.ning;
 
 import com.ning.http.client.AsyncHttpClient;
 import com.ning.http.client.AsyncHttpClientConfig;
+
 import play.libs.ws.WSClient;
 import play.libs.ws.WSRequest;
 
+/**
+ * A WS client backed by a Ning AsyncHttpClient.
+ *
+ * If you need to debug Ning, set logger.com.ning.http.client=DEBUG in your application.conf file.
+ */
 public class NingWSClient implements WSClient {
 
-    private AsyncHttpClient asyncHttpClient;
+    private final AsyncHttpClient asyncHttpClient;
 
     public NingWSClient(AsyncHttpClientConfig config) {
         this.asyncHttpClient = new AsyncHttpClient(config);
     }
 
+    @Override
     public Object getUnderlying() {
-        return this.asyncHttpClient;
+        return asyncHttpClient;
     }
 
     @Override
@@ -26,7 +33,8 @@ public class NingWSClient implements WSClient {
         return new NingWSRequest(this, url);
     }
 
+    @Override
     public void close() {
-        this.asyncHttpClient.close();
+        asyncHttpClient.close();
     }
 }
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSRequest.java b/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSRequest.java
index e9109a2ac7..f23427fb26 100644
--- a/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSRequest.java
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/ning/NingWSRequest.java
@@ -4,13 +4,17 @@
 
 package play.libs.ws.ning;
 
+import akka.stream.javadsl.*;
+
 import com.fasterxml.jackson.databind.JsonNode;
 import com.ning.http.client.*;
 import com.ning.http.client.generators.FileBodyGenerator;
 import com.ning.http.client.generators.InputStreamBodyGenerator;
 import com.ning.http.client.oauth.OAuthSignatureCalculator;
 import com.ning.http.util.AsyncHttpProviderUtils;
+
 import org.jboss.netty.handler.codec.http.HttpHeaders;
+import play.api.libs.ws.ning.*;
 import play.core.parsers.FormUrlEncodedParser;
 import play.libs.F;
 import play.libs.Json;
@@ -23,6 +27,7 @@ import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.util.*;
+import java.util.concurrent.CompletionStage;
 
 /**
  * provides the User facing API for building WS request.
@@ -395,6 +400,13 @@ public class NingWSRequest implements WSRequest {
         return execute(request);
     }
 
+    @Override
+    public CompletionStage<StreamedResponse> stream() {
+    	AsyncHttpClient asyncClient = (AsyncHttpClient) client.getUnderlying();
+    	Request request = buildRequest();
+    	return StreamedResponse.from(StreamedRequest.execute(asyncClient, request));
+    }
+
     Request buildRequest() {
         RequestBuilder builder = new RequestBuilder(method);
 
@@ -534,6 +546,4 @@ public class NingWSRequest implements WSRequest {
                 .setUsePreemptiveAuth(true)
                 .build();
     }
-
-
 }
diff --git a/framework/src/play-java-ws/src/main/java/play/libs/ws/util/CollectionUtil.scala b/framework/src/play-java-ws/src/main/java/play/libs/ws/util/CollectionUtil.scala
new file mode 100644
index 0000000000..4377f70942
--- /dev/null
+++ b/framework/src/play-java-ws/src/main/java/play/libs/ws/util/CollectionUtil.scala
@@ -0,0 +1,13 @@
+package play.libs.ws.util
+
+import java.{util =>ju}
+import scala.collection.convert.WrapAsJava._
+
+/** Utility class for converting a Scala `Map` with a nested collection type into its idiomatic Java counterpart. 
+ *  The reason why this source is written in Scala is that doing the conversion using Java is a lot more involved. 
+ *  This utility class is used by `play.libs.ws.StreamedResponse`.
+ */
+private[ws] object CollectionUtil {
+  def convert(headers: Map[String, Seq[String]]): ju.Map[String, ju.List[String]] =
+    mapAsJavaMap(headers.map { case (k, v) => k -> seqAsJavaList(v)})
+}
\ No newline at end of file
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
index e2b4d4230a..9f62d63c37 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/WS.scala
@@ -3,6 +3,8 @@
  */
 package play.api.libs.ws
 
+import java.io.Closeable
+
 import java.io.File
 import java.net.URI
 
@@ -15,15 +17,15 @@ import akka.stream.Materializer
 import akka.stream.scaladsl.Sink
 import akka.stream.scaladsl.Source
 import akka.util.ByteString
-
 import play.api.Application
 import play.api.http.Writeable
 import play.api.libs.json.JsValue
+import play.api.libs.iteratee._
 
 /**
  * The WSClient holds the configuration information needed to build a request, and provides a way to get a request holder.
  */
-trait WSClient {
+trait WSClient extends Closeable {
 
   /**
    * The underlying implementation of the client, if any.  You must cast explicitly to the type you want.
@@ -265,6 +267,11 @@ case class FileBody(file: File) extends WSBody
  */
 case object EmptyBody extends WSBody
 
+/**
+ * A streamed response containing a response header and a streamable body.
+ */
+case class StreamedResponse(headers: WSResponseHeaders, body: Source[ByteString, _])
+
 /**
  * A WS Request builder.
  */
@@ -416,19 +423,20 @@ trait WSRequest {
    * performs a get
    * @param consumer that's handling the response
    */
-  @deprecated("2.5.0", "Use `WS.get()` or `WS.getStream()`")
-  def get[A](consumer: WSResponseHeaders => Sink[ByteString, A])(implicit mat: Materializer): Future[A] = {
-    getStream().map {
-      case (response, source) =>
-        source.runWith(consumer(response))
-    }(mat.executionContext)
+  @deprecated("2.5.0", """Use WS.withMethod("GET").stream()""")
+  def get[A](consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
+    getStream().flatMap {
+      case (response, enumerator) =>
+        enumerator(consumer(response))
+    }
   }
 
   /**
    * performs a get
    */
-  def getStream(): Future[(WSResponseHeaders, Source[ByteString, Unit])] = {
-    withMethod("GET").stream()
+  @deprecated("2.5.0", """Use WS.withMethod("GET").stream()""")
+  def getStream(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
+    withMethod("GET").streamWithEnumerator()
   }
 
   /**
@@ -447,12 +455,12 @@ trait WSRequest {
    * performs a POST with supplied body
    * @param consumer that's handling the response
    */
-  @deprecated("2.5.0", "Use `WS.patch(body)`.")
-  def patchAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[ByteString, A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
-    withMethod("PATCH").withBody(body).stream().map {
-      case (response, source) =>
-        source.runWith(consumer(response))
-    }(mat.executionContext)
+  @deprecated("2.5.0", """Use WS.withMethod("PATCH").stream()""")
+  def patchAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
+    withMethod("PATCH").withBody(body).streamWithEnumerator().flatMap {
+      case (response, enumerator) =>
+        enumerator(consumer(response))
+    }
   }
 
   /**
@@ -471,12 +479,12 @@ trait WSRequest {
    * performs a POST with supplied body
    * @param consumer that's handling the response
    */
-  @deprecated("2.5.0", "Use `WS.post(body)`.")
-  def postAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[ByteString, A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
-    withMethod("POST").withBody(body).stream().map {
-      case (response, source) =>
-        source.runWith(consumer(response))
-    }(mat.executionContext)
+  @deprecated("2.5.0", """Use WS.withMethod("POST").stream()""")
+  def postAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
+    withMethod("POST").withBody(body).streamWithEnumerator().flatMap {
+      case (response, enumerator) =>
+        enumerator(consumer(response))
+    }
   }
 
   /**
@@ -495,12 +503,12 @@ trait WSRequest {
    * performs a PUT with supplied body
    * @param consumer that's handling the response
    */
-  @deprecated("2.5.0", "Use `WS.put(body)`.")
-  def putAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Sink[ByteString, A])(implicit wrt: Writeable[T], mat: Materializer): Future[A] = {
-    withMethod("PUT").withBody(body).stream().map {
-      case (response, source) =>
-        source.runWith(consumer(response))
-    }(mat.executionContext)
+  @deprecated("2.5.0", """Use WS.withMethod("PUT").stream()""")
+  def putAndRetrieveStream[A, T](body: T)(consumer: WSResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ec: ExecutionContext): Future[Iteratee[Array[Byte], A]] = {
+    withMethod("PUT").withBody(body).streamWithEnumerator().flatMap {
+      case (response, enumerator) =>
+        enumerator(consumer(response))
+    }
   }
 
   /**
@@ -528,7 +536,15 @@ trait WSRequest {
   /**
    * Execute this request and stream the response body.
    */
-  def stream(): Future[(WSResponseHeaders, Source[ByteString, Unit])]
+  def stream(): Future[StreamedResponse]
+
+  /**
+   * Execute this request and stream the response body.
+   * @note This method used to be named `stream`, but it was renamed because the method's signature was
+   *       changed and the JVM doesn't allow overloading on the return type.
+   */
+  @deprecated("2.5.0", "Use `WS.stream()` instead.")
+  def streamWithEnumerator(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])]
 }
 
 /**
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
index bc6e0b62d4..2455e9cc70 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
@@ -3,31 +3,35 @@
  */
 package play.api.libs.ws.ning
 
-import java.io.UnsupportedEncodingException
-import java.nio.charset.{ Charset, StandardCharsets }
-import javax.inject.{ Inject, Provider, Singleton }
+import akka.stream.scaladsl.Source
+import akka.util.ByteString
+
 import com.ning.http.client.{ Response => AHCResponse, ProxyServer => AHCProxyServer, _ }
-import com.ning.http.client.cookie.{ Cookie => AHCCookie }
 import com.ning.http.client.Realm.{ RealmBuilder, AuthScheme }
+import com.ning.http.client.cookie.{ Cookie => AHCCookie }
 import com.ning.http.util.AsyncHttpProviderUtils
+
+import java.io.IOException
+import java.io.UnsupportedEncodingException
+import java.nio.charset.{ Charset, StandardCharsets }
+
+import javax.inject.{ Inject, Provider, Singleton }
+
 import org.jboss.netty.handler.codec.http.HttpHeaders
+
+import play.api._
 import play.api.inject.{ ApplicationLifecycle, Module }
-import play.core.parsers.FormUrlEncodedParser
-import collection.immutable.TreeMap
-import scala.concurrent.{ Future, Promise }
-import scala.concurrent.duration.Duration
+import play.api.libs.iteratee.Enumerator
 import play.api.libs.ws._
 import play.api.libs.ws.ssl._
-import play.api.libs.iteratee._
-import play.api._
-import play.core.utils.CaseInsensitiveOrdered
-import play.api.libs.ws.DefaultWSResponseHeaders
-import play.api.libs.iteratee.Input.El
 import play.api.libs.ws.ssl.debug._
+import play.core.parsers.FormUrlEncodedParser
+import play.core.utils.CaseInsensitiveOrdered
+
 import scala.collection.JavaConverters._
-import akka.stream.scaladsl.Source
-import java.io.IOException
-import akka.util.ByteString
+import scala.collection.immutable.TreeMap
+import scala.concurrent.{ Future, Promise }
+import scala.concurrent.duration.Duration
 
 /**
  * A WS client backed by a Ning AsyncHttpClient.
@@ -40,11 +44,11 @@ case class NingWSClient(config: AsyncHttpClientConfig) extends WSClient {
 
   private val asyncHttpClient = new AsyncHttpClient(config)
 
-  def underlying[T] = asyncHttpClient.asInstanceOf[T]
+  def underlying[T]: T = asyncHttpClient.asInstanceOf[T]
 
   private[libs] def executeRequest[T](request: Request, handler: AsyncHandler[T]): ListenableFuture[T] = asyncHttpClient.executeRequest(request, handler)
 
-  def close() = asyncHttpClient.close()
+  def close(): Unit = asyncHttpClient.close()
 
   def url(url: String): WSRequest = NingWSRequest(this, url, "GET", EmptyBody, Map(), Map(), None, None, None, None, None, None, None)
 }
@@ -73,6 +77,14 @@ object NingWSClient {
   }
 }
 
+case object NingWSRequest {
+  private[libs] def ningHeadersToMap(headers: FluentCaseInsensitiveStringsMap): TreeMap[String, Seq[String]] = {
+    val res = mapAsScalaMapConverter(headers).asScala.map(e => e._1 -> e._2.asScala.toSeq).toMap
+    //todo: wrap the case insensitive ning map instead of creating a new one (unless perhaps immutabilty is important)
+    TreeMap(res.toSeq: _*)(CaseInsensitiveOrdered)
+  }
+}
+
 /**
  * A Ning WS Request.
  */
@@ -132,13 +144,16 @@ case class NingWSRequest(client: NingWSClient,
 
   def execute(): Future[WSResponse] = execute(buildRequest())
 
-  def stream(): Future[(WSResponseHeaders, Source[ByteString, Unit])] = executeStream(buildRequest())
+  def stream(): Future[StreamedResponse] = StreamedRequest.execute(client.underlying, buildRequest())
+
+  def streamWithEnumerator(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] =
+    StreamedRequest.executeAndReturnEnumerator(client.underlying, buildRequest())
 
   /**
    * Returns the current headers of the request, using the request builder.  This may be signed,
    * so may return extra headers that were not directly input.
    */
-  def requestHeaders: Map[String, Seq[String]] = ningHeadersToMap(buildRequest().getHeaders)
+  def requestHeaders: Map[String, Seq[String]] = NingWSRequest.ningHeadersToMap(buildRequest().getHeaders)
 
   /**
    * Returns the HTTP header given by name, using the request builder.  This may be signed,
@@ -193,12 +208,6 @@ case class NingWSRequest(client: NingWSClient,
       .build()
   }
 
-  private[libs] def ningHeadersToMap(headers: FluentCaseInsensitiveStringsMap) = {
-    val res = mapAsScalaMapConverter(headers).asScala.map(e => e._1 -> e._2.asScala.toSeq).toMap
-    //todo: wrap the case insensitive ning map instead of creating a new one (unless perhaps immutabilty is important)
-    TreeMap(res.toSeq: _*)(CaseInsensitiveOrdered)
-  }
-
   def contentType: Option[String] = {
     this.headers.find(p => p._1 == HttpHeaders.Names.CONTENT_TYPE).map {
       case (header, values) =>
@@ -320,115 +329,6 @@ case class NingWSRequest(client: NingWSClient,
     result.future
   }
 
-  private[libs] def executeStream(request: Request): Future[(WSResponseHeaders, Source[ByteString, Unit])] = {
-
-    import com.ning.http.client.AsyncHandler
-
-    val result = Promise[(WSResponseHeaders, Enumerator[ByteString])]()
-
-    val errorInStream = Promise[Unit]()
-
-    val promisedIteratee = Promise[Iteratee[ByteString, Unit]]()
-
-    @volatile var doneOrError = false
-    @volatile var statusCode = 0
-    @volatile var current: Iteratee[ByteString, Unit] = Iteratee.flatten(promisedIteratee.future)
-
-    client.executeRequest(request, new AsyncHandler[Unit]() {
-
-      import com.ning.http.client.AsyncHandler.STATE
-
-      @throws(classOf[Exception])
-      override def onStatusReceived(status: HttpResponseStatus): STATE = {
-        statusCode = status.getStatusCode
-        STATE.CONTINUE
-      }
-
-      @throws(classOf[Exception])
-      override def onHeadersReceived(h: HttpResponseHeaders): STATE = {
-        val headers = h.getHeaders
-
-        val responseHeader = DefaultWSResponseHeaders(statusCode, ningHeadersToMap(headers))
-        val enumerator = new Enumerator[ByteString]() {
-          def apply[A](i: Iteratee[ByteString, A]) = {
-
-            val doneIteratee = Promise[Iteratee[ByteString, A]]()
-
-            import play.api.libs.iteratee.Execution.Implicits.trampoline
-
-            // Map it so that we can complete the iteratee when it returns
-            val mapped = i.map {
-              a =>
-                doneIteratee.trySuccess(Done(a))
-                ()
-            }.recover {
-              // but if an error happens, we want to propogate that
-              case e =>
-                doneIteratee.tryFailure(e)
-                throw e
-            }
-
-            // Redeem the iteratee that we promised to the AsyncHandler
-            promisedIteratee.trySuccess(mapped)
-
-            // If there's an error in the stream from upstream, then fail this returned future with that
-            errorInStream.future.onFailure {
-              case e => doneIteratee.tryFailure(e)
-            }
-
-            doneIteratee.future
-          }
-        }
-
-        result.trySuccess((responseHeader, enumerator))
-        STATE.CONTINUE
-      }
-
-      @throws(classOf[Exception])
-      override def onBodyPartReceived(bodyPart: HttpResponseBodyPart): STATE = {
-        if (!doneOrError) {
-          import play.api.libs.concurrent.Execution.Implicits.defaultContext
-          current = current.pureFlatFold {
-            case Step.Done(a, e) =>
-              doneOrError = true
-              Done(a, e)
-
-            case Step.Cont(k) =>
-              k(El(ByteString(bodyPart.getBodyPartBytes)))
-
-            case Step.Error(e, input) =>
-              doneOrError = true
-              Error(e, input)
-
-          }
-          STATE.CONTINUE
-        } else {
-          current = null
-          // Must close underlying connection, otherwise async http client will drain the stream
-          bodyPart.markUnderlyingConnectionAsToBeClosed()
-          STATE.ABORT
-        }
-      }
-
-      @throws(classOf[Exception])
-      override def onCompleted(): Unit = {
-        Option(current).foreach(_.run)
-      }
-
-      override def onThrowable(t: Throwable): Unit = {
-        result.tryFailure(t)
-        errorInStream.tryFailure(t)
-      }
-    })
-    import play.core.Execution.Implicits.internalContext
-    result.future.map {
-      case (response, enumerator) =>
-        import play.api.libs.streams.Streams
-        val publisher = Streams.enumeratorToPublisher(enumerator)
-        (response, Source(publisher))
-    }
-  }
-
   private[libs] def createProxy(wsProxyServer: WSProxyServer): AHCProxyServer = {
 
     import com.ning.http.client.ProxyServer.Protocol
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala
new file mode 100644
index 0000000000..3c07bf4cf2
--- /dev/null
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala
@@ -0,0 +1,140 @@
+package play.api.libs.ws.ning
+
+import scala.concurrent.Future
+import scala.concurrent.Promise
+
+import com.ning.http.client.AsyncHandler
+import com.ning.http.client.AsyncHandler.STATE
+import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.HttpResponseBodyPart
+import com.ning.http.client.HttpResponseHeaders
+import com.ning.http.client.HttpResponseStatus
+import com.ning.http.client.Request
+
+import akka.stream.scaladsl.Source
+import akka.util.ByteString
+import play.api.libs.iteratee.Done
+import play.api.libs.iteratee.Enumerator
+import play.api.libs.iteratee.Error
+import play.api.libs.iteratee.Input.El
+import play.api.libs.iteratee.Iteratee
+import play.api.libs.iteratee.Step
+import play.api.libs.streams.Streams
+import play.api.libs.ws.DefaultWSResponseHeaders
+import play.api.libs.ws.WSResponseHeaders
+import play.api.libs.ws.StreamedResponse
+
+private[play] object StreamedRequest {
+
+  def execute(client: AsyncHttpClient, request: Request): Future[StreamedResponse] = {
+    val result = executeAndReturnEnumerator(client, request)
+    import play.core.Execution.Implicits.internalContext
+    result.map {
+      case (response, enumerator) =>
+        val publisher = Streams.enumeratorToPublisher(enumerator)
+        StreamedResponse(response, Source(publisher).map(ByteString(_)))
+    }
+  }
+
+  def executeAndReturnEnumerator(client: AsyncHttpClient, request: Request): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
+    import com.ning.http.client.AsyncHandler
+
+    val result = Promise[(WSResponseHeaders, Enumerator[Array[Byte]])]()
+
+    val errorInStream = Promise[Unit]()
+
+    val promisedIteratee = Promise[Iteratee[Array[Byte], Unit]]()
+
+    @volatile var doneOrError = false
+    @volatile var statusCode = 0
+    @volatile var current: Iteratee[Array[Byte], Unit] = Iteratee.flatten(promisedIteratee.future)
+
+    client.executeRequest(request, new AsyncHandler[Unit]() {
+
+      import com.ning.http.client.AsyncHandler.STATE
+
+      @throws(classOf[Exception])
+      override def onStatusReceived(status: HttpResponseStatus): STATE = {
+        statusCode = status.getStatusCode
+        STATE.CONTINUE
+      }
+
+      @throws(classOf[Exception])
+      override def onHeadersReceived(h: HttpResponseHeaders): STATE = {
+        val headers = h.getHeaders
+
+        val responseHeader = DefaultWSResponseHeaders(statusCode, NingWSRequest.ningHeadersToMap(headers))
+        val enumerator = new Enumerator[Array[Byte]]() {
+          def apply[A](i: Iteratee[Array[Byte], A]) = {
+
+            val doneIteratee = Promise[Iteratee[Array[Byte], A]]()
+
+            import play.api.libs.iteratee.Execution.Implicits.trampoline
+
+            // Map it so that we can complete the iteratee when it returns
+            val mapped = i.map {
+              a =>
+                doneIteratee.trySuccess(Done(a))
+                ()
+            }.recover {
+              // but if an error happens, we want to propogate that
+              case e =>
+                doneIteratee.tryFailure(e)
+                throw e
+            }
+
+            // Redeem the iteratee that we promised to the AsyncHandler
+            promisedIteratee.trySuccess(mapped)
+
+            // If there's an error in the stream from upstream, then fail this returned future with that
+            errorInStream.future.onFailure {
+              case e => doneIteratee.tryFailure(e)
+            }
+
+            doneIteratee.future
+          }
+        }
+
+        result.trySuccess((responseHeader, enumerator))
+        STATE.CONTINUE
+      }
+
+      @throws(classOf[Exception])
+      override def onBodyPartReceived(bodyPart: HttpResponseBodyPart): STATE = {
+        if (!doneOrError) {
+          import play.api.libs.concurrent.Execution.Implicits.defaultContext
+          current = current.pureFlatFold {
+            case Step.Done(a, e) =>
+              doneOrError = true
+              Done(a, e)
+
+            case Step.Cont(k) =>
+              k(El(bodyPart.getBodyPartBytes))
+
+            case Step.Error(e, input) =>
+              doneOrError = true
+              Error(e, input)
+
+          }
+          STATE.CONTINUE
+        } else {
+          current = null
+          // Must close underlying connection, otherwise async http client will drain the stream
+          bodyPart.markUnderlyingConnectionAsToBeClosed()
+          STATE.ABORT
+        }
+      }
+
+      @throws(classOf[Exception])
+      override def onCompleted(): Unit = {
+        Option(current).foreach(_.run)
+      }
+
+      override def onThrowable(t: Throwable): Unit = {
+        result.tryFailure(t)
+        errorInStream.tryFailure(t)
+      }
+    })
+    result.future
+  }
+}
\ No newline at end of file
