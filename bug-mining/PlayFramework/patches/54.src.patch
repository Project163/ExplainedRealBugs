diff --git a/framework/src/play-integration-test/src/test/java/play/it/JavaServerIntegrationTest.java b/framework/src/play-integration-test/src/test/java/play/it/JavaServerIntegrationTest.java
new file mode 100644
index 0000000000..c6fd0325e1
--- /dev/null
+++ b/framework/src/play-integration-test/src/test/java/play/it/JavaServerIntegrationTest.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
+ */
+package play.it;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import play.Mode;
+import play.api.routing.Router;
+import play.test.Helpers;
+import play.server.Server;
+import play.server.Server.PortConfig;
+
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.ServerSocket;
+import java.net.Socket;
+
+public class JavaServerIntegrationTest {
+    @Test
+    public void testHttpEmbeddedServerUsesCorrectProtocolAndPort() throws Exception {
+        int port = _availablePort();
+        _running(Server.forRouter(_emptyRouter(), port), server -> {
+            assertTrue(_isPortOccupied(port));
+            assertFalse(_isServingSSL(port));
+            assertEquals(server.httpPort(), port);
+            try {
+                server.httpsPort();
+                fail("Exception should be thrown on accessing https port of server started in http mode");
+            } catch (IllegalStateException e) {}
+        });
+        assertFalse(_isPortOccupied(port));
+    }
+
+    @Test
+    public void testHttpsEmbeddedServerUsesCorrectProtocolAndPort() throws Exception {
+        int port = _availablePort();
+        _running(Server.forRouter(_emptyRouter(), Mode.DEV, PortConfig.https(port)), server -> {
+            assertEquals(server.httpsPort(), port);
+            assertTrue(_isServingSSL(port));
+
+            try {
+                server.httpPort();
+                fail("Exception should be thrown ona ccessing http port of server started in https mode");
+            } catch (IllegalStateException e) {}
+        });
+        assertFalse(_isPortOccupied(port));
+    }
+
+    private void _running(Server server, ServerRunnable runnable) throws Exception {
+        try {
+            runnable.run(server);
+        } finally {
+            server.stop();
+        }
+    }
+
+    private interface ServerRunnable {
+        void run(Server server) throws Exception;
+    }
+
+    private int _availablePort() throws IOException {
+        ServerSocket socket = new ServerSocket(0);
+        int port = socket.getLocalPort();
+        socket.close();
+
+        return port;
+    }
+
+    private boolean _isServingSSL(int port) throws IOException {
+        // Inspired by @4ndrej's SSLPoke https://gist.github.com/4ndrej/4547029
+        try {
+            SSLSocket sslsocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket("127.0.0.1", port);
+            InputStream in = sslsocket.getInputStream();
+            OutputStream out = sslsocket.getOutputStream();
+
+            // Write a test byte to get a reaction :)
+            out.write(1);
+
+            while (in.available() > 0) {
+                in.read();
+            }
+
+            in.close();
+            out.close();
+
+            return true;
+        } catch (SSLHandshakeException e) {
+            // If it started handshaking then the port was definitely serving ssl
+            return true;
+        } catch (SSLException e) {
+            // Any other ssl exception probably means it wasn't serving SSL
+            return false;
+        }
+    }
+
+    private Router _emptyRouter() {
+        return Helpers.fakeApplication().getWrappedApplication().routes();
+    }
+
+    private boolean _isPortOccupied(int port) {
+        try {
+            Socket s = new Socket("127.0.0.1", port);
+            s.close();
+
+            return true;
+        } catch (IOException e) {
+            return false;
+        }
+    }
+
+}
diff --git a/framework/src/play-server/src/main/java/play/server/Server.java b/framework/src/play-server/src/main/java/play/server/Server.java
index 9b36d06861..4b96dcde07 100644
--- a/framework/src/play-server/src/main/java/play/server/Server.java
+++ b/framework/src/play-server/src/main/java/play/server/Server.java
@@ -7,6 +7,8 @@ import play.Mode;
 import play.api.routing.Router;
 import play.core.j.JavaModeConverter;
 import play.core.server.JavaServerHelper;
+import scala.Int;
+import scala.Option;
 
 import java.net.InetSocketAddress;
 
@@ -29,10 +31,29 @@ public class Server {
     }
 
     /**
-     * Get the port the server is running on.
+     * Get the HTTP port the server is running on.
+     *
+     * throws IllegalStateException if it is not running on the HTTP protocol
      */
     public int httpPort() {
-        return server.mainAddress().getPort();
+        if (server.httpPort().isDefined()) {
+            return Int.unbox(server.httpPort().get());
+        } else {
+            throw new IllegalStateException("Server has no HTTP port. Try starting it with \"PortConfig.http(<port num>)\"?");
+        }
+    }
+
+    /**
+     * Get the HTTPS port the server is running on.
+     *
+     * throws IllegalStateException if it is not running on the HTTPS protocol.
+     */
+    public int httpsPort() {
+        if (server.httpsPort().isDefined()) {
+            return Int.unbox(server.httpsPort().get());
+        } else {
+            throw new IllegalStateException("Server has no HTTPS port. Try starting it with \"PortConfig.https(<port num>)\"?");
+        }
     }
 
     /**
@@ -93,7 +114,76 @@ public class Server {
      * @return The running server.
      */
     public static Server forRouter(Router router, Mode mode, int port) {
-        return new Server(JavaServerHelper.forRouter(router, JavaModeConverter.asScalaMode(mode), port));
+        return forRouter(router, mode, PortConfig.http(port));
+    }
+
+    /**
+     * Create a server for the given router
+     * <p>
+     * The server will open to either HTTP or HTTPS traffic, depending on whether PortConfig.http(port) or
+     * PortConfig.https(port) is used.
+     *
+     * @param router The router for the server to serve
+     * @param mode The mode the server will run on
+     * @param portConfig The port and protocol the server will run on e.g. PortConfig.http(80), PortConfig.https(443)
+     * @return The running server
+     */
+    public static Server forRouter(Router router, Mode mode, PortConfig portConfig) {
+        return new Server(
+                JavaServerHelper.forRouter(
+                        router,
+                        JavaModeConverter.asScalaMode(mode),
+                        portConfig.maybeHttpPort(),
+                        portConfig.maybeSslPort()
+                )
+        );
     }
 
+    /**
+     * Specifies the protocols supported by the server.
+     * A choice of HTTPS will force the server to serve only SSL traffic
+     **/
+    private enum Protocol {
+        HTTP,
+        HTTPS
+    }
+
+    /**
+     * Helper class that specifies protocol/port pairs for the server to expose.
+     */
+    public static class PortConfig {
+        private final Server.Protocol protocol;
+        private final int port;
+
+        /**
+         * Create a PortConfig in HTTPS mode
+         * @param port the port on which to serve ssl traffic
+         * @return the PortConfig
+         */
+        public static PortConfig https(int port) {
+            return new PortConfig(Server.Protocol.HTTPS, port);
+        }
+
+        /**
+         * Create a PortConfig in HTTP mode
+         * @param port the port on which to serve http traffic
+         * @return the PortConfig
+         */
+        public static PortConfig http(int port) {
+            return new PortConfig(Server.Protocol.HTTP, port);
+        }
+
+        private PortConfig(Server.Protocol protocol, int port) {
+            this.protocol = protocol;
+            this.port = port;
+        }
+
+        private Option<Integer> maybeHttpPort() {
+            return protocol == Protocol.HTTP? Option.apply(port): Option.empty();
+        }
+
+        private Option<Integer> maybeSslPort() {
+            return protocol == Protocol.HTTPS? Option.apply(port): Option.empty();
+        }
+    }
 }
diff --git a/framework/src/play-server/src/main/scala/play/core/server/Server.scala b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
index 6a750c6404..b0b1a50937 100644
--- a/framework/src/play-server/src/main/scala/play/core/server/Server.scala
+++ b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
@@ -143,7 +143,7 @@ object Server {
 }
 
 private[play] object JavaServerHelper {
-  def forRouter(router: Router, mode: Mode.Mode, port: Int): Server = {
+  def forRouter(router: Router, mode: Mode.Mode, httpPort: Option[Integer], sslPort: Option[Integer]): Server = {
     val r = router
     val application = new BuiltInComponentsFromContext(ApplicationLoader.Context(
       Environment.simple(mode = mode),
@@ -152,6 +152,7 @@ private[play] object JavaServerHelper {
       def router = r
     }.application
     Play.start(application)
-    implicitly[ServerProvider].createServer(ServerConfig(mode = mode, port = Some(port)), application)
+    val serverConfig = ServerConfig(mode = mode, port = httpPort.map(_.intValue), sslPort = sslPort.map(_.intValue))
+    implicitly[ServerProvider].createServer(serverConfig, application)
   }
-}
\ No newline at end of file
+}
