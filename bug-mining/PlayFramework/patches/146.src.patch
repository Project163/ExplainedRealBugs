diff --git a/framework/project/BuildSettings.scala b/framework/project/BuildSettings.scala
index 18ce77ce1b..a0f70eb3ea 100644
--- a/framework/project/BuildSettings.scala
+++ b/framework/project/BuildSettings.scala
@@ -555,7 +555,14 @@ object BuildSettings {
 
       // Add configuration to set max header value length
       ProblemFilters.exclude[ReversedMissingMethodProblem]("play.api.http.Status.REQUEST_HEADER_FIELDS_TOO_LARGE"),
-      ProblemFilters.exclude[ReversedMissingMethodProblem]("play.api.http.Status.play$api$http$Status$_setter_$REQUEST_HEADER_FIELDS_TOO_LARGE_=")
+      ProblemFilters.exclude[ReversedMissingMethodProblem]("play.api.http.Status.play$api$http$Status$_setter_$REQUEST_HEADER_FIELDS_TOO_LARGE_="),
+
+      // https://github.com/playframework/playframework/issues/8534
+      // Removed StopHook from ActorSystemProvider.start methods return values
+      ProblemFilters.exclude[IncompatibleResultTypeProblem]("play.api.libs.concurrent.ActorSystemProvider.start"),
+      // Removed private[play] class CloseableLazy
+      ProblemFilters.exclude[MissingClassProblem]("play.core.ClosableLazy"),
+      ProblemFilters.exclude[DirectMissingMethodProblem]("play.api.libs.concurrent.ActorSystemProvider.lazyStart")
   ),
     unmanagedSourceDirectories in Compile += {
       (sourceDirectory in Compile).value / s"scala-${scalaBinaryVersion.value}"
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/server/ServerReloadingSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/server/ServerReloadingSpec.scala
index 1f24e13b41..66f807a647 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/server/ServerReloadingSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/server/ServerReloadingSpec.scala
@@ -37,7 +37,7 @@ trait ServerReloadingSpec extends PlaySpecification with WsTestClient with Serve
   def withApplicationProvider[A](ap: ApplicationProvider)(block: Port => A): A = {
     val classLoader = Thread.currentThread.getContextClassLoader
     val configuration = Configuration.load(classLoader, System.getProperties, Map.empty, allowMissingApplicationConf = true)
-    val (actorSystem, stopActorSystem) = ActorSystemProvider.start(classLoader, configuration)
+    val actorSystem = ActorSystemProvider.start(classLoader, configuration)
     val materializer = ActorMaterializer()(actorSystem)
 
     val server = integrationServerProvider.createServer(ServerProvider.Context(
@@ -47,7 +47,6 @@ trait ServerReloadingSpec extends PlaySpecification with WsTestClient with Serve
 
     try block(port) finally {
       server.stop()
-      stopActorSystem()
     }
   }
 
@@ -245,4 +244,4 @@ private[server] object ServerReloadingSpec {
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala b/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
index 06b12e1089..b75f9f140c 100644
--- a/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
+++ b/framework/src/play/src/main/scala/play/api/libs/concurrent/Akka.scala
@@ -15,7 +15,6 @@ import javax.inject.{ Inject, Provider, Singleton }
 import org.slf4j.LoggerFactory
 import play.api._
 import play.api.inject._
-import play.core.ClosableLazy
 
 import scala.concurrent._
 import scala.concurrent.duration.Duration
@@ -102,7 +101,7 @@ trait AkkaComponents {
 @Singleton
 class ActorSystemProvider @Inject() (environment: Environment, configuration: Configuration) extends Provider[ActorSystem] {
 
-  lazy val get: ActorSystem = ActorSystemProvider.start(environment.classLoader, configuration)._1
+  lazy val get: ActorSystem = ActorSystemProvider.start(environment.classLoader, configuration)
 
 }
 
@@ -135,7 +134,7 @@ object ActorSystemProvider {
    *
    * @return The ActorSystem and a function that can be used to stop it.
    */
-  def start(classLoader: ClassLoader, config: Configuration): (ActorSystem, StopHook) = {
+  def start(classLoader: ClassLoader, config: Configuration): ActorSystem = {
     start(classLoader, config, additionalSetup = None)
   }
 
@@ -144,11 +143,11 @@ object ActorSystemProvider {
    *
    * @return The ActorSystem and a function that can be used to stop it.
    */
-  def start(classLoader: ClassLoader, config: Configuration, additionalSetup: Setup): (ActorSystem, StopHook) = {
+  def start(classLoader: ClassLoader, config: Configuration, additionalSetup: Setup): ActorSystem = {
     start(classLoader, config, Some(additionalSetup))
   }
 
-  private def start(classLoader: ClassLoader, config: Configuration, additionalSetup: Option[Setup]): (ActorSystem, StopHook) = {
+  private def start(classLoader: ClassLoader, config: Configuration, additionalSetup: Option[Setup]): ActorSystem = {
     val akkaConfig: Config = {
       val akkaConfigRoot = config.get[String]("play.akka.config")
 
@@ -187,23 +186,7 @@ object ActorSystemProvider {
     val system = ActorSystem(name, actorSystemSetup)
     logger.debug(s"Starting application default Akka system: $name")
 
-    // noop. This is no longer necessary since we've reversed the dependency between
-    // ActorSystem and ApplicationLifecycle.
-    val stopHook = { () => Future.successful(Done) }
-
-    (system, stopHook)
-  }
-
-  /**
-   * A lazy wrapper around `start`. Useful when the `ActorSystem` may
-   * not be needed.
-   */
-  def lazyStart(classLoader: => ClassLoader, configuration: => Configuration): ClosableLazy[ActorSystem, Future[_]] = {
-    new ClosableLazy[ActorSystem, Future[_]] {
-      protected def create() = start(classLoader, configuration)
-
-      protected def closeNotNeeded = Future.successful(())
-    }
+    system
   }
 
 }
diff --git a/framework/src/play/src/main/scala/play/core/system/ClosableLazy.scala b/framework/src/play/src/main/scala/play/core/system/ClosableLazy.scala
deleted file mode 100644
index c06eca0bf6..0000000000
--- a/framework/src/play/src/main/scala/play/core/system/ClosableLazy.scala
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2009-2018 Lightbend Inc. <https://www.lightbend.com>
- */
-
-package play.core
-
-/**
- * Provides functionality like Scala's builtin lazy values, except allows cleanup of
- * the lazily initialized value. The value is lazily initialized when the `get()` method
- * is first called. Later, if the value is no longer needed, it can be cleaned up by
- * calling the `close()` method.
- *
- * Calling `close()` on an uninitialized ClosableLazy will not initialize the value
- * if it is not initialized. A ClosableLazy can be closed multiple times.
- *
- * After being closed, the value cannot be initialized again. ClosableLazy is designed
- * to make it easier to clean up resources when shutting down Play. If resources were able
- * to be reinitialized after closing, then it would be easy to accidentally allocate resources
- * when shutting down. To prevent reinitialization, galling the `get()` method after `close()`
- * will result in an `IllegalStateException`.
- *
- * The performance of this class should be similar to Scala's lazy values. Once initialized,
- * a single read of a volatile value is all that is needed to get the value. If the value is not initialized,
- * then initialization occurs, Initialization is synchronized on the ClosableLazy object.
- *
- * This class exposes `T` as the type of value that is lazily created. Subclasses
- * should implement the `create()` method to create this value. The `create()` method
- * also returns a function that will be called when `close()` is called. This allows
- * any resources associated with the value to be closed.
- */
-private[play] abstract class ClosableLazy[T >: Null <: AnyRef, C] {
-
-  protected type CloseFunction = (() => C)
-
-  @volatile
-  private var value: T = null
-  private var closeFunction: CloseFunction = null
-  private var hasBeenClosed: Boolean = false
-
-  /**
-   * Get the value. Calling this method may allocate resources, such as a thread pool.
-   *
-   * Calling this method after the `close()` method has been called will result in an
-   * IllegalStateException.
-   */
-  final def get(): T = {
-    val currentValue = value
-    if (currentValue != null) return currentValue
-    synchronized {
-      if (hasBeenClosed) throw new IllegalStateException("Can't get ClosableLazy value after it has been closed")
-      if (value == null) {
-        val (v, cf): (T, CloseFunction) = create()
-        if (v == null) throw new IllegalStateException("Can't initialize ClosableLazy to a null value")
-        if (cf == null) throw new IllegalStateException("Can't initialize ClosableLazy's close function to a null value")
-        value = v
-        closeFunction = cf
-        v
-      } else {
-        // Value was initialized by another thread before we got the monitor
-        value
-      }
-    }
-  }
-
-  /**
-   * Close the value. Calling this method is safe, but does nothing, if the value
-   * has not been initialized.
-   */
-  final def close(): C = {
-    val optionalClose: Option[CloseFunction] = synchronized {
-      if (hasBeenClosed) {
-        // Already closed
-        None
-      } else if (value == null) {
-        // Close before first call to get
-        hasBeenClosed = true
-        None
-      } else {
-        // Close and call the close function
-        hasBeenClosed = true
-        val prevCloseFunction = closeFunction
-        value = null
-        closeFunction = null
-        Some(prevCloseFunction)
-      }
-    }
-    // Perform actual close outside the synchronized block,
-    // just in case the close function calls get or close
-    // from another thread.
-    optionalClose.fold(closeNotNeeded)(_.apply())
-  }
-
-  /**
-   * Called when the lazy value is first initialized. Returns the value and
-   * a function to close the value when `close` is called.
-   */
-  protected def create(): (T, CloseFunction)
-
-  /**
-   * Called when `close` is called but no closing actually needs to
-   * happen. Used to return a valid value of `C` when this happens.
-   * In common usage this method will return `()` or `Future.successful(())`.
-   */
-  protected def closeNotNeeded: C
-}
diff --git a/framework/src/play/src/test/scala/play/api/PlayCoreTestApplication.scala b/framework/src/play/src/test/scala/play/api/PlayCoreTestApplication.scala
index fd108d668c..deb7f1c843 100644
--- a/framework/src/play/src/test/scala/play/api/PlayCoreTestApplication.scala
+++ b/framework/src/play/src/test/scala/play/api/PlayCoreTestApplication.scala
@@ -28,8 +28,7 @@ private[play] case class PlayCoreTestApplication(
 
   val classloader = Thread.currentThread.getContextClassLoader
   lazy val configuration = Configuration.from(config)
-  private val lazyActorSystem = ActorSystemProvider.lazyStart(classloader, configuration)
-  def actorSystem = lazyActorSystem.get()
+  lazy val actorSystem = ActorSystemProvider.start(classloader, configuration)
   lazy val materializer = ActorMaterializer()(actorSystem)
   lazy val coordinatedShutdown = CoordinatedShutdown(actorSystem)
   lazy val requestFactory = new DefaultRequestFactory(httpConfiguration)
@@ -44,8 +43,5 @@ private[play] case class PlayCoreTestApplication(
       .map(_ =>
         _terminated = true
       )
-      .flatMap(_ =>
-        lazyActorSystem.close()
-      )
   }
 }
diff --git a/framework/src/play/src/test/scala/play/api/libs/concurrent/ActorSystemProviderSpec.scala b/framework/src/play/src/test/scala/play/api/libs/concurrent/ActorSystemProviderSpec.scala
index 830037d434..f01d2bc438 100644
--- a/framework/src/play/src/test/scala/play/api/libs/concurrent/ActorSystemProviderSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/libs/concurrent/ActorSystemProviderSpec.scala
@@ -14,7 +14,7 @@ import org.specs2.mutable.Specification
 import play.api.inject.{ ApplicationLifecycle, DefaultApplicationLifecycle }
 import play.api.{ Configuration, Environment }
 
-import scala.concurrent.Future
+import scala.concurrent.{ Await, Future }
 import scala.concurrent.duration.Duration
 
 class ActorSystemProviderSpec extends Specification {
@@ -83,7 +83,7 @@ class ActorSystemProviderSpec extends Specification {
       val PhaseCustomDefinedPhase = "custom-defined-phase"
       val phaseCustomDefinedPhaseExecuted = new AtomicBoolean(false)
 
-      val (actorSystem, _) = ActorSystemProvider.start(
+      val actorSystem = ActorSystemProvider.start(
         this.getClass.getClassLoader,
         Configuration(config)
       )
@@ -115,14 +115,14 @@ class ActorSystemProviderSpec extends Specification {
       .underlying
       .withoutPath(playTimeoutKey)
     )
-    val (actorSystem, stopHook) = ActorSystemProvider.start(
+    val actorSystem = ActorSystemProvider.start(
       this.getClass.getClassLoader,
       Configuration(config)
     )
     try {
       block(actorSystem)
     } finally {
-      stopHook()
+      Await.ready(CoordinatedShutdown(actorSystem).run(CoordinatedShutdown.UnknownReason), fiveSec)
     }
   }
 
diff --git a/framework/src/play/src/test/scala/play/core/ClosableLazySpec.scala b/framework/src/play/src/test/scala/play/core/ClosableLazySpec.scala
deleted file mode 100644
index 861ff51891..0000000000
--- a/framework/src/play/src/test/scala/play/core/ClosableLazySpec.scala
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2009-2018 Lightbend Inc. <https://www.lightbend.com>
- */
-
-package play.core
-
-import java.util.concurrent.atomic.AtomicInteger
-import org.specs2.mutable.Specification
-import scala.concurrent.{ Await, Future, Promise }
-import scala.concurrent.duration._
-
-import scala.concurrent.ExecutionContext.Implicits.global
-
-class ClosableLazySpec extends Specification {
-
-  "ClosableLazy" should {
-
-    "create a value when first accessed" in {
-      val createCount = new AtomicInteger()
-      val cl = new ClosableLazy[String, Int] {
-        protected def create() = {
-          createCount.incrementAndGet()
-          ("hello", () => 1)
-        }
-        protected def closeNotNeeded = -1
-      }
-      createCount.get must_== 0
-      cl.get must_== "hello"
-      createCount.get must_== 1
-      cl.get must_== "hello"
-      createCount.get must_== 1
-      cl.close() must_== 1
-      createCount.get must_== 1
-    }
-
-    "call the close function when first closed" in {
-      val closeCount = new AtomicInteger()
-
-      val cl = new ClosableLazy[String, Int] {
-        protected def create() = {
-          ("hat", () => closeCount.incrementAndGet())
-        }
-        protected def closeNotNeeded = -1
-      }
-      closeCount.get must_== 0
-      cl.get must_== "hat"
-      closeCount.get must_== 0
-      cl.get must_== "hat"
-      closeCount.get must_== 0
-      cl.close() must_== 1
-      closeCount.get must_== 1
-      cl.close() must_== -1
-      closeCount.get must_== 1
-
-    }
-
-    "be closable before the first call to get" in {
-      val closeCount = new AtomicInteger()
-
-      val cl = new ClosableLazy[String, Int] {
-        protected def create() = {
-          ("sock", () => closeCount.incrementAndGet())
-        }
-        protected def closeNotNeeded = -1
-      }
-      closeCount.get must_== 0
-      cl.close() must_== -1
-      closeCount.get must_== 0
-      cl.get must throwAn[IllegalStateException]
-      closeCount.get must_== 0
-      cl.close() must_== -1
-      closeCount.get must_== 0
-
-    }
-
-    "throw an exception when accessed after being closed" in {
-      val cl = new ClosableLazy[String, Int] {
-        protected def create() = ("oof", () => 1)
-        protected def closeNotNeeded = -1
-      }
-      cl.get must_== "oof"
-      cl.close() must_== 1
-      cl.get must throwAn[IllegalStateException]
-    }
-
-    "not deadlock when get is called during the close function" in {
-
-      val getResultPromise = Promise[String]
-      val test = Future {
-        lazy val cl: ClosableLazy[String, Unit] = new ClosableLazy[String, Unit] {
-          protected def create() = {
-            ("banana", { () =>
-              val getResult = Future[String] {
-                cl.get()
-              }
-              getResultPromise.completeWith(getResult)
-              Await.result(getResult, Duration(2, MINUTES))
-            })
-          }
-          protected def closeNotNeeded = ()
-        }
-        cl.get must_== "banana"
-        cl.close() must_== (())
-      }
-
-      // Our get result should happen immediately and throw an IllegalStateException
-      // because the ClosableLazy is closed. Use a long duration so this will work
-      // on slow machines.
-      Await.result(getResultPromise.future, Duration(1, MINUTES)) must throwAn[IllegalStateException]
-    }
-
-  }
-
-}
