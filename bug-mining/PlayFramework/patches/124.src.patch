diff --git a/framework/src/play/src/main/scala/play/api/libs/Files.scala b/framework/src/play/src/main/scala/play/api/libs/Files.scala
index d0a9c16f44..5ea8a3b4e9 100644
--- a/framework/src/play/src/main/scala/play/api/libs/Files.scala
+++ b/framework/src/play/src/main/scala/play/api/libs/Files.scala
@@ -8,7 +8,6 @@ import java.lang.ref.Reference
 import java.nio.file.attribute.BasicFileAttributes
 import java.nio.file.{ Files => JFiles, _ }
 import java.time.{ Clock, Instant }
-import java.util.concurrent.atomic.AtomicReference
 import java.util.function.Predicate
 import javax.inject.{ Inject, Provider, Singleton }
 
@@ -19,7 +18,6 @@ import org.slf4j.LoggerFactory
 import play.api.Configuration
 import play.api.inject.ApplicationLifecycle
 
-import scala.annotation.tailrec
 import scala.concurrent.Future
 import scala.concurrent.duration._
 import scala.language.implicitConversions
@@ -149,38 +147,24 @@ object Files {
     private val logger = play.api.Logger(this.getClass)
     private val frq = new FinalizableReferenceQueue()
 
-    private val TempDirectoryPrefix = "playtemp"
-
     // Much of the PhantomReference implementation is taken from
     // the Google Guava documentation example
     //
     // https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/FinalizableReferenceQueue.html
     // Keeping references ensures that the FinalizablePhantomReference itself is not garbage-collected.
     private val references = Sets.newConcurrentHashSet[Reference[TemporaryFile]]()
-    private val _playTempFolder: AtomicReference[Option[Path]] = new AtomicReference(None)
 
-    override def create(prefix: String, suffix: String): TemporaryFile = {
-      JFiles.createDirectories(playTempFolder)
-      val tempFile = JFiles.createTempFile(playTempFolder, prefix, suffix)
-      createReference(new DefaultTemporaryFile(tempFile, this))
+    private val TempDirectoryPrefix = "playtemp"
+    private val _playTempFolder: Path = {
+      val tmpFolder = JFiles.createTempDirectory(TempDirectoryPrefix)
+      temporaryFileReaper.updateTempFolder(tmpFolder)
+      tmpFolder
     }
 
-    @tailrec private def playTempFolder: Path = {
-      val lastValue = _playTempFolder.get
-      val newFolder = lastValue match {
-        // We may need to recreate the file if it was deleted (e.g. by tmpwatch)
-        case Some(folder) if JFiles.exists(folder) =>
-          folder
-        case _ =>
-          JFiles.createTempDirectory(TempDirectoryPrefix)
-      }
-      if (_playTempFolder.compareAndSet(lastValue, Some(newFolder))) {
-        temporaryFileReaper.updateTempFolder(newFolder)
-        newFolder
-      } else {
-        JFiles.deleteIfExists(newFolder)
-        playTempFolder
-      }
+    override def create(prefix: String, suffix: String): TemporaryFile = {
+      JFiles.createDirectories(_playTempFolder)
+      val tempFile = JFiles.createTempFile(_playTempFolder, prefix, suffix)
+      createReference(new DefaultTemporaryFile(tempFile, this))
     }
 
     override def create(path: Path): TemporaryFile = {
@@ -192,7 +176,7 @@ object Files {
         override def finalizeReferent(): Unit = {
           references.remove(this)
           val path = tempFile.path
-          delete(tempFile)
+          deletePath(path)
         }
       }
       references.add(reference)
@@ -226,9 +210,9 @@ object Files {
      * Application stop hook which deletes the temporary folder recursively (including subfolders).
      */
     applicationLifecycle.addStopHook { () =>
-      Future.successful(JFiles.walkFileTree(playTempFolder, new SimpleFileVisitor[Path] {
+      Future.successful(JFiles.walkFileTree(_playTempFolder, new SimpleFileVisitor[Path] {
         override def visitFile(path: Path, attrs: BasicFileAttributes): FileVisitResult = {
-          logger.debug(s"stopHook: Removing leftover temporary file $path from $playTempFolder")
+          logger.debug(s"stopHook: Removing leftover temporary file $path from ${_playTempFolder}")
           deletePath(path)
           FileVisitResult.CONTINUE
         }
diff --git a/framework/src/play/src/test/scala/play/api/libs/TemporaryFileCreatorSpec.scala b/framework/src/play/src/test/scala/play/api/libs/TemporaryFileCreatorSpec.scala
index 397eba4c6f..4bf1f7cb46 100644
--- a/framework/src/play/src/test/scala/play/api/libs/TemporaryFileCreatorSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/libs/TemporaryFileCreatorSpec.scala
@@ -6,6 +6,7 @@ package play.api.libs
 import java.io.File
 import java.nio.charset.Charset
 import java.nio.file.{ Path, Files => JFiles }
+import java.util.concurrent.{ CountDownLatch, ExecutorService, Executors }
 
 import org.specs2.mock.Mockito
 import org.specs2.mutable.{ After, Specification }
@@ -16,6 +17,10 @@ import play.api.inject.DefaultApplicationLifecycle
 import play.api.libs.Files._
 import play.api.routing.Router
 
+import scala.concurrent.{ Await, ExecutionContext, Future }
+import scala.concurrent.duration._
+import scala.util.Try
+
 class TemporaryFileCreatorSpec extends Specification with Mockito {
 
   sequential
@@ -41,6 +46,50 @@ class TemporaryFileCreatorSpec extends Specification with Mockito {
       }
     }
 
+    "not have a race condition when creating temporary files" in {
+
+      // See issue https://github.com/playframework/playframework/issues/7700
+      // We were having problems by creating to many temporary folders and
+      // keeping track of them inside TemporaryFileCreator and between it and
+      // TemporaryFileReaper.
+
+      val threads = 25
+      val threadPool: ExecutorService = Executors.newFixedThreadPool(threads)
+
+      val lifecycle = new DefaultApplicationLifecycle
+      val reaper = mock[TemporaryFileReaper]
+      val creator = new DefaultTemporaryFileCreator(lifecycle, reaper)
+
+      try {
+        val executionContext = ExecutionContext.fromExecutorService(threadPool)
+
+        // Use a latch to stall the threads until they are all ready to go, then
+        // release them all at once. This maximizes the chance of a race condition
+        // being visible.
+        val raceLatch = new CountDownLatch(threads)
+
+        val futureResults: Seq[Future[Try[TemporaryFile]]] = for (_ <- 0 until threads) yield {
+          Future {
+            Try {
+              raceLatch.countDown()
+              creator.create("foo", "bar")
+            }
+          }(executionContext)
+        }
+
+        val results: Seq[Try[TemporaryFile]] = {
+          import ExecutionContext.Implicits.global // implicit for Future.sequence
+          Await.result(Future.sequence(futureResults), 30.seconds)
+        }
+
+        // If there is some failure, the test should fail then
+        results.exists(_.isFailure) must beFalse
+      } finally {
+        threadPool.shutdown()
+      }
+      ok
+    }
+
     "recreate directory if it is deleted" in new WithScope() {
       val lifecycle = new DefaultApplicationLifecycle
       val reaper = mock[TemporaryFileReaper]
