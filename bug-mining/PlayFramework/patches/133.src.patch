diff --git a/framework/build.sbt b/framework/build.sbt
index ec40e01fb6..78c0783c38 100644
--- a/framework/build.sbt
+++ b/framework/build.sbt
@@ -53,7 +53,8 @@ lazy val PlayJodaFormsProject = PlayCrossBuiltProject("Play-Joda-Forms", "play-j
 lazy val PlayProject = PlayCrossBuiltProject("Play", "play")
     .enablePlugins(SbtTwirl)
     .settings(
-      libraryDependencies ++= runtime(scalaVersion.value) ++ scalacheckDependencies ++ cookieEncodingDependencies,
+      libraryDependencies ++= runtime(scalaVersion.value) ++ scalacheckDependencies ++ cookieEncodingDependencies :+
+        jimfs % Test,
 
       sourceGenerators in Compile += Def.task(PlayVersion(
         version.value,
diff --git a/framework/project/Dependencies.scala b/framework/project/Dependencies.scala
index 080ecb0716..4a89d67c17 100644
--- a/framework/project/Dependencies.scala
+++ b/framework/project/Dependencies.scala
@@ -162,6 +162,8 @@ object Dependencies {
 
   val cookieEncodingDependencies = slf4j
 
+  val jimfs = "com.google.jimfs" % "jimfs" % "1.1"
+
   val okHttp = "com.squareup.okhttp3" % "okhttp" % "3.9.0"
 
   def routesCompilerDependencies(scalaVersion: String) = Seq(
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
index 95ca201723..4d4393fe78 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
@@ -3,16 +3,21 @@
  */
 package play.it.http.parsing
 
+import akka.NotUsed
 import akka.stream.scaladsl.Source
 import akka.util.ByteString
-import play.api.Application
-import play.api.libs.Files.TemporaryFile
-import play.api.mvc.{ MultipartFormData, PlayBodyParsers, Result }
+import play.api.{ Application, BuiltInComponentsFromContext, NoHttpFiltersComponents }
+import play.api.libs.Files.{ TemporaryFile, TemporaryFileCreator }
+import play.api.mvc._
 import play.api.test._
 import play.core.parsers.Multipart.{ FileInfoMatcher, PartInfoMatcher }
 import play.utils.PlayIO
+import play.api.libs.ws.WSClient
+import play.api.mvc.MultipartFormData.FilePart
+import play.api.routing.Router
+import play.core.server.Server
 
-class MultipartFormDataParserSpec extends PlaySpecification {
+class MultipartFormDataParserSpec extends PlaySpecification with WsTestClient {
 
   val body =
     """
@@ -66,6 +71,24 @@ class MultipartFormDataParserSpec extends PlaySpecification {
     }
   }
 
+  def withClientAndServer[T](totalSpace: Long)(block: WSClient => T) = {
+    Server.withApplicationFromContext() { context =>
+      new BuiltInComponentsFromContext(context) with NoHttpFiltersComponents {
+
+        override lazy val tempFileCreator: TemporaryFileCreator = new InMemoryTemporaryFileCreator(totalSpace)
+
+        import play.api.routing.sird.{ POST => SirdPost, _ }
+        override def router: Router = Router.from {
+          case SirdPost(p"/") => defaultActionBuilder(parse.multipartFormData) { request =>
+            Results.Ok(request.body.files.map(_.filename).mkString(", "))
+          }
+        }
+      }.application
+    } { implicit port =>
+      withClient(block)
+    }
+  }
+
   "The multipart/form-data parser" should {
     "parse some content" in new WithApplication() {
       val parser = parse.multipartFormData.apply(FakeRequest().withHeaders(
@@ -128,6 +151,19 @@ class MultipartFormDataParserSpec extends PlaySpecification {
       }
     }
 
+    "return server internal error when file upload fails because temporary file creator fails" in withClientAndServer(1 /* super small total space */ ) { ws =>
+      val fileBody: ByteString = ByteString.fromString("the file body")
+      val sourceFileBody: Source[ByteString, NotUsed] = Source.single(fileBody)
+      val filePart: FilePart[Source[ByteString, NotUsed]] = FilePart(key = "file", filename = "file.txt", contentType = Option("text/plain"), ref = sourceFileBody)
+
+      val response = ws
+        .url("/")
+        .post(Source.single(filePart))
+
+      val res = await(response)
+      res.status must_== INTERNAL_SERVER_ERROR
+    }
+
     "work if there's no crlf at the start" in new WithApplication() {
       val parser = parse.multipartFormData.apply(FakeRequest().withHeaders(
         CONTENT_TYPE -> "multipart/form-data; boundary=aabbccddee"
diff --git a/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala b/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
index 16b62a9046..6a5de3c07f 100644
--- a/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
+++ b/framework/src/play/src/main/scala/play/core/parsers/Multipart.scala
@@ -7,10 +7,11 @@ import scala.annotation.tailrec
 import scala.collection.mutable.ListBuffer
 import scala.collection.breakOut
 import scala.concurrent.Future
+import scala.util.{ Failure, Success }
 
 import akka.stream.Materializer
 import akka.stream.scaladsl._
-import akka.stream.{ Attributes, FlowShape, Inlet, Outlet }
+import akka.stream.{ Attributes, FlowShape, Inlet, IOResult, Outlet }
 import akka.stream.stage._
 import akka.util.ByteString
 
@@ -122,8 +123,9 @@ object Multipart {
   def handleFilePartAsTemporaryFile(temporaryFileCreator: TemporaryFileCreator): FilePartHandler[TemporaryFile] = {
     case FileInfo(partName, filename, contentType) =>
       val tempFile = temporaryFileCreator.create("multipartBody", "asTemporaryFile")
-      Accumulator(FileIO.toPath(tempFile.path)).map { _ =>
-        FilePart(partName, filename, contentType, tempFile)
+      Accumulator(FileIO.toPath(tempFile.path)).mapFuture {
+        case IOResult(_, Failure(error)) => Future.failed(error)
+        case _ => Future.successful(FilePart(partName, filename, contentType, tempFile))
       }
   }
 
diff --git a/framework/src/play/src/test/scala/play/api/mvc/InMemoryTemporaryFileCreator.scala b/framework/src/play/src/test/scala/play/api/mvc/InMemoryTemporaryFileCreator.scala
new file mode 100644
index 0000000000..fb9c93dfb1
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/api/mvc/InMemoryTemporaryFileCreator.scala
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.api.mvc
+
+import java.io.File
+import java.nio.file.{ FileSystem, Path, Files => JFiles }
+
+import com.google.common.jimfs.{ Configuration, Jimfs }
+import play.api.libs.Files.{ TemporaryFile, TemporaryFileCreator }
+
+import scala.util.Try
+
+class InMemoryTemporaryFile(val path: Path, val temporaryFileCreator: TemporaryFileCreator) extends TemporaryFile {
+  def file: File = path.toFile
+}
+
+class InMemoryTemporaryFileCreator(totalSpace: Long) extends TemporaryFileCreator {
+  private val fsConfig: Configuration = Configuration.unix
+    .toBuilder
+    .setMaxSize(totalSpace)
+    .build()
+  private val fs: FileSystem = Jimfs.newFileSystem(fsConfig)
+  private val playTempFolder: Path = fs.getPath("/tmp")
+
+  def create(prefix: String = "", suffix: String = ""): TemporaryFile = {
+    JFiles.createDirectories(playTempFolder)
+    val tempFile = JFiles.createTempFile(playTempFolder, prefix, suffix)
+    new InMemoryTemporaryFile(tempFile, this)
+  }
+
+  def create(path: Path): TemporaryFile = new InMemoryTemporaryFile(path, this)
+
+  def delete(file: TemporaryFile): Try[Boolean] = Try(JFiles.deleteIfExists(file.path))
+}
diff --git a/framework/src/play/src/test/scala/play/api/mvc/MultipartBodyParserSpec.scala b/framework/src/play/src/test/scala/play/api/mvc/MultipartBodyParserSpec.scala
new file mode 100644
index 0000000000..41d607d9c8
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/api/mvc/MultipartBodyParserSpec.scala
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.api.mvc
+
+import java.io.IOException
+
+import akka.actor.ActorSystem
+import akka.stream.ActorMaterializer
+import akka.stream.scaladsl.Source
+import akka.util.ByteString
+import org.specs2.mutable.Specification
+import play.core.test.{ FakeHeaders, FakeRequest }
+
+import scala.concurrent.Await
+import scala.concurrent.duration.Duration
+
+class MultipartBodyParserSpec extends Specification {
+
+  "Multipart body parser" should {
+    implicit val system = ActorSystem()
+    implicit val executionContext = system.dispatcher
+    implicit val materializer = ActorMaterializer()
+
+    val playBodyParsers = PlayBodyParsers(
+      tfc = new InMemoryTemporaryFileCreator(10))
+
+    "return an error if temporary file creation fails" in {
+
+      val fileSize = 100
+      val boundary = "-----------------------------14568445977970839651285587160"
+      val header =
+        s"--$boundary\r\n" +
+          "Content-Disposition: form-data; name=\"uploadedfile\"; filename=\"uploadedfile.txt\"\r\n" +
+          "Content-Type: application/octet-stream\r\n" +
+          "\r\n"
+      val content = Array.ofDim[Byte](fileSize)
+      val footer =
+        "\r\n" +
+          "\r\n" +
+          s"--$boundary--\r\n"
+
+      val body = Source(
+        ByteString(header) ::
+          ByteString(content) ::
+          ByteString(footer) ::
+          Nil)
+
+      val bodySize = header.length + fileSize + footer.length
+
+      val request = FakeRequest(
+        method = "POST",
+        uri = "/x",
+        headers = FakeHeaders(Seq(
+          "Content-Type" -> s"multipart/form-data; boundary=$boundary",
+          "Content-Length" -> bodySize.toString)),
+        body = body)
+
+      val response = playBodyParsers.multipartFormData.apply(request).run(body)
+      Await.result(response, Duration.Inf) must throwA[IOException]
+    }
+  }
+}
