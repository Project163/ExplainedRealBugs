diff --git a/framework/src/sbt-plugin/src/main/scala-sbt-0.13/play/sbt/run/PlayRunCompat.scala b/framework/src/sbt-plugin/src/main/scala-sbt-0.13/play/sbt/run/PlayRunCompat.scala
index 9385075f23..6f9f3bca00 100644
--- a/framework/src/sbt-plugin/src/main/scala-sbt-0.13/play/sbt/run/PlayRunCompat.scala
+++ b/framework/src/sbt-plugin/src/main/scala-sbt-0.13/play/sbt/run/PlayRunCompat.scala
@@ -17,7 +17,12 @@ private[run] trait PlayRunCompat {
 
   def getPollInterval(watched: Watched): Int = watched.pollInterval
 
-  def getSourcesFinder(watched: Watched, state: State): PlaySourceModificationWatch.PathFinder = () => watched.watchPaths(state).map(f => better.files.File(f.toURI)).toIterator
+  def getSourcesFinder(watched: Watched, state: State): PlaySourceModificationWatch.PathFinder = {
+    () =>
+      watched.watchPaths(state).collect {
+        case f if f.exists() => better.files.File(f.toURI)
+      }(scala.collection.breakOut)
+  }
 
   def kill(pid: String) = s"kill $pid".!
 
diff --git a/framework/src/sbt-plugin/src/main/scala-sbt-1.0/play/sbt/run/PlayRunCompat.scala b/framework/src/sbt-plugin/src/main/scala-sbt-1.0/play/sbt/run/PlayRunCompat.scala
index 8fde1c6bf8..182d9224c7 100644
--- a/framework/src/sbt-plugin/src/main/scala-sbt-1.0/play/sbt/run/PlayRunCompat.scala
+++ b/framework/src/sbt-plugin/src/main/scala-sbt-1.0/play/sbt/run/PlayRunCompat.scala
@@ -20,24 +20,12 @@ private[run] trait PlayRunCompat {
   def getPollInterval(watched: Watched): Int = watched.pollInterval.toMillis.toInt
 
   def getSourcesFinder(watched: Watched, state: State): SourceModificationWatch.PathFinder = () => {
-    // TODO: sbt 1.0
-    // For sbt 0.13 we have watched.watchPaths(state) which returns a Seq[sbt.File]
-    // that we can then transform in a Iterator[better.files.File]. But for sbt 1.0
-    // watched.watchSources(state) returns a Seq[sbt.Watched.WatchSource] where
-    // WatchSource is a type alias to sbt.internal.io.Source which has a `base`
-    // directory and filters, but there is no access to getUnfilteredPaths.
-    //
-    // A possible current approach here is to copy code from sbt and make it accessible
-    // to Play (maybe using play-file-watch), but it is possible that we need to
-    // copy a good amount of code just to have access to a "simple" method.
-    //
-    // So there is now PlaySource which is class declared inside sbt.internal.io
-    // to make it possible to access sbt.internal.io.Source methods.
     watched.watchSources(state)
       .map(source => new PlaySource(source))
       .flatMap(_.getFiles)
-      .map(f => better.files.File(f.toPath))
-      .toIterator
+      .collect {
+        case f if f.exists() => better.files.File(f.toPath)
+      }(scala.collection.breakOut)
   }
 
   def kill(pid: String) = s"kill $pid".!
diff --git a/framework/src/sbt-plugin/src/main/scala/play/sbt/run/PlayRun.scala b/framework/src/sbt-plugin/src/main/scala/play/sbt/run/PlayRun.scala
index c36160b19c..40842bb8a8 100644
--- a/framework/src/sbt-plugin/src/main/scala/play/sbt/run/PlayRun.scala
+++ b/framework/src/sbt-plugin/src/main/scala/play/sbt/run/PlayRun.scala
@@ -150,6 +150,7 @@ object PlayRun extends PlayRunCompat {
         case e: Exception =>
           val log = state.log
           log.error("Error occurred obtaining files to watch.  Terminating continuous execution...")
+          log.trace(e)
           (false, watchState, state.fail)
       }
 
