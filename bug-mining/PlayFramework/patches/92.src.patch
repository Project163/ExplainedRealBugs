diff --git a/documentation/manual/releases/release26/migration26/Migration26.md b/documentation/manual/releases/release26/migration26/Migration26.md
index 2bb6954cc1..01139f7828 100644
--- a/documentation/manual/releases/release26/migration26/Migration26.md
+++ b/documentation/manual/releases/release26/migration26/Migration26.md
@@ -153,3 +153,113 @@ libraryDependencies += "org.apache.tomcat" % "tomcat-servlet-api" % "8.0.33"
 ### Akka Migration
 
 The deprecated static methods `play.libs.Akka.system` and `play.api.libs.concurrent.Akka.system` were removed.  Please dependency inject an `ActorSystem` instance for access to the actor system.
+
+### Request tags deprecated, replaced with attributes
+
+In Play each `Request` and `RequestHeader` object carries a map of strings called *tags*. This map can be used to attach extra information to a request. In Play 2.6 request tags have been deprecated. A new alternative to tags, called *attributes*, should be used instead.
+
+Unlike tags, which can only be strings, attributes have types. Attributes are identified by a `TypedKey<T>` object that holds the attribute's type. This means the type system can catch errors in your code. It also means you can attach normal objects to a request, not just strings.
+
+In Play 2.6, tags are still provided and still work. However, tags will be removed in a future version of Play so you should update your existing code to use attributes instead.
+
+Existing Java code:
+
+```java
+// Tags have string keys
+final String USER_ID = "userId";
+...
+// Store the User object's id in the tags map
+User user = getUser(...);
+req.tags.put(USER_ID, Long.toString(user.getId()));
+...
+// Get the user's id out of the tags map then look up the original User object
+User user = getUserById(Long.parseLong(req.tags.get(USER_ID)));
+```
+
+Updated Java code:
+
+```java
+// Use a key with type User
+import play.api.libs.typedmap.TypedKey
+final TypedKey<User> USER = TypedKeyFactory.create("user");
+...
+// Create new copy of the request with the USER attribute added
+User user = getUser(...);
+Request reqWithUser = req.withAttr(USER, user);
+...
+// Get the USER attribute from the request
+User user = req.attr(USER);
+```
+
+Existing Scala code:
+
+```scala
+// Tags have string keys
+val UserId: String = "userId"
+...
+// Store the User object's id in the tags map
+val user: User = getUser(...)
+val reqWithUserId = req.copy(tags = req.tags + (UserId -> user.id.toString))
+...
+// Get the user's id out of the tags map then look up the original User object
+User user = getUserById(Long.parseLong(reqWithUserId.tags(UserId)))
+```
+
+Updated Scala code:
+
+```scala
+// Use a key with type User
+import play.api.libs.typedmap.TypedKey
+val User: TypedKey[User] = TypedKey("user")
+...
+// Create new copy of the request with the User attribute added
+val user: User = getUser(...)
+val reqWithUser = req.withAttr(User, user)
+...
+// Get the User attribute from the request
+val user: User = req.attr(User)
+```
+
+#### Request Security username property is now an attribute
+
+The Java Request object contains a `username` property which is set when the `Security.Authenticated` annotation is added to a Java action. In Play 2.6 the username property has been deprecated. The username property methods have been updated to store the username in the `Security.USERNAME` attribute. You should update your code to use the `Security.USERNAME` attribute directly. In a future version of Play we will remove the username property.
+
+The reason for this change is that the username property was provided as a special case for the `Security.Authenticated` annotation. Now that we have attributes we don't need a special case anymore.
+
+Existing Java code:
+
+```java
+// Set the username
+Request reqWithUsername = req.withUsername("admin");
+// Get the username
+String username = req1.username();
+// Set the username with a builder
+Request reqWithUsername = new RequestBuilder().username("admin").build();
+```
+
+Updated Java code:
+
+```java
+import play.mvc.Security.USERNAME;
+
+// Set the username
+Request reqWithUsername = req.withAttr(USERNAME, "admin");
+// Get the username
+String username = req1.attr(USERNAME);
+// Set the username with a builder
+Request reqWithUsername = new RequestBuilder().putAttr(USERNAME, "admin").build();
+```
+
+#### Router tags are now attributes
+
+If you used any of the `Router.Tags.*` tags, you should change your code to use the new `Router.HandlerDefAttr` attribute instead. The existing tags are still available, but are deprecated and will be removed in a future version of Play.
+
+The attribute contains a `HandlerDef` object that contains all the information that is currently in the tags. The relationship between a `HandlerDef` object and its tags is as follows:
+
+```scala
+RoutePattern -> handlerDef.path
+RouteVerb -> handlerDef.verb
+RouteController -> handlerDef.controller
+RouteActionMethod -> handlerDef.method
+RouteComments -> handlerDef.comments
+```
diff --git a/documentation/manual/working/scalaGuide/main/http/code/ScalaRouting.scala b/documentation/manual/working/scalaGuide/main/http/code/ScalaRouting.scala
index 0d0313feb4..82b909fcc9 100644
--- a/documentation/manual/working/scalaGuide/main/http/code/ScalaRouting.scala
+++ b/documentation/manual/working/scalaGuide/main/http/code/ScalaRouting.scala
@@ -142,9 +142,13 @@ object ScalaRoutingSpec extends Specification {
   def contentOf(rh: RequestHeader, router: Class[_ <: Router] = classOf[Routes]) = {
     running() { app =>
       implicit val mat = ActorMaterializer()(app.actorSystem)
-      contentAsString(app.injector.instanceOf(router).routes(rh) match {
-        case e: EssentialAction => e(rh).run()
-      })
+      contentAsString {
+        val routedHandler = app.injector.instanceOf(router).routes(rh)
+        val (rh2, terminalHandler) = Handler.applyStages(rh, routedHandler)
+        terminalHandler match {
+          case e: EssentialAction => e(rh2).run()
+        }
+      }
     }
   }
 }
diff --git a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
index ffc556202b..6c1aac4276 100644
--- a/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
+++ b/framework/src/play-akka-http-server/src/main/scala/play/core/server/akkahttp/ModelConversion.scala
@@ -12,9 +12,11 @@ import akka.stream.scaladsl.Source
 import akka.util.ByteString
 import play.api.Logger
 import play.api.http.HeaderNames._
-import play.api.http.{ HttpChunk, HttpErrorHandler, HttpEntity => PlayHttpEntity, Status }
+import play.api.http.{ HttpChunk, HttpErrorHandler, Status, HttpEntity => PlayHttpEntity }
+import play.api.libs.typedmap.TypedMap
 import play.api.mvc._
 import play.core.server.common.{ ConnectionInfo, ForwardedHeaderHandler, ServerResultUtils }
+
 import scala.collection.immutable
 import scala.concurrent.Future
 
@@ -48,13 +50,10 @@ private[akkahttp] class ModelConversion(forwardedHeaderHandler: ForwardedHeaderH
     remoteAddress: InetSocketAddress,
     secureProtocol: Boolean,
     request: HttpRequest): RequestHeader = {
-    val remoteHostAddress = remoteAddress.getAddress.getHostAddress
-    // Taken from PlayDefaultUpstreamHander
-
     // Avoid clash between method arg and RequestHeader field
     val remoteAddressArg = remoteAddress
 
-    new RequestHeader {
+    new RequestHeader with WithAttrMap[RequestHeader] {
       override val id = requestId
       // Send a tag so our tests can tell which kind of server we're using.
       // We could get NettyServer to send a similar tag, but for the moment
@@ -77,6 +76,8 @@ private[akkahttp] class ModelConversion(forwardedHeaderHandler: ForwardedHeaderH
       override def remoteAddress = remoteConnection.address.getHostAddress
       override def secure = remoteConnection.secure
       override def clientCertificateChain = None // TODO - Akka does not yet expose the SSLEngine used for the request
+      override protected def attrMap = TypedMap.empty
+      override protected def withAttrMap(newAttrMap: TypedMap): RequestHeader = new RequestHeaderWithAttributes(this, newAttrMap)
     }
   }
 
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
index 571c71cba9..02ca6a4b59 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/action/HeadActionSpec.scala
@@ -19,8 +19,10 @@ import play.api.test._
 import play.core.server.Server
 import play.it._
 import play.it.tools.HttpBinApplication._
+
 import scala.concurrent.ExecutionContext.Implicits.global
 import org.asynchttpclient.netty.NettyResponse
+import play.api.libs.typedmap.TypedKey
 
 class NettyHeadActionSpec extends HeadActionSpec with NettyIntegrationSpecification
 class AkkaHttpHeadActionSpec extends HeadActionSpec with AkkaHttpIntegrationSpecification
@@ -58,9 +60,9 @@ trait HeadActionSpec extends Specification with FutureAwaits with DefaultAwaitTi
       }
     }
 
-    def serverWithAction[T](action: EssentialAction)(block: WSClient => T): T = {
+    def serverWithHandler[T](handler: Handler)(block: WSClient => T): T = {
       Server.withRouter() {
-        case _ => action
+        case _ => handler
       } { implicit port =>
         implicit val mat = Play.current.materializer
         WsTestClient.withClient(block)
@@ -121,17 +123,41 @@ trait HeadActionSpec extends Specification with FutureAwaits with DefaultAwaitTi
       foreach(responseList)((_: WSResponse).status must_== NOT_FOUND)
     }
 
-    "tag request with DefaultHttpRequestHandler" in serverWithAction(new RequestTaggingHandler with EssentialAction {
-      def tagRequest(request: RequestHeader) = request.copy(tags = Map(RouteComments -> "some comment"))
-      def apply(rh: RequestHeader) = Action {
-        Results.Ok.withHeaders(rh.tags.get(RouteComments).map(RouteComments -> _).toSeq: _*)
-      }(rh)
+    val CustomAttr = TypedKey[String]("CustomAttr")
+    def addCustomTagAndAttr(r: RequestHeader): RequestHeader = {
+      r.copy(tags = Map("CustomTag" -> "x")).withAttr(CustomAttr, "y")
+    }
+    val tagAndAttrAction = Action { rh: RequestHeader =>
+      val tagComment = rh.tags.get("CustomTag")
+      val attrComment = rh.getAttr(CustomAttr)
+      val headers = Array.empty[(String, String)] ++
+        rh.tags.get("CustomTag").map("CustomTag" -> _) ++
+        rh.getAttr(CustomAttr).map("CustomAttr" -> _)
+      Results.Ok.withHeaders(headers: _*)
+    }
+
+    "tag request with DefaultHttpRequestHandler" in serverWithHandler(new RequestTaggingHandler with EssentialAction {
+      def tagRequest(request: RequestHeader) = addCustomTagAndAttr(request)
+      def apply(rh: RequestHeader) = tagAndAttrAction(rh)
     }) { client =>
       val result = await(client.url("/get").head())
       result.status must_== OK
-      result.header(RouteComments) must beSome("some comment")
+      result.header("CustomTag") must beSome("x")
+      result.header("CustomAttr") must beSome("y")
     }
 
+    "modify request with DefaultHttpRequestHandler" in serverWithHandler(
+      Handler.Stage.modifyRequest(
+        (rh: RequestHeader) => addCustomTagAndAttr(rh),
+        tagAndAttrAction
+      )
+    ) { client =>
+        val result = await(client.url("/get").head())
+        result.status must_== OK
+        result.header("CustomTag") must beSome("x")
+        result.header("CustomAttr") must beSome("y")
+      }
+
     "omit Content-Length for chunked responses" in withServer { client =>
       val response = await(client.url("/chunked").head())
 
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/JavaHttpHandlerSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/JavaHttpHandlerSpec.scala
new file mode 100644
index 0000000000..c486ac6b41
--- /dev/null
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/JavaHttpHandlerSpec.scala
@@ -0,0 +1,45 @@
+package play.it.http
+
+import play.api.Application
+import play.api.inject.guice.GuiceApplicationBuilder
+import play.api.libs.typedmap.TypedKey
+import play.api.libs.ws.WSResponse
+import play.api.mvc.{ Action, Handler, Results }
+import play.api.test.{ PlaySpecification, WsTestClient }
+import play.core.j.{ JavaHandler, JavaHandlerComponents }
+import play.it.{ AkkaHttpIntegrationSpecification, NettyIntegrationSpecification, ServerIntegrationSpecification }
+
+class NettyJavaHttpHandlerSpec extends JavaHttpHandlerSpec with NettyIntegrationSpecification
+class AkkaJavaHttpHandlerSpec extends JavaHttpHandlerSpec with AkkaHttpIntegrationSpecification
+
+trait JavaHttpHandlerSpec extends PlaySpecification with WsTestClient with ServerIntegrationSpecification {
+
+  def handlerResponse[T](handler: Handler)(block: WSResponse => T): T = {
+    implicit val port = testServerPort
+    val app: Application = GuiceApplicationBuilder().routes {
+      case _ => handler
+    }.build()
+    running(TestServer(port, app)) {
+      val response = await(wsUrl("/").get())
+      block(response)
+    }
+  }
+
+  val TestAttr = TypedKey[String]("testAttr")
+  val javaHandler: JavaHandler = new JavaHandler {
+    override def withComponents(components: JavaHandlerComponents): Handler = {
+      Action { req => Results.Ok(req.getAttr(TestAttr).toString) }
+    }
+  }
+
+  "JavaCompatibleHttpHandler" should {
+    "route requests to a JavaHandler's Action" in handlerResponse(javaHandler) { response =>
+      response.body must beEqualTo("None")
+    }
+    "route a modified request to a JavaHandler's Action" in handlerResponse(
+      Handler.Stage.modifyRequest(_.withAttr(TestAttr, "Hello!"), javaHandler)
+    ) { response =>
+        response.body must beEqualTo("Some(Hello!)")
+      }
+  }
+}
diff --git a/framework/src/play-java/src/test/java/play/mvc/RequestBuilderTest.java b/framework/src/play-java/src/test/java/play/mvc/RequestBuilderTest.java
index ef81b21aab..a29921e964 100644
--- a/framework/src/play-java/src/test/java/play/mvc/RequestBuilderTest.java
+++ b/framework/src/play-java/src/test/java/play/mvc/RequestBuilderTest.java
@@ -7,6 +7,8 @@ import akka.stream.javadsl.Source;
 import play.api.Application;
 import play.api.Play;
 import play.api.inject.guice.GuiceApplicationBuilder;
+import play.api.libs.typedmap.TypedKey;
+import play.api.libs.typedmap.TypedKeyFactory;
 import play.mvc.Http.Context;
 import play.mvc.Http.Request;
 import play.mvc.Http.RequestBuilder;
@@ -45,6 +47,59 @@ public class RequestBuilderTest {
         assertTrue(new RequestBuilder().uri("https://www.benmccann.com/blog").build().secure());
     }
 
+    @Test
+    public void testAttrs() {
+        final TypedKey<Long> NUMBER = TypedKeyFactory.create("number");
+        final TypedKey<String> COLOR = TypedKeyFactory.create("color");
+
+        RequestBuilder builder = new RequestBuilder().uri("http://www.playframework.com/");
+        assertFalse(builder.getAttr(NUMBER).isPresent());
+        assertFalse(builder.getAttr(COLOR).isPresent());
+
+        Request req1 = builder.build();
+
+        builder.putAttr(NUMBER, 6L);
+        assertTrue(builder.getAttr(NUMBER).isPresent());
+        assertFalse(builder.getAttr(COLOR).isPresent());
+        Request req2 = builder.build();
+
+        builder.putAttr(NUMBER, 70L);
+        assertTrue(builder.getAttr(NUMBER).isPresent());
+        assertFalse(builder.getAttr(COLOR).isPresent());
+        Request req3 = builder.build();
+
+        builder.putAttrs(NUMBER.bindValue(6L), COLOR.bindValue("blue"));
+        assertTrue(builder.getAttr(NUMBER).isPresent());
+        assertTrue(builder.getAttr(COLOR).isPresent());
+        Request req4 = builder.build();
+
+        builder.putAttrs(COLOR.bindValue("red"));
+        assertTrue(builder.getAttr(NUMBER).isPresent());
+        assertTrue(builder.getAttr(COLOR).isPresent());
+        Request req5 = builder.build();
+
+        assertFalse(req1.getAttr(NUMBER).isPresent());
+        assertFalse(req1.getAttr(COLOR).isPresent());
+
+        assertEquals(Optional.of(6L), req2.getAttr(NUMBER));
+        assertEquals((Long) 6L, req2.attr(NUMBER));
+        assertFalse(req2.getAttr(COLOR).isPresent());
+
+        assertEquals(Optional.of(70L), req3.getAttr(NUMBER));
+        assertEquals((Long) 70L, req3.attr(NUMBER));
+        assertFalse(req3.getAttr(COLOR).isPresent());
+
+        assertEquals(Optional.of(6L), req4.getAttr(NUMBER));
+        assertEquals((Long) 6L, req4.attr(NUMBER));
+        assertEquals(Optional.of("blue"), req4.getAttr(COLOR));
+        assertEquals("blue", req4.attr(COLOR));
+
+        assertEquals(Optional.of(6L), req5.getAttr(NUMBER));
+        assertEquals((Long) 6L, req5.attr(NUMBER));
+        assertEquals(Optional.of("red"), req5.getAttr(COLOR));
+        assertEquals("red", req5.attr(COLOR));
+    }
+
     @Test
     public void testFlash() {
         Context ctx = new Context(new RequestBuilder().flash("a","1").flash("b","1").flash("b","2"));
@@ -66,10 +121,25 @@ public class RequestBuilderTest {
     public void testUsername() {
         final Request req1 =
             new RequestBuilder().uri("http://playframework.com/").build();
-        final Request req2 = req1.withUsername("user2");
+        final Request req2 = req1.withAttr(Security.USERNAME, "user2");
+        final Request req3 = req1.withUsername("user3");
+        final Request req4 =
+                new RequestBuilder().uri("http://playframework.com/").username("user4").build();
 
         assertNull(req1.username());
+        assertFalse(req1.getAttr(Security.USERNAME).isPresent());
+
         assertEquals("user2", req2.username());
+        assertTrue(req2.getAttr(Security.USERNAME).isPresent());
+        assertEquals("user2", req2.attr(Security.USERNAME));
+
+        assertEquals("user3", req3.username());
+        assertTrue(req3.getAttr(Security.USERNAME).isPresent());
+        assertEquals("user3", req3.attr(Security.USERNAME));
+
+        assertEquals("user4", req4.username());
+        assertTrue(req4.getAttr(Security.USERNAME).isPresent());
+        assertEquals("user4", req4.attr(Security.USERNAME));
     }
 
     @Test
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyModelConversion.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyModelConversion.scala
index 9f4b6cc4b9..ff001d8ab3 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyModelConversion.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyModelConversion.scala
@@ -20,6 +20,7 @@ import io.netty.util.ReferenceCountUtil
 import play.api.Logger
 import play.api.http._
 import play.api.http.HeaderNames._
+import play.api.libs.typedmap.TypedMap
 import play.api.mvc._
 import play.core.server.common.{ ConnectionInfo, ForwardedHeaderHandler, ServerResultUtils }
 
@@ -73,7 +74,7 @@ private[server] class NettyModelConversion(forwardedHeaderHandler: ForwardedHead
     parameters: Map[String, Seq[String]], _remoteAddress: InetSocketAddress,
     sslHandler: Option[SslHandler]): RequestHeader = {
 
-    new RequestHeader {
+    new RequestHeader with WithAttrMap[RequestHeader] {
       override val id = requestId
       override val tags = Map.empty[String, String]
       override def uri = request.getUri
@@ -88,13 +89,15 @@ private[server] class NettyModelConversion(forwardedHeaderHandler: ForwardedHead
       override def remoteAddress = remoteConnection.address.getHostAddress
       override def secure = remoteConnection.secure
       override lazy val clientCertificateChain = clientCertificatesFromSslEngine(sslHandler.map(_.engine()))
+      override protected def attrMap = TypedMap.empty
+      override protected def withAttrMap(newAttrMap: TypedMap): RequestHeader = new RequestHeaderWithAttributes(this, newAttrMap)
     }
   }
 
   /** Create an unparsed request header. Used when even Netty couldn't parse the request. */
   def createUnparsedRequestHeader(requestId: Long, request: HttpRequest, _remoteAddress: InetSocketAddress, sslHandler: Option[SslHandler]) = {
 
-    new RequestHeader {
+    new RequestHeader with WithAttrMap[RequestHeader] {
       override def id = requestId
       override def tags = Map.empty[String, String]
       override def uri = request.getUri
@@ -126,6 +129,8 @@ private[server] class NettyModelConversion(forwardedHeaderHandler: ForwardedHead
       override def remoteAddress = _remoteAddress.getAddress.toString
       override def secure = sslHandler.isDefined
       override lazy val clientCertificateChain = clientCertificatesFromSslEngine(sslHandler.map(_.engine()))
+      override protected def attrMap = TypedMap.empty
+      override protected def withAttrMap(newAttrMap: TypedMap): RequestHeader = new RequestHeaderWithAttributes(this, newAttrMap)
     }
   }
 
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayRequestHandler.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayRequestHandler.scala
index 87f33938e2..4ff32a3e6f 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayRequestHandler.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/PlayRequestHandler.scala
@@ -143,6 +143,12 @@ private[play] class PlayRequestHandler(val server: NettyServer) extends ChannelI
         ))
         handleAction(action, requestHeader, request, Some(app))
 
+      // This case usually indicates an error in Play's internal routing or handling logic
+      case Right((h, _)) =>
+        val ex = new IllegalStateException(s"Netty server doesn't handle Handlers of this type: $h")
+        logger.error(ex.getMessage, ex)
+        throw ex
+
       case Left(e) =>
         logger.trace("No handler, got direct result: " + e)
         val action = EssentialAction(_ => Accumulator.done(e))
diff --git a/framework/src/play-server/src/test/scala/play/core/server/common/ServerResultUtilsSpec.scala b/framework/src/play-server/src/test/scala/play/core/server/common/ServerResultUtilsSpec.scala
index ab9c5b6316..e4bb7217bc 100644
--- a/framework/src/play-server/src/test/scala/play/core/server/common/ServerResultUtilsSpec.scala
+++ b/framework/src/play-server/src/test/scala/play/core/server/common/ServerResultUtilsSpec.scala
@@ -7,34 +7,38 @@ import akka.actor.ActorSystem
 import akka.stream.ActorMaterializer
 import akka.util.ByteString
 import org.specs2.mutable.Specification
-import play.api.http.{ DefaultHttpErrorHandler, HttpEntity }
 import play.api.http.Status._
-import play.api.mvc._
+import play.api.http.{ DefaultHttpErrorHandler, HttpEntity }
+import play.api.libs.typedmap.TypedMap
 import play.api.mvc.Results._
+import play.api.mvc._
 
-import scala.concurrent.{ Await, Future }
 import scala.concurrent.duration._
+import scala.concurrent.{ Await, Future }
 import scala.util.{ Success, Try }
 
 class ServerResultUtilsSpec extends Specification {
 
-  case class CookieRequestHeader(cookie: Option[(String, String)]) extends RequestHeader {
-    def id = 1
-    def tags = Map()
-    def uri = ""
-    def path = ""
-    def method = ""
-    def version = ""
-    def queryString = Map()
-    def remoteAddress = ""
-    def secure = false
-    override def clientCertificateChain = None
-    val headers = new Headers(cookie.map { case (name, value) => "Cookie" -> s"$name=$value" }.toSeq)
+  private def cookieRequestHeader(cookie: Option[(String, String)]): RequestHeader = {
+    new RequestHeaderImpl(
+      id = 1L,
+      tags = Map.empty,
+      uri = "",
+      path = "",
+      method = "",
+      version = "",
+      queryString = Map.empty,
+      headers = new Headers(cookie.map { case (name, value) => "Cookie" -> s"$name=$value" }.toSeq),
+      remoteAddress = "",
+      secure = false,
+      clientCertificateChain = None,
+      attrMap = TypedMap.empty
+    )
   }
 
   "ServerResultUtils.cleanFlashCookie" should {
     def flashCookieResult(cookie: Option[(String, String)], result: Result): Option[Seq[Cookie]] = {
-      val rh = CookieRequestHeader(cookie)
+      val rh = cookieRequestHeader(cookie)
       ServerResultUtils.cleanFlashCookie(rh, result).header.headers.get("Set-Cookie").map(Cookies.decodeSetCookieHeader)
     }
 
@@ -82,19 +86,20 @@ class ServerResultUtilsSpec extends Specification {
     implicit val system = ActorSystem()
     implicit val materializer = ActorMaterializer()
 
-    val header = new RequestHeader {
-      def id = 1
-      def tags = Map()
-      def uri = ""
-      def path = ""
-      def method = ""
-      def version = ""
-      def queryString = Map()
-      def remoteAddress = ""
-      def secure = false
-      def clientCertificateChain = None
-      def headers = new Headers(Seq())
-    }
+    val header = new RequestHeaderImpl(
+      id = 1L,
+      tags = Map(),
+      uri = "",
+      path = "",
+      method = "",
+      version = "",
+      queryString = Map(),
+      remoteAddressFunc = () => "",
+      secureFunc = () => false,
+      clientCertificateChain = None,
+      headers = new Headers(Seq()),
+      attrMap = TypedMap.empty
+    )
 
     def hasNoEntity(response: Future[Result], responseStatus: Int) = {
       Await.ready(response, 5.seconds)
diff --git a/framework/src/play-test/src/main/scala/play/api/test/Fakes.scala b/framework/src/play-test/src/main/scala/play/api/test/Fakes.scala
index a78a064c1d..0c33d09289 100644
--- a/framework/src/play-test/src/main/scala/play/api/test/Fakes.scala
+++ b/framework/src/play-test/src/main/scala/play/api/test/Fakes.scala
@@ -14,6 +14,7 @@ import play.api.inject._
 import play.api.inject.guice.GuiceApplicationBuilder
 import play.api.libs.Files.TemporaryFile
 import play.api.libs.json.JsValue
+import play.api.libs.typedmap.TypedMap
 import play.api.mvc._
 
 import scala.concurrent.Future
@@ -36,7 +37,19 @@ case class FakeHeaders(data: Seq[(String, String)] = Seq.empty) extends Headers(
  * @param body The request body.
  * @param remoteAddress The client IP.
  */
-case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A, remoteAddress: String = "127.0.0.1", version: String = "HTTP/1.1", id: Long = 666, tags: Map[String, String] = Map.empty[String, String], secure: Boolean = false, clientCertificateChain: Option[Seq[X509Certificate]] = None) extends Request[A] {
+case class FakeRequest[A](
+    method: String,
+    uri: String,
+    headers: Headers,
+    body: A,
+    remoteAddress: String = "127.0.0.1",
+    version: String = "HTTP/1.1",
+    id: Long = 666,
+    tags: Map[String, String] = Map.empty[String, String],
+    secure: Boolean = false,
+    clientCertificateChain: Option[Seq[X509Certificate]] = None,
+    attrMap: TypedMap = TypedMap.empty
+  ) extends Request[A] with WithAttrMap[FakeRequest[A]] {
 
   def copyFakeRequest[B](
     id: Long = this.id,
@@ -51,7 +64,7 @@ case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A
     clientCertificateChain: Option[Seq[X509Certificate]] = this.clientCertificateChain,
     body: B = this.body): FakeRequest[B] = {
     new FakeRequest[B](
-      method, uri, headers, body, remoteAddress, version, id, tags, secure, clientCertificateChain
+      method, uri, headers, body, remoteAddress, version, id, tags, secure, clientCertificateChain, attrMap
     )
   }
 
@@ -148,13 +161,16 @@ case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A
     copyFakeRequest(body = AnyContentAsMultipartFormData(form))
   }
 
-  /**
-   * Adds a body to the request.
-   */
-  def withBody[B](body: B): FakeRequest[B] = {
+  override def withBody[B](body: B): FakeRequest[B] = {
     copyFakeRequest(body = body)
   }
 
+  override protected def withAttrMap(newAttrMap: TypedMap): FakeRequest[A] = {
+    new FakeRequest[A](
+      method, uri, headers, body, remoteAddress, version, id, tags, secure, clientCertificateChain, newAttrMap
+    )
+  }
+
   /**
    * Returns the current method
    */
diff --git a/framework/src/play/src/main/java/play/mvc/Http.java b/framework/src/play/src/main/java/play/mvc/Http.java
index 71619374e0..274ed95d81 100644
--- a/framework/src/play/src/main/java/play/mvc/Http.java
+++ b/framework/src/play/src/main/java/play/mvc/Http.java
@@ -12,6 +12,9 @@ import com.google.common.collect.Lists;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 import play.api.libs.json.JsValue;
+import play.api.libs.typedmap.TypedEntry;
+import play.api.libs.typedmap.TypedKey;
+import play.api.libs.typedmap.TypedMap;
 import play.api.mvc.Headers;
 import play.core.j.JavaParsers;
 import play.core.system.RequestIdProvider;
@@ -500,6 +503,66 @@ public class Http {
          */
         boolean secure();
 
+        /**
+         * Get an attribute by its key or throw an exception if it's not
+         * present.
+         *
+         * Use this method if the attribute is expected to be present. If the
+         * attribute is optional then use {@link #getAttr(TypedKey)} instead.
+         *
+         * @param key The attribute key.
+         * @param <T> The type of attribute.
+         * @return The attribute value, if it exists.
+         * @throws NoSuchElementException If the attribute doesn't exist.
+         */
+        <T> T attr(TypedKey<T> key);
+
+        /**
+         * Get an optional attribute by its key.
+         *
+         * Use this method if the attribute is optional. If the attribute is
+         * always present then use {@link #attr(TypedKey)} instead.
+         *
+         * @param key The attribute key.
+         * @param <T> The type of attribute.
+         * @return An optional attribute value, present if it exists, absent otherwise.
+         */
+        <T> Optional<T> getAttr(TypedKey<T> key);
+
+        /**
+         * Check if this object contains an attribute.
+         *
+         * @param key The attribute key to check for.
+         * @return True if the object contains the attribute, false otherwise.
+         */
+        boolean containsAttr(TypedKey<?> key);
+
+        /**
+         * Create a new version of this object with an attribute added to it.
+         *
+         * @param key The attribute key.
+         * @param value The new attribute value.
+         * @param <T> The type of attribute.
+         * @return The new version of this object with the attribute added.
+         */
+        <T> RequestHeader withAttr(TypedKey<T> key, T value);
+
+        /**
+         * Create a new version of this object with several attributes added to it.
+         *
+         * @param entries The new attributes to add.
+         * @return The new version of this object with the attributes added.
+         */
+        RequestHeader withAttrs(TypedEntry<?> ...entries);
+
+        /**
+         * Attach a body to this header.
+         *
+         * @param body The body to attach.
+         * @return A new request with the body attached to the header.
+         */
+        Request withBody(RequestBody body);
+
         /**
          * The request host.
          *
@@ -613,7 +676,9 @@ public class Http {
 
         /**
          * @return the tags for the request
+         * @deprecated Use <code>attr</code>, <code>withAttr</code>, etc.
          */
+        @Deprecated
         Map<String, String> tags();
 
         /**
@@ -636,29 +701,28 @@ public class Http {
          */
         RequestBody body();
 
+        Request withBody(RequestBody body);
+
+        <T> Request withAttr(TypedKey<T> key, T value);
+        Request withAttrs(TypedEntry<?> ...entries);
+
         /**
          * The user name for this request, if defined.
          * This is usually set by annotating your Action with <code>@Authenticated</code>.
          *
          * @return the username
+         * @deprecated As of release 2.6, use <code>attr(Security.USERNAME)</code> or <code>getAttr(Security.USERNAME)</code>.
          */
-        String username();
-
-        /**
-         * Defines the user name for this request.
-         *
-         * @deprecated As of release 2.4, use {@link #withUsername}
-         * @param username Deprecated
-         */
-        @Deprecated void setUsername(String username);
+        @Deprecated String username();
 
         /**
          * Returns a request updated with specified user name
          *
          * @param username the new user name
          * @return a copy of the request containing the specified user name
+         * @deprecated As of release 2.6, use <code>withAttr(Security.USERNAME, username)</code>.
          */
-        Request withUsername(String username);
+        @Deprecated Request withUsername(String username);
 
         /**
          * For internal Play-use only
@@ -671,18 +735,14 @@ public class Http {
     /**
      * An HTTP request.
      */
-    public static class RequestImpl extends play.core.j.RequestHeaderImpl implements Request {
-
-        private final play.api.mvc.Request<RequestBody> underlying;
-        private String username; // Keep it non-final until setUsername is removed
+    public static class RequestImpl extends play.core.j.RequestImpl {
 
         /**
          * Constructor only based on a header.
          * @param header the header from a request
          */
         public RequestImpl(play.api.mvc.RequestHeader header) {
-            super(header);
-            this.underlying = null;
+            super(header.withBody(null));
         }
 
         /**
@@ -691,68 +751,7 @@ public class Http {
          */
         public RequestImpl(play.api.mvc.Request<RequestBody> request) {
             super(request);
-            this.underlying = request;
-        }
-
-        /**
-         * Constructor with a request and a username.
-         * @param request he body of the request
-         * @param username the user which is making the request
-         */
-        private RequestImpl(play.api.mvc.Request<RequestBody> request,
-                            String username) {
-
-            super(request);
-
-            this.underlying = request;
-            this.username = username;
-        }
-
-        /**
-         * @return the underlying body, if present otherwise null
-         */
-        public RequestBody body() {
-            return underlying != null ? underlying.body() : null;
         }
-
-        /**
-         * @return whether the underlying request has a body.
-         */
-        public boolean hasBody() {
-            return underlying != null && underlying.hasBody();
-        }
-
-        /**
-         * @return the username
-         */
-        public String username() {
-            return username;
-        }
-
-        /**
-         * Sets the username.
-         * @param username the username of the requester
-         */
-        public void setUsername(String username) {
-            this.username = username;
-        }
-
-        /**
-         * This method returns a new request, based on the current underlying with a giving username.
-         * @param username the new user name
-         * @return a new request with a request body based on the current request
-         */
-        public Request withUsername(String username) {
-            return new RequestImpl(this.underlying, username);
-        }
-
-        /**
-         * @return the underlying body of the request
-         */
-        public play.api.mvc.Request<RequestBody> _underlyingRequest() {
-            return underlying;
-        }
-
     }
 
     /**
@@ -783,18 +782,24 @@ public class Http {
         }
 
         /**
-         * @return the username
+         * Get the username. This method calls <code>getAttr(Security.USERNAME)</code>.
+         * @return the username or null
+         * @deprecated Use <code>attr(Security.USERNAME)</code> or <code>getAttr(Security.USERNAME)</code> instead.
          */
+        @Deprecated
         public String username() {
-            return username;
+            return getAttr(Security.USERNAME).orElse(null);
         }
 
         /**
+         * Set the username. This method calls <code>putAttr(Security.USERNAME, username)</code>.
          * @param username the username for the request
          * @return the modified builder
+         * @deprecated Use <code>putAttr(Security.USERNAME, username)</code> instead.
          */
+        @Deprecated
         public RequestBuilder username(String username) {
-            this.username = username;
+            putAttr(Security.USERNAME, username);
             return this;
         }
 
@@ -964,8 +969,7 @@ public class Http {
          * @return a build of the given parameters
          */
         public RequestImpl build() {
-            return new RequestImpl(new play.api.mvc.RequestImpl(
-                body(),
+            play.api.mvc.Request<RequestBody> underlyingRequest = new play.api.mvc.RequestImpl(
                 id,
                 asScala(tags()),
                 uri.toString(),
@@ -976,7 +980,13 @@ public class Http {
                 buildHeaders(),
                 remoteAddress,
                 secure,
-                OptionConverters.toScala(clientCertificateChain.map(lst -> scala.collection.JavaConversions.asScalaBuffer(lst).toSeq()))));
+                OptionConverters.toScala(clientCertificateChain.map(lst -> scala.collection.JavaConversions.asScalaBuffer(lst).toSeq())),
+                TypedMap.empty(),
+                body()
+            );
+            // Cast below is needed because Java doesn't pick up type properly
+            underlyingRequest = (play.api.mvc.Request<RequestBody>) underlyingRequest.withAttrs(attrs.entries());
+            return new RequestImpl(underlyingRequest);
         }
 
         // -------------------
@@ -984,6 +994,7 @@ public class Http {
 
         protected Long id = RequestIdProvider.requestIDs().incrementAndGet();
         protected Map<String, String> tags = new HashMap<>();
+        protected TypedMap attrs = TypedMap.empty();
         protected String method;
         protected boolean secure;
         protected URI uri;
@@ -1008,8 +1019,52 @@ public class Http {
             return this;
         }
 
+        /**
+         * Get the attribute for the given key.
+         *
+         * @param key The key of the attribute.
+         * @param <T> The type of the attribute.
+         * @return The attribute value, if present.
+         * @throws NoSuchElementException If the attribute is missing.
+         */
+        <T> T attr(TypedKey<T> key) {
+            return attrs.apply(key);
+        }
+
+        /**
+         * Get the attribute for the given key.
+         *
+         * @param key The key of the attribute.
+         * @param <T> The type of the attribute.
+         * @return An optional attribute value.
+         */
+        <T> Optional<T> getAttr(TypedKey<T> key) {
+            return OptionConverters.toJava(attrs.get(key));
+        }
+
+        /**
+         * Add an attribute to the request.
+         *
+         * @param key The key of the attribute to add.
+         * @param value The value of the attribute to add.
+         * @param <T> The type of the attribute to add.
+         */
+        <T> void putAttr(TypedKey<T> key, T value) {
+            attrs = attrs.updated(key, value);
+        }
+
+        /**
+         * Add several attributes to the request.
+         *
+         * @param entries The attribute entries to add.
+         */
+        void putAttrs(TypedEntry<?> ...entries) {
+            attrs = attrs.withEntries(entries);
+        }
+
         /**
          * @return the tags for the request
+         * @deprecated Use <code>attr</code> or <code>getAttr</code> instead.
          */
         public Map<String, String> tags() {
             return tags;
@@ -1018,7 +1073,9 @@ public class Http {
         /**
          * @param tags overwrites the tags for this request
          * @return the builder instance
+         * @deprecated Use <code>putAttrs</code> instead.
          */
+        @Deprecated
         public RequestBuilder tags(Map<String, String> tags) {
             this.tags = tags;
             return this;
@@ -1029,7 +1086,9 @@ public class Http {
          * @param key the key for the tag
          * @param value the value for the tag
          * @return the builder
+         * @deprecated Use <code>putAttr</code> instead.
          */
+        @Deprecated
         public RequestBuilder tag(String key, String value) {
             tags.put(key, value);
             return this;
diff --git a/framework/src/play/src/main/java/play/mvc/Security.java b/framework/src/play/src/main/java/play/mvc/Security.java
index 9e5dcd540d..4230dbe653 100644
--- a/framework/src/play/src/main/java/play/mvc/Security.java
+++ b/framework/src/play/src/main/java/play/mvc/Security.java
@@ -3,6 +3,8 @@
  */
 package play.mvc;
 
+import play.api.libs.typedmap.TypedKey;
+import play.api.libs.typedmap.TypedKeyFactory;
 import play.inject.Injector;
 import play.mvc.Http.*;
 
@@ -16,6 +18,8 @@ import javax.inject.Inject;
  */
 public class Security {
 
+    public static final TypedKey<String> USERNAME = TypedKeyFactory.create("username");
+
     /**
      * Wraps the annotated action in an <code>AuthenticatedAction</code>.
      */
@@ -48,15 +52,9 @@ public class Security {
                 Result unauthorized = authenticator.onUnauthorized(ctx);
                 return CompletableFuture.completedFuture(unauthorized);
             } else {
-                try {
-                    ctx.request().setUsername(username);
-                    return delegate.call(ctx).whenComplete(
-                        (result, error) -> ctx.request().setUsername(null)
-                    );
-                } catch (Exception e) {
-                    ctx.request().setUsername(null);
-                    throw e;
-                }
+                Request usernameReq = ctx.request().withAttr(USERNAME, username);
+                Context usernameCtx = ctx.withRequest(usernameReq);
+                return delegate.call(usernameCtx);
             }
         }
 
diff --git a/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala b/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
index b5bae579fd..94e21c3ef9 100644
--- a/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
+++ b/framework/src/play/src/main/scala/play/api/http/HttpRequestHandler.scala
@@ -14,6 +14,8 @@ import play.api.{ Configuration, Environment }
 import play.core.j.{ JavaHandler, JavaHandlerComponents, JavaHttpRequestHandlerDelegate }
 import play.utils.Reflect
 
+import scala.annotation.tailrec
+
 /**
  * Primary entry point for all HTTP requests on Play applications.
  */
@@ -105,39 +107,48 @@ class DefaultHttpRequestHandler(router: Router, errorHandler: HttpErrorHandler,
       (path.startsWith(context) && (path.length == context.length || path.charAt(context.length) == '/'))
   }
 
-  def handlerForRequest(request: RequestHeader) = {
+  override def handlerForRequest(request: RequestHeader): (RequestHeader, Handler) = {
 
+    /**
+     * An action for a 404 error.
+     */
     def notFoundHandler = Action.async(BodyParsers.parse.empty)(req =>
       errorHandler.onClientError(req, NOT_FOUND)
     )
 
-    val (routedRequest, handler) = routeRequest(request) map {
-      case handler: RequestTaggingHandler => (handler.tagRequest(request), handler)
-      case otherHandler => (request, otherHandler)
-    } getOrElse {
-
-      // We automatically permit HEAD requests against any GETs without the need to
-      // add an explicit mapping in Routes
-      request.method match {
-        case HttpVerbs.HEAD =>
-          routeRequest(request.copy(method = HttpVerbs.GET)) match {
-            case Some(action: EssentialAction) => action match {
-              case handler: RequestTaggingHandler => (handler.tagRequest(request), action)
-              case _ => (request, action)
-            }
-            case None => (request, notFoundHandler)
-          }
-        case _ =>
-          (request, notFoundHandler)
+    /**
+     * Call the router to get the handler, but with a couple of types of fallback.
+     * First, if a HEAD request isn't explicitly routed try routing it as a GET
+     * request. Second, if no routing information is present, fall back to a 404
+     * error.
+     */
+    def routeWithFallback(request: RequestHeader): Handler = {
+      routeRequest(request) match {
+        case Some(handler) => handler
+        // We automatically permit HEAD requests against any GETs without the need to
+        // add an explicit mapping in Routes. Since we couldn't route the HEAD request,
+        // try to get a Handler for the equivalent GET request instead. Note: the handler
+        // returned will still be passed a HEAD request when it is actually evaluated.
+        case None if request.method == HttpVerbs.HEAD => routeWithFallback(request.copy(method = HttpVerbs.GET))
+        case None => notFoundHandler
       }
     }
 
-    (routedRequest, filterHandler(rh => handler)(routedRequest))
+    // 1. Query the router to get a handler
+    // 2. Resolve handlers that preprocess the request
+    // 3. Modify the handler to do filtering, if necessary
+    // 4. Again resolve any handlers that do preprocessing
+    val routedHandler = routeWithFallback(request)
+    val (preprocessedRequest, preprocessedHandler) = Handler.applyStages(request, routedHandler)
+    val filteredHandler = filterHandler(preprocessedRequest, preprocessedHandler)
+    val (preprocessedPreprocessedRequest, preprocessedFilteredHandler) = Handler.applyStages(preprocessedRequest, filteredHandler)
+    (preprocessedPreprocessedRequest, preprocessedFilteredHandler)
   }
 
   /**
    * Apply any filters to the given handler.
    */
+  @deprecated("Use filterHandler(RequestHeader, Handler) instead", "2.6.0")
   protected def filterHandler(next: RequestHeader => Handler): (RequestHeader => Handler) = {
     (request: RequestHeader) =>
       next(request) match {
@@ -146,6 +157,18 @@ class DefaultHttpRequestHandler(router: Router, errorHandler: HttpErrorHandler,
       }
   }
 
+  /**
+   * Update the given handler so that when the handler is run any filters will also be run. The
+   * default behavior is to wrap all [[EssentialAction]]s by calling `filterAction`, but to leave
+   * other kinds of handlers unchanged.
+   */
+  protected def filterHandler(request: RequestHeader, handler: Handler): Handler = {
+    handler match {
+      case action: EssentialAction if inContext(request.path) => filterAction(action)
+      case handler => handler
+    }
+  }
+
   /**
    * Apply filters to the given action.
    */
@@ -184,11 +207,26 @@ class JavaCompatibleHttpRequestHandler @Inject() (router: Router, errorHandler:
   configuration: HttpConfiguration, filters: HttpFilters, components: JavaHandlerComponents) extends DefaultHttpRequestHandler(router,
   errorHandler, configuration, filters.filters: _*) {
 
-  override def routeRequest(request: RequestHeader): Option[Handler] = {
-    super.routeRequest(request) match {
-      case Some(javaHandler: JavaHandler) =>
-        Some(javaHandler.withComponents(components))
-      case other => other
+  // This is a Handler that, when evaluated, converts its underlying JavaHandler into
+  // another handler.
+  private class MapJavaHandler(nextHandler: Handler) extends Handler.Stage {
+    override def apply(requestHeader: RequestHeader): (RequestHeader, Handler) = {
+      // First, preprocess the request and our handler so we can get the underlying handler
+      val (preprocessedRequest, preprocessedHandler) = Handler.applyStages(requestHeader, nextHandler)
+
+      // Next, if the underlying handler is a JavaHandler, get its real handler
+      val mappedHandler: Handler = preprocessedHandler match {
+        case javaHandler: JavaHandler => javaHandler.withComponents(components)
+        case other => other
+      }
+
+      (preprocessedRequest, mappedHandler)
     }
   }
-}
+
+  override def routeRequest(request: RequestHeader): Option[Handler] = {
+    // Override the usual routing logic so that any JavaHandlers are
+    // rewritten.
+    super.routeRequest(request).map(new MapJavaHandler(_))
+  }
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/libs/typedmap/TypedMap.scala b/framework/src/play/src/main/scala/play/api/libs/typedmap/TypedMap.scala
new file mode 100644
index 0000000000..d547d08eee
--- /dev/null
+++ b/framework/src/play/src/main/scala/play/api/libs/typedmap/TypedMap.scala
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2009-2016 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.api.libs.typedmap
+
+import scala.annotation.varargs
+import scala.collection.immutable
+
+/**
+ * A TypedMap is an immutable map containing typed values. Each entry is
+ * associated with a [[TypedKey]] that can be used to look up the value. A
+ * `TypedKey` also defines the type of the value, e.g. a `TypedKey[String]`
+ * would be associated with a `String` value.
+ *
+ * Instances of this class are created with the `TypedMap.empty` method.
+ *
+ * @param m The map used to store values.
+ */
+final class TypedMap private (m: immutable.Map[TypedKey[_], Any]) {
+  /**
+   * Get a value from the map.
+   *
+   * @param key The key for the value to retrieve.
+   * @tparam A The type of value to retrieve.
+   * @return The value, if it is present in the map.
+   * @throws NoSuchElementException If the value isn't present in the map.
+   */
+  def apply[A](key: TypedKey[A]): A = m.apply(key).asInstanceOf[A]
+
+  /**
+   * Get a value from the map.
+   *
+   * @param key The key for the value to retrieve.
+   * @tparam A The type of value to retrieve.
+   * @return `Some` value, if it is present in the map, otherwise `None`.
+   */
+  def get[A](key: TypedKey[A]): Option[A] = m.get(key).asInstanceOf[Option[A]]
+
+  /**
+   * Check if the map contains a value with the given key.
+   *
+   * @param key The key to check for.
+   * @return True if the value is present, false otherwise.
+   */
+  def contains(key: TypedKey[_]): Boolean = m.contains(key)
+
+  /**
+   * Update the map with the given key and value, returning a new instance of the map.
+   *
+   * @param key The key to set.
+   * @param value The value to use.
+   * @tparam A The type of value.
+   * @return A new instance of the map with the new entry added.
+   */
+  def updated[A](key: TypedKey[A], value: A): TypedMap = new TypedMap(m.updated(key, value))
+
+  /**
+   * Update the map with several entries, returning a new instance of the map.
+   *
+   * @param entries The new entries to add to the map.
+   * @return A new instance of the map with the new entries added.
+   */
+  def +(entries: TypedEntry[_]*): TypedMap = {
+    val m2 = entries.foldLeft(m) {
+      case (m1, e) => m1.updated(e.key, e.value)
+    }
+    new TypedMap(m2)
+  }
+
+  /**
+   * Update the map with several entries, returning a new instance of the map.
+   *
+   * This is a variant of the `+`, provided for use from Java.
+   *
+   * @param entries The new entries to add to the map.
+   * @return A new instance of the map with the new entries added.
+   */
+  @varargs
+  def withEntries(entries: TypedEntry[_]*): TypedMap = this + (entries: _*)
+
+  /**
+   * Gets the entries present in this map.
+   */
+  def entries: immutable.Seq[TypedEntry[_]] = {
+    // Use local function to capture type of key
+    def makeEntry[A](key: TypedKey[A], value: Any): TypedEntry[_] = {
+      key.bindValue(value.asInstanceOf[A])
+    }
+    m.map { case (key, value) => makeEntry(key, value) }.to[immutable.Seq]
+  }
+
+  override def toString: String = m.mkString
+}
+
+object TypedMap {
+
+  /**
+   * The empty [[TypedMap]] instance.
+   */
+  val empty = new TypedMap(immutable.Map.empty)
+
+  /**
+   * Builds a [[TypedMap]] from a list of keys and values.
+   */
+  def apply(entries: TypedEntry[_]*): TypedMap = {
+    TypedMap.empty.+(entries: _*)
+  }
+  /**
+   * Builds a [[TypedMap]] from a list of entries (key/value pairs). This method
+   * is like `apply` but it can be used in varargs style from Java.
+   */
+  @varargs def withEntries(entries: TypedEntry[_]*): TypedMap = {
+    apply(entries: _*)
+  }
+}
+
+/**
+ * A TypedKey is a key that can be used to get and set values in a
+ * [[TypedMap]] or any object with typed keys. This class uses reference
+ * equality for comparisons, so each new instance is different key.
+ *
+ * @param displayName The name to display for this key or `null` if
+ * no display name has been provided. This name is only used for debugging.
+ * Keys with the same name are considered different keys.
+ * @tparam A The type of values associated with this key.
+ */
+final class TypedKey[A] private (val displayName: Option[String]) {
+
+  /**
+   * Bind this key to a value. This is equivalent to the `->` operator.
+   *
+   * @param value The value to bind this key to.
+   * @return A bound value.
+   */
+  def bindValue(value: A): TypedEntry[A] = TypedEntry(this, value)
+
+  /**
+   * Bind this key to a value. Equivalent to [[bindValue]].
+   *
+   * @param value The value to bind.
+   * @return An entry binding this key to a value of the right type.
+   */
+  def ->(value: A): TypedEntry[A] = bindValue(value)
+
+  override def toString: String = displayName.getOrElse(super.toString)
+}
+
+/**
+ * Helper for working with `TypedKey`s.
+ */
+object TypedKey {
+
+  /**
+   * Creates a [[TypedKey]] without a name.
+   *
+   * @tparam A The type of value this key is associated with.
+   * @return A fresh key.
+   */
+  def apply[A]: TypedKey[A] = new TypedKey[A](None)
+
+  /**
+   * Creates a [[TypedKey]] with the given name.
+   *
+   * @param displayName The name to display when printing this key.
+   * @tparam A The type of value this key is associated with.
+   * @return A fresh key.
+   */
+  def apply[A](displayName: String): TypedKey[A] = new TypedKey[A](Some(displayName))
+}
+
+/**
+ * A factory for creating [[TypedKey]]s. Usable from Java.
+ */
+// This class is usable from Java. It will probably not be needed
+// once we upgrade to Scala 2.12 which will support Java 8's ability
+// to add static methods to interfaces.
+object TypedKeyFactory {
+  /**
+   * Creates a [[TypedKey]] without a name.
+   *
+   * @tparam A The type of value this key is associated with.
+   * @return A fresh key.
+   */
+  def create[A](): TypedKey[A] = TypedKey.apply[A];
+
+  /**
+   * Creates a [[TypedKey]] with the given name.
+   *
+   * @param displayName The name to display when printing this key.
+   * @tparam A The type of value this key is associated with.
+   * @return A fresh key.
+   */
+  def create[A](displayName: String): TypedKey[A] = TypedKey.apply(displayName);
+}
+
+/**
+ * An entry that binds a typed key and a value. These entries can be
+ * placed into a [[TypedMap]] or any other type of object with typed
+ * values.
+ *
+ * @param key The key for this entry.
+ * @param value The value for this entry.
+ * @tparam A The type of the value.
+ */
+final case class TypedEntry[A](key: TypedKey[A], value: A) {
+  /**
+   * Convert the entry into a standard pair.
+   */
+  def toPair: (TypedKey[A], A) = (key, value)
+}
diff --git a/framework/src/play/src/main/scala/play/api/mvc/Action.scala b/framework/src/play/src/main/scala/play/api/mvc/Action.scala
index d8a82f851d..b6a11f70ec 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/Action.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/Action.scala
@@ -6,27 +6,10 @@ package play.api.mvc
 import akka.util.ByteString
 import play.api._
 import play.api.libs.streams.Accumulator
+
 import scala.concurrent._
 import scala.language.higherKinds
 
-/**
- * An Handler handles a request. Play understands several types of handlers,
- * for example `EssentialAction`s and `WebSocket`s.
- *
- * The `Handler` used to handle the request is controlled by `GlobalSetting`s's
- * `onRequestReceived` method. The default implementation of
- * `onRequestReceived` delegates to `onRouteRequest` which calls the default
- * `Router`.
- */
-trait Handler
-
-/**
- * A handler that is able to tag requests. Usually mixed in to other handlers.
- */
-trait RequestTaggingHandler extends Handler {
-  def tagRequest(request: RequestHeader): RequestHeader
-}
-
 /**
  * An `EssentialAction` underlies every `Action`. Given a `RequestHeader`, an
  * `EssentialAction` consumes the request body (an `ByteString`) and returns
diff --git a/framework/src/play/src/main/scala/play/api/mvc/Handler.scala b/framework/src/play/src/main/scala/play/api/mvc/Handler.scala
new file mode 100644
index 0000000000..f5feb63504
--- /dev/null
+++ b/framework/src/play/src/main/scala/play/api/mvc/Handler.scala
@@ -0,0 +1,83 @@
+package play.api.mvc
+
+import scala.annotation.tailrec
+
+/**
+ * An Handler handles a request. Play understands several types of handlers,
+ * for example `EssentialAction`s and `WebSocket`s.
+ *
+ * The `Handler` used to handle the request is controlled by `GlobalSetting`s's
+ * `onRequestReceived` method. The default implementation of
+ * `onRequestReceived` delegates to `onRouteRequest` which calls the default
+ * `Router`.
+ */
+trait Handler
+
+final object Handler {
+  /**
+   * Some handlers are built as a series of stages, with each stage returning
+   * a new [[RequestHeader]] and another stage, until eventually a terminal
+   * handler is returned. This method processes all stages in a handler, if any,
+   * returning a terminal handler such as `EssentialAction` or `WebSocket`.
+   *
+   * @param requestHeader The current RequestHeader.
+   * @param handler The input Handler.
+   * @return The new RequestHeader and Handler.
+   */
+  @tailrec
+  def applyStages(requestHeader: RequestHeader, handler: Handler): (RequestHeader, Handler) = handler match {
+    case m: Stage =>
+      // Call the ModifyRequest logic to get the new header and handler. The
+      // new handler could have its own modifications to apply to the header
+      // so we call `applyPreprocessingHandlers` recursively on the result.
+      val (newRequestHeader, newHandler) = m.apply(requestHeader)
+      applyStages(newRequestHeader, newHandler)
+    case t: RequestTaggingHandler =>
+      // Call the RequestTaggingHandler logic on this request. This handler
+      // will change the request header, but not the handler itself. Since the
+      // handler hasn't been changed we don't need to call
+      // `applyAllModifications` again. This means RequestTaggingHandlers can
+      // only be one level deep; they do not compose.
+      val newRequestHeader = t.tagRequest(requestHeader)
+      (newRequestHeader, handler)
+    case _ =>
+      // This is a normal handler that doesn't do any preprocessing.
+      (requestHeader, handler)
+  }
+
+  /**
+   * A special type of [[Handler]] which allows custom logic to be inserted
+   * during handling. A `Stage` accepts a `RequestHeader` then returns a new
+   * `RequestHeader` along with the next `Handler` to use during request
+   * handling. The next handler could be a terminal `Handler` like an
+   * [[EssentialAction]], but it could also be another `Stage`. This means
+   * it's possible to chains of `Stage`s that should each be executed in turn.
+   * To automatically execute all `Stage`s you can call [[Handler.applyStages()]].
+   */
+  trait Stage extends Handler {
+    def apply(requestHeader: RequestHeader): (RequestHeader, Handler)
+  }
+
+  object Stage {
+    /**
+     * Create a `Stage` that modifies the request before calling the next handler.
+     */
+    def modifyRequest(modifyRequestFunc: RequestHeader => RequestHeader, wrappedHandler: Handler): Handler.Stage = new Stage {
+      override def apply(requestHeader: RequestHeader): (RequestHeader, Handler) = (modifyRequestFunc(requestHeader), wrappedHandler)
+    }
+  }
+}
+
+/**
+ * A handler that is able to tag requests. Usually mixed in to other handlers.
+ *
+ * Instead of using the handler you should use [[Handler.Stage]].
+ * `Handler.Stage` is a handler improves upon the `RequestTaggingHandler` in several ways:
+ * (a) `Handler.Stage` can be nested to arbitrary depth, (b) it doesn't require
+ * mixing-in and (c) it allows handlers to be rewritten as well as requests, (d) it
+ * prevents Play from accessing the real handler until its logic has been run.
+ */
+@deprecated("Use Handler.Stage instead", "2.6.0")
+trait RequestTaggingHandler extends Handler {
+  def tagRequest(request: RequestHeader): RequestHeader
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/mvc/Request.scala b/framework/src/play/src/main/scala/play/api/mvc/Request.scala
index d4d053e518..3ca02d996b 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/Request.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/Request.scala
@@ -5,6 +5,8 @@ package play.api.mvc
 
 import java.security.cert.X509Certificate
 
+import play.api.libs.typedmap.{ TypedEntry, TypedKey, TypedMap }
+
 import scala.annotation.{ implicitNotFound, tailrec }
 
 /**
@@ -38,45 +40,32 @@ trait Request[+A] extends RequestHeader {
   /**
    * Transform the request body.
    */
-  def map[B](f: A => B): Request[B] = new Request[B] {
-    override def id = self.id
-    override def tags = self.tags
-    override def uri = self.uri
-    override def path = self.path
-    override def method = self.method
-    override def version = self.version
-    override def queryString = self.queryString
-    override def headers = self.headers
-    override def remoteAddress = self.remoteAddress
-    override def secure = self.secure
-    override def clientCertificateChain = self.clientCertificateChain
+  def map[B](f: A => B): Request[B] = withBody(f(body))
 
-    override lazy val body = f(self.body)
-  }
+  // Override the return type of these RequestHeader methods
+  override def withAttr[T](key: TypedKey[T], value: T): Request[A]
+  override def withAttrs(entries: TypedEntry[_]*): Request[A]
 
 }
 
 object Request {
-
-  def apply[A](rh: RequestHeader, a: A): Request[A] = new Request[A] {
-    override def id = rh.id
-    override def tags = rh.tags
-    override def uri = rh.uri
-    override def path = rh.path
-    override def method = rh.method
-    override def version = rh.version
-    override def queryString = rh.queryString
-    override def headers = rh.headers
-    override lazy val remoteAddress = rh.remoteAddress
-    override lazy val secure = rh.secure
-    override val clientCertificateChain = rh.clientCertificateChain
-    override val body = a
-  }
+  /**
+   * Create a new Request from a RequestHeader and a body. The RequestHeader's
+   * methods aren't evaluated when this method is called.
+   */
+  def apply[A](rh: RequestHeader, body: A): Request[A] = rh.withBody(body)
 }
 
-/** Used by Java wrapper */
-private[play] class RequestImpl[A](
-    override val body: A,
+/**
+ * A standard implementation of a Request.
+ *
+ * @param remoteAddressFunc A function that evaluates to the remote address.
+ * @param secureFunc A function that evaluates to the security status.
+ * @param attrMap A map of the request's typed attributes.
+ * @param body The body of the request.
+ * @tparam A The type of the body content.
+ */
+private[play] class RequestImpl[+A](
     override val id: Long,
     override val tags: Map[String, String],
     override val uri: String,
@@ -85,7 +74,77 @@ private[play] class RequestImpl[A](
     override val version: String,
     override val queryString: Map[String, Seq[String]],
     override val headers: Headers,
-    override val remoteAddress: String,
-    override val secure: Boolean,
-    override val clientCertificateChain: Option[Seq[X509Certificate]]) extends Request[A] {
+    remoteAddressFunc: () => String,
+    secureFunc: () => Boolean,
+    override val clientCertificateChain: Option[Seq[X509Certificate]],
+    override protected val attrMap: TypedMap,
+    override val body: A) extends Request[A] with WithAttrMap[Request[A]] {
+
+  def this(
+    id: Long,
+    tags: Map[String, String],
+    uri: String,
+    path: String,
+    method: String,
+    version: String,
+    queryString: Map[String, Seq[String]],
+    headers: Headers,
+    remoteAddress: String,
+    secure: Boolean,
+    clientCertificateChain: Option[Seq[X509Certificate]],
+    attrMap: TypedMap,
+    body: A) = {
+    this(
+      id = id,
+      tags = tags,
+      uri = uri,
+      path = path,
+      method = method,
+      version = version,
+      queryString = queryString,
+      headers = headers,
+      remoteAddressFunc = () => remoteAddress,
+      secureFunc = () => secure,
+      clientCertificateChain = clientCertificateChain,
+      attrMap = attrMap,
+      body = body
+    )
+  }
+
+  override lazy val remoteAddress: String = remoteAddressFunc()
+  override lazy val secure: Boolean = secureFunc()
+
+  override protected def withAttrMap(newAttrMap: TypedMap): Request[A] = {
+    new RequestImpl[A](
+      id = id,
+      tags = tags,
+      uri = uri,
+      path = path,
+      method = method,
+      version = version,
+      queryString = queryString,
+      headers = headers,
+      remoteAddressFunc = () => remoteAddress,
+      secureFunc = () => secure,
+      clientCertificateChain = clientCertificateChain,
+      attrMap = newAttrMap,
+      body = body
+    )
+  }
+
+  override def withBody[B](newBody: B): Request[B] = new RequestImpl[B](
+    id = id,
+    tags = tags,
+    uri = uri,
+    path = path,
+    method = method,
+    version = version,
+    queryString = queryString,
+    headers = headers,
+    remoteAddressFunc = () => remoteAddress,
+    secureFunc = () => secure,
+    clientCertificateChain = clientCertificateChain,
+    attrMap = attrMap,
+    body = newBody
+  )
 }
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/mvc/RequestHeader.scala b/framework/src/play/src/main/scala/play/api/mvc/RequestHeader.scala
index 8d57efd32b..e881b5c431 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/RequestHeader.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/RequestHeader.scala
@@ -7,6 +7,7 @@ import java.security.cert.X509Certificate
 
 import play.api.http.{ HeaderNames, MediaRange, MediaType }
 import play.api.i18n.Lang
+import play.api.libs.typedmap.{ TypedEntry, TypedKey, TypedMap }
 
 import scala.annotation.implicitNotFound
 
@@ -24,6 +25,7 @@ trait RequestHeader {
   /**
    * The request Tags.
    */
+  @deprecated("Use attributes instead (e.g. attr(), getAttr(), withAttr(), etc)", "2.6.0")
   def tags: Map[String, String]
 
   /**
@@ -79,6 +81,58 @@ trait RequestHeader {
    */
   def clientCertificateChain: Option[Seq[X509Certificate]]
 
+  /**
+   * Get an attribute by its key or throw an exception if it's not
+   * present.
+   *
+   * Use this method if the attribute is expected to be present. If the
+   * attribute is optional then use [[getAttr()]] instead.
+   *
+   * @param key The attribute key.
+   * @tparam A The type of attribute.
+   * @return The attribute value, if it exists.
+   * @throws NoSuchElementException If the attribute doesn't exist.
+   */
+  def attr[A](key: TypedKey[A]): A
+
+  /**
+   * Get an optional attribute by its key.
+   *
+   * Use this method if the attribute is optional. If the attribute is
+   * always present then use [[attr()]] instead.
+   *
+   * @param key The attribute key.
+   * @tparam A The type of attribute.
+   * @return `Some` attribute value, if it exists, or `None` otherwise.
+   */
+  def getAttr[A](key: TypedKey[A]): Option[A]
+
+  /**
+   * Check if this object contains an attribute.
+   *
+   * @param key The attribute key to check for.
+   * @return True if the object contains the attribute, false otherwise.
+   */
+  def containsAttr(key: TypedKey[_]): Boolean
+
+  /**
+   * Create a new version of this object with an attribute added to it.
+   *
+   * @param key The attribute key.
+   * @param value The new attribute value.
+   * @tparam A The type of attribute.
+   * @return The new version of this object with the attribute added.
+   */
+  def withAttr[A](key: TypedKey[A], value: A): RequestHeader
+
+  /**
+   * Create a new version of this object with several attributes added to it.
+   *
+   * @param entries The new attributes to add.
+   * @return The new version of this object with the attributes added.
+   */
+  def withAttrs(entries: TypedEntry[_]*): RequestHeader
+
   // -- Computed
 
   /**
@@ -184,6 +238,15 @@ trait RequestHeader {
     copy(tags = tags + (tagName -> tagValue))
   }
 
+  /**
+   * Attach a body to this header.
+   *
+   * @param body The body to attach.
+   * @tparam A The type of the body.
+   * @return A new request with the body attached to the header.
+   */
+  def withBody[A](body: A): Request[A] = new RequestHeaderWithBody[A](this, body)
+
   /**
    * Copy the request.
    */
@@ -199,21 +262,20 @@ trait RequestHeader {
     remoteAddress: => String = this.remoteAddress,
     secure: => Boolean = this.secure,
     clientCertificateChain: Option[Seq[X509Certificate]] = this.clientCertificateChain): RequestHeader = {
-    val (_id, _tags, _uri, _path, _method, _version, _queryString, _headers, _remoteAddress, _secure, _clientCertificateChain, _hasBody) = (id, tags, uri, path, method, version, queryString, headers, () => remoteAddress, () => secure, clientCertificateChain, hasBody)
-    new RequestHeader {
-      override val id = _id
-      override val tags = _tags
-      override val uri = _uri
-      override val path = _path
-      override val method = _method
-      override val version = _version
-      override val queryString = _queryString
-      override val headers = _headers
-      override lazy val remoteAddress = _remoteAddress()
-      override lazy val secure = _secure()
-      override val clientCertificateChain = _clientCertificateChain
-      override val hasBody = _hasBody || super.hasBody
-    }
+    new RequestHeaderImpl(
+      id = id,
+      tags = tags,
+      uri = uri,
+      path = path,
+      method = method,
+      version = version,
+      queryString = queryString,
+      headers = headers,
+      remoteAddressFunc = () => remoteAddress,
+      secureFunc = () => secure,
+      clientCertificateChain = clientCertificateChain,
+      attrMap = TypedMap.empty
+    )
   }
 
   override def toString = {
@@ -243,6 +305,13 @@ object RequestHeader {
   }
 }
 
+/**
+ * A standard implementation of a RequestHeader.
+ *
+ * @param remoteAddressFunc A function that evaluates to the remote address.
+ * @param secureFunc A function that evaluates to the security status.
+ * @param attrMap A map of the RequestHeader's typed attributes.
+ */
 private[play] class RequestHeaderImpl(
     override val id: Long,
     override val tags: Map[String, String],
@@ -252,7 +321,142 @@ private[play] class RequestHeaderImpl(
     override val version: String,
     override val queryString: Map[String, Seq[String]],
     override val headers: Headers,
-    override val remoteAddress: String,
-    override val secure: Boolean,
-    override val clientCertificateChain: Option[Seq[X509Certificate]]) extends RequestHeader {
-}
\ No newline at end of file
+    remoteAddressFunc: () => String,
+    secureFunc: () => Boolean,
+    override val clientCertificateChain: Option[Seq[X509Certificate]],
+    override protected val attrMap: TypedMap) extends RequestHeader with WithAttrMap[RequestHeader] {
+
+  def this(
+    id: Long,
+    tags: Map[String, String],
+    uri: String,
+    path: String,
+    method: String,
+    version: String,
+    queryString: Map[String, Seq[String]],
+    headers: Headers,
+    remoteAddress: String,
+    secure: Boolean,
+    clientCertificateChain: Option[Seq[X509Certificate]],
+    attrMap: TypedMap) = {
+    this(
+      id = id,
+      tags = tags,
+      uri = uri,
+      path = path,
+      method = method,
+      version = version,
+      queryString = queryString,
+      headers = headers,
+      remoteAddressFunc = () => remoteAddress,
+      secureFunc = () => secure,
+      clientCertificateChain = clientCertificateChain,
+      attrMap = attrMap
+    )
+  }
+
+  override lazy val remoteAddress: String = remoteAddressFunc()
+  override lazy val secure: Boolean = secureFunc()
+
+  override protected def withAttrMap(newAttrMap: TypedMap): RequestHeaderImpl = {
+    new RequestHeaderImpl(
+      id = id,
+      tags = tags,
+      uri = uri,
+      path = path,
+      method = method,
+      version = version,
+      queryString = queryString,
+      headers = headers,
+      remoteAddressFunc = () => remoteAddress,
+      secureFunc = () => secure,
+      clientCertificateChain = clientCertificateChain,
+      attrMap = newAttrMap
+    )
+  }
+}
+
+/**
+ * Mixin to help build a RequestHeader that has attributes. This mixin
+ * assumes the attributes are stored in a TypedMap.
+ *
+ * @tparam Repr The type of object to return when a copy is made.
+ */
+private[play] trait WithAttrMap[+Repr <: RequestHeader] {
+  self: RequestHeader =>
+
+  /**
+   * The TypeMap holding this RequestHeader's attributes.
+   */
+  protected def attrMap: TypedMap
+
+  /**
+   * Create a new instance with a new set of attributes.
+   */
+  protected def withAttrMap(newAttrMap: TypedMap): Repr
+
+  // Mixin methods
+
+  override def attr[A](key: TypedKey[A]): A =
+    attrMap.apply(key)
+  override def getAttr[A](key: TypedKey[A]): Option[A] =
+    attrMap.get(key)
+  override def withAttr[A](key: TypedKey[A], value: A): Repr =
+    withAttrMap(attrMap.updated(key, value))
+  override def containsAttr(key: TypedKey[_]): Boolean =
+    attrMap.contains(key)
+  override def withAttrs(entries: TypedEntry[_]*): Repr =
+    withAttrMap(attrMap.+(entries: _*))
+}
+
+/**
+ * A Request formed from a RequestHeader and a body value. Most methods are delegated
+ * to the RequestHeader. This means that creating this object is very cheap because it
+ * doesn't evaluate any of the RequestHeader methods when it's constructed.
+ */
+private[play] class RequestHeaderWithBody[+A](
+    private[RequestHeaderWithBody] val rh: RequestHeader,
+    override val body: A) extends Request[A] {
+  override def id = rh.id
+  override def tags = rh.tags
+  override def headers = rh.headers
+  override def queryString = rh.queryString
+  override def path = rh.path
+  override def uri = rh.uri
+  override def method = rh.method
+  override def version = rh.version
+  override def remoteAddress = rh.remoteAddress
+  override def secure = rh.secure
+  override def clientCertificateChain = rh.clientCertificateChain
+
+  override def withBody[B](newBody: B): Request[B] = this match {
+    case wrapper: RequestHeaderWithBody[_] => new RequestHeaderWithBody(wrapper.rh, newBody)
+    case _ => new RequestHeaderWithBody(rh, newBody)
+  }
+  override def withAttr[B](key: TypedKey[B], value: B): Request[A] = new RequestHeaderWithBody(rh.withAttr(key, value), body)
+  override def withAttrs(entries: TypedEntry[_]*): Request[A] = new RequestHeaderWithBody(rh.withAttrs(entries: _*), body)
+  override def getAttr[A](key: TypedKey[A]): Option[A] = rh.getAttr(key)
+  override def attr[A](key: TypedKey[A]): A = rh.attr(key)
+  override def containsAttr(key: TypedKey[_]): Boolean = rh.containsAttr(key)
+}
+
+/**
+ * A Request formed from a RequestHeader and a new set of attributes. Most methods are delegated
+ * to the RequestHeader. This means that creating this object is very cheap because it
+ * doesn't evaluate any of the RequestHeader methods when it's constructed.
+ */
+private[play] class RequestHeaderWithAttributes(rh: RequestHeader, override val attrMap: TypedMap)
+    extends RequestHeader with WithAttrMap[RequestHeader] {
+  override def id = rh.id
+  override def tags = rh.tags
+  override def headers = rh.headers
+  override def queryString = rh.queryString
+  override def path = rh.path
+  override def uri = rh.uri
+  override def method = rh.method
+  override def version = rh.version
+  override def remoteAddress = rh.remoteAddress
+  override def secure = rh.secure
+  override def clientCertificateChain = rh.clientCertificateChain
+  override protected def withAttrMap(newAttrMap: TypedMap): RequestHeader = new RequestHeaderWithAttributes(rh, newAttrMap)
+}
diff --git a/framework/src/play/src/main/scala/play/api/mvc/Security.scala b/framework/src/play/src/main/scala/play/api/mvc/Security.scala
index 44966d8764..da0b000146 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/Security.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/Security.scala
@@ -91,7 +91,9 @@ object Security {
    *
    * @param user The user that made the request
    */
-  class AuthenticatedRequest[A, U](val user: U, request: Request[A]) extends WrappedRequest[A](request)
+  class AuthenticatedRequest[A, U](val user: U, request: Request[A]) extends WrappedRequest[A](request) {
+    override protected def newWrapper[B](newRequest: Request[B]): AuthenticatedRequest[B, U] = new AuthenticatedRequest[B, U](user, newRequest)
+  }
 
   /**
    * An authenticated action builder.
diff --git a/framework/src/play/src/main/scala/play/api/mvc/WrappedRequest.scala b/framework/src/play/src/main/scala/play/api/mvc/WrappedRequest.scala
index bddd0b6733..41ac7c660f 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/WrappedRequest.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/WrappedRequest.scala
@@ -3,8 +3,14 @@
  */
 package play.api.mvc
 
+import play.api.libs.typedmap.{ TypedEntry, TypedKey }
+
 /**
  * Wrap an existing request. Useful to extend a request.
+ *
+ * If you need to add extra values to a request, you could consider
+ * using request attributes instead. See the `attr`, `withAttr`, etc
+ * methods.
  */
 class WrappedRequest[+A](request: Request[A]) extends Request[A] {
   override def id = request.id
@@ -19,4 +25,17 @@ class WrappedRequest[+A](request: Request[A]) extends Request[A] {
   override def remoteAddress = request.remoteAddress
   override def secure = request.secure
   override def clientCertificateChain = request.clientCertificateChain
+
+  /**
+   * Create a copy of this wrapper, but wrapping a new request.
+   * Subclasses can override this method.
+   */
+  protected def newWrapper[B](newRequest: Request[B]): WrappedRequest[B] = new WrappedRequest[B](newRequest)
+
+  override def withBody[B](body: B): WrappedRequest[B] = newWrapper(request.withBody(body))
+  override def withAttr[B](key: TypedKey[B], value: B): WrappedRequest[A] = newWrapper(request.withAttr(key, value))
+  override def withAttrs(entries: TypedEntry[_]*): WrappedRequest[A] = newWrapper(request.withAttrs(entries: _*))
+  override def getAttr[A](key: TypedKey[A]): Option[A] = request.getAttr(key)
+  override def attr[A](key: TypedKey[A]): A = request.attr(key)
+  override def containsAttr(key: TypedKey[_]): Boolean = request.containsAttr(key)
 }
diff --git a/framework/src/play/src/main/scala/play/api/routing/Router.scala b/framework/src/play/src/main/scala/play/api/routing/Router.scala
index 1223156fc0..b9d1d8a5eb 100644
--- a/framework/src/play/src/main/scala/play/api/routing/Router.scala
+++ b/framework/src/play/src/main/scala/play/api/routing/Router.scala
@@ -3,9 +3,11 @@
  */
 package play.api.routing
 
-import play.api.{ Configuration, Environment }
-import play.api.mvc.{ RequestHeader, Handler }
+import play.api.libs.typedmap.TypedKey
+import play.api.{Configuration, Environment}
+import play.api.mvc.{Handler, RequestHeader}
 import play.core.j.JavaRouterAdapter
+import play.core.routing.HandlerDef
 import play.utils.Reflect
 
 /**
@@ -72,17 +74,29 @@ object Router {
     }
   }
 
+  /**
+   * The [[RequestHeader]] attribute key used to access the routing
+   * [[HandlerDef]] used to handle the request.
+   */
+  val HandlerDefAttr = TypedKey[HandlerDef]("HandlerDef")
+
   /** Tags that are added to requests by the router. */
+  @deprecated("Use HandlerDefAttr instead", "2.6.0")
   object Tags {
     /** The verb that the router matched */
+    @deprecated("Use HandlerDefAttr instead", "2.6.0")
     val RouteVerb = "ROUTE_VERB"
     /** The pattern that the router used to match the path */
+    @deprecated("Use HandlerDefAttr instead", "2.6.0")
     val RoutePattern = "ROUTE_PATTERN"
     /** The controller that was routed to */
+    @deprecated("Use HandlerDefAttr instead", "2.6.0")
     val RouteController = "ROUTE_CONTROLLER"
     /** The method on the controller that was invoked */
+    @deprecated("Use HandlerDefAttr instead", "2.6.0")
     val RouteActionMethod = "ROUTE_ACTION_METHOD"
     /** The comments in the routes file that were above the route */
+    @deprecated("Use HandlerDefAttr instead", "2.6.0")
     val RouteComments = "ROUTE_COMMENTS"
   }
 
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
index 868d1fa50c..99ab43e178 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
@@ -3,17 +3,22 @@
  */
 package play.core.j
 
+import java.util.Optional
 import java.util.concurrent.CompletionStage
 
+import play.api.libs.typedmap.{ TypedEntry, TypedKey }
 import play.core.Execution.Implicits.trampoline
 import play.api.mvc._
+import play.mvc
 import play.mvc.{ Result => JResult }
-import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestImpl => JRequestImpl, RequestHeader => JRequestHeader, Cookies => JCookies, Cookie => JCookie }
+import play.mvc.Http.{ Context => JContext, Cookie => JCookie, Cookies => JCookies, Request => JRequest, RequestHeader => JRequestHeader, RequestImpl => JRequestImpl }
 import play.mvc.Http.RequestBody
+import play.mvc.Security
 
 import scala.compat.java8.{ FutureConverters, OptionConverters }
 import scala.concurrent.Future
 import collection.JavaConverters._
+import collection.JavaConversions._
 
 /**
  * Provides helper methods that manage Java to Scala Result and Scala to Java Context
@@ -21,6 +26,10 @@ import collection.JavaConverters._
  */
 trait JavaHelpers {
 
+  def attrsToScalaSeq(attrs: java.util.List[TypedEntry[_]]): Seq[TypedEntry[_]] = {
+    asScalaBuffer(attrs)
+  }
+
   def cookiesToScalaCookies(cookies: java.lang.Iterable[play.mvc.Http.Cookie]): Seq[Cookie] = {
     cookies.asScala.toSeq map { c =>
       Cookie(c.name, c.value,
@@ -163,7 +172,7 @@ object JavaHelpers extends JavaHelpers
 
 class RequestHeaderImpl(header: RequestHeader) extends JRequestHeader {
 
-  def _underlyingHeader = header
+  override def _underlyingHeader: RequestHeader = header
 
   def uri = header.uri
 
@@ -175,6 +184,16 @@ class RequestHeaderImpl(header: RequestHeader) extends JRequestHeader {
 
   def secure = header.secure
 
+  override def attr[A](key: TypedKey[A]): A = header.attr(key)
+  override def getAttr[A](key: TypedKey[A]): Optional[A] = OptionConverters.toJava(header.getAttr(key))
+  override def containsAttr(key: TypedKey[_]): Boolean = header.containsAttr(key)
+  override def withAttr[A](key: TypedKey[A], value: A): JRequestHeader =
+    new RequestHeaderImpl(header.withAttr(key, value))
+  override def withAttrs(entries: TypedEntry[_]*): JRequestHeader =
+    new RequestHeaderImpl(header.withAttrs(entries: _*))
+
+  def withBody(body: RequestBody): JRequest = new JRequestImpl(header.withBody(body))
+
   def host = header.host
 
   def path = header.path
@@ -231,3 +250,25 @@ class RequestHeaderImpl(header: RequestHeader) extends JRequestHeader {
   override def toString = header.toString
 
 }
+
+class RequestImpl(request: Request[RequestBody]) extends RequestHeaderImpl(request) with JRequest {
+  override def _underlyingRequest: Request[RequestBody] = request
+
+  override def attr[A](key: TypedKey[A]): A = _underlyingHeader.attr(key)
+  override def getAttr[A](key: TypedKey[A]): Optional[A] = OptionConverters.toJava(_underlyingHeader.getAttr(key))
+  override def containsAttr(key: TypedKey[_]): Boolean = _underlyingHeader.containsAttr(key)
+
+  override def withAttr[A](key: TypedKey[A], value: A): JRequest = {
+    new RequestImpl(request.withAttr(key, value))
+  }
+  override def withAttrs(entries: TypedEntry[_]*): JRequest = {
+    new RequestImpl(request.withAttrs(entries: _*))
+  }
+
+  override def body: RequestBody = request.body
+  override def hasBody: Boolean = request.hasBody
+  override def withBody(body: RequestBody): JRequest = new RequestImpl(request.withBody(body))
+
+  override def username: String = getAttr(Security.USERNAME).orElse(null)
+  override def withUsername(username: String): JRequest = withAttr(Security.USERNAME, username)
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/core/routing/GeneratedRouter.scala b/framework/src/play/src/main/scala/play/core/routing/GeneratedRouter.scala
index 951e7c4ae1..49d7a92043 100644
--- a/framework/src/play/src/main/scala/play/core/routing/GeneratedRouter.scala
+++ b/framework/src/play/src/main/scala/play/core/routing/GeneratedRouter.scala
@@ -231,8 +231,31 @@ abstract class GeneratedRouter extends Router {
   def createInvoker[T](
     fakeCall: => T,
     handlerDef: HandlerDef)(implicit hif: HandlerInvokerFactory[T]): HandlerInvoker[T] = {
-    val underlyingInvoker = hif.createInvoker(fakeCall, handlerDef)
-    new TaggingInvoker(underlyingInvoker, handlerDef)
+
+    // Get the implicit invoker factory and ask it for an invoker.
+    val underlyingInvoker: HandlerInvoker[T] = hif.createInvoker(fakeCall, handlerDef)
+
+    // Precalculate the function that adds routing information to the request
+    val tags = Map(
+      play.api.routing.Router.Tags.RoutePattern -> handlerDef.path,
+      play.api.routing.Router.Tags.RouteVerb -> handlerDef.verb,
+      play.api.routing.Router.Tags.RouteController -> handlerDef.controller,
+      play.api.routing.Router.Tags.RouteActionMethod -> handlerDef.method,
+      play.api.routing.Router.Tags.RouteComments -> handlerDef.comments
+    )
+    val modifyRequestFunc = { rh: RequestHeader =>
+      val newTags = if (rh.tags.isEmpty) tags else rh.tags ++ tags
+      rh.copy(tags = newTags).withAttr(play.api.routing.Router.HandlerDefAttr, handlerDef)
+    }
+
+    // Wrap the invoker with another invoker that preprocesses requests as they are made,
+    // adding routing information to each request.
+    new HandlerInvoker[T] {
+      override def call(call: => T): Handler = {
+        val nextHandler = underlyingInvoker.call(call)
+        Handler.Stage.modifyRequest(modifyRequestFunc, nextHandler)
+      }
+    }
   }
 }
 
diff --git a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
index 093fb5376e..fe5ad98eb6 100644
--- a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
+++ b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
@@ -30,28 +30,6 @@ trait HandlerInvoker[-T] {
   def call(call: => T): Handler
 }
 
-/**
- * An invoker that wraps another invoker, ensuring the request is tagged appropriately.
- */
-private class TaggingInvoker[-A](underlyingInvoker: HandlerInvoker[A], handlerDef: HandlerDef) extends HandlerInvoker[A] {
-  import HandlerInvokerFactory._
-  val cachedHandlerTags = handlerTags(handlerDef)
-  def call(call: => A): Handler = {
-    val handler = underlyingInvoker.call(call)
-    // All JavaAction's should already be tagged
-    handler match {
-      case alreadyTagged: RequestTaggingHandler => alreadyTagged
-      case action: EssentialAction => new EssentialAction with RequestTaggingHandler {
-        def apply(rh: RequestHeader) = action(rh)
-        def tagRequest(rh: RequestHeader) = taggedRequest(rh, cachedHandlerTags)
-      }
-      case ws: WebSocket =>
-        WebSocket(rh => ws(taggedRequest(rh, cachedHandlerTags)))
-      case other => other
-    }
-  }
-}
-
 /**
  * An object that creates a `HandlerInvoker`. Used by the `createInvoker` method
  * to create a `HandlerInvoker` for each route. The `Routes.createInvoker` method looks
@@ -72,19 +50,6 @@ object HandlerInvokerFactory {
 
   import play.mvc.{ Result => JResult, WebSocket => JWebSocket }
 
-  private[routing] def handlerTags(handlerDef: HandlerDef): Map[String, String] = Map(
-    play.api.routing.Router.Tags.RoutePattern -> handlerDef.path,
-    play.api.routing.Router.Tags.RouteVerb -> handlerDef.verb,
-    play.api.routing.Router.Tags.RouteController -> handlerDef.controller,
-    play.api.routing.Router.Tags.RouteActionMethod -> handlerDef.method,
-    play.api.routing.Router.Tags.RouteComments -> handlerDef.comments
-  )
-
-  private[routing] def taggedRequest(rh: RequestHeader, tags: Map[String, String]): RequestHeader = {
-    val newTags = if (rh.tags.isEmpty) tags else rh.tags ++ tags
-    rh.copy(tags = newTags)
-  }
-
   /**
    * Create a `HandlerInvokerFactory` for a call that already produces a
    * `Handler`.
@@ -118,31 +83,35 @@ object HandlerInvokerFactory {
    * tags and annotations.
    */
   private abstract class JavaActionInvokerFactory[A] extends HandlerInvokerFactory[A] {
-    def createInvoker(fakeCall: => A, handlerDef: HandlerDef): HandlerInvoker[A] = new HandlerInvoker[A] {
-      val cachedHandlerTags = handlerTags(handlerDef)
-      private[this] var _annotations: JavaActionAnnotations = null
+
+    override def createInvoker(fakeCall: => A, handlerDef: HandlerDef): HandlerInvoker[A] = new HandlerInvoker[A] {
+      // Cache annotations, initializing on first use
+      // (It's OK that this is unsynchronized since the initialization should be idempotent.)
+      private var _annotations: JavaActionAnnotations = null
       def cachedAnnotations(config: ActionCompositionConfiguration) = {
         if (_annotations == null) {
-          _annotations = {
-            val controller = loadJavaControllerClass(handlerDef)
-            val method = MethodUtils.getMatchingAccessibleMethod(controller, handlerDef.method, handlerDef.parameterTypes: _*)
-            new JavaActionAnnotations(controller, method, config)
-          }
+          val controller = loadJavaControllerClass(handlerDef)
+          val method = MethodUtils.getMatchingAccessibleMethod(controller, handlerDef.method, handlerDef.parameterTypes: _*)
+          _annotations = new JavaActionAnnotations(controller, method, config)
         }
         _annotations
       }
-      def call(call: => A): Handler = new JavaHandler {
-        def withComponents(components: JavaHandlerComponents) = new play.core.j.JavaAction(components) with RequestTaggingHandler {
-          val annotations = cachedAnnotations(components.httpConfiguration.actionComposition)
-          val parser = {
+
+      override def call(call: => A): Handler = new JavaHandler {
+        def withComponents(components: JavaHandlerComponents): Handler = new play.core.j.JavaAction(components) {
+          override val annotations = cachedAnnotations(components.httpConfiguration.actionComposition)
+          override val parser = {
             val javaParser = components.getBodyParser(annotations.parser)
             javaBodyParserToScala(javaParser)
           }
-          def invocation: CompletionStage[JResult] = resultCall(call)
-          def tagRequest(rh: RequestHeader) = taggedRequest(rh, cachedHandlerTags)
+          override def invocation: CompletionStage[JResult] = resultCall(call)
         }
       }
     }
+
+    /**
+     * The core logic for this Java action.
+     */
     def resultCall(call: => A): CompletionStage[JResult]
   }
 
@@ -172,8 +141,7 @@ object HandlerInvokerFactory {
   private abstract class JavaWebSocketInvokerFactory[A, B] extends HandlerInvokerFactory[A] {
     def webSocketCall(call: => A): WebSocket
     def createInvoker(fakeCall: => A, handlerDef: HandlerDef): HandlerInvoker[A] = new HandlerInvoker[A] {
-      val cachedHandlerTags = handlerTags(handlerDef)
-      def call(call: => A): WebSocket = webSocketCall(call)
+      override def call(call: => A): Handler = webSocketCall(call)
     }
   }
 
diff --git a/framework/src/play/src/test/java/play/mvc/SecurityTest.java b/framework/src/play/src/test/java/play/mvc/SecurityTest.java
index 3f532a977e..0aa5633efa 100644
--- a/framework/src/play/src/test/java/play/mvc/SecurityTest.java
+++ b/framework/src/play/src/test/java/play/mvc/SecurityTest.java
@@ -7,10 +7,9 @@ import com.google.common.collect.ImmutableMap;
 import java.lang.annotation.Annotation;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
 
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.runners.Enclosed;
@@ -18,6 +17,9 @@ import org.junit.runner.RunWith;
 
 import play.inject.Injector;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
 import static org.mockito.Mockito.*;
 
 @RunWith(Enclosed.class)
@@ -25,25 +27,48 @@ public class SecurityTest {
     public static class AuthenticatedActionTest {
         Http.Context ctx;
         Http.Request req;
-        Injector injector;
-        Security.AuthenticatedAction action;
-
-        RuntimeException exception = new RuntimeException("test exception");
-        final Result ok = Results.ok();
+        Http.Context usernameCtx;
+        Http.Request usernameReq;
 
         @Before
         public void setUp() {
             ctx = mock(Http.Context.class);
             req = mock(Http.Request.class);
-            injector = mock(Injector.class);
+            usernameCtx = mock(Http.Context.class);
+            usernameReq = mock(Http.Request.class);
+        }
 
+        @Test
+        public void testAuthorized() throws Exception {
             when(ctx.session()).thenReturn(new Http.Session(ImmutableMap.of("username", "test_user")));
             when(ctx.request()).thenReturn(req);
-            doNothing().when(req).setUsername(anyString());
-            doNothing().when(req).setUsername(null);
-            when(injector.instanceOf(Security.Authenticator.class)).thenReturn(new Security.Authenticator());
+            when(req.withAttr(Security.USERNAME, "test_user")).thenReturn(usernameReq);
+            when(ctx.withRequest(usernameReq)).thenReturn(usernameCtx);
+
+            Result r = callWithSecurity(ctx -> {
+                assertSame(usernameCtx, ctx);
+                when(usernameCtx.request()).thenReturn(usernameReq);
+                when(usernameReq.attr(Security.USERNAME)).thenReturn("test_user");
+                Http.Request req = ctx.request();
+                String username = req.attr(Security.USERNAME);
+                assertEquals("test_user", username);
+                return Results.ok().withHeader("Actual-Username", username);
+            });
+            assertEquals(Http.Status.OK, r.status());
+            assertEquals("test_user", r.headers().get("Actual-Username"));
+        }
+
+        @Test
+        public void testUnauthorized() throws Exception {
+            when(ctx.session()).thenReturn(new Http.Session(ImmutableMap.of()));
+            Result r = callWithSecurity(ctx -> { throw new AssertionError("Action should not be called"); });
+            assertEquals(Http.Status.UNAUTHORIZED, r.status());
+        }
 
-            action = new Security.AuthenticatedAction(injector);
+        private Result callWithSecurity(Function<Http.Context, Result> f) throws Exception {
+            Injector injector = mock(Injector.class);
+            when(injector.instanceOf(Security.Authenticator.class)).thenReturn(new Security.Authenticator());
+            Security.AuthenticatedAction action = new Security.AuthenticatedAction(injector);
             action.configuration = new Security.Authenticated() {
                 @Override
                 public Class<? extends Security.Authenticator> value() {
@@ -55,63 +80,14 @@ public class SecurityTest {
                     return null;
                 }
             };
-        }
-
-        @Test
-        public void testDontSetUsernameToNullUntilDelegateFinishes() throws Exception {
-            runSetUsernameToNullInCallback(false);
-        }
-
-        @Test
-        public void testDontSetUsernameToNullUntilDelegateRaisesException() throws Exception {
-            runSetUsernameToNullInCallback(true);
-        }
-
-        @Test
-        public void testSetUsernameToNullWhenExceptionRaised() {
-            action.delegate = new Action<Object>() {
-                @Override
-                public CompletionStage<Result> call(Http.Context ctx) {
-                    throw exception;
-                }
-            };
-
-            try {
-                action.call(ctx);
-            } catch (RuntimeException e) {
-                Assert.assertEquals(exception, e);
-            }
-
-            verify(req).setUsername("test_user");
-            verify(req).setUsername(null);
-        }
-
-        private void runSetUsernameToNullInCallback(final boolean shouldRaiseException) throws Exception {
             action.delegate = new Action<Object>() {
                 @Override
                 public CompletionStage<Result> call(Http.Context ctx) {
-                    return CompletableFuture.supplyAsync(() -> {
-                        if (shouldRaiseException) {
-                            throw exception;
-                        } else {
-                            return ok;
-                        }
-                    });
+                    Result r = f.apply(ctx);
+                    return CompletableFuture.completedFuture(r);
                 }
             };
-
-            if (shouldRaiseException) {
-                try {
-                    action.call(ctx).toCompletableFuture().get(1, TimeUnit.SECONDS);
-                } catch (ExecutionException e) {
-                    Assert.assertEquals(exception, e.getCause());
-                }
-            } else {
-                Assert.assertEquals(ok, action.call(ctx).toCompletableFuture().get(1, TimeUnit.SECONDS));
-            }
-
-            verify(req).setUsername("test_user");
-            verify(req).setUsername(null);
+            return action.call(ctx).toCompletableFuture().get(1, TimeUnit.SECONDS);
         }
     }
 }
diff --git a/framework/src/play/src/test/scala/play/api/mvc/RangeResultSpec.scala b/framework/src/play/src/test/scala/play/api/mvc/RangeResultSpec.scala
index b3866715e9..8dec023010 100644
--- a/framework/src/play/src/test/scala/play/api/mvc/RangeResultSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/mvc/RangeResultSpec.scala
@@ -180,11 +180,12 @@ class RangeSpec extends Specification {
   "Merge ranges" in {
     val range1 = Range(entityLength = Some(10000), range = "0-10")
     val range2 = Range(entityLength = Some(10000), range = "5-15")
-    val merged = (range1, range2) match {
-      case (Some(r1), Some(r2)) => r1.merge(r2)
+    (range1, range2) must beLike {
+      case (Some(r1), Some(r2)) =>
+        val merged = r1.merge(r2)
+        merged.start must beSome(0)
+        merged.end must beSome(15)
     }
-    merged.start must beSome(0)
-    merged.end must beSome(15)
   }
 
   "Validate ranges" in {
diff --git a/framework/src/play/src/test/scala/play/api/mvc/RequestHeaderSpec.scala b/framework/src/play/src/test/scala/play/api/mvc/RequestHeaderSpec.scala
index 7ac9c419cf..1d025d3471 100644
--- a/framework/src/play/src/test/scala/play/api/mvc/RequestHeaderSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/mvc/RequestHeaderSpec.scala
@@ -8,30 +8,51 @@ import java.net.URI
 import org.specs2.mutable.Specification
 import play.api.http.HeaderNames._
 import play.api.i18n.Lang
+import play.api.libs.typedmap.{ TypedKey, TypedMap }
 
 class RequestHeaderSpec extends Specification {
 
   "request header" should {
 
+    "have typed attributes" in {
+      "can set and get a single attribute" in {
+        val x = TypedKey[Int]("x")
+        (dummyRequestHeader().withAttrs(x -> 3)).attr(x) must_== 3
+      }
+      "can set two attributes and get one back" in {
+        val x = TypedKey[Int]("x")
+        val y = TypedKey[String]("y")
+        (dummyRequestHeader().withAttrs(x -> 3, y -> "hello")).attr(y) must_== "hello"
+      }
+      "getting a set attribute should be Some" in {
+        val x = TypedKey[Int]("x")
+        (dummyRequestHeader().withAttrs(x -> 5)).getAttr(x) must beSome(5)
+      }
+      "getting a nonexistent attribute should be None" in {
+        val x = TypedKey[Int]("x")
+        dummyRequestHeader().getAttr(x) must beNone
+      }
+    }
+
     "handle host" in {
       "relative uri with host header" in {
-        val rh = DummyRequestHeader("GET", "/", Headers(HOST -> "playframework.com"))
+        val rh = dummyRequestHeader("GET", "/", Headers(HOST -> "playframework.com"))
         rh.host must_== "playframework.com"
       }
       "absolute uri" in {
-        val rh = DummyRequestHeader("GET", "https://example.com/test", Headers(HOST -> "playframework.com"))
+        val rh = dummyRequestHeader("GET", "https://example.com/test", Headers(HOST -> "playframework.com"))
         rh.host must_== "example.com"
       }
       "absolute uri with port" in {
-        val rh = DummyRequestHeader("GET", "https://example.com:8080/test", Headers(HOST -> "playframework.com"))
+        val rh = dummyRequestHeader("GET", "https://example.com:8080/test", Headers(HOST -> "playframework.com"))
         rh.host must_== "example.com:8080"
       }
       "absolute uri with port and invalid characters" in {
-        val rh = DummyRequestHeader("GET", "https://example.com:8080/classified-search/classifieds?version=GTI|V8", Headers(HOST -> "playframework.com"))
+        val rh = dummyRequestHeader("GET", "https://example.com:8080/classified-search/classifieds?version=GTI|V8", Headers(HOST -> "playframework.com"))
         rh.host must_== "example.com:8080"
       }
       "relative uri with invalid characters" in {
-        val rh = DummyRequestHeader("GET", "/classified-search/classifieds?version=GTI|V8", Headers(HOST -> "playframework.com"))
+        val rh = dummyRequestHeader("GET", "/classified-search/classifieds?version=GTI|V8", Headers(HOST -> "playframework.com"))
         rh.host must_== "playframework.com"
       }
     }
@@ -39,7 +60,7 @@ class RequestHeaderSpec extends Specification {
     "parse accept languages" in {
 
       "return an empty sequence when no accept languages specified" in {
-        DummyRequestHeader().acceptLanguages must beEmpty
+        dummyRequestHeader().acceptLanguages must beEmpty
       }
 
       "parse a single accept language" in {
@@ -67,23 +88,27 @@ class RequestHeaderSpec extends Specification {
     }
   }
 
-  def accept(value: String) = DummyRequestHeader(
+  private def accept(value: String) = dummyRequestHeader(
     headers = Headers("Accept-Language" -> value)
   ).acceptLanguages
 
-  case class DummyRequestHeader(
-      requestMethod: String = "GET",
-      requestUri: String = "/",
-      headers: Headers = Headers()) extends RequestHeader {
-    def id = 1
-    def tags = Map()
-    def uri = requestUri
-    def path = new URI(requestUri).getPath // this just won't work for invalid URIs
-    def method = requestMethod
-    def version = ""
-    def queryString = Map()
-    def remoteAddress = ""
-    def secure = false
-    override def clientCertificateChain = None
+  private def dummyRequestHeader(
+    requestMethod: String = "GET",
+    requestUri: String = "/",
+    headers: Headers = Headers()): RequestHeader = {
+    new RequestHeaderImpl(
+      id = 1L,
+      tags = Map.empty,
+      uri = requestUri,
+      path = "",
+      method = requestMethod,
+      version = "",
+      queryString = Map.empty,
+      headers = headers,
+      remoteAddress = "",
+      secure = false,
+      clientCertificateChain = None,
+      attrMap = TypedMap.empty
+    )
   }
 }
diff --git a/framework/src/play/src/test/scala/play/core/routing/GeneratedRouterSpec.scala b/framework/src/play/src/test/scala/play/core/routing/GeneratedRouterSpec.scala
new file mode 100644
index 0000000000..b27ebb25d0
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/core/routing/GeneratedRouterSpec.scala
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2009-2016 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.core.routing
+
+import org.specs2.mutable.Specification
+import play.api.http.{ DefaultHttpErrorHandler, HttpErrorHandler }
+import play.api.mvc._
+import play.api.routing.Router
+import play.core.j.{ JavaAction, JavaHandler }
+import play.core.test.FakeRequest
+
+object GeneratedRouterSpec extends Specification {
+
+  class TestRouter[H](
+      handlerThunk: => H,
+      handlerDef: HandlerDef,
+      override val errorHandler: HttpErrorHandler = DefaultHttpErrorHandler,
+      val prefix: String = "/")(implicit hif: HandlerInvokerFactory[H]) extends GeneratedRouter {
+
+    override def withPrefix(prefix: String): Router = new TestRouter[H](handlerThunk, handlerDef, errorHandler, prefix)
+
+    // The following code is based on the code generated by the routes compiler.
+
+    private[this] lazy val route = Route("GET", PathPattern(List(StaticPart(this.prefix))))
+    private[this] lazy val invoker = createInvoker(
+      handlerThunk,
+      handlerDef
+    )
+    override def routes: PartialFunction[RequestHeader, Handler] = {
+      case route(params) => call { invoker.call(handlerThunk) }
+    }
+    override def documentation: Seq[(String, String, String)] = List(
+      ("GET", this.prefix, "TestRouter.handler")
+    )
+  }
+
+  class JavaController extends play.mvc.Controller {
+    def index = play.mvc.Results.ok("Hello world")
+  }
+
+  def routeToHandler[H, A](handlerThunk: => H, handlerDef: HandlerDef, request: RequestHeader)(block: Handler => A)(implicit hif: HandlerInvokerFactory[H]): A = {
+    val router = new TestRouter(handlerThunk, handlerDef)
+    val request = FakeRequest()
+    val routedHandler = router.routes(request)
+    block(routedHandler)
+  }
+
+  "A GeneratedRouter" should {
+
+    "route requests to Scala controllers" in {
+      val handler = Action(Results.Ok("Hello world"))
+      val handlerDef = HandlerDef(handler.getClass.getClassLoader,
+        "router",
+        "ControllerClassName",
+        "handler",
+        Nil,
+        "GET",
+        "Comment",
+        "/"
+      )
+      val request = FakeRequest()
+      routeToHandler(handler, handlerDef, request) { routedHandler: Handler =>
+        routedHandler must haveInterface[Handler.Stage]
+        val (preprocessedRequest, preprocessedHandler) = Handler.applyStages(request, routedHandler)
+        preprocessedHandler must_== handler
+        preprocessedRequest.path must_== "/"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RoutePattern) must_== "/"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteVerb) must_== "GET"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteController) must_== "ControllerClassName"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteActionMethod) must_== "handler"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteComments) must_== "Comment"
+        preprocessedRequest.attr(play.api.routing.Router.HandlerDefAttr) must_== handlerDef
+      }
+    }
+
+    "route requests to Java controllers" in {
+      val controller = new JavaController
+      val handlerDef = HandlerDef(controller.getClass.getClassLoader,
+        "router",
+        controller.getClass.getName,
+        "index",
+        Nil,
+        "GET",
+        "Comment",
+        "/"
+      )
+      val request = FakeRequest()
+      routeToHandler(controller.index, handlerDef, request) { routedHandler: Handler =>
+        routedHandler must haveInterface[Handler.Stage]
+        val (preprocessedRequest, preprocessedHandler) = Handler.applyStages(request, routedHandler)
+        preprocessedHandler must haveInterface[JavaHandler]
+        preprocessedRequest.path must_== "/"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RoutePattern) must_== "/"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteVerb) must_== "GET"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteController) must_== controller.getClass.getName
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteActionMethod) must_== "index"
+        preprocessedRequest.tags(play.api.routing.Router.Tags.RouteComments) must_== "Comment"
+        preprocessedRequest.attr(play.api.routing.Router.HandlerDefAttr) must_== handlerDef
+      }
+    }
+
+  }
+
+}
\ No newline at end of file
diff --git a/framework/src/play/src/test/scala/play/core/test/Fakes.scala b/framework/src/play/src/test/scala/play/core/test/Fakes.scala
index 1351072132..70bd174be5 100644
--- a/framework/src/play/src/test/scala/play/core/test/Fakes.scala
+++ b/framework/src/play/src/test/scala/play/core/test/Fakes.scala
@@ -9,6 +9,7 @@ import akka.util.ByteString
 import play.api.inject.{ Binding, Injector }
 import play.api.libs.Files.TemporaryFile
 import play.api.libs.json.JsValue
+import play.api.libs.typedmap.TypedMap
 import play.api.mvc._
 
 import scala.concurrent.Future
@@ -21,7 +22,18 @@ import scala.xml.NodeSeq
  */
 case class FakeHeaders(data: Seq[(String, String)] = Seq.empty) extends Headers(data)
 
-case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A, remoteAddress: String = "127.0.0.1", version: String = "HTTP/1.1", id: Long = 666, tags: Map[String, String] = Map.empty[String, String], secure: Boolean = false, clientCertificateChain: Option[Seq[X509Certificate]] = None) extends Request[A] {
+case class FakeRequest[A](
+    method: String,
+    uri: String,
+    headers: Headers,
+    body: A,
+    remoteAddress: String = "127.0.0.1",
+    version: String = "HTTP/1.1",
+    id: Long = 666,
+    tags: Map[String, String] = Map.empty[String, String],
+    secure: Boolean = false,
+    clientCertificateChain: Option[Seq[X509Certificate]] = None,
+    attrMap: TypedMap = TypedMap.empty) extends Request[A] with WithAttrMap[FakeRequest[A]] {
 
   private def _copy[B](
     id: Long = this.id,
@@ -34,6 +46,7 @@ case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A
     remoteAddress: String = this.remoteAddress,
     secure: Boolean = this.secure,
     clientCertificateChain: Option[Seq[X509Certificate]] = this.clientCertificateChain,
+    attrMap: TypedMap = this.attrMap,
     body: B = this.body): FakeRequest[B] = {
     new FakeRequest[B](
       method, uri, headers, body, remoteAddress, version, id, tags, secure, clientCertificateChain
@@ -133,13 +146,11 @@ case class FakeRequest[A](method: String, uri: String, headers: Headers, body: A
     _copy(body = AnyContentAsMultipartFormData(form))
   }
 
-  /**
-   * Adds a body to the request.
-   */
-  def withBody[B](body: B): FakeRequest[B] = {
-    _copy(body = body)
+  override protected def withAttrMap(newAttrMap: TypedMap): FakeRequest[A] = {
+    new FakeRequest[A](
+      method, uri, headers, body, remoteAddress, version, id, tags, secure, clientCertificateChain, newAttrMap
+    )
   }
-
   /**
    * Returns the current method
    */
