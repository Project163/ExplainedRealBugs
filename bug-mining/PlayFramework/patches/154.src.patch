diff --git a/framework/project/BuildSettings.scala b/framework/project/BuildSettings.scala
index 266e992838..c0866885f4 100644
--- a/framework/project/BuildSettings.scala
+++ b/framework/project/BuildSettings.scala
@@ -3,8 +3,8 @@
  */
 import sbt.ScriptedPlugin._
 import sbt._
-import Keys.{ version, _ }
-import com.typesafe.tools.mima.core._
+import Keys.{version, _}
+import com.typesafe.tools.mima.core.{ProblemFilters, _}
 import com.typesafe.tools.mima.plugin.MimaKeys._
 import com.typesafe.tools.mima.plugin.MimaPlugin._
 import de.heikoseeberger.sbtheader.AutomateHeaderPlugin
@@ -713,7 +713,12 @@ object BuildSettings {
       ProblemFilters.exclude[IncompatibleMethTypeProblem]("play.api.mvc.Flash.-"),
 
       // Allow to disable JPA thread local requires access to configuration
-      ProblemFilters.exclude[IncompatibleMethTypeProblem]("play.db.jpa.DefaultJPAApi#JPAApiProvider.this")
+      ProblemFilters.exclude[IncompatibleMethTypeProblem]("play.db.jpa.DefaultJPAApi#JPAApiProvider.this"),
+    
+      // Add play.db.Database.withTransaction config
+      ProblemFilters.exclude[ReversedMissingMethodProblem]("play.db.Database.withTransaction"),
+      ProblemFilters.exclude[ReversedMissingMethodProblem]("play.db.Database.withTransaction"),
+      ProblemFilters.exclude[ReversedMissingMethodProblem]("play.api.db.Database.withTransaction")
     ),
     unmanagedSourceDirectories in Compile += {
       (sourceDirectory in Compile).value / s"scala-${scalaBinaryVersion.value}"
diff --git a/framework/src/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java b/framework/src/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java
index 4135abb778..97888c972b 100644
--- a/framework/src/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java
+++ b/framework/src/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java
@@ -100,11 +100,21 @@ public class DefaultDatabase implements Database {
         db.withTransaction(connectionFunction(block));
     }
 
+    @Override
+    public void withTransaction(TransactionIsolationLevel isolationLevel, ConnectionRunnable block) {
+        db.withTransaction(isolationLevel.asScala(), connectionFunction(block));
+    }
+
     @Override
     public <A> A withTransaction(ConnectionCallable<A> block) {
         return db.withTransaction(connectionFunction(block));
     }
 
+    @Override
+    public <A> A withTransaction(TransactionIsolationLevel isolationLevel, ConnectionCallable<A> block) {
+        return db.withTransaction(isolationLevel.asScala(), connectionFunction(block));
+    }
+
     @Override
     public void shutdown() {
         db.shutdown();
diff --git a/framework/src/play-java-jdbc/src/test/java/play/db/DatabaseTest.java b/framework/src/play-java-jdbc/src/test/java/play/db/DatabaseTest.java
index f7b9b653af..adadc4bed3 100644
--- a/framework/src/play-java-jdbc/src/test/java/play/db/DatabaseTest.java
+++ b/framework/src/play-java-jdbc/src/test/java/play/db/DatabaseTest.java
@@ -144,6 +144,26 @@ public class DatabaseTest {
         db.shutdown();
     }
 
+    @Test
+    public void provideConnectionHelpersWithAutoCommitIsFalse() {
+        Database db = Databases.inMemory("test-withConnection(autoCommit = false");
+
+        db.withConnection(false, c -> {
+            c.createStatement().execute("create table test (id bigint not null, name varchar(255))");
+            c.createStatement().execute("insert into test (id, name) values (1, 'alice')");
+        });
+
+        boolean result = db.withConnection(c -> {
+            ResultSet results = c.createStatement().executeQuery("select * from test");
+            assertThat(results.next(), is(false));
+            return true;
+        });
+
+        assertThat(result, is(true));
+
+        db.shutdown();
+    }
+
     @Test
     public void provideTransactionHelper() {
         Database db = Databases.inMemory("test-withTransaction");
@@ -198,4 +218,25 @@ public class DatabaseTest {
         assertThat(JNDI.initialContext().lookup("DefaultDS"), instanceOf(LogSqlDataSource.class));
         db.shutdown();
     }
+
+    @Test
+    public void manualSetupTrasactionIsolationLevel() throws Exception {
+        Database db = Databases.inMemory("test-withTransaction");
+
+        boolean created = db.withTransaction(TransactionIsolationLevel.Serializable, c -> {
+            c.createStatement().execute("create table test (id bigint not null, name varchar(255))");
+            c.createStatement().execute("insert into test (id, name) values (1, 'alice')");
+            return true;
+        });
+
+        assertThat(created, is(true));
+
+        db.withConnection(c -> {
+            ResultSet results = c.createStatement().executeQuery("select * from test");
+            assertThat(results.next(), is(true));
+            assertThat(results.next(), is(false));
+        });
+
+        db.shutdown();
+    }
 }
diff --git a/framework/src/play-jdbc-api/src/main/java/play/db/Database.java b/framework/src/play-jdbc-api/src/main/java/play/db/Database.java
index 48a41a6f00..dcf96d0823 100644
--- a/framework/src/play-jdbc-api/src/main/java/play/db/Database.java
+++ b/framework/src/play-jdbc-api/src/main/java/play/db/Database.java
@@ -4,8 +4,8 @@
 
 package play.db;
 
-import java.sql.Connection;
 import javax.sql.DataSource;
+import java.sql.Connection;
 
 /**
  * Database API for managing data sources and connections.
@@ -95,6 +95,16 @@ public interface Database {
      */
     public void withTransaction(ConnectionRunnable block);
 
+    /**
+     * Execute a block of code in the scope of a JDBC transaction. The
+     * connection and all created statements are automatically released. The
+     * transaction is automatically committed, unless an exception occurs.
+     *
+     * @param isolationLevel determines transaction isolation level
+     * @param block code to execute
+     */
+    public void withTransaction(TransactionIsolationLevel isolationLevel, ConnectionRunnable block);
+
     /**
      * Execute a block of code in the scope of a JDBC transaction. The
      * connection and all created statements are automatically released. The
@@ -106,6 +116,18 @@ public interface Database {
      */
     public <A> A withTransaction(ConnectionCallable<A> block);
 
+    /**
+     * Execute a block of code in the scope of a JDBC transaction. The
+     * connection and all created statements are automatically released. The
+     * transaction is automatically committed, unless an exception occurs.
+     *
+     * @param isolationLevel determines transaction isolation level
+     * @param <A> the return value's type
+     * @param block code to execute
+     * @return the result of the code block
+     */
+    public <A> A withTransaction(TransactionIsolationLevel isolationLevel, ConnectionCallable<A> block);
+
     /**
      * Shutdown this database, closing the underlying data source.
      */
@@ -174,6 +196,10 @@ public interface Database {
                 return Database.this.withTransaction(block::apply);
             }
 
+            public <A> A withTransaction(play.api.db.TransactionIsolationLevel isolationLevel,
+                                         final scala.Function1<Connection, A> block) {
+                return Database.this.withTransaction(isolationLevel.asJava(), block::apply);
+            }
         };
     }
 }
diff --git a/framework/src/play-jdbc-api/src/main/java/play/db/TransactionIsolationLevel.java b/framework/src/play-jdbc-api/src/main/java/play/db/TransactionIsolationLevel.java
new file mode 100644
index 0000000000..c5948a7bbd
--- /dev/null
+++ b/framework/src/play-jdbc-api/src/main/java/play/db/TransactionIsolationLevel.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2009-2018 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package play.db;
+
+import play.api.db.TransactionIsolationLevel$;
+
+import java.sql.Connection;
+
+/**
+ * An enumeration defines of isolation level that determines the degree to which one transaction must be isolated from resource or data modifications made by other operations.
+ */
+public enum TransactionIsolationLevel {
+
+    ReadUncommitted(Connection.TRANSACTION_READ_UNCOMMITTED),
+
+    ReadCommited(Connection.TRANSACTION_READ_COMMITTED),
+
+    RepeatedRead(Connection.TRANSACTION_REPEATABLE_READ),
+
+    Serializable(Connection.TRANSACTION_SERIALIZABLE);
+
+    private final int id;
+
+    TransactionIsolationLevel(final int id) {
+        this.id = id;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public play.api.db.TransactionIsolationLevel asScala() {
+        return TransactionIsolationLevel$.MODULE$.apply(id);
+    }
+
+    public static TransactionIsolationLevel fromId(final int id) {
+        for (TransactionIsolationLevel type : values()) {
+            if (type.getId() == id) {
+                return type;
+            }
+        }
+        throw new IllegalArgumentException("Not a valid value for transaction isolation level. See java.sql.Connection for possible options.");
+    }
+
+}
diff --git a/framework/src/play-jdbc-api/src/main/scala/play/api/db/Database.scala b/framework/src/play-jdbc-api/src/main/scala/play/api/db/Database.scala
index 6761682808..ee011035c9 100644
--- a/framework/src/play-jdbc-api/src/main/scala/play/api/db/Database.scala
+++ b/framework/src/play-jdbc-api/src/main/scala/play/api/db/Database.scala
@@ -5,6 +5,7 @@
 package play.api.db
 
 import java.sql.Connection
+
 import javax.sql.DataSource
 
 /**
@@ -77,6 +78,17 @@ trait Database {
    */
   def withTransaction[A](block: Connection => A): A
 
+  /**
+   * Execute a block of code in the scope of a JDBC transaction.
+   * The connection and all created statements are automatically released.
+   * The transaction is automatically committed, unless an exception occurs.
+   *
+   * @param isolationLevel determines transaction isolation level
+   * @param block code to execute
+   * @return the result of the code block
+   */
+  def withTransaction[A](isolationLevel: TransactionIsolationLevel)(block: Connection => A): A
+
   /**
    * Shutdown this database, closing the underlying data source.
    */
diff --git a/framework/src/play-jdbc-api/src/main/scala/play/api/db/TransactionIsolationLevel.scala b/framework/src/play-jdbc-api/src/main/scala/play/api/db/TransactionIsolationLevel.scala
new file mode 100644
index 0000000000..4078a2cbab
--- /dev/null
+++ b/framework/src/play-jdbc-api/src/main/scala/play/api/db/TransactionIsolationLevel.scala
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009-2018 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package play.api.db
+
+import java.sql.Connection
+
+/**
+ * Defines isolation levels that determines the degree to which one transaction must be isolated from resource or data modifications made by other operations.
+ *
+ * @param id the transaction isolation level.
+ *
+ * @see [[Connection]].
+ */
+sealed abstract class TransactionIsolationLevel(val id: Int) {
+  def asJava(): play.db.TransactionIsolationLevel = play.db.TransactionIsolationLevel.fromId(id)
+}
+
+object TransactionIsolationLevel {
+
+  case object ReadUncommitted extends TransactionIsolationLevel(Connection.TRANSACTION_READ_UNCOMMITTED)
+
+  case object ReadCommited extends TransactionIsolationLevel(Connection.TRANSACTION_READ_COMMITTED)
+
+  case object RepeatedRead extends TransactionIsolationLevel(Connection.TRANSACTION_REPEATABLE_READ)
+
+  case object Serializable extends TransactionIsolationLevel(Connection.TRANSACTION_SERIALIZABLE)
+
+  def apply(id: Int): TransactionIsolationLevel = id match {
+    case Connection.TRANSACTION_READ_COMMITTED => ReadCommited
+    case Connection.TRANSACTION_READ_UNCOMMITTED => ReadUncommitted
+    case Connection.TRANSACTION_REPEATABLE_READ => RepeatedRead
+    case Connection.TRANSACTION_SERIALIZABLE => Serializable
+    case _ => throw new IllegalArgumentException("Not a valid value for transaction isolation level. See java.sql.Connection for possible options.")
+  }
+
+}
\ No newline at end of file
diff --git a/framework/src/play-jdbc/src/main/scala/play/api/db/Databases.scala b/framework/src/play-jdbc/src/main/scala/play/api/db/Databases.scala
index ce51df40ca..bb230366f3 100644
--- a/framework/src/play-jdbc/src/main/scala/play/api/db/Databases.scala
+++ b/framework/src/play-jdbc/src/main/scala/play/api/db/Databases.scala
@@ -5,13 +5,13 @@
 package play.api.db
 
 import java.sql.{ Connection, Driver, DriverManager }
-import javax.sql.DataSource
 
+import com.typesafe.config.Config
+import javax.sql.DataSource
+import play.api.{ Configuration, Environment }
 import play.utils.{ ProxyDriver, Reflect }
 
-import com.typesafe.config.Config
-import scala.util.control.{ NonFatal, ControlThrowable }
-import play.api.{ Environment, Configuration }
+import scala.util.control.{ ControlThrowable, NonFatal }
 
 /**
  * Creation helpers for manually instantiating databases.
@@ -95,7 +95,7 @@ object Databases {
 abstract class DefaultDatabase(val name: String, configuration: Config, environment: Environment) extends Database {
 
   private val config = Configuration(configuration)
-  val databaseConfig = DatabaseConfig.fromConfig(config, environment)
+  val databaseConfig: DatabaseConfig = DatabaseConfig.fromConfig(config, environment)
 
   // abstract methods to be implemented
 
@@ -183,6 +183,27 @@ abstract class DefaultDatabase(val name: String, configuration: Config, environm
     }
   }
 
+  def withTransaction[A](isolationLevel: TransactionIsolationLevel)(block: Connection => A): A = {
+    withConnection(autocommit = false) { connection =>
+      val oldIsolationLevel = connection.getTransactionIsolation
+      try {
+        connection.setTransactionIsolation(isolationLevel.id)
+        val r = block(connection)
+        connection.commit()
+        r
+      } catch {
+        case e: ControlThrowable =>
+          connection.commit()
+          throw e
+        case e: Throwable =>
+          connection.rollback()
+          throw e
+      } finally {
+        connection.setTransactionIsolation(oldIsolationLevel)
+      }
+    }
+  }
+
   // shutdown
 
   def shutdown(): Unit = {
diff --git a/framework/src/play-jdbc/src/test/scala/play/api/db/DatabasesSpec.scala b/framework/src/play-jdbc/src/test/scala/play/api/db/DatabasesSpec.scala
index bb7e3b5f7f..bdf23c32a0 100644
--- a/framework/src/play-jdbc/src/test/scala/play/api/db/DatabasesSpec.scala
+++ b/framework/src/play-jdbc/src/test/scala/play/api/db/DatabasesSpec.scala
@@ -125,6 +125,15 @@ class DatabasesSpec extends Specification {
       }
     }
 
+    "manual setup trasaction isolation level" in new WithDatabase {
+      val db = Databases.inMemory(name = "test-manualSetupTrasactionIsolationLevel")
+
+      db.withTransaction(TransactionIsolationLevel.Serializable) { c =>
+        c.createStatement.execute("create table test (id bigint not null, name varchar(255))")
+        c.createStatement.execute("insert into test (id, name) values (1, 'alice')")
+      }
+    }
+
     "not supply connections after shutdown" in {
       val db = Databases.inMemory(name = "test-shutdown")
       db.getConnection.close()
