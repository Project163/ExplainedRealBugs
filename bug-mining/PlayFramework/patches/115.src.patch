diff --git a/framework/src/play-guice/src/main/scala/play/api/inject/guice/GuiceInjectorBuilder.scala b/framework/src/play-guice/src/main/scala/play/api/inject/guice/GuiceInjectorBuilder.scala
index 59534004e8..4abf656bfb 100644
--- a/framework/src/play-guice/src/main/scala/play/api/inject/guice/GuiceInjectorBuilder.scala
+++ b/framework/src/play-guice/src/main/scala/play/api/inject/guice/GuiceInjectorBuilder.scala
@@ -5,11 +5,13 @@ package play.api.inject
 package guice
 
 import com.google.inject.util.{ Modules => GuiceModules, Providers => GuiceProviders }
-import com.google.inject.{ Module => GuiceModule, Binder, Stage, CreationException, Guice }
+import com.google.inject.{ Binder, CreationException, Guice, Stage, Module => GuiceModule }
 import java.io.File
-import javax.inject.Inject
+import javax.inject.{ Inject, Provider }
+
 import play.api.inject.{ Binding => PlayBinding, Injector => PlayInjector, Module => PlayModule }
 import play.api.{ Configuration, Environment, Mode, PlayException }
+
 import scala.collection.JavaConverters._
 import scala.reflect.ClassTag
 
@@ -157,7 +159,9 @@ abstract class GuiceBuilder[Self] protected (
   def createModule(): GuiceModule = {
     import scala.collection.JavaConverters._
     val injectorModule = GuiceableModule.guice(Seq(
-      bind[PlayInjector].to[GuiceInjector],
+      bind[GuiceInjector].toSelf,
+      bind[GuiceClassLoader].to(new GuiceClassLoader(environment.classLoader)),
+      bind[PlayInjector].toProvider[GuiceInjectorWithClassLoaderProvider],
       // Java API injector is bound here so that it's available in both
       // the default application loader and the Java Guice builders
       bind[play.inject.Injector].to[play.inject.DelegateInjector]
@@ -409,3 +413,23 @@ class GuiceInjector @Inject() (injector: com.google.inject.Injector) extends Pla
    */
   def instanceOf[T](key: BindingKey[T]) = injector.getInstance(GuiceKey(key))
 }
+
+/**
+ * An object that holds a `ClassLoader` for Guice to use. We use this
+ * simple value object so it can be looked up by its type when we're
+ * assembling the Guice injector.
+ *
+ * @param classLoader The wrapped `ClassLoader`.
+ */
+class GuiceClassLoader(val classLoader: ClassLoader)
+
+/**
+ * A provider for a Guice injector that wraps the injector to ensure
+ * it uses the correct `ClassLoader`.
+ *
+ * @param injector The injector to wrap.
+ * @param guiceClassLoader The `ClassLoader` the injector should use.
+ */
+class GuiceInjectorWithClassLoaderProvider @Inject() (injector: GuiceInjector, guiceClassLoader: GuiceClassLoader) extends Provider[Injector] {
+  override def get(): PlayInjector = new ContextClassLoaderInjector(injector, guiceClassLoader.classLoader)
+}
\ No newline at end of file
diff --git a/framework/src/play-guice/src/test/scala/play/api/inject/guice/GuiceInjectorBuilderSpec.scala b/framework/src/play-guice/src/test/scala/play/api/inject/guice/GuiceInjectorBuilderSpec.scala
index 0909b6f824..7e98108315 100644
--- a/framework/src/play-guice/src/test/scala/play/api/inject/guice/GuiceInjectorBuilderSpec.scala
+++ b/framework/src/play-guice/src/test/scala/play/api/inject/guice/GuiceInjectorBuilderSpec.scala
@@ -10,7 +10,7 @@ import java.net.URLClassLoader
 import com.google.inject.AbstractModule
 import org.specs2.mutable.Specification
 import play.api.inject._
-import play.api.{ Configuration, Environment, Mode }
+import play.api.{ Configuration, Environment, Mode, inject }
 
 class GuiceInjectorBuilderSpec extends Specification {
 
@@ -39,6 +39,16 @@ class GuiceInjectorBuilderSpec extends Specification {
       env.classLoader must be(classLoader)
     }
 
+    "use the right ClassLoader when injecting" in {
+      val classLoader = new URLClassLoader(Array.empty)
+      val classLoaderAware = new GuiceInjectorBuilder()
+        .in(classLoader)
+        .bindings(bind[GuiceInjectorBuilderSpec.ClassLoaderAware].toSelf)
+        .injector().instanceOf[GuiceInjectorBuilderSpec.ClassLoaderAware]
+
+      classLoaderAware.constructionClassLoader must_== classLoader
+    }
+
     "set configuration" in {
       val conf = new GuiceInjectorBuilder()
         .configure(Configuration("a" -> 1))
@@ -145,6 +155,11 @@ object GuiceInjectorBuilderSpec {
     def configure() = bind(classOf[Configuration]) toInstance conf
   }
 
+  class ClassLoaderAware {
+    // This is the value of the Thread's context ClassLoader at the time the object is constructed
+    val constructionClassLoader: ClassLoader = Thread.currentThread.getContextClassLoader
+  }
+
   trait A
   class A1 extends A
 
diff --git a/framework/src/play/src/main/scala/play/api/Application.scala b/framework/src/play/src/main/scala/play/api/Application.scala
index 80e02dbfe7..95a602e3d8 100644
--- a/framework/src/play/src/main/scala/play/api/Application.scala
+++ b/framework/src/play/src/main/scala/play/api/Application.scala
@@ -267,12 +267,13 @@ trait BuiltInComponents extends I18nComponents {
    * existing (deprecated) legacy APIs to function. It is not set up to support injecting arbitrary Play components.
    */
   lazy val injector: Injector = {
-    new SimpleInjector(NewInstanceInjector) +
+    val simple = new SimpleInjector(NewInstanceInjector) +
       cookieSigner + // play.api.libs.Crypto (for cookies)
       httpConfiguration + // play.api.mvc.BodyParsers trait
       tempFileCreator + // play.api.libs.TemporaryFileCreator object
       messagesApi + // play.api.i18n.Messages object
       langs // play.api.i18n.Langs object
+    new ContextClassLoaderInjector(simple, environment.classLoader)
   }
 
   lazy val playBodyParsers: PlayBodyParsers =
diff --git a/framework/src/play/src/main/scala/play/api/inject/Injector.scala b/framework/src/play/src/main/scala/play/api/inject/Injector.scala
index b364f09304..e9bfb4e2f8 100644
--- a/framework/src/play/src/main/scala/play/api/inject/Injector.scala
+++ b/framework/src/play/src/main/scala/play/api/inject/Injector.scala
@@ -109,3 +109,21 @@ class SimpleInjector(fallback: Injector, components: Map[Class[_], Any] = Map.em
     new SimpleInjector(fallback, components + (clazz -> component))
 
 }
+
+/**
+ * Wraps an existing injector, ensuring all calls have the correct context `ClassLoader` set.
+ */
+private[play] class ContextClassLoaderInjector(delegate: Injector, classLoader: ClassLoader) extends Injector {
+  override def instanceOf[T: ClassManifest]: T = withContext { delegate.instanceOf[T] }
+  override def instanceOf[T](clazz: Class[T]): T = withContext { delegate.instanceOf(clazz) }
+  override def instanceOf[T](key: BindingKey[T]): T = withContext { delegate.instanceOf(key) }
+
+  @inline
+  private def withContext[T](body: => T): T = {
+    val thread = Thread.currentThread()
+    val oldClassLoader = thread.getContextClassLoader
+    thread.setContextClassLoader(classLoader)
+    try body finally thread.setContextClassLoader(oldClassLoader)
+  }
+
+}
\ No newline at end of file
diff --git a/framework/src/play/src/test/scala/play/api/BuiltInComponentsSpec.scala b/framework/src/play/src/test/scala/play/api/BuiltInComponentsSpec.scala
new file mode 100644
index 0000000000..4e68d91d0d
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/api/BuiltInComponentsSpec.scala
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.api
+
+import java.io.File
+import java.net.URLClassLoader
+
+import org.specs2.mutable.Specification
+import play.api.inject.DefaultApplicationLifecycle
+import play.api.mvc.EssentialFilter
+import play.api.routing.Router
+import play.core.{ SourceMapper, WebCommands }
+
+class BuiltInComponentsSpec extends Specification {
+  "BuiltinComponents" should {
+    "use the Environment ClassLoader for runtime injection" in {
+      val classLoader = new URLClassLoader(Array())
+      val components = new BuiltInComponents {
+        override val environment: Environment = Environment(new File("."), classLoader, Mode.Test)
+        override def configuration: Configuration = Configuration.load(environment)
+        override def applicationLifecycle: DefaultApplicationLifecycle = new DefaultApplicationLifecycle
+        override def router: Router = ???
+        override def webCommands: WebCommands = ???
+        override def sourceMapper: Option[SourceMapper] = ???
+        override def httpFilters: Seq[EssentialFilter] = ???
+      }
+      components.environment.classLoader must_== classLoader
+      val constructedObject = components.injector.instanceOf[BuiltInComponentsSpec.ClassLoaderAware]
+      constructedObject.constructionClassLoader must_== classLoader
+    }
+  }
+}
+
+object BuiltInComponentsSpec {
+  class ClassLoaderAware {
+    // This is the value of the Thread's context ClassLoader at the time the object is constructed
+    val constructionClassLoader: ClassLoader = Thread.currentThread.getContextClassLoader
+  }
+}
\ No newline at end of file
