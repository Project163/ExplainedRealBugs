diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
index 26e4ed9a56..d83aee075e 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/ScalaResultsHandlingSpec.scala
@@ -10,8 +10,8 @@ import play.api.libs.ws._
 import play.api.libs.iteratee._
 import play.it._
 import scala.util.{ Failure, Success, Try }
-
 import play.api.libs.concurrent.Execution.{ defaultContext => ec }
+import play.api.http.Status
 
 object NettyScalaResultsHandlingSpec extends ScalaResultsHandlingSpec with NettyIntegrationSpecification
 object AkkaHttpScalaResultsHandlingSpec extends ScalaResultsHandlingSpec with AkkaHttpIntegrationSpecification
@@ -344,6 +344,16 @@ trait ScalaResultsHandlingSpec extends PlaySpecification with WsTestClient with
         response.body must beLeft("")
         response.headers.get(CONTENT_LENGTH) must beSome("0")
       }
-  }
 
+    "return a 500 response if a forbidden character is used in a response's header field" in withServer(
+      // both colon and space characters are not allowed in a header's field name 
+      Results.Ok.withHeaders("BadFieldName: " -> "SomeContent")
+    ) { port =>
+        val response = BasicHttpClient.makeRequests(port)(
+          BasicRequest("GET", "/", "HTTP/1.1", Map(), "")
+        ).apply(0)
+        response.status must_== Status.INTERNAL_SERVER_ERROR
+        (response.headers - (CONTENT_LENGTH)) must be(Map.empty)
+      }
+  }
 }
diff --git a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
index 706ee80256..bde795736d 100644
--- a/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
+++ b/framework/src/play-netty-server/src/main/scala/play/core/server/netty/NettyResultStreamer.scala
@@ -7,17 +7,15 @@ import play.api.mvc._
 import play.api.libs.iteratee._
 import play.api._
 import play.core.server.common.ServerResultUtils
-
 import org.jboss.netty.handler.codec.http.HttpHeaders.Names._
 import org.jboss.netty.buffer.ChannelBuffers
 import org.jboss.netty.channel._
 import org.jboss.netty.handler.codec.http._
 import org.jboss.netty.handler.codec.http.HttpHeaders.Values._
-
 import com.typesafe.netty.http.pipelining.{ OrderedDownstreamChannelEvent, OrderedUpstreamMessageEvent }
-
 import scala.concurrent.Future
 import scala.util.{ Failure, Success }
+import scala.util.control.NonFatal
 
 /**
  * Streams Play results to Netty
@@ -88,7 +86,7 @@ object NettyResultStreamer {
           ctx.sendDownstream(ode)
         }
       case Failure(ex) =>
-        logger.debug(ex.toString)
+        logger.error("Error while sending response.", ex)
         Channels.close(oue.getChannel)
     }
     sentResponse
@@ -116,8 +114,20 @@ object NettyResultStreamer {
     import scala.collection.JavaConverters._
 
     // Set response headers
-    ServerResultUtils.splitHeadersIntoSeq(header.headers).foreach {
-      case (name, value) => nettyResponse.headers().add(name, value)
+    val headers = ServerResultUtils.splitHeadersIntoSeq(header.headers)
+    try {
+      headers.foreach {
+        case (name, value) => nettyResponse.headers().add(name, value)
+      }
+    } catch {
+      case NonFatal(e) =>
+        if (logger.isErrorEnabled) {
+          val prettyHeaders = headers.map { case (name, value) => s"$name -> $value" }.mkString("[", ",", "]")
+          val msg = s"Exception occurred while setting response's headers to $prettyHeaders. Action taken is to set the response's status to ${HttpResponseStatus.INTERNAL_SERVER_ERROR} and discard all headers."
+          logger.error(msg, e)
+        }
+        nettyResponse.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR)
+        nettyResponse.headers().clear()
     }
 
     // Response header Connection: Keep-Alive is needed for HTTP 1.0
