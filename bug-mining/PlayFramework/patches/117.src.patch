diff --git a/framework/src/play/src/main/scala/play/api/data/Forms.scala b/framework/src/play/src/main/scala/play/api/data/Forms.scala
index 9038886bb1..2e6afe55d2 100644
--- a/framework/src/play/src/main/scala/play/api/data/Forms.scala
+++ b/framework/src/play/src/main/scala/play/api/data/Forms.scala
@@ -534,7 +534,7 @@ object Forms {
    *   Form("birthdate" -> sqlDate)
    * }}}
    */
-  val sqlDate: Mapping[java.sql.Date] = of[java.sql.Date]
+  val sqlDate: Mapping[java.sql.Date] = of[java.sql.Date](sqlDateFormat)
 
   /**
    * Constructs a simple mapping for a date field (mapped as `sql.Date type`).
@@ -549,6 +549,29 @@ object Forms {
    */
   def sqlDate(pattern: String, timeZone: java.util.TimeZone = java.util.TimeZone.getDefault): Mapping[java.sql.Date] = of[java.sql.Date] as sqlDateFormat(pattern, timeZone)
 
+  /**
+   * Constructs a simple mapping for a timestamp field (mapped as `java.sql.Timestamp type`).
+   *
+   * For example:
+   * {{{
+   *   Form("birthdate" -> sqlTimestamp)
+   * }}}
+   */
+  val sqlTimestamp: Mapping[java.sql.Timestamp] = of[java.sql.Timestamp](sqlTimestampFormat)
+
+  /**
+   * Constructs a simple mapping for a Timestamp field (mapped as `java.sql.Timestamp type`).
+   *
+   * For example:
+   * {{{
+   *   Form("birthdate" -> sqlTimestamp("dd-MM-yyyy hh:mm:ss"))
+   * }}}
+   *
+   * @param pattern the date pattern, as defined in `java.text.SimpleDateFormat`
+   * @param timeZone the `java.util.TimeZone` to use for parsing and formatting
+   */
+  def sqlTimestamp(pattern: String, timeZone: java.util.TimeZone = java.util.TimeZone.getDefault): Mapping[java.sql.Timestamp] = of[java.sql.Timestamp] as sqlTimestampFormat(pattern, timeZone)
+
   /**
    * Constructs a simple mapping for an e-mail field.
    *
diff --git a/framework/src/play/src/main/scala/play/api/data/format/Format.scala b/framework/src/play/src/main/scala/play/api/data/format/Format.scala
index b98cc20353..9f9930528e 100644
--- a/framework/src/play/src/main/scala/play/api/data/format/Format.scala
+++ b/framework/src/play/src/main/scala/play/api/data/format/Format.scala
@@ -3,10 +3,9 @@
  */
 package play.api.data.format
 
-import java.text.{ DateFormat, SimpleDateFormat }
-import java.time.temporal.{ ChronoField, TemporalAccessor, TemporalField, TemporalQueries }
+import java.sql.Timestamp
 import java.time._
-import java.time.format.{ DateTimeFormatter, DateTimeFormatterBuilder, ResolverStyle }
+import java.time.format.DateTimeFormatter
 import java.util.UUID
 
 import play.api.data._
@@ -225,15 +224,15 @@ object Formats {
    */
   def sqlDateFormat(pattern: String, timeZone: TimeZone = TimeZone.getDefault): Formatter[java.sql.Date] = new Formatter[java.sql.Date] {
 
-    val dateFormatter = dateFormat(pattern, timeZone)
+    private val dateFormatter: Formatter[LocalDate] = localDateFormat(pattern)
 
     override val format = Some(("format.date", Seq(pattern)))
 
     def bind(key: String, data: Map[String, String]) = {
-      dateFormatter.bind(key, data).right.map(d => new java.sql.Date(d.getTime))
+      dateFormatter.bind(key, data).right.map(d => java.sql.Date.valueOf(d))
     }
 
-    def unbind(key: String, value: java.sql.Date) = dateFormatter.unbind(key, value)
+    def unbind(key: String, value: java.sql.Date) = dateFormatter.unbind(key, value.toLocalDate)
   }
 
   /**
@@ -241,6 +240,31 @@ object Formats {
    */
   implicit val sqlDateFormat: Formatter[java.sql.Date] = sqlDateFormat("yyyy-MM-dd")
 
+  /**
+   * Formatter for the `java.sql.Timestamp` type.
+   *
+   * @param pattern a date pattern as specified in `java.time.DateTimeFormatter`.
+   * @param timeZone the `java.util.TimeZone` to use for parsing and formatting
+   */
+  def sqlTimestampFormat(pattern: String, timeZone: TimeZone = TimeZone.getDefault): Formatter[java.sql.Timestamp] = new Formatter[java.sql.Timestamp] {
+
+    import java.time.LocalDateTime
+
+    private val formatter = java.time.format.DateTimeFormatter.ofPattern(pattern).withZone(timeZone.toZoneId)
+    private def timestampParse(data: String) = java.sql.Timestamp.valueOf(LocalDateTime.parse(data, formatter))
+
+    override val format = Some(("format.timestamp", Seq(pattern)))
+
+    override def bind(key: String, data: Map[String, String]): Either[Seq[FormError], Timestamp] = parsing(timestampParse, "error.timestamp", Nil)(key, data)
+
+    override def unbind(key: String, value: java.sql.Timestamp) = Map(key -> value.toLocalDateTime.format(formatter))
+  }
+
+  /**
+   * Default formatter for `java.sql.Timestamp` type with pattern `yyyy-MM-dd HH:mm:ss`.
+   */
+  implicit val sqlTimestampFormat: Formatter[java.sql.Timestamp] = sqlTimestampFormat("yyyy-MM-dd HH:mm:ss")
+
   /**
    * Formatter for the `java.time.LocalDate` type.
    *
diff --git a/framework/src/play/src/test/scala/play/api/data/FormSpec.scala b/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
index 284eb62b43..9bf3ca8d26 100644
--- a/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
@@ -358,42 +358,82 @@ class FormSpec extends Specification {
     import java.time.LocalDate
     val dateForm = Form("date" -> localDate)
     val data = Map("date" -> "2012-01-01")
-    dateForm.bind(data).get mustEqual (LocalDate.of(2012, 1, 1))
+    dateForm.bind(data).get must beEqualTo(LocalDate.of(2012, 1, 1))
   }
 
   "render form using java.time.LocalDate with format(15/6/2016)" in {
     import java.time.LocalDate
     val dateForm = Form("date" -> localDate("dd/MM/yyyy"))
     val data = Map("date" -> "15/06/2016")
-    dateForm.bind(data).get mustEqual (LocalDate.of(2016, 6, 15))
+    dateForm.bind(data).get must beEqualTo(LocalDate.of(2016, 6, 15))
   }
 
   "render form using java.time.LocalDateTime" in {
     import java.time.LocalDateTime
     val dateForm = Form("date" -> localDateTime)
     val data = Map("date" -> "2012-01-01 10:10:10")
-    dateForm.bind(data).get mustEqual (LocalDateTime.of(2012, 1, 1, 10, 10, 10))
+    dateForm.bind(data).get must beEqualTo(LocalDateTime.of(2012, 1, 1, 10, 10, 10))
   }
 
   "render form using java.time.LocalDateTime with format(17/06/2016T17:15:33)" in {
     import java.time.LocalDateTime
     val dateForm = Form("date" -> localDateTime("dd/MM/yyyy HH:mm:ss"))
     val data = Map("date" -> "17/06/2016 10:10:10")
-    dateForm.bind(data).get mustEqual (LocalDateTime.of(2016, 6, 17, 10, 10, 10))
+    dateForm.bind(data).get must beEqualTo(LocalDateTime.of(2016, 6, 17, 10, 10, 10))
   }
 
   "render form using java.time.LocalTime" in {
     import java.time.LocalTime
     val dateForm = Form("date" -> localTime)
     val data = Map("date" -> "10:10:10")
-    dateForm.bind(data).get mustEqual (LocalTime.of(10, 10, 10))
+    dateForm.bind(data).get must beEqualTo(LocalTime.of(10, 10, 10))
   }
 
   "render form using java.time.LocalTime with format(HH-mm-ss)" in {
     import java.time.LocalTime
     val dateForm = Form("date" -> localTime("HH-mm-ss"))
     val data = Map("date" -> "10-11-12")
-    dateForm.bind(data).get mustEqual (LocalTime.of(10, 11, 12))
+    dateForm.bind(data).get must beEqualTo(LocalTime.of(10, 11, 12))
+  }
+
+  "render form using java.sql.Date" in {
+    import java.time.LocalDate
+    val dateForm = Form("date" -> sqlDate)
+    val data = Map("date" -> "2017-07-04")
+    val date = dateForm.bind(data).get.toLocalDate
+    date must beEqualTo(LocalDate.of(2017, 7, 4))
+  }
+
+  "render form using java.sql.Date with format(dd-MM-yyyy)" in {
+    import java.time.LocalDate
+    val dateForm = Form("date" -> sqlDate("dd-MM-yyyy"))
+    val data = Map("date" -> "04-07-2017")
+    val date = dateForm.bind(data).get.toLocalDate
+    date must beEqualTo(LocalDate.of(2017, 7, 4))
+  }
+
+  "render form using java.sql.Timestamp" in {
+    import java.time.LocalDateTime
+    val dateForm = Form("date" -> sqlTimestamp)
+    val data = Map("date" -> "2017-07-04 10:11:12")
+    val date = dateForm.bind(data).get.toLocalDateTime
+    date must beEqualTo(LocalDateTime.of(2017, 7, 4, 10, 11, 12))
+  }
+
+  "render form using java.sql.Date with format(dd/MM/yyyy HH-mm-ss)" in {
+    import java.time.LocalDateTime
+    val dateForm = Form("date" -> sqlTimestamp("dd/MM/yyyy HH-mm-ss"))
+    val data = Map("date" -> "04/07/2017 10-11-12")
+    val date = dateForm.bind(data).get.toLocalDateTime
+    date must beEqualTo(LocalDateTime.of(2017, 7, 4, 10, 11, 12))
+  }
+
+  "render form using java.time.Timestamp with format(17/06/2016T17:15:33)" in {
+    import java.time.LocalDateTime
+    val dateForm = Form("date" -> sqlTimestamp("dd/MM/yyyy HH:mm:ss"))
+    val data = Map("date" -> "17/06/2016 10:10:10")
+    val date = dateForm.bind(data).get.toLocalDateTime
+    date must beEqualTo(LocalDateTime.of(2016, 6, 17, 10, 10, 10))
   }
 
 }
@@ -463,7 +503,7 @@ object ScalaForms {
   )
 
   val form = Form(
-    "foo" -> Forms.text.verifying("first.digit", s => s.headOption exists { _ == '3' })
+    "foo" -> Forms.text.verifying("first.digit", s => s.headOption contains '3')
       .transform[Int](Integer.parseInt, _.toString).verifying("number.42", _ < 42)
   )
 
diff --git a/framework/src/play/src/test/scala/play/api/data/format/FormatSpec.scala b/framework/src/play/src/test/scala/play/api/data/format/FormatSpec.scala
index 67611b646f..6a82d15c52 100644
--- a/framework/src/play/src/test/scala/play/api/data/format/FormatSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/data/format/FormatSpec.scala
@@ -3,13 +3,120 @@
  */
 package play.api.data.format
 
+import java.sql
+import java.sql.Timestamp
+import java.time.{ LocalDate, LocalDateTime }
+
 import org.specs2.mutable.Specification
-import java.util.{ UUID, Date, TimeZone }
+import java.util.{ Date, TimeZone, UUID }
 
 import play.api.data._
 import play.api.data.Forms._
 
 class FormatSpec extends Specification {
+
+  "A java.sql.Date format" should {
+    "support formatting with a pattern" in {
+      val data = Map("date" -> "04-07-2017")
+      val format = Formats.sqlDateFormat("dd-MM-yyyy")
+      val bindResult = format.bind("date", data)
+
+      bindResult.right.map(_.toLocalDate.getDayOfMonth) should beRight(4)
+      bindResult.right.map(_.toLocalDate.getMonth) should beRight(java.time.Month.JULY)
+      bindResult.right.map(_.toLocalDate.getYear) should beRight(2017)
+    }
+
+    "use yyyy-MM-dd as the default format" in {
+      val data = Map("date" -> "2017-07-04")
+      val format = Formats.sqlDateFormat
+      val bindResult = format.bind("date", data)
+
+      bindResult.right.map(_.toLocalDate.getDayOfMonth) should beRight(4)
+      bindResult.right.map(_.toLocalDate.getMonth) should beRight(java.time.Month.JULY)
+      bindResult.right.map(_.toLocalDate.getYear) should beRight(2017)
+    }
+
+    "fails when form data is using the wrong pattern" in {
+      val data = Map("date" -> "04-07-2017") // default pattern is yyyy-MM-dd, so this is wrong
+      val format = Formats.sqlDateFormat
+
+      format.bind("date", data) should beLeft
+    }
+
+    "fails with the correct message key when using the wrong pattern" in {
+      val data = Map("date" -> "04-07-2017") // default pattern is yyyy-MM-dd, so this is wrong
+      val format = Formats.sqlDateFormat
+
+      format.bind("date", data) should beLeft.which(_.exists(_.message.equals("error.date")))
+    }
+
+    "convert raw data to form data using the given pattern" in {
+      val format = Formats.sqlDateFormat("dd-MM-yyyy")
+      val localDate = LocalDate.of(2017, java.time.Month.JULY, 4)
+      format.unbind("date", java.sql.Date.valueOf(localDate)).get("date") must beSome("04-07-2017")
+    }
+
+    "convert raw data to form data using the default pattern" in {
+      val format = Formats.sqlDateFormat
+      val localDate = LocalDate.of(2017, java.time.Month.JULY, 4)
+      format.unbind("date", java.sql.Date.valueOf(localDate)).get("date") must beSome("2017-07-04")
+    }
+  }
+
+  "A java.sql.Timestamp format" should {
+    "support formatting with a pattern" in {
+      val data = Map("date" -> "04-07-2017 10:11:12")
+      val format = Formats.sqlTimestampFormat("dd-MM-yyyy HH:mm:ss")
+      val bindResult = format.bind("date", data)
+
+      bindResult.right.map(_.toLocalDateTime.getDayOfMonth) should beRight(4)
+      bindResult.right.map(_.toLocalDateTime.getMonth) should beRight(java.time.Month.JULY)
+      bindResult.right.map(_.toLocalDateTime.getYear) should beRight(2017)
+      bindResult.right.map(_.toLocalDateTime.getHour) should beRight(10)
+      bindResult.right.map(_.toLocalDateTime.getMinute) should beRight(11)
+      bindResult.right.map(_.toLocalDateTime.getSecond) should beRight(12)
+    }
+
+    "use yyyy-MM-dd HH:ss:mm as the default format" in {
+      val data = Map("date" -> "2017-07-04 10:11:12")
+      val format = Formats.sqlTimestampFormat
+      val bindResult = format.bind("date", data)
+
+      bindResult.right.map(_.toLocalDateTime.getDayOfMonth) should beRight(4)
+      bindResult.right.map(_.toLocalDateTime.getMonth) should beRight(java.time.Month.JULY)
+      bindResult.right.map(_.toLocalDateTime.getYear) should beRight(2017)
+      bindResult.right.map(_.toLocalDateTime.getHour) should beRight(10)
+      bindResult.right.map(_.toLocalDateTime.getMinute) should beRight(11)
+      bindResult.right.map(_.toLocalDateTime.getSecond) should beRight(12)
+    }
+
+    "fails when form data is using the wrong pattern" in {
+      val data = Map("date" -> "04-07-2017") // default pattern is yyyy-MM-dd, so this is wrong
+      val format = Formats.sqlTimestampFormat
+
+      format.bind("date", data) should beLeft
+    }
+
+    "fails with the correct message key when using the wrong pattern" in {
+      val data = Map("date" -> "04-07-2017") // default pattern is yyyy-MM-dd, so this is wrong
+      val format = Formats.sqlTimestampFormat
+
+      format.bind("date", data) should beLeft.which(_.exists(_.message.equals("error.timestamp")))
+    }
+
+    "convert raw data to form data using the given pattern" in {
+      val format = Formats.sqlTimestampFormat("dd-MM-yyyy HH:mm:ss")
+      val localDateTime = LocalDateTime.of(2017, java.time.Month.JULY, 4, 10, 11, 12)
+      format.unbind("date", Timestamp.valueOf(localDateTime)).get("date") must beSome("04-07-2017 10:11:12")
+    }
+
+    "convert raw data to form data using the default pattern" in {
+      val format = Formats.sqlTimestampFormat
+      val localDateTime = LocalDateTime.of(2017, java.time.Month.JULY, 4, 10, 11, 12)
+      format.unbind("date", java.sql.Timestamp.valueOf(localDateTime)).get("date") must beSome("2017-07-04 10:11:12")
+    }
+  }
+
   "dateFormat" should {
     "support custom time zones" in {
       val data = Map("date" -> "00:00")
