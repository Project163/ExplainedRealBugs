diff --git a/cache/play-caffeine-cache/src/main/java/play/cache/caffeine/CaffeineDefaultExpiry.java b/cache/play-caffeine-cache/src/main/java/play/cache/caffeine/CaffeineDefaultExpiry.java
deleted file mode 100644
index 7fc1685e20..0000000000
--- a/cache/play-caffeine-cache/src/main/java/play/cache/caffeine/CaffeineDefaultExpiry.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
- */
-
-package play.cache.caffeine;
-
-import com.github.benmanes.caffeine.cache.Expiry;
-
-import javax.annotation.Nonnull;
-
-public final class CaffeineDefaultExpiry implements Expiry<Object, Object> {
-  @Override
-  public long expireAfterCreate(@Nonnull Object key, @Nonnull Object value, long currentTime) {
-    return Long.MAX_VALUE;
-  }
-
-  @Override
-  public long expireAfterUpdate(
-      @Nonnull Object key, @Nonnull Object value, long currentTime, long currentDuration) {
-    return currentDuration;
-  }
-
-  @Override
-  public long expireAfterRead(
-      @Nonnull Object key, @Nonnull Object value, long currentTime, long currentDuration) {
-    return currentDuration;
-  }
-}
diff --git a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheApi.scala b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheApi.scala
index c5f57d3dbf..edf064ba74 100644
--- a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheApi.scala
+++ b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheApi.scala
@@ -22,9 +22,9 @@ import play.api.inject._
 import play.api.Configuration
 import play.cache.NamedCacheImpl
 import play.cache.SyncCacheApiAdapter
-import play.cache.{ AsyncCacheApi => JavaAsyncCacheApi }
-import play.cache.{ DefaultAsyncCacheApi => JavaDefaultAsyncCacheApi }
-import play.cache.{ SyncCacheApi => JavaSyncCacheApi }
+import play.cache.{AsyncCacheApi => JavaAsyncCacheApi}
+import play.cache.{DefaultAsyncCacheApi => JavaDefaultAsyncCacheApi}
+import play.cache.{SyncCacheApi => JavaSyncCacheApi}
 
 import scala.compat.java8.DurationConverters
 import scala.concurrent.duration.Duration
@@ -205,22 +205,16 @@ class SyncCaffeineCacheApi @Inject()(val cache: NamedCaffeineCache[Any, Any]) ex
   override def remove(key: String): Unit = syncCache.invalidate(key)
 
   override def getOrElseUpdate[A: ClassTag](key: String, expiration: Duration)(orElse: => A): A = {
-    get[A](key) match {
-      case Some(value) => value
-      case None =>
-        val value = orElse
-        set(key, value, expiration)
-        value
-    }
+    cache.get(key, _ => ExpirableCacheValue(orElse, Some(expiration))).asInstanceOf[ExpirableCacheValue[A]].value
   }
 
   override def get[T](key: String)(implicit ct: ClassTag[T]): Option[T] = {
-    Option(syncCache.getIfPresent(key))
+    Option(syncCache.getIfPresent(key).asInstanceOf[ExpirableCacheValue[T]])
       .filter { v =>
-        Primitives.wrap(ct.runtimeClass).isInstance(v) ||
-        ct == ClassTag.Nothing || (ct == ClassTag.Unit && v == ((): Unit))
+        Primitives.wrap(ct.runtimeClass).isInstance(v.value) ||
+        ct == ClassTag.Nothing || (ct == ClassTag.Unit && v.value == ((): Unit))
       }
-      .asInstanceOf[Option[T]]
+      .map(_.value)
   }
 }
 
@@ -247,10 +241,7 @@ class CaffeineCacheApi @Inject()(val cache: NamedCaffeineCache[Any, Any])(implic
   }
 
   def getOrElseUpdate[A: ClassTag](key: String, expiration: Duration)(orElse: => Future[A]): Future[A] = {
-    get[A](key).flatMap {
-      case Some(value) => Future.successful(value)
-      case None        => orElse.flatMap(value => set(key, value, expiration).map(_ => value))
-    }
+    orElse.map(orElseValue => sync.getOrElseUpdate(key, expiration)(orElseValue))
   }
 
   def removeAll(): Future[Done] = Future {
diff --git a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheManager.scala b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheManager.scala
index 52545421e2..761499c57f 100644
--- a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheManager.scala
+++ b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineCacheManager.scala
@@ -10,7 +10,6 @@ import java.util.concurrent.ConcurrentMap
 import com.github.benmanes.caffeine.cache.AsyncCache
 import com.github.benmanes.caffeine.cache.Caffeine
 import com.typesafe.config.Config
-import play.cache.caffeine.CaffeineDefaultExpiry
 import play.cache.caffeine.CaffeineParser
 import play.cache.caffeine.NamedCaffeineCache
 
@@ -34,7 +33,7 @@ class CaffeineCacheManager(private var config: Config) {
 
   private[caffeine] def getCacheBuilder(cacheName: String): Caffeine[_, _] = {
     var cacheBuilder: Caffeine[_, _]         = null
-    val defaultExpiry: CaffeineDefaultExpiry = new CaffeineDefaultExpiry()
+    val defaultExpiry: CaffeineDefaultExpiry = new CaffeineDefaultExpiry
     val caches: Config                       = config.getConfig("caches")
     val defaults: Config                     = config.getConfig("defaults")
     var cacheConfig: Config                  = null
diff --git a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineDefaultExpiry.scala b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineDefaultExpiry.scala
new file mode 100644
index 0000000000..69dd927c51
--- /dev/null
+++ b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/CaffeineDefaultExpiry.scala
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package play.api.cache.caffeine
+
+import com.github.benmanes.caffeine.cache.Expiry
+
+class CaffeineDefaultExpiry extends Expiry[String, ExpirableCacheValue[Any]] {
+
+  def expireAfterCreate(key: String, value: ExpirableCacheValue[Any], currentTime: Long): Long = {
+    value.durationMaybe match {
+      case Some(duration) if duration.isFinite => duration.toNanos
+      case _ => Long.MaxValue
+    }
+  }
+
+  def expireAfterUpdate(key: String, value: ExpirableCacheValue[Any], currentTime: Long, currentDuration: Long): Long = {
+    currentDuration
+  }
+
+  def expireAfterRead(key: String, value: ExpirableCacheValue[Any], currentTime: Long, currentDuration: Long): Long = {
+    currentDuration
+  }
+
+}
\ No newline at end of file
diff --git a/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/ExpirableCacheValue.scala b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/ExpirableCacheValue.scala
new file mode 100644
index 0000000000..3cd0e20f42
--- /dev/null
+++ b/cache/play-caffeine-cache/src/main/scala/play/api/cache/caffeine/ExpirableCacheValue.scala
@@ -0,0 +1,9 @@
+/*
+ * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package play.api.cache.caffeine
+
+import scala.concurrent.duration.Duration
+
+case class ExpirableCacheValue[V](value: V, durationMaybe: Option[Duration] = None)
diff --git a/cache/play-caffeine-cache/src/test/scala/play/api/cache/caffeine/CaffeineCacheApiSpec.scala b/cache/play-caffeine-cache/src/test/scala/play/api/cache/caffeine/CaffeineCacheApiSpec.scala
index bd0ece1027..21a4d238a4 100644
--- a/cache/play-caffeine-cache/src/test/scala/play/api/cache/caffeine/CaffeineCacheApiSpec.scala
+++ b/cache/play-caffeine-cache/src/test/scala/play/api/cache/caffeine/CaffeineCacheApiSpec.scala
@@ -4,10 +4,10 @@
 
 package play.api.cache.caffeine
 
-import java.util.concurrent.Executors
+import java.util.concurrent.{Executors, TimeUnit}
+
 import javax.inject.Inject
 import javax.inject.Provider
-
 import play.api.cache.AsyncCacheApi
 import play.api.cache.SyncCacheApi
 import play.api.inject._
@@ -99,6 +99,35 @@ class CaffeineCacheApiSpec extends PlaySpecification {
       Await.result(cacheApi.removeAll(), 1.second) must be(akka.Done)
       Await.result(cacheApi.get("foo"), 1.second) must beNone
     }
+
+    "put and return the value given with orElse function if there is no value with the given key" in new WithApplication() {
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val result: String = syncCacheApi.getOrElseUpdate("aaa")("ddd")
+      result mustEqual "ddd"
+      val resultFromCacheMaybe = syncCacheApi.get("aaa")
+      resultFromCacheMaybe must beSome("ddd")
+    }
+
+    "asynchronously put and return the value given with orElse function if there is no value with the given key" in new WithApplication() {
+      val asyncCacheApi = app.injector.instanceOf[AsyncCacheApi]
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val resultFuture: Future[String] = asyncCacheApi.getOrElseUpdate[String]("aaa")(Future.successful("ddd"))
+      val result: String = Await.result(resultFuture, 2.seconds)
+      result mustEqual "ddd"
+      val resultFromCacheFuture = asyncCacheApi.get("aaa")
+      val resultFromCacheMaybe = Await.result(resultFromCacheFuture, 2.seconds)
+      resultFromCacheMaybe must beSome("ddd")
+    }
+
+    "expire the item after the given amount of time is passed" in new WithApplication() {
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val expiration = 1.second
+      val result: String = syncCacheApi.getOrElseUpdate("aaa", expiration)("ddd")
+      result mustEqual "ddd"
+      Thread.sleep(expiration.toMillis) // be sure that expire duration passes
+      val resultMaybe = syncCacheApi.get("aaa")
+      resultMaybe must beNone
+    }
   }
 }
 
diff --git a/cache/play-ehcache/src/main/scala/play/api/cache/ehcache/EhCacheApi.scala b/cache/play-ehcache/src/main/scala/play/api/cache/ehcache/EhCacheApi.scala
index 0b35f9fc2c..ca1b719a76 100644
--- a/cache/play-ehcache/src/main/scala/play/api/cache/ehcache/EhCacheApi.scala
+++ b/cache/play-ehcache/src/main/scala/play/api/cache/ehcache/EhCacheApi.scala
@@ -209,13 +209,15 @@ class SyncEhCacheApi @Inject()(private[ehcache] val cache: Ehcache) extends Sync
   override def remove(key: String): Unit = cache.remove(key)
 
   override def getOrElseUpdate[A: ClassTag](key: String, expiration: Duration)(orElse: => A): A = {
-    get[A](key) match {
-      case Some(value) => value
-      case None =>
-        val value = orElse
-        set(key, value, expiration)
-        value
+    val newElement = new Element(key, orElse)
+    if (expiration.isFinite) {
+      newElement.setTimeToIdle(expiration.toSeconds.toInt)
+    } else {
+      newElement.setEternal(true)
     }
+    val elementFromCache = cache.putIfAbsent(newElement)
+    val element = if (elementFromCache != null) elementFromCache else newElement
+    element.getObjectValue.asInstanceOf[A]
   }
 
   override def get[T](key: String)(implicit ct: ClassTag[T]): Option[T] = {
@@ -252,10 +254,7 @@ class EhCacheApi @Inject()(private[ehcache] val cache: Ehcache)(implicit context
   }
 
   def getOrElseUpdate[A: ClassTag](key: String, expiration: Duration)(orElse: => Future[A]): Future[A] = {
-    get[A](key).flatMap {
-      case Some(value) => Future.successful(value)
-      case None        => orElse.flatMap(value => set(key, value, expiration).map(_ => value))
-    }
+    orElse.map(orElseValue => sync.getOrElseUpdate(key, expiration)(orElseValue))
   }
 
   def removeAll(): Future[Done] = Future {
diff --git a/cache/play-ehcache/src/test/scala/play/api/cache/ehcache/EhCacheApiSpec.scala b/cache/play-ehcache/src/test/scala/play/api/cache/ehcache/EhCacheApiSpec.scala
index 05cb280b7f..ffd5c2edec 100644
--- a/cache/play-ehcache/src/test/scala/play/api/cache/ehcache/EhCacheApiSpec.scala
+++ b/cache/play-ehcache/src/test/scala/play/api/cache/ehcache/EhCacheApiSpec.scala
@@ -24,7 +24,7 @@ import scala.concurrent.Future
 class EhCacheApiSpec extends PlaySpecification {
   sequential
 
-  "SyncCacheApi" should {
+  "CacheApi" should {
     "bind named caches" in new WithApplication(
       _.configure(
         "play.cache.bindCaches" -> Seq("custom")
@@ -57,6 +57,35 @@ class EhCacheApiSpec extends PlaySpecification {
       syncCacheApi.getOrElseUpdate("foo")("baz") must_== "bar"
     }
 
+    "put and return the value given with orElse function if there is no value with the given key" in new WithApplication() {
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val result: String = syncCacheApi.getOrElseUpdate("aaa")("ddd")
+      result mustEqual "ddd"
+      val resultFromCacheMaybe = syncCacheApi.get("aaa")
+      resultFromCacheMaybe must beSome("ddd")
+    }
+
+    "asynchronously put and return the value given with orElse function if there is no value with the given key" in new WithApplication() {
+      val asyncCacheApi = app.injector.instanceOf[AsyncCacheApi]
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val resultFuture: Future[String] = asyncCacheApi.getOrElseUpdate[String]("aaa")(Future.successful("ddd"))
+      val result: String = Await.result(resultFuture, 2.seconds)
+      result mustEqual "ddd"
+      val resultFromCacheFuture = asyncCacheApi.get("aaa")
+      val resultFromCacheMaybe = Await.result(resultFromCacheFuture, 2.seconds)
+      resultFromCacheMaybe must beSome("ddd")
+    }
+
+    "expire the item after the given amount of time is passed" in new WithApplication() {
+      val syncCacheApi = app.injector.instanceOf[SyncCacheApi]
+      val expiration = 1.second
+      val result: String = syncCacheApi.getOrElseUpdate("aaa", expiration)("ddd")
+      result mustEqual "ddd"
+      Thread.sleep(expiration.toMillis) // be sure that expire duration passes
+      val resultMaybe = syncCacheApi.get("aaa")
+      resultMaybe must beNone
+    }
+
     "get values from cache without deadlocking" in new WithApplication(
       _.overrides(
         bind[ExecutionContext].toInstance(ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1)))
