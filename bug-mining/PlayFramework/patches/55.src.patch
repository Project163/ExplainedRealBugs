diff --git a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
index 96457f00ae..03aa085899 100644
--- a/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
+++ b/documentation/manual/working/scalaGuide/main/ws/code/ScalaWSSpec.scala
@@ -20,6 +20,7 @@ import scala.concurrent.duration._
 
 import play.api.mvc._
 import play.api.libs.ws._
+import play.api.http.HttpEntity
 
 import akka.actor.ActorSystem
 import akka.stream.ActorMaterializer
@@ -43,14 +44,6 @@ case class Person(name: String, age: Int)
 @RunWith(classOf[JUnitRunner])
 class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
 
-  // This needs to be removed when https://github.com/playframework/playframework/issues/4688 is fixed.
-  import play.api.libs.iteratee._
-  implicit def source2enumerator(source: Source[ByteString, _]): Enumerator[Array[Byte]] = {
-    import play.api.libs.streams.Streams
-    val publisher = source.map(_.toArray).runWith(Sink.publisher)
-    Streams.publisherToEnumerator(publisher)
-  }
-
   val url = s"http://localhost:$testServerPort/"
 
   // #scalaws-context
@@ -357,7 +350,7 @@ class ScalaWSSpec extends PlaySpecification with Results with AfterAll {
                   // If there's a content length, send that, otherwise return the body chunked
                   response.headers.get("Content-Length") match {
                     case Some(Seq(length)) =>
-                      Ok.feed(body).as(contentType).withHeaders("Content-Length" -> length)
+                      Ok.sendEntity(HttpEntity.Streamed(body, Some(length.toLong), Some(contentType)))
                     case _ =>
                       Ok.chunked(body).as(contentType)
                   }
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
index fdb8b14c53..23874451c1 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/NingWS.scala
@@ -5,21 +5,16 @@ package play.api.libs.ws.ning
 
 import akka.stream.scaladsl.Source
 import akka.util.ByteString
-
 import org.asynchttpclient.{ Response => AHCResponse, _ }
 import org.asynchttpclient.proxy.{ ProxyServer => AHCProxyServer }
 import org.asynchttpclient.Realm.{ RealmBuilder, AuthScheme }
 import org.asynchttpclient.cookie.{ Cookie => AHCCookie }
 import org.asynchttpclient.util.AsyncHttpProviderUtils
-
 import java.io.IOException
 import java.io.UnsupportedEncodingException
 import java.nio.charset.{ Charset, StandardCharsets }
-
 import javax.inject.{ Inject, Provider, Singleton }
-
 import io.netty.handler.codec.http.HttpHeaders
-
 import play.api._
 import play.api.inject.{ ApplicationLifecycle, Module }
 import play.api.libs.iteratee.Enumerator
@@ -28,7 +23,6 @@ import play.api.libs.ws.ssl._
 import play.api.libs.ws.ssl.debug._
 import play.core.parsers.FormUrlEncodedParser
 import play.core.utils.CaseInsensitiveOrdered
-
 import scala.collection.JavaConverters._
 import scala.collection.immutable.TreeMap
 import scala.concurrent.{ Future, Promise }
@@ -147,8 +141,8 @@ case class NingWSRequest(client: NingWSClient,
 
   def stream(): Future[StreamedResponse] = StreamedRequest.execute(client.underlying, buildRequest())
 
-  def streamWithEnumerator(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] =
-    StreamedRequest.executeAndReturnEnumerator(client.underlying, buildRequest())
+  @deprecated("2.5", "Use `stream()` instead.")
+  def streamWithEnumerator(): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = StreamedRequest.execute2(client.underlying, buildRequest())
 
   /**
    * Returns the current headers of the request, using the request builder.  This may be signed,
diff --git a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala
index 1dd03d9118..5168bc534f 100644
--- a/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala
+++ b/framework/src/play-ws/src/main/scala/play/api/libs/ws/ning/StreamedRequest.scala
@@ -1,135 +1,113 @@
 package play.api.libs.ws.ning
 
+import akka.stream.scaladsl.Source
+import akka.util.ByteString
+import java.lang.IllegalStateException
 import scala.concurrent.Future
 import scala.concurrent.Promise
-
-import org.asynchttpclient.AsyncHandler
+import org.asynchttpclient.handler.StreamedAsyncHandler
 import org.asynchttpclient.AsyncHandler.State
-import org.asynchttpclient.AsyncHttpClient;
+import org.asynchttpclient.AsyncHttpClient
 import org.asynchttpclient.HttpResponseBodyPart
 import org.asynchttpclient.HttpResponseHeaders
 import org.asynchttpclient.HttpResponseStatus
 import org.asynchttpclient.Request
-
-import akka.stream.scaladsl.Source
-import akka.util.ByteString
-import play.api.libs.iteratee.Done
+import org.reactivestreams.Publisher
 import play.api.libs.iteratee.Enumerator
-import play.api.libs.iteratee.Error
-import play.api.libs.iteratee.Input.El
-import play.api.libs.iteratee.Iteratee
-import play.api.libs.iteratee.Step
 import play.api.libs.streams.Streams
 import play.api.libs.ws.DefaultWSResponseHeaders
 import play.api.libs.ws.WSResponseHeaders
 import play.api.libs.ws.StreamedResponse
+import org.reactivestreams.Subscriber
+import org.reactivestreams.Subscription
 
 private[play] object StreamedRequest {
 
   def execute(client: AsyncHttpClient, request: Request): Future[StreamedResponse] = {
-    val result = executeAndReturnEnumerator(client, request)
-    import play.core.Execution.Implicits.internalContext
-    result.map {
-      case (response, enumerator) =>
-        val publisher = Streams.enumeratorToPublisher(enumerator)
-        StreamedResponse(response, Source(publisher).map(ByteString(_)))
+    val promise = Promise[(WSResponseHeaders, Publisher[HttpResponseBodyPart])]()
+    client.executeRequest(request, new DefaultStreamedAsyncHandler(promise))
+    import play.api.libs.iteratee.Execution.Implicits.trampoline
+    promise.future.map {
+      case (headers, publisher) =>
+        // this transformation is not part of `DefaultStreamedAsyncHandler.onCompleted` because 
+        // a reactive-streams `Publisher` needs to be returned to implement `execute2`. Though, 
+        // once `execute2` is removed, we should move the code here inside 
+        // `DefaultStreamedAsyncHandler.onCompleted`.
+        val source = Source(publisher).map(bodyPart => ByteString(bodyPart.getBodyPartBytes))
+        StreamedResponse(headers, source)
     }
   }
 
-  def executeAndReturnEnumerator(client: AsyncHttpClient, request: Request): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
-    val result = Promise[(WSResponseHeaders, Enumerator[Array[Byte]])]()
-
-    val errorInStream = Promise[Unit]()
+  // This method was introduced because in Play we have utilities that makes it easy to convert a `Publisher` into an `Enumerator`, 
+  // while it's not as easy to convert an akka-stream Source to a reactive-streams `Publisher` (as it requires materialization of 
+  // the stream). This is why `DefaultStreamedAsyncHandler`'s constructor takes a `Promise[(WSResponseHeaders, Publisher[HttpResponseBodyPart])]` 
+  // and not a `Promise[(WSResponseHeaders, Source[ByteString])]`. In fact, the moment this method is removed, we should refactor the 
+  // `DefaultStreamedAsyncHandler`' constructor parameter's type to the latter.
+  // This method is `deprecated` because we should remember to remove it together with `NingWSRequest.streamWithEnumerator`.
+  @deprecated("2.5", "Use `execute()` instead.")
+  def execute2(client: AsyncHttpClient, request: Request): Future[(WSResponseHeaders, Enumerator[Array[Byte]])] = {
+    val promise = Promise[(WSResponseHeaders, Publisher[HttpResponseBodyPart])]()
+    client.executeRequest(request, new DefaultStreamedAsyncHandler(promise))
+    import play.api.libs.iteratee.Execution.Implicits.trampoline
+    promise.future.map {
+      case (headers, publisher) =>
+        val enumerator = Streams.publisherToEnumerator(publisher).map(_.getBodyPartBytes)
+        (headers, enumerator)
+    }
+  }
 
-    val promisedIteratee = Promise[Iteratee[Array[Byte], Unit]]()
+  private class DefaultStreamedAsyncHandler(promise: Promise[(WSResponseHeaders, Publisher[HttpResponseBodyPart])]) extends StreamedAsyncHandler[Unit] {
+    private var statusCode: Int = _
+    private var responseHeaders: WSResponseHeaders = _
+    private var publisher: Publisher[HttpResponseBodyPart] = _
 
-    @volatile var doneOrError = false
-    @volatile var statusCode = 0
-    @volatile var current: Iteratee[Array[Byte], Unit] = Iteratee.flatten(promisedIteratee.future)
+    def onStream(publisher: Publisher[HttpResponseBodyPart]): State = {
+      if (this.publisher != null) State.ABORT
+      else {
+        this.publisher = publisher
+        promise.success((responseHeaders, publisher))
+        State.CONTINUE
+      }
+    }
 
-    client.executeRequest(request, new AsyncHandler[Unit]() {
-      @throws(classOf[Exception])
-      override def onStatusReceived(status: HttpResponseStatus): State = {
+    override def onStatusReceived(status: HttpResponseStatus): State = {
+      if (this.publisher != null) State.ABORT
+      else {
         statusCode = status.getStatusCode
         State.CONTINUE
       }
+    }
 
-      @throws(classOf[Exception])
-      override def onHeadersReceived(h: HttpResponseHeaders): State = {
+    override def onHeadersReceived(h: HttpResponseHeaders): State = {
+      if (this.publisher != null) State.ABORT
+      else {
         val headers = h.getHeaders
-
-        val responseHeader = DefaultWSResponseHeaders(statusCode, NingWSRequest.ningHeadersToMap(headers))
-        val enumerator = new Enumerator[Array[Byte]]() {
-          def apply[A](i: Iteratee[Array[Byte], A]) = {
-
-            val doneIteratee = Promise[Iteratee[Array[Byte], A]]()
-
-            import play.api.libs.iteratee.Execution.Implicits.trampoline
-
-            // Map it so that we can complete the iteratee when it returns
-            val mapped = i.map {
-              a =>
-                doneIteratee.trySuccess(Done(a))
-                ()
-            }.recover {
-              // but if an error happens, we want to propogate that
-              case e =>
-                doneIteratee.tryFailure(e)
-                throw e
-            }
-
-            // Redeem the iteratee that we promised to the AsyncHandler
-            promisedIteratee.trySuccess(mapped)
-
-            // If there's an error in the stream from upstream, then fail this returned future with that
-            errorInStream.future.onFailure {
-              case e => doneIteratee.tryFailure(e)
-            }
-
-            doneIteratee.future
-          }
-        }
-
-        result.trySuccess((responseHeader, enumerator))
+        responseHeaders = DefaultWSResponseHeaders(statusCode, NingWSRequest.ningHeadersToMap(headers))
         State.CONTINUE
       }
+    }
 
-      @throws(classOf[Exception])
-      override def onBodyPartReceived(bodyPart: HttpResponseBodyPart): State = {
-        if (!doneOrError) {
-          import play.api.libs.concurrent.Execution.Implicits.defaultContext
-          current = current.pureFlatFold {
-            case Step.Done(a, e) =>
-              doneOrError = true
-              Done(a, e)
-
-            case Step.Cont(k) =>
-              k(El(bodyPart.getBodyPartBytes))
-
-            case Step.Error(e, input) =>
-              doneOrError = true
-              Error(e, input)
+    override def onBodyPartReceived(bodyPart: HttpResponseBodyPart): State =
+      throw new IllegalStateException("Should not have received body part")
 
-          }
-          State.CONTINUE
-        } else {
-          current = null
-          // Must close underlying connection, otherwise async http client will drain the stream
-          bodyPart.markUnderlyingConnectionAsToBeClosed()
-          State.ABORT
-        }
-      }
+    override def onCompleted(): Unit = {
+      // EmptyPublisher can be replaces with `Source.empty` when we carry out the refactoring 
+      // mentioned in the `execute2` method.
+      promise.trySuccess((responseHeaders, EmptyPublisher))
+    }
 
-      @throws(classOf[Exception])
-      override def onCompleted(): Unit = {
-        Option(current).foreach(_.run)
-      }
+    override def onThrowable(t: Throwable): Unit = promise.tryFailure(t)
+  }
 
-      override def onThrowable(t: Throwable): Unit = {
-        result.tryFailure(t)
-        errorInStream.tryFailure(t)
-      }
-    })
-    result.future
+  private case object EmptyPublisher extends Publisher[HttpResponseBodyPart] {
+    def subscribe(s: Subscriber[_ >: HttpResponseBodyPart]): Unit = {
+      if (s eq null) throw new NullPointerException("Subscriber must not be null, rule 1.9")
+      s.onSubscribe(CancelledSubscription)
+      s.onComplete()
+    }
+    private case object CancelledSubscription extends Subscription {
+      override def request(elements: Long): Unit = ()
+      override def cancel(): Unit = ()
+    }
   }
 }
\ No newline at end of file
