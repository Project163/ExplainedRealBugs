diff --git a/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java b/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
index 0ecc11608c..f290eefab8 100644
--- a/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
+++ b/documentation/manual/working/javaGuide/advanced/routing/code/javaguide/advanced/routing/JavaRoutingDsl.java
@@ -13,12 +13,13 @@ import static play.mvc.Controller.*;
 //#imports
 
 import play.mvc.Result;
+import play.test.WithApplication;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
 import static play.test.Helpers.*;
 
-public class JavaRoutingDsl {
+public class JavaRoutingDsl extends WithApplication {
     @Test
     public void simple() {
         //#simple
diff --git a/documentation/manual/working/javaGuide/code/MockJavaAction.scala b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
index 043735fdb2..c5ed779701 100644
--- a/documentation/manual/working/javaGuide/code/MockJavaAction.scala
+++ b/documentation/manual/working/javaGuide/code/MockJavaAction.scala
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com>
  */
-package javaguide.testhelpers
+package javaguide.testhelpers {
 
 import akka.stream.Materializer
 import play.api.mvc.{Action, Request}
@@ -12,21 +12,30 @@ import play.api.test.Helpers
 import play.libs.F
 import java.lang.reflect.Method
 
-abstract class MockJavaAction extends Controller with Action[Http.RequestBody] { self =>
+abstract class MockJavaAction extends Controller with Action[Http.RequestBody] {
+  self =>
 
-  private lazy val action = new JavaAction(new JavaHandlerComponents(
+  private lazy val components = new JavaHandlerComponents(
     play.api.Play.current.injector, new DefaultHttpRequestHandler
-  )) {
+  )
+
+  private lazy val action = new JavaAction(components) {
     val annotations = new JavaActionAnnotations(controller, method)
-    def parser = annotations.parser
+
+    def parser = play.HandlerInvokerFactoryAccessor.javaBodyParserToScala(
+      components.injector.instanceOf(annotations.parser)
+    )
+
     def invocation = self.invocation
   }
 
   def parser = action.parser
+
   def apply(request: Request[Http.RequestBody]) = action.apply(request)
 
   private val controller = this.getClass
   private val method = MockJavaActionJavaMocker.findActionMethod(this)
+
   def invocation = {
     method.invoke(this) match {
       case r: Result => F.Promise.pure(r)
@@ -36,6 +45,7 @@ abstract class MockJavaAction extends Controller with Action[Http.RequestBody] {
 }
 
 object MockJavaActionHelper {
+
   import Helpers.defaultAwaitTimeout
 
   def call(action: Action[Http.RequestBody], requestBuilder: play.mvc.Http.RequestBuilder): Result = {
@@ -73,3 +83,16 @@ object MockJavaActionJavaMocker {
     theMethod
   }
 }
+
+}
+
+/**
+ * javaBodyParserToScala is private to play
+ */
+package play {
+
+object HandlerInvokerFactoryAccessor {
+  val javaBodyParserToScala = play.core.routing.HandlerInvokerFactory.javaBodyParserToScala _
+}
+
+}
\ No newline at end of file
diff --git a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
index 9e68043463..ccb2ace691 100644
--- a/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
+++ b/documentation/manual/working/javaGuide/main/http/JavaBodyParsers.md
@@ -52,6 +52,6 @@ Text based body parsers (such as **text**, **json**, **xml** or **formUrlEncoded
 
 For parsers that buffer content on disk, such as the raw parser or `multipart/form-data`, the maximum content length is specified using the `play.http.parser.maxDiskBuffer` property, it defaults to 10MB.  The `multipart/form-data` parser also enforces the text max length property for the aggregate of the data fields.
 
-You can also override the default maximum content length for a given action via the `@BodyParser.Of` annotation:
+You can also override the default maximum content length for a given action by defining a custom body parser that defines the maximum length.  For example:
 
 @[max-length](code/javaguide/http/JavaBodyParsers.java)
diff --git a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
index a6928892ab..af04688128 100644
--- a/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
+++ b/documentation/manual/working/javaGuide/main/http/code/javaguide/http/JavaBodyParsers.java
@@ -6,6 +6,7 @@ package javaguide.http;
 import akka.stream.Materializer;
 import org.junit.Before;
 import org.junit.Test;
+import play.http.HttpErrorHandler;
 import play.libs.Json;
 import play.test.WithApplication;
 import javaguide.testhelpers.MockJavaAction;
@@ -15,6 +16,8 @@ import play.mvc.*;
 import play.mvc.Http.*;
 //#imports
 
+import javax.inject.Inject;
+
 import static javaguide.testhelpers.MockJavaActionHelper.*;
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.*;
@@ -28,7 +31,7 @@ public class JavaBodyParsers extends WithApplication {
             //#request-body
             public Result index() {
                 RequestBody body = request().body();
-                return ok("Got body: " + body);
+                return ok("Got body: " + body.asText());
             }
             //#request-body
         }, fakeRequest().bodyText("foo"))), containsString("foo"));
@@ -74,16 +77,24 @@ public class JavaBodyParsers extends WithApplication {
             body.append("1234567890");
         }
         Materializer mat = app.injector().instanceOf(Materializer.class);
-        assertThat(callWithStringBody(new MockJavaAction() {
-                    //#max-length
-                    // Accept only 10KB of data.
-                    @BodyParser.Of(value = BodyParser.Text.class, maxLength = 10 * 1024)
-                    public Result index() {
-                        return ok("Got body: " + request().body().asText());
-                    }
-                    //#max-length
-                }, fakeRequest(), body.toString(), mat).status(),
+        assertThat(callWithStringBody(new MaxLengthAction(), fakeRequest(), body.toString(), mat).status(),
                 equalTo(413));
     }
 
+    public static class MaxLengthAction extends MockJavaAction {
+        //#max-length
+        // Accept only 10KB of data.
+        public static class Text10Kb extends BodyParser.Text {
+            @Inject
+            public Text10Kb(HttpErrorHandler errorHandler) {
+                super(10 * 1024, errorHandler);
+            }
+        }
+
+        @BodyParser.Of(Text10Kb.class)
+        public Result index() {
+            return ok("Got body: " + request().body().asText());
+        }
+        //#max-length
+    }
 }
diff --git a/documentation/manual/working/javaGuide/main/upload/code/JavaFileUpload.java b/documentation/manual/working/javaGuide/main/upload/code/JavaFileUpload.java
index 6d52bcc2dd..32251e7b24 100644
--- a/documentation/manual/working/javaGuide/main/upload/code/JavaFileUpload.java
+++ b/documentation/manual/working/javaGuide/main/upload/code/JavaFileUpload.java
@@ -1,12 +1,13 @@
 import play.mvc.Controller;
+import java.io.File;
 
 public class JavaFileUpload {
 
     static class SyncUpload extends Controller {
         //#syncUpload
         public static play.mvc.Result upload() {
-            play.mvc.Http.MultipartFormData body = request().body().asMultipartFormData();
-            play.mvc.Http.MultipartFormData.FilePart picture = body.getFile("picture");
+            play.mvc.Http.MultipartFormData<File> body = request().body().asMultipartFormData();
+            play.mvc.Http.MultipartFormData.FilePart<File> picture = body.getFile("picture");
             if (picture != null) {
                 String fileName = picture.getFilename();
                 String contentType = picture.getContentType();
diff --git a/framework/src/iteratees/src/main/scala/play/api/libs/iteratee/Execution.scala b/framework/src/iteratees/src/main/scala/play/api/libs/iteratee/Execution.scala
index a7081616c8..505fc84c60 100644
--- a/framework/src/iteratees/src/main/scala/play/api/libs/iteratee/Execution.scala
+++ b/framework/src/iteratees/src/main/scala/play/api/libs/iteratee/Execution.scala
@@ -5,7 +5,7 @@ package play.api.libs.iteratee
 
 import java.util.ArrayDeque
 import scala.annotation.tailrec
-import scala.concurrent.ExecutionContext
+import scala.concurrent.{ ExecutionContextExecutor, ExecutionContext }
 
 /**
  * Contains the default ExecutionContext used by Iteratees.
@@ -16,7 +16,7 @@ object Execution {
 
   object Implicits {
     implicit def defaultExecutionContext: ExecutionContext = Execution.trampoline
-    implicit def trampoline: ExecutionContext = Execution.trampoline
+    implicit def trampoline: ExecutionContextExecutor = Execution.trampoline
   }
 
   /**
@@ -28,7 +28,7 @@ object Execution {
    * Blocking should be strictly avoided as it could hog the current thread.
    * Also, since we're running on a single thread, blocking code risks deadlock.
    */
-  object trampoline extends ExecutionContext {
+  object trampoline extends ExecutionContextExecutor {
 
     /*
      * A ThreadLocal value is used to track the state of the trampoline in the current
diff --git a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
index e6ec61fcea..f744a048ec 100644
--- a/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
+++ b/framework/src/play-filters-helpers/src/main/java/play/filters/csrf/RequireCSRFCheckAction.java
@@ -13,6 +13,7 @@ import play.mvc.Result;
 import scala.Option;
 
 import javax.inject.Inject;
+import java.util.Map;
 
 public class RequireCSRFCheckAction extends Action<RequireCSRFCheck> {
 
@@ -54,7 +55,8 @@ public class RequireCSRFCheckAction extends Action<RequireCSRFCheck> {
                             tokenToCheck = values[0];
                         }
                     } else if (ctx.request().body().asMultipartFormData() != null) {
-                        String[] values = ctx.request().body().asMultipartFormData().asFormUrlEncoded().get(config.tokenName());
+                        Map<String, String[]> form = ctx.request().body().asMultipartFormData().asFormUrlEncoded();
+                        String[] values = form.get(config.tokenName());
                         if (values != null && values.length > 0) {
                             tokenToCheck = values[0];
                         }
diff --git a/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala b/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
index f796a76d04..d6472d70d2 100644
--- a/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
+++ b/framework/src/play-filters-helpers/src/main/scala/play/filters/csrf/csrf.scala
@@ -209,9 +209,17 @@ object CSRF {
       JavaHelpers.invokeWithContext(request, req => underlying.handle(req, msg))
   }
 
+  class JavaCSRFErrorHandlerDelegate @Inject() (delegate: ErrorHandler) extends CSRFErrorHandler {
+    import play.api.libs.iteratee.Execution.Implicits.trampoline
+
+    def handle(req: Http.RequestHeader, msg: String) =
+      play.libs.F.Promise.wrap(delegate.handle(req._underlyingHeader(), msg).map(_.asJava))
+  }
+
   object ErrorHandler {
     def bindingsFromConfiguration(environment: Environment, configuration: Configuration): Seq[Binding[_]] = {
-      Reflect.bindingsFromConfiguration[ErrorHandler, CSRFErrorHandler, JavaCSRFErrorHandlerAdapter, CSRFHttpErrorHandler](environment, PlayConfig(configuration), "play.filters.csrf.errorHandler", "CSRFErrorHandler")
+      Reflect.bindingsFromConfiguration[ErrorHandler, CSRFErrorHandler, JavaCSRFErrorHandlerAdapter, JavaCSRFErrorHandlerDelegate, CSRFHttpErrorHandler](environment, PlayConfig(configuration),
+        "play.filters.csrf.errorHandler", "CSRFErrorHandler")
     }
   }
 
diff --git a/framework/src/play-filters-helpers/src/test/scala/play/filters/csrf/JavaCSRFActionSpec.scala b/framework/src/play-filters-helpers/src/test/scala/play/filters/csrf/JavaCSRFActionSpec.scala
index 478598547c..a97ac79c86 100644
--- a/framework/src/play-filters-helpers/src/test/scala/play/filters/csrf/JavaCSRFActionSpec.scala
+++ b/framework/src/play-filters-helpers/src/test/scala/play/filters/csrf/JavaCSRFActionSpec.scala
@@ -5,6 +5,7 @@ package play.filters.csrf
 
 import play.api.libs.Crypto
 import play.api.mvc.Session
+import play.core.routing.HandlerInvokerFactory
 import play.libs.F.Promise
 import play.mvc.Http.{ RequestHeader, Context }
 
@@ -25,7 +26,9 @@ object JavaCSRFActionSpec extends CSRFCommonSpecs {
 
   def javaAction[T: ClassTag](method: String, inv: => Result) = new JavaAction(javaHandlerComponents) {
     val clazz = implicitly[ClassTag[T]].runtimeClass
-    def parser = annotations.parser
+    def parser = HandlerInvokerFactory.javaBodyParserToScala(
+      javaHandlerComponents.injector.instanceOf(annotations.parser)
+    )
     def invocation = F.Promise.pure(inv)
     val annotations = new JavaActionAnnotations(clazz, clazz.getMethod(method))
   }
diff --git a/framework/src/play-integration-test/src/test/java/play/routing/RoutingDslTest.java b/framework/src/play-integration-test/src/test/java/play/routing/RoutingDslTest.java
index 39f37e5654..91bcd0f5f0 100644
--- a/framework/src/play-integration-test/src/test/java/play/routing/RoutingDslTest.java
+++ b/framework/src/play-integration-test/src/test/java/play/routing/RoutingDslTest.java
@@ -9,6 +9,7 @@ import play.libs.F;
 import play.mvc.PathBindable;
 import play.mvc.Result;
 import play.mvc.Results;
+import play.test.WithApplication;
 
 import java.io.InputStream;
 
@@ -19,7 +20,7 @@ import static play.test.Helpers.*;
 /**
  * This class is in the integration tests so that we have the right helper classes to build a request with to test it.
  */
-public class RoutingDslTest {
+public class RoutingDslTest extends WithApplication {
 
     @Test
     public void noParameters() {
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/JAction.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/JAction.scala
index 454e9c3ad0..7b05f2b240 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/JAction.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/JAction.scala
@@ -6,6 +6,7 @@ package play.it.http
 import play.api._
 import play.api.mvc.EssentialAction
 import play.core.j.{ JavaHandlerComponents, JavaActionAnnotations, JavaAction }
+import play.core.routing.HandlerInvokerFactory
 import play.http.DefaultHttpRequestHandler
 import play.mvc.{ Http, Result }
 import play.libs.F.Promise
@@ -26,9 +27,10 @@ import play.libs.F.Promise
  */
 object JAction {
   def apply(app: Application, c: AbstractMockController): EssentialAction = {
-    new JavaAction(app.injector.instanceOf[JavaHandlerComponents]) {
+    val components = app.injector.instanceOf[JavaHandlerComponents]
+    new JavaAction(components) {
       val annotations = new JavaActionAnnotations(c.getClass, c.getClass.getMethod("action"))
-      val parser = annotations.parser
+      val parser = HandlerInvokerFactory.javaBodyParserToScala(components.injector.instanceOf(annotations.parser))
       def invocation = c.invocation
     }
   }
diff --git a/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala b/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
index 1a1f404299..6c5f5aa2ea 100644
--- a/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
+++ b/framework/src/play-java/src/main/scala/play/routing/RouterBuilderHelper.scala
@@ -3,10 +3,13 @@
  */
 package play.routing
 
-import play.api.mvc.{ Results, Action }
+import play.api.Play
+import play.api.http.{ JavaHttpErrorHandlerDelegate, HttpConfiguration }
+import play.api.mvc.{ BodyParser, Results, Action }
 import play.core.j.{ JavaParsers, JavaHelpers }
+import play.core.routing.HandlerInvokerFactory
 import play.libs.F
-import play.mvc.Http.Context
+import play.mvc.Http.{ RequestBody, Context }
 import play.mvc.Result
 import play.utils.UriEncoding
 import scala.collection.JavaConversions._
@@ -58,8 +61,15 @@ private[routing] object RouterBuilderHelper {
             val action = maybeParams match {
               case Left(error) => Action(Results.BadRequest(error))
               case Right(params) =>
+
                 // Convert to a Scala action
-                Action.async(JavaParsers.default_(-1)) { request =>
+                val parser = HandlerInvokerFactory.javaBodyParserToScala(
+                  // If testing an embedded application we may not have a Guice injector, therefore we can't rely on
+                  // it to instantiate the default body parser, we have to instantiate it ourselves.
+                  new play.mvc.BodyParser.Default(new JavaHttpErrorHandlerDelegate(Play.current.errorHandler),
+                    Play.current.injector.instanceOf[HttpConfiguration])
+                )
+                Action.async(parser) { request =>
                   val ctx = JavaHelpers.createJavaContext(request)
                   try {
                     Context.current.set(ctx)
diff --git a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
index 201306d8db..e47612fb0e 100644
--- a/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
+++ b/framework/src/play-streams/src/main/java/play/libs/streams/Accumulator.java
@@ -9,6 +9,7 @@ import scala.compat.java8.FutureConverters;
 import scala.concurrent.Future;
 
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
 import java.util.function.Function;
@@ -89,16 +90,46 @@ public final class Accumulator<E, A> {
      * @return A new accumulator that has recovered from errors.
      */
     public Accumulator<E, A> recoverWith(Function<? super Throwable, ? extends CompletionStage<A>> f, Executor executor) {
+        // Below is the way that this *should* be implemented, but doesn't work due to
+        // https://github.com/scala/scala-java8-compat/issues/29
+        //        return new Accumulator<>(
+        //                sink.mapMaterializedValue(cs ->
+        //                        cs.handleAsync((a, error) -> {
+        //                            if (a != null) {
+        //                                return CompletableFuture.completedFuture(a);
+        //                            } else {
+        //                                if (error instanceof CompletionException) {
+        //                                    return f.apply(error.getCause());
+        //                                } else {
+        //                                    return f.apply(error);
+        //                                }
+        //                            }
+        //                        }, executor).thenCompose(Function.identity()))
+        //        );
         return new Accumulator<>(
-                sink.mapMaterializedValue(cs ->
-                        cs.handleAsync((a, error) -> {
-                            if (a != null) {
-                                return CompletableFuture.completedFuture(a);
-                            } else {
-                                return f.apply(error);
+                sink.mapMaterializedValue(cs -> {
+                    CompletableFuture<A> future = new CompletableFuture<>();
+                    cs.whenCompleteAsync((a, error) -> {
+                        if (a != null) {
+                            future.complete(a);
+                        } else {
+                            try {
+                                CompletionStage<A> recovered;
+                                if (error instanceof CompletionException) {
+                                    recovered = f.apply(error.getCause());
+                                } else {
+                                    recovered = f.apply(error);
+                                }
+                                recovered.thenAccept(future::complete);
+                            } catch (Exception e) {
+                                future.completeExceptionally(e);
                             }
-                        }, executor).thenCompose(Function.identity()))
+                        }
+                    }, executor);
+                    return future;
+                })
         );
+
     }
 
     /**
@@ -169,7 +200,7 @@ public final class Accumulator<E, A> {
      * @param a The done value for the accumulator.
      * @return The accumulator.
      */
-    public static <A> Accumulator<Object, A> done(A a) {
+    public static <E, A> Accumulator<E, A> done(A a) {
         return done(CompletableFuture.completedFuture(a));
     }
 
@@ -179,8 +210,8 @@ public final class Accumulator<E, A> {
      * @param a A future of the done value.
      * @return The accumulator.
      */
-    public static <A> Accumulator<Object, A> done(CompletionStage<A> a) {
-        return new Accumulator<Object, A>(Sink.cancelled().mapMaterializedValue((unit) -> a));
+    public static <E, A> Accumulator<E, A> done(CompletionStage<A> a) {
+        return new Accumulator(Sink.cancelled().mapMaterializedValue((unit) -> a));
     }
 
 }
diff --git a/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala b/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
index c7728e292b..27ad046c73 100644
--- a/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
+++ b/framework/src/play-streams/src/main/scala/play/api/libs/streams/Accumulator.scala
@@ -90,12 +90,13 @@ final class Accumulator[-E, +A](sink: Sink[E, Future[A]]) {
    */
   def toSink: Sink[E, Future[A]] = sink
 
+  import scala.annotation.unchecked.{ uncheckedVariance => uV }
   /**
    * Convert this accumulator to a Java Accumulator.
    *
    * @return The Java accumulator.
    */
-  def asJava: play.libs.streams.Accumulator[_ >: E, _ <: A] = {
+  def asJava: play.libs.streams.Accumulator[E @uV, A @uV] = {
     play.libs.streams.Accumulator.fromSink(sink.asJava)
   }
 }
diff --git a/framework/src/play-test/src/main/java/play/test/Helpers.java b/framework/src/play-test/src/main/java/play/test/Helpers.java
index 624e4cedbc..b8d3217a7a 100644
--- a/framework/src/play-test/src/main/java/play/test/Helpers.java
+++ b/framework/src/play-test/src/main/java/play/test/Helpers.java
@@ -380,30 +380,10 @@ public class Helpers implements play.mvc.Http.Status, play.mvc.Http.HeaderNames
     @SuppressWarnings("unchecked")
     public static Result route(Application app, RequestBuilder requestBuilder, long timeout) {
       final scala.Option<scala.concurrent.Future<play.api.mvc.Result>> opt = play.api.test.Helpers.jRoute(
-          app.getWrappedApplication(), requestBuilder.build()._underlyingRequest(), requestBuilder.bodyAsAnyContent());
+          app.getWrappedApplication(), requestBuilder.build()._underlyingRequest(), requestBuilder.body());
       return wrapScalaResult(Scala.orNull(opt), timeout);
     }
 
-    @Deprecated
-    public static Result route(Application app, RequestBuilder requestBuilder, byte[] body) {
-      return route(app, requestBuilder, body, DEFAULT_TIMEOUT);
-    }
-
-    @Deprecated
-    public static Result route(Application app, RequestBuilder requestBuilder, byte[] body, long timeout) {
-      return wrapScalaResult(Scala.orNull(play.api.test.Helpers.jRoute(app.getWrappedApplication(), requestBuilder.build()._underlyingRequest(), body)), timeout);
-    }
-
-    @Deprecated
-    public static Result route(RequestBuilder requestBuilder, byte[] body) {
-      return route(requestBuilder, body, DEFAULT_TIMEOUT);
-    }
-
-    @Deprecated
-    public static Result route(RequestBuilder requestBuilder, byte[] body, long timeout) {
-      return route(play.Play.application(), requestBuilder, body, timeout);
-    }
-
     /**
      * Starts a new application.
      */
diff --git a/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala b/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
index fea75e2c28..96781fab21 100644
--- a/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
+++ b/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
@@ -5,6 +5,7 @@ package play.api.test
 
 import akka.stream.{ ClosedShape, Graph, Materializer }
 import akka.stream.scaladsl.Source
+import play.mvc.Http.RequestBody
 
 import scala.language.reflectiveCalls
 
@@ -212,16 +213,8 @@ trait RouteInvokers extends EssentialActionCaller {
   self: Writeables =>
 
   // Java compatibility
-  def jRoute[T](app: Application, r: RequestHeader, body: T): Option[Future[Result]] = {
-    (body: @unchecked) match {
-      case body: AnyContentAsFormUrlEncoded => route(app, r, body)
-      case body: AnyContentAsJson => route(app, r, body)
-      case body: AnyContentAsXml => route(app, r, body)
-      case body: AnyContentAsText => route(app, r, body)
-      case body: AnyContentAsRaw => route(app, r, body)
-      case body: AnyContentAsEmpty.type => route(app, r, body)
-      //case _ => MatchError is thrown
-    }
+  def jRoute[T](app: Application, r: RequestHeader, body: RequestBody): Option[Future[Result]] = {
+    route(app, r, body.asBytes())
   }
 
   /**
diff --git a/framework/src/play/src/main/java/play/libs/F.java b/framework/src/play/src/main/java/play/libs/F.java
index aa7b6fbfce..af7aa197dd 100644
--- a/framework/src/play/src/main/java/play/libs/F.java
+++ b/framework/src/play/src/main/java/play/libs/F.java
@@ -623,7 +623,7 @@ public class F {
          * @return A left sided disjoint union
          */
         public static <L, R> Either<L, R> Left(L value) {
-            return new Either<L, R>(Optional.ofNullable(value), Optional.<R>empty());
+            return new Either<L, R>(Optional.of(value), Optional.<R>empty());
         }
 
         /**
@@ -633,7 +633,7 @@ public class F {
          * @return A right sided disjoint union
          */
         public static <L, R> Either<L, R> Right(R value) {
-            return new Either<L, R>(Optional.<L>empty(), Optional.ofNullable(value));
+            return new Either<L, R>(Optional.<L>empty(), Optional.of(value));
         }
 
         @Override
diff --git a/framework/src/play/src/main/java/play/libs/XML.java b/framework/src/play/src/main/java/play/libs/XML.java
index af1b02f5e1..e522a4ef05 100644
--- a/framework/src/play/src/main/java/play/libs/XML.java
+++ b/framework/src/play/src/main/java/play/libs/XML.java
@@ -13,7 +13,14 @@ import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
 
+import akka.util.ByteString;
+import akka.util.ByteString$;
+import akka.util.ByteStringBuilder;
 import org.apache.xerces.impl.Constants;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
@@ -42,28 +49,56 @@ public class XML {
      * Parse an InputStream as DOM.
      */
     public static Document fromInputStream(InputStream in, String encoding) {
-       try {
+        InputSource is = new InputSource(in);
+        if (encoding != null) {
+            is.setEncoding(encoding);
+        }
 
-           DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance("org.apache.xerces.jaxp.DocumentBuilderFactoryImpl", XML.class.getClassLoader());
-           factory.setFeature(Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_GENERAL_ENTITIES_FEATURE, false);
-           factory.setFeature(Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_PARAMETER_ENTITIES_FEATURE, false);
-           factory.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.DISALLOW_DOCTYPE_DECL_FEATURE, true);
-           factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
-           factory.setNamespaceAware(true);
-           DocumentBuilder builder = factory.newDocumentBuilder();
+        return fromInputSource(is);
+    }
 
-           InputSource is = new InputSource(in);
-           is.setEncoding(encoding);
-           
-           return builder.parse(is);
+    /**
+     * Parse the input source as DOM.
+     *
+     * @param source The source to parse.
+     * @return The Document.
+     */
+    public static Document fromInputSource(InputSource source) {
+        try {
 
-       } catch (ParserConfigurationException e) {
-           throw new RuntimeException(e);
-       } catch (SAXException e) {
-           throw new RuntimeException(e);
-       } catch (IOException e) {
-           throw new RuntimeException(e);
-       }
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance("org.apache.xerces.jaxp.DocumentBuilderFactoryImpl", XML.class.getClassLoader());
+            factory.setFeature(Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_GENERAL_ENTITIES_FEATURE, false);
+            factory.setFeature(Constants.SAX_FEATURE_PREFIX + Constants.EXTERNAL_PARAMETER_ENTITIES_FEATURE, false);
+            factory.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.DISALLOW_DOCTYPE_DECL_FEATURE, true);
+            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+            factory.setNamespaceAware(true);
+            DocumentBuilder builder = factory.newDocumentBuilder();
+
+            return builder.parse(source);
+
+        } catch (ParserConfigurationException e) {
+            throw new RuntimeException(e);
+        } catch (SAXException e) {
+            throw new RuntimeException(e);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 
+    /**
+     * Convert the document to bytes.
+     *
+     * @param document The document to convert.
+     * @return The ByteString representation of the document.
+     */
+    public static ByteString toBytes(Document document) {
+        ByteStringBuilder builder = ByteString$.MODULE$.newBuilder();
+        try {
+            TransformerFactory.newInstance().newTransformer()
+                .transform(new DOMSource(document), new StreamResult(builder.asOutputStream()));
+        } catch (TransformerException e) {
+            throw new RuntimeException(e);
+        }
+        return builder.result();
+    }
 }
diff --git a/framework/src/play/src/main/java/play/mvc/BodyParser.java b/framework/src/play/src/main/java/play/mvc/BodyParser.java
index b2c5d6651b..dd7dd75b32 100644
--- a/framework/src/play/src/main/java/play/mvc/BodyParser.java
+++ b/framework/src/play/src/main/java/play/mvc/BodyParser.java
@@ -3,131 +3,448 @@
  */
 package play.mvc;
 
+import akka.stream.javadsl.Flow;
+import akka.stream.javadsl.Sink;
+import akka.util.ByteString;
+import com.fasterxml.jackson.databind.JsonNode;
+import org.w3c.dom.Document;
+import play.api.http.HttpConfiguration;
+import play.api.http.Status$;
+import play.api.libs.Files;
+import play.api.mvc.BodyParsers$;
+import play.core.j.JavaParsers;
+import play.core.parsers.FormUrlEncodedParser;
+import play.http.HttpErrorHandler;
+import play.libs.F;
+import play.libs.XML;
+import play.libs.streams.Accumulator;
+import scala.compat.java8.FutureConverters;
+
+import javax.inject.Inject;
+import java.io.File;
 import java.lang.annotation.*;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.function.Function;
 
 /**
  * A body parser parses the HTTP request body content.
  */
-public interface BodyParser {
+public interface BodyParser<A> {
 
-    play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength);
+    /**
+     * Return an accumulator to parse the body of the given HTTP request.
+     *
+     * The accumulator should either produce a result if an error was encountered, or the parsed body.
+     *
+     * @param request The request to create the body parser for.
+     * @return The accumulator to parse the body.
+     */
+    Accumulator<ByteString, F.Either<Result, A>> apply(Http.RequestHeader request);
 
     /**
      * Specify the body parser to use for an Action method.
      */
     @Target({ElementType.TYPE, ElementType.METHOD})
     @Retention(RetentionPolicy.RUNTIME)
-    public @interface Of {
+    @interface Of {
+
+        /**
+         * The class of the body parser to use.
+         */
         Class<? extends BodyParser> value();
+
+        /**
+         *
+         * @deprecated maxLength is now ignored. To define the maxLength globally, set
+         * play.http.parser.maxMemoryBuffer and play.http.parser.maxDiskBuffer. To define a custom max length for a
+         * particular action, create a custom body parser, optionally extending one of the existing ones and passing
+         * the max length into their constructors.
+         */
+        @Deprecated
         long maxLength() default -1;
     }
 
     /**
      * If PATCH, POST, or PUT, guess the body content by checking the Content-Type header.
      */
-    public static class Default implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.default_(maxLength);
+    class Default extends AnyContent {
+        @Inject
+        public Default(HttpErrorHandler errorHandler, HttpConfiguration httpConfiguration) {
+            super(errorHandler, httpConfiguration);
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, Object>> apply(Http.RequestHeader request) {
+            if (request.method().equals("POST") || request.method().equals("PUT") || request.method().equals("PATCH")) {
+                return super.apply(request);
+            } else {
+                return (Accumulator) new Empty().apply(request);
+            }
         }
     }
 
     /**
      * Guess the body content by checking the Content-Type header.
      */
-    public static class AnyContent implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.anyContent(maxLength);
+    class AnyContent implements BodyParser<Object> {
+        private final HttpErrorHandler errorHandler;
+        private final HttpConfiguration httpConfiguration;
+
+        @Inject
+        public AnyContent(HttpErrorHandler errorHandler, HttpConfiguration httpConfiguration) {
+            this.errorHandler = errorHandler;
+            this.httpConfiguration = httpConfiguration;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, Object>> apply(Http.RequestHeader request) {
+            String contentType = request.contentType().map(ct -> ct.toLowerCase(Locale.ENGLISH)).orElse(null);
+            BodyParser parser;
+            if (contentType == null) {
+                parser = new Raw();
+            } else if (contentType.equals("text/plain")) {
+                parser = new TolerantText(httpConfiguration, errorHandler);
+            } else if (contentType.equals("text/xml") || contentType.equals("application/xml") ||
+                    JavaParsers.parse().ApplicationXmlMatcher().pattern().matcher(contentType).matches()) {
+                parser = new TolerantXml(httpConfiguration, errorHandler);
+            } else if (contentType.equals("text/json") || contentType.equals("application/json")) {
+                parser = new TolerantJson(httpConfiguration, errorHandler);
+            } else if (contentType.equals("application/x-www-form-urlencoded")) {
+                parser = new FormUrlEncoded(httpConfiguration, errorHandler);
+            } else if (contentType.equals("multipart/form-data")) {
+                parser = new MultipartFormData();
+            } else {
+                parser = new Raw();
+            }
+            return parser.apply(request);
         }
     }
 
     /**
      * Parse the body as Json if the Content-Type is text/json or application/json.
      */
-    public static class Json implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.json(maxLength);
+    class Json extends TolerantJson {
+        private final HttpErrorHandler errorHandler;
+
+        public Json(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Inject
+        public Json(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, JsonNode>> apply(Http.RequestHeader request) {
+            return BodyParsers.validateContentType(errorHandler, request, "Expected application/json",
+                ct -> ct.equalsIgnoreCase("application/json") || ct.equalsIgnoreCase("text/json"),
+                super::apply
+            );
         }
     }
 
     /**
      * Parse the body as Json without checking the Content-Type.
      */
-    public static class TolerantJson implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.tolerantJson(maxLength);
+    class TolerantJson extends BufferingBodyParser<JsonNode> {
+        public TolerantJson(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler, "Error decoding json body");
+        }
+
+        @Inject
+        public TolerantJson(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler, "Error decoding json body");
+        }
+
+        @Override
+        protected JsonNode parse(Http.RequestHeader request, ByteString bytes) throws Exception {
+            return play.libs.Json.parse(bytes.iterator().asInputStream());
         }
     }
 
     /**
      * Parse the body as Xml if the Content-Type is application/xml.
      */
-    public static class Xml implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.xml(maxLength);
+    class Xml extends TolerantXml {
+        private final HttpErrorHandler errorHandler;
+
+        public Xml(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Inject
+        public Xml(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, Document>> apply(Http.RequestHeader request) {
+            return BodyParsers.validateContentType(errorHandler, request, "Expected XML",
+                ct -> ct.startsWith("text/xml") || ct.startsWith("application/xml") ||
+                    JavaParsers.parse().ApplicationXmlMatcher().pattern().matcher(ct).matches(),
+                super::apply
+            );
         }
     }
 
     /**
      * Parse the body as Xml without checking the Content-Type.
      */
-    public static class TolerantXml implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.tolerantXml(maxLength);
+    class TolerantXml extends BufferingBodyParser<Document> {
+        public TolerantXml(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler, "Error decoding xml body");
+        }
+
+        @Inject
+        public TolerantXml(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler, "Error decoding xml body");
+        }
+
+        @Override
+        protected Document parse(Http.RequestHeader request, ByteString bytes) throws Exception {
+            return XML.fromInputStream(bytes.iterator().asInputStream(), request.charset().orElse(null));
         }
     }
 
     /**
      * Parse the body as text if the Content-Type is text/plain.
      */
-    public static class Text implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.text(maxLength);
+    class Text extends TolerantText {
+        private final HttpErrorHandler errorHandler;
+
+        public Text(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Inject
+        public Text(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler);
+            this.errorHandler = errorHandler;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, String>> apply(Http.RequestHeader request) {
+            return BodyParsers.validateContentType(errorHandler, request, "Expected text/plain",
+                ct -> ct.equalsIgnoreCase("text/plain"), super::apply
+            );
         }
     }
 
     /**
      * Parse the body as text without checking the Content-Type.
      */
-    public static class TolerantText implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.tolerantText(maxLength);
+    class TolerantText extends BufferingBodyParser<String> {
+
+        public TolerantText(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler, "Error decoding text body");
+        }
+
+        @Inject
+        public TolerantText(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler, "Error decoding text body");
+        }
+
+        @Override
+        protected String parse(Http.RequestHeader request, ByteString bytes) throws Exception {
+            String charset = request.charset().orElse("ISO-8859-1");
+            return bytes.decodeString(charset);
+        }
+    }
+
+    /**
+     * Parse the body as a byte string.
+     */
+    class Bytes extends BufferingBodyParser<ByteString> {
+
+        public Bytes(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler, "Error decoding byte body");
+        }
+
+        @Inject
+        public Bytes(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler, "Error decoding byte body");
+        }
+
+        @Override
+        protected ByteString parse(Http.RequestHeader request, ByteString bytes) throws Exception {
+            return bytes;
         }
     }
 
     /**
      * Store the body content in a RawBuffer.
      */
-    public static class Raw implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.raw(maxLength);
+    class Raw extends DelegatingBodyParser<Http.RawBuffer, play.api.mvc.RawBuffer> {
+        @Inject
+        public Raw() {
+            super(JavaParsers.parse().raw(), JavaParsers::toJavaRaw);
         }
     }
 
     /**
      * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
      */
-    public static class FormUrlEncoded implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.formUrlEncoded(maxLength);
+    class FormUrlEncoded extends BufferingBodyParser<Map<String, String[]>> {
+        private final HttpErrorHandler errorHandler;
+
+        public FormUrlEncoded(long maxLength, HttpErrorHandler errorHandler) {
+            super(maxLength, errorHandler, "Error parsing form");
+            this.errorHandler = errorHandler;
+        }
+
+        @Inject
+        public FormUrlEncoded(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler) {
+            super(httpConfiguration, errorHandler, "Error parsing form");
+            this.errorHandler = errorHandler;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, Map<String, String[]>>> apply(Http.RequestHeader request) {
+            return BodyParsers.validateContentType(errorHandler, request, "Expected application/x-www-form-urlencoded",
+                    ct -> ct.equalsIgnoreCase("application/x-www-form-urlencoded"), super::apply);
+        }
+
+        @Override
+        protected Map<String, String[]> parse(Http.RequestHeader request, ByteString bytes) throws Exception {
+            String charset = request.charset().orElse("ISO-8859-1");
+            return FormUrlEncodedParser.parseAsJavaArrayValues(bytes.decodeString(charset), charset);
         }
     }
 
     /**
-     * Parse the body as form url encoded without checking the Content-Type.
+     * Parse the body as multipart form-data without checking the Content-Type.
      */
-    public static class MultipartFormData implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            return play.core.j.JavaParsers.multipartFormData(maxLength);
+    class MultipartFormData extends DelegatingBodyParser<Http.MultipartFormData<File>, play.api.mvc.MultipartFormData<Files.TemporaryFile>> {
+        @Inject
+        public MultipartFormData() {
+            super(JavaParsers.parse().multipartFormData(), JavaParsers::toJavaMultipartFormData);
         }
     }
 
     /**
      * Don't parse the body.
      */
-    public static class Empty implements BodyParser {
-        public play.api.mvc.BodyParser<Http.RequestBody> parser(long maxLength) {
-            if (maxLength != -1) throw new IllegalArgumentException("Empty BodyParser's maxLength argument is ignored so it must have a value of -1, was: " + maxLength);
-            return play.core.j.JavaParsers.empty();
+    class Empty implements BodyParser<Optional<Void>> {
+        @Override
+        public Accumulator<ByteString, F.Either<Result, Optional<Void>>> apply(Http.RequestHeader request) {
+            return Accumulator.done(F.Either.Right(Optional.empty()));
+        }
+    }
+
+    /**
+     * Abstract body parser that enforces a maximum length.
+     */
+    abstract class MaxLengthBodyParser<A> implements BodyParser<A> {
+        private final long maxLength;
+        private final HttpErrorHandler errorHandler;
+
+        protected MaxLengthBodyParser(long maxLength, HttpErrorHandler errorHandler) {
+            this.maxLength = maxLength;
+            this.errorHandler = errorHandler;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, A>> apply(Http.RequestHeader request) {
+            return apply1(request).through(
+                    Flow.<ByteString>create()
+                            .transform(() -> new BodyParsers$.TakeUpTo(maxLength))
+            ).recoverWith(exception -> {
+                if (exception instanceof play.api.mvc.BodyParsers$.MaxLengthLimitAttained) {
+                    return FutureConverters.toJava(
+                            errorHandler.onClientError(request, Status$.MODULE$.REQUEST_ENTITY_TOO_LARGE(), "Request entity too large")
+                                    .map(F.Either::<Result, A>Left).wrapped());
+                } else {
+                    CompletableFuture<F.Either<Result, A>> cf = new CompletableFuture<>();
+                    cf.completeExceptionally(exception);
+                    return cf;
+                }
+            }, JavaParsers.trampoline());
+        }
+
+        /**
+         * Implement this method to implement the actual body parser.
+         */
+        protected abstract Accumulator<ByteString, F.Either<Result, A>> apply1(Http.RequestHeader request);
+    }
+
+    /**
+     * A body parser that first buffers
+     */
+    abstract class BufferingBodyParser<A> extends MaxLengthBodyParser<A> {
+        private final HttpErrorHandler errorHandler;
+        private final String errorMessage;
+
+        protected BufferingBodyParser(long maxLength, HttpErrorHandler errorHandler, String errorMessage) {
+            super(maxLength, errorHandler);
+            this.errorHandler = errorHandler;
+            this.errorMessage = errorMessage;
+        }
+
+        protected BufferingBodyParser(HttpConfiguration httpConfiguration, HttpErrorHandler errorHandler,
+                                      String errorMessage) {
+            this(httpConfiguration.parser().maxMemoryBuffer(), errorHandler, errorMessage);
+        }
+
+        @Override
+        protected final Accumulator<ByteString, F.Either<Result, A>> apply1(Http.RequestHeader request) {
+            return Accumulator.fromSink(Sink.fold(ByteString.empty(), ByteString::concat)).mapFuture(bytes -> {
+                try {
+                    return CompletableFuture.completedFuture(F.Either.Right(parse(request, bytes)));
+                } catch (Exception e) {
+                    return FutureConverters.toJava(errorHandler.onClientError(request, Status$.MODULE$.BAD_REQUEST(), errorMessage + ": " + e.getMessage()).wrapped())
+                            .thenApply(F.Either::<Result, A>Left);
+                }
+            }, JavaParsers.trampoline());
+        }
+
+        /**
+         * Parse the body.
+         *
+         * @param request The request associated with the body.
+         * @param bytes The bytes of the body.
+         * @return The body.
+         * @throws Exception If the body failed to parse.  It is assumed that any exceptions thrown by this method are
+         *      the fault of the client, so a 400 bad request error will be returned if this method throws an exception.
+         */
+        protected abstract A parse(Http.RequestHeader request, ByteString bytes) throws Exception;
+
+    }
+
+    /**
+     * A body parser that delegates to a Scala body parser, and uses the supplied function to transform its result to
+     * a Java body.
+     */
+    abstract class DelegatingBodyParser<A, B> implements BodyParser<A> {
+        private final play.api.mvc.BodyParser<B> delegate;
+        private final Function<B, A> transform;
+
+        public DelegatingBodyParser(play.api.mvc.BodyParser<B> delegate, Function<B, A> transform) {
+            this.delegate = delegate;
+            this.transform = transform;
+        }
+
+        @Override
+        public Accumulator<ByteString, F.Either<Result, A>> apply(Http.RequestHeader request) {
+            Accumulator<ByteString, scala.util.Either<play.api.mvc.Result, B>> javaAccumulator =
+                    delegate.apply(request._underlyingHeader()).asJava();
+            return javaAccumulator.map(result -> {
+                        if (result.isLeft()) {
+                            return F.Either.Left(result.left().get().asJava());
+                        } else {
+                            return F.Either.Right(transform.apply(result.right().get()));
+                        }
+                    },
+                    JavaParsers.trampoline()
+            );
         }
     }
 
diff --git a/framework/src/play/src/main/java/play/mvc/BodyParsers.java b/framework/src/play/src/main/java/play/mvc/BodyParsers.java
new file mode 100644
index 0000000000..65daa7e2ab
--- /dev/null
+++ b/framework/src/play/src/main/java/play/mvc/BodyParsers.java
@@ -0,0 +1,44 @@
+package play.mvc;
+
+import akka.util.ByteString;
+import play.api.http.Status$;
+import play.http.HttpErrorHandler;
+import play.libs.F;
+import play.libs.streams.Accumulator;
+import scala.compat.java8.FutureConverters;
+
+import java.util.concurrent.CompletionStage;
+import java.util.function.Function;
+
+/**
+ * Utilities for creating body parsers.
+ */
+public class BodyParsers {
+
+    /**
+     * Validate the content type of the passed in request using the given validator.
+     *
+     * If the validator returns true, the passed in accumulator will be returned to parse the body, otherwise an
+     * accumulator with a result created by the error handler will be returned.
+     *
+     * @param errorHandler The error handler used to create a bad request result if the content type is not valid.
+     * @param request The request to validate.
+     * @param errorMessage The error message to pass to the error handler if the content type is not valid.
+     * @param validate The validation function.
+     * @param parser The parser to use if the content type is valid.
+     * @return An accumulator to parse tho body.
+     */
+    public static <A> Accumulator<ByteString, F.Either<Result, A>> validateContentType(HttpErrorHandler errorHandler,
+               Http.RequestHeader request, String errorMessage, Function<String, Boolean> validate,
+               Function<Http.RequestHeader, Accumulator<ByteString, F.Either<Result, A>>> parser) {
+        if (request.contentType().map(validate).orElse(false)) {
+            return parser.apply(request);
+        } else {
+            CompletionStage<Result> result = FutureConverters.toJava(
+                    errorHandler.onClientError(request, Status$.MODULE$.UNSUPPORTED_MEDIA_TYPE(), errorMessage).wrapped()
+            );
+            return Accumulator.done(result.thenApply(F.Either::Left));
+        }
+    }
+
+}
diff --git a/framework/src/play/src/main/java/play/mvc/Http.java b/framework/src/play/src/main/java/play/mvc/Http.java
index 991d68f9ab..0b92e52efa 100644
--- a/framework/src/play/src/main/java/play/mvc/Http.java
+++ b/framework/src/play/src/main/java/play/mvc/Http.java
@@ -9,12 +9,18 @@ import java.io.*;
 import java.net.URISyntaxException;
 import java.net.URI;
 import java.net.URLDecoder;
+import java.net.URLEncoder;
 import java.util.*;
 import java.util.Map.Entry;
+import java.util.stream.Collectors;
 
 import akka.util.ByteString;
 import akka.util.ByteString$;
+import akka.util.ByteStringBuilder;
 import akka.util.CompactByteString;
+import play.core.j.JavaParsers;
+import play.libs.Json;
+import play.libs.XML;
 import scala.Predef;
 import scala.Tuple2;
 import scala.collection.JavaConversions;
@@ -500,6 +506,20 @@ public class Http {
          */
         boolean hasHeader(String headerName);
 
+        /**
+         * Get the content type of the request.
+         *
+         * @return The request content type excluding the charset, if it exists.
+         */
+        Optional<String> contentType();
+
+        /**
+         * Get the charset of the request.
+         *
+         * @return The request charset, which comes from the content type header, if it exists.
+         */
+        Optional<String> charset();
+
         /**
          * For internal Play-use only
          */
@@ -625,7 +645,7 @@ public class Http {
      */
     public static class RequestBuilder {
 
-        protected AnyContent body;
+        protected RequestBody body;
         protected String username;
 
         /**
@@ -637,29 +657,13 @@ public class Http {
           host("localhost");
           version("HTTP/1.1");
           remoteAddress("127.0.0.1");
-          body(play.api.mvc.AnyContentAsEmpty$.MODULE$);
+          body(new RequestBody(null));
         }
 
         /**
          * @return the request body, if a previously the body has been set
          */
         public RequestBody body() {
-            if (body == null) {
-                return null;
-            }
-            return new play.core.j.JavaParsers.DefaultRequestBody(
-                body.asFormUrlEncoded(),
-                body.asRaw(),
-                body.asText(),
-                body.asJson(),
-                body.asXml(),
-                body.asMultipartFormData());
-        }
-
-        /**
-         * @return the body of the request
-         */
-        public AnyContent bodyAsAnyContent() {
             return body;
         }
 
@@ -680,22 +684,24 @@ public class Http {
         }
 
         /**
-         * Set a AnyContent to this request.
-         * @param anyContent the AnyContent
+         * Set the body of the request.
+         *
+         * @param body the body
          * @param contentType Content-Type header value
          */
-        protected RequestBuilder body(AnyContent anyContent, String contentType) {
+        protected RequestBuilder body(RequestBody body, String contentType) {
             header("Content-Type", contentType);
-            body(anyContent);
+            body(body);
             return this;
         }
 
         /**
-         * Set a AnyContent to this request.
-         * @param anyContent the AnyContent
+         * Set the body of the request.
+         *
+         * @param body The body.
          */
-        protected RequestBuilder body(AnyContent anyContent) {
-            body = anyContent;
+        protected RequestBuilder body(RequestBody body) {
+            this.body = body;
             return this;
         }
 
@@ -706,7 +712,7 @@ public class Http {
          */
         public RequestBuilder bodyRaw(ByteString data) {
             play.api.mvc.RawBuffer buffer = new play.api.mvc.RawBuffer(data.size(), data);
-            return body(new AnyContentAsRaw(buffer), "application/octet-stream");
+            return body(new RequestBody(JavaParsers.toJavaRaw(buffer)), "application/octet-stream");
         }
 
         /**
@@ -721,25 +727,19 @@ public class Http {
         /**
          * Set a Form url encoded body to this request.
          */
-        public RequestBuilder bodyFormArrayValues(Map<String,String[]> data) {
-            Map<String,Seq<String>> seqs = new HashMap<>();
-            for (Entry<String,String[]> entry: data.entrySet()) {
-                seqs.put(entry.getKey(), Predef.genericWrapArray(entry.getValue()));
-            }
-            scala.collection.immutable.Map<String,Seq<String>> map = asScala(seqs);
-            return body(new AnyContentAsFormUrlEncoded(map), "application/x-www-form-urlencoded");
+        public RequestBuilder bodyFormArrayValues(Map<String, String[]> data) {
+            return body(new RequestBody(data), "application/x-www-form-urlencoded");
         }
 
         /**
          * Set a Form url encoded body to this request.
          */
-        public RequestBuilder bodyForm(Map<String,String> data) {
-            Map<String,Seq<String>> seqs = new HashMap<>();
-            for (Entry<String,String> entry: data.entrySet()) {
-                seqs.put(entry.getKey(), JavaConversions.asScalaBuffer(Arrays.asList(entry.getValue())));
+        public RequestBuilder bodyForm(Map<String, String> data) {
+            Map<String, String[]> arrayValues = new HashMap<>();
+            for (Entry<String, String> entry: data.entrySet()) {
+                arrayValues.put(entry.getKey(), new String[]{entry.getValue()});
             }
-            scala.collection.immutable.Map<String,Seq<String>> map = asScala(seqs);
-            return body(new AnyContentAsFormUrlEncoded(map), "application/x-www-form-urlencoded");
+            return bodyFormArrayValues(arrayValues);
         }
 
         /**
@@ -748,7 +748,7 @@ public class Http {
          * @param node the Json Node
          */
         public RequestBuilder bodyJson(JsonNode node) {
-            return bodyJson(JacksonJson.jsonNodeToJsValue(node));
+            return body(new RequestBody(node), "application/json");
         }
 
         /**
@@ -757,7 +757,7 @@ public class Http {
          * @param json the JsValue
          */
         public RequestBuilder bodyJson(JsValue json) {
-            return body(new AnyContentAsJson(json), "application/json");
+            return bodyJson(Json.parse(play.api.libs.json.Json.stringify(json)));
         }
 
         /**
@@ -766,7 +766,16 @@ public class Http {
          * @param xml the XML
          */
         public RequestBuilder bodyXml(InputSource xml) {
-            return body(new AnyContentAsXml(scala.xml.XML.load(xml)), "application/xml");
+            return bodyXml(XML.fromInputSource(xml));
+        }
+
+        /**
+         * Set a XML to this request.
+         * The <tt>Content-Type</tt> header of the request is set to <tt>application/xml</tt>.
+         * @param xml the XML
+         */
+        public RequestBuilder bodyXml(Document xml) {
+            return body(new RequestBody(xml), "application/xml");
         }
 
         /**
@@ -775,7 +784,7 @@ public class Http {
          * @param text the text
          */
         public RequestBuilder bodyText(String text) {
-            return body(new AnyContentAsText(text), "text/plain");
+            return body(new RequestBody(text), "text/plain");
         }
 
         /**
@@ -1219,19 +1228,46 @@ public class Http {
     /**
      * Multipart form data body.
      */
-    public abstract static class MultipartFormData {
+    public abstract static class MultipartFormData<A> {
+
+        /**
+         * Info about a file part
+         */
+        public static class FileInfo {
+            private final String key;
+            private final String filename;
+            private final String contentType;
+
+            public FileInfo(String key, String filename, String contentType) {
+                this.key = key;
+                this.filename = filename;
+                this.contentType = contentType;
+            }
+
+            public String getKey() {
+                return key;
+            }
+
+            public String getFilename() {
+                return filename;
+            }
+
+            public String getContentType() {
+                return contentType;
+            }
+        }
 
         /**
          * A file part.
          */
-        public static class FilePart {
+        public static class FilePart<A> {
 
             final String key;
             final String filename;
             final String contentType;
-            final File file;
+            final A file;
 
-            public FilePart(String key, String filename, String contentType, File file) {
+            public FilePart(String key, String filename, String contentType, A file) {
                 this.key = key;
                 this.filename = filename;
                 this.contentType = contentType;
@@ -1262,7 +1298,7 @@ public class Http {
             /**
              * The File.
              */
-            public File getFile() {
+            public A getFile() {
                 return file;
             }
 
@@ -1271,17 +1307,17 @@ public class Http {
         /**
          * Extract the data parts as Form url encoded.
          */
-        public abstract Map<String,String[]> asFormUrlEncoded();
+        public abstract Map<String, String[]> asFormUrlEncoded();
 
         /**
          * Retrieves all file parts.
          */
-        public abstract List<FilePart> getFiles();
+        public abstract List<FilePart<A>> getFiles();
 
         /**
          * Access a file part.
          */
-        public FilePart getFile(String key) {
+        public FilePart<A> getFile(String key) {
             for(FilePart filePart: getFiles()) {
                 if(filePart.getKey().equals(key)) {
                     return filePart;
@@ -1289,34 +1325,41 @@ public class Http {
             }
             return null;
         }
-
     }
 
     /**
      * The request body.
      */
-    public static class RequestBody {
+    public static final class RequestBody {
 
-        /**
-         * @deprecated Since Play 2.4, this method always returns false. When the max size is exceeded, a 413 error is
-         *             returned
-         */
-        @Deprecated
-        public boolean isMaxSizeExceeded() {
-            return false;
+        private final Object body;
+
+        public RequestBody(Object body) {
+            this.body = body;
         }
 
         /**
          * The request content parsed as multipart form data.
          */
-        public MultipartFormData asMultipartFormData() {
-            return null;
+        public <A> MultipartFormData<A> asMultipartFormData() {
+            return as(MultipartFormData.class);
         }
 
         /**
          * The request content parsed as URL form-encoded.
          */
         public Map<String,String[]> asFormUrlEncoded() {
+            // Best effort, check if it's a map, then check if the first element in that map is String -> String[].
+            if (body instanceof Map) {
+                if (((Map) body).isEmpty()) {
+                    return Collections.emptyMap();
+                } else {
+                    Map.Entry<Object, Object> first = ((Map<Object, Object>) body).entrySet().iterator().next();
+                    if (first.getKey() instanceof String && first.getValue() instanceof String[]) {
+                        return (Map<String, String[]>) body;
+                    }
+                }
+            }
             return null;
         }
 
@@ -1324,37 +1367,84 @@ public class Http {
          * The request content as Array bytes.
          */
         public RawBuffer asRaw() {
-            return null;
+            return as(RawBuffer.class);
         }
 
         /**
          * The request content as text.
          */
         public String asText() {
-            return null;
+            return as(String.class);
         }
 
         /**
          * The request content as XML.
          */
         public Document asXml() {
-            return null;
+            return as(Document.class);
         }
 
         /**
          * The request content as Json.
          */
         public JsonNode asJson() {
+            return as(JsonNode.class);
+        }
+
+        /**
+         * The request content as a ByteString.
+         *
+         * This makes a best effort attempt to convert the parsed body to a ByteString, if it knows how. This includes
+         * String, json, XML and form bodies.  It doesn't include multipart/form-data or raw bodies that don't fit in
+         * the configured max memory buffer, nor does it include custom output types from custom body parsers.
+         */
+        public ByteString asBytes() {
+            if (body instanceof Optional) {
+                if (!((Optional<?>) body).isPresent()) {
+                    return ByteString.empty();
+                }
+            } else if (body instanceof ByteString) {
+                return (ByteString) body;
+            } else if (body instanceof byte[]) {
+                return ByteString.fromArray((byte[]) body);
+            } else if (body instanceof String) {
+                return ByteString.fromString((String) body);
+            } else if (body instanceof RawBuffer) {
+                return ((RawBuffer) body).asBytes();
+            } else if (body instanceof JsonNode) {
+                return ByteString.fromString(Json.stringify((JsonNode) body));
+            } else if (body instanceof Document) {
+                return XML.toBytes((Document) body);
+            } else {
+                Map<String, String[]> form = asFormUrlEncoded();
+                if (form != null) {
+                    return ByteString.fromString(form.entrySet().stream()
+                            .flatMap(entry -> {
+                                String key = encode(entry.getKey());
+                                return Arrays.asList(entry.getValue()).stream().map(
+                                        value -> key + "=" + encode(value)
+                                );
+                            }).collect(Collectors.joining("&")));
+                }
+            }
             return null;
         }
 
+        private String encode(String value) {
+            try {
+                return URLEncoder.encode(value, "utf8");
+            } catch (UnsupportedEncodingException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+
         /**
          * Cast this RequestBody as T if possible.
          */
-        @SuppressWarnings("unchecked")
         public <T> T as(Class<T> tType) {
-            if(this.getClass().isAssignableFrom(tType)) {
-                return (T)this;
+            if (tType.isInstance(body)) {
+                return tType.cast(body);
             } else {
                 return null;
             }
diff --git a/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala b/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
index 090a141136..66cbb4fbc2 100644
--- a/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
+++ b/framework/src/play/src/main/scala/play/api/http/HttpErrorHandler.scala
@@ -13,6 +13,7 @@ import play.api.http.Status._
 import play.api.routing.Router
 import play.core.j.JavaHttpErrorHandlerAdapter
 import play.core.SourceMapper
+import play.mvc.Http
 import play.utils.{ Reflect, PlayIO }
 
 import scala.concurrent._
@@ -49,7 +50,8 @@ object HttpErrorHandler {
    * Get the bindings for the error handler from the configuration
    */
   def bindingsFromConfiguration(environment: Environment, configuration: Configuration): Seq[Binding[_]] = {
-    Reflect.bindingsFromConfiguration[HttpErrorHandler, play.http.HttpErrorHandler, JavaHttpErrorHandlerAdapter, GlobalSettingsHttpErrorHandler](environment, PlayConfig(configuration), "play.http.errorHandler", "ErrorHandler")
+    Reflect.bindingsFromConfiguration[HttpErrorHandler, play.http.HttpErrorHandler, JavaHttpErrorHandlerAdapter, JavaHttpErrorHandlerDelegate, GlobalSettingsHttpErrorHandler](environment, PlayConfig(configuration),
+      "play.http.errorHandler", "ErrorHandler")
   }
 }
 
@@ -292,3 +294,17 @@ object LazyHttpErrorHandler extends HttpErrorHandler {
   def onServerError(request: RequestHeader, exception: Throwable) =
     errorHandler.onServerError(request, exception)
 }
+
+/**
+ * A Java error handler that's provided when a Scala one is configured, so that Java code can still have the error
+ * handler injected.
+ */
+private[play] class JavaHttpErrorHandlerDelegate @Inject() (delegate: HttpErrorHandler) extends play.http.HttpErrorHandler {
+  import play.api.libs.iteratee.Execution.Implicits.trampoline
+
+  def onClientError(request: Http.RequestHeader, statusCode: Int, message: String) =
+    play.libs.F.Promise.wrap(delegate.onClientError(request._underlyingHeader(), statusCode, message).map(_.asJava))
+
+  def onServerError(request: Http.RequestHeader, exception: Throwable) =
+    play.libs.F.Promise.wrap(delegate.onServerError(request._underlyingHeader(), exception).map(_.asJava))
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/http/HttpFilters.scala b/framework/src/play/src/main/scala/play/api/http/HttpFilters.scala
index d52fbaf697..30ab3fef32 100644
--- a/framework/src/play/src/main/scala/play/api/http/HttpFilters.scala
+++ b/framework/src/play/src/main/scala/play/api/http/HttpFilters.scala
@@ -23,8 +23,7 @@ trait HttpFilters {
 object HttpFilters {
 
   def bindingsFromConfiguration(environment: Environment, configuration: Configuration) = {
-    Reflect.bindingsFromConfiguration[HttpFilters, play.http.HttpFilters, JavaHttpFiltersAdapter, NoHttpFilters](environment,
-      PlayConfig(configuration), "play.http.filters", "Filters")
+    Reflect.bindingsFromConfiguration[HttpFilters, play.http.HttpFilters, JavaHttpFiltersAdapter, JavaHttpFiltersDelegate, NoHttpFilters](environment, PlayConfig(configuration), "play.http.filters", "Filters")
   }
 
   def apply(filters: EssentialFilter*): HttpFilters = {
@@ -50,3 +49,7 @@ object NoHttpFilters extends NoHttpFilters
 class JavaHttpFiltersAdapter @Inject() (underlying: play.http.HttpFilters) extends HttpFilters {
   def filters = underlying.filters()
 }
+
+class JavaHttpFiltersDelegate @Inject() (delegate: HttpFilters) extends play.http.HttpFilters {
+  def filters() = delegate.filters.toArray
+}
\ No newline at end of file
diff --git a/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala b/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
index de452c5900..ce5297922c 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/ContentTypes.scala
@@ -271,7 +271,7 @@ trait BodyParsers {
      */
     val UNLIMITED: Long = Long.MaxValue
 
-    private val ApplicationXmlMatcher = """application/.*\+xml.*""".r
+    private[play] val ApplicationXmlMatcher = """application/.*\+xml.*""".r
 
     private def config = Play.maybeApplication.map(app => hcCache(app).parser)
       .getOrElse(ParserConfiguration())
@@ -792,7 +792,7 @@ object BodyParsers extends BodyParsers {
 
   private val hcCache = Application.instanceCache[HttpConfiguration]
 
-  private class TakeUpTo(maxLength: Long) extends PushStage[ByteString, ByteString] {
+  private[play] class TakeUpTo(maxLength: Long) extends PushStage[ByteString, ByteString] {
     private var pushedBytes: Long = 0
 
     override def onPush(chunk: ByteString, ctx: Context[ByteString]): SyncDirective = {
@@ -802,7 +802,7 @@ object BodyParsers extends BodyParsers {
     }
   }
 
-  private class MaxLengthLimitAttained extends RuntimeException(null, null, false, false)
+  private[play] class MaxLengthLimitAttained extends RuntimeException(null, null, false, false)
 }
 
 /**
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaAction.scala b/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
index db26ec0865..73cc8a66d4 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaAction.scala
@@ -12,7 +12,7 @@ import scala.language.existentials
 
 import play.api.libs.iteratee.Execution.trampoline
 import play.api.mvc._
-import play.mvc.{ Action => JAction, Result => JResult }
+import play.mvc.{ Action => JAction, Result => JResult, BodyParser => JBodyParser }
 import play.mvc.Http.{ Context => JContext }
 import play.libs.F.{ Promise => JPromise }
 import scala.concurrent.{ ExecutionContext, Future }
@@ -24,12 +24,10 @@ import scala.concurrent.{ ExecutionContext, Future }
  */
 class JavaActionAnnotations(val controller: Class[_], val method: java.lang.reflect.Method) {
 
-  val parser: BodyParser[play.mvc.Http.RequestBody] =
+  val parser: Class[_ <: JBodyParser[_]] =
     Seq(method.getAnnotation(classOf[play.mvc.BodyParser.Of]), controller.getAnnotation(classOf[play.mvc.BodyParser.Of]))
       .filterNot(_ == null)
-      .headOption.map { bodyParserOf =>
-        bodyParserOf.value.newInstance.parser(bodyParserOf.maxLength)
-      }.getOrElse(JavaParsers.default_(-1))
+      .headOption.map(_.value).getOrElse(classOf[JBodyParser.Default])
 
   val controllerAnnotations = play.api.libs.Collections.unfoldLeft[Seq[java.lang.annotation.Annotation], Option[Class[_]]](Option(controller)) { clazz =>
     clazz.map(c => (Option(c.getSuperclass), c.getDeclaredAnnotations.toSeq))
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
index 139bfda8e9..afd4a5c61e 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaHelpers.scala
@@ -10,6 +10,7 @@ import play.mvc.{ Result => JResult }
 import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestImpl => JRequestImpl, RequestHeader => JRequestHeader, Cookies => JCookies, Cookie => JCookie }
 import play.mvc.Http.RequestBody
 
+import scala.compat.java8.OptionConverters
 import scala.concurrent.Future
 import collection.JavaConverters._
 
@@ -214,6 +215,10 @@ class RequestHeaderImpl(header: RequestHeader) extends JRequestHeader {
     map
   }
 
+  def contentType() = OptionConverters.toJava(header.contentType)
+
+  def charset() = OptionConverters.toJava(header.charset)
+
   override def toString = header.toString
 
 }
diff --git a/framework/src/play/src/main/scala/play/core/j/JavaParsers.scala b/framework/src/play/src/main/scala/play/core/j/JavaParsers.scala
index 330c0c67cd..6535180145 100644
--- a/framework/src/play/src/main/scala/play/core/j/JavaParsers.scala
+++ b/framework/src/play/src/main/scala/play/core/j/JavaParsers.scala
@@ -3,141 +3,47 @@
  */
 package play.core.j
 
-import play.core.parsers.Multipart
-
-import scala.collection.JavaConverters._
-import scala.xml._
-
-import com.fasterxml.jackson.databind.JsonNode
+import java.io.File
+import java.util.concurrent.Executor
 
 import play.api.libs.Files.TemporaryFile
-import play.api.libs.iteratee.Execution.trampoline
-import play.api.libs.json.Reads.JsonNodeReads
-import play.api.libs.json._
+import play.api.mvc.BodyParsers.TakeUpTo
+
+import scala.collection.JavaConverters._
 import play.api.mvc._
 
 /**
  * provides Java centric BodyParsers
  */
-object JavaParsers extends BodyParsers {
-
-  import play.mvc.Http.RequestBody
-
-  case class DefaultRequestBody(
-      urlFormEncoded: Option[Map[String, Seq[String]]] = None,
-      raw: Option[RawBuffer] = None,
-      text: Option[String] = None,
-      json: Option[JsValue] = None,
-      xml: Option[NodeSeq] = None,
-      multipart: Option[MultipartFormData[TemporaryFile]] = None) extends RequestBody {
-
-    override lazy val asFormUrlEncoded = {
-      urlFormEncoded.map(_.mapValues(_.toArray).asJava).orNull
-    }
-
-    override def asRaw = {
-      raw.map { rawBuffer =>
-        new play.mvc.Http.RawBuffer {
-          def size = rawBuffer.size
-          def asBytes(maxLength: Int) = rawBuffer.asBytes(maxLength).orNull
-          def asBytes = rawBuffer.asBytes().orNull
-          def asFile = rawBuffer.asFile
-          override def toString = rawBuffer.toString
-        }
-      }.orNull
-    }
-
-    override def asText = text.orNull
-
-    override lazy val asJson = json.map(Json.fromJson[JsonNode](_).get).orNull
-
-    override lazy val asXml = xml.map { xml =>
-      play.libs.XML.fromString(xml.toString)
-    }.orNull
-
-    override lazy val asMultipartFormData = multipart.map { multipart =>
-      new play.mvc.Http.MultipartFormData {
+object JavaParsers {
 
-        lazy val asFormUrlEncoded = {
-          multipart.asFormUrlEncoded.mapValues(_.toArray).asJava
-        }
+  // Java code can't access objects defined on traits, so we use this instead
+  val parse = BodyParsers.parse
 
-        lazy val getFiles = {
-          multipart.files.map { file =>
-            new play.mvc.Http.MultipartFormData.FilePart(
-              file.key, file.filename, file.contentType.orNull, file.ref.file)
-          }.asJava
-        }
+  def toJavaMultipartFormData[A](multipart: MultipartFormData[TemporaryFile]): play.mvc.Http.MultipartFormData[File] = {
+    new play.mvc.Http.MultipartFormData[File] {
+      lazy val asFormUrlEncoded = {
+        multipart.asFormUrlEncoded.mapValues(_.toArray).asJava
       }
-    }.orNull
+      lazy val getFiles = {
+        multipart.files.map { file =>
+          new play.mvc.Http.MultipartFormData.FilePart(
+            file.key, file.filename, file.contentType.orNull, file.ref.file)
+        }.asJava
+      }
+    }
   }
 
-  def default_(maxLength: Long): BodyParser[RequestBody] = anyContent(parse.default(Some(maxLength).filter(_ >= 0)))
-
-  def anyContent(maxLength: Long): BodyParser[RequestBody] = anyContent(parse.anyContent(Some(maxLength).filter(_ >= 0)))
-
-  private def anyContent(parser: BodyParser[AnyContent]): BodyParser[RequestBody] =
-    parser.map { anyContent =>
-      DefaultRequestBody(
-        anyContent.asFormUrlEncoded,
-        anyContent.asRaw,
-        anyContent.asText,
-        anyContent.asJson,
-        anyContent.asXml,
-        anyContent.asMultipartFormData)
-    }(trampoline)
-
-  def json(maxLength: Long): BodyParser[RequestBody] =
-    parse.json(orDefault(maxLength)).map { json =>
-      DefaultRequestBody(json = Some(json))
-    }(trampoline)
-
-  def tolerantJson(maxLength: Long): BodyParser[RequestBody] =
-    parse.tolerantJson(orDefault(maxLength)).map { json =>
-      DefaultRequestBody(json = Some(json))
-    }(trampoline)
-
-  def xml(maxLength: Long): BodyParser[RequestBody] =
-    parse.xml(orDefault(maxLength)).map { xml =>
-      DefaultRequestBody(xml = Some(xml))
-    }(trampoline)
-
-  def tolerantXml(maxLength: Long): BodyParser[RequestBody] =
-    parse.tolerantXml(orDefault(maxLength)).map { xml =>
-      DefaultRequestBody(xml = Some(xml))
-    }(trampoline)
-
-  def text(maxLength: Long): BodyParser[RequestBody] =
-    parse.text(orDefault(maxLength)).map { text =>
-      DefaultRequestBody(text = Some(text))
-    }(trampoline)
-
-  def tolerantText(maxLength: Long): BodyParser[RequestBody] =
-    parse.tolerantText(orDefault(maxLength)).map { text =>
-      DefaultRequestBody(text = Some(text))
-    }(trampoline)
-
-  def formUrlEncoded(maxLength: Long): BodyParser[RequestBody] =
-    parse.urlFormEncoded(orDefault(maxLength)).map { urlFormEncoded =>
-      DefaultRequestBody(urlFormEncoded = Some(urlFormEncoded))
-    }(trampoline)
-
-  def multipartFormData(maxLength: Long): BodyParser[RequestBody] = {
-    val maxLengthOrDefault = if (maxLength < 0) BodyParsers.parse.DefaultMaxDiskLength else maxLength
-    parse.multipartFormData(Multipart.handleFilePartAsTemporaryFile, maxLengthOrDefault).map { multipart =>
-      DefaultRequestBody(multipart = Some(multipart))
-    }(trampoline)
+  def toJavaRaw(rawBuffer: RawBuffer): play.mvc.Http.RawBuffer = {
+    new play.mvc.Http.RawBuffer {
+      def size = rawBuffer.size
+      def asBytes(maxLength: Int) = rawBuffer.asBytes(maxLength).orNull
+      def asBytes = rawBuffer.asBytes().orNull
+      def asFile = rawBuffer.asFile
+      override def toString = rawBuffer.toString
+    }
   }
 
-  def raw(maxLength: Long): BodyParser[RequestBody] =
-    parse.raw(parse.DefaultMaxTextLength, orDefault(maxLength)).map { raw =>
-      DefaultRequestBody(raw = Some(raw))
-    }(trampoline)
-
-  def empty(): BodyParser[RequestBody] = parse.empty.map {
-    (_: Unit) => new RequestBody()
-  }(trampoline)
-
-  private def orDefault(maxLength: Long) = if (maxLength < 0) parse.DefaultMaxTextLength else maxLength.toInt
+  def trampoline: Executor = play.api.libs.iteratee.Execution.Implicits.trampoline
 
 }
diff --git a/framework/src/play/src/main/scala/play/core/parsers/FormUrlEncodedParser.scala b/framework/src/play/src/main/scala/play/core/parsers/FormUrlEncodedParser.scala
index 2c0499d90b..b6f0661a1a 100644
--- a/framework/src/play/src/main/scala/play/core/parsers/FormUrlEncodedParser.scala
+++ b/framework/src/play/src/main/scala/play/core/parsers/FormUrlEncodedParser.scala
@@ -3,8 +3,6 @@
  */
 package play.core.parsers
 
-import scala.collection.immutable.ListMap
-
 /** An object for parsing application/x-www-form-urlencoded data */
 object FormUrlEncodedParser {
 
@@ -51,6 +49,20 @@ object FormUrlEncodedParser {
     }.asJava
   }
 
+  /**
+   * Parse the content type "application/x-www-form-urlencoded", mapping to a Java compatible format.
+   * @param data
+   * @param encoding
+   * @return
+   */
+  def parseAsJavaArrayValues(data: String, encoding: String): java.util.Map[String, Array[String]] = {
+    import scala.collection.JavaConverters._
+    parse(data, encoding).map {
+      case (key, values) =>
+        key -> values.toArray
+    }.asJava
+  }
+
   /**
    * Do the basic parsing into a sequence of key/value pairs
    * @param data The data to parse
diff --git a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
index 1f7fd5c3da..3b08a654f0 100644
--- a/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
+++ b/framework/src/play/src/main/scala/play/core/routing/HandlerInvoker.scala
@@ -4,8 +4,10 @@
 package play.core.routing
 
 import org.apache.commons.lang3.reflect.MethodUtils
+import play.api.inject.Injector
 import play.api.mvc._
 import play.core.j.{ JavaHandlerComponents, JavaHandler, JavaActionAnnotations }
+import play.mvc.Http.RequestBody
 
 import scala.util.control.NonFatal
 
@@ -123,7 +125,10 @@ object HandlerInvokerFactory {
       def call(call: => A): Handler = new JavaHandler {
         def withComponents(components: JavaHandlerComponents) = new play.core.j.JavaAction(components) with RequestTaggingHandler {
           val annotations = cachedAnnotations
-          val parser = cachedAnnotations.parser
+          val parser = {
+            val javaParser = components.injector.instanceOf(cachedAnnotations.parser)
+            javaBodyParserToScala(javaParser)
+          }
           def invocation: JPromise[JResult] = resultCall(call)
           def tagRequest(rh: RequestHeader) = taggedRequest(rh, cachedHandlerTags)
         }
@@ -132,6 +137,18 @@ object HandlerInvokerFactory {
     def resultCall(call: => A): JPromise[JResult]
   }
 
+  private[play] def javaBodyParserToScala(parser: play.mvc.BodyParser[_]): BodyParser[RequestBody] = BodyParser { request =>
+    val accumulator = parser.apply(new play.core.j.RequestHeaderImpl(request)).asScala()
+    import play.api.libs.iteratee.Execution.Implicits.trampoline
+    accumulator.map { javaEither =>
+      if (javaEither.left.isPresent) {
+        Left(javaEither.left.get().asScala())
+      } else {
+        Right(new RequestBody(javaEither.right.get()))
+      }
+    }
+  }
+
   implicit def wrapJava: HandlerInvokerFactory[JResult] = new JavaActionInvokerFactory[JResult] {
     def resultCall(call: => JResult) = JPromise.pure(call)
   }
diff --git a/framework/src/play/src/main/scala/play/utils/Reflect.scala b/framework/src/play/src/main/scala/play/utils/Reflect.scala
index 4fe0abf1f1..e52c4f91a4 100644
--- a/framework/src/play/src/main/scala/play/utils/Reflect.scala
+++ b/framework/src/play/src/main/scala/play/utils/Reflect.scala
@@ -34,12 +34,14 @@ object Reflect {
    * @tparam ScalaTrait The trait to bind
    * @tparam JavaInterface The Java interface for Java versions of the implementation
    * @tparam JavaAdapter An adapter class that depends on `JavaInterface` and provides `ScalaTrait`
+   * @tparam JavaDelegate An implementation of `JavaInterface` that delegates to `ScalaTrait`, for when the configured
+   *                      class is not an instance of `JavaInterface`.
    * @tparam Default The default implementation of `ScalaTrait` if no user implementation has been provided
    * @return Zero or more bindings to provide `ScalaTrait`
    */
-  def bindingsFromConfiguration[ScalaTrait, JavaInterface, JavaAdapter <: ScalaTrait, Default <: ScalaTrait](
+  def bindingsFromConfiguration[ScalaTrait, JavaInterface, JavaAdapter <: ScalaTrait, JavaDelegate <: JavaInterface, Default <: ScalaTrait](
     environment: Environment, config: PlayConfig, key: String, defaultClassName: String)(implicit scalaTrait: SubClassOf[ScalaTrait],
-      javaInterface: SubClassOf[JavaInterface], javaAdapter: ClassTag[JavaAdapter], default: ClassTag[Default]): Seq[Binding[_]] = {
+      javaInterface: SubClassOf[JavaInterface], javaAdapter: ClassTag[JavaAdapter], javaDelegate: ClassTag[JavaDelegate], default: ClassTag[Default]): Seq[Binding[_]] = {
 
     def bind[T: SubClassOf]: BindingKey[T] = BindingKey(implicitly[SubClassOf[T]].runtimeClass)
 
@@ -47,7 +49,10 @@ object Reflect {
 
       // Directly implements the scala trait
       case Some(Left(direct)) =>
-        Seq(bind[ScalaTrait].to(direct))
+        Seq(
+          bind[ScalaTrait].to(direct),
+          bind[JavaInterface].to[JavaDelegate]
+        )
       // Implements the java interface
       case Some(Right(java)) =>
         Seq(
diff --git a/framework/src/play/src/test/scala/play/core/j/JavaParsersSpec.scala b/framework/src/play/src/test/scala/play/core/j/JavaParsersSpec.scala
deleted file mode 100644
index 690d9ee2cc..0000000000
--- a/framework/src/play/src/test/scala/play/core/j/JavaParsersSpec.scala
+++ /dev/null
@@ -1,29 +0,0 @@
-package play.core.j
-
-import java.math.{ BigDecimal, BigInteger }
-
-import com.fasterxml.jackson.databind.node.BigIntegerNode
-
-import play.api.libs.json.{ JsNumber, JsObject }
-
-import JavaParsers._
-
-object JavaParsersSpecs extends org.specs2.mutable.Specification {
-  "Java parsers" title
-
-  "JSON body" should {
-    "be successfully parsed from integer value" in {
-      val jsonNode =
-        DefaultRequestBody(json = Some(JsNumber(new BigDecimal("50")))).asJson
-
-      jsonNode.intValue must_== 50 and (jsonNode.asText must_== "50")
-    }
-
-    "be successfully parsed from float value" in {
-      val bd = new BigDecimal("12.34")
-      val jsonNode = DefaultRequestBody(json = Some(JsNumber(bd))).asJson
-
-      jsonNode.decimalValue must_== bd and (jsonNode.asText must_== "12.34")
-    }
-  }
-}
diff --git a/framework/src/play/src/test/scala/play/utils/ReflectSpec.scala b/framework/src/play/src/test/scala/play/utils/ReflectSpec.scala
index dfeda67c1d..8c69bb305a 100644
--- a/framework/src/play/src/test/scala/play/utils/ReflectSpec.scala
+++ b/framework/src/play/src/test/scala/play/utils/ReflectSpec.scala
@@ -54,7 +54,7 @@ object ReflectSpec extends Specification {
   }
 
   def bindings(configured: String, defaultClassName: String): Seq[Binding[_]] = {
-    Reflect.bindingsFromConfiguration[Duck, JavaDuck, JavaDuckAdapter, DefaultDuck](
+    Reflect.bindingsFromConfiguration[Duck, JavaDuck, JavaDuckAdapter, JavaDuckDelegate, DefaultDuck](
       Environment.simple(), PlayConfig(Configuration.from(Map("duck" -> configured))), "duck", defaultClassName)
   }
 
@@ -86,10 +86,21 @@ object ReflectSpec extends Specification {
     def getQuack = "java quack"
   }
 
+  class JavaDuckDelegate @Inject() (delegate: Duck) extends JavaDuck {
+    def getQuack = delegate.quack
+  }
+
   class NotADuck
 
   def doQuack(bindings: Seq[Binding[_]]): String = {
-    new GuiceInjectorBuilder().bindings(bindings).injector.instanceOf[Duck].quack
+    val injector = new GuiceInjectorBuilder().bindings(bindings).injector
+    val duck = injector.instanceOf[Duck]
+    val javaDuck = injector.instanceOf[JavaDuck]
+
+    // The Java duck and the Scala duck must agree
+    javaDuck.getQuack must_== duck.quack
+
+    duck.quack
   }
 
 }
