diff --git a/framework/src/play-integration-test/src/test/scala/play/it/action/FormActionSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/action/FormActionSpec.scala
new file mode 100644
index 0000000000..d20f7effd7
--- /dev/null
+++ b/framework/src/play-integration-test/src/test/scala/play/it/action/FormActionSpec.scala
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.it.action
+
+import akka.actor.ActorSystem
+import akka.stream.{ ActorMaterializer, Materializer }
+import play.api.data._
+import play.api.data.Forms._
+import play.api.data.format.Formats._
+import play.api.Application
+import play.api.inject.guice.GuiceApplicationBuilder
+import play.api.libs.Files.TemporaryFile
+import play.api.mvc._
+import play.api.mvc.Results._
+import play.api.mvc.BodyParsers._
+import play.api.test.{ FakeRequest, PlaySpecification, WithApplication }
+
+class FormActionSpec extends PlaySpecification {
+
+  val userForm = Form(
+    mapping(
+      "name" -> of[String],
+      "email" -> of[String],
+      "age" -> of[Int]
+    )(User.apply)(User.unapply)
+  )
+
+  def application: Application = {
+
+    implicit val actorSystem = ActorSystem("form-action-spec")
+    implicit val materializer = ActorMaterializer()
+
+    GuiceApplicationBuilder()
+      .overrides(
+        play.api.inject.bind[ActorSystem].toInstance(actorSystem),
+        play.api.inject.bind[Materializer].toInstance(materializer)
+      )
+      .routes {
+        case (POST, "/multipart") => Action(parse.multipartFormData) { implicit request =>
+          val user = userForm.bindFromRequest().get
+          Ok(s"${user.name} - ${user.email}")
+        }
+        case (POST, "/multipart/max-length") => Action(parse.multipartFormData(1024)) { implicit request =>
+          val user = userForm.bindFromRequest().get
+          Ok(s"${user.name} - ${user.email}")
+        }
+        case (POST, "/multipart/wrapped-max-length") => Action(parse.maxLength(1024, parse.multipartFormData)) { implicit request =>
+          val user = userForm.bindFromRequest().get
+          Ok(s"${user.name} - ${user.email}")
+        }
+      }.build()
+  }
+
+  "Form Actions" should {
+
+    "When POSTing" in {
+
+      val multipartBody = MultipartFormData[TemporaryFile](
+        dataParts = Map(
+          "name" -> Seq("Player"),
+          "email" -> Seq("play@email.com"),
+          "age" -> Seq("10")
+        ),
+        files = Seq.empty,
+        badParts = Seq.empty
+      )
+
+      "bind all parameters for multipart request" in new WithApplication(application) {
+        val request = FakeRequest(POST, "/multipart").withMultipartFormDataBody(multipartBody)
+        contentAsString(route(app, request).get) must beEqualTo("Player - play@email.com")
+      }
+
+      "bind all parameters for multipart request with max length" in new WithApplication(application) {
+        val request = FakeRequest(POST, "/multipart/max-length").withMultipartFormDataBody(multipartBody)
+        contentAsString(route(app, request).get) must beEqualTo("Player - play@email.com")
+      }
+
+      "bind all parameters for multipart request to temporary file" in new WithApplication(application) {
+        val request = FakeRequest(POST, "/multipart/wrapped-max-length").withMultipartFormDataBody(multipartBody)
+        contentAsString(route(app, request).get) must beEqualTo("Player - play@email.com")
+      }
+    }
+  }
+}
+
+case class User(
+  name: String,
+  email: String,
+  age: Int
+)
diff --git a/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala b/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
index 78457bfcc4..95ca201723 100644
--- a/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
+++ b/framework/src/play-integration-test/src/test/scala/play/it/http/parsing/MultipartFormDataParserSpec.scala
@@ -52,10 +52,10 @@ class MultipartFormDataParserSpec extends PlaySpecification {
   def checkResult(result: Either[Result, MultipartFormData[TemporaryFile]]) = {
     result must beRight.like {
       case parts =>
-        parts.dataParts.get("text1") must_== Some(Seq("the first text field"))
-        parts.dataParts.get("text2:colon") must_== Some(Seq("the second text field"))
-        parts.dataParts.get("noQuotesText1") must_== Some(Seq("text field with unquoted name"))
-        parts.dataParts.get("noQuotesText1:colon") must_== Some(Seq("text field with unquoted name and colon"))
+        parts.dataParts.get("text1") must beSome(Seq("the first text field"))
+        parts.dataParts.get("text2:colon") must beSome(Seq("the second text field"))
+        parts.dataParts.get("noQuotesText1") must beSome(Seq("text field with unquoted name"))
+        parts.dataParts.get("noQuotesText1:colon") must beSome(Seq("text field with unquoted name and colon"))
         parts.files must haveLength(2)
         parts.file("file1") must beSome.like {
           case filePart => PlayIO.readFileAsString(filePart.ref) must_== "the first file\r\n"
diff --git a/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala b/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
index 459536ff0f..d23c3f37c1 100644
--- a/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
+++ b/framework/src/play-test/src/main/scala/play/api/test/Helpers.scala
@@ -9,7 +9,7 @@ import akka.actor.Cancellable
 import akka.stream.scaladsl.Source
 import akka.stream._
 import akka.util.{ ByteString, Timeout }
-import org.openqa.selenium.{ Cookie => SeleniumCookie, _ }
+import org.openqa.selenium.WebDriver
 import org.openqa.selenium.firefox._
 import org.openqa.selenium.htmlunit._
 import play.api._
@@ -169,6 +169,12 @@ trait Writeables {
 
   implicit def writeableOf_AnyContentAsEmpty(implicit code: Codec): Writeable[AnyContentAsEmpty.type] =
     Writeable(_ => ByteString.empty, None)
+
+  implicit def writeableOf_AnyContentAsMultipartForm(implicit codec: Codec): Writeable[AnyContentAsMultipartFormData] =
+    Writeable.writeableOf_MultipartFormData(codec, None).map(_.mfd)
+
+  implicit def writeableOf_AnyContentAsMultipartForm(contentType: Option[String])(implicit codec: Codec): Writeable[AnyContentAsMultipartFormData] =
+    Writeable.writeableOf_MultipartFormData(codec, contentType).map(_.mfd)
 }
 
 trait DefaultAwaitTimeout {
@@ -383,9 +389,9 @@ trait ResultExtractors {
     Await.result(of.map { result =>
       val cookies = result.newCookies
       new Cookies {
-        lazy val cookiesByName = cookies.groupBy(_.name).mapValues(_.head)
-        override def get(name: String) = cookiesByName.get(name)
-        override def foreach[U](f: Cookie => U) = cookies.foreach(f)
+        lazy val cookiesByName: Map[String, Cookie] = cookies.groupBy(_.name).mapValues(_.head)
+        override def get(name: String): Option[Cookie] = cookiesByName.get(name)
+        override def foreach[U](f: Cookie => U): Unit = cookies.foreach(f)
       }
     }(play.core.Execution.trampoline), timeout.duration)
   }
diff --git a/framework/src/play/src/main/scala/play/api/data/Form.scala b/framework/src/play/src/main/scala/play/api/data/Form.scala
index 2b39af5f44..bb799d680b 100644
--- a/framework/src/play/src/main/scala/play/api/data/Form.scala
+++ b/framework/src/play/src/main/scala/play/api/data/Form.scala
@@ -82,6 +82,10 @@ case class Form[T](mapping: Mapping[T], data: Map[String, String], errors: Seq[F
         case body: play.api.mvc.AnyContent if body.asJson.isDefined => FormUtils.fromJson(js = body.asJson.get).mapValues(Seq(_))
         case body: Map[_, _] => body.asInstanceOf[Map[String, Seq[String]]]
         case body: play.api.mvc.MultipartFormData[_] => body.asFormUrlEncoded
+        case body: Either[_, play.api.mvc.MultipartFormData[_]] => body match {
+          case Right(b) => b.asFormUrlEncoded
+          case Left(_) => Map.empty[String, Seq[String]]
+        }
         case body: play.api.libs.json.JsValue => FormUtils.fromJson(js = body).mapValues(Seq(_))
         case _ => Map.empty[String, Seq[String]]
       }) ++ (if (!request.method.equalsIgnoreCase(HttpVerbs.POST) && !request.method.equalsIgnoreCase(HttpVerbs.PUT) && !request.method.equalsIgnoreCase(HttpVerbs.PATCH)) { request.queryString } else { Nil })
diff --git a/framework/src/play/src/main/scala/play/api/http/Writeable.scala b/framework/src/play/src/main/scala/play/api/http/Writeable.scala
index 3edcdd58fe..885eed496d 100644
--- a/framework/src/play/src/main/scala/play/api/http/Writeable.scala
+++ b/framework/src/play/src/main/scala/play/api/http/Writeable.scala
@@ -4,10 +4,15 @@
 package play.api.http
 
 import akka.util.ByteString
+import play.api.libs.Files.TemporaryFile
 import play.api.mvc._
 import play.api.libs.json._
+import play.api.mvc.MultipartFormData.FilePart
+
 import scala.annotation._
 
+import java.nio.file.{ Files => JFiles }
+
 /**
  * Transform a value of type A to a Byte Array.
  *
@@ -39,7 +44,7 @@ object Writeable extends DefaultWriteables {
 }
 
 /**
- * Default Writeable with lowwe priority.
+ * Default Writeable with lower priority.
  */
 trait LowPriorityWriteables {
 
@@ -84,7 +89,7 @@ trait DefaultWriteables extends LowPriorityWriteables {
   implicit def writeableOf_urlEncodedForm(implicit codec: Codec): Writeable[Map[String, Seq[String]]] = {
     import java.net.URLEncoder
     Writeable(formData =>
-      codec.encode(formData.map(item => item._2.map(c => item._1 + "=" + URLEncoder.encode(c, "UTF-8"))).flatten.mkString("&"))
+      codec.encode(formData.flatMap(item => item._2.map(c => item._1 + "=" + URLEncoder.encode(c, "UTF-8"))).mkString("&"))
     )
   }
 
@@ -102,6 +107,59 @@ trait DefaultWriteables extends LowPriorityWriteables {
     Writeable(a => codec.encode(Json.stringify(a)), contentType)
   }
 
+  /**
+   * `Writeable` for `MultipartFormData` when using [[TemporaryFile]]s.
+   */
+  def writeableOf_MultipartFormData(codec: Codec, contentType: Option[String]): Writeable[MultipartFormData[TemporaryFile]] = {
+    writeableOf_MultipartFormData(
+      codec,
+      Writeable[FilePart[TemporaryFile]](
+        (f: FilePart[TemporaryFile]) => ByteString.fromArray(JFiles.readAllBytes(f.ref.path)),
+        contentType
+      )
+    )
+  }
+
+  /**
+   * `Writeable` for `MultipartFormData`.
+   */
+  def writeableOf_MultipartFormData[A](
+    codec: Codec,
+    aWriteable: Writeable[FilePart[A]]
+  ): Writeable[MultipartFormData[A]] = {
+
+    val boundary: String = "--------" + scala.util.Random.alphanumeric.take(20).mkString("")
+
+    def formatDataParts(data: Map[String, Seq[String]]) = {
+      val dataParts = data.flatMap {
+        case (name, values) =>
+          values.map { value =>
+            s"--$boundary\r\n${HeaderNames.CONTENT_DISPOSITION}: form-data; name=$name\r\n\r\n$value\r\n"
+          }
+      }.mkString("")
+      codec.encode(dataParts)
+    }
+
+    def filePartHeader(file: FilePart[A]) = {
+      val name = s""""${file.key}""""
+      val filename = s""""${file.filename}""""
+      val contentType = file.contentType.map { ct =>
+        s"${HeaderNames.CONTENT_TYPE}: $ct\r\n"
+      }.getOrElse("")
+      codec.encode(s"--$boundary\r\n${HeaderNames.CONTENT_DISPOSITION}: form-data; name=$name; filename=$filename\r\n$contentType\r\n")
+    }
+
+    Writeable[MultipartFormData[A]](
+      transform = { form: MultipartFormData[A] =>
+      formatDataParts(form.dataParts) ++ form.files.flatMap { file =>
+        val fileBytes = aWriteable.transform(file)
+        filePartHeader(file) ++ fileBytes ++ codec.encode("\r\n")
+      } ++ codec.encode(s"--$boundary--")
+    },
+      contentType = Some(s"multipart/form-data; boundary=$boundary")
+    )
+  }
+
   /**
    * `Writeable` for empty responses.
    */
@@ -123,4 +181,3 @@ trait DefaultWriteables extends LowPriorityWriteables {
   implicit val wBytes: Writeable[ByteString] = Writeable(identity)
 
 }
-
diff --git a/framework/src/play/src/main/scala/play/api/mvc/BodyParsers.scala b/framework/src/play/src/main/scala/play/api/mvc/BodyParsers.scala
index ee87948ecc..5d5cf055d5 100644
--- a/framework/src/play/src/main/scala/play/api/mvc/BodyParsers.scala
+++ b/framework/src/play/src/main/scala/play/api/mvc/BodyParsers.scala
@@ -4,10 +4,9 @@
 package play.api.mvc
 
 import java.io._
-import java.nio.channels.{ ByteChannel, Channels }
 import java.nio.file.Files
 import java.util.Locale
-import javax.inject.{ Inject, Provider }
+import javax.inject.Inject
 
 import akka.actor.ActorSystem
 import akka.stream._
@@ -461,7 +460,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as text without checking the Content-Type.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def tolerantText(maxLength: Long): BodyParser[String] = {
     tolerantBodyParser("text", maxLength, "Error decoding text body") { (request, bytes) =>
@@ -478,7 +477,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as text if the Content-Type is text/plain.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def text(maxLength: Int): BodyParser[String] = when(
     _.contentType.exists(_.equalsIgnoreCase("text/plain")),
@@ -497,6 +496,9 @@ trait PlayBodyParsers extends BodyParserUtils {
    * Store the body content in a RawBuffer.
    *
    * @param memoryThreshold If the content size is bigger than this limit, the content is stored as file.
+   *
+   * @see [[DefaultMaxDiskLength]]
+   * @see [[Results.EntityTooLarge]]
    */
   def raw(memoryThreshold: Int = DefaultMaxTextLength, maxLength: Long = DefaultMaxDiskLength): BodyParser[RawBuffer] =
     BodyParser("raw, memoryThreshold=" + memoryThreshold) { request =>
@@ -520,7 +522,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as Json without checking the Content-Type.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def tolerantJson(maxLength: Int): BodyParser[JsValue] =
     tolerantBodyParser[JsValue]("json", maxLength, "Invalid Json") { (request, bytes) =>
@@ -538,7 +540,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as Json if the Content-Type is text/json or application/json.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def json(maxLength: Int): BodyParser[JsValue] = when(
     _.contentType.exists(m => m.equalsIgnoreCase("text/json") || m.equalsIgnoreCase("application/json")),
@@ -590,7 +592,7 @@ trait PlayBodyParsers extends BodyParserUtils {
    * }}}
    *
    * @param form Form model
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response. If `None`, the default `play.http.parser.maxMemoryBuffer` configuration value is used.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response. If `None`, the default `play.http.parser.maxMemoryBuffer` configuration value is used.
    * @param onErrors The result to reply in case of errors during the form binding process
    */
   def form[A](form: Form[A], maxLength: Option[Long] = None, onErrors: Form[A] => Result = (formErrors: Form[A]) => Results.BadRequest): BodyParser[A] =
@@ -611,7 +613,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as Xml without checking the Content-Type.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def tolerantXml(maxLength: Int): BodyParser[NodeSeq] =
     tolerantBodyParser[NodeSeq]("xml", maxLength, "Invalid XML") { (request, bytes) =>
@@ -646,7 +648,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as Xml if the Content-Type is application/xml, text/xml or application/XXX+xml.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def xml(maxLength: Int): BodyParser[NodeSeq] = when(
     _.contentType.exists { t =>
@@ -687,7 +689,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as Form url encoded without checking the Content-Type.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def tolerantFormUrlEncoded(maxLength: Int): BodyParser[Map[String, Seq[String]]] =
     tolerantBodyParser("formUrlEncoded", maxLength, "Error parsing application/x-www-form-urlencoded") { (request, bytes) =>
@@ -712,7 +714,7 @@ trait PlayBodyParsers extends BodyParserUtils {
   /**
    * Parse the body as form url encoded if the Content-Type is application/x-www-form-urlencoded.
    *
-   * @param maxLength Max length allowed or returns EntityTooLarge HTTP response.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
    */
   def formUrlEncoded(maxLength: Int): BodyParser[Map[String, Seq[String]]] = when(
     _.contentType.exists(_.equalsIgnoreCase("application/x-www-form-urlencoded")),
@@ -797,10 +799,22 @@ trait PlayBodyParsers extends BodyParserUtils {
   def multipartFormData: BodyParser[MultipartFormData[TemporaryFile]] =
     multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator))
 
+  /**
+   * Parse the content as multipart/form-data
+   *
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
+   */
+  def multipartFormData(maxLength: Long): BodyParser[MultipartFormData[TemporaryFile]] =
+    multipartFormData(Multipart.handleFilePartAsTemporaryFile(temporaryFileCreator), maxLength)
+
   /**
    * Parse the content as multipart/form-data
    *
    * @param filePartHandler Handles file parts.
+   * @param maxLength Max length (in bytes) allowed or returns EntityTooLarge HTTP response.
+   *
+   * @see [[DefaultMaxDiskLength]]
+   * @see [[Results.EntityTooLarge]]
    */
   def multipartFormData[A](filePartHandler: Multipart.FilePartHandler[A], maxLength: Long = DefaultMaxDiskLength): BodyParser[MultipartFormData[A]] = {
     BodyParser("multipartFormData") { request =>
diff --git a/framework/src/play/src/test/resources/multipart-form-data-file.txt b/framework/src/play/src/test/resources/multipart-form-data-file.txt
new file mode 100644
index 0000000000..47b4124b3e
--- /dev/null
+++ b/framework/src/play/src/test/resources/multipart-form-data-file.txt
@@ -0,0 +1 @@
+multipart-form-data-file
\ No newline at end of file
diff --git a/framework/src/play/src/test/scala/play/api/data/FormSpec.scala b/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
index 38300cc107..284eb62b43 100644
--- a/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
+++ b/framework/src/play/src/test/scala/play/api/data/FormSpec.scala
@@ -11,10 +11,13 @@ import play.api.i18n._
 import play.api.libs.json.Json
 import org.specs2.mutable.Specification
 import play.api.http.HttpConfiguration
+import play.api.libs.Files.TemporaryFile
+import play.api.mvc.MultipartFormData
 import play.core.test.FakeRequest
 
 class FormSpec extends Specification {
   "A form" should {
+
     "have an error due to a malformed email" in {
       val f5 = ScalaForms.emailForm.fillAndValidate(("john@", "John"))
       f5.errors must haveSize(1)
@@ -38,6 +41,20 @@ class FormSpec extends Specification {
       ScalaForms.emailForm.fillAndValidate(("o'flynn@example.com", "O'Flynn")).errors must beEmpty
     }
 
+    "bind params when POSTing a multipart body" in {
+      val multipartBody = MultipartFormData[TemporaryFile](
+        dataParts = Map("email" -> Seq("michael@jackson.com")),
+        files = Seq.empty,
+        badParts = Seq.empty
+      )
+
+      implicit val request = FakeRequest(method = "POST", "/").withMultipartFormDataBody(multipartBody)
+
+      val f1 = ScalaForms.updateForm.bindFromRequest()
+      f1.errors must beEmpty
+      f1.get must equalTo((Some("michael@jackson.com"), None))
+    }
+
     "query params ignored when using POST" in {
       implicit val request = FakeRequest(method = "POST", "/?email=bob%40marley.com&name=john").withFormUrlEncodedBody("email" -> "michael@jackson.com")
 
@@ -339,45 +356,46 @@ class FormSpec extends Specification {
 
   "render form using java.time.LocalDate" in {
     import java.time.LocalDate
-    val dateForm = Form(("date" -> localDate))
+    val dateForm = Form("date" -> localDate)
     val data = Map("date" -> "2012-01-01")
     dateForm.bind(data).get mustEqual (LocalDate.of(2012, 1, 1))
   }
 
   "render form using java.time.LocalDate with format(15/6/2016)" in {
     import java.time.LocalDate
-    val dateForm = Form(("date" -> localDate("dd/MM/yyyy")))
+    val dateForm = Form("date" -> localDate("dd/MM/yyyy"))
     val data = Map("date" -> "15/06/2016")
     dateForm.bind(data).get mustEqual (LocalDate.of(2016, 6, 15))
   }
 
   "render form using java.time.LocalDateTime" in {
     import java.time.LocalDateTime
-    val dateForm = Form(("date" -> localDateTime))
+    val dateForm = Form("date" -> localDateTime)
     val data = Map("date" -> "2012-01-01 10:10:10")
     dateForm.bind(data).get mustEqual (LocalDateTime.of(2012, 1, 1, 10, 10, 10))
   }
 
   "render form using java.time.LocalDateTime with format(17/06/2016T17:15:33)" in {
     import java.time.LocalDateTime
-    val dateForm = Form(("date" -> localDateTime("dd/MM/yyyy HH:mm:ss")))
+    val dateForm = Form("date" -> localDateTime("dd/MM/yyyy HH:mm:ss"))
     val data = Map("date" -> "17/06/2016 10:10:10")
     dateForm.bind(data).get mustEqual (LocalDateTime.of(2016, 6, 17, 10, 10, 10))
   }
 
   "render form using java.time.LocalTime" in {
     import java.time.LocalTime
-    val dateForm = Form(("date" -> localTime))
+    val dateForm = Form("date" -> localTime)
     val data = Map("date" -> "10:10:10")
     dateForm.bind(data).get mustEqual (LocalTime.of(10, 10, 10))
   }
 
   "render form using java.time.LocalTime with format(HH-mm-ss)" in {
     import java.time.LocalTime
-    val dateForm = Form(("date" -> localTime("HH-mm-ss")))
+    val dateForm = Form("date" -> localTime("HH-mm-ss"))
     val data = Map("date" -> "10-11-12")
     dateForm.bind(data).get mustEqual (LocalTime.of(10, 11, 12))
   }
+
 }
 
 object ScalaForms {
@@ -445,8 +463,8 @@ object ScalaForms {
   )
 
   val form = Form(
-    "foo" -> Forms.text.verifying("first.digit", s => (s.headOption map { _ == '3' }) getOrElse false)
-      .transform[Int](Integer.parseInt _, _.toString).verifying("number.42", _ < 42)
+    "foo" -> Forms.text.verifying("first.digit", s => s.headOption exists { _ == '3' })
+      .transform[Int](Integer.parseInt, _.toString).verifying("number.42", _ < 42)
   )
 
   val emailForm = Form(
diff --git a/framework/src/play/src/test/scala/play/api/http/WriteableSpec.scala b/framework/src/play/src/test/scala/play/api/http/WriteableSpec.scala
new file mode 100644
index 0000000000..c1fa151671
--- /dev/null
+++ b/framework/src/play/src/test/scala/play/api/http/WriteableSpec.scala
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
+ */
+package play.api.http
+
+import java.io.File
+
+import akka.util.ByteString
+import org.specs2.mutable.Specification
+import play.api.libs.Files.TemporaryFile
+import play.api.mvc.{ Codec, MultipartFormData }
+import play.api.mvc.MultipartFormData.FilePart
+
+import play.api.libs.Files.SingletonTemporaryFileCreator._
+
+class WriteableSpec extends Specification {
+
+  "Writeable" in {
+
+    "of multipart" should {
+
+      "work for temporary files" in {
+        val multipartFormData = createMultipartFormData[TemporaryFile](create(new File("src/test/resources/multipart-form-data-file.txt").toPath))
+        val contentType = Some("text/plain")
+        val codec = Codec.utf_8
+
+        val writeable = Writeable.writeableOf_MultipartFormData(codec, contentType)
+        val transformed: ByteString = writeable.transform(multipartFormData)
+
+        transformed.utf8String must contain("Content-Disposition: form-data; name=name")
+        transformed.utf8String must contain("""Content-Disposition: form-data; name="thefile"; filename="something.text"""")
+        transformed.utf8String must contain("Content-Type: text/plain")
+        transformed.utf8String must contain("multipart-form-data-file")
+      }
+
+      "work composing with another writeable" in {
+        val multipartFormData = createMultipartFormData[String]("file part value")
+        val contentType = Some("text/plain")
+        val codec = Codec.utf_8
+
+        val writeable = Writeable.writeableOf_MultipartFormData(
+          codec,
+          Writeable[FilePart[String]]((f: FilePart[String]) => codec.encode(f.ref), contentType)
+        )
+        val transformed: ByteString = writeable.transform(multipartFormData)
+
+        transformed.utf8String must contain("Content-Disposition: form-data; name=name")
+        transformed.utf8String must contain("""Content-Disposition: form-data; name="thefile"; filename="something.text"""")
+        transformed.utf8String must contain("Content-Type: text/plain")
+        transformed.utf8String must contain("file part value")
+      }
+
+      "use multipart/form-data content-type" in {
+        val contentType = Some("text/plain")
+        val codec = Codec.utf_8
+        val writeable = Writeable.writeableOf_MultipartFormData(
+          codec,
+          Writeable[FilePart[String]]((f: FilePart[String]) => codec.encode(f.ref), contentType)
+        )
+
+        writeable.contentType must beSome.which(_.startsWith("multipart/form-data; boundary="))
+      }
+    }
+  }
+
+  def createMultipartFormData[A](ref: A): MultipartFormData[A] = {
+    MultipartFormData[A](
+      dataParts = Map(
+        "name" -> Seq("value")
+      ),
+      files = Seq(
+        FilePart[A](
+          key = "thefile",
+          filename = "something.text",
+          contentType = Some("text/plain"),
+          ref = ref
+        )
+      ),
+      badParts = Seq.empty
+    )
+  }
+}
