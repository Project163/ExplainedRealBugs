diff --git a/framework/src/play-integration-test/src/it/java/play/BuiltInComponentsFromContextTest.java b/framework/src/play-integration-test/src/it/java/play/BuiltInComponentsFromContextTest.java
index d6201b7927..3bc21d7beb 100644
--- a/framework/src/play-integration-test/src/it/java/play/BuiltInComponentsFromContextTest.java
+++ b/framework/src/play-integration-test/src/it/java/play/BuiltInComponentsFromContextTest.java
@@ -7,7 +7,10 @@ package play;
 import org.junit.Before;
 import org.junit.Test;
 import play.api.http.HttpConfiguration;
+import play.api.mvc.RequestHeader;
 import play.components.BodyParserComponents;
+import play.core.BuildLink;
+import play.core.HandleWebCommandSupport;
 import play.filters.components.HttpFiltersComponents;
 import play.mvc.EssentialFilter;
 import play.mvc.Http;
@@ -16,12 +19,14 @@ import play.mvc.Results;
 import play.routing.Router;
 import play.routing.RoutingDsl;
 import play.test.Helpers;
+import scala.Option;
 
+import java.io.File;
 import java.util.Arrays;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.*;
-import static org.junit.Assert.assertThat;
+import static org.junit.Assert.*;
 
 public class BuiltInComponentsFromContextTest {
 
@@ -36,7 +41,7 @@ public class BuiltInComponentsFromContextTest {
         @Override
         public Router router() {
             return new RoutingDsl(defaultBodyParser(), javaContextComponents())
-                    .GET("/").routeTo(() -> Results.ok("index"))
+                    .GET("/").routingTo(req -> Results.ok("index"))
                     .build();
         }
     }
@@ -189,4 +194,25 @@ public class BuiltInComponentsFromContextTest {
     public void temporaryFileCreatorMustBeASingleton() {
         assertThat(this.componentsFromContext.tempFileCreator(), sameInstance(this.componentsFromContext.tempFileCreator()));
     }
+
+    @Test
+    public void shouldKeepStateForWebCommands() {
+        componentsFromContext.webCommands().addHandler(new HandleWebCommandSupport() {
+            @Override
+            public Option<play.api.mvc.Result> handleWebCommand(RequestHeader request, BuildLink buildLink, File path) {
+                // We don't care at this test what the handler is doing.
+                // So we can throw an exception and check against it to
+                // verify that the components are maintaining its state.
+                throw new RuntimeException("Expected");
+            }
+        });
+
+        try {
+            // We also don't care about the parameters
+            componentsFromContext.webCommands().handleWebCommand(null, null, null);
+            fail("Should throw an exception");
+        } catch(RuntimeException ex) {
+            assertEquals("Expected", ex.getMessage());
+        }
+    }
 }
diff --git a/framework/src/play-integration-test/src/it/scala/play/it/http/HttpErrorHandlingSpec.scala b/framework/src/play-integration-test/src/it/scala/play/it/http/HttpErrorHandlingSpec.scala
index 2be3fa64ee..00fd0a0043 100644
--- a/framework/src/play-integration-test/src/it/scala/play/it/http/HttpErrorHandlingSpec.scala
+++ b/framework/src/play-integration-test/src/it/scala/play/it/http/HttpErrorHandlingSpec.scala
@@ -4,60 +4,75 @@
 
 package play.it.http
 
-import play.api.http.HttpErrorHandler
+import java.io.File
+import java.util
+
+import play.api.http.{DefaultHttpErrorHandler, HttpErrorHandler}
 import play.api.mvc._
 import play.api.routing.Router
-import play.api.test.{ ApplicationFactories, ApplicationFactory, PlaySpecification }
-import play.api.{ Application, ApplicationLoader, BuiltInComponentsFromContext, Environment }
-import play.it.test.{ EndpointIntegrationSpecification, OkHttpEndpointSupport }
+import play.api.test.{ApplicationFactories, ApplicationFactory, PlaySpecification}
+import play.api._
+import play.core.{BuildLink, HandleWebCommandSupport, SourceMapper}
+import play.it.test.{EndpointIntegrationSpecification, OkHttpEndpointSupport}
 
 import scala.concurrent.Future
 
 class HttpErrorHandlingSpec extends PlaySpecification
   with EndpointIntegrationSpecification with ApplicationFactories with OkHttpEndpointSupport {
 
-  "The configured HttpErrorHandler" should {
+  def createApplicationFactory(applicationContext: ApplicationLoader.Context, webCommandHandler: Option[HandleWebCommandSupport], filters: Seq[EssentialFilter]): ApplicationFactory = new ApplicationFactory {
+    override def create(): Application = {
+      val components = new BuiltInComponentsFromContext(applicationContext) {
+
+        // Add the web command handler if it is available
+        webCommandHandler.foreach(super.webCommands.addHandler)
+
+        import play.api.mvc.Results._
+        import play.api.routing.sird
+        import play.api.routing.sird._
+        override lazy val router: Router = Router.from {
+          case sird.GET(p"/error") => throw new RuntimeException("action exception!")
+          case sird.GET(p"/") => Action { Ok("Done!") }
+        }
 
-    val appFactory: ApplicationFactory = new ApplicationFactory {
-      override def create(): Application = {
-        val components = new BuiltInComponentsFromContext(
-          ApplicationLoader.Context.create(Environment.simple())) {
-          import play.api.mvc.Results._
-          import play.api.routing.sird
-          import play.api.routing.sird._
-          override lazy val router: Router = Router.from {
-            case sird.GET(p"/error") => throw new RuntimeException("error!")
-            case sird.GET(p"/") => Action { Ok("Done!") }
+        override def httpFilters: Seq[EssentialFilter] = filters
+
+        override lazy val httpErrorHandler: HttpErrorHandler = new DefaultHttpErrorHandler(sourceMapper = applicationContext.devContext.map(_.sourceMapper), router = Some(router)) {
+          override def onClientError(request: RequestHeader, statusCode: Int, message: String): Future[Result] = {
+            Future.successful(InternalServerError(message))
           }
-          override lazy val httpFilters: Seq[EssentialFilter] = Seq(
-            new EssentialFilter {
-              def apply(next: EssentialAction) = {
-                throw new RuntimeException("something went wrong!")
-              }
-            }
-          )
-
-          override lazy val httpErrorHandler: HttpErrorHandler = new HttpErrorHandler {
-            override def onServerError(request: RequestHeader, exception: Throwable) = {
-              Future(InternalServerError(s"got exception: ${exception.getMessage}"))
-            }
-            override def onClientError(request: RequestHeader, statusCode: Int, message: String) = {
-              Future(InternalServerError(message))
-            }
+
+          override def onServerError(request: RequestHeader, exception: Throwable): Future[Result] = {
+            Future.successful(InternalServerError(s"got exception: ${exception.getMessage}"))
           }
         }
-        components.application
       }
+      components.application
     }
+  }
 
-    "handle exceptions that happen in routing" in appFactory.withAllOkHttpEndpoints { endpoint =>
+  "The configured HttpErrorHandler" should {
+
+    val appFactory: ApplicationFactory = createApplicationFactory(
+      applicationContext = ApplicationLoader.Context.create(Environment.simple()),
+      webCommandHandler = None,
+      filters = Seq(
+        new EssentialFilter {
+          def apply(next: EssentialAction) = {
+            throw new RuntimeException("filter exception!")
+          }
+        }
+      )
+    )
+
+    "handle exceptions that happen in action" in appFactory.withAllOkHttpEndpoints { endpoint =>
       val request = new okhttp3.Request.Builder()
         .url(endpoint.endpoint.pathUrl("/error"))
         .get()
         .build()
       val response = endpoint.client.newCall(request).execute()
       response.code must_== 500
-      response.body.string must_== "got exception: error!"
+      response.body.string must_== "got exception: action exception!"
     }
 
     "handle exceptions that happen in filters" in appFactory.withAllOkHttpEndpoints { endpoint =>
@@ -67,7 +82,84 @@ class HttpErrorHandlingSpec extends PlaySpecification
         .build()
       val response = endpoint.client.newCall(request).execute()
       response.code must_== 500
-      response.body.string must_== "got exception: something went wrong!"
+      response.body.string must_== "got exception: filter exception!"
+    }
+
+    "in DEV mode" in {
+
+      val buildLink = new BuildLink {
+        override def reload(): AnyRef = null
+        override def findSource(className: String, line: Integer): Array[AnyRef] = null
+        override def projectPath(): File = new File("").getAbsoluteFile
+        override def forceReload(): Unit = { /* do nothing */ }
+        override def settings(): util.Map[String, String] = util.Collections.emptyMap()
+      }
+
+      val devSourceMapper = new SourceMapper {
+        override def sourceOf(className: String, line: Option[Int]): Option[(File, Option[Int])] = None
+      }
+
+      val applicationContext = ApplicationLoader.Context.create(
+        environment = Environment.simple(mode = Mode.Dev),
+        devContext = Some(ApplicationLoader.DevContext(devSourceMapper, buildLink))
+      )
+
+      val appWithActionException: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = None,
+        filters = Seq.empty
+      )
+
+      val appWithFilterException: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = None,
+        filters = Seq(
+        new EssentialFilter {
+          def apply(next: EssentialAction) = {
+            throw new RuntimeException("filter exception!")
+          }
+        }
+      ))
+
+      val appWithWebCommandExceptions: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = Some(
+        new HandleWebCommandSupport {
+          override def handleWebCommand(request: RequestHeader, buildLink: BuildLink, path: File): Option[Result] = {
+            throw new RuntimeException("webcommand exception!")
+          }
+        }
+      ), Seq.empty)
+
+      "handle exceptions that happens in action" in appWithActionException.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/error"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: action exception!"
+      }
+
+      "handle exceptions that happens in filters" in appWithFilterException.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: filter exception!"
+      }
+
+      "handle exceptions that happens in web command" in appWithWebCommandExceptions.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: webcommand exception!"
+      }
     }
   }
 }
diff --git a/framework/src/play-integration-test/src/it/scala/play/it/http/JavaHttpErrorHandlingSpec.scala b/framework/src/play-integration-test/src/it/scala/play/it/http/JavaHttpErrorHandlingSpec.scala
new file mode 100644
index 0000000000..0965496718
--- /dev/null
+++ b/framework/src/play-integration-test/src/it/scala/play/it/http/JavaHttpErrorHandlingSpec.scala
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2009-2019 Lightbend Inc. <https://www.lightbend.com>
+ */
+
+package play.it.http
+
+import java.io.File
+import java.lang.reflect.InvocationTargetException
+import java.util
+import java.util.concurrent.{CompletableFuture, CompletionStage}
+
+import javax.inject.Provider
+import play._
+import play.api.mvc.RequestHeader
+import play.api.test.{ApplicationFactories, ApplicationFactory, PlaySpecification}
+import play.api.{OptionalSourceMapper, Application => ScalaApplication}
+import play.core.{BuildLink, HandleWebCommandSupport, SourceMapper}
+import play.http.HttpErrorHandler
+import play.it.test.{EndpointIntegrationSpecification, OkHttpEndpointSupport}
+import play.mvc.{EssentialAction, EssentialFilter, Http, Result}
+import play.routing.{RequestFunctions, RoutingDslComponents}
+
+class JavaHttpErrorHandlingSpec extends PlaySpecification
+  with EndpointIntegrationSpecification
+  with ApplicationFactories
+  with OkHttpEndpointSupport {
+
+  def createApplicationFactory(applicationContext: ApplicationLoader.Context, webCommandHandler: Option[HandleWebCommandSupport], filters: Seq[EssentialFilter]): ApplicationFactory = new ApplicationFactory {
+    override def create(): ScalaApplication = {
+      val components = new BuiltInComponentsFromContext(applicationContext) with RoutingDslComponents {
+
+        import scala.collection.JavaConverters._
+        import scala.compat.java8.OptionConverters
+
+        // Add the web command handler if it is available
+        webCommandHandler.foreach(webCommands().addHandler)
+
+        override def httpFilters(): util.List[mvc.EssentialFilter] = filters.asJava
+
+        override def router(): routing.Router = {
+          routingDsl()
+            .GET("/").routingTo(new RequestFunctions.Params0[play.mvc.Result] {
+              override def apply(t: Http.Request): mvc.Result = play.mvc.Results.ok("Done!")
+            })
+            .GET("/error").routingTo(new RequestFunctions.Params0[play.mvc.Result] {
+              override def apply(t: Http.Request): mvc.Result = throw new RuntimeException("action exception!")
+            })
+            .build()
+        }
+
+        //  Config config, Environment environment, OptionalSourceMapper sourceMapper, Provider<Router> routes
+        override def httpErrorHandler(): HttpErrorHandler = {
+          val mapper = OptionConverters.toScala(applicationContext.devContext()).map(_.sourceMapper)
+
+          val routesProvider: Provider[play.api.routing.Router] = new Provider[play.api.routing.Router] {
+            override def get(): play.api.routing.Router = router().asScala()
+          }
+
+          new play.http.DefaultHttpErrorHandler(
+            this.config(),
+            this.environment(),
+            new OptionalSourceMapper(mapper),
+            routesProvider
+          ) {
+            override def onClientError(request: Http.RequestHeader, statusCode: Int, message: String): CompletionStage[Result] = {
+              CompletableFuture.completedFuture(mvc.Results.internalServerError(message))
+            }
+
+            override def onServerError(request: Http.RequestHeader, exception: Throwable): CompletionStage[Result] = {
+              exception match {
+                case ite: InvocationTargetException => CompletableFuture.completedFuture(mvc.Results.internalServerError(s"got exception: ${exception.getCause.getMessage}"))
+                case rex: Throwable => CompletableFuture.completedFuture(mvc.Results.internalServerError(s"got exception: ${exception.getMessage}"))
+              }
+            }
+          }
+        }
+      }
+
+      components.application().asScala()
+    }
+  }
+
+  "The configured HttpErrorHandler" should {
+
+    val appFactory: ApplicationFactory = createApplicationFactory(
+      applicationContext = new ApplicationLoader.Context(Environment.simple()),
+      webCommandHandler = None,
+      filters = Seq(
+        new EssentialFilter {
+          def apply(next: EssentialAction) = {
+            throw new RuntimeException("filter exception!")
+          }
+        }
+      )
+    )
+
+    val appFactoryWithoutFilters: ApplicationFactory = createApplicationFactory(
+      applicationContext = new ApplicationLoader.Context(Environment.simple()),
+      webCommandHandler = None,
+      filters = Seq.empty
+    )
+
+    "handle exceptions that happen in action" in appFactoryWithoutFilters.withAllOkHttpEndpoints { endpoint =>
+      val request = new okhttp3.Request.Builder()
+        .url(endpoint.endpoint.pathUrl("/error"))
+        .get()
+        .build()
+      val response = endpoint.client.newCall(request).execute()
+      response.code must_== 500
+      response.body.string must_== "got exception: action exception!"
+    }
+
+    "handle exceptions that happen in filters" in appFactory.withAllOkHttpEndpoints { endpoint =>
+      val request = new okhttp3.Request.Builder()
+        .url(endpoint.endpoint.pathUrl("/"))
+        .get()
+        .build()
+      val response = endpoint.client.newCall(request).execute()
+      response.code must_== 500
+      response.body.string must_== "got exception: filter exception!"
+    }
+
+    "in DEV mode" in {
+
+      val buildLink = new BuildLink {
+        override def reload(): AnyRef = null
+        override def findSource(className: String, line: Integer): Array[AnyRef] = null
+        override def projectPath(): File = new File("").getAbsoluteFile
+        override def forceReload(): Unit = { /* do nothing */ }
+        override def settings(): util.Map[String, String] = util.Collections.emptyMap()
+      }
+
+      val devSourceMapper = new SourceMapper {
+        override def sourceOf(className: String, line: Option[Int]): Option[(File, Option[Int])] = None
+      }
+
+      val scalaApplicationContext = play.api.ApplicationLoader.Context.create(
+        environment = play.api.Environment.simple(mode = play.api.Mode.Dev),
+        devContext = Some(play.api.ApplicationLoader.DevContext(devSourceMapper, buildLink))
+      )
+
+      val applicationContext = new ApplicationLoader.Context(scalaApplicationContext)
+
+      val appWithActionException: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = None,
+        filters = Seq.empty
+      )
+
+      val appWithFilterException: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = None,
+        filters = Seq(
+          new EssentialFilter {
+            def apply(next: EssentialAction) = {
+              throw new RuntimeException("filter exception!")
+            }
+          }
+        ))
+
+      val appWithWebCommandExceptions: ApplicationFactory = createApplicationFactory(
+        applicationContext = applicationContext,
+        webCommandHandler = Some(
+          new HandleWebCommandSupport {
+            override def handleWebCommand(request: RequestHeader, buildLink: BuildLink, path: File): Option[api.mvc.Result] = {
+              throw new RuntimeException("webcommand exception!")
+            }
+          }
+        ), Seq.empty)
+
+      "handle exceptions that happens in action" in appWithActionException.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/error"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: action exception!"
+      }
+
+      "handle exceptions that happens in filters" in appWithFilterException.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: filter exception!"
+      }
+
+      "handle exceptions that happens in web command" in appWithWebCommandExceptions.withAllOkHttpEndpoints { endpoint =>
+        val request = new okhttp3.Request.Builder()
+          .url(endpoint.endpoint.pathUrl("/"))
+          .get()
+          .build()
+        val response = endpoint.client.newCall(request).execute()
+        response.code must_== 500
+        response.body.string must_== "got exception: webcommand exception!"
+      }
+    }
+  }
+}
diff --git a/framework/src/play-server/src/main/scala/play/core/server/Server.scala b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
index 7a17d1c513..997afc1656 100644
--- a/framework/src/play-server/src/main/scala/play/core/server/Server.scala
+++ b/framework/src/play-server/src/main/scala/play/core/server/Server.scala
@@ -89,30 +89,34 @@ object Server {
    */
   private[server] def getHandlerFor(request: RequestHeader, tryApp: Try[Application]): (RequestHeader, Handler) = {
 
-    @inline def handleErrors(errorHandler: HttpErrorHandler): PartialFunction[Throwable, (RequestHeader, Handler)] = {
+    @inline def handleErrors(errorHandler: HttpErrorHandler, req: RequestHeader): PartialFunction[Throwable, (RequestHeader, Handler)] = {
       case e: ThreadDeath => throw e
       case e: VirtualMachineError => throw e
       case e: Throwable =>
-        val errorResult = errorHandler.onServerError(request, e)
+        val errorResult = errorHandler.onServerError(req, e)
         val errorAction = actionForResult(errorResult)
-        (request, errorAction)
+        (req, errorAction)
     }
 
     try {
       // Get the Application from the try.
       val application = tryApp.get
+      // We managed to get an Application, now make a fresh request using the Application's RequestFactory.
+      // The request created by the request factory needs to be at this scope so that it can be
+      // used by application error handler. The reason for that is that this request is populated
+      // with all attributes necessary to translate it to Java.
+      // TODO: `copyRequestHeader` is a misleading name here since it is also populating the request with attributes
+      //       such as id, session, flash, etc.
+      val enrichedRequest: RequestHeader = application.requestFactory.copyRequestHeader(request)
       try {
-        // We managed to get an Application, now make a fresh request
-        // using the Application's RequestFactory, then use the Application's
-        // logic to handle that request.
-        val factoryMadeHeader: RequestHeader = application.requestFactory.copyRequestHeader(request)
-        val (handlerHeader, handler) = application.requestHandler.handlerForRequest(factoryMadeHeader)
+        // We hen use the Application's logic to handle that request.
+        val (handlerHeader, handler) = application.requestHandler.handlerForRequest(enrichedRequest)
         (handlerHeader, handler)
       } catch {
-        handleErrors(application.errorHandler)
+        handleErrors(application.errorHandler, enrichedRequest)
       }
     } catch {
-      handleErrors(DefaultHttpErrorHandler)
+      handleErrors(DefaultHttpErrorHandler, request)
     }
   }
 
diff --git a/framework/src/play/src/main/java/play/BuiltInComponentsFromContext.java b/framework/src/play/src/main/java/play/BuiltInComponentsFromContext.java
index 26792adc28..ee2d190323 100644
--- a/framework/src/play/src/main/java/play/BuiltInComponentsFromContext.java
+++ b/framework/src/play/src/main/java/play/BuiltInComponentsFromContext.java
@@ -20,7 +20,9 @@ import play.api.libs.concurrent.CoordinatedShutdownProvider;
 import play.api.mvc.request.DefaultRequestFactory;
 import play.api.mvc.request.RequestFactory;
 
+import play.core.DefaultWebCommands;
 import play.core.SourceMapper;
+import play.core.WebCommands;
 import play.core.j.*;
 
 import play.http.DefaultHttpErrorHandler;
@@ -68,6 +70,7 @@ public abstract class BuiltInComponentsFromContext implements BuiltInComponents
 
     private final Supplier<HttpErrorHandler> _httpErrorHandler = lazy(this::createHttpErrorHandler);
     private final Supplier<MappedJavaHandlerComponents> _javaHandlerComponents = lazy(this::createJavaHandlerComponents);
+    private final Supplier<WebCommands> _webCommands = lazy(this::createWebCommands);
 
     public BuiltInComponentsFromContext(ApplicationLoader.Context context) {
         this.context = context;
@@ -85,7 +88,26 @@ public abstract class BuiltInComponentsFromContext implements BuiltInComponents
 
     @Override
     public Optional<SourceMapper> sourceMapper() {
-        return context.sourceMapper();
+        // Using `devContext()` method here instead of `context.sourceMapper()` because it will then
+        // respect any overrides a user might define.
+        return devContext().map(play.api.ApplicationLoader.DevContext::sourceMapper);
+    }
+
+    @Override
+    public Optional<play.api.ApplicationLoader.DevContext> devContext() {
+        return context.devContext();
+    }
+
+    @Override
+    public WebCommands webCommands() {
+        // We are maintaining state for webCommands because it is a mutable object
+        // where it is possible to add new handlers. Therefor the state needs to be
+        // consistent everywhere it is called.
+        return this._webCommands.get();
+    }
+
+    private WebCommands createWebCommands() {
+        return new DefaultWebCommands();
     }
 
     @Override
