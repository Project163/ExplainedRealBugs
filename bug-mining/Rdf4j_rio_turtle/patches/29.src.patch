diff --git a/core/rio/turtle/pom.xml b/core/rio/turtle/pom.xml
deleted file mode 100644
index 9e3243abcb..0000000000
--- a/core/rio/turtle/pom.xml
+++ /dev/null
@@ -1,60 +0,0 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-
-	<modelVersion>4.0.0</modelVersion>
-
-	<parent>
-		<groupId>org.eclipse.rdf4j</groupId>
-		<artifactId>rdf4j-rio</artifactId>
-		<version>2.3-SNAPSHOT</version>
-	</parent>
-
-	<artifactId>rdf4j-rio-turtle</artifactId>
-
-	<name>RDF4J: Rio - Turtle</name>
-	<description>Rio parser and writer implementation for the Turtle file format.</description>
-
-	<dependencies>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-model</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-api</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-datatypes</artifactId>
-			<version>${project.version}</version>
-			<scope>runtime</scope>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-rio-languages</artifactId>
-			<version>${project.version}</version>
-			<scope>runtime</scope>
-		</dependency>
-		<dependency>
-			<groupId>${project.groupId}</groupId>
-			<artifactId>rdf4j-util</artifactId>
-			<version>${project.version}</version>
-		</dependency>
-		<dependency>
-			<groupId>commons-io</groupId>
-			<artifactId>commons-io</artifactId>
-		</dependency>
-
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<scope>test</scope>
-		</dependency>
-		<dependency>
-			<groupId>org.hamcrest</groupId>
-			<artifactId>hamcrest-library</artifactId>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
-</project>
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java
deleted file mode 100644
index fcac0ce79b..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java
+++ /dev/null
@@ -1,419 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2017 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Deque;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Model;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.impl.LinkedHashModel;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.RioSetting;
-import org.eclipse.rdf4j.rio.WriterConfig;
-import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
-
-/**
- * Internal wrapper that sorts statements for pretty printing and repeats blank nodes if inlining them.
- *
- * @author James Leigh
- * @since 2.3
- */
-class ArrangedWriter implements RDFWriter {
-
-	private final static int DEFAULT_QUEUE_SIZE = 100;
-
-	private final RDFWriter delegate;
-
-	private boolean repeatBlankNodes;
-
-	private int targetQueueSize;
-
-	private int queueSize = 0;
-
-	private final Deque<SubjectInContext> stack = new LinkedList<>();
-
-	private final Map<String, String> prefixes = new TreeMap<String, String>();
-
-	private final Map<SubjectInContext, Set<Statement>> stmtBySubject = new LinkedHashMap<>();
-
-	private final Model blanks = new LinkedHashModel();
-
-	private final Model blankReferences = new LinkedHashModel();
-
-	private final Comparator<Statement> comparator = new Comparator<Statement>() {
-
-		public int compare(Statement s1, Statement s2) {
-			IRI p1 = s1.getPredicate();
-			IRI p2 = s2.getPredicate();
-			if (p1.equals(RDF.TYPE) && !p2.equals(RDF.TYPE)) {
-				return -1;
-			}
-			else if (!p1.equals(RDF.TYPE) && p2.equals(RDF.TYPE)) {
-				return 1;
-			}
-			int cmp = p1.stringValue().compareTo(p2.stringValue());
-			if (cmp != 0)
-				return cmp;
-			Value o1 = s1.getObject();
-			Value o2 = s2.getObject();
-			if (!(o1 instanceof BNode) && o2 instanceof BNode) {
-				return -1;
-			}
-			else if (o1 instanceof BNode && !(o2 instanceof BNode)) {
-				return 1;
-			}
-			if (!(o1 instanceof IRI) && o2 instanceof IRI) {
-				return -1;
-			}
-			else if (o1 instanceof IRI && !(o2 instanceof IRI)) {
-				return 1;
-			}
-			return o1.stringValue().compareTo(o2.stringValue());
-		}
-	};
-
-	public ArrangedWriter(RDFWriter delegate) {
-		this(delegate, 0);
-	}
-
-	public ArrangedWriter(RDFWriter delegate, int size) {
-		this(delegate, size, size == -1);
-	}
-
-	public ArrangedWriter(RDFWriter delegate, int size, boolean repeatBlankNodes) {
-		this.delegate = delegate;
-		this.targetQueueSize = size;
-		this.repeatBlankNodes = repeatBlankNodes;
-	}
-
-	public RDFFormat getRDFFormat() {
-		return delegate.getRDFFormat();
-	}
-
-	public RDFWriter setWriterConfig(WriterConfig config) {
-		return delegate.setWriterConfig(config);
-	}
-
-	public WriterConfig getWriterConfig() {
-		return delegate.getWriterConfig();
-	}
-
-	public Collection<RioSetting<?>> getSupportedSettings() {
-		return delegate.getSupportedSettings();
-	}
-
-	public <T> RDFWriter set(RioSetting<T> setting, T value) {
-		return delegate.set(setting, value);
-	}
-
-	public void startRDF()
-		throws RDFHandlerException
-	{
-		if (getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES)) {
-			targetQueueSize = -1;
-			repeatBlankNodes = true;
-		}
-		else if (getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT)) {
-			targetQueueSize = DEFAULT_QUEUE_SIZE;
-		}
-		delegate.startRDF();
-	}
-
-	public void endRDF()
-		throws RDFHandlerException
-	{
-		trimNamespaces();
-		flushStatements();
-		delegate.endRDF();
-	}
-
-	public void handleNamespace(String prefix, String uri)
-		throws RDFHandlerException
-	{
-		flushStatements();
-		if (targetQueueSize == 0) {
-			delegate.handleNamespace(prefix, uri);
-		}
-		else if (!prefixes.containsKey(uri)) {
-			prefixes.put(uri, prefix);
-		}
-	}
-
-	public void handleComment(String comment)
-		throws RDFHandlerException
-	{
-		flushStatements();
-		delegate.handleComment(comment);
-	}
-
-	public synchronized void handleStatement(Statement st)
-		throws RDFHandlerException
-	{
-		if (targetQueueSize == 0) {
-			delegate.handleStatement(st);
-		}
-		else {
-			queueStatement(st);
-		}
-		while (targetQueueSize >= 0 && queueSize > targetQueueSize) {
-			flushNamespaces();
-			delegate.handleStatement(nextStatement());
-		}
-	}
-
-	private synchronized Statement nextStatement() {
-		if (stmtBySubject.isEmpty() && blanks.isEmpty()) {
-			assert queueSize == 0;
-			return null;
-		}
-		Set<Statement> stmts = null;
-		while (stmts == null) {
-			SubjectInContext last = stack.peekLast();
-			stmts = stmtBySubject.get(last);
-			if (stmts == null && last != null
-					&& blanks.contains(last.getSubject(), null, null, last.getContext()))
-			{
-				stmts = queueBlankStatements(last);
-			}
-			else if (stmts == null) {
-				stack.pollLast();
-			}
-			if (stack.isEmpty() && stmtBySubject.isEmpty()) {
-				Statement st = blanks.iterator().next();
-				stmts = queueBlankStatements(new SubjectInContext(st));
-			}
-			else if (stack.isEmpty()) {
-				stmts = stmtBySubject.values().iterator().next();
-			}
-		}
-		Iterator<Statement> iter = stmts.iterator();
-		Statement next = iter.next();
-		queueSize--;
-		iter.remove();
-		SubjectInContext key = new SubjectInContext(next);
-		if (!key.equals(stack.peekLast())) {
-			stack.addLast(key);
-		}
-		if (!iter.hasNext()) {
-			stmtBySubject.remove(key);
-		}
-		Value obj = next.getObject();
-		if (obj instanceof BNode) {
-			// follow blank nodes before continuing with this subject
-			SubjectInContext bkey = new SubjectInContext((BNode)obj, next.getContext());
-			if (stack.contains(bkey)) {
-				// cycle detected
-				if (repeatBlankNodes) {
-					throw new RDFHandlerException("Blank node cycle detected. Try disabling "
-							+ BasicWriterSettings.INLINE_BLANK_NODES.getKey());
-				}
-			}
-			else {
-				stack.addLast(bkey);
-			}
-		}
-		return next;
-	}
-
-	private synchronized Set<Statement> queueBlankStatements(SubjectInContext key) {
-		Model firstMatch = blanks.filter(key.getSubject(), null, null, key.getContext());
-		Model matches = firstMatch.isEmpty()
-				? blankReferences.filter(key.getSubject(), null, null, key.getContext())
-				: firstMatch;
-		if (matches.isEmpty()) {
-			return null;
-		}
-		Set<Statement> set = stmtBySubject.get(key);
-		if (set == null) {
-			stmtBySubject.put(key, set = new TreeSet<Statement>(comparator));
-		}
-		set.addAll(matches);
-		if (firstMatch.isEmpty()) {
-			// repeat blank node values
-			queueSize += matches.size();
-		}
-		else {
-			if (repeatBlankNodes && key.getSubject() instanceof BNode && isStillReferenced(key)) {
-				blankReferences.addAll(matches);
-			}
-			blanks.remove(key.getSubject(), null, null, key.getContext());
-		}
-		return set;
-	}
-
-	private boolean isStillReferenced(SubjectInContext key) {
-		if (blanks.contains(null, null, key.getSubject(), key.getContext())) {
-			return true;
-		}
-		for (SubjectInContext subj : stack) {
-			Set<Statement> stmts = stmtBySubject.get(subj);
-			if (stmts != null) {
-				for (Statement st : stmts) {
-					if (st.getObject().equals(key.getSubject())
-							|| Objects.equals(st.getContext(), key.getContext()))
-					{
-						return true;
-					}
-				}
-			}
-		}
-		return false;
-	}
-
-	private synchronized void queueStatement(Statement st) {
-		SubjectInContext key = new SubjectInContext(st);
-		Set<Statement> stmts = stmtBySubject.get(key);
-		if (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {
-			blanks.add(st);
-		}
-		else {
-			if (stmts == null) {
-				stmtBySubject.put(key, stmts = new TreeSet<Statement>(comparator));
-			}
-			stmts.add(st);
-		}
-		queueSize++;
-	}
-
-	private synchronized void flushStatements()
-		throws RDFHandlerException
-	{
-		if (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {
-			flushNamespaces();
-			Statement st;
-			while ((st = nextStatement()) != null) {
-				delegate.handleStatement(st);
-			}
-			assert queueSize == 0;
-		}
-	}
-
-	private synchronized void flushNamespaces()
-		throws RDFHandlerException
-	{
-		Map<String, String> namespaces = new TreeMap<String, String>();
-		for (Map.Entry<String, String> e : prefixes.entrySet()) {
-			namespaces.put(e.getValue(), e.getKey());
-		}
-		for (Map.Entry<String, String> e : namespaces.entrySet()) {
-			delegate.handleNamespace(e.getKey(), e.getValue());
-		}
-		prefixes.clear();
-	}
-
-	private synchronized void trimNamespaces() {
-		if (!prefixes.isEmpty()) {
-			Set<String> used = new HashSet<String>(prefixes.size());
-			for (Set<Statement> stmts : stmtBySubject.values()) {
-				getUsedNamespaces(stmts, used);
-			}
-			getUsedNamespaces(blanks, used);
-			prefixes.keySet().retainAll(used);
-		}
-	}
-
-	private void getUsedNamespaces(Set<Statement> stmts, Set<String> used) {
-		for (Statement st : stmts) {
-			used.add(st.getPredicate().getNamespace());
-			if (st.getObject() instanceof IRI) {
-				IRI uri = (IRI)st.getObject();
-				used.add(uri.getNamespace());
-			}
-			else if (st.getObject() instanceof Literal) {
-				Literal lit = (Literal)st.getObject();
-				if (lit.getDatatype() != null) {
-					used.add(lit.getDatatype().getNamespace());
-				}
-			}
-		}
-	}
-
-	private class SubjectInContext {
-
-		private Resource subject;
-
-		private Resource context;
-
-		private SubjectInContext(Statement st) {
-			this(st.getSubject(), st.getContext());
-		}
-
-		private SubjectInContext(Resource subject, Resource context) {
-			assert subject != null;
-			this.subject = subject;
-			this.context = context;
-		}
-
-		public Resource getSubject() {
-			return subject;
-		}
-
-		public Resource getContext() {
-			return context;
-		}
-
-		@Override
-		public String toString() {
-			if (context == null) {
-				return subject.toString();
-			}
-			else {
-				return subject.toString() + " [" + context.toString() + "]";
-			}
-		}
-
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + subject.hashCode();
-			result = prime * result + ((context == null) ? 0 : context.hashCode());
-			return result;
-		}
-
-		@Override
-		public boolean equals(Object obj) {
-			if (this == obj)
-				return true;
-			if (obj == null)
-				return false;
-			if (getClass() != obj.getClass())
-				return false;
-			SubjectInContext other = (SubjectInContext)obj;
-			if (!subject.equals(other.subject))
-				return false;
-			if (context == null) {
-				if (other.context != null)
-					return false;
-			}
-			else if (!context.equals(other.context))
-				return false;
-			return true;
-		}
-	}
-
-}
\ No newline at end of file
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/Turtle grammar.txt b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/Turtle grammar.txt
deleted file mode 100644
index 8890e74af0..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/Turtle grammar.txt	
+++ /dev/null
@@ -1,52 +0,0 @@
-turtleDoc           ::= ws* (statement ws*)*
-statement           ::= directive ws* '.'
-                      | triples ws* '.'
-directive           ::= prefixID | base
-prefixID            ::= '@prefix' ws+ (prefixName ws*)? ':' ws* uriref
-base                ::= '@base' ws+ uriref
-triples             ::= subject ws* predicateObjectList
-predicateObjectList ::= verb ws* objectList ( ws* ';' ws* verb ws* objectList )* (ws* ';')?
-objectList          ::= object (ws* ',' ws* object)*
-verb                ::= predicate | 'a'
-subject             ::= resource | blank
-predicate           ::= resource
-object              ::= resource | blank | literal
-literal             ::= quotedString ( '@' language )? | datatypeString | integer | double | decimal | boolean
-datatypeString      ::= quotedString '^^' resource
-integer             ::= ('-' | '+') ? [0-9]+
-double              ::= ('-' | '+') ? ( [0-9]+ '.' [0-9]* exponent | '.' ([0-9])+ exponent | ([0-9])+ exponent )
-decimal             ::= ('-' | '+')? ( [0-9]+ '.' [0-9]* | '.' ([0-9])+ | ([0-9])+ )
-exponent            ::= [eE] ('-' | '+')? [0-9]+
-boolean             ::= 'true' | 'false'
-blank               ::= nodeID | '[]' | '[' ws* predicateObjectList ws* ']' | collection
-itemList            ::= object (ws* object)*
-collection          ::= '(' ws* itemList? ws* ')'
-resource            ::= uriref | qname
-nodeID              ::= '_:' name
-qname               ::= prefixName? ':' name?
-uriref              ::= '<' relativeURI '>'
-language            ::= [a-z]+ ('-' [a-z0-9]+ )*
-nameStartChar       ::= [A-Z] | "_" | [a-z]
-                      | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF]
-                      | [#x0370-#x037D] | [#x037F-#x1FFF]
-                      | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF]
-                      | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD]
-                      | [#x10000-#xEFFFF]
-nameChar            ::= nameStartChar | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
-name                ::= nameStartChar nameChar*
-prefixName          ::= ( nameStartChar - '_' ) nameChar*
-relativeURI         ::= ucharacter*
-quotedString        ::= string | longString
-string              ::= #x22 scharacter* #x22
-longString          ::= #x22 #x22 #x22 lcharacter* #x22 #x22 #x22
-character           ::= '\u' hex hex hex hex
-                      | '\U' hex hex hex hex hex hex hex hex
-                      | '\\'
-                      | [#x20-#x5B] | [#x5D-#x10FFFF]
-echaracter          ::= character | '\t' | '\n' | '\r'
-hex                 ::= [#x30-#x39] | [#x41-#x46]
-ucharacter          ::= ( character - #x3E ) | '\>'
-scharacter          ::= ( echaracter - #x22 ) | '\"'
-lcharacter          ::= echaracter | '\"' | #x9 | #xA | #xD
-ws                  ::= #x9 | #xA | #xD | #x20 | comment
-comment             ::= '#' ( [^#xA#xD] )*
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParser.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParser.java
deleted file mode 100644
index 142f5003da..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParser.java
+++ /dev/null
@@ -1,1359 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.PushbackReader;
-import java.io.Reader;
-import java.io.UnsupportedEncodingException;
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.apache.commons.io.input.BOMInputStream;
-import org.eclipse.rdf4j.common.text.ASCIIUtil;
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.ValueFactory;
-import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFParseException;
-import org.eclipse.rdf4j.rio.RioSetting;
-import org.eclipse.rdf4j.rio.helpers.AbstractRDFParser;
-import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
-import org.eclipse.rdf4j.rio.helpers.TurtleParserSettings;
-
-/**
- * RDF parser for <a href="https://www.w3.org/TR/turtle/">RDF-1.1 Turtle</a>
- * files. This parser is not thread-safe, therefore its public methods are
- * synchronized.
- * <p>
- * <li>Normalization of integer, floating point and boolean values is dependent
- * on the specified datatype handling. According to the specification, integers
- * and booleans should be normalized, but floats don't.</li>
- * <li>Comments can be used anywhere in the document, and extend to the end of
- * the line. The Turtle grammar doesn't allow comments to be used inside triple
- * constructs that extend over multiple lines, but the author's own parser
- * deviates from this too.</li>
- * </ul>
- * 
- * @author Arjohn Kampman
- * @author Peter Ansell
- */
-public class TurtleParser extends AbstractRDFParser {
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	private PushbackReader reader;
-
-	protected Resource subject;
-
-	protected IRI predicate;
-
-	protected Value object;
-
-	private int lineNumber = 1;
-	private final StringBuilder parsingBuilder = new StringBuilder();
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new TurtleParser that will use a {@link SimpleValueFactory} to
-	 * create RDF model objects.
-	 */
-	public TurtleParser() {
-		super();
-	}
-
-	/**
-	 * Creates a new TurtleParser that will use the supplied ValueFactory to
-	 * create RDF model objects.
-	 *
-	 * @param valueFactory
-	 *            A ValueFactory.
-	 */
-	public TurtleParser(ValueFactory valueFactory) {
-		super(valueFactory);
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.TURTLE;
-	}
-
-	@Override
-	public Collection<RioSetting<?>> getSupportedSettings() {
-		Set<RioSetting<?>> result = new HashSet<RioSetting<?>>(super.getSupportedSettings());
-		result.add(TurtleParserSettings.CASE_INSENSITIVE_DIRECTIVES);
-		return result;
-	}
-
-	/**
-	 * Implementation of the <tt>parse(InputStream, String)</tt> method defined
-	 * in the RDFParser interface.
-	 *
-	 * @param in
-	 *            The InputStream from which to read the data, must not be
-	 *            <tt>null</tt>. The InputStream is supposed to contain UTF-8
-	 *            encoded Unicode characters, as per the Turtle specification.
-	 * @param baseURI
-	 *            The URI associated with the data in the InputStream, must not
-	 *            be <tt>null</tt>.
-	 * @throws IOException
-	 *             If an I/O error occurred while data was read from the
-	 *             InputStream.
-	 * @throws RDFParseException
-	 *             If the parser has found an unrecoverable parse error.
-	 * @throws RDFHandlerException
-	 *             If the configured statement handler encountered an
-	 *             unrecoverable error.
-	 * @throws IllegalArgumentException
-	 *             If the supplied input stream or base URI is <tt>null</tt>.
-	 */
-	public synchronized void parse(InputStream in, String baseURI)
-			throws IOException, RDFParseException, RDFHandlerException {
-		if (in == null) {
-			throw new IllegalArgumentException("Input stream must not be 'null'");
-		}
-		// Note: baseURI will be checked in parse(Reader, String)
-
-		try {
-			parse(new InputStreamReader(new BOMInputStream(in, false), StandardCharsets.UTF_8), baseURI);
-		} catch (UnsupportedEncodingException e) {
-			// Every platform should support the UTF-8 encoding...
-			throw new RuntimeException(e);
-		}
-	}
-
-	/**
-	 * Implementation of the <tt>parse(Reader, String)</tt> method defined in
-	 * the RDFParser interface.
-	 *
-	 * @param reader
-	 *            The Reader from which to read the data, must not be
-	 *            <tt>null</tt>.
-	 * @param baseURI
-	 *            The URI associated with the data in the Reader, must not be
-	 *            <tt>null</tt>.
-	 * @throws IOException
-	 *             If an I/O error occurred while data was read from the
-	 *             InputStream.
-	 * @throws RDFParseException
-	 *             If the parser has found an unrecoverable parse error.
-	 * @throws RDFHandlerException
-	 *             If the configured statement handler encountered an
-	 *             unrecoverable error.
-	 * @throws IllegalArgumentException
-	 *             If the supplied reader or base URI is <tt>null</tt>.
-	 */
-	public synchronized void parse(Reader reader, String baseURI)
-			throws IOException, RDFParseException, RDFHandlerException {
-		clear();
-		
-		try {
-			if (reader == null) {
-				throw new IllegalArgumentException("Reader must not be 'null'");
-			}
-			if (baseURI == null) {
-				throw new IllegalArgumentException("base URI must not be 'null'");
-			}
-
-			if (rdfHandler != null) {
-				rdfHandler.startRDF();
-			}
-
-			// Start counting lines at 1:
-			lineNumber = 1;
-
-			// Allow at most 8 characters to be pushed back:
-			this.reader = new PushbackReader(reader, 8);
-
-			// Store normalized base URI
-			setBaseURI(baseURI);
-
-			reportLocation();
-
-			int c = skipWSC();
-
-			while (c != -1) {
-				parseStatement();
-				c = skipWSC();
-			}
-		} finally {
-			clear();
-		}
-
-		if (rdfHandler != null) {
-			rdfHandler.endRDF();
-		}
-	}
-
-	protected void parseStatement() throws IOException, RDFParseException, RDFHandlerException {
-
-		StringBuilder sb = new StringBuilder(8);
-
-		int codePoint;
-		// longest valid directive @prefix
-		do {
-			codePoint = readCodePoint();
-			if (codePoint == -1 || TurtleUtil.isWhitespace(codePoint)) {
-				unread(codePoint);
-				break;
-			}
-			appendCodepoint(sb, codePoint);
-		} while (sb.length() < 8);
-
-		String directive = sb.toString();
-
-		if (directive.startsWith("@") || directive.equalsIgnoreCase("prefix") || directive.equalsIgnoreCase("base")) {
-			parseDirective(directive);
-			skipWSC();
-			// SPARQL BASE and PREFIX lines do not end in .
-			if (directive.startsWith("@")) {
-				verifyCharacterOrFail(readCodePoint(), ".");
-			}
-		} else {
-			unread(directive);
-			parseTriples();
-			skipWSC();
-			verifyCharacterOrFail(readCodePoint(), ".");
-		}
-	}
-
-	protected void parseDirective(String directive) throws IOException, RDFParseException, RDFHandlerException {
-		if (directive.length() >= 7 && directive.substring(0, 7).equals("@prefix")) {
-			if (directive.length() > 7) {
-				unread(directive.substring(7));
-			}
-			parsePrefixID();
-		} else if (directive.length() >= 5 && directive.substring(0, 5).equals("@base")) {
-			if (directive.length() > 5) {
-				unread(directive.substring(5));
-			}
-			parseBase();
-		} else if (directive.length() >= 6 && directive.substring(0, 6).equalsIgnoreCase("prefix")) {
-			// SPARQL doesn't require whitespace after directive, so must unread
-			// if
-			// we found part of the prefixID
-			if (directive.length() > 6) {
-				unread(directive.substring(6));
-			}
-			parsePrefixID();
-		} else if ((directive.length() >= 4 && directive.substring(0, 4).equalsIgnoreCase("base"))) {
-			if (directive.length() > 4) {
-				unread(directive.substring(4));
-			}
-			parseBase();
-		} else if (directive.length() >= 7 && directive.substring(0, 7).equalsIgnoreCase("@prefix")) {
-			if (!this.getParserConfig().get(TurtleParserSettings.CASE_INSENSITIVE_DIRECTIVES)) {
-				reportFatalError("Cannot strictly support case-insensitive @prefix directive in compliance mode.");
-			}
-			if (directive.length() > 7) {
-				unread(directive.substring(7));
-			}
-			parsePrefixID();
-		} else if (directive.length() >= 5 && directive.substring(0, 5).equalsIgnoreCase("@base")) {
-			if (!this.getParserConfig().get(TurtleParserSettings.CASE_INSENSITIVE_DIRECTIVES)) {
-				reportFatalError("Cannot strictly support case-insensitive @base directive in compliance mode.");
-			}
-			if (directive.length() > 5) {
-				unread(directive.substring(5));
-			}
-			parseBase();
-		} else if (directive.length() == 0) {
-			reportFatalError("Directive name is missing, expected @prefix or @base");
-		} else {
-			reportFatalError("Unknown directive \"" + directive + "\"");
-		}
-	}
-
-	protected void parsePrefixID() throws IOException, RDFParseException, RDFHandlerException {
-		skipWSC();
-
-		// Read prefix ID (e.g. "rdf:" or ":")
-		StringBuilder prefixID = new StringBuilder(8);
-
-		while (true) {
-			int c = readCodePoint();
-
-			if (c == ':') {
-				unread(c);
-				break;
-			} else if (TurtleUtil.isWhitespace(c)) {
-				break;
-			} else if (c == -1) {
-				throwEOFException();
-			}
-
-			appendCodepoint(prefixID, c);
-		}
-
-		skipWSC();
-
-		verifyCharacterOrFail(readCodePoint(), ":");
-
-		skipWSC();
-
-		// Read the namespace URI
-		IRI namespace = parseURI();
-
-		// Store and report this namespace mapping
-		String prefixStr = prefixID.toString();
-		String namespaceStr = namespace.toString();
-
-		setNamespace(prefixStr, namespaceStr);
-
-		if (rdfHandler != null) {
-			rdfHandler.handleNamespace(prefixStr, namespaceStr);
-		}
-	}
-
-	protected void parseBase() throws IOException, RDFParseException, RDFHandlerException {
-		skipWSC();
-
-		IRI baseURI = parseURI();
-
-		setBaseURI(baseURI.toString());
-	}
-
-	protected void parseTriples() throws IOException, RDFParseException, RDFHandlerException {
-		int c = peekCodePoint();
-
-		// If the first character is an open bracket we need to decide which of
-		// the two parsing methods for blank nodes to use
-		if (c == '[') {
-			c = readCodePoint();
-			skipWSC();
-			c = peekCodePoint();
-			if (c == ']') {
-				c = readCodePoint();
-				subject = createBNode();
-				skipWSC();
-				parsePredicateObjectList();
-			} else {
-				unread('[');
-				subject = parseImplicitBlank();
-			}
-			skipWSC();
-			c = peekCodePoint();
-
-			// if this is not the end of the statement, recurse into the list of
-			// predicate and objects, using the subject parsed above as the
-			// subject
-			// of the statement.
-			if (c != '.') {
-				parsePredicateObjectList();
-			}
-		} else {
-			parseSubject();
-			skipWSC();
-			parsePredicateObjectList();
-		}
-
-		subject = null;
-		predicate = null;
-		object = null;
-	}
-
-	protected void parsePredicateObjectList() throws IOException, RDFParseException, RDFHandlerException {
-		predicate = parsePredicate();
-
-		skipWSC();
-
-		parseObjectList();
-
-		while (skipWSC() == ';') {
-			readCodePoint();
-
-			int c = skipWSC();
-
-			if (c == '.' || // end of triple
-					c == ']' || c == '}') // end of predicateObjectList inside
-											// blank
-			// node
-			{
-				break;
-			} else if (c == ';') {
-				// empty predicateObjectList, skip to next
-				continue;
-			}
-
-			predicate = parsePredicate();
-
-			skipWSC();
-
-			parseObjectList();
-		}
-	}
-
-	protected void parseObjectList() throws IOException, RDFParseException, RDFHandlerException {
-		parseObject();
-
-		while (skipWSC() == ',') {
-			readCodePoint();
-			skipWSC();
-			parseObject();
-		}
-	}
-
-	protected void parseSubject() throws IOException, RDFParseException, RDFHandlerException {
-		int c = peekCodePoint();
-
-		if (c == '(') {
-			subject = parseCollection();
-		} else if (c == '[') {
-			subject = parseImplicitBlank();
-		} else {
-			Value value = parseValue();
-
-			if (value instanceof Resource) {
-				subject = (Resource) value;
-			} else if (value != null) {
-				reportFatalError("Illegal subject value: " + value);
-			}
-		}
-	}
-
-	protected IRI parsePredicate() throws IOException, RDFParseException, RDFHandlerException {
-		// Check if the short-cut 'a' is used
-		int c1 = readCodePoint();
-
-		if (c1 == 'a') {
-			int c2 = readCodePoint();
-
-			if (TurtleUtil.isWhitespace(c2)) {
-				// Short-cut is used, return the rdf:type URI
-				return RDF.TYPE;
-			}
-
-			// Short-cut is not used, unread all characters
-			unread(c2);
-		}
-		unread(c1);
-
-		// Predicate is a normal resource
-		Value predicate = parseValue();
-		if (predicate instanceof IRI) {
-			return (IRI) predicate;
-		} else {
-			reportFatalError("Illegal predicate value: " + predicate);
-			return null;
-		}
-	}
-
-	protected void parseObject() throws IOException, RDFParseException, RDFHandlerException {
-		int c = peekCodePoint();
-
-		if (c == '(') {
-			object = parseCollection();
-		} else if (c == '[') {
-			object = parseImplicitBlank();
-		} else {
-			object = parseValue();
-			reportStatement(subject, predicate, object);
-		}
-	}
-
-	/**
-	 * Parses a collection, e.g. <tt>( item1 item2 item3 )</tt>.
-	 */
-	protected Resource parseCollection() throws IOException, RDFParseException, RDFHandlerException {
-		verifyCharacterOrFail(readCodePoint(), "(");
-
-		int c = skipWSC();
-
-		if (c == ')') {
-			// Empty list
-			readCodePoint();
-			if (subject != null) {
-				reportStatement(subject, predicate, RDF.NIL);
-			}
-			return RDF.NIL;
-		} else {
-			BNode listRoot = createBNode();
-			if (subject != null) {
-				reportStatement(subject, predicate, listRoot);
-			}
-
-			// Remember current subject and predicate
-			Resource oldSubject = subject;
-			IRI oldPredicate = predicate;
-
-			// generated bNode becomes subject, predicate becomes rdf:first
-			subject = listRoot;
-			predicate = RDF.FIRST;
-
-			parseObject();
-
-			BNode bNode = listRoot;
-
-			while (skipWSC() != ')') {
-				// Create another list node and link it to the previous
-				BNode newNode = createBNode();
-				reportStatement(bNode, RDF.REST, newNode);
-
-				// New node becomes the current
-				subject = bNode = newNode;
-
-				parseObject();
-			}
-
-			// Skip ')'
-			readCodePoint();
-
-			// Close the list
-			reportStatement(bNode, RDF.REST, RDF.NIL);
-
-			// Restore previous subject and predicate
-			subject = oldSubject;
-			predicate = oldPredicate;
-
-			return listRoot;
-		}
-	}
-
-	/**
-	 * Parses an implicit blank node. This method parses the token <tt>[]</tt>
-	 * and predicateObjectLists that are surrounded by square brackets.
-	 */
-	protected Resource parseImplicitBlank() throws IOException, RDFParseException, RDFHandlerException {
-		verifyCharacterOrFail(readCodePoint(), "[");
-
-		BNode bNode = createBNode();
-		if (subject != null) {
-			reportStatement(subject, predicate, bNode);
-		}
-
-		int c = readCodePoint();
-		if (c != ']') {
-			unread(c);
-
-			// Remember current subject and predicate
-			Resource oldSubject = subject;
-			IRI oldPredicate = predicate;
-
-			// generated bNode becomes subject
-			subject = bNode;
-
-			// Enter recursion with nested predicate-object list
-			skipWSC();
-
-			parsePredicateObjectList();
-
-			skipWSC();
-
-			// Read closing bracket
-			verifyCharacterOrFail(readCodePoint(), "]");
-
-			// Restore previous subject and predicate
-			subject = oldSubject;
-			predicate = oldPredicate;
-		}
-
-		return bNode;
-	}
-
-	/**
-	 * Parses an RDF value. This method parses uriref, qname, node ID, quoted
-	 * literal, integer, double and boolean.
-	 */
-	protected Value parseValue() throws IOException, RDFParseException, RDFHandlerException {
-		int c = peekCodePoint();
-
-		if (c == '<') {
-			// uriref, e.g. <foo://bar>
-			return parseURI();
-		} else if (c == ':' || TurtleUtil.isPrefixStartChar(c)) {
-			// qname or boolean
-			return parseQNameOrBoolean();
-		} else if (c == '_') {
-			// node ID, e.g. _:n1
-			return parseNodeID();
-		} else if (c == '"' || c == '\'') {
-			// quoted literal, e.g. "foo" or """foo""" or 'foo' or '''foo'''
-			return parseQuotedLiteral();
-		} else if (ASCIIUtil.isNumber(c) || c == '.' || c == '+' || c == '-') {
-			// integer or double, e.g. 123 or 1.2e3
-			return parseNumber();
-		} else if (c == -1) {
-			throwEOFException();
-			return null;
-		} else {
-			reportFatalError("Expected an RDF value here, found '" + new String(Character.toChars(c)) + "'");
-			return null;
-		}
-	}
-
-	/**
-	 * Parses a quoted string, optionally followed by a language tag or
-	 * datatype.
-	 */
-	protected Literal parseQuotedLiteral() throws IOException, RDFParseException, RDFHandlerException {
-		String label = parseQuotedString();
-
-		// Check for presence of a language tag or datatype
-		int c = peekCodePoint();
-
-		if (c == '@') {
-			readCodePoint();
-
-			// Read language
-			StringBuilder lang = getBuilder();
-
-			c = readCodePoint();
-			if (c == -1) {
-				throwEOFException();
-			}
-
-			boolean verifyLanguageTag = getParserConfig().get(BasicParserSettings.VERIFY_LANGUAGE_TAGS);
-			if (verifyLanguageTag && !TurtleUtil.isLanguageStartChar(c)) {
-				reportError("Expected a letter, found '" + new String(Character.toChars(c)) + "'",
-						BasicParserSettings.VERIFY_LANGUAGE_TAGS);
-			}
-
-			appendCodepoint(lang, c);
-
-			c = readCodePoint();
-			while (!TurtleUtil.isWhitespace(c)) {
-				// SES-1887 : Flexibility introduced for SES-1985 and SES-1821
-				// needs
-				// to be counterbalanced against legitimate situations where
-				// Turtle
-				// language tags do not need whitespace following the language
-				// tag
-				if (c == '.' || c == ';' || c == ',' || c == ')' || c == ']' || c == -1) {
-					break;
-				}
-				if (verifyLanguageTag && !TurtleUtil.isLanguageChar(c)) {
-					reportError("Illegal language tag char: '" + new String(Character.toChars(c)) + "'",
-							BasicParserSettings.VERIFY_LANGUAGE_TAGS);
-				}
-				appendCodepoint(lang, c);
-				c = readCodePoint();
-			}
-
-			unread(c);
-
-			return createLiteral(label, lang.toString(), null, getLineNumber(), -1);
-		} else if (c == '^') {
-			readCodePoint();
-
-			// next character should be another '^'
-			verifyCharacterOrFail(readCodePoint(), "^");
-
-			skipWSC();
-
-			// Read datatype
-			Value datatype = parseValue();
-			if (datatype instanceof IRI) {
-				return createLiteral(label, null, (IRI) datatype, getLineNumber(), -1);
-			} else {
-				reportFatalError("Illegal datatype value: " + datatype);
-				return null;
-			}
-		} else {
-			return createLiteral(label, null, null, getLineNumber(), -1);
-		}
-	}
-
-	/**
-	 * Parses a quoted string, which is either a "normal string" or a """long
-	 * string""".
-	 */
-	protected String parseQuotedString() throws IOException, RDFParseException {
-		String result = null;
-
-		int c1 = readCodePoint();
-
-		// First character should be '"' or "'"
-		verifyCharacterOrFail(c1, "\"\'");
-
-		// Check for long-string, which starts and ends with three double quotes
-		int c2 = readCodePoint();
-		int c3 = readCodePoint();
-
-		if ((c1 == '"' && c2 == '"' && c3 == '"') || (c1 == '\'' && c2 == '\'' && c3 == '\'')) {
-			// Long string
-			result = parseLongString(c2);
-		} else {
-			// Normal string
-			unread(c3);
-			unread(c2);
-
-			result = parseString(c1);
-		}
-
-		// Unescape any escape sequences
-		try {
-			result = TurtleUtil.decodeString(result);
-		} catch (IllegalArgumentException e) {
-			reportError(e.getMessage(), BasicParserSettings.VERIFY_DATATYPE_VALUES);
-		}
-
-		return result;
-	}
-
-	/**
-	 * Parses a "normal string". This method requires that the opening character
-	 * has already been parsed.
-	 */
-	protected String parseString(int closingCharacter) throws IOException, RDFParseException {
-		StringBuilder sb = getBuilder();
-
-		while (true) {
-			int c = readCodePoint();
-
-			if (c == closingCharacter) {
-				break;
-			} else if (c == -1) {
-				throwEOFException();
-			}
-
-			appendCodepoint(sb, c);
-
-			if (c == '\\') {
-				// This escapes the next character, which might be a '"'
-				c = readCodePoint();
-				if (c == -1) {
-					throwEOFException();
-				}
-				appendCodepoint(sb, c);
-			}
-		}
-
-		return sb.toString();
-	}
-
-	/**
-	 * Parses a """long string""". This method requires that the first three
-	 * characters have already been parsed.
-	 */
-	protected String parseLongString(int closingCharacter) throws IOException, RDFParseException {
-		StringBuilder sb = getBuilder();
-
-		int doubleQuoteCount = 0;
-		int c;
-
-		while (doubleQuoteCount < 3) {
-			c = readCodePoint();
-
-			if (c == -1) {
-				throwEOFException();
-			} else if (c == closingCharacter) {
-				doubleQuoteCount++;
-			} else {
-				doubleQuoteCount = 0;
-			}
-
-			appendCodepoint(sb, c);
-
-			if (c == '\\') {
-				// This escapes the next character, which might be a '"'
-				c = readCodePoint();
-				if (c == -1) {
-					throwEOFException();
-				}
-				appendCodepoint(sb, c);
-			}
-		}
-
-		return sb.substring(0, sb.length() - 3);
-	}
-
-	protected Literal parseNumber() throws IOException, RDFParseException {
-		StringBuilder value = getBuilder();
-		IRI datatype = XMLSchema.INTEGER;
-
-		int c = readCodePoint();
-
-		// read optional sign character
-		if (c == '+' || c == '-') {
-			appendCodepoint(value, c);
-			c = readCodePoint();
-		}
-
-		while (ASCIIUtil.isNumber(c)) {
-			appendCodepoint(value, c);
-			c = readCodePoint();
-		}
-
-		if (c == '.' || c == 'e' || c == 'E') {
-
-			// read optional fractional digits
-			if (c == '.') {
-
-				if (TurtleUtil.isWhitespace(peekCodePoint())) {
-					// We're parsing an integer that did not have a space before
-					// the
-					// period to end the statement
-				} else {
-					appendCodepoint(value, c);
-
-					c = readCodePoint();
-
-					while (ASCIIUtil.isNumber(c)) {
-						appendCodepoint(value, c);
-						c = readCodePoint();
-					}
-
-					if (value.length() == 1) {
-						// We've only parsed a '.'
-						reportFatalError("Object for statement missing");
-					}
-
-					// We're parsing a decimal or a double
-					datatype = XMLSchema.DECIMAL;
-				}
-			} else {
-				if (value.length() == 0) {
-					// We've only parsed an 'e' or 'E'
-					reportFatalError("Object for statement missing");
-				}
-			}
-
-			// read optional exponent
-			if (c == 'e' || c == 'E') {
-				datatype = XMLSchema.DOUBLE;
-				appendCodepoint(value, c);
-
-				c = readCodePoint();
-				if (c == '+' || c == '-') {
-					appendCodepoint(value, c);
-					c = readCodePoint();
-				}
-
-				if (!ASCIIUtil.isNumber(c)) {
-					reportError("Exponent value missing", BasicParserSettings.VERIFY_DATATYPE_VALUES);
-				}
-
-				appendCodepoint(value, c);
-
-				c = readCodePoint();
-				while (ASCIIUtil.isNumber(c)) {
-					appendCodepoint(value, c);
-					c = readCodePoint();
-				}
-			}
-		}
-
-		// Unread last character, it isn't part of the number
-		unread(c);
-
-		// String label = value.toString();
-		// if (datatype.equals(XMLSchema.INTEGER)) {
-		// try {
-		// label = XMLDatatypeUtil.normalizeInteger(label);
-		// }
-		// catch (IllegalArgumentException e) {
-		// // Note: this should never happen because of the parse constraints
-		// reportError("Illegal integer value: " + label);
-		// }
-		// }
-		// return createLiteral(label, null, datatype);
-
-		// Return result as a typed literal
-		return createLiteral(value.toString(), null, datatype, getLineNumber(), -1);
-	}
-
-	protected IRI parseURI() throws IOException, RDFParseException {
-		StringBuilder uriBuf = getBuilder();
-
-		// First character should be '<'
-		int c = readCodePoint();
-		verifyCharacterOrFail(c, "<");
-
-		boolean uriIsIllegal = false;
-		// Read up to the next '>' character
-		while (true) {
-			c = readCodePoint();
-
-			if (c == '>') {
-				break;
-			} else if (c == -1) {
-				throwEOFException();
-			}
-
-			if (c == ' ') {
-				reportError("IRI included an unencoded space: '" + c + "'", BasicParserSettings.VERIFY_URI_SYNTAX);
-				uriIsIllegal = true;
-			}
-
-			appendCodepoint(uriBuf, c);
-
-			if (c == '\\') {
-				// This escapes the next character, which might be a '>'
-				c = readCodePoint();
-				if (c == -1) {
-					throwEOFException();
-				}
-				if (c != 'u' && c != 'U') {
-					reportError("IRI includes string escapes: '\\" + c + "'", BasicParserSettings.VERIFY_URI_SYNTAX);
-					uriIsIllegal = true;
-				}
-				appendCodepoint(uriBuf, c);
-			}
-		}
-
-		if (c == '.') {
-			reportError("IRI must not end in a '.'", BasicParserSettings.VERIFY_URI_SYNTAX);
-			uriIsIllegal = true;
-		}
-
-		// do not report back the actual URI if it's illegal and the parser is
-		// configured to verify URI syntax.
-		if (!(uriIsIllegal && getParserConfig().get(BasicParserSettings.VERIFY_URI_SYNTAX))) {
-			String uri = uriBuf.toString();
-
-			// Unescape any escape sequences
-			try {
-				// FIXME: The following decodes \n and similar in URIs, which
-				// should
-				// be
-				// invalid according to test <turtle-syntax-bad-uri-04.ttl>
-				uri = TurtleUtil.decodeString(uri);
-			} catch (IllegalArgumentException e) {
-				reportError(e.getMessage(), BasicParserSettings.VERIFY_DATATYPE_VALUES);
-			}
-
-			return super.resolveURI(uri);
-		}
-
-		return null;
-	}
-
-	/**
-	 * Parses qnames and boolean values, which have equivalent starting
-	 * characters.
-	 */
-	protected Value parseQNameOrBoolean() throws IOException, RDFParseException {
-		// First character should be a ':' or a letter
-		int c = readCodePoint();
-		if (c == -1) {
-			throwEOFException();
-		}
-		if (c != ':' && !TurtleUtil.isPrefixStartChar(c)) {
-			reportError("Expected a ':' or a letter, found '" + new String(Character.toChars(c)) + "'",
-					BasicParserSettings.VERIFY_RELATIVE_URIS);
-		}
-
-		String namespace = null;
-
-		if (c == ':') {
-			// qname using default namespace
-			namespace = getNamespace("");
-		} else {
-			// c is the first letter of the prefix
-			StringBuilder prefix = new StringBuilder(8);
-			appendCodepoint(prefix, c);
-
-			int previousChar = c;
-			c = readCodePoint();
-			while (TurtleUtil.isPrefixChar(c)) {
-				appendCodepoint(prefix, c);
-				previousChar = c;
-				c = readCodePoint();
-			}
-
-			if (c != ':') {
-				// prefix may actually be a boolean value
-				String value = prefix.toString();
-
-				if (value.equals("true") || value.equals("false")) {
-					unread(c);
-					return createLiteral(value, null, XMLSchema.BOOLEAN, getLineNumber(), -1);
-				}
-			} else {
-				if (previousChar == '.') {
-					// '.' is a legal prefix name char, but can not appear at
-					// the end
-					reportFatalError("prefix can not end with with '.'");
-				}
-			}
-
-			verifyCharacterOrFail(c, ":");
-
-			namespace = getNamespace(prefix.toString());
-		}
-
-		// c == ':', read optional local name
-		StringBuilder localName = new StringBuilder(16);
-		c = readCodePoint();
-		if (TurtleUtil.isNameStartChar(c)) {
-			if (c == '\\') {
-				localName.append(readLocalEscapedChar());
-			} else {
-				appendCodepoint(localName, c);
-			}
-
-			int previousChar = c;
-			c = readCodePoint();
-			while (TurtleUtil.isNameChar(c)) {
-				if (c == '\\') {
-					localName.append(readLocalEscapedChar());
-				} else {
-					appendCodepoint(localName, c);
-				}
-				previousChar = c;
-				c = readCodePoint();
-			}
-
-			// Unread last character
-			unread(c);
-
-			if (previousChar == '.') {
-				// '.' is a legal name char, but can not appear at the end, so
-				// is
-				// not actually part of the name
-				unread(previousChar);
-				localName.deleteCharAt(localName.length() - 1);
-			}
-		} else {
-			// Unread last character
-			unread(c);
-		}
-
-		String localNameString = localName.toString();
-
-		for (int i = 0; i < localNameString.length(); i++) {
-			if (localNameString.charAt(i) == '%') {
-				if (i > localNameString.length() - 3 || !ASCIIUtil.isHex(localNameString.charAt(i + 1))
-						|| !ASCIIUtil.isHex(localNameString.charAt(i + 2))) {
-					reportFatalError("Found incomplete percent-encoded sequence: " + localNameString);
-				}
-			}
-		}
-
-		// if (c == '.') {
-		// reportFatalError("Blank node identifier must not end in a '.'");
-		// }
-
-		// Note: namespace has already been resolved
-		return createURI(namespace + localNameString);
-	}
-
-	private char readLocalEscapedChar() throws RDFParseException, IOException {
-		int c = readCodePoint();
-
-		if (TurtleUtil.isLocalEscapedChar(c)) {
-			return (char) c;
-		} else {
-			throw new RDFParseException("found '" + new String(Character.toChars(c)) + "', expected one of: "
-					+ Arrays.toString(TurtleUtil.LOCAL_ESCAPED_CHARS));
-		}
-	}
-
-	/**
-	 * Parses a blank node ID, e.g. <tt>_:node1</tt>.
-	 */
-	protected BNode parseNodeID() throws IOException, RDFParseException {
-		// Node ID should start with "_:"
-		verifyCharacterOrFail(readCodePoint(), "_");
-		verifyCharacterOrFail(readCodePoint(), ":");
-
-		// Read the node ID
-		int c = readCodePoint();
-		if (c == -1) {
-			throwEOFException();
-		} else if (!TurtleUtil.isBLANK_NODE_LABEL_StartChar(c)) {
-			reportError("Expected a letter, found '" + (char) c + "'", BasicParserSettings.PRESERVE_BNODE_IDS);
-		}
-
-		StringBuilder name = getBuilder();
-		appendCodepoint(name, c);
-
-		// Read all following letter and numbers, they are part of the name
-		c = readCodePoint();
-
-		// If we would never go into the loop we must unread now
-		if (!TurtleUtil.isBLANK_NODE_LABEL_Char(c)) {
-			unread(c);
-		}
-
-		while (TurtleUtil.isBLANK_NODE_LABEL_Char(c)) {
-			int previous = c;
-			c = readCodePoint();
-
-			if (previous == '.' && (c == -1 || TurtleUtil.isWhitespace(c) || c == '<' || c == '_')) {
-				unread(c);
-				unread(previous);
-				break;
-			}
-			appendCodepoint(name, previous);
-			if (!TurtleUtil.isBLANK_NODE_LABEL_Char(c)) {
-				unread(c);
-			}
-		}
-
-		return createBNode(name.toString());
-	}
-
-	protected void reportStatement(Resource subj, IRI pred, Value obj) throws RDFParseException, RDFHandlerException {
-		if (subj != null && pred != null && obj != null) {
-			Statement st = createStatement(subj, pred, obj);
-			if (rdfHandler != null) {
-				rdfHandler.handleStatement(st);
-			}
-		}
-	}
-
-	/**
-	 * Verifies that the supplied character code point <tt>codePoint</tt> is one
-	 * of the expected characters specified in <tt>expected</tt>. This method
-	 * will throw a <tt>ParseException</tt> if this is not the case.
-	 */
-	protected void verifyCharacterOrFail(int codePoint, String expected) throws RDFParseException {
-		if (codePoint == -1) {
-			throwEOFException();
-		}
-
-		final String supplied = new String(Character.toChars(codePoint));
-
-		if (expected.indexOf(supplied) == -1) {
-			StringBuilder msg = new StringBuilder(32);
-			msg.append("Expected ");
-			for (int i = 0; i < expected.length(); i++) {
-				if (i > 0) {
-					msg.append(" or ");
-				}
-				msg.append('\'');
-				msg.append(expected.charAt(i));
-				msg.append('\'');
-			}
-			msg.append(", found '");
-			msg.append(supplied);
-			msg.append("'");
-
-			reportFatalError(msg.toString());
-		}
-	}
-
-	/**
-	 * Consumes any white space characters (space, tab, line feed, newline) and
-	 * comments (#-style) from <tt>reader</tt>. After this method has been
-	 * called, the first character that is returned by <tt>reader</tt> is either
-	 * a non-ignorable character, or EOF. For convenience, this character is
-	 * also returned by this method.
-	 *
-	 * @return The next character code point that will be returned by
-	 *         <tt>reader</tt>.
-	 */
-	protected int skipWSC() throws IOException, RDFHandlerException {
-		int c = readCodePoint();
-		while (TurtleUtil.isWhitespace(c) || c == '#') {
-			if (c == '#') {
-				processComment();
-			} else if (c == '\n') {
-				// we only count line feeds (LF), not carriage return (CR), as
-				// normally a CR is immediately followed by a LF.
-				lineNumber++;
-				reportLocation();
-			}
-
-			c = readCodePoint();
-		}
-
-		unread(c);
-
-		return c;
-	}
-
-	/**
-	 * Consumes characters from reader until the first EOL has been read. This
-	 * line of text is then passed to the {@link #rdfHandler} as a comment.
-	 */
-	protected void processComment() throws IOException, RDFHandlerException {
-		StringBuilder comment = getBuilder();
-		int c = readCodePoint();
-		while (c != -1 && c != 0xD && c != 0xA) {
-			appendCodepoint(comment, c);
-			c = readCodePoint();
-		}
-
-		if (c == 0xA) {
-			lineNumber++;
-		}
-
-		// c is equal to -1, \r or \n.
-		// In case c is equal to \r, we should also read a following \n.
-		if (c == 0xD) {
-			c = readCodePoint();
-			lineNumber++;
-
-			if (c != 0xA) {
-				unread(c);
-			}
-		}
-		if (rdfHandler != null) {
-			rdfHandler.handleComment(comment.toString());
-		}
-		reportLocation();
-	}
-
-	/**
-	 * Reads the next Unicode code point.
-	 *
-	 * @return the next Unicode code point, or -1 if the end of the stream has
-	 *         been reached.
-	 * @throws IOException
-	 */
-	protected int readCodePoint() throws IOException {
-		int next = reader.read();
-		if (Character.isHighSurrogate((char) next)) {
-			next = Character.toCodePoint((char) next, (char) reader.read());
-		}
-		return next;
-	}
-
-	/**
-	 * Pushes back a single code point by copying it to the front of the buffer.
-	 * After this method returns, a call to {@link #readCodePoint()} will return
-	 * the same code point c again.
-	 *
-	 * @param codePoint
-	 *            a single Unicode code point.
-	 * @throws IOException
-	 */
-	protected void unread(int codePoint) throws IOException {
-		if (codePoint != -1) {
-			if (Character.isSupplementaryCodePoint(codePoint)) {
-				final char[] surrogatePair = Character.toChars(codePoint);
-				reader.unread(surrogatePair);
-			} else {
-				reader.unread(codePoint);
-			}
-		}
-	}
-
-	/**
-	 * Pushes back the supplied string by copying it to the front of the buffer.
-	 * After this method returns, successive calls to {@link #readCodePoint()}
-	 * will return the code points in the supplied string again, starting at the
-	 * first in the String..
-	 *
-	 * @param string
-	 *            the string to un-read.
-	 * @throws IOException
-	 */
-	protected void unread(String string) throws IOException {
-		for (int i = string.codePointCount(0, string.length()); i >= 1; i--) {
-			final int codePoint = string.codePointBefore(i);
-			if (Character.isSupplementaryCodePoint(codePoint)) {
-				final char[] surrogatePair = Character.toChars(codePoint);
-				reader.unread(surrogatePair);
-			} else {
-				reader.unread(codePoint);
-			}
-		}
-	}
-
-	/**
-	 * Peeks at the next Unicode code point without advancing the reader, and
-	 * returns its value.
-	 *
-	 * @return the next Unicode code point, or -1 if the end of the stream has
-	 *         been reached.
-	 * @throws IOException
-	 */
-	protected int peekCodePoint() throws IOException {
-		int result = readCodePoint();
-		unread(result);
-		return result;
-	}
-
-	protected void reportLocation() {
-		reportLocation(getLineNumber(), -1);
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportWarning(String)}, adding line
-	 * number information to the error.
-	 */
-	@Override
-	protected void reportWarning(String msg) {
-		reportWarning(msg, getLineNumber(), -1);
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportError(String, RioSetting)},
-	 * adding line number information to the error.
-	 */
-	@Override
-	protected void reportError(String msg, RioSetting<Boolean> setting) throws RDFParseException {
-		reportError(msg, getLineNumber(), -1, setting);
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportFatalError(String)}, adding line
-	 * number information to the error.
-	 */
-	@Override
-	protected void reportFatalError(String msg) throws RDFParseException {
-		reportFatalError(msg, getLineNumber(), -1);
-	}
-
-	/**
-	 * Overrides {@link AbstractRDFParser#reportFatalError(Exception)}, adding
-	 * line number information to the error.
-	 */
-	@Override
-	protected void reportFatalError(Exception e) throws RDFParseException {
-		reportFatalError(e, getLineNumber(), -1);
-	}
-
-	protected void throwEOFException() throws RDFParseException {
-		throw new RDFParseException("Unexpected end of file");
-	}
-
-	protected int getLineNumber() {
-		return lineNumber;
-	}
-
-	private StringBuilder getBuilder() {
-		parsingBuilder.setLength(0);
-		return parsingBuilder;
-	}
-
-	/**
-	 * Appends the characters from codepoint into the string builder. This is
-	 * the same as Character#toChars but prevents the additional char array
-	 * garbage for BMP codepoints.
-	 * 
-	 * @param dst
-	 *            the destination in which to append the characters
-	 * @param codePoint
-	 *            the codepoint to be appended
-	 */
-	private static void appendCodepoint(StringBuilder dst, int codePoint) {
-		if (Character.isBmpCodePoint(codePoint)) {
-			dst.append((char) codePoint);
-		} else if (Character.isValidCodePoint(codePoint)) {
-			dst.append(Character.highSurrogate(codePoint));
-			dst.append(Character.lowSurrogate(codePoint));
-		} else {
-			throw new IllegalArgumentException("Invalid codepoint " + codePoint);
-		}
-	}
-}
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParserFactory.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParserFactory.java
deleted file mode 100644
index 4e3f1917e6..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleParserFactory.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFParser;
-import org.eclipse.rdf4j.rio.RDFParserFactory;
-
-/**
- * An {@link RDFParserFactory} for Turtle parsers.
- * 
- * @author Arjohn Kampman
- */
-public class TurtleParserFactory implements RDFParserFactory {
-
-	/**
-	 * Returns {@link RDFFormat#TURTLE}.
-	 */
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.TURTLE;
-	}
-
-	/**
-	 * Returns a new instance of {@link TurtleParser}.
-	 */
-	public RDFParser getParser() {
-		return new TurtleParser();
-	}
-}
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleUtil.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleUtil.java
deleted file mode 100644
index a441200aac..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleUtil.java
+++ /dev/null
@@ -1,591 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import java.util.Arrays;
-
-import org.eclipse.rdf4j.common.text.ASCIIUtil;
-import org.eclipse.rdf4j.common.text.StringUtil;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Utility methods for Turtle encoding/decoding.
- * 
- * @see <a href="http://www.w3.org/TR/turtle/">Turtle: Terse RDF Triple Language</a>
- */
-public class TurtleUtil {
-
-	private static final Logger logger = LoggerFactory.getLogger(TurtleUtil.class);
-
-	public static final char[] LOCAL_ESCAPED_CHARS = new char[] {
-			'_',
-			'~',
-			'.',
-			'-',
-			'!',
-			'$',
-			'&',
-			'\'',
-			'(',
-			')',
-			'*',
-			'+',
-			',',
-			';',
-			'=',
-			'/',
-			'?',
-			'#',
-			'@',
-			'%' };
-
-	static {
-		// sorting array to allow simple binary search for char lookup.
-		Arrays.sort(LOCAL_ESCAPED_CHARS);
-	}
-
-	/**
-	 * Tries to find an index where the supplied URI can be split into a namespace and a local name that
-	 * comply with the serialization constraints of the Turtle format.
-	 * 
-	 * @param uri
-	 *        The URI to split.
-	 * @return The index where the supplied URI can be split, or <tt>-1</tt> if the URI cannot be split.
-	 */
-	public static int findURISplitIndex(String uri) {
-		int uriLength = uri.length();
-
-		int idx = uriLength - 1;
-
-		// Search last character that is not a name character
-		for (; idx >= 0; idx--) {
-			if (!TurtleUtil.isNameChar(uri.charAt(idx))) {
-				// Found a non-name character
-				break;
-			}
-		}
-
-		idx++;
-
-		// Local names need to start with a 'nameStartChar', skip characters
-		// that are not nameStartChar's.
-		for (; idx < uriLength; idx++) {
-			if (TurtleUtil.isNameStartChar(uri.charAt(idx))) {
-				break;
-			}
-		}
-
-		// Last character cannot be a period
-		if (!TurtleUtil.isNameEndChar(uri.charAt(uriLength - 1))) {
-			return -1;
-		}
-
-		if (idx > 0 && idx < uriLength) {
-			// A valid split index has been found
-			return idx;
-		}
-
-		// No valid local name has been found
-		return -1;
-	}
-
-	/**
-	 * Check if the supplied code point represents a whitespace character
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point
-	 * @return <code>true</code> iff the supplied code point represents a whitespace character,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isWhitespace(int codePoint) {
-		// Whitespace character are space, tab, newline and carriage return:
-		return codePoint == 0x20 || codePoint == 0x9 || codePoint == 0xA || codePoint == 0xD;
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid prefixed name base character.
-	 * <p>
-	 * From Turtle Spec:
-	 * <p>
-	 * http://www.w3.org/TR/turtle/#grammar-production-PN_CHARS_BASE
-	 * <p>
-	 * [163s] PN_CHARS_BASE ::= [A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] |
-	 * [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
-	 * [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
-	 */
-	public static boolean isPN_CHARS_BASE(int codePoint) {
-		return ASCIIUtil.isLetter(codePoint) || codePoint >= 0x00C0 && codePoint <= 0x00D6
-				|| codePoint >= 0x00D8 && codePoint <= 0x00F6 || codePoint >= 0x00F8 && codePoint <= 0x02FF
-				|| codePoint >= 0x0370 && codePoint <= 0x037D || codePoint >= 0x037F && codePoint <= 0x1FFF
-				|| codePoint >= 0x200C && codePoint <= 0x200D || codePoint >= 0x2070 && codePoint <= 0x218F
-				|| codePoint >= 0x2C00 && codePoint <= 0x2FEF || codePoint >= 0x3001 && codePoint <= 0xD7FF
-				|| codePoint >= 0xF900 && codePoint <= 0xFDCF || codePoint >= 0xFDF0 && codePoint <= 0xFFFD
-				|| codePoint >= 0x10000 && codePoint <= 0xEFFFF;
-	}
-
-	/**
-	 * Check if the supplied code point represents either a valid prefixed name base character or an
-	 * underscore.
-	 * <p>
-	 * From Turtle Spec:
-	 * <p>
-	 * http://www.w3.org/TR/turtle/#grammar-production-PN_CHARS_U
-	 * <p>
-	 * [164s] PN_CHARS_U ::= PN_CHARS_BASE | '_'
-	 */
-	public static boolean isPN_CHARS_U(int codePoint) {
-		return isPN_CHARS_BASE(codePoint) || codePoint == '_';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid prefixed name character.
-	 * <p>
-	 * From Turtle Spec:
-	 * <p>
-	 * http://www.w3.org/TR/turtle/#grammar-production-PN_CHARS
-	 * <p>
-	 * [166s] PN_CHARS ::= PN_CHARS_U | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]
-	 */
-	public static boolean isPN_CHARS(int codePoint) {
-		return isPN_CHARS_U(codePoint) || ASCIIUtil.isNumber(codePoint) || codePoint == '-'
-				|| codePoint == 0x00B7 || codePoint >= 0x0300 && codePoint <= 0x036F
-				|| codePoint >= 0x203F && codePoint <= 0x2040;
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid prefixed name start character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid prefixed name start char,
-	 *         false otherwise.
-	 */
-	public static boolean isPrefixStartChar(int codePoint) {
-		return isPN_CHARS_BASE(codePoint);
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid start character for a blank node label.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid blank node label start char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isBLANK_NODE_LABEL_StartChar(int codePoint) {
-		return isPN_CHARS_U(codePoint) || ASCIIUtil.isNumber(codePoint);
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid blank node label character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid blank node label char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isBLANK_NODE_LABEL_Char(int codePoint) {
-		return isPN_CHARS(codePoint) || codePoint == '.';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid blank node label end character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid blank node label end char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isBLANK_NODE_LABEL_EndChar(int codePoint) {
-		return isPN_CHARS(codePoint);
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid name start character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid name start char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isNameStartChar(int codePoint) {
-		return isPN_CHARS_U(codePoint) || codePoint == ':' || ASCIIUtil.isNumber(codePoint)
-				|| codePoint == '\\' || codePoint == '%';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid name character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid name char, <code>false</code>
-	 *         otherwise.
-	 */
-	public static boolean isNameChar(int codePoint) {
-		return isPN_CHARS(codePoint) || codePoint == '.' || codePoint == ':' | codePoint == '\\'
-				|| codePoint == '%';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid name end character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid name end char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isNameEndChar(int codePoint) {
-		return isPN_CHARS(codePoint) || codePoint == ':';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid local escaped character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid local escaped char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isLocalEscapedChar(int codePoint) {
-		return Arrays.binarySearch(LOCAL_ESCAPED_CHARS, (char)codePoint) > -1;
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid prefix character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid prefix char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isPrefixChar(int codePoint) {
-		return isPN_CHARS_BASE(codePoint) || isPN_CHARS(codePoint) || codePoint == '.';
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid language tag start character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid language tag start char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isLanguageStartChar(int codePoint) {
-		return ASCIIUtil.isLetter(codePoint);
-	}
-
-	/**
-	 * Check if the supplied code point represents a valid language tag character.
-	 * 
-	 * @param codePoint
-	 *        a Unicode code point.
-	 * @return <code>true</code> iff the supplied code point represents a valid language tag char,
-	 *         <code>false</code> otherwise.
-	 */
-	public static boolean isLanguageChar(int codePoint) {
-		return ASCIIUtil.isLetter(codePoint) || ASCIIUtil.isNumber(codePoint) || codePoint == '-';
-	}
-
-	/**
-	 * Checks if the supplied prefix string is a valid Turtle namespace prefix. From Turtle Spec:
-	 * <p>
-	 * http://www.w3.org/TR/turtle/#grammar-production-PN_PREFIX
-	 * <p>
-	 * [167s] PN_PREFIX ::= PN_CHARS_BASE ((PN_CHARS | '.')* PN_CHARS)?
-	 * 
-	 * @param prefix
-	 *        a prefix string.
-	 * @return true iff the supplied prefix conforms to Turtle grammar rules
-	 */
-	public static boolean isPN_PREFIX(String prefix) {
-		// Empty prefixes are not legal, they should always have a colon
-		if (prefix.length() == 0) {
-			logger.debug("PN_PREFIX was not valid (empty)");
-			return false;
-		}
-
-		if (!isPN_CHARS_BASE(prefix.charAt(0))) {
-			logger.debug("PN_PREFIX was not valid (start character invalid) i=0 nextchar={} prefix=",
-					prefix.charAt(0), prefix);
-			return false;
-		}
-
-		final int numberOfCodePoints = prefix.codePointCount(0, prefix.length());
-		for (int i = 1; i < numberOfCodePoints; i++) {
-			final int codePoint = prefix.codePointAt(i);
-
-			if (!isPN_CHARS(codePoint) || (codePoint == '.' && i < (numberOfCodePoints - 1))) {
-				logger.debug("PN_PREFIX was not valid (intermediate character invalid) i=" + i
-						+ " nextchar={} prefix={}", Character.toChars(codePoint), prefix);
-				return false;
-			}
-
-			// Check if the percent encoding was less than two characters from the
-			// end of the prefix, in which case it is invalid
-			if (codePoint == '%' && (prefix.length() - i) < 2) {
-				logger.debug("PN_PREFIX was not valid (percent encoding) i=" + i + " nextchar={} prefix={}",
-						Character.toChars(codePoint), prefix);
-				return false;
-			}
-
-			if (Character.isHighSurrogate((char)codePoint)) {
-				// surrogate pair, skip second member in char sequence.
-				i++;
-			}
-		}
-
-		return true;
-	}
-
-	public static boolean isPLX_START(String name) {
-		if (name.length() >= 3 && isPERCENT(name.substring(0, 3))) {
-			return true;
-		}
-
-		if (name.length() >= 2 && isPN_LOCAL_ESC(name.substring(0, 2))) {
-			return true;
-		}
-
-		return false;
-	}
-
-	public static boolean isPERCENT(String name) {
-		if (name.length() != 3) {
-			return false;
-		}
-
-		if (name.charAt(0) != '%') {
-			return false;
-		}
-
-		if (!ASCIIUtil.isHex(name.charAt(1)) || !ASCIIUtil.isHex(name.charAt(2))) {
-			return false;
-		}
-
-		return true;
-	}
-
-	public static boolean isPLX_INTERNAL(String name) {
-		if (name.length() == 3 && isPERCENT(name)) {
-			return true;
-		}
-
-		if (name.length() == 2 && isPN_LOCAL_ESC(name)) {
-			return true;
-		}
-
-		return false;
-	}
-
-	public static boolean isPN_LOCAL_ESC(String name) {
-		if (name.length() != 2) {
-			return false;
-		}
-
-		if (!name.startsWith("\\")) {
-			return false;
-		}
-
-		if (!(Arrays.binarySearch(LOCAL_ESCAPED_CHARS, name.charAt(1)) > -1)) {
-			return false;
-		}
-
-		return true;
-	}
-
-	public static boolean isPN_LOCAL(String name) {
-		// Empty names are legal
-		if (name.length() == 0) {
-			return true;
-		}
-
-		if (!isPN_CHARS_U(name.charAt(0)) && name.charAt(0) != ':' && !ASCIIUtil.isNumber(name.charAt(0))
-				&& !isPLX_START(name))
-		{
-			System.err.println("PN_LOCAL was not valid (start characters invalid) i=" + 0 + " nextchar="
-					+ name.charAt(0) + " name=" + name);
-			return false;
-		}
-
-		if (!isNameStartChar(name.charAt(0))) {
-			System.err.println("name was not valid (start character invalid) i=" + 0 + " nextchar="
-					+ name.charAt(0) + " name=" + name);
-			return false;
-		}
-
-		for (int i = 1; i < name.length(); i++) {
-			if (!isNameChar(name.charAt(i))) {
-				System.err.println("name was not valid (intermediate character invalid) i=" + i + " nextchar="
-						+ name.charAt(i) + " name=" + name);
-				return false;
-			}
-
-			// Check if the percent encoding was less than two characters from the
-			// end of the prefix, in which case it is invalid
-			if (name.charAt(i) == '%' && (name.length() - i) < 3) {
-				System.err.println("name was not valid (short percent escape) i=" + i + " nextchar="
-						+ name.charAt(i) + " name=" + name);
-				return false;
-			}
-		}
-
-		return true;
-	}
-
-	// public static boolean isLegalName(String name) {
-	// return isPN_LOCAL(name);
-	// }
-
-	/**
-	 * Encodes the supplied string for inclusion as a 'normal' string in a Turtle document.
-	 */
-	public static String encodeString(String s) {
-		s = StringUtil.gsub("\\", "\\\\", s);
-		s = StringUtil.gsub("\t", "\\t", s);
-		s = StringUtil.gsub("\n", "\\n", s);
-		s = StringUtil.gsub("\r", "\\r", s);
-		s = StringUtil.gsub("\"", "\\\"", s);
-		return s;
-	}
-
-	/**
-	 * Encodes the supplied string for inclusion as a long string in a Turtle document.
-	 **/
-	public static String encodeLongString(String s) {
-		// TODO: not all double quotes need to be escaped. It suffices to encode
-		// the ones that form sequences of 3 or more double quotes, and the ones
-		// at the end of a string.
-		s = StringUtil.gsub("\\", "\\\\", s);
-		s = StringUtil.gsub("\"", "\\\"", s);
-		return s;
-	}
-
-	/**
-	 * Encodes the supplied string for inclusion as a (relative) URI in a Turtle document.
-	 **/
-	public static String encodeURIString(String s) {
-		s = StringUtil.gsub("\\", "\\\\", s);
-		s = StringUtil.gsub(">", "\\>", s);
-		return s;
-	}
-
-	/**
-	 * Decodes an encoded Turtle string. Any \-escape sequences are substituted with their decoded value.
-	 * 
-	 * @param s
-	 *        An encoded Turtle string.
-	 * @return The unencoded string.
-	 * @exception IllegalArgumentException
-	 *            If the supplied string is not a correctly encoded Turtle string.
-	 **/
-	public static String decodeString(String s) {
-		int backSlashIdx = s.indexOf('\\');
-
-		if (backSlashIdx == -1) {
-			// No escaped characters found
-			return s;
-		}
-
-		int startIdx = 0;
-		int sLength = s.length();
-		StringBuilder sb = new StringBuilder(sLength);
-
-		while (backSlashIdx != -1) {
-			sb.append(s.substring(startIdx, backSlashIdx));
-
-			if (backSlashIdx + 1 >= sLength) {
-				throw new IllegalArgumentException("Unescaped backslash in: " + s);
-			}
-
-			char c = s.charAt(backSlashIdx + 1);
-
-			if (c == 't') {
-				sb.append('\t');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == 'r') {
-				sb.append('\r');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == 'n') {
-				sb.append('\n');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == 'b') {
-				sb.append('\b');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == 'f') {
-				sb.append('\f');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == '"') {
-				sb.append('"');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == '\'') {
-				sb.append('\'');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == '>') {
-				sb.append('>');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == '\\') {
-				sb.append('\\');
-				startIdx = backSlashIdx + 2;
-			}
-			else if (c == 'u') {
-				// \\uxxxx
-				if (backSlashIdx + 5 >= sLength) {
-					throw new IllegalArgumentException("Incomplete Unicode escape sequence in: " + s);
-				}
-				String xx = s.substring(backSlashIdx + 2, backSlashIdx + 6);
-
-				try {
-					final int codePoint = Integer.parseInt(xx, 16);
-					sb.append(Character.toChars(codePoint));
-
-					startIdx = backSlashIdx + 6;
-				}
-				catch (NumberFormatException e) {
-					throw new IllegalArgumentException(
-							"Illegal Unicode escape sequence '\\u" + xx + "' in: " + s);
-				}
-			}
-			else if (c == 'U') {
-				// \\Uxxxxxxxx
-				if (backSlashIdx + 9 >= sLength) {
-					throw new IllegalArgumentException("Incomplete Unicode escape sequence in: " + s);
-				}
-				String xx = s.substring(backSlashIdx + 2, backSlashIdx + 10);
-
-				try {
-					final int codePoint = Integer.parseInt(xx, 16);
-					sb.append(Character.toChars(codePoint));
-
-					startIdx = backSlashIdx + 10;
-				}
-				catch (NumberFormatException e) {
-					throw new IllegalArgumentException(
-							"Illegal Unicode escape sequence '\\U" + xx + "' in: " + s);
-				}
-			}
-			else {
-				throw new IllegalArgumentException("Unescaped backslash in: " + s);
-			}
-
-			backSlashIdx = s.indexOf('\\', startIdx);
-		}
-
-		sb.append(s.substring(startIdx));
-
-		return sb.toString();
-	}
-}
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java
deleted file mode 100644
index 69fbe037ea..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java
+++ /dev/null
@@ -1,797 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.nio.charset.Charset;
-import java.util.Deque;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-import org.eclipse.rdf4j.common.io.IndentingWriter;
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.model.BNode;
-import org.eclipse.rdf4j.model.IRI;
-import org.eclipse.rdf4j.model.Literal;
-import org.eclipse.rdf4j.model.Model;
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.Value;
-import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
-import org.eclipse.rdf4j.model.impl.SimpleIRI;
-import org.eclipse.rdf4j.model.util.Literals;
-import org.eclipse.rdf4j.model.vocabulary.RDF;
-import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFHandlerException;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.helpers.AbstractRDFWriter;
-import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
-import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
-
-/**
- * An implementation of the RDFWriter interface that writes RDF documents in Turtle format. The Turtle format
- * is defined in <a href="http://www.dajobe.org/2004/01/turtle/">in this document</a>.
- */
-public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
-
-	private static final int LINE_WRAP = 80;
-
-	private static final IRI FIRST = new SimpleIRI(RDF.FIRST.stringValue()) {
-
-		private static final long serialVersionUID = -7951518099940758898L;
-	};
-
-	private static final IRI REST = new SimpleIRI(RDF.REST.stringValue()) {
-
-		private static final long serialVersionUID = -7951518099940758898L;
-	};
-
-	/*-----------*
-	 * Variables *
-	 *-----------*/
-
-	protected ParsedIRI baseIRI;
-
-	protected IndentingWriter writer;
-
-	protected boolean writingStarted;
-
-	/**
-	 * Flag indicating whether the last written statement has been closed.
-	 */
-	protected boolean statementClosed;
-
-	protected Resource lastWrittenSubject;
-
-	protected IRI lastWrittenPredicate;
-
-	/**
-	 * Always null
-	 */
-	@Deprecated
-	protected Model prettyPrintModel;
-
-	private final Deque<Resource> stack = new LinkedList<Resource>();
-
-	private final Deque<IRI> path = new LinkedList<IRI>();
-
-	private Boolean xsdStringToPlainLiteral;
-
-	private Boolean prettyPrint;
-
-	private boolean inlineBNodes;
-
-	/*--------------*
-	 * Constructors *
-	 *--------------*/
-
-	/**
-	 * Creates a new TurtleWriter that will write to the supplied OutputStream.
-	 * 
-	 * @param out
-	 *        The OutputStream to write the Turtle document to.
-	 */
-	public TurtleWriter(OutputStream out) {
-		this(out, null);
-	}
-
-	/**
-	 * Creates a new TurtleWriter that will write to the supplied OutputStream.
-	 *
-	 * @param out
-	 *        The OutputStream to write the Turtle document to.
-	 */
-	public TurtleWriter(OutputStream out, ParsedIRI baseIRI) {
-		this(new OutputStreamWriter(out, Charset.forName("UTF-8")), baseIRI);
-	}
-
-	/**
-	 * Creates a new TurtleWriter that will write to the supplied Writer.
-	 * 
-	 * @param writer
-	 *        The Writer to write the Turtle document to.
-	 */
-	public TurtleWriter(Writer writer) {
-		this(writer, null);
-	}
-
-	/**
-	 * Creates a new TurtleWriter that will write to the supplied Writer.
-	 *
-	 * @param writer
-	 *        The Writer to write the Turtle document to.
-	 */
-	public TurtleWriter(Writer writer, ParsedIRI baseIRI) {
-		this.baseIRI = baseIRI;
-		this.writer = new IndentingWriter(writer);
-		namespaceTable = new LinkedHashMap<String, String>();
-		writingStarted = false;
-		statementClosed = true;
-		lastWrittenSubject = null;
-		lastWrittenPredicate = null;
-	}
-
-	/*---------*
-	 * Methods *
-	 *---------*/
-
-	@Override
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.TURTLE;
-	}
-
-	@Override
-	public void startRDF()
-		throws RDFHandlerException
-	{
-		if (writingStarted) {
-			throw new RuntimeException("Document writing has already started");
-		}
-
-		writingStarted = true;
-
-		try {
-			xsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);
-			prettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);
-			inlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);
-			if (prettyPrint) {
-				writer.setIndentationString("  ");
-			} else {
-				writer.setIndentationString("");
-			}
-			if (baseIRI != null && getWriterConfig().get(BasicWriterSettings.BASE_DIRECTIVE)) {
-				writeBase(baseIRI.toString());
-			}
-
-			// Write namespace declarations
-			for (Map.Entry<String, String> entry : namespaceTable.entrySet()) {
-				String name = entry.getKey();
-				String prefix = entry.getValue();
-
-				writeNamespace(prefix, name);
-			}
-
-			if (!namespaceTable.isEmpty()) {
-				writer.writeEOL();
-			}
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	@Override
-	public void endRDF()
-		throws RDFHandlerException
-	{
-		if (!writingStarted) {
-			throw new RuntimeException("Document writing has not yet started");
-		}
-
-		try {
-			closePreviousStatement();
-			writer.flush();
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-		finally {
-			writingStarted = false;
-		}
-	}
-
-	@Override
-	public void handleNamespace(String prefix, String name)
-		throws RDFHandlerException
-	{
-		try {
-			if (!namespaceTable.containsKey(name)) {
-				// Namespace not yet mapped to a prefix, try to give it the
-				// specified prefix
-
-				boolean isLegalPrefix = prefix.length() == 0 || TurtleUtil.isPN_PREFIX(prefix);
-
-				if (!isLegalPrefix || namespaceTable.containsValue(prefix)) {
-					// Specified prefix is not legal or the prefix is already in
-					// use,
-					// generate a legal unique prefix
-
-					if (prefix.length() == 0 || !isLegalPrefix) {
-						prefix = "ns";
-					}
-
-					int number = 1;
-
-					while (namespaceTable.containsValue(prefix + number)) {
-						number++;
-					}
-
-					prefix += number;
-				}
-
-				namespaceTable.put(name, prefix);
-
-				if (writingStarted) {
-					closePreviousStatement();
-
-					writeNamespace(prefix, name);
-				}
-			}
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	@Override
-	public void handleStatement(Statement st)
-		throws RDFHandlerException
-	{
-		if (!writingStarted) {
-			throw new RuntimeException("Document writing has not yet been started");
-		}
-
-		try {
-			Resource subj = st.getSubject();
-			IRI pred = st.getPredicate();
-			if (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {
-				handleList(st);
-			}
-			else if (inlineBNodes && !subj.equals(lastWrittenSubject) && stack.contains(subj)) {
-				handleInlineNode(st);
-			}
-			else {
-				closeHangingResource();
-				handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
-			}
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	/**
-	 * Internal method that differentiates between the pretty-print and streaming writer cases.
-	 * 
-	 * @param st
-	 *        The next statement to write
-	 * @param endRDFCalled
-	 *        True if endRDF has been called before this method is called. This is used to buffer statements
-	 *        for pretty-printing before dumping them when all statements have been delivered to us.
-	 * @param canShortenSubjectBNode
-	 *        True if, in the current context, we may be able to shorten the subject of this statement iff it
-	 *        is an instance of {@link BNode}.
-	 * @param canShortenObjectBNode
-	 *        True if, in the current context, we may be able to shorten the object of this statement iff it
-	 *        is an instance of {@link BNode}.
-	 */
-	protected void handleStatementInternal(Statement st, boolean endRDFCalled, boolean canShortenSubjectBNode,
-			boolean canShortenObjectBNode)
-	{
-		Resource subj = st.getSubject();
-		IRI pred = st.getPredicate();
-		Value obj = st.getObject();
-
-		try {
-			if (subj.equals(lastWrittenSubject)) {
-				if (pred.equals(lastWrittenPredicate)) {
-					// Identical subject and predicate
-					writer.write(",");
-					wrapLine(prettyPrint);
-				}
-				else {
-					// Identical subject, new predicate
-					writer.write(";");
-					writer.writeEOL();
-
-					// Write new predicate
-					writer.decreaseIndentation();
-					writePredicate(pred);
-					writer.increaseIndentation();
-					wrapLine(true);
-					path.removeLast();
-					path.addLast(pred);
-					lastWrittenPredicate = pred;
-				}
-			}
-			else {
-				// New subject
-				closePreviousStatement();
-				stack.addLast(subj);
-
-				// Write new subject:
-				if (prettyPrint) {
-					writer.writeEOL();
-				}
-				writeResource(subj, canShortenSubjectBNode);
-				wrapLine(true);
-				writer.increaseIndentation();
-				lastWrittenSubject = subj;
-
-				// Write new predicate
-				writePredicate(pred);
-				wrapLine(true);
-				path.addLast(pred);
-				lastWrittenPredicate = pred;
-
-				statementClosed = false;
-				writer.increaseIndentation();
-			}
-
-			writeValue(obj, canShortenObjectBNode);
-
-			// Don't close the line just yet. Maybe the next
-			// statement has the same subject and/or predicate.
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	@Override
-	public void handleComment(String comment)
-		throws RDFHandlerException
-	{
-		try {
-			closePreviousStatement();
-
-			if (comment.indexOf('\r') != -1 || comment.indexOf('\n') != -1) {
-				// Comment is not allowed to contain newlines or line feeds.
-				// Split comment in individual lines and write comment lines
-				// for each of them.
-				StringTokenizer st = new StringTokenizer(comment, "\r\n");
-				while (st.hasMoreTokens()) {
-					writeCommentLine(st.nextToken());
-				}
-			}
-			else {
-				writeCommentLine(comment);
-			}
-		}
-		catch (IOException e) {
-			throw new RDFHandlerException(e);
-		}
-	}
-
-	protected void writeCommentLine(String line)
-		throws IOException
-	{
-		writer.write("# ");
-		writer.write(line);
-		writer.writeEOL();
-	}
-
-	protected void writeBase(String baseURI)
-		throws IOException
-	{
-		writer.write("@base <");
-		writer.write(TurtleUtil.encodeURIString(baseURI));
-		writer.write("> .");
-		writer.writeEOL();
-	}
-
-	protected void writeNamespace(String prefix, String name)
-		throws IOException
-	{
-		writer.write("@prefix ");
-		writer.write(prefix);
-		writer.write(": <");
-		writer.write(TurtleUtil.encodeURIString(name));
-		writer.write("> .");
-		writer.writeEOL();
-	}
-
-	protected void writePredicate(IRI predicate)
-		throws IOException
-	{
-		if (predicate.equals(RDF.TYPE)) {
-			// Write short-cut for rdf:type
-			writer.write("a");
-		}
-		else {
-			writeURI(predicate);
-		}
-	}
-
-	/**
-	 * @param val
-	 *        The {@link Value} to write.
-	 * @throws IOException
-	 * @deprecated Use {@link #writeValue(Value, boolean)} instead.
-	 */
-	@Deprecated
-	protected void writeValue(Value val)
-		throws IOException
-	{
-		writeValue(val, false);
-	}
-
-	/**
-	 * Writes a value, optionally shortening it if it is an {@link IRI} and has a namespace definition that is
-	 * suitable for use in this context for shortening or a {@link BNode} that has been confirmed to be able
-	 * to be shortened in this context.
-	 * 
-	 * @param val
-	 *        The {@link Value} to write.
-	 * @param canShorten
-	 *        True if, in the current context, we can shorten this value if it is an instance of {@link BNode}
-	 *        .
-	 * @throws IOException
-	 */
-	protected void writeValue(Value val, boolean canShorten)
-		throws IOException
-	{
-		if (val instanceof BNode && canShorten && !val.equals(stack.peekLast())
-				&& !val.equals(lastWrittenSubject))
-		{
-			stack.addLast((BNode)val);
-		}
-		else if (val instanceof Resource) {
-			writeResource((Resource)val, canShorten);
-		}
-		else {
-			writeLiteral((Literal)val);
-		}
-	}
-
-	/**
-	 * @param res
-	 *        The {@link Resource} to write.
-	 * @throws IOException
-	 * @deprecated Use {@link #writeResource(Resource, boolean)} instead.
-	 */
-	@Deprecated
-	protected void writeResource(Resource res)
-		throws IOException
-	{
-		writeResource(res, false);
-	}
-
-	/**
-	 * Writes a {@link Resource}, optionally shortening it if it is an {@link IRI} and has a namespace
-	 * definition that is suitable for use in this context for shortening or a {@link BNode} that has been
-	 * confirmed to be able to be shortened in this context.
-	 * 
-	 * @param res
-	 *        The {@link Resource} to write.
-	 * @param canShorten
-	 *        True if, in the current context, we can shorten this value if it is an instance of {@link BNode}
-	 *        .
-	 * @throws IOException
-	 */
-	protected void writeResource(Resource res, boolean canShorten)
-		throws IOException
-	{
-		if (res instanceof IRI) {
-			writeURI((IRI)res);
-		}
-		else {
-			writeBNode((BNode)res, canShorten);
-		}
-	}
-
-	protected void writeURI(IRI uri)
-		throws IOException
-	{
-		String uriString = uri.toString();
-
-		// Try to find a prefix for the URI's namespace
-		String prefix = null;
-
-		int splitIdx = TurtleUtil.findURISplitIndex(uriString);
-		if (splitIdx > 0) {
-			String namespace = uriString.substring(0, splitIdx);
-			prefix = namespaceTable.get(namespace);
-		}
-
-		if (prefix != null) {
-			// Namespace is mapped to a prefix; write abbreviated URI
-			writer.write(prefix);
-			writer.write(":");
-			writer.write(uriString.substring(splitIdx));
-		}
-		else if (baseIRI != null) {
-			// Write relative URI
-			writer.write("<");
-			writer.write(TurtleUtil.encodeURIString(baseIRI.relativize(uriString)));
-			writer.write(">");
-		}
-		else {
-			// Write full URI
-			writer.write("<");
-			writer.write(TurtleUtil.encodeURIString(uriString));
-			writer.write(">");
-		}
-	}
-
-	/**
-	 * @param bNode
-	 *        The {@link BNode} to write.
-	 * @throws IOException
-	 * @deprecated Use {@link #writeBNode(BNode, boolean)} instead.
-	 */
-	@Deprecated
-	protected void writeBNode(BNode bNode)
-		throws IOException
-	{
-		writeBNode(bNode, false);
-	}
-
-	protected void writeBNode(BNode bNode, boolean canShorten)
-		throws IOException
-	{
-		if (canShorten) {
-			writer.write("[]");
-			return;
-		}
-
-		writer.write("_:");
-		String id = bNode.getID();
-
-		if (id.isEmpty()) {
-			if (this.getWriterConfig().get(BasicParserSettings.PRESERVE_BNODE_IDS)) {
-				throw new IOException(
-						"Cannot consistently write blank nodes with empty internal identifiers");
-			}
-			writer.write("genid-hash-");
-			writer.write(Integer.toHexString(System.identityHashCode(bNode)));
-		}
-		else {
-			if (!TurtleUtil.isNameStartChar(id.charAt(0))) {
-				writer.write("genid-start-");
-				writer.write(Integer.toHexString(id.charAt(0)));
-			}
-			else {
-				writer.write(id.charAt(0));
-			}
-			for (int i = 1; i < id.length() - 1; i++) {
-				if (TurtleUtil.isPN_CHARS(id.charAt(i))) {
-					writer.write(id.charAt(i));
-				}
-				else {
-					writer.write(Integer.toHexString(id.charAt(i)));
-				}
-			}
-			if (id.length() > 1) {
-				if (!TurtleUtil.isNameEndChar(id.charAt(id.length() - 1))) {
-					writer.write(Integer.toHexString(id.charAt(id.length() - 1)));
-				}
-				else {
-					writer.write(id.charAt(id.length() - 1));
-				}
-			}
-		}
-	}
-
-	protected void writeLiteral(Literal lit)
-		throws IOException
-	{
-		String label = lit.getLabel();
-		IRI datatype = lit.getDatatype();
-
-		if (prettyPrint) {
-			if (XMLSchema.INTEGER.equals(datatype) || XMLSchema.DECIMAL.equals(datatype)
-					|| XMLSchema.DOUBLE.equals(datatype) || XMLSchema.BOOLEAN.equals(datatype))
-			{
-				try {
-					writer.write(XMLDatatypeUtil.normalize(label, datatype));
-					return; // done
-				}
-				catch (IllegalArgumentException e) {
-					// not a valid numeric typed literal. ignore error and write
-					// as
-					// quoted string instead.
-				}
-			}
-		}
-
-		if (label.indexOf('\n') != -1 || label.indexOf('\r') != -1 || label.indexOf('\t') != -1) {
-			// Write label as long string
-			writer.write("\"\"\"");
-			writer.write(TurtleUtil.encodeLongString(label));
-			writer.write("\"\"\"");
-		}
-		else {
-			// Write label as normal string
-			writer.write("\"");
-			writer.write(TurtleUtil.encodeString(label));
-			writer.write("\"");
-		}
-
-		if (Literals.isLanguageLiteral(lit)) {
-			// Append the literal's language
-			writer.write("@");
-			writer.write(lit.getLanguage().get());
-		}
-		else if (!xsdStringToPlainLiteral || !XMLSchema.STRING.equals(datatype)) {
-			// Append the literal's datatype (possibly written as an abbreviated
-			// URI)
-			writer.write("^^");
-			writeURI(datatype);
-		}
-	}
-
-	protected void closePreviousStatement()
-		throws IOException
-	{
-		closeNestedResources(null);
-		if (!statementClosed) {
-			// The previous statement still needs to be closed:
-			writer.write(".");
-			writer.writeEOL();
-			writer.decreaseIndentation();
-			writer.decreaseIndentation();
-
-			stack.pollLast();
-			path.pollLast();
-			assert stack.isEmpty();
-			assert path.isEmpty();
-			statementClosed = true;
-			lastWrittenSubject = null;
-			lastWrittenPredicate = null;
-		}
-	}
-
-	private boolean isHanging() {
-		return !stack.isEmpty() && lastWrittenSubject != null && !lastWrittenSubject.equals(stack.peekLast());
-	}
-
-	private void closeHangingResource()
-		throws IOException
-	{
-		if (isHanging()) {
-			Value val = stack.pollLast();
-			if (val instanceof Resource) {
-				writeResource((Resource)val, inlineBNodes);
-			}
-			else {
-				writeLiteral((Literal)val);
-			}
-			assert lastWrittenSubject.equals(stack.peekLast());
-		}
-	}
-
-	private void closeNestedResources(Resource subj)
-		throws IOException
-	{
-		closeHangingResource();
-		while (stack.size() > 1 && !stack.peekLast().equals(subj)) {
-			if (prettyPrint) {
-				writer.writeEOL();
-			}
-			writer.decreaseIndentation();
-			writer.decreaseIndentation();
-			writer.write("]");
-
-			stack.pollLast();
-			path.pollLast();
-			lastWrittenSubject = stack.peekLast();
-			lastWrittenPredicate = path.peekLast();
-		}
-	}
-
-	private void handleInlineNode(Statement st)
-		throws IOException
-	{
-		Resource subj = st.getSubject();
-		IRI pred = st.getPredicate();
-		if (isHanging() && subj.equals(stack.peekLast())) {
-			// blank subject
-			lastWrittenSubject = subj;
-			writer.write("[");
-			if (prettyPrint && !RDF.TYPE.equals(pred)) {
-				writer.writeEOL();
-			}
-			else {
-				wrapLine(prettyPrint);
-			}
-			writer.increaseIndentation();
-
-			// Write new predicate
-			writePredicate(pred);
-			writer.increaseIndentation();
-			wrapLine(true);
-			path.addLast(pred);
-			lastWrittenPredicate = pred;
-			writeValue(st.getObject(), inlineBNodes);
-		}
-		else if (!subj.equals(lastWrittenSubject) && stack.contains(subj)) {
-			closeNestedResources(subj);
-			handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
-		}
-		else {
-			assert false;
-		}
-	}
-
-	private void handleList(Statement st)
-		throws IOException
-	{
-		Resource subj = st.getSubject();
-		boolean first = RDF.FIRST.equals(st.getPredicate());
-		boolean rest = RDF.REST.equals(st.getPredicate()) && !RDF.NIL.equals(st.getObject());
-		boolean nil = RDF.REST.equals(st.getPredicate()) && RDF.NIL.equals(st.getObject());
-		if (first && REST != lastWrittenPredicate && isHanging()) {
-			// new collection
-			writer.write("(");
-			writer.increaseIndentation();
-			wrapLine(false);
-			lastWrittenSubject = subj;
-			path.addLast(FIRST);
-			lastWrittenPredicate = FIRST;
-			writeValue(st.getObject(), inlineBNodes);
-		}
-		else if (first && REST == lastWrittenPredicate) {
-			// item in existing collection
-			lastWrittenSubject = subj;
-			path.addLast(FIRST);
-			lastWrittenPredicate = FIRST;
-			writeValue(st.getObject(), inlineBNodes);
-		}
-		else {
-			closeNestedResources(subj);
-			if (rest && FIRST == lastWrittenPredicate) {
-				// next item
-				wrapLine(true);
-				path.removeLast(); // RDF.FIRST
-				path.addLast(REST);
-				lastWrittenPredicate = REST;
-				writeValue(st.getObject(), inlineBNodes);
-			}
-			else if (nil && FIRST == lastWrittenPredicate) {
-				writer.decreaseIndentation();
-				writer.write(")");
-				path.removeLast(); // RDF.FIRST
-				path.addLast(REST);
-				while (REST == path.peekLast()) {
-					stack.pollLast();
-					path.pollLast();
-					lastWrittenSubject = stack.peekLast();
-					lastWrittenPredicate = path.peekLast();
-				}
-			}
-			else {
-				handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
-			}
-		}
-	}
-
-	private void wrapLine(boolean space) throws IOException {
-		if (prettyPrint && writer.getCharactersSinceEOL() > LINE_WRAP) {
-			writer.writeEOL();
-		} else if (space) {
-			writer.write(" ");
-		}
-	}
-}
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java
deleted file mode 100644
index 935c9a9d4c..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import java.io.OutputStream;
-import java.io.Writer;
-import java.net.URISyntaxException;
-
-import org.eclipse.rdf4j.common.net.ParsedIRI;
-import org.eclipse.rdf4j.rio.RDFFormat;
-import org.eclipse.rdf4j.rio.RDFWriter;
-import org.eclipse.rdf4j.rio.RDFWriterFactory;
-
-/**
- * An {@link RDFWriterFactory} for Turtle writers.
- * 
- * @author Arjohn Kampman
- */
-public class TurtleWriterFactory implements RDFWriterFactory {
-
-	/**
-	 * Returns {@link RDFFormat#TURTLE}.
-	 */
-	public RDFFormat getRDFFormat() {
-		return RDFFormat.TURTLE;
-	}
-
-	/**
-	 * Returns a new instance of {@link TurtleWriter}.
-	 */
-	public RDFWriter getWriter(OutputStream out) {
-		return new ArrangedWriter(new TurtleWriter(out));
-	}
-
-	public RDFWriter getWriter(OutputStream out, String baseURI)
-		throws URISyntaxException
-	{
-		return new ArrangedWriter(new TurtleWriter(out, new ParsedIRI(baseURI)));
-	}
-
-	/**
-	 * Returns a new instance of {@link TurtleWriter}.
-	 */
-	public RDFWriter getWriter(Writer writer) {
-		return new ArrangedWriter(new TurtleWriter(writer));
-	}
-
-	public RDFWriter getWriter(Writer writer, String baseURI)
-		throws URISyntaxException
-	{
-		return new ArrangedWriter(new TurtleWriter(writer, new ParsedIRI(baseURI)));
-	}
-}
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/package.html b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/package.html
deleted file mode 100644
index 6dfcedcda1..0000000000
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/package.html
+++ /dev/null
@@ -1,6 +0,0 @@
-<html>
-<head></head>
-<body>
-Parser and writer for RDF in <a href="http://www.dajobe.org/2004/01/turtle/">Turtle</a> format.
-</body>
-</html>
diff --git a/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory b/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory
deleted file mode 100644
index 8d96d58a7f..0000000000
--- a/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFParserFactory
+++ /dev/null
@@ -1 +0,0 @@
-org.eclipse.rdf4j.rio.turtle.TurtleParserFactory
diff --git a/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory b/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory
deleted file mode 100644
index 90e6730bb3..0000000000
--- a/core/rio/turtle/src/main/resources/META-INF/services/org.eclipse.rdf4j.rio.RDFWriterFactory
+++ /dev/null
@@ -1 +0,0 @@
-org.eclipse.rdf4j.rio.turtle.TurtleWriterFactory
diff --git a/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TestTurtleParser.java b/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TestTurtleParser.java
deleted file mode 100644
index f601cd706d..0000000000
--- a/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TestTurtleParser.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import static org.hamcrest.CoreMatchers.not;
-import static org.hamcrest.Matchers.empty;
-import static org.hamcrest.Matchers.hasSize;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.io.InputStream;
-import java.io.Reader;
-import java.io.StringReader;
-import java.net.URL;
-import java.util.Collection;
-import java.util.Iterator;
-
-import org.eclipse.rdf4j.model.Resource;
-import org.eclipse.rdf4j.model.Statement;
-import org.eclipse.rdf4j.model.ValueFactory;
-import org.eclipse.rdf4j.model.impl.SimpleValueFactory;
-import org.eclipse.rdf4j.model.vocabulary.DC;
-import org.eclipse.rdf4j.rio.RDFParseException;
-import org.eclipse.rdf4j.rio.RDFParser;
-import org.eclipse.rdf4j.rio.helpers.BasicParserSettings;
-import org.eclipse.rdf4j.rio.helpers.ParseErrorCollector;
-import org.eclipse.rdf4j.rio.helpers.SimpleParseLocationListener;
-import org.eclipse.rdf4j.rio.helpers.StatementCollector;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.Matchers;
-import org.junit.Before;
-import org.junit.Test;
-
-/**
- * @author jeen
- */
-public class TestTurtleParser {
-
-	private TurtleParser parser;
-
-	private ValueFactory vf = SimpleValueFactory.getInstance();
-
-	private final ParseErrorCollector errorCollector = new ParseErrorCollector();
-
-	private final StatementCollector statementCollector = new StatementCollector();
-
-	private final String prefixes = "@prefix ex: <http://example.org/ex/> . \n@prefix : <http://example.org/> . \n";
-
-	private final String baseURI = "http://example.org/";
-
-	private SimpleParseLocationListener locationListener = new SimpleParseLocationListener();
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp()
-		throws Exception
-	{
-		parser = new TurtleParser();
-		parser.setParseErrorListener(errorCollector);
-		parser.setRDFHandler(statementCollector);
-		parser.setParseLocationListener(locationListener);
-	}
-
-	@Test
-	public void testParseDots()
-		throws Exception
-	{
-
-		String data = prefixes + " ex:foo.bar ex:\\~foo.bar ex:foobar. ";
-
-		parser.parse(new StringReader(data), baseURI);
-
-		assertTrue(errorCollector.getWarnings().isEmpty());
-		assertTrue(errorCollector.getErrors().isEmpty());
-		assertTrue(errorCollector.getFatalErrors().isEmpty());
-
-		assertFalse(statementCollector.getStatements().isEmpty());
-		assertEquals(1, statementCollector.getStatements().size());
-
-		for (Statement st : statementCollector.getStatements()) {
-			System.out.println(st);
-		}
-	}
-
-	@Test
-	public void testParseIllegalURIFatal()
-		throws Exception
-	{
-		String data = " <urn:foo_bar\\r> <urn:foo> <urn:bar> ; <urn:foo2> <urn:bar2> . <urn:foobar> <urn:food> <urn:barf> . ";
-
-		try {
-			parser.parse(new StringReader(data), baseURI);
-			fail("default config should result in fatal error / parse exception");
-		}
-		catch (RDFParseException e) {
-			// expected
-		}
-	}
-
-	@Test
-	public void testParseIllegalURINonFatal()
-		throws Exception
-	{
-		String data = " <urn:foo_bar\\r> <urn:foo> <urn:bar> ; <urn:foo2> <urn:bar2> . <urn:foobar> <urn:food> <urn:barf> . ";
-
-		parser.getParserConfig().addNonFatalError(BasicParserSettings.VERIFY_URI_SYNTAX);
-		parser.parse(new StringReader(data), baseURI);
-		assertThat(errorCollector.getErrors(), hasSize(1));
-		assertThat(errorCollector.getFatalErrors(), empty());
-		assertThat(statementCollector.getStatements(), not(empty()));
-		assertThat("only syntactically legal triples should have been reported",
-				statementCollector.getStatements(), hasSize(1));
-	}
-
-	@Test
-	public void testParseIllegalURINoVerify()
-		throws Exception
-	{
-		String data = " <urn:foo_bar\\r> <urn:foo> <urn:bar> ; <urn:foo2> <urn:bar2> . <urn:foobar> <urn:food> <urn:barf> . ";
-
-		parser.getParserConfig().set(BasicParserSettings.VERIFY_URI_SYNTAX, false);
-
-		parser.parse(new StringReader(data), baseURI);
-		assertThat(errorCollector.getErrors(), empty());
-		assertThat(errorCollector.getFatalErrors(), empty());
-		assertThat(statementCollector.getStatements(), not(empty()));
-		assertThat("all triples should have been reported", statementCollector.getStatements(), hasSize(3));
-	}
-
-	@Test
-	public void testParseBNodes()
-		throws Exception
-	{
-		String data = prefixes + " [ :p  :o1,:2 ] . ";
-
-		parser.parse(new StringReader(data), baseURI);
-
-		assertTrue(errorCollector.getWarnings().isEmpty());
-		assertTrue(errorCollector.getErrors().isEmpty());
-		assertTrue(errorCollector.getFatalErrors().isEmpty());
-
-		assertFalse(statementCollector.getStatements().isEmpty());
-		assertEquals(2, statementCollector.getStatements().size());
-
-		for (Statement st : statementCollector.getStatements()) {
-			System.out.println(st);
-		}
-	}
-
-	@Test
-	public void testLineNumberReporting()
-		throws Exception
-	{
-
-		InputStream in = this.getClass().getResourceAsStream("/test-newlines.ttl");
-		try {
-			parser.parse(in, baseURI);
-			fail("expected to fail parsing input file");
-		}
-		catch (RDFParseException e) {
-			// expected
-			assertFalse(errorCollector.getFatalErrors().isEmpty());
-			final String error = errorCollector.getFatalErrors().get(0);
-			// expected to fail at line 9.
-			assertTrue(error.contains("(9,"));
-			assertEquals(9, locationListener.getLineNo());
-			assertEquals(-1, locationListener.getColumnNo());
-		}
-	}
-
-	@Test
-	public void testLineNumberReportingNoErrorsSingleLine()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("<urn:a> <urn:b> <urn:c>.");
-		parser.parse(in, baseURI);
-		assertEquals(1, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingNoErrorsSingleLineEndNewline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("<urn:a> <urn:b> <urn:c>.\n");
-		parser.parse(in, baseURI);
-		assertEquals(2, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingNoErrorsMultipleLinesNoEndNewline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("<urn:a> <urn:b> <urn:c>.\n<urn:a> <urn:b> <urn:d>.");
-		parser.parse(in, baseURI);
-		assertEquals(2, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingNoErrorsMultipleLinesEndNewline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("<urn:a> <urn:b> <urn:c>.\n<urn:a> <urn:b> <urn:d>.\n");
-		parser.parse(in, baseURI);
-		assertEquals(3, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingOnlySingleCommentNoEndline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("# This is just a comment");
-		parser.parse(in, baseURI);
-		assertEquals(1, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingOnlySingleCommentEndline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("# This is just a comment\n");
-		parser.parse(in, baseURI);
-		assertEquals(2, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingOnlySingleCommentCarriageReturn()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("# This is just a comment\r");
-		parser.parse(in, baseURI);
-		assertEquals(2, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testLineNumberReportingOnlySingleCommentCarriageReturnNewline()
-		throws Exception
-	{
-		assertEquals(0, locationListener.getLineNo());
-		assertEquals(0, locationListener.getColumnNo());
-		Reader in = new StringReader("# This is just a comment\r\n");
-		parser.parse(in, baseURI);
-		assertEquals(2, locationListener.getLineNo());
-		assertEquals(-1, locationListener.getColumnNo());
-	}
-
-	@Test
-	public void testParseBooleanLiteralComma()
-		throws Exception
-	{
-		String data = "<urn:a> <urn:b> true, false .";
-		Reader r = new StringReader(data);
-
-		try {
-			parser.parse(r, baseURI);
-			assertTrue(statementCollector.getStatements().size() == 2);
-		}
-		catch (RDFParseException e) {
-			fail("parse error on correct data: " + e.getMessage());
-		}
-	}
-
-	@Test
-	public void testParseBooleanLiteralWhitespaceComma()
-		throws Exception
-	{
-		String data = "<urn:a> <urn:b> true , false .";
-		Reader r = new StringReader(data);
-
-		try {
-			parser.parse(r, baseURI);
-			assertTrue(statementCollector.getStatements().size() == 2);
-		}
-		catch (RDFParseException e) {
-			fail("parse error on correct data: " + e.getMessage());
-		}
-	}
-
-	@Test
-	public void testParseBooleanLiteralSemicolumn()
-		throws Exception
-	{
-		String data = "<urn:a> <urn:b> true; <urn:c> false .";
-		Reader r = new StringReader(data);
-
-		try {
-			parser.parse(r, baseURI);
-			assertTrue(statementCollector.getStatements().size() == 2);
-		}
-		catch (RDFParseException e) {
-			fail("parse error on correct data: " + e.getMessage());
-		}
-	}
-
-	@Test
-	public void testParseBooleanLiteralWhitespaceSemicolumn()
-		throws Exception
-	{
-		String data = "<urn:a> <urn:b> true ; <urn:c> false .";
-		Reader r = new StringReader(data);
-
-		try {
-			parser.parse(r, baseURI);
-			assertTrue(statementCollector.getStatements().size() == 2);
-		}
-		catch (RDFParseException e) {
-			fail("parse error on correct data: " + e.getMessage());
-		}
-	}
-
-	@Test
-	public void rdfXmlLoadedFromInsideAJarResolvesRelativeUris()
-		throws Exception
-	{
-		URL zipfileUrl = TestTurtleParser.class.getResource("sample-with-turtle-data.zip");
-
-		assertNotNull("The sample-with-turtle-data.zip file must be present for this test", zipfileUrl);
-
-		String url = "jar:" + zipfileUrl + "!/index.ttl";
-
-		RDFParser parser = new TurtleParser();
-
-		StatementCollector sc = new StatementCollector();
-		parser.setRDFHandler(sc);
-
-		InputStream in = new URL(url).openStream();
-		parser.parse(in, url);
-		in.close();
-
-		Collection<Statement> stmts = sc.getStatements();
-
-		assertThat(stmts, Matchers.<Statement> iterableWithSize(2));
-
-		Iterator<Statement> iter = stmts.iterator();
-
-		Statement stmt1 = iter.next(), stmt2 = iter.next();
-
-		assertEquals(vf.createIRI("http://www.example.com/#"), stmt1.getSubject());
-		assertEquals(vf.createIRI("http://www.example.com/ns/#document-about"), stmt1.getPredicate());
-
-		Resource res = (Resource)stmt1.getObject();
-
-		String resourceUrl = res.stringValue();
-
-		assertThat(resourceUrl, CoreMatchers.startsWith("jar:" + zipfileUrl + "!"));
-
-		URL javaUrl = new URL(resourceUrl);
-		assertEquals("jar", javaUrl.getProtocol());
-
-		InputStream uc = javaUrl.openStream();
-		assertEquals("The resource stream should be empty", -1, uc.read());
-		uc.close();
-
-		assertEquals(res, stmt2.getSubject());
-		assertEquals(DC.TITLE, stmt2.getPredicate());
-		assertEquals(vf.createLiteral("Empty File"), stmt2.getObject());
-	}
-}
diff --git a/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TurtleUtilTest.java b/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TurtleUtilTest.java
deleted file mode 100644
index 1c94a7962f..0000000000
--- a/core/rio/turtle/src/test/java/org/eclipse/rdf4j/rio/turtle/TurtleUtilTest.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Distribution License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/org/documents/edl-v10.php.
- *******************************************************************************/
-package org.eclipse.rdf4j.rio.turtle;
-
-import static org.junit.Assert.assertFalse;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-/**
- * Test for the utility methods in {@link TurtleUtil}.
- * 
- * @author Peter Ansell
- */
-public class TurtleUtilTest {
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@Before
-	public void setUp()
-		throws Exception
-	{
-	}
-
-	/**
-	 * @throws java.lang.Exception
-	 */
-	@After
-	public void tearDown()
-		throws Exception
-	{
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#findURISplitIndex(java.lang.String)} .
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testFindURISplitIndex() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isWhitespace(int)}.
-	 */
-	@Test
-	public final void testIsWhitespace() {
-		assertFalse(TurtleUtil.isWhitespace(';'));
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_CHARS_BASE(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_CHARS_BASE() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_CHARS_U(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_CHARS_U() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_CHARS(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_CHARS() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPrefixStartChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPrefixStartChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isNameStartChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsNameStartChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isNameChar(int)}.
-	 */
-	@Test
-	public final void testIsNameChar() {
-		assertFalse(TurtleUtil.isNameChar(';'));
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isNameEndChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsNameEndChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isLocalEscapedChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsLocalEscapedChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPrefixChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPrefixChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isLanguageStartChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsLanguageStartChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isLanguageChar(int)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsLanguageChar() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_PREFIX(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_PREFIX() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPLX_START(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPLX_START() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPERCENT(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPERCENT() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPLX_INTERNAL(java.lang.String)} .
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPLX_INTERNAL() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_LOCAL_ESC(java.lang.String)} .
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_LOCAL_ESC() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#isPN_LOCAL(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testIsPN_LOCAL() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#encodeString(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testEncodeString() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#encodeLongString(java.lang.String)} .
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testEncodeLongString() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#encodeURIString(java.lang.String)} .
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testEncodeURIString() {
-
-	}
-
-	/**
-	 * Test method for {@link org.eclipse.rdf4j.rio.turtle.TurtleUtil#decodeString(java.lang.String)}.
-	 */
-	@Ignore("TODO: Implement me")
-	@Test
-	public final void testDecodeString() {
-
-	}
-
-}
diff --git a/core/rio/turtle/src/test/resources/org/eclipse/rdf4j/rio/turtle/sample-with-turtle-data.zip b/core/rio/turtle/src/test/resources/org/eclipse/rdf4j/rio/turtle/sample-with-turtle-data.zip
deleted file mode 100644
index 2908e354e4..0000000000
Binary files a/core/rio/turtle/src/test/resources/org/eclipse/rdf4j/rio/turtle/sample-with-turtle-data.zip and /dev/null differ
diff --git a/core/rio/turtle/src/test/resources/test-newlines.ttl b/core/rio/turtle/src/test/resources/test-newlines.ttl
deleted file mode 100644
index 677f2d3362..0000000000
--- a/core/rio/turtle/src/test/resources/test-newlines.ttl
+++ /dev/null
@@ -1,11 +0,0 @@
-@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
-@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
-@prefix ex: <http://example.org/> .
-
-ex:a a ex:Foo .
-ex:b a ex:Foo .
-ex:b ex:value '''^M'''.
-ex:c 
-    :foo ex:Foo .
-ex:a ex:value 1.0 .
-ex:a ex:value 3.0 .
