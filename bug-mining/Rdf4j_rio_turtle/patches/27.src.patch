diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java
new file mode 100644
index 0000000000..fcac0ce79b
--- /dev/null
+++ b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/ArrangedWriter.java
@@ -0,0 +1,419 @@
+/*******************************************************************************
+ * Copyright (c) 2017 Eclipse RDF4J contributors, Aduna, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Distribution License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/org/documents/edl-v10.php.
+ *******************************************************************************/
+package org.eclipse.rdf4j.rio.turtle;
+
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+import org.eclipse.rdf4j.model.BNode;
+import org.eclipse.rdf4j.model.IRI;
+import org.eclipse.rdf4j.model.Literal;
+import org.eclipse.rdf4j.model.Model;
+import org.eclipse.rdf4j.model.Resource;
+import org.eclipse.rdf4j.model.Statement;
+import org.eclipse.rdf4j.model.Value;
+import org.eclipse.rdf4j.model.impl.LinkedHashModel;
+import org.eclipse.rdf4j.model.vocabulary.RDF;
+import org.eclipse.rdf4j.rio.RDFFormat;
+import org.eclipse.rdf4j.rio.RDFHandlerException;
+import org.eclipse.rdf4j.rio.RDFWriter;
+import org.eclipse.rdf4j.rio.RioSetting;
+import org.eclipse.rdf4j.rio.WriterConfig;
+import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
+
+/**
+ * Internal wrapper that sorts statements for pretty printing and repeats blank nodes if inlining them.
+ *
+ * @author James Leigh
+ * @since 2.3
+ */
+class ArrangedWriter implements RDFWriter {
+
+	private final static int DEFAULT_QUEUE_SIZE = 100;
+
+	private final RDFWriter delegate;
+
+	private boolean repeatBlankNodes;
+
+	private int targetQueueSize;
+
+	private int queueSize = 0;
+
+	private final Deque<SubjectInContext> stack = new LinkedList<>();
+
+	private final Map<String, String> prefixes = new TreeMap<String, String>();
+
+	private final Map<SubjectInContext, Set<Statement>> stmtBySubject = new LinkedHashMap<>();
+
+	private final Model blanks = new LinkedHashModel();
+
+	private final Model blankReferences = new LinkedHashModel();
+
+	private final Comparator<Statement> comparator = new Comparator<Statement>() {
+
+		public int compare(Statement s1, Statement s2) {
+			IRI p1 = s1.getPredicate();
+			IRI p2 = s2.getPredicate();
+			if (p1.equals(RDF.TYPE) && !p2.equals(RDF.TYPE)) {
+				return -1;
+			}
+			else if (!p1.equals(RDF.TYPE) && p2.equals(RDF.TYPE)) {
+				return 1;
+			}
+			int cmp = p1.stringValue().compareTo(p2.stringValue());
+			if (cmp != 0)
+				return cmp;
+			Value o1 = s1.getObject();
+			Value o2 = s2.getObject();
+			if (!(o1 instanceof BNode) && o2 instanceof BNode) {
+				return -1;
+			}
+			else if (o1 instanceof BNode && !(o2 instanceof BNode)) {
+				return 1;
+			}
+			if (!(o1 instanceof IRI) && o2 instanceof IRI) {
+				return -1;
+			}
+			else if (o1 instanceof IRI && !(o2 instanceof IRI)) {
+				return 1;
+			}
+			return o1.stringValue().compareTo(o2.stringValue());
+		}
+	};
+
+	public ArrangedWriter(RDFWriter delegate) {
+		this(delegate, 0);
+	}
+
+	public ArrangedWriter(RDFWriter delegate, int size) {
+		this(delegate, size, size == -1);
+	}
+
+	public ArrangedWriter(RDFWriter delegate, int size, boolean repeatBlankNodes) {
+		this.delegate = delegate;
+		this.targetQueueSize = size;
+		this.repeatBlankNodes = repeatBlankNodes;
+	}
+
+	public RDFFormat getRDFFormat() {
+		return delegate.getRDFFormat();
+	}
+
+	public RDFWriter setWriterConfig(WriterConfig config) {
+		return delegate.setWriterConfig(config);
+	}
+
+	public WriterConfig getWriterConfig() {
+		return delegate.getWriterConfig();
+	}
+
+	public Collection<RioSetting<?>> getSupportedSettings() {
+		return delegate.getSupportedSettings();
+	}
+
+	public <T> RDFWriter set(RioSetting<T> setting, T value) {
+		return delegate.set(setting, value);
+	}
+
+	public void startRDF()
+		throws RDFHandlerException
+	{
+		if (getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES)) {
+			targetQueueSize = -1;
+			repeatBlankNodes = true;
+		}
+		else if (getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT)) {
+			targetQueueSize = DEFAULT_QUEUE_SIZE;
+		}
+		delegate.startRDF();
+	}
+
+	public void endRDF()
+		throws RDFHandlerException
+	{
+		trimNamespaces();
+		flushStatements();
+		delegate.endRDF();
+	}
+
+	public void handleNamespace(String prefix, String uri)
+		throws RDFHandlerException
+	{
+		flushStatements();
+		if (targetQueueSize == 0) {
+			delegate.handleNamespace(prefix, uri);
+		}
+		else if (!prefixes.containsKey(uri)) {
+			prefixes.put(uri, prefix);
+		}
+	}
+
+	public void handleComment(String comment)
+		throws RDFHandlerException
+	{
+		flushStatements();
+		delegate.handleComment(comment);
+	}
+
+	public synchronized void handleStatement(Statement st)
+		throws RDFHandlerException
+	{
+		if (targetQueueSize == 0) {
+			delegate.handleStatement(st);
+		}
+		else {
+			queueStatement(st);
+		}
+		while (targetQueueSize >= 0 && queueSize > targetQueueSize) {
+			flushNamespaces();
+			delegate.handleStatement(nextStatement());
+		}
+	}
+
+	private synchronized Statement nextStatement() {
+		if (stmtBySubject.isEmpty() && blanks.isEmpty()) {
+			assert queueSize == 0;
+			return null;
+		}
+		Set<Statement> stmts = null;
+		while (stmts == null) {
+			SubjectInContext last = stack.peekLast();
+			stmts = stmtBySubject.get(last);
+			if (stmts == null && last != null
+					&& blanks.contains(last.getSubject(), null, null, last.getContext()))
+			{
+				stmts = queueBlankStatements(last);
+			}
+			else if (stmts == null) {
+				stack.pollLast();
+			}
+			if (stack.isEmpty() && stmtBySubject.isEmpty()) {
+				Statement st = blanks.iterator().next();
+				stmts = queueBlankStatements(new SubjectInContext(st));
+			}
+			else if (stack.isEmpty()) {
+				stmts = stmtBySubject.values().iterator().next();
+			}
+		}
+		Iterator<Statement> iter = stmts.iterator();
+		Statement next = iter.next();
+		queueSize--;
+		iter.remove();
+		SubjectInContext key = new SubjectInContext(next);
+		if (!key.equals(stack.peekLast())) {
+			stack.addLast(key);
+		}
+		if (!iter.hasNext()) {
+			stmtBySubject.remove(key);
+		}
+		Value obj = next.getObject();
+		if (obj instanceof BNode) {
+			// follow blank nodes before continuing with this subject
+			SubjectInContext bkey = new SubjectInContext((BNode)obj, next.getContext());
+			if (stack.contains(bkey)) {
+				// cycle detected
+				if (repeatBlankNodes) {
+					throw new RDFHandlerException("Blank node cycle detected. Try disabling "
+							+ BasicWriterSettings.INLINE_BLANK_NODES.getKey());
+				}
+			}
+			else {
+				stack.addLast(bkey);
+			}
+		}
+		return next;
+	}
+
+	private synchronized Set<Statement> queueBlankStatements(SubjectInContext key) {
+		Model firstMatch = blanks.filter(key.getSubject(), null, null, key.getContext());
+		Model matches = firstMatch.isEmpty()
+				? blankReferences.filter(key.getSubject(), null, null, key.getContext())
+				: firstMatch;
+		if (matches.isEmpty()) {
+			return null;
+		}
+		Set<Statement> set = stmtBySubject.get(key);
+		if (set == null) {
+			stmtBySubject.put(key, set = new TreeSet<Statement>(comparator));
+		}
+		set.addAll(matches);
+		if (firstMatch.isEmpty()) {
+			// repeat blank node values
+			queueSize += matches.size();
+		}
+		else {
+			if (repeatBlankNodes && key.getSubject() instanceof BNode && isStillReferenced(key)) {
+				blankReferences.addAll(matches);
+			}
+			blanks.remove(key.getSubject(), null, null, key.getContext());
+		}
+		return set;
+	}
+
+	private boolean isStillReferenced(SubjectInContext key) {
+		if (blanks.contains(null, null, key.getSubject(), key.getContext())) {
+			return true;
+		}
+		for (SubjectInContext subj : stack) {
+			Set<Statement> stmts = stmtBySubject.get(subj);
+			if (stmts != null) {
+				for (Statement st : stmts) {
+					if (st.getObject().equals(key.getSubject())
+							|| Objects.equals(st.getContext(), key.getContext()))
+					{
+						return true;
+					}
+				}
+			}
+		}
+		return false;
+	}
+
+	private synchronized void queueStatement(Statement st) {
+		SubjectInContext key = new SubjectInContext(st);
+		Set<Statement> stmts = stmtBySubject.get(key);
+		if (stmts == null && st.getSubject() instanceof BNode && !stack.contains(key)) {
+			blanks.add(st);
+		}
+		else {
+			if (stmts == null) {
+				stmtBySubject.put(key, stmts = new TreeSet<Statement>(comparator));
+			}
+			stmts.add(st);
+		}
+		queueSize++;
+	}
+
+	private synchronized void flushStatements()
+		throws RDFHandlerException
+	{
+		if (!stmtBySubject.isEmpty() || !blanks.isEmpty()) {
+			flushNamespaces();
+			Statement st;
+			while ((st = nextStatement()) != null) {
+				delegate.handleStatement(st);
+			}
+			assert queueSize == 0;
+		}
+	}
+
+	private synchronized void flushNamespaces()
+		throws RDFHandlerException
+	{
+		Map<String, String> namespaces = new TreeMap<String, String>();
+		for (Map.Entry<String, String> e : prefixes.entrySet()) {
+			namespaces.put(e.getValue(), e.getKey());
+		}
+		for (Map.Entry<String, String> e : namespaces.entrySet()) {
+			delegate.handleNamespace(e.getKey(), e.getValue());
+		}
+		prefixes.clear();
+	}
+
+	private synchronized void trimNamespaces() {
+		if (!prefixes.isEmpty()) {
+			Set<String> used = new HashSet<String>(prefixes.size());
+			for (Set<Statement> stmts : stmtBySubject.values()) {
+				getUsedNamespaces(stmts, used);
+			}
+			getUsedNamespaces(blanks, used);
+			prefixes.keySet().retainAll(used);
+		}
+	}
+
+	private void getUsedNamespaces(Set<Statement> stmts, Set<String> used) {
+		for (Statement st : stmts) {
+			used.add(st.getPredicate().getNamespace());
+			if (st.getObject() instanceof IRI) {
+				IRI uri = (IRI)st.getObject();
+				used.add(uri.getNamespace());
+			}
+			else if (st.getObject() instanceof Literal) {
+				Literal lit = (Literal)st.getObject();
+				if (lit.getDatatype() != null) {
+					used.add(lit.getDatatype().getNamespace());
+				}
+			}
+		}
+	}
+
+	private class SubjectInContext {
+
+		private Resource subject;
+
+		private Resource context;
+
+		private SubjectInContext(Statement st) {
+			this(st.getSubject(), st.getContext());
+		}
+
+		private SubjectInContext(Resource subject, Resource context) {
+			assert subject != null;
+			this.subject = subject;
+			this.context = context;
+		}
+
+		public Resource getSubject() {
+			return subject;
+		}
+
+		public Resource getContext() {
+			return context;
+		}
+
+		@Override
+		public String toString() {
+			if (context == null) {
+				return subject.toString();
+			}
+			else {
+				return subject.toString() + " [" + context.toString() + "]";
+			}
+		}
+
+		@Override
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + subject.hashCode();
+			result = prime * result + ((context == null) ? 0 : context.hashCode());
+			return result;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			SubjectInContext other = (SubjectInContext)obj;
+			if (!subject.equals(other.subject))
+				return false;
+			if (context == null) {
+				if (other.context != null)
+					return false;
+			}
+			else if (!context.equals(other.context))
+				return false;
+			return true;
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java
index c5dd84a1e6..69fbe037ea 100644
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java
+++ b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriter.java
@@ -12,7 +12,9 @@ import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
 import java.nio.charset.Charset;
+import java.util.Deque;
 import java.util.LinkedHashMap;
+import java.util.LinkedList;
 import java.util.Map;
 import java.util.StringTokenizer;
 
@@ -26,7 +28,7 @@ import org.eclipse.rdf4j.model.Resource;
 import org.eclipse.rdf4j.model.Statement;
 import org.eclipse.rdf4j.model.Value;
 import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
-import org.eclipse.rdf4j.model.impl.LinkedHashModel;
+import org.eclipse.rdf4j.model.impl.SimpleIRI;
 import org.eclipse.rdf4j.model.util.Literals;
 import org.eclipse.rdf4j.model.vocabulary.RDF;
 import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
@@ -43,6 +45,18 @@ import org.eclipse.rdf4j.rio.helpers.BasicWriterSettings;
  */
 public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 
+	private static final int LINE_WRAP = 80;
+
+	private static final IRI FIRST = new SimpleIRI(RDF.FIRST.stringValue()) {
+
+		private static final long serialVersionUID = -7951518099940758898L;
+	};
+
+	private static final IRI REST = new SimpleIRI(RDF.REST.stringValue()) {
+
+		private static final long serialVersionUID = -7951518099940758898L;
+	};
+
 	/*-----------*
 	 * Variables *
 	 *-----------*/
@@ -63,9 +77,20 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 	protected IRI lastWrittenPredicate;
 
 	/**
-	 * A {@link Model} that is only used if pretty printing is enabled before startRDF is called;
+	 * Always null
 	 */
-	protected Model prettyPrintModel = null;
+	@Deprecated
+	protected Model prettyPrintModel;
+
+	private final Deque<Resource> stack = new LinkedList<Resource>();
+
+	private final Deque<IRI> path = new LinkedList<IRI>();
+
+	private Boolean xsdStringToPlainLiteral;
+
+	private Boolean prettyPrint;
+
+	private boolean inlineBNodes;
 
 	/*--------------*
 	 * Constructors *
@@ -136,11 +161,15 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 
 		writingStarted = true;
 
-		if (getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT)) {
-			prettyPrintModel = new LinkedHashModel();
-		}
-
 		try {
+			xsdStringToPlainLiteral = getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);
+			prettyPrint = getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT);
+			inlineBNodes = getWriterConfig().get(BasicWriterSettings.INLINE_BLANK_NODES);
+			if (prettyPrint) {
+				writer.setIndentationString("  ");
+			} else {
+				writer.setIndentationString("");
+			}
 			if (baseIRI != null && getWriterConfig().get(BasicWriterSettings.BASE_DIRECTIVE)) {
 				writeBase(baseIRI.toString());
 			}
@@ -151,9 +180,6 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 				String prefix = entry.getValue();
 
 				writeNamespace(prefix, name);
-				if (prettyPrintModel != null) {
-					prettyPrintModel.setNamespace(prefix, name);
-				}
 			}
 
 			if (!namespaceTable.isEmpty()) {
@@ -174,71 +200,6 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 		}
 
 		try {
-			if (prettyPrintModel != null) {
-				// Note: We can't guarantee ordering at this point because Resource doesn't implement Comparable<Resource>
-				for (Resource nextContext : prettyPrintModel.contexts()) {
-					for (Resource nextSubject : prettyPrintModel.subjects()) {
-						boolean canShortenSubjectBNode = true;
-						// We can almost always shorten subject IRIs, 
-						// with some known corner cases that are already embedded in the algorithm
-						// So just need to do checking for BNode subjects
-						if (nextSubject instanceof BNode) {
-							if (prettyPrintModel.contains(null, null, nextSubject)) {
-								// Cannot shorten this blank node as it is used as the object of a statement somewhere 
-								// so must be written in a non-anonymous form
-								canShortenSubjectBNode = false;
-							}
-							// Must check this for all writers, not just TriG/etc., 
-							// as Turtle writing only works right now for these statements because of the common blank node identifier
-							// The nextObjects iterator below does not take into account contexts
-							else if (prettyPrintModel.filter(nextSubject, null, null).contexts().size() > 1) {
-								// TriG section 2.3.1 specifies that we cannot shorten blank nodes shared across contexts, 
-								// and this code is shared with TriG.
-								canShortenSubjectBNode = false;
-							}
-							else if (prettyPrintModel.contains(null, null, null, nextSubject)) {
-								// Cannot anonymize if this blank node has been used as a context also
-								canShortenSubjectBNode = false;
-							}
-						}
-						for (IRI nextPredicate : prettyPrintModel.filter(nextSubject, null, null,
-								nextContext).predicates())
-						{
-							Model nextObjects = prettyPrintModel.filter(nextSubject, nextPredicate, null,
-									nextContext);
-							//if (nextObjects.size() > 1) {
-							// In this structure, cannot support shortening subject for multiple statements
-							//	canShortenSubject = false;
-							//}
-							for (Statement nextSt : nextObjects) {
-								Value nextObject = nextSt.getObject();
-								boolean canShortenObjectBNode = true;
-								if (nextObject instanceof BNode) {
-									if (prettyPrintModel.contains((BNode)nextObject, null, null)) {
-										// Cannot shorten this blank node as it is used as the subject of a statement somewhere 
-										// so must be written in a non-anonymous form
-										// NOTE: that this is only a restriction in this implementation because we write in CSPO order, 
-										// if we followed the linked chain we could be able to shorten here in some cases
-										canShortenObjectBNode = false;
-									}
-									else if (prettyPrintModel.filter(null, null, nextObject).size() > 1) {
-										// Cannot shorten BNode if any other statements reference it as an object
-										canShortenObjectBNode = false;
-									}
-									else if (prettyPrintModel.filter(null, null, null,
-											(BNode)nextObject).size() > 0)
-									{
-										// Cannot anonymize if this blank node has been used as a context also
-										canShortenObjectBNode = false;
-									}
-								}
-								handleStatementInternal(nextSt, true, canShortenSubjectBNode,
-										canShortenObjectBNode);
-							}
-						}
-					}
-				}
-			}
 			closePreviousStatement();
 			writer.flush();
 		}
@@ -301,13 +262,22 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 			throw new RuntimeException("Document writing has not yet been started");
 		}
 
-		// If we are pretty-printing, all writing is buffered until endRDF is
-		// called
-		if (prettyPrintModel != null) {
-			prettyPrintModel.add(st);
+		try {
+			Resource subj = st.getSubject();
+			IRI pred = st.getPredicate();
+			if (inlineBNodes && (pred.equals(RDF.FIRST) || pred.equals(RDF.REST))) {
+				handleList(st);
+			}
+			else if (inlineBNodes && !subj.equals(lastWrittenSubject) && stack.contains(subj)) {
+				handleInlineNode(st);
+			}
+			else {
+				closeHangingResource();
+				handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
+			}
 		}
-		else {
-			handleStatementInternal(st, false, false, false);
+		catch (IOException e) {
+			throw new RDFHandlerException(e);
 		}
 	}
 
@@ -329,14 +299,6 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 	protected void handleStatementInternal(Statement st, boolean endRDFCalled, boolean canShortenSubjectBNode,
 			boolean canShortenObjectBNode)
 	{
-
-		// Avoid accidentally writing statements early, but don't lose track of
-		// them if they are sent here
-		if (prettyPrintModel != null && !endRDFCalled) {
-			prettyPrintModel.add(st);
-			return;
-		}
-
 		Resource subj = st.getSubject();
 		IRI pred = st.getPredicate();
 		Value obj = st.getObject();
@@ -345,32 +307,42 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 			if (subj.equals(lastWrittenSubject)) {
 				if (pred.equals(lastWrittenPredicate)) {
 					// Identical subject and predicate
-					writer.write(" , ");
+					writer.write(",");
+					wrapLine(prettyPrint);
 				}
 				else {
 					// Identical subject, new predicate
-					writer.write(" ;");
+					writer.write(";");
 					writer.writeEOL();
 
 					// Write new predicate
+					writer.decreaseIndentation();
 					writePredicate(pred);
-					writer.write(" ");
+					writer.increaseIndentation();
+					wrapLine(true);
+					path.removeLast();
+					path.addLast(pred);
 					lastWrittenPredicate = pred;
 				}
 			}
 			else {
 				// New subject
 				closePreviousStatement();
+				stack.addLast(subj);
 
 				// Write new subject:
-				writer.writeEOL();
+				if (prettyPrint) {
+					writer.writeEOL();
+				}
 				writeResource(subj, canShortenSubjectBNode);
-				writer.write(" ");
+				wrapLine(true);
+				writer.increaseIndentation();
 				lastWrittenSubject = subj;
 
 				// Write new predicate
 				writePredicate(pred);
-				writer.write(" ");
+				wrapLine(true);
+				path.addLast(pred);
 				lastWrittenPredicate = pred;
 
 				statementClosed = false;
@@ -480,7 +452,12 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 	protected void writeValue(Value val, boolean canShorten)
 		throws IOException
 	{
-		if (val instanceof Resource) {
+		if (val instanceof BNode && canShorten && !val.equals(stack.peekLast())
+				&& !val.equals(lastWrittenSubject))
+		{
+			stack.addLast((BNode)val);
+		}
+		else if (val instanceof Resource) {
 			writeResource((Resource)val, canShorten);
 		}
 		else {
@@ -623,7 +600,7 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 		String label = lit.getLabel();
 		IRI datatype = lit.getDatatype();
 
-		if (getWriterConfig().get(BasicWriterSettings.PRETTY_PRINT)) {
+		if (prettyPrint) {
 			if (XMLSchema.INTEGER.equals(datatype) || XMLSchema.DECIMAL.equals(datatype)
 					|| XMLSchema.DOUBLE.equals(datatype) || XMLSchema.BOOLEAN.equals(datatype))
 			{
@@ -657,7 +634,7 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 			writer.write("@");
 			writer.write(lit.getLanguage().get());
 		}
-		else if (!XMLSchema.STRING.equals(datatype) || !xsdStringToPlainLiteral()) {
+		else if (!xsdStringToPlainLiteral || !XMLSchema.STRING.equals(datatype)) {
 			// Append the literal's datatype (possibly written as an abbreviated
 			// URI)
 			writer.write("^^");
@@ -668,19 +645,153 @@ public class TurtleWriter extends AbstractRDFWriter implements RDFWriter {
 	protected void closePreviousStatement()
 		throws IOException
 	{
+		closeNestedResources(null);
 		if (!statementClosed) {
 			// The previous statement still needs to be closed:
-			writer.write(" .");
+			writer.write(".");
 			writer.writeEOL();
 			writer.decreaseIndentation();
+			writer.decreaseIndentation();
 
+			stack.pollLast();
+			path.pollLast();
+			assert stack.isEmpty();
+			assert path.isEmpty();
 			statementClosed = true;
 			lastWrittenSubject = null;
 			lastWrittenPredicate = null;
 		}
 	}
 
-	private boolean xsdStringToPlainLiteral() {
-		return getWriterConfig().get(BasicWriterSettings.XSD_STRING_TO_PLAIN_LITERAL);
+	private boolean isHanging() {
+		return !stack.isEmpty() && lastWrittenSubject != null && !lastWrittenSubject.equals(stack.peekLast());
+	}
+
+	private void closeHangingResource()
+		throws IOException
+	{
+		if (isHanging()) {
+			Value val = stack.pollLast();
+			if (val instanceof Resource) {
+				writeResource((Resource)val, inlineBNodes);
+			}
+			else {
+				writeLiteral((Literal)val);
+			}
+			assert lastWrittenSubject.equals(stack.peekLast());
+		}
+	}
+
+	private void closeNestedResources(Resource subj)
+		throws IOException
+	{
+		closeHangingResource();
+		while (stack.size() > 1 && !stack.peekLast().equals(subj)) {
+			if (prettyPrint) {
+				writer.writeEOL();
+			}
+			writer.decreaseIndentation();
+			writer.decreaseIndentation();
+			writer.write("]");
+
+			stack.pollLast();
+			path.pollLast();
+			lastWrittenSubject = stack.peekLast();
+			lastWrittenPredicate = path.peekLast();
+		}
+	}
+
+	private void handleInlineNode(Statement st)
+		throws IOException
+	{
+		Resource subj = st.getSubject();
+		IRI pred = st.getPredicate();
+		if (isHanging() && subj.equals(stack.peekLast())) {
+			// blank subject
+			lastWrittenSubject = subj;
+			writer.write("[");
+			if (prettyPrint && !RDF.TYPE.equals(pred)) {
+				writer.writeEOL();
+			}
+			else {
+				wrapLine(prettyPrint);
+			}
+			writer.increaseIndentation();
+
+			// Write new predicate
+			writePredicate(pred);
+			writer.increaseIndentation();
+			wrapLine(true);
+			path.addLast(pred);
+			lastWrittenPredicate = pred;
+			writeValue(st.getObject(), inlineBNodes);
+		}
+		else if (!subj.equals(lastWrittenSubject) && stack.contains(subj)) {
+			closeNestedResources(subj);
+			handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
+		}
+		else {
+			assert false;
+		}
+	}
+
+	private void handleList(Statement st)
+		throws IOException
+	{
+		Resource subj = st.getSubject();
+		boolean first = RDF.FIRST.equals(st.getPredicate());
+		boolean rest = RDF.REST.equals(st.getPredicate()) && !RDF.NIL.equals(st.getObject());
+		boolean nil = RDF.REST.equals(st.getPredicate()) && RDF.NIL.equals(st.getObject());
+		if (first && REST != lastWrittenPredicate && isHanging()) {
+			// new collection
+			writer.write("(");
+			writer.increaseIndentation();
+			wrapLine(false);
+			lastWrittenSubject = subj;
+			path.addLast(FIRST);
+			lastWrittenPredicate = FIRST;
+			writeValue(st.getObject(), inlineBNodes);
+		}
+		else if (first && REST == lastWrittenPredicate) {
+			// item in existing collection
+			lastWrittenSubject = subj;
+			path.addLast(FIRST);
+			lastWrittenPredicate = FIRST;
+			writeValue(st.getObject(), inlineBNodes);
+		}
+		else {
+			closeNestedResources(subj);
+			if (rest && FIRST == lastWrittenPredicate) {
+				// next item
+				wrapLine(true);
+				path.removeLast(); // RDF.FIRST
+				path.addLast(REST);
+				lastWrittenPredicate = REST;
+				writeValue(st.getObject(), inlineBNodes);
+			}
+			else if (nil && FIRST == lastWrittenPredicate) {
+				writer.decreaseIndentation();
+				writer.write(")");
+				path.removeLast(); // RDF.FIRST
+				path.addLast(REST);
+				while (REST == path.peekLast()) {
+					stack.pollLast();
+					path.pollLast();
+					lastWrittenSubject = stack.peekLast();
+					lastWrittenPredicate = path.peekLast();
+				}
+			}
+			else {
+				handleStatementInternal(st, false, inlineBNodes, inlineBNodes);
+			}
+		}
+	}
+
+	private void wrapLine(boolean space) throws IOException {
+		if (prettyPrint && writer.getCharactersSinceEOL() > LINE_WRAP) {
+			writer.writeEOL();
+		} else if (space) {
+			writer.write(" ");
+		}
 	}
 }
diff --git a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java
index b81c342d7f..935c9a9d4c 100644
--- a/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java
+++ b/core/rio/turtle/src/main/java/org/eclipse/rdf4j/rio/turtle/TurtleWriterFactory.java
@@ -34,25 +34,25 @@ public class TurtleWriterFactory implements RDFWriterFactory {
 	 * Returns a new instance of {@link TurtleWriter}.
 	 */
 	public RDFWriter getWriter(OutputStream out) {
-		return new TurtleWriter(out);
+		return new ArrangedWriter(new TurtleWriter(out));
 	}
 
 	public RDFWriter getWriter(OutputStream out, String baseURI)
 		throws URISyntaxException
 	{
-		return new TurtleWriter(out, new ParsedIRI(baseURI));
+		return new ArrangedWriter(new TurtleWriter(out, new ParsedIRI(baseURI)));
 	}
 
 	/**
 	 * Returns a new instance of {@link TurtleWriter}.
 	 */
 	public RDFWriter getWriter(Writer writer) {
-		return new TurtleWriter(writer);
+		return new ArrangedWriter(new TurtleWriter(writer));
 	}
 
 	public RDFWriter getWriter(Writer writer, String baseURI)
 		throws URISyntaxException
 	{
-		return new TurtleWriter(writer, new ParsedIRI(baseURI));
+		return new ArrangedWriter(new TurtleWriter(writer, new ParsedIRI(baseURI)));
 	}
 }
