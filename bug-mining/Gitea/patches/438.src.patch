diff --git a/routers/web/repo/issue.go b/routers/web/repo/issue.go
index 415f34d1fb..833f59981b 100644
--- a/routers/web/repo/issue.go
+++ b/routers/web/repo/issue.go
@@ -637,8 +637,12 @@ func attachmentsHTML(ctx *context.Context, attachments []*repo_model.Attachment,
 	return attachHTML
 }
 
-// get all teams that current user can mention
-func handleTeamMentions(ctx *context.Context) {
+// handleMentionableAssigneesAndTeams gets all teams that current user can mention, and fills the assignee users to the context data
+func handleMentionableAssigneesAndTeams(ctx *context.Context, assignees []*user_model.User) {
+	// TODO: need to figure out how many places this is really used, and rename it to "MentionableAssignees"
+	// at the moment it is used on the issue list page, for the markdown editor mention
+	ctx.Data["Assignees"] = assignees
+
 	if ctx.Doer == nil || !ctx.Repo.Owner.IsOrganization() {
 		return
 	}
diff --git a/routers/web/repo/issue_list.go b/routers/web/repo/issue_list.go
index ee2fc080f5..50bb668433 100644
--- a/routers/web/repo/issue_list.go
+++ b/routers/web/repo/issue_list.go
@@ -715,9 +715,7 @@ func issues(ctx *context.Context, milestoneID, projectID int64, isPullOption opt
 		ctx.ServerError("GetRepoAssignees", err)
 		return
 	}
-	ctx.Data["Assignees"] = shared_user.MakeSelfOnTop(ctx.Doer, assigneeUsers)
-
-	handleTeamMentions(ctx)
+	handleMentionableAssigneesAndTeams(ctx, shared_user.MakeSelfOnTop(ctx.Doer, assigneeUsers))
 	if ctx.Written() {
 		return
 	}
diff --git a/routers/web/repo/issue_page_meta.go b/routers/web/repo/issue_page_meta.go
index e04d76b287..7eda6e3c73 100644
--- a/routers/web/repo/issue_page_meta.go
+++ b/routers/web/repo/issue_page_meta.go
@@ -148,7 +148,7 @@ func (d *IssuePageMetaData) retrieveAssigneesDataForIssueWriter(ctx *context.Con
 		d.AssigneesData.SelectedAssigneeIDs = strings.Join(ids, ",")
 	}
 	// FIXME: this is a tricky part which writes ctx.Data["Mentionable*"]
-	handleTeamMentions(ctx)
+	handleMentionableAssigneesAndTeams(ctx, d.AssigneesData.CandidateAssignees)
 }
 
 func (d *IssuePageMetaData) retrieveProjectsDataForIssueWriter(ctx *context.Context) {
diff --git a/routers/web/repo/pull.go b/routers/web/repo/pull.go
index e3b329d01d..0325585e53 100644
--- a/routers/web/repo/pull.go
+++ b/routers/web/repo/pull.go
@@ -840,9 +840,7 @@ func viewPullFiles(ctx *context.Context, specifiedStartCommit, specifiedEndCommi
 		ctx.ServerError("GetRepoAssignees", err)
 		return
 	}
-	ctx.Data["Assignees"] = shared_user.MakeSelfOnTop(ctx.Doer, assigneeUsers)
-
-	handleTeamMentions(ctx)
+	handleMentionableAssigneesAndTeams(ctx, shared_user.MakeSelfOnTop(ctx.Doer, assigneeUsers))
 	if ctx.Written() {
 		return
 	}
diff --git a/routers/web/shared/user/helper.go b/routers/web/shared/user/helper.go
index 6186b9b9ff..dfd65420c1 100644
--- a/routers/web/shared/user/helper.go
+++ b/routers/web/shared/user/helper.go
@@ -4,19 +4,23 @@
 package user
 
 import (
-	"sort"
+	"slices"
 
 	"code.gitea.io/gitea/models/user"
 )
 
 func MakeSelfOnTop(doer *user.User, users []*user.User) []*user.User {
 	if doer != nil {
-		sort.Slice(users, func(i, j int) bool {
-			if users[i].ID == users[j].ID {
-				return false
-			}
-			return users[i].ID == doer.ID // if users[i] is self, put it before others, so less=true
+		idx := slices.IndexFunc(users, func(u *user.User) bool {
+			return u.ID == doer.ID
 		})
+		if idx > 0 {
+			newUsers := make([]*user.User, len(users))
+			newUsers[0] = users[idx]
+			copy(newUsers[1:], users[:idx])
+			copy(newUsers[idx+1:], users[idx+1:])
+			return newUsers
+		}
 	}
 	return users
 }
