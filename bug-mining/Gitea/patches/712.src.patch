diff --git a/cmd/serv.go b/cmd/serv.go
index 72ca7c4a00..4110fda0d5 100644
--- a/cmd/serv.go
+++ b/cmd/serv.go
@@ -18,7 +18,7 @@ import (
 	asymkey_model "code.gitea.io/gitea/models/asymkey"
 	git_model "code.gitea.io/gitea/models/git"
 	"code.gitea.io/gitea/models/perm"
-	"code.gitea.io/gitea/models/repo"
+	repo_model "code.gitea.io/gitea/models/repo"
 	"code.gitea.io/gitea/modules/git"
 	"code.gitea.io/gitea/modules/git/gitcmd"
 	"code.gitea.io/gitea/modules/json"
@@ -207,7 +207,7 @@ func runServ(ctx context.Context, c *cli.Command) error {
 	username := repoPathFields[0]
 	reponame := strings.TrimSuffix(repoPathFields[1], ".git") // â€œthe-repo-name" or "the-repo-name.wiki"
 
-	if !repo.IsValidSSHAccessRepoName(reponame) {
+	if !repo_model.IsValidSSHAccessRepoName(reponame) {
 		return fail(ctx, "Invalid repo name", "Invalid repo name: %s", reponame)
 	}
 
@@ -253,10 +253,12 @@ func runServ(ctx context.Context, c *cli.Command) error {
 		return fail(ctx, extra.UserMsg, "ServCommand failed: %s", extra.Error)
 	}
 
-	// LowerCase and trim the repoPath as that's how they are stored.
-	// This should be done after splitting the repoPath into username and reponame
-	// so that username and reponame are not affected.
-	repoPath = strings.ToLower(results.OwnerName + "/" + results.RepoName + ".git")
+	// because the original repoPath maybe redirected, we need to use the returned actual repository information
+	if results.IsWiki {
+		repoPath = repo_model.RelativeWikiPath(results.OwnerName, results.RepoName)
+	} else {
+		repoPath = repo_model.RelativePath(results.OwnerName, results.RepoName)
+	}
 
 	// LFS SSH protocol
 	if verb == git.CmdVerbLfsTransfer {
diff --git a/tests/integration/wiki_test.go b/tests/integration/wiki_test.go
index c31f73eabf..5718156ffa 100644
--- a/tests/integration/wiki_test.go
+++ b/tests/integration/wiki_test.go
@@ -11,7 +11,9 @@ import (
 	"strings"
 	"testing"
 
+	auth_model "code.gitea.io/gitea/models/auth"
 	"code.gitea.io/gitea/modules/git"
+	api "code.gitea.io/gitea/modules/structs"
 	"code.gitea.io/gitea/modules/util"
 	"code.gitea.io/gitea/tests"
 
@@ -71,3 +73,46 @@ func Test_RepoWikiPages(t *testing.T) {
 		assert.Equal(t, expectedPagePaths[i], pagePath)
 	})
 }
+
+func Test_WikiClone(t *testing.T) {
+	onGiteaRun(t, func(t *testing.T, u *url.URL) {
+		username := "user2"
+		reponame := "repo1"
+		wikiPath := username + "/" + reponame + ".wiki.git"
+		keyname := "my-testing-key"
+		baseAPITestContext := NewAPITestContext(t, username, "repo1", auth_model.AccessTokenScopeWriteRepository, auth_model.AccessTokenScopeWriteUser)
+
+		u.Path = wikiPath
+
+		t.Run("Clone HTTP", func(t *testing.T) {
+			defer tests.PrintCurrentTest(t)()
+
+			dstLocalPath := t.TempDir()
+			assert.NoError(t, git.Clone(t.Context(), u.String(), dstLocalPath, git.CloneRepoOptions{}))
+			content, err := os.ReadFile(filepath.Join(dstLocalPath, "Home.md"))
+			assert.NoError(t, err)
+			assert.Equal(t, "# Home page\n\nThis is the home page!\n", string(content))
+		})
+
+		t.Run("Clone SSH", func(t *testing.T) {
+			defer tests.PrintCurrentTest(t)()
+
+			dstLocalPath := t.TempDir()
+			sshURL := createSSHUrl(wikiPath, u)
+
+			withKeyFile(t, keyname, func(keyFile string) {
+				var keyID int64
+				t.Run("CreateUserKey", doAPICreateUserKey(baseAPITestContext, "test-key", keyFile, func(t *testing.T, key api.PublicKey) {
+					keyID = key.ID
+				}))
+				assert.NotZero(t, keyID)
+
+				// Setup clone folder
+				assert.NoError(t, git.Clone(t.Context(), sshURL.String(), dstLocalPath, git.CloneRepoOptions{}))
+				content, err := os.ReadFile(filepath.Join(dstLocalPath, "Home.md"))
+				assert.NoError(t, err)
+				assert.Equal(t, "# Home page\n\nThis is the home page!\n", string(content))
+			})
+		})
+	})
+}
