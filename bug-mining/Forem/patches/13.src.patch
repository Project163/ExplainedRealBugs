diff --git a/app/models/reaction.rb b/app/models/reaction.rb
index d4c15f92f..83d8744a0 100644
--- a/app/models/reaction.rb
+++ b/app/models/reaction.rb
@@ -26,6 +26,10 @@ class Reaction < ApplicationRecord
   counter_culture :user
 
   scope :public_category, -> { where(category: PUBLIC_CATEGORIES) }
+
+  # Be wary, this is all things on the reading list, but for an end
+  # user they might only see readinglist items that are published.
+  # See https://github.com/forem/forem/issues/14796
   scope :readinglist, -> { where(category: "readinglist") }
   scope :for_articles, ->(ids) { where(reactable_type: "Article", reactable_id: ids) }
   scope :eager_load_serialized_data, -> { includes(:reactable, :user) }
diff --git a/app/services/search/reading_list.rb b/app/services/search/reading_list.rb
index ad2005672..a859ccb56 100644
--- a/app/services/search/reading_list.rb
+++ b/app/services/search/reading_list.rb
@@ -19,6 +19,17 @@ class ReadingList
     DEFAULT_PER_PAGE = 60
     MAX_PER_PAGE = 100 # to avoid querying too many items, we set a maximum amount for a page
 
+    # Search for the given user's reading list.
+    #
+    # @param user [User] whose reading list are we searching?
+    # @param term [String] search term for the articles
+    # @param statuses [Array<String>] what reading list status(es) to filter our search
+    # @param tags [Array<String>] a list of tags to filter our search
+    # @param page [Integer] the page in the pagination
+    # @param per_page [Integer] how many items do we return in our pagination result set
+    #
+    # @return [Hash<Symbol,Object>] with keys :items and :total.
+    #         :total is an Integer and :items is an Array of serialized data.
     def self.search_documents(user, term: nil, statuses: [], tags: [], page: 0, per_page: DEFAULT_PER_PAGE)
       return {} unless user
 
@@ -58,7 +69,7 @@ def self.search_documents(user, term: nil, statuses: [], tags: [], page: 0, per_
       }
     end
 
-    def self.find_articles(user:, term:, statuses:, tags:, page:, per_page:)
+    def self.find_articles(user:, term:, statuses:, tags:, page:, per_page:, only_published: true)
       # [@jgaskins, @rhymes] as `reactions` is potentially a big table, adding pagination
       # to an INNER JOIN (eg. `joins(:reactions)`) exponentially decreases the performance,
       # incrementing query time as the database has to scan all the rows just to discard
@@ -75,6 +86,8 @@ def self.find_articles(user:, term:, statuses:, tags:, page:, per_page:)
         "INNER JOIN (#{reaction_query_sql}) reactions ON reactions.reactable_id = articles.id",
       )
 
+      relation = relation.published if only_published
+
       relation = relation.search_articles(term) if term.present?
 
       relation = relation.cached_tagged_with(tags) if tags.any?
diff --git a/spec/services/search/reading_list_spec.rb b/spec/services/search/reading_list_spec.rb
index b2360c8fa..a00a815d6 100644
--- a/spec/services/search/reading_list_spec.rb
+++ b/spec/services/search/reading_list_spec.rb
@@ -6,11 +6,20 @@
   let(:article_not_in_reading_list) { create(:article) }
   let(:article_1) { create(:article, with_tags: false) }
   let(:article_2) { create(:article, with_tags: false) }
+  let(:unpublished_article) { create(:article) }
 
   def extract_from_results(result, attribute)
     result[:items].pluck(:reactable).pluck(attribute)
   end
 
+  def count_of_published_readling_items_for(user:)
+    Article.published.where(id: user.reactions.readinglist.map(&:reactable_id)).count
+  end
+
+  def published_reading_list_item_for(user:)
+    user.reactions.readinglist.detect { |item| item.reactable.published? }
+  end
+
   describe "::search_documents" do
     before do
       create(:reaction, user: user, reactable: article, category: :readinglist, status: :valid)
@@ -47,7 +56,19 @@ def extract_from_results(result, attribute)
       articles.each { |article| create(:reaction, category: :readinglist, reactable: article, user: user) }
 
       result = described_class.search_documents(user)
-      expect(result[:total]).to eq(user.reactions.readinglist.count)
+      expect(result[:total]).to eq(count_of_published_readling_items_for(user: user))
+    end
+
+    context "with an article added to a reading list then unpublished" do
+      before do
+        create(:reaction, user: user, reactable: unpublished_article, category: :readinglist, status: :valid)
+        unpublished_article.update_columns(published: false)
+      end
+
+      it "does not include the unpublished article" do
+        result = described_class.search_documents(user)
+        expect(extract_from_results(result, :path)).not_to include(unpublished_article.path)
+      end
     end
 
     context "when describing the result format" do
@@ -63,7 +84,11 @@ def extract_from_results(result, attribute)
         item = result[:items].first
 
         expect(item.keys).to match_array(%i[id user_id reactable])
-        expect(item[:id]).to eq(user.reactions.readinglist.first.id)
+
+        # The user's reading includes published and unpublished
+        # articles.  We want to make sure that what we found in the
+        # search is on the user's reading list.
+        expect(user.reactions.readinglist.map(&:id)).to include(item[:id])
         expect(item[:user_id]).to eq(user.id)
       end
 
@@ -100,14 +125,14 @@ def extract_from_results(result, attribute)
 
     context "when filtering by statuses" do
       it "returns confirmed items by default" do
-        item = user.reactions.readinglist.last
+        item = published_reading_list_item_for(user: user)
         item.update_columns(status: :confirmed)
 
         expect(described_class.search_documents(user)[:items].first[:id]).to eq(item.id)
       end
 
       it "returns valid items by default" do
-        item = user.reactions.readinglist.last
+        item = published_reading_list_item_for(user: user)
         item.update_columns(status: :valid)
 
         expect(described_class.search_documents(user)[:items].first[:id]).to eq(item.id)
@@ -317,7 +342,7 @@ def extract_from_results(result, attribute)
 
       it "returns the total count of the articles pre-pagination" do
         result = described_class.search_documents(user, page: 1, per_page: 1)
-        expect(result[:total]).to eq(user.reactions.readinglist.count)
+        expect(result[:total]).to eq(count_of_published_readling_items_for(user: user))
       end
 
       it "returns no items when out of pagination bounds" do
