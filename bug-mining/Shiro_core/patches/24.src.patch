diff --git a/core/src/main/java/org/apache/shiro/UnavailableSecurityManagerException.java b/core/src/main/java/org/apache/shiro/UnavailableSecurityManagerException.java
index 15efa77a1..b6b15f22c 100644
--- a/core/src/main/java/org/apache/shiro/UnavailableSecurityManagerException.java
+++ b/core/src/main/java/org/apache/shiro/UnavailableSecurityManagerException.java
@@ -1,36 +1,36 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro;
-
-/**
- * Exception thrown when attempting to acquire the application's {@code SecurityManager} instance, but Shiro's
- * lookup heuristics cannot find one.  This typically indicates an invalid application configuration.
- *
- * @since 1.0
- */
-public class UnavailableSecurityManagerException extends ShiroException {
-
-    public UnavailableSecurityManagerException(String message) {
-        super(message);
-    }
-
-    public UnavailableSecurityManagerException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro;
+
+/**
+ * Exception thrown when attempting to acquire the application's {@code SecurityManager} instance, but Shiro's
+ * lookup heuristics cannot find one.  This typically indicates an invalid application configuration.
+ *
+ * @since 1.0
+ */
+public class UnavailableSecurityManagerException extends ShiroException {
+
+    public UnavailableSecurityManagerException(String message) {
+        super(message);
+    }
+
+    public UnavailableSecurityManagerException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/aop/package-info.java b/core/src/main/java/org/apache/shiro/aop/package-info.java
index bba25dd32..34c94b91a 100644
--- a/core/src/main/java/org/apache/shiro/aop/package-info.java
+++ b/core/src/main/java/org/apache/shiro/aop/package-info.java
@@ -1,26 +1,26 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-/**
- * Components used to support the framework's AOP/interception support classes.
- * <p/>
- * As this package is a root-level package under <tt>org.apache.shiro</tt>, it contains AOP support classes
- * useful for any AOP environment and/or function. Feature-dependent AOP classes (e.g. authorization,
- * authentication, etc) will use these classes as their base in their respective packages.
- */
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Components used to support the framework's AOP/interception support classes.
+ * <p/>
+ * As this package is a root-level package under <tt>org.apache.shiro</tt>, it contains AOP support classes
+ * useful for any AOP environment and/or function. Feature-dependent AOP classes (e.g. authorization,
+ * authentication, etc) will use these classes as their base in their respective packages.
+ */
 package org.apache.shiro.aop;
\ No newline at end of file
diff --git a/core/src/main/java/org/apache/shiro/authc/AuthenticationListener.java b/core/src/main/java/org/apache/shiro/authc/AuthenticationListener.java
index 11ac7b3b7..916351837 100644
--- a/core/src/main/java/org/apache/shiro/authc/AuthenticationListener.java
+++ b/core/src/main/java/org/apache/shiro/authc/AuthenticationListener.java
@@ -1,56 +1,56 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc;
-
-import org.apache.shiro.subject.PrincipalCollection;
-
-/**
- * An {@code AuthenticationListener} listens for notifications while {@code Subject}s authenticate with the system.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public interface AuthenticationListener {
-
-    /**
-     * Callback triggered when an authentication attempt for a {@code Subject} has succeeded.
-     *
-     * @param token the authentication token submitted during the {@code Subject} (user)'s authentication attempt.
-     * @param info  the authentication-related account data acquired after authentication for the corresponding {@code Subject}.
-     */
-    void onSuccess(AuthenticationToken token, AuthenticationInfo info);
-
-    /**
-     * Callback triggered when an authentication attempt for a {@code Subject} has failed.
-     *
-     * @param token the authentication token submitted during the {@code Subject} (user)'s authentication attempt.
-     * @param ae    the {@code AuthenticationException} that occurred as a result of the attempt.
-     */
-    void onFailure(AuthenticationToken token, AuthenticationException ae);
-
-    /**
-     * Callback triggered when a {@code Subject} logs-out of the system.
-     * <p/>
-     * This method will only be triggered when a Subject explicitly logs-out of the session.  It will not
-     * be triggered if their Session times out.
-     *
-     * @param principals the identifying principals of the Subject logging out.
-     */
-    void onLogout(PrincipalCollection principals);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc;
+
+import org.apache.shiro.subject.PrincipalCollection;
+
+/**
+ * An {@code AuthenticationListener} listens for notifications while {@code Subject}s authenticate with the system.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public interface AuthenticationListener {
+
+    /**
+     * Callback triggered when an authentication attempt for a {@code Subject} has succeeded.
+     *
+     * @param token the authentication token submitted during the {@code Subject} (user)'s authentication attempt.
+     * @param info  the authentication-related account data acquired after authentication for the corresponding {@code Subject}.
+     */
+    void onSuccess(AuthenticationToken token, AuthenticationInfo info);
+
+    /**
+     * Callback triggered when an authentication attempt for a {@code Subject} has failed.
+     *
+     * @param token the authentication token submitted during the {@code Subject} (user)'s authentication attempt.
+     * @param ae    the {@code AuthenticationException} that occurred as a result of the attempt.
+     */
+    void onFailure(AuthenticationToken token, AuthenticationException ae);
+
+    /**
+     * Callback triggered when a {@code Subject} logs-out of the system.
+     * <p/>
+     * This method will only be triggered when a Subject explicitly logs-out of the session.  It will not
+     * be triggered if their Session times out.
+     *
+     * @param principals the identifying principals of the Subject logging out.
+     */
+    void onLogout(PrincipalCollection principals);
+}
diff --git a/core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java b/core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java
index 4de756527..8b37dcf87 100644
--- a/core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java
+++ b/core/src/main/java/org/apache/shiro/authc/HostAuthenticationToken.java
@@ -1,45 +1,45 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc;
-
-/**
- * A {@code HostAuthenticationToken} retains the host information from where
- * an authentication attempt originates.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public interface HostAuthenticationToken {
-
-    /**
-     * Returns the host name of the client from where the
-     * authentication attempt originates or if the Shiro environment cannot or
-     * chooses not to resolve the hostname to improve performance, this method
-     * returns the String representation of the client's IP address.
-     * <p/>
-     * When used in web environments, this value is usually the same as the
-     * {@code ServletRequest.getRemoteHost()} value.
-     *
-     * @return the fully qualified name of the client from where the
-     *         authentication attempt originates or the String representation
-     *         of the client's IP address is hostname resolution is not
-     *         available or disabled.
-     */
-    String getHost();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc;
+
+/**
+ * A {@code HostAuthenticationToken} retains the host information from where
+ * an authentication attempt originates.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public interface HostAuthenticationToken {
+
+    /**
+     * Returns the host name of the client from where the
+     * authentication attempt originates or if the Shiro environment cannot or
+     * chooses not to resolve the hostname to improve performance, this method
+     * returns the String representation of the client's IP address.
+     * <p/>
+     * When used in web environments, this value is usually the same as the
+     * {@code ServletRequest.getRemoteHost()} value.
+     *
+     * @return the fully qualified name of the client from where the
+     *         authentication attempt originates or the String representation
+     *         of the client's IP address is hostname resolution is not
+     *         available or disabled.
+     */
+    String getHost();
+}
diff --git a/core/src/main/java/org/apache/shiro/authc/credential/AllowAllCredentialsMatcher.java b/core/src/main/java/org/apache/shiro/authc/credential/AllowAllCredentialsMatcher.java
index 25f106b33..34196bba8 100644
--- a/core/src/main/java/org/apache/shiro/authc/credential/AllowAllCredentialsMatcher.java
+++ b/core/src/main/java/org/apache/shiro/authc/credential/AllowAllCredentialsMatcher.java
@@ -1,45 +1,45 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc.credential;
-
-import org.apache.shiro.authc.AuthenticationInfo;
-import org.apache.shiro.authc.AuthenticationToken;
-
-/**
- * A credentials matcher that always returns <tt>true</tt> when matching credentials no matter what arguments
- * are passed in.  This can be used for testing or when credentials are implicitly trusted for a particular
- * {@link org.apache.shiro.realm.Realm Realm}.
- *
- * @author Jeremy Haile
- * @author Les Hazlewood
- * @since 0.2
- */
-public class AllowAllCredentialsMatcher implements CredentialsMatcher {
-
-    /**
-     * Returns <code>true</code> <em>always</em> no matter what the method arguments are.
-     *
-     * @param token   the token submitted for authentication.
-     * @param info    the account being verified for access
-     * @return <code>true</code> <em>always</em>.
-     */
-    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
-        return true;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc.credential;
+
+import org.apache.shiro.authc.AuthenticationInfo;
+import org.apache.shiro.authc.AuthenticationToken;
+
+/**
+ * A credentials matcher that always returns <tt>true</tt> when matching credentials no matter what arguments
+ * are passed in.  This can be used for testing or when credentials are implicitly trusted for a particular
+ * {@link org.apache.shiro.realm.Realm Realm}.
+ *
+ * @author Jeremy Haile
+ * @author Les Hazlewood
+ * @since 0.2
+ */
+public class AllowAllCredentialsMatcher implements CredentialsMatcher {
+
+    /**
+     * Returns <code>true</code> <em>always</em> no matter what the method arguments are.
+     *
+     * @param token   the token submitted for authentication.
+     * @param info    the account being verified for access
+     * @return <code>true</code> <em>always</em>.
+     */
+    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {
+        return true;
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/authc/pam/AbstractAuthenticationStrategy.java b/core/src/main/java/org/apache/shiro/authc/pam/AbstractAuthenticationStrategy.java
index 6ee0eb8d7..c8e395afa 100644
--- a/core/src/main/java/org/apache/shiro/authc/pam/AbstractAuthenticationStrategy.java
+++ b/core/src/main/java/org/apache/shiro/authc/pam/AbstractAuthenticationStrategy.java
@@ -1,98 +1,98 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc.pam;
-
-import org.apache.shiro.authc.*;
-import org.apache.shiro.realm.Realm;
-
-import java.util.Collection;
-
-
-/**
- * Abstract base implementation for Shiro's concrete <code>AuthenticationStrategy</code>
- * implementations.
- *
- * @author Jeremy Haile
- * @author Les Hazlewood
- * @since 0.9
- */
-public abstract class AbstractAuthenticationStrategy implements AuthenticationStrategy {
-
-    /**
-     * Simply returns <code>new {@link org.apache.shiro.authc.SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports
-     * aggregating account data across realms.
-     */
-    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {
-        return new SimpleAuthenticationInfo();
-    }
-
-    /**
-     * Simply returns the <code>aggregate</code> method argument, without modification.
-     */
-    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
-        return aggregate;
-    }
-
-    /**
-     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the
-     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.
-     */
-    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {
-        AuthenticationInfo info;
-        if (singleRealmInfo == null) {
-            info = aggregateInfo;
-        } else {
-            if (aggregateInfo == null) {
-                info = singleRealmInfo;
-            } else {
-                info = merge(singleRealmInfo, aggregateInfo);
-            }
-        }
-
-        return info;
-    }
-
-    /**
-     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an
-     * aggregate for continued use throughout the login process.
-     * <p/>
-     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of
-     * {@link org.apache.shiro.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls
-     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of
-     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.
-     * Can be overridden by subclasses for custom merging behavior if implementing the
-     * {@link org.apache.shiro.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.
-     */
-    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
-        if( aggregate instanceof MergableAuthenticationInfo ) {
-            ((MergableAuthenticationInfo)aggregate).merge(info);
-            return aggregate;
-        } else {
-            throw new IllegalArgumentException( "Attempt to merge authentication info from multiple realms, but aggregate " +
-                      "AuthenticationInfo is not of type MergableAuthenticationInfo." );
-        }
-    }
-
-    /**
-     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.
-     */
-    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
-        return aggregate;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc.pam;
+
+import org.apache.shiro.authc.*;
+import org.apache.shiro.realm.Realm;
+
+import java.util.Collection;
+
+
+/**
+ * Abstract base implementation for Shiro's concrete <code>AuthenticationStrategy</code>
+ * implementations.
+ *
+ * @author Jeremy Haile
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public abstract class AbstractAuthenticationStrategy implements AuthenticationStrategy {
+
+    /**
+     * Simply returns <code>new {@link org.apache.shiro.authc.SimpleAuthenticationInfo SimpleAuthenticationInfo}();</code>, which supports
+     * aggregating account data across realms.
+     */
+    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {
+        return new SimpleAuthenticationInfo();
+    }
+
+    /**
+     * Simply returns the <code>aggregate</code> method argument, without modification.
+     */
+    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
+        return aggregate;
+    }
+
+    /**
+     * Base implementation that will aggregate the specified <code>singleRealmInfo</code> into the
+     * <code>aggregateInfo</code> and then returns the aggregate.  Can be overridden by subclasses for custom behavior.
+     */
+    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException {
+        AuthenticationInfo info;
+        if (singleRealmInfo == null) {
+            info = aggregateInfo;
+        } else {
+            if (aggregateInfo == null) {
+                info = singleRealmInfo;
+            } else {
+                info = merge(singleRealmInfo, aggregateInfo);
+            }
+        }
+
+        return info;
+    }
+
+    /**
+     * Merges the specified <code>info</code> argument into the <code>aggregate</code> argument and then returns an
+     * aggregate for continued use throughout the login process.
+     * <p/>
+     * This implementation merely checks to see if the specified <code>aggregate</code> argument is an instance of
+     * {@link org.apache.shiro.authc.MergableAuthenticationInfo MergableAuthenticationInfo}, and if so, calls
+     * <code>aggregate.merge(info)</code>  If it is <em>not</em> an instance of
+     * <code>MergableAuthenticationInfo</code>, an {@link IllegalArgumentException IllegalArgumentException} is thrown.
+     * Can be overridden by subclasses for custom merging behavior if implementing the
+     * {@link org.apache.shiro.authc.MergableAuthenticationInfo MergableAuthenticationInfo} is not desired for some reason.
+     */
+    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
+        if( aggregate instanceof MergableAuthenticationInfo ) {
+            ((MergableAuthenticationInfo)aggregate).merge(info);
+            return aggregate;
+        } else {
+            throw new IllegalArgumentException( "Attempt to merge authentication info from multiple realms, but aggregate " +
+                      "AuthenticationInfo is not of type MergableAuthenticationInfo." );
+        }
+    }
+
+    /**
+     * Simply returns the <code>aggregate</code> argument without modification.  Can be overridden for custom behavior.
+     */
+    public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException {
+        return aggregate;
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java b/core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
index cceb9f5a9..f4ce3d200 100644
--- a/core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
+++ b/core/src/main/java/org/apache/shiro/authc/pam/FirstSuccessfulStrategy.java
@@ -1,62 +1,62 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc.pam;
-
-import org.apache.shiro.authc.AuthenticationException;
-import org.apache.shiro.authc.AuthenticationInfo;
-import org.apache.shiro.authc.AuthenticationToken;
-import org.apache.shiro.realm.Realm;
-import org.apache.shiro.util.CollectionUtils;
-
-import java.util.Collection;
-
-/**
- * {@link AuthenticationStrategy} implementation that only accepts the account data from
- * the first successfully consulted Realm and ignores all subsequent realms.  This is slightly
- * different behavior than {@link AtLeastOneSuccessfulStrategy}, so please review both to see
- * which one meets your needs better.
- *
- * @author Les Hazlewood
- * @see AtLeastOneSuccessfulStrategy AtLeastOneSuccessfulAuthenticationStrategy
- * @since 0.9
- */
-public class FirstSuccessfulStrategy extends AbstractAuthenticationStrategy {
-
-    /**
-     * Returns {@code null} immediately, relying on this class's {@link #merge merge} implementation to return
-     * only the first {@code info} object it encounters, ignoring all subsequent ones.
-     */
-    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {
-        return null;
-    }
-
-    /**
-     * Returns the specified {@code aggregate} instance if is non null and valid (that is, has principals and they are
-     * not empty) immediately, or, if it is null or not valid, the {@code info} argument is returned instead.
-     * <p/>
-     * This logic ensures that the first valid info encountered is the one retained and all subsequent ones are ignored,
-     * since this strategy mandates that only the info from the first successfully authenticated realm be used.
-     */
-    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
-        if (aggregate != null && !CollectionUtils.isEmpty(aggregate.getPrincipals())) {
-            return aggregate;
-        }
-        return info != null ? info : aggregate;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc.pam;
+
+import org.apache.shiro.authc.AuthenticationException;
+import org.apache.shiro.authc.AuthenticationInfo;
+import org.apache.shiro.authc.AuthenticationToken;
+import org.apache.shiro.realm.Realm;
+import org.apache.shiro.util.CollectionUtils;
+
+import java.util.Collection;
+
+/**
+ * {@link AuthenticationStrategy} implementation that only accepts the account data from
+ * the first successfully consulted Realm and ignores all subsequent realms.  This is slightly
+ * different behavior than {@link AtLeastOneSuccessfulStrategy}, so please review both to see
+ * which one meets your needs better.
+ *
+ * @author Les Hazlewood
+ * @see AtLeastOneSuccessfulStrategy AtLeastOneSuccessfulAuthenticationStrategy
+ * @since 0.9
+ */
+public class FirstSuccessfulStrategy extends AbstractAuthenticationStrategy {
+
+    /**
+     * Returns {@code null} immediately, relying on this class's {@link #merge merge} implementation to return
+     * only the first {@code info} object it encounters, ignoring all subsequent ones.
+     */
+    public AuthenticationInfo beforeAllAttempts(Collection<? extends Realm> realms, AuthenticationToken token) throws AuthenticationException {
+        return null;
+    }
+
+    /**
+     * Returns the specified {@code aggregate} instance if is non null and valid (that is, has principals and they are
+     * not empty) immediately, or, if it is null or not valid, the {@code info} argument is returned instead.
+     * <p/>
+     * This logic ensures that the first valid info encountered is the one retained and all subsequent ones are ignored,
+     * since this strategy mandates that only the info from the first successfully authenticated realm be used.
+     */
+    protected AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) {
+        if (aggregate != null && !CollectionUtils.isEmpty(aggregate.getPrincipals())) {
+            return aggregate;
+        }
+        return info != null ? info : aggregate;
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java b/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
index 090ddf0df..8b1a3c462 100644
--- a/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
+++ b/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
@@ -1,105 +1,105 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authz.permission;
-
-import org.apache.shiro.util.StringUtils;
-
-/**
- * Provides a base Permission class from which type-safe/domain-specific subclasses may extend.  Can be used
- * as a base class for JPA/Hibernate persisted permissions that wish to store the parts of the permission string
- * in separate columns (e.g. 'domain', 'actions' and 'targets' columns), which can be used in querying
- * strategies.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public abstract class DomainPermission extends WildcardPermission {
-
-    private String domain;
-    private String actions;
-    private String targets;
-
-    /**
-     * Creates a domain permission with *all* actions for *all* targets;
-     */
-    public DomainPermission() {
-        setParts(getDomain(getClass()), null, null);
-    }
-
-    public DomainPermission(String actions) {
-        setParts(getDomain(getClass()), actions, null);
-    }
-
-    public DomainPermission(String actions, String targets) {
-        setParts(getDomain(getClass()), actions, targets);
-    }
-
-    protected void setParts(String domain, String actions, String targets) {
-        if (!StringUtils.hasText(domain)) {
-            throw new IllegalArgumentException("domain argument cannot be null or empty.");
-        }
-        StringBuilder sb = new StringBuilder(domain);
-
-        if (!StringUtils.hasText(actions)) {
-            if (StringUtils.hasText(targets)) {
-                sb.append(PART_DIVIDER_TOKEN).append(WILDCARD_TOKEN);
-            }
-        } else {
-            sb.append(PART_DIVIDER_TOKEN).append(actions);
-        }
-        if (targets != null) {
-            sb.append(PART_DIVIDER_TOKEN).append(targets);
-        }
-        setParts(sb.toString());
-    }
-
-    protected String getDomain(Class<? extends DomainPermission> clazz) {
-        String domain = clazz.getSimpleName().toLowerCase();
-        //strip any trailing 'permission' text from the name (as all subclasses should have been named):
-        int index = domain.lastIndexOf("permission");
-        if (index != -1) {
-            domain = domain.substring(0, index);
-        }
-        return domain;
-    }
-
-    public String getDomain() {
-        return domain;
-    }
-
-    protected void setDomain(String domain) {
-        this.domain = domain;
-    }
-
-    public String getActions() {
-        return actions;
-    }
-
-    protected void setActions(String actions) {
-        this.actions = actions;
-    }
-
-    public String getTargets() {
-        return targets;
-    }
-
-    protected void setTargets(String targets) {
-        this.targets = targets;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authz.permission;
+
+import org.apache.shiro.util.StringUtils;
+
+/**
+ * Provides a base Permission class from which type-safe/domain-specific subclasses may extend.  Can be used
+ * as a base class for JPA/Hibernate persisted permissions that wish to store the parts of the permission string
+ * in separate columns (e.g. 'domain', 'actions' and 'targets' columns), which can be used in querying
+ * strategies.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public abstract class DomainPermission extends WildcardPermission {
+
+    private String domain;
+    private String actions;
+    private String targets;
+
+    /**
+     * Creates a domain permission with *all* actions for *all* targets;
+     */
+    public DomainPermission() {
+        setParts(getDomain(getClass()), null, null);
+    }
+
+    public DomainPermission(String actions) {
+        setParts(getDomain(getClass()), actions, null);
+    }
+
+    public DomainPermission(String actions, String targets) {
+        setParts(getDomain(getClass()), actions, targets);
+    }
+
+    protected void setParts(String domain, String actions, String targets) {
+        if (!StringUtils.hasText(domain)) {
+            throw new IllegalArgumentException("domain argument cannot be null or empty.");
+        }
+        StringBuilder sb = new StringBuilder(domain);
+
+        if (!StringUtils.hasText(actions)) {
+            if (StringUtils.hasText(targets)) {
+                sb.append(PART_DIVIDER_TOKEN).append(WILDCARD_TOKEN);
+            }
+        } else {
+            sb.append(PART_DIVIDER_TOKEN).append(actions);
+        }
+        if (targets != null) {
+            sb.append(PART_DIVIDER_TOKEN).append(targets);
+        }
+        setParts(sb.toString());
+    }
+
+    protected String getDomain(Class<? extends DomainPermission> clazz) {
+        String domain = clazz.getSimpleName().toLowerCase();
+        //strip any trailing 'permission' text from the name (as all subclasses should have been named):
+        int index = domain.lastIndexOf("permission");
+        if (index != -1) {
+            domain = domain.substring(0, index);
+        }
+        return domain;
+    }
+
+    public String getDomain() {
+        return domain;
+    }
+
+    protected void setDomain(String domain) {
+        this.domain = domain;
+    }
+
+    public String getActions() {
+        return actions;
+    }
+
+    protected void setActions(String actions) {
+        this.actions = actions;
+    }
+
+    public String getTargets() {
+        return targets;
+    }
+
+    protected void setTargets(String targets) {
+        this.targets = targets;
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutor.java b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutor.java
index 84cfdbb78..78c842429 100644
--- a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutor.java
+++ b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutor.java
@@ -1,131 +1,131 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.concurrent;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.subject.Subject;
-
-import java.util.concurrent.Executor;
-
-/**
- * {@code Executor} implementation that will automatically first associate any argument
- * {@link Runnable} instances with the currently available {@link Subject} and then
- * dispatch the Subject-enabled runnable to an underlying delegate {@link Executor}
- * instance.
- * <p/>
- * This is a simplification for applications that want to execute code as the currently
- * executing {@code Subject} on another thread, but don't want or need to call the
- * {@link Subject#associateWith(Runnable)} method and dispatch to a Thread manually.  This
- * simplifies code and reduces Shiro dependencies across application source code.
- * <p/>
- * Consider this code that could be repeated in many places across an application:
- * <pre>
- * {@link Runnable Runnable} applicationWork = //instantiate or acquire Runnable from somewhere
- * {@link Subject Subject} subject = {@link SecurityUtils SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()};
- * {@link Runnable Runnable} work = subject.{@link Subject#associateWith(Runnable) associateWith(applicationWork)};
- * {@link Executor anExecutor}.{@link Executor#execute(Runnable) execute(work)};
- * </pre>
- * Instead, if the {@code Executor} instance used in application code is an instance of this class (which delegates
- * to the target Executor that you want), all places in code like the above reduce to this:
- * <pre>
- * {@link Runnable Runnable} applicationWork = //instantiate or acquire Runnable from somewhere
- * {@link Executor anExecutor}.{@link Executor#execute(Runnable) execute(work)};
- * </pre>
- * Notice there is no use of the Shiro API in the 2nd code block, encouraging the principle of loose coupling across
- * your codebase.
- *
- * @see SubjectAwareExecutorService
- * @since 1.0
- */
-public class SubjectAwareExecutor implements Executor {
-
-    /**
-     * The target Executor instance that will actually execute the subject-associated Runnable instances.
-     */
-    private Executor targetExecutor;
-
-    public SubjectAwareExecutor() {
-    }
-
-    public SubjectAwareExecutor(Executor targetExecutor) {
-        if (targetExecutor == null) {
-            throw new NullPointerException("target Executor instance cannot be null.");
-        }
-        this.targetExecutor = targetExecutor;
-    }
-
-    /**
-     * Returns the target Executor instance that will actually execute the subject-associated Runnable instances.
-     *
-     * @return target Executor instance that will actually execute the subject-associated Runnable instances.
-     */
-    public Executor getTargetExecutor() {
-        return targetExecutor;
-    }
-
-    /**
-     * Sets target Executor instance that will actually execute the subject-associated Runnable instances.
-     *
-     * @param targetExecutor the target Executor instance that will actually execute the subject-associated Runnable
-     *                       instances.
-     */
-    public void setTargetExecutor(Executor targetExecutor) {
-        this.targetExecutor = targetExecutor;
-    }
-
-    /**
-     * Returns the currently Subject instance that should be associated with Runnable or Callable instances before
-     * being dispatched to the target {@code Executor} instance.  This implementation merely defaults to returning
-     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()}.
-     *
-     * @return the currently Subject instance that should be associated with Runnable or Callable instances before
-     *         being dispatched to the target {@code Executor} instance.
-     */
-    protected Subject getSubject() {
-        return SecurityUtils.getSubject();
-    }
-
-    /**
-     * Utility method for subclasses to associate the argument {@code Runnable} with the currently executing subject
-     * and then return the associated Runnable.  The default implementation merely defaults to
-     * <pre>
-     * Subject subject = {@link #getSubject() getSubject()};
-     * return subject.{@link Subject#associateWith(Runnable) associateWith(r)};
-     * </pre>
-     *
-     * @param r the argument runnable to be associated with the current subject
-     * @return the associated runnable instance reflecting the current subject
-     */
-    protected Runnable associateWithSubject(Runnable r) {
-        Subject subject = getSubject();
-        return subject.associateWith(r);
-    }
-
-    /**
-     * Executes the specified runnable by first associating it with the currently executing {@code Subject} and then
-     * dispatches the associated Runnable to the underlying target {@link Executor} instance.
-     *
-     * @param command the runnable to associate with the currently executing subject and then to execute via the target
-     *                {@code Executor} instance.
-     */
-    public void execute(Runnable command) {
-        Runnable associated = associateWithSubject(command);
-        getTargetExecutor().execute(associated);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.concurrent;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.subject.Subject;
+
+import java.util.concurrent.Executor;
+
+/**
+ * {@code Executor} implementation that will automatically first associate any argument
+ * {@link Runnable} instances with the currently available {@link Subject} and then
+ * dispatch the Subject-enabled runnable to an underlying delegate {@link Executor}
+ * instance.
+ * <p/>
+ * This is a simplification for applications that want to execute code as the currently
+ * executing {@code Subject} on another thread, but don't want or need to call the
+ * {@link Subject#associateWith(Runnable)} method and dispatch to a Thread manually.  This
+ * simplifies code and reduces Shiro dependencies across application source code.
+ * <p/>
+ * Consider this code that could be repeated in many places across an application:
+ * <pre>
+ * {@link Runnable Runnable} applicationWork = //instantiate or acquire Runnable from somewhere
+ * {@link Subject Subject} subject = {@link SecurityUtils SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()};
+ * {@link Runnable Runnable} work = subject.{@link Subject#associateWith(Runnable) associateWith(applicationWork)};
+ * {@link Executor anExecutor}.{@link Executor#execute(Runnable) execute(work)};
+ * </pre>
+ * Instead, if the {@code Executor} instance used in application code is an instance of this class (which delegates
+ * to the target Executor that you want), all places in code like the above reduce to this:
+ * <pre>
+ * {@link Runnable Runnable} applicationWork = //instantiate or acquire Runnable from somewhere
+ * {@link Executor anExecutor}.{@link Executor#execute(Runnable) execute(work)};
+ * </pre>
+ * Notice there is no use of the Shiro API in the 2nd code block, encouraging the principle of loose coupling across
+ * your codebase.
+ *
+ * @see SubjectAwareExecutorService
+ * @since 1.0
+ */
+public class SubjectAwareExecutor implements Executor {
+
+    /**
+     * The target Executor instance that will actually execute the subject-associated Runnable instances.
+     */
+    private Executor targetExecutor;
+
+    public SubjectAwareExecutor() {
+    }
+
+    public SubjectAwareExecutor(Executor targetExecutor) {
+        if (targetExecutor == null) {
+            throw new NullPointerException("target Executor instance cannot be null.");
+        }
+        this.targetExecutor = targetExecutor;
+    }
+
+    /**
+     * Returns the target Executor instance that will actually execute the subject-associated Runnable instances.
+     *
+     * @return target Executor instance that will actually execute the subject-associated Runnable instances.
+     */
+    public Executor getTargetExecutor() {
+        return targetExecutor;
+    }
+
+    /**
+     * Sets target Executor instance that will actually execute the subject-associated Runnable instances.
+     *
+     * @param targetExecutor the target Executor instance that will actually execute the subject-associated Runnable
+     *                       instances.
+     */
+    public void setTargetExecutor(Executor targetExecutor) {
+        this.targetExecutor = targetExecutor;
+    }
+
+    /**
+     * Returns the currently Subject instance that should be associated with Runnable or Callable instances before
+     * being dispatched to the target {@code Executor} instance.  This implementation merely defaults to returning
+     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()}.
+     *
+     * @return the currently Subject instance that should be associated with Runnable or Callable instances before
+     *         being dispatched to the target {@code Executor} instance.
+     */
+    protected Subject getSubject() {
+        return SecurityUtils.getSubject();
+    }
+
+    /**
+     * Utility method for subclasses to associate the argument {@code Runnable} with the currently executing subject
+     * and then return the associated Runnable.  The default implementation merely defaults to
+     * <pre>
+     * Subject subject = {@link #getSubject() getSubject()};
+     * return subject.{@link Subject#associateWith(Runnable) associateWith(r)};
+     * </pre>
+     *
+     * @param r the argument runnable to be associated with the current subject
+     * @return the associated runnable instance reflecting the current subject
+     */
+    protected Runnable associateWithSubject(Runnable r) {
+        Subject subject = getSubject();
+        return subject.associateWith(r);
+    }
+
+    /**
+     * Executes the specified runnable by first associating it with the currently executing {@code Subject} and then
+     * dispatches the associated Runnable to the underlying target {@link Executor} instance.
+     *
+     * @param command the runnable to associate with the currently executing subject and then to execute via the target
+     *                {@code Executor} instance.
+     */
+    public void execute(Runnable command) {
+        Runnable associated = associateWithSubject(command);
+        getTargetExecutor().execute(associated);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutorService.java b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutorService.java
index e15c1d810..07be8bdcf 100644
--- a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutorService.java
+++ b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareExecutorService.java
@@ -1,158 +1,158 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.concurrent;
-
-import org.apache.shiro.subject.Subject;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.*;
-
-/**
- * {@code ExecutorService} implementation that will automatically first associate any argument
- * {@link Runnable} or {@link Callable} instances with the {@link #getSubject currently available subject} and then
- * dispatch the Subject-enabled runnable or callable to an underlying delegate
- * {@link java.util.concurrent.ExecutorService ExecutorService} instance.  The principle is the same as the
- * parent {@link SubjectAwareExecutor} class, but enables the richer {@link ExecutorService} API.
- * <p/>
- * This is a simplification for applications that want to execute code as the currently
- * executing {@code Subject} on another thread, but don't want or need to call the
- * {@link Subject#associateWith(Runnable)} or {@link Subject#associateWith(Callable)} methods and dispatch them to a
- * Thread manually.  This simplifies code and reduces Shiro dependencies across application source code.
- * <p/>
- * Consider this code that could be repeated in many places across an application:
- * <pre>
- * {@link Callable Callable} applicationWork = //instantiate or acquire Callable from somewhere
- * {@link Subject Subject} subject = {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()};
- * {@link Callable Callable} work = subject.{@link Subject#associateWith(Callable) associateWith(applicationWork)};
- * {@link ExecutorService anExecutorService}.{@link ExecutorService#submit(Callable) submit(work)};
- * </pre>
- * Instead, if the {@code ExecutorService} instance used at runtime is an instance of this class
- * (which delegates to the target ExecutorService that you want), all places in code like the above reduce to this:
- * <pre>
- * {@link Callable Callable} applicationWork = //instantiate or acquire Callable from somewhere
- * {@link ExecutorService anExecutorService}.{@link ExecutorService#submit(Callable) submit(work)};
- * </pre>
- * Notice there is no use of the Shiro API in the 2nd code block, encouraging the principle of loose coupling across
- * your codebase.
- *
- * @since 1.0
- */
-public class SubjectAwareExecutorService extends SubjectAwareExecutor implements ExecutorService {
-
-    private ExecutorService targetExecutorService;
-
-    public SubjectAwareExecutorService() {
-    }
-
-    public SubjectAwareExecutorService(ExecutorService target) {
-        setTargetExecutorService(target);
-    }
-
-    public ExecutorService getTargetExecutorService() {
-        return targetExecutorService;
-    }
-
-    public void setTargetExecutorService(ExecutorService targetExecutorService) {
-        super.setTargetExecutor(targetExecutorService);
-        this.targetExecutorService = targetExecutorService;
-    }
-
-    @Override
-    public void setTargetExecutor(Executor targetExecutor) {
-        if (!(targetExecutor instanceof ExecutorService)) {
-            String msg = "The " + getClass().getName() + " implementation only accepts " +
-                    ExecutorService.class.getName() + " target instances.";
-            throw new IllegalArgumentException(msg);
-        }
-        super.setTargetExecutor(targetExecutor);
-    }
-
-    public void shutdown() {
-        this.targetExecutorService.shutdown();
-    }
-
-    public List<Runnable> shutdownNow() {
-        return this.targetExecutorService.shutdownNow();
-    }
-
-    public boolean isShutdown() {
-        return this.targetExecutorService.isShutdown();
-    }
-
-    public boolean isTerminated() {
-        return this.targetExecutorService.isTerminated();
-    }
-
-    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-        return this.targetExecutorService.awaitTermination(timeout, unit);
-    }
-
-    protected <T> Callable<T> associateWithSubject(Callable<T> task) {
-        Subject subject = getSubject();
-        return subject.associateWith(task);
-    }
-
-    public <T> Future<T> submit(Callable<T> task) {
-        Callable<T> work = associateWithSubject(task);
-        return this.targetExecutorService.submit(work);
-    }
-
-    public <T> Future<T> submit(Runnable task, T result) {
-        Runnable work = associateWithSubject(task);
-        return this.targetExecutorService.submit(work, result);
-    }
-
-    public Future<?> submit(Runnable task) {
-        Runnable work = associateWithSubject(task);
-        return this.targetExecutorService.submit(work);
-    }
-
-    protected <T> Collection<Callable<T>> associateWithSubject(Collection<? extends Callable<T>> tasks) {
-        Collection<Callable<T>> workItems = new ArrayList<Callable<T>>(tasks.size());
-        for (Callable<T> task : tasks) {
-            Callable<T> work = associateWithSubject(task);
-            workItems.add(work);
-        }
-        return workItems;
-    }
-
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
-        Collection<Callable<T>> workItems = associateWithSubject(tasks);
-        return this.targetExecutorService.invokeAll(workItems);
-    }
-
-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
-            throws InterruptedException {
-        Collection<Callable<T>> workItems = associateWithSubject(tasks);
-        return this.targetExecutorService.invokeAll(workItems, timeout, unit);
-    }
-
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
-        Collection<Callable<T>> workItems = associateWithSubject(tasks);
-        return this.targetExecutorService.invokeAny(workItems);
-    }
-
-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
-            throws InterruptedException, ExecutionException, TimeoutException {
-        Collection<Callable<T>> workItems = associateWithSubject(tasks);
-        return this.targetExecutorService.invokeAny(workItems, timeout, unit);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.concurrent;
+
+import org.apache.shiro.subject.Subject;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.*;
+
+/**
+ * {@code ExecutorService} implementation that will automatically first associate any argument
+ * {@link Runnable} or {@link Callable} instances with the {@link #getSubject currently available subject} and then
+ * dispatch the Subject-enabled runnable or callable to an underlying delegate
+ * {@link java.util.concurrent.ExecutorService ExecutorService} instance.  The principle is the same as the
+ * parent {@link SubjectAwareExecutor} class, but enables the richer {@link ExecutorService} API.
+ * <p/>
+ * This is a simplification for applications that want to execute code as the currently
+ * executing {@code Subject} on another thread, but don't want or need to call the
+ * {@link Subject#associateWith(Runnable)} or {@link Subject#associateWith(Callable)} methods and dispatch them to a
+ * Thread manually.  This simplifies code and reduces Shiro dependencies across application source code.
+ * <p/>
+ * Consider this code that could be repeated in many places across an application:
+ * <pre>
+ * {@link Callable Callable} applicationWork = //instantiate or acquire Callable from somewhere
+ * {@link Subject Subject} subject = {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()};
+ * {@link Callable Callable} work = subject.{@link Subject#associateWith(Callable) associateWith(applicationWork)};
+ * {@link ExecutorService anExecutorService}.{@link ExecutorService#submit(Callable) submit(work)};
+ * </pre>
+ * Instead, if the {@code ExecutorService} instance used at runtime is an instance of this class
+ * (which delegates to the target ExecutorService that you want), all places in code like the above reduce to this:
+ * <pre>
+ * {@link Callable Callable} applicationWork = //instantiate or acquire Callable from somewhere
+ * {@link ExecutorService anExecutorService}.{@link ExecutorService#submit(Callable) submit(work)};
+ * </pre>
+ * Notice there is no use of the Shiro API in the 2nd code block, encouraging the principle of loose coupling across
+ * your codebase.
+ *
+ * @since 1.0
+ */
+public class SubjectAwareExecutorService extends SubjectAwareExecutor implements ExecutorService {
+
+    private ExecutorService targetExecutorService;
+
+    public SubjectAwareExecutorService() {
+    }
+
+    public SubjectAwareExecutorService(ExecutorService target) {
+        setTargetExecutorService(target);
+    }
+
+    public ExecutorService getTargetExecutorService() {
+        return targetExecutorService;
+    }
+
+    public void setTargetExecutorService(ExecutorService targetExecutorService) {
+        super.setTargetExecutor(targetExecutorService);
+        this.targetExecutorService = targetExecutorService;
+    }
+
+    @Override
+    public void setTargetExecutor(Executor targetExecutor) {
+        if (!(targetExecutor instanceof ExecutorService)) {
+            String msg = "The " + getClass().getName() + " implementation only accepts " +
+                    ExecutorService.class.getName() + " target instances.";
+            throw new IllegalArgumentException(msg);
+        }
+        super.setTargetExecutor(targetExecutor);
+    }
+
+    public void shutdown() {
+        this.targetExecutorService.shutdown();
+    }
+
+    public List<Runnable> shutdownNow() {
+        return this.targetExecutorService.shutdownNow();
+    }
+
+    public boolean isShutdown() {
+        return this.targetExecutorService.isShutdown();
+    }
+
+    public boolean isTerminated() {
+        return this.targetExecutorService.isTerminated();
+    }
+
+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+        return this.targetExecutorService.awaitTermination(timeout, unit);
+    }
+
+    protected <T> Callable<T> associateWithSubject(Callable<T> task) {
+        Subject subject = getSubject();
+        return subject.associateWith(task);
+    }
+
+    public <T> Future<T> submit(Callable<T> task) {
+        Callable<T> work = associateWithSubject(task);
+        return this.targetExecutorService.submit(work);
+    }
+
+    public <T> Future<T> submit(Runnable task, T result) {
+        Runnable work = associateWithSubject(task);
+        return this.targetExecutorService.submit(work, result);
+    }
+
+    public Future<?> submit(Runnable task) {
+        Runnable work = associateWithSubject(task);
+        return this.targetExecutorService.submit(work);
+    }
+
+    protected <T> Collection<Callable<T>> associateWithSubject(Collection<? extends Callable<T>> tasks) {
+        Collection<Callable<T>> workItems = new ArrayList<Callable<T>>(tasks.size());
+        for (Callable<T> task : tasks) {
+            Callable<T> work = associateWithSubject(task);
+            workItems.add(work);
+        }
+        return workItems;
+    }
+
+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
+        Collection<Callable<T>> workItems = associateWithSubject(tasks);
+        return this.targetExecutorService.invokeAll(workItems);
+    }
+
+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+            throws InterruptedException {
+        Collection<Callable<T>> workItems = associateWithSubject(tasks);
+        return this.targetExecutorService.invokeAll(workItems, timeout, unit);
+    }
+
+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
+        Collection<Callable<T>> workItems = associateWithSubject(tasks);
+        return this.targetExecutorService.invokeAny(workItems);
+    }
+
+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
+            throws InterruptedException, ExecutionException, TimeoutException {
+        Collection<Callable<T>> workItems = associateWithSubject(tasks);
+        return this.targetExecutorService.invokeAny(workItems, timeout, unit);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareScheduledExecutorService.java b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareScheduledExecutorService.java
index 4c2d9c615..9013ec827 100644
--- a/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareScheduledExecutorService.java
+++ b/core/src/main/java/org/apache/shiro/concurrent/SubjectAwareScheduledExecutorService.java
@@ -1,86 +1,86 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.concurrent;
-
-import java.util.concurrent.*;
-
-/**
- * Same concept as the {@link SubjectAwareExecutorService} but additionally supports the
- * {@link ScheduledExecutorService} interface.
- */
-public class SubjectAwareScheduledExecutorService extends SubjectAwareExecutorService implements ScheduledExecutorService {
-
-    private ScheduledExecutorService targetScheduledExecutorService;
-
-    public SubjectAwareScheduledExecutorService() {
-    }
-
-    public SubjectAwareScheduledExecutorService(ScheduledExecutorService target) {
-        setTargetScheduledExecutorService(target);
-    }
-
-    public ScheduledExecutorService getTargetScheduledExecutorService() {
-        return targetScheduledExecutorService;
-    }
-
-    public void setTargetScheduledExecutorService(ScheduledExecutorService targetScheduledExecutorService) {
-        super.setTargetExecutorService(targetScheduledExecutorService);
-        this.targetScheduledExecutorService = targetScheduledExecutorService;
-    }
-
-    @Override
-    public void setTargetExecutor(Executor targetExecutor) {
-        if (!(targetExecutor instanceof ScheduledExecutorService)) {
-            String msg = "The " + getClass().getName() + " implementation only accepts " +
-                    ScheduledExecutorService.class.getName() + " target instances.";
-            throw new IllegalArgumentException(msg);
-        }
-        super.setTargetExecutorService((ScheduledExecutorService) targetExecutor);
-    }
-
-    @Override
-    public void setTargetExecutorService(ExecutorService targetExecutorService) {
-        if (!(targetExecutorService instanceof ScheduledExecutorService)) {
-            String msg = "The " + getClass().getName() + " implementation only accepts " +
-                    ScheduledExecutorService.class.getName() + " target instances.";
-            throw new IllegalArgumentException(msg);
-        }
-        super.setTargetExecutorService(targetExecutorService);
-    }
-
-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-        Runnable work = associateWithSubject(command);
-        return this.targetScheduledExecutorService.schedule(work, delay, unit);
-    }
-
-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
-        Callable<V> work = associateWithSubject(callable);
-        return this.targetScheduledExecutorService.schedule(work, delay, unit);
-    }
-
-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
-        Runnable work = associateWithSubject(command);
-        return this.targetScheduledExecutorService.scheduleAtFixedRate(work, initialDelay, period, unit);
-    }
-
-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
-        Runnable work = associateWithSubject(command);
-        return this.targetScheduledExecutorService.scheduleWithFixedDelay(work, initialDelay, delay, unit);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.concurrent;
+
+import java.util.concurrent.*;
+
+/**
+ * Same concept as the {@link SubjectAwareExecutorService} but additionally supports the
+ * {@link ScheduledExecutorService} interface.
+ */
+public class SubjectAwareScheduledExecutorService extends SubjectAwareExecutorService implements ScheduledExecutorService {
+
+    private ScheduledExecutorService targetScheduledExecutorService;
+
+    public SubjectAwareScheduledExecutorService() {
+    }
+
+    public SubjectAwareScheduledExecutorService(ScheduledExecutorService target) {
+        setTargetScheduledExecutorService(target);
+    }
+
+    public ScheduledExecutorService getTargetScheduledExecutorService() {
+        return targetScheduledExecutorService;
+    }
+
+    public void setTargetScheduledExecutorService(ScheduledExecutorService targetScheduledExecutorService) {
+        super.setTargetExecutorService(targetScheduledExecutorService);
+        this.targetScheduledExecutorService = targetScheduledExecutorService;
+    }
+
+    @Override
+    public void setTargetExecutor(Executor targetExecutor) {
+        if (!(targetExecutor instanceof ScheduledExecutorService)) {
+            String msg = "The " + getClass().getName() + " implementation only accepts " +
+                    ScheduledExecutorService.class.getName() + " target instances.";
+            throw new IllegalArgumentException(msg);
+        }
+        super.setTargetExecutorService((ScheduledExecutorService) targetExecutor);
+    }
+
+    @Override
+    public void setTargetExecutorService(ExecutorService targetExecutorService) {
+        if (!(targetExecutorService instanceof ScheduledExecutorService)) {
+            String msg = "The " + getClass().getName() + " implementation only accepts " +
+                    ScheduledExecutorService.class.getName() + " target instances.";
+            throw new IllegalArgumentException(msg);
+        }
+        super.setTargetExecutorService(targetExecutorService);
+    }
+
+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+        Runnable work = associateWithSubject(command);
+        return this.targetScheduledExecutorService.schedule(work, delay, unit);
+    }
+
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+        Callable<V> work = associateWithSubject(callable);
+        return this.targetScheduledExecutorService.schedule(work, delay, unit);
+    }
+
+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
+        Runnable work = associateWithSubject(command);
+        return this.targetScheduledExecutorService.scheduleAtFixedRate(work, initialDelay, period, unit);
+    }
+
+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
+        Runnable work = associateWithSubject(command);
+        return this.targetScheduledExecutorService.scheduleWithFixedDelay(work, initialDelay, delay, unit);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/config/ConfigurationException.java b/core/src/main/java/org/apache/shiro/config/ConfigurationException.java
index dc0331023..a22f2f60d 100644
--- a/core/src/main/java/org/apache/shiro/config/ConfigurationException.java
+++ b/core/src/main/java/org/apache/shiro/config/ConfigurationException.java
@@ -1,67 +1,67 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.ShiroException;
-
-
-/**
- * Root exception indicating there was a problem parsing or processing the Shiro configuration.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public class ConfigurationException extends ShiroException
-{
-
-    /**
-     * Creates a new ConfigurationException.
-     */
-    public ConfigurationException() {
-        super();
-    }
-
-    /**
-     * Constructs a new ConfigurationException.
-     *
-     * @param message the reason for the exception
-     */
-    public ConfigurationException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs a new ConfigurationException.
-     *
-     * @param cause the underlying Throwable that caused this exception to be thrown.
-     */
-    public ConfigurationException(Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * Constructs a new ConfigurationException.
-     *
-     * @param message the reason for the exception
-     * @param cause   the underlying Throwable that caused this exception to be thrown.
-     */
-    public ConfigurationException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.ShiroException;
+
+
+/**
+ * Root exception indicating there was a problem parsing or processing the Shiro configuration.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public class ConfigurationException extends ShiroException
+{
+
+    /**
+     * Creates a new ConfigurationException.
+     */
+    public ConfigurationException() {
+        super();
+    }
+
+    /**
+     * Constructs a new ConfigurationException.
+     *
+     * @param message the reason for the exception
+     */
+    public ConfigurationException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new ConfigurationException.
+     *
+     * @param cause the underlying Throwable that caused this exception to be thrown.
+     */
+    public ConfigurationException(Throwable cause) {
+        super(cause);
+    }
+
+    /**
+     * Constructs a new ConfigurationException.
+     *
+     * @param message the reason for the exception
+     * @param cause   the underlying Throwable that caused this exception to be thrown.
+     */
+    public ConfigurationException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/config/Ini.java b/core/src/main/java/org/apache/shiro/config/Ini.java
index 59644ac07..881fbca1c 100644
--- a/core/src/main/java/org/apache/shiro/config/Ini.java
+++ b/core/src/main/java/org/apache/shiro/config/Ini.java
@@ -1,568 +1,568 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.io.ResourceUtils;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.*;
-import java.util.*;
-
-/**
- * A class representing the <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> text configuration format.
- * <p/>
- * An Ini instance is a map of {@link Ini.Section Section}s, keyed by section name.  Each
- * {@code Section} is itself a map of {@code String} name/value pairs.  Name/value pairs are guaranteed to be unique
- * within each {@code Section} only - not across the entire {@code Ini} instance.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class Ini implements Map<String, Ini.Section> {
-
-    private static transient final Logger log = LoggerFactory.getLogger(Ini.class);
-
-    public static final String DEFAULT_SECTION_NAME = ""; //empty string means the first unnamed section
-    public static final String DEFAULT_CHARSET_NAME = "ISO-8859-1";
-
-    public static final String COMMENT_POUND = "#";
-    public static final String COMMENT_SEMICOLON = ";";
-    public static final String SECTION_PREFIX = "[";
-    public static final String SECTION_SUFFIX = "]";
-
-    private final Map<String, Section> sections;
-
-    /**
-     * Creates a new empty {@code Ini} instance.
-     */
-    public Ini() {
-        this.sections = new LinkedHashMap<String, Section>();
-    }
-
-    /**
-     * Creates a new {@code Ini} instance with the specified defaults.
-     *
-     * @param defaults the default sections and/or key-value pairs to copy into the new instance.
-     */
-    public Ini(Ini defaults) {
-        this();
-        if (defaults == null) {
-            throw new NullPointerException("Defaults cannot be null.");
-        }
-        for (Section section : defaults.getSections()) {
-            Section copy = new Section(section);
-            this.sections.put(section.getName(), copy);
-        }
-    }
-
-    /**
-     * Returns {@code true} if no sections have been configured, or if there are sections, but the sections themselves
-     * are all empty, {@code false} otherwise.
-     *
-     * @return {@code true} if no sections have been configured, or if there are sections, but the sections themselves
-     *         are all empty, {@code false} otherwise.
-     */
-    public boolean isEmpty() {
-        Collection<Section> sections = this.sections.values();
-        if (!sections.isEmpty()) {
-            for (Section section : sections) {
-                if (!section.isEmpty()) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns the names of all sections managed by this {@code Ini} instance or an empty collection if there are
-     * no sections.
-     *
-     * @return the names of all sections managed by this {@code Ini} instance or an empty collection if there are
-     *         no sections.
-     */
-    public Set<String> getSectionNames() {
-        return Collections.unmodifiableSet(sections.keySet());
-    }
-
-    /**
-     * Returns the sections managed by this {@code Ini} instance or an empty collection if there are
-     * no sections.
-     *
-     * @return the sections managed by this {@code Ini} instance or an empty collection if there are
-     *         no sections.
-     */
-    public Collection<Section> getSections() {
-        return Collections.unmodifiableCollection(sections.values());
-    }
-
-    /**
-     * Returns the {@link Section} with the given name or {@code null} if no section with that name exists.
-     *
-     * @param sectionName the name of the section to retrieve.
-     * @return the {@link Section} with the given name or {@code null} if no section with that name exists.
-     */
-    public Section getSection(String sectionName) {
-        String name = cleanName(sectionName);
-        return sections.get(name);
-    }
-
-    /**
-     * Ensures a section with the specified name exists, adding a new one if it does not yet exist.
-     *
-     * @param sectionName the name of the section to ensure existence
-     * @return the section created if it did not yet exist, or the existing Section that already existed.
-     */
-    public Section addSection(String sectionName) {
-        String name = cleanName(sectionName);
-        Section section = getSection(name);
-        if (section == null) {
-            section = new Section(name);
-            this.sections.put(name, section);
-        }
-        return section;
-    }
-
-    /**
-     * Removes the section with the specified name and returns it, or {@code null} if the section did not exist.
-     *
-     * @param sectionName the name of the section to remove.
-     * @return the section with the specified name or {@code null} if the section did not exist.
-     */
-    public Section removeSection(String sectionName) {
-        String name = cleanName(sectionName);
-        return this.sections.remove(name);
-    }
-
-    private static String cleanName(String sectionName) {
-        String name = StringUtils.clean(sectionName);
-        if (name == null) {
-            log.trace("Specified name was null or empty.  Defaulting to the default section (name = \"\")");
-            name = DEFAULT_SECTION_NAME;
-        }
-        return name;
-    }
-
-    /**
-     * Sets a name/value pair for the section with the given {@code sectionName}.  If the section does not yet exist,
-     * it will be created.  If the {@code sectionName} is null or empty, the name/value pair will be placed in the
-     * default (unnamed, empty string) section.
-     *
-     * @param sectionName   the name of the section to add the name/value pair
-     * @param propertyName  the name of the property to add
-     * @param propertyValue the property value
-     */
-    public void setSectionProperty(String sectionName, String propertyName, String propertyValue) {
-        String name = cleanName(sectionName);
-        Section section = getSection(name);
-        if (section == null) {
-            section = addSection(name);
-        }
-        section.put(propertyName, propertyValue);
-    }
-
-    /**
-     * Returns the value of the specified section property, or {@code null} if the section or property do not exist.
-     *
-     * @param sectionName  the name of the section to retrieve to acquire the property value
-     * @param propertyName the name of the section property for which to return the value
-     * @return the value of the specified section property, or {@code null} if the section or property do not exist.
-     */
-    public String getSectionProperty(String sectionName, String propertyName) {
-        Section section = getSection(sectionName);
-        return section != null ? section.get(propertyName) : null;
-    }
-
-    /**
-     * Returns the value of the specified section property, or the {@code defaultValue} if the section or
-     * property do not exist.
-     *
-     * @param sectionName  the name of the section to add the name/value pair
-     * @param propertyName the name of the property to add
-     * @param defaultValue the default value to return if the section or property do not exist.
-     * @return the value of the specified section property, or the {@code defaultValue} if the section or
-     *         property do not exist.
-     */
-    public String getSectionProperty(String sectionName, String propertyName, String defaultValue) {
-        String value = getSectionProperty(sectionName, propertyName);
-        return value != null ? value : defaultValue;
-    }
-
-    /**
-     * Creates a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.  The
-     * resource path may be any value interpretable by the
-     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.
-     *
-     * @param resourcePath the resource location of the INI data to load when creating the {@code Ini} instance.
-     * @return a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.
-     * @throws ConfigurationException if the path cannot be loaded into an {@code Ini} instance.
-     */
-    public static Ini fromResourcePath(String resourcePath) throws ConfigurationException {
-        if (!StringUtils.hasLength(resourcePath)) {
-            throw new IllegalArgumentException("Resource Path argument cannot be null or empty.");
-        }
-        Ini ini = new Ini();
-        ini.loadFromPath(resourcePath);
-        return ini;
-    }
-
-    /**
-     * Loads data from the specified resource path into this current {@code Ini} instance.  The
-     * resource path may be any value interpretable by the
-     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.
-     *
-     * @param resourcePath the resource location of the INI data to load into this instance.
-     * @throws ConfigurationException if the path cannot be loaded
-     */
-    public void loadFromPath(String resourcePath) throws ConfigurationException {
-        InputStream is;
-        try {
-            is = ResourceUtils.getInputStreamForPath(resourcePath);
-        } catch (IOException e) {
-            throw new ConfigurationException(e);
-        }
-        load(is);
-    }
-
-    /**
-     * Loads the specified raw INI-formatted text into this instance.
-     *
-     * @param iniConfig the raw INI-formatted text to load into this instance.
-     * @throws ConfigurationException if the text cannot be loaded
-     */
-    public void load(String iniConfig) throws ConfigurationException {
-        load(new Scanner(iniConfig));
-    }
-
-    /**
-     * Loads the INI-formatted text backed by the given InputStream into this instance.  This implementation will
-     * close the input stream after it has finished loading.
-     *
-     * @param is the {@code InputStream} from which to read the INI-formatted text
-     * @throws ConfigurationException if unable
-     */
-    public void load(InputStream is) throws ConfigurationException {
-        if (is == null) {
-            throw new NullPointerException("InputStream argument cannot be null.");
-        }
-        InputStreamReader isr;
-        try {
-            isr = new InputStreamReader(is, DEFAULT_CHARSET_NAME);
-        } catch (UnsupportedEncodingException e) {
-            throw new ConfigurationException(e);
-        }
-        load(isr);
-    }
-
-    /**
-     * Loads the INI-formatted text backed by the given Reader into this instance.  This implementation will close the
-     * reader after it has finished loading.
-     *
-     * @param reader the {@code Reader} from which to read the INI-formatted text
-     */
-    public void load(Reader reader) {
-        Scanner scanner = new Scanner(reader);
-        try {
-            load(scanner);
-        } finally {
-            try {
-                scanner.close();
-            } catch (Exception e) {
-                log.debug("Unable to cleanly close the InputStream scanner.  Non-critical - ignoring.", e);
-            }
-        }
-    }
-
-    private static InputStream toInputStream(String content) {
-        byte[] bytes;
-        try {
-            bytes = content.getBytes(DEFAULT_CHARSET_NAME);
-        } catch (UnsupportedEncodingException e) {
-            throw new ConfigurationException(e);
-        }
-        return new ByteArrayInputStream(bytes);
-    }
-
-    private static Properties toProps(String content) {
-        InputStream is = toInputStream(content);
-        Properties props = new Properties();
-        try {
-            props.load(is);
-        } catch (IOException e) {
-            throw new ConfigurationException(e);
-        }
-        return props;
-    }
-
-    private void addSection(String name, StringBuffer content) {
-        if (content.length() > 0) {
-            String contentString = content.toString();
-            String cleaned = StringUtils.clean(contentString);
-            if (cleaned != null) {
-                Properties props = toProps(contentString);
-                if (!props.isEmpty()) {
-                    sections.put(name, new Section(name, props));
-                }
-            }
-        }
-    }
-
-    /**
-     * Loads the INI-formatted text backed by the given Scanner.  This implementation will close the
-     * scanner after it has finished loading.
-     *
-     * @param scanner the {@code Scanner} from which to read the INI-formatted text
-     */
-    public void load(Scanner scanner) {
-
-        String sectionName = DEFAULT_SECTION_NAME;
-        StringBuffer sectionContent = new StringBuffer();
-
-        while (scanner.hasNextLine()) {
-
-            String rawLine = scanner.nextLine();
-            String line = StringUtils.clean(rawLine);
-
-            if (line == null || line.startsWith(COMMENT_POUND) || line.startsWith(COMMENT_SEMICOLON)) {
-                //skip empty lines and comments:
-                continue;
-            }
-
-            String newSectionName = getSectionName(line);
-            if (newSectionName != null) {
-                //found a new section - convert the currently buffered one into a Section object
-                addSection(sectionName, sectionContent);
-
-                //reset the buffer for the new section:
-                sectionContent = new StringBuffer();
-
-                sectionName = newSectionName;
-
-                if (log.isDebugEnabled()) {
-                    log.debug("Parsing " + SECTION_PREFIX + sectionName + SECTION_SUFFIX);
-                }
-            } else {
-                //normal line - add it to the existing content buffer:
-                sectionContent.append(rawLine).append("\n");
-            }
-        }
-
-        //finish any remaining buffered content:
-        addSection(sectionName, sectionContent);
-    }
-
-    protected static boolean isSectionHeader(String line) {
-        String s = StringUtils.clean(line);
-        return s != null && s.startsWith(SECTION_PREFIX) && s.endsWith(SECTION_SUFFIX);
-    }
-
-    protected static String getSectionName(String line) {
-        String s = StringUtils.clean(line);
-        if (isSectionHeader(s)) {
-            return cleanName(s.substring(1, s.length() - 1));
-        }
-        return null;
-    }
-
-    public boolean equals(Object obj) {
-        if (obj instanceof Ini) {
-            Ini ini = (Ini) obj;
-            return this.sections.equals(ini.sections);
-        }
-        return false;
-    }
-
-    @Override
-    public int hashCode() {
-        return this.sections.hashCode();
-    }
-
-    public String toString() {
-        if (CollectionUtils.isEmpty(this.sections)) {
-            return "<empty INI>";
-        } else {
-            StringBuilder sb = new StringBuilder("sections=");
-            int i = 0;
-            for (Ini.Section section : this.sections.values()) {
-                if (i > 0) {
-                    sb.append(",");
-                }
-                sb.append(section.toString());
-                i++;
-            }
-            return sb.toString();
-        }
-    }
-
-    public int size() {
-        return this.sections.size();
-    }
-
-    public boolean containsKey(Object key) {
-        return this.sections.containsKey(key);
-    }
-
-    public boolean containsValue(Object value) {
-        return this.sections.containsValue(value);
-    }
-
-    public Section get(Object key) {
-        return this.sections.get(key);
-    }
-
-    public Section put(String key, Section value) {
-        return this.sections.put(key, value);
-    }
-
-    public Section remove(Object key) {
-        return this.sections.remove(key);
-    }
-
-    public void putAll(Map<? extends String, ? extends Section> m) {
-        this.sections.putAll(m);
-    }
-
-    public void clear() {
-        this.sections.clear();
-    }
-
-    public Set<String> keySet() {
-        return Collections.unmodifiableSet(this.sections.keySet());
-    }
-
-    public Collection<Section> values() {
-        return Collections.unmodifiableCollection(this.sections.values());
-    }
-
-    public Set<Entry<String, Section>> entrySet() {
-        return Collections.unmodifiableSet(this.sections.entrySet());
-    }
-
-    /**
-     * An {@code Ini.Section} is String-key-to-String-value Map, identifiable by a
-     * {@link #getName() name} unique within an {@link Ini} instance.
-     */
-    public class Section implements Map<String, String> {
-        private final String name;
-        private final Map<String, String> props;
-
-        private Section(String name) {
-            if (name == null) {
-                throw new NullPointerException("name");
-            }
-            this.name = name;
-            this.props = new LinkedHashMap<String, String>();
-        }
-
-        private Section(String name, Properties props) {
-            this(name);
-            Enumeration propNames = props.propertyNames();
-            while (propNames != null && propNames.hasMoreElements()) {
-                String key = propNames.nextElement().toString();
-                String value = props.getProperty(key);
-                if (value != null) {
-                    this.props.put(key, value.trim());
-                }
-            }
-        }
-
-        private Section(Section defaults) {
-            this(defaults.getName());
-            putAll(defaults.props);
-        }
-
-        public String getName() {
-            return this.name;
-        }
-
-        public void clear() {
-            this.props.clear();
-        }
-
-        public boolean containsKey(Object key) {
-            return this.props.containsKey(key);
-        }
-
-        public boolean containsValue(Object value) {
-            return this.props.containsValue(value);
-        }
-
-        public Set<Entry<String, String>> entrySet() {
-            return this.props.entrySet();
-        }
-
-        public String get(Object key) {
-            return this.props.get(key);
-        }
-
-        public boolean isEmpty() {
-            return this.props.isEmpty();
-        }
-
-        public Set<String> keySet() {
-            return this.props.keySet();
-        }
-
-        public String put(String key, String value) {
-            return this.props.put(key, value);
-        }
-
-        public void putAll(Map<? extends String, ? extends String> m) {
-            this.props.putAll(m);
-        }
-
-        public String remove(Object key) {
-            return this.props.remove(key);
-        }
-
-        public int size() {
-            return this.props.size();
-        }
-
-        public Collection<String> values() {
-            return this.props.values();
-        }
-
-        public String toString() {
-            String name = getName();
-            if (DEFAULT_SECTION_NAME.equals(name)) {
-                return "<default>";
-            }
-            return name;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj instanceof Section) {
-                Section other = (Section) obj;
-                return getName().equals(other.getName()) && this.props.equals(other.props);
-            }
-            return false;
-        }
-
-        @Override
-        public int hashCode() {
-            return this.name.hashCode() * 31 + this.props.hashCode();
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.io.ResourceUtils;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ * A class representing the <a href="http://en.wikipedia.org/wiki/INI_file">INI</a> text configuration format.
+ * <p/>
+ * An Ini instance is a map of {@link Ini.Section Section}s, keyed by section name.  Each
+ * {@code Section} is itself a map of {@code String} name/value pairs.  Name/value pairs are guaranteed to be unique
+ * within each {@code Section} only - not across the entire {@code Ini} instance.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class Ini implements Map<String, Ini.Section> {
+
+    private static transient final Logger log = LoggerFactory.getLogger(Ini.class);
+
+    public static final String DEFAULT_SECTION_NAME = ""; //empty string means the first unnamed section
+    public static final String DEFAULT_CHARSET_NAME = "ISO-8859-1";
+
+    public static final String COMMENT_POUND = "#";
+    public static final String COMMENT_SEMICOLON = ";";
+    public static final String SECTION_PREFIX = "[";
+    public static final String SECTION_SUFFIX = "]";
+
+    private final Map<String, Section> sections;
+
+    /**
+     * Creates a new empty {@code Ini} instance.
+     */
+    public Ini() {
+        this.sections = new LinkedHashMap<String, Section>();
+    }
+
+    /**
+     * Creates a new {@code Ini} instance with the specified defaults.
+     *
+     * @param defaults the default sections and/or key-value pairs to copy into the new instance.
+     */
+    public Ini(Ini defaults) {
+        this();
+        if (defaults == null) {
+            throw new NullPointerException("Defaults cannot be null.");
+        }
+        for (Section section : defaults.getSections()) {
+            Section copy = new Section(section);
+            this.sections.put(section.getName(), copy);
+        }
+    }
+
+    /**
+     * Returns {@code true} if no sections have been configured, or if there are sections, but the sections themselves
+     * are all empty, {@code false} otherwise.
+     *
+     * @return {@code true} if no sections have been configured, or if there are sections, but the sections themselves
+     *         are all empty, {@code false} otherwise.
+     */
+    public boolean isEmpty() {
+        Collection<Section> sections = this.sections.values();
+        if (!sections.isEmpty()) {
+            for (Section section : sections) {
+                if (!section.isEmpty()) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the names of all sections managed by this {@code Ini} instance or an empty collection if there are
+     * no sections.
+     *
+     * @return the names of all sections managed by this {@code Ini} instance or an empty collection if there are
+     *         no sections.
+     */
+    public Set<String> getSectionNames() {
+        return Collections.unmodifiableSet(sections.keySet());
+    }
+
+    /**
+     * Returns the sections managed by this {@code Ini} instance or an empty collection if there are
+     * no sections.
+     *
+     * @return the sections managed by this {@code Ini} instance or an empty collection if there are
+     *         no sections.
+     */
+    public Collection<Section> getSections() {
+        return Collections.unmodifiableCollection(sections.values());
+    }
+
+    /**
+     * Returns the {@link Section} with the given name or {@code null} if no section with that name exists.
+     *
+     * @param sectionName the name of the section to retrieve.
+     * @return the {@link Section} with the given name or {@code null} if no section with that name exists.
+     */
+    public Section getSection(String sectionName) {
+        String name = cleanName(sectionName);
+        return sections.get(name);
+    }
+
+    /**
+     * Ensures a section with the specified name exists, adding a new one if it does not yet exist.
+     *
+     * @param sectionName the name of the section to ensure existence
+     * @return the section created if it did not yet exist, or the existing Section that already existed.
+     */
+    public Section addSection(String sectionName) {
+        String name = cleanName(sectionName);
+        Section section = getSection(name);
+        if (section == null) {
+            section = new Section(name);
+            this.sections.put(name, section);
+        }
+        return section;
+    }
+
+    /**
+     * Removes the section with the specified name and returns it, or {@code null} if the section did not exist.
+     *
+     * @param sectionName the name of the section to remove.
+     * @return the section with the specified name or {@code null} if the section did not exist.
+     */
+    public Section removeSection(String sectionName) {
+        String name = cleanName(sectionName);
+        return this.sections.remove(name);
+    }
+
+    private static String cleanName(String sectionName) {
+        String name = StringUtils.clean(sectionName);
+        if (name == null) {
+            log.trace("Specified name was null or empty.  Defaulting to the default section (name = \"\")");
+            name = DEFAULT_SECTION_NAME;
+        }
+        return name;
+    }
+
+    /**
+     * Sets a name/value pair for the section with the given {@code sectionName}.  If the section does not yet exist,
+     * it will be created.  If the {@code sectionName} is null or empty, the name/value pair will be placed in the
+     * default (unnamed, empty string) section.
+     *
+     * @param sectionName   the name of the section to add the name/value pair
+     * @param propertyName  the name of the property to add
+     * @param propertyValue the property value
+     */
+    public void setSectionProperty(String sectionName, String propertyName, String propertyValue) {
+        String name = cleanName(sectionName);
+        Section section = getSection(name);
+        if (section == null) {
+            section = addSection(name);
+        }
+        section.put(propertyName, propertyValue);
+    }
+
+    /**
+     * Returns the value of the specified section property, or {@code null} if the section or property do not exist.
+     *
+     * @param sectionName  the name of the section to retrieve to acquire the property value
+     * @param propertyName the name of the section property for which to return the value
+     * @return the value of the specified section property, or {@code null} if the section or property do not exist.
+     */
+    public String getSectionProperty(String sectionName, String propertyName) {
+        Section section = getSection(sectionName);
+        return section != null ? section.get(propertyName) : null;
+    }
+
+    /**
+     * Returns the value of the specified section property, or the {@code defaultValue} if the section or
+     * property do not exist.
+     *
+     * @param sectionName  the name of the section to add the name/value pair
+     * @param propertyName the name of the property to add
+     * @param defaultValue the default value to return if the section or property do not exist.
+     * @return the value of the specified section property, or the {@code defaultValue} if the section or
+     *         property do not exist.
+     */
+    public String getSectionProperty(String sectionName, String propertyName, String defaultValue) {
+        String value = getSectionProperty(sectionName, propertyName);
+        return value != null ? value : defaultValue;
+    }
+
+    /**
+     * Creates a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.  The
+     * resource path may be any value interpretable by the
+     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.
+     *
+     * @param resourcePath the resource location of the INI data to load when creating the {@code Ini} instance.
+     * @return a new {@code Ini} instance loaded with the INI-formatted data in the resource at the given path.
+     * @throws ConfigurationException if the path cannot be loaded into an {@code Ini} instance.
+     */
+    public static Ini fromResourcePath(String resourcePath) throws ConfigurationException {
+        if (!StringUtils.hasLength(resourcePath)) {
+            throw new IllegalArgumentException("Resource Path argument cannot be null or empty.");
+        }
+        Ini ini = new Ini();
+        ini.loadFromPath(resourcePath);
+        return ini;
+    }
+
+    /**
+     * Loads data from the specified resource path into this current {@code Ini} instance.  The
+     * resource path may be any value interpretable by the
+     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} method.
+     *
+     * @param resourcePath the resource location of the INI data to load into this instance.
+     * @throws ConfigurationException if the path cannot be loaded
+     */
+    public void loadFromPath(String resourcePath) throws ConfigurationException {
+        InputStream is;
+        try {
+            is = ResourceUtils.getInputStreamForPath(resourcePath);
+        } catch (IOException e) {
+            throw new ConfigurationException(e);
+        }
+        load(is);
+    }
+
+    /**
+     * Loads the specified raw INI-formatted text into this instance.
+     *
+     * @param iniConfig the raw INI-formatted text to load into this instance.
+     * @throws ConfigurationException if the text cannot be loaded
+     */
+    public void load(String iniConfig) throws ConfigurationException {
+        load(new Scanner(iniConfig));
+    }
+
+    /**
+     * Loads the INI-formatted text backed by the given InputStream into this instance.  This implementation will
+     * close the input stream after it has finished loading.
+     *
+     * @param is the {@code InputStream} from which to read the INI-formatted text
+     * @throws ConfigurationException if unable
+     */
+    public void load(InputStream is) throws ConfigurationException {
+        if (is == null) {
+            throw new NullPointerException("InputStream argument cannot be null.");
+        }
+        InputStreamReader isr;
+        try {
+            isr = new InputStreamReader(is, DEFAULT_CHARSET_NAME);
+        } catch (UnsupportedEncodingException e) {
+            throw new ConfigurationException(e);
+        }
+        load(isr);
+    }
+
+    /**
+     * Loads the INI-formatted text backed by the given Reader into this instance.  This implementation will close the
+     * reader after it has finished loading.
+     *
+     * @param reader the {@code Reader} from which to read the INI-formatted text
+     */
+    public void load(Reader reader) {
+        Scanner scanner = new Scanner(reader);
+        try {
+            load(scanner);
+        } finally {
+            try {
+                scanner.close();
+            } catch (Exception e) {
+                log.debug("Unable to cleanly close the InputStream scanner.  Non-critical - ignoring.", e);
+            }
+        }
+    }
+
+    private static InputStream toInputStream(String content) {
+        byte[] bytes;
+        try {
+            bytes = content.getBytes(DEFAULT_CHARSET_NAME);
+        } catch (UnsupportedEncodingException e) {
+            throw new ConfigurationException(e);
+        }
+        return new ByteArrayInputStream(bytes);
+    }
+
+    private static Properties toProps(String content) {
+        InputStream is = toInputStream(content);
+        Properties props = new Properties();
+        try {
+            props.load(is);
+        } catch (IOException e) {
+            throw new ConfigurationException(e);
+        }
+        return props;
+    }
+
+    private void addSection(String name, StringBuffer content) {
+        if (content.length() > 0) {
+            String contentString = content.toString();
+            String cleaned = StringUtils.clean(contentString);
+            if (cleaned != null) {
+                Properties props = toProps(contentString);
+                if (!props.isEmpty()) {
+                    sections.put(name, new Section(name, props));
+                }
+            }
+        }
+    }
+
+    /**
+     * Loads the INI-formatted text backed by the given Scanner.  This implementation will close the
+     * scanner after it has finished loading.
+     *
+     * @param scanner the {@code Scanner} from which to read the INI-formatted text
+     */
+    public void load(Scanner scanner) {
+
+        String sectionName = DEFAULT_SECTION_NAME;
+        StringBuffer sectionContent = new StringBuffer();
+
+        while (scanner.hasNextLine()) {
+
+            String rawLine = scanner.nextLine();
+            String line = StringUtils.clean(rawLine);
+
+            if (line == null || line.startsWith(COMMENT_POUND) || line.startsWith(COMMENT_SEMICOLON)) {
+                //skip empty lines and comments:
+                continue;
+            }
+
+            String newSectionName = getSectionName(line);
+            if (newSectionName != null) {
+                //found a new section - convert the currently buffered one into a Section object
+                addSection(sectionName, sectionContent);
+
+                //reset the buffer for the new section:
+                sectionContent = new StringBuffer();
+
+                sectionName = newSectionName;
+
+                if (log.isDebugEnabled()) {
+                    log.debug("Parsing " + SECTION_PREFIX + sectionName + SECTION_SUFFIX);
+                }
+            } else {
+                //normal line - add it to the existing content buffer:
+                sectionContent.append(rawLine).append("\n");
+            }
+        }
+
+        //finish any remaining buffered content:
+        addSection(sectionName, sectionContent);
+    }
+
+    protected static boolean isSectionHeader(String line) {
+        String s = StringUtils.clean(line);
+        return s != null && s.startsWith(SECTION_PREFIX) && s.endsWith(SECTION_SUFFIX);
+    }
+
+    protected static String getSectionName(String line) {
+        String s = StringUtils.clean(line);
+        if (isSectionHeader(s)) {
+            return cleanName(s.substring(1, s.length() - 1));
+        }
+        return null;
+    }
+
+    public boolean equals(Object obj) {
+        if (obj instanceof Ini) {
+            Ini ini = (Ini) obj;
+            return this.sections.equals(ini.sections);
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return this.sections.hashCode();
+    }
+
+    public String toString() {
+        if (CollectionUtils.isEmpty(this.sections)) {
+            return "<empty INI>";
+        } else {
+            StringBuilder sb = new StringBuilder("sections=");
+            int i = 0;
+            for (Ini.Section section : this.sections.values()) {
+                if (i > 0) {
+                    sb.append(",");
+                }
+                sb.append(section.toString());
+                i++;
+            }
+            return sb.toString();
+        }
+    }
+
+    public int size() {
+        return this.sections.size();
+    }
+
+    public boolean containsKey(Object key) {
+        return this.sections.containsKey(key);
+    }
+
+    public boolean containsValue(Object value) {
+        return this.sections.containsValue(value);
+    }
+
+    public Section get(Object key) {
+        return this.sections.get(key);
+    }
+
+    public Section put(String key, Section value) {
+        return this.sections.put(key, value);
+    }
+
+    public Section remove(Object key) {
+        return this.sections.remove(key);
+    }
+
+    public void putAll(Map<? extends String, ? extends Section> m) {
+        this.sections.putAll(m);
+    }
+
+    public void clear() {
+        this.sections.clear();
+    }
+
+    public Set<String> keySet() {
+        return Collections.unmodifiableSet(this.sections.keySet());
+    }
+
+    public Collection<Section> values() {
+        return Collections.unmodifiableCollection(this.sections.values());
+    }
+
+    public Set<Entry<String, Section>> entrySet() {
+        return Collections.unmodifiableSet(this.sections.entrySet());
+    }
+
+    /**
+     * An {@code Ini.Section} is String-key-to-String-value Map, identifiable by a
+     * {@link #getName() name} unique within an {@link Ini} instance.
+     */
+    public class Section implements Map<String, String> {
+        private final String name;
+        private final Map<String, String> props;
+
+        private Section(String name) {
+            if (name == null) {
+                throw new NullPointerException("name");
+            }
+            this.name = name;
+            this.props = new LinkedHashMap<String, String>();
+        }
+
+        private Section(String name, Properties props) {
+            this(name);
+            Enumeration propNames = props.propertyNames();
+            while (propNames != null && propNames.hasMoreElements()) {
+                String key = propNames.nextElement().toString();
+                String value = props.getProperty(key);
+                if (value != null) {
+                    this.props.put(key, value.trim());
+                }
+            }
+        }
+
+        private Section(Section defaults) {
+            this(defaults.getName());
+            putAll(defaults.props);
+        }
+
+        public String getName() {
+            return this.name;
+        }
+
+        public void clear() {
+            this.props.clear();
+        }
+
+        public boolean containsKey(Object key) {
+            return this.props.containsKey(key);
+        }
+
+        public boolean containsValue(Object value) {
+            return this.props.containsValue(value);
+        }
+
+        public Set<Entry<String, String>> entrySet() {
+            return this.props.entrySet();
+        }
+
+        public String get(Object key) {
+            return this.props.get(key);
+        }
+
+        public boolean isEmpty() {
+            return this.props.isEmpty();
+        }
+
+        public Set<String> keySet() {
+            return this.props.keySet();
+        }
+
+        public String put(String key, String value) {
+            return this.props.put(key, value);
+        }
+
+        public void putAll(Map<? extends String, ? extends String> m) {
+            this.props.putAll(m);
+        }
+
+        public String remove(Object key) {
+            return this.props.remove(key);
+        }
+
+        public int size() {
+            return this.props.size();
+        }
+
+        public Collection<String> values() {
+            return this.props.values();
+        }
+
+        public String toString() {
+            String name = getName();
+            if (DEFAULT_SECTION_NAME.equals(name)) {
+                return "<default>";
+            }
+            return name;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj instanceof Section) {
+                Section other = (Section) obj;
+                return getName().equals(other.getName()) && this.props.equals(other.props);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return this.name.hashCode() * 31 + this.props.hashCode();
+        }
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/config/IniFactorySupport.java b/core/src/main/java/org/apache/shiro/config/IniFactorySupport.java
index 0bcde30aa..29edfd0d4 100644
--- a/core/src/main/java/org/apache/shiro/config/IniFactorySupport.java
+++ b/core/src/main/java/org/apache/shiro/config/IniFactorySupport.java
@@ -1,138 +1,138 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.io.ResourceUtils;
-import org.apache.shiro.util.AbstractFactory;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.Factory;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Base support class for {@link Factory} implementations that generate their instance(s) based on
- * {@link Ini} configuration.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public abstract class IniFactorySupport<T> extends AbstractFactory<T> {
-
-    public static final String DEFAULT_INI_RESOURCE_PATH = "classpath:shiro.ini";
-
-    private static transient final Logger log = LoggerFactory.getLogger(IniFactorySupport.class);
-
-    private Ini ini;
-
-    protected IniFactorySupport() {
-    }
-
-    protected IniFactorySupport(Ini ini) {
-        this.ini = ini;
-    }
-
-    public Ini getIni() {
-        return ini;
-    }
-
-    public void setIni(Ini ini) {
-        this.ini = ini;
-    }
-
-    /**
-     * Returns a new Ini instance created from the default {@code classpath:shiro.ini} file, or {@code null} if
-     * the file does not exist.
-     *
-     * @return a new Ini instance created from the default {@code classpath:shiro.ini} file, or {@code null} if
-     *         the file does not exist.
-     */
-    public static Ini loadDefaultClassPathIni() {
-        Ini ini = null;
-        if (ResourceUtils.resourceExists(DEFAULT_INI_RESOURCE_PATH)) {
-            log.debug("Found shiro.ini at the root of the classpath.");
-            ini = new Ini();
-            ini.loadFromPath(DEFAULT_INI_RESOURCE_PATH);
-            if (CollectionUtils.isEmpty(ini)) {
-                log.warn("shiro.ini found at the root of the classpath, but it did not contain any data.");
-            }
-        }
-        return ini;
-    }
-
-    /**
-     * Tries to resolve the Ini instance to use for configuration.  This implementation functions as follows:
-     * <ol>
-     * <li>The {@code Ini} instance returned from {@link #getIni()} will be returned if it is not null or empty.</li>
-     * <li>If {@link #getIni()} is {@code null} or empty, this implementation will attempt to find and load the
-     * {@link #loadDefaultClassPathIni() default class path Ini}.</li>
-     * <li>If neither of the two attempts above returns an instance, {@code null} is returned</li>
-     * </ol>
-     *
-     * @return the Ini instance to use for configuration.
-     */
-    protected Ini resolveIni() {
-        Ini ini = getIni();
-        if (CollectionUtils.isEmpty(ini)) {
-            log.debug("Null or empty Ini instance.  Falling back to the default {} file.", DEFAULT_INI_RESOURCE_PATH);
-            ini = loadDefaultClassPathIni();
-        }
-        return ini;
-    }
-
-    /**
-     * Creates a new object instance by using a configured INI source.  This implementation functions as follows:
-     * <ol>
-     * <li>{@link #resolveIni() Resolve} the {@code Ini} source to use for configuration.</li>
-     * <li>If there was no resolved Ini source, create and return a simple default instance via the
-     * {@link #createDefaultInstance()} method.</li>
-     * </ol>
-     *
-     * @return a new {@code SecurityManager} instance by using a configured INI source.
-     */
-    public T createInstance() {
-        Ini ini = resolveIni();
-
-        T instance;
-
-        if (CollectionUtils.isEmpty(ini)) {
-            log.debug("No populated Ini available.  Creating a default instance.");
-            instance = createDefaultInstance();
-            if (instance == null) {
-                String msg = getClass().getName() + " implementation did not return a default instance in " +
-                        "the event of a null/empty Ini configuration.  This is required to support the " +
-                        "Factory interface.  Please check your implementation.";
-                throw new IllegalStateException(msg);
-            }
-        } else {
-            log.debug("Creating instance from Ini [" + ini + "]");
-            instance = createInstance(ini);
-            if (instance == null) {
-                String msg = getClass().getName() + " implementation did not return a constructed instance from " +
-                        "the createInstance(Ini) method implementation.";
-                throw new IllegalStateException(msg);
-            }
-        }
-
-        return instance;
-    }
-
-    protected abstract T createInstance(Ini ini);
-
-    protected abstract T createDefaultInstance();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.io.ResourceUtils;
+import org.apache.shiro.util.AbstractFactory;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.Factory;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Base support class for {@link Factory} implementations that generate their instance(s) based on
+ * {@link Ini} configuration.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public abstract class IniFactorySupport<T> extends AbstractFactory<T> {
+
+    public static final String DEFAULT_INI_RESOURCE_PATH = "classpath:shiro.ini";
+
+    private static transient final Logger log = LoggerFactory.getLogger(IniFactorySupport.class);
+
+    private Ini ini;
+
+    protected IniFactorySupport() {
+    }
+
+    protected IniFactorySupport(Ini ini) {
+        this.ini = ini;
+    }
+
+    public Ini getIni() {
+        return ini;
+    }
+
+    public void setIni(Ini ini) {
+        this.ini = ini;
+    }
+
+    /**
+     * Returns a new Ini instance created from the default {@code classpath:shiro.ini} file, or {@code null} if
+     * the file does not exist.
+     *
+     * @return a new Ini instance created from the default {@code classpath:shiro.ini} file, or {@code null} if
+     *         the file does not exist.
+     */
+    public static Ini loadDefaultClassPathIni() {
+        Ini ini = null;
+        if (ResourceUtils.resourceExists(DEFAULT_INI_RESOURCE_PATH)) {
+            log.debug("Found shiro.ini at the root of the classpath.");
+            ini = new Ini();
+            ini.loadFromPath(DEFAULT_INI_RESOURCE_PATH);
+            if (CollectionUtils.isEmpty(ini)) {
+                log.warn("shiro.ini found at the root of the classpath, but it did not contain any data.");
+            }
+        }
+        return ini;
+    }
+
+    /**
+     * Tries to resolve the Ini instance to use for configuration.  This implementation functions as follows:
+     * <ol>
+     * <li>The {@code Ini} instance returned from {@link #getIni()} will be returned if it is not null or empty.</li>
+     * <li>If {@link #getIni()} is {@code null} or empty, this implementation will attempt to find and load the
+     * {@link #loadDefaultClassPathIni() default class path Ini}.</li>
+     * <li>If neither of the two attempts above returns an instance, {@code null} is returned</li>
+     * </ol>
+     *
+     * @return the Ini instance to use for configuration.
+     */
+    protected Ini resolveIni() {
+        Ini ini = getIni();
+        if (CollectionUtils.isEmpty(ini)) {
+            log.debug("Null or empty Ini instance.  Falling back to the default {} file.", DEFAULT_INI_RESOURCE_PATH);
+            ini = loadDefaultClassPathIni();
+        }
+        return ini;
+    }
+
+    /**
+     * Creates a new object instance by using a configured INI source.  This implementation functions as follows:
+     * <ol>
+     * <li>{@link #resolveIni() Resolve} the {@code Ini} source to use for configuration.</li>
+     * <li>If there was no resolved Ini source, create and return a simple default instance via the
+     * {@link #createDefaultInstance()} method.</li>
+     * </ol>
+     *
+     * @return a new {@code SecurityManager} instance by using a configured INI source.
+     */
+    public T createInstance() {
+        Ini ini = resolveIni();
+
+        T instance;
+
+        if (CollectionUtils.isEmpty(ini)) {
+            log.debug("No populated Ini available.  Creating a default instance.");
+            instance = createDefaultInstance();
+            if (instance == null) {
+                String msg = getClass().getName() + " implementation did not return a default instance in " +
+                        "the event of a null/empty Ini configuration.  This is required to support the " +
+                        "Factory interface.  Please check your implementation.";
+                throw new IllegalStateException(msg);
+            }
+        } else {
+            log.debug("Creating instance from Ini [" + ini + "]");
+            instance = createInstance(ini);
+            if (instance == null) {
+                String msg = getClass().getName() + " implementation did not return a constructed instance from " +
+                        "the createInstance(Ini) method implementation.";
+                throw new IllegalStateException(msg);
+            }
+        }
+
+        return instance;
+    }
+
+    protected abstract T createInstance(Ini ini);
+
+    protected abstract T createDefaultInstance();
+}
diff --git a/core/src/main/java/org/apache/shiro/config/IniSecurityManagerFactory.java b/core/src/main/java/org/apache/shiro/config/IniSecurityManagerFactory.java
index 58267f190..cdcc2deba 100644
--- a/core/src/main/java/org/apache/shiro/config/IniSecurityManagerFactory.java
+++ b/core/src/main/java/org/apache/shiro/config/IniSecurityManagerFactory.java
@@ -1,259 +1,259 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.mgt.DefaultSecurityManager;
-import org.apache.shiro.mgt.RealmSecurityManager;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.realm.Realm;
-import org.apache.shiro.realm.RealmFactory;
-import org.apache.shiro.realm.text.IniRealm;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.Factory;
-import org.apache.shiro.util.LifecycleUtils;
-import org.apache.shiro.util.Nameable;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.*;
-
-/**
- * A {@link Factory} that creates {@link SecurityManager} instances based on {@link Ini} configuration.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class IniSecurityManagerFactory extends IniFactorySupport<SecurityManager> {
-
-    public static final String MAIN_SECTION_NAME = "main";
-
-    public static final String SECURITY_MANAGER_NAME = "securityManager";
-    public static final String INI_REALM_NAME = "iniRealm";
-
-    private static transient final Logger log = LoggerFactory.getLogger(IniSecurityManagerFactory.class);
-
-    private ReflectionBuilder builder;
-
-    /**
-     * Creates a new instance.  See the {@link #getInstance()} JavaDoc for detailed explanation of how an INI
-     * source will be resolved to use to build the instance.
-     */
-    public IniSecurityManagerFactory() {
-    }
-
-    public IniSecurityManagerFactory(Ini config) {
-        setIni(config);
-    }
-
-    public IniSecurityManagerFactory(String iniResourcePath) {
-        this(Ini.fromResourcePath(iniResourcePath));
-    }
-
-    public Map<String, ?> getBeans() {
-        return this.builder != null ? Collections.unmodifiableMap(builder.getObjects()) : null;
-    }
-
-    private SecurityManager getSecurityManagerBean() {
-        return builder.getBean(SECURITY_MANAGER_NAME, SecurityManager.class);
-    }
-
-    protected SecurityManager createDefaultInstance() {
-        return new DefaultSecurityManager();
-    }
-
-    protected SecurityManager createInstance(Ini ini) {
-        if (CollectionUtils.isEmpty(ini)) {
-            throw new NullPointerException("Ini argument cannot be null or empty.");
-        }
-        SecurityManager securityManager = createSecurityManager(ini);
-        if (securityManager == null) {
-            String msg = SecurityManager.class + " instance cannot be null.";
-            throw new ConfigurationException(msg);
-        }
-        return securityManager;
-    }
-
-    private SecurityManager createSecurityManager(Ini ini) {
-        Ini.Section mainSection = ini.getSection(MAIN_SECTION_NAME);
-        if (CollectionUtils.isEmpty(mainSection)) {
-            //try the default:
-            mainSection = ini.getSection(Ini.DEFAULT_SECTION_NAME);
-        }
-        return createSecurityManager(ini, mainSection);
-    }
-
-    protected boolean isAutoApplyRealms(SecurityManager securityManager) {
-        boolean autoApply = true;
-        if (securityManager instanceof RealmSecurityManager) {
-            //only apply realms if they haven't been explicitly set by the user:
-            RealmSecurityManager realmSecurityManager = (RealmSecurityManager) securityManager;
-            Collection<Realm> realms = realmSecurityManager.getRealms();
-            if (!CollectionUtils.isEmpty(realms)) {
-                log.info("Realms have been explicitly set on the SecurityManager instance - auto-setting of " +
-                        "realms will not occur.");
-                autoApply = false;
-            }
-        }
-        return autoApply;
-    }
-
-    @SuppressWarnings({"unchecked"})
-    private SecurityManager createSecurityManager(Ini ini, Ini.Section mainSection) {
-
-        Map<String, ?> defaults = createDefaults(ini, mainSection);
-        Map<String, ?> objects = buildInstances(mainSection, defaults);
-
-        SecurityManager securityManager = getSecurityManagerBean();
-
-        boolean autoApplyRealms = isAutoApplyRealms(securityManager);
-
-        if (autoApplyRealms) {
-            //realms and realm factory might have been created - pull them out first so we can
-            //initialize the securityManager:
-            Collection<Realm> realms = getRealms(objects);
-            //set them on the SecurityManager
-            if (!CollectionUtils.isEmpty(realms)) {
-                applyRealmsToSecurityManager(realms, securityManager);
-            }
-        }
-
-        initRealms(securityManager);
-
-        return securityManager;
-    }
-
-    private void initRealms(SecurityManager securityManager) {
-        Collection<Realm> realms = getRealms(securityManager);
-        if (!CollectionUtils.isEmpty(realms)) {
-            LifecycleUtils.init(realms);
-        }
-    }
-
-    private Collection<Realm> getRealms(SecurityManager securityManager) {
-        assertRealmSecurityManager(securityManager);
-        return ((RealmSecurityManager) securityManager).getRealms();
-    }
-
-    protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {
-        Map<String, Object> defaults = new LinkedHashMap<String, Object>();
-
-        SecurityManager securityManager = createDefaultInstance();
-        defaults.put(SECURITY_MANAGER_NAME, securityManager);
-
-        if (shouldImplicitlyCreateRealm(ini)) {
-            Realm realm = createRealm(ini);
-            if (realm != null) {
-                defaults.put(INI_REALM_NAME, realm);
-            }
-        }
-
-        return defaults;
-    }
-
-    private Map<String, ?> buildInstances(Ini.Section section, Map<String, ?> defaults) {
-        this.builder = new ReflectionBuilder(defaults);
-        return this.builder.buildObjects(section);
-    }
-
-    private void addToRealms(Collection<Realm> realms, RealmFactory factory) {
-        LifecycleUtils.init(factory);
-        Collection<Realm> factoryRealms = factory.getRealms();
-        if (!CollectionUtils.isEmpty(realms)) {
-            realms.addAll(factoryRealms);
-        }
-    }
-
-    private Collection<Realm> getRealms(Map<String, ?> instances) {
-
-        //realms and realm factory might have been created - pull them out first so we can
-        //initialize the securityManager:
-        List<Realm> realms = new ArrayList<Realm>();
-
-        //iterate over the map entries to pull out the realm factory(s):
-        for (Map.Entry<String, ?> entry : instances.entrySet()) {
-
-            String name = entry.getKey();
-            Object value = entry.getValue();
-
-            if (value instanceof RealmFactory) {
-                addToRealms(realms, (RealmFactory) value);
-            } else if (value instanceof Realm) {
-                Realm realm = (Realm) value;
-                //set the name if null:
-                String existingName = realm.getName();
-                if (existingName == null || existingName.startsWith(realm.getClass().getName())) {
-                    if (realm instanceof Nameable) {
-                        ((Nameable) realm).setName(name);
-                        log.debug("Applied name '{}' to Nameable realm instance {}", name, realm);
-                    } else {
-                        log.info("Realm does not implement the {} interface.  Configured name will not be applied.",
-                                Nameable.class.getName());
-                    }
-                }
-                realms.add(realm);
-            }
-        }
-
-        return realms;
-    }
-
-    private void assertRealmSecurityManager(SecurityManager securityManager) {
-        if (securityManager == null) {
-            throw new NullPointerException("securityManager instance cannot be null");
-        }
-        if (!(securityManager instanceof RealmSecurityManager)) {
-            String msg = "securityManager instance is not a " + RealmSecurityManager.class.getName() +
-                    " instance.  This is required to access or configure realms on the instance.";
-            throw new ConfigurationException(msg);
-        }
-    }
-
-    protected void applyRealmsToSecurityManager(Collection<Realm> realms, SecurityManager securityManager) {
-        assertRealmSecurityManager(securityManager);
-        ((RealmSecurityManager) securityManager).setRealms(realms);
-    }
-
-    /**
-     * Returns {@code true} if the Ini contains account data and a {@code Realm} should be implicitly
-     * {@link #createRealm(Ini) created} to reflect the account data, {@code false} if no realm should be implicitly
-     * created.
-     *
-     * @param ini the Ini instance to inspect for account data resulting in an implicitly created realm.
-     * @return {@code true} if the Ini contains account data and a {@code Realm} should be implicitly
-     *         {@link #createRealm(Ini) created} to reflect the account data, {@code false} if no realm should be
-     *         implicitly created.
-     */
-    protected boolean shouldImplicitlyCreateRealm(Ini ini) {
-        return !CollectionUtils.isEmpty(ini) &&
-                (!CollectionUtils.isEmpty(ini.getSection(IniRealm.ROLES_SECTION_NAME)) ||
-                        !CollectionUtils.isEmpty(ini.getSection(IniRealm.USERS_SECTION_NAME)));
-    }
-
-    /**
-     * Creates a {@code Realm} from the Ini instance containing account data.
-     *
-     * @param ini the Ini instance from which to acquire the account data.
-     * @return a new Realm instance reflecting the account data discovered in the {@code Ini}.
-     */
-    protected Realm createRealm(Ini ini) {
-        IniRealm realm = new IniRealm(ini);
-        realm.setName(INI_REALM_NAME);
-        return realm;
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.mgt.RealmSecurityManager;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.realm.Realm;
+import org.apache.shiro.realm.RealmFactory;
+import org.apache.shiro.realm.text.IniRealm;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.Factory;
+import org.apache.shiro.util.LifecycleUtils;
+import org.apache.shiro.util.Nameable;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
+
+/**
+ * A {@link Factory} that creates {@link SecurityManager} instances based on {@link Ini} configuration.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class IniSecurityManagerFactory extends IniFactorySupport<SecurityManager> {
+
+    public static final String MAIN_SECTION_NAME = "main";
+
+    public static final String SECURITY_MANAGER_NAME = "securityManager";
+    public static final String INI_REALM_NAME = "iniRealm";
+
+    private static transient final Logger log = LoggerFactory.getLogger(IniSecurityManagerFactory.class);
+
+    private ReflectionBuilder builder;
+
+    /**
+     * Creates a new instance.  See the {@link #getInstance()} JavaDoc for detailed explanation of how an INI
+     * source will be resolved to use to build the instance.
+     */
+    public IniSecurityManagerFactory() {
+    }
+
+    public IniSecurityManagerFactory(Ini config) {
+        setIni(config);
+    }
+
+    public IniSecurityManagerFactory(String iniResourcePath) {
+        this(Ini.fromResourcePath(iniResourcePath));
+    }
+
+    public Map<String, ?> getBeans() {
+        return this.builder != null ? Collections.unmodifiableMap(builder.getObjects()) : null;
+    }
+
+    private SecurityManager getSecurityManagerBean() {
+        return builder.getBean(SECURITY_MANAGER_NAME, SecurityManager.class);
+    }
+
+    protected SecurityManager createDefaultInstance() {
+        return new DefaultSecurityManager();
+    }
+
+    protected SecurityManager createInstance(Ini ini) {
+        if (CollectionUtils.isEmpty(ini)) {
+            throw new NullPointerException("Ini argument cannot be null or empty.");
+        }
+        SecurityManager securityManager = createSecurityManager(ini);
+        if (securityManager == null) {
+            String msg = SecurityManager.class + " instance cannot be null.";
+            throw new ConfigurationException(msg);
+        }
+        return securityManager;
+    }
+
+    private SecurityManager createSecurityManager(Ini ini) {
+        Ini.Section mainSection = ini.getSection(MAIN_SECTION_NAME);
+        if (CollectionUtils.isEmpty(mainSection)) {
+            //try the default:
+            mainSection = ini.getSection(Ini.DEFAULT_SECTION_NAME);
+        }
+        return createSecurityManager(ini, mainSection);
+    }
+
+    protected boolean isAutoApplyRealms(SecurityManager securityManager) {
+        boolean autoApply = true;
+        if (securityManager instanceof RealmSecurityManager) {
+            //only apply realms if they haven't been explicitly set by the user:
+            RealmSecurityManager realmSecurityManager = (RealmSecurityManager) securityManager;
+            Collection<Realm> realms = realmSecurityManager.getRealms();
+            if (!CollectionUtils.isEmpty(realms)) {
+                log.info("Realms have been explicitly set on the SecurityManager instance - auto-setting of " +
+                        "realms will not occur.");
+                autoApply = false;
+            }
+        }
+        return autoApply;
+    }
+
+    @SuppressWarnings({"unchecked"})
+    private SecurityManager createSecurityManager(Ini ini, Ini.Section mainSection) {
+
+        Map<String, ?> defaults = createDefaults(ini, mainSection);
+        Map<String, ?> objects = buildInstances(mainSection, defaults);
+
+        SecurityManager securityManager = getSecurityManagerBean();
+
+        boolean autoApplyRealms = isAutoApplyRealms(securityManager);
+
+        if (autoApplyRealms) {
+            //realms and realm factory might have been created - pull them out first so we can
+            //initialize the securityManager:
+            Collection<Realm> realms = getRealms(objects);
+            //set them on the SecurityManager
+            if (!CollectionUtils.isEmpty(realms)) {
+                applyRealmsToSecurityManager(realms, securityManager);
+            }
+        }
+
+        initRealms(securityManager);
+
+        return securityManager;
+    }
+
+    private void initRealms(SecurityManager securityManager) {
+        Collection<Realm> realms = getRealms(securityManager);
+        if (!CollectionUtils.isEmpty(realms)) {
+            LifecycleUtils.init(realms);
+        }
+    }
+
+    private Collection<Realm> getRealms(SecurityManager securityManager) {
+        assertRealmSecurityManager(securityManager);
+        return ((RealmSecurityManager) securityManager).getRealms();
+    }
+
+    protected Map<String, ?> createDefaults(Ini ini, Ini.Section mainSection) {
+        Map<String, Object> defaults = new LinkedHashMap<String, Object>();
+
+        SecurityManager securityManager = createDefaultInstance();
+        defaults.put(SECURITY_MANAGER_NAME, securityManager);
+
+        if (shouldImplicitlyCreateRealm(ini)) {
+            Realm realm = createRealm(ini);
+            if (realm != null) {
+                defaults.put(INI_REALM_NAME, realm);
+            }
+        }
+
+        return defaults;
+    }
+
+    private Map<String, ?> buildInstances(Ini.Section section, Map<String, ?> defaults) {
+        this.builder = new ReflectionBuilder(defaults);
+        return this.builder.buildObjects(section);
+    }
+
+    private void addToRealms(Collection<Realm> realms, RealmFactory factory) {
+        LifecycleUtils.init(factory);
+        Collection<Realm> factoryRealms = factory.getRealms();
+        if (!CollectionUtils.isEmpty(realms)) {
+            realms.addAll(factoryRealms);
+        }
+    }
+
+    private Collection<Realm> getRealms(Map<String, ?> instances) {
+
+        //realms and realm factory might have been created - pull them out first so we can
+        //initialize the securityManager:
+        List<Realm> realms = new ArrayList<Realm>();
+
+        //iterate over the map entries to pull out the realm factory(s):
+        for (Map.Entry<String, ?> entry : instances.entrySet()) {
+
+            String name = entry.getKey();
+            Object value = entry.getValue();
+
+            if (value instanceof RealmFactory) {
+                addToRealms(realms, (RealmFactory) value);
+            } else if (value instanceof Realm) {
+                Realm realm = (Realm) value;
+                //set the name if null:
+                String existingName = realm.getName();
+                if (existingName == null || existingName.startsWith(realm.getClass().getName())) {
+                    if (realm instanceof Nameable) {
+                        ((Nameable) realm).setName(name);
+                        log.debug("Applied name '{}' to Nameable realm instance {}", name, realm);
+                    } else {
+                        log.info("Realm does not implement the {} interface.  Configured name will not be applied.",
+                                Nameable.class.getName());
+                    }
+                }
+                realms.add(realm);
+            }
+        }
+
+        return realms;
+    }
+
+    private void assertRealmSecurityManager(SecurityManager securityManager) {
+        if (securityManager == null) {
+            throw new NullPointerException("securityManager instance cannot be null");
+        }
+        if (!(securityManager instanceof RealmSecurityManager)) {
+            String msg = "securityManager instance is not a " + RealmSecurityManager.class.getName() +
+                    " instance.  This is required to access or configure realms on the instance.";
+            throw new ConfigurationException(msg);
+        }
+    }
+
+    protected void applyRealmsToSecurityManager(Collection<Realm> realms, SecurityManager securityManager) {
+        assertRealmSecurityManager(securityManager);
+        ((RealmSecurityManager) securityManager).setRealms(realms);
+    }
+
+    /**
+     * Returns {@code true} if the Ini contains account data and a {@code Realm} should be implicitly
+     * {@link #createRealm(Ini) created} to reflect the account data, {@code false} if no realm should be implicitly
+     * created.
+     *
+     * @param ini the Ini instance to inspect for account data resulting in an implicitly created realm.
+     * @return {@code true} if the Ini contains account data and a {@code Realm} should be implicitly
+     *         {@link #createRealm(Ini) created} to reflect the account data, {@code false} if no realm should be
+     *         implicitly created.
+     */
+    protected boolean shouldImplicitlyCreateRealm(Ini ini) {
+        return !CollectionUtils.isEmpty(ini) &&
+                (!CollectionUtils.isEmpty(ini.getSection(IniRealm.ROLES_SECTION_NAME)) ||
+                        !CollectionUtils.isEmpty(ini.getSection(IniRealm.USERS_SECTION_NAME)));
+    }
+
+    /**
+     * Creates a {@code Realm} from the Ini instance containing account data.
+     *
+     * @param ini the Ini instance from which to acquire the account data.
+     * @return a new Realm instance reflecting the account data discovered in the {@code Ini}.
+     */
+    protected Realm createRealm(Ini ini) {
+        IniRealm realm = new IniRealm(ini);
+        realm.setName(INI_REALM_NAME);
+        return realm;
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java b/core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java
index 6600e8ddc..da53f351f 100644
--- a/core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java
+++ b/core/src/main/java/org/apache/shiro/config/ReflectionBuilder.java
@@ -1,379 +1,379 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.commons.beanutils.BeanUtils;
-import org.apache.commons.beanutils.PropertyUtils;
-import org.apache.shiro.codec.Base64;
-import org.apache.shiro.codec.Hex;
-import org.apache.shiro.util.ClassUtils;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.Nameable;
-import org.apache.shiro.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.beans.PropertyDescriptor;
-import java.util.*;
-
-
-/**
- * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a
- * map of "property values".  Typically these come from the Shiro INI configuration and are used
- * to construct or modify the SecurityManager, its dependencies, and web-based security filters.
- *
- * @author Les Hazlewood
- * @author Jeremy Haile
- * @since 0.9
- */
-public class ReflectionBuilder {
-
-    //TODO - complete JavaDoc
-
-    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);
-
-    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = "$";
-    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = "\\$";
-    private static final String GLOBAL_PROPERTY_PREFIX = "shiro";
-    private static final char MAP_KEY_VALUE_DELIMITER = ':';
-    private static final String HEX_BEGIN_TOKEN = "0x";
-
-    private Map<String, ?> objects;
-
-    public ReflectionBuilder() {
-        this.objects = new LinkedHashMap<String, Object>();
-    }
-
-    public ReflectionBuilder(Map<String, ?> defaults) {
-        this.objects = CollectionUtils.isEmpty(defaults) ? new LinkedHashMap<String, Object>() : defaults;
-    }
-
-    public Map<String, ?> getObjects() {
-        return objects;
-    }
-
-    public void setObjects(Map<String, ?> objects) {
-        this.objects = CollectionUtils.isEmpty(objects) ? new LinkedHashMap<String, Object>() : objects;
-    }
-
-    public Object getBean(String id) {
-        return objects.get(id);
-    }
-
-    @SuppressWarnings({"unchecked"})
-    public <T> T getBean(String id, Class<T> requiredType) {
-        if (requiredType == null) {
-            throw new NullPointerException("requiredType argument cannot be null.");
-        }
-        Object bean = getBean(id);
-        if (bean == null) {
-            return null;
-        }
-        if (!requiredType.isAssignableFrom(bean.getClass())) {
-            throw new IllegalStateException("Bean with id [" + id + "] is not of the required type [" +
-                    requiredType.getName() + "].");
-        }
-        return (T) bean;
-    }
-
-    @SuppressWarnings({"unchecked"})
-    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {
-        if (kvPairs != null && !kvPairs.isEmpty()) {
-
-            // Separate key value pairs into object declarations and property assignment
-            // so that all objects can be created up front
-
-            //https://issues.apache.org/jira/browse/SHIRO-85 - need to use LinkedHashMaps here:
-            Map<String, String> instanceMap = new LinkedHashMap<String, String>();
-            Map<String, String> propertyMap = new LinkedHashMap<String, String>();
-
-            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {
-                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(".class")) {
-                    instanceMap.put(entry.getKey(), entry.getValue());
-                } else {
-                    propertyMap.put(entry.getKey(), entry.getValue());
-                }
-            }
-
-            // Create all instances
-            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {
-                createNewInstance((Map<String, Object>) objects, entry.getKey(), entry.getValue());
-            }
-
-            // Set all properties
-            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {
-                applyProperty(entry.getKey(), entry.getValue(), objects);
-            }
-        }
-
-        return objects;
-    }
-
-    protected void createNewInstance(Map<String, Object> objects, String name, String value) {
-
-        Object currentInstance = objects.get(name);
-        if (currentInstance != null) {
-            log.info("An instance with name '{}' already exists.  " +
-                    "Redefining this object as a new instance of type []", name, value);
-        }
-
-        Object instance;//name with no property, assume right hand side of equals sign is the class name:
-        try {
-            instance = ClassUtils.newInstance(value);
-            if (instance instanceof Nameable) {
-                ((Nameable) instance).setName(name);
-            }
-        } catch (Exception e) {
-            String msg = "Unable to instantiate class [" + value + "] for object named '" + name + "'.  " +
-                    "Please ensure you've specified the fully qualified class name correctly.";
-            throw new ConfigurationException(msg, e);
-        }
-        objects.put(name, instance);
-    }
-
-    protected void applyProperty(String key, String value, Map objects) {
-
-        int index = key.indexOf('.');
-
-        if (index >= 0) {
-            String name = key.substring(0, index);
-            String property = key.substring(index + 1, key.length());
-
-            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {
-                applyGlobalProperty(objects, property, value);
-            } else {
-                applySingleProperty(objects, name, property, value);
-            }
-
-        } else {
-            throw new IllegalArgumentException("All property keys must contain a '.' character. " +
-                    "(e.g. myBean.property = value)  These should already be separated out by buildObjects().");
-        }
-    }
-
-    protected void applyGlobalProperty(Map objects, String property, String value) {
-        for (Object instance : objects.values()) {
-            try {
-                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);
-                if (pd != null) {
-                    applyProperty(instance, property, value);
-                }
-            } catch (Exception e) {
-                String msg = "Error retrieving property descriptor for instance " +
-                        "of type [" + instance.getClass().getName() + "] " +
-                        "while setting property [" + property + "]";
-                throw new ConfigurationException(msg, e);
-            }
-        }
-    }
-
-    protected void applySingleProperty(Map objects, String name, String property, String value) {
-        Object instance = objects.get(name);
-        if (property.equals("class")) {
-            throw new IllegalArgumentException("Property keys should not contain 'class' properties since these " +
-                    "should already be separated out by buildObjects().");
-
-        } else if (instance == null) {
-            String msg = "Configuration error.  Specified object [" + name + "] with property [" +
-                    property + "] without first defining that object's class.  Please first " +
-                    "specify the class property first, e.g. myObject = fully_qualified_class_name " +
-                    "and then define additional properties.";
-            throw new IllegalArgumentException(msg);
-
-        } else {
-            applyProperty(instance, property, value);
-        }
-    }
-
-    protected boolean isReference(String value) {
-        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);
-    }
-
-    protected String getId(String referenceToken) {
-        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());
-    }
-
-    protected Object getReferencedObject(String id) {
-        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;
-        if (o == null) {
-            String msg = "The object with id [" + id + "] has not yet been defined and therefore cannot be " +
-                    "referenced.  Please ensure objects are defined in the order in which they should be " +
-                    "created and made available for future reference.";
-            throw new UnresolveableReferenceException(msg);
-        }
-        return o;
-    }
-
-    protected String unescapeIfNecessary(String value) {
-        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {
-            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);
-        }
-        return value;
-    }
-
-    protected Object resolveReference(String reference) {
-        String id = getId(reference);
-        log.debug("Encountered object reference '{}'.  Looking up object with id '{}'", reference, id);
-        return getReferencedObject(id);
-    }
-
-    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {
-        if (clazz == null) {
-            throw new NullPointerException("type (class) argument cannot be null.");
-        }
-        try {
-            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);
-            if (descriptor == null) {
-                String msg = "Property '" + propertyName + "' does not exist for object of " +
-                        "type " + object.getClass().getName() + ".";
-                throw new ConfigurationException(msg);
-            }
-            Class propertyClazz = descriptor.getPropertyType();
-            return clazz.isAssignableFrom(propertyClazz);
-        } catch (ConfigurationException ce) {
-            //let it propagate:
-            throw ce;
-        } catch (Exception e) {
-            String msg = "Unable to determine if property [" + propertyName + "] represents a " + clazz.getName();
-            throw new ConfigurationException(msg, e);
-        }
-    }
-
-    protected Set<?> toSet(String sValue) {
-        String[] tokens = StringUtils.split(sValue);
-        if (tokens == null || tokens.length <= 0) {
-            return null;
-        }
-        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));
-
-        //now convert into correct values and/or references:
-        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());
-        for (String token : setTokens) {
-            Object value = resolveValue(token);
-            values.add(value);
-        }
-        return values;
-    }
-
-    protected Map<?, ?> toMap(String sValue) {
-        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,
-                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);
-        if (tokens == null || tokens.length <= 0) {
-            return null;
-        }
-
-        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);
-        for (String token : tokens) {
-            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);
-            if (kvPair == null || kvPair.length != 2) {
-                String msg = "Map property value [" + sValue + "] contained key-value pair token [" +
-                        token + "] that does not properly split to a single key and pair.  This must be the " +
-                        "case for all map entries.";
-                throw new ConfigurationException(msg);
-            }
-            mapTokens.put(kvPair[0], kvPair[1]);
-        }
-
-        //now convert into correct values and/or references:
-        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());
-        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {
-            Object key = resolveValue(entry.getKey());
-            Object value = resolveValue(entry.getValue());
-            map.put(key, value);
-        }
-        return map;
-    }
-
-
-    protected List<?> toList(String sValue) {
-        String[] tokens = StringUtils.split(sValue);
-        if (tokens == null || tokens.length <= 0) {
-            return null;
-        }
-
-        //now convert into correct values and/or references:
-        List<Object> values = new ArrayList<Object>(tokens.length);
-        for (String token : tokens) {
-            Object value = resolveValue(token);
-            values.add(value);
-        }
-        return values;
-    }
-
-    protected byte[] toBytes(String sValue) {
-        if (sValue == null) {
-            return null;
-        }
-        byte[] bytes;
-        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {
-            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());
-            bytes = Hex.decode(hex);
-        } else {
-            //assume base64 encoded:
-            bytes = Base64.decode(sValue);
-        }
-        return bytes;
-    }
-
-    protected Object resolveValue(String stringValue) {
-        Object value;
-        if (isReference(stringValue)) {
-            value = resolveReference(stringValue);
-        } else {
-            value = unescapeIfNecessary(stringValue);
-        }
-        return value;
-    }
-
-
-    protected void applyProperty(Object object, String propertyName, String stringValue) {
-
-        Object value;
-
-        if (isTypedProperty(object, propertyName, Set.class)) {
-            value = toSet(stringValue);
-        } else if (isTypedProperty(object, propertyName, Map.class)) {
-            value = toMap(stringValue);
-        } else if (isTypedProperty(object, propertyName, List.class) ||
-                isTypedProperty(object, propertyName, Collection.class)) {
-            value = toList(stringValue);
-        } else if (isTypedProperty(object, propertyName, byte[].class)) {
-            value = toBytes(stringValue);
-        } else {
-            value = resolveValue(stringValue);
-        }
-
-        try {
-            if (log.isTraceEnabled()) {
-                log.trace("Applying property [{}] value [{}] on object of type [{}]",
-                        new Object[]{propertyName, value, object.getClass().getName()});
-            }
-            BeanUtils.setProperty(object, propertyName, value);
-        } catch (Exception e) {
-            String msg = "Unable to set property '" + propertyName + "' with value [" + stringValue + "] on object " +
-                    "of type " + (object != null ? object.getClass().getName() : null) + ".  If " +
-                    "'" + stringValue + "' is a reference to another (previously defined) object, prefix it with " +
-                    "'" + OBJECT_REFERENCE_BEGIN_TOKEN + "' to indicate that the referenced " +
-                    "object should be used as the actual value.  " +
-                    "For example, " + OBJECT_REFERENCE_BEGIN_TOKEN + stringValue;
-            throw new ConfigurationException(msg, e);
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.commons.beanutils.BeanUtils;
+import org.apache.commons.beanutils.PropertyUtils;
+import org.apache.shiro.codec.Base64;
+import org.apache.shiro.codec.Hex;
+import org.apache.shiro.util.ClassUtils;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.Nameable;
+import org.apache.shiro.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.beans.PropertyDescriptor;
+import java.util.*;
+
+
+/**
+ * Object builder that uses reflection and Apache Commons BeanUtils to build objects given a
+ * map of "property values".  Typically these come from the Shiro INI configuration and are used
+ * to construct or modify the SecurityManager, its dependencies, and web-based security filters.
+ *
+ * @author Les Hazlewood
+ * @author Jeremy Haile
+ * @since 0.9
+ */
+public class ReflectionBuilder {
+
+    //TODO - complete JavaDoc
+
+    private static final Logger log = LoggerFactory.getLogger(ReflectionBuilder.class);
+
+    private static final String OBJECT_REFERENCE_BEGIN_TOKEN = "$";
+    private static final String ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN = "\\$";
+    private static final String GLOBAL_PROPERTY_PREFIX = "shiro";
+    private static final char MAP_KEY_VALUE_DELIMITER = ':';
+    private static final String HEX_BEGIN_TOKEN = "0x";
+
+    private Map<String, ?> objects;
+
+    public ReflectionBuilder() {
+        this.objects = new LinkedHashMap<String, Object>();
+    }
+
+    public ReflectionBuilder(Map<String, ?> defaults) {
+        this.objects = CollectionUtils.isEmpty(defaults) ? new LinkedHashMap<String, Object>() : defaults;
+    }
+
+    public Map<String, ?> getObjects() {
+        return objects;
+    }
+
+    public void setObjects(Map<String, ?> objects) {
+        this.objects = CollectionUtils.isEmpty(objects) ? new LinkedHashMap<String, Object>() : objects;
+    }
+
+    public Object getBean(String id) {
+        return objects.get(id);
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public <T> T getBean(String id, Class<T> requiredType) {
+        if (requiredType == null) {
+            throw new NullPointerException("requiredType argument cannot be null.");
+        }
+        Object bean = getBean(id);
+        if (bean == null) {
+            return null;
+        }
+        if (!requiredType.isAssignableFrom(bean.getClass())) {
+            throw new IllegalStateException("Bean with id [" + id + "] is not of the required type [" +
+                    requiredType.getName() + "].");
+        }
+        return (T) bean;
+    }
+
+    @SuppressWarnings({"unchecked"})
+    public Map<String, ?> buildObjects(Map<String, String> kvPairs) {
+        if (kvPairs != null && !kvPairs.isEmpty()) {
+
+            // Separate key value pairs into object declarations and property assignment
+            // so that all objects can be created up front
+
+            //https://issues.apache.org/jira/browse/SHIRO-85 - need to use LinkedHashMaps here:
+            Map<String, String> instanceMap = new LinkedHashMap<String, String>();
+            Map<String, String> propertyMap = new LinkedHashMap<String, String>();
+
+            for (Map.Entry<String, String> entry : kvPairs.entrySet()) {
+                if (entry.getKey().indexOf('.') < 0 || entry.getKey().endsWith(".class")) {
+                    instanceMap.put(entry.getKey(), entry.getValue());
+                } else {
+                    propertyMap.put(entry.getKey(), entry.getValue());
+                }
+            }
+
+            // Create all instances
+            for (Map.Entry<String, String> entry : instanceMap.entrySet()) {
+                createNewInstance((Map<String, Object>) objects, entry.getKey(), entry.getValue());
+            }
+
+            // Set all properties
+            for (Map.Entry<String, String> entry : propertyMap.entrySet()) {
+                applyProperty(entry.getKey(), entry.getValue(), objects);
+            }
+        }
+
+        return objects;
+    }
+
+    protected void createNewInstance(Map<String, Object> objects, String name, String value) {
+
+        Object currentInstance = objects.get(name);
+        if (currentInstance != null) {
+            log.info("An instance with name '{}' already exists.  " +
+                    "Redefining this object as a new instance of type []", name, value);
+        }
+
+        Object instance;//name with no property, assume right hand side of equals sign is the class name:
+        try {
+            instance = ClassUtils.newInstance(value);
+            if (instance instanceof Nameable) {
+                ((Nameable) instance).setName(name);
+            }
+        } catch (Exception e) {
+            String msg = "Unable to instantiate class [" + value + "] for object named '" + name + "'.  " +
+                    "Please ensure you've specified the fully qualified class name correctly.";
+            throw new ConfigurationException(msg, e);
+        }
+        objects.put(name, instance);
+    }
+
+    protected void applyProperty(String key, String value, Map objects) {
+
+        int index = key.indexOf('.');
+
+        if (index >= 0) {
+            String name = key.substring(0, index);
+            String property = key.substring(index + 1, key.length());
+
+            if (GLOBAL_PROPERTY_PREFIX.equalsIgnoreCase(name)) {
+                applyGlobalProperty(objects, property, value);
+            } else {
+                applySingleProperty(objects, name, property, value);
+            }
+
+        } else {
+            throw new IllegalArgumentException("All property keys must contain a '.' character. " +
+                    "(e.g. myBean.property = value)  These should already be separated out by buildObjects().");
+        }
+    }
+
+    protected void applyGlobalProperty(Map objects, String property, String value) {
+        for (Object instance : objects.values()) {
+            try {
+                PropertyDescriptor pd = PropertyUtils.getPropertyDescriptor(instance, property);
+                if (pd != null) {
+                    applyProperty(instance, property, value);
+                }
+            } catch (Exception e) {
+                String msg = "Error retrieving property descriptor for instance " +
+                        "of type [" + instance.getClass().getName() + "] " +
+                        "while setting property [" + property + "]";
+                throw new ConfigurationException(msg, e);
+            }
+        }
+    }
+
+    protected void applySingleProperty(Map objects, String name, String property, String value) {
+        Object instance = objects.get(name);
+        if (property.equals("class")) {
+            throw new IllegalArgumentException("Property keys should not contain 'class' properties since these " +
+                    "should already be separated out by buildObjects().");
+
+        } else if (instance == null) {
+            String msg = "Configuration error.  Specified object [" + name + "] with property [" +
+                    property + "] without first defining that object's class.  Please first " +
+                    "specify the class property first, e.g. myObject = fully_qualified_class_name " +
+                    "and then define additional properties.";
+            throw new IllegalArgumentException(msg);
+
+        } else {
+            applyProperty(instance, property, value);
+        }
+    }
+
+    protected boolean isReference(String value) {
+        return value != null && value.startsWith(OBJECT_REFERENCE_BEGIN_TOKEN);
+    }
+
+    protected String getId(String referenceToken) {
+        return referenceToken.substring(OBJECT_REFERENCE_BEGIN_TOKEN.length());
+    }
+
+    protected Object getReferencedObject(String id) {
+        Object o = objects != null && !objects.isEmpty() ? objects.get(id) : null;
+        if (o == null) {
+            String msg = "The object with id [" + id + "] has not yet been defined and therefore cannot be " +
+                    "referenced.  Please ensure objects are defined in the order in which they should be " +
+                    "created and made available for future reference.";
+            throw new UnresolveableReferenceException(msg);
+        }
+        return o;
+    }
+
+    protected String unescapeIfNecessary(String value) {
+        if (value != null && value.startsWith(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN)) {
+            return value.substring(ESCAPED_OBJECT_REFERENCE_BEGIN_TOKEN.length() - 1);
+        }
+        return value;
+    }
+
+    protected Object resolveReference(String reference) {
+        String id = getId(reference);
+        log.debug("Encountered object reference '{}'.  Looking up object with id '{}'", reference, id);
+        return getReferencedObject(id);
+    }
+
+    protected boolean isTypedProperty(Object object, String propertyName, Class clazz) {
+        if (clazz == null) {
+            throw new NullPointerException("type (class) argument cannot be null.");
+        }
+        try {
+            PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(object, propertyName);
+            if (descriptor == null) {
+                String msg = "Property '" + propertyName + "' does not exist for object of " +
+                        "type " + object.getClass().getName() + ".";
+                throw new ConfigurationException(msg);
+            }
+            Class propertyClazz = descriptor.getPropertyType();
+            return clazz.isAssignableFrom(propertyClazz);
+        } catch (ConfigurationException ce) {
+            //let it propagate:
+            throw ce;
+        } catch (Exception e) {
+            String msg = "Unable to determine if property [" + propertyName + "] represents a " + clazz.getName();
+            throw new ConfigurationException(msg, e);
+        }
+    }
+
+    protected Set<?> toSet(String sValue) {
+        String[] tokens = StringUtils.split(sValue);
+        if (tokens == null || tokens.length <= 0) {
+            return null;
+        }
+        Set<String> setTokens = new LinkedHashSet<String>(Arrays.asList(tokens));
+
+        //now convert into correct values and/or references:
+        Set<Object> values = new LinkedHashSet<Object>(setTokens.size());
+        for (String token : setTokens) {
+            Object value = resolveValue(token);
+            values.add(value);
+        }
+        return values;
+    }
+
+    protected Map<?, ?> toMap(String sValue) {
+        String[] tokens = StringUtils.split(sValue, StringUtils.DEFAULT_DELIMITER_CHAR,
+                StringUtils.DEFAULT_QUOTE_CHAR, StringUtils.DEFAULT_QUOTE_CHAR, true, true);
+        if (tokens == null || tokens.length <= 0) {
+            return null;
+        }
+
+        Map<String, String> mapTokens = new LinkedHashMap<String, String>(tokens.length);
+        for (String token : tokens) {
+            String[] kvPair = StringUtils.split(token, MAP_KEY_VALUE_DELIMITER);
+            if (kvPair == null || kvPair.length != 2) {
+                String msg = "Map property value [" + sValue + "] contained key-value pair token [" +
+                        token + "] that does not properly split to a single key and pair.  This must be the " +
+                        "case for all map entries.";
+                throw new ConfigurationException(msg);
+            }
+            mapTokens.put(kvPair[0], kvPair[1]);
+        }
+
+        //now convert into correct values and/or references:
+        Map<Object, Object> map = new LinkedHashMap<Object, Object>(mapTokens.size());
+        for (Map.Entry<String, String> entry : mapTokens.entrySet()) {
+            Object key = resolveValue(entry.getKey());
+            Object value = resolveValue(entry.getValue());
+            map.put(key, value);
+        }
+        return map;
+    }
+
+
+    protected List<?> toList(String sValue) {
+        String[] tokens = StringUtils.split(sValue);
+        if (tokens == null || tokens.length <= 0) {
+            return null;
+        }
+
+        //now convert into correct values and/or references:
+        List<Object> values = new ArrayList<Object>(tokens.length);
+        for (String token : tokens) {
+            Object value = resolveValue(token);
+            values.add(value);
+        }
+        return values;
+    }
+
+    protected byte[] toBytes(String sValue) {
+        if (sValue == null) {
+            return null;
+        }
+        byte[] bytes;
+        if (sValue.startsWith(HEX_BEGIN_TOKEN)) {
+            String hex = sValue.substring(HEX_BEGIN_TOKEN.length());
+            bytes = Hex.decode(hex);
+        } else {
+            //assume base64 encoded:
+            bytes = Base64.decode(sValue);
+        }
+        return bytes;
+    }
+
+    protected Object resolveValue(String stringValue) {
+        Object value;
+        if (isReference(stringValue)) {
+            value = resolveReference(stringValue);
+        } else {
+            value = unescapeIfNecessary(stringValue);
+        }
+        return value;
+    }
+
+
+    protected void applyProperty(Object object, String propertyName, String stringValue) {
+
+        Object value;
+
+        if (isTypedProperty(object, propertyName, Set.class)) {
+            value = toSet(stringValue);
+        } else if (isTypedProperty(object, propertyName, Map.class)) {
+            value = toMap(stringValue);
+        } else if (isTypedProperty(object, propertyName, List.class) ||
+                isTypedProperty(object, propertyName, Collection.class)) {
+            value = toList(stringValue);
+        } else if (isTypedProperty(object, propertyName, byte[].class)) {
+            value = toBytes(stringValue);
+        } else {
+            value = resolveValue(stringValue);
+        }
+
+        try {
+            if (log.isTraceEnabled()) {
+                log.trace("Applying property [{}] value [{}] on object of type [{}]",
+                        new Object[]{propertyName, value, object.getClass().getName()});
+            }
+            BeanUtils.setProperty(object, propertyName, value);
+        } catch (Exception e) {
+            String msg = "Unable to set property '" + propertyName + "' with value [" + stringValue + "] on object " +
+                    "of type " + (object != null ? object.getClass().getName() : null) + ".  If " +
+                    "'" + stringValue + "' is a reference to another (previously defined) object, prefix it with " +
+                    "'" + OBJECT_REFERENCE_BEGIN_TOKEN + "' to indicate that the referenced " +
+                    "object should be used as the actual value.  " +
+                    "For example, " + OBJECT_REFERENCE_BEGIN_TOKEN + stringValue;
+            throw new ConfigurationException(msg, e);
+        }
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/config/UnresolveableReferenceException.java b/core/src/main/java/org/apache/shiro/config/UnresolveableReferenceException.java
index dc9ad1b94..8c09b8a8b 100644
--- a/core/src/main/java/org/apache/shiro/config/UnresolveableReferenceException.java
+++ b/core/src/main/java/org/apache/shiro/config/UnresolveableReferenceException.java
@@ -1,64 +1,64 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-/**
- * Exception thrown when a reference to an object is made, but that object cannot be found.  This is most likely
- * thrown due to a configuration line that references an object that hasn't been defined yet.
- *
- * @author Les Hazlewood
- * @since 0.9 RC2
- */
-public class UnresolveableReferenceException extends ConfigurationException {
-
-    /**
-     * Creates a new UnresolveableReferenceException.
-     */
-    public UnresolveableReferenceException() {
-        super();
-    }
-
-    /**
-     * Constructs a new UnresolveableReferenceException.
-     *
-     * @param message the reason for the exception
-     */
-    public UnresolveableReferenceException(String message) {
-        super(message);
-    }
-
-    /**
-     * Constructs a new UnresolveableReferenceException.
-     *
-     * @param cause the underlying Throwable that caused this exception to be thrown.
-     */
-    public UnresolveableReferenceException(Throwable cause) {
-        super(cause);
-    }
-
-    /**
-     * Constructs a new UnresolveableReferenceException.
-     *
-     * @param message the reason for the exception
-     * @param cause   the underlying Throwable that caused this exception to be thrown.
-     */
-    public UnresolveableReferenceException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+/**
+ * Exception thrown when a reference to an object is made, but that object cannot be found.  This is most likely
+ * thrown due to a configuration line that references an object that hasn't been defined yet.
+ *
+ * @author Les Hazlewood
+ * @since 0.9 RC2
+ */
+public class UnresolveableReferenceException extends ConfigurationException {
+
+    /**
+     * Creates a new UnresolveableReferenceException.
+     */
+    public UnresolveableReferenceException() {
+        super();
+    }
+
+    /**
+     * Constructs a new UnresolveableReferenceException.
+     *
+     * @param message the reason for the exception
+     */
+    public UnresolveableReferenceException(String message) {
+        super(message);
+    }
+
+    /**
+     * Constructs a new UnresolveableReferenceException.
+     *
+     * @param cause the underlying Throwable that caused this exception to be thrown.
+     */
+    public UnresolveableReferenceException(Throwable cause) {
+        super(cause);
+    }
+
+    /**
+     * Constructs a new UnresolveableReferenceException.
+     *
+     * @param message the reason for the exception
+     * @param cause   the underlying Throwable that caused this exception to be thrown.
+     */
+    public UnresolveableReferenceException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/jndi/JndiCallback.java b/core/src/main/java/org/apache/shiro/jndi/JndiCallback.java
index e6d911c60..e9ebb65d3 100644
--- a/core/src/main/java/org/apache/shiro/jndi/JndiCallback.java
+++ b/core/src/main/java/org/apache/shiro/jndi/JndiCallback.java
@@ -1,55 +1,55 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.jndi;
-
-import javax.naming.Context;
-import javax.naming.NamingException;
-
-/**
- * Callback interface to be implemented by classes that need to perform an
- * operation (such as a lookup) in a JNDI context. This callback approach
- * is valuable in simplifying error handling, which is performed by the
- * JndiTemplate class. This is a similar to JdbcTemplate's approach.
- *
- * <p>Note that there is hardly any need to implement this callback
- * interface, as JndiTemplate provides all usual JNDI operations via
- * convenience methods.
- *
- * <p>Note that this interface is an exact copy of the Spring Framework's identically named interface from
- * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
- * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
- * Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
- *
- * @author Rod Johnson
- * @see JndiTemplate
- */
-public interface JndiCallback {
-
-    /**
-     * Do something with the given JNDI context.
-     * Implementations don't need to worry about error handling
-     * or cleanup, as the JndiTemplate class will handle this.
-     *
-     * @param ctx the current JNDI context
-     * @return a result object, or <code>null</code>
-     * @throws NamingException if thrown by JNDI methods
-     */
-    Object doInContext(Context ctx) throws NamingException;
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.jndi;
+
+import javax.naming.Context;
+import javax.naming.NamingException;
+
+/**
+ * Callback interface to be implemented by classes that need to perform an
+ * operation (such as a lookup) in a JNDI context. This callback approach
+ * is valuable in simplifying error handling, which is performed by the
+ * JndiTemplate class. This is a similar to JdbcTemplate's approach.
+ *
+ * <p>Note that there is hardly any need to implement this callback
+ * interface, as JndiTemplate provides all usual JNDI operations via
+ * convenience methods.
+ *
+ * <p>Note that this interface is an exact copy of the Spring Framework's identically named interface from
+ * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
+ * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
+ * Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
+ *
+ * @author Rod Johnson
+ * @see JndiTemplate
+ */
+public interface JndiCallback {
+
+    /**
+     * Do something with the given JNDI context.
+     * Implementations don't need to worry about error handling
+     * or cleanup, as the JndiTemplate class will handle this.
+     *
+     * @param ctx the current JNDI context
+     * @return a result object, or <code>null</code>
+     * @throws NamingException if thrown by JNDI methods
+     */
+    Object doInContext(Context ctx) throws NamingException;
+
+}
diff --git a/core/src/main/java/org/apache/shiro/jndi/JndiLocator.java b/core/src/main/java/org/apache/shiro/jndi/JndiLocator.java
index cef9159a5..425934326 100644
--- a/core/src/main/java/org/apache/shiro/jndi/JndiLocator.java
+++ b/core/src/main/java/org/apache/shiro/jndi/JndiLocator.java
@@ -1,180 +1,180 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.jndi;
-
-import java.util.Properties;
-import javax.naming.NamingException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Convenient superclass for JNDI accessors, providing "jndiTemplate"
- * and "jndiEnvironment" bean properties.
- *
- * <p>Note that this implementation is an almost exact combined copy of the Spring Framework's 'JndiAccessor' and
- * 'JndiLocatorSupport' classes from their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require
- * a full dependency on the Spring framework, nor does Spring make available only its JNDI classes in a small jar, or
- * we would have used that. Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and
- * authors have remained in tact.
- *
- * @author Juergen Hoeller
- * @see #setJndiTemplate
- * @see #setJndiEnvironment
- * @see #setResourceRef
- * @since 1.1
- */
-public class JndiLocator {
-
-    /**
-     * Private class log.
-     */
-    private static final Logger log = LoggerFactory.getLogger(JndiLocator.class);
-
-    /**
-     * JNDI prefix used in a J2EE container
-     */
-    public static final String CONTAINER_PREFIX = "java:comp/env/";
-
-    private boolean resourceRef = false;
-
-    private JndiTemplate jndiTemplate = new JndiTemplate();
-
-
-    /**
-     * Set the JNDI template to use for JNDI lookups.
-     * <p>You can also specify JNDI environment settings via "jndiEnvironment".
-     *
-     * @see #setJndiEnvironment
-     */
-    public void setJndiTemplate(JndiTemplate jndiTemplate) {
-        this.jndiTemplate = (jndiTemplate != null ? jndiTemplate : new JndiTemplate());
-    }
-
-    /**
-     * Return the JNDI template to use for JNDI lookups.
-     */
-    public JndiTemplate getJndiTemplate() {
-        return this.jndiTemplate;
-    }
-
-    /**
-     * Set the JNDI environment to use for JNDI lookups.
-     * <p>Creates a JndiTemplate with the given environment settings.
-     *
-     * @see #setJndiTemplate
-     */
-    public void setJndiEnvironment(Properties jndiEnvironment) {
-        this.jndiTemplate = new JndiTemplate(jndiEnvironment);
-    }
-
-    /**
-     * Return the JNDI environment to use for JNDI lookups.
-     */
-    public Properties getJndiEnvironment() {
-        return this.jndiTemplate.getEnvironment();
-    }
-
-    /**
-     * Set whether the lookup occurs in a J2EE container, i.e. if the prefix
-     * "java:comp/env/" needs to be added if the JNDI name doesn't already
-     * contain it. Default is "false".
-     * <p>Note: Will only get applied if no other scheme (e.g. "java:") is given.
-     */
-    public void setResourceRef(boolean resourceRef) {
-        this.resourceRef = resourceRef;
-    }
-
-    /**
-     * Return whether the lookup occurs in a J2EE container.
-     */
-    public boolean isResourceRef() {
-        return this.resourceRef;
-    }
-
-
-    /**
-     * Perform an actual JNDI lookup for the given name via the JndiTemplate.
-     * <p>If the name doesn't begin with "java:comp/env/", this prefix is added
-     * if "resourceRef" is set to "true".
-     *
-     * @param jndiName the JNDI name to look up
-     * @return the obtained object
-     * @throws javax.naming.NamingException if the JNDI lookup failed
-     * @see #setResourceRef
-     */
-    protected Object lookup(String jndiName) throws NamingException {
-        return lookup(jndiName, null);
-    }
-
-    /**
-     * Perform an actual JNDI lookup for the given name via the JndiTemplate.
-     * <p>If the name doesn't begin with "java:comp/env/", this prefix is added
-     * if "resourceRef" is set to "true".
-     *
-     * @param jndiName     the JNDI name to look up
-     * @param requiredType the required type of the object
-     * @return the obtained object
-     * @throws NamingException if the JNDI lookup failed
-     * @see #setResourceRef
-     */
-    protected Object lookup(String jndiName, Class requiredType) throws NamingException {
-        if (jndiName == null) {
-            throw new IllegalArgumentException("jndiName argument must not be null");
-        }
-        String convertedName = convertJndiName(jndiName);
-        Object jndiObject;
-        try {
-            jndiObject = getJndiTemplate().lookup(convertedName, requiredType);
-        }
-        catch (NamingException ex) {
-            if (!convertedName.equals(jndiName)) {
-                // Try fallback to originally specified name...
-                if (log.isDebugEnabled()) {
-                    log.debug("Converted JNDI name [" + convertedName +
-                            "] not found - trying original name [" + jndiName + "]. " + ex);
-                }
-                jndiObject = getJndiTemplate().lookup(jndiName, requiredType);
-            } else {
-                throw ex;
-            }
-        }
-        log.debug("Located object with JNDI name '{}'", convertedName);
-        return jndiObject;
-    }
-
-    /**
-     * Convert the given JNDI name into the actual JNDI name to use.
-     * <p>The default implementation applies the "java:comp/env/" prefix if
-     * "resourceRef" is "true" and no other scheme (e.g. "java:") is given.
-     *
-     * @param jndiName the original JNDI name
-     * @return the JNDI name to use
-     * @see #CONTAINER_PREFIX
-     * @see #setResourceRef
-     */
-    protected String convertJndiName(String jndiName) {
-        // Prepend container prefix if not already specified and no other scheme given.
-        if (isResourceRef() && !jndiName.startsWith(CONTAINER_PREFIX) && jndiName.indexOf(':') == -1) {
-            jndiName = CONTAINER_PREFIX + jndiName;
-        }
-        return jndiName;
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.jndi;
+
+import java.util.Properties;
+import javax.naming.NamingException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Convenient superclass for JNDI accessors, providing "jndiTemplate"
+ * and "jndiEnvironment" bean properties.
+ *
+ * <p>Note that this implementation is an almost exact combined copy of the Spring Framework's 'JndiAccessor' and
+ * 'JndiLocatorSupport' classes from their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require
+ * a full dependency on the Spring framework, nor does Spring make available only its JNDI classes in a small jar, or
+ * we would have used that. Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and
+ * authors have remained in tact.
+ *
+ * @author Juergen Hoeller
+ * @see #setJndiTemplate
+ * @see #setJndiEnvironment
+ * @see #setResourceRef
+ * @since 1.1
+ */
+public class JndiLocator {
+
+    /**
+     * Private class log.
+     */
+    private static final Logger log = LoggerFactory.getLogger(JndiLocator.class);
+
+    /**
+     * JNDI prefix used in a J2EE container
+     */
+    public static final String CONTAINER_PREFIX = "java:comp/env/";
+
+    private boolean resourceRef = false;
+
+    private JndiTemplate jndiTemplate = new JndiTemplate();
+
+
+    /**
+     * Set the JNDI template to use for JNDI lookups.
+     * <p>You can also specify JNDI environment settings via "jndiEnvironment".
+     *
+     * @see #setJndiEnvironment
+     */
+    public void setJndiTemplate(JndiTemplate jndiTemplate) {
+        this.jndiTemplate = (jndiTemplate != null ? jndiTemplate : new JndiTemplate());
+    }
+
+    /**
+     * Return the JNDI template to use for JNDI lookups.
+     */
+    public JndiTemplate getJndiTemplate() {
+        return this.jndiTemplate;
+    }
+
+    /**
+     * Set the JNDI environment to use for JNDI lookups.
+     * <p>Creates a JndiTemplate with the given environment settings.
+     *
+     * @see #setJndiTemplate
+     */
+    public void setJndiEnvironment(Properties jndiEnvironment) {
+        this.jndiTemplate = new JndiTemplate(jndiEnvironment);
+    }
+
+    /**
+     * Return the JNDI environment to use for JNDI lookups.
+     */
+    public Properties getJndiEnvironment() {
+        return this.jndiTemplate.getEnvironment();
+    }
+
+    /**
+     * Set whether the lookup occurs in a J2EE container, i.e. if the prefix
+     * "java:comp/env/" needs to be added if the JNDI name doesn't already
+     * contain it. Default is "false".
+     * <p>Note: Will only get applied if no other scheme (e.g. "java:") is given.
+     */
+    public void setResourceRef(boolean resourceRef) {
+        this.resourceRef = resourceRef;
+    }
+
+    /**
+     * Return whether the lookup occurs in a J2EE container.
+     */
+    public boolean isResourceRef() {
+        return this.resourceRef;
+    }
+
+
+    /**
+     * Perform an actual JNDI lookup for the given name via the JndiTemplate.
+     * <p>If the name doesn't begin with "java:comp/env/", this prefix is added
+     * if "resourceRef" is set to "true".
+     *
+     * @param jndiName the JNDI name to look up
+     * @return the obtained object
+     * @throws javax.naming.NamingException if the JNDI lookup failed
+     * @see #setResourceRef
+     */
+    protected Object lookup(String jndiName) throws NamingException {
+        return lookup(jndiName, null);
+    }
+
+    /**
+     * Perform an actual JNDI lookup for the given name via the JndiTemplate.
+     * <p>If the name doesn't begin with "java:comp/env/", this prefix is added
+     * if "resourceRef" is set to "true".
+     *
+     * @param jndiName     the JNDI name to look up
+     * @param requiredType the required type of the object
+     * @return the obtained object
+     * @throws NamingException if the JNDI lookup failed
+     * @see #setResourceRef
+     */
+    protected Object lookup(String jndiName, Class requiredType) throws NamingException {
+        if (jndiName == null) {
+            throw new IllegalArgumentException("jndiName argument must not be null");
+        }
+        String convertedName = convertJndiName(jndiName);
+        Object jndiObject;
+        try {
+            jndiObject = getJndiTemplate().lookup(convertedName, requiredType);
+        }
+        catch (NamingException ex) {
+            if (!convertedName.equals(jndiName)) {
+                // Try fallback to originally specified name...
+                if (log.isDebugEnabled()) {
+                    log.debug("Converted JNDI name [" + convertedName +
+                            "] not found - trying original name [" + jndiName + "]. " + ex);
+                }
+                jndiObject = getJndiTemplate().lookup(jndiName, requiredType);
+            } else {
+                throw ex;
+            }
+        }
+        log.debug("Located object with JNDI name '{}'", convertedName);
+        return jndiObject;
+    }
+
+    /**
+     * Convert the given JNDI name into the actual JNDI name to use.
+     * <p>The default implementation applies the "java:comp/env/" prefix if
+     * "resourceRef" is "true" and no other scheme (e.g. "java:") is given.
+     *
+     * @param jndiName the original JNDI name
+     * @return the JNDI name to use
+     * @see #CONTAINER_PREFIX
+     * @see #setResourceRef
+     */
+    protected String convertJndiName(String jndiName) {
+        // Prepend container prefix if not already specified and no other scheme given.
+        if (isResourceRef() && !jndiName.startsWith(CONTAINER_PREFIX) && jndiName.indexOf(':') == -1) {
+            jndiName = CONTAINER_PREFIX + jndiName;
+        }
+        return jndiName;
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/jndi/JndiTemplate.java b/core/src/main/java/org/apache/shiro/jndi/JndiTemplate.java
index c921d7f93..bee5b53c6 100644
--- a/core/src/main/java/org/apache/shiro/jndi/JndiTemplate.java
+++ b/core/src/main/java/org/apache/shiro/jndi/JndiTemplate.java
@@ -1,226 +1,226 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.jndi;
-
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.Properties;
-import javax.naming.Context;
-import javax.naming.InitialContext;
-import javax.naming.NameNotFoundException;
-import javax.naming.NamingException;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Helper class that simplifies JNDI operations. It provides methods to lookup and
- * bind objects, and allows implementations of the {@link JndiCallback} interface
- * to perform any operation they like with a JNDI naming context provided.
- * <p/>
- * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from
- * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
- * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
- * Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
- *
- * @author Rod Johnson
- * @author Juergen Hoeller
- * @see JndiCallback
- * @see #execute
- */
-public class JndiTemplate {
-
-    private static final Logger log = LoggerFactory.getLogger(JndiTemplate.class);
-
-    private Properties environment;
-
-    /** Create a new JndiTemplate instance. */
-    public JndiTemplate() {
-    }
-
-    /**
-     * Create a new JndiTemplate instance, using the given environment.
-     *
-     * @param environment the Properties to initialize with
-     */
-    public JndiTemplate(Properties environment) {
-        this.environment = environment;
-    }
-
-    /**
-     * Set the environment for the JNDI InitialContext.
-     *
-     * @param environment the Properties to initialize with
-     */
-    public void setEnvironment(Properties environment) {
-        this.environment = environment;
-    }
-
-    /**
-     * Return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.
-     *
-     * @return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.
-     */
-    public Properties getEnvironment() {
-        return this.environment;
-    }
-
-    /**
-     * Execute the given JNDI context callback implementation.
-     *
-     * @param contextCallback JndiCallback implementation
-     * @return a result object returned by the callback, or <code>null</code>
-     * @throws NamingException thrown by the callback implementation
-     * @see #createInitialContext
-     */
-    public Object execute(JndiCallback contextCallback) throws NamingException {
-        Context ctx = createInitialContext();
-        try {
-            return contextCallback.doInContext(ctx);
-        }
-        finally {
-            try {
-                ctx.close();
-            } catch (NamingException ex) {
-                log.debug("Could not close JNDI InitialContext", ex);
-            }
-        }
-    }
-
-    /**
-     * Create a new JNDI initial context. Invoked by {@link #execute}.
-     * <p>The default implementation use this template's environment settings.
-     * Can be subclassed for custom contexts, e.g. for testing.
-     *
-     * @return the initial Context instance
-     * @throws NamingException in case of initialization errors
-     */
-    @SuppressWarnings({"unchecked"})
-    protected Context createInitialContext() throws NamingException {
-        Properties env = getEnvironment();
-        Hashtable icEnv = null;
-        if (env != null) {
-            icEnv = new Hashtable(env.size());
-            for (Enumeration en = env.propertyNames(); en.hasMoreElements();) {
-                String key = (String) en.nextElement();
-                icEnv.put(key, env.getProperty(key));
-            }
-        }
-        return new InitialContext(icEnv);
-    }
-
-    /**
-     * Look up the object with the given name in the current JNDI context.
-     *
-     * @param name the JNDI name of the object
-     * @return object found (cannot be <code>null</code>; if a not so well-behaved
-     *         JNDI implementations returns null, a NamingException gets thrown)
-     * @throws NamingException if there is no object with the given
-     *                         name bound to JNDI
-     */
-    public Object lookup(final String name) throws NamingException {
-        log.debug("Looking up JNDI object with name '{}'", name);
-        return execute(new JndiCallback() {
-            public Object doInContext(Context ctx) throws NamingException {
-                Object located = ctx.lookup(name);
-                if (located == null) {
-                    throw new NameNotFoundException(
-                            "JNDI object with [" + name + "] not found: JNDI implementation returned null");
-                }
-                return located;
-            }
-        });
-    }
-
-    /**
-     * Look up the object with the given name in the current JNDI context.
-     *
-     * @param name         the JNDI name of the object
-     * @param requiredType type the JNDI object must match. Can be an interface or
-     *                     superclass of the actual class, or <code>null</code> for any match. For example,
-     *                     if the value is <code>Object.class</code>, this method will succeed whatever
-     *                     the class of the returned instance.
-     * @return object found (cannot be <code>null</code>; if a not so well-behaved
-     *         JNDI implementations returns null, a NamingException gets thrown)
-     * @throws NamingException if there is no object with the given
-     *                         name bound to JNDI
-     */
-    public Object lookup(String name, Class requiredType) throws NamingException {
-        Object jndiObject = lookup(name);
-        if (requiredType != null && !requiredType.isInstance(jndiObject)) {
-            String msg = "Jndi object acquired under name '" + name + "' is of type [" +
-                    jndiObject.getClass().getName() + "] and not assignable to the required type [" +
-                    requiredType.getName() + "].";
-            throw new NamingException(msg);
-        }
-        return jndiObject;
-    }
-
-    /**
-     * Bind the given object to the current JNDI context, using the given name.
-     *
-     * @param name   the JNDI name of the object
-     * @param object the object to bind
-     * @throws NamingException thrown by JNDI, mostly name already bound
-     */
-    public void bind(final String name, final Object object) throws NamingException {
-        log.debug("Binding JNDI object with name '{}'", name);
-        execute(new JndiCallback() {
-            public Object doInContext(Context ctx) throws NamingException {
-                ctx.bind(name, object);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Rebind the given object to the current JNDI context, using the given name.
-     * Overwrites any existing binding.
-     *
-     * @param name   the JNDI name of the object
-     * @param object the object to rebind
-     * @throws NamingException thrown by JNDI
-     */
-    public void rebind(final String name, final Object object) throws NamingException {
-        log.debug("Rebinding JNDI object with name '{}'", name);
-        execute(new JndiCallback() {
-            public Object doInContext(Context ctx) throws NamingException {
-                ctx.rebind(name, object);
-                return null;
-            }
-        });
-    }
-
-    /**
-     * Remove the binding for the given name from the current JNDI context.
-     *
-     * @param name the JNDI name of the object
-     * @throws NamingException thrown by JNDI, mostly name not found
-     */
-    public void unbind(final String name) throws NamingException {
-        log.debug("Unbinding JNDI object with name '{}'", name);
-        execute(new JndiCallback() {
-            public Object doInContext(Context ctx) throws NamingException {
-                ctx.unbind(name);
-                return null;
-            }
-        });
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.jndi;
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Properties;
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.NameNotFoundException;
+import javax.naming.NamingException;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Helper class that simplifies JNDI operations. It provides methods to lookup and
+ * bind objects, and allows implementations of the {@link JndiCallback} interface
+ * to perform any operation they like with a JNDI naming context provided.
+ * <p/>
+ * <p>Note that this implementation is an almost exact copy of the Spring Framework's identically named class from
+ * their 2.5.4 distribution - we didn't want to re-invent the wheel, but not require a full dependency on the
+ * Spring framework, nor does Spring make available only its JNDI classes in a small jar, or we would have used that.
+ * Since Shiro is also Apache 2.0 licensed, all regular licenses and conditions and authors have remained in tact.
+ *
+ * @author Rod Johnson
+ * @author Juergen Hoeller
+ * @see JndiCallback
+ * @see #execute
+ */
+public class JndiTemplate {
+
+    private static final Logger log = LoggerFactory.getLogger(JndiTemplate.class);
+
+    private Properties environment;
+
+    /** Create a new JndiTemplate instance. */
+    public JndiTemplate() {
+    }
+
+    /**
+     * Create a new JndiTemplate instance, using the given environment.
+     *
+     * @param environment the Properties to initialize with
+     */
+    public JndiTemplate(Properties environment) {
+        this.environment = environment;
+    }
+
+    /**
+     * Set the environment for the JNDI InitialContext.
+     *
+     * @param environment the Properties to initialize with
+     */
+    public void setEnvironment(Properties environment) {
+        this.environment = environment;
+    }
+
+    /**
+     * Return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.
+     *
+     * @return the environment for the JNDI InitialContext, or <code>null</code> if none should be used.
+     */
+    public Properties getEnvironment() {
+        return this.environment;
+    }
+
+    /**
+     * Execute the given JNDI context callback implementation.
+     *
+     * @param contextCallback JndiCallback implementation
+     * @return a result object returned by the callback, or <code>null</code>
+     * @throws NamingException thrown by the callback implementation
+     * @see #createInitialContext
+     */
+    public Object execute(JndiCallback contextCallback) throws NamingException {
+        Context ctx = createInitialContext();
+        try {
+            return contextCallback.doInContext(ctx);
+        }
+        finally {
+            try {
+                ctx.close();
+            } catch (NamingException ex) {
+                log.debug("Could not close JNDI InitialContext", ex);
+            }
+        }
+    }
+
+    /**
+     * Create a new JNDI initial context. Invoked by {@link #execute}.
+     * <p>The default implementation use this template's environment settings.
+     * Can be subclassed for custom contexts, e.g. for testing.
+     *
+     * @return the initial Context instance
+     * @throws NamingException in case of initialization errors
+     */
+    @SuppressWarnings({"unchecked"})
+    protected Context createInitialContext() throws NamingException {
+        Properties env = getEnvironment();
+        Hashtable icEnv = null;
+        if (env != null) {
+            icEnv = new Hashtable(env.size());
+            for (Enumeration en = env.propertyNames(); en.hasMoreElements();) {
+                String key = (String) en.nextElement();
+                icEnv.put(key, env.getProperty(key));
+            }
+        }
+        return new InitialContext(icEnv);
+    }
+
+    /**
+     * Look up the object with the given name in the current JNDI context.
+     *
+     * @param name the JNDI name of the object
+     * @return object found (cannot be <code>null</code>; if a not so well-behaved
+     *         JNDI implementations returns null, a NamingException gets thrown)
+     * @throws NamingException if there is no object with the given
+     *                         name bound to JNDI
+     */
+    public Object lookup(final String name) throws NamingException {
+        log.debug("Looking up JNDI object with name '{}'", name);
+        return execute(new JndiCallback() {
+            public Object doInContext(Context ctx) throws NamingException {
+                Object located = ctx.lookup(name);
+                if (located == null) {
+                    throw new NameNotFoundException(
+                            "JNDI object with [" + name + "] not found: JNDI implementation returned null");
+                }
+                return located;
+            }
+        });
+    }
+
+    /**
+     * Look up the object with the given name in the current JNDI context.
+     *
+     * @param name         the JNDI name of the object
+     * @param requiredType type the JNDI object must match. Can be an interface or
+     *                     superclass of the actual class, or <code>null</code> for any match. For example,
+     *                     if the value is <code>Object.class</code>, this method will succeed whatever
+     *                     the class of the returned instance.
+     * @return object found (cannot be <code>null</code>; if a not so well-behaved
+     *         JNDI implementations returns null, a NamingException gets thrown)
+     * @throws NamingException if there is no object with the given
+     *                         name bound to JNDI
+     */
+    public Object lookup(String name, Class requiredType) throws NamingException {
+        Object jndiObject = lookup(name);
+        if (requiredType != null && !requiredType.isInstance(jndiObject)) {
+            String msg = "Jndi object acquired under name '" + name + "' is of type [" +
+                    jndiObject.getClass().getName() + "] and not assignable to the required type [" +
+                    requiredType.getName() + "].";
+            throw new NamingException(msg);
+        }
+        return jndiObject;
+    }
+
+    /**
+     * Bind the given object to the current JNDI context, using the given name.
+     *
+     * @param name   the JNDI name of the object
+     * @param object the object to bind
+     * @throws NamingException thrown by JNDI, mostly name already bound
+     */
+    public void bind(final String name, final Object object) throws NamingException {
+        log.debug("Binding JNDI object with name '{}'", name);
+        execute(new JndiCallback() {
+            public Object doInContext(Context ctx) throws NamingException {
+                ctx.bind(name, object);
+                return null;
+            }
+        });
+    }
+
+    /**
+     * Rebind the given object to the current JNDI context, using the given name.
+     * Overwrites any existing binding.
+     *
+     * @param name   the JNDI name of the object
+     * @param object the object to rebind
+     * @throws NamingException thrown by JNDI
+     */
+    public void rebind(final String name, final Object object) throws NamingException {
+        log.debug("Rebinding JNDI object with name '{}'", name);
+        execute(new JndiCallback() {
+            public Object doInContext(Context ctx) throws NamingException {
+                ctx.rebind(name, object);
+                return null;
+            }
+        });
+    }
+
+    /**
+     * Remove the binding for the given name from the current JNDI context.
+     *
+     * @param name the JNDI name of the object
+     * @throws NamingException thrown by JNDI, mostly name not found
+     */
+    public void unbind(final String name) throws NamingException {
+        log.debug("Unbinding JNDI object with name '{}'", name);
+        execute(new JndiCallback() {
+            public Object doInContext(Context ctx) throws NamingException {
+                ctx.unbind(name);
+                return null;
+            }
+        });
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/realm/text/IniRealm.java b/core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
index 1057aaf02..b53699490 100644
--- a/core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
+++ b/core/src/main/java/org/apache/shiro/realm/text/IniRealm.java
@@ -1,122 +1,122 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.realm.text;
-
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * A {@link org.apache.shiro.realm.Realm Realm} implementation that creates
- * {@link org.apache.shiro.authc.SimpleAccount SimpleAccount} instances based on
- * {@link Ini} configuration.
- * <p/>
- * This implementation looks for two {@link Ini.Section sections} in the {@code Ini} configuration:
- * <pre>
- * [users]
- * # One or more {@link org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions(String) user definitions}
- * ...
- * [roles]
- * # One or more {@link org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions(String) role definitions}</pre>
- * <p/>
- * This class also supports setting the {@link #setResourcePath(String) resourcePath} property to create account
- * data from an .ini resource.  This will only be used if there isn't already account data in the Realm.
- *
- * @since 1.0
- */
-public class IniRealm extends TextConfigurationRealm {
-
-    public static final String USERS_SECTION_NAME = "users";
-    public static final String ROLES_SECTION_NAME = "roles";
-
-    private static transient final Logger log = LoggerFactory.getLogger(IniRealm.class);
-
-    private String resourcePath;
-
-    public IniRealm() {
-        super();
-    }
-
-    public IniRealm(Ini ini) {
-        this();
-        processDefinitions(ini);
-    }
-
-    public IniRealm(String resourcePath) {
-        this();
-        Ini ini = Ini.fromResourcePath(resourcePath);
-        this.resourcePath = resourcePath;
-        processDefinitions(ini);
-    }
-
-    public String getResourcePath() {
-        return resourcePath;
-    }
-
-    public void setResourcePath(String resourcePath) {
-        this.resourcePath = resourcePath;
-    }
-
-    @Override
-    protected void onInit() {
-        // This is an in-memory realm only - no need for an additional cache when we're already
-        // as memory-efficient as we can be.
-        String resourcePath = getResourcePath();
-
-        if (CollectionUtils.isEmpty(this.users) && CollectionUtils.isEmpty(this.roles)) {
-            //no account data manually populated - try the resource path:
-            if (StringUtils.hasText(resourcePath)) {
-                log.debug("Resource path {} defined.  Creating INI instance.", resourcePath);
-                Ini ini = Ini.fromResourcePath(resourcePath);
-                processDefinitions(ini);
-            } else {
-                throw new IllegalStateException("No resource path was specified.  Cannot load account data.");
-            }
-        } else {
-            if (StringUtils.hasText(resourcePath)) {
-                log.warn("Users or Roles are already populated.  Resource path property will be ignored.");
-            }
-        }
-    }
-
-    private void processDefinitions(Ini ini) {
-        if (CollectionUtils.isEmpty(ini)) {
-            log.warn("{} defined, but the ini instance is null or empty.", getClass().getSimpleName());
-            return;
-        }
-
-        Ini.Section rolesSection = ini.getSection(ROLES_SECTION_NAME);
-        if (!CollectionUtils.isEmpty(rolesSection)) {
-            log.debug("Discovered the [{}] section.  Processing...", ROLES_SECTION_NAME);
-            processRoleDefinitions(rolesSection);
-        }
-
-        Ini.Section usersSection = ini.getSection(USERS_SECTION_NAME);
-        if (!CollectionUtils.isEmpty(usersSection)) {
-            log.debug("Discovered the [{}] section.  Processing...", USERS_SECTION_NAME);
-            processUserDefinitions(usersSection);
-        } else {
-            log.info("{} defined, but there is no [{}] section defined.  This realm will not be populated with any " +
-                    "users and it is assumed that they will be populated programatically.  Users must be defined " +
-                    "for this Realm instance to be useful.", getClass().getSimpleName(), USERS_SECTION_NAME);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.realm.text;
+
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A {@link org.apache.shiro.realm.Realm Realm} implementation that creates
+ * {@link org.apache.shiro.authc.SimpleAccount SimpleAccount} instances based on
+ * {@link Ini} configuration.
+ * <p/>
+ * This implementation looks for two {@link Ini.Section sections} in the {@code Ini} configuration:
+ * <pre>
+ * [users]
+ * # One or more {@link org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions(String) user definitions}
+ * ...
+ * [roles]
+ * # One or more {@link org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions(String) role definitions}</pre>
+ * <p/>
+ * This class also supports setting the {@link #setResourcePath(String) resourcePath} property to create account
+ * data from an .ini resource.  This will only be used if there isn't already account data in the Realm.
+ *
+ * @since 1.0
+ */
+public class IniRealm extends TextConfigurationRealm {
+
+    public static final String USERS_SECTION_NAME = "users";
+    public static final String ROLES_SECTION_NAME = "roles";
+
+    private static transient final Logger log = LoggerFactory.getLogger(IniRealm.class);
+
+    private String resourcePath;
+
+    public IniRealm() {
+        super();
+    }
+
+    public IniRealm(Ini ini) {
+        this();
+        processDefinitions(ini);
+    }
+
+    public IniRealm(String resourcePath) {
+        this();
+        Ini ini = Ini.fromResourcePath(resourcePath);
+        this.resourcePath = resourcePath;
+        processDefinitions(ini);
+    }
+
+    public String getResourcePath() {
+        return resourcePath;
+    }
+
+    public void setResourcePath(String resourcePath) {
+        this.resourcePath = resourcePath;
+    }
+
+    @Override
+    protected void onInit() {
+        // This is an in-memory realm only - no need for an additional cache when we're already
+        // as memory-efficient as we can be.
+        String resourcePath = getResourcePath();
+
+        if (CollectionUtils.isEmpty(this.users) && CollectionUtils.isEmpty(this.roles)) {
+            //no account data manually populated - try the resource path:
+            if (StringUtils.hasText(resourcePath)) {
+                log.debug("Resource path {} defined.  Creating INI instance.", resourcePath);
+                Ini ini = Ini.fromResourcePath(resourcePath);
+                processDefinitions(ini);
+            } else {
+                throw new IllegalStateException("No resource path was specified.  Cannot load account data.");
+            }
+        } else {
+            if (StringUtils.hasText(resourcePath)) {
+                log.warn("Users or Roles are already populated.  Resource path property will be ignored.");
+            }
+        }
+    }
+
+    private void processDefinitions(Ini ini) {
+        if (CollectionUtils.isEmpty(ini)) {
+            log.warn("{} defined, but the ini instance is null or empty.", getClass().getSimpleName());
+            return;
+        }
+
+        Ini.Section rolesSection = ini.getSection(ROLES_SECTION_NAME);
+        if (!CollectionUtils.isEmpty(rolesSection)) {
+            log.debug("Discovered the [{}] section.  Processing...", ROLES_SECTION_NAME);
+            processRoleDefinitions(rolesSection);
+        }
+
+        Ini.Section usersSection = ini.getSection(USERS_SECTION_NAME);
+        if (!CollectionUtils.isEmpty(usersSection)) {
+            log.debug("Discovered the [{}] section.  Processing...", USERS_SECTION_NAME);
+            processUserDefinitions(usersSection);
+        } else {
+            log.info("{} defined, but there is no [{}] section defined.  This realm will not be populated with any " +
+                    "users and it is assumed that they will be populated programatically.  Users must be defined " +
+                    "for this Realm instance to be useful.", getClass().getSimpleName(), USERS_SECTION_NAME);
+        }
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/session/ProxiedSession.java b/core/src/main/java/org/apache/shiro/session/ProxiedSession.java
index 71c6f3307..e573f675b 100644
--- a/core/src/main/java/org/apache/shiro/session/ProxiedSession.java
+++ b/core/src/main/java/org/apache/shiro/session/ProxiedSession.java
@@ -1,139 +1,139 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session;
-
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Date;
-
-/**
- * Simple <code>Session</code> implementation that immediately delegates all corresponding calls to an
- * underlying proxied session instance.
- * <p/>
- * This class is mostly useful for framework subclassing to intercept certain <code>Session</code> calls
- * and perform additional logic.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public class ProxiedSession implements Session {
-
-    /**
-     * The proxied instance
-     */
-    protected final Session delegate;
-
-    /**
-     * Constructs an instance that proxies the specified <code>target</code>.  Subclasses may access this
-     * target via the <code>protected final 'delegate'</code> attribute, i.e. <code>this.delegate</code>.
-     *
-     * @param target the specified target <code>Session</code> to proxy.
-     */
-    public ProxiedSession(Session target) {
-        if (target == null) {
-            throw new IllegalArgumentException("Target session to proxy cannot be null.");
-        }
-        delegate = target;
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Serializable getId() {
-        return delegate.getId();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Date getStartTimestamp() {
-        return delegate.getStartTimestamp();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Date getLastAccessTime() {
-        return delegate.getLastAccessTime();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public long getTimeout() throws InvalidSessionException {
-        return delegate.getTimeout();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {
-        delegate.setTimeout(maxIdleTimeInMillis);
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public String getHost() {
-        return delegate.getHost();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public void touch() throws InvalidSessionException {
-        delegate.touch();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public void stop() throws InvalidSessionException {
-        delegate.stop();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Collection<Object> getAttributeKeys() throws InvalidSessionException {
-        return delegate.getAttributeKeys();
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Object getAttribute(Object key) throws InvalidSessionException {
-        return delegate.getAttribute(key);
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public void setAttribute(Object key, Object value) throws InvalidSessionException {
-        delegate.setAttribute(key, value);
-    }
-
-    /**
-     * Immediately delegates to the underlying proxied session.
-     */
-    public Object removeAttribute(Object key) throws InvalidSessionException {
-        return delegate.removeAttribute(key);
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.Date;
+
+/**
+ * Simple <code>Session</code> implementation that immediately delegates all corresponding calls to an
+ * underlying proxied session instance.
+ * <p/>
+ * This class is mostly useful for framework subclassing to intercept certain <code>Session</code> calls
+ * and perform additional logic.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public class ProxiedSession implements Session {
+
+    /**
+     * The proxied instance
+     */
+    protected final Session delegate;
+
+    /**
+     * Constructs an instance that proxies the specified <code>target</code>.  Subclasses may access this
+     * target via the <code>protected final 'delegate'</code> attribute, i.e. <code>this.delegate</code>.
+     *
+     * @param target the specified target <code>Session</code> to proxy.
+     */
+    public ProxiedSession(Session target) {
+        if (target == null) {
+            throw new IllegalArgumentException("Target session to proxy cannot be null.");
+        }
+        delegate = target;
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Serializable getId() {
+        return delegate.getId();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Date getStartTimestamp() {
+        return delegate.getStartTimestamp();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Date getLastAccessTime() {
+        return delegate.getLastAccessTime();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public long getTimeout() throws InvalidSessionException {
+        return delegate.getTimeout();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {
+        delegate.setTimeout(maxIdleTimeInMillis);
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public String getHost() {
+        return delegate.getHost();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public void touch() throws InvalidSessionException {
+        delegate.touch();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public void stop() throws InvalidSessionException {
+        delegate.stop();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Collection<Object> getAttributeKeys() throws InvalidSessionException {
+        return delegate.getAttributeKeys();
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Object getAttribute(Object key) throws InvalidSessionException {
+        return delegate.getAttribute(key);
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public void setAttribute(Object key, Object value) throws InvalidSessionException {
+        delegate.setAttribute(key, value);
+    }
+
+    /**
+     * Immediately delegates to the underlying proxied session.
+     */
+    public Object removeAttribute(Object key) throws InvalidSessionException {
+        return delegate.removeAttribute(key);
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/session/SessionListener.java b/core/src/main/java/org/apache/shiro/session/SessionListener.java
index 0cff0b04b..6964c3a5c 100644
--- a/core/src/main/java/org/apache/shiro/session/SessionListener.java
+++ b/core/src/main/java/org/apache/shiro/session/SessionListener.java
@@ -1,60 +1,60 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session;
-
-/**
- * Interface to be implemented by components that wish to be notified of events that occur during a
- * {@link Session Session}'s life cycle.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public interface SessionListener {
-
-    /**
-     * Notification callback that occurs when the corresponding Session has started.
-     *
-     * @param session the session that has started.
-     */
-    void onStart(Session session);
-
-    /**
-     * Notification callback that occurs when the corresponding Session has stopped, either programmatically via
-     * {@link Session#stop} or automatically upon a subject logging out.
-     *
-     * @param session the session that has stopped.
-     */
-    void onStop(Session session);
-
-    /**
-     * Notification callback that occurs when the corresponding Session has expired.
-     * <p/>
-     * <b>Note</b>: this method is almost never called at the exact instant that the {@code Session} expires.  Almost all
-     * session management systems, including Shiro's implementations, lazily validate sessions - either when they
-     * are accessed or during a regular validation interval.  It would be too resource intensive to monitor every
-     * single session instance to know the exact instant it expires.
-     * <p/>
-     * If you need to perform time-based logic when a session expires, it is best to write it based on the
-     * session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} and <em>not</em> the time
-     * when this method is called.
-     *
-     * @param session the session that has expired.
-     */
-    void onExpiration(Session session);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session;
+
+/**
+ * Interface to be implemented by components that wish to be notified of events that occur during a
+ * {@link Session Session}'s life cycle.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public interface SessionListener {
+
+    /**
+     * Notification callback that occurs when the corresponding Session has started.
+     *
+     * @param session the session that has started.
+     */
+    void onStart(Session session);
+
+    /**
+     * Notification callback that occurs when the corresponding Session has stopped, either programmatically via
+     * {@link Session#stop} or automatically upon a subject logging out.
+     *
+     * @param session the session that has stopped.
+     */
+    void onStop(Session session);
+
+    /**
+     * Notification callback that occurs when the corresponding Session has expired.
+     * <p/>
+     * <b>Note</b>: this method is almost never called at the exact instant that the {@code Session} expires.  Almost all
+     * session management systems, including Shiro's implementations, lazily validate sessions - either when they
+     * are accessed or during a regular validation interval.  It would be too resource intensive to monitor every
+     * single session instance to know the exact instant it expires.
+     * <p/>
+     * If you need to perform time-based logic when a session expires, it is best to write it based on the
+     * session's {@link org.apache.shiro.session.Session#getLastAccessTime() lastAccessTime} and <em>not</em> the time
+     * when this method is called.
+     *
+     * @param session the session that has expired.
+     */
+    void onExpiration(Session session);
+}
diff --git a/core/src/main/java/org/apache/shiro/session/SessionListenerAdapter.java b/core/src/main/java/org/apache/shiro/session/SessionListenerAdapter.java
index 01ad4bd57..24d58608e 100644
--- a/core/src/main/java/org/apache/shiro/session/SessionListenerAdapter.java
+++ b/core/src/main/java/org/apache/shiro/session/SessionListenerAdapter.java
@@ -1,55 +1,55 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session;
-
-/**
- * Simple adapter implementation of the {@link SessionListener} interface, effectively providing
- * no-op implementations of all methods.
- *
- * @since 1.0
- */
-public class SessionListenerAdapter implements SessionListener {
-
-    /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
-     *
-     * @param session the session that has started.
-     */
-    public void onStart(Session session) {
-        //no-op
-    }
-
-    /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
-     *
-     * @param session the session that has stopped.
-     */
-    public void onStop(Session session) {
-        //no-op
-    }
-
-    /**
-     * Adapter no-op implemenation - does nothing and returns immediately.
-     *
-     * @param session the session that has expired.
-     */
-    public void onExpiration(Session session) {
-        //no-op
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session;
+
+/**
+ * Simple adapter implementation of the {@link SessionListener} interface, effectively providing
+ * no-op implementations of all methods.
+ *
+ * @since 1.0
+ */
+public class SessionListenerAdapter implements SessionListener {
+
+    /**
+     * Adapter no-op implemenation - does nothing and returns immediately.
+     *
+     * @param session the session that has started.
+     */
+    public void onStart(Session session) {
+        //no-op
+    }
+
+    /**
+     * Adapter no-op implemenation - does nothing and returns immediately.
+     *
+     * @param session the session that has stopped.
+     */
+    public void onStop(Session session) {
+        //no-op
+    }
+
+    /**
+     * Adapter no-op implemenation - does nothing and returns immediately.
+     *
+     * @param session the session that has expired.
+     */
+    public void onExpiration(Session session) {
+        //no-op
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/session/mgt/ImmutableProxiedSession.java b/core/src/main/java/org/apache/shiro/session/mgt/ImmutableProxiedSession.java
index b37aa75f5..a0557e19a 100644
--- a/core/src/main/java/org/apache/shiro/session/mgt/ImmutableProxiedSession.java
+++ b/core/src/main/java/org/apache/shiro/session/mgt/ImmutableProxiedSession.java
@@ -1,108 +1,108 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.InvalidSessionException;
-import org.apache.shiro.session.ProxiedSession;
-import org.apache.shiro.session.Session;
-
-
-/**
- * Implementation of the {@link Session Session} interface that proxies another <code>Session</code>, but does not
- * allow any 'write' operations to the underlying session. It allows 'read' operations only.
- * <p/>
- * The <code>Session</code> write operations are defined as follows.  A call to any of these methods on this
- * proxy will immediately result in an {@link InvalidSessionException} being thrown:
- * <ul>
- * <li>{@link Session#setTimeout(long) Session.setTimeout(long)}</li>
- * <li>{@link Session#touch() Session.touch()}</li>
- * <li>{@link Session#stop() Session.stop()}</li>
- * <li>{@link Session#setAttribute(Object, Object) Session.setAttribute(key,value)}</li>
- * <li>{@link Session#removeAttribute(Object) Session.removeAttribute(key)}</li>
- * </ul>
- * Any other method invocation not listed above will result in a corresponding call to the underlying <code>Session</code>.
- *
- * @author Les Hazlewood
- * @since 0.9
- */
-public class ImmutableProxiedSession extends ProxiedSession {
-
-    /**
-     * Constructs a new instance of this class proxying the specified <code>Session</code>.
-     *
-     * @param target the target <code>Session</code> to proxy.
-     */
-    public ImmutableProxiedSession(Session target) {
-        super(target);
-    }
-
-    /**
-     * Simply throws an <code>InvalidSessionException</code> indicating that this proxy is immutable.  Used
-     * only in the Session's 'write' methods documented in the top class-level JavaDoc.
-     *
-     * @throws InvalidSessionException in all cases - used by the Session 'write' method implementations.
-     */
-    protected void throwImmutableException() throws InvalidSessionException {
-        String msg = "This session is immutable and read-only - it cannot be altered.  This is usually because " +
-                "the session has been stopped or expired already.";
-        throw new InvalidSessionException(msg);
-    }
-
-    /**
-     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
-     * cases because this proxy is immutable.
-     */
-    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {
-        throwImmutableException();
-    }
-
-    /**
-     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
-     * cases because this proxy is immutable.
-     */
-    public void touch() throws InvalidSessionException {
-        throwImmutableException();
-    }
-
-    /**
-     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
-     * cases because this proxy is immutable.
-     */
-    public void stop() throws InvalidSessionException {
-        throwImmutableException();
-    }
-
-    /**
-     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
-     * cases because this proxy is immutable.
-     */
-    public void setAttribute(Object key, Object value) throws InvalidSessionException {
-        throwImmutableException();
-    }
-
-    /**
-     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
-     * cases because this proxy is immutable.
-     */
-    public Object removeAttribute(Object key) throws InvalidSessionException {
-        throwImmutableException();
-        //we should never ever reach this point due to the exception being thrown.
-        throw new InternalError("This code should never execute - please report this as a bug!");
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.InvalidSessionException;
+import org.apache.shiro.session.ProxiedSession;
+import org.apache.shiro.session.Session;
+
+
+/**
+ * Implementation of the {@link Session Session} interface that proxies another <code>Session</code>, but does not
+ * allow any 'write' operations to the underlying session. It allows 'read' operations only.
+ * <p/>
+ * The <code>Session</code> write operations are defined as follows.  A call to any of these methods on this
+ * proxy will immediately result in an {@link InvalidSessionException} being thrown:
+ * <ul>
+ * <li>{@link Session#setTimeout(long) Session.setTimeout(long)}</li>
+ * <li>{@link Session#touch() Session.touch()}</li>
+ * <li>{@link Session#stop() Session.stop()}</li>
+ * <li>{@link Session#setAttribute(Object, Object) Session.setAttribute(key,value)}</li>
+ * <li>{@link Session#removeAttribute(Object) Session.removeAttribute(key)}</li>
+ * </ul>
+ * Any other method invocation not listed above will result in a corresponding call to the underlying <code>Session</code>.
+ *
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public class ImmutableProxiedSession extends ProxiedSession {
+
+    /**
+     * Constructs a new instance of this class proxying the specified <code>Session</code>.
+     *
+     * @param target the target <code>Session</code> to proxy.
+     */
+    public ImmutableProxiedSession(Session target) {
+        super(target);
+    }
+
+    /**
+     * Simply throws an <code>InvalidSessionException</code> indicating that this proxy is immutable.  Used
+     * only in the Session's 'write' methods documented in the top class-level JavaDoc.
+     *
+     * @throws InvalidSessionException in all cases - used by the Session 'write' method implementations.
+     */
+    protected void throwImmutableException() throws InvalidSessionException {
+        String msg = "This session is immutable and read-only - it cannot be altered.  This is usually because " +
+                "the session has been stopped or expired already.";
+        throw new InvalidSessionException(msg);
+    }
+
+    /**
+     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
+     * cases because this proxy is immutable.
+     */
+    public void setTimeout(long maxIdleTimeInMillis) throws InvalidSessionException {
+        throwImmutableException();
+    }
+
+    /**
+     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
+     * cases because this proxy is immutable.
+     */
+    public void touch() throws InvalidSessionException {
+        throwImmutableException();
+    }
+
+    /**
+     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
+     * cases because this proxy is immutable.
+     */
+    public void stop() throws InvalidSessionException {
+        throwImmutableException();
+    }
+
+    /**
+     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
+     * cases because this proxy is immutable.
+     */
+    public void setAttribute(Object key, Object value) throws InvalidSessionException {
+        throwImmutableException();
+    }
+
+    /**
+     * Immediately {@link #throwImmutableException() throws} an <code>InvalidSessionException</code> in all
+     * cases because this proxy is immutable.
+     */
+    public Object removeAttribute(Object key) throws InvalidSessionException {
+        throwImmutableException();
+        //we should never ever reach this point due to the exception being thrown.
+        throw new InternalError("This code should never execute - please report this as a bug!");
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/session/mgt/SessionFactory.java b/core/src/main/java/org/apache/shiro/session/mgt/SessionFactory.java
index 943ecf260..ebbc125a5 100644
--- a/core/src/main/java/org/apache/shiro/session/mgt/SessionFactory.java
+++ b/core/src/main/java/org/apache/shiro/session/mgt/SessionFactory.java
@@ -1,43 +1,43 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.Session;
-
-/**
- * A simple factory class that instantiates concrete {@link Session Session} instances.  This is mainly a
- * mechanism to allow instances to be created at runtime if they need to be different the
- * defaults.  It is not used by end-users of the framework, but rather those configuring Shiro to work in an
- * application, and is typically injected into the {@link org.apache.shiro.mgt.SecurityManager SecurityManager} or a
- * {@link SessionManager}.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public interface SessionFactory {
-
-    /**
-     * Creates a new {@code Session} instance based on the specified contextual initialization data.
-     *
-     * @param initData the initialization data to be used during {@link Session} creation.
-     * @return a new {@code Session} instance.
-     * @since 1.0
-     */
-    Session createSession(SessionContext initData);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.Session;
+
+/**
+ * A simple factory class that instantiates concrete {@link Session Session} instances.  This is mainly a
+ * mechanism to allow instances to be created at runtime if they need to be different the
+ * defaults.  It is not used by end-users of the framework, but rather those configuring Shiro to work in an
+ * application, and is typically injected into the {@link org.apache.shiro.mgt.SecurityManager SecurityManager} or a
+ * {@link SessionManager}.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public interface SessionFactory {
+
+    /**
+     * Creates a new {@code Session} instance based on the specified contextual initialization data.
+     *
+     * @param initData the initialization data to be used during {@link Session} creation.
+     * @return a new {@code Session} instance.
+     * @since 1.0
+     */
+    Session createSession(SessionContext initData);
+}
diff --git a/core/src/main/java/org/apache/shiro/session/mgt/SimpleSessionFactory.java b/core/src/main/java/org/apache/shiro/session/mgt/SimpleSessionFactory.java
index 9b8005807..7eda33f5d 100644
--- a/core/src/main/java/org/apache/shiro/session/mgt/SimpleSessionFactory.java
+++ b/core/src/main/java/org/apache/shiro/session/mgt/SimpleSessionFactory.java
@@ -1,47 +1,47 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.Session;
-
-/**
- * {@code SessionFactory} implementation that generates {@link SimpleSession} instances.
- *
- * @author Les Hazlewood
- * @since 1.0
- */
-public class SimpleSessionFactory implements SessionFactory {
-
-    /**
-     * Creates a new {@link SimpleSession SimpleSession} instance retaining the context's
-     * {@link SessionContext#getHost() host} if one can be found.
-     *
-     * @param initData the initialization data to be used during {@link Session} creation.
-     * @return a new {@link SimpleSession SimpleSession} instance
-     */
-    public Session createSession(SessionContext initData) {
-        if (initData != null) {
-            String host = initData.getHost();
-            if (host != null) {
-                return new SimpleSession(host);
-            }
-        }
-        return new SimpleSession();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.Session;
+
+/**
+ * {@code SessionFactory} implementation that generates {@link SimpleSession} instances.
+ *
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public class SimpleSessionFactory implements SessionFactory {
+
+    /**
+     * Creates a new {@link SimpleSession SimpleSession} instance retaining the context's
+     * {@link SessionContext#getHost() host} if one can be found.
+     *
+     * @param initData the initialization data to be used during {@link Session} creation.
+     * @return a new {@link SimpleSession SimpleSession} instance
+     */
+    public Session createSession(SessionContext initData) {
+        if (initData != null) {
+            String host = initData.getHost();
+            if (host != null) {
+                return new SimpleSession(host);
+            }
+        }
+        return new SimpleSession();
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/session/mgt/ValidatingSession.java b/core/src/main/java/org/apache/shiro/session/mgt/ValidatingSession.java
index 928ef502e..f5dd2d509 100644
--- a/core/src/main/java/org/apache/shiro/session/mgt/ValidatingSession.java
+++ b/core/src/main/java/org/apache/shiro/session/mgt/ValidatingSession.java
@@ -1,40 +1,40 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.InvalidSessionException;
-import org.apache.shiro.session.Session;
-
-
-/**
- * A <code>ValidatingSession</code> is a <code>Session</code> that is capable of determining it is valid or not and
- * is able to validate itself if necessary.
- * <p/>
- * Validation is usually an exercise of determining when the session was last accessed or modified and determining if
- * that time is longer than a specified allowed duration.
- * 
- * @author Les Hazlewood
- * @since 0.9
- */
-public interface ValidatingSession extends Session {
-
-    boolean isValid();
-
-    void validate() throws InvalidSessionException;
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.InvalidSessionException;
+import org.apache.shiro.session.Session;
+
+
+/**
+ * A <code>ValidatingSession</code> is a <code>Session</code> that is capable of determining it is valid or not and
+ * is able to validate itself if necessary.
+ * <p/>
+ * Validation is usually an exercise of determining when the session was last accessed or modified and determining if
+ * that time is longer than a specified allowed duration.
+ * 
+ * @author Les Hazlewood
+ * @since 0.9
+ */
+public interface ValidatingSession extends Session {
+
+    boolean isValid();
+
+    void validate() throws InvalidSessionException;
+}
diff --git a/core/src/main/java/org/apache/shiro/subject/ExecutionException.java b/core/src/main/java/org/apache/shiro/subject/ExecutionException.java
index 57f6a8807..e4898cabd 100644
--- a/core/src/main/java/org/apache/shiro/subject/ExecutionException.java
+++ b/core/src/main/java/org/apache/shiro/subject/ExecutionException.java
@@ -1,41 +1,41 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject;
-
-import org.apache.shiro.ShiroException;
-
-/**
- * Exception wrapping any potential checked exception thrown when a {@code Subject} executes a
- * {@link java.util.concurrent.Callable}.  This is a nicer alternative than forcing calling code to catch
- * a normal checked {@code Exception} when it may not be necessary.
- * <p/>
- * If thrown, the causing exception will always be accessible via the {@link #getCause() getCause()} method.
- *
- * @since 1.0
- */
-public class ExecutionException extends ShiroException {
-
-    public ExecutionException(Throwable cause) {
-        super(cause);
-    }
-
-    public ExecutionException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject;
+
+import org.apache.shiro.ShiroException;
+
+/**
+ * Exception wrapping any potential checked exception thrown when a {@code Subject} executes a
+ * {@link java.util.concurrent.Callable}.  This is a nicer alternative than forcing calling code to catch
+ * a normal checked {@code Exception} when it may not be necessary.
+ * <p/>
+ * If thrown, the causing exception will always be accessible via the {@link #getCause() getCause()} method.
+ *
+ * @since 1.0
+ */
+public class ExecutionException extends ShiroException {
+
+    public ExecutionException(Throwable cause) {
+        super(cause);
+    }
+
+    public ExecutionException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/subject/Subject.java b/core/src/main/java/org/apache/shiro/subject/Subject.java
index ff832e8b4..918832075 100644
--- a/core/src/main/java/org/apache/shiro/subject/Subject.java
+++ b/core/src/main/java/org/apache/shiro/subject/Subject.java
@@ -1,823 +1,823 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.authc.AuthenticationException;
-import org.apache.shiro.authc.AuthenticationToken;
-import org.apache.shiro.authz.AuthorizationException;
-import org.apache.shiro.authz.Permission;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.mgt.SubjectFactory;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.subject.support.DefaultSubjectContext;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.StringUtils;
-
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.Callable;
-
-/**
- * A {@code Subject} represents state and security operations for a <em>single</em> application user.
- * These operations include authentication (login/logout), authorization (access control), and
- * session access. It is Shiro's primary mechanism for single-user security functionality.
- * <h3>Acquiring a Subject</h3>
- * To acquire the currently-executing {@code Subject}, application developers will almost always use
- * {@code SecurityUtils}:
- * <pre>
- * {@link SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}</pre>
- * Almost all security operations should be performed with the {@code Subject} returned from this method.
- * <h3>Permission methods</h3>
- * Note that there are many *Permission methods in this interface overloaded to accept String arguments instead of
- * {@link Permission Permission} instances. They are a convenience allowing the caller to use a String representation of
- * a {@link Permission Permission} if desired.  The underlying Authorization subsystem implementations will usually
- * simply convert these String values to {@link Permission Permission} instances and then just call the corresponding
- * type-safe method.  (Shiro's default implementations do String-to-Permission conversion for these methods using
- * {@link org.apache.shiro.authz.permission.PermissionResolver PermissionResolver}s.)
- * <p/>
- * These overloaded *Permission methods forgo type-saftey for the benefit of convenience and simplicity,
- * so you should choose which ones to use based on your preferences and needs.
- *
- * @author Les Hazlewood
- * @author Jeremy Haile
- * @since 0.1
- */
-public interface Subject {
-
-    /**
-     * Returns this Subject's application-wide uniquely identifying principal, or {@code null} if this
-     * Subject is anonymous because it doesn't yet have any associated account data (for example,
-     * if they haven't logged in).
-     * <p/>
-     * The term <em>principal</em> is just a fancy security term for any identifying attribute(s) of an application
-     * user, such as a username, or user id, or public key, or anything else you might use in your application to
-     * identify a user.
-     * <h4>Uniqueness</h4>
-     * Although given names and family names (first/last) are technically considered principals as well,
-     * Shiro expects the object returned from this method to be an identifying attribute unique across
-     * your entire application.
-     * <p/>
-     * This implies that things like given names and family names are usually poor
-     * candidates as return values since they are rarely guaranteed to be unique;  Things often used for this value:
-     * <ul>
-     * <li>A {@code long} RDBMS surrogate primary key</li>
-     * <li>An application-unique username</li>
-     * <li>A {@link java.util.UUID UUID}</li>
-     * <li>An LDAP Unique ID</li>
-     * </ul>
-     * or any other similar suitable unique mechanism valuable to your application.
-     * <p/>
-     * Most implementations will simply return
-     * <code>{@link #getPrincipals()}.{@link org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal() getPrimaryPrincipal()}</code>
-     *
-     * @return this Subject's application-specific unique identity.
-     * @see org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()
-     */
-    Object getPrincipal();
-
-    /**
-     * Returns this Subject's principals (identifying attributes) in the form of a {@code PrincipalCollection} or
-     * {@code null} if this Subject is anonymous because it doesn't yet have any associated account data (for example,
-     * if they haven't logged in).
-     * <p/>
-     * The word &quot;principals&quot; is nothing more than a fancy security term for identifying attributes associated
-     * with a Subject, aka, application user.  For example, user id, a surname (family/last name), given (first) name,
-     * social security number, nickname, username, etc, are all examples of a principal.
-     *
-     * @return all of this Subject's principals (identifying attributes).
-     * @see #getPrincipal()
-     * @see org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()
-     */
-    PrincipalCollection getPrincipals();
-
-    /**
-     * Returns {@code true} if this Subject is permitted to perform an action or access a resource summarized by the
-     * specified permission string.
-     * <p/>
-     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
-     * Please see the class-level JavaDoc for more information on these String-based permission methods.
-     *
-     * @param permission the String representation of a Permission that is being checked.
-     * @return true if this Subject is permitted, false otherwise.
-     * @see #isPermitted(Permission permission)
-     * @since 0.9
-     */
-    boolean isPermitted(String permission);
-
-    /**
-     * Returns {@code true} if this Subject is permitted to perform an action or access a resource summarized by the
-     * specified permission.
-     * <p/>
-     * More specifically, this method determines if any {@code Permission}s associated
-     * with the subject {@link Permission#implies(Permission) imply} the specified permission.
-     *
-     * @param permission the permission that is being checked.
-     * @return true if this Subject is permitted, false otherwise.
-     */
-    boolean isPermitted(Permission permission);
-
-    /**
-     * Checks if this Subject implies the given permission strings and returns a boolean array indicating which
-     * permissions are implied.
-     * <p/>
-     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
-     * Please see the class-level JavaDoc for more information on these String-based permission methods.
-     *
-     * @param permissions the String representations of the Permissions that are being checked.
-     * @return a boolean array where indices correspond to the index of the
-     *         permissions in the given list.  A true value at an index indicates this Subject is permitted for
-     *         for the associated {@code Permission} string in the list.  A false value at an index
-     *         indicates otherwise.
-     * @since 0.9
-     */
-    boolean[] isPermitted(String... permissions);
-
-    /**
-     * Checks if this Subject implies the given Permissions and returns a boolean array indicating which permissions
-     * are implied.
-     * <p/>
-     * More specifically, this method should determine if each {@code Permission} in
-     * the array is {@link Permission#implies(Permission) implied} by permissions
-     * already associated with the subject.
-     * <p/>
-     * This is primarily a performance-enhancing method to help reduce the number of
-     * {@link #isPermitted} invocations over the wire in client/server systems.
-     *
-     * @param permissions the permissions that are being checked.
-     * @return a boolean array where indices correspond to the index of the
-     *         permissions in the given list.  A true value at an index indicates this Subject is permitted for
-     *         for the associated {@code Permission} object in the list.  A false value at an index
-     *         indicates otherwise.
-     */
-    boolean[] isPermitted(List<Permission> permissions);
-
-    /**
-     * Returns {@code true} if this Subject implies all of the specified permission strings, {@code false} otherwise.
-     * <p/>
-     * This is an overloaded method for the corresponding type-safe {@link org.apache.shiro.authz.Permission Permission}
-     * variant.  Please see the class-level JavaDoc for more information on these String-based permission methods.
-     *
-     * @param permissions the String representations of the Permissions that are being checked.
-     * @return true if this Subject has all of the specified permissions, false otherwise.
-     * @see #isPermittedAll(Collection)
-     * @since 0.9
-     */
-    boolean isPermittedAll(String... permissions);
-
-    /**
-     * Returns {@code true} if this Subject implies all of the specified permissions, {@code false} otherwise.
-     * <p/>
-     * More specifically, this method determines if all of the given {@code Permission}s are
-     * {@link Permission#implies(Permission) implied by} permissions already associated with this Subject.
-     *
-     * @param permissions the permissions to check.
-     * @return true if this Subject has all of the specified permissions, false otherwise.
-     */
-    boolean isPermittedAll(Collection<Permission> permissions);
-
-    /**
-     * Ensures this Subject implies the specified permission String.
-     * <p/>
-     * If this subject's existing associated permissions do not {@link Permission#implies(Permission)} imply}
-     * the given permission, an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
-     * <p/>
-     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
-     * Please see the class-level JavaDoc for more information on these String-based permission methods.
-     *
-     * @param permission the String representation of the Permission to check.
-     * @throws org.apache.shiro.authz.AuthorizationException
-     *          if the user does not have the permission.
-     * @since 0.9
-     */
-    void checkPermission(String permission) throws AuthorizationException;
-
-    /**
-     * Ensures this Subject {@link Permission#implies(Permission) implies} the specified {@code Permission}.
-     * <p/>
-     * If this subject's existing associated permissions do not {@link Permission#implies(Permission) imply}
-     * the given permission, an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
-     *
-     * @param permission the Permission to check.
-     * @throws org.apache.shiro.authz.AuthorizationException
-     *          if this Subject does not have the permission.
-     */
-    void checkPermission(Permission permission) throws AuthorizationException;
-
-    /**
-     * Ensures this Subject
-     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) implies} all of the
-     * specified permission strings.
-     * <p/>
-     * If this subject's existing associated permissions do not
-     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) imply} all of the given permissions,
-     * an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
-     * <p/>
-     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
-     * Please see the class-level JavaDoc for more information on these String-based permission methods.
-     *
-     * @param permissions the string representations of Permissions to check.
-     * @throws AuthorizationException if this Subject does not have all of the given permissions.
-     * @since 0.9
-     */
-    void checkPermissions(String... permissions) throws AuthorizationException;
-
-    /**
-     * Ensures this Subject
-     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) implies} all of the
-     * specified permission strings.
-     * <p/>
-     * If this subject's existing associated permissions do not
-     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) imply} all of the given permissions,
-     * an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
-     *
-     * @param permissions the Permissions to check.
-     * @throws AuthorizationException if this Subject does not have all of the given permissions.
-     */
-    void checkPermissions(Collection<Permission> permissions) throws AuthorizationException;
-
-    /**
-     * Returns {@code true} if this Subject has the specified role, {@code false} otherwise.
-     *
-     * @param roleIdentifier the application-specific role identifier (usually a role id or role name).
-     * @return {@code true} if this Subject has the specified role, {@code false} otherwise.
-     */
-    boolean hasRole(String roleIdentifier);
-
-    /**
-     * Checks if this Subject has the specified roles, returning a boolean array indicating
-     * which roles are associated.
-     * <p/>
-     * This is primarily a performance-enhancing method to help reduce the number of
-     * {@link #hasRole} invocations over the wire in client/server systems.
-     *
-     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
-     * @return a boolean array where indices correspond to the index of the
-     *         roles in the given identifiers.  A true value indicates this Subject has the
-     *         role at that index.  False indicates this Subject does not have the role at that index.
-     */
-    boolean[] hasRoles(List<String> roleIdentifiers);
-
-    /**
-     * Returns {@code true} if this Subject has all of the specified roles, {@code false} otherwise.
-     *
-     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
-     * @return true if this Subject has all the roles, false otherwise.
-     */
-    boolean hasAllRoles(Collection<String> roleIdentifiers);
-
-    /**
-     * Asserts this Subject has the specified role by returning quietly if they do or throwing an
-     * {@link org.apache.shiro.authz.AuthorizationException} if they do not.
-     *
-     * @param roleIdentifier the application-specific role identifier (usually a role id or role name ).
-     * @throws org.apache.shiro.authz.AuthorizationException
-     *          if this Subject does not have the role.
-     */
-    void checkRole(String roleIdentifier) throws AuthorizationException;
-
-    /**
-     * Asserts this Subject has all of the specified roles by returning quietly if they do or throwing an
-     * {@link org.apache.shiro.authz.AuthorizationException} if they do not.
-     *
-     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
-     * @throws org.apache.shiro.authz.AuthorizationException
-     *          if this Subject does not have all of the specified roles.
-     */
-    void checkRoles(Collection<String> roleIdentifiers) throws AuthorizationException;
-
-    /**
-     * Performs a login attempt for this Subject/user.  If unsuccessful,
-     * an {@link AuthenticationException} is thrown, the subclass of which identifies why the attempt failed.
-     * If successful, the account data associated with the submitted principals/credentials will be
-     * associated with this {@code Subject} and the method will return quietly.
-     * <p/>
-     * Upon returning quietly, this {@code Subject} instance can be considered
-     * authenticated and {@link #getPrincipal() getPrincipal()} will be non-null and
-     * {@link #isAuthenticated() isAuthenticated()} will be {@code true}.
-     *
-     * @param token the token encapsulating the subject's principals and credentials to be passed to the
-     *              Authentication subsystem for verification.
-     * @throws org.apache.shiro.authc.AuthenticationException
-     *          if the authentication attempt fails.
-     * @since 0.9
-     */
-    void login(AuthenticationToken token) throws AuthenticationException;
-
-    /**
-     * Returns {@code true} if this Subject/user proved their identity <em>during their current session</em>
-     * by providing valid credentials matching those known to the system, {@code false} otherwise.
-     * <p/>
-     * Note that even if this Subject's identity has been remembered via 'remember me' services, this method will
-     * still return {@code false} unless the user has actually logged in with proper credentials <em>during their
-     * current session</em>.  See the {@link #isRemembered() isRemembered()} method JavaDoc for more.
-     *
-     * @return {@code true} if this Subject proved their identity during their current session
-     *         by providing valid credentials matching those known to the system, {@code false} otherwise.
-     * @since 0.9
-     */
-    boolean isAuthenticated();
-
-
-    /**
-     * Returns {@code true} if this {@code Subject} has an identity (it is not anonymous) and the identity
-     * (aka {@link #getPrincipals() principals}) is remembered from a successful authentication during a previous
-     * session.
-     * <p/>
-     * Although the underlying implementation determines exactly how this method functions, most implementations have
-     * this method act as the logical equivalent to this code:
-     * <pre>
-     * {@link #getPrincipal() getPrincipal()} != null && !{@link #isAuthenticated() isAuthenticated()}</pre>
-     * <p/>
-     * Note as indicated by the above code example, if a {@code Subject} is remembered, they are
-     * <em>NOT</em> considered authenticated.  A check against {@link #isAuthenticated() isAuthenticated()} is a more
-     * strict check than that reflected by this method.  For example, a check to see if a subject can access financial
-     * information should almost always depend on {@link #isAuthenticated() isAuthenticated()} to <em>guarantee</em> a
-     * verified identity, and not this method.
-     * <p/>
-     * Once the subject is authenticated, they are no longer considered only remembered because their identity would
-     * have been verified during the current session.
-     * <h4>Remembered vs Authenticated</h4>
-     * Authentication is the process of <em>proving</em> you are who you say you are.  When a user is only remembered,
-     * the remembered identity gives the system an idea who that user probably is, but in reality, has no way of
-     * absolutely <em>guaranteeing</em> if the remembered {@code Subject} represents the user currently
-     * using the application.
-     * <p/>
-     * So although many parts of the application can still perform user-specific logic based on the remembered
-     * {@link #getPrincipals() principals}, such as customized views, it should never perform highly-sensitive
-     * operations until the user has legitimately verified their identity by executing a successful authentication
-     * attempt.
-     * <p/>
-     * We see this paradigm all over the web, and we will use <a href="http://www.amazon.com">Amazon.com</a> as an
-     * example:
-     * <p/>
-     * When you visit Amazon.com and perform a login and ask it to 'remember me', it will set a cookie with your
-     * identity.  If you don't log out and your session expires, and you come back, say the next day, Amazon still knows
-     * who you <em>probably</em> are: you still see all of your book and movie recommendations and similar user-specific
-     * features since these are based on your (remembered) user id.
-     * <p/>
-     * BUT, if you try to do something sensitive, such as access your account's billing data, Amazon forces you
-     * to do an actual log-in, requiring your username and password.
-     * <p/>
-     * This is because although amazon.com assumed your identity from 'remember me', it recognized that you were not
-     * actually authenticated.  The only way to really guarantee you are who you say you are, and therefore allow you
-     * access to sensitive account data, is to force you to perform an actual successful authentication.  You can
-     * check this guarantee via the {@link #isAuthenticated() isAuthenticated()} method and not via this method.
-     *
-     * @return {@code true} if this {@code Subject}'s identity (aka {@link #getPrincipals() principals}) is
-     *         remembered from a successful authentication during a previous session, {@code false} otherwise.
-     * @since 1.0
-     */
-    boolean isRemembered();
-
-    /**
-     * Returns the application {@code Session} associated with this Subject.  If no session exists when this
-     * method is called, a new session will be created, associated with this Subject, and then returned.
-     *
-     * @return the application {@code Session} associated with this Subject.
-     * @see #getSession(boolean)
-     * @since 0.2
-     */
-    Session getSession();
-
-    /**
-     * Returns the application {@code Session} associated with this Subject.  Based on the boolean argument,
-     * this method functions as follows:
-     * <ul>
-     * <li>If there is already an existing session associated with this {@code Subject}, it is returned and
-     * the {@code create} argument is ignored.</li>
-     * <li>If no session exists and {@code create} is {@code true}, a new session will be created, associated with
-     * this {@code Subject} and then returned.</li>
-     * <li>If no session exists and {@code create} is {@code false}, {@code null} is returned.</li>
-     * </ul>
-     *
-     * @param create boolean argument determining if a new session should be created or not if there is no existing session.
-     * @return the application {@code Session} associated with this {@code Subject} or {@code null} based
-     *         on the above described logic.
-     * @since 0.2
-     */
-    Session getSession(boolean create);
-
-    /**
-     * Logs out this Subject and invalidates and/or removes any associated entities,
-     * such as a {@link Session Session} and authorization data.  After this method is called, the Subject is
-     * considered 'anonymous' and may continue to be used for another log-in if desired.
-     * <h3>Web Environment Warning</h3>
-     * Calling this method in web environments will usually remove any associated session cookie as part of
-     * session invalidation.  Because cookies are part of the HTTP header, and headers can only be set before the
-     * response body (html, image, etc) is sent, this method in web environments must be called before <em>any</em>
-     * content has been rendered.
-     * <p/>
-     * The typical approach most applications use in this scenario is to redirect the user to a different
-     * location (e.g. home page) immediately after calling this method.  This is an effect of the HTTP protocol
-     * itself and not a reflection of Shiro's implementation.
-     * <p/>
-     * Non-HTTP environments may of course use a logged-out subject for login again if desired.
-     */
-    void logout();
-
-    /**
-     * Associates the specified {@code Callable} with this {@code Subject} instance and then executes it on the
-     * currently running thread.  If you want to execute the {@code Callable} on a different thread, it is better to
-     * use the {@link #associateWith(Callable)} method instead.
-     *
-     * @param callable the Callable to associate with this subject and then execute.
-     * @param <V>      the type of return value the {@code Callable} will return
-     * @return the resulting object returned by the {@code Callable}'s execution.
-     * @throws ExecutionException if the {@code Callable}'s {@link Callable#call call} method throws an exception.
-     * @since 1.0
-     */
-    <V> V execute(Callable<V> callable) throws ExecutionException;
-
-    /**
-     * Associates the specified {@code Runnable} with this {@code Subject} instance and then executes it on the
-     * currently running thread.  If you want to execute the {@code Runnable} on a different thread, it is better to
-     * use the {@link #associateWith(Runnable)} method instead.
-     * <p/>
-     * <b>Note</b>: This method is primarily provided to execute existing/legacy Runnable implementations.  It is better
-     * for new code to use {@link #execute(Callable)} since that supports the ability to return values and catch
-     * exceptions.
-     *
-     * @param runnable the {@code Runnable} to associate with this {@code Subject} and then execute.
-     * @since 1.0
-     */
-    void execute(Runnable runnable);
-
-    /**
-     * Returns a {@code Callable} instance matching the given argument while additionally ensuring that it will
-     * retain and execute under this Subject's identity.  The returned object can be used with an
-     * {@link java.util.concurrent.ExecutorService ExecutorService} to execute as this Subject.
-     * <p/>
-     * This will effectively ensure that any calls to
-     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()} and related functionality will continue
-     * to function properly on any thread that executes the returned {@code Callable} instance.
-     *
-     * @param callable the callable to execute as this {@code Subject}
-     * @param <V>      the {@code Callable}s return value type
-     * @return a {@code Callable} that can be run as this {@code Subject}.
-     * @since 1.0
-     */
-    <V> Callable<V> associateWith(Callable<V> callable);
-
-    /**
-     * Returns a {@code Runnable} instance matching the given argument while additionally ensuring that it will
-     * retain and execute under this Subject's identity.  The returned object can be used with an
-     * {@link java.util.concurrent.Executor Executor} or another thread to execute as this Subject.
-     * <p/>
-     * This will effectively ensure that any calls to
-     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()} and related functionality will continue
-     * to function properly on any thread that executes the returned {@code Runnable} instance.
-     * <p/>
-     * *Note that if you need a return value to be returned as a result of the runnable's execution or if you need to
-     * react to any Exceptions, it is highly recommended to use the
-     * {@link #associateWith(java.util.concurrent.Callable) createCallable} method instead of this one.
-     *
-     * @param runnable the runnable to execute as this {@code Subject}
-     * @return a {@code Runnable} that can be run as this {@code Subject} on another thread.
-     * @see #associateWith (java.util.concurrent.Callable)
-     * @since 1.0
-     */
-    Runnable associateWith(Runnable runnable);
-
-    /**
-     * Allows this subject to 'run as' or 'assume' another identity indefinitely.  This can only be
-     * called when the {@code Subject} instance already has an identity (i.e. they are remembered from a previous
-     * log-in or they have authenticated during their current session).
-     * <p/>
-     * Some notes about {@code runAs}:
-     * <ul>
-     * <li>You can tell if a {@code Subject} is 'running as' another identity by calling the
-     * {@link #isRunAs() isRunAs()} method.</li>
-     * <li>If running as another identity, you can determine what the previous 'pre run as' identity
-     * was by calling the {@link #getPreviousPrincipals() getPreviousPrincipals()} method.</li>
-     * <li>When you want a {@code Subject} to stop running as another identity, you can return to its previous
-     * 'pre run as' identity by calling the {@link #releaseRunAs() releaseRunAs()} method.</li>
-     * </ul>
-     *
-     * @param principals the identity to 'run as', aka the identity to <em>assume</em> indefinitely.
-     * @throws NullPointerException  if the specified principals collection is {@code null} or empty.
-     * @throws IllegalStateException if this {@code Subject} does not yet have an identity of its own.
-     * @since 1.0
-     */
-    void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;
-
-    /**
-     * Returns {@code true} if this {@code Subject} is 'running as' another identity other than its original one or
-     * {@code false} otherwise (normal {@code Subject} state).  See the {@link #runAs runAs} method for more
-     * information.
-     *
-     * @return {@code true} if this {@code Subject} is 'running as' another identity other than its original one or
-     *         {@code false} otherwise (normal {@code Subject} state).
-     * @see #runAs
-     * @since 1.0
-     */
-    boolean isRunAs();
-
-    /**
-     * Returns the previous 'pre run as' identity of this {@code Subject} before assuming the current
-     * {@link #runAs runAs} identity, or {@code null} if this {@code Subject} is not operating under an assumed
-     * identity (normal state). See the {@link #runAs runAs} method for more information.
-     *
-     * @return the previous 'pre run as' identity of this {@code Subject} before assuming the current
-     *         {@link #runAs runAs} identity, or {@code null} if this {@code Subject} is not operating under an assumed
-     *         identity (normal state).
-     * @see #runAs
-     * @since 1.0
-     */
-    PrincipalCollection getPreviousPrincipals();
-
-    /**
-     * Releases the current 'run as' (assumed) identity and reverts back to the previous 'pre run as'
-     * identity that existed before {@code #runAs runAs} was called.
-     * <p/>
-     * This method returne 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not
-     * operating under an assumed identity.
-     *
-     * @return the 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not operating
-     *         under an assumed identity.
-     * @see #runAs
-     * @since 1.0
-     */
-    PrincipalCollection releaseRunAs();
-
-    /**
-     * Builder design pattern implementation for creating {@link Subject} instances in a simplified way without
-     * requiring knowledge of Shiro's construction techniques.
-     * <p/>
-     * <b>NOTE</b>: This is provided for framework development support only and should typically never be used by
-     * application developers.  {@code Subject} instances should generally be acquired by using
-     * <code>SecurityUtils.{@link SecurityUtils#getSubject() getSubject()}</code>
-     * <h4>Usage</h4>
-     * The simplest usage of this builder is to construct an anonymous, session-less {@code Subject} instance:
-     * <pre>
-     * Subject subject = new Subject.{@link #Builder() Builder}().{@link #buildSubject() buildSubject()};</pre>
-     * The default, no-arg {@code Subject.Builder()} constructor shown above will use the application's
-     * currently accessible {@code SecurityManager} via
-     * <code>SecurityUtils.{@link SecurityUtils#getSecurityManager() getSecurityManager()}</code>.  You may also
-     * specify the exact {@code SecurityManager} instance to be used by the additional
-     * <code>Subject.{@link #Builder(org.apache.shiro.mgt.SecurityManager) Builder(securityManager)}</code>
-     * constructor if desired.
-     * <p/>
-     * All other methods may be called before the {@link #buildSubject() buildSubject()} method to
-     * provide context on how to construct the {@code Subject} instance.  For example, if you have a session id and
-     * want to acquire the {@code Subject} that 'owns' that session (assuming the session exists and is not expired):
-     * <pre>
-     * Subject subject = new Subject.Builder().sessionId(sessionId).buildSubject();</pre>
-     * <p/>
-     * Similarly, if you want a {@code Subject} instance reflecting a certain identity:
-     * <pre>
-     * PrincipalCollection principals = new SimplePrincipalCollection("username", <em>yourRealmName</em>);
-     * Subject subject = new Subject.Builder().principals(principals).build();</pre>
-     * <p/>
-     * <b>Note*</b> that the returned {@code Subject} instance is <b>not</b> automatically bound to the application (thread)
-     * for further use.  That is,
-     * {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
-     * will not automatically return the same instance as what is returned by the builder.  It is up to the framework
-     * developer to bind the built {@code Subject} for continued use if desired.
-     *
-     * @since 1.0
-     */
-    public static class Builder {
-
-        /**
-         * Hold all contextual data via the Builder instance's method invocations to be sent to the
-         * {@code SecurityManager} during the {@link #buildSubject} call.
-         */
-        private final SubjectContext subjectContext;
-
-        /**
-         * The SecurityManager to invoke during the {@link #buildSubject} call.
-         */
-        private final SecurityManager securityManager;
-
-        /**
-         * Constructs a new {@link Subject.Builder} instance, using the {@code SecurityManager} instance available
-         * to the calling code as determined by a call to {@link org.apache.shiro.SecurityUtils#getSecurityManager()}
-         * to build the {@code Subject} instance.
-         */
-        public Builder() {
-            this(SecurityUtils.getSecurityManager());
-        }
-
-        /**
-         * Constructs a new {@link Subject.Builder} instance which will use the specified {@code SecurityManager} when
-         * building the {@code Subject} instance.
-         *
-         * @param securityManager the {@code SecurityManager} to use when building the {@code Subject} instance.
-         */
-        public Builder(SecurityManager securityManager) {
-            if (securityManager == null) {
-                throw new NullPointerException("SecurityManager method argument cannot be null.");
-            }
-            this.securityManager = securityManager;
-            this.subjectContext = newSubjectContextInstance();
-            if (this.subjectContext == null) {
-                throw new IllegalStateException("Subject instance returned from 'newSubjectContextInstance' " +
-                        "cannot be null.");
-            }
-            this.subjectContext.setSecurityManager(securityManager);
-        }
-
-        /**
-         * Creates a new {@code SubjectContext} instance to be used to populate with subject contextual data that
-         * will then be sent to the {@code SecurityManager} to create a new {@code Subject} instance.
-         *
-         * @return a new {@code SubjectContext} instance
-         */
-        protected SubjectContext newSubjectContextInstance() {
-            return new DefaultSubjectContext();
-        }
-
-        /**
-         * Returns the backing context used to build the {@code Subject} instance, available to subclasses
-         * since the {@code context} class attribute is marked as {@code private}.
-         *
-         * @return the backing context used to build the {@code Subject} instance, available to subclasses.
-         */
-        protected SubjectContext getSubjectContext() {
-            return this.subjectContext;
-        }
-
-        /**
-         * Enables building a {@link Subject Subject} instance that owns the {@link Session Session} with the
-         * specified {@code sessionId}.
-         * <p/>
-         * Usually when specifying a {@code sessionId}, no other {@code Builder} methods would be specified because
-         * everything else (principals, inet address, etc) can usually be reconstructed based on the referenced
-         * session alone.  In other words, this is almost always sufficient:
-         * <pre>
-         * new Subject.Builder().sessionId(sessionId).buildSubject();</pre>
-         * <p/>
-         * <b>Although simple in concept, this method provides very powerful functionality previously absent in almost
-         * all Java environments:</b>
-         * <p/>
-         * The ability to reference a {@code Subject} and their server-side session
-         * <em>across clients of different mediums</em> such as web applications, Java applets,
-         * standalone C# clients over XML-RPC and/or SOAP, and many others. This is a <em>huge</em>
-         * benefit in heterogeneous enterprise applications.
-         * <p/>
-         * To maintain session integrity across client mediums, the {@code sessionId} <b>must</b> be transmitted
-         * to all client mediums securely (e.g. over SSL) to prevent man-in-the-middle attacks.  This
-         * is nothing new - all web applications are susceptible to the same problem when transmitting
-         * {@code Cookie}s or when using URL rewriting.  As long as the
-         * {@code sessionId} is transmitted securely, session integrity can be maintained.
-         *
-         * @param sessionId the id of the session that backs the desired Subject being acquired.
-         * @return this {@code Builder} instance for method chaining.
-         */
-        public Builder sessionId(Serializable sessionId) {
-            if (sessionId != null) {
-                this.subjectContext.setSessionId(sessionId);
-            }
-            return this;
-        }
-
-        /**
-         * Ensures the {@code Subject} being built will reflect the specified host name or IP as its originating
-         * location.
-         *
-         * @param host the host name or IP address to use as the {@code Subject}'s originating location.
-         * @return this {@code Builder} instance for method chaining.
-         */
-        public Builder host(String host) {
-            if (StringUtils.hasText(host)) {
-                this.subjectContext.setHost(host);
-            }
-            return this;
-        }
-
-        /**
-         * Ensures the {@code Subject} being built will use the specified {@link Session} instance.  Note that it is
-         * more common to use the {@link #sessionId sessionId} builder method rather than having to construct a
-         * {@code Session} instance for this method.
-         *
-         * @param session the session to use as the {@code Subject}'s {@link Session}
-         * @return this {@code Builder} instance for method chaining.
-         */
-        public Builder session(Session session) {
-            if (session != null) {
-                this.subjectContext.setSession(session);
-            }
-            return this;
-        }
-
-        /**
-         * Ensures the {@code Subject} being built will reflect the specified principals (aka identity).
-         * <p/>
-         * For example, if your application's unique identifier for users is a {@code String} username, and you wanted
-         * to create a {@code Subject} instance that reflected a user whose username is
-         * '{@code jsmith}', and you knew the Realm that could acquire {@code jsmith}'s principals based on the username
-         * was named &quot;{@code myRealm}&quot;, you might create the '{@code jsmith} {@code Subject} instance this
-         * way:
-         * <pre>
-         * PrincipalCollection identity = new {@link org.apache.shiro.subject.SimplePrincipalCollection#SimplePrincipalCollection(Object, String) SimplePrincipalCollection}(&quot;jsmith&quot;, &quot;myRealm&quot;);
-         * Subject jsmith = new Subject.Builder().principals(identity).buildSubject();</pre>
-         * <p/>
-         * Similarly, if your application's unique identifier for users is a {@code long} value (such as might be used
-         * as a primary key in a relational database) and you were using a {@code JDBC}
-         * {@code Realm} named, (unimaginatively) &quot;jdbcRealm&quot;, you might create the Subject
-         * instance this way:
-         * <pre>
-         * long userId = //get user ID from somewhere
-         * PrincipalCollection userIdentity = new {@link org.apache.shiro.subject.SimplePrincipalCollection#SimplePrincipalCollection(Object, String) SimplePrincipalCollection}(<em>userId</em>, &quot;jdbcRealm&quot;);
-         * Subject user = new Subject.Builder().principals(identity).buildSubject();</pre>
-         *
-         * @param principals the principals to use as the {@code Subject}'s identity.
-         * @return this {@code Builder} instance for method chaining.
-         */
-        public Builder principals(PrincipalCollection principals) {
-            if (!CollectionUtils.isEmpty(principals)) {
-                this.subjectContext.setPrincipals(principals);
-            }
-            return this;
-        }
-
-        /**
-         * Ensures the {@code Subject} being built will be considered
-         * {@link org.apache.shiro.subject.Subject#isAuthenticated() authenticated}.  Per the
-         * {@link org.apache.shiro.subject.Subject#isAuthenticated() isAuthenticated()} JavaDoc, be careful
-         * when specifying {@code true} - you should know what you are doing and have a good reason for ignoring Shiro's
-         * default authentication state mechanisms.
-         *
-         * @param authenticated whether or not the built {@code Subject} will be considered authenticated.
-         * @return this {@code Builder} instance for method chaining.
-         * @see org.apache.shiro.subject.Subject#isAuthenticated()
-         */
-        public Builder authenticated(boolean authenticated) {
-            this.subjectContext.setAuthenticated(authenticated);
-            return this;
-        }
-
-        /**
-         * Allows custom attributes to be added to the underlying context {@code Map} used to construct the
-         * {@link Subject} instance.
-         * <p/>
-         * A {@code null} key throws an {@link IllegalArgumentException}. A {@code null} value effectively removes
-         * any previously stored attribute under the given key from the context map.
-         * <p/>
-         * <b>*NOTE*:</b> This method is only useful when configuring Shiro with a custom {@link SubjectFactory}
-         * implementation.  This method allows end-users to append additional data to the context map which the
-         * {@code SubjectFactory} implementation can use when building custom Subject instances. As such, this method
-         * is only useful when a custom {@code SubjectFactory} implementation has been configured.
-         *
-         * @param attributeKey   the key under which the corresponding value will be stored in the context {@code Map}.
-         * @param attributeValue the value to store in the context map under the specified {@code attributeKey}.
-         * @return this {@code Builder} instance for method chaining.
-         * @throws IllegalArgumentException if the {@code attributeKey} is {@code null}.
-         * @see SubjectFactory#createSubject(SubjectContext)
-         */
-        @SuppressWarnings({"UnusedDeclaration"})
-        public Builder contextAttribute(String attributeKey, Object attributeValue) {
-            if (attributeKey == null) {
-                String msg = "Subject context map key cannot be null.";
-                throw new IllegalArgumentException(msg);
-            }
-            if (attributeValue == null) {
-                this.subjectContext.remove(attributeKey);
-            } else {
-                this.subjectContext.put(attributeKey, attributeValue);
-            }
-            return this;
-        }
-
-        /**
-         * Creates and returns a new {@code Subject} instance reflecting the cumulative state acquired by the
-         * other methods in this class.
-         * <p/>
-         * This {@code Builder} instance will still retain the underlying state after this method is called - it
-         * will not clear it; repeated calls to this method will return multiple {@link Subject} instances, all
-         * reflecting the exact same state.  If a new (different) {@code Subject} is to be constructed, a new
-         * {@code Builder} instance must be created.
-         * <p/>
-         * <b>Note</b> that the returned {@code Subject} instance is <b>not</b> automatically bound to the application
-         * (thread) for further use.  That is,
-         * {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
-         * will not automatically return the same instance as what is returned by the builder.  It is up to the
-         * framework developer to bind the returned {@code Subject} for continued use if desired.
-         *
-         * @return a new {@code Subject} instance reflecting the cumulative state acquired by the
-         *         other methods in this class.
-         */
-        public Subject buildSubject() {
-            return this.securityManager.createSubject(this.subjectContext);
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.authc.AuthenticationException;
+import org.apache.shiro.authc.AuthenticationToken;
+import org.apache.shiro.authz.AuthorizationException;
+import org.apache.shiro.authz.Permission;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.mgt.SubjectFactory;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.subject.support.DefaultSubjectContext;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.StringUtils;
+
+import java.io.Serializable;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+/**
+ * A {@code Subject} represents state and security operations for a <em>single</em> application user.
+ * These operations include authentication (login/logout), authorization (access control), and
+ * session access. It is Shiro's primary mechanism for single-user security functionality.
+ * <h3>Acquiring a Subject</h3>
+ * To acquire the currently-executing {@code Subject}, application developers will almost always use
+ * {@code SecurityUtils}:
+ * <pre>
+ * {@link SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}</pre>
+ * Almost all security operations should be performed with the {@code Subject} returned from this method.
+ * <h3>Permission methods</h3>
+ * Note that there are many *Permission methods in this interface overloaded to accept String arguments instead of
+ * {@link Permission Permission} instances. They are a convenience allowing the caller to use a String representation of
+ * a {@link Permission Permission} if desired.  The underlying Authorization subsystem implementations will usually
+ * simply convert these String values to {@link Permission Permission} instances and then just call the corresponding
+ * type-safe method.  (Shiro's default implementations do String-to-Permission conversion for these methods using
+ * {@link org.apache.shiro.authz.permission.PermissionResolver PermissionResolver}s.)
+ * <p/>
+ * These overloaded *Permission methods forgo type-saftey for the benefit of convenience and simplicity,
+ * so you should choose which ones to use based on your preferences and needs.
+ *
+ * @author Les Hazlewood
+ * @author Jeremy Haile
+ * @since 0.1
+ */
+public interface Subject {
+
+    /**
+     * Returns this Subject's application-wide uniquely identifying principal, or {@code null} if this
+     * Subject is anonymous because it doesn't yet have any associated account data (for example,
+     * if they haven't logged in).
+     * <p/>
+     * The term <em>principal</em> is just a fancy security term for any identifying attribute(s) of an application
+     * user, such as a username, or user id, or public key, or anything else you might use in your application to
+     * identify a user.
+     * <h4>Uniqueness</h4>
+     * Although given names and family names (first/last) are technically considered principals as well,
+     * Shiro expects the object returned from this method to be an identifying attribute unique across
+     * your entire application.
+     * <p/>
+     * This implies that things like given names and family names are usually poor
+     * candidates as return values since they are rarely guaranteed to be unique;  Things often used for this value:
+     * <ul>
+     * <li>A {@code long} RDBMS surrogate primary key</li>
+     * <li>An application-unique username</li>
+     * <li>A {@link java.util.UUID UUID}</li>
+     * <li>An LDAP Unique ID</li>
+     * </ul>
+     * or any other similar suitable unique mechanism valuable to your application.
+     * <p/>
+     * Most implementations will simply return
+     * <code>{@link #getPrincipals()}.{@link org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal() getPrimaryPrincipal()}</code>
+     *
+     * @return this Subject's application-specific unique identity.
+     * @see org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()
+     */
+    Object getPrincipal();
+
+    /**
+     * Returns this Subject's principals (identifying attributes) in the form of a {@code PrincipalCollection} or
+     * {@code null} if this Subject is anonymous because it doesn't yet have any associated account data (for example,
+     * if they haven't logged in).
+     * <p/>
+     * The word &quot;principals&quot; is nothing more than a fancy security term for identifying attributes associated
+     * with a Subject, aka, application user.  For example, user id, a surname (family/last name), given (first) name,
+     * social security number, nickname, username, etc, are all examples of a principal.
+     *
+     * @return all of this Subject's principals (identifying attributes).
+     * @see #getPrincipal()
+     * @see org.apache.shiro.subject.PrincipalCollection#getPrimaryPrincipal()
+     */
+    PrincipalCollection getPrincipals();
+
+    /**
+     * Returns {@code true} if this Subject is permitted to perform an action or access a resource summarized by the
+     * specified permission string.
+     * <p/>
+     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
+     * Please see the class-level JavaDoc for more information on these String-based permission methods.
+     *
+     * @param permission the String representation of a Permission that is being checked.
+     * @return true if this Subject is permitted, false otherwise.
+     * @see #isPermitted(Permission permission)
+     * @since 0.9
+     */
+    boolean isPermitted(String permission);
+
+    /**
+     * Returns {@code true} if this Subject is permitted to perform an action or access a resource summarized by the
+     * specified permission.
+     * <p/>
+     * More specifically, this method determines if any {@code Permission}s associated
+     * with the subject {@link Permission#implies(Permission) imply} the specified permission.
+     *
+     * @param permission the permission that is being checked.
+     * @return true if this Subject is permitted, false otherwise.
+     */
+    boolean isPermitted(Permission permission);
+
+    /**
+     * Checks if this Subject implies the given permission strings and returns a boolean array indicating which
+     * permissions are implied.
+     * <p/>
+     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
+     * Please see the class-level JavaDoc for more information on these String-based permission methods.
+     *
+     * @param permissions the String representations of the Permissions that are being checked.
+     * @return a boolean array where indices correspond to the index of the
+     *         permissions in the given list.  A true value at an index indicates this Subject is permitted for
+     *         for the associated {@code Permission} string in the list.  A false value at an index
+     *         indicates otherwise.
+     * @since 0.9
+     */
+    boolean[] isPermitted(String... permissions);
+
+    /**
+     * Checks if this Subject implies the given Permissions and returns a boolean array indicating which permissions
+     * are implied.
+     * <p/>
+     * More specifically, this method should determine if each {@code Permission} in
+     * the array is {@link Permission#implies(Permission) implied} by permissions
+     * already associated with the subject.
+     * <p/>
+     * This is primarily a performance-enhancing method to help reduce the number of
+     * {@link #isPermitted} invocations over the wire in client/server systems.
+     *
+     * @param permissions the permissions that are being checked.
+     * @return a boolean array where indices correspond to the index of the
+     *         permissions in the given list.  A true value at an index indicates this Subject is permitted for
+     *         for the associated {@code Permission} object in the list.  A false value at an index
+     *         indicates otherwise.
+     */
+    boolean[] isPermitted(List<Permission> permissions);
+
+    /**
+     * Returns {@code true} if this Subject implies all of the specified permission strings, {@code false} otherwise.
+     * <p/>
+     * This is an overloaded method for the corresponding type-safe {@link org.apache.shiro.authz.Permission Permission}
+     * variant.  Please see the class-level JavaDoc for more information on these String-based permission methods.
+     *
+     * @param permissions the String representations of the Permissions that are being checked.
+     * @return true if this Subject has all of the specified permissions, false otherwise.
+     * @see #isPermittedAll(Collection)
+     * @since 0.9
+     */
+    boolean isPermittedAll(String... permissions);
+
+    /**
+     * Returns {@code true} if this Subject implies all of the specified permissions, {@code false} otherwise.
+     * <p/>
+     * More specifically, this method determines if all of the given {@code Permission}s are
+     * {@link Permission#implies(Permission) implied by} permissions already associated with this Subject.
+     *
+     * @param permissions the permissions to check.
+     * @return true if this Subject has all of the specified permissions, false otherwise.
+     */
+    boolean isPermittedAll(Collection<Permission> permissions);
+
+    /**
+     * Ensures this Subject implies the specified permission String.
+     * <p/>
+     * If this subject's existing associated permissions do not {@link Permission#implies(Permission)} imply}
+     * the given permission, an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
+     * <p/>
+     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
+     * Please see the class-level JavaDoc for more information on these String-based permission methods.
+     *
+     * @param permission the String representation of the Permission to check.
+     * @throws org.apache.shiro.authz.AuthorizationException
+     *          if the user does not have the permission.
+     * @since 0.9
+     */
+    void checkPermission(String permission) throws AuthorizationException;
+
+    /**
+     * Ensures this Subject {@link Permission#implies(Permission) implies} the specified {@code Permission}.
+     * <p/>
+     * If this subject's existing associated permissions do not {@link Permission#implies(Permission) imply}
+     * the given permission, an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
+     *
+     * @param permission the Permission to check.
+     * @throws org.apache.shiro.authz.AuthorizationException
+     *          if this Subject does not have the permission.
+     */
+    void checkPermission(Permission permission) throws AuthorizationException;
+
+    /**
+     * Ensures this Subject
+     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) implies} all of the
+     * specified permission strings.
+     * <p/>
+     * If this subject's existing associated permissions do not
+     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) imply} all of the given permissions,
+     * an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
+     * <p/>
+     * This is an overloaded method for the corresponding type-safe {@link Permission Permission} variant.
+     * Please see the class-level JavaDoc for more information on these String-based permission methods.
+     *
+     * @param permissions the string representations of Permissions to check.
+     * @throws AuthorizationException if this Subject does not have all of the given permissions.
+     * @since 0.9
+     */
+    void checkPermissions(String... permissions) throws AuthorizationException;
+
+    /**
+     * Ensures this Subject
+     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) implies} all of the
+     * specified permission strings.
+     * <p/>
+     * If this subject's existing associated permissions do not
+     * {@link org.apache.shiro.authz.Permission#implies(org.apache.shiro.authz.Permission) imply} all of the given permissions,
+     * an {@link org.apache.shiro.authz.AuthorizationException} will be thrown.
+     *
+     * @param permissions the Permissions to check.
+     * @throws AuthorizationException if this Subject does not have all of the given permissions.
+     */
+    void checkPermissions(Collection<Permission> permissions) throws AuthorizationException;
+
+    /**
+     * Returns {@code true} if this Subject has the specified role, {@code false} otherwise.
+     *
+     * @param roleIdentifier the application-specific role identifier (usually a role id or role name).
+     * @return {@code true} if this Subject has the specified role, {@code false} otherwise.
+     */
+    boolean hasRole(String roleIdentifier);
+
+    /**
+     * Checks if this Subject has the specified roles, returning a boolean array indicating
+     * which roles are associated.
+     * <p/>
+     * This is primarily a performance-enhancing method to help reduce the number of
+     * {@link #hasRole} invocations over the wire in client/server systems.
+     *
+     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
+     * @return a boolean array where indices correspond to the index of the
+     *         roles in the given identifiers.  A true value indicates this Subject has the
+     *         role at that index.  False indicates this Subject does not have the role at that index.
+     */
+    boolean[] hasRoles(List<String> roleIdentifiers);
+
+    /**
+     * Returns {@code true} if this Subject has all of the specified roles, {@code false} otherwise.
+     *
+     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
+     * @return true if this Subject has all the roles, false otherwise.
+     */
+    boolean hasAllRoles(Collection<String> roleIdentifiers);
+
+    /**
+     * Asserts this Subject has the specified role by returning quietly if they do or throwing an
+     * {@link org.apache.shiro.authz.AuthorizationException} if they do not.
+     *
+     * @param roleIdentifier the application-specific role identifier (usually a role id or role name ).
+     * @throws org.apache.shiro.authz.AuthorizationException
+     *          if this Subject does not have the role.
+     */
+    void checkRole(String roleIdentifier) throws AuthorizationException;
+
+    /**
+     * Asserts this Subject has all of the specified roles by returning quietly if they do or throwing an
+     * {@link org.apache.shiro.authz.AuthorizationException} if they do not.
+     *
+     * @param roleIdentifiers the application-specific role identifiers to check (usually role ids or role names).
+     * @throws org.apache.shiro.authz.AuthorizationException
+     *          if this Subject does not have all of the specified roles.
+     */
+    void checkRoles(Collection<String> roleIdentifiers) throws AuthorizationException;
+
+    /**
+     * Performs a login attempt for this Subject/user.  If unsuccessful,
+     * an {@link AuthenticationException} is thrown, the subclass of which identifies why the attempt failed.
+     * If successful, the account data associated with the submitted principals/credentials will be
+     * associated with this {@code Subject} and the method will return quietly.
+     * <p/>
+     * Upon returning quietly, this {@code Subject} instance can be considered
+     * authenticated and {@link #getPrincipal() getPrincipal()} will be non-null and
+     * {@link #isAuthenticated() isAuthenticated()} will be {@code true}.
+     *
+     * @param token the token encapsulating the subject's principals and credentials to be passed to the
+     *              Authentication subsystem for verification.
+     * @throws org.apache.shiro.authc.AuthenticationException
+     *          if the authentication attempt fails.
+     * @since 0.9
+     */
+    void login(AuthenticationToken token) throws AuthenticationException;
+
+    /**
+     * Returns {@code true} if this Subject/user proved their identity <em>during their current session</em>
+     * by providing valid credentials matching those known to the system, {@code false} otherwise.
+     * <p/>
+     * Note that even if this Subject's identity has been remembered via 'remember me' services, this method will
+     * still return {@code false} unless the user has actually logged in with proper credentials <em>during their
+     * current session</em>.  See the {@link #isRemembered() isRemembered()} method JavaDoc for more.
+     *
+     * @return {@code true} if this Subject proved their identity during their current session
+     *         by providing valid credentials matching those known to the system, {@code false} otherwise.
+     * @since 0.9
+     */
+    boolean isAuthenticated();
+
+
+    /**
+     * Returns {@code true} if this {@code Subject} has an identity (it is not anonymous) and the identity
+     * (aka {@link #getPrincipals() principals}) is remembered from a successful authentication during a previous
+     * session.
+     * <p/>
+     * Although the underlying implementation determines exactly how this method functions, most implementations have
+     * this method act as the logical equivalent to this code:
+     * <pre>
+     * {@link #getPrincipal() getPrincipal()} != null && !{@link #isAuthenticated() isAuthenticated()}</pre>
+     * <p/>
+     * Note as indicated by the above code example, if a {@code Subject} is remembered, they are
+     * <em>NOT</em> considered authenticated.  A check against {@link #isAuthenticated() isAuthenticated()} is a more
+     * strict check than that reflected by this method.  For example, a check to see if a subject can access financial
+     * information should almost always depend on {@link #isAuthenticated() isAuthenticated()} to <em>guarantee</em> a
+     * verified identity, and not this method.
+     * <p/>
+     * Once the subject is authenticated, they are no longer considered only remembered because their identity would
+     * have been verified during the current session.
+     * <h4>Remembered vs Authenticated</h4>
+     * Authentication is the process of <em>proving</em> you are who you say you are.  When a user is only remembered,
+     * the remembered identity gives the system an idea who that user probably is, but in reality, has no way of
+     * absolutely <em>guaranteeing</em> if the remembered {@code Subject} represents the user currently
+     * using the application.
+     * <p/>
+     * So although many parts of the application can still perform user-specific logic based on the remembered
+     * {@link #getPrincipals() principals}, such as customized views, it should never perform highly-sensitive
+     * operations until the user has legitimately verified their identity by executing a successful authentication
+     * attempt.
+     * <p/>
+     * We see this paradigm all over the web, and we will use <a href="http://www.amazon.com">Amazon.com</a> as an
+     * example:
+     * <p/>
+     * When you visit Amazon.com and perform a login and ask it to 'remember me', it will set a cookie with your
+     * identity.  If you don't log out and your session expires, and you come back, say the next day, Amazon still knows
+     * who you <em>probably</em> are: you still see all of your book and movie recommendations and similar user-specific
+     * features since these are based on your (remembered) user id.
+     * <p/>
+     * BUT, if you try to do something sensitive, such as access your account's billing data, Amazon forces you
+     * to do an actual log-in, requiring your username and password.
+     * <p/>
+     * This is because although amazon.com assumed your identity from 'remember me', it recognized that you were not
+     * actually authenticated.  The only way to really guarantee you are who you say you are, and therefore allow you
+     * access to sensitive account data, is to force you to perform an actual successful authentication.  You can
+     * check this guarantee via the {@link #isAuthenticated() isAuthenticated()} method and not via this method.
+     *
+     * @return {@code true} if this {@code Subject}'s identity (aka {@link #getPrincipals() principals}) is
+     *         remembered from a successful authentication during a previous session, {@code false} otherwise.
+     * @since 1.0
+     */
+    boolean isRemembered();
+
+    /**
+     * Returns the application {@code Session} associated with this Subject.  If no session exists when this
+     * method is called, a new session will be created, associated with this Subject, and then returned.
+     *
+     * @return the application {@code Session} associated with this Subject.
+     * @see #getSession(boolean)
+     * @since 0.2
+     */
+    Session getSession();
+
+    /**
+     * Returns the application {@code Session} associated with this Subject.  Based on the boolean argument,
+     * this method functions as follows:
+     * <ul>
+     * <li>If there is already an existing session associated with this {@code Subject}, it is returned and
+     * the {@code create} argument is ignored.</li>
+     * <li>If no session exists and {@code create} is {@code true}, a new session will be created, associated with
+     * this {@code Subject} and then returned.</li>
+     * <li>If no session exists and {@code create} is {@code false}, {@code null} is returned.</li>
+     * </ul>
+     *
+     * @param create boolean argument determining if a new session should be created or not if there is no existing session.
+     * @return the application {@code Session} associated with this {@code Subject} or {@code null} based
+     *         on the above described logic.
+     * @since 0.2
+     */
+    Session getSession(boolean create);
+
+    /**
+     * Logs out this Subject and invalidates and/or removes any associated entities,
+     * such as a {@link Session Session} and authorization data.  After this method is called, the Subject is
+     * considered 'anonymous' and may continue to be used for another log-in if desired.
+     * <h3>Web Environment Warning</h3>
+     * Calling this method in web environments will usually remove any associated session cookie as part of
+     * session invalidation.  Because cookies are part of the HTTP header, and headers can only be set before the
+     * response body (html, image, etc) is sent, this method in web environments must be called before <em>any</em>
+     * content has been rendered.
+     * <p/>
+     * The typical approach most applications use in this scenario is to redirect the user to a different
+     * location (e.g. home page) immediately after calling this method.  This is an effect of the HTTP protocol
+     * itself and not a reflection of Shiro's implementation.
+     * <p/>
+     * Non-HTTP environments may of course use a logged-out subject for login again if desired.
+     */
+    void logout();
+
+    /**
+     * Associates the specified {@code Callable} with this {@code Subject} instance and then executes it on the
+     * currently running thread.  If you want to execute the {@code Callable} on a different thread, it is better to
+     * use the {@link #associateWith(Callable)} method instead.
+     *
+     * @param callable the Callable to associate with this subject and then execute.
+     * @param <V>      the type of return value the {@code Callable} will return
+     * @return the resulting object returned by the {@code Callable}'s execution.
+     * @throws ExecutionException if the {@code Callable}'s {@link Callable#call call} method throws an exception.
+     * @since 1.0
+     */
+    <V> V execute(Callable<V> callable) throws ExecutionException;
+
+    /**
+     * Associates the specified {@code Runnable} with this {@code Subject} instance and then executes it on the
+     * currently running thread.  If you want to execute the {@code Runnable} on a different thread, it is better to
+     * use the {@link #associateWith(Runnable)} method instead.
+     * <p/>
+     * <b>Note</b>: This method is primarily provided to execute existing/legacy Runnable implementations.  It is better
+     * for new code to use {@link #execute(Callable)} since that supports the ability to return values and catch
+     * exceptions.
+     *
+     * @param runnable the {@code Runnable} to associate with this {@code Subject} and then execute.
+     * @since 1.0
+     */
+    void execute(Runnable runnable);
+
+    /**
+     * Returns a {@code Callable} instance matching the given argument while additionally ensuring that it will
+     * retain and execute under this Subject's identity.  The returned object can be used with an
+     * {@link java.util.concurrent.ExecutorService ExecutorService} to execute as this Subject.
+     * <p/>
+     * This will effectively ensure that any calls to
+     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()} and related functionality will continue
+     * to function properly on any thread that executes the returned {@code Callable} instance.
+     *
+     * @param callable the callable to execute as this {@code Subject}
+     * @param <V>      the {@code Callable}s return value type
+     * @return a {@code Callable} that can be run as this {@code Subject}.
+     * @since 1.0
+     */
+    <V> Callable<V> associateWith(Callable<V> callable);
+
+    /**
+     * Returns a {@code Runnable} instance matching the given argument while additionally ensuring that it will
+     * retain and execute under this Subject's identity.  The returned object can be used with an
+     * {@link java.util.concurrent.Executor Executor} or another thread to execute as this Subject.
+     * <p/>
+     * This will effectively ensure that any calls to
+     * {@code SecurityUtils}.{@link SecurityUtils#getSubject() getSubject()} and related functionality will continue
+     * to function properly on any thread that executes the returned {@code Runnable} instance.
+     * <p/>
+     * *Note that if you need a return value to be returned as a result of the runnable's execution or if you need to
+     * react to any Exceptions, it is highly recommended to use the
+     * {@link #associateWith(java.util.concurrent.Callable) createCallable} method instead of this one.
+     *
+     * @param runnable the runnable to execute as this {@code Subject}
+     * @return a {@code Runnable} that can be run as this {@code Subject} on another thread.
+     * @see #associateWith (java.util.concurrent.Callable)
+     * @since 1.0
+     */
+    Runnable associateWith(Runnable runnable);
+
+    /**
+     * Allows this subject to 'run as' or 'assume' another identity indefinitely.  This can only be
+     * called when the {@code Subject} instance already has an identity (i.e. they are remembered from a previous
+     * log-in or they have authenticated during their current session).
+     * <p/>
+     * Some notes about {@code runAs}:
+     * <ul>
+     * <li>You can tell if a {@code Subject} is 'running as' another identity by calling the
+     * {@link #isRunAs() isRunAs()} method.</li>
+     * <li>If running as another identity, you can determine what the previous 'pre run as' identity
+     * was by calling the {@link #getPreviousPrincipals() getPreviousPrincipals()} method.</li>
+     * <li>When you want a {@code Subject} to stop running as another identity, you can return to its previous
+     * 'pre run as' identity by calling the {@link #releaseRunAs() releaseRunAs()} method.</li>
+     * </ul>
+     *
+     * @param principals the identity to 'run as', aka the identity to <em>assume</em> indefinitely.
+     * @throws NullPointerException  if the specified principals collection is {@code null} or empty.
+     * @throws IllegalStateException if this {@code Subject} does not yet have an identity of its own.
+     * @since 1.0
+     */
+    void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;
+
+    /**
+     * Returns {@code true} if this {@code Subject} is 'running as' another identity other than its original one or
+     * {@code false} otherwise (normal {@code Subject} state).  See the {@link #runAs runAs} method for more
+     * information.
+     *
+     * @return {@code true} if this {@code Subject} is 'running as' another identity other than its original one or
+     *         {@code false} otherwise (normal {@code Subject} state).
+     * @see #runAs
+     * @since 1.0
+     */
+    boolean isRunAs();
+
+    /**
+     * Returns the previous 'pre run as' identity of this {@code Subject} before assuming the current
+     * {@link #runAs runAs} identity, or {@code null} if this {@code Subject} is not operating under an assumed
+     * identity (normal state). See the {@link #runAs runAs} method for more information.
+     *
+     * @return the previous 'pre run as' identity of this {@code Subject} before assuming the current
+     *         {@link #runAs runAs} identity, or {@code null} if this {@code Subject} is not operating under an assumed
+     *         identity (normal state).
+     * @see #runAs
+     * @since 1.0
+     */
+    PrincipalCollection getPreviousPrincipals();
+
+    /**
+     * Releases the current 'run as' (assumed) identity and reverts back to the previous 'pre run as'
+     * identity that existed before {@code #runAs runAs} was called.
+     * <p/>
+     * This method returne 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not
+     * operating under an assumed identity.
+     *
+     * @return the 'run as' (assumed) identity being released or {@code null} if this {@code Subject} is not operating
+     *         under an assumed identity.
+     * @see #runAs
+     * @since 1.0
+     */
+    PrincipalCollection releaseRunAs();
+
+    /**
+     * Builder design pattern implementation for creating {@link Subject} instances in a simplified way without
+     * requiring knowledge of Shiro's construction techniques.
+     * <p/>
+     * <b>NOTE</b>: This is provided for framework development support only and should typically never be used by
+     * application developers.  {@code Subject} instances should generally be acquired by using
+     * <code>SecurityUtils.{@link SecurityUtils#getSubject() getSubject()}</code>
+     * <h4>Usage</h4>
+     * The simplest usage of this builder is to construct an anonymous, session-less {@code Subject} instance:
+     * <pre>
+     * Subject subject = new Subject.{@link #Builder() Builder}().{@link #buildSubject() buildSubject()};</pre>
+     * The default, no-arg {@code Subject.Builder()} constructor shown above will use the application's
+     * currently accessible {@code SecurityManager} via
+     * <code>SecurityUtils.{@link SecurityUtils#getSecurityManager() getSecurityManager()}</code>.  You may also
+     * specify the exact {@code SecurityManager} instance to be used by the additional
+     * <code>Subject.{@link #Builder(org.apache.shiro.mgt.SecurityManager) Builder(securityManager)}</code>
+     * constructor if desired.
+     * <p/>
+     * All other methods may be called before the {@link #buildSubject() buildSubject()} method to
+     * provide context on how to construct the {@code Subject} instance.  For example, if you have a session id and
+     * want to acquire the {@code Subject} that 'owns' that session (assuming the session exists and is not expired):
+     * <pre>
+     * Subject subject = new Subject.Builder().sessionId(sessionId).buildSubject();</pre>
+     * <p/>
+     * Similarly, if you want a {@code Subject} instance reflecting a certain identity:
+     * <pre>
+     * PrincipalCollection principals = new SimplePrincipalCollection("username", <em>yourRealmName</em>);
+     * Subject subject = new Subject.Builder().principals(principals).build();</pre>
+     * <p/>
+     * <b>Note*</b> that the returned {@code Subject} instance is <b>not</b> automatically bound to the application (thread)
+     * for further use.  That is,
+     * {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
+     * will not automatically return the same instance as what is returned by the builder.  It is up to the framework
+     * developer to bind the built {@code Subject} for continued use if desired.
+     *
+     * @since 1.0
+     */
+    public static class Builder {
+
+        /**
+         * Hold all contextual data via the Builder instance's method invocations to be sent to the
+         * {@code SecurityManager} during the {@link #buildSubject} call.
+         */
+        private final SubjectContext subjectContext;
+
+        /**
+         * The SecurityManager to invoke during the {@link #buildSubject} call.
+         */
+        private final SecurityManager securityManager;
+
+        /**
+         * Constructs a new {@link Subject.Builder} instance, using the {@code SecurityManager} instance available
+         * to the calling code as determined by a call to {@link org.apache.shiro.SecurityUtils#getSecurityManager()}
+         * to build the {@code Subject} instance.
+         */
+        public Builder() {
+            this(SecurityUtils.getSecurityManager());
+        }
+
+        /**
+         * Constructs a new {@link Subject.Builder} instance which will use the specified {@code SecurityManager} when
+         * building the {@code Subject} instance.
+         *
+         * @param securityManager the {@code SecurityManager} to use when building the {@code Subject} instance.
+         */
+        public Builder(SecurityManager securityManager) {
+            if (securityManager == null) {
+                throw new NullPointerException("SecurityManager method argument cannot be null.");
+            }
+            this.securityManager = securityManager;
+            this.subjectContext = newSubjectContextInstance();
+            if (this.subjectContext == null) {
+                throw new IllegalStateException("Subject instance returned from 'newSubjectContextInstance' " +
+                        "cannot be null.");
+            }
+            this.subjectContext.setSecurityManager(securityManager);
+        }
+
+        /**
+         * Creates a new {@code SubjectContext} instance to be used to populate with subject contextual data that
+         * will then be sent to the {@code SecurityManager} to create a new {@code Subject} instance.
+         *
+         * @return a new {@code SubjectContext} instance
+         */
+        protected SubjectContext newSubjectContextInstance() {
+            return new DefaultSubjectContext();
+        }
+
+        /**
+         * Returns the backing context used to build the {@code Subject} instance, available to subclasses
+         * since the {@code context} class attribute is marked as {@code private}.
+         *
+         * @return the backing context used to build the {@code Subject} instance, available to subclasses.
+         */
+        protected SubjectContext getSubjectContext() {
+            return this.subjectContext;
+        }
+
+        /**
+         * Enables building a {@link Subject Subject} instance that owns the {@link Session Session} with the
+         * specified {@code sessionId}.
+         * <p/>
+         * Usually when specifying a {@code sessionId}, no other {@code Builder} methods would be specified because
+         * everything else (principals, inet address, etc) can usually be reconstructed based on the referenced
+         * session alone.  In other words, this is almost always sufficient:
+         * <pre>
+         * new Subject.Builder().sessionId(sessionId).buildSubject();</pre>
+         * <p/>
+         * <b>Although simple in concept, this method provides very powerful functionality previously absent in almost
+         * all Java environments:</b>
+         * <p/>
+         * The ability to reference a {@code Subject} and their server-side session
+         * <em>across clients of different mediums</em> such as web applications, Java applets,
+         * standalone C# clients over XML-RPC and/or SOAP, and many others. This is a <em>huge</em>
+         * benefit in heterogeneous enterprise applications.
+         * <p/>
+         * To maintain session integrity across client mediums, the {@code sessionId} <b>must</b> be transmitted
+         * to all client mediums securely (e.g. over SSL) to prevent man-in-the-middle attacks.  This
+         * is nothing new - all web applications are susceptible to the same problem when transmitting
+         * {@code Cookie}s or when using URL rewriting.  As long as the
+         * {@code sessionId} is transmitted securely, session integrity can be maintained.
+         *
+         * @param sessionId the id of the session that backs the desired Subject being acquired.
+         * @return this {@code Builder} instance for method chaining.
+         */
+        public Builder sessionId(Serializable sessionId) {
+            if (sessionId != null) {
+                this.subjectContext.setSessionId(sessionId);
+            }
+            return this;
+        }
+
+        /**
+         * Ensures the {@code Subject} being built will reflect the specified host name or IP as its originating
+         * location.
+         *
+         * @param host the host name or IP address to use as the {@code Subject}'s originating location.
+         * @return this {@code Builder} instance for method chaining.
+         */
+        public Builder host(String host) {
+            if (StringUtils.hasText(host)) {
+                this.subjectContext.setHost(host);
+            }
+            return this;
+        }
+
+        /**
+         * Ensures the {@code Subject} being built will use the specified {@link Session} instance.  Note that it is
+         * more common to use the {@link #sessionId sessionId} builder method rather than having to construct a
+         * {@code Session} instance for this method.
+         *
+         * @param session the session to use as the {@code Subject}'s {@link Session}
+         * @return this {@code Builder} instance for method chaining.
+         */
+        public Builder session(Session session) {
+            if (session != null) {
+                this.subjectContext.setSession(session);
+            }
+            return this;
+        }
+
+        /**
+         * Ensures the {@code Subject} being built will reflect the specified principals (aka identity).
+         * <p/>
+         * For example, if your application's unique identifier for users is a {@code String} username, and you wanted
+         * to create a {@code Subject} instance that reflected a user whose username is
+         * '{@code jsmith}', and you knew the Realm that could acquire {@code jsmith}'s principals based on the username
+         * was named &quot;{@code myRealm}&quot;, you might create the '{@code jsmith} {@code Subject} instance this
+         * way:
+         * <pre>
+         * PrincipalCollection identity = new {@link org.apache.shiro.subject.SimplePrincipalCollection#SimplePrincipalCollection(Object, String) SimplePrincipalCollection}(&quot;jsmith&quot;, &quot;myRealm&quot;);
+         * Subject jsmith = new Subject.Builder().principals(identity).buildSubject();</pre>
+         * <p/>
+         * Similarly, if your application's unique identifier for users is a {@code long} value (such as might be used
+         * as a primary key in a relational database) and you were using a {@code JDBC}
+         * {@code Realm} named, (unimaginatively) &quot;jdbcRealm&quot;, you might create the Subject
+         * instance this way:
+         * <pre>
+         * long userId = //get user ID from somewhere
+         * PrincipalCollection userIdentity = new {@link org.apache.shiro.subject.SimplePrincipalCollection#SimplePrincipalCollection(Object, String) SimplePrincipalCollection}(<em>userId</em>, &quot;jdbcRealm&quot;);
+         * Subject user = new Subject.Builder().principals(identity).buildSubject();</pre>
+         *
+         * @param principals the principals to use as the {@code Subject}'s identity.
+         * @return this {@code Builder} instance for method chaining.
+         */
+        public Builder principals(PrincipalCollection principals) {
+            if (!CollectionUtils.isEmpty(principals)) {
+                this.subjectContext.setPrincipals(principals);
+            }
+            return this;
+        }
+
+        /**
+         * Ensures the {@code Subject} being built will be considered
+         * {@link org.apache.shiro.subject.Subject#isAuthenticated() authenticated}.  Per the
+         * {@link org.apache.shiro.subject.Subject#isAuthenticated() isAuthenticated()} JavaDoc, be careful
+         * when specifying {@code true} - you should know what you are doing and have a good reason for ignoring Shiro's
+         * default authentication state mechanisms.
+         *
+         * @param authenticated whether or not the built {@code Subject} will be considered authenticated.
+         * @return this {@code Builder} instance for method chaining.
+         * @see org.apache.shiro.subject.Subject#isAuthenticated()
+         */
+        public Builder authenticated(boolean authenticated) {
+            this.subjectContext.setAuthenticated(authenticated);
+            return this;
+        }
+
+        /**
+         * Allows custom attributes to be added to the underlying context {@code Map} used to construct the
+         * {@link Subject} instance.
+         * <p/>
+         * A {@code null} key throws an {@link IllegalArgumentException}. A {@code null} value effectively removes
+         * any previously stored attribute under the given key from the context map.
+         * <p/>
+         * <b>*NOTE*:</b> This method is only useful when configuring Shiro with a custom {@link SubjectFactory}
+         * implementation.  This method allows end-users to append additional data to the context map which the
+         * {@code SubjectFactory} implementation can use when building custom Subject instances. As such, this method
+         * is only useful when a custom {@code SubjectFactory} implementation has been configured.
+         *
+         * @param attributeKey   the key under which the corresponding value will be stored in the context {@code Map}.
+         * @param attributeValue the value to store in the context map under the specified {@code attributeKey}.
+         * @return this {@code Builder} instance for method chaining.
+         * @throws IllegalArgumentException if the {@code attributeKey} is {@code null}.
+         * @see SubjectFactory#createSubject(SubjectContext)
+         */
+        @SuppressWarnings({"UnusedDeclaration"})
+        public Builder contextAttribute(String attributeKey, Object attributeValue) {
+            if (attributeKey == null) {
+                String msg = "Subject context map key cannot be null.";
+                throw new IllegalArgumentException(msg);
+            }
+            if (attributeValue == null) {
+                this.subjectContext.remove(attributeKey);
+            } else {
+                this.subjectContext.put(attributeKey, attributeValue);
+            }
+            return this;
+        }
+
+        /**
+         * Creates and returns a new {@code Subject} instance reflecting the cumulative state acquired by the
+         * other methods in this class.
+         * <p/>
+         * This {@code Builder} instance will still retain the underlying state after this method is called - it
+         * will not clear it; repeated calls to this method will return multiple {@link Subject} instances, all
+         * reflecting the exact same state.  If a new (different) {@code Subject} is to be constructed, a new
+         * {@code Builder} instance must be created.
+         * <p/>
+         * <b>Note</b> that the returned {@code Subject} instance is <b>not</b> automatically bound to the application
+         * (thread) for further use.  That is,
+         * {@link org.apache.shiro.SecurityUtils SecurityUtils}.{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
+         * will not automatically return the same instance as what is returned by the builder.  It is up to the
+         * framework developer to bind the returned {@code Subject} for continued use if desired.
+         *
+         * @return a new {@code Subject} instance reflecting the cumulative state acquired by the
+         *         other methods in this class.
+         */
+        public Subject buildSubject() {
+            return this.securityManager.createSubject(this.subjectContext);
+        }
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/subject/support/SubjectCallable.java b/core/src/main/java/org/apache/shiro/subject/support/SubjectCallable.java
index 77e104d8d..d23971b7b 100644
--- a/core/src/main/java/org/apache/shiro/subject/support/SubjectCallable.java
+++ b/core/src/main/java/org/apache/shiro/subject/support/SubjectCallable.java
@@ -1,92 +1,92 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject.support;
-
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.ThreadState;
-
-import java.util.concurrent.Callable;
-
-/**
- * A {@code SubjectCallable} associates a {@link Subject Subject} with a target/delegate
- * {@link Callable Callable} to ensure proper {@code Subject} thread-state management when the {@code Callable} executes.
- * This ensures that any calls to {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
- * during the target {@code Callable}'s execution still work correctly even if the {@code Callable} executes on a
- * different thread than the one that created it.  This allows {@code Subject} access during asynchronous operations.
- * <p/>
- * When instances of this class execute (typically via a {@link java.util.concurrent.ExecutorService ExecutorService}),
- * the following occurs:
- * <ol>
- * <li>The specified Subject any of its associated thread state is first bound to the thread that executes the
- * {@code Callable}.</li>
- * <li>The delegate/target {@code Callable} is {@link java.util.concurrent.Callable#call() executed}</li>
- * <li>The previous thread state that might have existed before the {@code Subject} was bound is fully restored</li>
- * </ol>
- * <p/>
- * This behavior ensures that the thread that executes this {@code Callable}, which is often a different thread than
- * the one that created the instance, retains a {@code Subject} to support {@code SecurityUtils.getSubject()}
- * invocations. It also guarantees that the running thread remains 'clean' in any thread-pooled environments.
- *
- * <h3>Usage</h3>
- *
- * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
- * the {@code Subject.}{@link Subject#associateWith(Callable) associateWith} method, which will automatically return
- * an instance of this class.
- * <p/>
- * An even more convenient alternative is to use a
- * {@link org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService}, which
- * transparently uses instances of this class.
- *
- * @see Subject#associateWith(Callable)
- * @see org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService
- * @since 1.0
- */
-public class SubjectCallable<V> implements Callable<V> {
-
-    protected final ThreadState threadState;
-    private final Callable<V> callable;
-
-    public SubjectCallable(Subject subject, Callable<V> delegate) {
-        this(new SubjectThreadState(subject), delegate);
-    }
-
-    protected SubjectCallable(ThreadState threadState, Callable<V> delegate) {
-        if (threadState == null) {
-            throw new IllegalArgumentException("ThreadState argument cannot be null.");
-        }
-        this.threadState = threadState;
-        if (delegate == null) {
-            throw new IllegalArgumentException("Callable delegate instance cannot be null.");
-        }
-        this.callable = delegate;
-    }
-
-    public V call() throws Exception {
-        try {
-            threadState.bind();
-            return doCall(this.callable);
-        } finally {
-            threadState.restore();
-        }
-    }
-
-    protected V doCall(Callable<V> target) throws Exception {
-        return target.call();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject.support;
+
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.ThreadState;
+
+import java.util.concurrent.Callable;
+
+/**
+ * A {@code SubjectCallable} associates a {@link Subject Subject} with a target/delegate
+ * {@link Callable Callable} to ensure proper {@code Subject} thread-state management when the {@code Callable} executes.
+ * This ensures that any calls to {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()}
+ * during the target {@code Callable}'s execution still work correctly even if the {@code Callable} executes on a
+ * different thread than the one that created it.  This allows {@code Subject} access during asynchronous operations.
+ * <p/>
+ * When instances of this class execute (typically via a {@link java.util.concurrent.ExecutorService ExecutorService}),
+ * the following occurs:
+ * <ol>
+ * <li>The specified Subject any of its associated thread state is first bound to the thread that executes the
+ * {@code Callable}.</li>
+ * <li>The delegate/target {@code Callable} is {@link java.util.concurrent.Callable#call() executed}</li>
+ * <li>The previous thread state that might have existed before the {@code Subject} was bound is fully restored</li>
+ * </ol>
+ * <p/>
+ * This behavior ensures that the thread that executes this {@code Callable}, which is often a different thread than
+ * the one that created the instance, retains a {@code Subject} to support {@code SecurityUtils.getSubject()}
+ * invocations. It also guarantees that the running thread remains 'clean' in any thread-pooled environments.
+ *
+ * <h3>Usage</h3>
+ *
+ * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
+ * the {@code Subject.}{@link Subject#associateWith(Callable) associateWith} method, which will automatically return
+ * an instance of this class.
+ * <p/>
+ * An even more convenient alternative is to use a
+ * {@link org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService}, which
+ * transparently uses instances of this class.
+ *
+ * @see Subject#associateWith(Callable)
+ * @see org.apache.shiro.concurrent.SubjectAwareExecutorService SubjectAwareExecutorService
+ * @since 1.0
+ */
+public class SubjectCallable<V> implements Callable<V> {
+
+    protected final ThreadState threadState;
+    private final Callable<V> callable;
+
+    public SubjectCallable(Subject subject, Callable<V> delegate) {
+        this(new SubjectThreadState(subject), delegate);
+    }
+
+    protected SubjectCallable(ThreadState threadState, Callable<V> delegate) {
+        if (threadState == null) {
+            throw new IllegalArgumentException("ThreadState argument cannot be null.");
+        }
+        this.threadState = threadState;
+        if (delegate == null) {
+            throw new IllegalArgumentException("Callable delegate instance cannot be null.");
+        }
+        this.callable = delegate;
+    }
+
+    public V call() throws Exception {
+        try {
+            threadState.bind();
+            return doCall(this.callable);
+        } finally {
+            threadState.restore();
+        }
+    }
+
+    protected V doCall(Callable<V> target) throws Exception {
+        return target.call();
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/subject/support/SubjectRunnable.java b/core/src/main/java/org/apache/shiro/subject/support/SubjectRunnable.java
index 531f85e45..9e633dd41 100644
--- a/core/src/main/java/org/apache/shiro/subject/support/SubjectRunnable.java
+++ b/core/src/main/java/org/apache/shiro/subject/support/SubjectRunnable.java
@@ -1,122 +1,122 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject.support;
-
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.ThreadState;
-
-/**
- * A {@code SubjectRunnable} ensures that a target/delegate {@link Runnable Runnable} will execute such that any
- * call to {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} during the
- * {@code Runnable}'s execution will return the associated {@code Subject} instance.  The {@code SubjectRunnable}
- * instance can be run on any thread (the current thread or asynchronously on another thread) and the
- * {@code SecurityUtils.getSubject()} call will still work properly.  This implementation also guarantees that Shiro's
- * thread state will be identical before and after execution to ensure threads remain clean in any thread-pooled
- * environment.
- * <p/>
- * When instances of this class {@link Runnable#run() run()}, the following occurs:
- * <ol>
- * <li>The Subject and any of its associated thread state is first bound to the thread that executes the
- * {@code Runnable}.</li>
- * <li>The delegate/target {@code Runnable} is {@link #doRun(Runnable) run}</li>
- * <li>Any previous thread state that might have existed before the {@code Subject} was bound is fully restored</li>
- * </ol>
- * <p/>
- *
- * <h3>Usage</h3>
- *
- * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
- * the {@code Subject.}{@link Subject#execute(Runnable) execute} or
- * {@code Subject.}{@link Subject#associateWith(Runnable) associateWith} methods, which transparently perform the
- * necessary association logic.
- * <p/>
- * An even more convenient alternative is to use a
- * {@link org.apache.shiro.concurrent.SubjectAwareExecutor SubjectAwareExecutor}, which transparently uses
- * instances of this class but does not require referencing Shiro's API at all.
- *
- * @see Subject#associateWith(Runnable)
- * @see org.apache.shiro.concurrent.SubjectAwareExecutor SubjectAwareExecutor
- * @since 1.0
- */
-public class SubjectRunnable implements Runnable {
-
-    protected final ThreadState threadState;
-    private final Runnable runnable;
-
-    /**
-     * Creates a new {@code SubjectRunnable} that, when executed, will execute the target {@code delegate}, but
-     * guarantees that it will run associated with the specified {@code Subject}.
-     *
-     * @param subject  the Subject to associate with the delegate's execution.
-     * @param delegate the runnable to run.
-     */
-    public SubjectRunnable(Subject subject, Runnable delegate) {
-        this(new SubjectThreadState(subject), delegate);
-    }
-
-    /**
-     * Creates a new {@code SubjectRunnable} that, when executed, will perform thread state
-     * {@link ThreadState#bind binding} and guaranteed {@link ThreadState#restore restoration} before and after the
-     * {@link Runnable Runnable}'s execution, respectively.
-     *
-     * @param threadState the thread state to bind and unbind before and after the runnable's execution.
-     * @param delegate    the delegate {@code Runnable} to execute when this instance is {@link #run() run()}.
-     * @throws IllegalArgumentException if either the {@code ThreadState} or {@link Runnable} arguments are {@code null}.
-     */
-    protected SubjectRunnable(ThreadState threadState, Runnable delegate) throws IllegalArgumentException {
-        if (threadState == null) {
-            throw new IllegalArgumentException("ThreadState argument cannot be null.");
-        }
-        this.threadState = threadState;
-        if (delegate == null) {
-            throw new IllegalArgumentException("Runnable argument cannot be null.");
-        }
-        this.runnable = delegate;
-    }
-
-    /**
-     * {@link ThreadState#bind Bind}s the Subject thread state, executes the target {@code Runnable} and then guarantees
-     * the previous thread state's {@link ThreadState#restore restoration}:
-     * <pre>
-     * try {
-     *     threadState.{@link ThreadState#bind bind()};
-     *     {@link #doRun doRun}(targetRunnable);
-     * } finally {
-     *     threadState.{@link ThreadState#restore restore()}
-     * }
-     * </pre>
-     */
-    public void run() {
-        try {
-            threadState.bind();
-            doRun(this.runnable);
-        } finally {
-            threadState.restore();
-        }
-    }
-
-    /**
-     * Simply calls the target {@link Runnable Runnable}'s {@link Runnable#run run()} method.
-     *
-     * @param runnable the target runnable to run.
-     */
-    protected void doRun(Runnable runnable) {
-        runnable.run();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject.support;
+
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.ThreadState;
+
+/**
+ * A {@code SubjectRunnable} ensures that a target/delegate {@link Runnable Runnable} will execute such that any
+ * call to {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} during the
+ * {@code Runnable}'s execution will return the associated {@code Subject} instance.  The {@code SubjectRunnable}
+ * instance can be run on any thread (the current thread or asynchronously on another thread) and the
+ * {@code SecurityUtils.getSubject()} call will still work properly.  This implementation also guarantees that Shiro's
+ * thread state will be identical before and after execution to ensure threads remain clean in any thread-pooled
+ * environment.
+ * <p/>
+ * When instances of this class {@link Runnable#run() run()}, the following occurs:
+ * <ol>
+ * <li>The Subject and any of its associated thread state is first bound to the thread that executes the
+ * {@code Runnable}.</li>
+ * <li>The delegate/target {@code Runnable} is {@link #doRun(Runnable) run}</li>
+ * <li>Any previous thread state that might have existed before the {@code Subject} was bound is fully restored</li>
+ * </ol>
+ * <p/>
+ *
+ * <h3>Usage</h3>
+ *
+ * This is typically considered a support class and is not often directly referenced.  Most people prefer to use
+ * the {@code Subject.}{@link Subject#execute(Runnable) execute} or
+ * {@code Subject.}{@link Subject#associateWith(Runnable) associateWith} methods, which transparently perform the
+ * necessary association logic.
+ * <p/>
+ * An even more convenient alternative is to use a
+ * {@link org.apache.shiro.concurrent.SubjectAwareExecutor SubjectAwareExecutor}, which transparently uses
+ * instances of this class but does not require referencing Shiro's API at all.
+ *
+ * @see Subject#associateWith(Runnable)
+ * @see org.apache.shiro.concurrent.SubjectAwareExecutor SubjectAwareExecutor
+ * @since 1.0
+ */
+public class SubjectRunnable implements Runnable {
+
+    protected final ThreadState threadState;
+    private final Runnable runnable;
+
+    /**
+     * Creates a new {@code SubjectRunnable} that, when executed, will execute the target {@code delegate}, but
+     * guarantees that it will run associated with the specified {@code Subject}.
+     *
+     * @param subject  the Subject to associate with the delegate's execution.
+     * @param delegate the runnable to run.
+     */
+    public SubjectRunnable(Subject subject, Runnable delegate) {
+        this(new SubjectThreadState(subject), delegate);
+    }
+
+    /**
+     * Creates a new {@code SubjectRunnable} that, when executed, will perform thread state
+     * {@link ThreadState#bind binding} and guaranteed {@link ThreadState#restore restoration} before and after the
+     * {@link Runnable Runnable}'s execution, respectively.
+     *
+     * @param threadState the thread state to bind and unbind before and after the runnable's execution.
+     * @param delegate    the delegate {@code Runnable} to execute when this instance is {@link #run() run()}.
+     * @throws IllegalArgumentException if either the {@code ThreadState} or {@link Runnable} arguments are {@code null}.
+     */
+    protected SubjectRunnable(ThreadState threadState, Runnable delegate) throws IllegalArgumentException {
+        if (threadState == null) {
+            throw new IllegalArgumentException("ThreadState argument cannot be null.");
+        }
+        this.threadState = threadState;
+        if (delegate == null) {
+            throw new IllegalArgumentException("Runnable argument cannot be null.");
+        }
+        this.runnable = delegate;
+    }
+
+    /**
+     * {@link ThreadState#bind Bind}s the Subject thread state, executes the target {@code Runnable} and then guarantees
+     * the previous thread state's {@link ThreadState#restore restoration}:
+     * <pre>
+     * try {
+     *     threadState.{@link ThreadState#bind bind()};
+     *     {@link #doRun doRun}(targetRunnable);
+     * } finally {
+     *     threadState.{@link ThreadState#restore restore()}
+     * }
+     * </pre>
+     */
+    public void run() {
+        try {
+            threadState.bind();
+            doRun(this.runnable);
+        } finally {
+            threadState.restore();
+        }
+    }
+
+    /**
+     * Simply calls the target {@link Runnable Runnable}'s {@link Runnable#run run()} method.
+     *
+     * @param runnable the target runnable to run.
+     */
+    protected void doRun(Runnable runnable) {
+        runnable.run();
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/subject/support/SubjectThreadState.java b/core/src/main/java/org/apache/shiro/subject/support/SubjectThreadState.java
index 5e3c67c02..7fe82d8a5 100644
--- a/core/src/main/java/org/apache/shiro/subject/support/SubjectThreadState.java
+++ b/core/src/main/java/org/apache/shiro/subject/support/SubjectThreadState.java
@@ -1,125 +1,125 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject.support;
-
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.ThreadContext;
-import org.apache.shiro.util.ThreadState;
-
-import java.util.Map;
-
-/**
- * Manages thread-state for {@link Subject Subject} access (supporting
- * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls)
- * during a thread's execution.
- * <p/>
- * The {@link #bind bind} method will bind a {@link Subject} and a
- * {@link org.apache.shiro.mgt.SecurityManager SecurityManager} to the {@link ThreadContext} so they can be retrieved
- * from the {@code ThreadContext} later by any
- * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls that might occur during
- * the thread's execution.
- *
- * @since 1.0
- * @author Les Hazlewood
- */
-public class SubjectThreadState implements ThreadState {
-
-    private Map<Object, Object> originalResources;
-
-    private final Subject subject;
-    private transient SecurityManager securityManager;
-
-    /**
-     * Creates a new {@code SubjectThreadState} that will bind and unbind the specified {@code Subject} to the
-     * thread
-     *
-     * @param subject the {@code Subject} instance to bind and unbind from the {@link ThreadContext}.
-     */
-    public SubjectThreadState(Subject subject) {
-        if (subject == null) {
-            throw new IllegalArgumentException("Subject argument cannot be null.");
-        }
-        this.subject = subject;
-
-        SecurityManager securityManager = null;
-        if ( subject instanceof DelegatingSubject) {
-            securityManager = ((DelegatingSubject)subject).getSecurityManager();
-        }
-        if ( securityManager == null) {
-            securityManager = ThreadContext.getSecurityManager();
-        }
-        this.securityManager = securityManager;
-    }
-
-    /**
-     * Returns the {@code Subject} instance managed by this {@code ThreadState} implementation.
-     *
-     * @return the {@code Subject} instance managed by this {@code ThreadState} implementation.
-     */
-    protected Subject getSubject() {
-        return this.subject;
-    }
-
-    /**
-     * Binds a {@link Subject} and {@link org.apache.shiro.mgt.SecurityManager SecurityManager} to the
-     * {@link ThreadContext} so they can be retrieved later by any
-     * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls that might occur
-     * during the thread's execution.
-     * <p/>
-     * Prior to binding, the {@code ThreadContext}'s existing {@link ThreadContext#getResources() resources} are
-     * retained so they can be restored later via the {@link #restore restore} call.
-     */
-    public void bind() {
-        SecurityManager securityManager = this.securityManager;
-        if ( securityManager == null ) {
-            //try just in case the constructor didn't find one at the time:
-            securityManager = ThreadContext.getSecurityManager();
-        }
-        this.originalResources = ThreadContext.getResources();
-        ThreadContext.remove();
-
-        ThreadContext.bind(this.subject);
-        if (securityManager != null) {
-            ThreadContext.bind(securityManager);
-        }
-    }
-
-    /**
-     * {@link ThreadContext#remove Remove}s all thread-state that was bound by this instance.  If any previous
-     * thread-bound resources existed prior to the {@link #bind bind} call, they are restored back to the
-     * {@code ThreadContext} to ensure the thread state is exactly as it was before binding.
-     */
-    public void restore() {
-        ThreadContext.remove();
-        if (!CollectionUtils.isEmpty(this.originalResources)) {
-            ThreadContext.setResources(this.originalResources);
-        }
-    }
-
-    /**
-     * Completely {@link ThreadContext#remove removes} the {@code ThreadContext} state.  Typically this method should
-     * only be called in special cases - it is more 'correct' to {@link #restore restore} a thread to its previous
-     * state than to clear it entirely.
-     */
-    public void clear() {
-        ThreadContext.remove();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject.support;
+
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.ThreadContext;
+import org.apache.shiro.util.ThreadState;
+
+import java.util.Map;
+
+/**
+ * Manages thread-state for {@link Subject Subject} access (supporting
+ * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls)
+ * during a thread's execution.
+ * <p/>
+ * The {@link #bind bind} method will bind a {@link Subject} and a
+ * {@link org.apache.shiro.mgt.SecurityManager SecurityManager} to the {@link ThreadContext} so they can be retrieved
+ * from the {@code ThreadContext} later by any
+ * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls that might occur during
+ * the thread's execution.
+ *
+ * @since 1.0
+ * @author Les Hazlewood
+ */
+public class SubjectThreadState implements ThreadState {
+
+    private Map<Object, Object> originalResources;
+
+    private final Subject subject;
+    private transient SecurityManager securityManager;
+
+    /**
+     * Creates a new {@code SubjectThreadState} that will bind and unbind the specified {@code Subject} to the
+     * thread
+     *
+     * @param subject the {@code Subject} instance to bind and unbind from the {@link ThreadContext}.
+     */
+    public SubjectThreadState(Subject subject) {
+        if (subject == null) {
+            throw new IllegalArgumentException("Subject argument cannot be null.");
+        }
+        this.subject = subject;
+
+        SecurityManager securityManager = null;
+        if ( subject instanceof DelegatingSubject) {
+            securityManager = ((DelegatingSubject)subject).getSecurityManager();
+        }
+        if ( securityManager == null) {
+            securityManager = ThreadContext.getSecurityManager();
+        }
+        this.securityManager = securityManager;
+    }
+
+    /**
+     * Returns the {@code Subject} instance managed by this {@code ThreadState} implementation.
+     *
+     * @return the {@code Subject} instance managed by this {@code ThreadState} implementation.
+     */
+    protected Subject getSubject() {
+        return this.subject;
+    }
+
+    /**
+     * Binds a {@link Subject} and {@link org.apache.shiro.mgt.SecurityManager SecurityManager} to the
+     * {@link ThreadContext} so they can be retrieved later by any
+     * {@code SecurityUtils.}{@link org.apache.shiro.SecurityUtils#getSubject() getSubject()} calls that might occur
+     * during the thread's execution.
+     * <p/>
+     * Prior to binding, the {@code ThreadContext}'s existing {@link ThreadContext#getResources() resources} are
+     * retained so they can be restored later via the {@link #restore restore} call.
+     */
+    public void bind() {
+        SecurityManager securityManager = this.securityManager;
+        if ( securityManager == null ) {
+            //try just in case the constructor didn't find one at the time:
+            securityManager = ThreadContext.getSecurityManager();
+        }
+        this.originalResources = ThreadContext.getResources();
+        ThreadContext.remove();
+
+        ThreadContext.bind(this.subject);
+        if (securityManager != null) {
+            ThreadContext.bind(securityManager);
+        }
+    }
+
+    /**
+     * {@link ThreadContext#remove Remove}s all thread-state that was bound by this instance.  If any previous
+     * thread-bound resources existed prior to the {@link #bind bind} call, they are restored back to the
+     * {@code ThreadContext} to ensure the thread state is exactly as it was before binding.
+     */
+    public void restore() {
+        ThreadContext.remove();
+        if (!CollectionUtils.isEmpty(this.originalResources)) {
+            ThreadContext.setResources(this.originalResources);
+        }
+    }
+
+    /**
+     * Completely {@link ThreadContext#remove removes} the {@code ThreadContext} state.  Typically this method should
+     * only be called in special cases - it is more 'correct' to {@link #restore restore} a thread to its previous
+     * state than to clear it entirely.
+     */
+    public void clear() {
+        ThreadContext.remove();
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/util/Factory.java b/core/src/main/java/org/apache/shiro/util/Factory.java
index 1ac8d6655..908d31ae3 100644
--- a/core/src/main/java/org/apache/shiro/util/Factory.java
+++ b/core/src/main/java/org/apache/shiro/util/Factory.java
@@ -1,37 +1,37 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-/**
- * Generics-aware interface supporting the
- * <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> design pattern.
- *
- * @param <T> The type of the instance returned by the Factory implementation.
- * @since 1.0
- */
-public interface Factory<T> {
-
-    /**
-     * Returns an instance of the required type.  The implementation determines whether or not a new or cached
-     * instance is created every time this method is called.
-     *
-     * @return an instance of the required type.
-     */
-    T getInstance();
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+/**
+ * Generics-aware interface supporting the
+ * <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> design pattern.
+ *
+ * @param <T> The type of the instance returned by the Factory implementation.
+ * @since 1.0
+ */
+public interface Factory<T> {
+
+    /**
+     * Returns an instance of the required type.  The implementation determines whether or not a new or cached
+     * instance is created every time this method is called.
+     *
+     * @return an instance of the required type.
+     */
+    T getInstance();
+}
diff --git a/core/src/main/java/org/apache/shiro/util/JdbcUtils.java b/core/src/main/java/org/apache/shiro/util/JdbcUtils.java
index 05262925b..b5c4473bc 100644
--- a/core/src/main/java/org/apache/shiro/util/JdbcUtils.java
+++ b/core/src/main/java/org/apache/shiro/util/JdbcUtils.java
@@ -1,116 +1,116 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-import java.sql.Connection;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * A set of static helper methods for managing JDBC API objects.
- * <p/>
- * <em>Note:</em> Some parts of this class were copied from the Spring Framework and then modified.
- * They were copied here to prevent Spring dependencies in the Shiro core API.  The original license conditions
- * (Apache 2.0) have been maintained.
- *
- * @author Jeremy Haile
- * @since 0.2
- */
-public class JdbcUtils {
-
-    /** Private internal log instance. */
-    private static final Logger log = LoggerFactory.getLogger(JdbcUtils.class);
-
-    /**
-     * Private constructor to prevent instantiation.
-     */
-    private JdbcUtils() {
-    }
-
-    /**
-     * Close the given JDBC Connection and ignore any thrown exception.
-     * This is useful for typical finally blocks in manual JDBC code.
-     *
-     * @param connection the JDBC Connection to close (may be <tt>null</tt>)
-     */
-    public static void closeConnection(Connection connection) {
-        if (connection != null) {
-            try {
-                connection.close();
-            } catch (SQLException ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Could not close JDBC Connection", ex);
-                }
-            } catch (Throwable ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Unexpected exception on closing JDBC Connection", ex);
-                }
-            }
-        }
-    }
-
-    /**
-     * Close the given JDBC Statement and ignore any thrown exception.
-     * This is useful for typical finally blocks in manual JDBC code.
-     *
-     * @param statement the JDBC Statement to close (may be <tt>null</tt>)
-     */
-    public static void closeStatement(Statement statement) {
-        if (statement != null) {
-            try {
-                statement.close();
-            } catch (SQLException ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Could not close JDBC Statement", ex);
-                }
-            } catch (Throwable ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Unexpected exception on closing JDBC Statement", ex);
-                }
-            }
-        }
-    }
-
-    /**
-     * Close the given JDBC ResultSet and ignore any thrown exception.
-     * This is useful for typical finally blocks in manual JDBC code.
-     *
-     * @param rs the JDBC ResultSet to close (may be <tt>null</tt>)
-     */
-    public static void closeResultSet(ResultSet rs) {
-        if (rs != null) {
-            try {
-                rs.close();
-            } catch (SQLException ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Could not close JDBC ResultSet", ex);
-                }
-            } catch (Throwable ex) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Unexpected exception on closing JDBC ResultSet", ex);
-                }
-            }
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A set of static helper methods for managing JDBC API objects.
+ * <p/>
+ * <em>Note:</em> Some parts of this class were copied from the Spring Framework and then modified.
+ * They were copied here to prevent Spring dependencies in the Shiro core API.  The original license conditions
+ * (Apache 2.0) have been maintained.
+ *
+ * @author Jeremy Haile
+ * @since 0.2
+ */
+public class JdbcUtils {
+
+    /** Private internal log instance. */
+    private static final Logger log = LoggerFactory.getLogger(JdbcUtils.class);
+
+    /**
+     * Private constructor to prevent instantiation.
+     */
+    private JdbcUtils() {
+    }
+
+    /**
+     * Close the given JDBC Connection and ignore any thrown exception.
+     * This is useful for typical finally blocks in manual JDBC code.
+     *
+     * @param connection the JDBC Connection to close (may be <tt>null</tt>)
+     */
+    public static void closeConnection(Connection connection) {
+        if (connection != null) {
+            try {
+                connection.close();
+            } catch (SQLException ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Could not close JDBC Connection", ex);
+                }
+            } catch (Throwable ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unexpected exception on closing JDBC Connection", ex);
+                }
+            }
+        }
+    }
+
+    /**
+     * Close the given JDBC Statement and ignore any thrown exception.
+     * This is useful for typical finally blocks in manual JDBC code.
+     *
+     * @param statement the JDBC Statement to close (may be <tt>null</tt>)
+     */
+    public static void closeStatement(Statement statement) {
+        if (statement != null) {
+            try {
+                statement.close();
+            } catch (SQLException ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Could not close JDBC Statement", ex);
+                }
+            } catch (Throwable ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unexpected exception on closing JDBC Statement", ex);
+                }
+            }
+        }
+    }
+
+    /**
+     * Close the given JDBC ResultSet and ignore any thrown exception.
+     * This is useful for typical finally blocks in manual JDBC code.
+     *
+     * @param rs the JDBC ResultSet to close (may be <tt>null</tt>)
+     */
+    public static void closeResultSet(ResultSet rs) {
+        if (rs != null) {
+            try {
+                rs.close();
+            } catch (SQLException ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Could not close JDBC ResultSet", ex);
+                }
+            } catch (Throwable ex) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unexpected exception on closing JDBC ResultSet", ex);
+                }
+            }
+        }
+    }
+
+}
diff --git a/core/src/main/java/org/apache/shiro/util/LifecycleUtils.java b/core/src/main/java/org/apache/shiro/util/LifecycleUtils.java
index 1573a5c46..481e48875 100644
--- a/core/src/main/java/org/apache/shiro/util/LifecycleUtils.java
+++ b/core/src/main/java/org/apache/shiro/util/LifecycleUtils.java
@@ -1,101 +1,101 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-import org.apache.shiro.ShiroException;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.Collection;
-
-
-/**
- * Utility class to help call {@link org.apache.shiro.util.Initializable#init() Initializable.init()} and
- * {@link org.apache.shiro.util.Destroyable#destroy() Destroyable.destroy()} methods cleanly on any object.
- *
- * @author Les Hazlewood
- * @since 0.2
- */
-public abstract class LifecycleUtils {
-
-    private static final Logger log = LoggerFactory.getLogger(LifecycleUtils.class);
-
-    public static void init(Object o) throws ShiroException {
-        if (o instanceof Initializable) {
-            init((Initializable) o);
-        }
-    }
-
-    public static void init(Initializable initializable) throws ShiroException {
-        initializable.init();
-    }
-
-    /**
-     * Calls {@link #init(Object) init} for each object in the collection.  If the collection is {@code null} or empty,
-     * this method returns quietly.
-     *
-     * @param c the collection containing objects to {@link #init init}.
-     * @throws ShiroException if unable to initialize one or more instances.
-     * @since 0.9
-     */
-    public static void init(Collection c) throws ShiroException {
-        if (c == null || c.isEmpty()) {
-            return;
-        }
-        for (Object o : c) {
-            init(o);
-        }
-    }
-
-    public static void destroy(Object o) {
-        if (o instanceof Destroyable) {
-            destroy((Destroyable) o);
-        }
-    }
-
-    public static void destroy(Destroyable d) {
-        if (d != null) {
-            try {
-                d.destroy();
-            } catch (Throwable t) {
-                if (log.isDebugEnabled()) {
-                    String msg = "Unable to cleanly destroy instance [" + d + "] of type [" + d.getClass().getName() + "].";
-                    log.debug(msg, t);
-                }
-            }
-        }
-    }
-
-    /**
-     * Calls {@link #destroy(Object) destroy} for each object in the collection.
-     * If the collection is {@code null} or empty, this method returns quietly.
-     *
-     * @param c the collection of objects to destroy.
-     * @since 0.9
-     */
-    public static void destroy(Collection c) {
-        if (c == null || c.isEmpty()) {
-            return;
-        }
-
-        for (Object o : c) {
-            destroy(o);
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+import org.apache.shiro.ShiroException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Collection;
+
+
+/**
+ * Utility class to help call {@link org.apache.shiro.util.Initializable#init() Initializable.init()} and
+ * {@link org.apache.shiro.util.Destroyable#destroy() Destroyable.destroy()} methods cleanly on any object.
+ *
+ * @author Les Hazlewood
+ * @since 0.2
+ */
+public abstract class LifecycleUtils {
+
+    private static final Logger log = LoggerFactory.getLogger(LifecycleUtils.class);
+
+    public static void init(Object o) throws ShiroException {
+        if (o instanceof Initializable) {
+            init((Initializable) o);
+        }
+    }
+
+    public static void init(Initializable initializable) throws ShiroException {
+        initializable.init();
+    }
+
+    /**
+     * Calls {@link #init(Object) init} for each object in the collection.  If the collection is {@code null} or empty,
+     * this method returns quietly.
+     *
+     * @param c the collection containing objects to {@link #init init}.
+     * @throws ShiroException if unable to initialize one or more instances.
+     * @since 0.9
+     */
+    public static void init(Collection c) throws ShiroException {
+        if (c == null || c.isEmpty()) {
+            return;
+        }
+        for (Object o : c) {
+            init(o);
+        }
+    }
+
+    public static void destroy(Object o) {
+        if (o instanceof Destroyable) {
+            destroy((Destroyable) o);
+        }
+    }
+
+    public static void destroy(Destroyable d) {
+        if (d != null) {
+            try {
+                d.destroy();
+            } catch (Throwable t) {
+                if (log.isDebugEnabled()) {
+                    String msg = "Unable to cleanly destroy instance [" + d + "] of type [" + d.getClass().getName() + "].";
+                    log.debug(msg, t);
+                }
+            }
+        }
+    }
+
+    /**
+     * Calls {@link #destroy(Object) destroy} for each object in the collection.
+     * If the collection is {@code null} or empty, this method returns quietly.
+     *
+     * @param c the collection of objects to destroy.
+     * @since 0.9
+     */
+    public static void destroy(Collection c) {
+        if (c == null || c.isEmpty()) {
+            return;
+        }
+
+        for (Object o : c) {
+            destroy(o);
+        }
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/util/PatternMatcher.java b/core/src/main/java/org/apache/shiro/util/PatternMatcher.java
index 84d8ce974..aa7d2cf01 100644
--- a/core/src/main/java/org/apache/shiro/util/PatternMatcher.java
+++ b/core/src/main/java/org/apache/shiro/util/PatternMatcher.java
@@ -1,43 +1,43 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-/**
- * Interface for components that can match source strings against a specified pattern string.
- * <p/>
- * Different implementations can support different pattern types, for example, Ant style path expressions, or
- * regular expressions, or other types of text based patterns.
- *
- * @author Les Hazlewood
- * @see org.apache.shiro.util.AntPathMatcher AntPathMatcher
- * @since 0.9 RC2
- */
-public interface PatternMatcher {
-
-    /**
-     * Returns <code>true</code> if the given <code>source</code> matches the specified <code>pattern</code>,
-     * <code>false</code> otherwise.
-     *
-     * @param pattern the pattern to match against
-     * @param source  the source to match
-     * @return <code>true</code> if the given <code>source</code> matches the specified <code>pattern</code>,
-     *         <code>false</code> otherwise.
-     */
-    boolean matches(String pattern, String source);
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+/**
+ * Interface for components that can match source strings against a specified pattern string.
+ * <p/>
+ * Different implementations can support different pattern types, for example, Ant style path expressions, or
+ * regular expressions, or other types of text based patterns.
+ *
+ * @author Les Hazlewood
+ * @see org.apache.shiro.util.AntPathMatcher AntPathMatcher
+ * @since 0.9 RC2
+ */
+public interface PatternMatcher {
+
+    /**
+     * Returns <code>true</code> if the given <code>source</code> matches the specified <code>pattern</code>,
+     * <code>false</code> otherwise.
+     *
+     * @param pattern the pattern to match against
+     * @param source  the source to match
+     * @return <code>true</code> if the given <code>source</code> matches the specified <code>pattern</code>,
+     *         <code>false</code> otherwise.
+     */
+    boolean matches(String pattern, String source);
+}
diff --git a/core/src/main/java/org/apache/shiro/util/RegExPatternMatcher.java b/core/src/main/java/org/apache/shiro/util/RegExPatternMatcher.java
index 42bc62a6c..21c28f966 100644
--- a/core/src/main/java/org/apache/shiro/util/RegExPatternMatcher.java
+++ b/core/src/main/java/org/apache/shiro/util/RegExPatternMatcher.java
@@ -1,53 +1,53 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-import java.util.regex.Pattern;
-import java.util.regex.Matcher;
-
-/**
- * {@code PatternMatcher} implementation that uses standard {@link java.util.regex} objects.
- *
- * @see Pattern
- * @author Les Hazlewood
- * @since 1.0
- */
-public class RegExPatternMatcher implements PatternMatcher {
-
-    /**
-     * Simple implementation that merely uses the default pattern comparison logic provided by the
-     * JDK.
-     * <p/>This implementation essentially executes the following:
-     * <pre>
-     * Pattern p = Pattern.compile(pattern);
-     * Matcher m = p.matcher(source);
-     * return m.matches();</pre>
-     * @param pattern the pattern to match against
-     * @param source  the source to match
-     * @return {@code true} if the source matches the required pattern, {@code false} otherwise.
-     */
-    public boolean matches(String pattern, String source) {
-        if (pattern == null) {
-            throw new IllegalArgumentException("pattern argument cannot be null.");
-        }
-        Pattern p = Pattern.compile(pattern);
-        Matcher m = p.matcher(source);
-        return m.matches();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+/**
+ * {@code PatternMatcher} implementation that uses standard {@link java.util.regex} objects.
+ *
+ * @see Pattern
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public class RegExPatternMatcher implements PatternMatcher {
+
+    /**
+     * Simple implementation that merely uses the default pattern comparison logic provided by the
+     * JDK.
+     * <p/>This implementation essentially executes the following:
+     * <pre>
+     * Pattern p = Pattern.compile(pattern);
+     * Matcher m = p.matcher(source);
+     * return m.matches();</pre>
+     * @param pattern the pattern to match against
+     * @param source  the source to match
+     * @return {@code true} if the source matches the required pattern, {@code false} otherwise.
+     */
+    public boolean matches(String pattern, String source) {
+        if (pattern == null) {
+            throw new IllegalArgumentException("pattern argument cannot be null.");
+        }
+        Pattern p = Pattern.compile(pattern);
+        Matcher m = p.matcher(source);
+        return m.matches();
+    }
+}
diff --git a/core/src/main/java/org/apache/shiro/util/ThreadState.java b/core/src/main/java/org/apache/shiro/util/ThreadState.java
index cefdef0d5..75b271eef 100644
--- a/core/src/main/java/org/apache/shiro/util/ThreadState.java
+++ b/core/src/main/java/org/apache/shiro/util/ThreadState.java
@@ -1,84 +1,84 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-/**
- * A {@code ThreadState} instance manages any state that might need to be bound and/or restored during a thread's
- * execution.
- * <h3>Usage</h3>
- * Calling {@link #bind bind()} will place state on the currently executing thread to be accessed later during
- * the thread's execution.
- * <h4>WARNING</h4>
- * After the thread is finished executing, or if an exception occurs, any previous state <b>MUST</b> be
- * {@link #restore restored} to guarantee all threads stay clean in any thread-pooled environment.  This should always
- * be done in a {@code try/finally} block:
- * <pre>
- * ThreadState state = //acquire or instantiate as necessary
- * try {
- *     state.bind();
- *     doSomething(); //execute any logic downstream logic that might need to access the state
- * } <b>finally {
- *     state.restore();
- * }</b>
- * </pre>
- *
- * @since 1.0
- */
-public interface ThreadState {
-
-    /**
-     * Binds any state that should be made accessible during a thread's execution.  This should typically always
-     * be called in a {@code try/finally} block paired with the {@link #restore} call to guarantee that the thread
-     * is cleanly restored back to its original state.  For example:
-     * <pre>
-     * ThreadState state = //acquire or instantiate as necessary
-     * <b>try {
-     *     state.bind();
-     *     doSomething(); //execute any logic downstream logic that might need to access the state
-     * } </b> finally {
-     *     state.restore();
-     * }
-     * </pre>
-     */
-    void bind();
-
-    /**
-     * Restores a thread to its state before bind {@link #bind bind} was invoked.  This should typically always be
-     * called in a {@code finally} block to guarantee that the thread is cleanly restored back to its original state
-     * before {@link #bind bind}'s bind was called.  For example:
-     * <pre>
-     * ThreadState state = //acquire or instantiate as necessary
-     * try {
-     *     state.bind();
-     *     doSomething(); //execute any logic downstream logic that might need to access the state
-     * } <b>finally {
-     *     state.restore();
-     * }</b>
-     * </pre>
-     */
-    void restore();
-
-    /**
-     * Completely clears/removes the {@code ThreadContext} state.  Typically this method should
-     * only be called in special cases - it is more 'correct' to {@link #restore restore} a thread to its previous
-     * state than to clear it entirely.
-     */
-    void clear();
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+/**
+ * A {@code ThreadState} instance manages any state that might need to be bound and/or restored during a thread's
+ * execution.
+ * <h3>Usage</h3>
+ * Calling {@link #bind bind()} will place state on the currently executing thread to be accessed later during
+ * the thread's execution.
+ * <h4>WARNING</h4>
+ * After the thread is finished executing, or if an exception occurs, any previous state <b>MUST</b> be
+ * {@link #restore restored} to guarantee all threads stay clean in any thread-pooled environment.  This should always
+ * be done in a {@code try/finally} block:
+ * <pre>
+ * ThreadState state = //acquire or instantiate as necessary
+ * try {
+ *     state.bind();
+ *     doSomething(); //execute any logic downstream logic that might need to access the state
+ * } <b>finally {
+ *     state.restore();
+ * }</b>
+ * </pre>
+ *
+ * @since 1.0
+ */
+public interface ThreadState {
+
+    /**
+     * Binds any state that should be made accessible during a thread's execution.  This should typically always
+     * be called in a {@code try/finally} block paired with the {@link #restore} call to guarantee that the thread
+     * is cleanly restored back to its original state.  For example:
+     * <pre>
+     * ThreadState state = //acquire or instantiate as necessary
+     * <b>try {
+     *     state.bind();
+     *     doSomething(); //execute any logic downstream logic that might need to access the state
+     * } </b> finally {
+     *     state.restore();
+     * }
+     * </pre>
+     */
+    void bind();
+
+    /**
+     * Restores a thread to its state before bind {@link #bind bind} was invoked.  This should typically always be
+     * called in a {@code finally} block to guarantee that the thread is cleanly restored back to its original state
+     * before {@link #bind bind}'s bind was called.  For example:
+     * <pre>
+     * ThreadState state = //acquire or instantiate as necessary
+     * try {
+     *     state.bind();
+     *     doSomething(); //execute any logic downstream logic that might need to access the state
+     * } <b>finally {
+     *     state.restore();
+     * }</b>
+     * </pre>
+     */
+    void restore();
+
+    /**
+     * Completely clears/removes the {@code ThreadContext} state.  Typically this method should
+     * only be called in special cases - it is more 'correct' to {@link #restore restore} a thread to its previous
+     * state than to clear it entirely.
+     */
+    void clear();
+
+}
diff --git a/core/src/test/java/org/apache/shiro/authc/SimpleAuthenticationInfoTest.java b/core/src/test/java/org/apache/shiro/authc/SimpleAuthenticationInfoTest.java
index f8c0e5c2a..ee7774566 100644
--- a/core/src/test/java/org/apache/shiro/authc/SimpleAuthenticationInfoTest.java
+++ b/core/src/test/java/org/apache/shiro/authc/SimpleAuthenticationInfoTest.java
@@ -1,93 +1,93 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authc;
-
-import static org.junit.Assert.assertEquals;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-
-import org.apache.shiro.subject.PrincipalCollection;
-import org.junit.Test;
-
-
-/**
- * @author Les Hazlewood
- * @author Kalle Korhonen
- * @since 0.9
- */
-public class SimpleAuthenticationInfoTest {
-
-    @Test
-    public void testMergeWithEmptyInstances() {
-        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
-        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo();
-        aggregate.merge(local);
-    }
-
-    /**
-     * Verifies fix for JSEC-122
-     */
-    @Test
-    public void testMergeWithAggregateNullCredentials() {
-        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
-        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");
-        aggregate.merge(local);
-    }
-    
-    @SuppressWarnings("serial")
-    @Test
-    public void testMergeWithImmutablePrincipalCollection() {
-        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
-        // Make a quick test fixture that does *not* implement MutablePrincipalCollection 
-        PrincipalCollection principalCollection = new PrincipalCollection() {
-	    @SuppressWarnings("unchecked")
-	    public List asList() { return null;}
-	    @SuppressWarnings("unchecked")
-	    public Set asSet() {return null;}
-	    public <T> Collection<T> byType(Class<T> type) {return null;}
-	    @SuppressWarnings("unchecked")
-	    public Collection fromRealm(String realmName) {
-		Collection<Object> principals = new HashSet<Object>();
-		principals.add("testprincipal");
-		return principals;
-	    }
-	    public Object getPrimaryPrincipal() {return null;}
-	    public Set<String> getRealmNames() {
-		Set<String> realms = new HashSet<String>();
-		realms.add("testrealm");
-		return realms;
-	    }
-	    public boolean isEmpty() {return false;}
-	    public <T> T oneByType(Class<T> type) {return null;}
-	    @SuppressWarnings("unchecked")
-	    public Iterator iterator() {return null;}
-            
-        };
-        aggregate.setPrincipals(principalCollection);
-        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");
-        aggregate.merge(local);
-        assertEquals(2, aggregate.getPrincipals().asList().size());
-    }
-    
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authc;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.shiro.subject.PrincipalCollection;
+import org.junit.Test;
+
+
+/**
+ * @author Les Hazlewood
+ * @author Kalle Korhonen
+ * @since 0.9
+ */
+public class SimpleAuthenticationInfoTest {
+
+    @Test
+    public void testMergeWithEmptyInstances() {
+        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
+        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo();
+        aggregate.merge(local);
+    }
+
+    /**
+     * Verifies fix for JSEC-122
+     */
+    @Test
+    public void testMergeWithAggregateNullCredentials() {
+        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
+        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");
+        aggregate.merge(local);
+    }
+    
+    @SuppressWarnings("serial")
+    @Test
+    public void testMergeWithImmutablePrincipalCollection() {
+        SimpleAuthenticationInfo aggregate = new SimpleAuthenticationInfo();
+        // Make a quick test fixture that does *not* implement MutablePrincipalCollection 
+        PrincipalCollection principalCollection = new PrincipalCollection() {
+	    @SuppressWarnings("unchecked")
+	    public List asList() { return null;}
+	    @SuppressWarnings("unchecked")
+	    public Set asSet() {return null;}
+	    public <T> Collection<T> byType(Class<T> type) {return null;}
+	    @SuppressWarnings("unchecked")
+	    public Collection fromRealm(String realmName) {
+		Collection<Object> principals = new HashSet<Object>();
+		principals.add("testprincipal");
+		return principals;
+	    }
+	    public Object getPrimaryPrincipal() {return null;}
+	    public Set<String> getRealmNames() {
+		Set<String> realms = new HashSet<String>();
+		realms.add("testrealm");
+		return realms;
+	    }
+	    public boolean isEmpty() {return false;}
+	    public <T> T oneByType(Class<T> type) {return null;}
+	    @SuppressWarnings("unchecked")
+	    public Iterator iterator() {return null;}
+            
+        };
+        aggregate.setPrincipals(principalCollection);
+        SimpleAuthenticationInfo local = new SimpleAuthenticationInfo("username", "password", "testRealm");
+        aggregate.merge(local);
+        assertEquals(2, aggregate.getPrincipals().asList().size());
+    }
+    
+}
diff --git a/core/src/test/java/org/apache/shiro/authz/AuthorizationExceptionTest.java b/core/src/test/java/org/apache/shiro/authz/AuthorizationExceptionTest.java
index 6a82a8b09..da6bfdbaa 100644
--- a/core/src/test/java/org/apache/shiro/authz/AuthorizationExceptionTest.java
+++ b/core/src/test/java/org/apache/shiro/authz/AuthorizationExceptionTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authz;
-
-import org.apache.shiro.ExceptionTest;
-
-
-/**
- * @author Les Hazlewood
- * @since Jun 10, 2008 4:03:56 PM
- */
-public class AuthorizationExceptionTest extends ExceptionTest {
-
-    protected Class getExceptionClass() {
-        return AuthorizationException.class;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authz;
+
+import org.apache.shiro.ExceptionTest;
+
+
+/**
+ * @author Les Hazlewood
+ * @since Jun 10, 2008 4:03:56 PM
+ */
+public class AuthorizationExceptionTest extends ExceptionTest {
+
+    protected Class getExceptionClass() {
+        return AuthorizationException.class;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/authz/HostUnauthorizedExceptionTest.java b/core/src/test/java/org/apache/shiro/authz/HostUnauthorizedExceptionTest.java
index f6c1a62d3..d1910adfa 100644
--- a/core/src/test/java/org/apache/shiro/authz/HostUnauthorizedExceptionTest.java
+++ b/core/src/test/java/org/apache/shiro/authz/HostUnauthorizedExceptionTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authz;
-
-import org.apache.shiro.ExceptionTest;
-
-
-/**
- * @author Les Hazlewood
- * @since Jun 10, 2008 4:04:38 PM
- */
-public class HostUnauthorizedExceptionTest extends ExceptionTest {
-
-    protected Class getExceptionClass() {
-        return HostUnauthorizedException.class;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authz;
+
+import org.apache.shiro.ExceptionTest;
+
+
+/**
+ * @author Les Hazlewood
+ * @since Jun 10, 2008 4:04:38 PM
+ */
+public class HostUnauthorizedExceptionTest extends ExceptionTest {
+
+    protected Class getExceptionClass() {
+        return HostUnauthorizedException.class;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/authz/UnauthenticatedExceptionTest.java b/core/src/test/java/org/apache/shiro/authz/UnauthenticatedExceptionTest.java
index 4b3ba2642..38cae39c6 100644
--- a/core/src/test/java/org/apache/shiro/authz/UnauthenticatedExceptionTest.java
+++ b/core/src/test/java/org/apache/shiro/authz/UnauthenticatedExceptionTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authz;
-
-import org.apache.shiro.ExceptionTest;
-
-
-/**
- * @author Les Hazlewood
- * @since Jun 10, 2008 4:06:15 PM
- */
-public class UnauthenticatedExceptionTest extends ExceptionTest {
-
-    protected Class getExceptionClass() {
-        return UnauthenticatedException.class;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authz;
+
+import org.apache.shiro.ExceptionTest;
+
+
+/**
+ * @author Les Hazlewood
+ * @since Jun 10, 2008 4:06:15 PM
+ */
+public class UnauthenticatedExceptionTest extends ExceptionTest {
+
+    protected Class getExceptionClass() {
+        return UnauthenticatedException.class;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/authz/UnauthorizedExceptionTest.java b/core/src/test/java/org/apache/shiro/authz/UnauthorizedExceptionTest.java
index d39ff435e..976c873e6 100644
--- a/core/src/test/java/org/apache/shiro/authz/UnauthorizedExceptionTest.java
+++ b/core/src/test/java/org/apache/shiro/authz/UnauthorizedExceptionTest.java
@@ -1,33 +1,33 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.authz;
-
-import org.apache.shiro.ExceptionTest;
-
-
-/**
- * @author Les Hazlewood
- * @since Jun 10, 2008 4:06:45 PM
- */
-public class UnauthorizedExceptionTest extends ExceptionTest {
-
-    protected Class getExceptionClass() {
-        return UnauthorizedException.class;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.authz;
+
+import org.apache.shiro.ExceptionTest;
+
+
+/**
+ * @author Les Hazlewood
+ * @since Jun 10, 2008 4:06:45 PM
+ */
+public class UnauthorizedExceptionTest extends ExceptionTest {
+
+    protected Class getExceptionClass() {
+        return UnauthorizedException.class;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorServiceTest.java b/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorServiceTest.java
index c43d4d357..7d6a025b6 100644
--- a/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorServiceTest.java
+++ b/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorServiceTest.java
@@ -1,75 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.concurrent;
-
-import org.apache.shiro.subject.support.SubjectRunnable;
-import org.apache.shiro.test.SecurityManagerTestSupport;
-import org.junit.Test;
-
-import java.util.concurrent.*;
-
-import static org.easymock.EasyMock.*;
-
-/**
- * Test cases for the {@link SubjectAwareExecutorService} implementation.
- */
-public class SubjectAwareExecutorServiceTest extends SecurityManagerTestSupport {
-
-    @SuppressWarnings({"unchecked"})
-    @Test
-    public void testSubmitRunnable() {
-        ExecutorService mockExecutorService = createNiceMock(ExecutorService.class);
-        expect(mockExecutorService.submit(isA(SubjectRunnable.class))).andReturn(new DummyFuture());
-        replay(mockExecutorService);
-
-        final SubjectAwareExecutorService executor = new SubjectAwareExecutorService(mockExecutorService);
-
-        Runnable testRunnable = new Runnable() {
-            public void run() {
-                System.out.println("Hello World");
-            }
-        };
-
-        executor.submit(testRunnable);
-        verify(mockExecutorService);
-    }
-
-    private class DummyFuture<V> implements Future<V> {
-
-        public boolean cancel(boolean b) {
-            return false;
-        }
-
-        public boolean isCancelled() {
-            return false;
-        }
-
-        public boolean isDone() {
-            return true;
-        }
-
-        public V get() throws InterruptedException, ExecutionException {
-            return null;
-        }
-
-        public V get(long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
-            return null;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.concurrent;
+
+import org.apache.shiro.subject.support.SubjectRunnable;
+import org.apache.shiro.test.SecurityManagerTestSupport;
+import org.junit.Test;
+
+import java.util.concurrent.*;
+
+import static org.easymock.EasyMock.*;
+
+/**
+ * Test cases for the {@link SubjectAwareExecutorService} implementation.
+ */
+public class SubjectAwareExecutorServiceTest extends SecurityManagerTestSupport {
+
+    @SuppressWarnings({"unchecked"})
+    @Test
+    public void testSubmitRunnable() {
+        ExecutorService mockExecutorService = createNiceMock(ExecutorService.class);
+        expect(mockExecutorService.submit(isA(SubjectRunnable.class))).andReturn(new DummyFuture());
+        replay(mockExecutorService);
+
+        final SubjectAwareExecutorService executor = new SubjectAwareExecutorService(mockExecutorService);
+
+        Runnable testRunnable = new Runnable() {
+            public void run() {
+                System.out.println("Hello World");
+            }
+        };
+
+        executor.submit(testRunnable);
+        verify(mockExecutorService);
+    }
+
+    private class DummyFuture<V> implements Future<V> {
+
+        public boolean cancel(boolean b) {
+            return false;
+        }
+
+        public boolean isCancelled() {
+            return false;
+        }
+
+        public boolean isDone() {
+            return true;
+        }
+
+        public V get() throws InterruptedException, ExecutionException {
+            return null;
+        }
+
+        public V get(long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
+            return null;
+        }
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorTest.java b/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorTest.java
index aa6389125..29d0148eb 100644
--- a/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorTest.java
+++ b/core/src/test/java/org/apache/shiro/concurrent/SubjectAwareExecutorTest.java
@@ -1,55 +1,55 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.concurrent;
-
-import org.apache.shiro.subject.support.SubjectRunnable;
-import org.apache.shiro.test.SecurityManagerTestSupport;
-import org.junit.Test;
-
-import java.util.concurrent.Executor;
-
-import static org.easymock.EasyMock.*;
-
-/**
- * Test cases for the {@link SubjectAwareExecutor} implementation.
- *
- * @since 1.0
- */
-public class SubjectAwareExecutorTest extends SecurityManagerTestSupport {
-
-    @Test
-    public void testExecute() {
-        Executor targetMockExecutor = createNiceMock(Executor.class);
-        //* ensure the target Executor receives a SubjectRunnable instance that retains the subject identity:
-        //(this is what verifies the test is valid):
-        targetMockExecutor.execute(isA(SubjectRunnable.class));
-        replay(targetMockExecutor);
-
-        final SubjectAwareExecutor executor = new SubjectAwareExecutor(targetMockExecutor);
-
-        Runnable work = new Runnable() {
-            public void run() {
-                System.out.println("Hello World");
-            }
-        };
-        executor.execute(work);
-
-        verify(targetMockExecutor);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.concurrent;
+
+import org.apache.shiro.subject.support.SubjectRunnable;
+import org.apache.shiro.test.SecurityManagerTestSupport;
+import org.junit.Test;
+
+import java.util.concurrent.Executor;
+
+import static org.easymock.EasyMock.*;
+
+/**
+ * Test cases for the {@link SubjectAwareExecutor} implementation.
+ *
+ * @since 1.0
+ */
+public class SubjectAwareExecutorTest extends SecurityManagerTestSupport {
+
+    @Test
+    public void testExecute() {
+        Executor targetMockExecutor = createNiceMock(Executor.class);
+        //* ensure the target Executor receives a SubjectRunnable instance that retains the subject identity:
+        //(this is what verifies the test is valid):
+        targetMockExecutor.execute(isA(SubjectRunnable.class));
+        replay(targetMockExecutor);
+
+        final SubjectAwareExecutor executor = new SubjectAwareExecutor(targetMockExecutor);
+
+        Runnable work = new Runnable() {
+            public void run() {
+                System.out.println("Hello World");
+            }
+        };
+        executor.execute(work);
+
+        verify(targetMockExecutor);
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/config/CompositeBean.java b/core/src/test/java/org/apache/shiro/config/CompositeBean.java
index 6c7347780..90e3220a8 100644
--- a/core/src/test/java/org/apache/shiro/config/CompositeBean.java
+++ b/core/src/test/java/org/apache/shiro/config/CompositeBean.java
@@ -1,109 +1,109 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * @author Les Hazlewood
- * @since Aug 5, 2008 10:17:37 AM
- */
-@SuppressWarnings({"UnusedDeclaration"})
-public class CompositeBean {
-
-    private String stringProp;
-    private boolean booleanProp;
-    private int intProp;
-    private SimpleBean simpleBean;
-
-    private Set<SimpleBean> simpleBeanSet;
-    private List<SimpleBean> simpleBeanList;
-    private Collection<SimpleBean> simpleBeanCollection;
-    private Map<String, SimpleBean> simpleBeanMap;
-
-    public CompositeBean() {
-    }
-
-    public String getStringProp() {
-        return stringProp;
-    }
-
-    public void setStringProp(String stringProp) {
-        this.stringProp = stringProp;
-    }
-
-    public boolean isBooleanProp() {
-        return booleanProp;
-    }
-
-    public void setBooleanProp(boolean booleanProp) {
-        this.booleanProp = booleanProp;
-    }
-
-    public int getIntProp() {
-        return intProp;
-    }
-
-    public void setIntProp(int intProp) {
-        this.intProp = intProp;
-    }
-
-    public SimpleBean getSimpleBean() {
-        return simpleBean;
-    }
-
-    public void setSimpleBean(SimpleBean simpleBean) {
-        this.simpleBean = simpleBean;
-    }
-
-    public Set<SimpleBean> getSimpleBeanSet() {
-        return simpleBeanSet;
-    }
-
-    public void setSimpleBeanSet(Set<SimpleBean> simpleBeanSet) {
-        this.simpleBeanSet = simpleBeanSet;
-    }
-
-    public List<SimpleBean> getSimpleBeanList() {
-        return simpleBeanList;
-    }
-
-    public void setSimpleBeanList(List<SimpleBean> simpleBeanList) {
-        this.simpleBeanList = simpleBeanList;
-    }
-
-    public Collection<SimpleBean> getSimpleBeanCollection() {
-        return simpleBeanCollection;
-    }
-
-    public void setSimpleBeanCollection(Collection<SimpleBean> simpleBeanCollection) {
-        this.simpleBeanCollection = simpleBeanCollection;
-    }
-
-    public Map<String, SimpleBean> getSimpleBeanMap() {
-        return simpleBeanMap;
-    }
-
-    public void setSimpleBeanMap(Map<String, SimpleBean> simpleBeanMap) {
-        this.simpleBeanMap = simpleBeanMap;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * @author Les Hazlewood
+ * @since Aug 5, 2008 10:17:37 AM
+ */
+@SuppressWarnings({"UnusedDeclaration"})
+public class CompositeBean {
+
+    private String stringProp;
+    private boolean booleanProp;
+    private int intProp;
+    private SimpleBean simpleBean;
+
+    private Set<SimpleBean> simpleBeanSet;
+    private List<SimpleBean> simpleBeanList;
+    private Collection<SimpleBean> simpleBeanCollection;
+    private Map<String, SimpleBean> simpleBeanMap;
+
+    public CompositeBean() {
+    }
+
+    public String getStringProp() {
+        return stringProp;
+    }
+
+    public void setStringProp(String stringProp) {
+        this.stringProp = stringProp;
+    }
+
+    public boolean isBooleanProp() {
+        return booleanProp;
+    }
+
+    public void setBooleanProp(boolean booleanProp) {
+        this.booleanProp = booleanProp;
+    }
+
+    public int getIntProp() {
+        return intProp;
+    }
+
+    public void setIntProp(int intProp) {
+        this.intProp = intProp;
+    }
+
+    public SimpleBean getSimpleBean() {
+        return simpleBean;
+    }
+
+    public void setSimpleBean(SimpleBean simpleBean) {
+        this.simpleBean = simpleBean;
+    }
+
+    public Set<SimpleBean> getSimpleBeanSet() {
+        return simpleBeanSet;
+    }
+
+    public void setSimpleBeanSet(Set<SimpleBean> simpleBeanSet) {
+        this.simpleBeanSet = simpleBeanSet;
+    }
+
+    public List<SimpleBean> getSimpleBeanList() {
+        return simpleBeanList;
+    }
+
+    public void setSimpleBeanList(List<SimpleBean> simpleBeanList) {
+        this.simpleBeanList = simpleBeanList;
+    }
+
+    public Collection<SimpleBean> getSimpleBeanCollection() {
+        return simpleBeanCollection;
+    }
+
+    public void setSimpleBeanCollection(Collection<SimpleBean> simpleBeanCollection) {
+        this.simpleBeanCollection = simpleBeanCollection;
+    }
+
+    public Map<String, SimpleBean> getSimpleBeanMap() {
+        return simpleBeanMap;
+    }
+
+    public void setSimpleBeanMap(Map<String, SimpleBean> simpleBeanMap) {
+        this.simpleBeanMap = simpleBeanMap;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/config/IniSecurityManagerFactoryTest.java b/core/src/test/java/org/apache/shiro/config/IniSecurityManagerFactoryTest.java
index 270e1ac56..46049bf9c 100644
--- a/core/src/test/java/org/apache/shiro/config/IniSecurityManagerFactoryTest.java
+++ b/core/src/test/java/org/apache/shiro/config/IniSecurityManagerFactoryTest.java
@@ -1,209 +1,209 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.cache.Cache;
-import org.apache.shiro.cache.MapCache;
-import org.apache.shiro.crypto.hash.Sha256Hash;
-import org.apache.shiro.mgt.DefaultSecurityManager;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.realm.Realm;
-import org.apache.shiro.realm.text.IniRealm;
-import org.apache.shiro.realm.text.PropertiesRealm;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.session.mgt.AbstractSessionManager;
-import org.apache.shiro.session.mgt.DefaultSessionManager;
-import org.apache.shiro.session.mgt.eis.CachingSessionDAO;
-import org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO;
-import org.apache.shiro.session.mgt.eis.SessionDAO;
-import org.apache.shiro.subject.Subject;
-import org.junit.Test;
-
-import java.util.Collection;
-
-import static junit.framework.Assert.*;
-
-/**
- * Unit tests for the {@link IniSecurityManagerFactory} implementation.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class IniSecurityManagerFactoryTest {
-
-    @Test
-    public void testGetInstanceWithoutIni() {
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory();
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-    }
-
-    @Test
-    public void testGetInstanceWithResourcePath() {
-        String path = "classpath:org/apache/shiro/config/IniSecurityManagerFactoryTest.ini";
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(path);
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-    }
-
-    @Test
-    public void testGetInstanceWithEmptyIni() {
-        Ini ini = new Ini();
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-    }
-
-    @Test
-    public void testGetInstanceWithSimpleIni() {
-        Ini ini = new Ini();
-        ini.setSectionProperty(IniSecurityManagerFactory.MAIN_SECTION_NAME,
-                "securityManager.sessionManager.globalSessionTimeout", "5000");
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-        assertEquals(5000, ((AbstractSessionManager) ((DefaultSecurityManager) sm).getSessionManager()).getGlobalSessionTimeout());
-    }
-
-    @Test
-    public void testGetInstanceWithConfiguredRealm() {
-        Ini ini = new Ini();
-        Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
-        section.put("propsRealm", PropertiesRealm.class.getName());
-        section.put("propsRealm.resourcePath",
-                "classpath:org/apache/shiro/config/IniSecurityManagerFactoryTest.propsRealm.properties");
-
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-        Collection<Realm> realms = ((DefaultSecurityManager) sm).getRealms();
-        assertEquals(1, realms.size());
-        Realm realm = realms.iterator().next();
-        assertTrue(realm instanceof PropertiesRealm);
-    }
-
-    @Test
-    public void testGetInstanceWithAutomaticallyCreatedIniRealm() {
-        Ini ini = new Ini();
-        Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);
-        section.put("admin", "admin");
-
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-        assertNotNull(sm);
-        assertTrue(sm instanceof DefaultSecurityManager);
-        Collection<Realm> realms = ((DefaultSecurityManager) sm).getRealms();
-        assertEquals(1, realms.size());
-        Realm realm = realms.iterator().next();
-        assertTrue(realm instanceof IniRealm);
-        assertTrue(((IniRealm) realm).accountExists("admin"));
-    }
-
-    /**
-     * Test for issue <a href="https://issues.apache.org/jira/browse/SHIRO-125">SHIRO-125</a>.
-     */
-    @Test
-    public void testImplicitIniRealmWithAdditionalRealmConfiguration() {
-
-        Ini ini = new Ini();
-
-        //The users section below should create an implicit 'iniRealm' instance in the
-        //main configuration.  So we should be able to set properties on it immediately
-        //such as the Sha256 credentials matcher:
-        Ini.Section main = ini.addSection("main");
-        main.put("credentialsMatcher", "org.apache.shiro.authc.credential.Sha256CredentialsMatcher");
-        main.put("iniRealm.credentialsMatcher", "$credentialsMatcher");
-
-        //create a users section - user 'admin', with a Sha256-hashed 'admin' password (hex encoded):
-        Ini.Section users = ini.addSection(IniRealm.USERS_SECTION_NAME);
-        users.put("admin", new Sha256Hash("secret").toString());
-
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-
-        //go ahead and try to log in with the admin user, ensuring the 
-        //iniRealm has a Sha256CredentialsMatcher enabled:
-
-        //try to log-in:
-        Subject subject = new Subject.Builder(sm).buildSubject();
-        //ensure thread clean-up after the login method returns.  Test cases only:
-        subject.execute(new Runnable() {
-            public void run() {
-                //the plain-text 'secret' should be converted to an Sha256 hash first
-                //by the CredentialsMatcher.  This should return quietly if
-                //this test case is valid:
-                SecurityUtils.getSubject().login(new UsernamePasswordToken("admin", "secret"));
-            }
-        });
-        assertTrue(subject.getPrincipal().equals("admin"));
-    }
-
-    /**
-     * Test case for issue <a href="https://issues.apache.org/jira/browse/SHIRO-95">SHIRO-95</a>.
-     */
-    @Test
-    public void testCacheManagerConfigOrderOfOperations() {
-
-        Ini ini = new Ini();
-        Ini.Section main = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
-        //create a non-default CacheManager:
-        main.put("cacheManager", "org.apache.shiro.config.HashMapCacheManager");
-
-        //now add a session DAO after the cache manager has been set - this is what tests the user-reported issue
-        main.put("sessionDAO", "org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO");
-        main.put("securityManager.sessionManager.sessionDAO", "$sessionDAO");
-
-        //add the cache manager after the sessionDAO has been set:
-        main.put("securityManager.cacheManager", "$cacheManager");
-
-        //add a test user:
-        ini.setSectionProperty(IniRealm.USERS_SECTION_NAME, "admin", "admin");
-
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-
-        //try to log-in:
-        Subject subject = new Subject.Builder(sm).buildSubject();
-        subject.login(new UsernamePasswordToken("admin", "admin"));
-        Session session = subject.getSession();
-        session.setAttribute("hello", "world");
-        //session should have been started, and a cache is in use.  Assert that the SessionDAO is still using
-        //the cache instances provided by our custom CacheManager and not the Default MemoryConstrainedCacheManager
-
-        SessionDAO sessionDAO = ((DefaultSessionManager) ((DefaultSecurityManager) sm).getSessionManager()).getSessionDAO();
-        assertTrue(sessionDAO instanceof EnterpriseCacheSessionDAO);
-        CachingSessionDAO cachingSessionDAO = (CachingSessionDAO) sessionDAO;
-        Cache activeSessionsCache = cachingSessionDAO.getActiveSessionsCache();
-        assertTrue(activeSessionsCache instanceof MapCache);
-        MapCache mapCache = (MapCache) activeSessionsCache;
-
-        //this is the line that verifies Caches created by our specific CacheManager are not overwritten by the
-        //default cache manager's caches:
-        assertTrue(mapCache instanceof HashMapCacheManager.HashMapCache);
-    }
-
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.cache.Cache;
+import org.apache.shiro.cache.MapCache;
+import org.apache.shiro.crypto.hash.Sha256Hash;
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.realm.Realm;
+import org.apache.shiro.realm.text.IniRealm;
+import org.apache.shiro.realm.text.PropertiesRealm;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.session.mgt.AbstractSessionManager;
+import org.apache.shiro.session.mgt.DefaultSessionManager;
+import org.apache.shiro.session.mgt.eis.CachingSessionDAO;
+import org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO;
+import org.apache.shiro.session.mgt.eis.SessionDAO;
+import org.apache.shiro.subject.Subject;
+import org.junit.Test;
+
+import java.util.Collection;
+
+import static junit.framework.Assert.*;
+
+/**
+ * Unit tests for the {@link IniSecurityManagerFactory} implementation.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class IniSecurityManagerFactoryTest {
+
+    @Test
+    public void testGetInstanceWithoutIni() {
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory();
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+    }
+
+    @Test
+    public void testGetInstanceWithResourcePath() {
+        String path = "classpath:org/apache/shiro/config/IniSecurityManagerFactoryTest.ini";
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(path);
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+    }
+
+    @Test
+    public void testGetInstanceWithEmptyIni() {
+        Ini ini = new Ini();
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+    }
+
+    @Test
+    public void testGetInstanceWithSimpleIni() {
+        Ini ini = new Ini();
+        ini.setSectionProperty(IniSecurityManagerFactory.MAIN_SECTION_NAME,
+                "securityManager.sessionManager.globalSessionTimeout", "5000");
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+        assertEquals(5000, ((AbstractSessionManager) ((DefaultSecurityManager) sm).getSessionManager()).getGlobalSessionTimeout());
+    }
+
+    @Test
+    public void testGetInstanceWithConfiguredRealm() {
+        Ini ini = new Ini();
+        Ini.Section section = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
+        section.put("propsRealm", PropertiesRealm.class.getName());
+        section.put("propsRealm.resourcePath",
+                "classpath:org/apache/shiro/config/IniSecurityManagerFactoryTest.propsRealm.properties");
+
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+        Collection<Realm> realms = ((DefaultSecurityManager) sm).getRealms();
+        assertEquals(1, realms.size());
+        Realm realm = realms.iterator().next();
+        assertTrue(realm instanceof PropertiesRealm);
+    }
+
+    @Test
+    public void testGetInstanceWithAutomaticallyCreatedIniRealm() {
+        Ini ini = new Ini();
+        Ini.Section section = ini.addSection(IniRealm.USERS_SECTION_NAME);
+        section.put("admin", "admin");
+
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+        assertNotNull(sm);
+        assertTrue(sm instanceof DefaultSecurityManager);
+        Collection<Realm> realms = ((DefaultSecurityManager) sm).getRealms();
+        assertEquals(1, realms.size());
+        Realm realm = realms.iterator().next();
+        assertTrue(realm instanceof IniRealm);
+        assertTrue(((IniRealm) realm).accountExists("admin"));
+    }
+
+    /**
+     * Test for issue <a href="https://issues.apache.org/jira/browse/SHIRO-125">SHIRO-125</a>.
+     */
+    @Test
+    public void testImplicitIniRealmWithAdditionalRealmConfiguration() {
+
+        Ini ini = new Ini();
+
+        //The users section below should create an implicit 'iniRealm' instance in the
+        //main configuration.  So we should be able to set properties on it immediately
+        //such as the Sha256 credentials matcher:
+        Ini.Section main = ini.addSection("main");
+        main.put("credentialsMatcher", "org.apache.shiro.authc.credential.Sha256CredentialsMatcher");
+        main.put("iniRealm.credentialsMatcher", "$credentialsMatcher");
+
+        //create a users section - user 'admin', with a Sha256-hashed 'admin' password (hex encoded):
+        Ini.Section users = ini.addSection(IniRealm.USERS_SECTION_NAME);
+        users.put("admin", new Sha256Hash("secret").toString());
+
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+
+        //go ahead and try to log in with the admin user, ensuring the 
+        //iniRealm has a Sha256CredentialsMatcher enabled:
+
+        //try to log-in:
+        Subject subject = new Subject.Builder(sm).buildSubject();
+        //ensure thread clean-up after the login method returns.  Test cases only:
+        subject.execute(new Runnable() {
+            public void run() {
+                //the plain-text 'secret' should be converted to an Sha256 hash first
+                //by the CredentialsMatcher.  This should return quietly if
+                //this test case is valid:
+                SecurityUtils.getSubject().login(new UsernamePasswordToken("admin", "secret"));
+            }
+        });
+        assertTrue(subject.getPrincipal().equals("admin"));
+    }
+
+    /**
+     * Test case for issue <a href="https://issues.apache.org/jira/browse/SHIRO-95">SHIRO-95</a>.
+     */
+    @Test
+    public void testCacheManagerConfigOrderOfOperations() {
+
+        Ini ini = new Ini();
+        Ini.Section main = ini.addSection(IniSecurityManagerFactory.MAIN_SECTION_NAME);
+        //create a non-default CacheManager:
+        main.put("cacheManager", "org.apache.shiro.config.HashMapCacheManager");
+
+        //now add a session DAO after the cache manager has been set - this is what tests the user-reported issue
+        main.put("sessionDAO", "org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO");
+        main.put("securityManager.sessionManager.sessionDAO", "$sessionDAO");
+
+        //add the cache manager after the sessionDAO has been set:
+        main.put("securityManager.cacheManager", "$cacheManager");
+
+        //add a test user:
+        ini.setSectionProperty(IniRealm.USERS_SECTION_NAME, "admin", "admin");
+
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+
+        //try to log-in:
+        Subject subject = new Subject.Builder(sm).buildSubject();
+        subject.login(new UsernamePasswordToken("admin", "admin"));
+        Session session = subject.getSession();
+        session.setAttribute("hello", "world");
+        //session should have been started, and a cache is in use.  Assert that the SessionDAO is still using
+        //the cache instances provided by our custom CacheManager and not the Default MemoryConstrainedCacheManager
+
+        SessionDAO sessionDAO = ((DefaultSessionManager) ((DefaultSecurityManager) sm).getSessionManager()).getSessionDAO();
+        assertTrue(sessionDAO instanceof EnterpriseCacheSessionDAO);
+        CachingSessionDAO cachingSessionDAO = (CachingSessionDAO) sessionDAO;
+        Cache activeSessionsCache = cachingSessionDAO.getActiveSessionsCache();
+        assertTrue(activeSessionsCache instanceof MapCache);
+        MapCache mapCache = (MapCache) activeSessionsCache;
+
+        //this is the line that verifies Caches created by our specific CacheManager are not overwritten by the
+        //default cache manager's caches:
+        assertTrue(mapCache instanceof HashMapCacheManager.HashMapCache);
+    }
+
+
+}
diff --git a/core/src/test/java/org/apache/shiro/config/IniTest.java b/core/src/test/java/org/apache/shiro/config/IniTest.java
index 9b6623759..5c1f63f6c 100644
--- a/core/src/test/java/org/apache/shiro/config/IniTest.java
+++ b/core/src/test/java/org/apache/shiro/config/IniTest.java
@@ -1,90 +1,90 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import static org.junit.Assert.*;
-import org.junit.Test;
-
-import java.util.Scanner;
-
-/**
- * Unit test for the {@link Ini} class.
- *
- * @since 1.0
- */
-public class IniTest {
-
-    private static final String NL = "\n";
-
-    @Test
-    public void testNoSections() {
-        String test =
-                "prop1 = value1" + NL +
-                        "prop2 = value2";
-
-        Ini ini = new Ini();
-        ini.load(test);
-
-        assertNotNull(ini.getSections());
-        assertEquals(1, ini.getSections().size());
-
-        Ini.Section section = ini.getSections().iterator().next();
-        assertEquals(Ini.DEFAULT_SECTION_NAME, section.getName());
-        assertFalse(section.isEmpty());
-        assertEquals(2, section.size());
-        assertEquals("value1", section.get("prop1"));
-        assertEquals("value2", section.get("prop2"));
-    }
-
-    @Test
-    public void testOneSection() {
-        String sectionName = "main";
-        String test = NL +
-                "" + NL +
-                "  " + NL +
-                "    #  comment1 " + NL +
-                " ; comment 2" + NL +
-                "[" + sectionName + "]" + NL +
-                "prop1 = value1" + NL +
-                "  " + NL +
-                "; comment " + NL +
-                "prop2   value2" + NL +
-                "prop3:value3" + NL +
-                "prop4 : value 4" + NL +
-                "prop5 some long \\" + NL +
-                "      value " + NL +
-                "# comment.";
-
-        Ini ini = new Ini();
-        ini.load(new Scanner(test));
-
-        assertNotNull(ini.getSections());
-        assertEquals(1, ini.getSections().size());
-        Ini.Section section = ini.getSection("main");
-        assertNotNull(section);
-        assertEquals(sectionName, section.getName());
-        assertFalse(section.isEmpty());
-        assertEquals(5, section.size());
-        assertEquals("value1", section.get("prop1"));
-        assertEquals("value2", section.get("prop2"));
-        assertEquals("value3", section.get("prop3"));
-        assertEquals("value 4", section.get("prop4"));
-        assertEquals("some long value", section.get("prop5"));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import java.util.Scanner;
+
+/**
+ * Unit test for the {@link Ini} class.
+ *
+ * @since 1.0
+ */
+public class IniTest {
+
+    private static final String NL = "\n";
+
+    @Test
+    public void testNoSections() {
+        String test =
+                "prop1 = value1" + NL +
+                        "prop2 = value2";
+
+        Ini ini = new Ini();
+        ini.load(test);
+
+        assertNotNull(ini.getSections());
+        assertEquals(1, ini.getSections().size());
+
+        Ini.Section section = ini.getSections().iterator().next();
+        assertEquals(Ini.DEFAULT_SECTION_NAME, section.getName());
+        assertFalse(section.isEmpty());
+        assertEquals(2, section.size());
+        assertEquals("value1", section.get("prop1"));
+        assertEquals("value2", section.get("prop2"));
+    }
+
+    @Test
+    public void testOneSection() {
+        String sectionName = "main";
+        String test = NL +
+                "" + NL +
+                "  " + NL +
+                "    #  comment1 " + NL +
+                " ; comment 2" + NL +
+                "[" + sectionName + "]" + NL +
+                "prop1 = value1" + NL +
+                "  " + NL +
+                "; comment " + NL +
+                "prop2   value2" + NL +
+                "prop3:value3" + NL +
+                "prop4 : value 4" + NL +
+                "prop5 some long \\" + NL +
+                "      value " + NL +
+                "# comment.";
+
+        Ini ini = new Ini();
+        ini.load(new Scanner(test));
+
+        assertNotNull(ini.getSections());
+        assertEquals(1, ini.getSections().size());
+        Ini.Section section = ini.getSection("main");
+        assertNotNull(section);
+        assertEquals(sectionName, section.getName());
+        assertFalse(section.isEmpty());
+        assertEquals(5, section.size());
+        assertEquals("value1", section.get("prop1"));
+        assertEquals("value2", section.get("prop2"));
+        assertEquals("value3", section.get("prop3"));
+        assertEquals("value 4", section.get("prop4"));
+        assertEquals("some long value", section.get("prop5"));
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/config/ReflectionBuilderTest.java b/core/src/test/java/org/apache/shiro/config/ReflectionBuilderTest.java
index 7c33c4375..fe58e103d 100644
--- a/core/src/test/java/org/apache/shiro/config/ReflectionBuilderTest.java
+++ b/core/src/test/java/org/apache/shiro/config/ReflectionBuilderTest.java
@@ -1,244 +1,244 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import org.apache.shiro.codec.Base64;
-import org.apache.shiro.codec.CodecSupport;
-import org.apache.shiro.codec.Hex;
-import org.apache.shiro.util.CollectionUtils;
-import org.junit.Test;
-
-import java.util.*;
-
-import static org.junit.Assert.*;
-
-/**
- * @author Les Hazlewood
- * @since Aug 5, 2008 9:53:00 AM
- */
-public class ReflectionBuilderTest {
-
-    @Test
-    public void testSimpleConfig() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.stringProp", "blah");
-        defs.put("compositeBean.booleanProp", "true");
-        defs.put("compositeBean.intProp", "42");
-
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map beans = builder.buildObjects(defs);
-
-        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
-        assertNotNull(compositeBean);
-        assertEquals(compositeBean.getStringProp(), "blah");
-        assertTrue(compositeBean.isBooleanProp());
-        assertEquals(compositeBean.getIntProp(), 42);
-    }
-
-    @Test
-    public void testSimpleConfigWithDollarSignStringValue() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.stringProp", "\\$500");
-
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map beans = builder.buildObjects(defs);
-
-        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
-        assertEquals(compositeBean.getStringProp(), "$500");
-    }
-
-    @Test
-    public void testObjectReferenceConfig() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean.intProp", "101");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.stringProp", "blah");
-        defs.put("compositeBean.simpleBean", "$simpleBean");
-
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map beans = builder.buildObjects(defs);
-
-        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
-        assertNotNull(compositeBean);
-        assertEquals(compositeBean.getStringProp(), "blah");
-        SimpleBean simpleBean = (SimpleBean) beans.get("simpleBean");
-        assertNotNull(simpleBean);
-        assertNotNull(compositeBean.getSimpleBean());
-        assertEquals(simpleBean, compositeBean.getSimpleBean());
-        assertEquals(simpleBean.getIntProp(), 101);
-    }
-
-    @Test(expected = ConfigurationException.class)
-    public void testObjectReferenceConfigWithTypeMismatch() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBean", "simpleBean");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        builder.buildObjects(defs);
-    }
-
-    @Test(expected = UnresolveableReferenceException.class)
-    public void testObjectReferenceConfigWithInvalidReference() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBean", "$foo");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        builder.buildObjects(defs);
-    }
-
-    @Test
-    public void testSetProperty() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBeanSet", "$simpleBean1, $simpleBean2, $simpleBean2");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
-        assertNotNull(cBean);
-        Set<SimpleBean> simpleBeans = cBean.getSimpleBeanSet();
-        assertNotNull(simpleBeans);
-        assertEquals(2, simpleBeans.size());
-    }
-
-    @Test
-    public void testListProperty() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBeanList", "$simpleBean1, $simpleBean2, $simpleBean2");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
-        assertNotNull(cBean);
-        List<SimpleBean> simpleBeans = cBean.getSimpleBeanList();
-        assertNotNull(simpleBeans);
-        assertEquals(3, simpleBeans.size());
-    }
-
-    @Test
-    public void testCollectionProperty() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBeanCollection", "$simpleBean1, $simpleBean2, $simpleBean2");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
-        assertNotNull(cBean);
-        Collection<SimpleBean> simpleBeans = cBean.getSimpleBeanCollection();
-        assertNotNull(simpleBeans);
-        assertTrue(simpleBeans instanceof List);
-        assertEquals(3, simpleBeans.size());
-    }
-
-    @Test
-    public void testByteArrayHexProperty() {
-        String source = "Hello, world.";
-        byte[] bytes = CodecSupport.toBytes(source);
-        String hex = Hex.encodeToString(bytes);
-        String hexValue = "0x" + hex;
-
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean.byteArrayProp", hexValue);
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        SimpleBean bean = (SimpleBean) objects.get("simpleBean");
-        assertNotNull(bean);
-        byte[] beanBytes = bean.getByteArrayProp();
-        assertNotNull(beanBytes);
-        String reconstituted = CodecSupport.toString(beanBytes);
-        assertEquals(source, reconstituted);
-    }
-
-    @Test
-    public void testByteArrayBase64Property() {
-        String source = "Hello, world.";
-        byte[] bytes = CodecSupport.toBytes(source);
-        String base64 = Base64.encodeToString(bytes);
-
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean.byteArrayProp", base64);
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        SimpleBean bean = (SimpleBean) objects.get("simpleBean");
-        byte[] beanBytes = bean.getByteArrayProp();
-        assertNotNull(beanBytes);
-        assertTrue(Arrays.equals(beanBytes, bytes));
-        String reconstituted = CodecSupport.toString(beanBytes);
-        assertEquals(reconstituted, source);
-    }
-
-    @Test
-    public void testMapProperty() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBeanMap", "simpleBean1:$simpleBean1, simpleBean2:$simpleBean2");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
-        assertNotNull(cBean);
-        Map map = cBean.getSimpleBeanMap();
-        assertNotNull(map);
-        assertEquals(2, map.size());
-        Object value = map.get("simpleBean1");
-        assertTrue(value instanceof SimpleBean);
-        value = map.get("simpleBean2");
-        assertTrue(value instanceof SimpleBean);
-    }
-
-    @Test
-    public void testNestedListProperty() {
-        Map<String, String> defs = new LinkedHashMap<String, String>();
-        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
-        defs.put("simpleBean3", "org.apache.shiro.config.SimpleBean");
-        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
-        defs.put("compositeBean.simpleBean", "$simpleBean1");
-        defs.put("compositeBean.simpleBean.simpleBeans", "$simpleBean2, $simpleBean3");
-        ReflectionBuilder builder = new ReflectionBuilder();
-        Map objects = builder.buildObjects(defs);
-        assertFalse(CollectionUtils.isEmpty(objects));
-        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
-        assertNotNull(cBean);
-        SimpleBean nested = cBean.getSimpleBean();
-        assertNotNull(nested);
-        List<SimpleBean> children = nested.getSimpleBeans();
-        assertNotNull(children);
-        assertEquals(2, children.size());
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import org.apache.shiro.codec.Base64;
+import org.apache.shiro.codec.CodecSupport;
+import org.apache.shiro.codec.Hex;
+import org.apache.shiro.util.CollectionUtils;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Les Hazlewood
+ * @since Aug 5, 2008 9:53:00 AM
+ */
+public class ReflectionBuilderTest {
+
+    @Test
+    public void testSimpleConfig() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.stringProp", "blah");
+        defs.put("compositeBean.booleanProp", "true");
+        defs.put("compositeBean.intProp", "42");
+
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map beans = builder.buildObjects(defs);
+
+        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
+        assertNotNull(compositeBean);
+        assertEquals(compositeBean.getStringProp(), "blah");
+        assertTrue(compositeBean.isBooleanProp());
+        assertEquals(compositeBean.getIntProp(), 42);
+    }
+
+    @Test
+    public void testSimpleConfigWithDollarSignStringValue() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.stringProp", "\\$500");
+
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map beans = builder.buildObjects(defs);
+
+        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
+        assertEquals(compositeBean.getStringProp(), "$500");
+    }
+
+    @Test
+    public void testObjectReferenceConfig() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean.intProp", "101");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.stringProp", "blah");
+        defs.put("compositeBean.simpleBean", "$simpleBean");
+
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map beans = builder.buildObjects(defs);
+
+        CompositeBean compositeBean = (CompositeBean) beans.get("compositeBean");
+        assertNotNull(compositeBean);
+        assertEquals(compositeBean.getStringProp(), "blah");
+        SimpleBean simpleBean = (SimpleBean) beans.get("simpleBean");
+        assertNotNull(simpleBean);
+        assertNotNull(compositeBean.getSimpleBean());
+        assertEquals(simpleBean, compositeBean.getSimpleBean());
+        assertEquals(simpleBean.getIntProp(), 101);
+    }
+
+    @Test(expected = ConfigurationException.class)
+    public void testObjectReferenceConfigWithTypeMismatch() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBean", "simpleBean");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        builder.buildObjects(defs);
+    }
+
+    @Test(expected = UnresolveableReferenceException.class)
+    public void testObjectReferenceConfigWithInvalidReference() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBean", "$foo");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        builder.buildObjects(defs);
+    }
+
+    @Test
+    public void testSetProperty() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBeanSet", "$simpleBean1, $simpleBean2, $simpleBean2");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
+        assertNotNull(cBean);
+        Set<SimpleBean> simpleBeans = cBean.getSimpleBeanSet();
+        assertNotNull(simpleBeans);
+        assertEquals(2, simpleBeans.size());
+    }
+
+    @Test
+    public void testListProperty() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBeanList", "$simpleBean1, $simpleBean2, $simpleBean2");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
+        assertNotNull(cBean);
+        List<SimpleBean> simpleBeans = cBean.getSimpleBeanList();
+        assertNotNull(simpleBeans);
+        assertEquals(3, simpleBeans.size());
+    }
+
+    @Test
+    public void testCollectionProperty() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBeanCollection", "$simpleBean1, $simpleBean2, $simpleBean2");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
+        assertNotNull(cBean);
+        Collection<SimpleBean> simpleBeans = cBean.getSimpleBeanCollection();
+        assertNotNull(simpleBeans);
+        assertTrue(simpleBeans instanceof List);
+        assertEquals(3, simpleBeans.size());
+    }
+
+    @Test
+    public void testByteArrayHexProperty() {
+        String source = "Hello, world.";
+        byte[] bytes = CodecSupport.toBytes(source);
+        String hex = Hex.encodeToString(bytes);
+        String hexValue = "0x" + hex;
+
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean.byteArrayProp", hexValue);
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        SimpleBean bean = (SimpleBean) objects.get("simpleBean");
+        assertNotNull(bean);
+        byte[] beanBytes = bean.getByteArrayProp();
+        assertNotNull(beanBytes);
+        String reconstituted = CodecSupport.toString(beanBytes);
+        assertEquals(source, reconstituted);
+    }
+
+    @Test
+    public void testByteArrayBase64Property() {
+        String source = "Hello, world.";
+        byte[] bytes = CodecSupport.toBytes(source);
+        String base64 = Base64.encodeToString(bytes);
+
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean.byteArrayProp", base64);
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        SimpleBean bean = (SimpleBean) objects.get("simpleBean");
+        byte[] beanBytes = bean.getByteArrayProp();
+        assertNotNull(beanBytes);
+        assertTrue(Arrays.equals(beanBytes, bytes));
+        String reconstituted = CodecSupport.toString(beanBytes);
+        assertEquals(reconstituted, source);
+    }
+
+    @Test
+    public void testMapProperty() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBeanMap", "simpleBean1:$simpleBean1, simpleBean2:$simpleBean2");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
+        assertNotNull(cBean);
+        Map map = cBean.getSimpleBeanMap();
+        assertNotNull(map);
+        assertEquals(2, map.size());
+        Object value = map.get("simpleBean1");
+        assertTrue(value instanceof SimpleBean);
+        value = map.get("simpleBean2");
+        assertTrue(value instanceof SimpleBean);
+    }
+
+    @Test
+    public void testNestedListProperty() {
+        Map<String, String> defs = new LinkedHashMap<String, String>();
+        defs.put("simpleBean1", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean2", "org.apache.shiro.config.SimpleBean");
+        defs.put("simpleBean3", "org.apache.shiro.config.SimpleBean");
+        defs.put("compositeBean", "org.apache.shiro.config.CompositeBean");
+        defs.put("compositeBean.simpleBean", "$simpleBean1");
+        defs.put("compositeBean.simpleBean.simpleBeans", "$simpleBean2, $simpleBean3");
+        ReflectionBuilder builder = new ReflectionBuilder();
+        Map objects = builder.buildObjects(defs);
+        assertFalse(CollectionUtils.isEmpty(objects));
+        CompositeBean cBean = (CompositeBean) objects.get("compositeBean");
+        assertNotNull(cBean);
+        SimpleBean nested = cBean.getSimpleBean();
+        assertNotNull(nested);
+        List<SimpleBean> children = nested.getSimpleBeans();
+        assertNotNull(children);
+        assertEquals(2, children.size());
+    }
+
+}
diff --git a/core/src/test/java/org/apache/shiro/config/SimpleBean.java b/core/src/test/java/org/apache/shiro/config/SimpleBean.java
index 39c31d5b2..e92436f1d 100644
--- a/core/src/test/java/org/apache/shiro/config/SimpleBean.java
+++ b/core/src/test/java/org/apache/shiro/config/SimpleBean.java
@@ -1,69 +1,69 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.config;
-
-import java.util.List;
-
-/**
- * @author Les Hazlewood
- * @since 1.0
- */
-public class SimpleBean {
-
-    private String stringProp = null;
-    private int intProp;
-    private byte[] byteArrayProp = null;
-
-    private List<SimpleBean> simpleBeans;
-
-    public SimpleBean() {
-    }
-
-    public String getStringProp() {
-        return stringProp;
-    }
-
-    public void setStringProp(String stringProp) {
-        this.stringProp = stringProp;
-    }
-
-    public int getIntProp() {
-        return intProp;
-    }
-
-    public void setIntProp(int intProp) {
-        this.intProp = intProp;
-    }
-
-    public byte[] getByteArrayProp() {
-        return byteArrayProp;
-    }
-
-    public void setByteArrayProp(byte[] byteArrayProp) {
-        this.byteArrayProp = byteArrayProp;
-    }
-
-    public List<SimpleBean> getSimpleBeans() {
-        return simpleBeans;
-    }
-
-    public void setSimpleBeans(List<SimpleBean> simpleBeans) {
-        this.simpleBeans = simpleBeans;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.config;
+
+import java.util.List;
+
+/**
+ * @author Les Hazlewood
+ * @since 1.0
+ */
+public class SimpleBean {
+
+    private String stringProp = null;
+    private int intProp;
+    private byte[] byteArrayProp = null;
+
+    private List<SimpleBean> simpleBeans;
+
+    public SimpleBean() {
+    }
+
+    public String getStringProp() {
+        return stringProp;
+    }
+
+    public void setStringProp(String stringProp) {
+        this.stringProp = stringProp;
+    }
+
+    public int getIntProp() {
+        return intProp;
+    }
+
+    public void setIntProp(int intProp) {
+        this.intProp = intProp;
+    }
+
+    public byte[] getByteArrayProp() {
+        return byteArrayProp;
+    }
+
+    public void setByteArrayProp(byte[] byteArrayProp) {
+        this.byteArrayProp = byteArrayProp;
+    }
+
+    public List<SimpleBean> getSimpleBeans() {
+        return simpleBeans;
+    }
+
+    public void setSimpleBeans(List<SimpleBean> simpleBeans) {
+        this.simpleBeans = simpleBeans;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/io/SerializationExceptionTest.java b/core/src/test/java/org/apache/shiro/io/SerializationExceptionTest.java
index 8b85127b9..b8e67251b 100644
--- a/core/src/test/java/org/apache/shiro/io/SerializationExceptionTest.java
+++ b/core/src/test/java/org/apache/shiro/io/SerializationExceptionTest.java
@@ -1,32 +1,32 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.io;
-
-import org.apache.shiro.ExceptionTest;
-
-
-/**
- * @author Les Hazlewood
- */
-public class SerializationExceptionTest extends ExceptionTest {
-
-    protected Class getExceptionClass() {
-        return SerializationException.class;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.io;
+
+import org.apache.shiro.ExceptionTest;
+
+
+/**
+ * @author Les Hazlewood
+ */
+public class SerializationExceptionTest extends ExceptionTest {
+
+    protected Class getExceptionClass() {
+        return SerializationException.class;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/mgt/AbstractRememberMeManagerTest.java b/core/src/test/java/org/apache/shiro/mgt/AbstractRememberMeManagerTest.java
index 3def99e2f..c52a2b280 100644
--- a/core/src/test/java/org/apache/shiro/mgt/AbstractRememberMeManagerTest.java
+++ b/core/src/test/java/org/apache/shiro/mgt/AbstractRememberMeManagerTest.java
@@ -1,77 +1,77 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.mgt;
-
-import org.apache.shiro.subject.PrincipalCollection;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.SubjectContext;
-import org.apache.shiro.subject.support.DefaultSubjectContext;
-import org.junit.Test;
-
-import static org.junit.Assert.assertNull;
-
-/**
- * Test cases for the {@link AbstractRememberMeManager} implementation.
- */
-public class AbstractRememberMeManagerTest {
-
-    /**
-     * Tests the {@link AbstractRememberMeManager#getRememberedPrincipals(SubjectContext)} method
-     * implementation when the internal
-     * {@link AbstractRememberMeManager#getRememberedSerializedIdentity(SubjectContext)} method
-     * returns null or empty bytes.
-     */
-    @Test
-    public void testGetRememberedPrincipalsWithEmptySerializedBytes() {
-        AbstractRememberMeManager rmm = new DummyRememberMeManager();
-        //Since the dummy's getRememberedSerializedIdentity implementation returns an empty byte
-        //array, we should be ok:
-        PrincipalCollection principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());
-        assertNull(principals);
-
-        //try with a null return value too:
-        rmm = new DummyRememberMeManager() {
-            @Override
-            protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {
-                return null;
-            }
-        };
-        principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());
-        assertNull(principals);
-    }
-
-    private static class DummyRememberMeManager extends AbstractRememberMeManager {
-        public void forgetIdentity(SubjectContext subjectContext) {
-            //do nothing
-        }
-
-        @Override
-        protected void forgetIdentity(Subject subject) {
-        }
-
-        @Override
-        protected void rememberSerializedIdentity(Subject subject, byte[] serialized) {
-        }
-
-        @Override
-        protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {
-            return new byte[0];
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.mgt;
+
+import org.apache.shiro.subject.PrincipalCollection;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.subject.SubjectContext;
+import org.apache.shiro.subject.support.DefaultSubjectContext;
+import org.junit.Test;
+
+import static org.junit.Assert.assertNull;
+
+/**
+ * Test cases for the {@link AbstractRememberMeManager} implementation.
+ */
+public class AbstractRememberMeManagerTest {
+
+    /**
+     * Tests the {@link AbstractRememberMeManager#getRememberedPrincipals(SubjectContext)} method
+     * implementation when the internal
+     * {@link AbstractRememberMeManager#getRememberedSerializedIdentity(SubjectContext)} method
+     * returns null or empty bytes.
+     */
+    @Test
+    public void testGetRememberedPrincipalsWithEmptySerializedBytes() {
+        AbstractRememberMeManager rmm = new DummyRememberMeManager();
+        //Since the dummy's getRememberedSerializedIdentity implementation returns an empty byte
+        //array, we should be ok:
+        PrincipalCollection principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());
+        assertNull(principals);
+
+        //try with a null return value too:
+        rmm = new DummyRememberMeManager() {
+            @Override
+            protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {
+                return null;
+            }
+        };
+        principals = rmm.getRememberedPrincipals(new DefaultSubjectContext());
+        assertNull(principals);
+    }
+
+    private static class DummyRememberMeManager extends AbstractRememberMeManager {
+        public void forgetIdentity(SubjectContext subjectContext) {
+            //do nothing
+        }
+
+        @Override
+        protected void forgetIdentity(Subject subject) {
+        }
+
+        @Override
+        protected void rememberSerializedIdentity(Subject subject, byte[] serialized) {
+        }
+
+        @Override
+        protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) {
+            return new byte[0];
+        }
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/mgt/AbstractSecurityManagerTest.java b/core/src/test/java/org/apache/shiro/mgt/AbstractSecurityManagerTest.java
index ac9a00040..7e316f9f9 100644
--- a/core/src/test/java/org/apache/shiro/mgt/AbstractSecurityManagerTest.java
+++ b/core/src/test/java/org/apache/shiro/mgt/AbstractSecurityManagerTest.java
@@ -1,45 +1,45 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.mgt;
-
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.subject.support.SubjectThreadState;
-import org.apache.shiro.util.ThreadContext;
-import org.apache.shiro.util.ThreadState;
-import org.junit.After;
-
-/**
- * @since 1.0
- */
-public abstract class AbstractSecurityManagerTest {
-
-    protected ThreadState threadState;
-
-    @After
-    public void tearDown() {
-        ThreadContext.remove();
-    }
-
-    protected Subject newSubject(SecurityManager securityManager) {
-        Subject subject = new Subject.Builder(securityManager).buildSubject();
-        threadState = new SubjectThreadState(subject);
-        threadState.bind();
-        return subject;
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.mgt;
+
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.subject.support.SubjectThreadState;
+import org.apache.shiro.util.ThreadContext;
+import org.apache.shiro.util.ThreadState;
+import org.junit.After;
+
+/**
+ * @since 1.0
+ */
+public abstract class AbstractSecurityManagerTest {
+
+    protected ThreadState threadState;
+
+    @After
+    public void tearDown() {
+        ThreadContext.remove();
+    }
+
+    protected Subject newSubject(SecurityManager securityManager) {
+        Subject subject = new Subject.Builder(securityManager).buildSubject();
+        threadState = new SubjectThreadState(subject);
+        threadState.bind();
+        return subject;
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/realm/UserIdPrincipal.java b/core/src/test/java/org/apache/shiro/realm/UserIdPrincipal.java
index c7c46618d..09d2f4967 100644
--- a/core/src/test/java/org/apache/shiro/realm/UserIdPrincipal.java
+++ b/core/src/test/java/org/apache/shiro/realm/UserIdPrincipal.java
@@ -1,39 +1,39 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.realm;
-
-import java.io.Serializable;
-import java.security.Principal;
-
-public class UserIdPrincipal implements Principal, Serializable {
-
-    private int userId;
-
-    public UserIdPrincipal(int userId) {
-        this.userId = userId;
-    }
-
-    public int getUserId() {
-        return userId;
-    }
-
-    public String getName() {
-        return String.valueOf(userId);
-    }
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.realm;
+
+import java.io.Serializable;
+import java.security.Principal;
+
+public class UserIdPrincipal implements Principal, Serializable {
+
+    private int userId;
+
+    public UserIdPrincipal(int userId) {
+        this.userId = userId;
+    }
+
+    public int getUserId() {
+        return userId;
+    }
+
+    public String getName() {
+        return String.valueOf(userId);
+    }
 }
\ No newline at end of file
diff --git a/core/src/test/java/org/apache/shiro/realm/UsernamePrincipal.java b/core/src/test/java/org/apache/shiro/realm/UsernamePrincipal.java
index be97dbe86..f9535f6d6 100644
--- a/core/src/test/java/org/apache/shiro/realm/UsernamePrincipal.java
+++ b/core/src/test/java/org/apache/shiro/realm/UsernamePrincipal.java
@@ -1,39 +1,39 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.realm;
-
-import java.io.Serializable;
-import java.security.Principal;
-
-public class UsernamePrincipal implements Principal, Serializable {
-
-    private String username;
-
-    public UsernamePrincipal(String username) {
-        this.username = username;
-    }
-
-    public String getUsername() {
-        return username;
-    }
-
-    public String getName() {
-        return String.valueOf(username);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.realm;
+
+import java.io.Serializable;
+import java.security.Principal;
+
+public class UsernamePrincipal implements Principal, Serializable {
+
+    private String username;
+
+    public UsernamePrincipal(String username) {
+        this.username = username;
+    }
+
+    public String getUsername() {
+        return username;
+    }
+
+    public String getName() {
+        return String.valueOf(username);
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/realm/text/IniRealmTest.java b/core/src/test/java/org/apache/shiro/realm/text/IniRealmTest.java
index 8c92a7407..d972d69d8 100644
--- a/core/src/test/java/org/apache/shiro/realm/text/IniRealmTest.java
+++ b/core/src/test/java/org/apache/shiro/realm/text/IniRealmTest.java
@@ -1,70 +1,70 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.realm.text;
-
-import org.apache.shiro.authc.AuthenticationInfo;
-import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.config.Ini;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import org.junit.Test;
-
-/**
- * Unit tests for the {@link IniRealm} class.
- *
- * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
- * @since 1.0
- */
-public class IniRealmTest {
-
-    @Test
-    public void testNullIni() {
-        IniRealm realm = new IniRealm((Ini) null);
-    }
-
-    @Test
-    public void testEmptyIni() {
-        new IniRealm(new Ini());
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testInitWithoutIniResource() {
-        new IniRealm().init();
-    }
-
-    @Test
-    public void testIniFile() {
-        IniRealm realm = new IniRealm();
-        realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.simple.ini");
-        realm.init();
-        assertTrue(realm.roleExists("admin"));
-        UsernamePasswordToken token = new UsernamePasswordToken("user1", "user1");
-        AuthenticationInfo info = realm.getAuthenticationInfo(token);
-        assertNotNull(info);
-        assertTrue(realm.hasRole(info.getPrincipals(), "admin"));
-    }
-
-    @Test
-    public void testIniFileWithoutUsers() {
-        IniRealm realm = new IniRealm();
-        realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.noUsers.ini");
-        realm.init();
-        assertTrue(realm.roleExists("admin"));
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.realm.text;
+
+import org.apache.shiro.authc.AuthenticationInfo;
+import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.config.Ini;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import org.junit.Test;
+
+/**
+ * Unit tests for the {@link IniRealm} class.
+ *
+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)
+ * @since 1.0
+ */
+public class IniRealmTest {
+
+    @Test
+    public void testNullIni() {
+        IniRealm realm = new IniRealm((Ini) null);
+    }
+
+    @Test
+    public void testEmptyIni() {
+        new IniRealm(new Ini());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testInitWithoutIniResource() {
+        new IniRealm().init();
+    }
+
+    @Test
+    public void testIniFile() {
+        IniRealm realm = new IniRealm();
+        realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.simple.ini");
+        realm.init();
+        assertTrue(realm.roleExists("admin"));
+        UsernamePasswordToken token = new UsernamePasswordToken("user1", "user1");
+        AuthenticationInfo info = realm.getAuthenticationInfo(token);
+        assertNotNull(info);
+        assertTrue(realm.hasRole(info.getPrincipals(), "admin"));
+    }
+
+    @Test
+    public void testIniFileWithoutUsers() {
+        IniRealm realm = new IniRealm();
+        realm.setResourcePath("classpath:org/apache/shiro/realm/text/IniRealmTest.noUsers.ini");
+        realm.init();
+        assertTrue(realm.roleExists("admin"));
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java b/core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
index d30cc7c51..4fda4c491 100644
--- a/core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
+++ b/core/src/test/java/org/apache/shiro/session/mgt/DefaultSessionManagerTest.java
@@ -1,193 +1,193 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.*;
-import org.apache.shiro.session.mgt.eis.SessionDAO;
-import org.apache.shiro.util.ThreadContext;
-import org.easymock.EasyMock;
-import org.easymock.IArgumentMatcher;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.UUID;
-
-import static org.easymock.EasyMock.*;
-import static org.junit.Assert.*;
-
-/**
- * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.
- */
-public class DefaultSessionManagerTest {
-
-    DefaultSessionManager sm = null;
-
-    @Before
-    public void setup() {
-        ThreadContext.remove();
-        sm = new DefaultSessionManager();
-    }
-
-    @After
-    public void tearDown() {
-        sm.destroy();
-        ThreadContext.remove();
-    }
-
-    public void sleep(long millis) {
-        try {
-            Thread.sleep(millis);
-        } catch (InterruptedException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-    @Test
-    public void testGlobalTimeout() {
-        long timeout = 1000;
-        sm.setGlobalSessionTimeout(timeout);
-        Session session = sm.start(null);
-        assertNotNull(session);
-        assertNotNull(session.getId());
-        assertEquals(session.getTimeout(), timeout);
-    }
-
-    @Test
-    public void testSessionListenerStartNotification() {
-        final boolean[] started = new boolean[1];
-        SessionListener listener = new SessionListenerAdapter() {
-            public void onStart(Session session) {
-                started[0] = true;
-            }
-        };
-        sm.getSessionListeners().add(listener);
-        sm.start(null);
-        assertTrue(started[0]);
-    }
-
-    @Test
-    public void testSessionListenerStopNotification() {
-        final boolean[] stopped = new boolean[1];
-        SessionListener listener = new SessionListenerAdapter() {
-            public void onStop(Session session) {
-                stopped[0] = true;
-            }
-        };
-        sm.getSessionListeners().add(listener);
-        Session session = sm.start(null);
-        sm.stop(new DefaultSessionKey(session.getId()));
-        assertTrue(stopped[0]);
-    }
-
-    @Test
-    public void testSessionListenerExpiredNotification() {
-        final boolean[] expired = new boolean[1];
-        SessionListener listener = new SessionListenerAdapter() {
-            public void onExpiration(Session session) {
-                expired[0] = true;
-            }
-        };
-        sm.getSessionListeners().add(listener);
-        sm.setGlobalSessionTimeout(100);
-        Session session = sm.start(null);
-        sleep(150);
-        try {
-            sm.checkValid(new DefaultSessionKey(session.getId()));
-            fail("check should have thrown an exception.");
-        } catch (InvalidSessionException expected) {
-            //do nothing - expected.
-        }
-        assertTrue(expired[0]);
-    }
-
-    @Test
-    public void testSessionDeleteOnExpiration() {
-        sm.setGlobalSessionTimeout(100);
-
-        SessionDAO sessionDAO = createMock(SessionDAO.class);
-        sm.setSessionDAO(sessionDAO);
-
-        String sessionId1 = UUID.randomUUID().toString();
-        final SimpleSession session1 = new SimpleSession();
-        session1.setId(sessionId1);
-
-        final Session[] activeSession = new SimpleSession[]{session1};
-        sm.setSessionFactory(new SessionFactory() {
-            public Session createSession(SessionContext initData) {
-                return activeSession[0];
-            }
-        });
-
-        expect(sessionDAO.create(eq(session1))).andReturn(sessionId1);
-        sessionDAO.update(eq(session1));
-        expectLastCall().anyTimes();
-        replay(sessionDAO);
-        Session session = sm.start(null);
-        assertNotNull(session);
-        verify(sessionDAO);
-        reset(sessionDAO);
-
-        expect(sessionDAO.readSession(sessionId1)).andReturn(session1).anyTimes();
-        sessionDAO.update(eq(session1));
-        replay(sessionDAO);
-        sm.setTimeout(new DefaultSessionKey(sessionId1), 1);
-        verify(sessionDAO);
-        reset(sessionDAO);
-
-        sleep(20);
-
-        expect(sessionDAO.readSession(sessionId1)).andReturn(session1);
-        sessionDAO.update(eq(session1)); //update's the stop timestamp
-        sessionDAO.delete(session1);
-        replay(sessionDAO);
-
-        //Try to access the same session, but it should throw an UnknownSessionException due to timeout:
-        try {
-            sm.getTimeout(new DefaultSessionKey(sessionId1));
-            fail("Session with id [" + sessionId1 + "] should have expired due to timeout.");
-        } catch (ExpiredSessionException expected) {
-            //expected
-        }
-
-        verify(sessionDAO); //verify that the delete call was actually made on the DAO
-    }
-
-    public static <T extends Session> T eqSessionTimeout(long timeout) {
-        EasyMock.reportMatcher(new SessionTimeoutMatcher(timeout));
-        return null;
-    }
-
-    private static class SessionTimeoutMatcher implements IArgumentMatcher {
-
-        private final long timeout;
-
-        public SessionTimeoutMatcher(long timeout) {
-            this.timeout = timeout;
-        }
-
-        public void appendTo(StringBuffer buffer) {
-            buffer.append("eqSession(timeout=").append(this.timeout).append(")");
-        }
-
-        public boolean matches(Object o) {
-            return o instanceof Session && ((Session) o).getTimeout() == this.timeout;
-        }
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.*;
+import org.apache.shiro.session.mgt.eis.SessionDAO;
+import org.apache.shiro.util.ThreadContext;
+import org.easymock.EasyMock;
+import org.easymock.IArgumentMatcher;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.UUID;
+
+import static org.easymock.EasyMock.*;
+import static org.junit.Assert.*;
+
+/**
+ * Unit test for the {@link DefaultSessionManager DefaultSessionManager} implementation.
+ */
+public class DefaultSessionManagerTest {
+
+    DefaultSessionManager sm = null;
+
+    @Before
+    public void setup() {
+        ThreadContext.remove();
+        sm = new DefaultSessionManager();
+    }
+
+    @After
+    public void tearDown() {
+        sm.destroy();
+        ThreadContext.remove();
+    }
+
+    public void sleep(long millis) {
+        try {
+            Thread.sleep(millis);
+        } catch (InterruptedException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    @Test
+    public void testGlobalTimeout() {
+        long timeout = 1000;
+        sm.setGlobalSessionTimeout(timeout);
+        Session session = sm.start(null);
+        assertNotNull(session);
+        assertNotNull(session.getId());
+        assertEquals(session.getTimeout(), timeout);
+    }
+
+    @Test
+    public void testSessionListenerStartNotification() {
+        final boolean[] started = new boolean[1];
+        SessionListener listener = new SessionListenerAdapter() {
+            public void onStart(Session session) {
+                started[0] = true;
+            }
+        };
+        sm.getSessionListeners().add(listener);
+        sm.start(null);
+        assertTrue(started[0]);
+    }
+
+    @Test
+    public void testSessionListenerStopNotification() {
+        final boolean[] stopped = new boolean[1];
+        SessionListener listener = new SessionListenerAdapter() {
+            public void onStop(Session session) {
+                stopped[0] = true;
+            }
+        };
+        sm.getSessionListeners().add(listener);
+        Session session = sm.start(null);
+        sm.stop(new DefaultSessionKey(session.getId()));
+        assertTrue(stopped[0]);
+    }
+
+    @Test
+    public void testSessionListenerExpiredNotification() {
+        final boolean[] expired = new boolean[1];
+        SessionListener listener = new SessionListenerAdapter() {
+            public void onExpiration(Session session) {
+                expired[0] = true;
+            }
+        };
+        sm.getSessionListeners().add(listener);
+        sm.setGlobalSessionTimeout(100);
+        Session session = sm.start(null);
+        sleep(150);
+        try {
+            sm.checkValid(new DefaultSessionKey(session.getId()));
+            fail("check should have thrown an exception.");
+        } catch (InvalidSessionException expected) {
+            //do nothing - expected.
+        }
+        assertTrue(expired[0]);
+    }
+
+    @Test
+    public void testSessionDeleteOnExpiration() {
+        sm.setGlobalSessionTimeout(100);
+
+        SessionDAO sessionDAO = createMock(SessionDAO.class);
+        sm.setSessionDAO(sessionDAO);
+
+        String sessionId1 = UUID.randomUUID().toString();
+        final SimpleSession session1 = new SimpleSession();
+        session1.setId(sessionId1);
+
+        final Session[] activeSession = new SimpleSession[]{session1};
+        sm.setSessionFactory(new SessionFactory() {
+            public Session createSession(SessionContext initData) {
+                return activeSession[0];
+            }
+        });
+
+        expect(sessionDAO.create(eq(session1))).andReturn(sessionId1);
+        sessionDAO.update(eq(session1));
+        expectLastCall().anyTimes();
+        replay(sessionDAO);
+        Session session = sm.start(null);
+        assertNotNull(session);
+        verify(sessionDAO);
+        reset(sessionDAO);
+
+        expect(sessionDAO.readSession(sessionId1)).andReturn(session1).anyTimes();
+        sessionDAO.update(eq(session1));
+        replay(sessionDAO);
+        sm.setTimeout(new DefaultSessionKey(sessionId1), 1);
+        verify(sessionDAO);
+        reset(sessionDAO);
+
+        sleep(20);
+
+        expect(sessionDAO.readSession(sessionId1)).andReturn(session1);
+        sessionDAO.update(eq(session1)); //update's the stop timestamp
+        sessionDAO.delete(session1);
+        replay(sessionDAO);
+
+        //Try to access the same session, but it should throw an UnknownSessionException due to timeout:
+        try {
+            sm.getTimeout(new DefaultSessionKey(sessionId1));
+            fail("Session with id [" + sessionId1 + "] should have expired due to timeout.");
+        } catch (ExpiredSessionException expected) {
+            //expected
+        }
+
+        verify(sessionDAO); //verify that the delete call was actually made on the DAO
+    }
+
+    public static <T extends Session> T eqSessionTimeout(long timeout) {
+        EasyMock.reportMatcher(new SessionTimeoutMatcher(timeout));
+        return null;
+    }
+
+    private static class SessionTimeoutMatcher implements IArgumentMatcher {
+
+        private final long timeout;
+
+        public SessionTimeoutMatcher(long timeout) {
+            this.timeout = timeout;
+        }
+
+        public void appendTo(StringBuffer buffer) {
+            buffer.append("eqSession(timeout=").append(this.timeout).append(")");
+        }
+
+        public boolean matches(Object o) {
+            return o instanceof Session && ((Session) o).getTimeout() == this.timeout;
+        }
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java b/core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
index c4294a221..b28c4d46d 100644
--- a/core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
+++ b/core/src/test/java/org/apache/shiro/session/mgt/DelegatingSessionTest.java
@@ -1,76 +1,76 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.session.mgt;
-
-import org.apache.shiro.session.ExpiredSessionException;
-import org.apache.shiro.util.ThreadContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.Serializable;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-/**
- * Unit test for the {@link DelegatingSession} class.
- */
-public class DelegatingSessionTest {
-
-    DelegatingSession session = null;
-    DefaultSessionManager sm = null;
-
-    @Before
-    public void setup() {
-        ThreadContext.remove();
-        sm = new DefaultSessionManager();
-        this.session = new DelegatingSession(sm, new DefaultSessionKey(sm.start(null).getId()));
-    }
-
-    @After
-    public void tearDown() {
-        sm.destroy();
-        ThreadContext.remove();
-    }
-
-    public void sleep(long millis) {
-        try {
-            Thread.sleep(millis);
-        } catch (InterruptedException e) {
-            throw new IllegalStateException(e);
-        }
-    }
-
-    @Test
-    public void testTimeout() {
-        Serializable origId = session.getId();
-        assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
-        session.touch();
-        session.setTimeout(100);
-        assertEquals(100, session.getTimeout());
-        sleep(150);
-        try {
-            session.getTimeout();
-            fail("Session should have expired.");
-        } catch (ExpiredSessionException expected) {
-        }
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.session.mgt;
+
+import org.apache.shiro.session.ExpiredSessionException;
+import org.apache.shiro.util.ThreadContext;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.Serializable;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+/**
+ * Unit test for the {@link DelegatingSession} class.
+ */
+public class DelegatingSessionTest {
+
+    DelegatingSession session = null;
+    DefaultSessionManager sm = null;
+
+    @Before
+    public void setup() {
+        ThreadContext.remove();
+        sm = new DefaultSessionManager();
+        this.session = new DelegatingSession(sm, new DefaultSessionKey(sm.start(null).getId()));
+    }
+
+    @After
+    public void tearDown() {
+        sm.destroy();
+        ThreadContext.remove();
+    }
+
+    public void sleep(long millis) {
+        try {
+            Thread.sleep(millis);
+        } catch (InterruptedException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    @Test
+    public void testTimeout() {
+        Serializable origId = session.getId();
+        assertEquals(session.getTimeout(), AbstractSessionManager.DEFAULT_GLOBAL_SESSION_TIMEOUT);
+        session.touch();
+        session.setTimeout(100);
+        assertEquals(100, session.getTimeout());
+        sleep(150);
+        try {
+            session.getTimeout();
+            fail("Session should have expired.");
+        } catch (ExpiredSessionException expected) {
+        }
+    }
+
+}
diff --git a/core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java b/core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java
index 42baa8eee..e412f042d 100644
--- a/core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java
+++ b/core/src/test/java/org/apache/shiro/subject/DelegatingSubjectTest.java
@@ -1,180 +1,180 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.subject;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.authc.UsernamePasswordToken;
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.config.IniSecurityManagerFactory;
-import org.apache.shiro.mgt.DefaultSecurityManager;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.session.Session;
-import org.apache.shiro.subject.support.DelegatingSubject;
-import org.apache.shiro.util.CollectionUtils;
-import org.apache.shiro.util.LifecycleUtils;
-import org.apache.shiro.util.ThreadContext;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.Serializable;
-import java.util.concurrent.Callable;
-
-import static org.easymock.EasyMock.createNiceMock;
-import static org.junit.Assert.*;
-
-
-/**
- * @author Les Hazlewood
- * @since Aug 1, 2008 2:11:17 PM
- */
-public class DelegatingSubjectTest {
-
-    @Before
-    public void setup() {
-        ThreadContext.remove();
-    }
-
-    @After
-    public void tearDown() {
-        ThreadContext.remove();
-    }
-
-    @Test
-    public void testSessionStopThenStart() {
-        String key = "testKey";
-        String value = "testValue";
-        DefaultSecurityManager sm = new DefaultSecurityManager();
-
-        DelegatingSubject subject = new DelegatingSubject(sm);
-
-        Session session = subject.getSession();
-        session.setAttribute(key, value);
-        assertTrue(session.getAttribute(key).equals(value));
-        Serializable firstSessionId = session.getId();
-        assertNotNull(firstSessionId);
-
-        session.stop();
-
-        session = subject.getSession();
-        assertNotNull(session);
-        assertNull(session.getAttribute(key));
-        Serializable secondSessionId = session.getId();
-        assertNotNull(secondSessionId);
-        assertFalse(firstSessionId.equals(secondSessionId));
-
-        subject.logout();
-
-        sm.destroy();
-    }
-
-    @Test
-    public void testExecuteCallable() {
-
-        String username = "jsmith";
-
-        SecurityManager securityManager = createNiceMock(SecurityManager.class);
-        PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");
-        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);
-
-        assertNull(ThreadContext.getSubject());
-        assertNull(ThreadContext.getSecurityManager());
-
-        Callable<String> callable = new Callable<String>() {
-            public String call() throws Exception {
-                Subject callingSubject = SecurityUtils.getSubject();
-                assertNotNull(callingSubject);
-                assertNotNull(SecurityUtils.getSecurityManager());
-                assertEquals(callingSubject, sourceSubject);
-                return "Hello " + callingSubject.getPrincipal();
-            }
-        };
-        String response = sourceSubject.execute(callable);
-
-        assertNotNull(response);
-        assertEquals("Hello " + username, response);
-
-        assertNull(ThreadContext.getSubject());
-        assertNull(ThreadContext.getSecurityManager());
-    }
-
-    @Test
-    public void testExecuteRunnable() {
-
-        String username = "jsmith";
-
-        SecurityManager securityManager = createNiceMock(SecurityManager.class);
-        PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");
-        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);
-
-        assertNull(ThreadContext.getSubject());
-        assertNull(ThreadContext.getSecurityManager());
-
-        Runnable runnable = new Runnable() {
-            public void run() {
-                Subject callingSubject = SecurityUtils.getSubject();
-                assertNotNull(callingSubject);
-                assertNotNull(SecurityUtils.getSecurityManager());
-                assertEquals(callingSubject, sourceSubject);
-            }
-        };
-        sourceSubject.execute(runnable);
-
-        assertNull(ThreadContext.getSubject());
-        assertNull(ThreadContext.getSecurityManager());
-    }
-
-    @Test
-    public void testRunAs() {
-
-        Ini ini = new Ini();
-        Ini.Section users = ini.addSection("users");
-        users.put("user1", "user1,role1");
-        users.put("user2", "user2,role2");
-        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
-        SecurityManager sm = factory.getInstance();
-
-        Subject subject = new Subject.Builder(sm).buildSubject();
-        subject.login(new UsernamePasswordToken("user1", "user1"));
-
-        assertTrue(subject.getPrincipal().equals("user1"));
-        assertTrue(subject.hasRole("role1"));
-        assertFalse(subject.isRunAs());
-        assertNull(subject.getPreviousPrincipals());
-
-        subject.runAs(new SimplePrincipalCollection("user2", IniSecurityManagerFactory.INI_REALM_NAME));
-
-        assertFalse(subject.getPrincipal().equals("user1"));
-        assertFalse(subject.hasRole("role1"));
-        assertTrue(subject.getPrincipal().equals("user2"));
-        assertTrue(subject.hasRole("role2"));
-        assertTrue(subject.isRunAs());
-        assertFalse(CollectionUtils.isEmpty(subject.getPreviousPrincipals()));
-        assertTrue(subject.getPreviousPrincipals().getPrimaryPrincipal().equals("user1"));
-
-        subject.releaseRunAs();
-        assertTrue(subject.getPrincipal().equals("user1"));
-        assertTrue(subject.hasRole("role1"));
-        assertFalse(subject.isRunAs());
-        assertNull(subject.getPreviousPrincipals());
-
-        subject.logout();
-        LifecycleUtils.destroy(sm);
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.subject;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.authc.UsernamePasswordToken;
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.config.IniSecurityManagerFactory;
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.session.Session;
+import org.apache.shiro.subject.support.DelegatingSubject;
+import org.apache.shiro.util.CollectionUtils;
+import org.apache.shiro.util.LifecycleUtils;
+import org.apache.shiro.util.ThreadContext;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.Serializable;
+import java.util.concurrent.Callable;
+
+import static org.easymock.EasyMock.createNiceMock;
+import static org.junit.Assert.*;
+
+
+/**
+ * @author Les Hazlewood
+ * @since Aug 1, 2008 2:11:17 PM
+ */
+public class DelegatingSubjectTest {
+
+    @Before
+    public void setup() {
+        ThreadContext.remove();
+    }
+
+    @After
+    public void tearDown() {
+        ThreadContext.remove();
+    }
+
+    @Test
+    public void testSessionStopThenStart() {
+        String key = "testKey";
+        String value = "testValue";
+        DefaultSecurityManager sm = new DefaultSecurityManager();
+
+        DelegatingSubject subject = new DelegatingSubject(sm);
+
+        Session session = subject.getSession();
+        session.setAttribute(key, value);
+        assertTrue(session.getAttribute(key).equals(value));
+        Serializable firstSessionId = session.getId();
+        assertNotNull(firstSessionId);
+
+        session.stop();
+
+        session = subject.getSession();
+        assertNotNull(session);
+        assertNull(session.getAttribute(key));
+        Serializable secondSessionId = session.getId();
+        assertNotNull(secondSessionId);
+        assertFalse(firstSessionId.equals(secondSessionId));
+
+        subject.logout();
+
+        sm.destroy();
+    }
+
+    @Test
+    public void testExecuteCallable() {
+
+        String username = "jsmith";
+
+        SecurityManager securityManager = createNiceMock(SecurityManager.class);
+        PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");
+        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);
+
+        assertNull(ThreadContext.getSubject());
+        assertNull(ThreadContext.getSecurityManager());
+
+        Callable<String> callable = new Callable<String>() {
+            public String call() throws Exception {
+                Subject callingSubject = SecurityUtils.getSubject();
+                assertNotNull(callingSubject);
+                assertNotNull(SecurityUtils.getSecurityManager());
+                assertEquals(callingSubject, sourceSubject);
+                return "Hello " + callingSubject.getPrincipal();
+            }
+        };
+        String response = sourceSubject.execute(callable);
+
+        assertNotNull(response);
+        assertEquals("Hello " + username, response);
+
+        assertNull(ThreadContext.getSubject());
+        assertNull(ThreadContext.getSecurityManager());
+    }
+
+    @Test
+    public void testExecuteRunnable() {
+
+        String username = "jsmith";
+
+        SecurityManager securityManager = createNiceMock(SecurityManager.class);
+        PrincipalCollection identity = new SimplePrincipalCollection(username, "testRealm");
+        final Subject sourceSubject = new DelegatingSubject(identity, true, null, null, securityManager);
+
+        assertNull(ThreadContext.getSubject());
+        assertNull(ThreadContext.getSecurityManager());
+
+        Runnable runnable = new Runnable() {
+            public void run() {
+                Subject callingSubject = SecurityUtils.getSubject();
+                assertNotNull(callingSubject);
+                assertNotNull(SecurityUtils.getSecurityManager());
+                assertEquals(callingSubject, sourceSubject);
+            }
+        };
+        sourceSubject.execute(runnable);
+
+        assertNull(ThreadContext.getSubject());
+        assertNull(ThreadContext.getSecurityManager());
+    }
+
+    @Test
+    public void testRunAs() {
+
+        Ini ini = new Ini();
+        Ini.Section users = ini.addSection("users");
+        users.put("user1", "user1,role1");
+        users.put("user2", "user2,role2");
+        IniSecurityManagerFactory factory = new IniSecurityManagerFactory(ini);
+        SecurityManager sm = factory.getInstance();
+
+        Subject subject = new Subject.Builder(sm).buildSubject();
+        subject.login(new UsernamePasswordToken("user1", "user1"));
+
+        assertTrue(subject.getPrincipal().equals("user1"));
+        assertTrue(subject.hasRole("role1"));
+        assertFalse(subject.isRunAs());
+        assertNull(subject.getPreviousPrincipals());
+
+        subject.runAs(new SimplePrincipalCollection("user2", IniSecurityManagerFactory.INI_REALM_NAME));
+
+        assertFalse(subject.getPrincipal().equals("user1"));
+        assertFalse(subject.hasRole("role1"));
+        assertTrue(subject.getPrincipal().equals("user2"));
+        assertTrue(subject.hasRole("role2"));
+        assertTrue(subject.isRunAs());
+        assertFalse(CollectionUtils.isEmpty(subject.getPreviousPrincipals()));
+        assertTrue(subject.getPreviousPrincipals().getPrimaryPrincipal().equals("user1"));
+
+        subject.releaseRunAs();
+        assertTrue(subject.getPrincipal().equals("user1"));
+        assertTrue(subject.hasRole("role1"));
+        assertFalse(subject.isRunAs());
+        assertNull(subject.getPreviousPrincipals());
+
+        subject.logout();
+        LifecycleUtils.destroy(sm);
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/test/SecurityManagerTestSupport.java b/core/src/test/java/org/apache/shiro/test/SecurityManagerTestSupport.java
index 24fff42d4..3cc47bd78 100644
--- a/core/src/test/java/org/apache/shiro/test/SecurityManagerTestSupport.java
+++ b/core/src/test/java/org/apache/shiro/test/SecurityManagerTestSupport.java
@@ -1,76 +1,76 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.test;
-
-import org.apache.shiro.SecurityUtils;
-import org.apache.shiro.config.Ini;
-import org.apache.shiro.mgt.DefaultSecurityManager;
-import org.apache.shiro.mgt.SecurityManager;
-import org.apache.shiro.realm.text.IniRealm;
-import org.apache.shiro.subject.Subject;
-import org.apache.shiro.util.LifecycleUtils;
-import org.apache.shiro.util.ThreadContext;
-import org.junit.After;
-import org.junit.Before;
-
-/**
- * Utility methods for use by Shiro test case subclasses.  You can use these methods as examples for your own
- * test cases, but you SHOULD NOT use any ThreadContext API calls in your actual application code.
- * The utility methods here make heavy assumptions about Shiro's implementation details, and your
- * application code should definitely not.
- * <p/>
- * See the <a href="http://cwiki.apache.org/confluence/display/SHIRO/Subject">wiki Subject documentation</a>
- * for proper application practices using Subject instances with threads.
- */
-public class SecurityManagerTestSupport {
-
-    protected static SecurityManager createTestSecurityManager() {
-        Ini ini = new Ini();
-        ini.setSectionProperty("users", "test", "test");
-        return new DefaultSecurityManager(new IniRealm(ini));
-    }
-
-    protected void destroy(SecurityManager sm) {
-        LifecycleUtils.destroy(sm);
-    }
-
-    protected SecurityManager createAndBindTestSecurityManager() {
-        SecurityManager sm = createTestSecurityManager();
-        ThreadContext.bind(sm);
-        return sm;
-    }
-
-    protected Subject createAndBindTestSubject() {
-        SecurityManager sm = ThreadContext.getSecurityManager();
-        if (sm == null) {
-            createAndBindTestSecurityManager();
-        }
-        return SecurityUtils.getSubject();
-    }
-
-    @Before
-    public void setup() {
-        createAndBindTestSubject();
-    }
-
-    @After
-    public void teardown() {
-        ThreadContext.remove();
-    }
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.test;
+
+import org.apache.shiro.SecurityUtils;
+import org.apache.shiro.config.Ini;
+import org.apache.shiro.mgt.DefaultSecurityManager;
+import org.apache.shiro.mgt.SecurityManager;
+import org.apache.shiro.realm.text.IniRealm;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.LifecycleUtils;
+import org.apache.shiro.util.ThreadContext;
+import org.junit.After;
+import org.junit.Before;
+
+/**
+ * Utility methods for use by Shiro test case subclasses.  You can use these methods as examples for your own
+ * test cases, but you SHOULD NOT use any ThreadContext API calls in your actual application code.
+ * The utility methods here make heavy assumptions about Shiro's implementation details, and your
+ * application code should definitely not.
+ * <p/>
+ * See the <a href="http://cwiki.apache.org/confluence/display/SHIRO/Subject">wiki Subject documentation</a>
+ * for proper application practices using Subject instances with threads.
+ */
+public class SecurityManagerTestSupport {
+
+    protected static SecurityManager createTestSecurityManager() {
+        Ini ini = new Ini();
+        ini.setSectionProperty("users", "test", "test");
+        return new DefaultSecurityManager(new IniRealm(ini));
+    }
+
+    protected void destroy(SecurityManager sm) {
+        LifecycleUtils.destroy(sm);
+    }
+
+    protected SecurityManager createAndBindTestSecurityManager() {
+        SecurityManager sm = createTestSecurityManager();
+        ThreadContext.bind(sm);
+        return sm;
+    }
+
+    protected Subject createAndBindTestSubject() {
+        SecurityManager sm = ThreadContext.getSecurityManager();
+        if (sm == null) {
+            createAndBindTestSecurityManager();
+        }
+        return SecurityUtils.getSubject();
+    }
+
+    @Before
+    public void setup() {
+        createAndBindTestSubject();
+    }
+
+    @After
+    public void teardown() {
+        ThreadContext.remove();
+    }
+}
diff --git a/core/src/test/java/org/apache/shiro/util/RegExPatternMatcherTest.java b/core/src/test/java/org/apache/shiro/util/RegExPatternMatcherTest.java
index 0c2dca0a6..5246ba609 100644
--- a/core/src/test/java/org/apache/shiro/util/RegExPatternMatcherTest.java
+++ b/core/src/test/java/org/apache/shiro/util/RegExPatternMatcherTest.java
@@ -1,43 +1,43 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.shiro.util;
-
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-import java.util.regex.Pattern;
-
-/**
- * Unit tests for the {@link RegExPatternMatcher}.
- *
- * @since 1.0
- */
-public class RegExPatternMatcherTest {
-
-    @Test
-    public void testSimplePattern() {
-        PatternMatcher pm = new RegExPatternMatcher();
-        String pattern = "a*b";
-        String test = "aaaaaaab";
-        //not necessary for the test, but Idea performs auto validation when it sees this:
-        Pattern.compile(pattern);
-        assertTrue(pm.matches(pattern, test));
-    }
-
-}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.shiro.util;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import java.util.regex.Pattern;
+
+/**
+ * Unit tests for the {@link RegExPatternMatcher}.
+ *
+ * @since 1.0
+ */
+public class RegExPatternMatcherTest {
+
+    @Test
+    public void testSimplePattern() {
+        PatternMatcher pm = new RegExPatternMatcher();
+        String pattern = "a*b";
+        String test = "aaaaaaab";
+        //not necessary for the test, but Idea performs auto validation when it sees this:
+        Pattern.compile(pattern);
+        assertTrue(pm.matches(pattern, test));
+    }
+
+}
diff --git a/core/src/test/resources/org/apache/shiro/config/IniSecurityManagerFactoryTest.ini b/core/src/test/resources/org/apache/shiro/config/IniSecurityManagerFactoryTest.ini
index c802c8aba..28657e64f 100644
--- a/core/src/test/resources/org/apache/shiro/config/IniSecurityManagerFactoryTest.ini
+++ b/core/src/test/resources/org/apache/shiro/config/IniSecurityManagerFactoryTest.ini
@@ -1,24 +1,24 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[users]
-user1 = user1, admin
-
-[roles]
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[users]
+user1 = user1, admin
+
+[roles]
 admin = *
\ No newline at end of file
diff --git a/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.noUsers.ini b/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.noUsers.ini
index b7b9cf9cd..69e3acb08 100644
--- a/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.noUsers.ini
+++ b/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.noUsers.ini
@@ -1,21 +1,21 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[roles]
-admin = *
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[roles]
+admin = *
diff --git a/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.simple.ini b/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.simple.ini
index 479b5a981..d3c81aa66 100644
--- a/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.simple.ini
+++ b/core/src/test/resources/org/apache/shiro/realm/text/IniRealmTest.simple.ini
@@ -1,25 +1,25 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
-#
-
-[users]
-user1 = user1, admin
-
-[roles]
-admin = *
-
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+[users]
+user1 = user1, admin
+
+[roles]
+admin = *
+
