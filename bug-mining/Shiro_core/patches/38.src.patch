diff --git a/core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java b/core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
index 74de3aee9..3632431ca 100644
--- a/core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
+++ b/core/src/main/java/org/apache/shiro/authc/pam/ModularRealmAuthenticator.java
@@ -21,6 +21,7 @@ package org.apache.shiro.authc.pam;
 import org.apache.shiro.authc.*;
 import org.apache.shiro.realm.Realm;
 import org.apache.shiro.subject.PrincipalCollection;
+import org.apache.shiro.util.CollectionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -154,7 +155,7 @@ public class ModularRealmAuthenticator extends AbstractAuthenticator {
 
     protected void assertRealmsConfigured() throws IllegalStateException {
         Collection<Realm> realms = getRealms();
-        if (realms == null || realms.isEmpty()) {
+        if (CollectionUtils.isEmpty(realms)) {
             String msg = "Configuration error:  No realms have been configured!  One or more realms must be " +
                     "present to execute an authentication attempt.";
             throw new IllegalStateException(msg);
@@ -206,6 +207,8 @@ public class ModularRealmAuthenticator extends AbstractAuthenticator {
 
         for (Realm realm : realms) {
 
+            aggregate = strategy.beforeAttempt(realm, token, aggregate);
+
             if (realm.supports(token)) {
 
                 log.trace("Attempting to authenticate token [{}] using realm [{}]", token, realm);
@@ -281,7 +284,7 @@ public class ModularRealmAuthenticator extends AbstractAuthenticator {
     public void onLogout(PrincipalCollection principals) {
         super.onLogout(principals);
         Collection<Realm> realms = getRealms();
-        if (realms != null && !realms.isEmpty()) {
+        if (!CollectionUtils.isEmpty(realms)) {
             for (Realm realm : realms) {
                 if (realm instanceof LogoutAware) {
                     ((LogoutAware) realm).onLogout(principals);
diff --git a/core/src/main/java/org/apache/shiro/util/CollectionUtils.java b/core/src/main/java/org/apache/shiro/util/CollectionUtils.java
index 1983d5cb8..0956efae7 100644
--- a/core/src/main/java/org/apache/shiro/util/CollectionUtils.java
+++ b/core/src/main/java/org/apache/shiro/util/CollectionUtils.java
@@ -66,6 +66,29 @@ public class CollectionUtils {
         return m == null || m.isEmpty();
     }
 
+    /**
+     * Returns the size of the specified collection or {@code 0} if the collection is {@code null}.
+     *
+     * @param c the collection to check
+     * @return the size of the specified collection or {@code 0} if the collection is {@code null}.
+     * @since 1.2
+     */
+    public static int size(Collection c) {
+        return c != null ? c.size() : 0;
+    }
+
+    /**
+     * Returns the size of the specified map or {@code 0} if the map is {@code null}.
+     *
+     * @param m the map to check
+     * @return the size of the specified map or {@code 0} if the map is {@code null}.
+     * @since 1.2
+     */
+    public static int size(Map m) {
+        return m != null ? m.size() : 0;
+    }
+
+
     /**
      * Returns {@code true} if the specified {@code PrincipalCollection} is {@code null} or
      * {@link PrincipalCollection#isEmpty empty}, {@code false} otherwise.
diff --git a/core/src/test/groovy/org/apache/shiro/authc/pam/ModularRealmAuthenticatorTest.groovy b/core/src/test/groovy/org/apache/shiro/authc/pam/ModularRealmAuthenticatorTest.groovy
new file mode 100644
index 000000000..0d7e5d610
--- /dev/null
+++ b/core/src/test/groovy/org/apache/shiro/authc/pam/ModularRealmAuthenticatorTest.groovy
@@ -0,0 +1,196 @@
+package org.apache.shiro.authc.pam
+
+import org.apache.shiro.realm.Realm
+import org.apache.shiro.subject.PrincipalCollection
+import org.apache.shiro.authc.*
+import static org.easymock.EasyMock.*
+
+/**
+ * Created by IntelliJ IDEA.
+ * User: lhazlewood
+ * Date: 2/19/11
+ * Time: 2:03 PM
+ * To change this template use File | Settings | File Templates.
+ */
+class ModularRealmAuthenticatorTest extends GroovyTestCase {
+
+    void testNewInstance() {
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        assertNotNull mra.authenticationStrategy
+        assertTrue mra.authenticationStrategy instanceof AtLeastOneSuccessfulStrategy
+    }
+
+    void testDoAuthenticateNoRealms() {
+
+        def token = createStrictMock(AuthenticationToken)
+
+        replay token
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator();
+        try {
+            mra.doAuthenticate(token)
+            fail "ModularRealmAuthenticator should fail when no realms are configured."
+        } catch (IllegalStateException expected) {
+        }
+
+        verify token
+    }
+
+    void testSingleRealmAuthenticationSuccess() {
+
+        def realm = createStrictMock(Realm)
+        def token = createStrictMock(AuthenticationToken)
+        def info = createStrictMock(AuthenticationInfo)
+
+        expect(realm.supports(same(token))).andReturn true
+        expect(realm.getAuthenticationInfo(same(token))).andReturn info
+
+        replay realm, token, info
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.realms = [realm]
+
+        assertSame info, mra.doAuthenticate(token)
+
+        verify realm, token, info
+    }
+
+    void testSingleRealmAuthenticationWithUnsupportedToken() {
+
+        def realm = createStrictMock(Realm)
+        def token = createStrictMock(AuthenticationToken)
+
+        expect(realm.supports(same(token))).andReturn false
+
+        replay realm, token
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.realms = [realm]
+
+        try {
+            mra.doAuthenticate(token)
+            fail "Should throw UnsupportedTokenException when single realm does not support a token."
+        } catch (UnsupportedTokenException expected) {
+        }
+
+        verify realm, token
+    }
+
+    void testSingleRealmAuthenticationWithNullAuthenticationInfo() {
+
+        def realm = createStrictMock(Realm)
+        def token = createStrictMock(AuthenticationToken)
+
+        expect(realm.supports(same(token))).andReturn true
+        expect(realm.getAuthenticationInfo(same(token))).andReturn null
+
+        replay realm, token
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.realms = [realm]
+
+        try {
+            mra.doAuthenticate(token)
+            fail "Should throw UnknownAccountException when single realm returns null."
+        } catch (UnknownAccountException expected) {
+        }
+
+        verify realm, token
+    }
+
+    void testMultiRealmAuthenticationSuccess() {
+
+        def realm1 = createStrictMock(Realm)
+        def realm1Info = createStrictMock(AuthenticationInfo)
+        def realm2 = createStrictMock(Realm)
+        def realm2Info = createStrictMock(AuthenticationInfo)
+        def token = createStrictMock(AuthenticationToken)
+        def aggregate = createStrictMock(AuthenticationInfo)
+        def strategy = createStrictMock(AuthenticationStrategy)
+        def realms = [realm1, realm2]
+
+
+        expect(strategy.beforeAllAttempts(same(realms), same(token))).andReturn aggregate
+
+        expect(strategy.beforeAttempt(same(realm1), same(token), same(aggregate))).andReturn aggregate
+        expect(realm1.supports(same(token))).andReturn true
+        expect(realm1.getAuthenticationInfo(same(token))).andReturn realm1Info
+        expect(strategy.afterAttempt(same(realm1), same(token), same(realm1Info), same(aggregate), isNull(Throwable))).andReturn aggregate
+
+        expect(strategy.beforeAttempt(same(realm2), same(token), same(aggregate))).andReturn aggregate
+        expect(realm2.supports(same(token))).andReturn true
+        expect(realm2.getAuthenticationInfo(same(token))).andReturn realm2Info
+        expect(strategy.afterAttempt(same(realm2), same(token), same(realm2Info), same(aggregate), isNull(Throwable))).andReturn aggregate
+
+        expect(strategy.afterAllAttempts(same(token), same(aggregate))).andReturn aggregate
+
+
+        replay realm1, realm1Info, realm2, realm2Info, token, aggregate, strategy
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.authenticationStrategy = strategy
+        mra.realms = realms
+
+        assertSame aggregate, mra.doAuthenticate(token)
+
+        verify realm1, realm1Info, realm2, realm2Info, token, aggregate, strategy
+    }
+
+    void testMultiRealmAuthenticationWithAuthenticationException() {
+
+        def realm1 = createStrictMock(Realm)
+        def realm1Info = createStrictMock(AuthenticationInfo)
+        def realm2 = createStrictMock(Realm)
+        def token = createStrictMock(AuthenticationToken)
+        def aggregate = createStrictMock(AuthenticationInfo)
+        def strategy = createStrictMock(AuthenticationStrategy)
+        def authcException = new AuthenticationException("test")
+        def realms = [realm1, realm2]
+
+
+        expect(strategy.beforeAllAttempts(same(realms), same(token))).andReturn aggregate
+
+        expect(strategy.beforeAttempt(same(realm1), same(token), same(aggregate))).andReturn aggregate
+        expect(realm1.supports(same(token))).andReturn true
+        expect(realm1.getAuthenticationInfo(same(token))).andReturn realm1Info
+        expect(strategy.afterAttempt(same(realm1), same(token), same(realm1Info), same(aggregate), isNull(Throwable))).andReturn aggregate
+
+        expect(strategy.beforeAttempt(same(realm2), same(token), same(aggregate))).andReturn aggregate
+        expect(realm2.supports(same(token))).andReturn true
+        expect(realm2.getAuthenticationInfo(same(token))).andThrow authcException
+        expect(strategy.afterAttempt(same(realm2), same(token), isNull(AuthenticationInfo), same(aggregate), same(authcException))).andReturn aggregate
+
+        expect(strategy.afterAllAttempts(same(token), same(aggregate))).andReturn aggregate
+
+
+        replay realm1, realm1Info, realm2, token, aggregate, strategy
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.authenticationStrategy = strategy
+        mra.realms = realms
+
+        assertSame aggregate, mra.doAuthenticate(token)
+
+        verify realm1, realm1Info, realm2, token, aggregate, strategy
+    }
+
+    void testOnLogout() {
+
+        def realm = createStrictMock(LogoutAwareRealm)
+        def principals = createStrictMock(PrincipalCollection)
+
+        realm.onLogout(same(principals))
+
+        replay realm, principals
+
+        ModularRealmAuthenticator mra = new ModularRealmAuthenticator()
+        mra.realms = [realm]
+        mra.onLogout(principals)
+
+        verify realm, principals
+    }
+
+    private static interface LogoutAwareRealm extends Realm, LogoutAware {
+
+    }
+}
