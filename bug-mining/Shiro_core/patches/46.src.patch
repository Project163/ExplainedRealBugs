diff --git a/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java b/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
index 8bcd05028..71c45fb4e 100644
--- a/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
+++ b/core/src/main/java/org/apache/shiro/authz/permission/DomainPermission.java
@@ -20,6 +20,8 @@ package org.apache.shiro.authz.permission;
 
 import org.apache.shiro.util.StringUtils;
 
+import java.util.Set;
+
 /**
  * Provides a base Permission class from which type-safe/domain-specific subclasses may extend.  Can be used
  * as a base class for JPA/Hibernate persisted permissions that wish to store the parts of the permission string
@@ -28,28 +30,41 @@ import org.apache.shiro.util.StringUtils;
  *
  * @since 1.0
  */
-public abstract class DomainPermission extends WildcardPermission {
+public class DomainPermission extends WildcardPermission {
 
     private String domain;
-    private String actions;
-    private String targets;
+    private Set<String> actions;
+    private Set<String> targets;
+
+    private static final long serialVersionUID = 1l;
 
     /**
      * Creates a domain permission with *all* actions for *all* targets;
      */
     public DomainPermission() {
-        setParts(getDomain(getClass()), null, null);
+        this.domain = getDomain(getClass());
+        setParts(getDomain(getClass()));
     }
 
     public DomainPermission(String actions) {
-        setParts(getDomain(getClass()), actions, null);
+        domain = getDomain(getClass());
+        this.actions = StringUtils.splitToSet(actions, SUBPART_DIVIDER_TOKEN);
+        encodeParts(domain, actions, null);
     }
 
     public DomainPermission(String actions, String targets) {
-        setParts(getDomain(getClass()), actions, targets);
+        this.domain = getDomain(getClass());
+        this.actions = StringUtils.splitToSet(actions, SUBPART_DIVIDER_TOKEN);
+        this.targets = StringUtils.splitToSet(actions, SUBPART_DIVIDER_TOKEN);
+        encodeParts(this.domain, actions, targets);
+    }
+
+    protected DomainPermission(Set<String> actions, Set<String> targets) {
+        this.domain = getDomain(getClass());
+        setParts(domain, actions, targets);
     }
 
-    protected void setParts(String domain, String actions, String targets) {
+    private void encodeParts(String domain, String actions, String targets) {
         if (!StringUtils.hasText(domain)) {
             throw new IllegalArgumentException("domain argument cannot be null or empty.");
         }
@@ -62,12 +77,21 @@ public abstract class DomainPermission extends WildcardPermission {
         } else {
             sb.append(PART_DIVIDER_TOKEN).append(actions);
         }
-        if (targets != null) {
+        if (StringUtils.hasText(targets)) {
             sb.append(PART_DIVIDER_TOKEN).append(targets);
         }
         setParts(sb.toString());
     }
 
+    protected void setParts(String domain, Set<String> actions, Set<String> targets) {
+        String actionsString = StringUtils.toDelimitedString(actions, SUBPART_DIVIDER_TOKEN);
+        String targetsString = StringUtils.toDelimitedString(targets, SUBPART_DIVIDER_TOKEN);
+        encodeParts(domain, actionsString, targetsString);
+        this.domain = domain;
+        this.actions = actions;
+        this.targets = targets;
+    }
+
     protected String getDomain(Class<? extends DomainPermission> clazz) {
         String domain = clazz.getSimpleName().toLowerCase();
         //strip any trailing 'permission' text from the name (as all subclasses should have been named):
@@ -83,22 +107,35 @@ public abstract class DomainPermission extends WildcardPermission {
     }
 
     protected void setDomain(String domain) {
+        if (this.domain != null && this.domain.equals(domain)) {
+            return;
+        }
         this.domain = domain;
+        setParts(domain, actions, targets);
     }
 
-    public String getActions() {
+    public Set<String> getActions() {
         return actions;
     }
 
-    protected void setActions(String actions) {
+    protected void setActions(Set<String> actions) {
+        if (this.actions != null && this.actions.equals(actions)) {
+            return;
+        }
         this.actions = actions;
+        setParts(domain, actions, targets);
     }
 
-    public String getTargets() {
+    public Set<String> getTargets() {
         return targets;
     }
 
-    protected void setTargets(String targets) {
+    protected void setTargets(Set<String> targets) {
+        this.targets = targets;
+        if (this.targets != null && this.targets.equals(targets)) {
+            return;
+        }
         this.targets = targets;
+        setParts(domain, actions, targets);
     }
 }
diff --git a/core/src/main/java/org/apache/shiro/util/StringUtils.java b/core/src/main/java/org/apache/shiro/util/StringUtils.java
index 0c9320d10..286dd0d4d 100644
--- a/core/src/main/java/org/apache/shiro/util/StringUtils.java
+++ b/core/src/main/java/org/apache/shiro/util/StringUtils.java
@@ -19,14 +19,11 @@
 package org.apache.shiro.util;
 
 import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.StringTokenizer;
+import java.util.*;
 
 /**
  * <p>Simple utility class for String operations useful across the framework.
- *
+ * <p/>
  * <p>Some methods in this class were copied from the Spring Framework so we didn't have to re-invent the wheel,
  * and in these cases, we have retained all license, copyright and author information.
  *
@@ -36,13 +33,19 @@ public class StringUtils {
 
     //TODO - complete JavaDoc
 
-    /** Constant representing the empty string, equal to &quot;&quot; */
+    /**
+     * Constant representing the empty string, equal to &quot;&quot;
+     */
     public static final String EMPTY_STRING = "";
 
-    /** Constant representing the default delimiter character (comma), equal to <code>','</code> */
+    /**
+     * Constant representing the default delimiter character (comma), equal to <code>','</code>
+     */
     public static final char DEFAULT_DELIMITER_CHAR = ',';
 
-    /** Constant representing the default quote character (double quote), equal to '&quot;'</code> */
+    /**
+     * Constant representing the default quote character (double quote), equal to '&quot;'</code>
+     */
     public static final char DEFAULT_QUOTE_CHAR = '"';
 
     /**
@@ -55,7 +58,7 @@ public class StringUtils {
      * StringUtils.hasText(" ") == false<br/>
      * StringUtils.hasText("12345") == true<br/>
      * StringUtils.hasText(" 12345 ") == true</code>
-     *
+     * <p/>
      * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
      *
      * @param str the String to check (may be <code>null</code>)
@@ -99,7 +102,7 @@ public class StringUtils {
     /**
      * Test if the given String starts with the specified prefix,
      * ignoring upper/lower case.
-     *
+     * <p/>
      * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
      *
      * @param str    the String to check
@@ -124,14 +127,14 @@ public class StringUtils {
 
     /**
      * Returns a 'cleaned' representation of the specified argument.  'Cleaned' is defined as the following:
-     *
+     * <p/>
      * <ol>
      * <li>If the specified <code>String</code> is <code>null</code>, return <code>null</code></li>
      * <li>If not <code>null</code>, {@link String#trim() trim()} it.</li>
      * <li>If the trimmed string is equal to the empty String (i.e. &quot;&quot;), return <code>null</code></li>
      * <li>If the trimmed string is not the empty string, return the trimmed version</li>.
      * </ol>
-     *
+     * <p/>
      * Therefore this method always ensures that any given string has trimmed text, and if it doesn't, <code>null</code>
      * is returned.
      *
@@ -153,30 +156,31 @@ public class StringUtils {
 
     /**
      * Returns the specified array as a comma-delimited (',') string.
+     *
      * @param array the array whose contents will be converted to a string.
      * @return the array's contents as a comma-delimited (',') string.
      * @since 1.0
      */
     public static String toString(Object[] array) {
-        return toDelimitedString(array,",");
+        return toDelimitedString(array, ",");
     }
 
     /**
      * Returns the array's contents as a string, with each element delimited by the specified
      * {@code delimiter} argument.  Useful for {@code toString()} implementations and log messages.
      *
-     * @param array the array whose contents will be converted to a string
+     * @param array     the array whose contents will be converted to a string
      * @param delimiter the delimiter to use between each element
      * @return a single string, delimited by the specified {@code delimiter}.
      * @since 1.0
      */
-    public static String toDelimitedString(Object[] array, String delimiter ) {
-        if ( array == null || array.length == 0 ) {
+    public static String toDelimitedString(Object[] array, String delimiter) {
+        if (array == null || array.length == 0) {
             return EMPTY_STRING;
         }
         StringBuilder sb = new StringBuilder();
-        for( int i=0; i < array.length; i++ ) {
-            if ( i > 0 ) {
+        for (int i = 0; i < array.length; i++) {
+            if (i > 0) {
                 sb.append(delimiter);
             }
             sb.append(array[i]);
@@ -184,6 +188,22 @@ public class StringUtils {
         return sb.toString();
     }
 
+    /**
+     * Returns the collection's contents as a string, with each element delimited by the specified
+     * {@code delimiter} argument.  Useful for {@code toString()} implementations and log messages.
+     *
+     * @param c         the collection whose contents will be converted to a string
+     * @param delimiter the delimiter to use between each element
+     * @return a single string, delimited by the specified {@code delimiter}.
+     * @since 1.2
+     */
+    public static String toDelimitedString(Collection c, String delimiter) {
+        if (c == null || c.isEmpty()) {
+            return EMPTY_STRING;
+        }
+        return join(c.iterator(), delimiter);
+    }
+
     /**
      * Tokenize the given String into a String array via a StringTokenizer.
      * Trims tokens and omits empty tokens.
@@ -191,7 +211,7 @@ public class StringUtils {
      * delimiter characters. Each of those characters can be used to separate
      * tokens. A delimiter is always a single character; for multi-character
      * delimiters, consider using <code>delimitedListToStringArray</code>
-     *
+     * <p/>
      * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
      *
      * @param str        the String to tokenize
@@ -211,7 +231,7 @@ public class StringUtils {
      * delimiter characters. Each of those characters can be used to separate
      * tokens. A delimiter is always a single character; for multi-character
      * delimiters, consider using <code>delimitedListToStringArray</code>
-     *
+     * <p/>
      * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
      *
      * @param str               the String to tokenize
@@ -250,7 +270,7 @@ public class StringUtils {
     /**
      * Copy the given Collection into a String array.
      * The Collection must contain String elements only.
-     *
+     * <p/>
      * <p>Copied from the Spring Framework while retaining all license, copyright and author information.
      *
      * @param collection the Collection to copy
@@ -321,13 +341,13 @@ public class StringUtils {
     /**
      * Splits the specified delimited String into tokens, supporting quoted tokens so that quoted strings themselves
      * won't be tokenized.
-     *
-     * <p>This method's implementation is very loosely based (with significant modifications) on
+     * <p/>
+     * This method's implementation is very loosely based (with significant modifications) on
      * <a href="http://blogs.bytecode.com.au/glen">Glen Smith</a>'s open-source
      * <a href="http://opencsv.svn.sourceforge.net/viewvc/opencsv/trunk/src/au/com/bytecode/opencsv/CSVReader.java?&view=markup">CSVReader.java</a>
      * file.
-     *
-     * <p>That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to
+     * <p/>
+     * That file is Apache 2.0 licensed as well, making Glen's code a great starting point for us to modify to
      * our needs.
      *
      * @param aLine          the String to parse
@@ -392,4 +412,70 @@ public class StringUtils {
         return tokens.toArray(new String[tokens.size()]);
     }
 
+    /**
+     * Joins the elements of the provided {@code Iterator} into
+     * a single String containing the provided elements.</p>
+     * <p/>
+     * No delimiter is added before or after the list.
+     * A {@code null} separator is the same as an empty String ("").</p>
+     * <p/>
+     * Copied from Commons Lang, version 3 (r1138702).</p>
+     *
+     * @param iterator  the {@code Iterator} of values to join together, may be null
+     * @param separator the separator character to use, null treated as ""
+     * @return the joined String, {@code null} if null iterator input
+     * @since 1.2
+     */
+    public static String join(Iterator<?> iterator, String separator) {
+        final String empty = "";
+
+        // handle null, zero and one elements before building a buffer
+        if (iterator == null) {
+            return null;
+        }
+        if (!iterator.hasNext()) {
+            return empty;
+        }
+        Object first = iterator.next();
+        if (!iterator.hasNext()) {
+            return first == null ? empty : first.toString();
+        }
+
+        // two or more elements
+        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small
+        if (first != null) {
+            buf.append(first);
+        }
+
+        while (iterator.hasNext()) {
+            if (separator != null) {
+                buf.append(separator);
+            }
+            Object obj = iterator.next();
+            if (obj != null) {
+                buf.append(obj);
+            }
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Splits the {@code delimited} string (delimited by the specified {@code separator} character) and returns the
+     * delimited values as a {@code Set}.
+     * <p/>
+     * If either argument is {@code null}, this method returns {@code null}.
+     *
+     * @param delimited the string to split
+     * @param separator the character that delineates individual tokens to split
+     * @return the delimited values as a {@code Set}.
+     * @since 1.2
+     */
+    public static Set<String> splitToSet(String delimited, String separator) {
+        if (delimited == null || separator == null) {
+            return null;
+        }
+        String[] split = split(delimited, separator.charAt(0));
+        return CollectionUtils.asSet(split);
+    }
+
 }
