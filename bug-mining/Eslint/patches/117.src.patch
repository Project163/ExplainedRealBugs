diff --git a/lib/cli-engine.js b/lib/cli-engine.js
index 352a9ca3c..8442de2de 100644
--- a/lib/cli-engine.js
+++ b/lib/cli-engine.js
@@ -540,23 +540,14 @@ class CLIEngine {
 
         if (options.cache) {
             results.forEach(result => {
-                if (result.messages.length) {
-
-                    /*
-                     * if a file contains errors or warnings we don't want to
-                     * store the file in the cache so we can guarantee that
-                     * next execution will also operate on this file
-                     */
-                    lintResultCache.removeEntry(result.filePath);
-                } else {
-
-                    /*
-                     * since the file passed we store the result here
-                     * TODO: it might not be necessary to store the results list in the cache,
-                     * since it should always be 0 errors/warnings
-                     */
-                    lintResultCache.setCachedLintResults(result.filePath, result);
-                }
+
+                /*
+                 * Store the lint result in the LintResultCache.
+                 * NOTE: The LintResultCache will remove the file source and any
+                 * other properties that are difficult to serialize, and will
+                 * hydrate those properties back in on future lint runs.
+                 */
+                lintResultCache.setCachedLintResults(result.filePath, result);
             });
 
             // persist the cache to disk
diff --git a/lib/util/lint-result-cache.js b/lib/util/lint-result-cache.js
index a8f1c775f..29b432bd5 100644
--- a/lib/util/lint-result-cache.js
+++ b/lib/util/lint-result-cache.js
@@ -9,6 +9,7 @@
 //-----------------------------------------------------------------------------
 
 const assert = require("assert"),
+    fs = require("fs"),
     fileEntryCache = require("file-entry-cache"),
     hash = require("./hash"),
     pkg = require("../../package.json"),
@@ -89,21 +90,46 @@ class LintResultCache {
             return null;
         }
 
+        // If source is present but null, need to reread the file from the filesystem.
+        if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {
+            fileDescriptor.meta.results.source = fs.readFileSync(filePath, "utf-8");
+        }
+
         return fileDescriptor.meta.results;
     }
 
     /**
      * Set the cached lint results for a given file path, after removing any
      * information that will be both unnecessary and difficult to serialize.
+     * Avoids caching results with an "output" property (meaning fixes were
+     * applied), to prevent potentially incorrect results if fixes are not
+     * written to disk.
      * @param {string} filePath The file for which to set lint results.
      * @param {Object} result The lint result to be set for the file.
      * @returns {void}
      */
     setCachedLintResults(filePath, result) {
+        if (result && result.hasOwnProperty("output")) {
+            return;
+        }
+
         const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);
 
-        if (!fileDescriptor.notFound) {
-            fileDescriptor.meta.results = result;
+        if (fileDescriptor && !fileDescriptor.notFound) {
+
+            // Serialize the result, except that we want to remove the file source if present.
+            const resultToSerialize = Object.assign({}, result);
+
+            /*
+             * Set result.source to null.
+             * In `getCachedLintResults`, if source is explicitly null, we will
+             * read the file from the filesystem to set the value again.
+             */
+            if (resultToSerialize.hasOwnProperty("source")) {
+                resultToSerialize.source = null;
+            }
+
+            fileDescriptor.meta.results = resultToSerialize;
             fileDescriptor.meta.hashOfConfig = hashOfConfigFor(this.configHelper, result.filePath);
         }
     }
@@ -115,15 +141,6 @@ class LintResultCache {
     reconcile() {
         this.fileEntryCache.reconcile();
     }
-
-    /**
-     * Remove a file entry from this lint result cache.
-     * @param {string} filePath The file path to be removed from the cache.
-     * @returns {void}
-     */
-    removeEntry(filePath) {
-        this.fileEntryCache.removeEntry(filePath);
-    }
 }
 
 module.exports = LintResultCache;
diff --git a/tests/fixtures/lint-result-cache/.eslintrc.json b/tests/fixtures/lint-result-cache/.eslintrc.json
index 6e5817ef6..8036a75af 100644
--- a/tests/fixtures/lint-result-cache/.eslintrc.json
+++ b/tests/fixtures/lint-result-cache/.eslintrc.json
@@ -1,5 +1,6 @@
 {
     "rules": {
+        "no-dupe-args": "error",
         "semi": ["error", "always"]
     },
     "root": true
diff --git a/tests/fixtures/lint-result-cache/test-with-errors.js b/tests/fixtures/lint-result-cache/test-with-errors.js
index 7f97cd8a0..38790aabe 100644
--- a/tests/fixtures/lint-result-cache/test-with-errors.js
+++ b/tests/fixtures/lint-result-cache/test-with-errors.js
@@ -1 +1,2 @@
 console.log("Hello, world!")
+function foo(a, a) {}
diff --git a/tests/lib/cli-engine.js b/tests/lib/cli-engine.js
index c4e0ab054..7643a241d 100644
--- a/tests/lib/cli-engine.js
+++ b/tests/lib/cli-engine.js
@@ -2132,7 +2132,7 @@ describe("CLIEngine", () => {
                 assert.isFalse(shell.test("-f", cacheFile), "the cache for eslint was deleted since last run did not used the cache");
             });
 
-            it("should not store in the cache a file that failed the test", () => {
+            it("should store in the cache a file that failed the test", () => {
 
                 const cacheFile = getFixturePath(".eslintcache");
 
@@ -2163,7 +2163,7 @@ describe("CLIEngine", () => {
 
                 assert.isTrue(typeof cache[goodFile] === "object", "the entry for the good file is in the cache");
 
-                assert.isTrue(typeof cache[badFile] === "undefined", "the entry for the bad file is not in the cache");
+                assert.isTrue(typeof cache[badFile] === "object", "the entry for the bad file is in the cache");
 
                 const cachedResult = engine.executeOnFiles([badFile, goodFile]);
 
@@ -2378,7 +2378,7 @@ describe("CLIEngine", () => {
 
                     assert.isTrue(typeof cache[goodFile] === "object", "the entry for the good file is in the cache");
 
-                    assert.isTrue(typeof cache[badFile] === "undefined", "the entry for the bad file is not in the cache");
+                    assert.isTrue(typeof cache[badFile] === "object", "the entry for the bad file is in the cache");
 
                     const cachedResult = engine.executeOnFiles([badFile, goodFile]);
 
diff --git a/tests/lib/util/lint-result-cache.js b/tests/lib/util/lint-result-cache.js
index c895918b3..3bb6382c7 100644
--- a/tests/lib/util/lint-result-cache.js
+++ b/tests/lib/util/lint-result-cache.js
@@ -28,7 +28,8 @@ describe("LintResultCache", () => {
         hashStub,
         sandbox,
         fakeConfigHelper,
-        fakeErrorResults;
+        fakeErrorResults,
+        fakeErrorResultsAutofix;
 
     before(() => {
         sandbox = sinon.sandbox.create();
@@ -39,14 +40,23 @@ describe("LintResultCache", () => {
 
         hashStub = sandbox.stub();
 
-        // Get lint results for test fixtures with and without errors
+        let shouldFix = false;
+
+        // Get lint results for test fixtures
         const cliEngine = new CLIEngine({
             cache: false,
-            globInputPaths: false
+            ignore: false,
+            globInputPaths: false,
+            fix: () => shouldFix
         });
 
+        // Get results without autofixing...
         fakeErrorResults = cliEngine.executeOnFiles([path.join(fixturePath, "test-with-errors.js")]).results[0];
 
+        // ...and with autofixing
+        shouldFix = true;
+        fakeErrorResultsAutofix = cliEngine.executeOnFiles([path.join(fixturePath, "test-with-errors.js")]).results[0];
+
         // Set up LintResultCache with fake fileEntryCache module
         LintResultCache = proxyquire("../../../lib/util/lint-result-cache", {
             "file-entry-cache": fileEntryCacheStubs,
@@ -105,7 +115,10 @@ describe("LintResultCache", () => {
         beforeEach(() => {
             cacheEntry = {
                 meta: {
-                    results: fakeErrorResults,
+
+                    // Serialized results will have null source
+                    results: Object.assign({}, fakeErrorResults, { source: null }),
+
                     hashOfConfig
                 }
             };
@@ -170,6 +183,7 @@ describe("LintResultCache", () => {
                 const result = lintResultsCache.getCachedLintResults(filePath);
 
                 assert.deepStrictEqual(result, fakeErrorResults);
+                assert.ok(result.source, "source property should be hydrated from filesystem");
             });
         });
     });
@@ -211,6 +225,15 @@ describe("LintResultCache", () => {
             lintResultsCache = new LintResultCache(cacheFileLocation, fakeConfigHelper);
         });
 
+        describe("When lint result has output property", () => {
+            it("does not modify file entry", () => {
+                lintResultsCache.setCachedLintResults(filePath, fakeErrorResultsAutofix);
+
+                assert.notProperty(cacheEntry.meta, "results");
+                assert.notProperty(cacheEntry.meta, "hashOfConfig");
+            });
+        });
+
         describe("When file is not found on filesystem", () => {
             beforeEach(() => {
                 cacheEntry.notFound = true;
@@ -225,53 +248,58 @@ describe("LintResultCache", () => {
         });
 
         describe("When file is found on filesystem", () => {
-            it("stores results and hash of config in file entry", () => {
+            beforeEach(() => {
                 lintResultsCache.setCachedLintResults(filePath, fakeErrorResults);
+            });
 
-                assert.deepStrictEqual(cacheEntry.meta.results, fakeErrorResults);
+            it("stores hash of config in file entry", () => {
                 assert.strictEqual(cacheEntry.meta.hashOfConfig, hashOfConfig);
             });
-        });
-    });
 
-    describe("reconcile", () => {
-        let reconcileStub,
-            lintResultsCache;
+            it("stores results (except source) in file entry", () => {
+                const expectedCachedResults = Object.assign(
+                    {},
+                    fakeErrorResults,
+                    { source: null }
+                );
 
-        before(() => {
-            reconcileStub = sandbox.stub();
-
-            fileEntryCacheStubs.create = () => ({
-                reconcile: reconcileStub
+                assert.deepStrictEqual(cacheEntry.meta.results, expectedCachedResults);
             });
         });
 
-        after(() => {
-            delete fileEntryCacheStubs.create;
-        });
+        describe("When file is found and empty", () => {
+            beforeEach(() => {
+                lintResultsCache.setCachedLintResults(
+                    filePath,
+                    Object.assign({}, fakeErrorResults, { source: "" })
+                );
+            });
 
-        beforeEach(() => {
-            lintResultsCache = new LintResultCache(cacheFileLocation, fakeConfigHelper);
-        });
+            it("stores hash of config in file entry", () => {
+                assert.strictEqual(cacheEntry.meta.hashOfConfig, hashOfConfig);
+            });
 
-        it("calls reconcile on the underlying cache", () => {
-            lintResultsCache.reconcile();
+            it("stores results (except source) in file entry", () => {
+                const expectedCachedResults = Object.assign(
+                    {},
+                    fakeErrorResults,
+                    { source: null }
+                );
 
-            assert.isTrue(reconcileStub.calledOnce);
+                assert.deepStrictEqual(cacheEntry.meta.results, expectedCachedResults);
+            });
         });
     });
 
-    describe("removeEntry", () => {
-        const filePath = path.join(fixturePath, "test-with-errors.js");
-
-        let removeEntryStub,
+    describe("reconcile", () => {
+        let reconcileStub,
             lintResultsCache;
 
         before(() => {
-            removeEntryStub = sandbox.stub();
+            reconcileStub = sandbox.stub();
 
             fileEntryCacheStubs.create = () => ({
-                removeEntry: removeEntryStub
+                reconcile: reconcileStub
             });
         });
 
@@ -283,11 +311,10 @@ describe("LintResultCache", () => {
             lintResultsCache = new LintResultCache(cacheFileLocation, fakeConfigHelper);
         });
 
-        it("calls removeEntry on the underlying cache", () => {
-            lintResultsCache.removeEntry(filePath);
+        it("calls reconcile on the underlying cache", () => {
+            lintResultsCache.reconcile();
 
-            assert.isTrue(removeEntryStub.calledOnce);
-            assert.isTrue(removeEntryStub.alwaysCalledWith(filePath));
+            assert.isTrue(reconcileStub.calledOnce);
         });
     });
 });
