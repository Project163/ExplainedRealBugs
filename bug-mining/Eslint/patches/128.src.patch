diff --git a/.gitattributes b/.gitattributes
index 797b96ff6..1df258761 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -1,4 +1,8 @@
 # Convert text file line endings to lf
 * text=auto
 
-*.js    text eol=lf
+*.js text eol=lf
+
+# The test fixtures are text files.
+/tests/fixtures/**/* text eol=lf
+/tests/fixtures/ignored-paths/crlf/.eslintignore text eol=crlf
diff --git a/lib/ignored-paths.js b/lib/ignored-paths.js
index 5e99c781c..634bfbc0c 100644
--- a/lib/ignored-paths.js
+++ b/lib/ignored-paths.js
@@ -79,6 +79,19 @@ function mergeDefaultOptions(options) {
     return Object.assign({}, DEFAULT_OPTIONS, options);
 }
 
+/* eslint-disable valid-jsdoc */
+/**
+ * Normalize the path separators in a given string.
+ * On Windows environment, this replaces `\` by `/`.
+ * Otherwrise, this does nothing.
+ * @param {string} str The path string to normalize.
+ * @returns {string} The normalized path.
+ */
+const normalizePathSeps = path.sep === "/"
+    ? (str => str)
+    : ((seps, str) => str.replace(seps, "/")).bind(null, new RegExp(`\\${path.sep}`, "g"));
+/* eslint-enable valid-jsdoc */
+
 /**
  * Converts a glob pattern to a new glob pattern relative to a different directory
  * @param {string} globPattern The glob pattern, relative the the old base directory
@@ -94,7 +107,7 @@ function relativize(globPattern, relativePathToOldBaseDir) {
     const globWithoutPrefix = globPattern.replace(/^!/, "");
 
     if (globWithoutPrefix.startsWith("/")) {
-        return `${prefix}/${relativePathToOldBaseDir}${globWithoutPrefix}`;
+        return `${prefix}/${normalizePathSeps(relativePathToOldBaseDir)}${globWithoutPrefix}`;
     }
 
     return globPattern;
@@ -123,6 +136,7 @@ class IgnoredPaths {
             ? path.dirname(path.resolve(options.cwd, options.ignorePath))
             : options.cwd;
         this.options = options;
+        this._baseDir = null;
 
         this.ig = {
             custom: ignore(),
@@ -229,23 +243,54 @@ class IgnoredPaths {
      */
 
     addPatternRelativeToCwd(ig, pattern) {
-        ig.addPattern(
-            this.getBaseDir() === this.options.cwd
-                ? pattern
-                : relativize(pattern, path.relative(this.ignoreFileDir, this.options.cwd))
-        );
+        const baseDir = this.getBaseDir();
+        const cookedPattern = baseDir === this.options.cwd
+            ? pattern
+            : relativize(pattern, path.relative(baseDir, this.options.cwd));
+
+        ig.addPattern(cookedPattern);
+        debug("addPatternRelativeToCwd:\n  original = %j\n  cooked   = %j", pattern, cookedPattern);
     }
 
     addPatternRelativeToIgnoreFile(ig, pattern) {
-        ig.addPattern(
-            this.getBaseDir() === this.ignoreFileDir
-                ? pattern
-                : relativize(pattern, path.relative(this.options.cwd, this.ignoreFileDir))
-        );
+        const baseDir = this.getBaseDir();
+        const cookedPattern = baseDir === this.ignoreFileDir
+            ? pattern
+            : relativize(pattern, path.relative(baseDir, this.ignoreFileDir));
+
+        ig.addPattern(cookedPattern);
+        debug("addPatternRelativeToIgnoreFile:\n  original = %j\n  cooked   = %j", pattern, cookedPattern);
     }
 
+    // Detect the common ancestor
     getBaseDir() {
-        return this.ignoreFileDir.startsWith(this.options.cwd) ? this.options.cwd : this.ignoreFileDir;
+        if (!this._baseDir) {
+            const a = path.resolve(this.options.cwd);
+            const b = path.resolve(this.ignoreFileDir);
+            let lastSepPos = 0;
+
+            // Set the shorter one (it's the common ancestor if one includes the other).
+            this._baseDir = a.length < b.length ? a : b;
+
+            // Set the common ancestor.
+            for (let i = 0; i < a.length && i < b.length; ++i) {
+                if (a[i] !== b[i]) {
+                    this._baseDir = a.slice(0, lastSepPos);
+                    break;
+                }
+                if (a[i] === path.sep) {
+                    lastSepPos = i;
+                }
+            }
+
+            // If it's only Windows drive letter, it needs \
+            if (/^[A-Z]:$/.test(this._baseDir)) {
+                this._baseDir += "\\";
+            }
+
+            debug("baseDir = %j", this._baseDir);
+        }
+        return this._baseDir;
     }
 
     /**
@@ -255,7 +300,7 @@ class IgnoredPaths {
      */
     readIgnoreFile(filePath) {
         if (typeof this.cache[filePath] === "undefined") {
-            this.cache[filePath] = fs.readFileSync(filePath, "utf8").split("\n").filter(Boolean);
+            this.cache[filePath] = fs.readFileSync(filePath, "utf8").split(/\r?\n/g).filter(Boolean);
         }
         return this.cache[filePath];
     }
@@ -291,6 +336,9 @@ class IgnoredPaths {
         } else {
             result = (this.ig[category].filter([relativePath]).length === 0);
         }
+        debug("contains:");
+        debug("  target = %j", filepath);
+        debug("  result = %j", result);
 
         return result;
 
diff --git a/lib/util/path-utils.js b/lib/util/path-utils.js
index 54460ffd1..07cf4e790 100644
--- a/lib/util/path-utils.js
+++ b/lib/util/path-utils.js
@@ -54,7 +54,7 @@ function getRelativePath(filepath, baseDir) {
 
     if (baseDir) {
         if (!path.isAbsolute(baseDir)) {
-            throw new Error("baseDir should be an absolute path");
+            throw new Error(`baseDir should be an absolute path: ${baseDir}`);
         }
         return path.relative(baseDir, absolutePath);
     }
diff --git a/tests/fixtures/ignored-paths/crlf/.eslintignore b/tests/fixtures/ignored-paths/crlf/.eslintignore
new file mode 100644
index 000000000..a523bd68b
--- /dev/null
+++ b/tests/fixtures/ignored-paths/crlf/.eslintignore
@@ -0,0 +1,2 @@
+hide1/
+hide2/
diff --git a/tests/lib/ignored-paths.js b/tests/lib/ignored-paths.js
index 7eae184b3..b03314e61 100644
--- a/tests/lib/ignored-paths.js
+++ b/tests/lib/ignored-paths.js
@@ -244,6 +244,20 @@ describe("IgnoredPaths", () => {
             assert.strictEqual(ignoredPaths.ignoreFileDir, path.dirname(ignoreFilePath));
         });
 
+        it("should set the common ancestor directory of cwd and ignorePath to baseDir (in the case that 'ignoreFilePath' and 'cwd' are siblings)", () => {
+            const baseDir = path.dirname(ignoreFilePath);
+            const ignoredPaths = new IgnoredPaths({ ignore: true, ignorePath: ignoreFilePath, cwd: path.resolve(baseDir, "testcwd") });
+
+            assert.strictEqual(ignoredPaths.getBaseDir(), baseDir);
+        });
+
+        it("should set the common ancestor directory of cwd and ignorePath to baseDir", () => {
+            const baseDir = path.resolve(ignoreFilePath, "../../..");
+            const ignoredPaths = new IgnoredPaths({ ignore: true, ignorePath: ignoreFilePath, cwd: path.resolve(baseDir, "fix/testcwd") });
+
+            assert.strictEqual(ignoredPaths.getBaseDir(), baseDir);
+        });
+
     });
 
     describe("initialization with ignorePath file not named .eslintignore", () => {
@@ -435,6 +449,22 @@ describe("IgnoredPaths", () => {
 
             assert.isTrue(ignoredPaths.contains("node_modules/blah.js"));
         });
+
+        it("should handle .eslintignore which contains CRLF correctly.", () => {
+            const ignoreFileContent = fs.readFileSync(getFixturePath("crlf/.eslintignore"), "utf8");
+
+            assert.isTrue(ignoreFileContent.includes("\r"), "crlf/.eslintignore should contains CR.");
+
+            const ignoredPaths = new IgnoredPaths({
+                ignore: true,
+                ignorePath: getFixturePath("crlf/.eslintignore"),
+                cwd: getFixturePath()
+            });
+
+            assert.isTrue(ignoredPaths.contains(getFixturePath("crlf/hide1/a.js")));
+            assert.isTrue(ignoredPaths.contains(getFixturePath("crlf/hide2/a.js")));
+            assert.isFalse(ignoredPaths.contains(getFixturePath("crlf/hide3/a.js")));
+        });
     });
 
     describe("initialization with ignorePath containing commented lines", () => {
