diff --git a/docs/src/extend/languages.md b/docs/src/extend/languages.md
index abc35dc49..4588d8380 100644
--- a/docs/src/extend/languages.md
+++ b/docs/src/extend/languages.md
@@ -88,7 +88,7 @@ The following optional members allow you to customize how ESLint interacts with
 - `visitorKeys` - visitor keys that are specific to the AST or CST. This is used to optimize traversal of the AST or CST inside of ESLint. While not required, it is strongly recommended, especially for AST or CST formats that deviate significantly from ESTree format.
 - `defaultLanguageOptions` - default `languageOptions` when the language is used. User-specified `languageOptions` are merged with this object when calculating the config for the file being linted.
 - `matchesSelectorClass(className, node, ancestry)` - allows you to specify selector classes, such as `:expression`, that match more than one node. This method is called whenever an [esquery](https://github.com/estools/esquery) selector contains a `:` followed by an identifier.
-- `normalizeLanguageOptions(languageOptions)` - takes a validated language options object and normalizes its values. This is helpful for backwards compatibility when language options properties change.
+- `normalizeLanguageOptions(languageOptions)` - takes a validated language options object and normalizes its values. This is helpful for backwards compatibility when language options properties change and also to add custom serialization with a `toJSON()` method.
 
 See [`JSONLanguage`](https://github.com/eslint/json/blob/main/src/languages/json-language.js) as an example of a basic `Language` class.
 
diff --git a/lib/config/config.js b/lib/config/config.js
index bb638bb32..22fd5cc4e 100644
--- a/lib/config/config.js
+++ b/lib/config/config.js
@@ -265,6 +265,27 @@ function getObjectId(object) {
 	return name;
 }
 
+/**
+ * Asserts that a value is not a function.
+ * @param {any} value The value to check.
+ * @param {string} key The key of the value in the object.
+ * @param {string} objectKey The key of the object being checked.
+ * @returns {void}
+ * @throws {TypeError} If the value is a function.
+ */
+function assertNotFunction(value, key, objectKey) {
+	if (typeof value === "function") {
+		const error = new TypeError(
+			`Cannot serialize key "${key}" in "${objectKey}": Function values are not supported.`,
+		);
+
+		error.messageTemplate = "config-serialize-function";
+		error.messageData = { key, objectKey };
+
+		throw error;
+	}
+}
+
 /**
  * Converts a languageOptions object to a JSON representation.
  * @param {Record<string, any>} languageOptions The options to create a JSON
@@ -274,6 +295,14 @@ function getObjectId(object) {
  * @throws {TypeError} If a function is found in the languageOptions.
  */
 function languageOptionsToJSON(languageOptions, objectKey = "languageOptions") {
+	if (typeof languageOptions.toJSON === "function") {
+		const result = languageOptions.toJSON();
+
+		assertNotFunction(result, "toJSON", objectKey);
+
+		return result;
+	}
+
 	const result = {};
 
 	for (const [key, value] of Object.entries(languageOptions)) {
@@ -281,7 +310,10 @@ function languageOptionsToJSON(languageOptions, objectKey = "languageOptions") {
 			if (typeof value === "object") {
 				const name = getObjectId(value);
 
-				if (name && hasMethod(value)) {
+				if (typeof value.toJSON === "function") {
+					result[key] = value.toJSON();
+					assertNotFunction(result[key], key, objectKey);
+				} else if (name && hasMethod(value)) {
 					result[key] = name;
 				} else {
 					result[key] = languageOptionsToJSON(value, key);
@@ -289,16 +321,7 @@ function languageOptionsToJSON(languageOptions, objectKey = "languageOptions") {
 				continue;
 			}
 
-			if (typeof value === "function") {
-				const error = new TypeError(
-					`Cannot serialize key "${key}" in ${objectKey}: Function values are not supported.`,
-				);
-
-				error.messageTemplate = "config-serialize-function";
-				error.messageData = { key, objectKey };
-
-				throw error;
-			}
+			assertNotFunction(value, key, objectKey);
 		}
 
 		result[key] = value;
diff --git a/tests/lib/config/config.js b/tests/lib/config/config.js
index c7ad77e85..a028b3049 100644
--- a/tests/lib/config/config.js
+++ b/tests/lib/config/config.js
@@ -15,6 +15,103 @@ const { Config } = require("../../../lib/config/config");
 const assert = require("chai").assert;
 const sinon = require("sinon");
 
+//-----------------------------------------------------------------------------
+// Helper Functions
+//-----------------------------------------------------------------------------
+
+/**
+ * Creates a mock language object with default properties
+ * @param {Object} overrides Properties to override
+ * @returns {Object} Mock language object
+ */
+function createMockLanguage(overrides = {}) {
+	return {
+		validateLanguageOptions() {},
+		normalizeLanguageOptions: options => options,
+		meta: {
+			name: "testLang",
+			version: "1.0.0",
+		},
+		...overrides,
+	};
+}
+
+/**
+ * Creates a mock plugin object with default properties
+ * @param {Object} overrides Properties to override
+ * @returns {Object} Mock plugin object
+ */
+function createMockPlugin(overrides = {}) {
+	return {
+		meta: {
+			name: "testPlugin",
+			version: "1.0.0",
+		},
+		...overrides,
+	};
+}
+
+/**
+ * Creates a mock processor object with default properties
+ * @param {Object} overrides Properties to override
+ * @returns {Object} Mock processor object
+ */
+function createMockProcessor(overrides = {}) {
+	return {
+		meta: {
+			name: "testProcessor",
+			version: "1.0.0",
+		},
+		preprocess() {},
+		postprocess() {},
+		...overrides,
+	};
+}
+
+/**
+ * Creates a basic config structure for testing
+ * @param {Object} configOptions Config options to merge
+ * @param {Object} mockLanguage Mock language to use
+ * @returns {Object} Config options object
+ */
+function createBasicConfigOptions(configOptions = {}, mockLanguage = null) {
+	const language = mockLanguage || createMockLanguage();
+
+	return {
+		language: "test/lang",
+		plugins: {
+			test: {
+				languages: {
+					lang: language,
+				},
+			},
+		},
+		...configOptions,
+	};
+}
+
+/**
+ * Creates a mock rule object with default schema
+ * @param {Object} overrides Properties to override
+ * @returns {Object} Mock rule object
+ */
+function createMockRule(overrides = {}) {
+	return {
+		meta: {
+			schema: [
+				{
+					type: "object",
+					properties: {
+						option1: { type: "boolean" },
+					},
+				},
+			],
+			...overrides.meta,
+		},
+		...overrides,
+	};
+}
+
 //-----------------------------------------------------------------------------
 // Tests
 //-----------------------------------------------------------------------------
@@ -167,10 +264,10 @@ describe("Config", () => {
 		let mockLanguage;
 
 		beforeEach(() => {
-			mockLanguage = {
+			mockLanguage = createMockLanguage({
 				validateLanguageOptions: sinon.stub(),
 				normalizeLanguageOptions: sinon.spy(options => options),
-			};
+			});
 		});
 
 		it("should throw error when language is not provided", () => {
@@ -193,35 +290,27 @@ describe("Config", () => {
 		});
 
 		it("should correctly set up language from plugins", () => {
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
-						},
-					},
-				},
-			});
+			const config = new Config(
+				createBasicConfigOptions({}, mockLanguage),
+			);
 
 			assert.strictEqual(config.language, mockLanguage);
 			assert.isTrue(mockLanguage.validateLanguageOptions.called);
 		});
 
 		it("should correctly merge language options with default language options", () => {
-			mockLanguage.defaultLanguageOptions = { parser: "default" };
+			const languageWithDefaults = createMockLanguage({
+				defaultLanguageOptions: { parser: "default" },
+			});
 
-			const config = new Config({
-				language: "test/lang",
-				languageOptions: { ecmaVersion: 2022 },
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
-						},
+			const config = new Config(
+				createBasicConfigOptions(
+					{
+						languageOptions: { ecmaVersion: 2022 },
 					},
-				},
-			});
+					languageWithDefaults,
+				),
+			);
 
 			assert.deepStrictEqual(config.languageOptions, {
 				parser: "default",
@@ -231,135 +320,116 @@ describe("Config", () => {
 
 		it("should throw error when processor is not found in plugins", () => {
 			assert.throws(() => {
-				new Config({
-					language: "test/lang",
+				new Config(
+					createBasicConfigOptions(
+						{
+							processor: "test/proc",
+						},
+						mockLanguage,
+					),
+				);
+			}, /Could not find "proc" in plugin "test"/u);
+		});
+
+		it("should correctly set up processor from plugins", () => {
+			const mockProcessor = createMockProcessor();
+			const config = new Config(
+				createBasicConfigOptions({
 					plugins: {
 						test: {
 							languages: {
 								lang: mockLanguage,
 							},
+							processors: {
+								proc: mockProcessor,
+							},
 						},
 					},
 					processor: "test/proc",
-				});
-			}, /Could not find "proc" in plugin "test"/u);
-		});
-
-		it("should correctly set up processor from plugins", () => {
-			const mockProcessor = {};
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
-						},
-						processors: {
-							proc: mockProcessor,
-						},
-					},
-				},
-				processor: "test/proc",
-			});
+				}),
+			);
 
 			assert.strictEqual(config.processor, mockProcessor);
 		});
 
 		it("should accept processor object directly", () => {
-			const mockProcessor = {
+			const mockProcessor = createMockProcessor({
 				meta: { name: "test-processor" },
-				preprocess() {},
-				postprocess() {},
-			};
+			});
 
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
-						},
+			const config = new Config(
+				createBasicConfigOptions(
+					{
+						processor: mockProcessor,
 					},
-				},
-				processor: mockProcessor,
-			});
+					mockLanguage,
+				),
+			);
 
 			assert.strictEqual(config.processor, mockProcessor);
 		});
 
 		it("should throw error when processor is not string or object", () => {
 			assert.throws(() => {
-				new Config({
-					language: "test/lang",
-					plugins: {
-						test: {
-							languages: {
-								lang: mockLanguage,
-							},
+				new Config(
+					createBasicConfigOptions(
+						{
+							processor: 123,
 						},
-					},
-					processor: 123,
-				});
+						mockLanguage,
+					),
+				);
 			}, "Expected an object or a string");
 		});
 
 		it("should normalize rules configuration", () => {
 			const mockRule = { meta: {} };
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
+			const config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: mockLanguage,
+							},
+							rules: {},
 						},
-						rules: {},
-					},
-					"@": {
-						rules: {
-							"test-rule": mockRule,
+						"@": {
+							rules: {
+								"test-rule": mockRule,
+							},
 						},
 					},
-				},
-				rules: {
-					"test-rule": "error",
-				},
-			});
+					rules: {
+						"test-rule": "error",
+					},
+				}),
+			);
 
 			assert.deepStrictEqual(config.rules["test-rule"], [2]);
 		});
 
 		it("should normalize rules with options", () => {
-			const mockRule = {
-				meta: {
-					schema: [
-						{
-							type: "object",
-							properties: {
-								option1: { type: "boolean" },
+			const mockRule = createMockRule();
+			const config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: mockLanguage,
 							},
+							rules: {},
 						},
-					],
-				},
-			};
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
+						"@": {
+							rules: {
+								"test-rule": mockRule,
+							},
 						},
-						rules: {},
 					},
-					"@": {
-						rules: {
-							"test-rule": mockRule,
-						},
+					rules: {
+						"test-rule": ["warn", { option1: true }],
 					},
-				},
-				rules: {
-					"test-rule": ["warn", { option1: true }],
-				},
-			});
+				}),
+			);
 
 			assert.deepStrictEqual(config.rules["test-rule"], [
 				1,
@@ -368,7 +438,7 @@ describe("Config", () => {
 		});
 
 		it("should apply rule's defaultOptions when present", () => {
-			const mockRule = {
+			const mockRule = createMockRule({
 				meta: {
 					schema: [
 						{
@@ -381,27 +451,28 @@ describe("Config", () => {
 					],
 					defaultOptions: [{ defaultOption: true }],
 				},
-			};
+			});
 
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: mockLanguage,
+			const config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: mockLanguage,
+							},
+							rules: {},
 						},
-						rules: {},
-					},
-					"@": {
-						rules: {
-							"test-rule": mockRule,
+						"@": {
+							rules: {
+								"test-rule": mockRule,
+							},
 						},
 					},
-				},
-				rules: {
-					"test-rule": ["error", { option1: true }],
-				},
-			});
+					rules: {
+						"test-rule": ["error", { option1: true }],
+					},
+				}),
+			);
 
 			assert.deepStrictEqual(config.rules["test-rule"], [
 				2,
@@ -413,19 +484,20 @@ describe("Config", () => {
 	describe("getRuleDefinition", () => {
 		it("should retrieve rule definition from plugins", () => {
 			const mockRule = { meta: {} };
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: { validateLanguageOptions() {} },
-						},
-						rules: {
-							"test-rule": mockRule,
+			const config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: createMockLanguage(),
+							},
+							rules: {
+								"test-rule": mockRule,
+							},
 						},
 					},
-				},
-			});
+				}),
+			);
 
 			const rule = config.getRuleDefinition("test/test-rule");
 			assert.strictEqual(rule, mockRule);
@@ -433,21 +505,22 @@ describe("Config", () => {
 
 		it("should retrieve core rule definition", () => {
 			const mockRule = { meta: {} };
-			const config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: { validateLanguageOptions() {} },
+			const config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: createMockLanguage(),
+							},
 						},
-					},
-					"@": {
-						rules: {
-							"core-rule": mockRule,
+						"@": {
+							rules: {
+								"core-rule": mockRule,
+							},
 						},
 					},
-				},
-			});
+				}),
+			);
 
 			const rule = config.getRuleDefinition("core-rule");
 			assert.strictEqual(rule, mockRule);
@@ -456,29 +529,9 @@ describe("Config", () => {
 
 	describe("toJSON", () => {
 		it("should convert config to JSON representation", () => {
-			const mockLanguage = {
-				validateLanguageOptions() {},
-				meta: {
-					name: "testLang",
-					version: "1.0.0",
-				},
-			};
-
-			const mockProcessor = {
-				meta: {
-					name: "testProcessor",
-					version: "1.0.0",
-				},
-				preprocess() {},
-				postprocess() {},
-			};
-
-			const mockPlugin = {
-				meta: {
-					name: "testPlugin",
-					version: "1.0.0",
-				},
-			};
+			const mockLanguage = createMockLanguage();
+			const mockProcessor = createMockProcessor();
+			const mockPlugin = createMockPlugin();
 
 			const config = new Config({
 				language: "test/lang",
@@ -504,29 +557,278 @@ describe("Config", () => {
 			});
 
 			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				language: "test/lang",
+				processor: "testProcessor@1.0.0",
+				languageOptions: {
+					ecmaVersion: 2022,
+					sourceType: "module",
+					parser: "testParser",
+				},
+			});
+		});
 
-			assert.deepStrictEqual(json.plugins, ["test:testPlugin@1.0.0"]);
-			assert.strictEqual(json.language, "test/lang");
-			assert.strictEqual(json.processor, "testProcessor@1.0.0");
-			assert.deepStrictEqual(json.languageOptions, {
-				ecmaVersion: 2022,
-				sourceType: "module",
-				parser: "testParser",
+		it("should serialize when a language option has a toJSON() method and a function", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.syntax.toJSON = () => "syntax";
+					return options;
+				},
+			});
+
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						atrule: {
+							name() {},
+						},
+					},
+				},
+			});
+			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				processor: void 0,
+				language: "test/lang",
+				languageOptions: {
+					syntax: "syntax",
+				},
+			});
+		});
+
+		it("should pass through the value when toJSON is not a function", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.syntax.toJSON = "not a function";
+					return options;
+				},
+			});
+
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						toJSON: "not a function",
+					},
+				},
+			});
+			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				processor: void 0,
+				language: "test/lang",
+				languageOptions: {
+					syntax: {
+						toJSON: "not a function",
+					},
+				},
 			});
 		});
 
+		it("should only call toJSON on a parent and not on a child object", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.syntax.block.toJSON = () => "block";
+					options.syntax.block.selector.toJSON = () => "selector";
+					return options;
+				},
+			});
+
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						block: {
+							selector: {
+								value: "test",
+							},
+						},
+					},
+				},
+			});
+			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				processor: void 0,
+				language: "test/lang",
+				languageOptions: {
+					syntax: {
+						block: "block",
+					},
+				},
+			});
+		});
+
+		it("should call languageOptions.toJSON() when present instead of serializing the object", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.toJSON = () => "languageOptions";
+					return options;
+				},
+			});
+
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						someValue: "string",
+					},
+				},
+			});
+
+			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				processor: void 0,
+				language: "test/lang",
+				languageOptions: "languageOptions",
+			});
+		});
+
+		it("should call toJSON() on language option even when object has meta information", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.someObject.toJSON = () => "someObject";
+					return options;
+				},
+			});
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					someObject: {
+						meta: {
+							name: "testMeta",
+						},
+					},
+				},
+			});
+			const json = config.toJSON();
+			assert.deepStrictEqual(json, {
+				plugins: ["test:testPlugin@1.0.0"],
+				processor: void 0,
+				language: "test/lang",
+				languageOptions: {
+					someObject: "someObject",
+				},
+			});
+		});
+
+		it("should throw an error when toJSON() returns a function", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.syntax.toJSON = () => () => "function";
+					return options;
+				},
+			});
+
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						someValue: "string",
+					},
+				},
+			});
+
+			assert.throws(() => {
+				config.toJSON();
+			}, 'Cannot serialize key "syntax" in "languageOptions": Function values are not supported.');
+		});
+
+		it("should throw an error when languageOptions.toJSON() returns a function", () => {
+			const mockLanguage = createMockLanguage({
+				normalizeLanguageOptions(options) {
+					options.toJSON = () => () => "function";
+					return options;
+				},
+			});
+			const mockPlugin = createMockPlugin({
+				languages: {
+					lang: mockLanguage,
+				},
+			});
+			const config = new Config({
+				language: "test/lang",
+				plugins: {
+					test: mockPlugin,
+				},
+				languageOptions: {
+					syntax: {
+						someValue: "string",
+					},
+				},
+			});
+			assert.throws(() => {
+				config.toJSON();
+			}, 'Cannot serialize key "toJSON" in "languageOptions": Function values are not supported.');
+		});
+
 		it("should throw when processor doesn't have meta information", () => {
-			const mockLanguage = {
-				validateLanguageOptions() {},
+			const mockLanguage = createMockLanguage({
 				meta: {
 					name: "testLang",
 				},
-			};
+			});
 
-			const mockProcessor = {
-				preprocess() {},
-				postprocess() {},
-			}; // Missing meta property
+			const mockProcessor = createMockProcessor({
+				meta: void 0, // Missing meta property
+			});
+			delete mockProcessor.meta; // Completely remove meta
 
 			const config = new Config({
 				language: "test/lang",
@@ -549,7 +851,7 @@ describe("Config", () => {
 	describe("validateRulesConfig", () => {
 		let config;
 
-		const mockRule = {
+		const mockRule = createMockRule({
 			meta: {
 				schema: {
 					type: "array",
@@ -564,38 +866,39 @@ describe("Config", () => {
 					],
 				},
 			},
-		};
+		});
 
 		beforeEach(() => {
-			config = new Config({
-				language: "test/lang",
-				plugins: {
-					test: {
-						languages: {
-							lang: { validateLanguageOptions() {} },
-						},
-					},
-					"@": {
-						rules: {
-							"error-rule": {},
-							"warn-rule": {},
-							"off-rule": {},
-							"test-rule": mockRule,
-							"test-broken-rule": {
-								meta: { schema: 123 }, // Invalid schema
+			config = new Config(
+				createBasicConfigOptions({
+					plugins: {
+						test: {
+							languages: {
+								lang: createMockLanguage(),
 							},
-							"test-no-schema": {
-								meta: { schema: false }, // No schema
+						},
+						"@": {
+							rules: {
+								"error-rule": {},
+								"warn-rule": {},
+								"off-rule": {},
+								"test-rule": mockRule,
+								"test-broken-rule": {
+									meta: { schema: 123 }, // Invalid schema
+								},
+								"test-no-schema": {
+									meta: { schema: false }, // No schema
+								},
 							},
 						},
 					},
-				},
-				rules: {
-					"error-rule": "error",
-					"warn-rule": "warn",
-					"off-rule": "off",
-				},
-			});
+					rules: {
+						"error-rule": "error",
+						"warn-rule": "warn",
+						"off-rule": "off",
+					},
+				}),
+			);
 		});
 
 		it("should throw when config is not provided", () => {
