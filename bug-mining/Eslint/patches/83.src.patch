diff --git a/lib/rules/prefer-template.js b/lib/rules/prefer-template.js
index 2b893fd37..14c419942 100644
--- a/lib/rules/prefer-template.js
+++ b/lib/rules/prefer-template.js
@@ -38,6 +38,45 @@ function getTopConcatBinaryExpression(node) {
     return currentNode;
 }
 
+/**
+ * Determines whether a given node is a octal escape sequence
+ * @param {ASTNode} node A node to check
+ * @returns {boolean} `true` if the node is an octal escape sequence
+ */
+function isOctalEscapeSequence(node) {
+
+    // No need to check TemplateLiterals â€“ would throw error with octal escape
+    const isStringLiteral = node.type === "Literal" && typeof node.value === "string";
+
+    if (!isStringLiteral) {
+        return false;
+    }
+
+    const match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-7]{1,3})/);
+
+    if (match) {
+
+        // \0 is actually not considered an octal
+        if (match[2] !== "0" || typeof match[3] !== "undefined") {
+            return true;
+        }
+    }
+    return false;
+}
+
+/**
+ * Checks whether or not a node contains a octal escape sequence
+ * @param {ASTNode} node A node to check
+ * @returns {boolean} `true` if the node contains an octal escape sequence
+ */
+function hasOctalEscapeSequence(node) {
+    if (isConcatenation(node)) {
+        return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);
+    }
+
+    return isOctalEscapeSequence(node);
+}
+
 /**
  * Checks whether or not a given binary expression has string literals.
  * @param {ASTNode} node - A node to check.
@@ -193,6 +232,22 @@ module.exports = {
             return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
         }
 
+        /**
+         * Returns a fixer object that converts a non-string binary expression to a template literal
+         * @param {SourceCodeFixer} fixer The fixer object
+         * @param {ASTNode} node A node that should be converted to a template literal
+         * @returns {Object} A fix for this binary expression
+         */
+        function fixNonStringBinaryExpression(fixer, node) {
+            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
+
+            if (hasOctalEscapeSequence(topBinaryExpr)) {
+                return null;
+            }
+
+            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
+        }
+
         /**
          * Reports if a given node is string concatenation with non string literals.
          *
@@ -216,9 +271,7 @@ module.exports = {
                 context.report({
                     node: topBinaryExpr,
                     message: "Unexpected string concatenation.",
-                    fix(fixer) {
-                        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
-                    }
+                    fix: fixer => fixNonStringBinaryExpression(fixer, node)
                 });
             }
         }
diff --git a/tests/lib/rules/prefer-template.js b/tests/lib/rules/prefer-template.js
index d7fa457ab..bab21ebb5 100644
--- a/tests/lib/rules/prefer-template.js
+++ b/tests/lib/rules/prefer-template.js
@@ -26,6 +26,7 @@ const ruleTester = new RuleTester({ parserOptions: { ecmaVersion: 6 } });
 ruleTester.run("prefer-template", rule, {
     valid: [
         "'use strict';",
+        "var foo = 'foo' + '\\0';",
         "var foo = 'bar';",
         "var foo = 'bar' + 'baz';",
         "var foo = foo + +'100';",
@@ -187,6 +188,26 @@ ruleTester.run("prefer-template", rule, {
             code: "foo + 'handles unicode escapes correctly: \\x27'", // "\x27" === "'"
             output: "`${foo  }handles unicode escapes correctly: \\x27`",
             errors
+        },
+        {
+            code: "foo + 'does not autofix octal escape sequence' + '\\033'",
+            output: null,
+            errors
+        },
+        {
+            code: "foo + '\\n other text \\033'",
+            output: null,
+            errors
+        },
+        {
+            code: "foo + '\\\\033'",
+            output: "`${foo  }\\\\033`",
+            errors
+        },
+        {
+            code: "foo + '\\0'",
+            output: "`${foo  }\\0`",
+            errors
         }
     ]
 });
