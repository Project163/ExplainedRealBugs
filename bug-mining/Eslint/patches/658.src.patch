diff --git a/docs/src/use/configure/configuration-files.md b/docs/src/use/configure/configuration-files.md
index 0b824d863..69727498a 100644
--- a/docs/src/use/configure/configuration-files.md
+++ b/docs/src/use/configure/configuration-files.md
@@ -499,6 +499,22 @@ npx eslint --config some-other-file.js **/*.js
 
 In this case, ESLint does not search for `eslint.config.js` and instead uses `some-other-file.js`.
 
+### Experimental Configuration File Resolution
+
+::: warning
+This feature is experimental and its details may change before being finalized. This behavior will be the new lookup behavior starting in v10.0.0, but you can try it today using a feature flag.
+:::
+
+You can use the `unstable_config_lookup_from_file` flag to change the way ESLint searches for configuration files. Instead of searching from the current working directory, ESLint will search for a configuration file by first starting in the directory of the file being linted and then searching up its ancestor directories until it finds a `eslint.config.js` file (or any other extension of configuration file). This behavior is better for monorepos, where each subdirectory may have its own configuration file.
+
+To use this feature on the command line, use the `--flag` flag:
+
+```shell
+npx eslint --flag unstable_config_lookup_from_file .
+```
+
+For more information about using feature flags, see [Feature Flags](../../flags/).
+
 ## TypeScript Configuration Files
 
 ::: warning
@@ -511,6 +527,8 @@ You need to enable this feature through the `unstable_ts_config` feature flag:
 npx eslint --flag unstable_ts_config
 ```
 
+For more information about using feature flags, see [Feature Flags](../../flags/).
+
 For Deno and Bun, TypeScript configuration files are natively supported; for Node.js, you must install the optional dev dependency [`jiti`](https://github.com/unjs/jiti) in your project (this dependency is not automatically installed by ESLint):
 
 ```bash
@@ -560,7 +578,7 @@ ESLint does not perform type checking on your configuration file and does not ap
 :::
 
 ::: warning
-As of now, [`jiti`](https://github.com/unjs/jiti) does not support [Top-level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await)
+As of now, [`jiti`](https://github.com/unjs/jiti) does not support [top-level `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await)
 :::
 
 ### Configuration File Precedence
diff --git a/lib/cli.js b/lib/cli.js
index 8ad99b33b..5acb6349e 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -348,14 +348,9 @@ const cli = {
         // find the config file
         const {
             configFilePath,
-            basePath,
-            error
+            basePath
         } = await locateConfigFileToUse({ cwd: process.cwd(), configFile }, hasUnstableTSConfigFlag);
 
-        if (error) {
-            throw error;
-        }
-
         return ["--config", configFilePath, "--basePath", basePath];
     },
 
diff --git a/lib/config/config-loader.js b/lib/config/config-loader.js
new file mode 100644
index 000000000..4aab296ef
--- /dev/null
+++ b/lib/config/config-loader.js
@@ -0,0 +1,694 @@
+/**
+ * @fileoverview Utility to load config files
+ * @author Nicholas C. Zakas
+ */
+
+"use strict";
+
+//------------------------------------------------------------------------------
+// Requirements
+//------------------------------------------------------------------------------
+
+const path = require("node:path");
+const fs = require("node:fs/promises");
+const findUp = require("find-up");
+const { pathToFileURL } = require("node:url");
+const debug = require("debug")("eslint:config-loader");
+const { FlatConfigArray } = require("../config/flat-config-array");
+
+//-----------------------------------------------------------------------------
+// Types
+//-----------------------------------------------------------------------------
+
+/**
+ * @typedef {import("../shared/types").FlatConfigObject} FlatConfigObject
+ * @typedef {import("../shared/types").FlatConfigArray} FlatConfigArray
+ * @typedef {Object} ConfigLoaderOptions
+ * @property {string|false|undefined} configFile The path to the config file to use.
+ * @property {string} cwd The current working directory.
+ * @property {boolean} ignoreEnabled Indicates if ignore patterns should be honored.
+ * @property {FlatConfigArray} [baseConfig] The base config to use.
+ * @property {Array<FlatConfigObject>} [defaultConfigs] The default configs to use.
+ * @property {Array<string>} [ignorePatterns] The ignore patterns to use.
+ * @property {FlatConfigObject|Array<FlatConfigObject>} overrideConfig The override config to use.
+ * @property {boolean} allowTS Indicates if TypeScript configuration files are allowed.
+ */
+
+//------------------------------------------------------------------------------
+// Helpers
+//------------------------------------------------------------------------------
+
+const FLAT_CONFIG_FILENAMES = [
+    "eslint.config.js",
+    "eslint.config.mjs",
+    "eslint.config.cjs"
+];
+
+const TS_FLAT_CONFIG_FILENAMES = [
+    "eslint.config.ts",
+    "eslint.config.mts",
+    "eslint.config.cts"
+];
+
+const importedConfigFileModificationTime = new Map();
+
+/**
+ * Asserts that the given file path is valid.
+ * @param {string} filePath The file path to check.
+ * @returns {void}
+ * @throws {Error} If `filePath` is not a non-empty string.
+ */
+function assertValidFilePath(filePath) {
+    if (!filePath || typeof filePath !== "string") {
+        throw new Error("'filePath' must be a non-empty string");
+    }
+}
+
+/**
+ * Asserts that a configuration exists. A configuration exists if any
+ * of the following are true:
+ * - `configFilePath` is defined.
+ * - `useConfigFile` is `false`.
+ * @param {string|undefined} configFilePath The path to the config file.
+ * @param {ConfigLoaderOptions} loaderOptions The options to use when loading configuration files.
+ * @returns {void}
+ * @throws {Error} If no configuration exists.
+ */
+function assertConfigurationExists(configFilePath, loaderOptions) {
+
+    const {
+        configFile: useConfigFile
+    } = loaderOptions;
+
+    if (!configFilePath && useConfigFile !== false) {
+        const error = new Error("Could not find config file.");
+
+        error.messageTemplate = "config-file-missing";
+        throw error;
+    }
+
+}
+
+/**
+ * Check if the file is a TypeScript file.
+ * @param {string} filePath The file path to check.
+ * @returns {boolean} `true` if the file is a TypeScript file, `false` if it's not.
+ */
+function isFileTS(filePath) {
+    const fileExtension = path.extname(filePath);
+
+    return /^\.[mc]?ts$/u.test(fileExtension);
+}
+
+/**
+ * Check if ESLint is running in Bun.
+ * @returns {boolean} `true` if the ESLint is running Bun, `false` if it's not.
+ */
+function isRunningInBun() {
+    return !!globalThis.Bun;
+}
+
+/**
+ * Check if ESLint is running in Deno.
+ * @returns {boolean} `true` if the ESLint is running in Deno, `false` if it's not.
+ */
+function isRunningInDeno() {
+    return !!globalThis.Deno;
+}
+
+/**
+ * Load the config array from the given filename.
+ * @param {string} filePath The filename to load from.
+ * @param {boolean} allowTS Indicates if TypeScript configuration files are allowed.
+ * @returns {Promise<any>} The config loaded from the config file.
+ */
+async function loadConfigFile(filePath, allowTS) {
+
+    debug(`Loading config from ${filePath}`);
+
+    const fileURL = pathToFileURL(filePath);
+
+    debug(`Config file URL is ${fileURL}`);
+
+    const mtime = (await fs.stat(filePath)).mtime.getTime();
+
+    /*
+     * Append a query with the config file's modification time (`mtime`) in order
+     * to import the current version of the config file. Without the query, `import()` would
+     * cache the config file module by the pathname only, and then always return
+     * the same version (the one that was actual when the module was imported for the first time).
+     *
+     * This ensures that the config file module is loaded and executed again
+     * if it has been changed since the last time it was imported.
+     * If it hasn't been changed, `import()` will just return the cached version.
+     *
+     * Note that we should not overuse queries (e.g., by appending the current time
+     * to always reload the config file module) as that could cause memory leaks
+     * because entries are never removed from the import cache.
+     */
+    fileURL.searchParams.append("mtime", mtime);
+
+    /*
+     * With queries, we can bypass the import cache. However, when import-ing a CJS module,
+     * Node.js uses the require infrastructure under the hood. That includes the require cache,
+     * which caches the config file module by its file path (queries have no effect).
+     * Therefore, we also need to clear the require cache before importing the config file module.
+     * In order to get the same behavior with ESM and CJS config files, in particular - to reload
+     * the config file only if it has been changed, we track file modification times and clear
+     * the require cache only if the file has been changed.
+     */
+    if (importedConfigFileModificationTime.get(filePath) !== mtime) {
+        delete require.cache[filePath];
+    }
+
+    const isTS = isFileTS(filePath);
+    const isBun = isRunningInBun();
+    const isDeno = isRunningInDeno();
+
+    /*
+     * If we are dealing with a TypeScript file, then we need to use `jiti` to load it
+     * in Node.js. Deno and Bun both allow native importing of TypeScript files.
+     *
+     * When Node.js supports native TypeScript imports, we can remove this check.
+     */
+    if (allowTS && isTS && !isDeno && !isBun) {
+
+        const createJiti = await import("jiti").then(jitiModule => jitiModule.default, () => {
+            throw new Error("The 'jiti' library is required for loading TypeScript configuration files. Make sure to install it.");
+        });
+
+        /*
+         * Disabling `moduleCache` allows us to reload a
+         * config file when the last modified timestamp changes.
+         */
+
+        const jiti = createJiti(__filename, { moduleCache: false });
+
+        if (typeof jiti?.import !== "function") {
+            throw new Error("You are using an outdated version of the 'jiti' library. Please update to the latest version of 'jiti' to ensure compatibility and access to the latest features.");
+        }
+
+        const config = await jiti.import(fileURL.href);
+
+        importedConfigFileModificationTime.set(filePath, mtime);
+
+        return config?.default ?? config;
+    }
+
+
+    // fallback to normal runtime behavior
+
+    const config = (await import(fileURL)).default;
+
+    importedConfigFileModificationTime.set(filePath, mtime);
+
+    return config;
+}
+
+/**
+ * Calculates the config array for this run based on inputs.
+ * @param {string} configFilePath The absolute path to the config file to use if not overridden.
+ * @param {string} basePath The base path to use for relative paths in the config file.
+ * @param {ConfigLoaderOptions} options The options to use when loading configuration files.
+ * @returns {Promise<FlatConfigArray>} The config array for `eslint`.
+ */
+async function calculateConfigArray(configFilePath, basePath, options) {
+
+    const {
+        cwd,
+        baseConfig,
+        ignoreEnabled,
+        ignorePatterns,
+        overrideConfig,
+        defaultConfigs = [],
+        allowTS
+    } = options;
+
+    debug(`Calculating config array from config file ${configFilePath} and base path ${basePath}`);
+
+    const configs = new FlatConfigArray(baseConfig || [], { basePath, shouldIgnore: ignoreEnabled });
+
+    // load config file
+    if (configFilePath) {
+
+        debug(`Loading config file ${configFilePath}`);
+        const fileConfig = await loadConfigFile(configFilePath, allowTS);
+
+        if (Array.isArray(fileConfig)) {
+            configs.push(...fileConfig);
+        } else {
+            configs.push(fileConfig);
+        }
+    }
+
+    // add in any configured defaults
+    configs.push(...defaultConfigs);
+
+    // append command line ignore patterns
+    if (ignorePatterns && ignorePatterns.length > 0) {
+
+        let relativeIgnorePatterns;
+
+        /*
+         * If the config file basePath is different than the cwd, then
+         * the ignore patterns won't work correctly. Here, we adjust the
+         * ignore pattern to include the correct relative path. Patterns
+         * passed as `ignorePatterns` are relative to the cwd, whereas
+         * the config file basePath can be an ancestor of the cwd.
+         */
+        if (basePath === cwd) {
+            relativeIgnorePatterns = ignorePatterns;
+        } else {
+
+            // relative path must only have Unix-style separators
+            const relativeIgnorePath = path.relative(basePath, cwd).replace(/\\/gu, "/");
+
+            relativeIgnorePatterns = ignorePatterns.map(pattern => {
+                const negated = pattern.startsWith("!");
+                const basePattern = negated ? pattern.slice(1) : pattern;
+
+                return (negated ? "!" : "") +
+                    path.posix.join(relativeIgnorePath, basePattern);
+            });
+        }
+
+        /*
+         * Ignore patterns are added to the end of the config array
+         * so they can override default ignores.
+         */
+        configs.push({
+            ignores: relativeIgnorePatterns
+        });
+    }
+
+    if (overrideConfig) {
+        if (Array.isArray(overrideConfig)) {
+            configs.push(...overrideConfig);
+        } else {
+            configs.push(overrideConfig);
+        }
+    }
+
+    await configs.normalize();
+
+    return configs;
+}
+
+
+//-----------------------------------------------------------------------------
+// Exports
+//-----------------------------------------------------------------------------
+
+/**
+ * Encapsulates the loading and caching of configuration files when looking up
+ * from the file being linted.
+ */
+class ConfigLoader {
+
+    /**
+     * Map of config file paths to the config arrays for those directories.
+     * @type {Map<string, FlatConfigArray>}
+     */
+    #configArrays = new Map();
+
+    /**
+     * Map of absolute directory names to the config file paths for those directories.
+     * @type {Map<string, {configFilePath:string,basePath:string}>}
+     */
+    #configFilePaths = new Map();
+
+    /**
+     * The options to use when loading configuration files.
+     * @type {ConfigLoaderOptions}
+     */
+    #options;
+
+    /**
+     * Creates a new instance.
+     * @param {ConfigLoaderOptions} options The options to use when loading configuration files.
+     */
+    constructor(options) {
+        this.#options = options;
+    }
+
+    /**
+     * Determines which config file to use. This is determined by seeing if an
+     * override config file was specified, and if so, using it; otherwise, as long
+     * as override config file is not explicitly set to `false`, it will search
+     * upwards from `fromDirectory` for a file named `eslint.config.js`.
+     * @param {string} fromDirectory The directory from which to start searching.
+     * @returns {Promise<{configFilePath:string|undefined,basePath:string}>} Location information for
+     *      the config file.
+     */
+    async #locateConfigFileToUse(fromDirectory) {
+
+        // check cache first
+        if (this.#configFilePaths.has(fromDirectory)) {
+            return this.#configFilePaths.get(fromDirectory);
+        }
+
+        const configFilenames = this.#options.allowTS
+            ? [...FLAT_CONFIG_FILENAMES, ...TS_FLAT_CONFIG_FILENAMES]
+            : FLAT_CONFIG_FILENAMES;
+
+        // determine where to load config file from
+        let configFilePath;
+        const {
+            cwd,
+            configFile: useConfigFile
+        } = this.#options;
+        let basePath = cwd;
+
+        if (typeof useConfigFile === "string") {
+            debug(`Override config file path is ${useConfigFile}`);
+            configFilePath = path.resolve(cwd, useConfigFile);
+            basePath = cwd;
+        } else if (useConfigFile !== false) {
+            debug("Searching for eslint.config.js");
+            configFilePath = await findUp(
+                configFilenames,
+                { cwd: fromDirectory }
+            );
+
+            if (configFilePath) {
+                basePath = path.dirname(configFilePath);
+            }
+
+        }
+
+        // cache the result
+        this.#configFilePaths.set(fromDirectory, { configFilePath, basePath });
+
+        return {
+            configFilePath,
+            basePath
+        };
+
+    }
+
+    /**
+     * Calculates the config array for this run based on inputs.
+     * @param {string} configFilePath The absolute path to the config file to use if not overridden.
+     * @param {string} basePath The base path to use for relative paths in the config file.
+     * @returns {Promise<FlatConfigArray>} The config array for `eslint`.
+     */
+    async #calculateConfigArray(configFilePath, basePath) {
+
+        // check for cached version first
+        if (this.#configArrays.has(configFilePath)) {
+            return this.#configArrays.get(configFilePath);
+        }
+
+        const configs = await calculateConfigArray(configFilePath, basePath, this.#options);
+
+        // cache the config array for this instance
+        this.#configArrays.set(configFilePath, configs);
+
+        return configs;
+    }
+
+    /**
+     * Returns the config file path for the given directory or file. This will either use
+     * the override config file that was specified in the constructor options or
+     * search for a config file from the directory.
+     * @param {string} fileOrDirPath The file or directory path to get the config file path for.
+     * @returns {Promise<string|undefined>} The config file path or `undefined` if not found.
+     * @throws {Error} If `fileOrDirPath` is not a non-empty string.
+     * @throws {Error} If `fileOrDirPath` is not an absolute path.
+     */
+    async findConfigFileForPath(fileOrDirPath) {
+
+        assertValidFilePath(fileOrDirPath);
+
+        const absoluteDirPath = path.resolve(this.#options.cwd, path.dirname(fileOrDirPath));
+        const { configFilePath } = await this.#locateConfigFileToUse(absoluteDirPath);
+
+        return configFilePath;
+    }
+
+    /**
+     * Returns a configuration object for the given file based on the CLI options.
+     * This is the same logic used by the ESLint CLI executable to determine
+     * configuration for each file it processes.
+     * @param {string} filePath The path of the file or directory to retrieve config for.
+     * @returns {Promise<ConfigData|undefined>} A configuration object for the file
+     *      or `undefined` if there is no configuration data for the file.
+     * @throws {Error} If no configuration for `filePath` exists.
+     */
+    async loadConfigArrayForFile(filePath) {
+
+        assertValidFilePath(filePath);
+
+        debug(`Calculating config for file ${filePath}`);
+
+        const configFilePath = await this.findConfigFileForPath(filePath);
+
+        assertConfigurationExists(configFilePath, this.#options);
+
+        return this.loadConfigArrayForDirectory(filePath);
+    }
+
+    /**
+     * Returns a configuration object for the given directory based on the CLI options.
+     * This is the same logic used by the ESLint CLI executable to determine
+     * configuration for each file it processes.
+     * @param {string} dirPath The path of the directory to retrieve config for.
+     * @returns {Promise<ConfigData|undefined>} A configuration object for the directory
+     *      or `undefined` if there is no configuration data for the directory.
+     */
+    async loadConfigArrayForDirectory(dirPath) {
+
+        assertValidFilePath(dirPath);
+
+        debug(`Calculating config for directory ${dirPath}`);
+
+        const absoluteDirPath = path.resolve(this.#options.cwd, path.dirname(dirPath));
+        const { configFilePath, basePath } = await this.#locateConfigFileToUse(absoluteDirPath);
+
+        debug(`Using config file ${configFilePath} and base path ${basePath}`);
+        return this.#calculateConfigArray(configFilePath, basePath);
+    }
+
+    /**
+     * Returns a configuration array for the given file based on the CLI options.
+     * This is a synchronous operation and does not read any files from disk. It's
+     * intended to be used in locations where we know the config file has already
+     * been loaded and we just need to get the configuration for a file.
+     * @param {string} filePath The path of the file to retrieve a config object for.
+     * @returns {ConfigData|undefined} A configuration object for the file
+     *     or `undefined` if there is no configuration data for the file.
+     * @throws {Error} If `filePath` is not a non-empty string.
+     * @throws {Error} If `filePath` is not an absolute path.
+     * @throws {Error} If the config file was not already loaded.
+     */
+    getCachedConfigArrayForFile(filePath) {
+        assertValidFilePath(filePath);
+
+        debug(`Looking up cached config for ${filePath}`);
+
+        return this.getCachedConfigArrayForPath(path.dirname(filePath));
+    }
+
+    /**
+     * Returns a configuration array for the given directory based on the CLI options.
+     * This is a synchronous operation and does not read any files from disk. It's
+     * intended to be used in locations where we know the config file has already
+     * been loaded and we just need to get the configuration for a file.
+     * @param {string} fileOrDirPath The path of the directory to retrieve a config object for.
+     * @returns {ConfigData|undefined} A configuration object for the directory
+     *     or `undefined` if there is no configuration data for the directory.
+     * @throws {Error} If `dirPath` is not a non-empty string.
+     * @throws {Error} If `dirPath` is not an absolute path.
+     * @throws {Error} If the config file was not already loaded.
+     */
+    getCachedConfigArrayForPath(fileOrDirPath) {
+        assertValidFilePath(fileOrDirPath);
+
+        debug(`Looking up cached config for ${fileOrDirPath}`);
+
+        const absoluteDirPath = path.resolve(this.#options.cwd, fileOrDirPath);
+
+        if (!this.#configFilePaths.has(absoluteDirPath)) {
+            throw new Error(`Could not find config file for ${fileOrDirPath}`);
+        }
+
+        const { configFilePath } = this.#configFilePaths.get(absoluteDirPath);
+
+        return this.#configArrays.get(configFilePath);
+    }
+
+}
+
+/**
+ * Encapsulates the loading and caching of configuration files when looking up
+ * from the current working directory.
+ */
+class LegacyConfigLoader extends ConfigLoader {
+
+    /**
+     * The options to use when loading configuration files.
+     * @type {ConfigLoaderOptions}
+     */
+    #options;
+
+    /**
+     * The cached config file path for this instance.
+     * @type {{configFilePath:string,basePath:string}|undefined}
+     */
+    #configFilePath;
+
+    /**
+     * The cached config array for this instance.
+     * @type {FlatConfigArray}
+     */
+    #configArray;
+
+    /**
+     * Creates a new instance.
+     * @param {ConfigLoaderOptions} options The options to use when loading configuration files.
+     */
+    constructor(options) {
+        super(options);
+        this.#options = options;
+    }
+
+    /**
+     * Determines which config file to use. This is determined by seeing if an
+     * override config file was specified, and if so, using it; otherwise, as long
+     * as override config file is not explicitly set to `false`, it will search
+     * upwards from the cwd for a file named `eslint.config.js`.
+     * @returns {Promise<{configFilePath:string|undefined,basePath:string}>} Location information for
+     *      the config file.
+     */
+    async #locateConfigFileToUse() {
+
+        // check cache first
+        if (this.#configFilePath) {
+            return this.#configFilePath;
+        }
+
+        const configFilenames = this.#options.allowTS
+            ? [...FLAT_CONFIG_FILENAMES, ...TS_FLAT_CONFIG_FILENAMES]
+            : FLAT_CONFIG_FILENAMES;
+
+        // determine where to load config file from
+        let configFilePath;
+        const {
+            cwd,
+            configFile: useConfigFile
+        } = this.#options;
+        let basePath = cwd;
+
+        if (typeof useConfigFile === "string") {
+            debug(`[Legacy]: Override config file path is ${useConfigFile}`);
+            configFilePath = path.resolve(cwd, useConfigFile);
+            basePath = cwd;
+        } else if (useConfigFile !== false) {
+            debug("[Legacy]: Searching for eslint.config.js");
+            configFilePath = await findUp(
+                configFilenames,
+                { cwd }
+            );
+
+            if (configFilePath) {
+                basePath = path.dirname(configFilePath);
+            }
+
+        }
+
+        // cache the result
+        this.#configFilePath = { configFilePath, basePath };
+
+        return {
+            configFilePath,
+            basePath
+        };
+
+    }
+
+    /**
+     * Calculates the config array for this run based on inputs.
+     * @param {string} configFilePath The absolute path to the config file to use if not overridden.
+     * @param {string} basePath The base path to use for relative paths in the config file.
+     * @returns {Promise<FlatConfigArray>} The config array for `eslint`.
+     */
+    async #calculateConfigArray(configFilePath, basePath) {
+
+        // check for cached version first
+        if (this.#configArray) {
+            return this.#configArray;
+        }
+
+        const configs = await calculateConfigArray(configFilePath, basePath, this.#options);
+
+        // cache the config array for this instance
+        this.#configArray = configs;
+
+        return configs;
+    }
+
+
+    /**
+     * Returns the config file path for the given directory. This will either use
+     * the override config file that was specified in the constructor options or
+     * search for a config file from the directory of the file being linted.
+     * @param {string} dirPath The directory path to get the config file path for.
+     * @returns {Promise<string|undefined>} The config file path or `undefined` if not found.
+     * @throws {Error} If `fileOrDirPath` is not a non-empty string.
+     * @throws {Error} If `fileOrDirPath` is not an absolute path.
+     */
+    async findConfigFileForPath(dirPath) {
+
+        assertValidFilePath(dirPath);
+
+        const { configFilePath } = await this.#locateConfigFileToUse();
+
+        return configFilePath;
+    }
+
+    /**
+     * Returns a configuration object for the given file based on the CLI options.
+     * This is the same logic used by the ESLint CLI executable to determine
+     * configuration for each file it processes.
+     * @param {string} dirPath The path of the directory to retrieve config for.
+     * @returns {Promise<ConfigData|undefined>} A configuration object for the file
+     *      or `undefined` if there is no configuration data for the file.
+     */
+    async loadConfigArrayForDirectory(dirPath) {
+
+        assertValidFilePath(dirPath);
+
+        debug(`[Legacy]: Calculating config for ${dirPath}`);
+
+        const { configFilePath, basePath } = await this.#locateConfigFileToUse();
+
+        debug(`[Legacy]: Using config file ${configFilePath} and base path ${basePath}`);
+        return this.#calculateConfigArray(configFilePath, basePath);
+    }
+
+    /**
+     * Returns a configuration array for the given directory based on the CLI options.
+     * This is a synchronous operation and does not read any files from disk. It's
+     * intended to be used in locations where we know the config file has already
+     * been loaded and we just need to get the configuration for a file.
+     * @param {string} dirPath The path of the directory to retrieve a config object for.
+     * @returns {ConfigData|undefined} A configuration object for the file
+     *     or `undefined` if there is no configuration data for the file.
+     * @throws {Error} If `dirPath` is not a non-empty string.
+     * @throws {Error} If `dirPath` is not an absolute path.
+     * @throws {Error} If the config file was not already loaded.
+     */
+    getCachedConfigArrayForPath(dirPath) {
+        assertValidFilePath(dirPath);
+
+        debug(`[Legacy]: Looking up cached config for ${dirPath}`);
+
+        if (!this.#configArray) {
+            throw new Error(`Could not find config file for ${dirPath}`);
+        }
+
+        return this.#configArray;
+    }
+}
+
+module.exports = { ConfigLoader, LegacyConfigLoader };
diff --git a/lib/eslint/eslint-helpers.js b/lib/eslint/eslint-helpers.js
index 38c16155c..c938d0d63 100644
--- a/lib/eslint/eslint-helpers.js
+++ b/lib/eslint/eslint-helpers.js
@@ -15,9 +15,7 @@ const fsp = fs.promises;
 const isGlob = require("is-glob");
 const hash = require("../cli-engine/hash");
 const minimatch = require("minimatch");
-const fswalk = require("@nodelib/fs.walk");
 const globParent = require("glob-parent");
-const isPathInside = require("is-path-inside");
 
 //-----------------------------------------------------------------------------
 // Fixup references
@@ -160,31 +158,28 @@ function isGlobPattern(pattern) {
  * @param {string} options.pattern A glob pattern to match.
  * @returns {Promise<boolean>} True if there is a glob match, false if not.
  */
-function globMatch({ basePath, pattern }) {
+async function globMatch({ basePath, pattern }) {
 
     let found = false;
+    const { hfs } = await import("@humanfs/node");
     const patternToUse = path.isAbsolute(pattern)
         ? normalizeToPosix(path.relative(basePath, pattern))
         : pattern;
 
     const matcher = new Minimatch(patternToUse, MINIMATCH_OPTIONS);
 
-    const fsWalkSettings = {
+    const walkSettings = {
 
-        deepFilter(entry) {
-            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));
-
-            return !found && matcher.match(relativePath, true);
+        directoryFilter(entry) {
+            return !found && matcher.match(entry.path, true);
         },
 
         entryFilter(entry) {
-            if (found || entry.dirent.isDirectory()) {
+            if (found || entry.isDirectory) {
                 return false;
             }
 
-            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));
-
-            if (matcher.match(relativePath)) {
+            if (matcher.match(entry.path)) {
                 found = true;
                 return true;
             }
@@ -193,25 +188,11 @@ function globMatch({ basePath, pattern }) {
         }
     };
 
-    return new Promise(resolve => {
-
-        // using a stream so we can exit early because we just need one match
-        const globStream = fswalk.walkStream(basePath, fsWalkSettings);
-
-        globStream.on("data", () => {
-            globStream.destroy();
-            resolve(true);
-        });
-
-        // swallow errors as they're not important here
-        globStream.on("error", () => { });
-
-        globStream.on("end", () => {
-            resolve(false);
-        });
-        globStream.read();
-    });
+    if (await hfs.isDirectory(basePath)) {
+        return hfs.walk(basePath, walkSettings).next().then(() => found);
+    }
 
+    return found;
 }
 
 /**
@@ -225,7 +206,7 @@ function globMatch({ basePath, pattern }) {
  *      to match.
  * @param {Array<string>} options.rawPatterns An array of glob patterns
  *      as the user inputted them. Used for errors.
- * @param {FlatConfigArray} options.configs The config array to use for
+ * @param {ConfigLoader|LegacyConfigLoader} options.configLoader The config array to use for
  *      determining what to ignore.
  * @param {boolean} options.errorOnUnmatchedPattern Determines if an error
  *      should be thrown when a pattern is unmatched.
@@ -238,7 +219,7 @@ async function globSearch({
     basePath,
     patterns,
     rawPatterns,
-    configs,
+    configLoader,
     errorOnUnmatchedPattern
 }) {
 
@@ -277,94 +258,76 @@ async function globSearch({
      * search.
      */
     const unmatchedPatterns = new Set([...relativeToPatterns.keys()]);
+    const { hfs } = await import("@humanfs/node");
 
-    const filePaths = (await new Promise((resolve, reject) => {
-
-        let promiseRejected = false;
+    const walk = hfs.walk(
+        basePath,
+        {
+            async directoryFilter(entry) {
 
-        /**
-         * Wraps a boolean-returning filter function. The wrapped function will reject the promise if an error occurs.
-         * @param {Function} filter A filter function to wrap.
-         * @returns {Function} A function similar to the wrapped filter that rejects the promise if an error occurs.
-         */
-        function wrapFilter(filter) {
-            return (...args) => {
-
-                // No need to run the filter if an error has been thrown.
-                if (!promiseRejected) {
-                    try {
-                        return filter(...args);
-                    } catch (error) {
-                        promiseRejected = true;
-                        reject(error);
-                    }
+                if (!matchers.some(matcher => matcher.match(entry.path, true))) {
+                    return false;
                 }
-                return false;
-            };
-        }
 
-        fswalk.walk(
-            basePath,
-            {
-                deepFilter: wrapFilter(entry => {
-                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));
-                    const matchesPattern = matchers.some(matcher => matcher.match(relativePath, true));
-
-                    return matchesPattern && !configs.isDirectoryIgnored(entry.path);
-                }),
-                entryFilter: wrapFilter(entry => {
-                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));
-
-                    // entries may be directories or files so filter out directories
-                    if (entry.dirent.isDirectory()) {
-                        return false;
-                    }
-
-                    /*
-                     * Optimization: We need to track when patterns are left unmatched
-                     * and so we use `unmatchedPatterns` to do that. There is a bit of
-                     * complexity here because the same file can be matched by more than
-                     * one pattern. So, when we start, we actually need to test every
-                     * pattern against every file. Once we know there are no remaining
-                     * unmatched patterns, then we can switch to just looking for the
-                     * first matching pattern for improved speed.
-                     */
-                    const matchesPattern = unmatchedPatterns.size > 0
-                        ? matchers.reduce((previousValue, matcher) => {
-                            const pathMatches = matcher.match(relativePath);
-
-                            /*
-                             * We updated the unmatched patterns set only if the path
-                             * matches and the file has a config. If the file has no
-                             * config, that means there wasn't a match for the
-                             * pattern so it should not be removed.
-                             *
-                             * Performance note: `getConfig()` aggressively caches
-                             * results so there is no performance penalty for calling
-                             * it multiple times with the same argument.
-                             */
-                            if (pathMatches && configs.getConfig(entry.path)) {
-                                unmatchedPatterns.delete(matcher.pattern);
-                            }
-
-                            return pathMatches || previousValue;
-                        }, false)
-                        : matchers.some(matcher => matcher.match(relativePath));
-
-                    return matchesPattern && configs.getConfig(entry.path) !== void 0;
-                })
+                const absolutePath = path.resolve(basePath, entry.path);
+                const configs = await configLoader.loadConfigArrayForDirectory(absolutePath);
+
+                return !configs.isDirectoryIgnored(absolutePath);
             },
-            (error, entries) => {
+            async entryFilter(entry) {
+                const absolutePath = path.resolve(basePath, entry.path);
 
-                // If the promise is already rejected, calling `resolve` or `reject` will do nothing.
-                if (error) {
-                    reject(error);
-                } else {
-                    resolve(entries);
+                // entries may be directories or files so filter out directories
+                if (entry.isDirectory) {
+                    return false;
                 }
+
+                const configs = await configLoader.loadConfigArrayForFile(absolutePath);
+                const config = configs.getConfig(absolutePath);
+
+                /*
+                 * Optimization: We need to track when patterns are left unmatched
+                 * and so we use `unmatchedPatterns` to do that. There is a bit of
+                 * complexity here because the same file can be matched by more than
+                 * one pattern. So, when we start, we actually need to test every
+                 * pattern against every file. Once we know there are no remaining
+                 * unmatched patterns, then we can switch to just looking for the
+                 * first matching pattern for improved speed.
+                 */
+                const matchesPattern = unmatchedPatterns.size > 0
+                    ? matchers.reduce((previousValue, matcher) => {
+                        const pathMatches = matcher.match(entry.path);
+
+                        /*
+                         * We updated the unmatched patterns set only if the path
+                         * matches and the file has a config. If the file has no
+                         * config, that means there wasn't a match for the
+                         * pattern so it should not be removed.
+                         *
+                         * Performance note: `getConfig()` aggressively caches
+                         * results so there is no performance penalty for calling
+                         * it multiple times with the same argument.
+                         */
+                        if (pathMatches && config) {
+                            unmatchedPatterns.delete(matcher.pattern);
+                        }
+
+                        return pathMatches || previousValue;
+                    }, false)
+                    : matchers.some(matcher => matcher.match(entry.path));
+
+                return matchesPattern && config !== void 0;
             }
-        );
-    })).map(entry => entry.path);
+        }
+    );
+
+    const filePaths = [];
+
+    if (await hfs.isDirectory(basePath)) {
+        for await (const entry of walk) {
+            filePaths.push(path.resolve(basePath, entry.path));
+        }
+    }
 
     // now check to see if we have any unmatched patterns
     if (errorOnUnmatchedPattern && unmatchedPatterns.size > 0) {
@@ -426,14 +389,14 @@ async function throwErrorForUnmatchedPatterns({
  * @param {Object} options The options for this function.
  * @param {Map<string,GlobSearch>} options.searches
  *      An array of glob patterns to match.
- * @param {FlatConfigArray} options.configs The config array to use for
+ * @param {ConfigLoader|LegacyConfigLoader} options.configLoader The config loader to use for
  *      determining what to ignore.
  * @param {boolean} options.errorOnUnmatchedPattern Determines if an
  *      unmatched glob pattern should throw an error.
  * @returns {Promise<Array<string>>} An array of matching file paths
  *      or an empty array if there are no matches.
  */
-async function globMultiSearch({ searches, configs, errorOnUnmatchedPattern }) {
+async function globMultiSearch({ searches, configLoader, errorOnUnmatchedPattern }) {
 
     /*
      * For convenience, we normalized the search map into an array of objects.
@@ -452,7 +415,7 @@ async function globMultiSearch({ searches, configs, errorOnUnmatchedPattern }) {
                 basePath,
                 patterns,
                 rawPatterns,
-                configs,
+                configLoader,
                 errorOnUnmatchedPattern
             })
         )
@@ -505,7 +468,7 @@ async function globMultiSearch({ searches, configs, errorOnUnmatchedPattern }) {
  * @param {boolean} args.globInputPaths true to interpret glob patterns,
  *      false to not interpret glob patterns.
  * @param {string} args.cwd The current working directory to find from.
- * @param {FlatConfigArray} args.configs The configs for the current run.
+ * @param {ConfigLoader|LegacyConfigLoader} args.configLoader The config loeader for the current run.
  * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern
  *      should throw an error.
  * @returns {Promise<Array<string>>} The fully resolved file paths.
@@ -516,7 +479,7 @@ async function findFiles({
     patterns,
     globInputPaths,
     cwd,
-    configs,
+    configLoader,
     errorOnUnmatchedPattern
 }) {
 
@@ -526,6 +489,42 @@ async function findFiles({
     let rawPatterns = [];
     const searches = new Map([[cwd, { patterns: globbyPatterns, rawPatterns: [] }]]);
 
+    /*
+     * This part is a bit involved because we need to account for
+     * the different ways that the patterns can match directories.
+     * For each different way, we need to decide if we should look
+     * for a config file or just use the default config. (Directories
+     * without a config file always use the default config.)
+     *
+     * Here are the cases:
+     *
+     * 1. A directory is passed directly (e.g., "subdir"). In this case, we
+     * can assume that the user intends to lint this directory and we should
+     * not look for a config file in the parent directory, because the only
+     * reason to do that would be to ignore this directory (which we already
+     * know we don't want to do). Instead, we use the default config until we
+     * get to the directory that was passed, at which point we start looking
+     * for config files again.
+     *
+     * 2. A dot (".") or star ("*"). In this case, we want to read
+     * the config file in the current directory because the user is
+     * explicitly asking to lint the current directory. Note that "."
+     * will traverse into subdirectories while "*" will not.
+     *
+     * 3. A directory is passed in the form of "subdir/subsubdir".
+     * In this case, we don't want to look for a config file in the
+     * parent directory ("subdir"). We can skip looking for a config
+     * file until `entry.depth` is greater than 1 because there's no
+     * way that the pattern can match `entry.path` yet.
+     *
+     * 4. A directory glob pattern is passed (e.g., "subd*"). We want
+     * this case to act like case 2 because it's unclear whether or not
+     * any particular directory is meant to be traversed.
+     *
+     * 5. A recursive glob pattern is passed (e.g., "**"). We want this
+     * case to act like case 2.
+     */
+
     // check to see if we have explicit files and directories
     const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));
     const stats = await Promise.all(
@@ -549,15 +548,10 @@ async function findFiles({
             // directories need extensions attached
             if (stat.isDirectory()) {
 
-                // group everything in cwd together and split out others
-                if (isPathInside(filePath, cwd)) {
-                    ({ patterns: globbyPatterns, rawPatterns } = searches.get(cwd));
-                } else {
-                    if (!searches.has(filePath)) {
-                        searches.set(filePath, { patterns: [], rawPatterns: [] });
-                    }
-                    ({ patterns: globbyPatterns, rawPatterns } = searches.get(filePath));
+                if (!searches.has(filePath)) {
+                    searches.set(filePath, { patterns: [], rawPatterns: [] });
                 }
+                ({ patterns: globbyPatterns, rawPatterns } = searches.get(filePath));
 
                 globbyPatterns.push(`${normalizeToPosix(filePath)}/**`);
                 rawPatterns.push(pattern);
@@ -569,17 +563,17 @@ async function findFiles({
         // save patterns for later use based on whether globs are enabled
         if (globInputPaths && isGlobPattern(pattern)) {
 
+            /*
+             * We are grouping patterns by their glob parent. This is done to
+             * make it easier to determine when a config file should be loaded.
+             */
+
             const basePath = path.resolve(cwd, globParent(pattern));
 
-            // group in cwd if possible and split out others
-            if (isPathInside(basePath, cwd)) {
-                ({ patterns: globbyPatterns, rawPatterns } = searches.get(cwd));
-            } else {
-                if (!searches.has(basePath)) {
-                    searches.set(basePath, { patterns: [], rawPatterns: [] });
-                }
-                ({ patterns: globbyPatterns, rawPatterns } = searches.get(basePath));
+            if (!searches.has(basePath)) {
+                searches.set(basePath, { patterns: [], rawPatterns: [] });
             }
+            ({ patterns: globbyPatterns, rawPatterns } = searches.get(basePath));
 
             globbyPatterns.push(filePath);
             rawPatterns.push(pattern);
@@ -596,7 +590,7 @@ async function findFiles({
     // now we are safe to do the search
     const globbyResults = await globMultiSearch({
         searches,
-        configs,
+        configLoader,
         errorOnUnmatchedPattern
     });
 
diff --git a/lib/eslint/eslint.js b/lib/eslint/eslint.js
index 1e69f04ac..26bc7e771 100644
--- a/lib/eslint/eslint.js
+++ b/lib/eslint/eslint.js
@@ -12,7 +12,6 @@
 const fs = require("node:fs/promises");
 const { existsSync } = require("node:fs");
 const path = require("node:path");
-const findUp = require("find-up");
 const { version } = require("../../package.json");
 const { Linter } = require("../linter");
 const { getRuleFromConfig } = require("../config/flat-config-helpers");
@@ -39,9 +38,9 @@ const {
     processOptions
 } = require("./eslint-helpers");
 const { pathToFileURL } = require("node:url");
-const { FlatConfigArray } = require("../config/flat-config-array");
 const LintResultCache = require("../cli-engine/lint-result-cache");
 const { Retrier } = require("@humanwhocodes/retry");
+const { ConfigLoader, LegacyConfigLoader } = require("../config/config-loader");
 
 /*
  * This is necessary to allow overwriting writeFile for testing purposes.
@@ -97,24 +96,8 @@ const { Retrier } = require("@humanwhocodes/retry");
 // Helpers
 //------------------------------------------------------------------------------
 
-const FLAT_CONFIG_FILENAMES = [
-    "eslint.config.js",
-    "eslint.config.mjs",
-    "eslint.config.cjs"
-];
-const FLAT_CONFIG_FILENAMES_WITH_TS = [
-    ...FLAT_CONFIG_FILENAMES,
-    "eslint.config.ts",
-    "eslint.config.mts",
-    "eslint.config.cts"
-];
 const debug = require("debug")("eslint:eslint");
 const privateMembers = new WeakMap();
-
-/**
- * @type {Map<string, string>}
- */
-const importedConfigFileModificationTime = new Map();
 const removedFormatters = new Set([
     "checkstyle",
     "codeframe",
@@ -196,12 +179,13 @@ const usedDeprecatedRulesCache = new WeakMap();
  */
 function getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {
     const {
-        configs,
-        options: { cwd }
+        options: { cwd },
+        configLoader
     } = privateMembers.get(eslint);
     const filePath = path.isAbsolute(maybeFilePath)
         ? maybeFilePath
         : getPlaceholderPath(cwd);
+    const configs = configLoader.getCachedConfigArrayForFile(filePath);
     const config = configs.getConfig(filePath);
 
     // Most files use the same config, so cache it.
@@ -270,269 +254,38 @@ function compareResultsByFilePath(a, b) {
     return 0;
 }
 
-/**
- * Searches from the current working directory up until finding the
- * given flat config filename.
- * @param {string} cwd The current working directory to search from.
- * @param {boolean} hasUnstableTSConfigFlag `true` if the `unstable_ts_config` flag is enabled, `false` if it's not.
- * @returns {Promise<string|undefined>} The filename if found or `undefined` if not.
- */
-function findFlatConfigFile(cwd, hasUnstableTSConfigFlag) {
-    const filenames = hasUnstableTSConfigFlag ? FLAT_CONFIG_FILENAMES_WITH_TS : FLAT_CONFIG_FILENAMES;
-
-    return findUp(
-        filenames,
-        { cwd }
-    );
-}
-
-/**
- * Check if the file is a TypeScript file.
- * @param {string} filePath The file path to check.
- * @returns {boolean} `true` if the file is a TypeScript file, `false` if it's not.
- */
-function isFileTS(filePath) {
-    const fileExtension = path.extname(filePath);
-
-    return /^\.[mc]?ts$/u.test(fileExtension);
-}
-
-/**
- * Check if ESLint is running in Bun.
- * @returns {boolean} `true` if the ESLint is running Bun, `false` if it's not.
- */
-function isRunningInBun() {
-    return !!globalThis.Bun;
-}
-
-/**
- * Check if ESLint is running in Deno.
- * @returns {boolean} `true` if the ESLint is running in Deno, `false` if it's not.
- */
-function isRunningInDeno() {
-    return !!globalThis.Deno;
-}
-
-/**
- * Load the config array from the given filename.
- * @param {string} filePath The filename to load from.
- * @param {boolean} hasUnstableTSConfigFlag `true` if the `unstable_ts_config` flag is enabled, `false` if it's not.
- * @returns {Promise<any>} The config loaded from the config file.
- */
-async function loadFlatConfigFile(filePath, hasUnstableTSConfigFlag) {
-    debug(`Loading config from ${filePath}`);
-
-    const fileURL = pathToFileURL(filePath);
-
-    debug(`Config file URL is ${fileURL}`);
-
-    const mtime = (await fs.stat(filePath)).mtime.getTime().toString();
-
-    /*
-     * Append a query with the config file's modification time (`mtime`) in order
-     * to import the current version of the config file. Without the query, `import()` would
-     * cache the config file module by the pathname only, and then always return
-     * the same version (the one that was actual when the module was imported for the first time).
-     *
-     * This ensures that the config file module is loaded and executed again
-     * if it has been changed since the last time it was imported.
-     * If it hasn't been changed, `import()` will just return the cached version.
-     *
-     * Note that we should not overuse queries (e.g., by appending the current time
-     * to always reload the config file module) as that could cause memory leaks
-     * because entries are never removed from the import cache.
-     */
-    fileURL.searchParams.append("mtime", mtime);
-
-    /*
-     * With queries, we can bypass the import cache. However, when import-ing a CJS module,
-     * Node.js uses the require infrastructure under the hood. That includes the require cache,
-     * which caches the config file module by its file path (queries have no effect).
-     * Therefore, we also need to clear the require cache before importing the config file module.
-     * In order to get the same behavior with ESM and CJS config files, in particular - to reload
-     * the config file only if it has been changed, we track file modification times and clear
-     * the require cache only if the file has been changed.
-     */
-    if (importedConfigFileModificationTime.get(filePath) !== mtime) {
-        delete require.cache[filePath];
-    }
-
-    const isTS = isFileTS(filePath) && hasUnstableTSConfigFlag;
-
-    const isBun = isRunningInBun();
-
-    const isDeno = isRunningInDeno();
-
-    if (isTS && !isDeno && !isBun) {
-
-        const createJiti = await import("jiti").then(jitiModule => jitiModule.default, () => {
-            throw new Error("The 'jiti' library is required for loading TypeScript configuration files. Make sure to install it.");
-        });
-
-        /*
-         * Disabling `moduleCache` allows us to reload a
-         * config file when the last modified timestamp changes.
-         */
-
-        const jiti = createJiti(__filename, { moduleCache: false });
-
-        if (typeof jiti?.import !== "function") {
-            throw new Error("You are using an outdated version of the 'jiti' library. Please update to the latest version of 'jiti' to ensure compatibility and access to the latest features.");
-        }
-
-        const config = await jiti.import(fileURL.href);
-
-        importedConfigFileModificationTime.set(filePath, mtime);
-
-        return config?.default ?? config;
-    }
-
-    const config = (await import(fileURL.href)).default;
-
-    importedConfigFileModificationTime.set(filePath, mtime);
-
-    return config;
-}
 
 /**
  * Determines which config file to use. This is determined by seeing if an
  * override config file was passed, and if so, using it; otherwise, as long
  * as override config file is not explicitly set to `false`, it will search
  * upwards from the cwd for a file named `eslint.config.js`.
+ *
+ * This function is used primarily by the `--inspect-config` option. For now,
+ * we will maintain the existing behavior, which is to search up from the cwd.
  * @param {ESLintOptions} options The ESLint instance options.
- * @param {boolean} hasUnstableTSConfigFlag `true` if the `unstable_ts_config` flag is enabled, `false` if it's not.
- * @returns {Promise<{configFilePath:string|undefined;basePath:string;error:Error|null}>} Location information for
+ * @param {boolean} allowTS `true` if the `unstable_ts_config` flag is enabled, `false` if it's not.
+ * @returns {Promise<{configFilePath:string|undefined;basePath:string}>} Location information for
  *      the config file.
  */
-async function locateConfigFileToUse({ configFile, cwd }, hasUnstableTSConfigFlag) {
-
-    // determine where to load config file from
-    let configFilePath;
-    let basePath = cwd;
-    let error = null;
-
-    if (typeof configFile === "string") {
-        debug(`Override config file path is ${configFile}`);
-        configFilePath = path.resolve(cwd, configFile);
-    } else if (configFile !== false) {
-        debug("Searching for eslint.config.js");
-        configFilePath = await findFlatConfigFile(cwd, hasUnstableTSConfigFlag);
-
-        if (configFilePath) {
-            basePath = path.resolve(path.dirname(configFilePath));
-        } else {
-            error = new Error("Could not find config file.");
-            error.messageTemplate = "config-file-missing";
-        }
+async function locateConfigFileToUse({ configFile, cwd }, allowTS) {
+
+    const configLoader = new ConfigLoader({
+        cwd,
+        allowTS,
+        configFile
+    });
+
+    const configFilePath = await configLoader.findConfigFileForPath(path.join(cwd, "__placeholder__.js"));
 
+    if (!configFilePath) {
+        throw new Error("No ESLint configuration file was found.");
     }
 
     return {
         configFilePath,
-        basePath,
-        error
+        basePath: configFile ? cwd : path.dirname(configFilePath)
     };
-
-}
-
-/**
- * Calculates the config array for this run based on inputs.
- * @param {ESLint} eslint The instance to create the config array for.
- * @param {ESLintOptions} options The ESLint instance options.
- * @returns {Promise<typeof FlatConfigArray>} The config array for `eslint``.
- */
-async function calculateConfigArray(eslint, {
-    cwd,
-    baseConfig,
-    overrideConfig,
-    configFile,
-    ignore: shouldIgnore,
-    ignorePatterns
-}) {
-
-    // check for cached instance
-    const slots = privateMembers.get(eslint);
-
-    if (slots.configs) {
-        return slots.configs;
-    }
-
-    const hasUnstableTSConfigFlag = eslint.hasFlag("unstable_ts_config");
-
-    const { configFilePath, basePath, error } = await locateConfigFileToUse({ configFile, cwd }, hasUnstableTSConfigFlag);
-
-    // config file is required to calculate config
-    if (error) {
-        throw error;
-    }
-
-    const configs = new FlatConfigArray(baseConfig || [], { basePath, shouldIgnore });
-
-    // load config file
-    if (configFilePath) {
-        const fileConfig = await loadFlatConfigFile(configFilePath, hasUnstableTSConfigFlag);
-
-        if (Array.isArray(fileConfig)) {
-            configs.push(...fileConfig);
-        } else {
-            configs.push(fileConfig);
-        }
-    }
-
-    // add in any configured defaults
-    configs.push(...slots.defaultConfigs);
-
-    // append command line ignore patterns
-    if (ignorePatterns && ignorePatterns.length > 0) {
-
-        let relativeIgnorePatterns;
-
-        /*
-         * If the config file basePath is different than the cwd, then
-         * the ignore patterns won't work correctly. Here, we adjust the
-         * ignore pattern to include the correct relative path. Patterns
-         * passed as `ignorePatterns` are relative to the cwd, whereas
-         * the config file basePath can be an ancestor of the cwd.
-         */
-        if (basePath === cwd) {
-            relativeIgnorePatterns = ignorePatterns;
-        } else {
-
-            // In minimatch patterns, only `/` can be used as path separator
-            const relativeIgnorePath = path.relative(basePath, cwd).replaceAll(path.sep, "/");
-
-            relativeIgnorePatterns = ignorePatterns.map(pattern => {
-                const negated = pattern.startsWith("!");
-                const basePattern = negated ? pattern.slice(1) : pattern;
-
-                return (negated ? "!" : "") +
-                path.posix.join(relativeIgnorePath, basePattern);
-            });
-        }
-
-        /*
-         * Ignore patterns are added to the end of the config array
-         * so they can override default ignores.
-         */
-        configs.push({
-            ignores: relativeIgnorePatterns
-        });
-    }
-
-    if (overrideConfig) {
-        if (Array.isArray(overrideConfig)) {
-            configs.push(...overrideConfig);
-        } else {
-            configs.push(overrideConfig);
-        }
-    }
-
-    await configs.normalize();
-
-    // cache the config array for this instance
-    slots.configs = configs;
-
-    return configs;
 }
 
 /**
@@ -678,6 +431,12 @@ class ESLint {
      */
     static configType = "flat";
 
+    /**
+     * The loader to use for finding config files.
+     * @type {ConfigLoader|LegacyConfigLoader}
+     */
+    #configLoader;
+
     /**
      * Creates a new instance of the main ESLint API.
      * @param {ESLintOptions} options The options for this instance.
@@ -701,15 +460,34 @@ class ESLint {
             ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy)
             : null;
 
+        const configLoaderOptions = {
+            cwd: processedOptions.cwd,
+            baseConfig: processedOptions.baseConfig,
+            overrideConfig: processedOptions.overrideConfig,
+            configFile: processedOptions.configFile,
+            ignoreEnabled: processedOptions.ignore,
+            ignorePatterns: processedOptions.ignorePatterns,
+            defaultConfigs,
+            allowTS: processedOptions.flags.includes("unstable_ts_config")
+        };
+
+        this.#configLoader = processedOptions.flags.includes("unstable_config_lookup_from_file")
+            ? new ConfigLoader(configLoaderOptions)
+            : new LegacyConfigLoader(configLoaderOptions);
+
+        debug(`Using config loader ${this.#configLoader.constructor.name}`);
+
         privateMembers.set(this, {
             options: processedOptions,
             linter,
             cacheFilePath,
             lintResultCache,
             defaultConfigs,
-            configs: null
+            configs: null,
+            configLoader: this.#configLoader
         });
 
+
         /**
          * If additional plugins are passed in, add that to the default
          * configs for this instance.
@@ -813,20 +591,10 @@ class ESLint {
 
         const resultRules = new Map();
         const {
-            configs,
+            configLoader,
             options: { cwd }
         } = privateMembers.get(this);
 
-        /*
-         * We can only accurately return rules meta information for linting results if the
-         * results were created by this instance. Otherwise, the necessary rules data is
-         * not available. So if the config array doesn't already exist, just throw an error
-         * to let the user know we can't do anything here.
-         */
-        if (!configs) {
-            throw createExtraneousResultsError();
-        }
-
         for (const result of results) {
 
             /*
@@ -845,6 +613,14 @@ class ESLint {
                  * All of the plugin and rule information is contained within the
                  * calculated config for the given file.
                  */
+                let configs;
+
+                try {
+                    configs = configLoader.getCachedConfigArrayForFile(filePath);
+                } catch {
+                    throw createExtraneousResultsError();
+                }
+
                 const config = configs.getConfig(filePath);
 
                 if (!config) {
@@ -919,7 +695,6 @@ class ESLint {
 
         debug(`Using file patterns: ${normalizedPatterns}`);
 
-        const configs = await calculateConfigArray(this, eslintOptions);
         const {
             allowInlineConfig,
             cache,
@@ -955,7 +730,7 @@ class ESLint {
             patterns: normalizedPatterns,
             cwd,
             globInputPaths,
-            configs,
+            configLoader: this.#configLoader,
             errorOnUnmatchedPattern
         });
         const controller = new AbortController();
@@ -972,8 +747,9 @@ class ESLint {
          */
         const results = await Promise.all(
 
-            filePaths.map(filePath => {
+            filePaths.map(async filePath => {
 
+                const configs = await this.#configLoader.loadConfigArrayForFile(filePath);
                 const config = configs.getConfig(filePath);
 
                 /*
@@ -1111,7 +887,6 @@ class ESLint {
             linter,
             options: eslintOptions
         } = privateMembers.get(this);
-        const configs = await calculateConfigArray(this, eslintOptions);
         const {
             allowInlineConfig,
             cwd,
@@ -1125,21 +900,21 @@ class ESLint {
         const startTime = Date.now();
         const fixTypesSet = fixTypes ? new Set(fixTypes) : null;
         const resolvedFilename = path.resolve(cwd, filePath || "__placeholder__.js");
-        const config = configs.getConfig(resolvedFilename);
-
-        const fixer = getFixerForFixTypes(fix, fixTypesSet, config);
+        const configs = await this.#configLoader.loadConfigArrayForFile(resolvedFilename);
+        const configStatus = configs?.getConfigStatus(resolvedFilename) ?? "unconfigured";
 
         // Clear the last used config arrays.
-        if (resolvedFilename && await this.isPathIgnored(resolvedFilename)) {
+        if (resolvedFilename && configStatus !== "matched") {
             const shouldWarnIgnored = typeof warnIgnored === "boolean" ? warnIgnored : constructorWarnIgnored;
 
             if (shouldWarnIgnored) {
-                const configStatus = configs.getConfigStatus(resolvedFilename);
-
                 results.push(createIgnoreResult(resolvedFilename, cwd, configStatus));
             }
         } else {
 
+            const config = configs.getConfig(resolvedFilename);
+            const fixer = getFixerForFixTypes(fix, fixTypesSet, config);
+
             // Do lint.
             results.push(verifyText({
                 text: code,
@@ -1271,7 +1046,14 @@ class ESLint {
         }
         const options = privateMembers.get(this).options;
         const absolutePath = path.resolve(options.cwd, filePath);
-        const configs = await calculateConfigArray(this, options);
+        const configs = await this.#configLoader.loadConfigArrayForFile(absolutePath);
+
+        if (!configs) {
+            const error = new Error("Could not find config file.");
+
+            error.messageTemplate = "config-file-missing";
+            throw error;
+        }
 
         return configs.getConfig(absolutePath);
     }
@@ -1279,14 +1061,22 @@ class ESLint {
     /**
      * Finds the config file being used by this instance based on the options
      * passed to the constructor.
+     * @param {string} [filePath] The path of the file to find the config file for.
      * @returns {Promise<string|undefined>} The path to the config file being used or
      *      `undefined` if no config file is being used.
      */
-    async findConfigFile() {
+    findConfigFile(filePath) {
         const options = privateMembers.get(this).options;
-        const { configFilePath } = await locateConfigFileToUse(options, this.hasFlag("unstable_ts_config"));
 
-        return configFilePath;
+        /*
+         * Because the new config lookup scheme skips the current directory
+         * and looks into the parent directories, we need to use a placeholder
+         * directory to ensure the file in cwd is checked.
+         */
+        const fakeCwd = path.join(options.cwd, "__placeholder__");
+
+        return this.#configLoader.findConfigFileForPath(filePath ?? fakeCwd)
+            .catch(() => void 0);
     }
 
     /**
diff --git a/lib/shared/flags.js b/lib/shared/flags.js
index 9c66efe85..464835b05 100644
--- a/lib/shared/flags.js
+++ b/lib/shared/flags.js
@@ -10,6 +10,7 @@
  */
 const activeFlags = new Map([
     ["test_only", "Used only for testing."],
+    ["unstable_config_lookup_from_file", "Look up eslint.config.js from the file being linted."],
     ["unstable_ts_config", "Enable TypeScript configuration files."]
 ]);
 
diff --git a/package.json b/package.json
index 35c35900b..2f861be4a 100644
--- a/package.json
+++ b/package.json
@@ -89,9 +89,9 @@
     "@eslint/eslintrc": "^3.1.0",
     "@eslint/js": "9.11.1",
     "@eslint/plugin-kit": "^0.2.0",
+    "@humanfs/node": "^0.16.5",
     "@humanwhocodes/module-importer": "^1.0.1",
     "@humanwhocodes/retry": "^0.3.0",
-    "@nodelib/fs.walk": "^1.2.8",
     "@types/estree": "^1.0.6",
     "@types/json-schema": "^7.0.15",
     "ajv": "^6.12.4",
@@ -111,7 +111,6 @@
     "ignore": "^5.2.0",
     "imurmurhash": "^0.1.4",
     "is-glob": "^4.0.0",
-    "is-path-inside": "^3.0.3",
     "json-stable-stringify-without-jsonify": "^1.0.1",
     "lodash.merge": "^4.6.2",
     "minimatch": "^3.1.2",
diff --git a/tests/fixtures/config-lookup-ignores-2/eslint.config.cjs b/tests/fixtures/config-lookup-ignores-2/eslint.config.cjs
new file mode 100644
index 000000000..9670fe4f1
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores-2/eslint.config.cjs
@@ -0,0 +1,11 @@
+let x;
+module.exports = [
+    {
+        ignores: ["subdir3"]
+    },
+    {
+        rules: {
+            "no-unused-vars": "warn"
+        }
+    }
+];
diff --git a/tests/fixtures/config-lookup-ignores-2/subdir1/1.js b/tests/fixtures/config-lookup-ignores-2/subdir1/1.js
new file mode 100644
index 000000000..5a845d262
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores-2/subdir1/1.js
@@ -0,0 +1 @@
+let foo;
diff --git a/tests/fixtures/config-lookup-ignores-2/subdir2/2.js b/tests/fixtures/config-lookup-ignores-2/subdir2/2.js
new file mode 100644
index 000000000..7ca74ee8c
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores-2/subdir2/2.js
@@ -0,0 +1 @@
+let bar;
diff --git a/tests/fixtures/config-lookup-ignores-2/subdir3/3.js b/tests/fixtures/config-lookup-ignores-2/subdir3/3.js
new file mode 100644
index 000000000..972eff9f3
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores-2/subdir3/3.js
@@ -0,0 +1 @@
+let baz;
diff --git a/tests/fixtures/config-lookup-ignores-2/subdir3/eslint.config.mjs b/tests/fixtures/config-lookup-ignores-2/subdir3/eslint.config.mjs
new file mode 100644
index 000000000..01ac256d7
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores-2/subdir3/eslint.config.mjs
@@ -0,0 +1,5 @@
+export default {
+    rules: {
+        "no-unused-vars": "error"
+    }
+}
diff --git a/tests/fixtures/config-lookup-ignores/eslint.config.cjs b/tests/fixtures/config-lookup-ignores/eslint.config.cjs
new file mode 100644
index 000000000..3168dfe75
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores/eslint.config.cjs
@@ -0,0 +1,5 @@
+module.exports = [
+    {
+        ignores: ["subdir*/"]
+    }
+];
diff --git a/tests/fixtures/config-lookup-ignores/subdir1/eslint.config.mjs b/tests/fixtures/config-lookup-ignores/subdir1/eslint.config.mjs
new file mode 100644
index 000000000..7761383ca
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores/subdir1/eslint.config.mjs
@@ -0,0 +1,9 @@
+let foo;
+export default [
+    {
+        files: ['*.mjs'],
+        rules: {
+            "no-unused-vars": "error"
+        }
+    }
+];
diff --git a/tests/fixtures/config-lookup-ignores/subdir2/foo.js b/tests/fixtures/config-lookup-ignores/subdir2/foo.js
new file mode 100644
index 000000000..1ac74b421
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores/subdir2/foo.js
@@ -0,0 +1 @@
+console.log("hi")
diff --git a/tests/fixtures/config-lookup-ignores/subdir3/subsubdir/eslint.config.mjs b/tests/fixtures/config-lookup-ignores/subdir3/subsubdir/eslint.config.mjs
new file mode 100644
index 000000000..7761383ca
--- /dev/null
+++ b/tests/fixtures/config-lookup-ignores/subdir3/subsubdir/eslint.config.mjs
@@ -0,0 +1,9 @@
+let foo;
+export default [
+    {
+        files: ['*.mjs'],
+        rules: {
+            "no-unused-vars": "error"
+        }
+    }
+];
diff --git a/tests/fixtures/lookup-from-file/code.js b/tests/fixtures/lookup-from-file/code.js
new file mode 100644
index 000000000..822e4b3d1
--- /dev/null
+++ b/tests/fixtures/lookup-from-file/code.js
@@ -0,0 +1,2 @@
+// intentional unused variable
+const foo = 1;
diff --git a/tests/fixtures/lookup-from-file/eslint.config.js b/tests/fixtures/lookup-from-file/eslint.config.js
new file mode 100644
index 000000000..74b9f068d
--- /dev/null
+++ b/tests/fixtures/lookup-from-file/eslint.config.js
@@ -0,0 +1,7 @@
+module.exports = [{
+    ignores: ["eslint.config.js"]
+}, {
+    rules: {
+        "no-unused-vars": "error"
+    }
+}];
diff --git a/tests/fixtures/lookup-from-file/subdir/code.js b/tests/fixtures/lookup-from-file/subdir/code.js
new file mode 100644
index 000000000..44713e02f
--- /dev/null
+++ b/tests/fixtures/lookup-from-file/subdir/code.js
@@ -0,0 +1,2 @@
+// intentional unused variable
+const bar = 2;
diff --git a/tests/fixtures/lookup-from-file/subdir/eslint.config.js b/tests/fixtures/lookup-from-file/subdir/eslint.config.js
new file mode 100644
index 000000000..0ee41a377
--- /dev/null
+++ b/tests/fixtures/lookup-from-file/subdir/eslint.config.js
@@ -0,0 +1,7 @@
+module.exports = [{
+    ignores: ["eslint.config.js"]
+}, {
+    rules: {
+        "no-unused-vars": "warn"
+    }
+}];
diff --git a/tests/fixtures/no-config-file/foo.js b/tests/fixtures/no-config-file/foo.js
new file mode 100644
index 000000000..3918c74e4
--- /dev/null
+++ b/tests/fixtures/no-config-file/foo.js
@@ -0,0 +1 @@
+"use strict";
diff --git a/tests/fixtures/subdir-only-config/subdir/eslint.config.mjs b/tests/fixtures/subdir-only-config/subdir/eslint.config.mjs
new file mode 100644
index 000000000..7761383ca
--- /dev/null
+++ b/tests/fixtures/subdir-only-config/subdir/eslint.config.mjs
@@ -0,0 +1,9 @@
+let foo;
+export default [
+    {
+        files: ['*.mjs'],
+        rules: {
+            "no-unused-vars": "error"
+        }
+    }
+];
diff --git a/tests/lib/cli.js b/tests/lib/cli.js
index bc89a9309..945a103ad 100644
--- a/tests/lib/cli.js
+++ b/tests/lib/cli.js
@@ -1938,6 +1938,21 @@ describe("cli", () => {
                 });
 
             });
+
+            describe("unstable_config_lookup_from_file", () => {
+
+                const flag = "unstable_config_lookup_from_file";
+
+                it("should throw an error when text is passed and no config file is found", async () => {
+
+                    await stdAssert.rejects(
+                        () => cli.execute(`--flag ${flag} --stdin --stdin-filename /foo.js"`, "var foo = 'bar';", true),
+                        /Could not find config file/u
+                    );
+
+                });
+
+            });
         });
     });
 
diff --git a/tests/lib/eslint/eslint.config.js b/tests/lib/eslint/eslint.config.js
index 6b389dc67..a9e2b1b1e 100644
--- a/tests/lib/eslint/eslint.config.js
+++ b/tests/lib/eslint/eslint.config.js
@@ -1,4 +1,4 @@
-"use strict";
+/* eslint strict: off -- config used for testing only */
 
 module.exports = {
     rules: {
diff --git a/tests/lib/eslint/eslint.js b/tests/lib/eslint/eslint.js
index af8809139..f900e2d4b 100644
--- a/tests/lib/eslint/eslint.js
+++ b/tests/lib/eslint/eslint.js
@@ -4,12 +4,12 @@
  * @author Toru Nagashima
  */
 
+"use strict";
+
 /**
  * @import { ESLintOptions } from '../../../lib/eslint/eslint.js';
  */
 
-"use strict";
-
 //------------------------------------------------------------------------------
 // Requirements
 //------------------------------------------------------------------------------
@@ -133,6 +133,10 @@ describe("ESLint", () => {
         shell.cp("-r", "./tests/fixtures/.", fixtureDir);
     });
 
+    after(() => {
+        shell.rm("-r", fixtureDir);
+    });
+
     beforeEach(() => {
         ({ ESLint } = require("../../../lib/eslint/eslint"));
         sinon.stub(process, "emitWarning").withArgs(sinon.match.any, "ESLintIgnoreWarning").returns();
@@ -143,1825 +147,1942 @@ describe("ESLint", () => {
         sinon.restore();
     });
 
-    after(() => {
-        shell.rm("-r", fixtureDir);
-    });
-
-    describe("ESLint constructor function", () => {
+    [
+        [],
+        ["unstable_config_lookup_from_file"]
+    ].forEach(flags => {
 
-        it("should have a static property indicating the configType being used", () => {
-            assert.strictEqual(ESLint.configType, "flat");
-        });
+        describe("ESLint constructor function", () => {
 
-        it("the default value of 'options.cwd' should be the current working directory.", async () => {
-            process.chdir(__dirname);
-            try {
-                const engine = new ESLint();
-                const results = await engine.lintFiles("eslint.js");
+            it("should have a static property indicating the configType being used", () => {
+                assert.strictEqual(ESLint.configType, "flat");
+            });
 
-                assert.strictEqual(path.dirname(results[0].filePath), __dirname);
-            } finally {
-                process.chdir(originalDir);
-            }
-        });
+            it("the default value of 'options.cwd' should be the current working directory.", async () => {
+                process.chdir(__dirname);
+                try {
+                    const engine = new ESLint({ flags });
+                    const results = await engine.lintFiles("eslint.js");
 
-        it("should normalize 'options.cwd'.", async () => {
-            const cwd = getFixturePath("example-app3");
-            const engine = new ESLint({
-                cwd: `${cwd}${path.sep}foo${path.sep}..`, // `<cwd>/foo/..` should be normalized to `<cwd>`
-                overrideConfigFile: true,
-                overrideConfig: {
-                    plugins: {
-                        test: require(path.join(cwd, "node_modules", "eslint-plugin-test"))
-                    },
-                    rules: {
-                        "test/report-cwd": "error"
-                    }
+                    assert.strictEqual(path.dirname(results[0].filePath), __dirname);
+                } finally {
+                    process.chdir(originalDir);
                 }
             });
-            const results = await engine.lintText("");
 
-            assert.strictEqual(results[0].messages[0].ruleId, "test/report-cwd");
-            assert.strictEqual(results[0].messages[0].message, cwd);
+            it("should normalize 'options.cwd'.", async () => {
+                const cwd = getFixturePath("example-app3");
+                const engine = new ESLint({
+                    flags,
+                    cwd: `${cwd}${path.sep}foo${path.sep}..`, // `<cwd>/foo/..` should be normalized to `<cwd>`
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        plugins: {
+                            test: require(path.join(cwd, "node_modules", "eslint-plugin-test"))
+                        },
+                        rules: {
+                            "test/report-cwd": "error"
+                        }
+                    }
+                });
+                const results = await engine.lintText("");
 
-            const formatter = await engine.loadFormatter("cwd");
+                assert.strictEqual(results[0].messages[0].ruleId, "test/report-cwd");
+                assert.strictEqual(results[0].messages[0].message, cwd);
 
-            assert.strictEqual(formatter.format(results), cwd);
-        });
+                const formatter = await engine.loadFormatter("cwd");
 
-        // https://github.com/eslint/eslint/issues/2380
-        it("should not modify baseConfig when format is specified", () => {
-            const customBaseConfig = { root: true };
+                assert.strictEqual(formatter.format(results), cwd);
+            });
 
-            new ESLint({ baseConfig: customBaseConfig }); // eslint-disable-line no-new -- Check for argument side effects
+            // https://github.com/eslint/eslint/issues/2380
+            it("should not modify baseConfig when format is specified", () => {
+                const customBaseConfig = { root: true };
 
-            assert.deepStrictEqual(customBaseConfig, { root: true });
-        });
+                new ESLint({ baseConfig: customBaseConfig, flags }); // eslint-disable-line no-new -- Check for argument side effects
 
-        it("should throw readable messages if removed options are present", () => {
-            assert.throws(
-                () => new ESLint({
-                    cacheFile: "",
-                    configFile: "",
-                    envs: [],
-                    globals: [],
-                    ignorePath: ".gitignore",
-                    ignorePattern: [],
-                    parser: "",
-                    parserOptions: {},
-                    rules: {},
-                    plugins: [],
-                    reportUnusedDisableDirectives: "error"
-                }),
-                new RegExp(escapeStringRegExp([
-                    "Invalid Options:",
-                    "- Unknown options: cacheFile, configFile, envs, globals, ignorePath, ignorePattern, parser, parserOptions, rules, reportUnusedDisableDirectives"
-                ].join("\n")), "u")
-            );
-        });
+                assert.deepStrictEqual(customBaseConfig, { root: true });
+            });
 
-        it("should throw readable messages if wrong type values are given to options", () => {
-            assert.throws(
-                () => new ESLint({
-                    allowInlineConfig: "",
-                    baseConfig: "",
-                    cache: "",
-                    cacheLocation: "",
-                    cwd: "foo",
-                    errorOnUnmatchedPattern: "",
-                    fix: "",
-                    fixTypes: ["xyz"],
-                    globInputPaths: "",
-                    ignore: "",
-                    ignorePatterns: "",
-                    overrideConfig: "",
-                    overrideConfigFile: "",
-                    plugins: "",
-                    warnIgnored: "",
-                    ruleFilter: ""
-                }),
-                new RegExp(escapeStringRegExp([
-                    "Invalid Options:",
-                    "- 'allowInlineConfig' must be a boolean.",
-                    "- 'baseConfig' must be an object or null.",
-                    "- 'cache' must be a boolean.",
-                    "- 'cacheLocation' must be a non-empty string.",
-                    "- 'cwd' must be an absolute path.",
-                    "- 'errorOnUnmatchedPattern' must be a boolean.",
-                    "- 'fix' must be a boolean or a function.",
-                    "- 'fixTypes' must be an array of any of \"directive\", \"problem\", \"suggestion\", and \"layout\".",
-                    "- 'globInputPaths' must be a boolean.",
-                    "- 'ignore' must be a boolean.",
-                    "- 'ignorePatterns' must be an array of non-empty strings or null.",
-                    "- 'overrideConfig' must be an object or null.",
-                    "- 'overrideConfigFile' must be a non-empty string, null, or true.",
-                    "- 'plugins' must be an object or null.",
-                    "- 'warnIgnored' must be a boolean.",
-                    "- 'ruleFilter' must be a function."
-                ].join("\n")), "u")
-            );
-        });
+            it("should throw readable messages if removed options are present", () => {
+                assert.throws(
+                    () => new ESLint({
+                        flags,
+                        cacheFile: "",
+                        configFile: "",
+                        envs: [],
+                        globals: [],
+                        ignorePath: ".gitignore",
+                        ignorePattern: [],
+                        parser: "",
+                        parserOptions: {},
+                        rules: {},
+                        plugins: [],
+                        reportUnusedDisableDirectives: "error"
+                    }),
+                    new RegExp(escapeStringRegExp([
+                        "Invalid Options:",
+                        "- Unknown options: cacheFile, configFile, envs, globals, ignorePath, ignorePattern, parser, parserOptions, rules, reportUnusedDisableDirectives"
+                    ].join("\n")), "u")
+                );
+            });
 
-        it("should throw readable messages if 'ignorePatterns' is not an array of non-empty strings.", () => {
-            const invalidIgnorePatterns = [
-                () => {},
-                false,
-                {},
-                "",
-                "foo",
-                [[]],
-                [() => {}],
-                [false],
-                [{}],
-                [""],
-                ["foo", ""],
-                ["foo", "", "bar"],
-                ["foo", false, "bar"]
-            ];
-
-            invalidIgnorePatterns.forEach(ignorePatterns => {
+            it("should throw readable messages if wrong type values are given to options", () => {
                 assert.throws(
-                    () => new ESLint({ ignorePatterns }),
+                    () => new ESLint({
+                        flags,
+                        allowInlineConfig: "",
+                        baseConfig: "",
+                        cache: "",
+                        cacheLocation: "",
+                        cwd: "foo",
+                        errorOnUnmatchedPattern: "",
+                        fix: "",
+                        fixTypes: ["xyz"],
+                        globInputPaths: "",
+                        ignore: "",
+                        ignorePatterns: "",
+                        overrideConfig: "",
+                        overrideConfigFile: "",
+                        plugins: "",
+                        warnIgnored: "",
+                        ruleFilter: ""
+                    }),
                     new RegExp(escapeStringRegExp([
                         "Invalid Options:",
-                        "- 'ignorePatterns' must be an array of non-empty strings or null."
+                        "- 'allowInlineConfig' must be a boolean.",
+                        "- 'baseConfig' must be an object or null.",
+                        "- 'cache' must be a boolean.",
+                        "- 'cacheLocation' must be a non-empty string.",
+                        "- 'cwd' must be an absolute path.",
+                        "- 'errorOnUnmatchedPattern' must be a boolean.",
+                        "- 'fix' must be a boolean or a function.",
+                        "- 'fixTypes' must be an array of any of \"directive\", \"problem\", \"suggestion\", and \"layout\".",
+                        "- 'globInputPaths' must be a boolean.",
+                        "- 'ignore' must be a boolean.",
+                        "- 'ignorePatterns' must be an array of non-empty strings or null.",
+                        "- 'overrideConfig' must be an object or null.",
+                        "- 'overrideConfigFile' must be a non-empty string, null, or true.",
+                        "- 'plugins' must be an object or null.",
+                        "- 'warnIgnored' must be a boolean.",
+                        "- 'ruleFilter' must be a function."
                     ].join("\n")), "u")
                 );
             });
-        });
 
-        it("should throw readable messages if 'plugins' option contains empty key", () => {
-            assert.throws(
-                () => new ESLint({
-                    plugins: {
-                        "eslint-plugin-foo": {},
-                        "eslint-plugin-bar": {},
-                        "": {}
-                    }
-                }),
-                new RegExp(escapeStringRegExp([
-                    "Invalid Options:",
-                    "- 'plugins' must not include an empty string."
-                ].join("\n")), "u")
-            );
-        });
+            it("should throw readable messages if 'ignorePatterns' is not an array of non-empty strings.", () => {
+                const invalidIgnorePatterns = [
+                    () => { },
+                    false,
+                    {},
+                    "",
+                    "foo",
+                    [[]],
+                    [() => { }],
+                    [false],
+                    [{}],
+                    [""],
+                    ["foo", ""],
+                    ["foo", "", "bar"],
+                    ["foo", false, "bar"]
+                ];
+
+                invalidIgnorePatterns.forEach(ignorePatterns => {
+                    assert.throws(
+                        () => new ESLint({ ignorePatterns, flags }),
+                        new RegExp(escapeStringRegExp([
+                            "Invalid Options:",
+                            "- 'ignorePatterns' must be an array of non-empty strings or null."
+                        ].join("\n")), "u")
+                    );
+                });
+            });
+
+            it("should throw readable messages if 'plugins' option contains empty key", () => {
+                assert.throws(
+                    () => new ESLint({
+                        flags,
+                        plugins: {
+                            "eslint-plugin-foo": {},
+                            "eslint-plugin-bar": {},
+                            "": {}
+                        }
+                    }),
+                    new RegExp(escapeStringRegExp([
+                        "Invalid Options:",
+                        "- 'plugins' must not include an empty string."
+                    ].join("\n")), "u")
+                );
+            });
 
-        it("should warn if .eslintignore file is present", async () => {
-            const cwd = getFixturePath("ignored-paths");
+            it("should warn if .eslintignore file is present", async () => {
+                const cwd = getFixturePath("ignored-paths");
 
-            sinon.restore();
-            const processStub = sinon.stub(process, "emitWarning");
+                sinon.restore();
+                const processStub = sinon.stub(process, "emitWarning");
 
-            // eslint-disable-next-line no-new -- for testing purpose only
-            new ESLint({ cwd });
+                // eslint-disable-next-line no-new -- for testing purpose only
+                new ESLint({ cwd, flags });
 
-            assert.strictEqual(processStub.callCount, 1, "calls `process.emitWarning()` once");
-            assert.strictEqual(processStub.getCall(0).args[0], "The \".eslintignore\" file is no longer supported. Switch to using the \"ignores\" property in \"eslint.config.js\": https://eslint.org/docs/latest/use/configure/migration-guide#ignoring-files");
-            assert.strictEqual(processStub.getCall(0).args[1], "ESLintIgnoreWarning");
+                assert.strictEqual(processStub.callCount, 1, "calls `process.emitWarning()` once");
+                assert.strictEqual(processStub.getCall(0).args[0], "The \".eslintignore\" file is no longer supported. Switch to using the \"ignores\" property in \"eslint.config.js\": https://eslint.org/docs/latest/use/configure/migration-guide#ignoring-files");
+                assert.strictEqual(processStub.getCall(0).args[1], "ESLintIgnoreWarning");
 
-            processStub.restore();
+                processStub.restore();
+            });
         });
-    });
 
-    describe("hasFlag", () => {
+        describe("hasFlag", () => {
 
-        /** @type {InstanceType<ESLint>} */
-        let eslint;
+            /** @type {InstanceType<ESLint>} */
+            let eslint;
 
-        it("should return true if the flag is present and active", () => {
-            eslint = new ESLint({ cwd: getFixturePath(), flags: ["test_only"] });
+            it("should return true if the flag is present and active", () => {
+                eslint = new ESLint({ cwd: getFixturePath(), flags: ["test_only"] });
 
-            assert.strictEqual(eslint.hasFlag("test_only"), true);
-        });
+                assert.strictEqual(eslint.hasFlag("test_only"), true);
+            });
 
-        it("should throw an error if the flag is inactive", () => {
+            it("should throw an error if the flag is inactive", () => {
 
-            assert.throws(() => {
-                eslint = new ESLint({ cwd: getFixturePath(), flags: ["test_only_old"] });
-            }, /The flag 'test_only_old' is inactive/u);
+                assert.throws(() => {
+                    eslint = new ESLint({ cwd: getFixturePath(), flags: ["test_only_old"] });
+                }, /The flag 'test_only_old' is inactive/u);
 
-        });
+            });
 
-        it("should return false if the flag is not present", () => {
-            eslint = new ESLint({ cwd: getFixturePath() });
+            it("should return false if the flag is not present", () => {
+                eslint = new ESLint({ cwd: getFixturePath() });
 
-            assert.strictEqual(eslint.hasFlag("x_feature"), false);
+                assert.strictEqual(eslint.hasFlag("x_feature"), false);
+            });
         });
-    });
 
-    describe("lintText()", () => {
+        describe("lintText()", () => {
 
-        /** @type {InstanceType<ESLint>} */
-        let eslint;
+            /** @type {InstanceType<ESLint>} */
+            let eslint;
 
-        it("should report the total and per file errors when using local cwd eslint.config.js", async () => {
-            eslint = new ESLint({
-                cwd: __dirname
-            });
-
-            const results = await eslint.lintText("var foo = 'bar';");
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 4);
-            assert.strictEqual(results[0].messages[0].ruleId, "no-var");
-            assert.strictEqual(results[0].messages[1].ruleId, "no-unused-vars");
-            assert.strictEqual(results[0].messages[2].ruleId, "quotes");
-            assert.strictEqual(results[0].messages[3].ruleId, "eol-last");
-            assert.strictEqual(results[0].fixableErrorCount, 3);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 2);
-            assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
-            assert.strictEqual(results[0].usedDeprecatedRules[1].ruleId, "eol-last");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should report the total and per file errors when using local cwd eslint.config.js", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: __dirname
+                });
 
-        it("should report the total and per file warnings when using local cwd .eslintrc", async () => {
-            eslint = new ESLint({
-                overrideConfig: {
-                    rules: {
-                        quotes: 1,
-                        "no-var": 1,
-                        "eol-last": 1,
-                        "no-unused-vars": 1
-                    }
-                },
-                overrideConfigFile: true
-            });
-            const results = await eslint.lintText("var foo = 'bar';");
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 4);
-            assert.strictEqual(results[0].messages[0].ruleId, "no-var");
-            assert.strictEqual(results[0].messages[1].ruleId, "no-unused-vars");
-            assert.strictEqual(results[0].messages[2].ruleId, "quotes");
-            assert.strictEqual(results[0].messages[3].ruleId, "eol-last");
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 3);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 2);
-            assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
-            assert.strictEqual(results[0].usedDeprecatedRules[1].ruleId, "eol-last");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                const results = await eslint.lintText("var foo = 'bar';");
 
-        it("should report one message when using specific config file", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: "fixtures/configurations/quotes-error.js",
-                cwd: getFixturePath("..")
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 4);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-var");
+                assert.strictEqual(results[0].messages[1].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[2].ruleId, "quotes");
+                assert.strictEqual(results[0].messages[3].ruleId, "eol-last");
+                assert.strictEqual(results[0].fixableErrorCount, 3);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 2);
+                assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
+                assert.strictEqual(results[0].usedDeprecatedRules[1].ruleId, "eol-last");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintText("var foo = 'bar';");
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].ruleId, "quotes");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 1);
-            assert.strictEqual(results[0].fixableErrorCount, 1);
-            assert.strictEqual(results[0].warningCount, 0);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 1);
-            assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should report the total and per file warnings when using local cwd .eslintrc", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfig: {
+                        rules: {
+                            quotes: 1,
+                            "no-var": 1,
+                            "eol-last": 1,
+                            "no-unused-vars": 1
+                        }
+                    },
+                    overrideConfigFile: true
+                });
+                const results = await eslint.lintText("var foo = 'bar';");
 
-        it("should report the filename when passed in", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath()
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 4);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-var");
+                assert.strictEqual(results[0].messages[1].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[2].ruleId, "quotes");
+                assert.strictEqual(results[0].messages[3].ruleId, "eol-last");
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 3);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 2);
+                assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
+                assert.strictEqual(results[0].usedDeprecatedRules[1].ruleId, "eol-last");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const options = { filePath: "test.js" };
-            const results = await eslint.lintText("var foo = 'bar';", options);
 
-            assert.strictEqual(results[0].filePath, getFixturePath("test.js"));
-        });
+            it("should report one message when using specific config file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: "fixtures/configurations/quotes-error.js",
+                    cwd: getFixturePath("..")
+                });
+                const results = await eslint.lintText("var foo = 'bar';");
 
-        it("should return a warning when given a filename by --stdin-filename in excluded files list if warnIgnored is true", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
-            });
-
-            const options = { filePath: "fixtures/passing.js", warnIgnored: true };
-            const results = await eslint.lintText("var bar = foo;", options);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
-            assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "quotes");
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].errorCount, 1);
+                assert.strictEqual(results[0].fixableErrorCount, 1);
+                assert.strictEqual(results[0].warningCount, 0);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 1);
+                assert.strictEqual(results[0].usedDeprecatedRules[0].ruleId, "quotes");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-        it("should return a warning when given a filename without a matching config by --stdin-filename if warnIgnored is true", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: true
-            });
-
-            const options = { filePath: "fixtures/file.ts", warnIgnored: true };
-            const results = await eslint.lintText("type foo = { bar: string };", options);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("file.ts"));
-            assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because no matching configuration was supplied.");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should report the filename when passed in", async () => {
+                eslint = new ESLint({
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath()
+                });
+                const options = { filePath: "test.js" };
+                const results = await eslint.lintText("var foo = 'bar';", options);
 
-        it("should return a warning when given a filename outside the base path by --stdin-filename if warnIgnored is true", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(),
-                overrideConfigFile: true
-            });
-
-            const options = { filePath: "../file.js", warnIgnored: true };
-            const results = await eslint.lintText("var bar = foo;", options);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("../file.js"));
-            assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because outside of base path.");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                assert.strictEqual(results[0].filePath, getFixturePath("test.js"));
+            });
 
-        it("should return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false, but lintText warnIgnored is true", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
-                warnIgnored: false
-            });
-
-            const options = { filePath: "fixtures/passing.js", warnIgnored: true };
-            const results = await eslint.lintText("var bar = foo;", options);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
-            assert.strictEqual(results[0].messages[0].severity, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should return a warning when given a filename by --stdin-filename in excluded files list if warnIgnored is true", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
+                });
 
-        it("should not return a warning when given a filename by --stdin-filename in excluded files list if warnIgnored is false", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
+                const options = { filePath: "fixtures/passing.js", warnIgnored: true };
+                const results = await eslint.lintText("var bar = foo;", options);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 1);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const options = {
-                filePath: "fixtures/passing.js",
-                warnIgnored: false
-            };
 
-            // intentional parsing error
-            const results = await eslint.lintText("va r bar = foo;", options);
+            it("should return a warning when given a filename without a matching config by --stdin-filename if warnIgnored is true", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: true
+                });
 
-            // should not report anything because the file is ignored
-            assert.strictEqual(results.length, 0);
-        });
+                const options = { filePath: "fixtures/file.ts", warnIgnored: true };
+                const results = await eslint.lintText("type foo = { bar: string };", options);
 
-        it("should not return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
-                warnIgnored: false
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("file.ts"));
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].messages[0].message, "File ignored because no matching configuration was supplied.");
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 1);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const options = { filePath: "fixtures/passing.js" };
-            const results = await eslint.lintText("var bar = foo;", options);
 
-            // should not report anything because the warning is suppressed
-            assert.strictEqual(results.length, 0);
-        });
+            it("should return a warning when given a filename outside the base path by --stdin-filename if warnIgnored is true", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(),
+                    overrideConfigFile: true
+                });
 
-        it("should show excluded file warnings by default", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
+                const options = { filePath: "../file.js", warnIgnored: true };
+                const results = await eslint.lintText("var bar = foo;", options);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("../file.js"));
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].messages[0].message, "File ignored because outside of base path.");
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 1);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const options = { filePath: "fixtures/passing.js" };
-            const results = await eslint.lintText("var bar = foo;", options);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-        });
+            it("should return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false, but lintText warnIgnored is true", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
+                    warnIgnored: false
+                });
 
-        it("should return a message when given a filename by --stdin-filename in excluded files list and ignore is off", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                ignore: false,
-                overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
-                overrideConfig: {
-                    rules: {
-                        "no-undef": 2
-                    }
-                }
+                const options = { filePath: "fixtures/passing.js", warnIgnored: true };
+                const results = await eslint.lintText("var bar = foo;", options);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 1);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].usedDeprecatedRules.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const options = { filePath: "fixtures/passing.js" };
-            const results = await eslint.lintText("var bar = foo;", options);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
-            assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-            assert.strictEqual(results[0].messages[0].severity, 2);
-            assert.strictEqual(results[0].messages[0].output, void 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should not return a warning when given a filename by --stdin-filename in excluded files list if warnIgnored is false", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
+                });
+                const options = {
+                    filePath: "fixtures/passing.js",
+                    warnIgnored: false
+                };
 
-        it("should return a message and fixed text when in fix mode", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2
-                    }
-                },
-                ignore: false,
-                cwd: getFixturePath()
+                // intentional parsing error
+                const results = await eslint.lintText("va r bar = foo;", options);
+
+                // should not report anything because the file is ignored
+                assert.strictEqual(results.length, 0);
             });
-            const options = { filePath: "passing.js" };
-            const results = await eslint.lintText("var bar = foo", options);
 
-            assert.deepStrictEqual(results, [
-                {
-                    filePath: getFixturePath("passing.js"),
-                    messages: [],
-                    suppressedMessages: [],
-                    errorCount: 0,
-                    warningCount: 0,
-                    fatalErrorCount: 0,
-                    fixableErrorCount: 0,
-                    fixableWarningCount: 0,
-                    output: "var bar = foo;",
-                    usedDeprecatedRules: [
-                        {
-                            ruleId: "semi",
-                            replacedBy: []
-                        }
-                    ]
-                }
-            ]);
-        });
+            it("should not return a warning when given a filename by --stdin-filename in excluded files list if constructor warnIgnored is false", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
+                    warnIgnored: false
+                });
+                const options = { filePath: "fixtures/passing.js" };
+                const results = await eslint.lintText("var bar = foo;", options);
 
-        it("should return a message and omit fixed text when in fix mode and fixes aren't done", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        "no-undef": 2
-                    }
-                },
-                ignore: false,
-                cwd: getFixturePath()
+                // should not report anything because the warning is suppressed
+                assert.strictEqual(results.length, 0);
             });
-            const options = { filePath: "passing.js" };
-            const results = await eslint.lintText("var bar = foo", options);
 
-            assert.deepStrictEqual(results, [
-                {
-                    filePath: getFixturePath("passing.js"),
-                    messages: [
-                        {
-                            ruleId: "no-undef",
-                            severity: 2,
-                            messageId: "undef",
-                            message: "'foo' is not defined.",
-                            line: 1,
-                            column: 11,
-                            endLine: 1,
-                            endColumn: 14,
-                            nodeType: "Identifier"
-                        }
-                    ],
-                    suppressedMessages: [],
-                    errorCount: 1,
-                    warningCount: 0,
-                    fatalErrorCount: 0,
-                    fixableErrorCount: 0,
-                    fixableWarningCount: 0,
-                    source: "var bar = foo",
-                    usedDeprecatedRules: []
-                }
-            ]);
-        });
+            it("should throw an error when there's no config file for a stdin file", () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: "/"
+                });
+                const options = { filePath: "fixtures/passing.js" };
 
-        it("should not delete code if there is a syntax error after trying to autofix.", async () => {
-            eslint = eslintWithPlugins({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        "example/make-syntax-error": "error"
-                    }
-                },
-                ignore: false,
-                cwd: getFixturePath(".")
+                return assert.rejects(() => eslint.lintText("var bar = foo;", options), /Could not find config file/u);
             });
-            const options = { filePath: "test.js" };
-            const results = await eslint.lintText("var bar = foo", options);
 
-            assert.deepStrictEqual(results, [
-                {
-                    filePath: getFixturePath("test.js"),
-                    messages: [
-                        {
-                            ruleId: null,
-                            fatal: true,
-                            severity: 2,
-                            message: "Parsing error: Unexpected token is",
-                            line: 1,
-                            column: 19,
-                            nodeType: null
-                        }
-                    ],
-                    suppressedMessages: [],
-                    errorCount: 1,
-                    warningCount: 0,
-                    fatalErrorCount: 1,
-                    fixableErrorCount: 0,
-                    fixableWarningCount: 0,
-                    output: "var bar = foothis is a syntax error.",
-                    usedDeprecatedRules: []
-                }
-            ]);
-        });
+            it("should show excluded file warnings by default", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js"
+                });
+                const options = { filePath: "fixtures/passing.js" };
+                const results = await eslint.lintText("var bar = foo;", options);
 
-        it("should not crash even if there are any syntax error since the first time.", async () => {
-            eslint = eslintWithPlugins({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        "example/make-syntax-error": "error"
-                    }
-                },
-                ignore: false,
-                cwd: getFixturePath()
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
             });
-            const options = { filePath: "test.js" };
-            const results = await eslint.lintText("var bar =", options);
 
-            assert.deepStrictEqual(results, [
-                {
-                    filePath: getFixturePath("test.js"),
-                    messages: [
-                        {
-                            ruleId: null,
-                            fatal: true,
-                            severity: 2,
-                            message: "Parsing error: Unexpected token",
-                            line: 1,
-                            column: 10,
-                            nodeType: null
+            it("should return a message when given a filename by --stdin-filename in excluded files list and ignore is off", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    ignore: false,
+                    overrideConfigFile: "fixtures/eslint.config-with-ignores.js",
+                    overrideConfig: {
+                        rules: {
+                            "no-undef": 2
                         }
-                    ],
-                    suppressedMessages: [],
-                    errorCount: 1,
-                    warningCount: 0,
-                    fatalErrorCount: 1,
-                    fixableErrorCount: 0,
-                    fixableWarningCount: 0,
-                    source: "var bar =",
-                    usedDeprecatedRules: []
-                }
-            ]);
-        });
-
-        it("should return source code of file in `source` property when errors are present", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { semi: 2 }
-                }
-            });
-            const results = await eslint.lintText("var foo = 'bar'");
-
-            assert.strictEqual(results[0].source, "var foo = 'bar'");
-        });
+                    }
+                });
+                const options = { filePath: "fixtures/passing.js" };
+                const results = await eslint.lintText("var bar = foo;", options);
 
-        it("should return source code of file in `source` property when warnings are present", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { semi: 1 }
-                }
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("passing.js"));
+                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].messages[0].output, void 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintText("var foo = 'bar'");
-
-            assert.strictEqual(results[0].source, "var foo = 'bar'");
-        });
 
+            it("should return a message and fixed text when in fix mode", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    },
+                    ignore: false,
+                    cwd: getFixturePath()
+                });
+                const options = { filePath: "passing.js" };
+                const results = await eslint.lintText("var bar = foo", options);
 
-        it("should not return a `source` property when no errors or warnings are present", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { semi: 2 }
-                }
+                assert.deepStrictEqual(results, [
+                    {
+                        filePath: getFixturePath("passing.js"),
+                        messages: [],
+                        suppressedMessages: [],
+                        errorCount: 0,
+                        warningCount: 0,
+                        fatalErrorCount: 0,
+                        fixableErrorCount: 0,
+                        fixableWarningCount: 0,
+                        output: "var bar = foo;",
+                        usedDeprecatedRules: [
+                            {
+                                ruleId: "semi",
+                                replacedBy: []
+                            }
+                        ]
+                    }
+                ]);
             });
-            const results = await eslint.lintText("var foo = 'bar';");
 
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].source, void 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should return a message and omit fixed text when in fix mode and fixes aren't done", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            "no-undef": 2
+                        }
+                    },
+                    ignore: false,
+                    cwd: getFixturePath()
+                });
+                const options = { filePath: "passing.js" };
+                const results = await eslint.lintText("var bar = foo", options);
 
-        it("should not return a `source` property when fixes are applied", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2,
-                        "no-unused-vars": 2
+                assert.deepStrictEqual(results, [
+                    {
+                        filePath: getFixturePath("passing.js"),
+                        messages: [
+                            {
+                                ruleId: "no-undef",
+                                severity: 2,
+                                messageId: "undef",
+                                message: "'foo' is not defined.",
+                                line: 1,
+                                column: 11,
+                                endLine: 1,
+                                endColumn: 14,
+                                nodeType: "Identifier"
+                            }
+                        ],
+                        suppressedMessages: [],
+                        errorCount: 1,
+                        warningCount: 0,
+                        fatalErrorCount: 0,
+                        fixableErrorCount: 0,
+                        fixableWarningCount: 0,
+                        source: "var bar = foo",
+                        usedDeprecatedRules: []
                     }
-                }
+                ]);
             });
-            const results = await eslint.lintText("var msg = 'hi' + foo\n");
 
-            assert.strictEqual(results[0].source, void 0);
-            assert.strictEqual(results[0].output, "var msg = 'hi' + foo;\n");
-        });
+            it("should not delete code if there is a syntax error after trying to autofix.", async () => {
+                eslint = eslintWithPlugins({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            "example/make-syntax-error": "error"
+                        }
+                    },
+                    ignore: false,
+                    cwd: getFixturePath(".")
+                });
+                const options = { filePath: "test.js" };
+                const results = await eslint.lintText("var bar = foo", options);
 
-        it("should return a `source` property when a parsing error has occurred", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { eqeqeq: 2 }
-                }
+                assert.deepStrictEqual(results, [
+                    {
+                        filePath: getFixturePath("test.js"),
+                        messages: [
+                            {
+                                ruleId: null,
+                                fatal: true,
+                                severity: 2,
+                                message: "Parsing error: Unexpected token is",
+                                line: 1,
+                                column: 19,
+                                nodeType: null
+                            }
+                        ],
+                        suppressedMessages: [],
+                        errorCount: 1,
+                        warningCount: 0,
+                        fatalErrorCount: 1,
+                        fixableErrorCount: 0,
+                        fixableWarningCount: 0,
+                        output: "var bar = foothis is a syntax error.",
+                        usedDeprecatedRules: []
+                    }
+                ]);
             });
-            const results = await eslint.lintText("var bar = foothis is a syntax error.\n return bar;");
 
-            assert.deepStrictEqual(results, [
-                {
-                    filePath: "<text>",
-                    messages: [
-                        {
-                            ruleId: null,
-                            fatal: true,
-                            severity: 2,
-                            message: "Parsing error: Unexpected token is",
-                            line: 1,
-                            column: 19,
-                            nodeType: null
+            it("should not crash even if there are any syntax error since the first time.", async () => {
+                eslint = eslintWithPlugins({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            "example/make-syntax-error": "error"
                         }
-                    ],
-                    suppressedMessages: [],
-                    errorCount: 1,
-                    warningCount: 0,
-                    fatalErrorCount: 1,
-                    fixableErrorCount: 0,
-                    fixableWarningCount: 0,
-                    source: "var bar = foothis is a syntax error.\n return bar;",
-                    usedDeprecatedRules: []
-                }
-            ]);
-        });
+                    },
+                    ignore: false,
+                    cwd: getFixturePath()
+                });
+                const options = { filePath: "test.js" };
+                const results = await eslint.lintText("var bar =", options);
 
-        // https://github.com/eslint/eslint/issues/5547
-        it("should respect default ignore rules (ignoring node_modules), even with --no-ignore", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(),
-                ignore: false
+                assert.deepStrictEqual(results, [
+                    {
+                        filePath: getFixturePath("test.js"),
+                        messages: [
+                            {
+                                ruleId: null,
+                                fatal: true,
+                                severity: 2,
+                                message: "Parsing error: Unexpected token",
+                                line: 1,
+                                column: 10,
+                                nodeType: null
+                            }
+                        ],
+                        suppressedMessages: [],
+                        errorCount: 1,
+                        warningCount: 0,
+                        fatalErrorCount: 1,
+                        fixableErrorCount: 0,
+                        fixableWarningCount: 0,
+                        source: "var bar =",
+                        usedDeprecatedRules: []
+                    }
+                ]);
             });
-            const results = await eslint.lintText("var bar = foo;", { filePath: "node_modules/passing.js", warnIgnored: true });
-            const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("node_modules/passing.js"));
-            assert.strictEqual(results[0].messages[0].message, expectedMsg);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should return source code of file in `source` property when errors are present", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { semi: 2 }
+                    }
+                });
+                const results = await eslint.lintText("var foo = 'bar'");
 
-        it("should warn when deprecated rules are found in a config", async () => {
-            eslint = new ESLint({
-                cwd: originalDir,
-                overrideConfigFile: "tests/fixtures/cli-engine/deprecated-rule-config/eslint.config.js"
+                assert.strictEqual(results[0].source, "var foo = 'bar'");
             });
-            const [result] = await eslint.lintText("foo");
 
-            assert.deepStrictEqual(
-                result.usedDeprecatedRules,
-                [{ ruleId: "indent-legacy", replacedBy: ["indent"] }]
-            );
-        });
+            it("should return source code of file in `source` property when warnings are present", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { semi: 1 }
+                    }
+                });
+                const results = await eslint.lintText("var foo = 'bar'");
 
-        it("should throw if eslint.config.js file is not present", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("..")
+                assert.strictEqual(results[0].source, "var foo = 'bar'");
             });
-            await assert.rejects(() => eslint.lintText("var foo = 'bar';"), /Could not find config file/u);
-        });
 
-        it("should not throw if eslint.config.js file is not present and overrideConfigFile is `true`", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: true
-            });
-            await eslint.lintText("var foo = 'bar';");
-        });
 
-        it("should not throw if eslint.config.js file is not present and overrideConfigFile is path to a config file", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/configurations/quotes-error.js"
-            });
-            await eslint.lintText("var foo = 'bar';");
-        });
+            it("should not return a `source` property when no errors or warnings are present", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { semi: 2 }
+                    }
+                });
+                const results = await eslint.lintText("var foo = 'bar';");
 
-        it("should throw if overrideConfigFile is path to a file that doesn't exist", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(""),
-                overrideConfigFile: "does-not-exist.js"
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].source, void 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            await assert.rejects(() => eslint.lintText("var foo = 'bar';"), { code: "ENOENT" });
-        });
-
-        it("should throw if non-string value is given to 'code' parameter", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintText(100), /'code' must be a string/u);
-        });
 
-        it("should throw if non-object value is given to 'options' parameter", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintText("var a = 0", "foo.js"), /'options' must be an object, null, or undefined/u);
-        });
-
-        it("should throw if 'options' argument contains unknown key", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintText("var a = 0", { filename: "foo.js" }), /'options' must not include the unknown option\(s\): filename/u);
-        });
-
-        it("should throw if non-string value is given to 'options.filePath' option", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintText("var a = 0", { filePath: "" }), /'options.filePath' must be a non-empty string or undefined/u);
-        });
-
-        it("should throw if non-boolean value is given to 'options.warnIgnored' option", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintText("var a = 0", { warnIgnored: "" }), /'options.warnIgnored' must be a boolean or undefined/u);
-        });
+            it("should not return a `source` property when fixes are applied", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2,
+                            "no-unused-vars": 2
+                        }
+                    }
+                });
+                const results = await eslint.lintText("var msg = 'hi' + foo\n");
 
-        it("should work with config file that exports a promise", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("promise-config")
+                assert.strictEqual(results[0].source, void 0);
+                assert.strictEqual(results[0].output, "var msg = 'hi' + foo;\n");
             });
-            const results = await eslint.lintText("var foo = \"bar\";");
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].severity, 2);
-            assert.strictEqual(results[0].messages[0].ruleId, "quotes");
-        });
 
-        describe("Alternate config files", () => {
-
-            it("should find eslint.config.mjs when present", async () => {
+            it("should return a `source` property when a parsing error has occurred", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { eqeqeq: 2 }
+                    }
+                });
+                const results = await eslint.lintText("var bar = foothis is a syntax error.\n return bar;");
 
-                const cwd = getFixturePath("mjs-config");
+                assert.deepStrictEqual(results, [
+                    {
+                        filePath: "<text>",
+                        messages: [
+                            {
+                                ruleId: null,
+                                fatal: true,
+                                severity: 2,
+                                message: "Parsing error: Unexpected token is",
+                                line: 1,
+                                column: 19,
+                                nodeType: null
+                            }
+                        ],
+                        suppressedMessages: [],
+                        errorCount: 1,
+                        warningCount: 0,
+                        fatalErrorCount: 1,
+                        fixableErrorCount: 0,
+                        fixableWarningCount: 0,
+                        source: "var bar = foothis is a syntax error.\n return bar;",
+                        usedDeprecatedRules: []
+                    }
+                ]);
+            });
 
+            // https://github.com/eslint/eslint/issues/5547
+            it("should respect default ignore rules (ignoring node_modules), even with --no-ignore", async () => {
                 eslint = new ESLint({
-                    cwd
+                    flags,
+                    cwd: getFixturePath(),
+                    ignore: false
                 });
-
-                const results = await eslint.lintText("foo");
+                const results = await eslint.lintText("var bar = foo;", { filePath: "node_modules/passing.js", warnIgnored: true });
+                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
 
                 assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-
+                assert.strictEqual(results[0].filePath, getFixturePath("node_modules/passing.js"));
+                assert.strictEqual(results[0].messages[0].message, expectedMsg);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should find eslint.config.cjs when present", async () => {
-
-                const cwd = getFixturePath("cjs-config");
-
+            it("should warn when deprecated rules are found in a config", async () => {
                 eslint = new ESLint({
-                    cwd
+                    flags,
+                    cwd: originalDir,
+                    overrideConfigFile: "tests/fixtures/cli-engine/deprecated-rule-config/eslint.config.js"
                 });
+                const [result] = await eslint.lintText("foo");
 
-                const results = await eslint.lintText("foo");
+                assert.deepStrictEqual(
+                    result.usedDeprecatedRules,
+                    [{ ruleId: "indent-legacy", replacedBy: ["indent"] }]
+                );
+            });
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should throw if eslint.config.js file is not present", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath("..")
+                });
+                await assert.rejects(() => eslint.lintText("var foo = 'bar';"), /Could not find config file/u);
+            });
 
+            it("should throw if eslint.config.js file is not present even if overrideConfig was passed", async () => {
+                eslint = new ESLint({
+                    cwd: getFixturePath(".."),
+                    overrideConfig: {
+                        rules: {
+                            "no-unused-vars": 2
+                        }
+                    }
+                });
+                await assert.rejects(() => eslint.lintText("var foo = 'bar';"), /Could not find config file/u);
             });
 
-            it("should favor eslint.config.js when eslint.config.mjs and eslint.config.cjs are present", async () => {
+            it("should not throw if eslint.config.js file is not present and overrideConfigFile is `true`", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: true
+                });
+                await eslint.lintText("var foo = 'bar';");
+            });
 
-                const cwd = getFixturePath("js-mjs-cjs-config");
+            it("should not throw if eslint.config.js file is not present and overrideConfigFile is path to a config file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(".."),
+                    overrideConfigFile: "fixtures/configurations/quotes-error.js"
+                });
+                await eslint.lintText("var foo = 'bar';");
+            });
 
+            it("should throw if overrideConfigFile is path to a file that doesn't exist", async () => {
                 eslint = new ESLint({
-                    cwd
+                    flags,
+                    cwd: getFixturePath(""),
+                    overrideConfigFile: "does-not-exist.js"
                 });
+                await assert.rejects(() => eslint.lintText("var foo = 'bar';"), { code: "ENOENT" });
+            });
 
-                const results = await eslint.lintText("foo");
+            it("should throw if non-string value is given to 'code' parameter", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintText(100), /'code' must be a string/u);
+            });
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 0);
+            it("should throw if non-object value is given to 'options' parameter", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintText("var a = 0", "foo.js"), /'options' must be an object, null, or undefined/u);
+            });
+
+            it("should throw if 'options' argument contains unknown key", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintText("var a = 0", { filename: "foo.js" }), /'options' must not include the unknown option\(s\): filename/u);
             });
 
-            it("should favor eslint.config.mjs when eslint.config.cjs is present", async () => {
+            it("should throw if non-string value is given to 'options.filePath' option", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintText("var a = 0", { filePath: "" }), /'options.filePath' must be a non-empty string or undefined/u);
+            });
 
-                const cwd = getFixturePath("mjs-cjs-config");
+            it("should throw if non-boolean value is given to 'options.warnIgnored' option", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintText("var a = 0", { warnIgnored: "" }), /'options.warnIgnored' must be a boolean or undefined/u);
+            });
 
+            it("should work with config file that exports a promise", async () => {
                 eslint = new ESLint({
-                    cwd
+                    flags,
+                    cwd: getFixturePath("promise-config")
                 });
-
-                const results = await eslint.lintText("foo");
+                const results = await eslint.lintText('var foo = "bar";');
 
                 assert.strictEqual(results.length, 1);
                 assert.strictEqual(results[0].messages.length, 1);
                 assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                assert.strictEqual(results[0].messages[0].ruleId, "quotes");
             });
-        });
 
-        describe("TypeScript config files", () => {
+            describe("Alternate config files", () => {
 
-            const flags = ["unstable_ts_config"];
+                it("should find eslint.config.mjs when present", async () => {
 
-            it("should find and load eslint.config.ts when present", async () => {
+                    const cwd = getFixturePath("mjs-config");
 
-                const cwd = getFixturePath("ts-config-files", "ts");
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
+
+                    const results = await eslint.lintText("foo");
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should find eslint.config.cjs when present", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("cjs-config");
 
-            });
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-            it("should load eslint.config.ts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should favor eslint.config.js when eslint.config.mjs and eslint.config.cjs are present", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-
-            });
+                    const cwd = getFixturePath("js-mjs-cjs-config");
 
-            it("should load eslint.config.ts when we have \"type\": \"module\" in nearest `package.json`", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module");
+                    const results = await eslint.lintText("foo");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 0);
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should favor eslint.config.mjs when eslint.config.cjs is present", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("mjs-cjs-config");
+
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
+                    const results = await eslint.lintText("foo");
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                });
             });
 
-            it("should load eslint.config.ts with const enums", async () => {
+            describe("TypeScript config files", () => {
 
-                const cwd = getFixturePath("ts-config-files", "ts", "const-enums");
+                const tsFlags = ["unstable_ts_config", ...flags];
+
+                it("should find and load eslint.config.ts when present", async () => {
+
+                    const cwd = getFixturePath("ts-config-files", "ts");
+
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
+
+                    const results = await eslint.lintText("foo");
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.ts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should load eslint.config.ts with local namespace", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "local-namespace");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.ts when we have \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should allow passing a TS config file to `overrideConfigFile`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "custom-config");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags,
-                    overrideConfigFile: getFixturePath("ts-config-files", "ts", "custom-config", "eslint.custom.config.ts")
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.ts with const enums", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "ts", "const-enums");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should find and load eslint.config.mts when present", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "mts");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.ts with local namespace", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "ts", "local-namespace");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should load eslint.config.mts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "mts", "with-type-commonjs");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should allow passing a TS config file to `overrideConfigFile`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "ts", "custom-config");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags,
+                        overrideConfigFile: getFixturePath("ts-config-files", "ts", "custom-config", "eslint.custom.config.ts")
+                    });
 
-            it("should load eslint.config.mts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "mts", "with-type-module");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should find and load eslint.config.mts when present", async () => {
 
-            });
+                    const cwd = getFixturePath("ts-config-files", "mts");
+
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should find and load eslint.config.cts when present", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "cts");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.mts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "mts", "with-type-commonjs");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should load eslint.config.cts config file when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "cts", "with-type-commonjs");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should load eslint.config.mts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "mts", "with-type-module");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should load .cts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "cts", "with-type-module");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo");
+                it("should find and load eslint.config.cts when present", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "cts");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            it("should successfully load a TS config file that exports a promise", async () => {
+                    const results = await eslint.lintText("foo");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "exports-promise");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintText("foo;");
+                it("should load eslint.config.cts config file when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "cts", "with-type-commonjs");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-        });
+                    const results = await eslint.lintText("foo");
 
-        it("should pass BOM through processors", async () => {
-            eslint = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: [
-                    {
-                        files: ["**/*.myjs"],
-                        processor: {
-                            preprocess(text, filename) {
-                                return [{ text, filename }];
-                            },
-                            postprocess(messages) {
-                                return messages.flat();
-                            },
-                            supportsAutofix: true
-                        },
-                        rules: {
-                            "unicode-bom": ["error", "never"]
-                        }
-                    }
-                ],
-                cwd: path.join(fixtureDir)
-            });
-            const results = await eslint.lintText("\uFEFFvar foo = 'bar';", { filePath: "test.myjs" });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].severity, 2);
-            assert.strictEqual(results[0].messages[0].ruleId, "unicode-bom");
-        });
-    });
+                });
 
-    describe("lintFiles()", () => {
+                it("should load .cts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
 
-        /** @type {InstanceType<ESLint>} */
-        let eslint;
+                    const cwd = getFixturePath("ts-config-files", "cts", "with-type-module");
 
-        it("should use correct parser when custom parser is specified", async () => {
-            const filePath = path.resolve(__dirname, "../../fixtures/configurations/parser/custom.js");
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            eslint = new ESLint({
-                cwd: originalDir,
-                ignore: false,
-                overrideConfigFile: true,
-                overrideConfig: {
-                    languageOptions: {
-                        parser: require(filePath)
-                    }
-                }
-            });
+                    const results = await eslint.lintText("foo");
 
-            const results = await eslint.lintFiles([filePath]);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].message, "Parsing error: Boom!");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                });
 
-        it("should report zero messages when given a config file and a valid file", async () => {
-            eslint = new ESLint({
-                cwd: originalDir,
-                overrideConfigFile: "tests/fixtures/simple-valid-project/eslint.config.js"
-            });
-            const results = await eslint.lintFiles(["tests/fixtures/simple-valid-project/**/foo*.js"]);
+                it("should successfully load a TS config file that exports a promise", async () => {
 
-            assert.strictEqual(results.length, 2);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    const cwd = getFixturePath("ts-config-files", "ts", "exports-promise");
 
-        it("should handle multiple patterns with overlapping files", async () => {
-            eslint = new ESLint({
-                cwd: originalDir,
-                overrideConfigFile: "tests/fixtures/simple-valid-project/eslint.config.js"
-            });
-            const results = await eslint.lintFiles([
-                "tests/fixtures/simple-valid-project/**/foo*.js",
-                "tests/fixtures/simple-valid-project/foo.?s",
-                "tests/fixtures/simple-valid-project/{foo,src/foobar}.js"
-            ]);
+                    eslint = new ESLint({
+                        cwd,
+                        flags: tsFlags
+                    });
 
-            assert.strictEqual(results.length, 2);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    const results = await eslint.lintText("foo;");
 
-        it("should report zero messages when given a config file and a valid file and espree as parser", async () => {
-            eslint = new ESLint({
-                overrideConfig: {
-                    languageOptions: {
-                        parser: require("espree"),
-                        parserOptions: {
-                            ecmaVersion: 2021
-                        }
-                    }
-                },
-                overrideConfigFile: true
-            });
-            const results = await eslint.lintFiles(["lib/cli.js"]);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                });
 
-        it("should report zero messages when given a config file and a valid file and esprima as parser", async () => {
-            eslint = new ESLint({
-                overrideConfig: {
-                    languageOptions: {
-                        parser: require("esprima")
-                    }
-                },
-                overrideConfigFile: true,
-                ignore: false
             });
-            const results = await eslint.lintFiles(["tests/fixtures/passing.js"]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should pass BOM through processors", async () => {
+                eslint = new ESLint({
+                    overrideConfigFile: true,
+                    overrideConfig: [
+                        {
+                            files: ["**/*.myjs"],
+                            processor: {
+                                preprocess(text, filename) {
+                                    return [{ text, filename }];
+                                },
+                                postprocess(messages) {
+                                    return messages.flat();
+                                },
+                                supportsAutofix: true
+                            },
+                            rules: {
+                                "unicode-bom": ["error", "never"]
+                            }
+                        }
+                    ],
+                    cwd: path.join(fixtureDir)
+                });
+                const results = await eslint.lintText("\uFEFFvar foo = 'bar';", { filePath: "test.myjs" });
 
-        it("should throw if eslint.config.js file is not present", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("..")
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].messages[0].ruleId, "unicode-bom");
             });
-            await assert.rejects(() => eslint.lintFiles("fixtures/undef*.js"), /Could not find config file/u);
         });
 
-        it("should not throw if eslint.config.js file is not present and overrideConfigFile is `true`", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: true
-            });
-            await eslint.lintFiles("fixtures/undef*.js");
-        });
+        describe("lintFiles()", () => {
 
-        it("should not throw if eslint.config.js file is not present and overrideConfigFile is path to a config file", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(".."),
-                overrideConfigFile: "fixtures/configurations/quotes-error.js"
-            });
-            await eslint.lintFiles("fixtures/undef*.js");
-        });
+            /** @type {InstanceType<ESLint>} */
+            let eslint;
 
-        it("should throw if overrideConfigFile is path to a file that doesn't exist", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(),
-                overrideConfigFile: "does-not-exist.js"
-            });
-            await assert.rejects(() => eslint.lintFiles("undef*.js"), { code: "ENOENT" });
-        });
+            it("should use correct parser when custom parser is specified", async () => {
+                const filePath = path.resolve(__dirname, "../../fixtures/configurations/parser/custom.js");
 
-        it("should throw an error when given a config file and a valid file and invalid parser", async () => {
-            eslint = new ESLint({
-                overrideConfig: {
-                    languageOptions: {
-                        parser: "test11"
+                eslint = new ESLint({
+                    flags,
+                    cwd: originalDir,
+                    ignore: false,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        languageOptions: {
+                            parser: require(filePath)
+                        }
                     }
-                },
-                overrideConfigFile: true
-            });
-
-            await assert.rejects(async () => await eslint.lintFiles(["lib/cli.js"]), /Expected object with parse\(\) or parseForESLint\(\) method/u);
-        });
-
-        // https://github.com/eslint/eslint/issues/18407
-        it("should work in case when `fsp.readFile()` returns an object that is not an instance of Promise from this realm", async () => {
-
-            /**
-             * Promise wrapper
-             */
-            class PromiseLike {
-                constructor(promise) {
-                    this.promise = promise;
-                }
-                then(...args) {
-                    return new PromiseLike(this.promise.then(...args));
-                }
-                catch(...args) {
-                    return new PromiseLike(this.promise.catch(...args));
-                }
-                finally(...args) {
-                    return new PromiseLike(this.promise.finally(...args));
-                }
-            }
+                });
 
-            const spy = sinon.spy(
-                (...args) => new PromiseLike(fsp.readFile(...args))
-            );
+                const results = await eslint.lintFiles([filePath]);
 
-            const { ESLint: LocalESLint } = proxyquire("../../../lib/eslint/eslint", {
-                "node:fs/promises": {
-                    readFile: spy,
-                    "@noCallThru": false // allows calling other methods of `fs/promises`
-                }
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].message, "Parsing error: Boom!");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            const testDir = "tests/fixtures/simple-valid-project";
-            const expectedLintedFiles = [
-                path.resolve(testDir, "foo.js"),
-                path.resolve(testDir, "src", "foobar.js")
-            ];
+            it("should report zero messages when given a config file and a valid file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: originalDir,
+                    overrideConfigFile: "tests/fixtures/simple-valid-project/eslint.config.js"
+                });
+                const results = await eslint.lintFiles(["tests/fixtures/simple-valid-project/**/foo*.js"]);
 
-            eslint = new LocalESLint({
-                cwd: originalDir,
-                overrideConfigFile: path.resolve(testDir, "eslint.config.js")
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            const results = await eslint.lintFiles([`${testDir}/**/foo*.js`]);
-
-            assert.strictEqual(results.length, expectedLintedFiles.length);
+            it("should handle multiple patterns with overlapping files", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: originalDir,
+                    overrideConfigFile: "tests/fixtures/simple-valid-project/eslint.config.js"
+                });
+                const results = await eslint.lintFiles([
+                    "tests/fixtures/simple-valid-project/**/foo*.js",
+                    "tests/fixtures/simple-valid-project/foo.?s",
+                    "tests/fixtures/simple-valid-project/{foo,src/foobar}.js"
+                ]);
 
-            expectedLintedFiles.forEach((file, index) => {
-                assert(spy.calledWith(file), `Spy was not called with ${file}`);
-                assert.strictEqual(results[index].filePath, file);
-                assert.strictEqual(results[index].messages.length, 0);
-                assert.strictEqual(results[index].suppressedMessages.length, 0);
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-        });
-
-        describe("Overlapping searches", () => {
-            it("should not lint the same file multiple times when the file path was passed multiple times", async () => {
-                const cwd = getFixturePath();
 
+            it("should report zero messages when given a config file and a valid file and espree as parser", async () => {
                 eslint = new ESLint({
-                    cwd,
+                    flags,
+                    overrideConfig: {
+                        languageOptions: {
+                            parser: require("espree"),
+                            parserOptions: {
+                                ecmaVersion: 2021
+                            }
+                        }
+                    },
                     overrideConfigFile: true
                 });
-
-                const results = await eslint.lintFiles(["files/foo.js", "files/../files/foo.js", "files/foo.js"]);
+                const results = await eslint.lintFiles(["lib/cli.js"]);
 
                 assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
                 assert.strictEqual(results[0].messages.length, 0);
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should not lint the same file multiple times when the file path and a pattern that matches the file were passed", async () => {
-                const cwd = getFixturePath();
-
+            it("should report zero messages when given a config file and a valid file and esprima as parser", async () => {
                 eslint = new ESLint({
-                    cwd,
-                    overrideConfigFile: true
+                    flags,
+                    overrideConfig: {
+                        languageOptions: {
+                            parser: require("esprima")
+                        }
+                    },
+                    overrideConfigFile: true,
+                    ignore: false
                 });
-
-                const results = await eslint.lintFiles(["files/foo.js", "files/foo*"]);
+                const results = await eslint.lintFiles(["tests/fixtures/passing.js"]);
 
                 assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
                 assert.strictEqual(results[0].messages.length, 0);
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should not lint the same file multiple times when multiple patterns that match the file were passed", async () => {
-                const cwd = getFixturePath();
+            describe("Missing Configuration File", () => {
+
+                const workDirName = "no-config-file";
+                const workDir = path.resolve(fs.realpathSync(os.tmpdir()), "eslint/no-config");
+
+                // copy into clean area so as not to get "infected" by other config files
+                before(() => {
+
+                    shell.mkdir("-p", workDir);
+                    shell.cp("-r", `./tests/fixtures/${workDirName}`, workDir);
+                });
+
+                after(() => {
+                    shell.rm("-r", workDir);
+                });
+
+                it(`${flags}:should throw if eslint.config.js file is not present`, async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: workDir
+                    });
+                    await assert.rejects(() => eslint.lintFiles("no-config-file/*.js"), /Could not find config file/u);
+                });
+
+                it("should throw if eslint.config.js file is not present even if overrideConfig was passed", async () => {
+                    eslint = new ESLint({
+                        cwd: getFixturePath(".."),
+                        overrideConfig: {
+                            rules: {
+                                "no-unused-vars": 2
+                            }
+                        }
+                    });
+                    await assert.rejects(() => eslint.lintFiles("fixtures/undef*.js"), /Could not find config file/u);
+                });
+
+                it("should throw if eslint.config.js file is not present even if overrideConfig was passed and a file path is given", async () => {
+                    eslint = new ESLint({
+                        cwd: getFixturePath(".."),
+                        overrideConfig: {
+                            rules: {
+                                "no-unused-vars": 2
+                            }
+                        }
+                    });
+                    await assert.rejects(() => eslint.lintFiles("fixtures/undef.js"), /Could not find config file/u);
+                });
+
+                it("should not throw if eslint.config.js file is not present and overrideConfigFile is `true`", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: workDir,
+                        overrideConfigFile: true
+                    });
+                    await eslint.lintFiles("no-config-file/*.js");
+                });
+
+                it("should not throw if eslint.config.js file is not present and overrideConfigFile is path to a config file", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: workDir,
+                        overrideConfigFile: path.join(fixtureDir, "configurations/quotes-error.js")
+                    });
+                    await eslint.lintFiles("no-config-file/*.js");
+                });
+            });
+
+            it("should throw if overrideConfigFile is path to a file that doesn't exist", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(),
+                    overrideConfigFile: "does-not-exist.js"
+                });
+                await assert.rejects(() => eslint.lintFiles("undef*.js"), { code: "ENOENT" });
+            });
 
+            it("should throw an error when given a config file and a valid file and invalid parser", async () => {
                 eslint = new ESLint({
-                    cwd,
+                    flags,
+                    overrideConfig: {
+                        languageOptions: {
+                            parser: "test11"
+                        }
+                    },
                     overrideConfigFile: true
                 });
 
-                const results = await eslint.lintFiles(["files/f*.js", "files/foo*"]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
-                assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                await assert.rejects(async () => await eslint.lintFiles(["lib/cli.js"]), /Expected object with parse\(\) or parseForESLint\(\) method/u);
             });
-        });
 
-        describe("Invalid inputs", () => {
+            // https://github.com/eslint/eslint/issues/18407
+            it("should work in case when `fsp.readFile()` returns an object that is not an instance of Promise from this realm", async () => {
 
-            [
-                ["a string with a single space", " "],
-                ["an array with one empty string", [""]],
-                ["an array with two empty strings", ["", ""]],
-                ["undefined", void 0]
-            ].forEach(([name, value]) => {
+                /**
+                 * Promise wrapper
+                 */
+                class PromiseLike {
+                    constructor(promise) {
+                        this.promise = promise;
+                    }
+                    then(...args) {
+                        return new PromiseLike(this.promise.then(...args));
+                    }
+                    catch(...args) {
+                        return new PromiseLike(this.promise.catch(...args));
+                    }
+                    finally(...args) {
+                        return new PromiseLike(this.promise.finally(...args));
+                    }
+                }
 
-                it(`should throw an error when passed ${name}`, async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true
-                    });
+                const spy = sinon.spy(
+                    (...args) => new PromiseLike(fsp.readFile(...args))
+                );
 
-                    await assert.rejects(async () => await eslint.lintFiles(value), /'patterns' must be a non-empty string or an array of non-empty strings/u);
+                const { ESLint: LocalESLint } = proxyquire("../../../lib/eslint/eslint", {
+                    "node:fs/promises": {
+                        readFile: spy,
+                        "@noCallThru": false // allows calling other methods of `fs/promises`
+                    }
                 });
-            });
 
-        });
+                const testDir = "tests/fixtures/simple-valid-project";
+                const expectedLintedFiles = [
+                    path.resolve(testDir, "foo.js"),
+                    path.resolve(testDir, "src", "foobar.js")
+                ];
+
+                eslint = new LocalESLint({
+                    flags,
+                    cwd: originalDir,
+                    overrideConfigFile: path.resolve(testDir, "eslint.config.js")
+                });
+
+                const results = await eslint.lintFiles([`${testDir}/**/foo*.js`]);
 
-        describe("Normalized inputs", () => {
+                assert.strictEqual(results.length, expectedLintedFiles.length);
 
-            [
-                ["an empty string", ""],
-                ["an empty array", []]
+                expectedLintedFiles.forEach((file, index) => {
+                    assert(spy.calledWith(file), `Spy was not called with ${file}`);
+                    assert.strictEqual(results[index].filePath, file);
+                    assert.strictEqual(results[index].messages.length, 0);
+                    assert.strictEqual(results[index].suppressedMessages.length, 0);
+                });
+            });
 
-            ].forEach(([name, value]) => {
+            describe("Overlapping searches", () => {
+                it("should not lint the same file multiple times when the file path was passed multiple times", async () => {
+                    const cwd = getFixturePath();
 
-                it(`should normalize to '.' when ${name} is passed`, async () => {
                     eslint = new ESLint({
-                        ignore: false,
-                        cwd: getFixturePath("files"),
-                        overrideConfig: { files: ["**/*.js"] },
-                        overrideConfigFile: getFixturePath("eslint.config.js")
+                        flags,
+                        cwd,
+                        overrideConfigFile: true
                     });
-                    const results = await eslint.lintFiles(value);
 
-                    assert.strictEqual(results.length, 2);
-                    assert.strictEqual(results[0].filePath, getFixturePath("files/.bar.js"));
+                    const results = await eslint.lintFiles(["files/foo.js", "files/../files/foo.js", "files/foo.js"]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
                     assert.strictEqual(results[0].messages.length, 0);
-                    assert.strictEqual(results[1].filePath, getFixturePath("files/foo.js"));
-                    assert.strictEqual(results[1].messages.length, 0);
                     assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
 
-                it(`should return an empty array when ${name} is passed with passOnNoPatterns: true`, async () => {
+                it("should not lint the same file multiple times when the file path and a pattern that matches the file were passed", async () => {
+                    const cwd = getFixturePath();
+
                     eslint = new ESLint({
-                        ignore: false,
-                        cwd: getFixturePath("files"),
-                        overrideConfig: { files: ["**/*.js"] },
-                        overrideConfigFile: getFixturePath("eslint.config.js"),
-                        passOnNoPatterns: true
+                        flags,
+                        cwd,
+                        overrideConfigFile: true
                     });
-                    const results = await eslint.lintFiles(value);
 
-                    assert.strictEqual(results.length, 0);
+                    const results = await eslint.lintFiles(["files/foo.js", "files/foo*"]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-            });
 
-        });
+                it("should not lint the same file multiple times when multiple patterns that match the file were passed", async () => {
+                    const cwd = getFixturePath();
 
-        it("should report zero messages when given a directory with a .js2 file", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: getFixturePath("eslint.config.js"),
-                overrideConfig: {
-                    files: ["**/*.js2"]
-                }
-            });
-            const results = await eslint.lintFiles([getFixturePath("files/foo.js2")]);
+                    eslint = new ESLint({
+                        flags,
+                        cwd,
+                        overrideConfigFile: true
+                    });
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    const results = await eslint.lintFiles(["files/f*.js", "files/foo*"]);
 
-        it("should report zero messages when given a directory with a .js and a .js2 file", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath(".."),
-                overrideConfig: { files: ["**/*.js", "**/*.js2"] },
-                overrideConfigFile: getFixturePath("eslint.config.js")
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.resolve(cwd, "files/foo.js"));
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
             });
-            const results = await eslint.lintFiles(["fixtures/files/"]);
 
-            assert.strictEqual(results.length, 3);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            describe("Invalid inputs", () => {
 
-        // https://github.com/eslint/eslint/issues/18550
-        it("should skip files with non-standard extensions when they're matched only by a '*' files pattern", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("files"),
-                overrideConfig: { files: ["*"] },
-                overrideConfigFile: true
-            });
-            const results = await eslint.lintFiles(["."]);
+                [
+                    ["a string with a single space", " "],
+                    ["an array with one empty string", [""]],
+                    ["an array with two empty strings", ["", ""]],
+                    ["undefined", void 0]
+                ].forEach(([name, value]) => {
+
+                    it(`should throw an error when passed ${name}`, async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true
+                        });
 
-            assert.strictEqual(results.length, 2);
-            assert(
-                results.every(result => /^\.[cm]?js$/u.test(path.extname(result.filePath))),
-                "File with a non-standard extension was linted"
-            );
-        });
+                        await assert.rejects(async () => await eslint.lintFiles(value), /'patterns' must be a non-empty string or an array of non-empty strings/u);
+                    });
+                });
 
-        // https://github.com/eslint/eslint/issues/16413
-        it("should find files and report zero messages when given a parent directory with a .js", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath("example-app/subdir")
             });
-            const results = await eslint.lintFiles(["../*.js"]);
 
-            assert.strictEqual(results.length, 2);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[1].suppressedMessages.length, 0);
-        });
+            describe("Normalized inputs", () => {
 
-        // https://github.com/eslint/eslint/issues/16038
-        it("should allow files patterns with '..' inside", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath("dots-in-files")
-            });
-            const results = await eslint.lintFiles(["."]);
+                [
+                    ["an empty string", ""],
+                    ["an empty array", []]
+
+                ].forEach(([name, value]) => {
+
+                    it(`should normalize to '.' when ${name} is passed`, async () => {
+                        eslint = new ESLint({
+                            flags,
+                            ignore: false,
+                            cwd: getFixturePath("files"),
+                            overrideConfig: { files: ["**/*.js"] },
+                            overrideConfigFile: getFixturePath("eslint.config.js")
+                        });
+                        const results = await eslint.lintFiles(value);
+
+                        assert.strictEqual(results.length, 2);
+                        assert.strictEqual(results[0].filePath, getFixturePath("files/.bar.js"));
+                        assert.strictEqual(results[0].messages.length, 0);
+                        assert.strictEqual(results[1].filePath, getFixturePath("files/foo.js"));
+                        assert.strictEqual(results[1].messages.length, 0);
+                        assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    });
 
-            assert.strictEqual(results.length, 2);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].filePath, getFixturePath("dots-in-files/a..b.js"));
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    it(`should return an empty array when ${name} is passed with passOnNoPatterns: true`, async () => {
+                        eslint = new ESLint({
+                            flags,
+                            ignore: false,
+                            cwd: getFixturePath("files"),
+                            overrideConfig: { files: ["**/*.js"] },
+                            overrideConfigFile: getFixturePath("eslint.config.js"),
+                            passOnNoPatterns: true
+                        });
+                        const results = await eslint.lintFiles(value);
 
+                        assert.strictEqual(results.length, 0);
+                    });
+                });
 
-        // https://github.com/eslint/eslint/issues/16299
-        it("should only find files in the subdir1 directory when given a directory name", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath("example-app2")
             });
-            const results = await eslint.lintFiles(["subdir1"]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].filePath, getFixturePath("example-app2/subdir1/a.js"));
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should report zero messages when given a directory with a .js2 file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: getFixturePath("eslint.config.js"),
+                    overrideConfig: {
+                        files: ["**/*.js2"]
+                    }
+                });
+                const results = await eslint.lintFiles([getFixturePath("files/foo.js2")]);
 
-        // https://github.com/eslint/eslint/issues/14742
-        it("should run", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("{curly-path}", "server")
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintFiles(["src/**/*.{js,json}"]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].ruleId, "no-console");
-            assert.strictEqual(
-                results[0].filePath,
-                getFixturePath("{curly-path}/server/src/two.js")
-            );
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+            it("should report zero messages when given a directory with a .js and a .js2 file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath(".."),
+                    overrideConfig: { files: ["**/*.js", "**/*.js2"] },
+                    overrideConfigFile: getFixturePath("eslint.config.js")
+                });
+                const results = await eslint.lintFiles(["fixtures/files/"]);
 
-        it("should work with config file that exports a promise", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath("promise-config")
+                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintFiles(["a*.js"]);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, getFixturePath("promise-config", "a.js"));
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].severity, 2);
-            assert.strictEqual(results[0].messages[0].ruleId, "quotes");
-        });
 
-        // https://github.com/eslint/eslint/issues/16265
-        describe("Dot files in searches", () => {
-
-            it("should find dot files in current directory when a . pattern is used", async () => {
+            // https://github.com/eslint/eslint/issues/18550
+            it("should skip files with non-standard extensions when they're matched only by a '*' files pattern", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("dot-files")
+                    flags,
+                    cwd: getFixturePath("files"),
+                    overrideConfig: { files: ["*"] },
+                    overrideConfigFile: true
                 });
                 const results = await eslint.lintFiles(["."]);
 
-                assert.strictEqual(results.length, 3);
-                assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-                assert.strictEqual(results[1].messages.length, 0);
-                assert.strictEqual(results[1].filePath, getFixturePath("dot-files/.c.js"));
-                assert.strictEqual(results[1].suppressedMessages.length, 0);
-                assert.strictEqual(results[2].messages.length, 0);
-                assert.strictEqual(results[2].filePath, getFixturePath("dot-files/b.js"));
-                assert.strictEqual(results[2].suppressedMessages.length, 0);
+                assert.strictEqual(results.length, 2);
+                assert(
+                    results.every(result => /^\.[cm]?js$/u.test(path.extname(result.filePath))),
+                    "File with a non-standard extension was linted"
+                );
             });
 
-            it("should find dot files in current directory when a *.js pattern is used", async () => {
+            // https://github.com/eslint/eslint/issues/16413
+            it("should find files and report zero messages when given a parent directory with a .js", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("dot-files")
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath("example-app/subdir")
                 });
-                const results = await eslint.lintFiles(["*.js"]);
+                const results = await eslint.lintFiles(["../*.js"]);
 
-                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results.length, 2);
                 assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
                 assert.strictEqual(results[1].messages.length, 0);
-                assert.strictEqual(results[1].filePath, getFixturePath("dot-files/.c.js"));
                 assert.strictEqual(results[1].suppressedMessages.length, 0);
-                assert.strictEqual(results[2].messages.length, 0);
-                assert.strictEqual(results[2].filePath, getFixturePath("dot-files/b.js"));
-                assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
 
-            it("should find dot files in current directory when a .a.js pattern is used", async () => {
+            // https://github.com/eslint/eslint/issues/16038
+            it("should allow files patterns with '..' inside", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("dot-files")
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath("dots-in-files")
                 });
-                const results = await eslint.lintFiles([".a.js"]);
+                const results = await eslint.lintFiles(["."]);
 
-                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results.length, 2);
                 assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
+                assert.strictEqual(results[0].filePath, getFixturePath("dots-in-files/a..b.js"));
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-        });
 
-        // https://github.com/eslint/eslint/issues/16275
-        describe("Glob patterns without matches", () => {
 
-            it("should throw an error for a missing pattern when combined with a found pattern", async () => {
+            // https://github.com/eslint/eslint/issues/16299
+            it("should only find files in the subdir1 directory when given a directory name", async () => {
                 eslint = new ESLint({
+                    flags,
                     ignore: false,
                     cwd: getFixturePath("example-app2")
                 });
+                const results = await eslint.lintFiles(["subdir1"]);
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir1", "doesnotexist/*.js"]);
-                }, /No files matching 'doesnotexist\/\*\.js' were found/u);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].filePath, getFixturePath("example-app2/subdir1/a.js"));
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should throw an error for an ignored directory pattern when combined with a found pattern", async () => {
+            // https://github.com/eslint/eslint/issues/14742
+            it("should run", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("example-app2"),
-                    overrideConfig: {
-                        ignores: ["subdir2"]
-                    }
+                    flags,
+                    cwd: getFixturePath("{curly-path}", "server")
                 });
+                const results = await eslint.lintFiles(["src/**/*.{js,json}"]);
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
-                }, /All files matched by 'subdir2\/\*\.js' are ignored/u);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-console");
+                assert.strictEqual(
+                    results[0].filePath,
+                    getFixturePath("{curly-path}/server/src/two.js")
+                );
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should throw an error for an ignored file pattern when combined with a found pattern", async () => {
+            it("should work with config file that exports a promise", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("example-app2"),
-                    overrideConfig: {
-                        ignores: ["subdir2/*.js"]
-                    }
+                    flags,
+                    cwd: getFixturePath("promise-config")
                 });
+                const results = await eslint.lintFiles(["a*.js"]);
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
-                }, /All files matched by 'subdir2\/\*\.js' are ignored/u);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, getFixturePath("promise-config", "a.js"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].messages[0].ruleId, "quotes");
             });
 
-            it("should always throw an error for the first unmatched file pattern", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("example-app2"),
-                    overrideConfig: {
-                        ignores: ["subdir1/*.js", "subdir2/*.js"]
-                    }
+            // https://github.com/eslint/eslint/issues/16265
+            describe("Dot files in searches", () => {
+
+                it("should find dot files in current directory when a . pattern is used", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("dot-files")
+                    });
+                    const results = await eslint.lintFiles(["."]);
+
+                    assert.strictEqual(results.length, 3);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[1].messages.length, 0);
+                    assert.strictEqual(results[1].filePath, getFixturePath("dot-files/.c.js"));
+                    assert.strictEqual(results[1].suppressedMessages.length, 0);
+                    assert.strictEqual(results[2].messages.length, 0);
+                    assert.strictEqual(results[2].filePath, getFixturePath("dot-files/b.js"));
+                    assert.strictEqual(results[2].suppressedMessages.length, 0);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["doesnotexist1/*.js", "doesnotexist2/*.js"]);
-                }, /No files matching 'doesnotexist1\/\*\.js' were found/u);
+                it("should find dot files in current directory when a *.js pattern is used", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("dot-files")
+                    });
+                    const results = await eslint.lintFiles(["*.js"]);
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["doesnotexist1/*.js", "subdir1/*.js"]);
-                }, /No files matching 'doesnotexist1\/\*\.js' were found/u);
+                    assert.strictEqual(results.length, 3);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[1].messages.length, 0);
+                    assert.strictEqual(results[1].filePath, getFixturePath("dot-files/.c.js"));
+                    assert.strictEqual(results[1].suppressedMessages.length, 0);
+                    assert.strictEqual(results[2].messages.length, 0);
+                    assert.strictEqual(results[2].filePath, getFixturePath("dot-files/b.js"));
+                    assert.strictEqual(results[2].suppressedMessages.length, 0);
+                });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir1/*.js", "doesnotexist1/*.js"]);
-                }, /All files matched by 'subdir1\/\*\.js' are ignored/u);
+                it("should find dot files in current directory when a .a.js pattern is used", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("dot-files")
+                    });
+                    const results = await eslint.lintFiles([".a.js"]);
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
-                }, /All files matched by 'subdir1\/\*\.js' are ignored/u);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("dot-files/.a.js"));
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
             });
 
-            it("should not throw an error for an ignored file pattern when errorOnUnmatchedPattern is false", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("example-app2"),
-                    overrideConfig: {
-                        ignores: ["subdir2/*.js"]
-                    },
-                    errorOnUnmatchedPattern: false
+            // https://github.com/eslint/eslint/issues/16275
+            describe("Glob patterns without matches", () => {
+
+                it("should throw an error for a missing pattern when combined with a found pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        ignore: false,
+                        cwd: getFixturePath("example-app2")
+                    });
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir1", "doesnotexist/*.js"]);
+                    }, /No files matching 'doesnotexist\/\*\.js' were found/u);
                 });
 
-                const results = await eslint.lintFiles(["subdir2/*.js"]);
+                it("should throw an error for an ignored directory pattern when combined with a found pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("example-app2"),
+                        overrideConfig: {
+                            ignores: ["subdir2"]
+                        }
+                    });
 
-                assert.strictEqual(results.length, 0);
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
+                    }, /All files matched by 'subdir2\/\*\.js' are ignored/u);
+                });
+
+                it("should throw an error for an ignored file pattern when combined with a found pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("example-app2"),
+                        overrideConfig: {
+                            ignores: ["subdir2/*.js"]
+                        }
+                    });
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
+                    }, /All files matched by 'subdir2\/\*\.js' are ignored/u);
+                });
+
+                it("should always throw an error for the first unmatched file pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("example-app2"),
+                        overrideConfig: {
+                            ignores: ["subdir1/*.js", "subdir2/*.js"]
+                        }
+                    });
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["doesnotexist1/*.js", "doesnotexist2/*.js"]);
+                    }, /No files matching 'doesnotexist1\/\*\.js' were found/u);
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["doesnotexist1/*.js", "subdir1/*.js"]);
+                    }, /No files matching 'doesnotexist1\/\*\.js' were found/u);
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir1/*.js", "doesnotexist1/*.js"]);
+                    }, /All files matched by 'subdir1\/\*\.js' are ignored/u);
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir1/*.js", "subdir2/*.js"]);
+                    }, /All files matched by 'subdir1\/\*\.js' are ignored/u);
+                });
+
+                it("should not throw an error for an ignored file pattern when errorOnUnmatchedPattern is false", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("example-app2"),
+                        overrideConfig: {
+                            ignores: ["subdir2/*.js"]
+                        },
+                        errorOnUnmatchedPattern: false
+                    });
+
+                    const results = await eslint.lintFiles(["subdir2/*.js"]);
+
+                    assert.strictEqual(results.length, 0);
+                });
+
+                it("should not throw an error for a non-existing file pattern when errorOnUnmatchedPattern is false", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("example-app2"),
+                        errorOnUnmatchedPattern: false
+                    });
+
+                    const results = await eslint.lintFiles(["doesexist/*.js"]);
+
+                    assert.strictEqual(results.length, 0);
+                });
             });
 
-            it("should not throw an error for a non-existing file pattern when errorOnUnmatchedPattern is false", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("example-app2"),
-                    errorOnUnmatchedPattern: false
+            // https://github.com/eslint/eslint/issues/16260
+            describe("Globbing based on configs", () => {
+                it("should report zero messages when given a directory with a .js and config file specifying a subdirectory", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        ignore: false,
+                        cwd: getFixturePath("shallow-glob")
+                    });
+                    const results = await eslint.lintFiles(["target-dir"]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
+
+                it("should glob for .jsx file in a subdirectory of the passed-in directory and not glob for any other patterns", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        ignore: false,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            files: ["subdir/**/*.jsx", "target-dir/*.js"],
+                            languageOptions: {
+                                parserOptions: {
+                                    jsx: true
+                                }
+                            }
+                        },
+                        cwd: getFixturePath("shallow-glob")
+                    });
+                    const results = await eslint.lintFiles(["subdir/subsubdir"]);
+
+                    assert.strictEqual(results.length, 2);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("shallow-glob/subdir/subsubdir/broken.js"));
+                    assert(results[0].messages[0].fatal, "Fatal error expected.");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[1].filePath, getFixturePath("shallow-glob/subdir/subsubdir/plain.jsx"));
+                    assert.strictEqual(results[1].messages.length, 0);
+                    assert.strictEqual(results[1].suppressedMessages.length, 0);
                 });
 
-                const results = await eslint.lintFiles(["doesexist/*.js"]);
-
-                assert.strictEqual(results.length, 0);
-            });
-        });
+                it("should glob for all files in subdir when passed-in on the command line with a partial matching glob", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        ignore: false,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            files: ["s*/subsubdir/*.jsx", "target-dir/*.js"],
+                            languageOptions: {
+                                parserOptions: {
+                                    jsx: true
+                                }
+                            }
+                        },
+                        cwd: getFixturePath("shallow-glob")
+                    });
+                    const results = await eslint.lintFiles(["subdir"]);
 
-        // https://github.com/eslint/eslint/issues/16260
-        describe("Globbing based on configs", () => {
-            it("should report zero messages when given a directory with a .js and config file specifying a subdirectory", async () => {
-                eslint = new ESLint({
-                    ignore: false,
-                    cwd: getFixturePath("shallow-glob")
+                    assert.strictEqual(results.length, 3);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert(results[0].messages[0].fatal, "Fatal error expected.");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[1].messages.length, 1);
+                    assert(results[0].messages[0].fatal, "Fatal error expected.");
+                    assert.strictEqual(results[1].suppressedMessages.length, 0);
+                    assert.strictEqual(results[2].messages.length, 0);
+                    assert.strictEqual(results[2].suppressedMessages.length, 0);
                 });
-                const results = await eslint.lintFiles(["target-dir"]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should glob for .jsx file in a subdirectory of the passed-in directory and not glob for any other patterns", async () => {
+            it("should report zero messages when given a '**' pattern with a .js and a .js2 file", async () => {
                 eslint = new ESLint({
+                    flags,
                     ignore: false,
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        files: ["subdir/**/*.jsx", "target-dir/*.js"],
-                        languageOptions: {
-                            parserOptions: {
-                                jsx: true
-                            }
-                        }
-                    },
-                    cwd: getFixturePath("shallow-glob")
-                });
-                const results = await eslint.lintFiles(["subdir/subsubdir"]);
-
-                assert.strictEqual(results.length, 2);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("shallow-glob/subdir/subsubdir/broken.js"));
-                assert(results[0].messages[0].fatal, "Fatal error expected.");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-                assert.strictEqual(results[1].filePath, getFixturePath("shallow-glob/subdir/subsubdir/plain.jsx"));
-                assert.strictEqual(results[1].messages.length, 0);
-                assert.strictEqual(results[1].suppressedMessages.length, 0);
-            });
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfig: { files: ["**/*.js", "**/*.js2"] },
+                    overrideConfigFile: getFixturePath("eslint.config.js")
 
-            it("should glob for all files in subdir when passed-in on the command line with a partial matching glob", async () => {
-                eslint = new ESLint({
-                    ignore: false,
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        files: ["s*/subsubdir/*.jsx", "target-dir/*.js"],
-                        languageOptions: {
-                            parserOptions: {
-                                jsx: true
-                            }
-                        }
-                    },
-                    cwd: getFixturePath("shallow-glob")
                 });
-                const results = await eslint.lintFiles(["subdir"]);
+                const results = await eslint.lintFiles(["fixtures/files/*"]);
 
                 assert.strictEqual(results.length, 3);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert(results[0].messages[0].fatal, "Fatal error expected.");
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[2].messages.length, 0);
                 assert.strictEqual(results[0].suppressedMessages.length, 0);
-                assert.strictEqual(results[1].messages.length, 1);
-                assert(results[0].messages[0].fatal, "Fatal error expected.");
                 assert.strictEqual(results[1].suppressedMessages.length, 0);
-                assert.strictEqual(results[2].messages.length, 0);
                 assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
-        });
-
-        it("should report zero messages when given a '**' pattern with a .js and a .js2 file", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfig: { files: ["**/*.js", "**/*.js2"] },
-                overrideConfigFile: getFixturePath("eslint.config.js")
-
-            });
-            const results = await eslint.lintFiles(["fixtures/files/*"]);
-
-            assert.strictEqual(results.length, 3);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[2].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(results[1].suppressedMessages.length, 0);
-            assert.strictEqual(results[2].suppressedMessages.length, 0);
-        });
-
-        it("should resolve globs when 'globInputPaths' option is true", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath(".."),
-                overrideConfig: { files: ["**/*.js", "**/*.js2"] },
-                overrideConfigFile: getFixturePath("eslint.config.js")
-
-            });
-            const results = await eslint.lintFiles(["fixtures/files/*"]);
-
-            assert.strictEqual(results.length, 3);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[2].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(results[1].suppressedMessages.length, 0);
-            assert.strictEqual(results[2].suppressedMessages.length, 0);
-        });
-
-        // only works on a Windows machine
-        if (os.platform() === "win32") {
 
-            it("should resolve globs with Windows slashes when 'globInputPaths' option is true", async () => {
+            it("should resolve globs when 'globInputPaths' option is true", async () => {
                 eslint = new ESLint({
+                    flags,
                     ignore: false,
                     cwd: getFixturePath(".."),
                     overrideConfig: { files: ["**/*.js", "**/*.js2"] },
                     overrideConfigFile: getFixturePath("eslint.config.js")
 
                 });
-                const results = await eslint.lintFiles(["fixtures\\files\\*"]);
+                const results = await eslint.lintFiles(["fixtures/files/*"]);
 
                 assert.strictEqual(results.length, 3);
                 assert.strictEqual(results[0].messages.length, 0);
@@ -1972,7049 +2093,7723 @@ describe("ESLint", () => {
                 assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
 
-        }
-
-
-        it("should not resolve globs when 'globInputPaths' option is false", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath(".."),
-                overrideConfig: { files: ["**/*.js", "**/*.js2"] },
-                overrideConfigFile: true,
-                globInputPaths: false
-            });
+            // only works on a Windows machine
+            if (os.platform() === "win32") {
 
-            await assert.rejects(async () => {
-                await eslint.lintFiles(["fixtures/files/*"]);
-            }, /No files matching 'fixtures\/files\/\*' were found \(glob was disabled\)\./u);
-        });
+                it("should resolve globs with Windows slashes when 'globInputPaths' option is true", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        ignore: false,
+                        cwd: getFixturePath(".."),
+                        overrideConfig: { files: ["**/*.js", "**/*.js2"] },
+                        overrideConfigFile: getFixturePath("eslint.config.js")
 
-        describe("Ignoring Files", () => {
+                    });
+                    const results = await eslint.lintFiles(["fixtures\\files\\*"]);
 
-            it("should report on a file in the node_modules folder passed explicitly, even if ignored by default", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine")
+                    assert.strictEqual(results.length, 3);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[1].messages.length, 0);
+                    assert.strictEqual(results[2].messages.length, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[1].suppressedMessages.length, 0);
+                    assert.strictEqual(results[2].suppressedMessages.length, 0);
                 });
-                const results = await eslint.lintFiles(["node_modules/foo.js"]);
-                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, expectedMsg);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
 
-            it("should report on a file in a node_modules subfolder passed explicitly, even if ignored by default", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine")
-                });
-                const results = await eslint.lintFiles(["nested_node_modules/subdir/node_modules/text.js"]);
-                const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+            }
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, expectedMsg);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
 
-            it("should report on an ignored file with \"node_modules\" in its name", async () => {
+            it("should not resolve globs when 'globInputPaths' option is false", async () => {
                 eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    ignorePatterns: ["*.js"]
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath(".."),
+                    overrideConfig: { files: ["**/*.js", "**/*.js2"] },
+                    overrideConfigFile: true,
+                    globInputPaths: false
                 });
-                const results = await eslint.lintFiles(["node_modules_cleaner.js"]);
-                const expectedMsg = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, expectedMsg);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                await assert.rejects(async () => {
+                    await eslint.lintFiles(["fixtures/files/*"]);
+                }, /No files matching 'fixtures\/files\/\*' were found \(glob was disabled\)\./u);
             });
 
-            it("should suppress the warning when a file in the node_modules folder passed explicitly and warnIgnored is false", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    warnIgnored: false
-                });
-                const results = await eslint.lintFiles(["node_modules/foo.js"]);
-
-                assert.strictEqual(results.length, 0);
-            });
+            describe("Ignoring Files", () => {
 
-            it("should report on globs with explicit inclusion of dotfiles", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: {
-                            quotes: [2, "single"]
-                        }
-                    }
+                it("should report on a file in the node_modules folder passed explicitly, even if ignored by default", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine")
+                    });
+                    const results = await eslint.lintFiles(["node_modules/foo.js"]);
+                    const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, expectedMsg);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const results = await eslint.lintFiles(["hidden/.hiddenfolder/*.js"]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 1);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 1);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-            });
 
-            it("should ignore node_modules files when using ignore file", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    overrideConfigFile: true
+                it("should report on a file in a node_modules subfolder passed explicitly, even if ignored by default", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine")
+                    });
+                    const results = await eslint.lintFiles(["nested_node_modules/subdir/node_modules/text.js"]);
+                    const expectedMsg = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, expectedMsg);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["node_modules"]);
-                }, /All files matched by 'node_modules' are ignored\./u);
-            });
-
-            // https://github.com/eslint/eslint/issues/5547
-            it("should ignore node_modules files even with ignore: false", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    ignore: false
+                it("should report on an ignored file with \"node_modules\" in its name", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        ignorePatterns: ["*.js"]
+                    });
+                    const results = await eslint.lintFiles(["node_modules_cleaner.js"]);
+                    const expectedMsg = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, expectedMsg);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["node_modules"]);
-                }, /All files matched by 'node_modules' are ignored\./u);
-            });
+                it("should suppress the warning when a file in the node_modules folder passed explicitly and warnIgnored is false", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        warnIgnored: false
+                    });
+                    const results = await eslint.lintFiles(["node_modules/foo.js"]);
 
-            it("should throw an error when all given files are ignored", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores.js")
+                    assert.strictEqual(results.length, 0);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["tests/fixtures/cli-engine/"]);
-                }, /All files matched by 'tests\/fixtures\/cli-engine\/' are ignored\./u);
-            });
+                it("should report on globs with explicit inclusion of dotfiles", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: {
+                                quotes: [2, "single"]
+                            }
+                        }
+                    });
+                    const results = await eslint.lintFiles(["hidden/.hiddenfolder/*.js"]);
 
-            it("should throw an error when all given files are ignored by a config object that has `name`", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores3.js")
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 1);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 1);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["tests/fixtures/cli-engine/"]);
-                }, /All files matched by 'tests\/fixtures\/cli-engine\/' are ignored\./u);
-            });
+                it("should ignore node_modules files when using ignore file", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        overrideConfigFile: true
+                    });
 
-            it("should throw an error when all given files are ignored even with a `./` prefix", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores.js")
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["node_modules"]);
+                    }, /All files matched by 'node_modules' are ignored\./u);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["./tests/fixtures/cli-engine/"]);
-                }, /All files matched by '\.\/tests\/fixtures\/cli-engine\/' are ignored\./u);
-            });
+                // https://github.com/eslint/eslint/issues/5547
+                it("should ignore node_modules files even with ignore: false", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        ignore: false
+                    });
 
-            // https://github.com/eslint/eslint/issues/3788
-            it("should ignore one-level down node_modules by default", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: {
-                            quotes: [2, "double"]
-                        }
-                    },
-                    cwd: getFixturePath("cli-engine", "nested_node_modules")
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["node_modules"]);
+                    }, /All files matched by 'node_modules' are ignored\./u);
                 });
-                const results = await eslint.lintFiles(["."]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-            });
+                it("should throw an error when all given files are ignored", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores.js")
+                    });
 
-            // https://github.com/eslint/eslint/issues/3812
-            it("should ignore all files and throw an error when **/fixtures/** is in `ignores` in the config file", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: getFixturePath("cli-engine/eslint.config-with-ignores2.js"),
-                    overrideConfig: {
-                        rules: {
-                            quotes: [2, "double"]
-                        }
-                    }
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["tests/fixtures/cli-engine/"]);
+                    }, /All files matched by 'tests\/fixtures\/cli-engine\/' are ignored\./u);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["./tests/fixtures/cli-engine/"]);
-                }, /All files matched by '\.\/tests\/fixtures\/cli-engine\/' are ignored\./u);
-            });
+                it("should throw an error when all given files are ignored by a config object that has `name`", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores3.js")
+                    });
 
-            it("should throw an error when all given files are ignored via ignorePatterns", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    ignorePatterns: ["tests/fixtures/single-quoted.js"]
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["tests/fixtures/cli-engine/"]);
+                    }, /All files matched by 'tests\/fixtures\/cli-engine\/' are ignored\./u);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["tests/fixtures/*-quoted.js"]);
-                }, /All files matched by 'tests\/fixtures\/\*-quoted\.js' are ignored\./u);
-            });
+                it("should throw an error when all given files are ignored even with a `./` prefix", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores.js")
+                    });
 
-            it("should not throw an error when ignorePatterns is an empty array", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    ignorePatterns: []
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["./tests/fixtures/cli-engine/"]);
+                    }, /All files matched by '\.\/tests\/fixtures\/cli-engine\/' are ignored\./u);
                 });
 
-                await assert.doesNotReject(async () => {
-                    await eslint.lintFiles(["*.js"]);
+                // https://github.com/eslint/eslint/issues/3788
+                it("should ignore one-level down node_modules by default", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: {
+                                quotes: [2, "double"]
+                            }
+                        },
+                        cwd: getFixturePath("cli-engine", "nested_node_modules")
+                    });
+                    const results = await eslint.lintFiles(["."]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
                 });
-            });
 
+                // https://github.com/eslint/eslint/issues/3812
+                it("should ignore all files and throw an error when **/fixtures/** is in `ignores` in the config file", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: getFixturePath("cli-engine/eslint.config-with-ignores2.js"),
+                        overrideConfig: {
+                            rules: {
+                                quotes: [2, "double"]
+                            }
+                        }
+                    });
 
-            it("should return a warning when an explicitly given file is ignored", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: "eslint.config-with-ignores.js",
-                    cwd: getFixturePath()
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["./tests/fixtures/cli-engine/"]);
+                    }, /All files matched by '\.\/tests\/fixtures\/cli-engine\/' are ignored\./u);
                 });
-                const filePath = getFixturePath("passing.js");
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                it("should throw an error when all given files are ignored via ignorePatterns", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        ignorePatterns: ["tests/fixtures/single-quoted.js"]
+                    });
 
-            it("should return a warning when an explicitly given file has no matching config", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd: getFixturePath()
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["tests/fixtures/*-quoted.js"]);
+                    }, /All files matched by 'tests\/fixtures\/\*-quoted\.js' are ignored\./u);
                 });
-                const filePath = getFixturePath("files", "foo.js2");
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because no matching configuration was supplied.");
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                it("should not throw an error when ignorePatterns is an empty array", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        ignorePatterns: []
+                    });
 
-            it("should return a warning when an explicitly given file is outside the base path", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd: getFixturePath("files")
+                    await assert.doesNotReject(async () => {
+                        await eslint.lintFiles(["*.js"]);
+                    });
                 });
-                const filePath = getFixturePath("passing.js");
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because outside of base path.");
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
 
-            it("should suppress the warning when an explicitly given file is ignored and warnIgnored is false", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: "eslint.config-with-ignores.js",
-                    cwd: getFixturePath(),
-                    warnIgnored: false
+                it("should return a warning when an explicitly given file is ignored", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: "eslint.config-with-ignores.js",
+                        cwd: getFixturePath()
+                    });
+                    const filePath = getFixturePath("passing.js");
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const filePath = getFixturePath("passing.js");
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 0);
-            });
+                it("should return a warning when an explicitly given file has no matching config", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        cwd: getFixturePath()
+                    });
+                    const filePath = getFixturePath("files", "foo.js2");
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, "File ignored because no matching configuration was supplied.");
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-            it("should return a warning about matching ignore patterns when an explicitly given dotfile is ignored", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: "eslint.config-with-ignores.js",
-                    cwd: getFixturePath()
+                it("should return a warning when an explicitly given file is outside the base path", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        cwd: getFixturePath("files")
+                    });
+                    const filePath = getFixturePath("passing.js");
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, "File ignored because outside of base path.");
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const filePath = getFixturePath("dot-files/.a.js");
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].fatalErrorCount, 0);
-                assert.strictEqual(results[0].fixableErrorCount, 0);
-                assert.strictEqual(results[0].fixableWarningCount, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                it("should suppress the warning when an explicitly given file is ignored and warnIgnored is false", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: "eslint.config-with-ignores.js",
+                        cwd: getFixturePath(),
+                        warnIgnored: false
+                    });
+                    const filePath = getFixturePath("passing.js");
+                    const results = await eslint.lintFiles([filePath]);
 
-            it("should return two messages when given a file in excluded files list while ignore is off", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath(),
-                    ignore: false,
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores.js"),
-                    overrideConfig: {
-                        rules: {
-                            "no-undef": 2
-                        }
-                    }
+                    assert.strictEqual(results.length, 0);
                 });
-                const filePath = fs.realpathSync(getFixturePath("undef.js"));
-                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].ruleId, "no-undef");
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                it("should return a warning about matching ignore patterns when an explicitly given dotfile is ignored", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: "eslint.config-with-ignores.js",
+                        cwd: getFixturePath()
+                    });
+                    const filePath = getFixturePath("dot-files/.a.js");
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].message, "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.");
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].fatalErrorCount, 0);
+                    assert.strictEqual(results[0].fixableErrorCount, 0);
+                    assert.strictEqual(results[0].fixableWarningCount, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-            it("should return two messages when given a file in excluded files list by a config object that has `name` while ignore is off", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath(),
-                    ignore: false,
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores3.js"),
-                    overrideConfig: {
-                        rules: {
-                            "no-undef": 2
+                it("should return two messages when given a file in excluded files list while ignore is off", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath(),
+                        ignore: false,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores.js"),
+                        overrideConfig: {
+                            rules: {
+                                "no-undef": 2
+                            }
                         }
-                    }
+                    });
+                    const filePath = fs.realpathSync(getFixturePath("undef.js"));
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].ruleId, "no-undef");
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const filePath = fs.realpathSync(getFixturePath("undef.js"));
-                const results = await eslint.lintFiles([filePath]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, filePath);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].ruleId, "no-undef");
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
 
-            // https://github.com/eslint/eslint/issues/16300
-            it("should process ignore patterns relative to basePath not cwd", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-relative/subdir")
+                it("should return two messages when given a file in excluded files list by a config object that has `name` while ignore is off", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath(),
+                        ignore: false,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores3.js"),
+                        overrideConfig: {
+                            rules: {
+                                "no-undef": 2
+                            }
+                        }
+                    });
+                    const filePath = fs.realpathSync(getFixturePath("undef.js"));
+                    const results = await eslint.lintFiles([filePath]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, filePath);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].ruleId, "no-undef");
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const results = await eslint.lintFiles(["**/*.js"]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative/subdir/a.js"));
-            });
+                // https://github.com/eslint/eslint/issues/16300
+                it("should process ignore patterns relative to basePath not cwd", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-relative/subdir")
+                    });
+                    const results = await eslint.lintFiles(["**/*.js"]);
 
-            // https://github.com/eslint/eslint/issues/16354
-            it("should skip subdirectory files when ignore pattern matches deep subdirectory", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory")
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative/subdir/a.js"));
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir/**"]);
-                }, /All files matched by 'subdir\/\*\*' are ignored\./u);
+                // https://github.com/eslint/eslint/issues/16354
+                it("should skip subdirectory files when ignore pattern matches deep subdirectory", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory")
+                    });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir/subsubdir/**"]);
-                }, /All files matched by 'subdir\/subsubdir\/\*\*' are ignored\./u);
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir/**"]);
+                    }, /All files matched by 'subdir\/\*\*' are ignored\./u);
 
-                const results = await eslint.lintFiles(["subdir/subsubdir/a.js"]);
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir/subsubdir/**"]);
+                    }, /All files matched by 'subdir\/subsubdir\/\*\*' are ignored\./u);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory/subdir/subsubdir/a.js"));
-                assert.strictEqual(results[0].warningCount, 1);
-                assert(results[0].messages[0].message.startsWith("File ignored"), "Should contain file ignored warning");
+                    const results = await eslint.lintFiles(["subdir/subsubdir/a.js"]);
 
-            });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory/subdir/subsubdir/a.js"));
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert(results[0].messages[0].message.startsWith("File ignored"), "Should contain file ignored warning");
 
-            // https://github.com/eslint/eslint/issues/16414
-            it("should skip subdirectory files when ignore pattern matches subdirectory", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-subdirectory")
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subdir/**/*.js"]);
-                }, /All files matched by 'subdir\/\*\*\/\*\.js' are ignored\./u);
+                // https://github.com/eslint/eslint/issues/16414
+                it("should skip subdirectory files when ignore pattern matches subdirectory", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-subdirectory")
+                    });
 
-                const results = await eslint.lintFiles(["subdir/subsubdir/a.js"]);
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subdir/**/*.js"]);
+                    }, /All files matched by 'subdir\/\*\*\/\*\.js' are ignored\./u);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-subdirectory/subdir/subsubdir/a.js"));
-                assert.strictEqual(results[0].warningCount, 1);
-                assert(results[0].messages[0].message.startsWith("File ignored"), "Should contain file ignored warning");
+                    const results = await eslint.lintFiles(["subdir/subsubdir/a.js"]);
 
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-subdirectory/subdir")
-                });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-subdirectory/subdir/subsubdir/a.js"));
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert(results[0].messages[0].message.startsWith("File ignored"), "Should contain file ignored warning");
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["subsubdir/**/*.js"]);
-                }, /All files matched by 'subsubdir\/\*\*\/\*\.js' are ignored\./u);
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-subdirectory/subdir")
+                    });
 
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["subsubdir/**/*.js"]);
+                    }, /All files matched by 'subsubdir\/\*\*\/\*\.js' are ignored\./u);
 
-            });
 
-            // https://github.com/eslint/eslint/issues/16340
-            it("should lint files even when cwd directory name matches ignores pattern", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-self")
                 });
 
-                const results = await eslint.lintFiles(["*.js"]);
+                // https://github.com/eslint/eslint/issues/16340
+                it("should lint files even when cwd directory name matches ignores pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-self")
+                    });
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-self/eslint.config.js"));
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
+                    const results = await eslint.lintFiles(["*.js"]);
 
-            });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-self/eslint.config.js"));
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
 
-            // https://github.com/eslint/eslint/issues/16416
-            it("should allow reignoring of previously ignored files", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-relative"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
-                            "*.js",
-                            "!a*.js",
-                            "a.js"
-                        ]
-                    }
                 });
-                const results = await eslint.lintFiles(["a.js"]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative/a.js"));
-            });
+                // https://github.com/eslint/eslint/issues/16416
+                it("should allow reignoring of previously ignored files", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-relative"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
+                                "*.js",
+                                "!a*.js",
+                                "a.js"
+                            ]
+                        }
+                    });
+                    const results = await eslint.lintFiles(["a.js"]);
 
-            // https://github.com/eslint/eslint/issues/16415
-            it("should allow directories to be unignored", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
-                            "subdir/*",
-                            "!subdir/subsubdir"
-                        ]
-                    }
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative/a.js"));
                 });
-                const results = await eslint.lintFiles(["subdir/**/*.js"]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory/subdir/subsubdir/a.js"));
-            });
 
-            // https://github.com/eslint/eslint/issues/17964#issuecomment-1879840650
-            it("should allow directories to be unignored without also unignoring all files in them", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory-deep"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
-
-                            // ignore all files and directories
-                            "tests/format/**/*",
-
-                            // unignore all directories
-                            "!tests/format/**/*/",
+                // https://github.com/eslint/eslint/issues/16415
+                it("should allow directories to be unignored", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
+                                "subdir/*",
+                                "!subdir/subsubdir"
+                            ]
+                        }
+                    });
+                    const results = await eslint.lintFiles(["subdir/**/*.js"]);
 
-                            // unignore only specific files
-                            "!tests/format/**/jsfmt.spec.js"
-                        ]
-                    }
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory/subdir/subsubdir/a.js"));
                 });
-                const results = await eslint.lintFiles(["."]);
 
-                assert.strictEqual(results.length, 2);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
-                assert.strictEqual(results[1].errorCount, 0);
-                assert.strictEqual(results[1].warningCount, 0);
-                assert.strictEqual(results[1].filePath, getFixturePath("ignores-directory-deep/tests/format/subdir/jsfmt.spec.js"));
-            });
+                // https://github.com/eslint/eslint/issues/17964#issuecomment-1879840650
+                it("should allow directories to be unignored without also unignoring all files in them", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory-deep"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
 
-            it("should allow only subdirectories to be ignored by a pattern ending with '/'", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory-deep"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
-                            "tests/format/*/"
-                        ]
-                    }
-                });
-                const results = await eslint.lintFiles(["."]);
+                                // ignore all files and directories
+                                "tests/format/**/*",
 
-                assert.strictEqual(results.length, 2);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/foo.js"));
-                assert.strictEqual(results[1].errorCount, 0);
-                assert.strictEqual(results[1].warningCount, 0);
-                assert.strictEqual(results[1].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
-            });
+                                // unignore all directories
+                                "!tests/format/**/*/",
 
-            it("should allow only contents of a directory but not the directory itself to be ignored by a pattern ending with '**/*'", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory-deep"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
-                            "tests/format/**/*",
-                            "!tests/format/jsfmt.spec.js"
-                        ]
-                    }
+                                // unignore only specific files
+                                "!tests/format/**/jsfmt.spec.js"
+                            ]
+                        }
+                    });
+                    const results = await eslint.lintFiles(["."]);
+
+                    assert.strictEqual(results.length, 2);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
+                    assert.strictEqual(results[1].errorCount, 0);
+                    assert.strictEqual(results[1].warningCount, 0);
+                    assert.strictEqual(results[1].filePath, getFixturePath("ignores-directory-deep/tests/format/subdir/jsfmt.spec.js"));
                 });
-                const results = await eslint.lintFiles(["."]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].errorCount, 0);
-                assert.strictEqual(results[0].warningCount, 0);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
-            });
+                it("should allow only subdirectories to be ignored by a pattern ending with '/'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory-deep"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
+                                "tests/format/*/"
+                            ]
+                        }
+                    });
+                    const results = await eslint.lintFiles(["."]);
 
-            it("should skip ignored files in an unignored directory", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory-deep"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
+                    assert.strictEqual(results.length, 2);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/foo.js"));
+                    assert.strictEqual(results[1].errorCount, 0);
+                    assert.strictEqual(results[1].warningCount, 0);
+                    assert.strictEqual(results[1].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
+                });
 
-                            // ignore 'tests/format/' and all its contents
-                            "tests/format/**",
+                it("should allow only contents of a directory but not the directory itself to be ignored by a pattern ending with '**/*'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory-deep"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
+                                "tests/format/**/*",
+                                "!tests/format/jsfmt.spec.js"
+                            ]
+                        }
+                    });
+                    const results = await eslint.lintFiles(["."]);
 
-                            // unignore 'tests/format/', but its contents is still ignored
-                            "!tests/format/"
-                        ]
-                    }
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].errorCount, 0);
+                    assert.strictEqual(results[0].warningCount, 0);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-directory-deep/tests/format/jsfmt.spec.js"));
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["."]);
-                }, /All files matched by '.' are ignored/u);
-            });
+                it("should skip ignored files in an unignored directory", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory-deep"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: [
 
-            it("should skip files in an ignored directory even if they are matched by a negated pattern", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-directory-deep"),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: [
+                                // ignore 'tests/format/' and all its contents
+                                "tests/format/**",
 
-                            // ignore 'tests/format/' and all its contents
-                            "tests/format/**",
+                                // unignore 'tests/format/', but its contents is still ignored
+                                "!tests/format/"
+                            ]
+                        }
+                    });
 
-                            // this patterns match some or all of its contents, but 'tests/format/' is still ignored
-                            "!tests/format/jsfmt.spec.js",
-                            "!tests/format/**/jsfmt.spec.js",
-                            "!tests/format/*",
-                            "!tests/format/**/*"
-                        ]
-                    }
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["."]);
+                    }, /All files matched by '.' are ignored/u);
                 });
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["."]);
-                }, /All files matched by '.' are ignored/u);
-            });
-
-            // https://github.com/eslint/eslint/issues/18597
-            it("should skip files ignored by a pattern with escape character '\\'", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath(),
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
+                it("should skip files in an ignored directory even if they are matched by a negated pattern", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("ignores-directory-deep"),
+                        overrideConfigFile: true,
+                        overrideConfig: {
                             ignores: [
-                                "curly-files/\\{a,b}.js" // ignore file named `{a,b}.js`, not files named `a.js` or `b.js`
+
+                                // ignore 'tests/format/' and all its contents
+                                "tests/format/**",
+
+                                // this patterns match some or all of its contents, but 'tests/format/' is still ignored
+                                "!tests/format/jsfmt.spec.js",
+                                "!tests/format/**/jsfmt.spec.js",
+                                "!tests/format/*",
+                                "!tests/format/**/*"
                             ]
-                        },
-                        {
-                            rules: {
-                                "no-undef": "warn"
-                            }
                         }
-                    ]
+                    });
+
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["."]);
+                    }, /All files matched by '.' are ignored/u);
                 });
 
-                const results = await eslint.lintFiles(["curly-files"]);
+                // https://github.com/eslint/eslint/issues/18597
+                it("should skip files ignored by a pattern with escape character '\\'", async () => {
+                    eslint = new ESLint({
+                        cwd: getFixturePath(),
+                        flags,
+                        overrideConfigFile: true,
+                        overrideConfig: [
+                            {
+                                ignores: [
+                                    "curly-files/\\{a,b}.js" // ignore file named `{a,b}.js`, not files named `a.js` or `b.js`
+                                ]
+                            },
+                            {
+                                rules: {
+                                    "no-undef": "warn"
+                                }
+                            }
+                        ]
+                    });
 
-                assert.strictEqual(results.length, 2);
-                assert.strictEqual(results[0].filePath, getFixturePath("curly-files", "a.js"));
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-                assert.strictEqual(results[0].messages[0].messageId, "undef");
-                assert.match(results[0].messages[0].message, /'bar'/u);
-                assert.strictEqual(results[1].filePath, getFixturePath("curly-files", "b.js"));
-                assert.strictEqual(results[1].messages.length, 1);
-                assert.strictEqual(results[1].messages[0].severity, 1);
-                assert.strictEqual(results[1].messages[0].ruleId, "no-undef");
-                assert.strictEqual(results[1].messages[0].messageId, "undef");
-                assert.match(results[1].messages[0].message, /'baz'/u);
-            });
+                    const results = await eslint.lintFiles(["curly-files"]);
 
-            // https://github.com/eslint/eslint/issues/18706
-            it("should disregard ignore pattern '/'", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-relative"),
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            ignores: ["/"]
-                        },
-                        {
-                            plugins: {
-                                "test-plugin": {
-                                    rules: {
-                                        "no-program": {
-                                            create(context) {
-                                                return {
-                                                    Program(node) {
-                                                        context.report({
-                                                            node,
-                                                            message: "Program is disallowed."
-                                                        });
-                                                    }
-                                                };
+                    assert.strictEqual(results.length, 2);
+                    assert.strictEqual(results[0].filePath, getFixturePath("curly-files", "a.js"));
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    assert.strictEqual(results[0].messages[0].messageId, "undef");
+                    assert.match(results[0].messages[0].message, /'bar'/u);
+                    assert.strictEqual(results[1].filePath, getFixturePath("curly-files", "b.js"));
+                    assert.strictEqual(results[1].messages.length, 1);
+                    assert.strictEqual(results[1].messages[0].severity, 1);
+                    assert.strictEqual(results[1].messages[0].ruleId, "no-undef");
+                    assert.strictEqual(results[1].messages[0].messageId, "undef");
+                    assert.match(results[1].messages[0].message, /'baz'/u);
+                });
+
+                // https://github.com/eslint/eslint/issues/18706
+                it("should disregard ignore pattern '/'", async () => {
+                    eslint = new ESLint({
+                        cwd: getFixturePath("ignores-relative"),
+                        flags,
+                        overrideConfigFile: true,
+                        overrideConfig: [
+                            {
+                                ignores: ["/"]
+                            },
+                            {
+                                plugins: {
+                                    "test-plugin": {
+                                        rules: {
+                                            "no-program": {
+                                                create(context) {
+                                                    return {
+                                                        Program(node) {
+                                                            context.report({
+                                                                node,
+                                                                message: "Program is disallowed."
+                                                            });
+                                                        }
+                                                    };
+                                                }
                                             }
                                         }
                                     }
+                                },
+                                rules: {
+                                    "test-plugin/no-program": "warn"
                                 }
-                            },
-                            rules: {
-                                "test-plugin/no-program": "warn"
                             }
-                        }
-                    ]
-                });
+                        ]
+                    });
 
-                const results = await eslint.lintFiles(["**/a.js"]);
+                    const results = await eslint.lintFiles(["**/a.js"]);
 
-                assert.strictEqual(results.length, 2);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative", "a.js"));
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].ruleId, "test-plugin/no-program");
-                assert.strictEqual(results[0].messages[0].message, "Program is disallowed.");
-                assert.strictEqual(results[1].filePath, getFixturePath("ignores-relative", "subdir", "a.js"));
-                assert.strictEqual(results[1].messages.length, 1);
-                assert.strictEqual(results[1].messages[0].severity, 1);
-                assert.strictEqual(results[1].messages[0].ruleId, "test-plugin/no-program");
-                assert.strictEqual(results[1].messages[0].message, "Program is disallowed.");
-            });
+                    assert.strictEqual(results.length, 2);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative", "a.js"));
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].ruleId, "test-plugin/no-program");
+                    assert.strictEqual(results[0].messages[0].message, "Program is disallowed.");
+                    assert.strictEqual(results[1].filePath, getFixturePath("ignores-relative", "subdir", "a.js"));
+                    assert.strictEqual(results[1].messages.length, 1);
+                    assert.strictEqual(results[1].messages[0].severity, 1);
+                    assert.strictEqual(results[1].messages[0].ruleId, "test-plugin/no-program");
+                    assert.strictEqual(results[1].messages[0].message, "Program is disallowed.");
+                });
 
-            it("should not skip an unignored file in base path when all files are initially ignored by '**'", async () => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("ignores-relative"),
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            ignores: [
-                                "**",
-                                "!a.js"
-                            ]
-                        },
-                        {
-                            plugins: {
-                                "test-plugin": {
-                                    rules: {
-                                        "no-program": {
-                                            create(context) {
-                                                return {
-                                                    Program(node) {
-                                                        context.report({
-                                                            node,
-                                                            message: "Program is disallowed."
-                                                        });
-                                                    }
-                                                };
+                it("should not skip an unignored file in base path when all files are initially ignored by '**'", async () => {
+                    eslint = new ESLint({
+                        cwd: getFixturePath("ignores-relative"),
+                        flags,
+                        overrideConfigFile: true,
+                        overrideConfig: [
+                            {
+                                ignores: [
+                                    "**",
+                                    "!a.js"
+                                ]
+                            },
+                            {
+                                plugins: {
+                                    "test-plugin": {
+                                        rules: {
+                                            "no-program": {
+                                                create(context) {
+                                                    return {
+                                                        Program(node) {
+                                                            context.report({
+                                                                node,
+                                                                message: "Program is disallowed."
+                                                            });
+                                                        }
+                                                    };
+                                                }
                                             }
                                         }
                                     }
+                                },
+                                rules: {
+                                    "test-plugin/no-program": "warn"
                                 }
-                            },
-                            rules: {
-                                "test-plugin/no-program": "warn"
                             }
-                        }
-                    ]
-                });
-
-                const results = await eslint.lintFiles(["**/a.js"]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative", "a.js"));
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].ruleId, "test-plugin/no-program");
-                assert.strictEqual(results[0].messages[0].message, "Program is disallowed.");
-            });
-
-        });
-
-
-        it("should report zero messages when given a pattern with a .js and a .js2 file", async () => {
-            eslint = new ESLint({
-                overrideConfig: { files: ["**/*.js", "**/*.js2"] },
-                ignore: false,
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: true
-            });
-            const results = await eslint.lintFiles(["fixtures/files/*.?s*"]);
-
-            assert.strictEqual(results.length, 3);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[1].suppressedMessages.length, 0);
-            assert.strictEqual(results[2].messages.length, 0);
-            assert.strictEqual(results[2].suppressedMessages.length, 0);
-        });
+                        ]
+                    });
 
-        it("should return one error message when given a config with rules with options and severity level set to error", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(),
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        quotes: ["error", "double"]
-                    }
-                },
-                ignore: false
-            });
-            const results = await eslint.lintFiles([getFixturePath("single-quoted.js")]);
+                    const results = await eslint.lintFiles(["**/a.js"]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].ruleId, "quotes");
-            assert.strictEqual(results[0].messages[0].severity, 2);
-            assert.strictEqual(results[0].errorCount, 1);
-            assert.strictEqual(results[0].warningCount, 0);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 1);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, getFixturePath("ignores-relative", "a.js"));
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].ruleId, "test-plugin/no-program");
+                    assert.strictEqual(results[0].messages[0].message, "Program is disallowed.");
+                });
 
-        it("should return 5 results when given a config and a directory of 5 valid files", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 1,
-                        strict: 0
-                    }
-                }
             });
 
-            const formattersDir = getFixturePath("formatters");
-            const results = await eslint.lintFiles([formattersDir]);
 
-            assert.strictEqual(results.length, 5);
-            assert.strictEqual(path.relative(formattersDir, results[0].filePath), "async.js");
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 0);
-            assert.strictEqual(results[0].fatalErrorCount, 0);
-            assert.strictEqual(results[0].fixableErrorCount, 0);
-            assert.strictEqual(results[0].fixableWarningCount, 0);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(path.relative(formattersDir, results[1].filePath), "broken.js");
-            assert.strictEqual(results[1].errorCount, 0);
-            assert.strictEqual(results[1].warningCount, 0);
-            assert.strictEqual(results[1].fatalErrorCount, 0);
-            assert.strictEqual(results[1].fixableErrorCount, 0);
-            assert.strictEqual(results[1].fixableWarningCount, 0);
-            assert.strictEqual(results[1].messages.length, 0);
-            assert.strictEqual(results[1].suppressedMessages.length, 0);
-            assert.strictEqual(path.relative(formattersDir, results[2].filePath), "cwd.js");
-            assert.strictEqual(results[2].errorCount, 0);
-            assert.strictEqual(results[2].warningCount, 0);
-            assert.strictEqual(results[2].fatalErrorCount, 0);
-            assert.strictEqual(results[2].fixableErrorCount, 0);
-            assert.strictEqual(results[2].fixableWarningCount, 0);
-            assert.strictEqual(results[2].messages.length, 0);
-            assert.strictEqual(results[2].suppressedMessages.length, 0);
-            assert.strictEqual(path.relative(formattersDir, results[3].filePath), "simple.js");
-            assert.strictEqual(results[3].errorCount, 0);
-            assert.strictEqual(results[3].warningCount, 0);
-            assert.strictEqual(results[3].fatalErrorCount, 0);
-            assert.strictEqual(results[3].fixableErrorCount, 0);
-            assert.strictEqual(results[3].fixableWarningCount, 0);
-            assert.strictEqual(results[3].messages.length, 0);
-            assert.strictEqual(results[3].suppressedMessages.length, 0);
-            assert.strictEqual(path.relative(formattersDir, results[4].filePath), path.join("test", "simple.js"));
-            assert.strictEqual(results[4].errorCount, 0);
-            assert.strictEqual(results[4].warningCount, 0);
-            assert.strictEqual(results[4].fatalErrorCount, 0);
-            assert.strictEqual(results[4].fixableErrorCount, 0);
-            assert.strictEqual(results[4].fixableWarningCount, 0);
-            assert.strictEqual(results[4].messages.length, 0);
-            assert.strictEqual(results[4].suppressedMessages.length, 0);
-        });
+            it("should report zero messages when given a pattern with a .js and a .js2 file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    overrideConfig: { files: ["**/*.js", "**/*.js2"] },
+                    ignore: false,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: true
+                });
+                const results = await eslint.lintFiles(["fixtures/files/*.?s*"]);
 
-        it("should return zero messages when given a config with browser globals", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: getFixturePath("configurations", "env-browser.js")
+                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+                assert.strictEqual(results[2].messages.length, 0);
+                assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-browser.js"))]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0, "Should have no messages.");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
-
-        it("should return zero messages when given an option to add browser globals", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: true,
-                overrideConfig: {
-                    languageOptions: {
-                        globals: {
-                            window: false
+            it("should return one error message when given a config with rules with options and severity level set to error", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(),
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            quotes: ["error", "double"]
                         }
                     },
-                    rules: {
-                        "no-alert": 0,
-                        "no-undef": 2
-                    }
-                }
-            });
-            const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-browser.js"))]);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                    ignore: false
+                });
+                const results = await eslint.lintFiles([getFixturePath("single-quoted.js")]);
 
-        it("should return zero messages when given a config with sourceType set to commonjs and Node.js globals", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: getFixturePath("configurations", "env-node.js")
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "quotes");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].errorCount, 1);
+                assert.strictEqual(results[0].warningCount, 0);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 1);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-node.js"))]);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0, "Should have no messages.");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
 
-        it("should not return results from previous call when calling more than once", async () => {
-            eslint = new ESLint({
-                cwd: path.join(fixtureDir, ".."),
-                overrideConfigFile: getFixturePath("eslint.config.js"),
-                ignore: false,
-                overrideConfig: {
-                    rules: {
-                        semi: 2
+            it("should return 5 results when given a config and a directory of 5 valid files", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 1,
+                            strict: 0
+                        }
                     }
-                }
-            });
-            const failFilePath = fs.realpathSync(getFixturePath("missing-semicolon.js"));
-            const passFilePath = fs.realpathSync(getFixturePath("passing.js"));
-
-            let results = await eslint.lintFiles([failFilePath]);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, failFilePath);
-            assert.strictEqual(results[0].messages.length, 1);
-            assert.strictEqual(results[0].messages[0].ruleId, "semi");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-            assert.strictEqual(results[0].messages[0].severity, 2);
-
-            results = await eslint.lintFiles([passFilePath]);
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, passFilePath);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                });
 
-        it("should return zero messages when executing a file with a shebang", async () => {
-            eslint = new ESLint({
-                ignore: false,
-                cwd: getFixturePath(),
-                overrideConfigFile: getFixturePath("eslint.config.js")
-            });
-            const results = await eslint.lintFiles([getFixturePath("shebang.js")]);
+                const formattersDir = getFixturePath("formatters");
+                const results = await eslint.lintFiles([formattersDir]);
 
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].messages.length, 0, "Should have lint messages.");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                assert.strictEqual(results.length, 5);
+                assert.strictEqual(path.relative(formattersDir, results[0].filePath), "async.js");
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 0);
+                assert.strictEqual(results[0].fatalErrorCount, 0);
+                assert.strictEqual(results[0].fixableErrorCount, 0);
+                assert.strictEqual(results[0].fixableWarningCount, 0);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(path.relative(formattersDir, results[1].filePath), "broken.js");
+                assert.strictEqual(results[1].errorCount, 0);
+                assert.strictEqual(results[1].warningCount, 0);
+                assert.strictEqual(results[1].fatalErrorCount, 0);
+                assert.strictEqual(results[1].fixableErrorCount, 0);
+                assert.strictEqual(results[1].fixableWarningCount, 0);
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+                assert.strictEqual(path.relative(formattersDir, results[2].filePath), "cwd.js");
+                assert.strictEqual(results[2].errorCount, 0);
+                assert.strictEqual(results[2].warningCount, 0);
+                assert.strictEqual(results[2].fatalErrorCount, 0);
+                assert.strictEqual(results[2].fixableErrorCount, 0);
+                assert.strictEqual(results[2].fixableWarningCount, 0);
+                assert.strictEqual(results[2].messages.length, 0);
+                assert.strictEqual(results[2].suppressedMessages.length, 0);
+                assert.strictEqual(path.relative(formattersDir, results[3].filePath), "simple.js");
+                assert.strictEqual(results[3].errorCount, 0);
+                assert.strictEqual(results[3].warningCount, 0);
+                assert.strictEqual(results[3].fatalErrorCount, 0);
+                assert.strictEqual(results[3].fixableErrorCount, 0);
+                assert.strictEqual(results[3].fixableWarningCount, 0);
+                assert.strictEqual(results[3].messages.length, 0);
+                assert.strictEqual(results[3].suppressedMessages.length, 0);
+                assert.strictEqual(path.relative(formattersDir, results[4].filePath), path.join("test", "simple.js"));
+                assert.strictEqual(results[4].errorCount, 0);
+                assert.strictEqual(results[4].warningCount, 0);
+                assert.strictEqual(results[4].fatalErrorCount, 0);
+                assert.strictEqual(results[4].fixableErrorCount, 0);
+                assert.strictEqual(results[4].fixableWarningCount, 0);
+                assert.strictEqual(results[4].messages.length, 0);
+                assert.strictEqual(results[4].suppressedMessages.length, 0);
+            });
+
+            it("should return zero messages when given a config with browser globals", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: getFixturePath("configurations", "env-browser.js")
+                });
+                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-browser.js"))]);
 
-        it("should return zero messages when executing without a config file", async () => {
-            eslint = new ESLint({
-                cwd: getFixturePath(),
-                ignore: false,
-                overrideConfigFile: true
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0, "Should have no messages.");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-            const filePath = fs.realpathSync(getFixturePath("missing-semicolon.js"));
-            const results = await eslint.lintFiles([filePath]);
-
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].filePath, filePath);
-            assert.strictEqual(results[0].messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
-
-        // working
-        describe("Deprecated Rules", () => {
 
-            it("should warn when deprecated rules are configured", async () => {
+            it("should return zero messages when given an option to add browser globals", async () => {
                 eslint = new ESLint({
-                    cwd: originalDir,
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
                     overrideConfigFile: true,
                     overrideConfig: {
+                        languageOptions: {
+                            globals: {
+                                window: false
+                            }
+                        },
                         rules: {
-                            "indent-legacy": 1,
-                            "callback-return": 1
+                            "no-alert": 0,
+                            "no-undef": 2
                         }
                     }
                 });
-                const results = await eslint.lintFiles(["lib/cli*.js"]);
+                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-browser.js"))]);
 
-                assert.deepStrictEqual(
-                    results[0].usedDeprecatedRules,
-                    [
-                        { ruleId: "indent-legacy", replacedBy: ["indent"] },
-                        { ruleId: "callback-return", replacedBy: [] }
-                    ]
-                );
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should not warn when deprecated rules are not configured", async () => {
+            it("should return zero messages when given a config with sourceType set to commonjs and Node.js globals", async () => {
                 eslint = new ESLint({
-                    cwd: originalDir,
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: { eqeqeq: 1, "callback-return": 0 }
-                    }
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: getFixturePath("configurations", "env-node.js")
                 });
-                const results = await eslint.lintFiles(["lib/cli*.js"]);
+                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("globals-node.js"))]);
 
-                assert.deepStrictEqual(results[0].usedDeprecatedRules, []);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0, "Should have no messages.");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should warn when deprecated rules are found in a config", async () => {
+            it("should not return results from previous call when calling more than once", async () => {
                 eslint = new ESLint({
-                    cwd: originalDir,
-                    overrideConfigFile: "tests/fixtures/cli-engine/deprecated-rule-config/eslint.config.js"
+                    flags,
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: getFixturePath("eslint.config.js"),
+                    ignore: false,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    }
                 });
-                const results = await eslint.lintFiles(["lib/cli*.js"]);
+                const failFilePath = fs.realpathSync(getFixturePath("missing-semicolon.js"));
+                const passFilePath = fs.realpathSync(getFixturePath("passing.js"));
 
-                assert.deepStrictEqual(
-                    results[0].usedDeprecatedRules,
-                    [{ ruleId: "indent-legacy", replacedBy: ["indent"] }]
-                );
-            });
-        });
+                let results = await eslint.lintFiles([failFilePath]);
 
-        // working
-        describe("Fix Mode", () => {
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, failFilePath);
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "semi");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[0].messages[0].severity, 2);
+
+                results = await eslint.lintFiles([passFilePath]);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, passFilePath);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-            it("correctly autofixes semicolon-conflicting-fixes", async () => {
+            it("should return zero messages when executing a file with a shebang", async () => {
                 eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath(),
+                    overrideConfigFile: getFixturePath("eslint.config.js")
                 });
-                const inputPath = getFixturePath("autofix/semicolon-conflicting-fixes.js");
-                const outputPath = getFixturePath("autofix/semicolon-conflicting-fixes.expected.js");
-                const results = await eslint.lintFiles([inputPath]);
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
+                const results = await eslint.lintFiles([getFixturePath("shebang.js")]);
 
-                assert.strictEqual(results[0].output, expectedOutput);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].messages.length, 0, "Should have lint messages.");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("correctly autofixes return-conflicting-fixes", async () => {
+            it("should return zero messages when executing without a config file", async () => {
                 eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true
+                    flags,
+                    cwd: getFixturePath(),
+                    ignore: false,
+                    overrideConfigFile: true
                 });
-                const inputPath = getFixturePath("autofix/return-conflicting-fixes.js");
-                const outputPath = getFixturePath("autofix/return-conflicting-fixes.expected.js");
-                const results = await eslint.lintFiles([inputPath]);
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
+                const filePath = fs.realpathSync(getFixturePath("missing-semicolon.js"));
+                const results = await eslint.lintFiles([filePath]);
 
-                assert.strictEqual(results[0].output, expectedOutput);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, filePath);
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should return fixed text on multiple files when in fix mode", async () => {
+            // working
+            describe("Deprecated Rules", () => {
 
-                /**
-                 * Converts CRLF to LF in output.
-                 * This is a workaround for git's autocrlf option on Windows.
-                 * @param {Object} result A result object to convert.
-                 * @returns {void}
-                 */
-                function convertCRLF(result) {
-                    if (result && result.output) {
-                        result.output = result.output.replace(/\r\n/gu, "\n");
-                    }
-                }
+                it("should warn when deprecated rules are configured", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: originalDir,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: {
+                                "indent-legacy": 1,
+                                "callback-return": 1
+                            }
+                        }
+                    });
+                    const results = await eslint.lintFiles(["lib/cli*.js"]);
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    overrideConfig: {
-                        rules: {
-                            semi: 2,
-                            quotes: [2, "double"],
-                            eqeqeq: 2,
-                            "no-undef": 2,
-                            "space-infix-ops": 2
+                    assert.deepStrictEqual(
+                        results[0].usedDeprecatedRules,
+                        [
+                            { ruleId: "indent-legacy", replacedBy: ["indent"] },
+                            { ruleId: "callback-return", replacedBy: [] }
+                        ]
+                    );
+                });
+
+                it("should not warn when deprecated rules are not configured", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: originalDir,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: { eqeqeq: 1, "callback-return": 0 }
                         }
-                    }
+                    });
+                    const results = await eslint.lintFiles(["lib/cli*.js"]);
+
+                    assert.deepStrictEqual(results[0].usedDeprecatedRules, []);
                 });
-                const results = await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
 
-                results.forEach(convertCRLF);
-                assert.deepStrictEqual(results, [
-                    {
-                        filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/multipass.js")),
-                        messages: [],
-                        suppressedMessages: [],
-                        errorCount: 0,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        output: "true ? \"yes\" : \"no\";\n",
-                        usedDeprecatedRules: [
-                            {
-                                replacedBy: [],
-                                ruleId: "semi"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "quotes"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "space-infix-ops"
-                            }
-                        ]
-                    },
-                    {
-                        filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/ok.js")),
-                        messages: [],
-                        suppressedMessages: [],
-                        errorCount: 0,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        usedDeprecatedRules: [
-                            {
-                                replacedBy: [],
-                                ruleId: "semi"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "quotes"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "space-infix-ops"
-                            }
-                        ]
-                    },
-                    {
-                        filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/quotes-semi-eqeqeq.js")),
-                        messages: [
-                            {
-                                column: 9,
-                                line: 2,
-                                endColumn: 11,
-                                endLine: 2,
-                                message: "Expected '===' and instead saw '=='.",
-                                messageId: "unexpected",
-                                nodeType: "BinaryExpression",
-                                ruleId: "eqeqeq",
-                                severity: 2
-                            }
-                        ],
-                        suppressedMessages: [],
-                        errorCount: 1,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        output: "var msg = \"hi\";\nif (msg == \"hi\") {\n\n}\n",
-                        usedDeprecatedRules: [
-                            {
-                                replacedBy: [],
-                                ruleId: "semi"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "quotes"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "space-infix-ops"
-                            }
-                        ]
-                    },
-                    {
-                        filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/quotes.js")),
-                        messages: [
-                            {
-                                column: 18,
-                                line: 1,
-                                endColumn: 21,
-                                endLine: 1,
-                                messageId: "undef",
-                                message: "'foo' is not defined.",
-                                nodeType: "Identifier",
-                                ruleId: "no-undef",
-                                severity: 2
-                            }
-                        ],
-                        suppressedMessages: [],
-                        errorCount: 1,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        output: "var msg = \"hi\" + foo;\n",
-                        usedDeprecatedRules: [
-                            {
-                                replacedBy: [],
-                                ruleId: "semi"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "quotes"
-                            },
-                            {
-                                replacedBy: [],
-                                ruleId: "space-infix-ops"
-                            }
-                        ]
-                    }
-                ]);
+                it("should warn when deprecated rules are found in a config", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: originalDir,
+                        overrideConfigFile: "tests/fixtures/cli-engine/deprecated-rule-config/eslint.config.js"
+                    });
+                    const results = await eslint.lintFiles(["lib/cli*.js"]);
+
+                    assert.deepStrictEqual(
+                        results[0].usedDeprecatedRules,
+                        [{ ruleId: "indent-legacy", replacedBy: ["indent"] }]
+                    );
+                });
             });
 
-            // Cannot be run properly until cache is implemented
-            it("should run autofix even if files are cached without autofix results", async () => {
-                const baseOptions = {
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: {
-                            semi: 2,
-                            quotes: [2, "double"],
-                            eqeqeq: 2,
-                            "no-undef": 2,
-                            "space-infix-ops": 2
-                        }
-                    }
-                };
+            // working
+            describe("Fix Mode", () => {
+
+                it("correctly autofixes semicolon-conflicting-fixes", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true
+                    });
+                    const inputPath = getFixturePath("autofix/semicolon-conflicting-fixes.js");
+                    const outputPath = getFixturePath("autofix/semicolon-conflicting-fixes.expected.js");
+                    const results = await eslint.lintFiles([inputPath]);
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
+
+                    assert.strictEqual(results[0].output, expectedOutput);
+                });
 
-                eslint = new ESLint(Object.assign({}, baseOptions, { cache: true, fix: false }));
+                it("correctly autofixes return-conflicting-fixes", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true
+                    });
+                    const inputPath = getFixturePath("autofix/return-conflicting-fixes.js");
+                    const outputPath = getFixturePath("autofix/return-conflicting-fixes.expected.js");
+                    const results = await eslint.lintFiles([inputPath]);
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                // Do initial lint run and populate the cache file
-                await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
+                    assert.strictEqual(results[0].output, expectedOutput);
+                });
 
-                eslint = new ESLint(Object.assign({}, baseOptions, { cache: true, fix: true }));
-                const results = await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
+                it("should return fixed text on multiple files when in fix mode", async () => {
 
-                assert(results.some(result => result.output));
-            });
-        });
+                    /**
+                     * Converts CRLF to LF in output.
+                     * This is a workaround for git's autocrlf option on Windows.
+                     * @param {Object} result A result object to convert.
+                     * @returns {void}
+                     */
+                    function convertCRLF(result) {
+                        if (result && result.output) {
+                            result.output = result.output.replace(/\r\n/gu, "\n");
+                        }
+                    }
 
-        describe("plugins", () => {
-            it("should return two messages when executing with config file that specifies a plugin", async () => {
-                eslint = eslintWithPlugins({
-                    cwd: path.resolve(fixtureDir, ".."),
-                    overrideConfigFile: getFixturePath("configurations", "plugins-with-prefix.js")
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        overrideConfig: {
+                            rules: {
+                                semi: 2,
+                                quotes: [2, "double"],
+                                eqeqeq: 2,
+                                "no-undef": 2,
+                                "space-infix-ops": 2
+                            }
+                        }
+                    });
+                    const results = await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
+
+                    results.forEach(convertCRLF);
+                    assert.deepStrictEqual(results, [
+                        {
+                            filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/multipass.js")),
+                            messages: [],
+                            suppressedMessages: [],
+                            errorCount: 0,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            output: "true ? \"yes\" : \"no\";\n",
+                            usedDeprecatedRules: [
+                                {
+                                    replacedBy: [],
+                                    ruleId: "semi"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "quotes"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "space-infix-ops"
+                                }
+                            ]
+                        },
+                        {
+                            filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/ok.js")),
+                            messages: [],
+                            suppressedMessages: [],
+                            errorCount: 0,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            usedDeprecatedRules: [
+                                {
+                                    replacedBy: [],
+                                    ruleId: "semi"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "quotes"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "space-infix-ops"
+                                }
+                            ]
+                        },
+                        {
+                            filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/quotes-semi-eqeqeq.js")),
+                            messages: [
+                                {
+                                    column: 9,
+                                    line: 2,
+                                    endColumn: 11,
+                                    endLine: 2,
+                                    message: "Expected '===' and instead saw '=='.",
+                                    messageId: "unexpected",
+                                    nodeType: "BinaryExpression",
+                                    ruleId: "eqeqeq",
+                                    severity: 2
+                                }
+                            ],
+                            suppressedMessages: [],
+                            errorCount: 1,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            output: "var msg = \"hi\";\nif (msg == \"hi\") {\n\n}\n",
+                            usedDeprecatedRules: [
+                                {
+                                    replacedBy: [],
+                                    ruleId: "semi"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "quotes"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "space-infix-ops"
+                                }
+                            ]
+                        },
+                        {
+                            filePath: fs.realpathSync(path.resolve(fixtureDir, "fixmode/quotes.js")),
+                            messages: [
+                                {
+                                    column: 18,
+                                    line: 1,
+                                    endColumn: 21,
+                                    endLine: 1,
+                                    messageId: "undef",
+                                    message: "'foo' is not defined.",
+                                    nodeType: "Identifier",
+                                    ruleId: "no-undef",
+                                    severity: 2
+                                }
+                            ],
+                            suppressedMessages: [],
+                            errorCount: 1,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            output: "var msg = \"hi\" + foo;\n",
+                            usedDeprecatedRules: [
+                                {
+                                    replacedBy: [],
+                                    ruleId: "semi"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "quotes"
+                                },
+                                {
+                                    replacedBy: [],
+                                    ruleId: "space-infix-ops"
+                                }
+                            ]
+                        }
+                    ]);
                 });
-                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test/test-custom-rule.js"))]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2, "Expected two messages.");
-                assert.strictEqual(results[0].messages[0].ruleId, "example/example-rule");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                // Cannot be run properly until cache is implemented
+                it("should run autofix even if files are cached without autofix results", async () => {
+                    const baseOptions = {
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: {
+                                semi: 2,
+                                quotes: [2, "double"],
+                                eqeqeq: 2,
+                                "no-undef": 2,
+                                "space-infix-ops": 2
+                            }
+                        }
+                    };
 
-            });
+                    eslint = new ESLint(Object.assign({}, baseOptions, { cache: true, fix: false }));
 
-            it("should return two messages when executing with cli option that specifies a plugin", async () => {
-                eslint = eslintWithPlugins({
-                    cwd: path.resolve(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: { "example/example-rule": 1 }
-                    }
-                });
-                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test", "test-custom-rule.js"))]);
+                    // Do initial lint run and populate the cache file
+                    await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "example/example-rule");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    eslint = new ESLint(Object.assign({}, baseOptions, { cache: true, fix: true }));
+                    const results = await eslint.lintFiles([path.resolve(fixtureDir, `${fixtureDir}/fixmode`)]);
 
+                    assert(results.some(result => result.output));
+                });
             });
 
-            it("should return two messages when executing with cli option that specifies preloaded plugin", async () => {
-                eslint = new ESLint({
-                    cwd: path.resolve(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        rules: { "test/example-rule": 1 }
-                    },
-                    plugins: {
-                        "eslint-plugin-test": { rules: { "example-rule": require("../../fixtures/rules/custom-rule") } }
-                    }
-                });
-                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test", "test-custom-rule.js"))]);
+            describe("plugins", () => {
+                it("should return two messages when executing with config file that specifies a plugin", async () => {
+                    eslint = eslintWithPlugins({
+                        flags,
+                        cwd: path.resolve(fixtureDir, ".."),
+                        overrideConfigFile: getFixturePath("configurations", "plugins-with-prefix.js")
+                    });
+                    const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test/test-custom-rule.js"))]);
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "test/example-rule");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2, "Expected two messages.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "example/example-rule");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-            });
-        });
+                });
 
-        describe("cache", () => {
+                it("should return two messages when executing with cli option that specifies a plugin", async () => {
+                    eslint = eslintWithPlugins({
+                        flags,
+                        cwd: path.resolve(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: { "example/example-rule": 1 }
+                        }
+                    });
+                    const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test", "test-custom-rule.js"))]);
 
-            /**
-             * helper method to delete a file without caring about exceptions
-             * @param {string} filePath The file path
-             * @returns {void}
-             */
-            function doDelete(filePath) {
-                try {
-                    fs.unlinkSync(filePath);
-                } catch {
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "example/example-rule");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                    /*
-                     * we don't care if the file didn't exist, since our
-                     * intention was to remove the file
-                     */
-                }
-            }
+                });
 
-            let cacheFilePath;
+                it("should return two messages when executing with cli option that specifies preloaded plugin", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.resolve(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            rules: { "test/example-rule": 1 }
+                        },
+                        plugins: {
+                            "eslint-plugin-test": { rules: { "example-rule": require("../../fixtures/rules/custom-rule") } }
+                        }
+                    });
+                    const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("rules", "test", "test-custom-rule.js"))]);
 
-            beforeEach(() => {
-                cacheFilePath = null;
-            });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "test/example-rule");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-            afterEach(() => {
-                sinon.restore();
-                if (cacheFilePath) {
-                    doDelete(cacheFilePath);
-                }
+                });
             });
 
-            describe("when cacheLocation is a directory or looks like a directory", () => {
+            describe("processors", () => {
 
-                const cwd = getFixturePath();
+                it("should return two messages when executing with config file that specifies preloaded processor", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        overrideConfig: [
+                            {
+                                plugins: {
+                                    test: {
+                                        processors: {
+                                            txt: {
+                                                preprocess(text) {
+                                                    return [text];
+                                                },
+                                                postprocess(messages) {
+                                                    return messages[0];
+                                                }
+                                            }
+                                        }
+                                    }
+                                },
+                                processor: "test/txt",
+                                rules: {
+                                    "no-console": 2,
+                                    "no-unused-vars": 2
+                                }
+                            },
+                            {
+                                files: ["**/*.txt", "**/*.txt/*.txt"]
+                            }
+                        ],
+                        cwd: path.join(fixtureDir, "..")
+                    });
+                    const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("processors", "test", "test-processor.txt"))]);
 
-                /**
-                 * helper method to delete the directory used in testing
-                 * @returns {void}
-                 */
-                function deleteCacheDir() {
-                    try {
-                        fs.rmSync(path.resolve(cwd, "tmp/.cacheFileDir/"), { recursive: true, force: true });
-                    } catch {
-
-                        /*
-                         * we don't care if the file didn't exist, since our
-                         * intention was to remove the file
-                         */
-                    }
-                }
-                beforeEach(() => {
-                    deleteCacheDir();
-                });
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                afterEach(() => {
-                    deleteCacheDir();
                 });
 
-                it("should create the directory and the cache file inside it when cacheLocation ends with a slash", async () => {
-                    assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
-
+                it("should run processors when calling lintFiles with config file that specifies preloaded processor", async () => {
                     eslint = new ESLint({
+                        flags,
                         overrideConfigFile: true,
-                        cwd,
-
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: "./tmp/.cacheFileDir/",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
+                        overrideConfig: [
+                            {
+                                plugins: {
+                                    test: {
+                                        processors: {
+                                            txt: {
+                                                preprocess(text) {
+                                                    return [text.replace("a()", "b()")];
+                                                },
+                                                postprocess(messages) {
+                                                    messages[0][0].ruleId = "post-processed";
+                                                    return messages[0];
+                                                }
+                                            }
+                                        }
+                                    }
+                                },
+                                processor: "test/txt",
+                                rules: {
+                                    "no-console": 2,
+                                    "no-unused-vars": 2
+                                }
+                            },
+                            {
+                                files: ["**/*.txt", "**/*.txt/*.txt"]
                             }
-                        },
-                        ignore: false
+                        ],
+                        cwd: path.join(fixtureDir, "..")
                     });
-                    const file = getFixturePath("cache/src", "test-file.js");
+                    const results = await eslint.lintFiles([getFixturePath("processors", "test", "test-processor.txt")]);
 
-                    await eslint.lintFiles([file]);
+                    assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                    assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
                 });
 
-                it("should create the cache file inside existing cacheLocation directory when cacheLocation ends with a slash", async () => {
-                    assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
-
-                    fs.mkdirSync(path.resolve(cwd, "./tmp/.cacheFileDir/"), { recursive: true });
-
+                it("should run processors when calling lintText with config file that specifies preloaded processor", async () => {
                     eslint = new ESLint({
+                        flags,
                         overrideConfigFile: true,
-                        cwd,
-
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: "./tmp/.cacheFileDir/",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
+                        overrideConfig: [
+                            {
+                                plugins: {
+                                    test: {
+                                        processors: {
+                                            txt: {
+                                                preprocess(text) {
+                                                    return [text.replace("a()", "b()")];
+                                                },
+                                                postprocess(messages) {
+                                                    messages[0][0].ruleId = "post-processed";
+                                                    return messages[0];
+                                                }
+                                            }
+                                        }
+                                    }
+                                },
+                                processor: "test/txt",
+                                rules: {
+                                    "no-console": 2,
+                                    "no-unused-vars": 2
+                                }
+                            },
+                            {
+                                files: ["**/*.txt", "**/*.txt/*.txt"]
                             }
-                        },
+                        ],
                         ignore: false
                     });
-                    const file = getFixturePath("cache/src", "test-file.js");
-
-                    await eslint.lintFiles([file]);
+                    const results = await eslint.lintText("function a() {console.log(\"Test\");}", { filePath: "tests/fixtures/processors/test/test-processor.txt" });
 
-                    assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
+                    assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
 
-                it("should create the cache file inside existing cacheLocation directory when cacheLocation doesn't end with a path separator", async () => {
-                    assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
-
-                    fs.mkdirSync(path.resolve(cwd, "./tmp/.cacheFileDir/"), { recursive: true });
+                it("should run processors when calling lintText with processor resolves same extension but different content correctly", async () => {
+                    let count = 0;
 
                     eslint = new ESLint({
+                        flags,
                         overrideConfigFile: true,
-                        cwd,
-
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: "./tmp/.cacheFileDir",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
+                        overrideConfig: [
+                            {
+                                plugins: {
+                                    test: {
+                                        processors: {
+                                            txt: {
+                                                preprocess(text) {
+                                                    count++;
+                                                    return [
+                                                        {
+
+                                                            // it will be run twice, and text will be as-is at the second time, then it will not run third time
+                                                            text: text.replace("a()", "b()"),
+                                                            filename: ".txt"
+                                                        }
+                                                    ];
+                                                },
+                                                postprocess(messages) {
+                                                    messages[0][0].ruleId = "post-processed";
+                                                    return messages[0];
+                                                }
+                                            }
+                                        }
+                                    }
+                                },
+                                processor: "test/txt"
+                            },
+                            {
+                                files: ["**/*.txt/*.txt"],
+                                rules: {
+                                    "no-console": 2,
+                                    "no-unused-vars": 2
+                                }
+                            },
+                            {
+                                files: ["**/*.txt"]
                             }
-                        },
+                        ],
                         ignore: false
                     });
-                    const file = getFixturePath("cache/src", "test-file.js");
+                    const results = await eslint.lintText("function a() {console.log(\"Test\");}", { filePath: "tests/fixtures/processors/test/test-processor.txt" });
 
-                    await eslint.lintFiles([file]);
+                    assert.strictEqual(count, 2);
+                    assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                    assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
                 });
-            });
 
-            it("should create the cache file inside cwd when no cacheLocation provided", async () => {
-                const cwd = path.resolve(getFixturePath("cli-engine"));
+                describe("autofixing with processors", () => {
+                    const HTML_PROCESSOR = Object.freeze({
+                        preprocess(text) {
+                            return [text.replace(/^<script>/u, "").replace(/<\/script>$/u, "")];
+                        },
+                        postprocess(problemLists) {
+                            return problemLists[0].map(problem => {
+                                if (problem.fix) {
+                                    const updatedFix = Object.assign({}, problem.fix, {
+                                        range: problem.fix.range.map(index => index + "<script>".length)
+                                    });
+
+                                    return Object.assign({}, problem, { fix: updatedFix });
+                                }
+                                return problem;
+                            });
+                        }
+                    });
 
-                cacheFilePath = path.resolve(cwd, ".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cache: true,
-                    cwd,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0
-                        }
-                    },
-                    ignore: false
+                    it("should run in autofix mode when using a processor that supports autofixing", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                {
+                                    files: ["**/*.html"],
+                                    plugins: {
+                                        test: { processors: { html: Object.assign({ supportsAutofix: true }, HTML_PROCESSOR) } }
+                                    },
+                                    processor: "test/html",
+                                    rules: {
+                                        semi: 2
+                                    }
+                                },
+                                {
+                                    files: ["**/*.txt"]
+                                }
+                            ],
+                            ignore: false,
+                            fix: true
+                        });
+                        const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
+
+                        assert.strictEqual(results[0].messages.length, 0);
+                        assert.strictEqual(results[0].suppressedMessages.length, 0);
+                        assert.strictEqual(results[0].output, "<script>foo;</script>");
+                    });
+
+                    it("should not run in autofix mode when using a processor that does not support autofixing", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: {
+                                files: ["**/*.html"],
+                                plugins: {
+                                    test: { processors: { html: HTML_PROCESSOR } }
+                                },
+                                processor: "test/html",
+                                rules: {
+                                    semi: 2
+                                }
+                            },
+                            ignore: false,
+                            fix: true
+                        });
+                        const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
+
+                        assert.strictEqual(results[0].messages.length, 1);
+                        assert.strictEqual(results[0].suppressedMessages.length, 0);
+                        assert(!Object.hasOwn(results[0], "output"));
+                    });
+
+                    it("should not run in autofix mode when `fix: true` is not provided, even if the processor supports autofixing", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                {
+                                    files: ["**/*.html"],
+                                    plugins: {
+                                        test: { processors: { html: Object.assign({ supportsAutofix: true }, HTML_PROCESSOR) } }
+                                    },
+                                    processor: "test/html",
+                                    rules: {
+                                        semi: 2
+                                    }
+                                },
+                                {
+                                    files: ["**/*.txt"]
+                                }
+                            ],
+                            ignore: false
+                        });
+                        const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
+
+                        assert.strictEqual(results[0].messages.length, 1);
+                        assert.strictEqual(results[0].suppressedMessages.length, 0);
+                        assert(!Object.hasOwn(results[0], "output"));
+                    });
                 });
-                const file = getFixturePath("cli-engine", "console.js");
 
-                await eslint.lintFiles([file]);
+                describe("matching and ignoring code blocks", () => {
+                    const pluginConfig = {
+                        files: ["**/*.md"],
+                        plugins: {
+                            markdown: exampleMarkdownPlugin
+                        },
+                        processor: "markdown/markdown"
+                    };
+                    const text = unIndent`
+                        \`\`\`js
+                        foo_js
+                        \`\`\`
+
+                        \`\`\`ts
+                        foo_ts
+                        \`\`\`
+
+                        \`\`\`cjs
+                        foo_cjs
+                        \`\`\`
+
+                        \`\`\`mjs
+                        foo_mjs
+                        \`\`\`
+                    `;
+
+                    it("should by default lint only .js, .mjs, and .cjs virtual files", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                pluginConfig,
+                                {
+                                    rules: {
+                                        "no-undef": 2
+                                    }
+                                }
+                            ]
+                        });
+                        const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+
+                        assert.strictEqual(result.messages.length, 3);
+                        assert.strictEqual(result.messages[0].ruleId, "no-undef");
+                        assert.match(result.messages[0].message, /foo_js/u);
+                        assert.strictEqual(result.messages[0].line, 2);
+                        assert.strictEqual(result.messages[1].ruleId, "no-undef");
+                        assert.match(result.messages[1].message, /foo_cjs/u);
+                        assert.strictEqual(result.messages[1].line, 10);
+                        assert.strictEqual(result.messages[2].ruleId, "no-undef");
+                        assert.match(result.messages[2].message, /foo_mjs/u);
+                        assert.strictEqual(result.messages[2].line, 14);
+                    });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created at provided cwd");
-            });
+                    it("should lint additional virtual files that match non-universal patterns", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                pluginConfig,
+                                {
+                                    rules: {
+                                        "no-undef": 2
+                                    }
+                                },
+                                {
+                                    files: ["**/*.ts"]
+                                }
+                            ]
+                        });
+                        const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+
+                        assert.strictEqual(result.messages.length, 4);
+                        assert.strictEqual(result.messages[0].ruleId, "no-undef");
+                        assert.match(result.messages[0].message, /foo_js/u);
+                        assert.strictEqual(result.messages[0].line, 2);
+                        assert.strictEqual(result.messages[1].ruleId, "no-undef");
+                        assert.match(result.messages[1].message, /foo_ts/u);
+                        assert.strictEqual(result.messages[1].line, 6);
+                        assert.strictEqual(result.messages[2].ruleId, "no-undef");
+                        assert.match(result.messages[2].message, /foo_cjs/u);
+                        assert.strictEqual(result.messages[2].line, 10);
+                        assert.strictEqual(result.messages[3].ruleId, "no-undef");
+                        assert.match(result.messages[3].message, /foo_mjs/u);
+                        assert.strictEqual(result.messages[3].line, 14);
+                    });
 
-            it("should invalidate the cache if the overrideConfig changed between executions", async () => {
-                const cwd = getFixturePath("cache/src");
+                    // https://github.com/eslint/eslint/issues/18493
+                    it("should silently skip virtual files that match only universal patterns", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                pluginConfig,
+                                {
+                                    files: ["**/*"],
+                                    rules: {
+                                        "no-undef": 2
+                                    }
+                                }
+                            ]
+                        });
+                        const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+
+                        assert.strictEqual(result.messages.length, 3);
+                        assert.strictEqual(result.messages[0].ruleId, "no-undef");
+                        assert.match(result.messages[0].message, /foo_js/u);
+                        assert.strictEqual(result.messages[0].line, 2);
+                        assert.strictEqual(result.messages[1].ruleId, "no-undef");
+                        assert.match(result.messages[1].message, /foo_cjs/u);
+                        assert.strictEqual(result.messages[1].line, 10);
+                        assert.strictEqual(result.messages[2].ruleId, "no-undef");
+                        assert.match(result.messages[2].message, /foo_mjs/u);
+                        assert.strictEqual(result.messages[2].line, 14);
+                    });
 
-                cacheFilePath = path.resolve(cwd, ".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    it("should silently skip virtual files that are ignored by global ignores", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                pluginConfig,
+                                {
+                                    rules: {
+                                        "no-undef": 2
+                                    }
+                                },
+                                {
+                                    ignores: ["**/*.cjs"]
+                                }
+                            ]
+                        });
+                        const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+
+                        assert.strictEqual(result.messages.length, 2);
+                        assert.strictEqual(result.messages[0].ruleId, "no-undef");
+                        assert.match(result.messages[0].message, /foo_js/u);
+                        assert.strictEqual(result.messages[0].line, 2);
+                        assert.strictEqual(result.messages[1].ruleId, "no-undef");
+                        assert.match(result.messages[1].message, /foo_mjs/u);
+                        assert.strictEqual(result.messages[1].line, 14);
+                    });
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd,
+                    // https://github.com/eslint/eslint/issues/15949
+                    it("should silently skip virtual files that are ignored by global ignores even if they match non-universal patterns", async () => {
+                        eslint = new ESLint({
+                            flags,
+                            overrideConfigFile: true,
+                            overrideConfig: [
+                                pluginConfig,
+                                {
+                                    rules: {
+                                        "no-undef": 2
+                                    }
+                                },
+                                {
+                                    files: ["**/*.ts"]
+                                },
+                                {
+                                    ignores: ["**/*.md/*.ts"]
+                                }
+                            ]
+                        });
+                        const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+
+                        assert.strictEqual(result.messages.length, 3);
+                        assert.strictEqual(result.messages[0].ruleId, "no-undef");
+                        assert.match(result.messages[0].message, /foo_js/u);
+                        assert.strictEqual(result.messages[0].line, 2);
+                        assert.strictEqual(result.messages[1].ruleId, "no-undef");
+                        assert.match(result.messages[1].message, /foo_cjs/u);
+                        assert.strictEqual(result.messages[1].line, 10);
+                        assert.strictEqual(result.messages[2].ruleId, "no-undef");
+                        assert.match(result.messages[2].message, /foo_mjs/u);
+                        assert.strictEqual(result.messages[2].line, 14);
+                    });
+                });
+            });
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    },
-                    ignore: false
+            describe("Patterns which match no file should throw errors.", () => {
+                beforeEach(() => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: getFixturePath("cli-engine"),
+                        overrideConfigFile: true
+                    });
                 });
 
-                let spy = sinon.spy(fs.promises, "readFile");
+                it("one file", async () => {
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["non-exist.js"]);
+                    }, /No files matching 'non-exist\.js' were found\./u);
+                });
+
+                it("should throw if the directory exists and is empty", async () => {
+                    ensureDirectoryExists(getFixturePath("cli-engine/empty"));
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["empty"]);
+                    }, /No files matching 'empty' were found\./u);
+                });
+
+                it("one glob pattern", async () => {
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["non-exist/**/*.js"]);
+                    }, /No files matching 'non-exist\/\*\*\/\*\.js' were found\./u);
+                });
+
+                it("two files", async () => {
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["aaa.js", "bbb.js"]);
+                    }, /No files matching 'aaa\.js' were found\./u);
+                });
+
+                it("a mix of an existing file and a non-existing file", async () => {
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["console.js", "non-exist.js"]);
+                    }, /No files matching 'non-exist\.js' were found\./u);
+                });
+
+                // https://github.com/eslint/eslint/issues/16275
+                it("a mix of an existing glob pattern and a non-existing glob pattern", async () => {
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["*.js", "non-exist/*.js"]);
+                    }, /No files matching 'non-exist\/\*\.js' were found\./u);
+                });
+            });
+
+            describe("multiple processors", () => {
+                const root = path.join(os.tmpdir(), "eslint/eslint/multiple-processors");
+                const commonFiles = {
+                    "node_modules/pattern-processor/index.js": fs.readFileSync(
+                        require.resolve("../../fixtures/processors/pattern-processor"),
+                        "utf8"
+                    ),
+                    "node_modules/eslint-plugin-markdown/index.js": `
+                        const { defineProcessor } = require("pattern-processor");
+                        const processor = defineProcessor(${/```(\w+)\n([\s\S]+?)\n```/gu});
+                        exports.processors = {
+                            "markdown": { ...processor, supportsAutofix: true },
+                            "non-fixable": processor
+                        };
+                    `,
+                    "node_modules/eslint-plugin-html/index.js": `
+                        const { defineProcessor } = require("pattern-processor");
+                        const processor = defineProcessor(${/<script lang="(\w*)">\n([\s\S]+?)\n<\/script>/gu});
+                        const legacyProcessor = defineProcessor(${/<script lang="(\w*)">\n([\s\S]+?)\n<\/script>/gu}, true);
+                        exports.processors = {
+                            "html": { ...processor, supportsAutofix: true },
+                            "non-fixable": processor,
+                            "legacy": legacyProcessor
+                        };
+                    `,
+                    "test.md": unIndent`
+                        \`\`\`js
+                        console.log("hello")
+                        \`\`\`
+                        \`\`\`html
+                        <div>Hello</div>
+                        <script lang="js">
+                            console.log("hello")
+                        </script>
+                        <script lang="ts">
+                            console.log("hello")
+                        </script>
+                        \`\`\`
+                    `
+                };
 
-                let file = path.join(cwd, "test-file.js");
+                // unique directory for each test to avoid quirky disk-cleanup errors
+                let id;
 
-                file = fs.realpathSync(file);
-                const results = await eslint.lintFiles([file]);
+                beforeEach(() => (id = Date.now().toString()));
 
-                for (const { errorCount, warningCount } of results) {
-                    assert.strictEqual(errorCount + warningCount, 0, "the file should have passed linting without errors or warnings");
+                /*
+                 * `fs.rmdir(path, { recursive: true })` is deprecated and will be removed.
+                 * Use `fs.rm(path, { recursive: true })` instead.
+                 * When supporting Node.js 14.14.0+, the compatibility condition can be removed for `fs.rmdir`.
+                 */
+                if (typeof fsp.rm === "function") {
+                    afterEach(async () => fsp.rm(root, { recursive: true, force: true }));
+                } else {
+                    afterEach(async () => fsp.rmdir(root, { recursive: true, force: true }));
                 }
 
-                assert(spy.calledWith(file), "ESLint should have read the file because there was no cache file");
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                it("should lint only JavaScript blocks.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    }
+                                },
+                                {
+                                    files: ["**/*.js"],
+                                    rules: { semi: "error" }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/markdown"
+                                }
+                            ];`
+                        }
+                    });
 
-                // destroy the spy
-                sinon.restore();
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
+                    const results = await eslint.lintFiles(["test.md"]);
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd,
+                    assert.strictEqual(results.length, 1, "Should have one result.");
+                    assert.strictEqual(results[0].messages.length, 1, "Should have one message.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "semi");
+                    assert.strictEqual(results[0].messages[0].line, 2, "Message should be on line 2.");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 2,
-                            "no-unused-vars": 2
-                        }
-                    },
-                    ignore: false
                 });
 
-                // create a new spy
-                spy = sinon.spy(fs.promises, "readFile");
+                it("should lint HTML blocks as well with multiple processors if represented in config.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    }
+                                },
+                                {
+                                    files: ["**/*.js"],
+                                    rules: { semi: "error" }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/markdown"
+                                },
+                                {
+                                    files: ["**/*.html"],
+                                    processor: "html/html"
+                                }
+                            ];`
+                        }
+                    });
 
-                const [newResult] = await eslint.lintFiles([file]);
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
+                    const results = await eslint.lintFiles(["test.md"]);
+
+                    assert.strictEqual(results.length, 1, "Should have one result.");
+                    assert.strictEqual(results[0].messages.length, 2, "Should have two messages.");
+                    assert.strictEqual(results[0].messages[0].ruleId, "semi"); // JS block
+                    assert.strictEqual(results[0].messages[0].line, 2, "First error should be on line 2");
+                    assert.strictEqual(results[0].messages[1].ruleId, "semi"); // JS block in HTML block
+                    assert.strictEqual(results[0].messages[1].line, 7, "Second error should be on line 7.");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                assert(spy.calledWith(file), "ESLint should have read the file again because it's considered changed because the config changed");
-                assert.strictEqual(newResult.errorCount, 1, "since configuration changed the cache should have not been used and one error should have been reported");
-                assert.strictEqual(newResult.messages[0].ruleId, "no-console");
-                assert(shell.test("-f", cacheFilePath), "The cache for ESLint should still exist");
-            });
+                it("should fix HTML blocks as well with multiple processors if represented in config.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    }
+                                },
+                                {
+                                    files: ["**/*.js"],
+                                    rules: { semi: "error" }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/markdown"
+                                },
+                                {
+                                    files: ["**/*.html"],
+                                    processor: "html/html"
+                                }
+                            ];`
+                        }
+                    });
 
-            it("should remember the files from a previous run and do not operate on them if not changed", async () => {
-                const cwd = getFixturePath("cache/src");
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] }, fix: true });
+                    const results = await eslint.lintFiles(["test.md"]);
 
-                cacheFilePath = path.resolve(cwd, ".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 0);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    assert.strictEqual(results[0].output, unIndent`
+                        \`\`\`js
+                        console.log("hello");${/*  fixed */""}
+                        \`\`\`
+                        \`\`\`html
+                        <div>Hello</div>
+                        <script lang="js">
+                            console.log("hello");${/*  fixed */""}
+                        </script>
+                        <script lang="ts">
+                            console.log("hello")${/*  ignored */""}
+                        </script>
+                        \`\`\`
+                    `);
+                });
+
+                it("should use the config '**/*.html/*.js' to lint JavaScript blocks in HTML.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    }
+                                },
+                                {
+                                    files: ["**/*.js"],
+                                    rules: { semi: "error" }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/markdown"
+                                },
+                                {
+                                    files: ["**/*.html"],
+                                    processor: "html/html"
+                                },
+                                {
+                                    files: ["**/*.html/*.js"],
+                                    rules: {
+                                        semi: "off",
+                                        "no-console": "error"
+                                    }
+                                }
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd,
+                            ];`
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
                         }
-                    },
-                    ignore: false
-                });
-
-                let spy = sinon.spy(fs.promises, "readFile");
+                    });
 
-                let file = getFixturePath("cache/src", "test-file.js");
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
+                    const results = await eslint.lintFiles(["test.md"]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "semi");
+                    assert.strictEqual(results[0].messages[0].line, 2);
+                    assert.strictEqual(results[0].messages[1].ruleId, "no-console");
+                    assert.strictEqual(results[0].messages[1].line, 7);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
 
-                file = fs.realpathSync(file);
+                });
 
-                const result = await eslint.lintFiles([file]);
+                it("should use the same config as one which has 'processor' property in order to lint blocks in HTML if the processor was legacy style.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    },
+                                    rules: { semi: "error" }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/markdown"
+                                },
+                                {
+                                    files: ["**/*.html"],
+                                    processor: "html/legacy",  // this processor returns strings rather than '{ text, filename }'
+                                    rules: {
+                                        semi: "off",
+                                        "no-console": "error"
+                                    }
+                                },
+                                {
+                                    files: ["**/*.html/*.js"],
+                                    rules: {
+                                        semi: "error",
+                                        "no-console": "off"
+                                    }
+                                }
 
-                assert(spy.calledWith(file), "ESLint should have read the file because there was no cache file");
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                            ];`
+                        }
+                    });
 
-                // destroy the spy
-                sinon.restore();
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
+                    const results = await eslint.lintFiles(["test.md"]);
+
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 3);
+                    assert.strictEqual(results[0].messages[0].ruleId, "semi");
+                    assert.strictEqual(results[0].messages[0].line, 2);
+                    assert.strictEqual(results[0].messages[1].ruleId, "no-console");
+                    assert.strictEqual(results[0].messages[1].line, 7);
+                    assert.strictEqual(results[0].messages[2].ruleId, "no-console");
+                    assert.strictEqual(results[0].messages[2].line, 10);
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    cwd,
+                it("should throw an error if invalid processor was specified.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: path.join(root, id),
+                        files: {
+                            ...commonFiles,
+                            "eslint.config.js": `module.exports = [
+                                {
+                                    plugins: {
+                                        markdown: require("eslint-plugin-markdown"),
+                                        html: require("eslint-plugin-html")
+                                    }
+                                },
+                                {
+                                    files: ["**/*.md"],
+                                    processor: "markdown/unknown"
+                                }
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
+                            ];`
                         }
-                    },
-                    ignore: false
-                });
-
-                // create a new spy
-                spy = sinon.spy(fs.promises, "readFile");
+                    });
 
-                const cachedResult = await eslint.lintFiles([file]);
+                    await teardown.prepare();
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                assert.deepStrictEqual(result, cachedResult, "the result should have been the same");
+                    await assert.rejects(async () => {
+                        await eslint.lintFiles(["test.md"]);
+                    }, /Key "processor": Could not find "unknown" in plugin "markdown"/u);
+                });
 
-                // assert the file was not processed because the cache was used
-                assert(!spy.calledWith(file), "the file should not have been reloaded");
             });
 
-            it("when `cacheLocation` is specified, should create the cache file with `cache:true` and then delete it with `cache:false`", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+            describe("glob pattern '[ab].js'", () => {
+                const root = getFixturePath("cli-engine/unmatched-glob");
 
-                const eslintOptions = {
-                    overrideConfigFile: true,
+                let cleanup;
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    },
-                    cwd: path.join(fixtureDir, "..")
-                };
+                beforeEach(() => {
+                    cleanup = () => { };
+                });
 
-                eslint = new ESLint(eslintOptions);
+                afterEach(() => cleanup());
 
-                let file = getFixturePath("cache/src", "test-file.js");
+                it("should match '[ab].js' if existed.", async () => {
 
-                file = fs.realpathSync(file);
+                    const teardown = createCustomTeardown({
+                        cwd: root,
+                        files: {
+                            "a.js": "",
+                            "b.js": "",
+                            "ab.js": "",
+                            "[ab].js": "",
+                            "eslint.config.js": "module.exports = [];"
+                        }
+                    });
 
-                await eslint.lintFiles([file]);
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
+                    const results = await eslint.lintFiles(["[ab].js"]);
+                    const filenames = results.map(r => path.basename(r.filePath));
 
-                eslintOptions.cache = false;
-                eslint = new ESLint(eslintOptions);
+                    assert.deepStrictEqual(filenames, ["[ab].js"]);
+                });
 
-                await eslint.lintFiles([file]);
+                it("should match 'a.js' and 'b.js' if '[ab].js' didn't existed.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: root,
+                        files: {
+                            "a.js": "",
+                            "b.js": "",
+                            "ab.js": "",
+                            "eslint.config.js": "module.exports = [];"
+                        }
+                    });
+
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
+                    const results = await eslint.lintFiles(["[ab].js"]);
+                    const filenames = results.map(r => path.basename(r.filePath));
 
-                assert(!shell.test("-f", cacheFilePath), "the cache for eslint should have been deleted since last run did not use the cache");
+                    assert.deepStrictEqual(filenames, ["a.js", "b.js"]);
+                });
             });
 
-            it("should not throw an error if the cache file to be deleted does not exist on a read-only file system", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+            describe("with 'noInlineConfig' setting", () => {
+                const root = getFixturePath("cli-engine/noInlineConfig");
 
-                // Simulate a read-only file system.
-                sinon.stub(fsp, "unlink").rejects(
-                    Object.assign(new Error("read-only file system"), { code: "EROFS" })
-                );
+                let cleanup;
 
-                const eslintOptions = {
-                    overrideConfigFile: true,
+                beforeEach(() => {
+                    cleanup = () => { };
+                });
 
-                    // specifying cache false the cache will be deleted
-                    cache: false,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
+                afterEach(() => cleanup());
+
+                it("should warn directive comments if 'noInlineConfig' was given.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: root,
+                        files: {
+                            "test.js": "/* globals foo */",
+                            "eslint.config.js": "module.exports = [{ linterOptions: { noInlineConfig: true } }];"
                         }
-                    },
-                    cwd: path.join(fixtureDir, "..")
-                };
+                    });
 
-                eslint = new ESLint(eslintOptions);
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                const file = getFixturePath("cache/src", "test-file.js");
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                await eslint.lintFiles([file]);
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].message, "'/* globals foo */' has no effect because you have 'noInlineConfig' setting in your config.");
+                });
 
-                assert(fsp.unlink.calledWithExactly(cacheFilePath), "Expected attempt to delete the cache was not made.");
             });
 
-            it("should store in the cache a file that has lint messages and a file that doesn't have lint messages", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+            describe("with 'reportUnusedDisableDirectives' setting", () => {
+                const root = getFixturePath("cli-engine/reportUnusedDisableDirectives");
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
+                let cleanup;
+                let i = 0;
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    }
+                beforeEach(() => {
+                    cleanup = () => { };
+                    i++;
                 });
-                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
-                const result = await eslint.lintFiles([badFile, goodFile]);
-                const [badFileResult, goodFileResult] = result;
 
-                assert.notStrictEqual(badFileResult.errorCount + badFileResult.warningCount, 0, "the bad file should have some lint errors or warnings");
-                assert.strictEqual(goodFileResult.errorCount + badFileResult.warningCount, 0, "the good file should have passed linting without errors or warnings");
+                afterEach(() => cleanup());
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
-
-                const fileCache = fCache.createFromFile(cacheFilePath);
-                const { cache } = fileCache;
+                it("should error unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = error'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'error' } }"
+                        }
+                    });
 
-                assert.strictEqual(typeof cache.getKey(goodFile), "object", "the entry for the good file should have been in the cache");
-                assert.strictEqual(typeof cache.getKey(badFile), "object", "the entry for the bad file should have been in the cache");
-                const cachedResult = await eslint.lintFiles([badFile, goodFile]);
 
-                assert.deepStrictEqual(result, cachedResult, "result should be the same with or without cache");
-            });
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-            it("should not contain in the cache a file that was deleted", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].severity, 2);
+                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
+                it("should error unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 2'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 2 } }"
                         }
-                    }
+                    });
+
+
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
+
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
+
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].severity, 2);
+                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
-                const toBeDeletedFile = fs.realpathSync(getFixturePath("cache/src", "file-to-delete.js"));
 
-                await eslint.lintFiles([badFile, goodFile, toBeDeletedFile]);
-                const fileCache = fCache.createFromFile(cacheFilePath);
-                let { cache } = fileCache;
+                it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = warn'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'warn' } }"
+                        }
+                    });
+
 
-                assert.strictEqual(typeof cache.getKey(toBeDeletedFile), "object", "the entry for the file to be deleted should have been in the cache");
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                // delete the file from the file system
-                fs.unlinkSync(toBeDeletedFile);
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                /*
-                 * file-entry-cache@2.0.0 will remove from the cache deleted files
-                 * even when they were not part of the array of files to be analyzed
-                 */
-                await eslint.lintFiles([badFile, goodFile]);
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].severity, 1);
+                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                cache = JSON.parse(fs.readFileSync(cacheFilePath));
+                it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 1'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 1 } }"
+                        }
+                    });
 
-                assert.strictEqual(typeof cache[0][toBeDeletedFile], "undefined", "the entry for the file to be deleted should not have been in the cache");
 
-                // make sure that the previos assertion checks the right place
-                assert.notStrictEqual(typeof cache[0][badFile], "undefined", "the entry for the bad file should have been in the cache");
-                assert.notStrictEqual(typeof cache[0][goodFile], "undefined", "the entry for the good file should have been in the cache");
-            });
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-            it("should contain files that were not visited in the cache provided they still exist", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].severity, 1);
+                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
+                it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = true'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: true } }"
                         }
-                    }
-                });
-                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
-                const testFile2 = fs.realpathSync(getFixturePath("cache/src", "test-file2.js"));
+                    });
 
-                await eslint.lintFiles([badFile, goodFile, testFile2]);
 
-                let fileCache = fCache.createFromFile(cacheFilePath);
-                let { cache } = fileCache;
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                assert.strictEqual(typeof cache.getKey(testFile2), "object", "the entry for the test-file2 should have been in the cache");
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                /*
-                 * we pass a different set of files (minus test-file2)
-                 * previous version of file-entry-cache would remove the non visited
-                 * entries. 2.0.0 version will keep them unless they don't exist
-                 */
-                await eslint.lintFiles([badFile, goodFile]);
+                    assert.strictEqual(messages.length, 1);
+                    assert.strictEqual(messages[0].severity, 1);
+                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                    assert.strictEqual(results[0].suppressedMessages.length, 0);
+                });
 
-                fileCache = fCache.createFromFile(cacheFilePath);
-                cache = fileCache.cache;
+                it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = false'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: false } }"
+                        }
+                    });
 
-                assert.strictEqual(typeof cache.getKey(testFile2), "object", "the entry for the test-file2 should have been in the cache");
-            });
 
-            it("should not delete cache when executing on text", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    }
+                    assert.strictEqual(messages.length, 0);
                 });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
-
-                await eslint.lintText("var foo = 'bar';");
+                it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = off'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'off' } }"
+                        }
+                    });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
-            });
 
-            it("should not delete cache when executing on text with a provided filename", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    }
+                    assert.strictEqual(messages.length, 0);
                 });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
-
-                await eslint.lintText("var bar = foo;", { filePath: "fixtures/passing.js" });
+                it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 0'.", async () => {
+                    const teardown = createCustomTeardown({
+                        cwd: `${root}${i}`,
+                        files: {
+                            "test.js": "/* eslint-disable eqeqeq */",
+                            "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 0 } }"
+                        }
+                    });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
-            });
 
-            it("should not delete cache when executing on files with --cache flag", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    await teardown.prepare();
+                    cleanup = teardown.cleanup;
+                    eslint = new ESLint({ flags, cwd: teardown.getPath() });
 
-                fs.writeFileSync(cacheFilePath, "");
+                    const results = await eslint.lintFiles(["test.js"]);
+                    const messages = results[0].messages;
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    }
+                    assert.strictEqual(messages.length, 0);
                 });
-                const file = getFixturePath("cli-engine", "console.js");
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
+                describe("the runtime option overrides config files.", () => {
+                    it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives=off' was given in runtime.", async () => {
+                        const teardown = createCustomTeardown({
+                            cwd: `${root}${i}`,
+                            files: {
+                                "test.js": "/* eslint-disable eqeqeq */",
+                                "eslint.config.js": "module.exports = [{ linterOptions: { reportUnusedDisableDirectives: true } }]"
+                            }
+                        });
 
-                await eslint.lintFiles([file]);
+                        await teardown.prepare();
+                        cleanup = teardown.cleanup;
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
-            });
+                        eslint = new ESLint({
+                            flags,
+                            cwd: teardown.getPath(),
+                            overrideConfig: {
+                                linterOptions: { reportUnusedDisableDirectives: "off" }
+                            }
+                        });
 
-            it("should delete cache when executing on files without --cache flag", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                        const results = await eslint.lintFiles(["test.js"]);
+                        const messages = results[0].messages;
 
-                fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+                        assert.strictEqual(messages.length, 0);
+                    });
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    }
-                });
-                const file = getFixturePath("cli-engine", "console.js");
+                    it("should warn unused 'eslint-disable' comments as error if 'reportUnusedDisableDirectives=error' was given in runtime.", async () => {
+                        const teardown = createCustomTeardown({
+                            cwd: `${root}${i}`,
+                            files: {
+                                "test.js": "/* eslint-disable eqeqeq */",
+                                "eslint.config.js": "module.exports = [{ linterOptions: { reportUnusedDisableDirectives: true } }]"
+                            }
+                        });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
+                        await teardown.prepare();
+                        cleanup = teardown.cleanup;
 
-                await eslint.lintFiles([file]);
+                        eslint = new ESLint({
+                            flags,
+                            cwd: teardown.getPath(),
+                            overrideConfig: {
+                                linterOptions: { reportUnusedDisableDirectives: "error" }
+                            }
+                        });
 
-                assert(!shell.test("-f", cacheFilePath), "the cache for eslint should have been deleted");
+                        const results = await eslint.lintFiles(["test.js"]);
+                        const messages = results[0].messages;
+
+                        assert.strictEqual(messages.length, 1);
+                        assert.strictEqual(messages[0].severity, 2);
+                        assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
+                        assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    });
+                });
             });
 
-            it("should use the specified cache file", async () => {
-                cacheFilePath = path.resolve(".cache/custom-cache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+            it("should throw if non-boolean value is given to 'options.warnIgnored' option", async () => {
+                eslint = new ESLint({ flags });
+                await assert.rejects(() => eslint.lintFiles(777), /'patterns' must be a non-empty string or an array of non-empty strings/u);
+                await assert.rejects(() => eslint.lintFiles([null]), /'patterns' must be a non-empty string or an array of non-empty strings/u);
+            });
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
+            describe("Alternate config files", () => {
 
-                    // specify a custom cache file
-                    cacheLocation: cacheFilePath,
+                it("should find eslint.config.mjs when present", async () => {
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    overrideConfig: {
-                        rules: {
-                            "no-console": 0,
-                            "no-unused-vars": 2
-                        }
-                    },
+                    const cwd = getFixturePath("mjs-config");
 
-                    cwd: path.join(fixtureDir, "..")
-                });
-                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
-                const result = await eslint.lintFiles([badFile, goodFile]);
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                    const results = await eslint.lintFiles("foo.js");
 
-                const fileCache = fCache.createFromFile(cacheFilePath);
-                const { cache } = fileCache;
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                assert(typeof cache.getKey(goodFile) === "object", "the entry for the good file should have been in the cache");
-                assert(typeof cache.getKey(badFile) === "object", "the entry for the bad file should have been in the cache");
+                });
 
-                const cachedResult = await eslint.lintFiles([badFile, goodFile]);
+                it("should find eslint.config.cjs when present", async () => {
 
-                assert.deepStrictEqual(result, cachedResult, "result should be the same with or without cache");
-            });
+                    const cwd = getFixturePath("cjs-config");
 
-            // https://github.com/eslint/eslint/issues/13507
-            it("should not store `usedDeprecatedRules` in the cache file", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-                const deprecatedRuleId = "space-in-parens";
+                    const results = await eslint.lintFiles("foo.js");
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 1);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            [deprecatedRuleId]: 2
-                        }
-                    }
                 });
 
-                const filePath = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+                it("should favor eslint.config.js when eslint.config.mjs and eslint.config.cjs are present", async () => {
 
-                /*
-                 * Run linting on the same file 3 times to cover multiple cases:
-                 *   Run 1: Lint result wasn't already cached.
-                 *   Run 2: Lint result was already cached. The cached lint result is used but the cache is reconciled before the run ends.
-                 *   Run 3: Lint result was already cached. The cached lint result was being used throughout the previous run, so possible
-                 *     mutations in the previous run that occured after the cache was reconciled may have side effects for this run.
-                 */
-                for (let i = 0; i < 3; i++) {
-                    const [result] = await eslint.lintFiles([filePath]);
+                    const cwd = getFixturePath("js-mjs-cjs-config");
 
-                    assert(
-                        result.usedDeprecatedRules && result.usedDeprecatedRules.some(rule => rule.ruleId === deprecatedRuleId),
-                        "the deprecated rule should have been in result.usedDeprecatedRules"
-                    );
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-                    assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                    const results = await eslint.lintFiles("foo.js");
 
-                    const fileCache = fCache.create(cacheFilePath);
-                    const descriptor = fileCache.getFileDescriptor(filePath);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 0);
+                });
 
-                    assert(typeof descriptor === "object", "an entry for the file should have been in the cache file");
-                    assert(typeof descriptor.meta.results === "object", "lint result for the file should have been in its cache entry in the cache file");
-                    assert(typeof descriptor.meta.results.usedDeprecatedRules === "undefined", "lint result in the cache file contains `usedDeprecatedRules`");
-                }
+                it("should favor eslint.config.mjs when eslint.config.cjs is present", async () => {
 
-            });
+                    const cwd = getFixturePath("mjs-cjs-config");
 
-            // https://github.com/eslint/eslint/issues/13507
-            it("should store `source` as `null` in the cache file if the lint result has `source` property", async () => {
-                cacheFilePath = getFixturePath(".eslintcache");
-                doDelete(cacheFilePath);
-                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                    eslint = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
+                    const results = await eslint.lintFiles("foo.js");
 
-                    // specifying cache true the cache will be created
-                    cache: true,
-                    cacheLocation: cacheFilePath,
-                    overrideConfig: {
-                        rules: {
-                            "no-unused-vars": 2
-                        }
-                    }
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
                 });
+            });
 
-                const filePath = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+            describe("TypeScript config files", () => {
+                const typeModule = JSON.stringify({ type: "module" }, null, 2);
 
-                /*
-                 * Run linting on the same file 3 times to cover multiple cases:
-                 *   Run 1: Lint result wasn't already cached.
-                 *   Run 2: Lint result was already cached. The cached lint result is used but the cache is reconciled before the run ends.
-                 *   Run 3: Lint result was already cached. The cached lint result was being used throughout the previous run, so possible
-                 *     mutations in the previous run that occured after the cache was reconciled may have side effects for this run.
-                 */
-                for (let i = 0; i < 3; i++) {
-                    const [result] = await eslint.lintFiles([filePath]);
+                const typeCommonJS = JSON.stringify({ type: "commonjs" }, null, 2);
 
-                    assert(typeof result.source === "string", "the result should have contained the `source` property");
+                const newFlags = flags.concat("unstable_ts_config");
 
-                    assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+                it("should find and load eslint.config.ts when present", async () => {
 
-                    const fileCache = fCache.create(cacheFilePath);
-                    const descriptor = fileCache.getFileDescriptor(filePath);
+                    const cwd = getFixturePath("ts-config-files", "ts");
 
-                    assert(typeof descriptor === "object", "an entry for the file should have been in the cache file");
-                    assert(typeof descriptor.meta.results === "object", "lint result for the file should have been in its cache entry in the cache file");
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                    // if the lint result contains `source`, it should be stored as `null` in the cache file
-                    assert.strictEqual(descriptor.meta.results.source, null, "lint result in the cache file contains non-null `source`");
-                }
+                    const results = await eslint.lintFiles("foo.js");
 
-            });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            describe("cacheStrategy", () => {
-                it("should detect changes using a file's modification time when set to 'metadata'", async () => {
-                    cacheFilePath = getFixturePath(".eslintcache");
-                    doDelete(cacheFilePath);
-                    assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                });
 
-                    eslint = new ESLint({
-                        cwd: path.join(fixtureDir, ".."),
-                        overrideConfigFile: true,
+                it("should load eslint.config.ts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: cacheFilePath,
-                        cacheStrategy: "metadata",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
-                            }
-                        }
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs");
 
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
                     });
-                    const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                    const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
 
-                    await eslint.lintFiles([badFile, goodFile]);
-                    let fileCache = fCache.createFromFile(cacheFilePath);
-                    const entries = fileCache.normalizeEntries([badFile, goodFile]);
+                    const results = await eslint.lintFiles("foo.js");
 
-                    entries.forEach(entry => {
-                        assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
-                    });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    // this should result in a changed entry
-                    shell.touch(goodFile);
-                    fileCache = fCache.createFromFile(cacheFilePath);
-                    assert(fileCache.getFileDescriptor(badFile).changed === false, `the entry for ${badFile} should have been unchanged`);
-                    assert(fileCache.getFileDescriptor(goodFile).changed === true, `the entry for ${goodFile} should have been changed`);
                 });
 
-                it("should not detect changes using a file's modification time when set to 'content'", async () => {
-                    cacheFilePath = getFixturePath(".eslintcache");
-                    doDelete(cacheFilePath);
-                    assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
-
-                    eslint = new ESLint({
-                        cwd: path.join(fixtureDir, ".."),
-                        overrideConfigFile: true,
+                it("should load eslint.config.ts when we have \"type\": \"module\" in nearest `package.json`", async () => {
 
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: cacheFilePath,
-                        cacheStrategy: "content",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
-                            }
-                        }
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module");
 
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
                     });
-                    const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                    const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
 
-                    await eslint.lintFiles([badFile, goodFile]);
-                    let fileCache = fCache.createFromFile(cacheFilePath, true);
-                    let entries = fileCache.normalizeEntries([badFile, goodFile]);
+                    const results = await eslint.lintFiles("foo.js");
 
-                    entries.forEach(entry => {
-                        assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
-                    });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    // this should NOT result in a changed entry
-                    shell.touch(goodFile);
-                    fileCache = fCache.createFromFile(cacheFilePath, true);
-                    entries = fileCache.normalizeEntries([badFile, goodFile]);
-                    entries.forEach(entry => {
-                        assert(entry.changed === false, `the entry for ${entry.key} should have remained unchanged`);
-                    });
                 });
 
-                it("should detect changes using a file's contents when set to 'content'", async () => {
-                    cacheFilePath = getFixturePath(".eslintcache");
-                    doDelete(cacheFilePath);
-                    assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+                it("should load eslint.config.ts with ESM syntax and \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                    eslint = new ESLint({
-                        cwd: path.join(fixtureDir, ".."),
-                        overrideConfigFile: true,
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "ESM-syntax");
 
-                        // specifying cache true the cache will be created
-                        cache: true,
-                        cacheLocation: cacheFilePath,
-                        cacheStrategy: "content",
-                        overrideConfig: {
-                            rules: {
-                                "no-console": 0,
-                                "no-unused-vars": 2
-                            }
-                        }
+                    const configFileContent = `import type { FlatConfig } from "../../../helper";\nexport default ${
+                        JSON.stringify([
+                            { rules: { "no-undef": 2 } }
+                        ], null, 2)} satisfies FlatConfig[];`;
 
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo;"
+                        }
                     });
-                    const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
-                    const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
-                    const goodFileCopy = path.resolve(`${path.dirname(goodFile)}`, "test-file-copy.js");
-
-                    shell.cp(goodFile, goodFileCopy);
 
-                    await eslint.lintFiles([badFile, goodFileCopy]);
-                    let fileCache = fCache.createFromFile(cacheFilePath, true);
-                    const entries = fileCache.normalizeEntries([badFile, goodFileCopy]);
+                    await teardown.prepare();
 
-                    entries.forEach(entry => {
-                        assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
                     });
 
-                    // this should result in a changed entry
-                    shell.sed("-i", "abc", "xzy", goodFileCopy);
-                    fileCache = fCache.createFromFile(cacheFilePath, true);
-                    assert(fileCache.getFileDescriptor(badFile).changed === false, `the entry for ${badFile} should have been unchanged`);
-                    assert(fileCache.getFileDescriptor(goodFileCopy).changed === true, `the entry for ${goodFileCopy} should have been changed`);
-                });
-            });
-        });
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-        describe("processors", () => {
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should return two messages when executing with config file that specifies preloaded processor", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            plugins: {
-                                test: {
-                                    processors: {
-                                        txt: {
-                                            preprocess(text) {
-                                                return [text];
-                                            },
-                                            postprocess(messages) {
-                                                return messages[0];
-                                            }
-                                        }
-                                    }
-                                }
-                            },
-                            processor: "test/txt",
-                            rules: {
-                                "no-console": 2,
-                                "no-unused-vars": 2
-                            }
-                        },
-                        {
-                            files: ["**/*.txt", "**/*.txt/*.txt"]
-                        }
-                    ],
-                    cwd: path.join(fixtureDir, "..")
                 });
-                const results = await eslint.lintFiles([fs.realpathSync(getFixturePath("processors", "test", "test-processor.txt"))]);
-
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-
-            });
 
-            it("should run processors when calling lintFiles with config file that specifies preloaded processor", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            plugins: {
-                                test: {
-                                    processors: {
-                                        txt: {
-                                            preprocess(text) {
-                                                return [text.replace("a()", "b()")];
-                                            },
-                                            postprocess(messages) {
-                                                messages[0][0].ruleId = "post-processed";
-                                                return messages[0];
-                                            }
-                                        }
-                                    }
-                                }
-                            },
-                            processor: "test/txt",
-                            rules: {
-                                "no-console": 2,
-                                "no-unused-vars": 2
-                            }
-                        },
-                        {
-                            files: ["**/*.txt", "**/*.txt/*.txt"]
-                        }
-                    ],
-                    cwd: path.join(fixtureDir, "..")
-                });
-                const results = await eslint.lintFiles([getFixturePath("processors", "test", "test-processor.txt")]);
+                it("should load eslint.config.ts with CJS syntax and \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
-                assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-syntax");
 
-            });
+                    const configFileContent = `import type { FlatConfig } from "../../../helper";\nmodule.exports = ${
+                        JSON.stringify([
+                            { rules: { "no-undef": 2 } }
+                        ], null, 2)} satisfies FlatConfig[];`;
 
-            it("should run processors when calling lintText with config file that specifies preloaded processor", async () => {
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            plugins: {
-                                test: {
-                                    processors: {
-                                        txt: {
-                                            preprocess(text) {
-                                                return [text.replace("a()", "b()")];
-                                            },
-                                            postprocess(messages) {
-                                                messages[0][0].ruleId = "post-processed";
-                                                return messages[0];
-                                            }
-                                        }
-                                    }
-                                }
-                            },
-                            processor: "test/txt",
-                            rules: {
-                                "no-console": 2,
-                                "no-unused-vars": 2
-                            }
-                        },
-                        {
-                            files: ["**/*.txt", "**/*.txt/*.txt"]
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo;"
                         }
-                    ],
-                    ignore: false
-                });
-                const results = await eslint.lintText("function a() {console.log(\"Test\");}", { filePath: "tests/fixtures/processors/test/test-processor.txt" });
-
-                assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
-                assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    });
 
-            it("should run processors when calling lintText with processor resolves same extension but different content correctly", async () => {
-                let count = 0;
+                    await teardown.prepare();
 
-                eslint = new ESLint({
-                    overrideConfigFile: true,
-                    overrideConfig: [
-                        {
-                            plugins: {
-                                test: {
-                                    processors: {
-                                        txt: {
-                                            preprocess(text) {
-                                                count++;
-                                                return [
-                                                    {
-
-                                                        // it will be run twice, and text will be as-is at the second time, then it will not run third time
-                                                        text: text.replace("a()", "b()"),
-                                                        filename: ".txt"
-                                                    }
-                                                ];
-                                            },
-                                            postprocess(messages) {
-                                                messages[0][0].ruleId = "post-processed";
-                                                return messages[0];
-                                            }
-                                        }
-                                    }
-                                }
-                            },
-                            processor: "test/txt"
-                        },
-                        {
-                            files: ["**/*.txt/*.txt"],
-                            rules: {
-                                "no-console": 2,
-                                "no-unused-vars": 2
-                            }
-                        },
-                        {
-                            files: ["**/*.txt"]
-                        }
-                    ],
-                    ignore: false
-                });
-                const results = await eslint.lintText("function a() {console.log(\"Test\");}", { filePath: "tests/fixtures/processors/test/test-processor.txt" });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                assert.strictEqual(count, 2);
-                assert.strictEqual(results[0].messages[0].message, "'b' is defined but never used.");
-                assert.strictEqual(results[0].messages[0].ruleId, "post-processed");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            describe("autofixing with processors", () => {
-                const HTML_PROCESSOR = Object.freeze({
-                    preprocess(text) {
-                        return [text.replace(/^<script>/u, "").replace(/<\/script>$/u, "")];
-                    },
-                    postprocess(problemLists) {
-                        return problemLists[0].map(problem => {
-                            if (problem.fix) {
-                                const updatedFix = Object.assign({}, problem.fix, {
-                                    range: problem.fix.range.map(index => index + "<script>".length)
-                                });
-
-                                return Object.assign({}, problem, { fix: updatedFix });
-                            }
-                            return problem;
-                        });
-                    }
                 });
 
+                it("should load eslint.config.ts with CJS syntax and \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                it("should run in autofix mode when using a processor that supports autofixing", async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            {
-                                files: ["**/*.html"],
-                                plugins: {
-                                    test: { processors: { html: Object.assign({ supportsAutofix: true }, HTML_PROCESSOR) } }
-                                },
-                                processor: "test/html",
-                                rules: {
-                                    semi: 2
-                                }
-                            },
-                            {
-                                files: ["**/*.txt"]
-                            }
-                        ],
-                        ignore: false,
-                        fix: true
-                    });
-                    const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-syntax");
 
-                    assert.strictEqual(results[0].messages.length, 0);
-                    assert.strictEqual(results[0].suppressedMessages.length, 0);
-                    assert.strictEqual(results[0].output, "<script>foo;</script>");
-                });
+                    const configFileContent = `import type { FlatConfig } from "../../../helper";\nmodule.exports = ${
+                        JSON.stringify([
+                            { rules: { "no-undef": 2 } }
+                        ], null, 2)} satisfies FlatConfig[];`;
 
-                it("should not run in autofix mode when using a processor that does not support autofixing", async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: {
-                            files: ["**/*.html"],
-                            plugins: {
-                                test: { processors: { html: HTML_PROCESSOR } }
-                            },
-                            processor: "test/html",
-                            rules: {
-                                semi: 2
-                            }
-                        },
-                        ignore: false,
-                        fix: true
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo;"
+                        }
                     });
-                    const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
 
-                    assert.strictEqual(results[0].messages.length, 1);
-                    assert.strictEqual(results[0].suppressedMessages.length, 0);
-                    assert(!Object.hasOwn(results[0], "output"));
-                });
+                    await teardown.prepare();
 
-                it("should not run in autofix mode when `fix: true` is not provided, even if the processor supports autofixing", async () => {
                     eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            {
-                                files: ["**/*.html"],
-                                plugins: {
-                                    test: { processors: { html: Object.assign({ supportsAutofix: true }, HTML_PROCESSOR) } }
-                                },
-                                processor: "test/html",
-                                rules: {
-                                    semi: 2
-                                }
-                            },
-                            {
-                                files: ["**/*.txt"]
-                            }
-                        ],
-                        ignore: false
+                        cwd,
+                        flags: newFlags
                     });
-                    const results = await eslint.lintText("<script>foo</script>", { filePath: "foo.html" });
 
+                    const results = await eslint.lintFiles(["foo.js"]);
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
                     assert.strictEqual(results[0].messages.length, 1);
-                    assert.strictEqual(results[0].suppressedMessages.length, 0);
-                    assert(!Object.hasOwn(results[0], "output"));
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+
                 });
-            });
 
-            describe("matching and ignoring code blocks", () => {
-                const pluginConfig = {
-                    files: ["**/*.md"],
-                    plugins: {
-                        markdown: exampleMarkdownPlugin
-                    },
-                    processor: "markdown/markdown"
-                };
-                const text = unIndent`
-                    \`\`\`js
-                    foo_js
-                    \`\`\`
+                // TODO: Re-enable these tests when `jiti` v2 becomes stable.
 
-                    \`\`\`ts
-                    foo_ts
-                    \`\`\`
+                /*
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-syntax", "top-level-await");
+                 *
+                 *    const configFileContent = `import type { FlatConfig } from "../../../../helper";\nmodule.exports = await Promise.resolve(${
+                 *        JSON.stringify([
+                 *            { rules: { "no-undef": 2 } }
+                 *        ], null, 2)}) satisfies FlatConfig[];`;
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "package.json": typeModule,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags: newFlags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-syntax", "top-level-await");
+                 *
+                 *    const configFileContent = `import type { FlatConfig } from "../../../../helper";\nmodule.exports = await Promise.resolve(${
+                 *        JSON.stringify([
+                 *            { rules: { "no-undef": 2 } }
+                 *        ], null, 2)}) satisfies FlatConfig[];`;
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "package.json": typeCommonJS,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (named import)", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "named-import");
+                 *
+                 *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "rules.ts": `export const rules = ${
+                 *                JSON.stringify({
+                 *                    "no-undef": 2
+                 *                }, null, 2)};`,
+                 *            "package.json": typeModule,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax (named import)", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "top-level-await", "named-import");
+                 *
+                 *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "rules.ts": `export const rules = ${
+                 *                JSON.stringify({
+                 *                    "no-undef": 2
+                 *                }, null, 2)};`,
+                 *            "package.json": typeCommonJS,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (import default)", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "import-default");
+                 *
+                 *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "rules.ts": `export default ${
+                 *                JSON.stringify({
+                 *                    "no-undef": 2
+                 *                }, null, 2)};`,
+                 *            "package.json": typeModule,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax (import default)", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "top-level-await", "import-default");
+                 *
+                 *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "rules.ts": `export default ${
+                 *                JSON.stringify({
+                 *                    "no-undef": 2
+                 *                }, null, 2)};`,
+                 *            "package.json": typeCommonJS,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo;"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 1);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 *
+                 *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (default and named imports)", async () => {
+                 *
+                 *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "import-default-and-named");
+                 *
+                 *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = await import(\"./rules\");\n\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                 *
+                 *    const teardown = createCustomTeardown({
+                 *        cwd,
+                 *        files: {
+                 *            "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
+                 *                JSON.stringify({
+                 *                    "no-undef": 2
+                 *                }, null, 2)} satisfies RulesRecord;`,
+                 *            "package.json": typeModule,
+                 *            "eslint.config.ts": configFileContent,
+                 *            "foo.js": "foo"
+                 *        }
+                 *    });
+                 *
+                 *    await teardown.prepare();
+                 *
+                 *    eslint = new ESLint({
+                 *        cwd,
+                 *        flags
+                 *    });
+                 *
+                 *    const results = await eslint.lintFiles(["foo.js"]);
+                 *
+                 *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                 *    assert.strictEqual(results.length, 1);
+                 *    assert.strictEqual(results[0].messages.length, 2);
+                 *    assert.strictEqual(results[0].messages[0].severity, 2);
+                 *    assert.strictEqual(results[0].messages[1].severity, 2);
+                 *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                 *
+                 *});
+                 */
 
-                    \`\`\`cjs
-                    foo_cjs
-                    \`\`\`
+                it("should load eslint.config.ts with TypeScript's CJS syntax (import and export assignment), \"type\": \"module\" in nearest `package.json`", async () => {
 
-                    \`\`\`mjs
-                    foo_mjs
-                    \`\`\`
-                `;
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "import-and-export-assignment");
 
-                it("should by default lint only .js, .mjs, and .cjs virtual files", async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            pluginConfig,
-                            {
-                                rules: {
-                                    "no-undef": 2
-                                }
-                            }
-                        ]
+                    const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { rules, Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport = { rules: { \"no-undef\": Severity.Error }, Level } satisfies RulesRecord;",
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
                     });
-                    const [result] = await eslint.lintText(text, { filePath: "foo.md" });
 
-                    assert.strictEqual(result.messages.length, 3);
-                    assert.strictEqual(result.messages[0].ruleId, "no-undef");
-                    assert.match(result.messages[0].message, /foo_js/u);
-                    assert.strictEqual(result.messages[0].line, 2);
-                    assert.strictEqual(result.messages[1].ruleId, "no-undef");
-                    assert.match(result.messages[1].message, /foo_cjs/u);
-                    assert.strictEqual(result.messages[1].line, 10);
-                    assert.strictEqual(result.messages[2].ruleId, "no-undef");
-                    assert.match(result.messages[2].message, /foo_mjs/u);
-                    assert.strictEqual(result.messages[2].line, 14);
-                });
+                    await teardown.prepare();
 
-                it("should lint additional virtual files that match non-universal patterns", async () => {
                     eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            pluginConfig,
-                            {
-                                rules: {
-                                    "no-undef": 2
-                                }
-                            },
-                            {
-                                files: ["**/*.ts"]
-                            }
-                        ]
+                        cwd,
+                        flags: newFlags
                     });
-                    const [result] = await eslint.lintText(text, { filePath: "foo.md" });
 
-                    assert.strictEqual(result.messages.length, 4);
-                    assert.strictEqual(result.messages[0].ruleId, "no-undef");
-                    assert.match(result.messages[0].message, /foo_js/u);
-                    assert.strictEqual(result.messages[0].line, 2);
-                    assert.strictEqual(result.messages[1].ruleId, "no-undef");
-                    assert.match(result.messages[1].message, /foo_ts/u);
-                    assert.strictEqual(result.messages[1].line, 6);
-                    assert.strictEqual(result.messages[2].ruleId, "no-undef");
-                    assert.match(result.messages[2].message, /foo_cjs/u);
-                    assert.strictEqual(result.messages[2].line, 10);
-                    assert.strictEqual(result.messages[3].ruleId, "no-undef");
-                    assert.match(result.messages[3].message, /foo_mjs/u);
-                    assert.strictEqual(result.messages[3].line, 14);
-                });
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-                // https://github.com/eslint/eslint/issues/18493
-                it("should silently skip virtual files that match only universal patterns", async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            pluginConfig,
-                            {
-                                files: ["**/*"],
-                                rules: {
-                                    "no-undef": 2
-                                }
-                            }
-                        ]
-                    });
-                    const [result] = await eslint.lintText(text, { filePath: "foo.md" });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    assert.strictEqual(result.messages.length, 3);
-                    assert.strictEqual(result.messages[0].ruleId, "no-undef");
-                    assert.match(result.messages[0].message, /foo_js/u);
-                    assert.strictEqual(result.messages[0].line, 2);
-                    assert.strictEqual(result.messages[1].ruleId, "no-undef");
-                    assert.match(result.messages[1].message, /foo_cjs/u);
-                    assert.strictEqual(result.messages[1].line, 10);
-                    assert.strictEqual(result.messages[2].ruleId, "no-undef");
-                    assert.match(result.messages[2].message, /foo_mjs/u);
-                    assert.strictEqual(result.messages[2].line, 14);
                 });
 
-                it("should silently skip virtual files that are ignored by global ignores", async () => {
-                    eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            pluginConfig,
-                            {
-                                rules: {
-                                    "no-undef": 2
-                                }
-                            },
-                            {
-                                ignores: ["**/*.cjs"]
-                            }
-                        ]
+                it("should load eslint.config.ts with TypeScript's CJS syntax (import and export assignment), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "import-and-export-assignment");
+
+                    const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { rules, Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport = { rules: { \"no-undef\": Severity.Error }, Level } satisfies RulesRecord;",
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
                     });
-                    const [result] = await eslint.lintText(text, { filePath: "foo.md" });
 
-                    assert.strictEqual(result.messages.length, 2);
-                    assert.strictEqual(result.messages[0].ruleId, "no-undef");
-                    assert.match(result.messages[0].message, /foo_js/u);
-                    assert.strictEqual(result.messages[0].line, 2);
-                    assert.strictEqual(result.messages[1].ruleId, "no-undef");
-                    assert.match(result.messages[1].message, /foo_mjs/u);
-                    assert.strictEqual(result.messages[1].line, 14);
-                });
+                    await teardown.prepare();
 
-                // https://github.com/eslint/eslint/issues/15949
-                it("should silently skip virtual files that are ignored by global ignores even if they match non-universal patterns", async () => {
                     eslint = new ESLint({
-                        overrideConfigFile: true,
-                        overrideConfig: [
-                            pluginConfig,
-                            {
-                                rules: {
-                                    "no-undef": 2
-                                }
-                            },
-                            {
-                                files: ["**/*.ts"]
-                            },
-                            {
-                                ignores: ["**/*.md/*.ts"]
-                            }
-                        ]
+                        cwd,
+                        flags: newFlags
                     });
-                    const [result] = await eslint.lintText(text, { filePath: "foo.md" });
 
-                    assert.strictEqual(result.messages.length, 3);
-                    assert.strictEqual(result.messages[0].ruleId, "no-undef");
-                    assert.match(result.messages[0].message, /foo_js/u);
-                    assert.strictEqual(result.messages[0].line, 2);
-                    assert.strictEqual(result.messages[1].ruleId, "no-undef");
-                    assert.match(result.messages[1].message, /foo_cjs/u);
-                    assert.strictEqual(result.messages[1].line, 10);
-                    assert.strictEqual(result.messages[2].ruleId, "no-undef");
-                    assert.match(result.messages[2].message, /foo_mjs/u);
-                    assert.strictEqual(result.messages[2].line, 14);
-                });
-            });
-        });
+                    const results = await eslint.lintFiles(["foo.js"]);
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-        describe("Patterns which match no file should throw errors.", () => {
-            beforeEach(() => {
-                eslint = new ESLint({
-                    cwd: getFixturePath("cli-engine"),
-                    overrideConfigFile: true
                 });
-            });
 
-            it("one file", async () => {
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["non-exist.js"]);
-                }, /No files matching 'non-exist\.js' were found\./u);
-            });
+                it("should load eslint.config.ts with wildcard imports, \"type\": \"module\" in nearest `package.json`", async () => {
 
-            it("should throw if the directory exists and is empty", async () => {
-                ensureDirectoryExists(getFixturePath("cli-engine/empty"));
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["empty"]);
-                }, /No files matching 'empty' were found\./u);
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "wildcard-imports");
 
-            it("one glob pattern", async () => {
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["non-exist/**/*.js"]);
-                }, /No files matching 'non-exist\/\*\*\/\*\.js' were found\./u);
-            });
+                    const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport * as rulesModule from \"./rules\";\nconst { default: rules ,Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
 
-            it("two files", async () => {
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["aaa.js", "bbb.js"]);
-                }, /No files matching 'aaa\.js' were found\./u);
-            });
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-            it("a mix of an existing file and a non-existing file", async () => {
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["console.js", "non-exist.js"]);
-                }, /No files matching 'non-exist\.js' were found\./u);
-            });
+                    await teardown.prepare();
 
-            // https://github.com/eslint/eslint/issues/16275
-            it("a mix of an existing glob pattern and a non-existing glob pattern", async () => {
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["*.js", "non-exist/*.js"]);
-                }, /No files matching 'non-exist\/\*\.js' were found\./u);
-            });
-        });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-        describe("multiple processors", () => {
-            const root = path.join(os.tmpdir(), "eslint/eslint/multiple-processors");
-            const commonFiles = {
-                "node_modules/pattern-processor/index.js": fs.readFileSync(
-                    require.resolve("../../fixtures/processors/pattern-processor"),
-                    "utf8"
-                ),
-                "node_modules/eslint-plugin-markdown/index.js": `
-                    const { defineProcessor } = require("pattern-processor");
-                    const processor = defineProcessor(${/```(\w+)\n([\s\S]+?)\n```/gu});
-                    exports.processors = {
-                        "markdown": { ...processor, supportsAutofix: true },
-                        "non-fixable": processor
-                    };
-                `,
-                "node_modules/eslint-plugin-html/index.js": `
-                    const { defineProcessor } = require("pattern-processor");
-                    const processor = defineProcessor(${/<script lang="(\w*)">\n([\s\S]+?)\n<\/script>/gu});
-                    const legacyProcessor = defineProcessor(${/<script lang="(\w*)">\n([\s\S]+?)\n<\/script>/gu}, true);
-                    exports.processors = {
-                        "html": { ...processor, supportsAutofix: true },
-                        "non-fixable": processor,
-                        "legacy": legacyProcessor
-                    };
-                `,
-                "test.md": unIndent`
-                    \`\`\`js
-                    console.log("hello")
-                    \`\`\`
-                    \`\`\`html
-                    <div>Hello</div>
-                    <script lang="js">
-                        console.log("hello")
-                    </script>
-                    <script lang="ts">
-                        console.log("hello")
-                    </script>
-                    \`\`\`
-                `
-            };
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            // unique directory for each test to avoid quirky disk-cleanup errors
-            let id;
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            beforeEach(() => (id = Date.now().toString()));
+                });
 
-            /*
-             * `fs.rmdir(path, { recursive: true })` is deprecated and will be removed.
-             * Use `fs.rm(path, { recursive: true })` instead.
-             * When supporting Node.js 14.14.0+, the compatibility condition can be removed for `fs.rmdir`.
-             */
-            if (typeof fsp.rm === "function") {
-                afterEach(async () => fsp.rm(root, { recursive: true, force: true }));
-            } else {
-                afterEach(async () => fsp.rmdir(root, { recursive: true, force: true }));
-            }
+                it("should load eslint.config.ts with wildcard imports, \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-            it("should lint only JavaScript blocks.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                }
-                            },
-                            {
-                                files: ["**/*.js"],
-                                rules: { semi: "error" }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/markdown"
-                            }
-                        ];`
-                    }
-                });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "wildcard-imports");
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath() });
-                const results = await eslint.lintFiles(["test.md"]);
+                    const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport * as rulesModule from \"./rules\";\nconst { default: rules ,Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
 
-                assert.strictEqual(results.length, 1, "Should have one result.");
-                assert.strictEqual(results[0].messages.length, 1, "Should have one message.");
-                assert.strictEqual(results[0].messages[0].ruleId, "semi");
-                assert.strictEqual(results[0].messages[0].line, 2, "Message should be on line 2.");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-            });
+                    await teardown.prepare();
 
-            it("should lint HTML blocks as well with multiple processors if represented in config.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                }
-                            },
-                            {
-                                files: ["**/*.js"],
-                                rules: { semi: "error" }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/markdown"
-                            },
-                            {
-                                files: ["**/*.html"],
-                                processor: "html/html"
-                            }
-                        ];`
-                    }
-                });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
-                const results = await eslint.lintFiles(["test.md"]);
-
-                assert.strictEqual(results.length, 1, "Should have one result.");
-                assert.strictEqual(results[0].messages.length, 2, "Should have two messages.");
-                assert.strictEqual(results[0].messages[0].ruleId, "semi"); // JS block
-                assert.strictEqual(results[0].messages[0].line, 2, "First error should be on line 2");
-                assert.strictEqual(results[0].messages[1].ruleId, "semi"); // JS block in HTML block
-                assert.strictEqual(results[0].messages[1].line, 7, "Second error should be on line 7.");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    const results = await eslint.lintFiles(["foo.js"]);
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should fix HTML blocks as well with multiple processors if represented in config.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                }
-                            },
-                            {
-                                files: ["**/*.js"],
-                                rules: { semi: "error" }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/markdown"
-                            },
-                            {
-                                files: ["**/*.html"],
-                                processor: "html/html"
-                            }
-                        ];`
-                    }
                 });
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] }, fix: true });
-                const results = await eslint.lintFiles(["test.md"]);
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import and module.exports), \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 0);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-                assert.strictEqual(results[0].output, unIndent`
-                    \`\`\`js
-                    console.log("hello");${/*  fixed */""}
-                    \`\`\`
-                    \`\`\`html
-                    <div>Hello</div>
-                    <script lang="js">
-                        console.log("hello");${/*  fixed */""}
-                    </script>
-                    <script lang="ts">
-                        console.log("hello")${/*  ignored */""}
-                    </script>
-                    \`\`\`
-                `);
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-and-module-exports");
 
-            it("should use the config '**/*.html/*.js' to lint JavaScript blocks in HTML.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                }
-                            },
-                            {
-                                files: ["**/*.js"],
-                                rules: { semi: "error" }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/markdown"
-                            },
-                            {
-                                files: ["**/*.html"],
-                                processor: "html/html"
-                            },
-                            {
-                                files: ["**/*.html/*.js"],
-                                rules: {
-                                    semi: "off",
-                                    "no-console": "error"
-                                }
-                            }
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rules, { Level } from \"./rules\";\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
+                                JSON.stringify({
+                                    "no-undef": 2
+                                }, null, 2)} satisfies RulesRecord;`,
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-                        ];`
+                    await teardown.prepare();
+
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
+
+                    const results = await eslint.lintFiles(["foo.js"]);
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    }
                 });
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
-                const results = await eslint.lintFiles(["test.md"]);
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import and module.exports), \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "semi");
-                assert.strictEqual(results[0].messages[0].line, 2);
-                assert.strictEqual(results[0].messages[1].ruleId, "no-console");
-                assert.strictEqual(results[0].messages[1].line, 7);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-and-module-exports");
 
-            });
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rules, { Level } from \"./rules\";\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
 
-            it("should use the same config as one which has 'processor' property in order to lint blocks in HTML if the processor was legacy style.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                },
-                                rules: { semi: "error" }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/markdown"
-                            },
-                            {
-                                files: ["**/*.html"],
-                                processor: "html/legacy",  // this processor returns strings rather than '{ text, filename }'
-                                rules: {
-                                    semi: "off",
-                                    "no-console": "error"
-                                }
-                            },
-                            {
-                                files: ["**/*.html/*.js"],
-                                rules: {
-                                    semi: "error",
-                                    "no-console": "off"
-                                }
-                            }
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
+                                JSON.stringify({
+                                    "no-undef": 2
+                                }, null, 2)} satisfies RulesRecord;`,
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-                        ];`
-                    }
-                });
+                    await teardown.prepare();
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath(), overrideConfig: { files: ["**/*.html"] } });
-                const results = await eslint.lintFiles(["test.md"]);
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 3);
-                assert.strictEqual(results[0].messages[0].ruleId, "semi");
-                assert.strictEqual(results[0].messages[0].line, 2);
-                assert.strictEqual(results[0].messages[1].ruleId, "no-console");
-                assert.strictEqual(results[0].messages[1].line, 7);
-                assert.strictEqual(results[0].messages[2].ruleId, "no-console");
-                assert.strictEqual(results[0].messages[2].line, 10);
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            it("should throw an error if invalid processor was specified.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: path.join(root, id),
-                    files: {
-                        ...commonFiles,
-                        "eslint.config.js": `module.exports = [
-                            {
-                                plugins: {
-                                    markdown: require("eslint-plugin-markdown"),
-                                    html: require("eslint-plugin-html")
-                                }
-                            },
-                            {
-                                files: ["**/*.md"],
-                                processor: "markdown/unknown"
-                            }
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                        ];`
-                    }
                 });
 
-                await teardown.prepare();
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (require and export default), \"type\": \"module\" in nearest `package.json`", async () => {
 
-                await assert.rejects(async () => {
-                    await eslint.lintFiles(["test.md"]);
-                }, /Key "processor": Could not find "unknown" in plugin "markdown"/u);
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "require-and-export-default");
 
-        });
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = require(\"./rules\");\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
 
-        describe("glob pattern '[ab].js'", () => {
-            const root = getFixturePath("cli-engine/unmatched-glob");
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-            let cleanup;
+                    await teardown.prepare();
 
-            beforeEach(() => {
-                cleanup = () => { };
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            afterEach(() => cleanup());
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            it("should match '[ab].js' if existed.", async () => {
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                const teardown = createCustomTeardown({
-                    cwd: root,
-                    files: {
-                        "a.js": "",
-                        "b.js": "",
-                        "ab.js": "",
-                        "[ab].js": "",
-                        "eslint.config.js": "module.exports = [];"
-                    }
                 });
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (require and export default), \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                eslint = new ESLint({ cwd: teardown.getPath() });
-                const results = await eslint.lintFiles(["[ab].js"]);
-                const filenames = results.map(r => path.basename(r.filePath));
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "require-and-export-default");
 
-                assert.deepStrictEqual(filenames, ["[ab].js"]);
-            });
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = require(\"./rules\");\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
+
+                    await teardown.prepare();
+
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
+
+                    const results = await eslint.lintFiles(["foo.js"]);
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should match 'a.js' and 'b.js' if '[ab].js' didn't existed.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: root,
-                    files: {
-                        "a.js": "",
-                        "b.js": "",
-                        "ab.js": "",
-                        "eslint.config.js": "module.exports = [];"
-                    }
                 });
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
-                const results = await eslint.lintFiles(["[ab].js"]);
-                const filenames = results.map(r => path.basename(r.filePath));
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import assignment and export default), \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.deepStrictEqual(filenames, ["a.js", "b.js"]);
-            });
-        });
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-assignment-and-export-default");
+
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-        describe("with 'noInlineConfig' setting", () => {
-            const root = getFixturePath("cli-engine/noInlineConfig");
+                    await teardown.prepare();
 
-            let cleanup;
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            beforeEach(() => {
-                cleanup = () => { };
-            });
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            afterEach(() => cleanup());
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should warn directive comments if 'noInlineConfig' was given.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: root,
-                    files: {
-                        "test.js": "/* globals foo */",
-                        "eslint.config.js": "module.exports = [{ linterOptions: { noInlineConfig: true } }];"
-                    }
                 });
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import assignment and export default), \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-assignment-and-export-default");
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].message, "'/* globals foo */' has no effect because you have 'noInlineConfig' setting in your config.");
-            });
+                    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
 
-        });
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
-        describe("with 'reportUnusedDisableDirectives' setting", () => {
-            const root = getFixturePath("cli-engine/reportUnusedDisableDirectives");
+                    await teardown.prepare();
 
-            let cleanup;
-            let i = 0;
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            beforeEach(() => {
-                cleanup = () => { };
-                i++;
-            });
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-            afterEach(() => cleanup());
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should error unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = error'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'error' } }"
-                    }
                 });
 
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import and export assignment), \"type\": \"module\" in nearest `package.json`", async () => {
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
-
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-and-export-assignment");
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].severity, 2);
-                assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    const configFileContent = "import helpers = require(\"../../../../helper\");\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nconst allExports = [{ rules: { ...rules, semi: Level.Error } }] satisfies helpers.FlatConfig[];\nexport = allExports;";
 
-            it("should error unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 2'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 2 } }"
-                    }
-                });
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import helpers = require(\"../../../../helper\");\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nconst rules = { \"no-undef\": helpers.Severity.Error } satisfies helpers.RulesRecord;\nconst allExports = { default: rules, Level };\nexport = allExports;",
+                            "package.json": typeModule,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
+                    await teardown.prepare();
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].severity, 2);
-                assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = warn'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'warn' } }"
-                    }
                 });
 
+                it("should load eslint.config.ts with CJS-ESM mixed syntax (import and export assignment), \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
-
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-and-export-assignment");
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].severity, 1);
-                assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    const configFileContent = "import helpers = require(\"../../../../helper\");\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nconst allExports = [{ rules: { ...rules, semi: Level.Error } }] satisfies helpers.FlatConfig[];\nexport = allExports;";
 
-            it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 1'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 1 } }"
-                    }
-                });
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "rules.ts": "import helpers = require(\"../../../../helper\");\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nconst rules = { \"no-undef\": helpers.Severity.Error } satisfies helpers.RulesRecord;\nconst allExports = { default: rules, Level };\nexport = allExports;",
+                            "package.json": typeCommonJS,
+                            "eslint.config.ts": configFileContent,
+                            "foo.js": "foo"
+                        }
+                    });
 
+                    await teardown.prepare();
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const results = await eslint.lintFiles(["foo.js"]);
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].severity, 1);
-                assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 2);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[1].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-            it("should warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = true'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: true } }"
-                    }
                 });
 
+                it("should load eslint.config.ts with const enums", async () => {
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                    const cwd = getFixturePath("ts-config-files", "ts", "const-enums");
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                assert.strictEqual(messages.length, 1);
-                assert.strictEqual(messages[0].severity, 1);
-                assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                assert.strictEqual(results[0].suppressedMessages.length, 0);
-            });
+                    const results = await eslint.lintFiles("foo.js");
 
-            it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = false'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: false } }"
-                    }
-                });
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
+                });
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                it("should load eslint.config.ts with local namespace", async () => {
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    const cwd = getFixturePath("ts-config-files", "ts", "local-namespace");
 
-                assert.strictEqual(messages.length, 0);
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = off'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 'off' } }"
-                    }
-                });
+                    const results = await eslint.lintFiles("foo.js");
 
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                });
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                it("should allow passing a TS config file to `overrideConfigFile`", async () => {
 
-                assert.strictEqual(messages.length, 0);
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts", "custom-config");
 
-            it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives = 0'.", async () => {
-                const teardown = createCustomTeardown({
-                    cwd: `${root}${i}`,
-                    files: {
-                        "test.js": "/* eslint-disable eqeqeq */",
-                        "eslint.config.js": "module.exports = { linterOptions: { reportUnusedDisableDirectives: 0 } }"
-                    }
-                });
+                    const overrideConfigFile = path.join(cwd, "eslint.custom.config.ts");
 
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags,
+                        overrideConfigFile
+                    });
 
-                await teardown.prepare();
-                cleanup = teardown.cleanup;
-                eslint = new ESLint({ cwd: teardown.getPath() });
+                    const results = await eslint.lintFiles("foo.js");
 
-                const results = await eslint.lintFiles(["test.js"]);
-                const messages = results[0].messages;
+                    assert.strictEqual(await eslint.findConfigFile(), overrideConfigFile);
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                assert.strictEqual(messages.length, 0);
-            });
+                });
 
-            describe("the runtime option overrides config files.", () => {
-                it("should not warn unused 'eslint-disable' comments if 'reportUnusedDisableDirectives=off' was given in runtime.", async () => {
-                    const teardown = createCustomTeardown({
-                        cwd: `${root}${i}`,
-                        files: {
-                            "test.js": "/* eslint-disable eqeqeq */",
-                            "eslint.config.js": "module.exports = [{ linterOptions: { reportUnusedDisableDirectives: true } }]"
-                        }
-                    });
+                it("should find and load eslint.config.mts when present", async () => {
 
-                    await teardown.prepare();
-                    cleanup = teardown.cleanup;
+                    const cwd = getFixturePath("ts-config-files", "mts");
 
                     eslint = new ESLint({
-                        cwd: teardown.getPath(),
-                        overrideConfig: {
-                            linterOptions: { reportUnusedDisableDirectives: "off" }
-                        }
+                        cwd,
+                        flags: newFlags
                     });
 
-                    const results = await eslint.lintFiles(["test.js"]);
-                    const messages = results[0].messages;
+                    const results = await eslint.lintFiles("foo.js");
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    assert.strictEqual(messages.length, 0);
                 });
 
-                it("should warn unused 'eslint-disable' comments as error if 'reportUnusedDisableDirectives=error' was given in runtime.", async () => {
-                    const teardown = createCustomTeardown({
-                        cwd: `${root}${i}`,
-                        files: {
-                            "test.js": "/* eslint-disable eqeqeq */",
-                            "eslint.config.js": "module.exports = [{ linterOptions: { reportUnusedDisableDirectives: true } }]"
-                        }
-                    });
+                it("should load eslint.config.mts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                    await teardown.prepare();
-                    cleanup = teardown.cleanup;
+                    const cwd = getFixturePath("ts-config-files", "mts", "with-type-commonjs");
 
                     eslint = new ESLint({
-                        cwd: teardown.getPath(),
-                        overrideConfig: {
-                            linterOptions: { reportUnusedDisableDirectives: "error" }
-                        }
+                        cwd,
+                        flags: newFlags
                     });
 
-                    const results = await eslint.lintFiles(["test.js"]);
-                    const messages = results[0].messages;
+                    const results = await eslint.lintFiles("foo.js");
+
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                    assert.strictEqual(messages.length, 1);
-                    assert.strictEqual(messages[0].severity, 2);
-                    assert.strictEqual(messages[0].message, "Unused eslint-disable directive (no problems were reported from 'eqeqeq').");
-                    assert.strictEqual(results[0].suppressedMessages.length, 0);
                 });
-            });
-        });
 
-        it("should throw if non-boolean value is given to 'options.warnIgnored' option", async () => {
-            eslint = new ESLint();
-            await assert.rejects(() => eslint.lintFiles(777), /'patterns' must be a non-empty string or an array of non-empty strings/u);
-            await assert.rejects(() => eslint.lintFiles([null]), /'patterns' must be a non-empty string or an array of non-empty strings/u);
-        });
+                it("should load eslint.config.mts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
+
+                    const cwd = getFixturePath("ts-config-files", "mts", "with-type-module");
 
-        describe("Alternate config files", () => {
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            it("should find eslint.config.mjs when present", async () => {
+                    const results = await eslint.lintFiles("foo.js");
 
-                const cwd = getFixturePath("mjs-config");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                it("should find and load eslint.config.cts when present", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "cts");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            it("should find eslint.config.cjs when present", async () => {
+                    const results = await eslint.lintFiles("foo.js");
 
-                const cwd = getFixturePath("cjs-config");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                it("should load eslint.config.cts config file when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 1);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const cwd = getFixturePath("ts-config-files", "cts", "with-type-commonjs");
 
-            });
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            it("should favor eslint.config.js when eslint.config.mjs and eslint.config.cjs are present", async () => {
+                    const results = await eslint.lintFiles("foo.js");
 
-                const cwd = getFixturePath("js-mjs-cjs-config");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                it("should load .cts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 0);
-            });
+                    const cwd = getFixturePath("ts-config-files", "cts", "with-type-module");
+
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-            it("should favor eslint.config.mjs when eslint.config.cjs is present", async () => {
+                    const results = await eslint.lintFiles("foo.js");
 
-                const cwd = getFixturePath("mjs-cjs-config");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                eslint = new ESLint({
-                    cwd
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                it("should not load extensions other than .ts, .mts or .cts", async () => {
 
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-            });
-        });
+                    const cwd = getFixturePath("ts-config-files", "wrong-extension");
 
-        describe("TypeScript config files", () => {
-            const typeModule = JSON.stringify({ type: "module" }, null, 2);
+                    const configFileContent = `import type { FlatConfig } from "../../helper";\nexport default ${
+                        JSON.stringify([
+                            { rules: { "no-undef": 2 } }
+                        ], null, 2)} satisfies FlatConfig[];`;
 
-            const typeCommonJS = JSON.stringify({ type: "commonjs" }, null, 2);
+                    const teardown = createCustomTeardown({
+                        cwd,
+                        files: {
+                            "package.json": typeCommonJS,
+                            "eslint.config.mcts": configFileContent,
+                            "foo.js": "foo;"
+                        }
+                    });
 
-            const flags = ["unstable_ts_config"];
+                    await teardown.prepare();
 
-            it("should find and load eslint.config.ts when present", async () => {
+                    eslint = new ESLint({
+                        cwd,
+                        overrideConfigFile: "eslint.config.mcts",
+                        flags: newFlags
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mcts"));
+                    await assert.rejects(() => eslint.lintFiles(["foo.js"]));
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should not load TS config files when `\"unstable_ts_config\"` flag is not set", async () => {
 
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts");
 
-            it("should load eslint.config.ts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                    eslint = new ESLint({
+                        cwd,
+                        flags,
+                        overrideConfigFile: "eslint.config.ts"
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    await assert.rejects(() => eslint.lintFiles(["foo.js"]));
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should fallback to JS config files when `\"unstable_ts_config\"` flag is not set", async () => {
 
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts");
 
-            it("should load eslint.config.ts when we have \"type\": \"module\" in nearest `package.json`", async () => {
+                    eslint = new ESLint({
+                        cwd,
+                        flags
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module");
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "../../eslint.config.js"));
+                    await assert.doesNotReject(() => eslint.lintFiles(["foo.js"]));
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should successfully load a TS config file that exports a promise", async () => {
 
-            });
+                    const cwd = getFixturePath("ts-config-files", "ts", "exports-promise");
 
-            it("should load eslint.config.ts with ESM syntax and \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                    eslint = new ESLint({
+                        cwd,
+                        flags: newFlags
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "ESM-syntax");
+                    const results = await eslint.lintFiles(["foo*.js"]);
 
-                const configFileContent = `import type { FlatConfig } from "../../../helper";\nexport default ${
-                    JSON.stringify([
-                        { rules: { "no-undef": 2 } }
-                    ], null, 2)} satisfies FlatConfig[];`;
+                    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.join(cwd, "foo.js"));
+                    assert.strictEqual(results[0].messages.length, 1);
+                    assert.strictEqual(results[0].messages[0].severity, 2);
+                    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo;"
-                    }
                 });
 
-                await teardown.prepare();
+            });
+
+            it("should stop linting files if a rule crashes", async () => {
+
+                const cwd = getFixturePath("files");
+                let createCallCount = 0;
 
                 eslint = new ESLint({
+                    flags,
                     cwd,
-                    flags
+                    plugins: {
+                        boom: {
+                            rules: {
+                                boom: {
+                                    create() {
+                                        createCallCount++;
+                                        throw Error("Boom!");
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    baseConfig: {
+                        rules: {
+                            "boom/boom": "error"
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                await assert.rejects(eslint.lintFiles("*.js"));
 
+                // Wait until all files have been closed.
+                // eslint-disable-next-line n/no-unsupported-features/node-builtins -- it's still an experimental feature.
+                while (process.getActiveResourcesInfo().includes("CloseReq")) {
+                    await timers.setImmediate();
+                }
+                assert.strictEqual(createCallCount, 1);
             });
 
-            it("should load eslint.config.ts with CJS syntax and \"type\": \"module\" in nearest `package.json`", async () => {
+            describe("Error while globbing", () => {
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-syntax");
+                it("should throw an error with a glob pattern if an invalid config was provided", async () => {
 
-                const configFileContent = `import type { FlatConfig } from "../../../helper";\nmodule.exports = ${
-                    JSON.stringify([
-                        { rules: { "no-undef": 2 } }
-                    ], null, 2)} satisfies FlatConfig[];`;
+                    const cwd = getFixturePath("files");
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo;"
-                    }
+                    eslint = new ESLint({
+                        flags,
+                        cwd,
+                        overrideConfig: [{ invalid: "foobar" }]
+                    });
+
+                    await assert.rejects(eslint.lintFiles("*.js"));
                 });
 
-                await teardown.prepare();
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
-                });
+        });
 
-                const results = await eslint.lintFiles(["foo.js"]);
+        describe("Fix Types", () => {
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            /** @type {InstanceType<ESLint>} */
+            let eslint;
 
+            describe("fixTypes values validation", () => {
+                it("should throw an error when an invalid fix type is specified", () => {
+                    assert.throws(() => {
+                        eslint = new ESLint({
+                            flags,
+                            cwd: path.join(fixtureDir, ".."),
+                            overrideConfigFile: true,
+                            fix: true,
+                            fixTypes: ["layou"]
+                        });
+                    }, /'fixTypes' must be an array of any of "directive", "problem", "suggestion", and "layout"\./iu);
+                });
             });
 
-            it("should load eslint.config.ts with CJS syntax and \"type\": \"commonjs\" in nearest `package.json`", async () => {
+            describe("with lintFiles", () => {
+                it("should not fix any rules when fixTypes is used without fix", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: false,
+                        fixTypes: ["layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-semi.js");
+                    const results = await eslint.lintFiles([inputPath]);
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-syntax");
+                    assert.strictEqual(results[0].output, void 0);
+                });
 
-                const configFileContent = `import type { FlatConfig } from "../../../helper";\nmodule.exports = ${
-                    JSON.stringify([
-                        { rules: { "no-undef": 2 } }
-                    ], null, 2)} satisfies FlatConfig[];`;
+                it("should not fix any rules when fixTypes is used without fix", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: false,
+                        fixTypes: ["layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-semi.js");
+                    const results = await eslint.lintFiles([inputPath]);
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo;"
-                    }
+                    assert.strictEqual(results[0].output, void 0);
                 });
 
-                await teardown.prepare();
+                it("should not fix non-style rules when fixTypes has only 'layout'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-semi.js");
+                    const outputPath = getFixturePath("fix-types/fix-only-semi.expected.js");
+                    const results = await eslint.lintFiles([inputPath]);
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert.strictEqual(results[0].output, expectedOutput);
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                it("should not fix style or problem rules when fixTypes has only 'suggestion'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["suggestion"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.js");
+                    const outputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.expected.js");
+                    const results = await eslint.lintFiles([inputPath]);
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    assert.strictEqual(results[0].output, expectedOutput);
+                });
+
+                it("should fix both style and problem rules when fixTypes has 'suggestion' and 'layout'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["suggestion", "layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.js");
+                    const outputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.expected.js");
+                    const results = await eslint.lintFiles([inputPath]);
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
+                    assert.strictEqual(results[0].output, expectedOutput);
+                });
             });
 
-            // TODO: Re-enable these tests when `jiti` v2 becomes stable.
+            describe("with lintText", () => {
+                it("should not fix any rules when fixTypes is used without fix", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: false,
+                        fixTypes: ["layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-semi.js");
+                    const content = fs.readFileSync(inputPath, "utf8");
+                    const results = await eslint.lintText(content, { filePath: inputPath });
 
-            /*
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-syntax", "top-level-await");
-             *
-             *    const configFileContent = `import type { FlatConfig } from "../../../../helper";\nmodule.exports = await Promise.resolve(${
-             *        JSON.stringify([
-             *            { rules: { "no-undef": 2 } }
-             *        ], null, 2)}) satisfies FlatConfig[];`;
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "package.json": typeModule,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-syntax", "top-level-await");
-             *
-             *    const configFileContent = `import type { FlatConfig } from "../../../../helper";\nmodule.exports = await Promise.resolve(${
-             *        JSON.stringify([
-             *            { rules: { "no-undef": 2 } }
-             *        ], null, 2)}) satisfies FlatConfig[];`;
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "package.json": typeCommonJS,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (named import)", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "named-import");
-             *
-             *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "rules.ts": `export const rules = ${
-             *                JSON.stringify({
-             *                    "no-undef": 2
-             *                }, null, 2)};`,
-             *            "package.json": typeModule,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax (named import)", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "top-level-await", "named-import");
-             *
-             *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "rules.ts": `export const rules = ${
-             *                JSON.stringify({
-             *                    "no-undef": 2
-             *                }, null, 2)};`,
-             *            "package.json": typeCommonJS,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (import default)", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "import-default");
-             *
-             *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "rules.ts": `export default ${
-             *                JSON.stringify({
-             *                    "no-undef": 2
-             *                }, null, 2)};`,
-             *            "package.json": typeModule,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"commonjs\" in nearest `package.json` and top-level await syntax (import default)", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "top-level-await", "import-default");
-             *
-             *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules } = await import(\"./rules\");\nmodule.exports = [{ rules }] satisfies FlatConfig[];";
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "rules.ts": `export default ${
-             *                JSON.stringify({
-             *                    "no-undef": 2
-             *                }, null, 2)};`,
-             *            "package.json": typeCommonJS,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo;"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 1);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             *
-             *it("should load eslint.config.ts with CJS syntax, \"type\": \"module\" in nearest `package.json` and top-level await syntax (default and named imports)", async () => {
-             *
-             *    const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "top-level-await", "import-default-and-named");
-             *
-             *    const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = await import(\"./rules\");\n\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
-             *
-             *    const teardown = createCustomTeardown({
-             *        cwd,
-             *        files: {
-             *            "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
-             *                JSON.stringify({
-             *                    "no-undef": 2
-             *                }, null, 2)} satisfies RulesRecord;`,
-             *            "package.json": typeModule,
-             *            "eslint.config.ts": configFileContent,
-             *            "foo.js": "foo"
-             *        }
-             *    });
-             *
-             *    await teardown.prepare();
-             *
-             *    eslint = new ESLint({
-             *        cwd,
-             *        flags
-             *    });
-             *
-             *    const results = await eslint.lintFiles(["foo.js"]);
-             *
-             *    assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-             *    assert.strictEqual(results.length, 1);
-             *    assert.strictEqual(results[0].messages.length, 2);
-             *    assert.strictEqual(results[0].messages[0].severity, 2);
-             *    assert.strictEqual(results[0].messages[1].severity, 2);
-             *    assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
-             *
-             *});
-             */
+                    assert.strictEqual(results[0].output, void 0);
+                });
 
-            it("should load eslint.config.ts with TypeScript's CJS syntax (import and export assignment), \"type\": \"module\" in nearest `package.json`", async () => {
+                it("should not fix non-style rules when fixTypes has only 'layout'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-semi.js");
+                    const outputPath = getFixturePath("fix-types/fix-only-semi.expected.js");
+                    const content = fs.readFileSync(inputPath, "utf8");
+                    const results = await eslint.lintText(content, { filePath: inputPath });
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "import-and-export-assignment");
+                    assert.strictEqual(results[0].output, expectedOutput);
+                });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { rules, Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                it("should not fix style or problem rules when fixTypes has only 'suggestion'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["suggestion"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.js");
+                    const outputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.expected.js");
+                    const content = fs.readFileSync(inputPath, "utf8");
+                    const results = await eslint.lintText(content, { filePath: inputPath });
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport = { rules: { \"no-undef\": Severity.Error }, Level } satisfies RulesRecord;",
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert.strictEqual(results[0].output, expectedOutput);
                 });
 
-                await teardown.prepare();
+                it("should fix both style and problem rules when fixTypes has 'suggestion' and 'layout'", async () => {
+                    eslint = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        fix: true,
+                        fixTypes: ["suggestion", "layout"]
+                    });
+                    const inputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.js");
+                    const outputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.expected.js");
+                    const content = fs.readFileSync(inputPath, "utf8");
+                    const results = await eslint.lintText(content, { filePath: inputPath });
+                    const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert.strictEqual(results[0].output, expectedOutput);
                 });
+            });
+        });
 
-                const results = await eslint.lintFiles(["foo.js"]);
+        describe("isPathIgnored", () => {
+            it("should check if the given path is ignored", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
+                    cwd: getFixturePath()
+                });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                assert(await engine.isPathIgnored("undef.js"));
+                assert(!await engine.isPathIgnored("passing.js"));
+            });
+
+            it("should return false if ignoring is disabled", async () => {
+                const engine = new ESLint({
+                    flags,
+                    ignore: false,
+                    overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
+                    cwd: getFixturePath()
+                });
 
+                assert(!await engine.isPathIgnored("undef.js"));
             });
 
-            it("should load eslint.config.ts with TypeScript's CJS syntax (import and export assignment), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+            // https://github.com/eslint/eslint/issues/5547
+            it("should return true for default ignores even if ignoring is disabled", async () => {
+                const engine = new ESLint({
+                    flags,
+                    ignore: false,
+                    cwd: getFixturePath("cli-engine")
+                });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "import-and-export-assignment");
+                assert(await engine.isPathIgnored("node_modules/foo.js"));
+            });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { rules, Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+            describe("about the default ignore patterns", () => {
+                it("should always apply default ignore patterns if ignore option is true", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, cwd });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport = { rules: { \"no-undef\": Severity.Error }, Level } satisfies RulesRecord;",
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules/package/file.js")));
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "subdir/node_modules/package/file.js")));
                 });
 
-                await teardown.prepare();
+                it("should still apply default ignore patterns if ignore option is false", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, ignore: false, cwd });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules/package/file.js")));
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "subdir/node_modules/package/file.js")));
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                it("should allow subfolders of defaultPatterns to be unignored by ignorePattern constructor option", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        cwd,
+                        overrideConfigFile: true,
+                        ignorePatterns: ["!node_modules/", "node_modules/*", "!node_modules/package/"]
+                    });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    const result = await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules", "package", "file.js"));
 
-            });
+                    assert(!result, "File should not be ignored");
+                });
 
-            it("should load eslint.config.ts with wildcard imports, \"type\": \"module\" in nearest `package.json`", async () => {
+                it("should allow subfolders of defaultPatterns to be unignored by ignores in overrideConfig", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        cwd,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            ignores: ["!node_modules/", "node_modules/*", "!node_modules/package/"]
+                        }
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "wildcard-imports");
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules", "package", "file.js")));
+                });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport * as rulesModule from \"./rules\";\nconst { default: rules ,Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                it("should ignore .git directory", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, cwd });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", ".git/bar")));
                 });
 
-                await teardown.prepare();
+                it("should still ignore .git directory when ignore option disabled", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, ignore: false, cwd });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", ".git/bar")));
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should not ignore absolute paths containing '..'", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, cwd });
 
-            });
+                    assert(!await engine.isPathIgnored(`${getFixturePath("ignored-paths", "foo")}/../unignored.js`));
+                });
 
-            it("should load eslint.config.ts with wildcard imports, \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                it("should ignore /node_modules/ relative to cwd without any configured ignore patterns", async () => {
+                    const cwd = getFixturePath("ignored-paths", "no-ignore-file");
+                    const engine = new ESLint({ flags, cwd });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "wildcard-imports");
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "no-ignore-file", "node_modules", "existing.js")));
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "no-ignore-file", "foo", "node_modules", "existing.js")));
+                });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../helper\";\nimport * as rulesModule from \"./rules\";\nconst { default: rules ,Level } = rulesModule;\nexport = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                it("should not inadvertently ignore all files in parent directories", async () => {
+                    const engine = new ESLint({ flags, cwd: getFixturePath("ignored-paths", "no-ignore-file") });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../helper\";\nimport { Severity } from \"../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
                 });
+            });
 
-                await teardown.prepare();
+            describe("with ignorePatterns option", () => {
+                it("should accept a string for options.ignorePatterns", async () => {
+                    const cwd = getFixturePath("ignored-paths", "ignore-pattern");
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["ignore-me.txt"],
+                        cwd
+                    });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert(await engine.isPathIgnored("ignore-me.txt"));
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should accept an array for options.ignorePattern", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["a.js", "b.js"],
+                        overrideConfigFile: true
+                    });
 
-            });
+                    assert(await engine.isPathIgnored("a.js"), "a.js should be ignored");
+                    assert(await engine.isPathIgnored("b.js"), "b.js should be ignored");
+                    assert(!await engine.isPathIgnored("c.js"), "c.js should not be ignored");
+                });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import and module.exports), \"type\": \"module\" in nearest `package.json`", async () => {
+                it("should interpret ignorePatterns as relative to cwd", async () => {
+                    const cwd = getFixturePath("ignored-paths", "subdir");
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["undef.js"],
+                        cwd // using ../../eslint.config.js
+                    });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-and-module-exports");
+                    assert(await engine.isPathIgnored(path.join(cwd, "undef.js")));
+                });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rules, { Level } from \"./rules\";\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                it("should return true for files which match an ignorePattern even if they do not exist on the filesystem", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["not-a-file"],
+                        cwd
+                    });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
-                            JSON.stringify({
-                                "no-undef": 2
-                            }, null, 2)} satisfies RulesRecord;`,
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "not-a-file")));
                 });
 
-                await teardown.prepare();
+                it("should return true for file matching an ignore pattern exactly", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["undef.js"],
+                        cwd,
+                        overrideConfigFile: true
+                    });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("should return false for file in subfolder of cwd matching an ignore pattern with a base filename", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const filePath = getFixturePath("ignored-paths", "subdir", "undef.js");
+                    const engine = new ESLint({
+                        flags,
+                        ignorePatterns: ["undef.js"],
+                        overrideConfigFile: true,
+                        cwd
+                    });
 
-            });
+                    assert(!await engine.isPathIgnored(filePath));
+                });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import and module.exports), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                it("should return true for file matching a child of an ignore pattern", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, ignorePatterns: ["ignore-pattern"], cwd });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-and-module-exports");
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "ignore-pattern", "ignore-me.txt")));
+                });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rules, { Level } from \"./rules\";\nmodule.exports = [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                it("should return true for file matching a grandchild of a directory when the pattern is directory/**", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, ignorePatterns: ["ignore-pattern/**"], cwd });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": `import type { RulesRecord } from "../../../../helper";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default ${
-                            JSON.stringify({
-                                "no-undef": 2
-                            }, null, 2)} satisfies RulesRecord;`,
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "ignore-pattern", "subdir", "ignore-me.js")));
                 });
 
-                await teardown.prepare();
+                it("should return false for file not matching any ignore pattern", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({ flags, ignorePatterns: ["failing.js"], cwd });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "unignored.js")));
                 });
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                it("two globstar '**' ignore pattern should ignore files in nested directories", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: true,
+                        ignorePatterns: ["**/*.js"],
+                        cwd
+                    });
 
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo.js")), "foo.js should be ignored");
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar.js")), "foo/bar.js should be ignored");
+                    assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar/baz.js")), "foo/bar/baz.js");
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo.cjs")), "foo.cjs should not be ignored");
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar.cjs")), "foo/bar.cjs should not be ignored");
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar/baz.cjs")), "foo/bar/baz.cjs should not be ignored");
+                });
             });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (require and export default), \"type\": \"module\" in nearest `package.json`", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "require-and-export-default");
-
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = require(\"./rules\");\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+            describe("with config ignores ignorePatterns option", () => {
+                it("should return false for ignored file when unignored with ignore pattern", async () => {
+                    const cwd = getFixturePath("ignored-paths");
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
+                        ignorePatterns: ["!undef.js"],
+                        cwd
+                    });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+                    assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
                 });
+            });
 
-                await teardown.prepare();
+            it("should throw if non-string value is given to 'filePath' parameter", async () => {
+                const eslint = new ESLint({ flags });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
-                });
+                await assert.rejects(() => eslint.isPathIgnored(null), /'filePath' must be a non-empty string/u);
+            });
+        });
+
+        describe("loadFormatter()", () => {
+            it("should return a formatter object when a bundled formatter is requested", async () => {
+                const engine = new ESLint({ flags });
+                const formatter = await engine.loadFormatter("json");
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should return a formatter object when no argument is passed", async () => {
+                const engine = new ESLint({ flags });
+                const formatter = await engine.loadFormatter();
 
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
             });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (require and export default), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+            it("should return a formatter object when a custom formatter is requested", async () => {
+                const engine = new ESLint({ flags });
+                const formatter = await engine.loadFormatter(getFixturePath("formatters", "simple.js"));
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "require-and-export-default");
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
+
+            it("should return a formatter object when a custom formatter is requested, also if the path has backslashes", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: path.join(fixtureDir, "..")
+                });
+                const formatter = await engine.loadFormatter(".\\fixtures\\formatters\\simple.js");
 
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nconst { default: rules, Level } = require(\"./rules\");\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+            it("should return a formatter object when a formatter prefixed with eslint-formatter is requested", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: getFixturePath("cli-engine")
                 });
+                const formatter = await engine.loadFormatter("bar");
 
-                await teardown.prepare();
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return a formatter object when a formatter is requested, also when the eslint-formatter prefix is included in the format argument", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: getFixturePath("cli-engine")
                 });
+                const formatter = await engine.loadFormatter("eslint-formatter-bar");
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should return a formatter object when a formatter is requested within a scoped npm package", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: getFixturePath("cli-engine")
+                });
+                const formatter = await engine.loadFormatter("@somenamespace/foo");
 
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
             });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import assignment and export default), \"type\": \"module\" in nearest `package.json`", async () => {
+            it("should return a formatter object when a formatter is requested within a scoped npm package, also when the eslint-formatter prefix is included in the format argument", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: getFixturePath("cli-engine")
+                });
+                const formatter = await engine.loadFormatter("@somenamespace/eslint-formatter-foo");
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-assignment-and-export-default");
+                assert.strictEqual(typeof formatter, "object");
+                assert.strictEqual(typeof formatter.format, "function");
+            });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+            it("should throw if a custom formatter doesn't exist", async () => {
+                const engine = new ESLint({ flags });
+                const formatterPath = getFixturePath("formatters", "doesntexist.js");
+                const fullFormatterPath = path.resolve(formatterPath);
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
-                });
+                await assert.rejects(async () => {
+                    await engine.loadFormatter(formatterPath);
+                }, new RegExp(escapeStringRegExp(`There was a problem loading formatter: ${fullFormatterPath}\nError: Cannot find module '${fullFormatterPath}'`), "u"));
+            });
 
-                await teardown.prepare();
+            it("should throw if a built-in formatter doesn't exist", async () => {
+                const engine = new ESLint({ flags });
+                const fullFormatterPath = path.resolve(__dirname, "../../../lib/cli-engine/formatters/special");
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
-                });
+                await assert.rejects(async () => {
+                    await engine.loadFormatter("special");
+                }, new RegExp(escapeStringRegExp(`There was a problem loading formatter: ${fullFormatterPath}.js\nError: Cannot find module '${fullFormatterPath}.js'`), "u"));
+            });
 
-                const results = await eslint.lintFiles(["foo.js"]);
+            it("should throw if the required formatter exists but has an error", async () => {
+                const engine = new ESLint({ flags });
+                const formatterPath = getFixturePath("formatters", "broken.js");
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                await assert.rejects(async () => {
+                    await engine.loadFormatter(formatterPath);
 
+                    // for some reason, the error here contains multiple "there was a problem loading formatter" lines, so omitting
+                }, new RegExp(escapeStringRegExp("Error: Cannot find module 'this-module-does-not-exist'"), "u"));
             });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import assignment and export default), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+            it("should throw if a non-string formatter name is passed", async () => {
+                const engine = new ESLint({ flags });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-assignment-and-export-default");
+                await assert.rejects(async () => {
+                    await engine.loadFormatter(5);
+                }, /'name' must be a string/u);
+            });
+        });
 
-                const configFileContent = "import type { FlatConfig } from \"../../../../helper\";\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nexport default [{ rules: { ...rules, semi: Level.Error } }] satisfies FlatConfig[];";
+        describe("getErrorResults()", () => {
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import type { RulesRecord } from \"../../../../helper\";\nimport { Severity } from \"../../../../helper\";\nexport const enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nexport default { \"no-undef\": Severity.Error } satisfies RulesRecord;",
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
+            it("should report 5 error messages when looking for errors only", async () => {
+                process.chdir(originalDir);
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            quotes: "error",
+                            "no-var": "error",
+                            "eol-last": "error",
+                            "no-unused-vars": "error"
+                        }
                     }
                 });
+                const results = await engine.lintText("var foo = 'bar';");
+                const errorResults = ESLint.getErrorResults(results);
 
-                await teardown.prepare();
+                assert.strictEqual(errorResults[0].messages.length, 4, "messages.length is wrong");
+                assert.strictEqual(errorResults[0].errorCount, 4, "errorCount is wrong");
+                assert.strictEqual(errorResults[0].fixableErrorCount, 3, "fixableErrorCount is wrong");
+                assert.strictEqual(errorResults[0].fixableWarningCount, 0, "fixableWarningCount is wrong");
+                assert.strictEqual(errorResults[0].messages[0].ruleId, "no-var");
+                assert.strictEqual(errorResults[0].messages[0].severity, 2);
+                assert.strictEqual(errorResults[0].messages[1].ruleId, "no-unused-vars");
+                assert.strictEqual(errorResults[0].messages[1].severity, 2);
+                assert.strictEqual(errorResults[0].messages[2].ruleId, "quotes");
+                assert.strictEqual(errorResults[0].messages[2].severity, 2);
+                assert.strictEqual(errorResults[0].messages[3].ruleId, "eol-last");
+                assert.strictEqual(errorResults[0].messages[3].severity, 2);
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should not mutate passed report parameter", async () => {
+                process.chdir(originalDir);
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { quotes: [1, "double"] }
+                    }
                 });
+                const results = await engine.lintText("var foo = 'bar';");
+                const reportResultsLength = results[0].messages.length;
 
-                const results = await eslint.lintFiles(["foo.js"]);
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                ESLint.getErrorResults(results);
 
+                assert.strictEqual(results[0].messages.length, reportResultsLength);
             });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import and export assignment), \"type\": \"module\" in nearest `package.json`", async () => {
+            it("should report a warningCount of 0 when looking for errors only", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            strict: ["error", "global"],
+                            quotes: "error",
+                            "no-var": "error",
+                            "eol-last": "error",
+                            "no-unused-vars": "error"
+                        }
+                    }
+                });
+                const lintResults = await engine.lintText("var foo = 'bar';");
+                const errorResults = ESLint.getErrorResults(lintResults);
+
+                assert.strictEqual(errorResults[0].warningCount, 0);
+                assert.strictEqual(errorResults[0].fixableWarningCount, 0);
+            });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-module", "CJS-ESM-mixed-syntax", "import-and-export-assignment");
+            it("should return 0 error or warning messages even when the file has warnings", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: getFixturePath("eslint.config-with-ignores.js"),
+                    cwd: path.join(fixtureDir, "..")
+                });
+                const options = {
+                    filePath: "fixtures/passing.js",
+                    warnIgnored: true
+                };
+                const results = await engine.lintText("var bar = foo;", options);
+                const errorReport = ESLint.getErrorResults(results);
 
-                const configFileContent = "import helpers = require(\"../../../../helper\");\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nconst allExports = [{ rules: { ...rules, semi: Level.Error } }] satisfies helpers.FlatConfig[];\nexport = allExports;";
+                assert.strictEqual(errorReport.length, 0);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].errorCount, 0);
+                assert.strictEqual(results[0].warningCount, 1);
+            });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import helpers = require(\"../../../../helper\");\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nconst rules = { \"no-undef\": helpers.Severity.Error } satisfies helpers.RulesRecord;\nconst allExports = { default: rules, Level };\nexport = allExports;",
-                        "package.json": typeModule,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
+            it("should return source code of file in the `source` property", async () => {
+                process.chdir(originalDir);
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: { quotes: [2, "double"] }
                     }
                 });
+                const results = await engine.lintText("var foo = 'bar';");
+                const errorResults = ESLint.getErrorResults(results);
 
-                await teardown.prepare();
+                assert.strictEqual(errorResults[0].messages.length, 1);
+                assert.strictEqual(errorResults[0].source, "var foo = 'bar';");
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should contain `output` property after fixes", async () => {
+                process.chdir(originalDir);
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    fix: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2,
+                            "no-console": 2
+                        }
+                    }
                 });
+                const results = await engine.lintText("console.log('foo')");
+                const errorResults = ESLint.getErrorResults(results);
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                assert.strictEqual(errorResults[0].messages.length, 1);
+                assert.strictEqual(errorResults[0].output, "console.log('foo');");
+            });
+        });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+        describe("findConfigFile()", () => {
 
-            });
+            it("should return undefined when overrideConfigFile is true", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true
+                });
 
-            it("should load eslint.config.ts with CJS-ESM mixed syntax (import and export assignment), \"type\": \"commonjs\" in nearest `package.json`", async () => {
+                assert.strictEqual(await engine.findConfigFile(), void 0);
+            });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "with-type-commonjs", "CJS-ESM-mixed-syntax", "import-and-export-assignment");
+            it("should return undefined when a config file isn't found", async () => {
+                const engine = new ESLint({
+                    flags,
+                    cwd: path.resolve(__dirname, "../../../../")
+                });
 
-                const configFileContent = "import helpers = require(\"../../../../helper\");\nimport rulesModule = require(\"./rules\");\nconst { default: rules, Level } = rulesModule;\nconst allExports = [{ rules: { ...rules, semi: Level.Error } }] satisfies helpers.FlatConfig[];\nexport = allExports;";
+                assert.strictEqual(await engine.findConfigFile(), void 0);
+            });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "rules.ts": "import helpers = require(\"../../../../helper\");\nconst enum Level {\nError = 2,\nWarn = 1,\nOff = 0,\n};\nconst rules = { \"no-undef\": helpers.Severity.Error } satisfies helpers.RulesRecord;\nconst allExports = { default: rules, Level };\nexport = allExports;",
-                        "package.json": typeCommonJS,
-                        "eslint.config.ts": configFileContent,
-                        "foo.js": "foo"
-                    }
+            it("should return custom config file path when overrideConfigFile is a nonempty string", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: "my-config.js"
                 });
+                const configFilePath = path.resolve(__dirname, "../../../my-config.js");
 
-                await teardown.prepare();
+                assert.strictEqual(await engine.findConfigFile(), configFilePath);
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return root level eslint.config.js when overrideConfigFile is null", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: null
                 });
+                const configFilePath = path.resolve(__dirname, "../../../eslint.config.js");
 
-                const results = await eslint.lintFiles(["foo.js"]);
+                assert.strictEqual(await engine.findConfigFile(), configFilePath);
+            });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 2);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[1].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should return root level eslint.config.js when overrideConfigFile is not specified", async () => {
+                const engine = new ESLint({ flags });
+                const configFilePath = path.resolve(__dirname, "../../../eslint.config.js");
 
+                assert.strictEqual(await engine.findConfigFile(), configFilePath);
             });
 
-            it("should load eslint.config.ts with const enums", async () => {
+        });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "const-enums");
+        describe("Use stats option", () => {
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            /**
+             * Check if the given number is a number.
+             * @param {number} n The number to check.
+             * @returns {boolean} `true` if the number is a number, `false` otherwise.
+             */
+            function isNumber(n) {
+                return typeof n === "number" && !Number.isNaN(n);
+            }
+
+            it("should report stats", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            "no-regex-spaces": "error"
+                        }
+                    },
+                    cwd: getFixturePath("stats-example"),
+                    stats: true
                 });
+                const results = await engine.lintFiles(["file-to-fix.js"]);
 
-                const results = await eslint.lintFiles("foo.js");
+                assert.strictEqual(results[0].stats.fixPasses, 0);
+                assert.strictEqual(results[0].stats.times.passes.length, 1);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].parse.total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["no-regex-spaces"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["wrap-regex"].total), true);
+                assert.strictEqual(results[0].stats.times.passes[0].fix.total, 0);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].total), true);
+            });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should report stats with fix", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            "no-regex-spaces": "error"
+                        }
+                    },
+                    cwd: getFixturePath("stats-example"),
+                    fix: true,
+                    stats: true
+                });
+                const results = await engine.lintFiles(["file-to-fix.js"]);
 
+                assert.strictEqual(results[0].stats.fixPasses, 2);
+                assert.strictEqual(results[0].stats.times.passes.length, 3);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].parse.total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[1].parse.total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[2].parse.total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["no-regex-spaces"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["wrap-regex"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[1].rules["no-regex-spaces"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[1].rules["wrap-regex"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[2].rules["no-regex-spaces"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[2].rules["wrap-regex"].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].fix.total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[1].fix.total), true);
+                assert.strictEqual(results[0].stats.times.passes[2].fix.total, 0);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[0].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[1].total), true);
+                assert.strictEqual(isNumber(results[0].stats.times.passes[2].total), true);
             });
 
-            it("should load eslint.config.ts with local namespace", async () => {
+        });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "local-namespace");
+        describe("getRulesMetaForResults()", () => {
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should throw an error when this instance did not lint any files", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                assert.throws(() => {
+                    engine.getRulesMetaForResults([
+                        {
+                            filePath: "path/to/file.js",
+                            messages: [
+                                {
+                                    ruleId: "curly",
+                                    severity: 2,
+                                    message: "Expected { after 'if' condition.",
+                                    line: 2,
+                                    column: 1,
+                                    nodeType: "IfStatement"
+                                },
+                                {
+                                    ruleId: "no-process-exit",
+                                    severity: 2,
+                                    message: "Don't use process.exit(); throw an error instead.",
+                                    line: 3,
+                                    column: 1,
+                                    nodeType: "CallExpression"
+                                }
+                            ],
+                            suppressedMessages: [],
+                            errorCount: 2,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            source:
+                                "var err = doStuff();\nif (err) console.log('failed tests: ' + err);\nprocess.exit(1);\n"
+                        }
+                    ]);
+                }, {
+                    constructor: TypeError,
+                    message: "Results object was not created from this ESLint instance."
+                });
+            });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+            it("should throw an error when results were created from a different instance", async () => {
+                const engine1 = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    cwd: path.join(fixtureDir, "foo"),
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    }
+                });
+                const engine2 = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    cwd: path.join(fixtureDir, "bar"),
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    }
+                });
+
+                const results1 = await engine1.lintText("1", { filePath: "file.js" });
+                const results2 = await engine2.lintText("2", { filePath: "file.js" });
 
+                engine1.getRulesMetaForResults(results1); // should not throw an error
+                assert.throws(() => {
+                    engine1.getRulesMetaForResults(results2);
+                }, {
+                    constructor: TypeError,
+                    message: "Results object was not created from this ESLint instance."
+                });
             });
 
-            it("should allow passing a TS config file to `overrideConfigFile`", async () => {
+            it("should treat a result without `filePath` as if the file was located in `cwd`", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    cwd: path.join(fixtureDir, "foo", "bar"),
+                    ignorePatterns: ["*/**"], // ignore all subdirectories of `cwd`
+                    overrideConfig: {
+                        rules: {
+                            eqeqeq: "warn"
+                        }
+                    }
+                });
 
-                const cwd = getFixturePath("ts-config-files", "ts", "custom-config");
+                const results = await engine.lintText("a==b");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
-                const overrideConfigFile = path.join(cwd, "eslint.custom.config.ts");
+                assert.deepStrictEqual(rulesMeta.eqeqeq, coreRules.get("eqeqeq").meta);
+            });
 
-                eslint = new ESLint({
-                    cwd,
+            it("should not throw an error if a result without `filePath` contains an ignored file warning", async () => {
+                const engine = new ESLint({
                     flags,
-                    overrideConfigFile
+                    overrideConfigFile: true,
+                    cwd: path.join(fixtureDir, "foo", "bar"),
+                    ignorePatterns: ["**"]
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                const results = await engine.lintText("", { warnIgnored: true });
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
-                assert.strictEqual(await eslint.findConfigFile(), overrideConfigFile);
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                assert.deepStrictEqual(rulesMeta, {});
+            });
+
+            it("should not throw an error if results contain linted files and one ignored file", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    cwd: getFixturePath(),
+                    ignorePatterns: ["passing*"],
+                    overrideConfig: {
+                        rules: {
+                            "no-undef": 2,
+                            semi: 1
+                        }
+                    }
+                });
 
-            });
+                const results = await engine.lintFiles(["missing-semicolon.js", "passing.js", "undef.js"]);
 
-            it("should find and load eslint.config.mts when present", async () => {
+                assert(
+                    results.some(({ messages }) => messages.some(({ message, ruleId }) => !ruleId && message.startsWith("File ignored"))),
+                    "At least one file should be ignored but none is."
+                );
 
-                const cwd = getFixturePath("ts-config-files", "mts");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
-                });
+                assert.deepStrictEqual(rulesMeta["no-undef"], coreRules.get("no-undef").meta);
+                assert.deepStrictEqual(rulesMeta.semi, coreRules.get("semi").meta);
+            });
 
-                const results = await eslint.lintFiles("foo.js");
+            it("should return empty object when there are no linting errors", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true
+                });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                const rulesMeta = engine.getRulesMetaForResults([]);
 
+                assert.deepStrictEqual(rulesMeta, {});
             });
 
-            it("should load eslint.config.mts when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "mts", "with-type-commonjs");
-
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return one rule meta when there is a linting error", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                const results = await engine.lintText("a", { filePath: "foo.js" });
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.strictEqual(Object.keys(rulesMeta).length, 1);
+                assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
             });
 
-            it("should load eslint.config.mts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "mts", "with-type-module");
-
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return one rule meta when there is a suppressed linting error", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                const results = await engine.lintText("a // eslint-disable-line semi");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.strictEqual(Object.keys(rulesMeta).length, 1);
+                assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
             });
 
-            it("should find and load eslint.config.cts when present", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "cts");
-
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return multiple rule meta when there are multiple linting errors", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        rules: {
+                            semi: 2,
+                            quotes: [2, "double"]
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                const results = await engine.lintText("'a'");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
+                assert.strictEqual(rulesMeta.quotes, coreRules.get("quotes").meta);
             });
 
-            it("should load eslint.config.cts config file when we have \"type\": \"commonjs\" in nearest `package.json`", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "cts", "with-type-commonjs");
-
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should return multiple rule meta when there are multiple linting errors from a plugin", async () => {
+                const customPlugin = {
+                    rules: {
+                        "no-var": require("../../../lib/rules/no-var")
+                    }
+                };
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: {
+                        plugins: {
+                            "custom-plugin": customPlugin
+                        },
+                        rules: {
+                            "custom-plugin/no-var": 2,
+                            semi: 2,
+                            quotes: [2, "double"]
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles("foo.js");
-
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                const results = await engine.lintText("var foo = 0; var bar = '1'");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
+                assert.strictEqual(rulesMeta.quotes, coreRules.get("quotes").meta);
+                assert.strictEqual(
+                    rulesMeta["custom-plugin/no-var"],
+                    customPlugin.rules["no-var"].meta
+                );
             });
 
-            it("should load .cts config file when we have \"type\": \"module\" in nearest `package.json`", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "cts", "with-type-module");
-
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should ignore messages not related to a rule", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    ignorePatterns: ["ignored.js"],
+                    overrideConfig: {
+                        rules: {
+                            "no-var": "warn"
+                        },
+                        linterOptions: {
+                            reportUnusedDisableDirectives: "warn"
+                        }
+                    }
                 });
 
-                const results = await eslint.lintFiles("foo.js");
+                {
+                    const results = await engine.lintText("syntax error");
+                    const rulesMeta = engine.getRulesMetaForResults(results);
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.cts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                    assert.deepStrictEqual(rulesMeta, {});
+                }
+                {
+                    const results = await engine.lintText("// eslint-disable-line no-var");
+                    const rulesMeta = engine.getRulesMetaForResults(results);
+
+                    assert.deepStrictEqual(rulesMeta, {});
+                }
+                {
+                    const results = await engine.lintText("", { filePath: "ignored.js", warnIgnored: true });
+                    const rulesMeta = engine.getRulesMetaForResults(results);
 
+                    assert.deepStrictEqual(rulesMeta, {});
+                }
             });
 
-            it("should not load extensions other than .ts, .mts or .cts", async () => {
+            it("should return a non-empty value if some of the messages are related to a rule", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: { rules: { "no-var": "warn" }, linterOptions: { reportUnusedDisableDirectives: "warn" } }
+                });
 
-                const cwd = getFixturePath("ts-config-files", "wrong-extension");
+                const results = await engine.lintText("// eslint-disable-line no-var\nvar foo;");
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
-                const configFileContent = `import type { FlatConfig } from "../../helper";\nexport default ${
-                    JSON.stringify([
-                        { rules: { "no-undef": 2 } }
-                    ], null, 2)} satisfies FlatConfig[];`;
+                assert.deepStrictEqual(rulesMeta, { "no-var": coreRules.get("no-var").meta });
+            });
 
-                const teardown = createCustomTeardown({
-                    cwd,
-                    files: {
-                        "package.json": typeCommonJS,
-                        "eslint.config.mcts": configFileContent,
-                        "foo.js": "foo;"
-                    }
+            it("should return empty object if all messages are related to unknown rules", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true
                 });
 
-                await teardown.prepare();
+                const results = await engine.lintText("// eslint-disable-line foo, bar/baz, bar/baz/qux");
 
-                eslint = new ESLint({
-                    cwd,
-                    overrideConfigFile: "eslint.config.mcts",
-                    flags
-                });
+                assert.strictEqual(results[0].messages.length, 3);
+                assert.strictEqual(results[0].messages[0].ruleId, "foo");
+                assert.strictEqual(results[0].messages[1].ruleId, "bar/baz");
+                assert.strictEqual(results[0].messages[2].ruleId, "bar/baz/qux");
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.mcts"));
-                await assert.rejects(() => eslint.lintFiles(["foo.js"]));
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.strictEqual(Object.keys(rulesMeta).length, 0);
             });
 
-            it("should not load TS config files when `\"unstable_ts_config\"` flag is not set", async () => {
+            it("should return object with meta of known rules if some messages are related to unknown rules", async () => {
+                const engine = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    overrideConfig: { rules: { "no-var": "warn" } }
+                });
 
-                const cwd = getFixturePath("ts-config-files", "ts");
+                const results = await engine.lintText("// eslint-disable-line foo, bar/baz, bar/baz/qux\nvar x;");
 
-                eslint = new ESLint({
-                    cwd,
-                    overrideConfigFile: "eslint.config.ts"
-                });
+                assert.strictEqual(results[0].messages.length, 4);
+                assert.strictEqual(results[0].messages[0].ruleId, "foo");
+                assert.strictEqual(results[0].messages[1].ruleId, "bar/baz");
+                assert.strictEqual(results[0].messages[2].ruleId, "bar/baz/qux");
+                assert.strictEqual(results[0].messages[3].ruleId, "no-var");
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                await assert.rejects(() => eslint.lintFiles(["foo.js"]));
+                const rulesMeta = engine.getRulesMetaForResults(results);
 
+                assert.deepStrictEqual(rulesMeta, { "no-var": coreRules.get("no-var").meta });
             });
+        });
 
-            it("should fallback to JS config files when `\"unstable_ts_config\"` flag is not set", async () => {
-
-                const cwd = getFixturePath("ts-config-files", "ts");
+        describe("outputFixes()", () => {
+            afterEach(() => {
+                sinon.verifyAndRestore();
+            });
 
-                eslint = new ESLint({
-                    cwd
+            it("should call fs.writeFile() for each result with output", async () => {
+                const spy = sinon.spy(() => Promise.resolve());
+                const { ESLint: localESLint } = proxyquire("../../../lib/eslint/eslint", {
+                    "node:fs/promises": {
+                        writeFile: spy
+                    }
                 });
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "../../eslint.config.js"));
-                await assert.doesNotReject(() => eslint.lintFiles(["foo.js"]));
-
-            });
+                const results = [
+                    {
+                        filePath: path.resolve("foo.js"),
+                        output: "bar"
+                    },
+                    {
+                        filePath: path.resolve("bar.js"),
+                        output: "baz"
+                    }
+                ];
 
-            it("should successfully load a TS config file that exports a promise", async () => {
+                await localESLint.outputFixes(results);
 
-                const cwd = getFixturePath("ts-config-files", "ts", "exports-promise");
+                assert.strictEqual(spy.callCount, 2);
+                assert(spy.firstCall.calledWithExactly(path.resolve("foo.js"), "bar"), "First call was incorrect.");
+                assert(spy.secondCall.calledWithExactly(path.resolve("bar.js"), "baz"), "Second call was incorrect.");
+            });
 
-                eslint = new ESLint({
-                    cwd,
-                    flags
+            it("should call fs.writeFile() for each result with output and not at all for a result without output", async () => {
+                const spy = sinon.spy(() => Promise.resolve());
+                const { ESLint: localESLint } = proxyquire("../../../lib/eslint/eslint", {
+                    "node:fs/promises": {
+                        writeFile: spy
+                    }
                 });
 
-                const results = await eslint.lintFiles(["foo*.js"]);
+                const results = [
+                    {
+                        filePath: path.resolve("foo.js"),
+                        output: "bar"
+                    },
+                    {
+                        filePath: path.resolve("abc.js")
+                    },
+                    {
+                        filePath: path.resolve("bar.js"),
+                        output: "baz"
+                    }
+                ];
 
-                assert.strictEqual(await eslint.findConfigFile(), path.join(cwd, "eslint.config.ts"));
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.join(cwd, "foo.js"));
-                assert.strictEqual(results[0].messages.length, 1);
-                assert.strictEqual(results[0].messages[0].severity, 2);
-                assert.strictEqual(results[0].messages[0].ruleId, "no-undef");
+                await localESLint.outputFixes(results);
 
+                assert.strictEqual(spy.callCount, 2, "Call count was wrong");
+                assert(spy.firstCall.calledWithExactly(path.resolve("foo.js"), "bar"), "First call was incorrect.");
+                assert(spy.secondCall.calledWithExactly(path.resolve("bar.js"), "baz"), "Second call was incorrect.");
             });
 
+            it("should throw if non object array is given to 'results' parameter", async () => {
+                await assert.rejects(() => ESLint.outputFixes(null), /'results' must be an array/u);
+                await assert.rejects(() => ESLint.outputFixes([null]), /'results' must include only objects/u);
+            });
         });
 
-        it("should stop linting files if a rule crashes", async () => {
-
-            const cwd = getFixturePath("files");
-            let createCallCount = 0;
-
-            eslint = new ESLint({
-                cwd,
-                plugins: {
-                    boom: {
+        describe("when evaluating code with comments to change config when allowInlineConfig is disabled", () => {
+            it("should report a violation for disabling rules", async () => {
+                const code = [
+                    "alert('test'); // eslint-disable-line no-alert"
+                ].join("\n");
+                const config = {
+                    flags,
+                    ignore: true,
+                    overrideConfigFile: true,
+                    allowInlineConfig: false,
+                    overrideConfig: {
                         rules: {
-                            boom: {
-                                create() {
-                                    createCallCount++;
-                                    throw Error("Boom!");
-                                }
-                            }
+                            "eol-last": 0,
+                            "no-alert": 1,
+                            "no-trailing-spaces": 0,
+                            strict: 0,
+                            quotes: 0
                         }
                     }
-                },
-                baseConfig: {
-                    rules: {
-                        "boom/boom": "error"
-                    }
-                }
+                };
+                const eslintCLI = new ESLint(config);
+                const results = await eslintCLI.lintText(code);
+                const messages = results[0].messages;
+
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "no-alert");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            await assert.rejects(eslint.lintFiles("*.js"));
+            it("should not report a violation by default", async () => {
+                const code = [
+                    "alert('test'); // eslint-disable-line no-alert"
+                ].join("\n");
+                const config = {
+                    flags,
+                    ignore: true,
+                    overrideConfigFile: true,
+                    allowInlineConfig: true,
+                    overrideConfig: {
+                        rules: {
+                            "eol-last": 0,
+                            "no-alert": 1,
+                            "no-trailing-spaces": 0,
+                            strict: 0,
+                            quotes: 0
+                        }
+                    }
+                };
+                const eslintCLI = new ESLint(config);
+                const results = await eslintCLI.lintText(code);
+                const messages = results[0].messages;
 
-            // Wait until all files have been closed.
-            // eslint-disable-next-line n/no-unsupported-features/node-builtins -- it's still an experimental feature.
-            while (process.getActiveResourcesInfo().includes("CloseReq")) {
-                await timers.setImmediate();
-            }
-            assert.strictEqual(createCallCount, 1);
+                assert.strictEqual(messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 1);
+                assert.strictEqual(results[0].suppressedMessages[0].ruleId, "no-alert");
+            });
         });
 
-        describe("Error while globbing", () => {
-
-            it("should throw an error with a glob pattern if an invalid config was provided", async () => {
-
-                const cwd = getFixturePath("files");
-
-                eslint = new ESLint({
-                    cwd,
-                    overrideConfig: [{ invalid: "foobar" }]
-                });
+        describe("when evaluating code when reportUnusedDisableDirectives is enabled", () => {
+            it("should report problems for unused eslint-disable directives", async () => {
+                const eslint = new ESLint({ flags, overrideConfigFile: true, overrideConfig: { linterOptions: { reportUnusedDisableDirectives: "error" } } });
 
-                await assert.rejects(eslint.lintFiles("*.js"));
+                assert.deepStrictEqual(
+                    await eslint.lintText("/* eslint-disable */"),
+                    [
+                        {
+                            filePath: "<text>",
+                            messages: [
+                                {
+                                    ruleId: null,
+                                    message: "Unused eslint-disable directive (no problems were reported).",
+                                    line: 1,
+                                    column: 1,
+                                    fix: {
+                                        range: [0, 20],
+                                        text: " "
+                                    },
+                                    severity: 2,
+                                    nodeType: null
+                                }
+                            ],
+                            suppressedMessages: [],
+                            errorCount: 1,
+                            warningCount: 0,
+                            fatalErrorCount: 0,
+                            fixableErrorCount: 1,
+                            fixableWarningCount: 0,
+                            source: "/* eslint-disable */",
+                            usedDeprecatedRules: []
+                        }
+                    ]
+                );
             });
+        });
 
-            it("should throw an error with a glob pattern if an error occurs traversing a directory", async () => {
+        describe("when retrieving version number", () => {
+            it("should return current version number", () => {
+                const eslintCLI = require("../../../lib/eslint/eslint").ESLint;
+                const version = eslintCLI.version;
 
-                const fsWalk = require("@nodelib/fs.walk");
-                const error = new Error("Boom!");
+                assert.strictEqual(typeof version, "string");
+                assert(parseInt(version[0], 10) >= 3);
+            });
+        });
 
-                sinon
-                    .stub(fsWalk, "walk")
-                    .value(sinon.stub().yieldsRight(error)); // call the callback passed to `fs.walk` with an error
+        describe("mutability", () => {
 
-                const cwd = getFixturePath("files");
+            describe("rules", () => {
+                it("Loading rules in one instance doesn't mutate to another instance", async () => {
+                    const filePath = getFixturePath("single-quoted.js");
+                    const engine1 = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            plugins: {
+                                example: {
+                                    rules: {
+                                        "example-rule"() {
+                                            return {};
+                                        }
+                                    }
+                                }
+                            },
+                            rules: { "example/example-rule": 1 }
+                        }
+                    });
+                    const engine2 = new ESLint({
+                        flags,
+                        cwd: path.join(fixtureDir, ".."),
+                        overrideConfigFile: true
+                    });
+                    const fileConfig1 = await engine1.calculateConfigForFile(filePath);
+                    const fileConfig2 = await engine2.calculateConfigForFile(filePath);
 
-                eslint = new ESLint({
-                    cwd,
-                    overrideConfigFile: true
+                    // plugin
+                    assert.deepStrictEqual(fileConfig1.rules["example/example-rule"], [1], "example is present for engine 1");
+                    assert.strictEqual(fileConfig2.rules, void 0, "example is not present for engine 2");
                 });
-
-                await assert.rejects(eslint.lintFiles("*.js"), error);
             });
-
         });
 
-    });
+        describe("configs with 'ignores' and without 'files'", () => {
 
-    describe("Fix Types", () => {
+            // https://github.com/eslint/eslint/issues/17103
+            describe("config with ignores: ['error.js']", () => {
+                const cwd = getFixturePath("config-with-ignores-without-files");
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd,
+                    files: {
+                        "eslint.config.js": `module.exports = [
+                            {
+                                rules: {
+                                    "no-unused-vars": "error",
+                                },
+                            },
+                            {
+                                ignores: ["error.js"],
+                                rules: {
+                                    "no-unused-vars": "warn",
+                                },
+                            },
+                        ];`,
+                        "error.js": "let unusedVar;",
+                        "warn.js": "let unusedVar;"
+                    }
+                });
 
-        /** @type {InstanceType<ESLint>} */
-        let eslint;
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-        describe("fixTypes values validation", () => {
-            it("should throw an error when an invalid fix type is specified", () => {
-                assert.throws(() => {
-                    eslint = new ESLint({
-                        cwd: path.join(fixtureDir, ".."),
-                        overrideConfigFile: true,
-                        fix: true,
-                        fixTypes: ["layou"]
+                it("should apply to all files except for 'error.js'", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        cwd
                     });
-                }, /'fixTypes' must be an array of any of "directive", "problem", "suggestion", and "layout"\./iu);
-            });
-        });
 
-        describe("with lintFiles", () => {
-            it("should not fix any rules when fixTypes is used without fix", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: false,
-                    fixTypes: ["layout"]
-                });
-                const inputPath = getFixturePath("fix-types/fix-only-semi.js");
-                const results = await eslint.lintFiles([inputPath]);
-
-                assert.strictEqual(results[0].output, void 0);
-            });
-
-            it("should not fix non-style rules when fixTypes has only 'layout'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["layout"]
-                });
-                const inputPath = getFixturePath("fix-types/fix-only-semi.js");
-                const outputPath = getFixturePath("fix-types/fix-only-semi.expected.js");
-                const results = await eslint.lintFiles([inputPath]);
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
+                    const results = await engine.lintFiles("{error,warn}.js");
 
-                assert.strictEqual(results[0].output, expectedOutput);
-            });
+                    assert.strictEqual(results.length, 2);
 
-            it("should not fix style or problem rules when fixTypes has only 'suggestion'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["suggestion"]
-                });
-                const inputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.js");
-                const outputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.expected.js");
-                const results = await eslint.lintFiles([inputPath]);
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
+                    const [errorResult, warnResult] = results;
 
-                assert.strictEqual(results[0].output, expectedOutput);
-            });
+                    assert.strictEqual(errorResult.filePath, path.join(getPath(), "error.js"));
+                    assert.strictEqual(errorResult.messages.length, 1);
+                    assert.strictEqual(errorResult.messages[0].ruleId, "no-unused-vars");
+                    assert.strictEqual(errorResult.messages[0].severity, 2);
 
-            it("should fix both style and problem rules when fixTypes has 'suggestion' and 'layout'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["suggestion", "layout"]
+                    assert.strictEqual(warnResult.filePath, path.join(getPath(), "warn.js"));
+                    assert.strictEqual(warnResult.messages.length, 1);
+                    assert.strictEqual(warnResult.messages[0].ruleId, "no-unused-vars");
+                    assert.strictEqual(warnResult.messages[0].severity, 1);
                 });
-                const inputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.js");
-                const outputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.expected.js");
-                const results = await eslint.lintFiles([inputPath]);
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                assert.strictEqual(results[0].output, expectedOutput);
-            });
-        });
+                // https://github.com/eslint/eslint/issues/18261
+                it("should apply to all files except for 'error.js' even with `ignore: false` option", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        cwd,
+                        ignore: false
+                    });
 
-        describe("with lintText", () => {
-            it("should not fix any rules when fixTypes is used without fix", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: false,
-                    fixTypes: ["layout"]
-                });
-                const inputPath = getFixturePath("fix-types/fix-only-semi.js");
-                const content = fs.readFileSync(inputPath, "utf8");
-                const results = await eslint.lintText(content, { filePath: inputPath });
+                    const results = await engine.lintFiles("{error,warn}.js");
 
-                assert.strictEqual(results[0].output, void 0);
-            });
+                    assert.strictEqual(results.length, 2);
 
-            it("should not fix non-style rules when fixTypes has only 'layout'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["layout"]
-                });
-                const inputPath = getFixturePath("fix-types/fix-only-semi.js");
-                const outputPath = getFixturePath("fix-types/fix-only-semi.expected.js");
-                const content = fs.readFileSync(inputPath, "utf8");
-                const results = await eslint.lintText(content, { filePath: inputPath });
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
+                    const [errorResult, warnResult] = results;
 
-                assert.strictEqual(results[0].output, expectedOutput);
-            });
+                    assert.strictEqual(errorResult.filePath, path.join(getPath(), "error.js"));
+                    assert.strictEqual(errorResult.messages.length, 1);
+                    assert.strictEqual(errorResult.messages[0].ruleId, "no-unused-vars");
+                    assert.strictEqual(errorResult.messages[0].severity, 2);
 
-            it("should not fix style or problem rules when fixTypes has only 'suggestion'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["suggestion"]
+                    assert.strictEqual(warnResult.filePath, path.join(getPath(), "warn.js"));
+                    assert.strictEqual(warnResult.messages.length, 1);
+                    assert.strictEqual(warnResult.messages[0].ruleId, "no-unused-vars");
+                    assert.strictEqual(warnResult.messages[0].severity, 1);
                 });
-                const inputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.js");
-                const outputPath = getFixturePath("fix-types/fix-only-prefer-arrow-callback.expected.js");
-                const content = fs.readFileSync(inputPath, "utf8");
-                const results = await eslint.lintText(content, { filePath: inputPath });
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
-
-                assert.strictEqual(results[0].output, expectedOutput);
             });
 
-            it("should fix both style and problem rules when fixTypes has 'suggestion' and 'layout'", async () => {
-                eslint = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true,
-                    fix: true,
-                    fixTypes: ["suggestion", "layout"]
+            describe("config with ignores: ['**/*.json']", () => {
+                const cwd = getFixturePath("config-with-ignores-without-files");
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd,
+                    files: {
+                        "eslint.config.js": `module.exports = [
+                            {
+                                rules: {
+                                    "no-undef": "error",
+                                },
+                            },
+                            {
+                                ignores: ["**/*.json"],
+                                rules: {
+                                    "no-unused-vars": "error",
+                                },
+                            },
+                        ];`,
+                        "foo.js": "",
+                        "foo.json": ""
+                    }
                 });
-                const inputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.js");
-                const outputPath = getFixturePath("fix-types/fix-both-semi-and-prefer-arrow-callback.expected.js");
-                const content = fs.readFileSync(inputPath, "utf8");
-                const results = await eslint.lintText(content, { filePath: inputPath });
-                const expectedOutput = fs.readFileSync(outputPath, "utf8");
 
-                assert.strictEqual(results[0].output, expectedOutput);
-            });
-        });
-    });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-    describe("isPathIgnored", () => {
-        it("should check if the given path is ignored", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
-                cwd: getFixturePath()
-            });
+                it("should not add json files as lint targets", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        cwd
+                    });
 
-            assert(await engine.isPathIgnored("undef.js"));
-            assert(!await engine.isPathIgnored("passing.js"));
-        });
+                    const results = await engine.lintFiles("foo*");
 
-        it("should return false if ignoring is disabled", async () => {
-            const engine = new ESLint({
-                ignore: false,
-                overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
-                cwd: getFixturePath()
+                    // should not lint `foo.json`
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.join(getPath(), "foo.js"));
+                });
             });
 
-            assert(!await engine.isPathIgnored("undef.js"));
         });
 
-        // https://github.com/eslint/eslint/issues/5547
-        it("should return true for default ignores even if ignoring is disabled", async () => {
-            const engine = new ESLint({
-                ignore: false,
-                cwd: getFixturePath("cli-engine")
-            });
+        describe("with ignores config", () => {
+            const root = getFixturePath("cli-engine/ignore-patterns");
 
-            assert(await engine.isPathIgnored("node_modules/foo.js"));
-        });
+            describe("ignores can add an ignore pattern ('foo.js').", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root,
+                    files: {
+                        "eslint.config.js": `module.exports = {
+                            ignores: ["**/foo.js"]
+                        };`,
+                        "foo.js": "",
+                        "bar.js": "",
+                        "subdir/foo.js": "",
+                        "subdir/bar.js": ""
+                    }
+                });
 
-        describe("about the default ignore patterns", () => {
-            it("should always apply default ignore patterns if ignore option is true", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ cwd });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules/package/file.js")));
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "subdir/node_modules/package/file.js")));
-            });
+                it("'isPathIgnored()' should return 'true' for 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should still apply default ignore patterns if ignore option is false", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ ignore: false, cwd });
+                    assert.strictEqual(await engine.isPathIgnored("foo.js"), true);
+                    assert.strictEqual(await engine.isPathIgnored("subdir/foo.js"), true);
+                });
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules/package/file.js")));
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "subdir/node_modules/package/file.js")));
-            });
+                it("'isPathIgnored()' should return 'false' for 'bar.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should allow subfolders of defaultPatterns to be unignored by ignorePattern constructor option", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    cwd,
-                    overrideConfigFile: true,
-                    ignorePatterns: ["!node_modules/", "node_modules/*", "!node_modules/package/"]
+                    assert.strictEqual(await engine.isPathIgnored("bar.js"), false);
+                    assert.strictEqual(await engine.isPathIgnored("subdir/bar.js"), false);
                 });
 
-                const result = await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules", "package", "file.js"));
+                it("'lintFiles()' should not verify 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-                assert(!result, "File should not be ignored");
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(root, "bar.js"),
+                        path.join(root, "eslint.config.js"),
+                        path.join(root, "subdir/bar.js")
+                    ]);
+                });
             });
 
-            it("should allow subfolders of defaultPatterns to be unignored by ignores in overrideConfig", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    cwd,
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        ignores: ["!node_modules/", "node_modules/*", "!node_modules/package/"]
+            describe("ignores can add ignore patterns ('**/foo.js', '/bar.js').", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root + Date.now(),
+                    files: {
+                        "eslint.config.js": `module.exports = {
+                            ignores: ["**/foo.js", "bar.js"]
+                        };`,
+                        "foo.js": "",
+                        "bar.js": "",
+                        "baz.js": "",
+                        "subdir/foo.js": "",
+                        "subdir/bar.js": "",
+                        "subdir/baz.js": ""
                     }
                 });
 
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "node_modules", "package", "file.js")));
-            });
-
-            it("should ignore .git directory", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ cwd });
-
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", ".git/bar")));
-            });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            it("should still ignore .git directory when ignore option disabled", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ ignore: false, cwd });
+                it("'isPathIgnored()' should return 'true' for 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", ".git/bar")));
-            });
+                    assert.strictEqual(await engine.isPathIgnored("foo.js"), true);
+                    assert.strictEqual(await engine.isPathIgnored("subdir/foo.js"), true);
+                });
 
-            it("should not ignore absolute paths containing '..'", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ cwd });
+                it("'isPathIgnored()' should return 'true' for '/bar.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-                assert(!await engine.isPathIgnored(`${getFixturePath("ignored-paths", "foo")}/../unignored.js`));
-            });
+                    assert.strictEqual(await engine.isPathIgnored("bar.js"), true);
+                    assert.strictEqual(await engine.isPathIgnored("subdir/bar.js"), false);
+                });
 
-            it("should ignore /node_modules/ relative to cwd without any configured ignore patterns", async () => {
-                const cwd = getFixturePath("ignored-paths", "no-ignore-file");
-                const engine = new ESLint({ cwd });
+                it("'lintFiles()' should not verify 'foo.js' and '/bar.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "no-ignore-file", "node_modules", "existing.js")));
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "no-ignore-file", "foo", "node_modules", "existing.js")));
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "baz.js"),
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "subdir/bar.js"),
+                        path.join(getPath(), "subdir/baz.js")
+                    ]);
+                });
             });
 
-            it("should not inadvertently ignore all files in parent directories", async () => {
-                const engine = new ESLint({ cwd: getFixturePath("ignored-paths", "no-ignore-file") });
 
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
-            });
-        });
+            describe("ignores can unignore '/node_modules/foo' with patterns ['!node_modules/', 'node_modules/*', '!node_modules/foo/'].", () => {
 
-        describe("with ignorePatterns option", () => {
-            it("should accept a string for options.ignorePatterns", async () => {
-                const cwd = getFixturePath("ignored-paths", "ignore-pattern");
-                const engine = new ESLint({
-                    ignorePatterns: ["ignore-me.txt"],
-                    cwd
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}-unignores`,
+                    files: {
+                        "eslint.config.js": `module.exports = {
+                            ignores: ["!node_modules/", "node_modules/*", "!node_modules/foo/"]
+                        };`,
+                        "node_modules/foo/index.js": "",
+                        "node_modules/foo/.dot.js": "",
+                        "node_modules/bar/index.js": "",
+                        "foo.js": ""
+                    }
                 });
 
-                assert(await engine.isPathIgnored("ignore-me.txt"));
-            });
-
-            it("should accept an array for options.ignorePattern", async () => {
-                const engine = new ESLint({
-                    ignorePatterns: ["a.js", "b.js"],
-                    overrideConfigFile: true
-                });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-                assert(await engine.isPathIgnored("a.js"), "a.js should be ignored");
-                assert(await engine.isPathIgnored("b.js"), "b.js should be ignored");
-                assert(!await engine.isPathIgnored("c.js"), "c.js should not be ignored");
-            });
+                it("'isPathIgnored()' should return 'false' for 'node_modules/foo/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should interpret ignorePatterns as relative to cwd", async () => {
-                const cwd = getFixturePath("ignored-paths", "subdir");
-                const engine = new ESLint({
-                    ignorePatterns: ["undef.js"],
-                    cwd // using ../../eslint.config.js
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/foo/index.js"), false);
                 });
 
-                assert(await engine.isPathIgnored(path.join(cwd, "undef.js")));
-            });
+                it("'isPathIgnored()' should return 'false' for 'node_modules/foo/.dot.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should return true for files which match an ignorePattern even if they do not exist on the filesystem", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    ignorePatterns: ["not-a-file"],
-                    cwd
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/foo/.dot.js"), false);
                 });
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "not-a-file")));
-            });
+                it("'isPathIgnored()' should return 'true' for 'node_modules/bar/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should return true for file matching an ignore pattern exactly", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    ignorePatterns: ["undef.js"],
-                    cwd,
-                    overrideConfigFile: true
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/bar/index.js"), true);
                 });
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
-            });
+                it("'lintFiles()' should verify 'node_modules/foo/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-            it("should return false for file in subfolder of cwd matching an ignore pattern with a base filename", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const filePath = getFixturePath("ignored-paths", "subdir", "undef.js");
-                const engine = new ESLint({
-                    ignorePatterns: ["undef.js"],
-                    overrideConfigFile: true,
-                    cwd
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo.js"),
+                        path.join(getPath(), "node_modules/foo/.dot.js"),
+                        path.join(getPath(), "node_modules/foo/index.js")
+                    ]);
                 });
-
-                assert(!await engine.isPathIgnored(filePath));
             });
 
-            it("should return true for file matching a child of an ignore pattern", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ ignorePatterns: ["ignore-pattern"], cwd });
+            describe("ignores can unignore '/node_modules/foo' with patterns ['!node_modules/', 'node_modules/*', '!node_modules/foo/**'].", () => {
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "ignore-pattern", "ignore-me.txt")));
-            });
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}-unignores`,
+                    files: {
+                        "eslint.config.js": `module.exports = {
+                            ignores: ["!node_modules/", "node_modules/*", "!node_modules/foo/**"]
+                        };`,
+                        "node_modules/foo/index.js": "",
+                        "node_modules/foo/.dot.js": "",
+                        "node_modules/bar/index.js": "",
+                        "foo.js": ""
+                    }
+                });
 
-            it("should return true for file matching a grandchild of a directory when the pattern is directory/**", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ ignorePatterns: ["ignore-pattern/**"], cwd });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "ignore-pattern", "subdir", "ignore-me.js")));
-            });
+                it("'isPathIgnored()' should return 'false' for 'node_modules/foo/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("should return false for file not matching any ignore pattern", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({ ignorePatterns: ["failing.js"], cwd });
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/foo/index.js"), false);
+                });
 
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "unignored.js")));
-            });
+                it("'isPathIgnored()' should return 'false' for 'node_modules/foo/.dot.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            it("two globstar '**' ignore pattern should ignore files in nested directories", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    overrideConfigFile: true,
-                    ignorePatterns: ["**/*.js"],
-                    cwd
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/foo/.dot.js"), false);
                 });
 
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo.js")), "foo.js should be ignored");
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar.js")), "foo/bar.js should be ignored");
-                assert(await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar/baz.js")), "foo/bar/baz.js");
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo.cjs")), "foo.cjs should not be ignored");
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar.cjs")), "foo/bar.cjs should not be ignored");
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "foo/bar/baz.cjs")), "foo/bar/baz.cjs should not be ignored");
-            });
-        });
+                it("'isPathIgnored()' should return 'true' for 'node_modules/bar/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-        describe("with config ignores ignorePatterns option", () => {
-            it("should return false for ignored file when unignored with ignore pattern", async () => {
-                const cwd = getFixturePath("ignored-paths");
-                const engine = new ESLint({
-                    overrideConfigFile: getFixturePath("eslint.config-with-ignores2.js"),
-                    ignorePatterns: ["!undef.js"],
-                    cwd
+                    assert.strictEqual(await engine.isPathIgnored("node_modules/bar/index.js"), true);
                 });
 
-                assert(!await engine.isPathIgnored(getFixturePath("ignored-paths", "undef.js")));
-            });
-        });
+                it("'lintFiles()' should verify 'node_modules/foo/index.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const result = (await engine.lintFiles("**/*.js"));
 
-        it("should throw if non-string value is given to 'filePath' parameter", async () => {
-            const eslint = new ESLint();
+                    const filePaths = result
+                        .map(r => r.filePath)
+                        .sort();
 
-            await assert.rejects(() => eslint.isPathIgnored(null), /'filePath' must be a non-empty string/u);
-        });
-    });
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo.js"),
+                        path.join(getPath(), "node_modules/foo/.dot.js"),
+                        path.join(getPath(), "node_modules/foo/index.js")
+                    ]);
+                });
+            });
 
-    describe("loadFormatter()", () => {
-        it("should return a formatter object when a bundled formatter is requested", async () => {
-            const engine = new ESLint();
-            const formatter = await engine.loadFormatter("json");
+            describe("ignore pattern can re-ignore files that are unignored by a previous pattern.", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}-reignore`,
+                    files: {
+                        "eslint.config.js": `module.exports = ${JSON.stringify({
+                            ignores: ["!.*", ".foo*"]
+                        })}`,
+                        ".foo.js": "",
+                        ".bar.js": ""
+                    }
+                });
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-        it("should return a formatter object when no argument is passed", async () => {
-            const engine = new ESLint();
-            const formatter = await engine.loadFormatter();
+                it("'isPathIgnored()' should return 'true' for re-ignored '.foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                    assert.strictEqual(await engine.isPathIgnored(".foo.js"), true);
+                });
 
-        it("should return a formatter object when a custom formatter is requested", async () => {
-            const engine = new ESLint();
-            const formatter = await engine.loadFormatter(getFixturePath("formatters", "simple.js"));
+                it("'isPathIgnored()' should return 'false' for unignored '.bar.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                    assert.strictEqual(await engine.isPathIgnored(".bar.js"), false);
+                });
 
-        it("should return a formatter object when a custom formatter is requested, also if the path has backslashes", async () => {
-            const engine = new ESLint({
-                cwd: path.join(fixtureDir, "..")
+                it("'lintFiles()' should not lint re-ignored '.foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
+
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), ".bar.js"),
+                        path.join(getPath(), "eslint.config.js")
+                    ]);
+                });
             });
-            const formatter = await engine.loadFormatter(".\\fixtures\\formatters\\simple.js");
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+            describe("ignore pattern can unignore files that are ignored by a previous pattern.", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}-dignore`,
+                    files: {
+                        "eslint.config.js": `module.exports = ${JSON.stringify({
+                            ignores: ["**/*.js", "!foo.js"]
+                        })}`,
+                        "foo.js": "",
+                        "bar.js": ""
+                    }
+                });
 
-        it("should return a formatter object when a formatter prefixed with eslint-formatter is requested", async () => {
-            const engine = new ESLint({
-                cwd: getFixturePath("cli-engine")
-            });
-            const formatter = await engine.loadFormatter("bar");
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                it("'isPathIgnored()' should return 'false' for unignored 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-        it("should return a formatter object when a formatter is requested, also when the eslint-formatter prefix is included in the format argument", async () => {
-            const engine = new ESLint({
-                cwd: getFixturePath("cli-engine")
-            });
-            const formatter = await engine.loadFormatter("eslint-formatter-bar");
+                    assert.strictEqual(await engine.isPathIgnored("foo.js"), false);
+                });
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                it("'isPathIgnored()' should return 'true' for ignored 'bar.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
 
-        it("should return a formatter object when a formatter is requested within a scoped npm package", async () => {
-            const engine = new ESLint({
-                cwd: getFixturePath("cli-engine")
-            });
-            const formatter = await engine.loadFormatter("@somenamespace/foo");
+                    assert.strictEqual(await engine.isPathIgnored("bar.js"), true);
+                });
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+                it("'lintFiles()' should verify unignored 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-        it("should return a formatter object when a formatter is requested within a scoped npm package, also when the eslint-formatter prefix is included in the format argument", async () => {
-            const engine = new ESLint({
-                cwd: getFixturePath("cli-engine")
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "foo.js")
+                    ]);
+                });
             });
-            const formatter = await engine.loadFormatter("@somenamespace/eslint-formatter-foo");
 
-            assert.strictEqual(typeof formatter, "object");
-            assert.strictEqual(typeof formatter.format, "function");
-        });
+            describe("ignores in a config file should not be used if ignore: false.", () => {
 
-        it("should throw if a custom formatter doesn't exist", async () => {
-            const engine = new ESLint();
-            const formatterPath = getFixturePath("formatters", "doesntexist.js");
-            const fullFormatterPath = path.resolve(formatterPath);
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root,
+                    files: {
+                        "eslint.config.js": `module.exports = {
+                            ignores: ["*.js"]
+                        }`,
+                        "foo.js": ""
+                    }
+                });
 
-            await assert.rejects(async () => {
-                await engine.loadFormatter(formatterPath);
-            }, new RegExp(escapeStringRegExp(`There was a problem loading formatter: ${fullFormatterPath}\nError: Cannot find module '${fullFormatterPath}'`), "u"));
-        });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-        it("should throw if a built-in formatter doesn't exist", async () => {
-            const engine = new ESLint();
-            const fullFormatterPath = path.resolve(__dirname, "../../../lib/cli-engine/formatters/special");
+                it("'isPathIgnored()' should return 'false' for 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath(), ignore: false });
 
-            await assert.rejects(async () => {
-                await engine.loadFormatter("special");
-            }, new RegExp(escapeStringRegExp(`There was a problem loading formatter: ${fullFormatterPath}.js\nError: Cannot find module '${fullFormatterPath}.js'`), "u"));
-        });
+                    assert.strictEqual(await engine.isPathIgnored("foo.js"), false);
+                });
 
-        it("should throw if the required formatter exists but has an error", async () => {
-            const engine = new ESLint();
-            const formatterPath = getFixturePath("formatters", "broken.js");
+                it("'lintFiles()' should verify 'foo.js'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath(), ignore: false });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-            await assert.rejects(async () => {
-                await engine.loadFormatter(formatterPath);
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(root, "eslint.config.js"),
+                        path.join(root, "foo.js")
+                    ]);
+                });
+            });
 
-                // for some reason, the error here contains multiple "there was a problem loading formatter" lines, so omitting
-            }, new RegExp(escapeStringRegExp("Error: Cannot find module 'this-module-does-not-exist'"), "u"));
         });
 
-        it("should throw if a non-string formatter name is passed", async () => {
-            const engine = new ESLint();
-
-            await assert.rejects(async () => {
-                await engine.loadFormatter(5);
-            }, /'name' must be a string/u);
-        });
-    });
+        describe("config.files adds lint targets", () => {
+            const root = getFixturePath("cli-engine/additional-lint-targets");
 
-    describe("getErrorResults()", () => {
 
-        it("should report 5 error messages when looking for errors only", async () => {
-            process.chdir(originalDir);
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        quotes: "error",
-                        "no-var": "error",
-                        "eol-last": "error",
-                        "no-unused-vars": "error"
+            describe("if { files: 'foo/*.txt', ignores: '**/ignore.txt' } is present,", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root + 1,
+                    files: {
+                        "eslint.config.js": `module.exports = [{
+                            files: ["foo/*.txt"],
+                            ignores: ["**/ignore.txt"]
+                        }];`,
+                        "foo/nested/test.txt": "",
+                        "foo/test.js": "",
+                        "foo/test.txt": "",
+                        "foo/ignore.txt": "",
+                        "bar/test.js": "",
+                        "bar/test.txt": "",
+                        "bar/ignore.txt": "",
+                        "test.js": "",
+                        "test.txt": "",
+                        "ignore.txt": ""
                     }
-                }
-            });
-            const results = await engine.lintText("var foo = 'bar';");
-            const errorResults = ESLint.getErrorResults(results);
-
-            assert.strictEqual(errorResults[0].messages.length, 4, "messages.length is wrong");
-            assert.strictEqual(errorResults[0].errorCount, 4, "errorCount is wrong");
-            assert.strictEqual(errorResults[0].fixableErrorCount, 3, "fixableErrorCount is wrong");
-            assert.strictEqual(errorResults[0].fixableWarningCount, 0, "fixableWarningCount is wrong");
-            assert.strictEqual(errorResults[0].messages[0].ruleId, "no-var");
-            assert.strictEqual(errorResults[0].messages[0].severity, 2);
-            assert.strictEqual(errorResults[0].messages[1].ruleId, "no-unused-vars");
-            assert.strictEqual(errorResults[0].messages[1].severity, 2);
-            assert.strictEqual(errorResults[0].messages[2].ruleId, "quotes");
-            assert.strictEqual(errorResults[0].messages[2].severity, 2);
-            assert.strictEqual(errorResults[0].messages[3].ruleId, "eol-last");
-            assert.strictEqual(errorResults[0].messages[3].severity, 2);
-        });
+                });
 
-        it("should not mutate passed report parameter", async () => {
-            process.chdir(originalDir);
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { quotes: [1, "double"] }
-                }
-            });
-            const results = await engine.lintText("var foo = 'bar';");
-            const reportResultsLength = results[0].messages.length;
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            ESLint.getErrorResults(results);
+                it("'lintFiles()' with a directory path should contain 'foo/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("."))
+                        .map(r => r.filePath)
+                        .sort();
 
-            assert.strictEqual(results[0].messages.length, reportResultsLength);
-        });
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "bar/test.js"),
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo/test.js"),
+                        path.join(getPath(), "foo/test.txt"),
+                        path.join(getPath(), "test.js")
+                    ]);
+                });
 
-        it("should report a warningCount of 0 when looking for errors only", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        strict: ["error", "global"],
-                        quotes: "error",
-                        "no-var": "error",
-                        "eol-last": "error",
-                        "no-unused-vars": "error"
-                    }
-                }
+                it("'lintFiles()' with a glob pattern '*.js' should not contain 'foo/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
+
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "bar/test.js"),
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo/test.js"),
+                        path.join(getPath(), "test.js")
+                    ]);
+                });
             });
-            const lintResults = await engine.lintText("var foo = 'bar';");
-            const errorResults = ESLint.getErrorResults(lintResults);
 
-            assert.strictEqual(errorResults[0].warningCount, 0);
-            assert.strictEqual(errorResults[0].fixableWarningCount, 0);
-        });
+            describe("if { files: 'foo/*.txt', ignores: '**/ignore.txt' } is present and subdirectory is passed,", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root + 2,
+                    files: {
+                        "eslint.config.js": `module.exports = [{
+                            files: ["foo/*.txt"],
+                            ignores: ["**/ignore.txt"]
+                        }];`,
+                        "foo/nested/test.txt": "",
+                        "foo/test.js": "",
+                        "foo/test.txt": "",
+                        "foo/ignore.txt": "",
+                        "bar/test.js": "",
+                        "bar/test.txt": "",
+                        "bar/ignore.txt": "",
+                        "test.js": "",
+                        "test.txt": "",
+                        "ignore.txt": ""
+                    }
+                });
 
-        it("should return 0 error or warning messages even when the file has warnings", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: getFixturePath("eslint.config-with-ignores.js"),
-                cwd: path.join(fixtureDir, "..")
-            });
-            const options = {
-                filePath: "fixtures/passing.js",
-                warnIgnored: true
-            };
-            const results = await engine.lintText("var bar = foo;", options);
-            const errorReport = ESLint.getErrorResults(results);
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            assert.strictEqual(errorReport.length, 0);
-            assert.strictEqual(results.length, 1);
-            assert.strictEqual(results[0].errorCount, 0);
-            assert.strictEqual(results[0].warningCount, 1);
-        });
+                it("'lintFiles()' with a directory path should contain 'foo/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("foo"))
+                        .map(r => r.filePath)
+                        .sort();
 
-        it("should return source code of file in the `source` property", async () => {
-            process.chdir(originalDir);
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: { quotes: [2, "double"] }
-                }
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "foo/test.js"),
+                        path.join(getPath(), "foo/test.txt")
+                    ]);
+                });
+
+                it("'lintFiles()' with a glob pattern '*.js' should not contain 'foo/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("foo/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
+
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "foo/test.js")
+                    ]);
+                });
             });
-            const results = await engine.lintText("var foo = 'bar';");
-            const errorResults = ESLint.getErrorResults(results);
 
-            assert.strictEqual(errorResults[0].messages.length, 1);
-            assert.strictEqual(errorResults[0].source, "var foo = 'bar';");
-        });
+            describe("if { files: 'foo/**/*.txt' } is present,", () => {
 
-        it("should contain `output` property after fixes", async () => {
-            process.chdir(originalDir);
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                fix: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2,
-                        "no-console": 2
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root + 3,
+                    files: {
+                        "eslint.config.js": `module.exports = [
+                            {
+                                files: ["foo/**/*.txt"]
+                            }
+                        ]`,
+                        "foo/nested/test.txt": "",
+                        "foo/test.js": "",
+                        "foo/test.txt": "",
+                        "bar/test.js": "",
+                        "bar/test.txt": "",
+                        "test.js": "",
+                        "test.txt": ""
                     }
-                }
-            });
-            const results = await engine.lintText("console.log('foo')");
-            const errorResults = ESLint.getErrorResults(results);
+                });
 
-            assert.strictEqual(errorResults[0].messages.length, 1);
-            assert.strictEqual(errorResults[0].output, "console.log('foo');");
-        });
-    });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-    describe("findConfigFile()", () => {
+                it("'lintFiles()' with a directory path should contain 'foo/test.txt' and 'foo/nested/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("."))
+                        .map(r => r.filePath)
+                        .sort();
 
-        it("should return undefined when overrideConfigFile is true", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "bar/test.js"),
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo/nested/test.txt"),
+                        path.join(getPath(), "foo/test.js"),
+                        path.join(getPath(), "foo/test.txt"),
+                        path.join(getPath(), "test.js")
+                    ]);
+                });
             });
 
-            assert.strictEqual(await engine.findConfigFile(), void 0);
-        });
+            describe("if { files: 'foo/**/*' } is present,", () => {
 
-        it("should return undefined when a config file isn't found", async () => {
-            const engine = new ESLint({
-                cwd: path.resolve(__dirname, "../../../../")
-            });
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: root + 4,
+                    files: {
+                        "eslint.config.js": `module.exports = [
+                            {
+                                files: ["foo/**/*"]
+                            }
+                        ]`,
+                        "foo/nested/test.txt": "",
+                        "foo/test.js": "",
+                        "foo/test.txt": "",
+                        "bar/test.js": "",
+                        "bar/test.txt": "",
+                        "test.js": "",
+                        "test.txt": ""
+                    }
+                });
+
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            assert.strictEqual(await engine.findConfigFile(), void 0);
-        });
+                it("'lintFiles()' with a directory path should NOT contain 'foo/test.txt' and 'foo/nested/test.txt'.", async () => {
+                    const engine = new ESLint({ flags, cwd: getPath() });
+                    const filePaths = (await engine.lintFiles("."))
+                        .map(r => r.filePath)
+                        .sort();
 
-        it("should return custom config file path when overrideConfigFile is a nonempty string", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: "my-config.js"
+                    assert.deepStrictEqual(filePaths, [
+                        path.join(getPath(), "bar/test.js"),
+                        path.join(getPath(), "eslint.config.js"),
+                        path.join(getPath(), "foo/test.js"),
+                        path.join(getPath(), "test.js")
+                    ]);
+                });
             });
-            const configFilePath = path.resolve(__dirname, "../../../my-config.js");
 
-            assert.strictEqual(await engine.findConfigFile(), configFilePath);
         });
 
-        it("should return root level eslint.config.js when overrideConfigFile is null", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: null
-            });
-            const configFilePath = path.resolve(__dirname, "../../../eslint.config.js");
+        describe("'ignores', 'files' of the configuration that the '--config' option provided should be resolved from CWD.", () => {
+            const root = getFixturePath("cli-engine/config-and-overrides-files");
 
-            assert.strictEqual(await engine.findConfigFile(), configFilePath);
-        });
+            describe("if { files: 'foo/*.txt', ... } is present by '--config node_modules/myconf/eslint.config.js',", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}a1`,
+                    files: {
+                        "node_modules/myconf/eslint.config.js": `module.exports = [
+                            {
+                                files: ["foo/*.js"],
+                                rules: {
+                                    eqeqeq: "error"
+                                }
+                            }
+                        ];`,
+                        "node_modules/myconf/foo/test.js": "a == b",
+                        "foo/test.js": "a == b"
+                    }
+                });
 
-        it("should return root level eslint.config.js when overrideConfigFile is not specified", async () => {
-            const engine = new ESLint();
-            const configFilePath = path.resolve(__dirname, "../../../eslint.config.js");
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            assert.strictEqual(await engine.findConfigFile(), configFilePath);
-        });
+                it("'lintFiles()' with 'foo/test.js' should use the files entry.", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: "node_modules/myconf/eslint.config.js",
+                        cwd: getPath(),
+                        ignore: false
+                    });
+                    const results = await engine.lintFiles("foo/test.js");
 
-    });
+                    // Expected to be an 'eqeqeq' error because the file matches to `$CWD/foo/*.js`.
+                    assert.deepStrictEqual(results, [
+                        {
+                            suppressedMessages: [],
+                            errorCount: 1,
+                            filePath: path.join(getPath(), "foo/test.js"),
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            messages: [
+                                {
+                                    column: 3,
+                                    endColumn: 5,
+                                    endLine: 1,
+                                    line: 1,
+                                    message: "Expected '===' and instead saw '=='.",
+                                    messageId: "unexpected",
+                                    nodeType: "BinaryExpression",
+                                    ruleId: "eqeqeq",
+                                    severity: 2
+                                }
+                            ],
+                            source: "a == b",
+                            usedDeprecatedRules: [],
+                            warningCount: 0,
+                            fatalErrorCount: 0
+                        }
+                    ]);
+                });
 
-    describe("Use stats option", () => {
+                it("'lintFiles()' with 'node_modules/myconf/foo/test.js' should NOT use the files entry.", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: "node_modules/myconf/eslint.config.js",
+                        cwd: getPath(),
+                        ignore: false
+                    });
+                    const results = await engine.lintFiles("node_modules/myconf/foo/test.js");
 
-        /**
-         * Check if the given number is a number.
-         * @param {number} n The number to check.
-         * @returns {boolean} `true` if the number is a number, `false` otherwise.
-         */
-        function isNumber(n) {
-            return typeof n === "number" && !Number.isNaN(n);
-        }
+                    // Expected to be no errors because the file doesn't match to `$CWD/foo/*.js`.
+                    assert.deepStrictEqual(results, [
+                        {
+                            suppressedMessages: [],
+                            errorCount: 0,
+                            filePath: path.join(getPath(), "node_modules/myconf/foo/test.js"),
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            messages: [
+                                {
+                                    ruleId: null,
+                                    fatal: false,
+                                    message: "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.",
+                                    severity: 1,
+                                    nodeType: null
+                                }
+                            ],
+                            usedDeprecatedRules: [],
+                            warningCount: 1,
+                            fatalErrorCount: 0
+                        }
+                    ]);
+                });
+            });
 
-        it("should report stats", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        "no-regex-spaces": "error"
+            describe("if { files: '*', ignores: 'foo/*.txt', ... } is present by '--config bar/myconf/eslint.config.js',", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}a2`,
+                    files: {
+                        "bar/myconf/eslint.config.js": `module.exports = [
+                            {
+                                files: ["**/*"],
+                                ignores: ["foo/*.js"],
+                                rules: {
+                                    eqeqeq: "error"
+                                }
+                            }
+                        ]`,
+                        "bar/myconf/foo/test.js": "a == b",
+                        "foo/test.js": "a == b"
                     }
-                },
-                cwd: getFixturePath("stats-example"),
-                stats: true
-            });
-            const results = await engine.lintFiles(["file-to-fix.js"]);
-
-            assert.strictEqual(results[0].stats.fixPasses, 0);
-            assert.strictEqual(results[0].stats.times.passes.length, 1);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].parse.total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["no-regex-spaces"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["wrap-regex"].total), true);
-            assert.strictEqual(results[0].stats.times.passes[0].fix.total, 0);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].total), true);
-        });
+                });
 
-        it("should report stats with fix", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        "no-regex-spaces": "error"
-                    }
-                },
-                cwd: getFixturePath("stats-example"),
-                fix: true,
-                stats: true
-            });
-            const results = await engine.lintFiles(["file-to-fix.js"]);
-
-            assert.strictEqual(results[0].stats.fixPasses, 2);
-            assert.strictEqual(results[0].stats.times.passes.length, 3);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].parse.total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[1].parse.total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[2].parse.total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["no-regex-spaces"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].rules["wrap-regex"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[1].rules["no-regex-spaces"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[1].rules["wrap-regex"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[2].rules["no-regex-spaces"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[2].rules["wrap-regex"].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].fix.total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[1].fix.total), true);
-            assert.strictEqual(results[0].stats.times.passes[2].fix.total, 0);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[0].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[1].total), true);
-            assert.strictEqual(isNumber(results[0].stats.times.passes[2].total), true);
-        });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-    });
+                it("'lintFiles()' with 'foo/test.js' should have no errors because no rules are enabled.", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: "bar/myconf/eslint.config.js",
+                        cwd: getPath(),
+                        ignore: false
+                    });
+                    const results = await engine.lintFiles("foo/test.js");
+
+                    // Expected to be no errors because the file matches to `$CWD/foo/*.js`.
+                    assert.deepStrictEqual(results, [
+                        {
+                            suppressedMessages: [],
+                            errorCount: 0,
+                            filePath: path.join(getPath(), "foo/test.js"),
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            messages: [],
+                            usedDeprecatedRules: [],
+                            warningCount: 0,
+                            fatalErrorCount: 0
+                        }
+                    ]);
+                });
 
-    describe("getRulesMetaForResults()", () => {
+                it("'lintFiles()' with 'bar/myconf/foo/test.js' should have an error because eqeqeq is enabled.", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: "bar/myconf/eslint.config.js",
+                        cwd: getPath(),
+                        ignore: false
+                    });
+                    const results = await engine.lintFiles("bar/myconf/foo/test.js");
 
-        it("should throw an error when this instance did not lint any files", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true
+                    // Expected to be an 'eqeqeq' error because the file doesn't match to `$CWD/foo/*.js`.
+                    assert.deepStrictEqual(results, [
+                        {
+                            suppressedMessages: [],
+                            errorCount: 1,
+                            filePath: path.join(getPath(), "bar/myconf/foo/test.js"),
+                            fixableErrorCount: 0,
+                            fixableWarningCount: 0,
+                            messages: [
+                                {
+                                    column: 3,
+                                    endColumn: 5,
+                                    endLine: 1,
+                                    line: 1,
+                                    message: "Expected '===' and instead saw '=='.",
+                                    messageId: "unexpected",
+                                    nodeType: "BinaryExpression",
+                                    ruleId: "eqeqeq",
+                                    severity: 2
+                                }
+                            ],
+                            source: "a == b",
+                            usedDeprecatedRules: [],
+                            warningCount: 0,
+                            fatalErrorCount: 0
+                        }
+                    ]);
+                });
             });
 
-            assert.throws(() => {
-                engine.getRulesMetaForResults([
-                    {
-                        filePath: "path/to/file.js",
-                        messages: [
-                            {
-                                ruleId: "curly",
-                                severity: 2,
-                                message: "Expected { after 'if' condition.",
-                                line: 2,
-                                column: 1,
-                                nodeType: "IfStatement"
-                            },
-                            {
-                                ruleId: "no-process-exit",
-                                severity: 2,
-                                message: "Don't use process.exit(); throw an error instead.",
-                                line: 3,
-                                column: 1,
-                                nodeType: "CallExpression"
+            describe("if { ignores: 'foo/*.js', ... } is present by '--config node_modules/myconf/eslint.config.js',", () => {
+                const { prepare, cleanup, getPath } = createCustomTeardown({
+                    cwd: `${root}a3`,
+                    files: {
+                        "node_modules/myconf/eslint.config.js": `module.exports = [{
+                            ignores: ["!node_modules", "node_modules/*", "!node_modules/myconf", "foo/*.js"],
+                        }, {
+                            rules: {
+                                eqeqeq: "error"
                             }
-                        ],
-                        suppressedMessages: [],
-                        errorCount: 2,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        source:
-                            "var err = doStuff();\nif (err) console.log('failed tests: ' + err);\nprocess.exit(1);\n"
+                        }]`,
+                        "node_modules/myconf/foo/test.js": "a == b",
+                        "foo/test.js": "a == b"
                     }
-                ]);
-            }, {
-                constructor: TypeError,
-                message: "Results object was not created from this ESLint instance."
-            });
-        });
+                });
 
-        it("should throw an error when results were created from a different instance", async () => {
-            const engine1 = new ESLint({
-                overrideConfigFile: true,
-                cwd: path.join(fixtureDir, "foo"),
-                overrideConfig: {
-                    rules: {
-                        semi: 2
-                    }
-                }
-            });
-            const engine2 = new ESLint({
-                overrideConfigFile: true,
-                cwd: path.join(fixtureDir, "bar"),
-                overrideConfig: {
-                    rules: {
-                        semi: 2
-                    }
-                }
-            });
+                beforeEach(prepare);
+                afterEach(cleanup);
 
-            const results1 = await engine1.lintText("1", { filePath: "file.js" });
-            const results2 = await engine2.lintText("2", { filePath: "file.js" });
+                it("'lintFiles()' with '**/*.js' should lint 'node_modules/myconf/foo/test.js' but not 'foo/test.js'.", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        overrideConfigFile: "node_modules/myconf/eslint.config.js",
+                        cwd: getPath()
+                    });
+                    const files = (await engine.lintFiles("**/*.js"))
+                        .map(r => r.filePath)
+                        .sort();
 
-            engine1.getRulesMetaForResults(results1); // should not throw an error
-            assert.throws(() => {
-                engine1.getRulesMetaForResults(results2);
-            }, {
-                constructor: TypeError,
-                message: "Results object was not created from this ESLint instance."
+                    assert.deepStrictEqual(files, [
+                        path.join(getPath(), "node_modules/myconf/eslint.config.js"),
+                        path.join(getPath(), "node_modules/myconf/foo/test.js")
+                    ]);
+                });
             });
         });
 
-        it("should treat a result without `filePath` as if the file was located in `cwd`", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                cwd: path.join(fixtureDir, "foo", "bar"),
-                ignorePatterns: ["*/**"], // ignore all subdirectories of `cwd`
-                overrideConfig: {
-                    rules: {
-                        eqeqeq: "warn"
+        describe("baseConfig", () => {
+            it("can be an object", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    baseConfig: {
+                        rules: {
+                            semi: 2
+                        }
                     }
-                }
+                });
+
+                const [{ messages }] = await eslint.lintText("foo");
+
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
             });
 
-            const results = await engine.lintText("a==b");
-            const rulesMeta = engine.getRulesMetaForResults(results);
+            it("can be an array", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    baseConfig: [
+                        {
+                            rules: {
+                                "no-var": 2
+                            }
+                        },
+                        {
+                            rules: {
+                                semi: 2
+                            }
+                        }
+                    ]
+                });
 
-            assert.deepStrictEqual(rulesMeta.eqeqeq, coreRules.get("eqeqeq").meta);
-        });
+                const [{ messages }] = await eslint.lintText("var foo");
 
-        it("should not throw an error if a result without `filePath` contains an ignored file warning", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                cwd: path.join(fixtureDir, "foo", "bar"),
-                ignorePatterns: ["**"]
+                assert.strictEqual(messages.length, 2);
+                assert.strictEqual(messages[0].ruleId, "no-var");
+                assert.strictEqual(messages[1].ruleId, "semi");
             });
 
-            const results = await engine.lintText("", { warnIgnored: true });
-            const rulesMeta = engine.getRulesMetaForResults(results);
+            it("should be inserted after default configs", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    baseConfig: {
+                        languageOptions: {
+                            ecmaVersion: 5,
+                            sourceType: "script"
+                        }
+                    }
+                });
+
+                const [{ messages }] = await eslint.lintText("let x");
 
-            assert.deepStrictEqual(rulesMeta, {});
-        });
+                /*
+                 * if baseConfig was inserted before default configs,
+                 * `ecmaVersion: "latest"` from default configs would overwrite
+                 * `ecmaVersion: 5` from baseConfig, so this wouldn't be a parsing error.
+                 */
 
-        it("should not throw an error if results contain linted files and one ignored file", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                cwd: getFixturePath(),
-                ignorePatterns: ["passing*"],
-                overrideConfig: {
-                    rules: {
-                        "no-undef": 2,
-                        semi: 1
-                    }
-                }
+                assert.strictEqual(messages.length, 1);
+                assert(messages[0].fatal, "Fatal error expected.");
             });
 
-            const results = await engine.lintFiles(["missing-semicolon.js", "passing.js", "undef.js"]);
-
-            assert(
-                results.some(({ messages }) => messages.some(({ message, ruleId }) => !ruleId && message.startsWith("File ignored"))),
-                "At least one file should be ignored but none is."
-            );
+            it("should be inserted before configs from the config file", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath(),
+                    baseConfig: {
+                        rules: {
+                            strict: ["error", "global"]
+                        },
+                        languageOptions: {
+                            sourceType: "script"
+                        }
+                    }
+                });
 
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                const [{ messages }] = await eslint.lintText("foo");
 
-            assert.deepStrictEqual(rulesMeta["no-undef"], coreRules.get("no-undef").meta);
-            assert.deepStrictEqual(rulesMeta.semi, coreRules.get("semi").meta);
-        });
+                /*
+                 * if baseConfig was inserted after configs from the config file,
+                 * `strict: 0` from eslint.config.js wouldn't overwrite `strict: ["error", "global"]`
+                 * from baseConfig, so there would be an error message from the `strict` rule.
+                 */
 
-        it("should return empty object when there are no linting errors", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true
+                assert.strictEqual(messages.length, 0);
             });
 
-            const rulesMeta = engine.getRulesMetaForResults([]);
+            it("should be inserted before overrideConfig", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    baseConfig: {
+                        rules: {
+                            semi: 2
+                        }
+                    },
+                    overrideConfig: {
+                        rules: {
+                            semi: 1
+                        }
+                    }
+                });
+
+                const [{ messages }] = await eslint.lintText("foo");
 
-            assert.deepStrictEqual(rulesMeta, {});
-        });
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].severity, 1);
+            });
 
-        it("should return one rule meta when there is a linting error", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2
+            it("should be inserted before configs from the config file and overrideConfig", async () => {
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: getFixturePath("eslint.config-with-rules.js"),
+                    baseConfig: {
+                        rules: {
+                            quotes: ["error", "double"],
+                            semi: "error"
+                        }
+                    },
+                    overrideConfig: {
+                        rules: {
+                            quotes: "warn"
+                        }
                     }
-                }
-            });
+                });
 
-            const results = await engine.lintText("a", { filePath: "foo.js" });
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                const [{ messages }] = await eslint.lintText("const foo = \"bar\"");
 
-            assert.strictEqual(Object.keys(rulesMeta).length, 1);
-            assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
-        });
+                /*
+                 * baseConfig: { quotes: ["error", "double"], semi: "error" }
+                 * eslint.config-with-rules.js: { quotes: ["error", "single"] }
+                 * overrideConfig: { quotes: "warn" }
+                 *
+                 * Merged config: { quotes: ["warn", "single"], semi: "error" }
+                 */
 
-        it("should return one rule meta when there is a suppressed linting error", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2
-                    }
-                }
+                assert.strictEqual(messages.length, 2);
+                assert.strictEqual(messages[0].ruleId, "quotes");
+                assert.strictEqual(messages[0].severity, 1);
+                assert.strictEqual(messages[1].ruleId, "semi");
+                assert.strictEqual(messages[1].severity, 2);
             });
 
-            const results = await engine.lintText("a // eslint-disable-line semi");
-            const rulesMeta = engine.getRulesMetaForResults(results);
-
-            assert.strictEqual(Object.keys(rulesMeta).length, 1);
-            assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
-        });
+            it("when it has 'files' they should be interpreted as relative to the config file", async () => {
 
-        it("should return multiple rule meta when there are multiple linting errors", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    rules: {
-                        semi: 2,
-                        quotes: [2, "double"]
+                /*
+                 * `fixtures/plugins` directory does not have a config file.
+                 * It's parent directory `fixtures` does have a config file, so
+                 * the base path will be `fixtures`, cwd will be `fixtures/plugins`
+                 */
+                const eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath("plugins"),
+                    baseConfig: {
+                        files: ["plugins/a.js"],
+                        rules: {
+                            semi: 2
+                        }
                     }
-                }
-            });
+                });
 
-            const results = await engine.lintText("'a'");
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                const [{ messages }] = await eslint.lintText("foo", { filePath: getFixturePath("plugins/a.js") });
 
-            assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
-            assert.strictEqual(rulesMeta.quotes, coreRules.get("quotes").meta);
-        });
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+            });
 
-        it("should return multiple rule meta when there are multiple linting errors from a plugin", async () => {
-            const customPlugin = {
-                rules: {
-                    "no-var": require("../../../lib/rules/no-var")
-                }
-            };
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: {
-                    plugins: {
-                        "custom-plugin": customPlugin
-                    },
-                    rules: {
-                        "custom-plugin/no-var": 2,
-                        semi: 2,
-                        quotes: [2, "double"]
+            it("when it has 'ignores' they should be interpreted as relative to the config file", async () => {
+
+                /*
+                 * `fixtures/plugins` directory does not have a config file.
+                 * It's parent directory `fixtures` does have a config file, so
+                 * the base path will be `fixtures`, cwd will be `fixtures/plugins`
+                 */
+                const eslint = new ESLint({
+                    flags,
+                    cwd: getFixturePath("plugins"),
+                    baseConfig: {
+                        ignores: ["plugins/a.js"]
                     }
-                }
-            });
+                });
 
-            const results = await engine.lintText("var foo = 0; var bar = '1'");
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                const [{ messages }] = await eslint.lintText("foo", { filePath: getFixturePath("plugins/a.js"), warnIgnored: true });
 
-            assert.strictEqual(rulesMeta.semi, coreRules.get("semi").meta);
-            assert.strictEqual(rulesMeta.quotes, coreRules.get("quotes").meta);
-            assert.strictEqual(
-                rulesMeta["custom-plugin/no-var"],
-                customPlugin.rules["no-var"].meta
-            );
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].severity, 1);
+                assert.match(messages[0].message, /ignored/u);
+            });
         });
 
-        it("should ignore messages not related to a rule", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                ignorePatterns: ["ignored.js"],
-                overrideConfig: {
-                    rules: {
-                        "no-var": "warn"
-                    },
-                    linterOptions: {
-                        reportUnusedDisableDirectives: "warn"
+        describe("config file", () => {
+
+            it("new instance of ESLint should use the latest version of the config file (ESM)", async () => {
+                const cwd = path.join(getFixturePath(), `config_file_${Date.now()}`);
+                const configFileContent = "export default [{ rules: { semi: ['error', 'always'] } }];";
+                const teardown = createCustomTeardown({
+                    cwd,
+                    files: {
+                        "package.json": "{ \"type\": \"module\" }",
+                        "eslint.config.js": configFileContent,
+                        "a.js": "foo\nbar;"
                     }
-                }
-            });
+                });
 
-            {
-                const results = await engine.lintText("syntax error");
-                const rulesMeta = engine.getRulesMetaForResults(results);
+                await teardown.prepare();
 
-                assert.deepStrictEqual(rulesMeta, {});
-            }
-            {
-                const results = await engine.lintText("// eslint-disable-line no-var");
-                const rulesMeta = engine.getRulesMetaForResults(results);
+                let eslint = new ESLint({ flags, cwd });
+                let [{ messages }] = await eslint.lintFiles(["a.js"]);
 
-                assert.deepStrictEqual(rulesMeta, {});
-            }
-            {
-                const results = await engine.lintText("", { filePath: "ignored.js", warnIgnored: true });
-                const rulesMeta = engine.getRulesMetaForResults(results);
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "missingSemi");
+                assert.strictEqual(messages[0].line, 1);
 
-                assert.deepStrictEqual(rulesMeta, {});
-            }
-        });
+                await sleep(100);
+                await fsp.writeFile(path.join(cwd, "eslint.config.js"), configFileContent.replace("always", "never"));
 
-        it("should return a non-empty value if some of the messages are related to a rule", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: { rules: { "no-var": "warn" }, linterOptions: { reportUnusedDisableDirectives: "warn" } }
+                eslint = new ESLint({ flags, cwd });
+                [{ messages }] = await eslint.lintFiles(["a.js"]);
+
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "extraSemi");
+                assert.strictEqual(messages[0].line, 2);
             });
 
-            const results = await engine.lintText("// eslint-disable-line no-var\nvar foo;");
-            const rulesMeta = engine.getRulesMetaForResults(results);
+            it("new instance of ESLint should use the latest version of the config file (CJS)", async () => {
+                const cwd = path.join(getFixturePath(), `config_file_${Date.now()}`);
+                const configFileContent = "module.exports = [{ rules: { semi: ['error', 'always'] } }];";
+                const teardown = createCustomTeardown({
+                    cwd,
+                    files: {
+                        "eslint.config.js": configFileContent,
+                        "a.js": "foo\nbar;"
+                    }
+                });
+
+                await teardown.prepare();
 
-            assert.deepStrictEqual(rulesMeta, { "no-var": coreRules.get("no-var").meta });
-        });
+                let eslint = new ESLint({ flags, cwd });
+                let [{ messages }] = await eslint.lintFiles(["a.js"]);
 
-        it("should return empty object if all messages are related to unknown rules", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true
-            });
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "missingSemi");
+                assert.strictEqual(messages[0].line, 1);
 
-            const results = await engine.lintText("// eslint-disable-line foo, bar/baz, bar/baz/qux");
+                await sleep(100);
+                await fsp.writeFile(path.join(cwd, "eslint.config.js"), configFileContent.replace("always", "never"));
 
-            assert.strictEqual(results[0].messages.length, 3);
-            assert.strictEqual(results[0].messages[0].ruleId, "foo");
-            assert.strictEqual(results[0].messages[1].ruleId, "bar/baz");
-            assert.strictEqual(results[0].messages[2].ruleId, "bar/baz/qux");
+                eslint = new ESLint({ flags, cwd });
+                [{ messages }] = await eslint.lintFiles(["a.js"]);
 
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "extraSemi");
+                assert.strictEqual(messages[0].line, 2);
+            });
 
-            assert.strictEqual(Object.keys(rulesMeta).length, 0);
-        });
+            it("new instance of ESLint should use the latest version of the config file (TypeScript)", async () => {
+                const cwd = getFixturePath(`config_file_${Date.now()}`);
+                const configFileContent = "export default [{ rules: { semi: ['error', 'always'] } }];";
+                const teardown = createCustomTeardown({
+                    cwd,
+                    files: {
+                        "eslint.config.ts": configFileContent,
+                        "a.js": "foo\nbar;"
+                    }
+                });
 
-        it("should return object with meta of known rules if some messages are related to unknown rules", async () => {
-            const engine = new ESLint({
-                overrideConfigFile: true,
-                overrideConfig: { rules: { "no-var": "warn" } }
-            });
+                await teardown.prepare();
 
-            const results = await engine.lintText("// eslint-disable-line foo, bar/baz, bar/baz/qux\nvar x;");
+                let eslint = new ESLint({ cwd, flags: ["unstable_ts_config"] });
+                let [{ messages }] = await eslint.lintFiles(["a.js"]);
 
-            assert.strictEqual(results[0].messages.length, 4);
-            assert.strictEqual(results[0].messages[0].ruleId, "foo");
-            assert.strictEqual(results[0].messages[1].ruleId, "bar/baz");
-            assert.strictEqual(results[0].messages[2].ruleId, "bar/baz/qux");
-            assert.strictEqual(results[0].messages[3].ruleId, "no-var");
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "missingSemi");
+                assert.strictEqual(messages[0].line, 1);
 
-            const rulesMeta = engine.getRulesMetaForResults(results);
+                await sleep(100);
+                await fsp.writeFile(path.join(cwd, "eslint.config.ts"), configFileContent.replace("always", "never"));
 
-            assert.deepStrictEqual(rulesMeta, { "no-var": coreRules.get("no-var").meta });
-        });
-    });
+                eslint = new ESLint({ cwd, flags: ["unstable_ts_config"] });
+                [{ messages }] = await eslint.lintFiles(["a.js"]);
 
-    describe("outputFixes()", () => {
-        afterEach(() => {
-            sinon.verifyAndRestore();
+                assert.strictEqual(messages.length, 1);
+                assert.strictEqual(messages[0].ruleId, "semi");
+                assert.strictEqual(messages[0].messageId, "extraSemi");
+                assert.strictEqual(messages[0].line, 2);
+            });
         });
 
-        it("should call fs.writeFile() for each result with output", async () => {
-            const spy = sinon.spy(() => Promise.resolve());
-            const { ESLint: localESLint } = proxyquire("../../../lib/eslint/eslint", {
-                "node:fs/promises": {
-                    writeFile: spy
-                }
-            });
+        // only works on a Windows machine
+        if (os.platform() === "win32") {
 
-            const results = [
-                {
-                    filePath: path.resolve("foo.js"),
-                    output: "bar"
-                },
-                {
-                    filePath: path.resolve("bar.js"),
-                    output: "baz"
-                }
-            ];
+            // https://github.com/eslint/eslint/issues/17042
+            describe("with cwd that is using forward slash on Windows", () => {
+                const cwd = getFixturePath("example-app3");
+                const cwdForwardSlash = cwd.replace(/\\/gu, "/");
 
-            await localESLint.outputFixes(results);
+                it("should correctly handle ignore patterns", async () => {
+                    const engine = new ESLint({ flags, cwd: cwdForwardSlash });
+                    const results = await engine.lintFiles(["./src"]);
 
-            assert.strictEqual(spy.callCount, 2);
-            assert(spy.firstCall.calledWithExactly(path.resolve("foo.js"), "bar"), "First call was incorrect.");
-            assert(spy.secondCall.calledWithExactly(path.resolve("bar.js"), "baz"), "Second call was incorrect.");
-        });
+                    // src/dist/2.js should be ignored
+                    assert.strictEqual(results.length, 1);
+                    assert.strictEqual(results[0].filePath, path.join(cwd, "src\\1.js"));
+                });
 
-        it("should call fs.writeFile() for each result with output and not at all for a result without output", async () => {
-            const spy = sinon.spy(() => Promise.resolve());
-            const { ESLint: localESLint } = proxyquire("../../../lib/eslint/eslint", {
-                "node:fs/promises": {
-                    writeFile: spy
-                }
-            });
+                it("should pass cwd with backslashes to rules", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        cwd: cwdForwardSlash,
+                        overrideConfigFile: true,
+                        overrideConfig: {
+                            plugins: {
+                                test: require(path.join(cwd, "node_modules", "eslint-plugin-test"))
+                            },
+                            rules: {
+                                "test/report-cwd": "error"
+                            }
+                        }
+                    });
+                    const results = await engine.lintText("");
 
-            const results = [
-                {
-                    filePath: path.resolve("foo.js"),
-                    output: "bar"
-                },
-                {
-                    filePath: path.resolve("abc.js")
-                },
-                {
-                    filePath: path.resolve("bar.js"),
-                    output: "baz"
-                }
-            ];
+                    assert.strictEqual(results[0].messages[0].ruleId, "test/report-cwd");
+                    assert.strictEqual(results[0].messages[0].message, cwd);
+                });
 
-            await localESLint.outputFixes(results);
+                it("should pass cwd with backslashes to formatters", async () => {
+                    const engine = new ESLint({
+                        flags,
+                        cwd: cwdForwardSlash
+                    });
+                    const results = await engine.lintText("");
+                    const formatter = await engine.loadFormatter("cwd");
 
-            assert.strictEqual(spy.callCount, 2, "Call count was wrong");
-            assert(spy.firstCall.calledWithExactly(path.resolve("foo.js"), "bar"), "First call was incorrect.");
-            assert(spy.secondCall.calledWithExactly(path.resolve("bar.js"), "baz"), "Second call was incorrect.");
-        });
+                    assert.strictEqual(formatter.format(results), cwd);
+                });
+            });
+        }
 
-        it("should throw if non object array is given to 'results' parameter", async () => {
-            await assert.rejects(() => ESLint.outputFixes(null), /'results' must be an array/u);
-            await assert.rejects(() => ESLint.outputFixes([null]), /'results' must include only objects/u);
-        });
-    });
+        describe("config with circular references", () => {
+            it("in 'settings'", async () => {
+                let resolvedSettings = null;
 
-    describe("when evaluating code with comments to change config when allowInlineConfig is disabled", () => {
-        it("should report a violation for disabling rules", async () => {
-            const code = [
-                "alert('test'); // eslint-disable-line no-alert"
-            ].join("\n");
-            const config = {
-                ignore: true,
-                overrideConfigFile: true,
-                allowInlineConfig: false,
-                overrideConfig: {
-                    rules: {
-                        "eol-last": 0,
-                        "no-alert": 1,
-                        "no-trailing-spaces": 0,
-                        strict: 0,
-                        quotes: 0
-                    }
-                }
-            };
-            const eslintCLI = new ESLint(config);
-            const results = await eslintCLI.lintText(code);
-            const messages = results[0].messages;
+                const circular = {};
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "no-alert");
-            assert.strictEqual(results[0].suppressedMessages.length, 0);
-        });
+                circular.self = circular;
 
-        it("should not report a violation by default", async () => {
-            const code = [
-                "alert('test'); // eslint-disable-line no-alert"
-            ].join("\n");
-            const config = {
-                ignore: true,
-                overrideConfigFile: true,
-                allowInlineConfig: true,
-                overrideConfig: {
-                    rules: {
-                        "eol-last": 0,
-                        "no-alert": 1,
-                        "no-trailing-spaces": 0,
-                        strict: 0,
-                        quotes: 0
+                const eslint = new ESLint({
+                    flags,
+                    overrideConfigFile: true,
+                    baseConfig: {
+                        settings: {
+                            sharedData: circular
+                        },
+                        rules: {
+                            "test-plugin/test-rule": 1
+                        }
+                    },
+                    plugins: {
+                        "test-plugin": {
+                            rules: {
+                                "test-rule": {
+                                    create(context) {
+                                        resolvedSettings = context.settings;
+                                        return {};
+                                    }
+                                }
+                            }
+                        }
                     }
-                }
-            };
-            const eslintCLI = new ESLint(config);
-            const results = await eslintCLI.lintText(code);
-            const messages = results[0].messages;
-
-            assert.strictEqual(messages.length, 0);
-            assert.strictEqual(results[0].suppressedMessages.length, 1);
-            assert.strictEqual(results[0].suppressedMessages[0].ruleId, "no-alert");
-        });
-    });
+                });
 
-    describe("when evaluating code when reportUnusedDisableDirectives is enabled", () => {
-        it("should report problems for unused eslint-disable directives", async () => {
-            const eslint = new ESLint({ overrideConfigFile: true, overrideConfig: { linterOptions: { reportUnusedDisableDirectives: "error" } } });
+                await eslint.lintText("debugger;");
 
-            assert.deepStrictEqual(
-                await eslint.lintText("/* eslint-disable */"),
-                [
-                    {
-                        filePath: "<text>",
-                        messages: [
-                            {
-                                ruleId: null,
-                                message: "Unused eslint-disable directive (no problems were reported).",
-                                line: 1,
-                                column: 1,
-                                fix: {
-                                    range: [0, 20],
-                                    text: " "
-                                },
-                                severity: 2,
-                                nodeType: null
-                            }
-                        ],
-                        suppressedMessages: [],
-                        errorCount: 1,
-                        warningCount: 0,
-                        fatalErrorCount: 0,
-                        fixableErrorCount: 1,
-                        fixableWarningCount: 0,
-                        source: "/* eslint-disable */",
-                        usedDeprecatedRules: []
-                    }
-                ]
-            );
-        });
-    });
+                assert.deepStrictEqual(resolvedSettings.sharedData, circular);
+            });
 
-    describe("when retrieving version number", () => {
-        it("should return current version number", () => {
-            const eslintCLI = require("../../../lib/eslint/eslint").ESLint;
-            const version = eslintCLI.version;
+            it("in 'parserOptions'", async () => {
+                let resolvedParserOptions = null;
 
-            assert.strictEqual(typeof version, "string");
-            assert(parseInt(version[0], 10) >= 3);
-        });
-    });
+                const circular = {};
 
-    describe("mutability", () => {
+                circular.self = circular;
 
-        describe("rules", () => {
-            it("Loading rules in one instance doesn't mutate to another instance", async () => {
-                const filePath = getFixturePath("single-quoted.js");
-                const engine1 = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
+                const eslint = new ESLint({
+                    flags,
                     overrideConfigFile: true,
-                    overrideConfig: {
-                        plugins: {
-                            example: {
-                                rules: {
-                                    "example-rule"() {
-                                        return {};
-                                    }
+                    baseConfig: {
+                        languageOptions: {
+                            parser: {
+                                parse(text, parserOptions) {
+                                    resolvedParserOptions = parserOptions;
+                                    return espree.parse(text, parserOptions);
                                 }
+                            },
+                            parserOptions: {
+                                testOption: circular
                             }
-                        },
-                        rules: { "example/example-rule": 1 }
+                        }
                     }
                 });
-                const engine2 = new ESLint({
-                    cwd: path.join(fixtureDir, ".."),
-                    overrideConfigFile: true
-                });
-                const fileConfig1 = await engine1.calculateConfigForFile(filePath);
-                const fileConfig2 = await engine2.calculateConfigForFile(filePath);
 
-                // plugin
-                assert.deepStrictEqual(fileConfig1.rules["example/example-rule"], [1], "example is present for engine 1");
-                assert.strictEqual(fileConfig2.rules, void 0, "example is not present for engine 2");
+                await eslint.lintText("debugger;");
+
+                assert.deepStrictEqual(resolvedParserOptions.testOption, circular);
             });
         });
-    });
 
-    describe("configs with 'ignores' and without 'files'", () => {
+    });
 
-        // https://github.com/eslint/eslint/issues/17103
-        describe("config with ignores: ['error.js']", () => {
-            const cwd = getFixturePath("config-with-ignores-without-files");
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd,
-                files: {
-                    "eslint.config.js": `module.exports = [
-                        {
-                            rules: {
-                                "no-unused-vars": "error",
-                            },
-                        },
-                        {
-                            ignores: ["error.js"],
-                            rules: {
-                                "no-unused-vars": "warn",
-                            },
-                        },
-                      ];`,
-                    "error.js": "let unusedVar;",
-                    "warn.js": "let unusedVar;"
-                }
-            });
+    describe("shouldUseFlatConfig", () => {
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+        /**
+         * Check that `shouldUseFlatConfig` returns the expected value from a CWD
+         * with a flat config and one without a flat config.
+         * @param {boolean} expectedValueWithConfig the expected return value of
+         * `shouldUseFlatConfig` when in a directory with a flat config present
+         * @param {boolean} expectedValueWithoutConfig the expected return value of
+         * `shouldUseFlatConfig` when in a directory without any flat config present
+         * @returns {void}
+         */
+        function testShouldUseFlatConfig(expectedValueWithConfig, expectedValueWithoutConfig) {
+            describe("when there is a flat config file present", () => {
+                const originalCwd = process.cwd();
 
-            it("should apply to all files except for 'error.js'", async () => {
-                const engine = new ESLint({
-                    cwd
+                beforeEach(() => {
+                    process.chdir(__dirname);
                 });
 
-                const results = await engine.lintFiles("{error,warn}.js");
+                afterEach(() => {
+                    process.chdir(originalCwd);
+                });
 
-                assert.strictEqual(results.length, 2);
+                it(`is \`${expectedValueWithConfig}\``, async () => {
+                    assert.strictEqual(await shouldUseFlatConfig(), expectedValueWithConfig);
+                });
+            });
 
-                const [errorResult, warnResult] = results;
+            describe("when there is no flat config file present", () => {
+                const originalCwd = process.cwd();
 
-                assert.strictEqual(errorResult.filePath, path.join(getPath(), "error.js"));
-                assert.strictEqual(errorResult.messages.length, 1);
-                assert.strictEqual(errorResult.messages[0].ruleId, "no-unused-vars");
-                assert.strictEqual(errorResult.messages[0].severity, 2);
+                beforeEach(() => {
+                    process.chdir(os.tmpdir());
+                });
 
-                assert.strictEqual(warnResult.filePath, path.join(getPath(), "warn.js"));
-                assert.strictEqual(warnResult.messages.length, 1);
-                assert.strictEqual(warnResult.messages[0].ruleId, "no-unused-vars");
-                assert.strictEqual(warnResult.messages[0].severity, 1);
-            });
+                afterEach(() => {
+                    process.chdir(originalCwd);
+                });
 
-            // https://github.com/eslint/eslint/issues/18261
-            it("should apply to all files except for 'error.js' even with `ignore: false` option", async () => {
-                const engine = new ESLint({
-                    cwd,
-                    ignore: false
+                it(`is \`${expectedValueWithoutConfig}\``, async () => {
+                    assert.strictEqual(await shouldUseFlatConfig(), expectedValueWithoutConfig);
                 });
+            });
+        }
 
-                const results = await engine.lintFiles("{error,warn}.js");
+        describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is `'true'`", () => {
+            beforeEach(() => {
+                process.env.ESLINT_USE_FLAT_CONFIG = true;
+            });
 
-                assert.strictEqual(results.length, 2);
+            afterEach(() => {
+                delete process.env.ESLINT_USE_FLAT_CONFIG;
+            });
 
-                const [errorResult, warnResult] = results;
+            testShouldUseFlatConfig(true, true);
+        });
 
-                assert.strictEqual(errorResult.filePath, path.join(getPath(), "error.js"));
-                assert.strictEqual(errorResult.messages.length, 1);
-                assert.strictEqual(errorResult.messages[0].ruleId, "no-unused-vars");
-                assert.strictEqual(errorResult.messages[0].severity, 2);
+        describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is `'false'`", () => {
+            beforeEach(() => {
+                process.env.ESLINT_USE_FLAT_CONFIG = false;
+            });
 
-                assert.strictEqual(warnResult.filePath, path.join(getPath(), "warn.js"));
-                assert.strictEqual(warnResult.messages.length, 1);
-                assert.strictEqual(warnResult.messages[0].ruleId, "no-unused-vars");
-                assert.strictEqual(warnResult.messages[0].severity, 1);
+            afterEach(() => {
+                delete process.env.ESLINT_USE_FLAT_CONFIG;
             });
+
+            testShouldUseFlatConfig(false, false);
         });
 
-        describe("config with ignores: ['**/*.json']", () => {
-            const cwd = getFixturePath("config-with-ignores-without-files");
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd,
-                files: {
-                    "eslint.config.js": `module.exports = [
-                        {
-                            rules: {
-                                "no-undef": "error",
-                            },
-                        },
-                        {
-                            ignores: ["**/*.json"],
-                            rules: {
-                                "no-unused-vars": "error",
-                            },
-                        },
-                      ];`,
-                    "foo.js": "",
-                    "foo.json": ""
-                }
-            });
+        describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is unset", () => {
+            testShouldUseFlatConfig(true, true);
+        });
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+    });
 
-            it("should not add json files as lint targets", async () => {
-                const engine = new ESLint({
-                    cwd
-                });
+    describe("cache", () => {
 
-                const results = await engine.lintFiles("foo*");
+        let eslint;
 
-                // should not lint `foo.json`
-                assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.join(getPath(), "foo.js"));
-            });
+        /**
+         * helper method to delete a file without caring about exceptions
+         * @param {string} filePath The file path
+         * @returns {void}
+         */
+        function doDelete(filePath) {
+            try {
+                fs.unlinkSync(filePath);
+            } catch {
+
+                /*
+                 * we don't care if the file didn't exist, since our
+                 * intention was to remove the file
+                 */
+            }
+        }
+
+        let cacheFilePath;
+
+        beforeEach(() => {
+            cacheFilePath = null;
         });
 
-    });
+        afterEach(() => {
+            sinon.restore();
+            if (cacheFilePath) {
+                doDelete(cacheFilePath);
+            }
+        });
+
+        describe("when cacheLocation is a directory or looks like a directory", () => {
 
-    describe("with ignores config", () => {
-        const root = getFixturePath("cli-engine/ignore-patterns");
-
-        describe("ignores can add an ignore pattern ('foo.js').", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root,
-                files: {
-                    "eslint.config.js": `module.exports = {
-                        ignores: ["**/foo.js"]
-                    };`,
-                    "foo.js": "",
-                    "bar.js": "",
-                    "subdir/foo.js": "",
-                    "subdir/bar.js": ""
+            const cwd = getFixturePath();
+
+            /**
+             * helper method to delete the directory used in testing
+             * @returns {void}
+             */
+            function deleteCacheDir() {
+                try {
+                    fs.rmSync(path.resolve(cwd, "tmp/.cacheFileDir/"), { recursive: true, force: true });
+                } catch {
+
+                    /*
+                     * we don't care if the file didn't exist, since our
+                     * intention was to remove the file
+                     */
                 }
+            }
+            beforeEach(() => {
+                deleteCacheDir();
             });
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            afterEach(() => {
+                deleteCacheDir();
+            });
 
-            it("'isPathIgnored()' should return 'true' for 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            it("should create the directory and the cache file inside it when cacheLocation ends with a slash", async () => {
+                assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
 
-                assert.strictEqual(await engine.isPathIgnored("foo.js"), true);
-                assert.strictEqual(await engine.isPathIgnored("subdir/foo.js"), true);
-            });
+                eslint = new ESLint({
+                    overrideConfigFile: true,
+                    cwd,
+
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: "./tmp/.cacheFileDir/",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
+                    },
+                    ignore: false
+                });
+                const file = getFixturePath("cache/src", "test-file.js");
 
-            it("'isPathIgnored()' should return 'false' for 'bar.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+                await eslint.lintFiles([file]);
 
-                assert.strictEqual(await engine.isPathIgnored("bar.js"), false);
-                assert.strictEqual(await engine.isPathIgnored("subdir/bar.js"), false);
+                assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
             });
 
-            it("'lintFiles()' should not verify 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            it("should create the cache file inside existing cacheLocation directory when cacheLocation ends with a slash", async () => {
+                assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(root, "bar.js"),
-                    path.join(root, "eslint.config.js"),
-                    path.join(root, "subdir/bar.js")
-                ]);
-            });
-        });
+                fs.mkdirSync(path.resolve(cwd, "./tmp/.cacheFileDir/"), { recursive: true });
 
-        describe("ignores can add ignore patterns ('**/foo.js', '/bar.js').", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root + Date.now(),
-                files: {
-                    "eslint.config.js": `module.exports = {
-                        ignores: ["**/foo.js", "bar.js"]
-                    };`,
-                    "foo.js": "",
-                    "bar.js": "",
-                    "baz.js": "",
-                    "subdir/foo.js": "",
-                    "subdir/bar.js": "",
-                    "subdir/baz.js": ""
-                }
-            });
+                eslint = new ESLint({
+                    overrideConfigFile: true,
+                    cwd,
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: "./tmp/.cacheFileDir/",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
+                    },
+                    ignore: false
+                });
+                const file = getFixturePath("cache/src", "test-file.js");
 
-            it("'isPathIgnored()' should return 'true' for 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+                await eslint.lintFiles([file]);
 
-                assert.strictEqual(await engine.isPathIgnored("foo.js"), true);
-                assert.strictEqual(await engine.isPathIgnored("subdir/foo.js"), true);
+                assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
             });
 
-            it("'isPathIgnored()' should return 'true' for '/bar.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            it("should create the cache file inside existing cacheLocation directory when cacheLocation doesn't end with a path separator", async () => {
+                assert(!shell.test("-d", path.resolve(cwd, "./tmp/.cacheFileDir/")), "the cache directory already exists and wasn't successfully deleted");
 
-                assert.strictEqual(await engine.isPathIgnored("bar.js"), true);
-                assert.strictEqual(await engine.isPathIgnored("subdir/bar.js"), false);
-            });
-
-            it("'lintFiles()' should not verify 'foo.js' and '/bar.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+                fs.mkdirSync(path.resolve(cwd, "./tmp/.cacheFileDir/"), { recursive: true });
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "baz.js"),
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "subdir/bar.js"),
-                    path.join(getPath(), "subdir/baz.js")
-                ]);
-            });
-        });
+                eslint = new ESLint({
+                    overrideConfigFile: true,
+                    cwd,
 
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: "./tmp/.cacheFileDir",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
+                    },
+                    ignore: false
+                });
+                const file = getFixturePath("cache/src", "test-file.js");
 
-        describe("ignores can unignore '/node_modules/foo' with patterns ['!node_modules/', 'node_modules/*', '!node_modules/foo/'].", () => {
+                await eslint.lintFiles([file]);
 
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}-unignores`,
-                files: {
-                    "eslint.config.js": `module.exports = {
-                        ignores: ["!node_modules/", "node_modules/*", "!node_modules/foo/"]
-                    };`,
-                    "node_modules/foo/index.js": "",
-                    "node_modules/foo/.dot.js": "",
-                    "node_modules/bar/index.js": "",
-                    "foo.js": ""
-                }
+                assert(shell.test("-f", path.resolve(cwd, `./tmp/.cacheFileDir/.cache_${hash(cwd)}`)), "the cache for eslint should have been created");
             });
+        });
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+        it("should create the cache file inside cwd when no cacheLocation provided", async () => {
+            const cwd = path.resolve(getFixturePath("cli-engine"));
 
-            it("'isPathIgnored()' should return 'false' for 'node_modules/foo/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            cacheFilePath = path.resolve(cwd, ".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/foo/index.js"), false);
+            eslint = new ESLint({
+                overrideConfigFile: true,
+                cache: true,
+                cwd,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0
+                    }
+                },
+                ignore: false
             });
+            const file = getFixturePath("cli-engine", "console.js");
 
-            it("'isPathIgnored()' should return 'false' for 'node_modules/foo/.dot.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            await eslint.lintFiles([file]);
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/foo/.dot.js"), false);
-            });
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created at provided cwd");
+        });
 
-            it("'isPathIgnored()' should return 'true' for 'node_modules/bar/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+        it("should invalidate the cache if the overrideConfig changed between executions", async () => {
+            const cwd = getFixturePath("cache/src");
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/bar/index.js"), true);
-            });
+            cacheFilePath = path.resolve(cwd, ".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-            it("'lintFiles()' should verify 'node_modules/foo/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            eslint = new ESLint({
+                overrideConfigFile: true,
+                cwd,
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo.js"),
-                    path.join(getPath(), "node_modules/foo/.dot.js"),
-                    path.join(getPath(), "node_modules/foo/index.js")
-                ]);
+                // specifying cache true the cache will be created
+                cache: true,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                },
+                ignore: false
             });
-        });
 
-        describe("ignores can unignore '/node_modules/foo' with patterns ['!node_modules/', 'node_modules/*', '!node_modules/foo/**'].", () => {
-
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}-unignores`,
-                files: {
-                    "eslint.config.js": `module.exports = {
-                        ignores: ["!node_modules/", "node_modules/*", "!node_modules/foo/**"]
-                    };`,
-                    "node_modules/foo/index.js": "",
-                    "node_modules/foo/.dot.js": "",
-                    "node_modules/bar/index.js": "",
-                    "foo.js": ""
-                }
-            });
+            let spy = sinon.spy(fs.promises, "readFile");
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            let file = path.join(cwd, "test-file.js");
 
-            it("'isPathIgnored()' should return 'false' for 'node_modules/foo/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            file = fs.realpathSync(file);
+            const results = await eslint.lintFiles([file]);
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/foo/index.js"), false);
-            });
+            for (const { errorCount, warningCount } of results) {
+                assert.strictEqual(errorCount + warningCount, 0, "the file should have passed linting without errors or warnings");
+            }
 
-            it("'isPathIgnored()' should return 'false' for 'node_modules/foo/.dot.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            assert(spy.calledWith(file), "ESLint should have read the file because there was no cache file");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/foo/.dot.js"), false);
-            });
+            // destroy the spy
+            sinon.restore();
 
-            it("'isPathIgnored()' should return 'true' for 'node_modules/bar/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            eslint = new ESLint({
+                overrideConfigFile: true,
+                cwd,
 
-                assert.strictEqual(await engine.isPathIgnored("node_modules/bar/index.js"), true);
+                // specifying cache true the cache will be created
+                cache: true,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 2,
+                        "no-unused-vars": 2
+                    }
+                },
+                ignore: false
             });
 
-            it("'lintFiles()' should verify 'node_modules/foo/index.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const result = (await engine.lintFiles("**/*.js"));
+            // create a new spy
+            spy = sinon.spy(fs.promises, "readFile");
 
-                const filePaths = result
-                    .map(r => r.filePath)
-                    .sort();
+            const [newResult] = await eslint.lintFiles([file]);
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo.js"),
-                    path.join(getPath(), "node_modules/foo/.dot.js"),
-                    path.join(getPath(), "node_modules/foo/index.js")
-                ]);
-            });
+            assert(spy.calledWith(file), "ESLint should have read the file again because it's considered changed because the config changed");
+            assert.strictEqual(newResult.errorCount, 1, "since configuration changed the cache should have not been used and one error should have been reported");
+            assert.strictEqual(newResult.messages[0].ruleId, "no-console");
+            assert(shell.test("-f", cacheFilePath), "The cache for ESLint should still exist");
         });
 
-        describe("ignore pattern can re-ignore files that are unignored by a previous pattern.", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}-reignore`,
-                files: {
-                    "eslint.config.js": `module.exports = ${JSON.stringify({
-                        ignores: ["!.*", ".foo*"]
-                    })}`,
-                    ".foo.js": "",
-                    ".bar.js": ""
-                }
-            });
+        it("should remember the files from a previous run and do not operate on them if not changed", async () => {
+            const cwd = getFixturePath("cache/src");
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            cacheFilePath = path.resolve(cwd, ".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-            it("'isPathIgnored()' should return 'true' for re-ignored '.foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            eslint = new ESLint({
+                overrideConfigFile: true,
+                cwd,
 
-                assert.strictEqual(await engine.isPathIgnored(".foo.js"), true);
+                // specifying cache true the cache will be created
+                cache: true,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                },
+                ignore: false
             });
 
-            it("'isPathIgnored()' should return 'false' for unignored '.bar.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            let spy = sinon.spy(fs.promises, "readFile");
 
-                assert.strictEqual(await engine.isPathIgnored(".bar.js"), false);
-            });
+            let file = getFixturePath("cache/src", "test-file.js");
 
-            it("'lintFiles()' should not lint re-ignored '.foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            file = fs.realpathSync(file);
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), ".bar.js"),
-                    path.join(getPath(), "eslint.config.js")
-                ]);
-            });
-        });
+            const result = await eslint.lintFiles([file]);
 
-        describe("ignore pattern can unignore files that are ignored by a previous pattern.", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}-dignore`,
-                files: {
-                    "eslint.config.js": `module.exports = ${JSON.stringify({
-                        ignores: ["**/*.js", "!foo.js"]
-                    })}`,
-                    "foo.js": "",
-                    "bar.js": ""
-                }
-            });
+            assert(spy.calledWith(file), "ESLint should have read the file because there was no cache file");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            // destroy the spy
+            sinon.restore();
 
-            it("'isPathIgnored()' should return 'false' for unignored 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            eslint = new ESLint({
+                overrideConfigFile: true,
+                cwd,
 
-                assert.strictEqual(await engine.isPathIgnored("foo.js"), false);
+                // specifying cache true the cache will be created
+                cache: true,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                },
+                ignore: false
             });
 
-            it("'isPathIgnored()' should return 'true' for ignored 'bar.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
+            // create a new spy
+            spy = sinon.spy(fs.promises, "readFile");
 
-                assert.strictEqual(await engine.isPathIgnored("bar.js"), true);
-            });
+            const cachedResult = await eslint.lintFiles([file]);
 
-            it("'lintFiles()' should verify unignored 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            assert.deepStrictEqual(result, cachedResult, "the result should have been the same");
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "foo.js")
-                ]);
-            });
+            // assert the file was not processed because the cache was used
+            assert(!spy.calledWith(file), "the file should not have been reloaded");
         });
 
-        describe("ignores in a config file should not be used if ignore: false.", () => {
-
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root,
-                files: {
-                    "eslint.config.js": `module.exports = {
-                        ignores: ["*.js"]
-                    }`,
-                    "foo.js": ""
-                }
-            });
-
-            beforeEach(prepare);
-            afterEach(cleanup);
-
-            it("'isPathIgnored()' should return 'false' for 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath(), ignore: false });
+        it("when `cacheLocation` is specified, should create the cache file with `cache:true` and then delete it with `cache:false`", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-                assert.strictEqual(await engine.isPathIgnored("foo.js"), false);
-            });
+            const eslintOptions = {
+                overrideConfigFile: true,
 
-            it("'lintFiles()' should verify 'foo.js'.", async () => {
-                const engine = new ESLint({ cwd: getPath(), ignore: false });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                },
+                cwd: path.join(fixtureDir, "..")
+            };
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(root, "eslint.config.js"),
-                    path.join(root, "foo.js")
-                ]);
-            });
-        });
+            eslint = new ESLint(eslintOptions);
 
-    });
+            let file = getFixturePath("cache/src", "test-file.js");
 
-    describe("config.files adds lint targets", () => {
-        const root = getFixturePath("cli-engine/additional-lint-targets");
-
-
-        describe("if { files: 'foo/*.txt', ignores: '**/ignore.txt' } is present,", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root + 1,
-                files: {
-                    "eslint.config.js": `module.exports = [{
-                        files: ["foo/*.txt"],
-                        ignores: ["**/ignore.txt"]
-                    }];`,
-                    "foo/nested/test.txt": "",
-                    "foo/test.js": "",
-                    "foo/test.txt": "",
-                    "foo/ignore.txt": "",
-                    "bar/test.js": "",
-                    "bar/test.txt": "",
-                    "bar/ignore.txt": "",
-                    "test.js": "",
-                    "test.txt": "",
-                    "ignore.txt": ""
-                }
-            });
+            file = fs.realpathSync(file);
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            await eslint.lintFiles([file]);
 
-            it("'lintFiles()' with a directory path should contain 'foo/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("."))
-                    .map(r => r.filePath)
-                    .sort();
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "bar/test.js"),
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo/test.js"),
-                    path.join(getPath(), "foo/test.txt"),
-                    path.join(getPath(), "test.js")
-                ]);
-            });
+            eslintOptions.cache = false;
+            eslint = new ESLint(eslintOptions);
 
-            it("'lintFiles()' with a glob pattern '*.js' should not contain 'foo/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            await eslint.lintFiles([file]);
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "bar/test.js"),
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo/test.js"),
-                    path.join(getPath(), "test.js")
-                ]);
-            });
+            assert(!shell.test("-f", cacheFilePath), "the cache for eslint should have been deleted since last run did not use the cache");
         });
 
-        describe("if { files: 'foo/*.txt', ignores: '**/ignore.txt' } is present and subdirectory is passed,", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root + 2,
-                files: {
-                    "eslint.config.js": `module.exports = [{
-                        files: ["foo/*.txt"],
-                        ignores: ["**/ignore.txt"]
-                    }];`,
-                    "foo/nested/test.txt": "",
-                    "foo/test.js": "",
-                    "foo/test.txt": "",
-                    "foo/ignore.txt": "",
-                    "bar/test.js": "",
-                    "bar/test.txt": "",
-                    "bar/ignore.txt": "",
-                    "test.js": "",
-                    "test.txt": "",
-                    "ignore.txt": ""
-                }
-            });
+        it("should not throw an error if the cache file to be deleted does not exist on a read-only file system", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            // Simulate a read-only file system.
+            sinon.stub(fsp, "unlink").rejects(
+                Object.assign(new Error("read-only file system"), { code: "EROFS" })
+            );
 
-            it("'lintFiles()' with a directory path should contain 'foo/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("foo"))
-                    .map(r => r.filePath)
-                    .sort();
+            const eslintOptions = {
+                overrideConfigFile: true,
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "foo/test.js"),
-                    path.join(getPath(), "foo/test.txt")
-                ]);
-            });
+                // specifying cache false the cache will be deleted
+                cache: false,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                },
+                cwd: path.join(fixtureDir, "..")
+            };
 
-            it("'lintFiles()' with a glob pattern '*.js' should not contain 'foo/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("foo/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            eslint = new ESLint(eslintOptions);
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "foo/test.js")
-                ]);
-            });
-        });
+            const file = getFixturePath("cache/src", "test-file.js");
 
-        describe("if { files: 'foo/**/*.txt' } is present,", () => {
+            await eslint.lintFiles([file]);
 
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root + 3,
-                files: {
-                    "eslint.config.js": `module.exports = [
-                        {
-                            files: ["foo/**/*.txt"]
-                        }
-                    ]`,
-                    "foo/nested/test.txt": "",
-                    "foo/test.js": "",
-                    "foo/test.txt": "",
-                    "bar/test.js": "",
-                    "bar/test.txt": "",
-                    "test.js": "",
-                    "test.txt": ""
-                }
-            });
+            assert(fsp.unlink.calledWithExactly(cacheFilePath), "Expected attempt to delete the cache was not made.");
+        });
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+        it("should store in the cache a file that has lint messages and a file that doesn't have lint messages", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-            it("'lintFiles()' with a directory path should contain 'foo/test.txt' and 'foo/nested/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("."))
-                    .map(r => r.filePath)
-                    .sort();
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "bar/test.js"),
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo/nested/test.txt"),
-                    path.join(getPath(), "foo/test.js"),
-                    path.join(getPath(), "foo/test.txt"),
-                    path.join(getPath(), "test.js")
-                ]);
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
+                }
             });
-        });
+            const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+            const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+            const result = await eslint.lintFiles([badFile, goodFile]);
+            const [badFileResult, goodFileResult] = result;
 
-        describe("if { files: 'foo/**/*' } is present,", () => {
+            assert.notStrictEqual(badFileResult.errorCount + badFileResult.warningCount, 0, "the bad file should have some lint errors or warnings");
+            assert.strictEqual(goodFileResult.errorCount + badFileResult.warningCount, 0, "the good file should have passed linting without errors or warnings");
 
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: root + 4,
-                files: {
-                    "eslint.config.js": `module.exports = [
-                        {
-                            files: ["foo/**/*"]
-                        }
-                    ]`,
-                    "foo/nested/test.txt": "",
-                    "foo/test.js": "",
-                    "foo/test.txt": "",
-                    "bar/test.js": "",
-                    "bar/test.txt": "",
-                    "test.js": "",
-                    "test.txt": ""
-                }
-            });
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            const fileCache = fCache.createFromFile(cacheFilePath);
+            const { cache } = fileCache;
 
-            it("'lintFiles()' with a directory path should NOT contain 'foo/test.txt' and 'foo/nested/test.txt'.", async () => {
-                const engine = new ESLint({ cwd: getPath() });
-                const filePaths = (await engine.lintFiles("."))
-                    .map(r => r.filePath)
-                    .sort();
+            assert.strictEqual(typeof cache.getKey(goodFile), "object", "the entry for the good file should have been in the cache");
+            assert.strictEqual(typeof cache.getKey(badFile), "object", "the entry for the bad file should have been in the cache");
+            const cachedResult = await eslint.lintFiles([badFile, goodFile]);
 
-                assert.deepStrictEqual(filePaths, [
-                    path.join(getPath(), "bar/test.js"),
-                    path.join(getPath(), "eslint.config.js"),
-                    path.join(getPath(), "foo/test.js"),
-                    path.join(getPath(), "test.js")
-                ]);
-            });
+            assert.deepStrictEqual(result, cachedResult, "result should be the same with or without cache");
         });
 
-    });
-
-    describe("'ignores', 'files' of the configuration that the '--config' option provided should be resolved from CWD.", () => {
-        const root = getFixturePath("cli-engine/config-and-overrides-files");
+        it("should not contain in the cache a file that was deleted", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
 
-        describe("if { files: 'foo/*.txt', ... } is present by '--config node_modules/myconf/eslint.config.js',", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}a1`,
-                files: {
-                    "node_modules/myconf/eslint.config.js": `module.exports = [
-                        {
-                            files: ["foo/*.js"],
-                            rules: {
-                                eqeqeq: "error"
-                            }
-                        }
-                    ];`,
-                    "node_modules/myconf/foo/test.js": "a == b",
-                    "foo/test.js": "a == b"
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
                 }
             });
+            const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+            const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+            const toBeDeletedFile = fs.realpathSync(getFixturePath("cache/src", "file-to-delete.js"));
 
-            beforeEach(prepare);
-            afterEach(cleanup);
-
-            it("'lintFiles()' with 'foo/test.js' should use the files entry.", async () => {
-                const engine = new ESLint({
-                    overrideConfigFile: "node_modules/myconf/eslint.config.js",
-                    cwd: getPath(),
-                    ignore: false
-                });
-                const results = await engine.lintFiles("foo/test.js");
-
-                // Expected to be an 'eqeqeq' error because the file matches to `$CWD/foo/*.js`.
-                assert.deepStrictEqual(results, [
-                    {
-                        suppressedMessages: [],
-                        errorCount: 1,
-                        filePath: path.join(getPath(), "foo/test.js"),
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        messages: [
-                            {
-                                column: 3,
-                                endColumn: 5,
-                                endLine: 1,
-                                line: 1,
-                                message: "Expected '===' and instead saw '=='.",
-                                messageId: "unexpected",
-                                nodeType: "BinaryExpression",
-                                ruleId: "eqeqeq",
-                                severity: 2
-                            }
-                        ],
-                        source: "a == b",
-                        usedDeprecatedRules: [],
-                        warningCount: 0,
-                        fatalErrorCount: 0
-                    }
-                ]);
-            });
+            await eslint.lintFiles([badFile, goodFile, toBeDeletedFile]);
+            const fileCache = fCache.createFromFile(cacheFilePath);
+            let { cache } = fileCache;
 
-            it("'lintFiles()' with 'node_modules/myconf/foo/test.js' should NOT use the files entry.", async () => {
-                const engine = new ESLint({
-                    overrideConfigFile: "node_modules/myconf/eslint.config.js",
-                    cwd: getPath(),
-                    ignore: false
-                });
-                const results = await engine.lintFiles("node_modules/myconf/foo/test.js");
+            assert.strictEqual(typeof cache.getKey(toBeDeletedFile), "object", "the entry for the file to be deleted should have been in the cache");
 
-                // Expected to be no errors because the file doesn't match to `$CWD/foo/*.js`.
-                assert.deepStrictEqual(results, [
-                    {
-                        suppressedMessages: [],
-                        errorCount: 0,
-                        filePath: path.join(getPath(), "node_modules/myconf/foo/test.js"),
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        messages: [
-                            {
-                                ruleId: null,
-                                fatal: false,
-                                message: "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.",
-                                severity: 1,
-                                nodeType: null
-                            }
-                        ],
-                        usedDeprecatedRules: [],
-                        warningCount: 1,
-                        fatalErrorCount: 0
-                    }
-                ]);
-            });
-        });
+            // delete the file from the file system
+            fs.unlinkSync(toBeDeletedFile);
 
-        describe("if { files: '*', ignores: 'foo/*.txt', ... } is present by '--config bar/myconf/eslint.config.js',", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}a2`,
-                files: {
-                    "bar/myconf/eslint.config.js": `module.exports = [
-                        {
-                            files: ["**/*"],
-                            ignores: ["foo/*.js"],
-                            rules: {
-                                eqeqeq: "error"
-                            }
-                        }
-                    ]`,
-                    "bar/myconf/foo/test.js": "a == b",
-                    "foo/test.js": "a == b"
-                }
-            });
+            /*
+             * file-entry-cache@2.0.0 will remove from the cache deleted files
+             * even when they were not part of the array of files to be analyzed
+             */
+            await eslint.lintFiles([badFile, goodFile]);
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            cache = JSON.parse(fs.readFileSync(cacheFilePath));
 
-            it("'lintFiles()' with 'foo/test.js' should have no errors because no rules are enabled.", async () => {
-                const engine = new ESLint({
-                    overrideConfigFile: "bar/myconf/eslint.config.js",
-                    cwd: getPath(),
-                    ignore: false
-                });
-                const results = await engine.lintFiles("foo/test.js");
+            assert.strictEqual(typeof cache[0][toBeDeletedFile], "undefined", "the entry for the file to be deleted should not have been in the cache");
 
-                // Expected to be no errors because the file matches to `$CWD/foo/*.js`.
-                assert.deepStrictEqual(results, [
-                    {
-                        suppressedMessages: [],
-                        errorCount: 0,
-                        filePath: path.join(getPath(), "foo/test.js"),
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        messages: [],
-                        usedDeprecatedRules: [],
-                        warningCount: 0,
-                        fatalErrorCount: 0
-                    }
-                ]);
-            });
+            // make sure that the previos assertion checks the right place
+            assert.notStrictEqual(typeof cache[0][badFile], "undefined", "the entry for the bad file should have been in the cache");
+            assert.notStrictEqual(typeof cache[0][goodFile], "undefined", "the entry for the good file should have been in the cache");
+        });
 
-            it("'lintFiles()' with 'bar/myconf/foo/test.js' should have an error because eqeqeq is enabled.", async () => {
-                const engine = new ESLint({
-                    overrideConfigFile: "bar/myconf/eslint.config.js",
-                    cwd: getPath(),
-                    ignore: false
-                });
-                const results = await engine.lintFiles("bar/myconf/foo/test.js");
+        it("should contain files that were not visited in the cache provided they still exist", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
 
-                // Expected to be an 'eqeqeq' error because the file doesn't match to `$CWD/foo/*.js`.
-                assert.deepStrictEqual(results, [
-                    {
-                        suppressedMessages: [],
-                        errorCount: 1,
-                        filePath: path.join(getPath(), "bar/myconf/foo/test.js"),
-                        fixableErrorCount: 0,
-                        fixableWarningCount: 0,
-                        messages: [
-                            {
-                                column: 3,
-                                endColumn: 5,
-                                endLine: 1,
-                                line: 1,
-                                message: "Expected '===' and instead saw '=='.",
-                                messageId: "unexpected",
-                                nodeType: "BinaryExpression",
-                                ruleId: "eqeqeq",
-                                severity: 2
-                            }
-                        ],
-                        source: "a == b",
-                        usedDeprecatedRules: [],
-                        warningCount: 0,
-                        fatalErrorCount: 0
-                    }
-                ]);
-            });
-        });
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
 
-        describe("if { ignores: 'foo/*.js', ... } is present by '--config node_modules/myconf/eslint.config.js',", () => {
-            const { prepare, cleanup, getPath } = createCustomTeardown({
-                cwd: `${root}a3`,
-                files: {
-                    "node_modules/myconf/eslint.config.js": `module.exports = [{
-                        ignores: ["!node_modules", "node_modules/*", "!node_modules/myconf", "foo/*.js"],
-                    }, {
-                        rules: {
-                            eqeqeq: "error"
-                        }
-                    }]`,
-                    "node_modules/myconf/foo/test.js": "a == b",
-                    "foo/test.js": "a == b"
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
+                    }
                 }
             });
+            const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+            const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+            const testFile2 = fs.realpathSync(getFixturePath("cache/src", "test-file2.js"));
 
-            beforeEach(prepare);
-            afterEach(cleanup);
+            await eslint.lintFiles([badFile, goodFile, testFile2]);
 
-            it("'lintFiles()' with '**/*.js' should lint 'node_modules/myconf/foo/test.js' but not 'foo/test.js'.", async () => {
-                const engine = new ESLint({
-                    overrideConfigFile: "node_modules/myconf/eslint.config.js",
-                    cwd: getPath()
-                });
-                const files = (await engine.lintFiles("**/*.js"))
-                    .map(r => r.filePath)
-                    .sort();
+            let fileCache = fCache.createFromFile(cacheFilePath);
+            let { cache } = fileCache;
 
-                assert.deepStrictEqual(files, [
-                    path.join(getPath(), "node_modules/myconf/eslint.config.js"),
-                    path.join(getPath(), "node_modules/myconf/foo/test.js")
-                ]);
-            });
+            assert.strictEqual(typeof cache.getKey(testFile2), "object", "the entry for the test-file2 should have been in the cache");
+
+            /*
+             * we pass a different set of files (minus test-file2)
+             * previous version of file-entry-cache would remove the non visited
+             * entries. 2.0.0 version will keep them unless they don't exist
+             */
+            await eslint.lintFiles([badFile, goodFile]);
+
+            fileCache = fCache.createFromFile(cacheFilePath);
+            cache = fileCache.cache;
+
+            assert.strictEqual(typeof cache.getKey(testFile2), "object", "the entry for the test-file2 should have been in the cache");
         });
-    });
 
-    describe("baseConfig", () => {
-        it("can be an object", async () => {
-            const eslint = new ESLint({
+        it("should not delete cache when executing on text", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
                 overrideConfigFile: true,
-                baseConfig: {
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
                     rules: {
-                        semi: 2
+                        "no-console": 0,
+                        "no-unused-vars": 2
                     }
                 }
             });
 
-            const [{ messages }] = await eslint.lintText("foo");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
+
+            await eslint.lintText("var foo = 'bar';");
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
         });
 
-        it("can be an array", async () => {
-            const eslint = new ESLint({
+        it("should not delete cache when executing on text with a provided filename", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
                 overrideConfigFile: true,
-                baseConfig: [
-                    {
-                        rules: {
-                            "no-var": 2
-                        }
-                    },
-                    {
-                        rules: {
-                            semi: 2
-                        }
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
                     }
-                ]
+                }
             });
 
-            const [{ messages }] = await eslint.lintText("var foo");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
+
+            await eslint.lintText("var bar = foo;", { filePath: "fixtures/passing.js" });
 
-            assert.strictEqual(messages.length, 2);
-            assert.strictEqual(messages[0].ruleId, "no-var");
-            assert.strictEqual(messages[1].ruleId, "semi");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
         });
 
-        it("should be inserted after default configs", async () => {
-            const eslint = new ESLint({
+        it("should not delete cache when executing on files with --cache flag", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            fs.writeFileSync(cacheFilePath, "");
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
                 overrideConfigFile: true,
-                baseConfig: {
-                    languageOptions: {
-                        ecmaVersion: 5,
-                        sourceType: "script"
+                cache: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
+                    rules: {
+                        "no-console": 0,
+                        "no-unused-vars": 2
                     }
                 }
             });
+            const file = getFixturePath("cli-engine", "console.js");
 
-            const [{ messages }] = await eslint.lintText("let x");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
 
-            /*
-             * if baseConfig was inserted before default configs,
-             * `ecmaVersion: "latest"` from default configs would overwrite
-             * `ecmaVersion: 5` from baseConfig, so this wouldn't be a parsing error.
-             */
+            await eslint.lintFiles([file]);
 
-            assert.strictEqual(messages.length, 1);
-            assert(messages[0].fatal, "Fatal error expected.");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should still exist");
         });
 
-        it("should be inserted before configs from the config file", async () => {
-            const eslint = new ESLint({
-                cwd: getFixturePath(),
-                baseConfig: {
+        it("should delete cache when executing on files without --cache flag", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            fs.writeFileSync(cacheFilePath, "[]"); // intenationally invalid to additionally make sure it isn't used
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
+                cacheLocation: cacheFilePath,
+                overrideConfig: {
                     rules: {
-                        strict: ["error", "global"]
-                    },
-                    languageOptions: {
-                        sourceType: "script"
+                        "no-console": 0,
+                        "no-unused-vars": 2
                     }
                 }
             });
+            const file = getFixturePath("cli-engine", "console.js");
 
-            const [{ messages }] = await eslint.lintText("foo");
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should exist");
 
-            /*
-             * if baseConfig was inserted after configs from the config file,
-             * `strict: 0` from eslint.config.js wouldn't overwrite `strict: ["error", "global"]`
-             * from baseConfig, so there would be an error message from the `strict` rule.
-             */
+            await eslint.lintFiles([file]);
 
-            assert.strictEqual(messages.length, 0);
+            assert(!shell.test("-f", cacheFilePath), "the cache for eslint should have been deleted");
         });
 
-        it("should be inserted before overrideConfig", async () => {
-            const eslint = new ESLint({
+        it("should use the specified cache file", async () => {
+            cacheFilePath = path.resolve(".cache/custom-cache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            eslint = new ESLint({
                 overrideConfigFile: true,
-                baseConfig: {
+
+                // specify a custom cache file
+                cacheLocation: cacheFilePath,
+
+                // specifying cache true the cache will be created
+                cache: true,
+                overrideConfig: {
                     rules: {
-                        semi: 2
+                        "no-console": 0,
+                        "no-unused-vars": 2
                     }
                 },
+
+                cwd: path.join(fixtureDir, "..")
+            });
+            const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+            const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+            const result = await eslint.lintFiles([badFile, goodFile]);
+
+            assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+
+            const fileCache = fCache.createFromFile(cacheFilePath);
+            const { cache } = fileCache;
+
+            assert(typeof cache.getKey(goodFile) === "object", "the entry for the good file should have been in the cache");
+            assert(typeof cache.getKey(badFile) === "object", "the entry for the bad file should have been in the cache");
+
+            const cachedResult = await eslint.lintFiles([badFile, goodFile]);
+
+            assert.deepStrictEqual(result, cachedResult, "result should be the same with or without cache");
+        });
+
+        // https://github.com/eslint/eslint/issues/13507
+        it("should not store `usedDeprecatedRules` in the cache file", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            const deprecatedRuleId = "space-in-parens";
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
+
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
                 overrideConfig: {
                     rules: {
-                        semi: 1
+                        [deprecatedRuleId]: 2
                     }
                 }
             });
 
-            const [{ messages }] = await eslint.lintText("foo");
+            const filePath = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+
+            /*
+             * Run linting on the same file 3 times to cover multiple cases:
+             *   Run 1: Lint result wasn't already cached.
+             *   Run 2: Lint result was already cached. The cached lint result is used but the cache is reconciled before the run ends.
+             *   Run 3: Lint result was already cached. The cached lint result was being used throughout the previous run, so possible
+             *     mutations in the previous run that occured after the cache was reconciled may have side effects for this run.
+             */
+            for (let i = 0; i < 3; i++) {
+                const [result] = await eslint.lintFiles([filePath]);
+
+                assert(
+                    result.usedDeprecatedRules && result.usedDeprecatedRules.some(rule => rule.ruleId === deprecatedRuleId),
+                    "the deprecated rule should have been in result.usedDeprecatedRules"
+                );
+
+                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+
+                const fileCache = fCache.create(cacheFilePath);
+                const descriptor = fileCache.getFileDescriptor(filePath);
+
+                assert(typeof descriptor === "object", "an entry for the file should have been in the cache file");
+                assert(typeof descriptor.meta.results === "object", "lint result for the file should have been in its cache entry in the cache file");
+                assert(typeof descriptor.meta.results.usedDeprecatedRules === "undefined", "lint result in the cache file contains `usedDeprecatedRules`");
+            }
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].severity, 1);
         });
 
-        it("should be inserted before configs from the config file and overrideConfig", async () => {
-            const eslint = new ESLint({
-                overrideConfigFile: getFixturePath("eslint.config-with-rules.js"),
-                baseConfig: {
-                    rules: {
-                        quotes: ["error", "double"],
-                        semi: "error"
-                    }
-                },
+        // https://github.com/eslint/eslint/issues/13507
+        it("should store `source` as `null` in the cache file if the lint result has `source` property", async () => {
+            cacheFilePath = getFixturePath(".eslintcache");
+            doDelete(cacheFilePath);
+            assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+            eslint = new ESLint({
+                cwd: path.join(fixtureDir, ".."),
+                overrideConfigFile: true,
+
+                // specifying cache true the cache will be created
+                cache: true,
+                cacheLocation: cacheFilePath,
                 overrideConfig: {
                     rules: {
-                        quotes: "warn"
+                        "no-unused-vars": 2
                     }
                 }
             });
 
-            const [{ messages }] = await eslint.lintText("const foo = \"bar\"");
+            const filePath = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
 
             /*
-             * baseConfig: { quotes: ["error", "double"], semi: "error" }
-             * eslint.config-with-rules.js: { quotes: ["error", "single"] }
-             * overrideConfig: { quotes: "warn" }
-             *
-             * Merged config: { quotes: ["warn", "single"], semi: "error" }
+             * Run linting on the same file 3 times to cover multiple cases:
+             *   Run 1: Lint result wasn't already cached.
+             *   Run 2: Lint result was already cached. The cached lint result is used but the cache is reconciled before the run ends.
+             *   Run 3: Lint result was already cached. The cached lint result was being used throughout the previous run, so possible
+             *     mutations in the previous run that occured after the cache was reconciled may have side effects for this run.
              */
+            for (let i = 0; i < 3; i++) {
+                const [result] = await eslint.lintFiles([filePath]);
+
+                assert(typeof result.source === "string", "the result should have contained the `source` property");
+
+                assert(shell.test("-f", cacheFilePath), "the cache for eslint should have been created");
+
+                const fileCache = fCache.create(cacheFilePath);
+                const descriptor = fileCache.getFileDescriptor(filePath);
+
+                assert(typeof descriptor === "object", "an entry for the file should have been in the cache file");
+                assert(typeof descriptor.meta.results === "object", "lint result for the file should have been in its cache entry in the cache file");
+
+                // if the lint result contains `source`, it should be stored as `null` in the cache file
+                assert.strictEqual(descriptor.meta.results.source, null, "lint result in the cache file contains non-null `source`");
+            }
 
-            assert.strictEqual(messages.length, 2);
-            assert.strictEqual(messages[0].ruleId, "quotes");
-            assert.strictEqual(messages[0].severity, 1);
-            assert.strictEqual(messages[1].ruleId, "semi");
-            assert.strictEqual(messages[1].severity, 2);
         });
 
-        it("when it has 'files' they should be interpreted as relative to the config file", async () => {
+        describe("cacheStrategy", () => {
+            it("should detect changes using a file's modification time when set to 'metadata'", async () => {
+                cacheFilePath = getFixturePath(".eslintcache");
+                doDelete(cacheFilePath);
+                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+                eslint = new ESLint({
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: true,
 
-            /*
-             * `fixtures/plugins` directory does not have a config file.
-             * It's parent directory `fixtures` does have a config file, so
-             * the base path will be `fixtures`, cwd will be `fixtures/plugins`
-             */
-            const eslint = new ESLint({
-                cwd: getFixturePath("plugins"),
-                baseConfig: {
-                    files: ["plugins/a.js"],
-                    rules: {
-                        semi: 2
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: cacheFilePath,
+                    cacheStrategy: "metadata",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
                     }
-                }
+
+                });
+                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+
+                await eslint.lintFiles([badFile, goodFile]);
+                let fileCache = fCache.createFromFile(cacheFilePath);
+                const entries = fileCache.normalizeEntries([badFile, goodFile]);
+
+                entries.forEach(entry => {
+                    assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
+                });
+
+                // this should result in a changed entry
+                shell.touch(goodFile);
+                fileCache = fCache.createFromFile(cacheFilePath);
+                assert(fileCache.getFileDescriptor(badFile).changed === false, `the entry for ${badFile} should have been unchanged`);
+                assert(fileCache.getFileDescriptor(goodFile).changed === true, `the entry for ${goodFile} should have been changed`);
+            });
+
+            it("should not detect changes using a file's modification time when set to 'content'", async () => {
+                cacheFilePath = getFixturePath(".eslintcache");
+                doDelete(cacheFilePath);
+                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+                eslint = new ESLint({
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: true,
+
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: cacheFilePath,
+                    cacheStrategy: "content",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
+                    }
+
+                });
+                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+
+                await eslint.lintFiles([badFile, goodFile]);
+                let fileCache = fCache.createFromFile(cacheFilePath, true);
+                let entries = fileCache.normalizeEntries([badFile, goodFile]);
+
+                entries.forEach(entry => {
+                    assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
+                });
+
+                // this should NOT result in a changed entry
+                shell.touch(goodFile);
+                fileCache = fCache.createFromFile(cacheFilePath, true);
+                entries = fileCache.normalizeEntries([badFile, goodFile]);
+                entries.forEach(entry => {
+                    assert(entry.changed === false, `the entry for ${entry.key} should have remained unchanged`);
+                });
             });
 
-            const [{ messages }] = await eslint.lintText("foo", { filePath: getFixturePath("plugins/a.js") });
+            it("should detect changes using a file's contents when set to 'content'", async () => {
+                cacheFilePath = getFixturePath(".eslintcache");
+                doDelete(cacheFilePath);
+                assert(!shell.test("-f", cacheFilePath), "the cache file already exists and wasn't successfully deleted");
+
+                eslint = new ESLint({
+                    cwd: path.join(fixtureDir, ".."),
+                    overrideConfigFile: true,
+
+                    // specifying cache true the cache will be created
+                    cache: true,
+                    cacheLocation: cacheFilePath,
+                    cacheStrategy: "content",
+                    overrideConfig: {
+                        rules: {
+                            "no-console": 0,
+                            "no-unused-vars": 2
+                        }
+                    }
+
+                });
+                const badFile = fs.realpathSync(getFixturePath("cache/src", "fail-file.js"));
+                const goodFile = fs.realpathSync(getFixturePath("cache/src", "test-file.js"));
+                const goodFileCopy = path.resolve(`${path.dirname(goodFile)}`, "test-file-copy.js");
+
+                shell.cp(goodFile, goodFileCopy);
+
+                await eslint.lintFiles([badFile, goodFileCopy]);
+                let fileCache = fCache.createFromFile(cacheFilePath, true);
+                const entries = fileCache.normalizeEntries([badFile, goodFileCopy]);
+
+                entries.forEach(entry => {
+                    assert(entry.changed === false, `the entry for ${entry.key} should have been initially unchanged`);
+                });
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
+                // this should result in a changed entry
+                shell.sed("-i", "abc", "xzy", goodFileCopy);
+                fileCache = fCache.createFromFile(cacheFilePath, true);
+                assert(fileCache.getFileDescriptor(badFile).changed === false, `the entry for ${badFile} should have been unchanged`);
+                assert(fileCache.getFileDescriptor(goodFileCopy).changed === true, `the entry for ${goodFileCopy} should have been changed`);
+            });
         });
+    });
+
+    describe("unstable_config_lookup_from_file", () => {
 
-        it("when it has 'ignores' they should be interpreted as relative to the config file", async () => {
+        let eslint;
+        const flags = ["unstable_config_lookup_from_file"];
+
+        it("should report zero messages when given a config file and a valid file", async () => {
 
             /*
-             * `fixtures/plugins` directory does not have a config file.
-             * It's parent directory `fixtures` does have a config file, so
-             * the base path will be `fixtures`, cwd will be `fixtures/plugins`
+             * This test ensures subdir/code.js is linted using the configuration in
+             * subdir/eslint.config.js and not from eslint.config.js in the parent
+             * directory.
              */
-            const eslint = new ESLint({
-                cwd: getFixturePath("plugins"),
-                baseConfig: {
-                    ignores: ["plugins/a.js"]
-                }
+
+            eslint = new ESLint({
+                flags,
+                cwd: getFixturePath("lookup-from-file")
+            });
+            const results = await eslint.lintFiles(["."]);
+
+            assert.strictEqual(results.length, 2);
+            assert.strictEqual(results[0].filePath, getFixturePath("lookup-from-file", "code.js"));
+            assert.strictEqual(results[0].messages.length, 1);
+            assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+            assert.strictEqual(results[0].messages[0].severity, 2);
+            assert.strictEqual(results[0].suppressedMessages.length, 0);
+
+            assert.strictEqual(results[1].filePath, getFixturePath("lookup-from-file", "subdir", "code.js"));
+            assert.strictEqual(results[1].messages.length, 1);
+            assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+            assert.strictEqual(results[1].messages[0].severity, 1);
+            assert.strictEqual(results[1].suppressedMessages.length, 0);
+        });
+
+        describe("Subdirectory Config File", () => {
+
+            const workDirName = "subdir-only-config";
+            const tmpDir = path.resolve(fs.realpathSync(os.tmpdir()), "eslint");
+            const workDir = path.join(tmpDir, workDirName);
+
+            // copy into clean area so as not to get "infected" by other config files
+            before(() => {
+
+                shell.mkdir("-p", workDir);
+                shell.cp("-r", `./tests/fixtures/${workDirName}`, tmpDir);
+            });
+
+            after(() => {
+                shell.rm("-r", workDir);
+            });
+
+            it("should find config file when cwd doesn't have a config file", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["."]);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
+
+        });
+
+        describe("Root config trying to ignore subdirectory pattern with config", () => {
+
+            const workDirName = "config-lookup-ignores";
+            const tmpDir = path.resolve(fs.realpathSync(os.tmpdir()), "eslint");
+            const workDir = path.join(tmpDir, workDirName);
+
+            // copy into clean area so as not to get "infected" by other config files
+            before(() => {
+
+                shell.mkdir("-p", workDir);
+                shell.cp("-r", `./tests/fixtures/${workDirName}`, tmpDir);
+            });
+
+            after(() => {
+                shell.rm("-r", workDir);
+            });
+
+            it("should not traverse into subdir1 when parent config file specifies it as ignored and passing in .", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["."]);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
+
+            it("should not traverse into subdir1 when parent config file specifies it as ignored and passing in *", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["*"]);
+
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            const [{ messages }] = await eslint.lintText("foo", { filePath: getFixturePath("plugins/a.js"), warnIgnored: true });
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in subdir1", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir1"]);
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].severity, 1);
-            assert.match(messages[0].message, /ignored/u);
-        });
-    });
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-    describe("config file", () => {
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in subdir1/*.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir1/*.mjs"]);
 
-        it("new instance of ESLint should use the latest version of the config file (ESM)", async () => {
-            const cwd = path.join(getFixturePath(), `config_file_${Date.now()}`);
-            const configFileContent = "export default [{ rules: { semi: ['error', 'always'] } }];";
-            const teardown = createCustomTeardown({
-                cwd,
-                files: {
-                    "package.json": "{ \"type\": \"module\" }",
-                    "eslint.config.js": configFileContent,
-                    "a.js": "foo\nbar;"
-                }
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            await teardown.prepare();
+            it("should reject an error when parent config file specifies subdir1 as ignored and passing in sub*1/*.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
 
-            let eslint = new ESLint({ cwd });
-            let [{ messages }] = await eslint.lintFiles(["a.js"]);
+                return assert.rejects(
+                    () => eslint.lintFiles(["sub*1/*.mjs"]),
+                    /All files matched by 'sub\*1\/\*.mjs' are ignored\./u
+                );
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "missingSemi");
-            assert.strictEqual(messages[0].line, 1);
+            });
 
-            await sleep(100);
-            await fsp.writeFile(path.join(cwd, "eslint.config.js"), configFileContent.replace("always", "never"));
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in subdir1/eslint.config.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir1/eslint.config.mjs"]);
 
-            eslint = new ESLint({ cwd });
-            [{ messages }] = await eslint.lintFiles(["a.js"]);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "extraSemi");
-            assert.strictEqual(messages[0].line, 2);
-        });
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in ../subdir1/eslint.config.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir1/eslint.config.mjs"]);
 
-        it("new instance of ESLint should use the latest version of the config file (CJS)", async () => {
-            const cwd = path.join(getFixturePath(), `config_file_${Date.now()}`);
-            const configFileContent = "module.exports = [{ rules: { semi: ['error', 'always'] } }];";
-            const teardown = createCustomTeardown({
-                cwd,
-                files: {
-                    "eslint.config.js": configFileContent,
-                    "a.js": "foo\nbar;"
-                }
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            await teardown.prepare();
-
-            let eslint = new ESLint({ cwd });
-            let [{ messages }] = await eslint.lintFiles(["a.js"]);
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in ../subdir1/*.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir1/*.mjs"]);
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "missingSemi");
-            assert.strictEqual(messages[0].line, 1);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-            await sleep(100);
-            await fsp.writeFile(path.join(cwd, "eslint.config.js"), configFileContent.replace("always", "never"));
+            it("should traverse into subdir1 when parent config file specifies it as ignored and passing in ../subdir1", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir1"]);
 
-            eslint = new ESLint({ cwd });
-            [{ messages }] = await eslint.lintFiles(["a.js"]);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "extraSemi");
-            assert.strictEqual(messages[0].line, 2);
-        });
+            it("should traverse into subdir3/subsubdir when parent config file specifies it as ignored and passing in subdir3/subsubdir", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir3/subsubdir"]);
 
-        it("new instance of ESLint should use the latest version of the config file (TypeScript)", async () => {
-            const cwd = getFixturePath(`config_file_${Date.now()}`);
-            const configFileContent = "export default [{ rules: { semi: ['error', 'always'] } }];";
-            const teardown = createCustomTeardown({
-                cwd,
-                files: {
-                    "eslint.config.ts": configFileContent,
-                    "a.js": "foo\nbar;"
-                }
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3", "subsubdir", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            await teardown.prepare();
+        });
 
-            let eslint = new ESLint({ cwd, flags: ["unstable_ts_config"] });
-            let [{ messages }] = await eslint.lintFiles(["a.js"]);
+        describe("Root config trying to ignore specific subdirectory with config", () => {
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "missingSemi");
-            assert.strictEqual(messages[0].line, 1);
+            const workDirName = "config-lookup-ignores-2";
+            const tmpDir = path.resolve(fs.realpathSync(os.tmpdir()), "eslint");
+            const workDir = path.join(tmpDir, workDirName);
 
-            await sleep(100);
-            await fsp.writeFile(path.join(cwd, "eslint.config.ts"), configFileContent.replace("always", "never"));
+            // copy into clean area so as not to get "infected" by other config files
+            before(() => {
 
-            eslint = new ESLint({ cwd, flags: ["unstable_ts_config"] });
-            [{ messages }] = await eslint.lintFiles(["a.js"]);
+                shell.mkdir("-p", workDir);
+                shell.cp("-r", `./tests/fixtures/${workDirName}`, tmpDir);
+            });
 
-            assert.strictEqual(messages.length, 1);
-            assert.strictEqual(messages[0].ruleId, "semi");
-            assert.strictEqual(messages[0].messageId, "extraSemi");
-            assert.strictEqual(messages[0].line, 2);
-        });
-    });
+            after(() => {
+                shell.rm("-r", workDir);
+            });
 
-    // only works on a Windows machine
-    if (os.platform() === "win32") {
+            it("should traverse into subdir1 and subdir2 but not subdir3 when parent config file specifies it as ignored and passing in .", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["."]);
 
-        // https://github.com/eslint/eslint/issues/17042
-        describe("with cwd that is using forward slash on Windows", () => {
-            const cwd = getFixturePath("example-app3");
-            const cwdForwardSlash = cwd.replace(/\\/gu, "/");
+                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir1/1.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 1);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+                assert.strictEqual(results[2].filePath, path.resolve(workDir, "subdir2/2.js"));
+                assert.strictEqual(results[2].messages.length, 1);
+                assert.strictEqual(results[2].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[2].messages[0].severity, 1);
+                assert.strictEqual(results[2].suppressedMessages.length, 0);
+            });
 
-            it("should correctly handle ignore patterns", async () => {
-                const engine = new ESLint({ cwd: cwdForwardSlash });
-                const results = await engine.lintFiles(["./src"]);
+            it("should not traverse into subdirectories when passing in *", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["*"]);
 
-                // src/dist/2.js should be ignored
                 assert.strictEqual(results.length, 1);
-                assert.strictEqual(results[0].filePath, path.join(cwd, "src\\1.js"));
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            it("should pass cwd with backslashes to rules", async () => {
-                const engine = new ESLint({
-                    cwd: cwdForwardSlash,
-                    overrideConfigFile: true,
-                    overrideConfig: {
-                        plugins: {
-                            test: require(path.join(cwd, "node_modules", "eslint-plugin-test"))
-                        },
-                        rules: {
-                            "test/report-cwd": "error"
-                        }
-                    }
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in subdir3", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
                 });
-                const results = await engine.lintText("");
+                const results = await eslint.lintFiles(["subdir3"]);
 
-                assert.strictEqual(results[0].messages[0].ruleId, "test/report-cwd");
-                assert.strictEqual(results[0].messages[0].message, cwd);
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3/3.js"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir3/eslint.config.mjs"));
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
             });
 
-            it("should pass cwd with backslashes to formatters", async () => {
-                const engine = new ESLint({
-                    cwd: cwdForwardSlash
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in subdir3/*.js", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
                 });
-                const results = await engine.lintText("");
-                const formatter = await engine.loadFormatter("cwd");
+                const results = await eslint.lintFiles(["subdir3/*.js"]);
 
-                assert.strictEqual(formatter.format(results), cwd);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3/3.js"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-        });
-    }
 
-    describe("config with circular references", () => {
-        it("in 'settings'", async () => {
-            let resolvedSettings = null;
-
-            const circular = {};
-
-            circular.self = circular;
+            it("should lint files in subdir3 and eslint.config.cjs when parent config file specifies subdir3 as ignored and passing in subdir3/*.js, **/*.cjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir3/*.js", "**/*.cjs"]);
 
-            const eslint = new ESLint({
-                overrideConfigFile: true,
-                baseConfig: {
-                    settings: {
-                        sharedData: circular
-                    },
-                    rules: {
-                        "test-plugin/test-rule": 1
-                    }
-                },
-                plugins: {
-                    "test-plugin": {
-                        rules: {
-                            "test-rule": {
-                                create(context) {
-                                    resolvedSettings = context.settings;
-                                    return { };
-                                }
-                            }
-                        }
-                    }
-                }
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir3/3.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 2);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
             });
 
-            await eslint.lintText("debugger;");
-
-            assert.deepStrictEqual(resolvedSettings.sharedData, circular);
-        });
-
-        it("in 'parserOptions'", async () => {
-            let resolvedParserOptions = null;
-
-            const circular = {};
-
-            circular.self = circular;
+            it("should lint files in subdir3 and eslint.config.cjs when parent config file specifies subdir3 as ignored and passing in **/*.cjs, subdir3/*.js", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["**/*.cjs", "subdir3/*.js"]);
 
-            const eslint = new ESLint({
-                overrideConfigFile: true,
-                baseConfig: {
-                    languageOptions: {
-                        parser: {
-                            parse(text, parserOptions) {
-                                resolvedParserOptions = parserOptions;
-                                return espree.parse(text, parserOptions);
-                            }
-                        },
-                        parserOptions: {
-                            testOption: circular
-                        }
-                    }
-                }
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir3/3.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 2);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
             });
 
-            await eslint.lintText("debugger;");
+            it("should traverse into subdir1 and subdir2 but not subdir3 when parent config file specifies it as ignored and passing in sub*/*.js", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["sub*/*.js"]);
 
-            assert.deepStrictEqual(resolvedParserOptions.testOption, circular);
-        });
-    });
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir1/1.js"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir2/2.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 1);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+            });
 
-});
+            it("should reject an error when parent config file specifies subdir3 as ignored and passing in sub*3/*.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
 
-describe("shouldUseFlatConfig", () => {
+                return assert.rejects(
+                    () => eslint.lintFiles(["sub*3/*.mjs"]),
+                    /All files matched by 'sub\*3\/\*\.mjs' are ignored\./u
+                );
+            });
 
-    /**
-     * Check that `shouldUseFlatConfig` returns the expected value from a CWD
-     * with a flat config and one without a flat config.
-     * @param {boolean} expectedValueWithConfig the expected return value of
-     * `shouldUseFlatConfig` when in a directory with a flat config present
-     * @param {boolean} expectedValueWithoutConfig the expected return value of
-     * `shouldUseFlatConfig` when in a directory without any flat config present
-     * @returns {void}
-     */
-    function testShouldUseFlatConfig(expectedValueWithConfig, expectedValueWithoutConfig) {
-        describe("when there is a flat config file present", () => {
-            const originalDir = process.cwd();
+            it("should traverse into subdir1 and subdir2 but not subdir3 when parent config file specifies it as ignored and passing in sub*/*.js and **/*.cjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["sub*/*.js", "**/*.cjs"]);
 
-            beforeEach(() => {
-                process.chdir(__dirname);
+                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir1/1.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 1);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+                assert.strictEqual(results[2].filePath, path.resolve(workDir, "subdir2/2.js"));
+                assert.strictEqual(results[2].messages.length, 1);
+                assert.strictEqual(results[2].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[2].messages[0].severity, 1);
+                assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
 
-            afterEach(() => {
-                process.chdir(originalDir);
-            });
+            it("should traverse into subdir1 and subdir2 but not subdir3 when parent config file specifies it as ignored and passing in **/*.cjs and sub*/*.js", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["**/*.cjs", "sub*/*.js"]);
 
-            it(`is \`${expectedValueWithConfig}\``, async () => {
-                assert.strictEqual(await shouldUseFlatConfig(), expectedValueWithConfig);
+                assert.strictEqual(results.length, 3);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "eslint.config.cjs"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 1);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir1/1.js"));
+                assert.strictEqual(results[1].messages.length, 1);
+                assert.strictEqual(results[1].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[1].messages[0].severity, 1);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+                assert.strictEqual(results[2].filePath, path.resolve(workDir, "subdir2/2.js"));
+                assert.strictEqual(results[2].messages.length, 1);
+                assert.strictEqual(results[2].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[2].messages[0].severity, 1);
+                assert.strictEqual(results[2].suppressedMessages.length, 0);
             });
-        });
 
-        describe("when there is no flat config file present", () => {
-            const originalDir = process.cwd();
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in subdir3/eslint.config.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: workDir
+                });
+                const results = await eslint.lintFiles(["subdir3/eslint.config.mjs"]);
 
-            beforeEach(() => {
-                process.chdir(os.tmpdir());
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
 
-            afterEach(() => {
-                process.chdir(originalDir);
-            });
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in ../subdir3/eslint.config.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir3/eslint.config.mjs"]);
 
-            it(`is \`${expectedValueWithoutConfig}\``, async () => {
-                assert.strictEqual(await shouldUseFlatConfig(), expectedValueWithoutConfig);
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
             });
-        });
-    }
 
-    describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is `'true'`", () => {
-        beforeEach(() => {
-            process.env.ESLINT_USE_FLAT_CONFIG = true;
-        });
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in ../subdir3/*.mjs", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir3/*.mjs"]);
 
-        afterEach(() => {
-            delete process.env.ESLINT_USE_FLAT_CONFIG;
-        });
+                assert.strictEqual(results.length, 1);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3", "eslint.config.mjs"));
+                assert.strictEqual(results[0].messages.length, 0);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+            });
 
-        testShouldUseFlatConfig(true, true);
-    });
+            it("should traverse into subdir3 when parent config file specifies it as ignored and passing in ../subdir3", async () => {
+                eslint = new ESLint({
+                    flags,
+                    cwd: path.resolve(workDir, "subdir2")
+                });
+                const results = await eslint.lintFiles(["../subdir3"]);
 
-    describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is `'false'`", () => {
-        beforeEach(() => {
-            process.env.ESLINT_USE_FLAT_CONFIG = false;
-        });
+                assert.strictEqual(results.length, 2);
+                assert.strictEqual(results[0].filePath, path.resolve(workDir, "subdir3/3.js"));
+                assert.strictEqual(results[0].messages.length, 1);
+                assert.strictEqual(results[0].messages[0].ruleId, "no-unused-vars");
+                assert.strictEqual(results[0].messages[0].severity, 2);
+                assert.strictEqual(results[0].suppressedMessages.length, 0);
+                assert.strictEqual(results[1].filePath, path.resolve(workDir, "subdir3/eslint.config.mjs"));
+                assert.strictEqual(results[1].messages.length, 0);
+                assert.strictEqual(results[1].suppressedMessages.length, 0);
+            });
 
-        afterEach(() => {
-            delete process.env.ESLINT_USE_FLAT_CONFIG;
         });
 
-        testShouldUseFlatConfig(false, false);
-    });
-
-    describe("when the env variable `ESLINT_USE_FLAT_CONFIG` is unset", () => {
-        testShouldUseFlatConfig(true, true);
     });
 });
