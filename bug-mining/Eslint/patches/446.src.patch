diff --git a/lib/rules/arrow-body-style.js b/lib/rules/arrow-body-style.js
index b2167fde7..5b8a5f011 100644
--- a/lib/rules/arrow-body-style.js
+++ b/lib/rules/arrow-body-style.js
@@ -87,17 +87,17 @@ module.exports = {
         }
 
         /**
-         * Gets the closing parenthesis which is the pair of the given opening parenthesis.
-         * @param {Token} token The opening parenthesis token to get.
+         * Gets the closing parenthesis by the given node.
+         * @param {ASTNode} node first node after an opening parenthesis.
          * @returns {Token} The found closing parenthesis token.
          */
-        function findClosingParen(token) {
-            let node = sourceCode.getNodeByRangeIndex(token.range[0]);
+        function findClosingParen(node) {
+            let nodeToCheck = node;
 
-            while (!astUtils.isParenthesised(sourceCode, node)) {
-                node = node.parent;
+            while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {
+                nodeToCheck = nodeToCheck.parent;
             }
-            return sourceCode.getTokenAfter(node);
+            return sourceCode.getTokenAfter(nodeToCheck);
         }
 
         /**
@@ -226,12 +226,22 @@ module.exports = {
                             const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
                             const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });
                             const lastToken = sourceCode.getLastToken(node);
-                            const isParenthesisedObjectLiteral =
+
+                            let parenthesisedObjectLiteral = null;
+
+                            if (
                                 astUtils.isOpeningParenToken(firstTokenAfterArrow) &&
-                                astUtils.isOpeningBraceToken(secondTokenAfterArrow);
+                                astUtils.isOpeningBraceToken(secondTokenAfterArrow)
+                            ) {
+                                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);
+
+                                if (braceNode.type === "ObjectExpression") {
+                                    parenthesisedObjectLiteral = braceNode;
+                                }
+                            }
 
                             // If the value is object literal, remove parentheses which were forced by syntax.
-                            if (isParenthesisedObjectLiteral) {
+                            if (parenthesisedObjectLiteral) {
                                 const openingParenToken = firstTokenAfterArrow;
                                 const openingBraceToken = secondTokenAfterArrow;
 
@@ -247,7 +257,7 @@ module.exports = {
                                 }
 
                                 // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()
-                                fixes.push(fixer.remove(findClosingParen(openingBraceToken)));
+                                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));
                                 fixes.push(fixer.insertTextAfter(lastToken, "}"));
 
                             } else {
diff --git a/tests/lib/rules/arrow-body-style.js b/tests/lib/rules/arrow-body-style.js
index 7a8de4fe5..0ccb440d3 100644
--- a/tests/lib/rules/arrow-body-style.js
+++ b/tests/lib/rules/arrow-body-style.js
@@ -810,6 +810,14 @@ ruleTester.run("arrow-body-style", rule, {
             `,
             options: ["always"],
             errors: [{ messageId: "expectedBlock" }]
+        },
+
+        // https://github.com/eslint/eslint/issues/14633
+        {
+            code: "const createMarker = (color) => ({ latitude, longitude }, index) => {};",
+            output: "const createMarker = (color) => {return ({ latitude, longitude }, index) => {}};",
+            options: ["always"],
+            errors: [{ messageId: "expectedBlock" }]
         }
     ]
 });
