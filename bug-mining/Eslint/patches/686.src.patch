diff --git a/docs/src/extend/scope-manager-interface.md b/docs/src/extend/scope-manager-interface.md
index 314507375..612a6dc4f 100644
--- a/docs/src/extend/scope-manager-interface.md
+++ b/docs/src/extend/scope-manager-interface.md
@@ -374,7 +374,7 @@ Those members are defined but not used in ESLint.
 | `"CatchClause"`            | `CatchClause`                                                              |
 | `"ClassName"`              | `ClassDeclaration` or `ClassExpression`                                    |
 | `"FunctionName"`           | `FunctionDeclaration` or `FunctionExpression`                              |
-| `"ImplicitGlobalVariable"` | `AssignmentExpression`                                                     |
+| `"ImplicitGlobalVariable"` | `AssignmentExpression` or `ForInStatement` or `ForOfStatement`             |
 | `"ImportBinding"`          | `ImportSpecifier`, `ImportDefaultSpecifier`, or `ImportNamespaceSpecifier` |
 | `"Parameter"`              | `FunctionDeclaration`, `FunctionExpression`, or `ArrowFunctionExpression`  |
 | `"Variable"`               | `VariableDeclarator`                                                       |
diff --git a/lib/languages/js/source-code/source-code.js b/lib/languages/js/source-code/source-code.js
index 65ce4d095..6776f1e69 100644
--- a/lib/languages/js/source-code/source-code.js
+++ b/lib/languages/js/source-code/source-code.js
@@ -316,6 +316,36 @@ function addDeclaredGlobals(
 
 		return true;
 	});
+
+	/*
+	 * "implicit" contains information about implicit global variables (those created
+	 * implicitly by assigning values to undeclared variables in non-strict code).
+	 * Since we augment the global scope using configuration, we need to remove
+	 * the ones that were added by configuration, as they are either built-in
+	 * or declared elsewhere, therefore not implicit.
+	 * Since the "implicit" property was not documented, first we'll check if it exists
+	 * because it's possible that not all custom scope managers create this property.
+	 * If it exists, we assume it has properties `variables` and `set`. Property
+	 * `left` is considered optional (for example, typescript-eslint's scope manage
+	 * has this property named `leftToBeResolved`).
+	 */
+	const { implicit } = globalScope;
+	if (typeof implicit === "object" && implicit !== null) {
+		implicit.variables = implicit.variables.filter(variable => {
+			const name = variable.name;
+			if (globalScope.set.has(name)) {
+				implicit.set.delete(name);
+				return false;
+			}
+			return true;
+		});
+
+		if (implicit.left) {
+			implicit.left = implicit.left.filter(
+				reference => !globalScope.set.has(reference.identifier.name),
+			);
+		}
+	}
 }
 
 /**
diff --git a/lib/rules/no-implicit-globals.js b/lib/rules/no-implicit-globals.js
index 7326a115e..c291cd86b 100644
--- a/lib/rules/no-implicit-globals.js
+++ b/lib/rules/no-implicit-globals.js
@@ -5,6 +5,12 @@
 
 "use strict";
 
+const ASSIGNMENT_NODES = new Set([
+	"AssignmentExpression",
+	"ForInStatement",
+	"ForOfStatement",
+]);
+
 //------------------------------------------------------------------------------
 // Rule Definition
 //------------------------------------------------------------------------------
@@ -142,27 +148,37 @@ module.exports = {
 							}
 						}
 					});
-				});
 
-				// Undeclared assigned variables.
-				scope.implicit.variables.forEach(variable => {
-					const scopeVariable = scope.set.get(variable.name);
-					let messageId;
+					if (
+						isReadonlyEslintGlobalVariable &&
+						variable.defs.length === 0
+					) {
+						variable.references.forEach(reference => {
+							if (reference.isWrite() && !reference.isRead()) {
+								let assignmentParent =
+									reference.identifier.parent;
+
+								while (
+									assignmentParent &&
+									!ASSIGNMENT_NODES.has(assignmentParent.type)
+								) {
+									assignmentParent = assignmentParent.parent;
+								}
 
-					if (scopeVariable) {
-						// ESLint global variable
-						if (scopeVariable.writeable) {
-							return;
-						}
-						messageId = "assignmentToReadonlyGlobal";
-					} else {
-						// Reference to an unknown variable, possible global leak.
-						messageId = "globalVariableLeak";
+								report(
+									assignmentParent ?? reference.identifier,
+									"assignmentToReadonlyGlobal",
+								);
+							}
+						});
 					}
+				});
 
+				// Undeclared assigned variables.
+				scope.implicit.variables.forEach(variable => {
 					// def.node is an AssignmentExpression, ForInStatement or ForOfStatement.
 					variable.defs.forEach(def => {
-						report(def.node, messageId);
+						report(def.node, "globalVariableLeak");
 					});
 				});
 			},
diff --git a/tests/lib/languages/js/source-code/source-code.js b/tests/lib/languages/js/source-code/source-code.js
index 058669ba6..fcf7baf27 100644
--- a/tests/lib/languages/js/source-code/source-code.js
+++ b/tests/lib/languages/js/source-code/source-code.js
@@ -3606,4 +3606,216 @@ describe("SourceCode", () => {
 			assert.isNull(problem.ruleId);
 		});
 	});
+
+	describe("finalize()", () => {
+		it("should remove ECMAScript globals from global scope's `implicit`", () => {
+			const code = "Array = 1; Foo = 1; Promise = 1; Array; Foo; Promise";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				ecmaVersion: 6,
+			});
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyLanguageOptions({
+				ecmaVersion: 2015,
+			});
+
+			sourceCode.finalize();
+
+			const globalScope = sourceCode.scopeManager.scopes[0];
+			const { implicit } = globalScope;
+
+			assert.deepStrictEqual(
+				[...implicit.set].map(([name]) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.variables.map(({ name }) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.left.map(reference => reference.identifier.name),
+				["Foo", "Foo"],
+			);
+		});
+
+		it("should remove custom globals from global scope's `implicit`", () => {
+			const code = "Bar = 1; Foo = 1; Baz = 1; Bar; Foo; Baz";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				ecmaVersion: 6,
+			});
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyLanguageOptions({
+				ecmaVersion: 2015,
+				globals: {
+					Bar: "writable",
+					Baz: "readonly",
+				},
+			});
+
+			sourceCode.finalize();
+
+			const globalScope = sourceCode.scopeManager.scopes[0];
+			const { implicit } = globalScope;
+
+			assert.deepStrictEqual(
+				[...implicit.set].map(([name]) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.variables.map(({ name }) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.left.map(reference => reference.identifier.name),
+				["Foo", "Foo"],
+			);
+		});
+
+		it("should remove commonjs globals from global scope's `implicit`", () => {
+			const code =
+				"exports = {}; Foo = 1; require = () => {}; exports; Foo; require";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				nodejsScope: true,
+				ecmaVersion: 6,
+			});
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyLanguageOptions({
+				ecmaVersion: 2015,
+				sourceType: "commonjs",
+			});
+
+			sourceCode.finalize();
+
+			const globalScope = sourceCode.scopeManager.scopes[0];
+			const { implicit } = globalScope;
+
+			assert.deepStrictEqual(
+				[...implicit.set].map(([name]) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.variables.map(({ name }) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.left.map(reference => reference.identifier.name),
+				["Foo", "Foo"],
+			);
+		});
+
+		it("should remove inline globals from global scope's `implicit`", () => {
+			const code =
+				"/* globals Bar: writable, Baz: readonly */ Bar = 1; Foo = 1; Baz = 1; Bar; Foo; Baz";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				ecmaVersion: 6,
+			});
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyInlineConfig();
+			sourceCode.finalize();
+
+			const globalScope = sourceCode.scopeManager.scopes[0];
+			const { implicit } = globalScope;
+
+			assert.deepStrictEqual(
+				[...implicit.set].map(([name]) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.variables.map(({ name }) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.left.map(reference => reference.identifier.name),
+				["Foo", "Foo"],
+			);
+		});
+
+		it("should not crash if global scope doesn't have `implicit` property", () => {
+			const code = "Array = 1; Foo = 1; Promise = 1; Array; Foo; Promise";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				ecmaVersion: 6,
+			});
+
+			const globalScope = scopeManager.scopes[0];
+			delete globalScope.implicit;
+
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyLanguageOptions({
+				ecmaVersion: 2015,
+			});
+
+			// should not throw
+			sourceCode.finalize();
+		});
+
+		it("should not crash if global scope doesn't have `implicit.left` property", () => {
+			const code = "Array = 1; Foo = 1; Promise = 1; Array; Foo; Promise";
+			const ast = espree.parse(code, DEFAULT_CONFIG);
+			const scopeManager = eslintScope.analyze(ast, {
+				ignoreEval: true,
+				ecmaVersion: 6,
+			});
+
+			const globalScope = scopeManager.scopes[0];
+			delete globalScope.implicit.left;
+
+			const sourceCode = new SourceCode({
+				text: code,
+				ast,
+				scopeManager,
+			});
+
+			sourceCode.applyLanguageOptions({
+				ecmaVersion: 2015,
+			});
+
+			// should not throw
+			sourceCode.finalize();
+
+			const { implicit } = globalScope;
+
+			assert.deepStrictEqual(
+				[...implicit.set].map(([name]) => name),
+				["Foo"],
+			);
+			assert.deepStrictEqual(
+				implicit.variables.map(({ name }) => name),
+				["Foo"],
+			);
+		});
+	});
 });
diff --git a/tests/lib/rules/no-implicit-globals.js b/tests/lib/rules/no-implicit-globals.js
index ad393e290..e35fc9974 100644
--- a/tests/lib/rules/no-implicit-globals.js
+++ b/tests/lib/rules/no-implicit-globals.js
@@ -372,6 +372,14 @@ ruleTester.run("no-implicit-globals", rule, {
 		"foo",
 		"foo + bar",
 		"foo(bar)",
+		"foo++",
+		"--foo",
+		"foo += 1",
+		{
+			code: "foo ||= 1",
+			languageOptions: { ecmaVersion: 2021 },
+		},
+		"/* global foo: writable*/ foo = bar",
 
 		// Leaks are not possible in strict mode (explicit or implicit). Therefore, rule doesn't report assignments in strict mode.
 		"'use strict';foo = 1;",
@@ -459,6 +467,15 @@ ruleTester.run("no-implicit-globals", rule, {
 		"Object['assign'] = 1;",
 		"/*global foo:readonly*/ foo.bar = 1;",
 
+		// This rule doesn't disallow updates of readonly globals
+		"/*global foo:readonly*/ foo++;",
+		"/*global foo:readonly*/ --foo;",
+		"/*global foo:readonly*/ foo += 1;",
+		{
+			code: "/*global foo:readonly*/ foo ||= 1;",
+			languageOptions: { ecmaVersion: 2021 },
+		},
+
 		//------------------------------------------------------------------------------
 		// exported
 		//------------------------------------------------------------------------------
@@ -782,6 +799,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 27,
 					type: "AssignmentExpression",
 				},
 			],
@@ -822,6 +840,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 24,
 					type: "AssignmentExpression",
 				},
 			],
@@ -855,10 +874,12 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 1,
 					type: "AssignmentExpression",
 				},
 				{
 					message: leakMessage,
+					column: 10,
 					type: "AssignmentExpression",
 				},
 			],
@@ -868,10 +889,12 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 1,
 					type: "AssignmentExpression",
 				},
 				{
 					message: leakMessage,
+					column: 7,
 					type: "AssignmentExpression",
 				},
 			],
@@ -881,6 +904,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 31,
 					type: "AssignmentExpression",
 				},
 			],
@@ -890,6 +914,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 25,
 					type: "AssignmentExpression",
 				},
 			],
@@ -916,6 +941,7 @@ ruleTester.run("no-implicit-globals", rule, {
 				},
 				{
 					message: leakMessage,
+					column: 11,
 					type: "AssignmentExpression",
 				},
 			],
@@ -925,6 +951,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 35,
 					type: "AssignmentExpression",
 				},
 			],
@@ -944,10 +971,12 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 1,
 					type: "AssignmentExpression",
 				},
 				{
 					message: leakMessage,
+					column: 1,
 					type: "AssignmentExpression",
 				},
 			],
@@ -958,6 +987,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 25,
 					type: "AssignmentExpression",
 				},
 			],
@@ -968,6 +998,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 25,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1046,6 +1077,15 @@ ruleTester.run("no-implicit-globals", rule, {
 				},
 			],
 		},
+		{
+			code: "var Array = 1; Array = 2;",
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
 		{
 			code: "/*global foo:readonly*/ var foo",
 			errors: [
@@ -1064,6 +1104,53 @@ ruleTester.run("no-implicit-globals", rule, {
 				},
 			],
 		},
+		{
+			code: "/*global foo:readonly*/ var foo; foo = 1;",
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
+		{
+			code: "/*global foo:readonly*/ for (var foo in obj);",
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
+		{
+			code: "/*global foo:readonly*/ for (var foo in obj); foo = 1;",
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
+		{
+			code: "/*global foo:readonly*/ for (var foo of arr);",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
+		{
+			code: "/*global foo:readonly*/ for (var foo of arr); foo = 1;",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
 		{
 			code: "/*global foo:readonly*/ function foo() {}",
 			errors: [
@@ -1084,6 +1171,17 @@ ruleTester.run("no-implicit-globals", rule, {
 				},
 			],
 		},
+		{
+			code: "/*global foo:readonly*/ const foo = 1; foo = 2;",
+			options: [{ lexicalBindings: true }],
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
 		{
 			code: "/*global foo:readonly*/ let foo",
 			options: [{ lexicalBindings: true }],
@@ -1106,6 +1204,17 @@ ruleTester.run("no-implicit-globals", rule, {
 				},
 			],
 		},
+		{
+			code: "/*global foo:readonly*/ let foo; foo = 1;",
+			options: [{ lexicalBindings: true }],
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyRedeclarationMessage,
+					type: "VariableDeclarator",
+				},
+			],
+		},
 		{
 			code: "/*global Foo:readonly*/ class Foo {}",
 			options: [{ lexicalBindings: true }],
@@ -1124,10 +1233,12 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: readonlyAssignmentMessage,
+					column: 40,
 					type: "AssignmentExpression",
 				},
 				{
 					message: readonlyAssignmentMessage,
+					column: 46,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1137,6 +1248,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: readonlyAssignmentMessage,
+					column: 46,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1146,6 +1258,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: readonlyAssignmentMessage,
+					column: 40,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1155,10 +1268,12 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: readonlyAssignmentMessage,
+					column: 26,
 					type: "AssignmentExpression",
 				},
 				{
 					message: leakMessage,
+					column: 32,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1168,10 +1283,88 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 26,
+					type: "AssignmentExpression",
+				},
+				{
+					message: readonlyAssignmentMessage,
+					column: 32,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo*/ [foo] = arr",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 16,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo, bar: readonly*/ [foo, bar] = arr",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 31,
+					type: "AssignmentExpression",
+				},
+				{
+					message: readonlyAssignmentMessage,
+					column: 31,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo: readonly*/ ({ foo } = obj)",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 27,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo: readonly*/ ({ 'a': foo } = obj)",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 27,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo: readonly*/ ({ 'a': { 'b': [foo] } } = obj)",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 27,
+					type: "AssignmentExpression",
+				},
+			],
+		},
+		{
+			code: "/*global foo, bar: readonly*/ ({ foo, 'a': bar } = obj)",
+			languageOptions: { ecmaVersion: 2015 },
+			errors: [
+				{
+					message: readonlyAssignmentMessage,
+					column: 32,
 					type: "AssignmentExpression",
 				},
 				{
 					message: readonlyAssignmentMessage,
+					column: 32,
 					type: "AssignmentExpression",
 				},
 			],
@@ -1629,6 +1822,7 @@ ruleTester.run("no-implicit-globals", rule, {
 			errors: [
 				{
 					message: leakMessage,
+					column: 46,
 					type: "AssignmentExpression",
 				},
 			],
