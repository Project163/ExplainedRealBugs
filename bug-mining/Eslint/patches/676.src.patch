diff --git a/docs/src/use/command-line-interface.md b/docs/src/use/command-line-interface.md
index ccc795e7d..626039b80 100644
--- a/docs/src/use/command-line-interface.md
+++ b/docs/src/use/command-line-interface.md
@@ -93,6 +93,7 @@ Basic configuration:
   -c, --config path::String       Use this configuration instead of eslint.config.js, eslint.config.mjs, or
                                   eslint.config.cjs
   --inspect-config                Open the config inspector with the current configuration
+  --ext [String]                  Specify additional file extensions to lint
   --global [String]               Define global variables
   --parser String                 Specify the parser to be used
   --parser-options Object         Specify parser options
@@ -219,34 +220,32 @@ Details about the global variables defined by each environment are available in
 
 #### `--ext`
 
-**eslintrc Mode Only.** If you are using flat config (`eslint.config.js`), please see [migration guide](./configure/migration-guide#--ext).
-
-This option allows you to specify which file extensions ESLint uses when searching for target files in the directories you specify.
+This option allows you to specify additional file extensions to lint.
 
 * **Argument Type**: String. File extension.
 * **Multiple Arguments**: Yes
-* **Default Value**: `.js` and the files that match the `overrides` entries of your configuration.
+* **Default Value**: By default, ESLint lints files with extensions `.js`, `.mjs`, `.cjs`, and additional extensions [specified in the configuration file](configure/configuration-files#specifying-files-with-arbitrary-extensions).
 
-`--ext` is only used when the patterns to lint are directories. If you use glob patterns or file names, then `--ext` is ignored. For example, `npx eslint "lib/*" --ext .js` matches all files within the `lib/` directory, regardless of extension.
+This option is primarely intended for use in combination with the `--no-config-lookup` option, since in that case there is no configuration file in which the additional extensions would be specified.
 
 ##### `--ext` example
 
 {{ npx_tabs ({
     package: "eslint",
     args: [".", "--ext", ".ts"],
-    comment: "Use only .ts extension"
+    comment: "Include .ts files"
 }) }}
 
 {{ npx_tabs ({
     package: "eslint",
-    args: [".", "--ext", ".js", "--ext", ".ts"],
-    comment: "Use both .js and .ts"
+    args: [".", "--ext", ".ts", "--ext", ".tsx"],
+    comment: "Include .ts and .tsx files"
 }) }}
 
 {{ npx_tabs ({
     package: "eslint",
-    args: [".", "--ext", ".js,.ts"],
-    comment: "Also use both .js and .ts"
+    args: [".", "--ext", ".ts,.tsx"],
+    comment: "Also include .ts and .tsx files"
 }) }}
 
 #### `--global`
diff --git a/lib/cli.js b/lib/cli.js
index 26d2de7f4..1238efda7 100644
--- a/lib/cli.js
+++ b/lib/cli.js
@@ -192,6 +192,12 @@ async function translateOptions({
             overrideConfig[0].plugins = await loadPlugins(importer, plugin);
         }
 
+        if (ext) {
+            overrideConfig.push({
+                files: ext.map(extension => `**/*${extension.startsWith(".") ? "" : "."}${extension}`)
+            });
+        }
+
     } else {
         overrideConfigFile = config;
 
@@ -489,6 +495,23 @@ const cli = {
             return 2;
         }
 
+        if (usingFlatConfig && options.ext) {
+
+            // Passing `--ext ""` results in `options.ext` being an empty array.
+            if (options.ext.length === 0) {
+                log.error("The --ext option value cannot be empty.");
+                return 2;
+            }
+
+            // Passing `--ext ,ts` results in an empty string at index 0. Passing `--ext ts,,tsx` results in an empty string at index 1.
+            const emptyStringIndex = options.ext.indexOf("");
+
+            if (emptyStringIndex >= 0) {
+                log.error(`The --ext option arguments cannot be empty strings. Found an empty string at index ${emptyStringIndex}.`);
+                return 2;
+            }
+        }
+
         const ActiveESLint = usingFlatConfig ? ESLint : LegacyESLint;
         const eslintOptions = await translateOptions(options, usingFlatConfig ? "flat" : "eslintrc");
         const engine = new ActiveESLint(eslintOptions);
diff --git a/lib/options.js b/lib/options.js
index e196f88a2..51d077f2f 100644
--- a/lib/options.js
+++ b/lib/options.js
@@ -123,6 +123,12 @@ module.exports = function(usingFlatConfig) {
             type: "[String]",
             description: "Specify JavaScript file extensions"
         };
+    } else {
+        extFlag = {
+            option: "ext",
+            type: "[String]",
+            description: "Specify additional file extensions to lint"
+        };
     }
 
     let resolvePluginsFlag;
diff --git a/tests/fixtures/file-extensions/a.js b/tests/fixtures/file-extensions/a.js
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/a.js
@@ -0,0 +1 @@
+// empty
diff --git a/tests/fixtures/file-extensions/b.mjs b/tests/fixtures/file-extensions/b.mjs
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/b.mjs
@@ -0,0 +1 @@
+// empty
diff --git a/tests/fixtures/file-extensions/c.cjs b/tests/fixtures/file-extensions/c.cjs
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/c.cjs
@@ -0,0 +1 @@
+// empty
diff --git a/tests/fixtures/file-extensions/d.jsx b/tests/fixtures/file-extensions/d.jsx
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/d.jsx
@@ -0,0 +1 @@
+// empty
diff --git a/tests/fixtures/file-extensions/eslint.config.js b/tests/fixtures/file-extensions/eslint.config.js
new file mode 100644
index 000000000..8053d6332
--- /dev/null
+++ b/tests/fixtures/file-extensions/eslint.config.js
@@ -0,0 +1 @@
+module.exports = [{ files: ["**/*.jsx"] }];
diff --git a/tests/fixtures/file-extensions/f.ts b/tests/fixtures/file-extensions/f.ts
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/f.ts
@@ -0,0 +1 @@
+// empty
diff --git a/tests/fixtures/file-extensions/foots b/tests/fixtures/file-extensions/foots
new file mode 100644
index 000000000..3926eb28c
--- /dev/null
+++ b/tests/fixtures/file-extensions/foots
@@ -0,0 +1 @@
+// this file should not be linted with --ext ts
diff --git a/tests/fixtures/file-extensions/g.tsx b/tests/fixtures/file-extensions/g.tsx
new file mode 100644
index 000000000..8b1a39374
--- /dev/null
+++ b/tests/fixtures/file-extensions/g.tsx
@@ -0,0 +1 @@
+// empty
diff --git a/tests/lib/cli.js b/tests/lib/cli.js
index a509428b9..84b2cd670 100644
--- a/tests/lib/cli.js
+++ b/tests/lib/cli.js
@@ -218,9 +218,9 @@ describe("cli", () => {
                 it(`should use it when an eslint.config.js is present and useFlatConfig is true:${configType}`, async () => {
                     process.cwd = getFixturePath;
 
-                    const exitCode = await cli.execute(`--no-ignore --ext .js ${getFixturePath("files")}`, null, useFlatConfig);
+                    const exitCode = await cli.execute(`--no-ignore --env es2024 ${getFixturePath("files")}`, null, useFlatConfig);
 
-                    // When flat config is used, we get an exit code of 2 because the --ext option is unrecognized.
+                    // When flat config is used, we get an exit code of 2 because the --env option is unrecognized.
                     assert.strictEqual(exitCode, useFlatConfig ? 2 : 0);
                 });
 
@@ -228,7 +228,7 @@ describe("cli", () => {
                     process.env.ESLINT_USE_FLAT_CONFIG = "false";
                     process.cwd = getFixturePath;
 
-                    const exitCode = await cli.execute(`--no-ignore --ext .js ${getFixturePath("files")}`, null, useFlatConfig);
+                    const exitCode = await cli.execute(`--no-ignore --env es2024 ${getFixturePath("files")}`, null, useFlatConfig);
 
                     assert.strictEqual(exitCode, 0);
 
@@ -245,9 +245,9 @@ describe("cli", () => {
                     // Set the CWD to outside the fixtures/ directory so that no eslint.config.js is found
                     process.cwd = () => getFixturePath("..");
 
-                    const exitCode = await cli.execute(`--no-ignore --ext .js ${getFixturePath("files")}`, null, useFlatConfig);
+                    const exitCode = await cli.execute(`--no-ignore --env es2024 ${getFixturePath("files")}`, null, useFlatConfig);
 
-                    // When flat config is used, we get an exit code of 2 because the --ext option is unrecognized.
+                    // When flat config is used, we get an exit code of 2 because the --env option is unrecognized.
                     assert.strictEqual(exitCode, useFlatConfig ? 2 : 0);
                 });
             });
@@ -2027,6 +2027,129 @@ describe("cli", () => {
                 });
             });
 
+            describe("--ext option", () => {
+
+                let originalCwd;
+
+                beforeEach(() => {
+                    originalCwd = process.cwd();
+                    process.chdir(getFixturePath("file-extensions"));
+                });
+
+                afterEach(() => {
+                    process.chdir(originalCwd);
+                    originalCwd = void 0;
+                });
+
+                it("when not provided, without config file only default extensions should be linted", async () => {
+                    const exitCode = await cli.execute("--no-config-lookup -f json .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "eslint.config.js"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it("when not provided, only default extensions and extensions from the config file should be linted", async () => {
+                    const exitCode = await cli.execute("-f json .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "d.jsx", "eslint.config.js"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it("should include an additional extension when specified with dot", async () => {
+                    const exitCode = await cli.execute("-f json --ext .ts .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "d.jsx", "eslint.config.js", "f.ts"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it("should include an additional extension when specified without dot", async () => {
+                    const exitCode = await cli.execute("-f json --ext ts .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    // should not include "foots"
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "d.jsx", "eslint.config.js", "f.ts"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it("should include multiple additional extensions when specified by repeating the option", async () => {
+                    const exitCode = await cli.execute("-f json --ext .ts --ext tsx .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "d.jsx", "eslint.config.js", "f.ts", "g.tsx"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it("should include multiple additional extensions when specified with comma-delimited list", async () => {
+                    const exitCode = await cli.execute("-f json --ext .ts,.tsx .", null, true);
+
+                    assert.strictEqual(exitCode, 0, "exit code should be 0");
+
+                    const results = JSON.parse(log.info.args[0][0]);
+
+                    assert.deepStrictEqual(
+                        results.map(({ filePath }) => filePath).sort(),
+                        ["a.js", "b.mjs", "c.cjs", "d.jsx", "eslint.config.js", "f.ts", "g.tsx"].map(filename => path.resolve(filename))
+                    );
+                });
+
+                it('should fail when passing --ext ""', async () => {
+
+                    // When passing "" on command line, its corresponding item in process.argv[] is an empty string
+                    const exitCode = await cli.execute(["argv0", "argv1", "--ext", ""], null, true);
+
+                    assert.strictEqual(exitCode, 2, "exit code should be 2");
+                    assert.strictEqual(log.info.callCount, 0, "log.info should not be called");
+                    assert.strictEqual(log.error.callCount, 1, "log.error should be called once");
+                    assert.deepStrictEqual(log.error.firstCall.args[0], "The --ext option value cannot be empty.");
+                });
+
+                it("should fail when passing --ext ,ts", async () => {
+                    const exitCode = await cli.execute("--ext ,ts", null, true);
+
+                    assert.strictEqual(exitCode, 2, "exit code should be 2");
+                    assert.strictEqual(log.info.callCount, 0, "log.info should not be called");
+                    assert.strictEqual(log.error.callCount, 1, "log.error should be called once");
+                    assert.deepStrictEqual(log.error.firstCall.args[0], "The --ext option arguments cannot be empty strings. Found an empty string at index 0.");
+                });
+
+                it("should fail when passing --ext ts,,tsx", async () => {
+                    const exitCode = await cli.execute("--ext ts,,tsx", null, true);
+
+                    assert.strictEqual(exitCode, 2, "exit code should be 2");
+                    assert.strictEqual(log.info.callCount, 0, "log.info should not be called");
+                    assert.strictEqual(log.error.callCount, 1, "log.error should be called once");
+                    assert.deepStrictEqual(log.error.firstCall.args[0], "The --ext option arguments cannot be empty strings. Found an empty string at index 1.");
+                });
+            });
+
             describe("unstable_config_lookup_from_file", () => {
 
                 const flag = "unstable_config_lookup_from_file";
diff --git a/tests/lib/options.js b/tests/lib/options.js
index 64d84c16c..f137e7980 100644
--- a/tests/lib/options.js
+++ b/tests/lib/options.js
@@ -318,40 +318,39 @@ describe("options", () => {
                     assert.strictEqual(currentOptions.printConfig, "file.js");
                 });
             });
-        });
 
-    });
+            describe("--ext", () => {
+                it("should return an array with one item when passed .jsx", () => {
+                    const currentOptions = options.parse("--ext .jsx");
 
+                    assert.isArray(currentOptions.ext);
+                    assert.strictEqual(currentOptions.ext[0], ".jsx");
+                });
 
-    describe("--ext", () => {
-        it("should return an array with one item when passed .jsx", () => {
-            const currentOptions = eslintrcOptions.parse("--ext .jsx");
+                it("should return an array with two items when passed .js and .jsx", () => {
+                    const currentOptions = options.parse("--ext .jsx --ext .js");
 
-            assert.isArray(currentOptions.ext);
-            assert.strictEqual(currentOptions.ext[0], ".jsx");
-        });
+                    assert.isArray(currentOptions.ext);
+                    assert.strictEqual(currentOptions.ext[0], ".jsx");
+                    assert.strictEqual(currentOptions.ext[1], ".js");
+                });
 
-        it("should return an array with two items when passed .js and .jsx", () => {
-            const currentOptions = eslintrcOptions.parse("--ext .jsx --ext .js");
+                it("should return an array with two items when passed .jsx,.js", () => {
+                    const currentOptions = options.parse("--ext .jsx,.js");
 
-            assert.isArray(currentOptions.ext);
-            assert.strictEqual(currentOptions.ext[0], ".jsx");
-            assert.strictEqual(currentOptions.ext[1], ".js");
-        });
+                    assert.isArray(currentOptions.ext);
+                    assert.strictEqual(currentOptions.ext[0], ".jsx");
+                    assert.strictEqual(currentOptions.ext[1], ".js");
+                });
 
-        it("should return an array with two items when passed .jsx,.js", () => {
-            const currentOptions = eslintrcOptions.parse("--ext .jsx,.js");
+                it("should not exist when not passed", () => {
+                    const currentOptions = options.parse("");
 
-            assert.isArray(currentOptions.ext);
-            assert.strictEqual(currentOptions.ext[0], ".jsx");
-            assert.strictEqual(currentOptions.ext[1], ".js");
+                    assert.notProperty(currentOptions, "ext");
+                });
+            });
         });
 
-        it("should not exist when not passed", () => {
-            const currentOptions = eslintrcOptions.parse("");
-
-            assert.notProperty(currentOptions, "ext");
-        });
     });
 
     describe("--rulesdir", () => {
