diff --git a/docs/rules/no-empty-function.md b/docs/rules/no-empty-function.md
index c0c1a1ea9..0f8691c82 100644
--- a/docs/rules/no-empty-function.md
+++ b/docs/rules/no-empty-function.md
@@ -177,6 +177,8 @@ This rule has an option to allow specific kinds of functions to be empty.
     * `"getters"` - Getters.
     * `"setters"` - Setters.
     * `"constructors"` - Class constructors.
+    * `"asyncFunctions"` - Async functions.
+    * `"asyncMethods"` - Async class methods and method shorthands of object literals.
 
 #### allow: functions
 
@@ -307,6 +309,35 @@ class A {
 }
 ```
 
+#### allow: asyncFunctions
+
+Examples of **correct** code for the `{ "allow": ["asyncFunctions"] }` options:
+
+```js
+/*eslint no-empty-function: ["error", { "allow": ["asyncFunctions"] }]*/
+/*eslint-env es2017*/
+
+async function a(){}
+```
+
+#### allow: asyncMethods
+
+Examples of **correct** code for the `{ "allow": ["asyncMethods"] }` options:
+
+```js
+/*eslint no-empty-function: ["error", { "allow": ["asyncMethods"] }]*/
+/*eslint-env es2017*/
+
+var obj = {
+    async foo() {}
+};
+
+class A {
+    async foo() {}
+    static async foo() {}
+}
+```
+
 ## When Not To Use It
 
 If you don't want to be notified about empty functions, then it's safe to disable this rule.
diff --git a/lib/rules/no-empty-function.js b/lib/rules/no-empty-function.js
index c57e66fd5..c74321158 100644
--- a/lib/rules/no-empty-function.js
+++ b/lib/rules/no-empty-function.js
@@ -23,7 +23,9 @@ const ALLOW_OPTIONS = Object.freeze([
     "generatorMethods",
     "getters",
     "setters",
-    "constructors"
+    "constructors",
+    "asyncFunctions",
+    "asyncMethods"
 ]);
 
 /**
diff --git a/tests/lib/rules/no-empty-function.js b/tests/lib/rules/no-empty-function.js
index 71077842f..c43ec4a0c 100644
--- a/tests/lib/rules/no-empty-function.js
+++ b/tests/lib/rules/no-empty-function.js
@@ -24,7 +24,9 @@ const ALLOW_OPTIONS = Object.freeze([
     "generatorMethods",
     "getters",
     "setters",
-    "constructors"
+    "constructors",
+    "asyncFunctions",
+    "asyncMethods"
 ]);
 
 /**
@@ -36,24 +38,29 @@ const ALLOW_OPTIONS = Object.freeze([
  */
 function toValidInvalid(patterns, item) {
 
+    const ecmaVersion =
+        item.parserOptions && item.parserOptions.ecmaVersion
+            ? item.parserOptions.ecmaVersion
+            : 6;
+
     // Valid Patterns
     patterns.valid.push(
         {
             code: item.code.replace("{}", "{ bar(); }"),
-            parserOptions: { ecmaVersion: 6 }
+            parserOptions: { ecmaVersion }
         },
         {
             code: item.code.replace("{}", "{ /* empty */ }"),
-            parserOptions: { ecmaVersion: 6 }
+            parserOptions: { ecmaVersion }
         },
         {
             code: item.code.replace("{}", "{\n    // empty\n}"),
-            parserOptions: { ecmaVersion: 6 }
+            parserOptions: { ecmaVersion }
         },
         {
             code: `${item.code} // allow: ${item.allow}`,
             options: [{ allow: [item.allow] }],
-            parserOptions: { ecmaVersion: 6 }
+            parserOptions: { ecmaVersion }
         }
     );
 
@@ -63,7 +70,7 @@ function toValidInvalid(patterns, item) {
     patterns.invalid.push({
         code: item.code,
         errors: [error],
-        parserOptions: { ecmaVersion: 6 }
+        parserOptions: { ecmaVersion }
     });
     ALLOW_OPTIONS
         .filter(allow => allow !== item.allow)
@@ -74,7 +81,7 @@ function toValidInvalid(patterns, item) {
                 code: `${item.code} // allow: ${allow}`,
                 errors: [error],
                 options: [{ allow: [allow] }],
-                parserOptions: { ecmaVersion: 6 }
+                parserOptions: { ecmaVersion }
             });
         });
 
@@ -261,6 +268,41 @@ ruleTester.run("no-empty-function", rule, [
         messageId: "unexpected",
         data: { name: "constructor" },
         allow: "constructors"
+    },
+    {
+        code: "const foo = { async method() {} }",
+        allow: "asyncMethods",
+        messageId: "unexpected",
+        data: { name: "async method 'method'" },
+        parserOptions: { ecmaVersion: 8 }
+    },
+    {
+        code: "async function a(){}",
+        allow: "asyncFunctions",
+        messageId: "unexpected",
+        data: { name: "async function 'a'" },
+        parserOptions: { ecmaVersion: 8 }
+    },
+    {
+        code: "const foo = async function () {}",
+        messageId: "unexpected",
+        data: { name: "async function" },
+        allow: "asyncFunctions",
+        parserOptions: { ecmaVersion: 8 }
+    },
+    {
+        code: "class Foo { async bar() {} }",
+        messageId: "unexpected",
+        data: { name: "async method 'bar'" },
+        allow: "asyncMethods",
+        parserOptions: { ecmaVersion: 8 }
+    },
+    {
+        code: "const foo = async () => {};",
+        messageId: "unexpected",
+        data: { name: "async arrow function" },
+        allow: "arrowFunctions",
+        parserOptions: { ecmaVersion: 8 }
     }
 ].reduce(toValidInvalid, {
     valid: [
@@ -268,6 +310,7 @@ ruleTester.run("no-empty-function", rule, [
             code: "var foo = () => 0;",
             parserOptions: { ecmaVersion: 6 }
         }
+
     ],
     invalid: []
 }));
