diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index c184c01ac..9c09f896d 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -112,3 +112,16 @@ jobs:
           name: logs
           path: |
             wdio-logs/*.log
+
+  test_types:
+    name: Types Test
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - uses: actions/setup-node@v4
+        with:
+          node-version: "lts/*"
+      - name: Install Packages
+        run: npm install
+      - name: Test
+        run: npm run test:types
diff --git a/.github/workflows/types-integration.yml b/.github/workflows/types-integration.yml
new file mode 100644
index 000000000..94e616ca5
--- /dev/null
+++ b/.github/workflows/types-integration.yml
@@ -0,0 +1,109 @@
+name: CI
+on:
+  push:
+    branches: [main]
+  pull_request:
+    branches: [main]
+
+permissions:
+  contents: read
+
+jobs:
+  webpack_plugin:
+    name: Types (eslint-webpack-plugin)
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout eslint
+        uses: actions/checkout@v4
+        with:
+          path: eslint
+
+      - name: Checkout eslint-webpack-plugin
+        uses: actions/checkout@v4
+        with:
+          repository: webpack-contrib/eslint-webpack-plugin
+          path: webpack
+
+      - uses: actions/setup-node@v4
+        with:
+          node-version: "lts/*"
+
+      - name: Install Packages (eslint)
+        working-directory: eslint
+        run: npm install
+
+      - name: Install Packages (eslint-webpack-plugin)
+        working-directory: webpack
+        run: |
+          npm install
+          npm install ../eslint
+
+      - name: Run TSC
+        working-directory: webpack
+        run: npm run lint:types
+
+  neostandard:
+    name: Types (neostandard)
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout eslint
+        uses: actions/checkout@v4
+        with:
+          path: eslint
+
+      - name: Checkout neostandard
+        uses: actions/checkout@v4
+        with:
+          repository: neostandard/neostandard
+          path: neostandard
+
+      - uses: actions/setup-node@v4
+        with:
+          node-version: "lts/*"
+
+      - name: Install Packages (eslint)
+        working-directory: eslint
+        run: npm install
+
+      - name: Install Packages (neostandard)
+        working-directory: neostandard
+        run: |
+          npm install
+          npm install ../eslint
+
+      - name: Run TSC
+        working-directory: neostandard
+        run: npm run check:tsc
+
+  eslint-flat-config-utils:
+    name: Types (eslint-flat-config-utils)
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout eslint
+        uses: actions/checkout@v4
+        with:
+          path: eslint
+
+      - name: Checkout eslint-flat-config-utils
+        uses: actions/checkout@v4
+        with:
+          repository: antfu/eslint-flat-config-utils
+          path: antfu
+
+      - uses: actions/setup-node@v4
+        with:
+          node-version: "lts/*"
+
+      - name: Install Packages (eslint)
+        working-directory: eslint
+        run: npm install
+
+      - name: Install Packages (neostandard)
+        working-directory: antfu
+        run: |
+          npm install
+          npm install ../eslint
+
+      - name: Run TSC
+        working-directory: antfu
+        run: npm run typecheck
diff --git a/eslint.config.js b/eslint.config.js
index d5e10ece7..cb37750ea 100644
--- a/eslint.config.js
+++ b/eslint.config.js
@@ -93,7 +93,8 @@ module.exports = [
             "tests/performance/**",
             "tmp/**",
             "**/test.js",
-            ".vscode"
+            ".vscode",
+            "**/*.ts"
         ]
     },
     {
diff --git a/lib/types/index.d.ts b/lib/types/index.d.ts
new file mode 100644
index 000000000..6cefe3470
--- /dev/null
+++ b/lib/types/index.d.ts
@@ -0,0 +1,1635 @@
+/**
+ * @fileoverview This file contains the core types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import * as ESTree from "estree";
+import { JSONSchema4 } from "json-schema";
+import { LegacyESLint } from "./use-at-your-own-risk.js";
+
+export namespace AST {
+    type TokenType =
+        | "Boolean"
+        | "Null"
+        | "Identifier"
+        | "Keyword"
+        | "Punctuator"
+        | "JSXIdentifier"
+        | "JSXText"
+        | "Numeric"
+        | "String"
+        | "RegularExpression";
+
+    interface Token {
+        type: TokenType;
+        value: string;
+        range: Range;
+        loc: SourceLocation;
+    }
+
+    interface SourceLocation {
+        start: ESTree.Position;
+        end: ESTree.Position;
+    }
+
+    type Range = [number, number];
+
+    interface Program extends ESTree.Program {
+        comments: ESTree.Comment[];
+        tokens: Token[];
+        loc: SourceLocation;
+        range: Range;
+    }
+}
+
+export namespace Scope {
+    interface ScopeManager {
+        scopes: Scope[];
+        globalScope: Scope | null;
+
+        acquire(node: ESTree.Node, inner?: boolean): Scope | null;
+
+        getDeclaredVariables(node: ESTree.Node): Variable[];
+    }
+
+    interface Scope {
+        type:
+        | "block"
+        | "catch"
+        | "class"
+        | "for"
+        | "function"
+        | "function-expression-name"
+        | "global"
+        | "module"
+        | "switch"
+        | "with"
+        | "TDZ";
+        isStrict: boolean;
+        upper: Scope | null;
+        childScopes: Scope[];
+        variableScope: Scope;
+        block: ESTree.Node;
+        variables: Variable[];
+        set: Map<string, Variable>;
+        references: Reference[];
+        through: Reference[];
+        functionExpressionScope: boolean;
+    }
+
+    interface Variable {
+        name: string;
+        scope: Scope;
+        identifiers: ESTree.Identifier[];
+        references: Reference[];
+        defs: Definition[];
+    }
+
+    interface Reference {
+        identifier: ESTree.Identifier;
+        from: Scope;
+        resolved: Variable | null;
+        writeExpr: ESTree.Node | null;
+        init: boolean;
+
+        isWrite(): boolean;
+
+        isRead(): boolean;
+
+        isWriteOnly(): boolean;
+
+        isReadOnly(): boolean;
+
+        isReadWrite(): boolean;
+    }
+
+    type DefinitionType =
+        | { type: "CatchClause"; node: ESTree.CatchClause; parent: null }
+        | { type: "ClassName"; node: ESTree.ClassDeclaration | ESTree.ClassExpression; parent: null }
+        | { type: "FunctionName"; node: ESTree.FunctionDeclaration | ESTree.FunctionExpression; parent: null }
+        | { type: "ImplicitGlobalVariable"; node: ESTree.Program; parent: null }
+        | {
+            type: "ImportBinding";
+            node: ESTree.ImportSpecifier | ESTree.ImportDefaultSpecifier | ESTree.ImportNamespaceSpecifier;
+            parent: ESTree.ImportDeclaration;
+        }
+        | {
+            type: "Parameter";
+            node: ESTree.FunctionDeclaration | ESTree.FunctionExpression | ESTree.ArrowFunctionExpression;
+            parent: null;
+        }
+        | { type: "TDZ"; node: any; parent: null }
+        | { type: "Variable"; node: ESTree.VariableDeclarator; parent: ESTree.VariableDeclaration };
+
+    type Definition = DefinitionType & { name: ESTree.Identifier };
+}
+
+// #region SourceCode
+
+export class SourceCode {
+    text: string;
+    ast: AST.Program;
+    lines: string[];
+    hasBOM: boolean;
+    parserServices: SourceCode.ParserServices;
+    scopeManager: Scope.ScopeManager;
+    visitorKeys: SourceCode.VisitorKeys;
+
+    constructor(text: string, ast: AST.Program);
+    constructor(config: SourceCode.Config);
+
+    static splitLines(text: string): string[];
+
+    getText(node?: ESTree.Node, beforeCount?: number, afterCount?: number): string;
+
+    getLines(): string[];
+
+    getAllComments(): ESTree.Comment[];
+
+    getAncestors(node: ESTree.Node): ESTree.Node[];
+
+    getDeclaredVariables(node: ESTree.Node): Scope.Variable[];
+
+    getJSDocComment(node: ESTree.Node): ESTree.Comment | null;
+
+    getNodeByRangeIndex(index: number): ESTree.Node | null;
+
+    isSpaceBetweenTokens(first: AST.Token, second: AST.Token): boolean;
+
+    getLocFromIndex(index: number): ESTree.Position;
+
+    getIndexFromLoc(location: ESTree.Position): number;
+
+    // Inherited methods from TokenStore
+    // ---------------------------------
+
+    getTokenByRangeStart(offset: number, options?: { includeComments: false }): AST.Token | null;
+    getTokenByRangeStart(offset: number, options: { includeComments: boolean }): AST.Token | ESTree.Comment | null;
+
+    getFirstToken: SourceCode.UnaryNodeCursorWithSkipOptions;
+
+    getFirstTokens: SourceCode.UnaryNodeCursorWithCountOptions;
+
+    getLastToken: SourceCode.UnaryNodeCursorWithSkipOptions;
+
+    getLastTokens: SourceCode.UnaryNodeCursorWithCountOptions;
+
+    getTokenBefore: SourceCode.UnaryCursorWithSkipOptions;
+
+    getTokensBefore: SourceCode.UnaryCursorWithCountOptions;
+
+    getTokenAfter: SourceCode.UnaryCursorWithSkipOptions;
+
+    getTokensAfter: SourceCode.UnaryCursorWithCountOptions;
+
+    getFirstTokenBetween: SourceCode.BinaryCursorWithSkipOptions;
+
+    getFirstTokensBetween: SourceCode.BinaryCursorWithCountOptions;
+
+    getLastTokenBetween: SourceCode.BinaryCursorWithSkipOptions;
+
+    getLastTokensBetween: SourceCode.BinaryCursorWithCountOptions;
+
+    getTokensBetween: SourceCode.BinaryCursorWithCountOptions;
+
+    getTokens:
+        & ((node: ESTree.Node, beforeCount?: number, afterCount?: number) => AST.Token[])
+        & SourceCode.UnaryNodeCursorWithCountOptions;
+
+    commentsExistBetween(
+        left: ESTree.Node | AST.Token | ESTree.Comment,
+        right: ESTree.Node | AST.Token | ESTree.Comment,
+    ): boolean;
+
+    getCommentsBefore(nodeOrToken: ESTree.Node | AST.Token): ESTree.Comment[];
+
+    getCommentsAfter(nodeOrToken: ESTree.Node | AST.Token): ESTree.Comment[];
+
+    getCommentsInside(node: ESTree.Node): ESTree.Comment[];
+
+    getScope(node: ESTree.Node): Scope.Scope;
+
+    isSpaceBetween(
+        first: ESTree.Node | AST.Token,
+        second: ESTree.Node | AST.Token,
+    ): boolean;
+
+    markVariableAsUsed(name: string, refNode?: ESTree.Node): boolean;
+}
+
+export namespace SourceCode {
+    interface Config {
+        text: string;
+        ast: AST.Program;
+        parserServices?: ParserServices | undefined;
+        scopeManager?: Scope.ScopeManager | undefined;
+        visitorKeys?: VisitorKeys | undefined;
+    }
+
+    type ParserServices = any;
+
+    interface VisitorKeys {
+        [nodeType: string]: string[];
+    }
+
+    interface UnaryNodeCursorWithSkipOptions {
+        <T extends AST.Token>(
+            node: ESTree.Node,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                },
+        ): T | null;
+        <T extends AST.Token | ESTree.Comment>(
+            node: ESTree.Node,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): T | null;
+        (
+            node: ESTree.Node,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token | null;
+        (
+            node: ESTree.Node,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): AST.Token | ESTree.Comment | null;
+    }
+
+    interface UnaryNodeCursorWithCountOptions {
+        <T extends AST.Token>(
+            node: ESTree.Node,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                },
+        ): T[];
+        <T extends AST.Token | ESTree.Comment>(
+            node: ESTree.Node,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): T[];
+        (
+            node: ESTree.Node,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token[];
+        (
+            node: ESTree.Node,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): Array<AST.Token | ESTree.Comment>;
+    }
+
+    interface UnaryCursorWithSkipOptions {
+        <T extends AST.Token>(
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                },
+        ): T | null;
+        <T extends AST.Token | ESTree.Comment>(
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): T | null;
+        (
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token | null;
+        (
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): AST.Token | ESTree.Comment | null;
+    }
+
+    interface UnaryCursorWithCountOptions {
+        <T extends AST.Token>(
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                },
+        ): T[];
+        <T extends AST.Token | ESTree.Comment>(
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): T[];
+        (
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token[];
+        (
+            node: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): Array<AST.Token | ESTree.Comment>;
+    }
+
+    interface BinaryCursorWithSkipOptions {
+        <T extends AST.Token>(
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                },
+        ): T | null;
+        <T extends AST.Token | ESTree.Comment>(
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): T | null;
+        (
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    skip?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token | null;
+        (
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                skip?: number | undefined;
+            },
+        ): AST.Token | ESTree.Comment | null;
+    }
+
+    interface BinaryCursorWithCountOptions {
+        <T extends AST.Token>(
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options:
+                | ((token: AST.Token) => token is T)
+                | {
+                    filter: (token: AST.Token) => token is T;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                },
+        ): T[];
+        <T extends AST.Token | ESTree.Comment>(
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): T[];
+        (
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options?:
+                | {
+                    filter?: ((token: AST.Token) => boolean) | undefined;
+                    includeComments?: false | undefined;
+                    count?: number | undefined;
+                }
+                | ((token: AST.Token) => boolean)
+                | number,
+        ): AST.Token[];
+        (
+            left: ESTree.Node | AST.Token | ESTree.Comment,
+            right: ESTree.Node | AST.Token | ESTree.Comment,
+            options: {
+                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;
+                includeComments: boolean;
+                count?: number | undefined;
+            },
+        ): Array<AST.Token | ESTree.Comment>;
+    }
+}
+
+// #endregion
+
+export namespace Rule {
+    interface RuleModule {
+        create(context: RuleContext): RuleListener;
+        meta?: RuleMetaData | undefined;
+    }
+
+    type NodeTypes = ESTree.Node["type"];
+    interface NodeListener {
+        ArrayExpression?: ((node: ESTree.ArrayExpression & NodeParentExtension) => void) | undefined;
+        "ArrayExpression:exit"?: ((node: ESTree.ArrayExpression & NodeParentExtension) => void) | undefined;
+        ArrayPattern?: ((node: ESTree.ArrayPattern & NodeParentExtension) => void) | undefined;
+        "ArrayPattern:exit"?: ((node: ESTree.ArrayPattern & NodeParentExtension) => void) | undefined;
+        ArrowFunctionExpression?: ((node: ESTree.ArrowFunctionExpression & NodeParentExtension) => void) | undefined;
+        "ArrowFunctionExpression:exit"?:
+        | ((node: ESTree.ArrowFunctionExpression & NodeParentExtension) => void)
+        | undefined;
+        AssignmentExpression?: ((node: ESTree.AssignmentExpression & NodeParentExtension) => void) | undefined;
+        "AssignmentExpression:exit"?: ((node: ESTree.AssignmentExpression & NodeParentExtension) => void) | undefined;
+        AssignmentPattern?: ((node: ESTree.AssignmentPattern & NodeParentExtension) => void) | undefined;
+        "AssignmentPattern:exit"?: ((node: ESTree.AssignmentPattern & NodeParentExtension) => void) | undefined;
+        AwaitExpression?: ((node: ESTree.AwaitExpression & NodeParentExtension) => void) | undefined;
+        "AwaitExpression:exit"?: ((node: ESTree.AwaitExpression & NodeParentExtension) => void) | undefined;
+        BinaryExpression?: ((node: ESTree.BinaryExpression & NodeParentExtension) => void) | undefined;
+        "BinaryExpression:exit"?: ((node: ESTree.BinaryExpression & NodeParentExtension) => void) | undefined;
+        BlockStatement?: ((node: ESTree.BlockStatement & NodeParentExtension) => void) | undefined;
+        "BlockStatement:exit"?: ((node: ESTree.BlockStatement & NodeParentExtension) => void) | undefined;
+        BreakStatement?: ((node: ESTree.BreakStatement & NodeParentExtension) => void) | undefined;
+        "BreakStatement:exit"?: ((node: ESTree.BreakStatement & NodeParentExtension) => void) | undefined;
+        CallExpression?: ((node: ESTree.CallExpression & NodeParentExtension) => void) | undefined;
+        "CallExpression:exit"?: ((node: ESTree.CallExpression & NodeParentExtension) => void) | undefined;
+        CatchClause?: ((node: ESTree.CatchClause & NodeParentExtension) => void) | undefined;
+        "CatchClause:exit"?: ((node: ESTree.CatchClause & NodeParentExtension) => void) | undefined;
+        ChainExpression?: ((node: ESTree.ChainExpression & NodeParentExtension) => void) | undefined;
+        "ChainExpression:exit"?: ((node: ESTree.ChainExpression & NodeParentExtension) => void) | undefined;
+        ClassBody?: ((node: ESTree.ClassBody & NodeParentExtension) => void) | undefined;
+        "ClassBody:exit"?: ((node: ESTree.ClassBody & NodeParentExtension) => void) | undefined;
+        ClassDeclaration?: ((node: ESTree.ClassDeclaration & NodeParentExtension) => void) | undefined;
+        "ClassDeclaration:exit"?: ((node: ESTree.ClassDeclaration & NodeParentExtension) => void) | undefined;
+        ClassExpression?: ((node: ESTree.ClassExpression & NodeParentExtension) => void) | undefined;
+        "ClassExpression:exit"?: ((node: ESTree.ClassExpression & NodeParentExtension) => void) | undefined;
+        ConditionalExpression?: ((node: ESTree.ConditionalExpression & NodeParentExtension) => void) | undefined;
+        "ConditionalExpression:exit"?: ((node: ESTree.ConditionalExpression & NodeParentExtension) => void) | undefined;
+        ContinueStatement?: ((node: ESTree.ContinueStatement & NodeParentExtension) => void) | undefined;
+        "ContinueStatement:exit"?: ((node: ESTree.ContinueStatement & NodeParentExtension) => void) | undefined;
+        DebuggerStatement?: ((node: ESTree.DebuggerStatement & NodeParentExtension) => void) | undefined;
+        "DebuggerStatement:exit"?: ((node: ESTree.DebuggerStatement & NodeParentExtension) => void) | undefined;
+        DoWhileStatement?: ((node: ESTree.DoWhileStatement & NodeParentExtension) => void) | undefined;
+        "DoWhileStatement:exit"?: ((node: ESTree.DoWhileStatement & NodeParentExtension) => void) | undefined;
+        EmptyStatement?: ((node: ESTree.EmptyStatement & NodeParentExtension) => void) | undefined;
+        "EmptyStatement:exit"?: ((node: ESTree.EmptyStatement & NodeParentExtension) => void) | undefined;
+        ExportAllDeclaration?: ((node: ESTree.ExportAllDeclaration & NodeParentExtension) => void) | undefined;
+        "ExportAllDeclaration:exit"?: ((node: ESTree.ExportAllDeclaration & NodeParentExtension) => void) | undefined;
+        ExportDefaultDeclaration?: ((node: ESTree.ExportDefaultDeclaration & NodeParentExtension) => void) | undefined;
+        "ExportDefaultDeclaration:exit"?:
+        | ((node: ESTree.ExportDefaultDeclaration & NodeParentExtension) => void)
+        | undefined;
+        ExportNamedDeclaration?: ((node: ESTree.ExportNamedDeclaration & NodeParentExtension) => void) | undefined;
+        "ExportNamedDeclaration:exit"?:
+        | ((node: ESTree.ExportNamedDeclaration & NodeParentExtension) => void)
+        | undefined;
+        ExportSpecifier?: ((node: ESTree.ExportSpecifier & NodeParentExtension) => void) | undefined;
+        "ExportSpecifier:exit"?: ((node: ESTree.ExportSpecifier & NodeParentExtension) => void) | undefined;
+        ExpressionStatement?: ((node: ESTree.ExpressionStatement & NodeParentExtension) => void) | undefined;
+        "ExpressionStatement:exit"?: ((node: ESTree.ExpressionStatement & NodeParentExtension) => void) | undefined;
+        ForInStatement?: ((node: ESTree.ForInStatement & NodeParentExtension) => void) | undefined;
+        "ForInStatement:exit"?: ((node: ESTree.ForInStatement & NodeParentExtension) => void) | undefined;
+        ForOfStatement?: ((node: ESTree.ForOfStatement & NodeParentExtension) => void) | undefined;
+        "ForOfStatement:exit"?: ((node: ESTree.ForOfStatement & NodeParentExtension) => void) | undefined;
+        ForStatement?: ((node: ESTree.ForStatement & NodeParentExtension) => void) | undefined;
+        "ForStatement:exit"?: ((node: ESTree.ForStatement & NodeParentExtension) => void) | undefined;
+        FunctionDeclaration?: ((node: ESTree.FunctionDeclaration & NodeParentExtension) => void) | undefined;
+        "FunctionDeclaration:exit"?: ((node: ESTree.FunctionDeclaration & NodeParentExtension) => void) | undefined;
+        FunctionExpression?: ((node: ESTree.FunctionExpression & NodeParentExtension) => void) | undefined;
+        "FunctionExpression:exit"?: ((node: ESTree.FunctionExpression & NodeParentExtension) => void) | undefined;
+        Identifier?: ((node: ESTree.Identifier & NodeParentExtension) => void) | undefined;
+        "Identifier:exit"?: ((node: ESTree.Identifier & NodeParentExtension) => void) | undefined;
+        IfStatement?: ((node: ESTree.IfStatement & NodeParentExtension) => void) | undefined;
+        "IfStatement:exit"?: ((node: ESTree.IfStatement & NodeParentExtension) => void) | undefined;
+        ImportDeclaration?: ((node: ESTree.ImportDeclaration & NodeParentExtension) => void) | undefined;
+        "ImportDeclaration:exit"?: ((node: ESTree.ImportDeclaration & NodeParentExtension) => void) | undefined;
+        ImportDefaultSpecifier?: ((node: ESTree.ImportDefaultSpecifier & NodeParentExtension) => void) | undefined;
+        "ImportDefaultSpecifier:exit"?:
+        | ((node: ESTree.ImportDefaultSpecifier & NodeParentExtension) => void)
+        | undefined;
+        ImportExpression?: ((node: ESTree.ImportExpression & NodeParentExtension) => void) | undefined;
+        "ImportExpression:exit"?: ((node: ESTree.ImportExpression & NodeParentExtension) => void) | undefined;
+        ImportNamespaceSpecifier?: ((node: ESTree.ImportNamespaceSpecifier & NodeParentExtension) => void) | undefined;
+        "ImportNamespaceSpecifier:exit"?:
+        | ((node: ESTree.ImportNamespaceSpecifier & NodeParentExtension) => void)
+        | undefined;
+        ImportSpecifier?: ((node: ESTree.ImportSpecifier & NodeParentExtension) => void) | undefined;
+        "ImportSpecifier:exit"?: ((node: ESTree.ImportSpecifier & NodeParentExtension) => void) | undefined;
+        LabeledStatement?: ((node: ESTree.LabeledStatement & NodeParentExtension) => void) | undefined;
+        "LabeledStatement:exit"?: ((node: ESTree.LabeledStatement & NodeParentExtension) => void) | undefined;
+        Literal?: ((node: ESTree.Literal & NodeParentExtension) => void) | undefined;
+        "Literal:exit"?: ((node: ESTree.Literal & NodeParentExtension) => void) | undefined;
+        LogicalExpression?: ((node: ESTree.LogicalExpression & NodeParentExtension) => void) | undefined;
+        "LogicalExpression:exit"?: ((node: ESTree.LogicalExpression & NodeParentExtension) => void) | undefined;
+        MemberExpression?: ((node: ESTree.MemberExpression & NodeParentExtension) => void) | undefined;
+        "MemberExpression:exit"?: ((node: ESTree.MemberExpression & NodeParentExtension) => void) | undefined;
+        MetaProperty?: ((node: ESTree.MetaProperty & NodeParentExtension) => void) | undefined;
+        "MetaProperty:exit"?: ((node: ESTree.MetaProperty & NodeParentExtension) => void) | undefined;
+        MethodDefinition?: ((node: ESTree.MethodDefinition & NodeParentExtension) => void) | undefined;
+        "MethodDefinition:exit"?: ((node: ESTree.MethodDefinition & NodeParentExtension) => void) | undefined;
+        NewExpression?: ((node: ESTree.NewExpression & NodeParentExtension) => void) | undefined;
+        "NewExpression:exit"?: ((node: ESTree.NewExpression & NodeParentExtension) => void) | undefined;
+        ObjectExpression?: ((node: ESTree.ObjectExpression & NodeParentExtension) => void) | undefined;
+        "ObjectExpression:exit"?: ((node: ESTree.ObjectExpression & NodeParentExtension) => void) | undefined;
+        ObjectPattern?: ((node: ESTree.ObjectPattern & NodeParentExtension) => void) | undefined;
+        "ObjectPattern:exit"?: ((node: ESTree.ObjectPattern & NodeParentExtension) => void) | undefined;
+        PrivateIdentifier?: ((node: ESTree.PrivateIdentifier & NodeParentExtension) => void) | undefined;
+        "PrivateIdentifier:exit"?: ((node: ESTree.PrivateIdentifier & NodeParentExtension) => void) | undefined;
+        Program?: ((node: ESTree.Program) => void) | undefined;
+        "Program:exit"?: ((node: ESTree.Program) => void) | undefined;
+        Property?: ((node: ESTree.Property & NodeParentExtension) => void) | undefined;
+        "Property:exit"?: ((node: ESTree.Property & NodeParentExtension) => void) | undefined;
+        PropertyDefinition?: ((node: ESTree.PropertyDefinition & NodeParentExtension) => void) | undefined;
+        "PropertyDefinition:exit"?: ((node: ESTree.PropertyDefinition & NodeParentExtension) => void) | undefined;
+        RestElement?: ((node: ESTree.RestElement & NodeParentExtension) => void) | undefined;
+        "RestElement:exit"?: ((node: ESTree.RestElement & NodeParentExtension) => void) | undefined;
+        ReturnStatement?: ((node: ESTree.ReturnStatement & NodeParentExtension) => void) | undefined;
+        "ReturnStatement:exit"?: ((node: ESTree.ReturnStatement & NodeParentExtension) => void) | undefined;
+        SequenceExpression?: ((node: ESTree.SequenceExpression & NodeParentExtension) => void) | undefined;
+        "SequenceExpression:exit"?: ((node: ESTree.SequenceExpression & NodeParentExtension) => void) | undefined;
+        SpreadElement?: ((node: ESTree.SpreadElement & NodeParentExtension) => void) | undefined;
+        "SpreadElement:exit"?: ((node: ESTree.SpreadElement & NodeParentExtension) => void) | undefined;
+        StaticBlock?: ((node: ESTree.StaticBlock & NodeParentExtension) => void) | undefined;
+        "StaticBlock:exit"?: ((node: ESTree.StaticBlock & NodeParentExtension) => void) | undefined;
+        Super?: ((node: ESTree.Super & NodeParentExtension) => void) | undefined;
+        "Super:exit"?: ((node: ESTree.Super & NodeParentExtension) => void) | undefined;
+        SwitchCase?: ((node: ESTree.SwitchCase & NodeParentExtension) => void) | undefined;
+        "SwitchCase:exit"?: ((node: ESTree.SwitchCase & NodeParentExtension) => void) | undefined;
+        SwitchStatement?: ((node: ESTree.SwitchStatement & NodeParentExtension) => void) | undefined;
+        "SwitchStatement:exit"?: ((node: ESTree.SwitchStatement & NodeParentExtension) => void) | undefined;
+        TaggedTemplateExpression?: ((node: ESTree.TaggedTemplateExpression & NodeParentExtension) => void) | undefined;
+        "TaggedTemplateExpression:exit"?:
+        | ((node: ESTree.TaggedTemplateExpression & NodeParentExtension) => void)
+        | undefined;
+        TemplateElement?: ((node: ESTree.TemplateElement & NodeParentExtension) => void) | undefined;
+        "TemplateElement:exit"?: ((node: ESTree.TemplateElement & NodeParentExtension) => void) | undefined;
+        TemplateLiteral?: ((node: ESTree.TemplateLiteral & NodeParentExtension) => void) | undefined;
+        "TemplateLiteral:exit"?: ((node: ESTree.TemplateLiteral & NodeParentExtension) => void) | undefined;
+        ThisExpression?: ((node: ESTree.ThisExpression & NodeParentExtension) => void) | undefined;
+        "ThisExpression:exit"?: ((node: ESTree.ThisExpression & NodeParentExtension) => void) | undefined;
+        ThrowStatement?: ((node: ESTree.ThrowStatement & NodeParentExtension) => void) | undefined;
+        "ThrowStatement:exit"?: ((node: ESTree.ThrowStatement & NodeParentExtension) => void) | undefined;
+        TryStatement?: ((node: ESTree.TryStatement & NodeParentExtension) => void) | undefined;
+        "TryStatement:exit"?: ((node: ESTree.TryStatement & NodeParentExtension) => void) | undefined;
+        UnaryExpression?: ((node: ESTree.UnaryExpression & NodeParentExtension) => void) | undefined;
+        "UnaryExpression:exit"?: ((node: ESTree.UnaryExpression & NodeParentExtension) => void) | undefined;
+        UpdateExpression?: ((node: ESTree.UpdateExpression & NodeParentExtension) => void) | undefined;
+        "UpdateExpression:exit"?: ((node: ESTree.UpdateExpression & NodeParentExtension) => void) | undefined;
+        VariableDeclaration?: ((node: ESTree.VariableDeclaration & NodeParentExtension) => void) | undefined;
+        "VariableDeclaration:exit"?: ((node: ESTree.VariableDeclaration & NodeParentExtension) => void) | undefined;
+        VariableDeclarator?: ((node: ESTree.VariableDeclarator & NodeParentExtension) => void) | undefined;
+        "VariableDeclarator:exit"?: ((node: ESTree.VariableDeclarator & NodeParentExtension) => void) | undefined;
+        WhileStatement?: ((node: ESTree.WhileStatement & NodeParentExtension) => void) | undefined;
+        "WhileStatement:exit"?: ((node: ESTree.WhileStatement & NodeParentExtension) => void) | undefined;
+        WithStatement?: ((node: ESTree.WithStatement & NodeParentExtension) => void) | undefined;
+        "WithStatement:exit"?: ((node: ESTree.WithStatement & NodeParentExtension) => void) | undefined;
+        YieldExpression?: ((node: ESTree.YieldExpression & NodeParentExtension) => void) | undefined;
+        "YieldExpression:exit"?: ((node: ESTree.YieldExpression & NodeParentExtension) => void) | undefined;
+    }
+
+    interface NodeParentExtension {
+        parent: Node;
+    }
+    type Node = ESTree.Node & NodeParentExtension;
+
+    interface RuleListener extends NodeListener {
+        onCodePathStart?(codePath: CodePath, node: Node): void;
+
+        onCodePathEnd?(codePath: CodePath, node: Node): void;
+
+        onCodePathSegmentStart?(segment: CodePathSegment, node: Node): void;
+
+        onCodePathSegmentEnd?(segment: CodePathSegment, node: Node): void;
+
+        onCodePathSegmentLoop?(fromSegment: CodePathSegment, toSegment: CodePathSegment, node: Node): void;
+
+        [key: string]:
+        | ((codePath: CodePath, node: Node) => void)
+        | ((segment: CodePathSegment, node: Node) => void)
+        | ((fromSegment: CodePathSegment, toSegment: CodePathSegment, node: Node) => void)
+        | ((node: Node) => void)
+        | NodeListener[keyof NodeListener]
+        | undefined;
+    }
+
+    type CodePathOrigin = "program" | "function" | "class-field-initializer" | "class-static-block";
+
+    interface CodePath {
+        id: string;
+        origin: CodePathOrigin;
+        initialSegment: CodePathSegment;
+        finalSegments: CodePathSegment[];
+        returnedSegments: CodePathSegment[];
+        thrownSegments: CodePathSegment[];
+        upper: CodePath | null;
+        childCodePaths: CodePath[];
+    }
+
+    interface CodePathSegment {
+        id: string;
+        nextSegments: CodePathSegment[];
+        prevSegments: CodePathSegment[];
+        reachable: boolean;
+    }
+
+    interface RuleMetaData {
+        /** Properties often used for documentation generation and tooling. */
+        docs?: {
+            /** Provides a short description of the rule. Commonly used when generating lists of rules. */
+            description?: string | undefined;
+            /** Historically used by some plugins that divide rules into categories in their documentation. */
+            category?: string | undefined;
+            /** Historically used by some plugins to indicate a rule belongs in their `recommended` configuration. */
+            recommended?: boolean | undefined;
+            /** Specifies the URL at which the full documentation can be accessed. Code editors often use this to provide a helpful link on highlighted rule violations. */
+            url?: string | undefined;
+        } | undefined;
+        /** Violation and suggestion messages. */
+        messages?: { [messageId: string]: string } | undefined;
+        /**
+         * Specifies if the `--fix` option on the command line automatically fixes problems reported by the rule.
+         * Mandatory for fixable rules.
+         */
+        fixable?: "code" | "whitespace" | undefined;
+        /**
+         * Specifies the [options](https://eslint.org/docs/latest/extend/custom-rules#options-schemas)
+         * so ESLint can prevent invalid [rule configurations](https://eslint.org/docs/latest/use/configure/rules#configuring-rules).
+         * Mandatory for rules with options.
+         */
+        schema?: JSONSchema4 | JSONSchema4[] | false | undefined;
+
+        /** Indicates whether the rule has been deprecated. Omit if not deprecated. */
+        deprecated?: boolean | undefined;
+        /** The name of the rule(s) this rule was replaced by, if it was deprecated. */
+        replacedBy?: readonly string[];
+
+        /**
+         * Indicates the type of rule:
+         * - `"problem"` means the rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.
+         * - `"suggestion"` means the rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.
+         * - `"layout"` means the rule cares primarily about whitespace, semicolons, commas, and parentheses,
+         *   all the parts of the program that determine how the code looks rather than how it executes.
+         *   These rules work on parts of the code that aren’t specified in the AST.
+         */
+        type?: "problem" | "suggestion" | "layout" | undefined;
+        /**
+         * Specifies whether the rule can return suggestions (defaults to `false` if omitted).
+         * Mandatory for rules that provide suggestions.
+         */
+        hasSuggestions?: boolean | undefined;
+    }
+
+    interface RuleContext {
+        id: string;
+        options: any[];
+        settings: { [name: string]: any };
+        parserPath: string | undefined;
+        languageOptions: Linter.LanguageOptions;
+        parserOptions: Linter.ParserOptions;
+        cwd: string;
+        filename: string;
+        physicalFilename: string;
+        sourceCode: SourceCode;
+
+        getAncestors(): ESTree.Node[];
+
+        getDeclaredVariables(node: ESTree.Node): Scope.Variable[];
+
+        /** @deprecated Use property `filename` directly instead */
+        getFilename(): string;
+
+        /** @deprecated Use property `physicalFilename` directly instead */
+        getPhysicalFilename(): string;
+
+        /** @deprecated Use property `cwd` directly instead */
+        getCwd(): string;
+
+        getScope(): Scope.Scope;
+
+        /** @deprecated Use property `sourceCode` directly instead */
+        getSourceCode(): SourceCode;
+
+        markVariableAsUsed(name: string): boolean;
+
+        report(descriptor: ReportDescriptor): void;
+    }
+
+    type ReportFixer = (fixer: RuleFixer) => null | Fix | IterableIterator<Fix> | Fix[];
+
+    interface ReportDescriptorOptionsBase {
+        data?: { [key: string]: string };
+
+        fix?: null | ReportFixer;
+    }
+
+    interface SuggestionReportOptions {
+        data?: { [key: string]: string };
+
+        fix: ReportFixer;
+    }
+
+    type SuggestionDescriptorMessage = { desc: string } | { messageId: string };
+    type SuggestionReportDescriptor = SuggestionDescriptorMessage & SuggestionReportOptions;
+
+    interface ReportDescriptorOptions extends ReportDescriptorOptionsBase {
+        suggest?: SuggestionReportDescriptor[] | null | undefined;
+    }
+
+    type ReportDescriptor = ReportDescriptorMessage & ReportDescriptorLocation & ReportDescriptorOptions;
+    type ReportDescriptorMessage = { message: string } | { messageId: string };
+    type ReportDescriptorLocation =
+        | { node: ESTree.Node }
+        | { loc: AST.SourceLocation | { line: number; column: number } };
+
+    interface RuleFixer {
+        insertTextAfter(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;
+
+        insertTextAfterRange(range: AST.Range, text: string): Fix;
+
+        insertTextBefore(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;
+
+        insertTextBeforeRange(range: AST.Range, text: string): Fix;
+
+        remove(nodeOrToken: ESTree.Node | AST.Token): Fix;
+
+        removeRange(range: AST.Range): Fix;
+
+        replaceText(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;
+
+        replaceTextRange(range: AST.Range, text: string): Fix;
+    }
+
+    interface Fix {
+        range: AST.Range;
+        text: string;
+    }
+}
+
+// #region Linter
+
+export class Linter {
+    static readonly version: string;
+
+    version: string;
+
+    constructor(options?: { cwd?: string | undefined; configType?: "flat" | "eslintrc" });
+
+    verify(
+        code: SourceCode | string,
+        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],
+        filename?: string,
+    ): Linter.LintMessage[];
+    verify(
+        code: SourceCode | string,
+        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],
+        options: Linter.LintOptions,
+    ): Linter.LintMessage[];
+
+    verifyAndFix(
+        code: string,
+        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],
+        filename?: string,
+    ): Linter.FixReport;
+    verifyAndFix(
+        code: string,
+        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],
+        options: Linter.FixOptions,
+    ): Linter.FixReport;
+
+    getSourceCode(): SourceCode;
+
+    defineRule(name: string, rule: Rule.RuleModule): void;
+
+    defineRules(rules: { [name: string]: Rule.RuleModule }): void;
+
+    getRules(): Map<string, Rule.RuleModule>;
+
+    defineParser(name: string, parser: Linter.Parser): void;
+
+    getTimes(): Linter.Stats["times"];
+
+    getFixPassCount(): Linter.Stats["fixPasses"];
+}
+
+export namespace Linter {
+    /**
+     * The numeric severity level for a rule.
+     *
+     * - `0` means off.
+     * - `1` means warn.
+     * - `2` means error.
+     *
+     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)
+     */
+    type Severity = 0 | 1 | 2;
+
+    /**
+     * The human readable severity level for a rule.
+     *
+     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)
+     */
+    type StringSeverity = "off" | "warn" | "error";
+
+    /**
+     * The numeric or human readable severity level for a rule.
+     *
+     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)
+     */
+    type RuleSeverity = Severity | StringSeverity;
+
+    /**
+     * An array containing the rule severity level, followed by the rule options.
+     *
+     * @see [Rules](https://eslint.org/docs/latest/use/configure/rules)
+     */
+    type RuleSeverityAndOptions<Options extends any[] = any[]> = [RuleSeverity, ...Partial<Options>];
+
+    /**
+     * The severity level for the rule or an array containing the rule severity level, followed by the rule options.
+     *
+     * @see [Rules](https://eslint.org/docs/latest/use/configure/rules)
+     */
+    type RuleEntry<Options extends any[] = any[]> = RuleSeverity | RuleSeverityAndOptions<Options>;
+
+    /**
+     * The rules config object is a key/value map of rule names and their severity and options.
+     */
+    interface RulesRecord {
+        [rule: string]: RuleEntry;
+    }
+
+    /**
+     * A configuration object that may have a `rules` block.
+     */
+    interface HasRules<Rules extends RulesRecord = RulesRecord> {
+        rules?: Partial<Rules> | undefined;
+    }
+
+    /**
+     * The ECMAScript version of the code being linted.
+     */
+    type EcmaVersion =
+        | 3
+        | 5
+        | 6
+        | 7
+        | 8
+        | 9
+        | 10
+        | 11
+        | 12
+        | 13
+        | 14
+        | 15
+        | 16
+        | 2015
+        | 2016
+        | 2017
+        | 2018
+        | 2019
+        | 2020
+        | 2021
+        | 2022
+        | 2023
+        | 2024
+        | 2025
+        | "latest";
+
+    /**
+     * The type of JavaScript source code.
+     */
+    type SourceType = "script" | "module" | "commonjs";
+
+    /**
+     * ESLint legacy configuration.
+     *
+     * @see [ESLint Legacy Configuration](https://eslint.org/docs/latest/use/configure/)
+     */
+    interface BaseConfig<Rules extends RulesRecord = RulesRecord, OverrideRules extends RulesRecord = Rules>
+        extends HasRules<Rules> {
+        $schema?: string | undefined;
+
+        /**
+         * An environment provides predefined global variables.
+         *
+         * @see [Environments](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-environments)
+         */
+        env?: { [name: string]: boolean } | undefined;
+
+        /**
+         * Extending configuration files.
+         *
+         * @see [Extends](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#extending-configuration-files)
+         */
+        extends?: string | string[] | undefined;
+
+        /**
+         * Specifying globals.
+         *
+         * @see [Globals](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-globals)
+         */
+        globals?: Linter.Globals | undefined;
+
+        /**
+         * Disable processing of inline comments.
+         *
+         * @see [Disabling Inline Comments](https://eslint.org/docs/latest/use/configure/rules-deprecated#disabling-inline-comments)
+         */
+        noInlineConfig?: boolean | undefined;
+
+        /**
+         * Overrides can be used to use a differing configuration for matching sub-directories and files.
+         *
+         * @see [How do overrides work](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#how-do-overrides-work)
+         */
+        overrides?: Array<ConfigOverride<OverrideRules>> | undefined;
+
+        /**
+         * Parser.
+         *
+         * @see [Working with Custom Parsers](https://eslint.org/docs/latest/extend/custom-parsers)
+         * @see [Specifying Parser](https://eslint.org/docs/latest/use/configure/parser-deprecated)
+         */
+        parser?: string | undefined;
+
+        /**
+         * Parser options.
+         *
+         * @see [Working with Custom Parsers](https://eslint.org/docs/latest/extend/custom-parsers)
+         * @see [Specifying Parser Options](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options)
+         */
+        parserOptions?: ParserOptions | undefined;
+
+        /**
+         * Which third-party plugins define additional rules, environments, configs, etc. for ESLint to use.
+         *
+         * @see [Configuring Plugins](https://eslint.org/docs/latest/use/configure/plugins-deprecated#configure-plugins)
+         */
+        plugins?: string[] | undefined;
+
+        /**
+         * Specifying processor.
+         *
+         * @see [processor](https://eslint.org/docs/latest/use/configure/plugins-deprecated#specify-a-processor)
+         */
+        processor?: string | undefined;
+
+        /**
+         * Report unused eslint-disable comments as warning.
+         *
+         * @see [Report unused eslint-disable comments](https://eslint.org/docs/latest/use/configure/rules-deprecated#report-unused-eslint-disable-comments)
+         */
+        reportUnusedDisableDirectives?: boolean | undefined;
+
+        /**
+         * Settings.
+         *
+         * @see [Settings](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#adding-shared-settings)
+         */
+        settings?: { [name: string]: any } | undefined;
+    }
+
+    /**
+     * The overwrites that apply more differing configuration to specific files or directories.
+     */
+    interface ConfigOverride<Rules extends RulesRecord = RulesRecord> extends BaseConfig<Rules> {
+        /**
+         * The glob patterns for excluded files.
+         */
+        excludedFiles?: string | string[] | undefined;
+
+        /**
+         * The glob patterns for target files.
+         */
+        files: string | string[];
+    }
+
+    /**
+     * ESLint legacy configuration.
+     *
+     * @see [ESLint Legacy Configuration](https://eslint.org/docs/latest/use/configure/)
+     */
+    // https://github.com/eslint/eslint/blob/v8.57.0/conf/config-schema.js
+    interface LegacyConfig<Rules extends RulesRecord = RulesRecord, OverrideRules extends RulesRecord = Rules>
+        extends BaseConfig<Rules, OverrideRules> {
+        /**
+         * Tell ESLint to ignore specific files and directories.
+         *
+         * @see [Ignore Patterns](https://eslint.org/docs/latest/use/configure/ignore-deprecated#ignorepatterns-in-config-files)
+         */
+        ignorePatterns?: string | string[] | undefined;
+
+        /**
+         * @see [Using Configuration Files](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#using-configuration-files)
+         */
+        root?: boolean | undefined;
+    }
+
+    /**
+     * Parser options.
+     *
+     * @see [Specifying Parser Options](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options)
+     */
+    interface ParserOptions {
+        /**
+         * Accepts any valid ECMAScript version number or `'latest'`:
+         *
+         * - A version: es3, es5, es6, es7, es8, es9, es10, es11, es12, es13, es14, ..., or
+         * - A year: es2015, es2016, es2017, es2018, es2019, es2020, es2021, es2022, es2023, ..., or
+         * - `'latest'`
+         *
+         * When it's a version or a year, the value must be a number - so do not include the `es` prefix.
+         *
+         * Specifies the version of ECMAScript syntax you want to use. This is used by the parser to determine how to perform scope analysis, and it affects the default
+         *
+         * @default 5
+         */
+        ecmaVersion?: EcmaVersion | undefined;
+
+        /**
+         * The type of JavaScript source code. Possible values are "script" for
+         * traditional script files, "module" for ECMAScript modules (ESM), and
+         * "commonjs" for CommonJS files.
+         *
+         * @default 'script'
+         *
+         * @see https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options
+         */
+        sourceType?: SourceType | undefined;
+
+        /**
+         * An object indicating which additional language features you'd like to use.
+         *
+         * @see https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options
+         */
+        ecmaFeatures?: {
+            globalReturn?: boolean | undefined;
+            impliedStrict?: boolean | undefined;
+            jsx?: boolean | undefined;
+            experimentalObjectRestSpread?: boolean | undefined;
+            [key: string]: any;
+        } | undefined;
+        [key: string]: any;
+    }
+
+    interface LintOptions {
+        filename?: string | undefined;
+        preprocess?: ((code: string) => string[]) | undefined;
+        postprocess?: ((problemLists: LintMessage[][]) => LintMessage[]) | undefined;
+        filterCodeBlock?: boolean | undefined;
+        disableFixes?: boolean | undefined;
+        allowInlineConfig?: boolean | undefined;
+        reportUnusedDisableDirectives?: boolean | undefined;
+    }
+
+    interface LintSuggestion {
+        desc: string;
+        fix: Rule.Fix;
+        messageId?: string | undefined;
+    }
+
+    interface LintMessage {
+        column: number;
+        line: number;
+        endColumn?: number | undefined;
+        endLine?: number | undefined;
+        ruleId: string | null;
+        message: string;
+        messageId?: string | undefined;
+        nodeType?: string | undefined;
+        fatal?: true | undefined;
+        severity: Exclude<Severity, 0>;
+        fix?: Rule.Fix | undefined;
+        suggestions?: LintSuggestion[] | undefined;
+    }
+
+    interface LintSuppression {
+        kind: string;
+        justification: string;
+    }
+
+    interface SuppressedLintMessage extends LintMessage {
+        suppressions: LintSuppression[];
+    }
+
+    interface FixOptions extends LintOptions {
+        fix?: boolean | undefined;
+    }
+
+    interface FixReport {
+        fixed: boolean;
+        output: string;
+        messages: LintMessage[];
+    }
+
+    // Temporarily loosen type for just flat config files (see #68232)
+    type NonESTreeParser =
+        & Omit<ESTreeParser, "parseForESLint">
+        & ({
+            parse(text: string, options?: any): unknown;
+        } | {
+            parseForESLint(text: string, options?: any): Omit<ESLintParseResult, "ast" | "scopeManager"> & {
+                ast: unknown;
+                scopeManager?: unknown;
+            };
+        });
+
+    type ESTreeParser =
+        & ESLint.ObjectMetaProperties
+        & (
+            | { parse(text: string, options?: any): AST.Program }
+            | { parseForESLint(text: string, options?: any): ESLintParseResult }
+        );
+
+    type Parser = NonESTreeParser | ESTreeParser;
+
+    interface ESLintParseResult {
+        ast: AST.Program;
+        parserServices?: SourceCode.ParserServices | undefined;
+        scopeManager?: Scope.ScopeManager | undefined;
+        visitorKeys?: SourceCode.VisitorKeys | undefined;
+    }
+
+    interface ProcessorFile {
+        text: string;
+        filename: string;
+    }
+
+    // https://eslint.org/docs/latest/extend/plugins#processors-in-plugins
+    interface Processor<T extends string | ProcessorFile = string | ProcessorFile> extends ESLint.ObjectMetaProperties {
+        supportsAutofix?: boolean | undefined;
+        preprocess?(text: string, filename: string): T[];
+        postprocess?(messages: LintMessage[][], filename: string): LintMessage[];
+    }
+
+    interface Config<Rules extends RulesRecord = RulesRecord> {
+        /**
+         * An string to identify the configuration object. Used in error messages and
+         * inspection tools.
+         */
+        name?: string;
+
+        /**
+         * An array of glob patterns indicating the files that the configuration
+         * object should apply to. If not specified, the configuration object applies
+         * to all files
+         */
+        files?: Array<string | string[]>;
+
+        /**
+         * An array of glob patterns indicating the files that the configuration
+         * object should not apply to. If not specified, the configuration object
+         * applies to all files matched by files
+         */
+        ignores?: string[];
+
+        /**
+         * An object containing settings related to how JavaScript is configured for
+         * linting.
+         */
+        languageOptions?: LanguageOptions;
+
+        /**
+         * An object containing settings related to the linting process
+         */
+        linterOptions?: LinterOptions;
+
+        /**
+         * Either an object containing preprocess() and postprocess() methods or a
+         * string indicating the name of a processor inside of a plugin
+         * (i.e., "pluginName/processorName").
+         */
+        processor?: string | Processor;
+
+        /**
+         * An object containing a name-value mapping of plugin names to plugin objects.
+         * When files is specified, these plugins are only available to the matching files.
+         */
+        plugins?: Record<string, ESLint.Plugin>;
+
+        /**
+         * An object containing the configured rules. When files or ignores are specified,
+         * these rule configurations are only available to the matching files.
+         */
+        rules?: Partial<Rules>;
+
+        /**
+         * An object containing name-value pairs of information that should be
+         * available to all rules.
+         */
+        settings?: Record<string, unknown>;
+    }
+
+    /** @deprecated  Use `Config` instead of `FlatConfig` */
+    type FlatConfig = Config;
+
+    type GlobalConf = boolean | "off" | "readable" | "readonly" | "writable" | "writeable";
+
+    interface Globals {
+        [name: string]: GlobalConf;
+    }
+
+    interface LanguageOptions {
+        /**
+         * The version of ECMAScript to support. May be any year (i.e., 2022) or
+         * version (i.e., 5). Set to "latest" for the most recent supported version.
+         * @default "latest"
+         */
+        ecmaVersion?: EcmaVersion | undefined;
+
+        /**
+         * The type of JavaScript source code. Possible values are "script" for
+         * traditional script files, "module" for ECMAScript modules (ESM), and
+         * "commonjs" for CommonJS files. (default: "module" for .js and .mjs
+         * files; "commonjs" for .cjs files)
+         */
+        sourceType?: SourceType | undefined;
+
+        /**
+         * An object specifying additional objects that should be added to the
+         * global scope during linting.
+         */
+        globals?: Globals | undefined;
+
+        /**
+         * An object containing a parse() or parseForESLint() method.
+         * If not configured, the default ESLint parser (Espree) will be used.
+         */
+        parser?: Parser | undefined;
+
+        /**
+         * An object specifying additional options that are passed directly to the
+         * parser() method on the parser. The available options are parser-dependent
+         */
+        parserOptions?: Linter.ParserOptions | undefined;
+    }
+
+    interface LinterOptions {
+        /**
+         * A boolean value indicating if inline configuration is allowed.
+         */
+        noInlineConfig?: boolean;
+
+        /**
+         * A severity value indicating if and how unused disable directives should be
+         * tracked and reported.
+         */
+        reportUnusedDisableDirectives?: Severity | StringSeverity | boolean;
+    }
+
+    interface Stats {
+        /**
+         * The number of times ESLint has applied at least one fix after linting.
+         */
+        fixPasses: number;
+
+        /**
+         * The times spent on (parsing, fixing, linting) a file, where the linting refers to the timing information for each rule.
+         */
+        times: { passes: TimePass[] };
+    }
+
+    interface TimePass {
+        parse: { total: number };
+        rules?: Record<string, { total: number }>;
+        fix: { total: number };
+        total: number;
+    }
+}
+
+// #endregion
+
+// #region ESLint
+
+export class ESLint {
+    static configType: "flat";
+
+    static readonly version: string;
+
+    static outputFixes(results: ESLint.LintResult[]): Promise<void>;
+
+    static getErrorResults(results: ESLint.LintResult[]): ESLint.LintResult[];
+
+    constructor(options?: ESLint.Options);
+
+    lintFiles(patterns: string | string[]): Promise<ESLint.LintResult[]>;
+
+    lintText(
+        code: string,
+        options?: { filePath?: string | undefined; warnIgnored?: boolean | undefined },
+    ): Promise<ESLint.LintResult[]>;
+
+    getRulesMetaForResults(results: ESLint.LintResult[]): ESLint.LintResultData["rulesMeta"];
+
+    hasFlag(flag: string): boolean;
+
+    calculateConfigForFile(filePath: string): Promise<any>;
+
+    findConfigFile(): Promise<string | undefined>;
+
+    isPathIgnored(filePath: string): Promise<boolean>;
+
+    loadFormatter(nameOrPath?: string): Promise<ESLint.Formatter>;
+}
+
+export namespace ESLint {
+    type ConfigData<Rules extends Linter.RulesRecord = Linter.RulesRecord> = Omit<
+        Linter.LegacyConfig<Rules>,
+        "$schema"
+    >;
+
+    interface Environment {
+        globals?: Linter.Globals | undefined;
+        parserOptions?: Linter.ParserOptions | undefined;
+    }
+
+    interface ObjectMetaProperties {
+        /** @deprecated Use `meta.name` instead. */
+        name?: string | undefined;
+
+        /** @deprecated Use `meta.version` instead. */
+        version?: string | undefined;
+
+        meta?: {
+            name?: string | undefined;
+            version?: string | undefined;
+        };
+    }
+
+    interface Plugin extends ObjectMetaProperties {
+        configs?: Record<string, Linter.LegacyConfig | Linter.Config | Linter.Config[]> | undefined;
+        environments?: Record<string, Environment> | undefined;
+        processors?: Record<string, Linter.Processor> | undefined;
+        rules?: Record<string, Rule.RuleModule> | undefined;
+    }
+
+    type FixType = "directive" | "problem" | "suggestion" | "layout";
+
+    type CacheStrategy = "content" | "metadata";
+
+    interface Options {
+        // File enumeration
+        cwd?: string | undefined;
+        errorOnUnmatchedPattern?: boolean | undefined;
+        globInputPaths?: boolean | undefined;
+        ignore?: boolean | undefined;
+        ignorePatterns?: string[] | null | undefined;
+        passOnNoPatterns?: boolean | undefined;
+        warnIgnored?: boolean | undefined;
+
+        // Linting
+        allowInlineConfig?: boolean | undefined;
+        baseConfig?: Linter.Config | Linter.Config[] | null | undefined;
+        overrideConfig?: Linter.Config | Linter.Config[] | null | undefined;
+        overrideConfigFile?: string | boolean | undefined;
+        plugins?: Record<string, Plugin> | null | undefined;
+        ruleFilter?: ((arg: { ruleId: string; severity: Exclude<Linter.Severity, 0> }) => boolean) | undefined;
+        stats?: boolean | undefined;
+
+        // Autofix
+        fix?: boolean | ((message: Linter.LintMessage) => boolean) | undefined;
+        fixTypes?: FixType[] | undefined;
+
+        // Cache-related
+        cache?: boolean | undefined;
+        cacheLocation?: string | undefined;
+        cacheStrategy?: CacheStrategy | undefined;
+
+        // Other Options
+        flags?: string[] | undefined;
+    }
+
+    interface LegacyOptions {
+        // File enumeration
+        cwd?: string | undefined;
+        errorOnUnmatchedPattern?: boolean | undefined;
+        extensions?: string[] | undefined;
+        globInputPaths?: boolean | undefined;
+        ignore?: boolean | undefined;
+        ignorePath?: string | undefined;
+
+        // Linting
+        allowInlineConfig?: boolean | undefined;
+        baseConfig?: Linter.LegacyConfig | undefined;
+        overrideConfig?: Linter.LegacyConfig | undefined;
+        overrideConfigFile?: string | undefined;
+        plugins?: Record<string, Plugin> | undefined;
+        reportUnusedDisableDirectives?: Linter.StringSeverity | undefined;
+        resolvePluginsRelativeTo?: string | undefined;
+        rulePaths?: string[] | undefined;
+        useEslintrc?: boolean | undefined;
+
+        // Autofix
+        fix?: boolean | ((message: Linter.LintMessage) => boolean) | undefined;
+        fixTypes?: FixType[] | undefined;
+
+        // Cache-related
+        cache?: boolean | undefined;
+        cacheLocation?: string | undefined;
+        cacheStrategy?: CacheStrategy | undefined;
+
+        // Other Options
+        flags?: string[] | undefined;
+    }
+
+    interface LintResult {
+        filePath: string;
+        messages: Linter.LintMessage[];
+        suppressedMessages: Linter.SuppressedLintMessage[];
+        errorCount: number;
+        fatalErrorCount: number;
+        warningCount: number;
+        fixableErrorCount: number;
+        fixableWarningCount: number;
+        output?: string | undefined;
+        source?: string | undefined;
+        stats?: Linter.Stats | undefined;
+        usedDeprecatedRules: DeprecatedRuleUse[];
+    }
+
+    interface MaxWarningsExceeded {
+
+        /**
+         * Number of warnings to trigger nonzero exit code.
+         */
+        maxWarnings: number;
+
+        /**
+         * Number of warnings found while linting.
+         */
+        foundWarnings: number;
+    }
+
+    interface LintResultData {
+        cwd: string;
+        maxWarningsExceeded?: MaxWarningsExceeded | undefined;
+        rulesMeta: {
+            [ruleId: string]: Rule.RuleMetaData;
+        };
+    }
+
+    interface DeprecatedRuleUse {
+        ruleId: string;
+        replacedBy: string[];
+    }
+
+    interface Formatter {
+        format(results: LintResult[], data?: LintResultData): string | Promise<string>;
+    }
+
+    // Docs reference the types by those name
+    type EditInfo = Rule.Fix;
+    type LoadedFormatter = Formatter;
+    type ResultsMeta = LintResultData;
+}
+
+// #endregion
+
+export function loadESLint(options: { useFlatConfig: true }): Promise<typeof ESLint>;
+export function loadESLint(options: { useFlatConfig: false }): Promise<typeof LegacyESLint>;
+export function loadESLint(
+    options?: { useFlatConfig?: boolean | undefined },
+): Promise<typeof ESLint | typeof LegacyESLint>;
+
+// #region RuleTester
+
+export class RuleTester {
+    static describe: ((...args: any) => any) | null;
+    static it: ((...args: any) => any) | null;
+    static itOnly: ((...args: any) => any) | null;
+
+    constructor(config?: Linter.Config);
+
+    run(
+        name: string,
+        rule: Rule.RuleModule,
+        tests: {
+            valid: Array<string | RuleTester.ValidTestCase>;
+            invalid: RuleTester.InvalidTestCase[];
+        },
+    ): void;
+
+    static only(
+        item: string | RuleTester.ValidTestCase | RuleTester.InvalidTestCase,
+    ): RuleTester.ValidTestCase | RuleTester.InvalidTestCase;
+}
+
+export namespace RuleTester {
+    interface ValidTestCase {
+        name?: string;
+        code: string;
+        options?: any;
+        filename?: string | undefined;
+        only?: boolean;
+        languageOptions?: Linter.LanguageOptions | undefined;
+        settings?: { [name: string]: any } | undefined;
+    }
+
+    interface SuggestionOutput {
+        messageId?: string;
+        desc?: string;
+        data?: Record<string, unknown> | undefined;
+        output: string;
+    }
+
+    interface InvalidTestCase extends ValidTestCase {
+        errors: number | Array<TestCaseError | string>;
+        output?: string | null | undefined;
+    }
+
+    interface TestCaseError {
+        message?: string | RegExp;
+        messageId?: string;
+        type?: string | undefined;
+        data?: any;
+        line?: number | undefined;
+        column?: number | undefined;
+        endLine?: number | undefined;
+        endColumn?: number | undefined;
+        suggestions?: SuggestionOutput[] | undefined;
+    }
+}
+
+// #endregion
diff --git a/lib/types/rules/best-practices.d.ts b/lib/types/rules/best-practices.d.ts
new file mode 100644
index 000000000..b49ce9ad8
--- /dev/null
+++ b/lib/types/rules/best-practices.d.ts
@@ -0,0 +1,1075 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface BestPractices extends Linter.RulesRecord {
+    /**
+     * Rule to enforce getter and setter pairs in objects.
+     *
+     * @since 0.22.0
+     * @see https://eslint.org/docs/rules/accessor-pairs
+     */
+    "accessor-pairs": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                setWithoutGet: boolean;
+                /**
+                 * @default false
+                 */
+                getWithoutSet: boolean;
+                /**
+                 * @default true
+                 */
+                enforceForClassMembers: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce `return` statements in callbacks of array methods.
+     *
+     * @since 2.0.0-alpha-1
+     * @see https://eslint.org/docs/rules/array-callback-return
+     */
+    "array-callback-return": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowImplicit: boolean;
+                /**
+                 * @default false
+                 */
+                checkForEach: boolean;
+                /**
+                 * @default false
+                 */
+                allowVoid: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce the use of variables within the scope they are defined.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/block-scoped-var
+     */
+    "block-scoped-var": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce that class methods utilize `this`.
+     *
+     * @since 3.4.0
+     * @see https://eslint.org/docs/rules/class-methods-use-this
+     */
+    "class-methods-use-this": Linter.RuleEntry<
+        [
+            Partial<{
+                exceptMethods: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum cyclomatic complexity allowed in a program.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/complexity
+     */
+    complexity: Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 20
+                 */
+                max: number;
+                /**
+                 * @deprecated
+                 * @default 20
+                 */
+                maximum: number;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to require `return` statements to either always or never specify values.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/consistent-return
+     */
+    "consistent-return": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                treatUndefinedAsUnspecified: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent brace style for all control statements.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/curly
+     */
+    curly: Linter.RuleEntry<["all" | "multi" | "multi-line" | "multi-or-nest" | "consistent"]>;
+
+    /**
+     * Rule to require `default` cases in `switch` statements.
+     *
+     * @since 0.6.0
+     * @see https://eslint.org/docs/rules/default-case
+     */
+    "default-case": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default '^no default$'
+                 */
+                commentPattern: string;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce default clauses in switch statements to be last
+     *
+     * @since 7.0.0
+     * @see https://eslint.org/docs/latest/rules/default-case-last
+     */
+    "default-case-last": Linter.RuleEntry<[]>;
+
+    /**
+     * Enforce default parameters to be last
+     *
+     * @since 6.4.0
+     * @see https://eslint.org/docs/latest/rules/default-param-last
+     */
+    "default-param-last": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce consistent newlines before and after dots.
+     *
+     * @since 0.21.0
+     * @see https://eslint.org/docs/rules/dot-location
+     */
+    "dot-location": Linter.RuleEntry<["object" | "property"]>;
+
+    /**
+     * Rule to enforce dot notation whenever possible.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/dot-notation
+     */
+    "dot-notation": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                allowKeywords: boolean;
+                allowPattern: string;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require the use of `===` and `!==`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/eqeqeq
+     */
+    eqeqeq:
+        | Linter.RuleEntry<
+            [
+                "always",
+                Partial<{
+                    /**
+                     * @default 'always'
+                     */
+                    null: "always" | "never" | "ignore";
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["smart" | "allow-null"]>;
+
+    /**
+     * Require grouped accessor pairs in object literals and classes.
+     *
+     * @since 6.7.0
+     * @see https://eslint.org/docs/latest/rules/grouped-accessor-pairs
+     */
+    "grouped-accessor-pairs": Linter.RuleEntry<["anyOrder" | "getBeforeSet" | "setBeforeGet"]>;
+
+    /**
+     * Rule to require `for-in` loops to include an `if` statement.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/guard-for-in
+     */
+    "guard-for-in": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce a maximum number of classes per file.
+     *
+     * @since 5.0.0-alpha.3
+     * @see https://eslint.org/docs/rules/max-classes-per-file
+     */
+    "max-classes-per-file": Linter.RuleEntry<[number]>;
+
+    /**
+     * Rule to disallow the use of `alert`, `confirm`, and `prompt`.
+     *
+     * @since 0.0.5
+     * @see https://eslint.org/docs/rules/no-alert
+     */
+    "no-alert": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `arguments.caller` or `arguments.callee`.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-caller
+     */
+    "no-caller": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow lexical declarations in case clauses.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.9.0
+     * @see https://eslint.org/docs/rules/no-case-declarations
+     */
+    "no-case-declarations": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow division operators explicitly at the beginning of regular expressions.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/no-div-regex
+     */
+    "no-div-regex": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `else` blocks after `return` statements in `if` statements.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-else-return
+     */
+    "no-else-return": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                allowElseIf: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow empty functions.
+     *
+     * @since 2.0.0
+     * @see https://eslint.org/docs/rules/no-empty-function
+     */
+    "no-empty-function": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default []
+                 */
+                allow: Array<
+                    | "functions"
+                    | "arrowFunctions"
+                    | "generatorFunctions"
+                    | "methods"
+                    | "generatorMethods"
+                    | "getters"
+                    | "setters"
+                    | "constructors"
+                >;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow empty destructuring patterns.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.7.0
+     * @see https://eslint.org/docs/rules/no-empty-pattern
+     */
+    "no-empty-pattern": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `null` comparisons without type-checking operators.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-eq-null
+     */
+    "no-eq-null": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `eval()`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-eval
+     */
+    "no-eval": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowIndirect: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow extending native types.
+     *
+     * @since 0.1.4
+     * @see https://eslint.org/docs/rules/no-extend-native
+     */
+    "no-extend-native": Linter.RuleEntry<
+        [
+            Partial<{
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow unnecessary calls to `.bind()`.
+     *
+     * @since 0.8.0
+     * @see https://eslint.org/docs/rules/no-extra-bind
+     */
+    "no-extra-bind": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary labels.
+     *
+     * @since 2.0.0-rc.0
+     * @see https://eslint.org/docs/rules/no-extra-label
+     */
+    "no-extra-label": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow fallthrough of `case` statements.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/no-fallthrough
+     */
+    "no-fallthrough": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 'falls?\s?through'
+                 */
+                commentPattern: string;
+                /**
+                 * @default false
+                 */
+                allowEmptyCase: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow leading or trailing decimal points in numeric literals.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-floating-decimal
+     */
+    "no-floating-decimal": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow assignments to native objects or read-only global variables.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 3.3.0
+     * @see https://eslint.org/docs/rules/no-global-assign
+     */
+    "no-global-assign": Linter.RuleEntry<
+        [
+            Partial<{
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow shorthand type conversions.
+     *
+     * @since 1.0.0-rc-2
+     * @see https://eslint.org/docs/rules/no-implicit-coercion
+     */
+    "no-implicit-coercion": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                boolean: boolean;
+                /**
+                 * @default true
+                 */
+                number: boolean;
+                /**
+                 * @default true
+                 */
+                string: boolean;
+                /**
+                 * @default false
+                 */
+                disallowTemplateShorthand: boolean;
+                /**
+                 * @default []
+                 */
+                allow: Array<"~" | "!!" | "+" | "*">;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow variable and `function` declarations in the global scope.
+     *
+     * @since 2.0.0-alpha-1
+     * @see https://eslint.org/docs/rules/no-implicit-globals
+     */
+    "no-implicit-globals": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `eval()`-like methods.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/no-implied-eval
+     */
+    "no-implied-eval": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow assigning to imported bindings.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 6.4.0
+     * @see https://eslint.org/docs/latest/rules/no-import-assign
+     */
+    "no-import-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `this` keywords outside of classes or class-like objects.
+     *
+     * @since 1.0.0-rc-2
+     * @see https://eslint.org/docs/rules/no-invalid-this
+     */
+    "no-invalid-this": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                capIsConstructor: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow the use of the `__iterator__` property.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-iterator
+     */
+    "no-iterator": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow labeled statements.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-labels
+     */
+    "no-labels": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowLoop: boolean;
+                /**
+                 * @default false
+                 */
+                allowSwitch: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow unnecessary nested blocks.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-lone-blocks
+     */
+    "no-lone-blocks": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow function declarations that contain unsafe references inside loop statements.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-loop-func
+     */
+    "no-loop-func": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow magic numbers.
+     *
+     * @since 1.7.0
+     * @see https://eslint.org/docs/rules/no-magic-numbers
+     */
+    "no-magic-numbers": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default []
+                 */
+                ignore: number[];
+                /**
+                 * @default false
+                 */
+                ignoreArrayIndexes: boolean;
+                /**
+                 * @default false
+                 */
+                enforceConst: boolean;
+                /**
+                 * @default false
+                 */
+                detectObjects: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow multiple spaces.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/no-multi-spaces
+     */
+    "no-multi-spaces": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                ignoreEOLComments: boolean;
+                /**
+                 * @default { Property: true }
+                 */
+                exceptions: Record<string, boolean>;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow multiline strings.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-multi-str
+     */
+    "no-multi-str": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `new` operators outside of assignments or comparisons.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/no-new
+     */
+    "no-new": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `new` operators with the `Function` object.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/no-new-func
+     */
+    "no-new-func": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `new` operators with the `String`, `Number`, and `Boolean` objects.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-new-wrappers
+     */
+    "no-new-wrappers": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow `\\8` and `\\9` escape sequences in string literals.
+     *
+     * @since 7.14.0
+     * @see https://eslint.org/docs/rules/no-nonoctal-decimal-escape
+     */
+    "no-nonoctal-decimal-escape": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow octal literals.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-octal
+     */
+    "no-octal": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow octal escape sequences in string literals.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-octal-escape
+     */
+    "no-octal-escape": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow reassigning `function` parameters.
+     *
+     * @since 0.18.0
+     * @see https://eslint.org/docs/rules/no-param-reassign
+     */
+    "no-param-reassign": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                props: boolean;
+                /**
+                 * @default []
+                 */
+                ignorePropertyModificationsFor: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow the use of the `__proto__` property.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-proto
+     */
+    "no-proto": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow variable redeclaration.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-redeclare
+     */
+    "no-redeclare": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                builtinGlobals: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow certain properties on certain objects.
+     *
+     * @since 3.5.0
+     * @see https://eslint.org/docs/rules/no-restricted-properties
+     */
+    "no-restricted-properties": Linter.RuleEntry<
+        [
+            ...Array<
+                | {
+                    object: string;
+                    property?: string | undefined;
+                    message?: string | undefined;
+                }
+                | {
+                    property: string;
+                    message?: string | undefined;
+                }
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow assignment operators in `return` statements.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-return-assign
+     */
+    "no-return-assign": Linter.RuleEntry<["except-parens" | "always"]>;
+
+    /**
+     * Rule to disallow unnecessary `return await`.
+     *
+     * @since 3.10.0
+     * @see https://eslint.org/docs/rules/no-return-await
+     */
+    "no-return-await": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `javascript:` urls.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-script-url
+     */
+    "no-script-url": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow assignments where both sides are exactly the same.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.0.0-rc.0
+     * @see https://eslint.org/docs/rules/no-self-assign
+     */
+    "no-self-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow comparisons where both sides are exactly the same.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-self-compare
+     */
+    "no-self-compare": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow comma operators.
+     *
+     * @since 0.5.1
+     * @see https://eslint.org/docs/rules/no-sequences
+     */
+    "no-sequences": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow throwing literals as exceptions.
+     *
+     * @since 0.15.0
+     * @see https://eslint.org/docs/rules/no-throw-literal
+     */
+    "no-throw-literal": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unmodified loop conditions.
+     *
+     * @since 2.0.0-alpha-2
+     * @see https://eslint.org/docs/rules/no-unmodified-loop-condition
+     */
+    "no-unmodified-loop-condition": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unused expressions.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/no-unused-expressions
+     */
+    "no-unused-expressions": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowShortCircuit: boolean;
+                /**
+                 * @default false
+                 */
+                allowTernary: boolean;
+                /**
+                 * @default false
+                 */
+                allowTaggedTemplates: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow unused labels.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.0.0-rc.0
+     * @see https://eslint.org/docs/rules/no-unused-labels
+     */
+    "no-unused-labels": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow useless backreferences in regular expressions
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 7.0.0-alpha.0
+     * @see https://eslint.org/docs/latest/rules/no-useless-backreference
+     */
+    "no-useless-backreference": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary calls to `.call()` and `.apply()`.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/no-useless-call
+     */
+    "no-useless-call": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary `catch` clauses.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 5.11.0
+     * @see https://eslint.org/docs/rules/no-useless-catch
+     */
+    "no-useless-catch": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary concatenation of literals or template literals.
+     *
+     * @since 1.3.0
+     * @see https://eslint.org/docs/rules/no-useless-concat
+     */
+    "no-useless-concat": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary escape characters.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.5.0
+     * @see https://eslint.org/docs/rules/no-useless-escape
+     */
+    "no-useless-escape": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow redundant return statements.
+     *
+     * @since 3.9.0
+     * @see https://eslint.org/docs/rules/no-useless-return
+     */
+    "no-useless-return": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `void` operators.
+     *
+     * @since 0.8.0
+     * @see https://eslint.org/docs/rules/no-void
+     */
+    "no-void": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowAsStatement: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow specified warning terms in comments.
+     *
+     * @since 0.4.4
+     * @see https://eslint.org/docs/rules/no-warning-comments
+     */
+    "no-warning-comments": Linter.RuleEntry<
+        [
+            {
+                /**
+                 * @default ["todo", "fixme", "xxx"]
+                 */
+                terms: string[];
+                /**
+                 * @default 'start'
+                 */
+                location: "start" | "anywhere";
+            },
+        ]
+    >;
+
+    /**
+     * Rule to disallow `with` statements.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-with
+     */
+    "no-with": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce using named capture group in regular expression.
+     *
+     * @since 5.15.0
+     * @see https://eslint.org/docs/rules/prefer-named-capture-group
+     */
+    "prefer-named-capture-group": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow use of `Object.prototype.hasOwnProperty.call()` and prefer use of `Object.hasOwn()`.
+     *
+     * @since 3.5.0
+     * @see https://eslint.org/docs/rules/prefer-object-has-own
+     */
+    "prefer-object-has-own": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require using Error objects as Promise rejection reasons.
+     *
+     * @since 3.14.0
+     * @see https://eslint.org/docs/rules/prefer-promise-reject-errors
+     */
+    "prefer-promise-reject-errors": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowEmptyReject: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Disallow use of the `RegExp` constructor in favor of regular expression literals.
+     *
+     * @since 6.4.0
+     * @see https://eslint.org/docs/latest/rules/prefer-regex-literals
+     */
+    "prefer-regex-literals": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                disallowRedundantWrapping: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce the consistent use of the radix argument when using `parseInt()`.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/radix
+     */
+    radix: Linter.RuleEntry<["always" | "as-needed"]>;
+
+    /**
+     * Rule to disallow async functions which have no `await` expression.
+     *
+     * @since 3.11.0
+     * @see https://eslint.org/docs/rules/require-await
+     */
+    "require-await": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce the use of `u` flag on RegExp.
+     *
+     * @since 5.3.0
+     * @see https://eslint.org/docs/rules/require-unicode-regexp
+     */
+    "require-unicode-regexp": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require `var` declarations be placed at the top of their containing scope.
+     *
+     * @since 0.8.0
+     * @see https://eslint.org/docs/rules/vars-on-top
+     */
+    "vars-on-top": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require parentheses around immediate `function` invocations.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/wrap-iife
+     */
+    "wrap-iife": Linter.RuleEntry<
+        [
+            "outside" | "inside" | "any",
+            Partial<{
+                /**
+                 * @default false
+                 */
+                functionPrototypeMethods: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow “Yoda” conditions.
+     *
+     * @since 0.7.1
+     * @see https://eslint.org/docs/rules/yoda
+     */
+    yoda:
+        | Linter.RuleEntry<
+            [
+                "never",
+                Partial<{
+                    exceptRange: boolean;
+                    onlyEquality: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["always"]>;
+}
diff --git a/lib/types/rules/deprecated.d.ts b/lib/types/rules/deprecated.d.ts
new file mode 100644
index 000000000..0e3b178f2
--- /dev/null
+++ b/lib/types/rules/deprecated.d.ts
@@ -0,0 +1,294 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface Deprecated extends Linter.RulesRecord {
+    /**
+     * Rule to enforce consistent indentation.
+     *
+     * @since 4.0.0-alpha.0
+     * @deprecated since 4.0.0, use [`indent`](https://eslint.org/docs/rules/indent) instead.
+     * @see https://eslint.org/docs/rules/indent-legacy
+     */
+    "indent-legacy": Linter.RuleEntry<
+        [
+            number | "tab",
+            Partial<{
+                /**
+                 * @default 0
+                 */
+                SwitchCase: number;
+                /**
+                 * @default 1
+                 */
+                VariableDeclarator:
+                    | Partial<{
+                        /**
+                         * @default 1
+                         */
+                        var: number | "first";
+                        /**
+                         * @default 1
+                         */
+                        let: number | "first";
+                        /**
+                         * @default 1
+                         */
+                        const: number | "first";
+                    }>
+                    | number
+                    | "first";
+                /**
+                 * @default 1
+                 */
+                outerIIFEBody: number;
+                /**
+                 * @default 1
+                 */
+                MemberExpression: number | "off";
+                /**
+                 * @default { parameters: 1, body: 1 }
+                 */
+                FunctionDeclaration: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    parameters: number | "first" | "off";
+                    /**
+                     * @default 1
+                     */
+                    body: number;
+                }>;
+                /**
+                 * @default { parameters: 1, body: 1 }
+                 */
+                FunctionExpression: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    parameters: number | "first" | "off";
+                    /**
+                     * @default 1
+                     */
+                    body: number;
+                }>;
+                /**
+                 * @default { arguments: 1 }
+                 */
+                CallExpression: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    arguments: number | "first" | "off";
+                }>;
+                /**
+                 * @default 1
+                 */
+                ArrayExpression: number | "first" | "off";
+                /**
+                 * @default 1
+                 */
+                ObjectExpression: number | "first" | "off";
+                /**
+                 * @default 1
+                 */
+                ImportDeclaration: number | "first" | "off";
+                /**
+                 * @default false
+                 */
+                flatTernaryExpressions: boolean;
+                ignoredNodes: string[];
+                /**
+                 * @default false
+                 */
+                ignoreComments: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow newlines around directives.
+     *
+     * @since 3.5.0
+     * @deprecated since 4.0.0, use [`padding-line-between-statements`](https://eslint.org/docs/rules/padding-line-between-statements) instead.
+     * @see https://eslint.org/docs/rules/lines-around-directive
+     */
+    "lines-around-directive": Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to require or disallow an empty line after variable declarations.
+     *
+     * @since 0.18.0
+     * @deprecated since 4.0.0, use [`padding-line-between-statements`](https://eslint.org/docs/rules/padding-line-between-statements) instead.
+     * @see https://eslint.org/docs/rules/newline-after-var
+     */
+    "newline-after-var": Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to require an empty line before `return` statements.
+     *
+     * @since 2.3.0
+     * @deprecated since 4.0.0, use [`padding-line-between-statements`](https://eslint.org/docs/rules/padding-line-between-statements) instead.
+     * @see https://eslint.org/docs/rules/newline-before-return
+     */
+    "newline-before-return": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow shadowing of variables inside of `catch`.
+     *
+     * @since 0.0.9
+     * @deprecated since 5.1.0, use [`no-shadow`](https://eslint.org/docs/rules/no-shadow) instead.
+     * @see https://eslint.org/docs/rules/no-catch-shadow
+     */
+    "no-catch-shadow": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow reassignment of native objects.
+     *
+     * @since 0.0.9
+     * @deprecated since 3.3.0, use [`no-global-assign`](https://eslint.org/docs/rules/no-global-assign) instead.
+     * @see https://eslint.org/docs/rules/no-native-reassign
+     */
+    "no-native-reassign": Linter.RuleEntry<
+        [
+            Partial<{
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow negating the left operand in `in` expressions.
+     *
+     * @since 0.1.2
+     * @deprecated since 3.3.0, use [`no-unsafe-negation`](https://eslint.org/docs/rules/no-unsafe-negation) instead.
+     * @see https://eslint.org/docs/rules/no-negated-in-lhs
+     */
+    "no-negated-in-lhs": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow spacing between function identifiers and their applications.
+     *
+     * @since 0.1.2
+     * @deprecated since 3.3.0, use [`func-call-spacing`](https://eslint.org/docs/rules/func-call-spacing) instead.
+     * @see https://eslint.org/docs/rules/no-spaced-func
+     */
+    "no-spaced-func": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to suggest using `Reflect` methods where applicable.
+     *
+     * @since 1.0.0-rc-2
+     * @deprecated since 3.9.0
+     * @see https://eslint.org/docs/rules/prefer-reflect
+     */
+    "prefer-reflect": Linter.RuleEntry<
+        [
+            Partial<{
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require JSDoc comments.
+     *
+     * @since 1.4.0
+     * @deprecated since 5.10.0
+     * @see https://eslint.org/docs/rules/require-jsdoc
+     */
+    "require-jsdoc": Linter.RuleEntry<
+        [
+            Partial<{
+                require: Partial<{
+                    /**
+                     * @default true
+                     */
+                    FunctionDeclaration: boolean;
+                    /**
+                     * @default false
+                     */
+                    MethodDefinition: boolean;
+                    /**
+                     * @default false
+                     */
+                    ClassDeclaration: boolean;
+                    /**
+                     * @default false
+                     */
+                    ArrowFunctionExpression: boolean;
+                    /**
+                     * @default false
+                     */
+                    FunctionExpression: boolean;
+                }>;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce valid JSDoc comments.
+     *
+     * @since 0.4.0
+     * @deprecated since 5.10.0
+     * @see https://eslint.org/docs/rules/valid-jsdoc
+     */
+    "valid-jsdoc": Linter.RuleEntry<
+        [
+            Partial<{
+                prefer: Record<string, string>;
+                preferType: Record<string, string>;
+                /**
+                 * @default true
+                 */
+                requireReturn: boolean;
+                /**
+                 * @default true
+                 */
+                requireReturnType: boolean;
+                /**
+                 * @remarks
+                 * Also accept for regular expression pattern
+                 */
+                matchDescription: string;
+                /**
+                 * @default true
+                 */
+                requireParamDescription: boolean;
+                /**
+                 * @default true
+                 */
+                requireReturnDescription: boolean;
+                /**
+                 * @default true
+                 */
+                requireParamType: boolean;
+            }>,
+        ]
+    >;
+}
diff --git a/lib/types/rules/ecmascript-6.d.ts b/lib/types/rules/ecmascript-6.d.ts
new file mode 100644
index 000000000..feeff98f4
--- /dev/null
+++ b/lib/types/rules/ecmascript-6.d.ts
@@ -0,0 +1,561 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface ECMAScript6 extends Linter.RulesRecord {
+    /**
+     * Rule to require braces around arrow function bodies.
+     *
+     * @since 1.8.0
+     * @see https://eslint.org/docs/rules/arrow-body-style
+     */
+    "arrow-body-style":
+        | Linter.RuleEntry<
+            [
+                "as-needed",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    requireReturnForObjectLiteral: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to require parentheses around arrow function arguments.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/arrow-parens
+     */
+    "arrow-parens":
+        | Linter.RuleEntry<["always"]>
+        | Linter.RuleEntry<
+            [
+                "as-needed",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    requireForBlockBody: boolean;
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to enforce consistent spacing before and after the arrow in arrow functions.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/arrow-spacing
+     */
+    "arrow-spacing": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require `super()` calls in constructors.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.24.0
+     * @see https://eslint.org/docs/rules/constructor-super
+     */
+    "constructor-super": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce consistent spacing around `*` operators in generator functions.
+     *
+     * @since 0.17.0
+     * @see https://eslint.org/docs/rules/generator-star-spacing
+     */
+    "generator-star-spacing": Linter.RuleEntry<
+        [
+            | Partial<{
+                before: boolean;
+                after: boolean;
+                named:
+                    | Partial<{
+                        before: boolean;
+                        after: boolean;
+                    }>
+                    | "before"
+                    | "after"
+                    | "both"
+                    | "neither";
+                anonymous:
+                    | Partial<{
+                        before: boolean;
+                        after: boolean;
+                    }>
+                    | "before"
+                    | "after"
+                    | "both"
+                    | "neither";
+                method:
+                    | Partial<{
+                        before: boolean;
+                        after: boolean;
+                    }>
+                    | "before"
+                    | "after"
+                    | "both"
+                    | "neither";
+            }>
+            | "before"
+            | "after"
+            | "both"
+            | "neither",
+        ]
+    >;
+
+    /**
+     * Require or disallow logical assignment operator shorthand.
+     *
+     * @since 8.24.0
+     * @see https://eslint.org/docs/rules/logical-assignment-operators
+     */
+    "logical-assignment-operators":
+        | Linter.RuleEntry<
+            [
+                "always",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    enforceForIfStatements: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["never"]>;
+
+    /**
+     * Rule to disallow reassigning class members.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/no-class-assign
+     */
+    "no-class-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow arrow functions where they could be confused with comparisons.
+     *
+     * @since 2.0.0-alpha-2
+     * @see https://eslint.org/docs/rules/no-confusing-arrow
+     */
+    "no-confusing-arrow": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                allowParens: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow reassigning `const` variables.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/no-const-assign
+     */
+    "no-const-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow duplicate class members.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.2.0
+     * @see https://eslint.org/docs/rules/no-dupe-class-members
+     */
+    "no-dupe-class-members": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow duplicate module imports.
+     *
+     * @since 2.5.0
+     * @see https://eslint.org/docs/rules/no-duplicate-imports
+     */
+    "no-duplicate-imports": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                includeExports: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow `new` operators with the `Symbol` object.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.0.0-beta.1
+     * @see https://eslint.org/docs/rules/no-new-symbol
+     */
+    "no-new-symbol": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow specified modules when loaded by `import`.
+     *
+     * @since 2.0.0-alpha-1
+     * @see https://eslint.org/docs/rules/no-restricted-imports
+     */
+    "no-restricted-imports": Linter.RuleEntry<
+        [
+            ...Array<
+                | string
+                | {
+                    name: string;
+                    importNames?: string[] | undefined;
+                    message?: string | undefined;
+                }
+                | Partial<{
+                    paths: Array<
+                        | string
+                        | {
+                            name: string;
+                            importNames?: string[] | undefined;
+                            message?: string | undefined;
+                        }
+                    >;
+                    patterns: string[];
+                }>
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow `this`/`super` before calling `super()` in constructors.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.24.0
+     * @see https://eslint.org/docs/rules/no-this-before-super
+     */
+    "no-this-before-super": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary computed property keys in object literals.
+     *
+     * @since 2.9.0
+     * @see https://eslint.org/docs/rules/no-useless-computed-key
+     */
+    "no-useless-computed-key": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary constructors.
+     *
+     * @since 2.0.0-beta.1
+     * @see https://eslint.org/docs/rules/no-useless-constructor
+     */
+    "no-useless-constructor": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow renaming import, export, and destructured assignments to the same name.
+     *
+     * @since 2.11.0
+     * @see https://eslint.org/docs/rules/no-useless-rename
+     */
+    "no-useless-rename": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                ignoreImport: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreExport: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreDestructuring: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require `let` or `const` instead of `var`.
+     *
+     * @since 0.12.0
+     * @see https://eslint.org/docs/rules/no-var
+     */
+    "no-var": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require or disallow method and property shorthand syntax for object literals.
+     *
+     * @since 0.20.0
+     * @see https://eslint.org/docs/rules/object-shorthand
+     */
+    "object-shorthand":
+        | Linter.RuleEntry<
+            [
+                "always" | "methods",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    avoidQuotes: boolean;
+                    /**
+                     * @default false
+                     */
+                    ignoreConstructors: boolean;
+                    /**
+                     * @default false
+                     */
+                    avoidExplicitReturnArrows: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                "properties",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    avoidQuotes: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["never" | "consistent" | "consistent-as-needed"]>;
+
+    /**
+     * Rule to require using arrow functions for callbacks.
+     *
+     * @since 1.2.0
+     * @see https://eslint.org/docs/rules/prefer-arrow-callback
+     */
+    "prefer-arrow-callback": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowNamedFunctions: boolean;
+                /**
+                 * @default true
+                 */
+                allowUnboundThis: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require `const` declarations for variables that are never reassigned after declared.
+     *
+     * @since 0.23.0
+     * @see https://eslint.org/docs/rules/prefer-const
+     */
+    "prefer-const": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 'any'
+                 */
+                destructuring: "any" | "all";
+                /**
+                 * @default false
+                 */
+                ignoreReadBeforeAssign: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require destructuring from arrays and/or objects.
+     *
+     * @since 3.13.0
+     * @see https://eslint.org/docs/rules/prefer-destructuring
+     */
+    "prefer-destructuring": Linter.RuleEntry<
+        [
+            Partial<
+                | {
+                    VariableDeclarator: Partial<{
+                        array: boolean;
+                        object: boolean;
+                    }>;
+                    AssignmentExpression: Partial<{
+                        array: boolean;
+                        object: boolean;
+                    }>;
+                }
+                | {
+                    array: boolean;
+                    object: boolean;
+                }
+            >,
+            Partial<{
+                enforceForRenamedProperties: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Disallow the use of `Math.pow` in favor of the `**` operator.
+     *
+     * @since 6.7.0
+     * @see https://eslint.org/docs/latest/rules/prefer-exponentiation-operator
+     */
+    "prefer-exponentiation-operator": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals.
+     *
+     * @since 3.5.0
+     * @see https://eslint.org/docs/rules/prefer-numeric-literals
+     */
+    "prefer-numeric-literals": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require rest parameters instead of `arguments`.
+     *
+     * @since 2.0.0-alpha-1
+     * @see https://eslint.org/docs/rules/prefer-rest-params
+     */
+    "prefer-rest-params": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require spread operators instead of `.apply()`.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/prefer-spread
+     */
+    "prefer-spread": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require template literals instead of string concatenation.
+     *
+     * @since 1.2.0
+     * @see https://eslint.org/docs/rules/prefer-template
+     */
+    "prefer-template": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require generator functions to contain `yield`.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/require-yield
+     */
+    "require-yield": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce spacing between rest and spread operators and their expressions.
+     *
+     * @since 2.12.0
+     * @see https://eslint.org/docs/rules/rest-spread-spacing
+     */
+    "rest-spread-spacing": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to enforce sorted import declarations within modules.
+     *
+     * @since 2.0.0-beta.1
+     * @see https://eslint.org/docs/rules/sort-imports
+     */
+    "sort-imports": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                ignoreCase: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreDeclarationSort: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreMemberSort: boolean;
+                /**
+                 * @default ['none', 'all', 'multiple', 'single']
+                 */
+                memberSyntaxSortOrder: Array<"none" | "all" | "multiple" | "single">;
+                /**
+                 * @default false
+                 */
+                allowSeparatedGroups: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require symbol descriptions.
+     *
+     * @since 3.4.0
+     * @see https://eslint.org/docs/rules/symbol-description
+     */
+    "symbol-description": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require or disallow spacing around embedded expressions of template strings.
+     *
+     * @since 2.0.0-rc.0
+     * @see https://eslint.org/docs/rules/template-curly-spacing
+     */
+    "template-curly-spacing": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to require or disallow spacing around the `*` in `yield*` expressions.
+     *
+     * @since 2.0.0-alpha-1
+     * @see https://eslint.org/docs/rules/yield-star-spacing
+     */
+    "yield-star-spacing": Linter.RuleEntry<
+        [
+            | Partial<{
+                before: boolean;
+                after: boolean;
+            }>
+            | "before"
+            | "after"
+            | "both"
+            | "neither",
+        ]
+    >;
+}
diff --git a/lib/types/rules/index.d.ts b/lib/types/rules/index.d.ts
new file mode 100644
index 000000000..f29844f4a
--- /dev/null
+++ b/lib/types/rules/index.d.ts
@@ -0,0 +1,50 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+
+import { Linter } from "../index";
+
+import { BestPractices } from "./best-practices";
+import { Deprecated } from "./deprecated";
+import { ECMAScript6 } from "./ecmascript-6";
+import { NodeJSAndCommonJS } from "./node-commonjs";
+import { PossibleErrors } from "./possible-errors";
+import { StrictMode } from "./strict-mode";
+import { StylisticIssues } from "./stylistic-issues";
+import { Variables } from "./variables";
+
+export interface ESLintRules
+    extends
+    Linter.RulesRecord,
+    PossibleErrors,
+    BestPractices,
+    StrictMode,
+    Variables,
+    NodeJSAndCommonJS,
+    StylisticIssues,
+    ECMAScript6,
+    Deprecated { }
diff --git a/lib/types/rules/node-commonjs.d.ts b/lib/types/rules/node-commonjs.d.ts
new file mode 100644
index 000000000..7418b5fc5
--- /dev/null
+++ b/lib/types/rules/node-commonjs.d.ts
@@ -0,0 +1,160 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface NodeJSAndCommonJS extends Linter.RulesRecord {
+    /**
+     * Rule to require `return` statements after callbacks.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/callback-return
+     */
+    "callback-return": Linter.RuleEntry<[string[]]>;
+
+    /**
+     * Rule to require `require()` calls to be placed at top-level module scope.
+     *
+     * @since 1.4.0
+     * @see https://eslint.org/docs/rules/global-require
+     */
+    "global-require": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require error handling in callbacks.
+     *
+     * @since 0.4.5
+     * @see https://eslint.org/docs/rules/handle-callback-err
+     */
+    "handle-callback-err": Linter.RuleEntry<[string]>;
+
+    /**
+     * Rule to disallow use of the `Buffer()` constructor.
+     *
+     * @since 4.0.0-alpha.0
+     * @see https://eslint.org/docs/rules/no-buffer-constructor
+     */
+    "no-buffer-constructor": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `require` calls to be mixed with regular variable declarations.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-mixed-requires
+     */
+    "no-mixed-requires": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                grouping: boolean;
+                /**
+                 * @default false
+                 */
+                allowCall: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow `new` operators with calls to `require`.
+     *
+     * @since 0.6.0
+     * @see https://eslint.org/docs/rules/no-new-require
+     */
+    "no-new-require": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow string concatenation when using `__dirname` and `__filename`.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-path-concat
+     */
+    "no-path-concat": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `process.env`.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/no-process-env
+     */
+    "no-process-env": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `process.exit()`.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-process-exit
+     */
+    "no-process-exit": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow specified modules when loaded by `require`.
+     *
+     * @since 0.6.0
+     * @see https://eslint.org/docs/rules/no-restricted-modules
+     */
+    "no-restricted-modules": Linter.RuleEntry<
+        [
+            ...Array<
+                | string
+                | {
+                    name: string;
+                    message?: string | undefined;
+                }
+                | Partial<{
+                    paths: Array<
+                        | string
+                        | {
+                            name: string;
+                            message?: string | undefined;
+                        }
+                    >;
+                    patterns: string[];
+                }>
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow synchronous methods.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-sync
+     */
+    "no-sync": Linter.RuleEntry<
+        [
+            {
+                /**
+                 * @default false
+                 */
+                allowAtRootLevel: boolean;
+            },
+        ]
+    >;
+}
diff --git a/lib/types/rules/possible-errors.d.ts b/lib/types/rules/possible-errors.d.ts
new file mode 100644
index 000000000..f81320021
--- /dev/null
+++ b/lib/types/rules/possible-errors.d.ts
@@ -0,0 +1,598 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface PossibleErrors extends Linter.RulesRecord {
+    /**
+     * Rule to enforce `for` loop update clause moving the counter in the right direction.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 4.0.0-beta.0
+     * @see https://eslint.org/docs/rules/for-direction
+     */
+    "for-direction": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce `return` statements in getters.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 4.2.0
+     * @see https://eslint.org/docs/rules/getter-return
+     */
+    "getter-return": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowImplicit: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow using an async function as a `Promise` executor.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 5.3.0
+     * @see https://eslint.org/docs/rules/no-async-promise-executor
+     */
+    "no-async-promise-executor": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `await` inside of loops.
+     *
+     * @since 3.12.0
+     * @see https://eslint.org/docs/rules/no-await-in-loop
+     */
+    "no-await-in-loop": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow comparing against `-0`.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 3.17.0
+     * @see https://eslint.org/docs/rules/no-compare-neg-zero
+     */
+    "no-compare-neg-zero": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow assignment operators in conditional statements.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-cond-assign
+     */
+    "no-cond-assign": Linter.RuleEntry<["except-parens" | "always"]>;
+
+    /**
+     * Rule to disallow the use of `console`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-console
+     */
+    "no-console": Linter.RuleEntry<
+        [
+            Partial<{
+                allow: Array<keyof Console>;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow constant expressions in conditions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.4.1
+     * @see https://eslint.org/docs/rules/no-constant-condition
+     */
+    "no-constant-condition": Linter.RuleEntry<
+        [
+            {
+                /**
+                 * @default true
+                 */
+                checkLoops: boolean;
+            },
+        ]
+    >;
+
+    /**
+     * Rule to disallow control characters in regular expressions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/no-control-regex
+     */
+    "no-control-regex": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `debugger`.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-debugger
+     */
+    "no-debugger": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow duplicate arguments in `function` definitions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.16.0
+     * @see https://eslint.org/docs/rules/no-dupe-args
+     */
+    "no-dupe-args": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow duplicate conditions in if-else-if chains.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 6.7.0
+     * @see https://eslint.org/docs/rules/no-dupe-else-if
+     */
+    "no-dupe-else-if": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow duplicate keys in object literals.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-dupe-keys
+     */
+    "no-dupe-keys": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow a duplicate case label.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.17.0
+     * @see https://eslint.org/docs/rules/no-duplicate-case
+     */
+    "no-duplicate-case": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow empty block statements.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-empty
+     */
+    "no-empty": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowEmptyCatch: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow empty character classes in regular expressions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.22.0
+     * @see https://eslint.org/docs/rules/no-empty-character-class
+     */
+    "no-empty-character-class": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow reassigning exceptions in `catch` clauses.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-ex-assign
+     */
+    "no-ex-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary boolean casts.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-extra-boolean-cast
+     */
+    "no-extra-boolean-cast": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unnecessary parentheses.
+     *
+     * @since 0.1.4
+     * @see https://eslint.org/docs/rules/no-extra-parens
+     */
+    "no-extra-parens":
+        | Linter.RuleEntry<
+            [
+                "all",
+                Partial<{
+                    /**
+                     * @default true,
+                     */
+                    conditionalAssign: boolean;
+                    /**
+                     * @default true
+                     */
+                    returnAssign: boolean;
+                    /**
+                     * @default true
+                     */
+                    nestedBinaryExpressions: boolean;
+                    /**
+                     * @default 'none'
+                     */
+                    ignoreJSX: "none" | "all" | "multi-line" | "single-line";
+                    /**
+                     * @default true
+                     */
+                    enforceForArrowConditionals: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<["functions"]>;
+
+    /**
+     * Rule to disallow unnecessary semicolons.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-extra-semi
+     */
+    "no-extra-semi": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow reassigning `function` declarations.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-func-assign
+     */
+    "no-func-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow variable or `function` declarations in nested blocks.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.6.0
+     * @see https://eslint.org/docs/rules/no-inner-declarations
+     */
+    "no-inner-declarations": Linter.RuleEntry<["functions" | "both"]>;
+
+    /**
+     * Rule to disallow invalid regular expression strings in `RegExp` constructors.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.1.4
+     * @see https://eslint.org/docs/rules/no-invalid-regexp
+     */
+    "no-invalid-regexp": Linter.RuleEntry<
+        [
+            Partial<{
+                allowConstructorFlags: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow irregular whitespace.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/no-irregular-whitespace
+     */
+    "no-irregular-whitespace": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                skipStrings: boolean;
+                /**
+                 * @default false
+                 */
+                skipComments: boolean;
+                /**
+                 * @default false
+                 */
+                skipRegExps: boolean;
+                /**
+                 * @default false
+                 */
+                skipTemplates: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Disallow literal numbers that lose precision.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 7.1.0
+     * @see https://eslint.org/docs/latest/rules/no-loss-of-precision
+     */
+    "no-loss-of-precision": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow characters which are made with multiple code points in character class syntax.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 5.3.0
+     * @see https://eslint.org/docs/rules/no-misleading-character-class
+     */
+    "no-misleading-character-class": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow calling global object properties as functions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-obj-calls
+     */
+    "no-obj-calls": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow returning values from Promise executor functions.
+     *
+     * @since 7.3.0
+     * @see https://eslint.org/docs/rules/no-promise-executor-return
+     */
+    "no-promise-executor-return": Linter.RuleEntry<[
+        {
+            /**
+             * @default false
+             */
+            allowVoid?: boolean;
+        },
+    ]>;
+
+    /**
+     * Rule to disallow use of `Object.prototypes` builtins directly.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.11.0
+     * @see https://eslint.org/docs/rules/no-prototype-builtins
+     */
+    "no-prototype-builtins": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow multiple spaces in regular expressions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-regex-spaces
+     */
+    "no-regex-spaces": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow sparse arrays.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-sparse-arrays
+     */
+    "no-sparse-arrays": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow template literal placeholder syntax in regular strings.
+     *
+     * @since 3.3.0
+     * @see https://eslint.org/docs/rules/no-template-curly-in-string
+     */
+    "no-template-curly-in-string": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow confusing multiline expressions.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.24.0
+     * @see https://eslint.org/docs/rules/no-unexpected-multiline
+     */
+    "no-unexpected-multiline": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unreachable code after `return`, `throw`, `continue`, and `break` statements.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-unreachable
+     */
+    "no-unreachable": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow loops with a body that allows only one iteration.
+     *
+     * @since 7.3.0
+     * @see https://eslint.org/docs/latest/rules/no-unreachable-loop
+     */
+    "no-unreachable-loop": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default []
+                 */
+                ignore: "WhileStatement" | "DoWhileStatement" | "ForStatement" | "ForInStatement" | "ForOfStatement";
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow control flow statements in `finally` blocks.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 2.9.0
+     * @see https://eslint.org/docs/rules/no-unsafe-finally
+     */
+    "no-unsafe-finally": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow negating the left operand of relational operators.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 3.3.0
+     * @see https://eslint.org/docs/rules/no-unsafe-negation
+     */
+    "no-unsafe-negation": Linter.RuleEntry<[]>;
+
+    /**
+     * Disallow use of optional chaining in contexts where the `undefined` value is not allowed.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 7.15.0
+     * @see https://eslint.org/docs/rules/no-unsafe-optional-chaining
+     */
+    "no-unsafe-optional-chaining": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                disallowArithmeticOperators: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow assignments that can lead to race conditions due to usage of `await` or `yield`.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 5.3.0
+     * @see https://eslint.org/docs/rules/require-atomic-updates
+     */
+    "require-atomic-updates": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require calls to `isNaN()` when checking for `NaN`.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/use-isnan
+     */
+    "use-isnan": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                enforceForSwitchCase: boolean;
+                /**
+                 * @default true
+                 */
+                enforceForIndexOf: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce comparing `typeof` expressions against valid strings.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.5.0
+     * @see https://eslint.org/docs/rules/valid-typeof
+     */
+    "valid-typeof": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                requireStringLiterals: boolean;
+            }>,
+        ]
+    >;
+}
diff --git a/lib/types/rules/strict-mode.d.ts b/lib/types/rules/strict-mode.d.ts
new file mode 100644
index 000000000..23bd9a9ad
--- /dev/null
+++ b/lib/types/rules/strict-mode.d.ts
@@ -0,0 +1,38 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface StrictMode extends Linter.RulesRecord {
+    /**
+     * Rule to require or disallow strict mode directives.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/strict
+     */
+    strict: Linter.RuleEntry<["safe" | "global" | "function" | "never"]>;
+}
diff --git a/lib/types/rules/stylistic-issues.d.ts b/lib/types/rules/stylistic-issues.d.ts
new file mode 100644
index 000000000..bfc9d7471
--- /dev/null
+++ b/lib/types/rules/stylistic-issues.d.ts
@@ -0,0 +1,1932 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface StylisticIssues extends Linter.RulesRecord {
+    /**
+     * Rule to enforce linebreaks after opening and before closing array brackets.
+     *
+     * @since 4.0.0-alpha.1
+     * @see https://eslint.org/docs/rules/array-bracket-newline
+     */
+    "array-bracket-newline": Linter.RuleEntry<
+        [
+            | "always"
+            | "never"
+            | "consistent"
+            | Partial<{
+                /**
+                 * @default true
+                 */
+                multiline: boolean;
+                /**
+                 * @default null
+                 */
+                minItems: number | null;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing inside array brackets.
+     *
+     * @since 0.24.0
+     * @see https://eslint.org/docs/rules/array-bracket-spacing
+     */
+    "array-bracket-spacing":
+        | Linter.RuleEntry<
+            [
+                "never",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    singleValue: boolean;
+                    /**
+                     * @default false
+                     */
+                    objectsInArrays: boolean;
+                    /**
+                     * @default false
+                     */
+                    arraysInArrays: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                "always",
+                Partial<{
+                    /**
+                     * @default true
+                     */
+                    singleValue: boolean;
+                    /**
+                     * @default true
+                     */
+                    objectsInArrays: boolean;
+                    /**
+                     * @default true
+                     */
+                    arraysInArrays: boolean;
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to enforce line breaks after each array element.
+     *
+     * @since 4.0.0-rc.0
+     * @see https://eslint.org/docs/rules/array-element-newline
+     */
+    "array-element-newline": Linter.RuleEntry<
+        [
+            | "always"
+            | "never"
+            | "consistent"
+            | Partial<{
+                /**
+                 * @default true
+                 */
+                multiline: boolean;
+                /**
+                 * @default null
+                 */
+                minItems: number | null;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow or enforce spaces inside of blocks after opening block and before closing block.
+     *
+     * @since 1.2.0
+     * @see https://eslint.org/docs/rules/block-spacing
+     */
+    "block-spacing": Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to enforce consistent brace style for blocks.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/brace-style
+     */
+    "brace-style": Linter.RuleEntry<
+        [
+            "1tbs" | "stroustrup" | "allman",
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowSingleLine: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce camelcase naming convention.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/camelcase
+     */
+    camelcase: Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 'always'
+                 */
+                properties: "always" | "never";
+                /**
+                 * @default false
+                 */
+                ignoreDestructuring: boolean;
+                /**
+                 * @remarks
+                 * Also accept for regular expression patterns
+                 */
+                allow: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce or disallow capitalization of the first letter of a comment.
+     *
+     * @since 3.11.0
+     * @see https://eslint.org/docs/rules/capitalized-comments
+     */
+    "capitalized-comments": Linter.RuleEntry<
+        [
+            "always" | "never",
+            Partial<{
+                ignorePattern: string;
+                /**
+                 * @default false
+                 */
+                ignoreInlineComments: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreConsecutiveComments: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow trailing commas.
+     *
+     * @since 0.16.0
+     * @see https://eslint.org/docs/rules/comma-dangle
+     */
+    "comma-dangle": Linter.RuleEntry<
+        [
+            | "never"
+            | "always"
+            | "always-multiline"
+            | "only-multiline"
+            | Partial<{
+                /**
+                 * @default 'never'
+                 */
+                arrays: "never" | "always" | "always-multiline" | "only-multiline";
+                /**
+                 * @default 'never'
+                 */
+                objects: "never" | "always" | "always-multiline" | "only-multiline";
+                /**
+                 * @default 'never'
+                 */
+                imports: "never" | "always" | "always-multiline" | "only-multiline";
+                /**
+                 * @default 'never'
+                 */
+                exports: "never" | "always" | "always-multiline" | "only-multiline";
+                /**
+                 * @default 'never'
+                 */
+                functions: "never" | "always" | "always-multiline" | "only-multiline";
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing before and after commas.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/comma-spacing
+     */
+    "comma-spacing": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                before: boolean;
+                /**
+                 * @default true
+                 */
+                after: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent comma style.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/comma-style
+     */
+    "comma-style": Linter.RuleEntry<
+        [
+            "last" | "first",
+            Partial<{
+                exceptions: Record<string, boolean>;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing inside computed property brackets.
+     *
+     * @since 0.23.0
+     * @see https://eslint.org/docs/rules/computed-property-spacing
+     */
+    "computed-property-spacing": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to enforce consistent naming when capturing the current execution context.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/consistent-this
+     */
+    "consistent-this": Linter.RuleEntry<[...string[]]>;
+
+    /**
+     * Rule to require or disallow newline at the end of files.
+     *
+     * @since 0.7.1
+     * @see https://eslint.org/docs/rules/eol-last
+     */
+    "eol-last": Linter.RuleEntry<
+        [
+            "always" | "never", // | 'unix' | 'windows'
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow spacing between function identifiers and their invocations.
+     *
+     * @since 3.3.0
+     * @see https://eslint.org/docs/rules/func-call-spacing
+     */
+    "func-call-spacing": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to require function names to match the name of the variable or property to which they are assigned.
+     *
+     * @since 3.8.0
+     * @see https://eslint.org/docs/rules/func-name-matching
+     */
+    "func-name-matching":
+        | Linter.RuleEntry<
+            [
+                "always" | "never",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    considerPropertyDescriptor: boolean;
+                    /**
+                     * @default false
+                     */
+                    includeCommonJSModuleExports: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    considerPropertyDescriptor: boolean;
+                    /**
+                     * @default false
+                     */
+                    includeCommonJSModuleExports: boolean;
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to require or disallow named `function` expressions.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/func-names
+     */
+    "func-names": Linter.RuleEntry<
+        [
+            "always" | "as-needed" | "never",
+            Partial<{
+                generators: "always" | "as-needed" | "never";
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce the consistent use of either `function` declarations or expressions.
+     *
+     * @since 0.2.0
+     * @see https://eslint.org/docs/rules/func-style
+     */
+    "func-style": Linter.RuleEntry<
+        [
+            "expression" | "declaration",
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowArrowFunctions: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent line breaks inside function parentheses.
+     *
+     * @since 4.6.0
+     * @see https://eslint.org/docs/rules/function-paren-newline
+     */
+    "function-paren-newline": Linter.RuleEntry<
+        [
+            | "always"
+            | "never"
+            | "multiline"
+            | "multiline-arguments"
+            | "consistent"
+            | Partial<{
+                minItems: number;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow specified identifiers.
+     *
+     * @since 2.0.0-beta.2
+     * @see https://eslint.org/docs/rules/id-blacklist
+     */
+    "id-blacklist": Linter.RuleEntry<[...string[]]>;
+
+    /**
+     * Rule to enforce minimum and maximum identifier lengths.
+     *
+     * @since 1.0.0
+     * @see https://eslint.org/docs/rules/id-length
+     */
+    "id-length": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 2
+                 */
+                min: number;
+                /**
+                 * @default Infinity
+                 */
+                max: number;
+                /**
+                 * @default 'always'
+                 */
+                properties: "always" | "never";
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require identifiers to match a specified regular expression.
+     *
+     * @since 1.0.0
+     * @see https://eslint.org/docs/rules/id-match
+     */
+    "id-match": Linter.RuleEntry<
+        [
+            string,
+            Partial<{
+                /**
+                 * @default false
+                 */
+                properties: boolean;
+                /**
+                 * @default false
+                 */
+                onlyDeclarations: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreDestructuring: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce the location of arrow function bodies.
+     *
+     * @since 4.12.0
+     * @see https://eslint.org/docs/rules/implicit-arrow-linebreak
+     */
+    "implicit-arrow-linebreak": Linter.RuleEntry<["beside" | "below"]>;
+
+    /**
+     * Rule to enforce consistent indentation.
+     *
+     * @since 0.14.0
+     * @see https://eslint.org/docs/rules/indent
+     */
+    indent: Linter.RuleEntry<
+        [
+            number | "tab",
+            Partial<{
+                /**
+                 * @default 0
+                 */
+                SwitchCase: number;
+                /**
+                 * @default 1
+                 */
+                VariableDeclarator:
+                    | Partial<{
+                        /**
+                         * @default 1
+                         */
+                        var: number | "first";
+                        /**
+                         * @default 1
+                         */
+                        let: number | "first";
+                        /**
+                         * @default 1
+                         */
+                        const: number | "first";
+                    }>
+                    | number
+                    | "first";
+                /**
+                 * @default 1
+                 */
+                outerIIFEBody: number;
+                /**
+                 * @default 1
+                 */
+                MemberExpression: number | "off";
+                /**
+                 * @default { parameters: 1, body: 1 }
+                 */
+                FunctionDeclaration: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    parameters: number | "first" | "off";
+                    /**
+                     * @default 1
+                     */
+                    body: number;
+                }>;
+                /**
+                 * @default { parameters: 1, body: 1 }
+                 */
+                FunctionExpression: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    parameters: number | "first" | "off";
+                    /**
+                     * @default 1
+                     */
+                    body: number;
+                }>;
+                /**
+                 * @default { arguments: 1 }
+                 */
+                CallExpression: Partial<{
+                    /**
+                     * @default 1
+                     */
+                    arguments: number | "first" | "off";
+                }>;
+                /**
+                 * @default 1
+                 */
+                ArrayExpression: number | "first" | "off";
+                /**
+                 * @default 1
+                 */
+                ObjectExpression: number | "first" | "off";
+                /**
+                 * @default 1
+                 */
+                ImportDeclaration: number | "first" | "off";
+                /**
+                 * @default false
+                 */
+                flatTernaryExpressions: boolean;
+                ignoredNodes: string[];
+                /**
+                 * @default false
+                 */
+                ignoreComments: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce the consistent use of either double or single quotes in JSX attributes.
+     *
+     * @since 1.4.0
+     * @see https://eslint.org/docs/rules/jsx-quotes
+     */
+    "jsx-quotes": Linter.RuleEntry<["prefer-double" | "prefer-single"]>;
+
+    /**
+     * Rule to enforce consistent spacing between keys and values in object literal properties.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/key-spacing
+     */
+    "key-spacing": Linter.RuleEntry<
+        [
+            | Partial<
+                | {
+                    /**
+                     * @default false
+                     */
+                    beforeColon: boolean;
+                    /**
+                     * @default true
+                     */
+                    afterColon: boolean;
+                    /**
+                     * @default 'strict'
+                     */
+                    mode: "strict" | "minimum";
+                    align:
+                        | Partial<{
+                            /**
+                             * @default false
+                             */
+                            beforeColon: boolean;
+                            /**
+                             * @default true
+                             */
+                            afterColon: boolean;
+                            /**
+                             * @default 'colon'
+                             */
+                            on: "value" | "colon";
+                            /**
+                             * @default 'strict'
+                             */
+                            mode: "strict" | "minimum";
+                        }>
+                        | "value"
+                        | "colon";
+                }
+                | {
+                    singleLine?:
+                        | Partial<{
+                            /**
+                             * @default false
+                             */
+                            beforeColon: boolean;
+                            /**
+                             * @default true
+                             */
+                            afterColon: boolean;
+                            /**
+                             * @default 'strict'
+                             */
+                            mode: "strict" | "minimum";
+                        }>
+                        | undefined;
+                    multiLine?:
+                        | Partial<{
+                            /**
+                             * @default false
+                             */
+                            beforeColon: boolean;
+                            /**
+                             * @default true
+                             */
+                            afterColon: boolean;
+                            /**
+                             * @default 'strict'
+                             */
+                            mode: "strict" | "minimum";
+                            align:
+                                | Partial<{
+                                    /**
+                                     * @default false
+                                     */
+                                    beforeColon: boolean;
+                                    /**
+                                     * @default true
+                                     */
+                                    afterColon: boolean;
+                                    /**
+                                     * @default 'colon'
+                                     */
+                                    on: "value" | "colon";
+                                    /**
+                                     * @default 'strict'
+                                     */
+                                    mode: "strict" | "minimum";
+                                }>
+                                | "value"
+                                | "colon";
+                        }>
+                        | undefined;
+                }
+            >
+            | {
+                align: Partial<{
+                    /**
+                     * @default false
+                     */
+                    beforeColon: boolean;
+                    /**
+                     * @default true
+                     */
+                    afterColon: boolean;
+                    /**
+                     * @default 'colon'
+                     */
+                    on: "value" | "colon";
+                    /**
+                     * @default 'strict'
+                     */
+                    mode: "strict" | "minimum";
+                }>;
+                singleLine?:
+                    | Partial<{
+                        /**
+                         * @default false
+                         */
+                        beforeColon: boolean;
+                        /**
+                         * @default true
+                         */
+                        afterColon: boolean;
+                        /**
+                         * @default 'strict'
+                         */
+                        mode: "strict" | "minimum";
+                    }>
+                    | undefined;
+                multiLine?:
+                    | Partial<{
+                        /**
+                         * @default false
+                         */
+                        beforeColon: boolean;
+                        /**
+                         * @default true
+                         */
+                        afterColon: boolean;
+                        /**
+                         * @default 'strict'
+                         */
+                        mode: "strict" | "minimum";
+                    }>
+                    | undefined;
+            },
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing before and after keywords.
+     *
+     * @since 2.0.0-beta.1
+     * @see https://eslint.org/docs/rules/keyword-spacing
+     */
+    "keyword-spacing": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                before: boolean;
+                /**
+                 * @default true
+                 */
+                after: boolean;
+                overrides: Record<
+                    string,
+                    Partial<{
+                        before: boolean;
+                        after: boolean;
+                    }>
+                >;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce position of line comments.
+     *
+     * @since 3.5.0
+     * @see https://eslint.org/docs/rules/line-comment-position
+     */
+    "line-comment-position": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 'above'
+                 */
+                position: "above" | "beside";
+                ignorePattern: string;
+                /**
+                 * @default true
+                 */
+                applyDefaultIgnorePatterns: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent linebreak style.
+     *
+     * @since 0.21.0
+     * @see https://eslint.org/docs/rules/linebreak-style
+     */
+    "linebreak-style": Linter.RuleEntry<["unix" | "windows"]>;
+
+    /**
+     * Rule to require empty lines around comments.
+     *
+     * @since 0.22.0
+     * @see https://eslint.org/docs/rules/lines-around-comment
+     */
+    "lines-around-comment": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                beforeBlockComment: boolean;
+                /**
+                 * @default false
+                 */
+                afterBlockComment: boolean;
+                /**
+                 * @default false
+                 */
+                beforeLineComment: boolean;
+                /**
+                 * @default false
+                 */
+                afterLineComment: boolean;
+                /**
+                 * @default false
+                 */
+                allowBlockStart: boolean;
+                /**
+                 * @default false
+                 */
+                allowBlockEnd: boolean;
+                /**
+                 * @default false
+                 */
+                allowObjectStart: boolean;
+                /**
+                 * @default false
+                 */
+                allowObjectEnd: boolean;
+                /**
+                 * @default false
+                 */
+                allowArrayStart: boolean;
+                /**
+                 * @default false
+                 */
+                allowArrayEnd: boolean;
+                /**
+                 * @default false
+                 */
+                allowClassStart: boolean;
+                /**
+                 * @default false
+                 */
+                allowClassEnd: boolean;
+                ignorePattern: string;
+                /**
+                 * @default true
+                 */
+                applyDefaultIgnorePatterns: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow an empty line between class members.
+     *
+     * @since 4.9.0
+     * @see https://eslint.org/docs/rules/lines-between-class-members
+     */
+    "lines-between-class-members": Linter.RuleEntry<
+        [
+            "always" | "never",
+            Partial<{
+                /**
+                 * @default false
+                 */
+                exceptAfterSingleLine: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum depth that blocks can be nested.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/max-depth
+     */
+    "max-depth": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 4
+                 */
+                max: number;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum line length.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/max-len
+     */
+    "max-len": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 80
+                 */
+                code: number;
+                /**
+                 * @default 4
+                 */
+                tabWidth: number;
+                comments: number;
+                ignorePattern: string;
+                /**
+                 * @default false
+                 */
+                ignoreComments: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreTrailingComments: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreUrls: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreStrings: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreTemplateLiterals: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreRegExpLiterals: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum number of lines per file.
+     *
+     * @since 2.12.0
+     * @see https://eslint.org/docs/rules/max-lines
+     */
+    "max-lines": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 300
+                 */
+                max: number;
+                /**
+                 * @default false
+                 */
+                skipBlankLines: boolean;
+                /**
+                 * @default false
+                 */
+                skipComments: boolean;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum number of line of code in a function.
+     *
+     * @since 5.0.0
+     * @see https://eslint.org/docs/rules/max-lines-per-function
+     */
+    "max-lines-per-function": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default 50
+                 */
+                max: number;
+                /**
+                 * @default false
+                 */
+                skipBlankLines: boolean;
+                /**
+                 * @default false
+                 */
+                skipComments: boolean;
+                /**
+                 * @default false
+                 */
+                IIFEs: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum depth that callbacks can be nested.
+     *
+     * @since 0.2.0
+     * @see https://eslint.org/docs/rules/max-nested-callbacks
+     */
+    "max-nested-callbacks": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 10
+                 */
+                max: number;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum number of parameters in function definitions.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/max-params
+     */
+    "max-params": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 3
+                 */
+                max: number;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum number of statements allowed in function blocks.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/max-statements
+     */
+    "max-statements": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 10
+                 */
+                max: number;
+                /**
+                 * @default false
+                 */
+                ignoreTopLevelFunctions: boolean;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a maximum number of statements allowed per line.
+     *
+     * @since 2.5.0
+     * @see https://eslint.org/docs/rules/max-statements-per-line
+     */
+    "max-statements-per-line": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 1
+                 */
+                max: number;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to enforce a particular style for multiline comments.
+     *
+     * @since 4.10.0
+     * @see https://eslint.org/docs/rules/multiline-comment-style
+     */
+    "multiline-comment-style": Linter.RuleEntry<["starred-block" | "bare-block" | "separate-lines"]>;
+
+    /**
+     * Rule to enforce newlines between operands of ternary expressions.
+     *
+     * @since 3.1.0
+     * @see https://eslint.org/docs/rules/multiline-ternary
+     */
+    "multiline-ternary": Linter.RuleEntry<["always" | "always-multiline" | "never"]>;
+
+    /**
+     * Rule to require constructor names to begin with a capital letter.
+     *
+     * @since 0.0.3-0
+     * @see https://eslint.org/docs/rules/new-cap
+     */
+    "new-cap": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                newIsCap: boolean;
+                /**
+                 * @default true
+                 */
+                capIsNew: boolean;
+                newIsCapExceptions: string[];
+                newIsCapExceptionPattern: string;
+                capIsNewExceptions: string[];
+                capIsNewExceptionPattern: string;
+                /**
+                 * @default true
+                 */
+                properties: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce or disallow parentheses when invoking a constructor with no arguments.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/new-parens
+     */
+    "new-parens": Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to require a newline after each call in a method chain.
+     *
+     * @since 2.0.0-rc.0
+     * @see https://eslint.org/docs/rules/newline-per-chained-call
+     */
+    "newline-per-chained-call": Linter.RuleEntry<
+        [
+            {
+                /**
+                 * @default 2
+                 */
+                ignoreChainWithDepth: number;
+            },
+        ]
+    >;
+
+    /**
+     * Rule to disallow `Array` constructors.
+     *
+     * @since 0.4.0
+     * @see https://eslint.org/docs/rules/no-array-constructor
+     */
+    "no-array-constructor": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow bitwise operators.
+     *
+     * @since 0.0.2
+     * @see https://eslint.org/docs/rules/no-bitwise
+     */
+    "no-bitwise": Linter.RuleEntry<
+        [
+            Partial<{
+                allow: string[];
+                /**
+                 * @default false
+                 */
+                int32Hint: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow `continue` statements.
+     *
+     * @since 0.19.0
+     * @see https://eslint.org/docs/rules/no-continue
+     */
+    "no-continue": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow inline comments after code.
+     *
+     * @since 0.10.0
+     * @see https://eslint.org/docs/rules/no-inline-comments
+     */
+    "no-inline-comments": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `if` statements as the only statement in `else` blocks.
+     *
+     * @since 0.6.0
+     * @see https://eslint.org/docs/rules/no-lonely-if
+     */
+    "no-lonely-if": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow mixed binary operators.
+     *
+     * @since 2.12.0
+     * @see https://eslint.org/docs/rules/no-mixed-operators
+     */
+    "no-mixed-operators": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default
+                 * [
+                 *     ["+", "-", "*", "/", "%", "**"],
+                 *     ["&", "|", "^", "~", "<<", ">>", ">>>"],
+                 *     ["==", "!=", "===", "!==", ">", ">=", "<", "<="],
+                 *     ["&&", "||"],
+                 *     ["in", "instanceof"]
+                 * ]
+                 */
+                groups: string[][];
+                /**
+                 * @default true
+                 */
+                allowSamePrecedence: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow mixed spaces and tabs for indentation.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.7.1
+     * @see https://eslint.org/docs/rules/no-mixed-spaces-and-tabs
+     */
+    "no-mixed-spaces-and-tabs": Linter.RuleEntry<["smart-tabs"]>;
+
+    /**
+     * Rule to disallow use of chained assignment expressions.
+     *
+     * @since 3.14.0
+     * @see https://eslint.org/docs/rules/no-multi-assign
+     */
+    "no-multi-assign": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow multiple empty lines.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/no-multiple-empty-lines
+     */
+    "no-multiple-empty-lines": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default 2
+                 */
+                max: number;
+                maxEOF: number;
+                maxBOF: number;
+            }>
+            | number,
+        ]
+    >;
+
+    /**
+     * Rule to disallow negated conditions.
+     *
+     * @since 1.6.0
+     * @see https://eslint.org/docs/rules/no-negated-condition
+     */
+    "no-negated-condition": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow nested ternary expressions.
+     *
+     * @since 0.2.0
+     * @see https://eslint.org/docs/rules/no-nested-ternary
+     */
+    "no-nested-ternary": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow `Object` constructors.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-new-object
+     */
+    "no-new-object": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the unary operators `++` and `--`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-plusplus
+     */
+    "no-plusplus": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowForLoopAfterthoughts: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow specified syntax.
+     *
+     * @since 1.4.0
+     * @see https://eslint.org/docs/rules/no-restricted-syntax
+     */
+    "no-restricted-syntax": Linter.RuleEntry<
+        [
+            ...Array<
+                | string
+                | {
+                    selector: string;
+                    message?: string | undefined;
+                }
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow all tabs.
+     *
+     * @since 3.2.0
+     * @see https://eslint.org/docs/rules/no-tabs
+     */
+    "no-tabs": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowIndentationTabs: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow ternary operators.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-ternary
+     */
+    "no-ternary": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow trailing whitespace at the end of lines.
+     *
+     * @since 0.7.1
+     * @see https://eslint.org/docs/rules/no-trailing-spaces
+     */
+    "no-trailing-spaces": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                skipBlankLines: boolean;
+                /**
+                 * @default false
+                 */
+                ignoreComments: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow dangling underscores in identifiers.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-underscore-dangle
+     */
+    "no-underscore-dangle": Linter.RuleEntry<
+        [
+            Partial<{
+                allow: string[];
+                /**
+                 * @default false
+                 */
+                allowAfterThis: boolean;
+                /**
+                 * @default false
+                 */
+                allowAfterSuper: boolean;
+                /**
+                 * @default false
+                 */
+                enforceInMethodNames: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow ternary operators when simpler alternatives exist.
+     *
+     * @since 0.21.0
+     * @see https://eslint.org/docs/rules/no-unneeded-ternary
+     */
+    "no-unneeded-ternary": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                defaultAssignment: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow whitespace before properties.
+     *
+     * @since 2.0.0-beta.1
+     * @see https://eslint.org/docs/rules/no-whitespace-before-property
+     */
+    "no-whitespace-before-property": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to enforce the location of single-line statements.
+     *
+     * @since 3.17.0
+     * @see https://eslint.org/docs/rules/nonblock-statement-body-position
+     */
+    "nonblock-statement-body-position": Linter.RuleEntry<
+        [
+            "beside" | "below" | "any",
+            Partial<{
+                overrides: Record<string, "beside" | "below" | "any">;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent line breaks inside braces.
+     *
+     * @since 2.12.0
+     * @see https://eslint.org/docs/rules/object-curly-newline
+     */
+    "object-curly-newline": Linter.RuleEntry<
+        [
+            | "always"
+            | "never"
+            | Partial<{
+                /**
+                 * @default false
+                 */
+                multiline: boolean;
+                minProperties: number;
+                /**
+                 * @default true
+                 */
+                consistent: boolean;
+            }>
+            | Partial<
+                Record<
+                    "ObjectExpression" | "ObjectPattern" | "ImportDeclaration" | "ExportDeclaration",
+                    | "always"
+                    | "never"
+                    | Partial<{
+                        /**
+                         * @default false
+                         */
+                        multiline: boolean;
+                        minProperties: number;
+                        /**
+                         * @default true
+                         */
+                        consistent: boolean;
+                    }>
+                >
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing inside braces.
+     *
+     * @since 0.22.0
+     * @see https://eslint.org/docs/rules/object-curly-spacing
+     */
+    "object-curly-spacing":
+        | Linter.RuleEntry<
+            [
+                "never",
+                {
+                    /**
+                     * @default false
+                     */
+                    arraysInObjects: boolean;
+                    /**
+                     * @default false
+                     */
+                    objectsInObjects: boolean;
+                },
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                "always",
+                {
+                    /**
+                     * @default true
+                     */
+                    arraysInObjects: boolean;
+                    /**
+                     * @default true
+                     */
+                    objectsInObjects: boolean;
+                },
+            ]
+        >;
+
+    /**
+     * Rule to enforce placing object properties on separate lines.
+     *
+     * @since 2.10.0
+     * @see https://eslint.org/docs/rules/object-property-newline
+     */
+    "object-property-newline": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                allowAllPropertiesOnSameLine: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce variables to be declared either together or separately in functions.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/one-var
+     */
+    "one-var": Linter.RuleEntry<
+        [
+            | "always"
+            | "never"
+            | "consecutive"
+            | Partial<
+                {
+                    /**
+                     * @default false
+                     */
+                    separateRequires: boolean;
+                } & Record<"var" | "let" | "const", "always" | "never" | "consecutive">
+            >
+            | Partial<Record<"initialized" | "uninitialized", "always" | "never" | "consecutive">>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow newlines around variable declarations.
+     *
+     * @since 2.0.0-beta.3
+     * @see https://eslint.org/docs/rules/one-var-declaration-per-line
+     */
+    "one-var-declaration-per-line": Linter.RuleEntry<["initializations" | "always"]>;
+
+    /**
+     * Rule to require or disallow assignment operator shorthand where possible.
+     *
+     * @since 0.10.0
+     * @see https://eslint.org/docs/rules/operator-assignment
+     */
+    "operator-assignment": Linter.RuleEntry<["always" | "never"]>;
+
+    /**
+     * Rule to enforce consistent linebreak style for operators.
+     *
+     * @since 0.19.0
+     * @see https://eslint.org/docs/rules/operator-linebreak
+     */
+    "operator-linebreak": Linter.RuleEntry<
+        [
+            "after" | "before" | "none",
+            Partial<{
+                overrides: Record<string, "after" | "before" | "none">;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow padding within blocks.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/padded-blocks
+     */
+    "padded-blocks": Linter.RuleEntry<
+        [
+            "always" | "never" | Partial<Record<"blocks" | "classes" | "switches", "always" | "never">>,
+            {
+                /**
+                 * @default false
+                 */
+                allowSingleLineBlocks: boolean;
+            },
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow padding lines between statements.
+     *
+     * @since 4.0.0-beta.0
+     * @see https://eslint.org/docs/rules/padding-line-between-statements
+     */
+    "padding-line-between-statements": Linter.RuleEntry<
+        [
+            ...Array<
+                {
+                    blankLine: "any" | "never" | "always";
+                } & Record<"prev" | "next", string | string[]>
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.
+     *
+     * @since 5.0.0-alpha.3
+     * @see https://eslint.org/docs/rules/prefer-object-spread
+     */
+    "prefer-object-spread": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to require quotes around object literal property names.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/quote-props
+     */
+    "quote-props":
+        | Linter.RuleEntry<["always" | "consistent"]>
+        | Linter.RuleEntry<
+            [
+                "as-needed",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    keywords: boolean;
+                    /**
+                     * @default true
+                     */
+                    unnecessary: boolean;
+                    /**
+                     * @default false
+                     */
+                    numbers: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                "consistent-as-needed",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    keywords: boolean;
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to enforce the consistent use of either backticks, double, or single quotes.
+     *
+     * @since 0.0.7
+     * @see https://eslint.org/docs/rules/quotes
+     */
+    quotes: Linter.RuleEntry<
+        [
+            "double" | "single" | "backtick",
+            Partial<{
+                /**
+                 * @default false
+                 */
+                avoidEscape: boolean;
+                /**
+                 * @default false
+                 */
+                allowTemplateLiterals: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow semicolons instead of ASI.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/semi
+     */
+    semi:
+        | Linter.RuleEntry<
+            [
+                "always",
+                Partial<{
+                    /**
+                     * @default false
+                     */
+                    omitLastInOneLineBlock: boolean;
+                }>,
+            ]
+        >
+        | Linter.RuleEntry<
+            [
+                "never",
+                Partial<{
+                    /**
+                     * @default 'any'
+                     */
+                    beforeStatementContinuationChars: "any" | "always" | "never";
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to enforce consistent spacing before and after semicolons.
+     *
+     * @since 0.16.0
+     * @see https://eslint.org/docs/rules/semi-spacing
+     */
+    "semi-spacing": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                before: boolean;
+                /**
+                 * @default true
+                 */
+                after: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce location of semicolons.
+     *
+     * @since 4.0.0-beta.0
+     * @see https://eslint.org/docs/rules/semi-style
+     */
+    "semi-style": Linter.RuleEntry<["last" | "first"]>;
+
+    /**
+     * Rule to require object keys to be sorted.
+     *
+     * @since 3.3.0
+     * @see https://eslint.org/docs/rules/sort-keys
+     */
+    "sort-keys": Linter.RuleEntry<
+        [
+            "asc" | "desc",
+            Partial<{
+                /**
+                 * @default true
+                 */
+                caseSensitive: boolean;
+                /**
+                 * @default 2
+                 */
+                minKeys: number;
+                /**
+                 * @default false
+                 */
+                natural: boolean;
+                /**
+                 * @default false
+                 */
+                allowLineSeparatedGroups: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require variables within the same declaration block to be sorted.
+     *
+     * @since 0.2.0
+     * @see https://eslint.org/docs/rules/sort-vars
+     */
+    "sort-vars": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                ignoreCase: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing before blocks.
+     *
+     * @since 0.9.0
+     * @see https://eslint.org/docs/rules/space-before-blocks
+     */
+    "space-before-blocks": Linter.RuleEntry<
+        ["always" | "never" | Partial<Record<"functions" | "keywords" | "classes", "always" | "never" | "off">>]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing before `function` definition opening parenthesis.
+     *
+     * @since 0.18.0
+     * @see https://eslint.org/docs/rules/space-before-function-paren
+     */
+    "space-before-function-paren": Linter.RuleEntry<
+        ["always" | "never" | Partial<Record<"anonymous" | "named" | "asyncArrow", "always" | "never" | "ignore">>]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing inside parentheses.
+     *
+     * @since 0.8.0
+     * @see https://eslint.org/docs/rules/space-in-parens
+     */
+    "space-in-parens": Linter.RuleEntry<
+        [
+            "never" | "always",
+            Partial<{
+                exceptions: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require spacing around infix operators.
+     *
+     * @since 0.2.0
+     * @see https://eslint.org/docs/rules/space-infix-ops
+     */
+    "space-infix-ops": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                int32Hint: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing before or after unary operators.
+     *
+     * @since 0.10.0
+     * @see https://eslint.org/docs/rules/space-unary-ops
+     */
+    "space-unary-ops": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default true
+                 */
+                words: boolean;
+                /**
+                 * @default false
+                 */
+                nonwords: boolean;
+                overrides: Record<string, boolean>;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to enforce consistent spacing after the `//` or `/*` in a comment.
+     *
+     * @since 0.23.0
+     * @see https://eslint.org/docs/rules/spaced-comment
+     */
+    "spaced-comment": Linter.RuleEntry<
+        [
+            "always" | "never",
+            {
+                exceptions: string[];
+                markers: string[];
+                line: {
+                    exceptions: string[];
+                    markers: string[];
+                };
+                block: {
+                    exceptions: string[];
+                    markers: string[];
+                    /**
+                     * @default false
+                     */
+                    balanced: boolean;
+                };
+            },
+        ]
+    >;
+
+    /**
+     * Rule to enforce spacing around colons of switch statements.
+     *
+     * @since 4.0.0-beta.0
+     * @see https://eslint.org/docs/rules/switch-colon-spacing
+     */
+    "switch-colon-spacing": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                before: boolean;
+                /**
+                 * @default true
+                 */
+                after: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to require or disallow spacing between template tags and their literals.
+     *
+     * @since 3.15.0
+     * @see https://eslint.org/docs/rules/template-tag-spacing
+     */
+    "template-tag-spacing": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to require or disallow Unicode byte order mark (BOM).
+     *
+     * @since 2.11.0
+     * @see https://eslint.org/docs/rules/unicode-bom
+     */
+    "unicode-bom": Linter.RuleEntry<["never" | "always"]>;
+
+    /**
+     * Rule to require parenthesis around regex literals.
+     *
+     * @since 0.1.0
+     * @see https://eslint.org/docs/rules/wrap-regex
+     */
+    "wrap-regex": Linter.RuleEntry<[]>;
+}
diff --git a/lib/types/rules/variables.d.ts b/lib/types/rules/variables.d.ts
new file mode 100644
index 000000000..5227dd12a
--- /dev/null
+++ b/lib/types/rules/variables.d.ts
@@ -0,0 +1,221 @@
+/**
+ * @fileoverview This file contains the rule types for ESLint. It was initially extracted
+ * from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { Linter } from "../index";
+
+export interface Variables extends Linter.RulesRecord {
+    /**
+     * Rule to require or disallow initialization in variable declarations.
+     *
+     * @since 1.0.0-rc-1
+     * @see https://eslint.org/docs/rules/init-declarations
+     */
+    "init-declarations":
+        | Linter.RuleEntry<["always"]>
+        | Linter.RuleEntry<
+            [
+                "never",
+                Partial<{
+                    ignoreForLoopInit: boolean;
+                }>,
+            ]
+        >;
+
+    /**
+     * Rule to disallow deleting variables.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-delete-var
+     */
+    "no-delete-var": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow labels that share a name with a variable.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-label-var
+     */
+    "no-label-var": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow specified global variables.
+     *
+     * @since 2.3.0
+     * @see https://eslint.org/docs/rules/no-restricted-globals
+     */
+    "no-restricted-globals": Linter.RuleEntry<
+        [
+            ...Array<
+                | string
+                | {
+                    name: string;
+                    message?: string | undefined;
+                }
+            >,
+        ]
+    >;
+
+    /**
+     * Rule to disallow variable declarations from shadowing variables declared in the outer scope.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-shadow
+     */
+    "no-shadow": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                builtinGlobals: boolean;
+                /**
+                 * @default 'functions'
+                 */
+                hoist: "functions" | "all" | "never";
+                allow: string[];
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow identifiers from shadowing restricted names.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.1.4
+     * @see https://eslint.org/docs/rules/no-shadow-restricted-names
+     */
+    "no-shadow-restricted-names": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of undeclared variables unless mentioned in `global` comments.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-undef
+     */
+    "no-undef": Linter.RuleEntry<
+        [
+            Partial<{
+                /**
+                 * @default false
+                 */
+                typeof: boolean;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow initializing variables to `undefined`.
+     *
+     * @since 0.0.6
+     * @see https://eslint.org/docs/rules/no-undef-init
+     */
+    "no-undef-init": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow the use of `undefined` as an identifier.
+     *
+     * @since 0.7.1
+     * @see https://eslint.org/docs/rules/no-undefined
+     */
+    "no-undefined": Linter.RuleEntry<[]>;
+
+    /**
+     * Rule to disallow unused variables.
+     *
+     * @remarks
+     * Recommended by ESLint, the rule was enabled in `eslint:recommended`.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-unused-vars
+     */
+    "no-unused-vars": Linter.RuleEntry<
+        [
+            | "all"
+            | "local"
+            | Partial<{
+                /**
+                 * @default 'all'
+                 */
+                vars: "all" | "local";
+                varsIgnorePattern: string;
+                /**
+                 * @default 'after-used'
+                 */
+                args: "after-used" | "all" | "none";
+                /**
+                 * @default false
+                 */
+                ignoreRestSiblings: boolean;
+                argsIgnorePattern: string;
+                /**
+                 * @default 'none'
+                 */
+                caughtErrors: "none" | "all";
+                caughtErrorsIgnorePattern: string;
+                destructuredArrayIgnorePattern: string;
+            }>,
+        ]
+    >;
+
+    /**
+     * Rule to disallow the use of variables before they are defined.
+     *
+     * @since 0.0.9
+     * @see https://eslint.org/docs/rules/no-use-before-define
+     */
+    "no-use-before-define": Linter.RuleEntry<
+        [
+            | Partial<{
+                /**
+                 * @default true
+                 */
+                functions: boolean;
+                /**
+                 * @default true
+                 */
+                classes: boolean;
+                /**
+                 * @default true
+                 */
+                variables: boolean;
+                /**
+                 * @default false
+                 */
+                allowNamedExports: boolean;
+            }>
+            | "nofunc",
+        ]
+    >;
+}
diff --git a/lib/types/use-at-your-own-risk.d.ts b/lib/types/use-at-your-own-risk.d.ts
new file mode 100644
index 000000000..2600b72df
--- /dev/null
+++ b/lib/types/use-at-your-own-risk.d.ts
@@ -0,0 +1,85 @@
+/**
+ * @fileoverview This file contains the types for the use-at-your-own-risk
+ * entrypoint. It was initially extracted from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+
+import { ESLint, Rule } from "./index.js";
+
+/** @deprecated */
+export const builtinRules: Map<string, Rule.RuleModule>;
+
+/** @deprecated */
+export class FileEnumerator {
+    constructor(
+        params?: {
+            cwd?: string;
+            configArrayFactory?: any;
+            extensions?: any;
+            globInputPaths?: boolean;
+            errorOnUnmatchedPattern?: boolean;
+            ignore?: boolean;
+        },
+    );
+    isTargetPath(filePath: string, providedConfig?: any): boolean;
+    iterateFiles(
+        patternOrPatterns: string | string[],
+    ): IterableIterator<{ config: any; filePath: string; ignored: boolean }>;
+}
+
+export { /** @deprecated */ ESLint as FlatESLint };
+
+/** @deprecated */
+export class LegacyESLint {
+    static configType: "eslintrc";
+
+    static readonly version: string;
+
+    static outputFixes(results: ESLint.LintResult[]): Promise<void>;
+
+    static getErrorResults(results: ESLint.LintResult[]): ESLint.LintResult[];
+
+    constructor(options?: ESLint.LegacyOptions);
+
+    lintFiles(patterns: string | string[]): Promise<ESLint.LintResult[]>;
+
+    lintText(
+        code: string,
+        options?: { filePath?: string | undefined; warnIgnored?: boolean | undefined },
+    ): Promise<ESLint.LintResult[]>;
+
+    getRulesMetaForResults(results: ESLint.LintResult[]): ESLint.LintResultData["rulesMeta"];
+
+    hasFlag(flag: string): false;
+
+    calculateConfigForFile(filePath: string): Promise<any>;
+
+    isPathIgnored(filePath: string): Promise<boolean>;
+
+    loadFormatter(nameOrPath?: string): Promise<ESLint.Formatter>;
+}
+
+/** @deprecated */
+export function shouldUseFlatConfig(): Promise<boolean>;
diff --git a/package.json b/package.json
index cbad9e5ad..0add7e779 100644
--- a/package.json
+++ b/package.json
@@ -7,10 +7,20 @@
     "eslint": "./bin/eslint.js"
   },
   "main": "./lib/api.js",
+  "types": "./lib/types/index.d.ts",
   "exports": {
+    ".": {
+      "types": "./lib/types/index.d.ts",
+      "default": "./lib/api.js"
+    },
     "./package.json": "./package.json",
-    ".": "./lib/api.js",
-    "./use-at-your-own-risk": "./lib/unsupported-api.js"
+    "./use-at-your-own-risk": {
+      "types": "./lib/types/use-at-your-own-risk.d.ts",
+      "default": "./lib/unsupported-api.js"
+    },
+    "./rules": {
+      "types": "./lib/types/rules/index.d.ts"
+    }
   },
   "scripts": {
     "build:docs:update-links": "node tools/fetch-docs-links.js",
@@ -34,7 +44,8 @@
     "test:cli": "mocha",
     "test:fuzz": "node Makefile.js fuzz",
     "test:performance": "node Makefile.js perf",
-    "test:emfile": "node tools/check-emfile-handling.js"
+    "test:emfile": "node tools/check-emfile-handling.js",
+    "test:types": "tsc -p tests/lib/types/tsconfig.json"
   },
   "gitHooks": {
     "pre-commit": "lint-staged"
@@ -108,6 +119,7 @@
     "@eslint/json": "^0.4.0",
     "@trunkio/launcher": "^1.3.0",
     "@types/estree": "^1.0.5",
+    "@types/json-schema": "^7.0.15",
     "@types/node": "^20.11.5",
     "@wdio/browser-runner": "^9.0.5",
     "@wdio/cli": "^9.0.5",
diff --git a/tests/lib/types/tsconfig.json b/tests/lib/types/tsconfig.json
new file mode 100644
index 000000000..453c51a11
--- /dev/null
+++ b/tests/lib/types/tsconfig.json
@@ -0,0 +1,21 @@
+{
+    "compilerOptions": {
+        "module": "node16",
+        "lib": [
+            "dom",
+            "es6"
+        ],
+        "noImplicitAny": true,
+        "noImplicitThis": true,
+        "strictNullChecks": true,
+        "strictFunctionTypes": true,
+        "types": [],
+        "noEmit": true,
+        "forceConsistentCasingInFileNames": true,
+        "exactOptionalPropertyTypes": true
+    },
+    "files": [
+        "../../../lib/types/index.d.ts",
+        "types.test.ts"
+    ]
+}
diff --git a/tests/lib/types/types.test.ts b/tests/lib/types/types.test.ts
new file mode 100644
index 000000000..29c2e7d93
--- /dev/null
+++ b/tests/lib/types/types.test.ts
@@ -0,0 +1,1511 @@
+/**
+ * @fileoverview This file contains code intended to test our types.
+ * It was initially extracted from the `@types/eslint` package.
+ */
+
+/*
+ * MIT License
+ * Copyright (c) Microsoft Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE
+ */
+
+import { AST, ESLint, Linter, loadESLint, Rule, RuleTester, Scope, SourceCode } from "eslint";
+import { ESLintRules } from "eslint/rules";
+import {
+    builtinRules,
+    FileEnumerator,
+    FlatESLint,
+    LegacyESLint,
+    shouldUseFlatConfig,
+} from "eslint/use-at-your-own-risk";
+import { Comment, PrivateIdentifier, PropertyDefinition, StaticBlock, WhileStatement } from "estree";
+
+const SOURCE = `var foo = bar;`;
+
+const AST: AST.Program = {
+    type: "Program",
+    sourceType: "module",
+    body: [],
+    comments: [],
+    tokens: [],
+    loc: {
+        start: { line: 0, column: 0 },
+        end: { line: 0, column: 0 },
+    },
+    range: [0, 0],
+};
+
+const TOKEN: AST.Token = {
+    type: "Identifier",
+    value: "foo",
+    loc: {
+        start: { line: 0, column: 0 },
+        end: { line: 0, column: 3 },
+    },
+    range: [0, 3],
+};
+
+const COMMENT: Comment = {
+    type: "Block",
+    value: "foo",
+    loc: {
+        start: { line: 0, column: 0 },
+        end: { line: 0, column: 0 },
+    },
+    range: [0, 0],
+};
+
+// #region SourceCode
+
+let sourceCode = new SourceCode(SOURCE, AST);
+
+SourceCode.splitLines(SOURCE);
+
+sourceCode.getText();
+sourceCode.getText(AST);
+sourceCode.getText(AST, 0);
+sourceCode.getText(AST, 0, 0);
+
+sourceCode.getLines();
+
+sourceCode.getAllComments();
+
+sourceCode.getJSDocComment(AST); // $ExpectType Comment | null
+
+sourceCode.getNodeByRangeIndex(0);
+
+sourceCode.getNodeByRangeIndex(0);
+
+sourceCode.isSpaceBetweenTokens(TOKEN, TOKEN);
+
+sourceCode.isSpaceBetween(TOKEN, TOKEN);
+sourceCode.isSpaceBetween(AST, TOKEN);
+sourceCode.isSpaceBetween(TOKEN, AST);
+
+const loc = sourceCode.getLocFromIndex(0);
+loc.line; // $ExpectType number
+loc.column; // $ExpectType number
+
+sourceCode.getIndexFromLoc({ line: 0, column: 0 });
+
+sourceCode.getTokenByRangeStart(0); // $ExpectType Token | null
+sourceCode.getTokenByRangeStart(0, { includeComments: true }); // $ExpectType Comment | Token | null || Token | Comment | null
+sourceCode.getTokenByRangeStart(0, { includeComments: false }); // $ExpectType Token | null
+sourceCode.getTokenByRangeStart(0, { includeComments: false as boolean }); // $ExpectType Comment | Token | null || Token | Comment | null
+
+sourceCode.getFirstToken(AST); // $ExpectType Token | null
+sourceCode.getFirstToken(AST, 0);
+sourceCode.getFirstToken(AST, { skip: 0 });
+sourceCode.getFirstToken(AST, (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier"); // $ExpectType (Token & { type: "Identifier"; }) | null
+sourceCode.getFirstToken(AST, { filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier" }); // $ExpectType (Token & { type: "Identifier"; }) | null
+sourceCode.getFirstToken(AST, { skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getFirstToken(AST, { includeComments: true }); // $ExpectType Comment | Token | null || Token | Comment | null
+sourceCode.getFirstToken(AST, { includeComments: true, skip: 0 });
+// prettier-ignore
+sourceCode.getFirstToken(AST, { // $ExpectType (Token & { type: "Identifier"; }) | null
+    includeComments: true,
+    skip: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+
+sourceCode.getFirstTokens(AST); // $ExpectType Token[]
+sourceCode.getFirstTokens(AST, 0); // $ExpectType Token[]
+sourceCode.getFirstTokens(AST, { count: 0 });
+sourceCode.getFirstTokens(AST, (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier"); // $ExpectType (Token & { type: "Identifier"; })[]
+sourceCode.getFirstTokens(AST, { filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier" }); // $ExpectType (Token & { type: "Identifier"; })[]
+// prettier-ignore
+sourceCode.getFirstTokens(AST, { // $ExpectType (Token & { type: "Identifier"; })[]
+    count: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+sourceCode.getFirstTokens(AST, { includeComments: true }); //  $ ExpectType (Comment | Token)[]
+sourceCode.getFirstTokens(AST, { includeComments: true, count: 0 }); //  $ ExpectType (Comment | Token)[]
+// prettier-ignore
+sourceCode.getFirstTokens(AST, { // $ExpectType (Token & { type: "Identifier"; })[]
+    includeComments: true,
+    count: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+
+sourceCode.getLastToken(AST);
+sourceCode.getLastToken(AST, 0);
+sourceCode.getLastToken(AST, { skip: 0 });
+sourceCode.getLastToken(AST, t => t.type === "Identifier");
+sourceCode.getLastToken(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getLastToken(AST, { skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getLastToken(AST, { includeComments: true });
+sourceCode.getLastToken(AST, { includeComments: true, skip: 0 });
+sourceCode.getLastToken(AST, { includeComments: true, skip: 0, filter: t => t.type === "Identifier" });
+
+sourceCode.getLastTokens(AST);
+sourceCode.getLastTokens(AST, 0);
+sourceCode.getLastTokens(AST, { count: 0 });
+sourceCode.getLastTokens(AST, t => t.type === "Identifier");
+sourceCode.getLastTokens(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getLastTokens(AST, { count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getLastTokens(AST, { includeComments: true });
+sourceCode.getLastTokens(AST, { includeComments: true, count: 0 });
+sourceCode.getLastTokens(AST, { includeComments: true, count: 0, filter: t => t.type === "Identifier" });
+
+sourceCode.getTokenBefore(AST);
+sourceCode.getTokenBefore(AST, 0);
+sourceCode.getTokenBefore(AST, { skip: 0 });
+sourceCode.getTokenBefore(AST, t => t.type === "Identifier");
+sourceCode.getTokenBefore(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getTokenBefore(AST, { skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokenBefore(AST, { includeComments: true });
+sourceCode.getTokenBefore(AST, { includeComments: true, skip: 0 });
+sourceCode.getTokenBefore(AST, { includeComments: true, skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokenBefore(TOKEN, 0);
+sourceCode.getTokenBefore(COMMENT, 0);
+
+sourceCode.getTokensBefore(AST);
+sourceCode.getTokensBefore(AST, 0);
+sourceCode.getTokensBefore(AST, { count: 0 });
+sourceCode.getTokensBefore(AST, t => t.type === "Identifier");
+sourceCode.getTokensBefore(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getTokensBefore(AST, { count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokensBefore(AST, { includeComments: true });
+sourceCode.getTokensBefore(AST, { includeComments: true, count: 0 });
+sourceCode.getTokensBefore(AST, { includeComments: true, count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokensBefore(TOKEN, 0);
+sourceCode.getTokensBefore(COMMENT, 0);
+
+sourceCode.getTokenAfter(AST);
+sourceCode.getTokenAfter(AST, 0);
+sourceCode.getTokenAfter(AST, { skip: 0 });
+sourceCode.getTokenAfter(AST, t => t.type === "Identifier");
+sourceCode.getTokenAfter(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getTokenAfter(AST, { skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokenAfter(AST, { includeComments: true });
+sourceCode.getTokenAfter(AST, { includeComments: true, skip: 0 });
+sourceCode.getTokenAfter(AST, { includeComments: true, skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokenAfter(TOKEN, 0);
+sourceCode.getTokenAfter(COMMENT, 0);
+
+sourceCode.getTokensAfter(AST);
+sourceCode.getTokensAfter(AST, 0);
+sourceCode.getTokensAfter(AST, { count: 0 });
+sourceCode.getTokensAfter(AST, t => t.type === "Identifier");
+sourceCode.getTokensAfter(AST, { filter: t => t.type === "Identifier" });
+sourceCode.getTokensAfter(AST, { count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokensAfter(AST, { includeComments: true });
+sourceCode.getTokensAfter(AST, { includeComments: true, count: 0 });
+sourceCode.getTokensAfter(AST, { includeComments: true, count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getTokensAfter(TOKEN, 0);
+sourceCode.getTokensAfter(COMMENT, 0);
+
+sourceCode.getFirstTokenBetween(AST, AST); // $ExpectType Token | null
+sourceCode.getFirstTokenBetween(AST, AST, 0);
+sourceCode.getFirstTokenBetween(AST, AST, { skip: 0 });
+sourceCode.getFirstTokenBetween(AST, AST, (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier"); // $ExpectType (Token & { type: "Identifier"; }) | null
+// prettier-ignore
+sourceCode.getFirstTokenBetween(AST, AST, { // $ExpectType (Token & { type: "Identifier"; }) | null
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+sourceCode.getFirstTokenBetween(AST, AST, {
+    skip: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+sourceCode.getFirstTokenBetween(AST, AST, { includeComments: true }); // $ExpectType Comment | Token | null || Token | Comment | null
+sourceCode.getFirstTokenBetween(AST, AST, { includeComments: true, skip: 0 });
+// prettier-ignore
+sourceCode.getFirstTokenBetween(AST, AST, { // $ExpectType (Token & { type: "Identifier"; }) | null
+    includeComments: true,
+    skip: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+
+sourceCode.getFirstTokensBetween(AST, AST); // $ExpectType Token[]
+sourceCode.getFirstTokensBetween(AST, AST, 0);
+sourceCode.getFirstTokensBetween(AST, AST, { count: 0 });
+sourceCode.getFirstTokensBetween(AST, AST, (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier"); // $ExpectType (Token & { type: "Identifier"; })[]
+// prettier-ignore
+sourceCode.getFirstTokensBetween(AST, AST, { // $ExpectType (Token & { type: "Identifier"; })[]
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+sourceCode.getFirstTokensBetween(AST, AST, { count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getFirstTokensBetween(AST, AST, { includeComments: true }); // $ExpectType (Comment | Token)[] || (Token | Comment)[]
+sourceCode.getFirstTokensBetween(AST, AST, { includeComments: true, count: 0 });
+// prettier-ignore
+sourceCode.getFirstTokensBetween(AST, AST, { // $ExpectType (Token & { type: "Identifier"; })[]
+    includeComments: true,
+    count: 0,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+
+sourceCode.getLastTokenBetween(AST, AST);
+sourceCode.getLastTokenBetween(AST, AST, 0);
+sourceCode.getLastTokenBetween(AST, AST, { skip: 0 });
+sourceCode.getLastTokenBetween(AST, AST, t => t.type === "Identifier");
+sourceCode.getLastTokenBetween(AST, AST, { filter: t => t.type === "Identifier" });
+sourceCode.getLastTokenBetween(AST, AST, { skip: 0, filter: t => t.type === "Identifier" });
+sourceCode.getLastTokenBetween(AST, AST, { includeComments: true });
+sourceCode.getLastTokenBetween(AST, AST, { includeComments: true, skip: 0 });
+sourceCode.getLastTokenBetween(AST, AST, { includeComments: true, skip: 0, filter: t => t.type === "Identifier" });
+
+sourceCode.getLastTokensBetween(AST, AST);
+sourceCode.getLastTokensBetween(AST, AST, 0);
+sourceCode.getLastTokensBetween(AST, AST, { count: 0 });
+sourceCode.getLastTokensBetween(AST, AST, t => t.type === "Identifier");
+sourceCode.getLastTokensBetween(AST, AST, { filter: t => t.type === "Identifier" });
+sourceCode.getLastTokensBetween(AST, AST, { count: 0, filter: t => t.type === "Identifier" });
+sourceCode.getLastTokensBetween(AST, AST, { includeComments: true });
+sourceCode.getLastTokensBetween(AST, AST, { includeComments: true, count: 0 });
+sourceCode.getLastTokensBetween(AST, AST, { includeComments: true, count: 0, filter: t => t.type === "Identifier" });
+
+sourceCode.getTokensBetween(AST, AST);
+sourceCode.getTokensBetween(AST, AST, 0);
+
+sourceCode.getTokens(AST); // $ExpectType Token[]
+sourceCode.getTokens(AST, 0);
+sourceCode.getTokens(AST, 0, 0);
+sourceCode.getTokens(AST, (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier"); // $ExpectType (Token & { type: "Identifier"; })[]
+sourceCode.getTokens(AST, { filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier" }); // $ExpectType (Token & { type: "Identifier"; })[]
+sourceCode.getTokens(AST, { includeComments: true }); // $ExpectType (Comment | Token)[] || (Token | Comment)[]
+// prettier-ignore
+sourceCode.getTokens(AST, { // $ExpectType (Token & { type: "Identifier"; })[]
+    includeComments: true,
+    filter: (t): t is AST.Token & { type: "Identifier" } => t.type === "Identifier",
+});
+
+sourceCode.commentsExistBetween(AST, AST);
+sourceCode.commentsExistBetween(TOKEN, TOKEN);
+sourceCode.commentsExistBetween(COMMENT, COMMENT);
+
+sourceCode.getCommentsBefore(AST);
+sourceCode.getCommentsBefore(TOKEN);
+
+sourceCode.getCommentsAfter(AST);
+sourceCode.getCommentsAfter(TOKEN);
+
+sourceCode.getCommentsInside(AST);
+
+sourceCode.markVariableAsUsed("foo");
+sourceCode.markVariableAsUsed("foo", AST);
+
+sourceCode.getDeclaredVariables(AST); // $ExpectType Variable[]
+
+sourceCode.getAncestors(AST); // $ExpectType Node[]
+
+// #endregion
+
+// #region Scope
+
+const scopeManager: Scope.ScopeManager = {
+    scopes: [],
+    globalScope: null,
+    acquire(node, inner) {
+        return scopeManager.scopes[0];
+    },
+    getDeclaredVariables() {
+        return [];
+    },
+};
+
+const scope = scopeManager.scopes[0];
+
+const variable = scope.variables[0];
+
+variable.name = "foo";
+
+variable.identifiers[0].type = "Identifier";
+
+variable.defs[0].name.type = "Identifier";
+variable.defs[0].type;
+variable.defs[0].node;
+variable.defs[0].parent;
+
+const reference = scope.references[0];
+
+reference.from = scope;
+reference.identifier.type = "Identifier";
+reference.resolved = variable;
+reference.writeExpr = AST;
+reference.init = true;
+
+reference.isRead();
+reference.isReadOnly();
+reference.isWrite();
+reference.isWriteOnly();
+reference.isReadWrite();
+
+// #endregion
+
+// #region Rule
+
+const oldStyleRule = (context: Rule.RuleContext) => ({});
+
+let rule: Rule.RuleModule;
+
+// @ts-expect-error
+rule = oldStyleRule;
+
+rule = {
+    create(context) {
+        return {};
+    },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: {},
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: {
+        docs: {
+            description: "disallow the use of `console`",
+            category: "Possible Errors",
+            recommended: true,
+            url: "https://eslint.org/docs/rules/no-console",
+        },
+        hasSuggestions: true,
+    },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { fixable: "whitespace" },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { fixable: "code" },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { schema: [{ enum: ["always", "never"] }] },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { schema: false },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { deprecated: true, replacedBy: ["other-rule-name"] },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: { type: "layout" },
+};
+rule = {
+    create(context) {
+        return {};
+    },
+    meta: {
+        docs: {
+            description: "disallow the use of `console`",
+            category: "Possible Errors",
+            recommended: true,
+            url: "https://eslint.org/docs/rules/no-console",
+        },
+        hasSuggestions: true,
+    },
+};
+
+rule = {
+    create(context) {
+        context.getAncestors();
+
+        context.getDeclaredVariables(AST);
+
+        context.filename;
+
+        context.getFilename();
+
+        context.physicalFilename;
+
+        context.getPhysicalFilename();
+
+        context.cwd;
+
+        context.getCwd();
+
+        context.sourceCode;
+
+        context.getSourceCode();
+
+        context.getScope();
+
+        if (typeof context.parserPath === "string") {
+            context.parserPath;
+        } else {
+            context.languageOptions?.parser;
+        }
+
+        context.markVariableAsUsed("foo");
+
+        context.report({ message: "foo", node: AST });
+        context.report({ message: "foo", loc: { line: 0, column: 0 } });
+        context.report({ message: "foo", node: AST, data: { foo: "bar" } });
+        context.report({ message: "foo", node: AST, fix: () => null });
+        context.report({ message: "foo", node: AST, fix: ruleFixer => ruleFixer.replaceText(AST, "foo") });
+
+        context.report({
+            message: "foo",
+            node: AST,
+            fix: ruleFixer => {
+                ruleFixer.insertTextAfter(AST, "foo");
+                ruleFixer.insertTextAfter(TOKEN, "foo");
+
+                ruleFixer.insertTextAfterRange([0, 0], "foo");
+
+                ruleFixer.insertTextBefore(AST, "foo");
+                ruleFixer.insertTextBefore(TOKEN, "foo");
+
+                ruleFixer.insertTextBeforeRange([0, 0], "foo");
+
+                ruleFixer.remove(AST);
+                ruleFixer.remove(TOKEN);
+
+                ruleFixer.removeRange([0, 0]);
+
+                ruleFixer.replaceText(AST, "foo");
+                ruleFixer.replaceText(TOKEN, "foo");
+
+                ruleFixer.replaceTextRange([0, 0], "foo");
+
+                return null;
+            },
+        });
+
+        context.report({
+            message: "foo",
+            node: AST,
+            fix: ruleFixer => {
+                return [ruleFixer.insertTextAfter(AST, "foo"), ruleFixer.insertTextAfter(TOKEN, "foo")];
+            },
+        });
+
+        context.report({
+            message: "foo",
+            node: AST,
+            suggest: [
+                {
+                    desc: "foo",
+                    fix: ruleFixer => {
+                        return [ruleFixer.insertTextAfter(AST, "foo"), ruleFixer.insertTextAfter(TOKEN, "foo")];
+                    },
+                },
+                {
+                    messageId: "foo",
+                    fix: ruleFixer => {
+                        return [ruleFixer.insertTextAfter(AST, "foo"), ruleFixer.insertTextAfter(TOKEN, "foo")];
+                    },
+                },
+                {
+                    desc: "foo",
+                    fix: ruleFixer => null,
+                },
+            ],
+        });
+
+        return {
+            onCodePathStart(codePath, node) {
+                const origin: Rule.CodePathOrigin = codePath.origin;
+            },
+            onCodePathEnd(codePath, node) {
+                const origin: Rule.CodePathOrigin = codePath.origin;
+            },
+            onCodePathSegmentStart(segment, node) {},
+            onCodePathSegmentEnd(segment, node) {},
+            onCodePathSegmentLoop(fromSegment, toSegment, node) {},
+            IfStatement(node) {
+                node.parent;
+            },
+            WhileStatement(node: WhileStatement) {},
+            Program(node) {
+                // @ts-expect-error
+                node.parent;
+            },
+            "Program:exit"(node) {
+                node.body;
+            },
+            "IfStatement:exit"(node) {
+                node.parent;
+            },
+            "MemberExpression[object.name=\"req\"]": (node: Rule.Node) => {
+                node.parent;
+            },
+            PrivateIdentifier(node) {
+                const expected: PrivateIdentifier & Rule.NodeParentExtension = node;
+                expected.parent;
+            },
+            PropertyDefinition(node) {
+                const expected: PropertyDefinition & Rule.NodeParentExtension = node;
+                expected.parent;
+            },
+            StaticBlock(node) {
+                const expected: StaticBlock & Rule.NodeParentExtension = node;
+                expected.parent;
+            },
+        };
+    },
+};
+
+// #endregion
+
+// #region Linter
+
+const linter = new Linter();
+
+linter.version;
+
+linter.verify(SOURCE, {});
+linter.verify(new SourceCode(SOURCE, AST), {});
+
+linter.verify(SOURCE, {}, "test.js");
+linter.verify(SOURCE, {}, {});
+linter.verify(SOURCE, {}, { filename: "test.js" });
+linter.verify(SOURCE, {}, { allowInlineConfig: false });
+linter.verify(SOURCE, {}, { reportUnusedDisableDirectives: true });
+linter.verify(SOURCE, {}, { preprocess: input => input.split(" ") });
+linter.verify(SOURCE, {}, { postprocess: problemList => problemList[0] });
+
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 2021 } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 2022 } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 2023 } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 2024 } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 2025 } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: "latest" } }, "test.js");
+linter.verify(SOURCE, { parserOptions: { ecmaVersion: 6, ecmaFeatures: { globalReturn: true } } }, "test.js");
+linter.verify(
+    SOURCE,
+    { parserOptions: { ecmaVersion: 6, ecmaFeatures: { experimentalObjectRestSpread: true } } },
+    "test.js",
+);
+linter.verify(SOURCE, { env: { node: true } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: true } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: "off" } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: "readonly" } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: "readable" } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: "writable" } }, "test.js");
+linter.verify(SOURCE, { globals: { foo: "writeable" } }, "test.js");
+linter.verify(SOURCE, { parser: "custom-parser" }, "test.js");
+linter.verify(SOURCE, { settings: { info: "foo" } }, "test.js");
+linter.verify(SOURCE, { processor: "a-plugin/a-processor" }, "test.js");
+linter.verify(SOURCE, { plugins: ["a-plugin"] }, "test.js");
+linter.verify(SOURCE, { root: true }, "test.js");
+linter.verify(SOURCE, { extends: "eslint-config-bad-guy" }, "test.js");
+linter.verify(SOURCE, { extends: ["eslint-config-bad-guy", "eslint-config-roblox"] }, "test.js");
+
+linter.verify(SOURCE, { rules: {} }, "test.js");
+linter.verify(SOURCE, { rules: { quotes: 2 } }, "test.js");
+linter.verify(SOURCE, { rules: { quotes: [2, "double"] } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-unused-vars": [2, { vars: "all" }] } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-console": 1 } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-console": 0 } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-console": "error" } }, "test.js");
+linter.verify(
+    SOURCE,
+    {
+        rules: { "no-console": "error" },
+        overrides: [
+            {
+                extends: ["eslint-config-bad-guy"],
+                excludedFiles: ["*-test.js", "*.spec.js"],
+                files: ["*-test.js", "*.spec.js"],
+                rules: {
+                    "no-unused-expressions": "off",
+                },
+            },
+        ],
+    },
+    "test.js",
+);
+linter.verify(SOURCE, { rules: { "no-console": "warn" } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-console": "off" } }, "test.js");
+linter.verify(SOURCE, { rules: { "no-void": [2, { allowAsStatement: true }] } }, "test.js");
+
+const lintingResult = linter.verify(SOURCE, {});
+
+for (const msg of lintingResult) {
+    msg.severity = 1;
+    msg.severity = 2;
+
+    msg.ruleId = "foo";
+
+    msg.fatal = true;
+
+    msg.message = "foo";
+    msg.messageId = "foo";
+
+    msg.line = 0;
+    msg.endLine = 0;
+    msg.column = 0;
+    msg.endColumn = 0;
+
+    if (msg.fix) {
+        msg.fix.text = "foo";
+        msg.fix.range = [0, 0];
+    }
+
+    if (msg.suggestions) {
+        for (const suggestion of msg.suggestions) {
+            suggestion.desc = "foo";
+            suggestion.messageId = "foo";
+            suggestion.fix.text = "foo";
+            suggestion.fix.range = [0, 0];
+        }
+    }
+}
+
+linter.verifyAndFix(SOURCE, {});
+linter.verifyAndFix(SOURCE, {}, "test.js");
+linter.verifyAndFix(SOURCE, {}, { fix: false });
+
+const fixResult = linter.verifyAndFix(SOURCE, {});
+
+fixResult.fixed = true;
+fixResult.output = "foo";
+
+for (const msg of fixResult.messages) {
+    msg.ruleId = "foo";
+}
+
+sourceCode = linter.getSourceCode();
+
+linter.defineRule("test", rule);
+
+linter.defineRules({
+    foo: rule,
+    bar: rule,
+});
+
+linter.getRules();
+
+linter.defineParser("custom-parser", {
+    name: "foo",
+    version: "1.2.3",
+    meta: {
+        name: "foo",
+        version: "1.2.3",
+    },
+    parse: (src, opts) => AST,
+});
+linter.defineParser("custom-parser", {
+    name: "foo",
+    version: "1.2.3",
+    meta: {
+        name: "foo",
+        version: "1.2.3",
+    },
+    parseForESLint(src, opts) {
+        return {
+            ast: AST,
+            visitorKeys: {},
+            parserServices: {},
+            scopeManager,
+        };
+    },
+});
+
+linter.getFixPassCount(); // $ExpectType number
+
+((index: number, ruleId: string) => {
+    const pass = linter.getTimes().passes[index];
+    pass.fix.total; // $ExpectType number
+    pass.parse.total; // $ExpectType number
+    pass.rules![ruleId].total; // $ExpectType number
+    delete pass.rules;
+    pass.total; // $ExpectType number
+});
+
+const _processor: Linter.Processor = {
+    name: "foo",
+    version: "1.2.3",
+    meta: {
+        name: "foo",
+        version: "1.2.3",
+    },
+    supportsAutofix: true,
+    preprocess(text, filename) {
+        return [
+            text,
+            {
+                text: "",
+                filename: "1.js",
+            },
+        ];
+    },
+    postprocess(messages, filename) {
+        return ([] as Linter.LintMessage[]).concat(...messages);
+    },
+};
+
+// #region Linter with flat config
+
+const linterWithFlatConfig = new Linter({ configType: "flat" });
+
+linterWithFlatConfig.version;
+
+linterWithFlatConfig.verify(SOURCE, [{}]);
+linterWithFlatConfig.verify(new SourceCode(SOURCE, AST), [{}]);
+
+linterWithFlatConfig.verify(SOURCE, [{}], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{}], {});
+linterWithFlatConfig.verify(SOURCE, [{}], { filename: "test.js" });
+linterWithFlatConfig.verify(SOURCE, [{}], { allowInlineConfig: false });
+linterWithFlatConfig.verify(SOURCE, [{}], { reportUnusedDisableDirectives: true });
+linterWithFlatConfig.verify(SOURCE, [{}], { preprocess: input => input.split(" ") });
+linterWithFlatConfig.verify(SOURCE, [{}], { postprocess: problemList => problemList[0] });
+
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 2021 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 2022 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 2023 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 2024 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 2025 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: "latest" } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ languageOptions: { ecmaVersion: 6 } }], "test.js");
+linterWithFlatConfig.verify(
+    SOURCE,
+    [{
+        languageOptions: {
+            ecmaVersion: 6,
+            globals: {
+                true: true,
+                false: false,
+                foo: "readonly",
+                bar: "writable",
+                baz: "off",
+            },
+        },
+    }],
+    "test.js",
+);
+
+linterWithFlatConfig.verify(SOURCE, [{ rules: {} }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { quotes: 2 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { quotes: [2, "double"] } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-unused-vars": [2, { vars: "all" }] } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-console": 1 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-console": 0 } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-console": "error" } }], "test.js");
+linterWithFlatConfig.verify(
+    SOURCE,
+    [{
+        rules: { "no-console": "error" },
+    }, {
+        files: ["*-test.js", "*.spec.js"],
+        rules: {
+            "no-unused-expressions": "off",
+        },
+    }],
+    "test.js",
+);
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-console": "warn" } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-console": "off" } }], "test.js");
+linterWithFlatConfig.verify(SOURCE, [{ rules: { "no-void": [2, { allowAsStatement: true }] } }], "test.js");
+
+linterWithFlatConfig.verify(SOURCE, { linterOptions: {} }, "test.js");
+linterWithFlatConfig.verify(SOURCE, { linterOptions: {} }, { filename: "test.js" });
+linterWithFlatConfig.verifyAndFix(SOURCE, { linterOptions: {} }, "test.js");
+linterWithFlatConfig.verifyAndFix(SOURCE, { linterOptions: {} }, { filename: "test.js" });
+
+// #endregion Linter with flat config
+
+// #region Linter with eslintrc config
+
+const linterWithEslintrcConfig = new Linter({ configType: "eslintrc" });
+
+linterWithEslintrcConfig.version;
+
+linterWithEslintrcConfig.verify(SOURCE, {});
+linterWithEslintrcConfig.verify(new SourceCode(SOURCE, AST), {});
+
+linterWithEslintrcConfig.verify(SOURCE, {}, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, {}, {});
+linterWithEslintrcConfig.verify(SOURCE, {}, { filename: "test.js" });
+linterWithEslintrcConfig.verify(SOURCE, {}, { allowInlineConfig: false });
+linterWithEslintrcConfig.verify(SOURCE, {}, { reportUnusedDisableDirectives: true });
+linterWithEslintrcConfig.verify(SOURCE, {}, { preprocess: input => input.split(" ") });
+linterWithEslintrcConfig.verify(SOURCE, {}, { postprocess: problemList => problemList[0] });
+
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: 2021 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: 2022 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: 2023 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: 2024 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: 2025 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parserOptions: { ecmaVersion: "latest" } }, "test.js");
+linterWithEslintrcConfig.verify(
+    SOURCE,
+    { parserOptions: { ecmaVersion: 6, ecmaFeatures: { globalReturn: true } } },
+    "test.js",
+);
+linterWithEslintrcConfig.verify(
+    SOURCE,
+    { parserOptions: { ecmaVersion: 6, ecmaFeatures: { experimentalObjectRestSpread: true } } },
+    "test.js",
+);
+linterWithEslintrcConfig.verify(SOURCE, { env: { node: true } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: true } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: "off" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: "readonly" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: "readable" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: "writable" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { globals: { foo: "writeable" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { parser: "custom-parser" }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { settings: { info: "foo" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { processor: "a-plugin/a-processor" }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { plugins: ["a-plugin"] }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { root: true }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { extends: "eslint-config-bad-guy" }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { extends: ["eslint-config-bad-guy", "eslint-config-roblox"] }, "test.js");
+
+linterWithEslintrcConfig.verify(SOURCE, { rules: {} }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { quotes: 2 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { quotes: [2, "double"] } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-unused-vars": [2, { vars: "all" }] } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-console": 1 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-console": 0 } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-console": "error" } }, "test.js");
+linterWithEslintrcConfig.verify(
+    SOURCE,
+    {
+        rules: { "no-console": "error" },
+        overrides: [
+            {
+                extends: ["eslint-config-bad-guy"],
+                excludedFiles: ["*-test.js", "*.spec.js"],
+                files: ["*-test.js", "*.spec.js"],
+                rules: {
+                    "no-unused-expressions": "off",
+                },
+            },
+        ],
+    },
+    "test.js",
+);
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-console": "warn" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-console": "off" } }, "test.js");
+linterWithEslintrcConfig.verify(SOURCE, { rules: { "no-void": [2, { allowAsStatement: true }] } }, "test.js");
+
+linterWithEslintrcConfig.getRules();
+
+// #endregion Linter with eslintrc config
+
+// #endregion Linter
+
+// #region ESLint
+
+{
+    let eslint: ESLint;
+
+    eslint = new ESLint();
+    eslint = new ESLint({ allowInlineConfig: false });
+    eslint = new ESLint({ baseConfig: {} });
+    eslint = new ESLint({ overrideConfig: {} });
+    eslint = new ESLint({ overrideConfigFile: "foo" });
+    eslint = new ESLint({ cache: true });
+    eslint = new ESLint({ cacheLocation: "foo" });
+    eslint = new ESLint({ cacheStrategy: "content" });
+    eslint = new ESLint({ cwd: "foo" });
+    eslint = new ESLint({ errorOnUnmatchedPattern: true });
+    eslint = new ESLint({ fix: true });
+    eslint = new ESLint({ fix: message => false });
+    eslint = new ESLint({ fixTypes: ["directive", "problem"] });
+    eslint = new ESLint({ flags: ["foo", "bar"] });
+    eslint = new ESLint({ globInputPaths: true });
+    eslint = new ESLint({ ignore: true });
+    eslint = new ESLint({ ignorePatterns: ["foo", "bar"] });
+    eslint = new ESLint({ plugins: { foo: {} } });
+    eslint = new ESLint({
+        ruleFilter({ severity }) {
+            return severity === 1;
+        },
+    });
+    eslint = new ESLint({ stats: true });
+    eslint = new ESLint({
+        plugins: {
+            bar: {
+                name: "bar",
+                version: "1.0.0",
+                meta: {
+                    name: "bar",
+                    version: "1.0.0",
+                },
+                configs: {
+                    myConfig: {
+                        noInlineConfig: true,
+                    },
+                    production: {
+                        languageOptions: {
+                            ecmaVersion: 6,
+                        },
+                    },
+                },
+                processors: {
+                    myProcessor: {
+                        name: "blah",
+                        version: "1.2.3",
+                        meta: {
+                            name: "blah",
+                            version: "1.2.3",
+                        },
+                        supportsAutofix: false,
+                    },
+                },
+                rules: {
+                    myRule: {
+                        create(context) {
+                            return {};
+                        },
+                        meta: {},
+                    },
+                },
+            },
+        },
+    });
+
+    let resultsPromise = eslint.lintFiles(["myfile.js", "lib/"]);
+
+    resultsPromise = eslint.lintText(SOURCE, { filePath: "foo" });
+
+    eslint.calculateConfigForFile("./config.json");
+
+    eslint.isPathIgnored("./dist/index.js");
+
+    let formatterPromise: Promise<ESLint.Formatter>;
+
+    formatterPromise = eslint.loadFormatter("codeframe");
+    formatterPromise = eslint.loadFormatter();
+
+    const customFormatter1: ESLint.Formatter = { format: () => "ok" };
+    const customFormatter2: ESLint.Formatter = { format: () => Promise.resolve("ok") };
+
+    let data: ESLint.LintResultData;
+    const meta: Rule.RuleMetaData = {
+        type: "suggestion",
+        docs: {
+            description: "disallow unnecessary semicolons",
+            category: "Possible Errors",
+            recommended: true,
+            url: "https://eslint.org/docs/rules/no-extra-semi",
+        },
+        fixable: "code",
+        schema: [],
+        messages: {
+            unexpected: "Unnecessary semicolon.",
+        },
+    };
+
+    data = { cwd: "/foo/bar", rulesMeta: { "no-extra-semi": meta } };
+
+    const version: string = ESLint.version;
+
+    (async () => {
+        const results: ESLint.LintResult[] = await resultsPromise;
+        const formatter = await formatterPromise;
+
+        const output: string = await formatter.format(results, data);
+
+        eslint.getRulesMetaForResults(results);
+
+        ESLint.getErrorResults(results);
+
+        ESLint.outputFixes(results);
+    })();
+
+    const hasFooFlag: boolean = eslint.hasFlag("foo");
+}
+
+// #endregion
+
+// #region LegacyESLint
+
+{
+    let eslint: LegacyESLint;
+
+    eslint = new LegacyESLint();
+    eslint = new LegacyESLint({ allowInlineConfig: false });
+    eslint = new LegacyESLint({ baseConfig: {} });
+    eslint = new LegacyESLint({ overrideConfig: {} });
+    eslint = new LegacyESLint({ overrideConfigFile: "foo" });
+    eslint = new LegacyESLint({ cache: true });
+    eslint = new LegacyESLint({ cacheLocation: "foo" });
+    eslint = new LegacyESLint({ cacheStrategy: "content" });
+    eslint = new LegacyESLint({ cwd: "foo" });
+    eslint = new LegacyESLint({ errorOnUnmatchedPattern: true });
+    eslint = new LegacyESLint({ extensions: ["js"] });
+    eslint = new LegacyESLint({ fix: true });
+    eslint = new LegacyESLint({ fix: message => false });
+    eslint = new LegacyESLint({ fixTypes: ["directive", "problem"] });
+    eslint = new LegacyESLint({ flags: ["foo", "bar"] });
+    eslint = new LegacyESLint({ globInputPaths: true });
+    eslint = new LegacyESLint({ ignore: true });
+    eslint = new LegacyESLint({ ignorePath: "foo" });
+    eslint = new LegacyESLint({ useEslintrc: false });
+    eslint = new LegacyESLint({ plugins: { foo: {} } });
+    eslint = new LegacyESLint({
+        plugins: {
+            bar: {
+                name: "bar",
+                version: "1.0.0",
+                meta: {
+                    name: "bar",
+                    version: "1.0.0",
+                },
+                configs: {
+                    myConfig: {
+                        noInlineConfig: true,
+                    },
+                },
+                environments: {
+                    production: {
+                        parserOptions: {
+                            ecmaVersion: 6,
+                        },
+                    },
+                },
+                processors: {
+                    myProcessor: {
+                        name: "blah",
+                        version: "1.2.3",
+                        meta: {
+                            name: "blah",
+                            version: "1.2.3",
+                        },
+                        supportsAutofix: false,
+                    },
+                },
+                rules: {
+                    myRule: {
+                        create(context) {
+                            return {};
+                        },
+                        meta: {},
+                    },
+                },
+            },
+        },
+    });
+    eslint = new LegacyESLint({ reportUnusedDisableDirectives: "error" });
+    // @ts-expect-error
+    eslint = new LegacyESLint({ reportUnusedDisableDirectives: 2 });
+    eslint = new LegacyESLint({ resolvePluginsRelativeTo: "test" });
+    eslint = new LegacyESLint({ rulePaths: ["foo"] });
+
+    let resultsPromise = eslint.lintFiles(["myfile.js", "lib/"]);
+
+    resultsPromise = eslint.lintText(SOURCE, { filePath: "foo" });
+
+    eslint.calculateConfigForFile("./config.json");
+
+    eslint.isPathIgnored("./dist/index.js");
+
+    let formatterPromise: Promise<ESLint.Formatter>;
+
+    formatterPromise = eslint.loadFormatter("codeframe");
+    formatterPromise = eslint.loadFormatter();
+
+    const customFormatter1: ESLint.Formatter = { format: () => "ok" };
+    const customFormatter2: ESLint.Formatter = { format: () => Promise.resolve("ok") };
+
+    let data: ESLint.LintResultData;
+    const meta: Rule.RuleMetaData = {
+        type: "suggestion",
+        docs: {
+            description: "disallow unnecessary semicolons",
+            category: "Possible Errors",
+            recommended: true,
+            url: "https://eslint.org/docs/rules/no-extra-semi",
+        },
+        fixable: "code",
+        schema: [],
+        messages: {
+            unexpected: "Unnecessary semicolon.",
+        },
+    };
+
+    data = { cwd: "/foo/bar", rulesMeta: { "no-extra-semi": meta } };
+
+    const version: string = LegacyESLint.version;
+
+    (async () => {
+        const results: ESLint.LintResult[] = await resultsPromise;
+        const formatter = await formatterPromise;
+
+        const output: string = await formatter.format(results, data);
+
+        eslint.getRulesMetaForResults(results);
+
+        LegacyESLint.getErrorResults(results);
+
+        LegacyESLint.outputFixes(results);
+    })();
+
+    const hasFooFlag: false = eslint.hasFlag("foo");
+}
+
+// #endregion
+
+// #region ESLint.LintResult
+
+let results!: ESLint.LintResult[];
+
+for (const result of results) {
+    result.filePath = "foo.js";
+
+    result.fatalErrorCount = 0;
+    result.errorCount = 1;
+    result.warningCount = 2;
+    result.fixableErrorCount = 3;
+    result.fixableWarningCount = 4;
+
+    result.source = "foo";
+    result.output = "foo";
+
+    result.stats = {
+        fixPasses: 2,
+        times: {
+            passes: [{
+                parse: { total: 1 },
+                fix: { total: 2 },
+                total: 3,
+            }, {
+                parse: { total: 4 },
+                rules: { foo: { total: 0.5 } },
+                fix: { total: 5 },
+                total: 9,
+            }],
+        },
+    };
+    delete result.stats;
+
+    for (const message of result.messages) {
+        message.ruleId = "foo";
+    }
+
+    for (const suppressedMessage of result.suppressedMessages) {
+        suppressedMessage.suppressions = [
+            {
+                kind: "foo",
+                justification: "just cuz",
+            },
+        ];
+    }
+}
+
+// #region ESLint.LintResult
+
+// #region ESLintRules
+
+let eslintConfig: Linter.LegacyConfig<ESLintRules>;
+
+eslintConfig = {
+    rules: {
+        "capitalized-comments": [2, "always", { ignorePattern: "const|let" }],
+        "no-promise-executor-return": [2, { allowVoid: true }],
+        "sort-keys": [2, "asc", { allowLineSeparatedGroups: true }],
+    },
+    overrides: [{
+        files: "*.json",
+        rules: {
+            "max-len": 0,
+        },
+    }, {
+        files: "*.ts",
+        rules: {
+            "@typescript-eslint/no-invalid-void-type": [2, { allowAsThisParameter: true }],
+        },
+    }],
+};
+
+eslintConfig.rules; // $ExpectType Partial<ESLintRules> | undefined
+eslintConfig.overrides?.[0].rules; // $ExpectType Partial<ESLintRules> | undefined
+
+interface TSLinterRules {
+    "@typescript-eslint/no-invalid-void-type"?: Linter.RuleEntry<[
+        Partial<{
+            allowInGenericTypeArguments: boolean | string[];
+            allowAsThisParameter: boolean;
+        }>,
+    ]>;
+}
+
+const eslintConfig2: Linter.LegacyConfig<ESLintRules, ESLintRules & TSLinterRules> = eslintConfig;
+
+eslintConfig2.rules; // $ExpectType Partial<ESLintRules> | undefined
+eslintConfig2.overrides?.[1].rules; // $ExpectType Partial<ESLintRules & TSLinterRules> | undefined
+
+const eslintConfig3: Linter.LegacyConfig<ESLintRules & TSLinterRules> = eslintConfig2;
+
+eslintConfig3.rules; // $ExpectType Partial<ESLintRules & TSLinterRules> | undefined
+eslintConfig3.overrides?.[1].rules; // $ExpectType Partial<ESLintRules & TSLinterRules> | undefined
+
+// #endregion
+
+// #region RuleTester
+
+const ruleTester = new RuleTester({ languageOptions: { ecmaVersion: 2015 } });
+
+ruleTester.run("my-rule", rule, {
+    valid: [
+        { code: "foo" },
+        { code: "foo", options: [{ allowFoo: true }] },
+        { code: "foo", filename: "test.js" },
+        { code: "foo", languageOptions: { globals: { foo: true } } },
+        { code: "foo", settings: { foo: true } },
+        RuleTester.only("foo"),
+    ],
+
+    invalid: [
+        { code: "foo", errors: 1 },
+        { code: "foo", errors: 1, output: "foo" },
+        { code: "foo", errors: ["foo"] },
+        { code: "foo", errors: [{ message: "foo" }] },
+        { code: "foo", errors: [{ message: "foo", type: "foo" }] },
+        { code: "foo", errors: [{ message: "foo", data: { foo: true } }] },
+        { code: "foo", errors: [{ message: "foo", line: 0 }] },
+        {
+            code: "foo",
+            errors: [
+                {
+                    message: "foo",
+                    suggestions: [
+                        {
+                            desc: "foo",
+                            output: "foo",
+                        },
+                        {
+                            messageId: "foo",
+                            output: "foo",
+                        },
+                    ],
+                },
+            ],
+        },
+        { code: "foo", errors: 1, only: true },
+        // @ts-expect-error // `message` cannot be `undefined`
+        { code: "foo", errors: [{ message: undefined }], only: true },
+        // @ts-expect-error // `messageId` cannot be `undefined`
+        { code: "foo", errors: [{ messageId: undefined }], only: true },
+        {
+            code: "foo",
+            errors: [
+                {
+                    message: "foo",
+                    suggestions: [
+                        // @ts-expect-error // `desc` cannot be `undefined`
+                        { desc: undefined, output: "foo" },
+                        // @ts-expect-error // `messageId` cannot be `undefined`
+                        { messageId: undefined, output: "foo" },
+                    ],
+                },
+            ],
+        },
+    ],
+});
+
+RuleTester.describe = null;
+
+RuleTester.it = RuleTester.itOnly = function(text: string, fn: () => Promise<void>) {};
+
+ruleTester.run("simple-valid-test", rule, {
+    valid: ["foo", "bar", { code: "foo", options: [{ allowFoo: true }] }],
+    invalid: [{ code: "bar", errors: ["baz"] }],
+});
+
+// #endregion
+
+// #region Config
+
+((): Linter.Config => ({
+    languageOptions: {
+        parser: {
+            parse: () => AST,
+        },
+    },
+}));
+
+((): Linter.Config => ({
+    languageOptions: {
+        parser: {
+            parseForESLint: () => ({ ast: AST }),
+        },
+    },
+}));
+
+((): Linter.Config => ({
+    languageOptions: {
+        // @ts-expect-error
+        parser: "foo-parser",
+    },
+}));
+
+((): Linter.Config => ({ files: ["abc"] }));
+((): Linter.Config => ({ files: [["abc"]] }));
+
+((): Linter.Config => ({
+    // @ts-expect-error // Second level of nesting is not allowed
+    files: ["abc", ["abc"], [["abc"]]],
+}));
+
+((): Linter.Config => ({ ignores: ["abc"] }));
+
+((): Linter.Config => ({
+    // @ts-expect-error // No nesting
+    ignores: ["abc", ["abc"]],
+}));
+
+// @ts-expect-error // Must be an array
+((): Linter.Config => ({ files: "abc" }));
+
+// @ts-expect-error // Must be an array
+((): Linter.Config => ({ ignores: "abc" }));
+
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: "error" } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: "warn" } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: "off" } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: 2 } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: 1 } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: 0 } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: true } }));
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: false } }));
+
+// @ts-expect-error
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: "on" } }));
+
+// @ts-expect-error
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: 3 } }));
+
+// @ts-expect-error
+((): Linter.Config => ({ linterOptions: { reportUnusedDisableDirectives: null } }));
+
+((): Linter.Config => ({ name: "eslint:js" }));
+
+// @ts-expect-error // Generic passed in does not match the RuleEntry schema
+((): Linter.Config<{ foo?: "bar" }> => ({
+    rules: {},
+}));
+
+((): Linter.Config<{ foo?: Linter.RuleEntry<[1 | 2]> }> => ({
+    rules: {
+        foo: "error",
+    },
+}));
+
+((): Linter.Config<{ foo?: Linter.RuleEntry<[1 | 2]> }> => ({
+    rules: {
+        // @ts-expect-error // Invalid value
+        foo: ["error", 3],
+    },
+}));
+
+((): Linter.Config<{ foo?: Linter.RuleEntry }> => ({
+    rules: {
+        // @ts-expect-error // Unspecified value
+        bar: "error",
+    },
+}));
+
+((): Linter.Config<{ foo: Linter.RuleEntry<[1 | 2]>; [x: string]: Linter.RuleEntry }> => ({
+    rules: {
+        // @ts-expect-error // Invalid value
+        foo: ["error", 3],
+        // Wildcard values are supported
+        bar: 2,
+        baz: "off",
+        // @ts-expect-error // Invalid value
+        "foo/bar": "bar",
+    },
+}));
+
+// The following are only errors when `exactOptionalPropertyTypes` is `true`.
+// The error can't be enforced on consumers.
+// @ts-expect-error
+((): Linter.Config => ({ files: undefined }));
+// @ts-expect-error
+((): Linter.Config => ({ ignores: undefined }));
+
+((): ESLint.Plugin => ({
+    configs: {
+        "old-style": {
+            parser: "foo-parser",
+        },
+
+        // @ts-expect-error
+        "old-style-array": [{ parser: "foo-parser" }],
+
+        "new-style": {
+            languageOptions: {
+                parser: {
+                    parseForESLint: () => ({ ast: AST }),
+                },
+            },
+        },
+
+        "new-style-array": [{
+            languageOptions: {
+                parser: {
+                    parseForESLint: () => ({ ast: AST }),
+                },
+            },
+        }],
+    },
+}));
+
+let config!: Linter.Config;
+let flatConfig!: Linter.FlatConfig;
+config = flatConfig;
+flatConfig = config;
+
+// #endregion Config
+
+(async (useFlatConfig?: boolean) => {
+    await loadESLint(); // $ExpectType typeof ESLint | typeof LegacyESLint
+    await loadESLint({}); // $ExpectType typeof ESLint | typeof LegacyESLint
+    await loadESLint({ useFlatConfig: undefined }); // $ExpectType typeof ESLint | typeof LegacyESLint
+    await loadESLint({ useFlatConfig: true }); // $ExpectType typeof ESLint
+    await loadESLint({ useFlatConfig: false }); // $ExpectType typeof LegacyESLint
+    await loadESLint({ useFlatConfig }); // $ExpectType typeof ESLint | typeof LegacyESLint
+
+    const DefaultESLint = await loadESLint();
+    if (DefaultESLint.configType === "flat") {
+        const eslint = new DefaultESLint({ stats: true }); // $ExpectType ESLint
+    } else {
+        const eslint = new DefaultESLint({ useEslintrc: false }); // $ExpectType LegacyESLint
+    }
+});
+
+// #region use-at-your-own-risk
+
+builtinRules; // $ExpectType Map<string, RuleModule>
+
+new FileEnumerator();
+
+FlatESLint; // $ExpectType typeof ESLint
+
+shouldUseFlatConfig(); // $ExpectType Promise<boolean>
+
+// #endregion
