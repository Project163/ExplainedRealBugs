diff --git a/docs/cmdline-opts/config.md b/docs/cmdline-opts/config.md
index 2f393e27e..fa206c43b 100644
--- a/docs/cmdline-opts/config.md
+++ b/docs/cmdline-opts/config.md
@@ -28,9 +28,9 @@ is specified with one or two dashes, there can be no colon or equals character
 between the option and its parameter.
 
 If the parameter contains whitespace or starts with a colon (:) or equals sign
-(=), it must be specified enclosed within double quotes ("). Within double
-quotes the following escape sequences are available: \\, \", \t, \n, \r and
-\v. A backslash preceding any other letter is ignored.
+(=), it must be specified enclosed within double quotes ("like this"). Within
+double quotes the following escape sequences are available: \\, \", \t, \n, \r
+and \v. A backslash preceding any other letter is ignored.
 
 If the first non-blank column of a config line is a '#' character, that line
 is treated as a comment.
diff --git a/docs/cmdline-opts/gen.pl b/docs/cmdline-opts/gen.pl
index 9b3128444..17beab5b8 100755
--- a/docs/cmdline-opts/gen.pl
+++ b/docs/cmdline-opts/gen.pl
@@ -262,25 +262,9 @@ sub render {
         $d =~ s/`%VERSION`/$version/g;
         $d =~ s/`%GLOBALS`/$globals/g;
 
-        # convert single backslahes to doubles
-        $d =~ s/\\/\\\\/g;
-
         # convert backticks to double quotes
         $d =~ s/\`/\"/g;
 
-        if(!$quote && $d =~ /--/) {
-            # scan for options in longest-names first order
-            for my $k (sort {length($b) <=> length($a)} keys %optlong) {
-                # --tlsv1 is complicated since --tlsv1.2 etc are also
-                # acceptable options!
-                if(($k eq "tlsv1") && ($d =~ /--tlsv1\.[0-9]\\f/)) {
-                    next;
-                }
-                my $l = manpageify($k);
-                $d =~ s/\-\-$k([^a-z0-9-])/$l$1/g;
-            }
-        }
-
         if($d =~ /\(Added in ([0-9.]+)\)/i) {
             my $ver = $1;
             if(too_old($ver)) {
@@ -300,7 +284,23 @@ sub render {
             }
         }
         # convert backslash-'<' or '> to just the second character
-        $d =~ s/\\([<<])/$1/g;
+        $d =~ s/\\([><])/$1/g;
+        # convert single backslash to double-backslash
+        $d =~ s/\\/\\\\/g;
+
+        if(!$quote && $d =~ /--/) {
+            # scan for options in longest-names first order
+            for my $k (sort {length($b) <=> length($a)} keys %optlong) {
+                # --tlsv1 is complicated since --tlsv1.2 etc are also
+                # acceptable options!
+                if(($k eq "tlsv1") && ($d =~ /--tlsv1\.[0-9]\\f/)) {
+                    next;
+                }
+                my $l = manpageify($k);
+                $d =~ s/--$k([^a-z0-9-])/$l$1/g;
+            }
+        }
+
         # quote minuses in the output
         $d =~ s/([^\\])-/$1\\-/g;
         # replace single quotes
