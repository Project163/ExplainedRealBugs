diff --git a/docs/libcurl/curl_ws_start_frame.md b/docs/libcurl/curl_ws_start_frame.md
index efce758a6..cf67d33bf 100644
--- a/docs/libcurl/curl_ws_start_frame.md
+++ b/docs/libcurl/curl_ws_start_frame.md
@@ -46,6 +46,14 @@ the data belonging to the frame.
 The function fails, if a previous frame has not been completely
 read yet. Also it fails in *CURLWS_RAW_MODE*.
 
+The read function in libcurl usually treats a return value of 0
+as the end of file indication and stops any further reads. This
+would prevent sending WebSocket frames of length 0.
+
+If the read function calls `curl_ws_start_frame()` however, a return
+value of 0 is *not* treated as an end of file and libcurl calls
+the read function again.
+
 # FLAGS
 
 Supports all flags documented in curl_ws_meta(3).
diff --git a/lib/cw-out.c b/lib/cw-out.c
index ee7dc65df..c2c2f49c0 100644
--- a/lib/cw-out.c
+++ b/lib/cw-out.c
@@ -74,6 +74,7 @@
 typedef enum {
   CW_OUT_NONE,
   CW_OUT_BODY,
+  CW_OUT_BODY_0LEN,
   CW_OUT_HDS
 } cw_out_type;
 
@@ -170,6 +171,7 @@ static void cw_get_writefunc(struct Curl_easy *data, cw_out_type otype,
 {
   switch(otype) {
   case CW_OUT_BODY:
+  case CW_OUT_BODY_0LEN:
     *pwcb = data->set.fwrite_func;
     *pwcb_data = data->set.out;
     *pmax_write = CURL_MAX_WRITE_SIZE;
@@ -217,40 +219,50 @@ static CURLcode cw_out_ptr_flush(struct cw_out_ctx *ctx,
   }
 
   *pconsumed = 0;
-  while(blen && !ctx->paused) {
-    if(!flush_all && blen < min_write)
-      break;
-    wlen = max_write ? CURLMIN(blen, max_write) : blen;
+  if(otype == CW_OUT_BODY_0LEN) {
+    DEBUGASSERT(!blen);
     Curl_set_in_callback(data, TRUE);
-    nwritten = wcb((char *)CURL_UNCONST(buf), 1, wlen, wcb_data);
+    nwritten = wcb((char *)CURL_UNCONST(buf), 1, blen, wcb_data);
     Curl_set_in_callback(data, FALSE);
-    CURL_TRC_WRITE(data, "[OUT] wrote %zu %s bytes -> %zu",
-                   wlen, (otype == CW_OUT_BODY) ? "body" : "header",
-                   nwritten);
-    if(CURL_WRITEFUNC_PAUSE == nwritten) {
-      if(data->conn && data->conn->handler->flags & PROTOPT_NONETWORK) {
-        /* Protocols that work without network cannot be paused. This is
-           actually only FILE:// just now, and it cannot pause since the
-           transfer is not done using the "normal" procedure. */
-        failf(data, "Write callback asked for PAUSE when not supported");
+    CURL_TRC_WRITE(data, "[OUT] wrote %zu BODY bytes -> %zu",
+                   blen, nwritten);
+  }
+  else {
+    while(blen && !ctx->paused) {
+      if(!flush_all && blen < min_write)
+        break;
+      wlen = max_write ? CURLMIN(blen, max_write) : blen;
+      Curl_set_in_callback(data, TRUE);
+      nwritten = wcb((char *)CURL_UNCONST(buf), 1, wlen, wcb_data);
+      Curl_set_in_callback(data, FALSE);
+      CURL_TRC_WRITE(data, "[OUT] wrote %zu %s bytes -> %zu",
+                     wlen, (otype == CW_OUT_BODY) ? "body" : "header",
+                     nwritten);
+      if(CURL_WRITEFUNC_PAUSE == nwritten) {
+        if(data->conn && data->conn->handler->flags & PROTOPT_NONETWORK) {
+          /* Protocols that work without network cannot be paused. This is
+             actually only FILE:// just now, and it cannot pause since the
+             transfer is not done using the "normal" procedure. */
+          failf(data, "Write callback asked for PAUSE when not supported");
+          return CURLE_WRITE_ERROR;
+        }
+        ctx->paused = TRUE;
+        CURL_TRC_WRITE(data, "[OUT] PAUSE requested by client");
+        return Curl_xfer_pause_recv(data, TRUE);
+      }
+      else if(CURL_WRITEFUNC_ERROR == nwritten) {
+        failf(data, "client returned ERROR on write of %zu bytes", wlen);
         return CURLE_WRITE_ERROR;
       }
-      ctx->paused = TRUE;
-      CURL_TRC_WRITE(data, "[OUT] PAUSE requested by client");
-      return Curl_xfer_pause_recv(data, TRUE);
-    }
-    else if(CURL_WRITEFUNC_ERROR == nwritten) {
-      failf(data, "client returned ERROR on write of %zu bytes", wlen);
-      return CURLE_WRITE_ERROR;
-    }
-    else if(nwritten != wlen) {
-      failf(data, "Failure writing output to destination, "
-            "passed %zu returned %zd", wlen, nwritten);
-      return CURLE_WRITE_ERROR;
+      else if(nwritten != wlen) {
+        failf(data, "Failure writing output to destination, "
+              "passed %zu returned %zd", wlen, nwritten);
+        return CURLE_WRITE_ERROR;
+      }
+      *pconsumed += nwritten;
+      blen -= nwritten;
+      buf += nwritten;
     }
-    *pconsumed += nwritten;
-    blen -= nwritten;
-    buf += nwritten;
   }
   return CURLE_OK;
 }
@@ -413,7 +425,9 @@ static CURLcode cw_out_write(struct Curl_easy *data,
 
   if((type & CLIENTWRITE_BODY) ||
      ((type & CLIENTWRITE_HEADER) && data->set.include_header)) {
-    result = cw_out_do_write(ctx, data, CW_OUT_BODY, flush_all, buf, blen);
+    cw_out_type otype = (!blen && (type & CLIENTWRITE_0LEN)) ?
+                        CW_OUT_BODY_0LEN : CW_OUT_BODY;
+    result = cw_out_do_write(ctx, data, otype, flush_all, buf, blen);
     if(result)
       return result;
   }
diff --git a/lib/http.c b/lib/http.c
index 06ab3f164..bf584e093 100644
--- a/lib/http.c
+++ b/lib/http.c
@@ -4836,8 +4836,7 @@ static const struct Curl_crtype cr_exp100 = {
   Curl_creader_def_needs_rewind,
   Curl_creader_def_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   cr_exp100_done,
   sizeof(struct cr_exp100_ctx)
diff --git a/lib/http_chunks.c b/lib/http_chunks.c
index f014a256a..f735a820c 100644
--- a/lib/http_chunks.c
+++ b/lib/http_chunks.c
@@ -656,8 +656,7 @@ const struct Curl_crtype Curl_httpchunk_encoder = {
   Curl_creader_def_needs_rewind,
   cr_chunked_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct chunked_reader)
diff --git a/lib/mime.c b/lib/mime.c
index 3d4eef767..f480bc704 100644
--- a/lib/mime.c
+++ b/lib/mime.c
@@ -2150,22 +2150,27 @@ static CURLcode cr_mime_resume_from(struct Curl_easy *data,
   return CURLE_OK;
 }
 
-static CURLcode cr_mime_rewind(struct Curl_easy *data,
-                               struct Curl_creader *reader)
+static CURLcode cr_mime_cntrl(struct Curl_easy *data,
+                              struct Curl_creader *reader,
+                              Curl_creader_cntrl opcode)
 {
   struct cr_mime_ctx *ctx = reader->ctx;
-  CURLcode result = mime_rewind(ctx->part);
-  if(result)
-    failf(data, "Cannot rewind mime/post data");
-  return result;
-}
-
-static CURLcode cr_mime_unpause(struct Curl_easy *data,
-                                struct Curl_creader *reader)
-{
-  struct cr_mime_ctx *ctx = reader->ctx;
-  (void)data;
-  mime_unpause(ctx->part);
+  switch(opcode) {
+  case CURL_CRCNTRL_REWIND: {
+    CURLcode result = mime_rewind(ctx->part);
+    if(result)
+      failf(data, "Cannot rewind mime/post data");
+    return result;
+  }
+  case CURL_CRCNTRL_UNPAUSE:
+    mime_unpause(ctx->part);
+    break;
+  case CURL_CRCNTRL_CLEAR_EOS:
+    ctx->seen_eos = FALSE;
+    break;
+  default:
+    break;
+  }
   return CURLE_OK;
 }
 
@@ -2185,8 +2190,7 @@ static const struct Curl_crtype cr_mime = {
   cr_mime_needs_rewind,
   cr_mime_total_length,
   cr_mime_resume_from,
-  cr_mime_rewind,
-  cr_mime_unpause,
+  cr_mime_cntrl,
   cr_mime_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_mime_ctx)
diff --git a/lib/sendf.c b/lib/sendf.c
index 43b30ecc7..9959de4ea 100644
--- a/lib/sendf.c
+++ b/lib/sendf.c
@@ -151,7 +151,7 @@ CURLcode Curl_client_start(struct Curl_easy *data)
 
     CURL_TRC_READ(data, "client start, rewind readers");
     while(r) {
-      result = r->crt->rewind(data, r);
+      result = r->crt->cntrl(data, r, CURL_CRCNTRL_REWIND);
       if(result) {
         failf(data, "rewind of client reader '%s' failed: %d",
               r->crt->name, result);
@@ -543,6 +543,15 @@ CURLcode Curl_creader_read(struct Curl_easy *data,
   return reader->crt->do_read(data, reader, buf, blen, nread, eos);
 }
 
+void Curl_creader_clear_eos(struct Curl_easy *data,
+                            struct Curl_creader *reader)
+{
+  while(reader) {
+    (void)reader->crt->cntrl(data, reader, CURL_CRCNTRL_CLEAR_EOS);
+    reader = reader->next;
+  }
+}
+
 CURLcode Curl_creader_def_init(struct Curl_easy *data,
                                struct Curl_creader *reader)
 {
@@ -598,19 +607,13 @@ CURLcode Curl_creader_def_resume_from(struct Curl_easy *data,
   return CURLE_READ_ERROR;
 }
 
-CURLcode Curl_creader_def_rewind(struct Curl_easy *data,
-                                 struct Curl_creader *reader)
-{
-  (void)data;
-  (void)reader;
-  return CURLE_OK;
-}
-
-CURLcode Curl_creader_def_unpause(struct Curl_easy *data,
-                                  struct Curl_creader *reader)
+CURLcode Curl_creader_def_cntrl(struct Curl_easy *data,
+                                struct Curl_creader *reader,
+                                Curl_creader_cntrl opcode)
 {
   (void)data;
   (void)reader;
+  (void)opcode;
   return CURLE_OK;
 }
 
@@ -891,12 +894,24 @@ static CURLcode cr_in_rewind(struct Curl_easy *data,
   return CURLE_OK;
 }
 
-static CURLcode cr_in_unpause(struct Curl_easy *data,
-                              struct Curl_creader *reader)
+static CURLcode cr_in_cntrl(struct Curl_easy *data,
+                            struct Curl_creader *reader,
+                            Curl_creader_cntrl opcode)
 {
   struct cr_in_ctx *ctx = reader->ctx;
-  (void)data;
-  ctx->is_paused = FALSE;
+
+  switch(opcode) {
+  case CURL_CRCNTRL_REWIND:
+    return cr_in_rewind(data, reader);
+  case CURL_CRCNTRL_UNPAUSE:
+    ctx->is_paused = FALSE;
+    break;
+  case CURL_CRCNTRL_CLEAR_EOS:
+    ctx->seen_eos = FALSE;
+    break;
+  default:
+    break;
+  }
   return CURLE_OK;
 }
 
@@ -916,8 +931,7 @@ static const struct Curl_crtype cr_in = {
   cr_in_needs_rewind,
   cr_in_total_length,
   cr_in_resume_from,
-  cr_in_rewind,
-  cr_in_unpause,
+  cr_in_cntrl,
   cr_in_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_in_ctx)
@@ -1077,8 +1091,7 @@ static const struct Curl_crtype cr_lc = {
   Curl_creader_def_needs_rewind,
   cr_lc_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_lc_ctx)
@@ -1251,8 +1264,7 @@ static const struct Curl_crtype cr_null = {
   Curl_creader_def_needs_rewind,
   cr_null_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct Curl_creader)
@@ -1312,12 +1324,19 @@ static bool cr_buf_needs_rewind(struct Curl_easy *data,
   return ctx->index > 0;
 }
 
-static CURLcode cr_buf_rewind(struct Curl_easy *data,
-                              struct Curl_creader *reader)
+static CURLcode cr_buf_cntrl(struct Curl_easy *data,
+                             struct Curl_creader *reader,
+                             Curl_creader_cntrl opcode)
 {
   struct cr_buf_ctx *ctx = reader->ctx;
   (void)data;
-  ctx->index = 0;
+  switch(opcode) {
+  case CURL_CRCNTRL_REWIND:
+    ctx->index = 0;
+    break;
+  default:
+    break;
+  }
   return CURLE_OK;
 }
 
@@ -1360,8 +1379,7 @@ static const struct Curl_crtype cr_buf = {
   cr_buf_needs_rewind,
   cr_buf_total_length,
   cr_buf_resume_from,
-  cr_buf_rewind,
-  Curl_creader_def_unpause,
+  cr_buf_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_buf_ctx)
@@ -1417,7 +1435,7 @@ CURLcode Curl_creader_unpause(struct Curl_easy *data)
   CURLcode result = CURLE_OK;
 
   while(reader) {
-    result = reader->crt->unpause(data, reader);
+    result = reader->crt->cntrl(data, reader, CURL_CRCNTRL_UNPAUSE);
     if(result)
       break;
     reader = reader->next;
diff --git a/lib/sendf.h b/lib/sendf.h
index e5cc600bf..686744390 100644
--- a/lib/sendf.h
+++ b/lib/sendf.h
@@ -50,6 +50,7 @@
 #define CLIENTWRITE_1XX     (1<<5) /* a 1xx response related HEADER */
 #define CLIENTWRITE_TRAILER (1<<6) /* a trailer HEADER */
 #define CLIENTWRITE_EOS     (1<<7) /* End Of transfer download Stream */
+#define CLIENTWRITE_0LEN    (1<<8) /* write even 0-length buffers */
 
 /**
  * Write `len` bytes at `prt` to the client. `type` indicates what
@@ -202,6 +203,11 @@ void Curl_cwriter_def_close(struct Curl_easy *data,
                             struct Curl_cwriter *writer);
 
 
+typedef enum {
+  CURL_CRCNTRL_REWIND,
+  CURL_CRCNTRL_UNPAUSE,
+  CURL_CRCNTRL_CLEAR_EOS
+} Curl_creader_cntrl;
 
 /* Client Reader Type, provides the implementation */
 struct Curl_crtype {
@@ -215,8 +221,8 @@ struct Curl_crtype {
                              struct Curl_creader *reader);
   CURLcode (*resume_from)(struct Curl_easy *data,
                           struct Curl_creader *reader, curl_off_t offset);
-  CURLcode (*rewind)(struct Curl_easy *data, struct Curl_creader *reader);
-  CURLcode (*unpause)(struct Curl_easy *data, struct Curl_creader *reader);
+  CURLcode (*cntrl)(struct Curl_easy *data, struct Curl_creader *reader,
+                    Curl_creader_cntrl opcode);
   bool (*is_paused)(struct Curl_easy *data, struct Curl_creader *reader);
   void (*done)(struct Curl_easy *data,
                struct Curl_creader *reader, int premature);
@@ -264,10 +270,9 @@ curl_off_t Curl_creader_def_total_length(struct Curl_easy *data,
 CURLcode Curl_creader_def_resume_from(struct Curl_easy *data,
                                       struct Curl_creader *reader,
                                       curl_off_t offset);
-CURLcode Curl_creader_def_rewind(struct Curl_easy *data,
-                                 struct Curl_creader *reader);
-CURLcode Curl_creader_def_unpause(struct Curl_easy *data,
-                                  struct Curl_creader *reader);
+CURLcode Curl_creader_def_cntrl(struct Curl_easy *data,
+                                struct Curl_creader *reader,
+                                Curl_creader_cntrl opcode);
 bool Curl_creader_def_is_paused(struct Curl_easy *data,
                                 struct Curl_creader *reader);
 void Curl_creader_def_done(struct Curl_easy *data,
@@ -281,6 +286,10 @@ CURLcode Curl_creader_read(struct Curl_easy *data,
                            struct Curl_creader *reader,
                            char *buf, size_t blen, size_t *nread, bool *eos);
 
+/* Tell the reader and all below that any EOS state is to be cleared */
+void Curl_creader_clear_eos(struct Curl_easy *data,
+                            struct Curl_creader *reader);
+
 /**
  * Create a new creader instance with given type and phase. Is not
  * inserted into the writer chain by this call.
diff --git a/lib/smtp.c b/lib/smtp.c
index 97083e41f..c52cf0dc5 100644
--- a/lib/smtp.c
+++ b/lib/smtp.c
@@ -2069,8 +2069,7 @@ static const struct Curl_crtype cr_eob = {
   Curl_creader_def_needs_rewind,
   cr_eob_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_eob_ctx)
diff --git a/lib/ws.c b/lib/ws.c
index 82b8a2c22..b6434b0b8 100644
--- a/lib/ws.c
+++ b/lib/ws.c
@@ -474,7 +474,7 @@ static CURLcode ws_dec_read_head(struct ws_decoder *dec,
 static CURLcode ws_dec_pass_payload(struct ws_decoder *dec,
                                     struct Curl_easy *data,
                                     struct bufq *inraw,
-                                    ws_write_payload *write_payload,
+                                    ws_write_payload *write_cb,
                                     void *write_ctx)
 {
   const unsigned char *inbuf;
@@ -487,9 +487,9 @@ static CURLcode ws_dec_pass_payload(struct ws_decoder *dec,
   while(remain && Curl_bufq_peek(inraw, &inbuf, &inlen)) {
     if((curl_off_t)inlen > remain)
       inlen = (size_t)remain;
-    nwritten = write_payload(inbuf, inlen, dec->frame_age, dec->frame_flags,
-                             dec->payload_offset, dec->payload_len,
-                             write_ctx, &result);
+    nwritten = write_cb(inbuf, inlen, dec->frame_age, dec->frame_flags,
+                        dec->payload_offset, dec->payload_len,
+                        write_ctx, &result);
     if(nwritten < 0)
       return result;
     Curl_bufq_skip(inraw, (size_t)nwritten);
@@ -505,7 +505,7 @@ static CURLcode ws_dec_pass_payload(struct ws_decoder *dec,
 static CURLcode ws_dec_pass(struct ws_decoder *dec,
                             struct Curl_easy *data,
                             struct bufq *inraw,
-                            ws_write_payload *write_payload,
+                            ws_write_payload *write_cb,
                             void *write_ctx)
 {
   CURLcode result;
@@ -535,8 +535,8 @@ static CURLcode ws_dec_pass(struct ws_decoder *dec,
       ssize_t nwritten;
       const unsigned char tmp = '\0';
       /* special case of a 0 length frame, need to write once */
-      nwritten = write_payload(&tmp, 0, dec->frame_age, dec->frame_flags,
-                               0, 0, write_ctx, &result);
+      nwritten = write_cb(&tmp, 0, dec->frame_age, dec->frame_flags,
+                          0, 0, write_ctx, &result);
       if(nwritten < 0)
         return result;
       dec->state = WS_DEC_INIT;
@@ -544,7 +544,7 @@ static CURLcode ws_dec_pass(struct ws_decoder *dec,
     }
     FALLTHROUGH();
   case WS_DEC_PAYLOAD:
-    result = ws_dec_pass_payload(dec, data, inraw, write_payload, write_ctx);
+    result = ws_dec_pass_payload(dec, data, inraw, write_cb, write_ctx);
     ws_dec_info(dec, data, "passing");
     if(result)
       return result;
@@ -631,7 +631,8 @@ static ssize_t ws_cw_dec_next(const unsigned char *buf, size_t buflen,
     update_meta(ws, frame_age, frame_flags, payload_offset,
                 payload_len, buflen);
 
-    *err = Curl_cwriter_write(data, ctx->next_writer, ctx->cw_type,
+    *err = Curl_cwriter_write(data, ctx->next_writer,
+                              (ctx->cw_type | CLIENTWRITE_0LEN),
                               (const char *)buf, buflen);
     if(*err)
       return -1;
@@ -943,7 +944,12 @@ static CURLcode cr_ws_read(struct Curl_easy *data,
       return result;
     ctx->read_eos = eos;
 
-    if(!nread) {
+    if(!Curl_bufq_is_empty(&ws->sendbuf)) {
+      /* client_read started a new frame, we disregard any eos reported */
+      ctx->read_eos = FALSE;
+      Curl_creader_clear_eos(data, reader->next);
+    }
+    else if(!nread) {
       /* nothing to convert, return this right away */
       if(ctx->read_eos)
         ctx->eos = TRUE;
@@ -952,7 +958,7 @@ static CURLcode cr_ws_read(struct Curl_easy *data,
       goto out;
     }
 
-    if(!ws->enc.payload_remain) {
+    if(!ws->enc.payload_remain && Curl_bufq_is_empty(&ws->sendbuf)) {
       /* encode the data as a new BINARY frame */
       result = ws_enc_write_head(data, &ws->enc, CURLWS_BINARY, nread,
                                  &ws->sendbuf);
@@ -990,8 +996,7 @@ static const struct Curl_crtype ws_cr_encode = {
   Curl_creader_def_needs_rewind,
   Curl_creader_def_total_length,
   Curl_creader_def_resume_from,
-  Curl_creader_def_rewind,
-  Curl_creader_def_unpause,
+  Curl_creader_def_cntrl,
   Curl_creader_def_is_paused,
   Curl_creader_def_done,
   sizeof(struct cr_ws_ctx)
@@ -1732,7 +1737,7 @@ CURL_EXTERN CURLcode curl_ws_start_frame(CURL *d,
     return CURLE_FAILED_INIT;
   }
 
-  CURL_TRC_WS(data, "curl_start_frame(flags=%x, frame_len=%" FMT_OFF_T,
+  CURL_TRC_WS(data, "curl_ws_start_frame(flags=%x, frame_len=%" FMT_OFF_T,
               flags, frame_len);
 
   if(!data->conn) {
diff --git a/tests/http/test_20_websockets.py b/tests/http/test_20_websockets.py
index c28b610f5..2612b0afe 100644
--- a/tests/http/test_20_websockets.py
+++ b/tests/http/test_20_websockets.py
@@ -135,7 +135,7 @@ class TestWebsockets:
         if not client.exists():
             pytest.skip(f'example client not built: {client.name}')
         url = f'ws://localhost:{env.ws_port}/'
-        r = client.run(args=[f'-{model}', '-m', str(0), '-M', str(10), url])
+        r = client.run(args=[f'-{model}', '-m', str(1), '-M', str(10), url])
         r.check_exit_code(0)
 
     @pytest.mark.parametrize("model", [
@@ -193,3 +193,17 @@ class TestWebsockets:
         large = 20000
         r = client.run(args=[f'-{model}', '-c', str(count), '-m', str(large), url])
         r.check_exit_code(0)
+
+    @pytest.mark.parametrize("model", [
+        pytest.param(1, id='multi_perform'),
+        pytest.param(2, id='curl_ws_send+recv'),
+    ])
+    def test_20_09_data_empty(self, env: Env, ws_echo, model):
+        client = LocalClient(env=env, name='cli_ws_data')
+        if not client.exists():
+            pytest.skip(f'example client not built: {client.name}')
+        url = f'ws://localhost:{env.ws_port}/'
+        count = 10
+        large = 0
+        r = client.run(args=[f'-{model}', '-c', str(count), '-m', str(large), url])
+        r.check_exit_code(0)
diff --git a/tests/libtest/cli_ws_data.c b/tests/libtest/cli_ws_data.c
index 501c01eae..36d5dea25 100644
--- a/tests/libtest/cli_ws_data.c
+++ b/tests/libtest/cli_ws_data.c
@@ -195,6 +195,12 @@ struct test_ws_m1_ctx {
   char *recv_buf;
   size_t send_len, nsent;
   size_t recv_len, nrcvd;
+  int nframes;
+  int read_calls;
+  int write_calls;
+  int frames_read;
+  int frames_written;
+  BIT(frame_reading);
 };
 
 static size_t test_ws_data_m1_read(char *buf, size_t nitems, size_t buflen,
@@ -204,15 +210,37 @@ static size_t test_ws_data_m1_read(char *buf, size_t nitems, size_t buflen,
   size_t len = nitems * buflen;
   size_t left = ctx->send_len - ctx->nsent;
 
-  curl_mfprintf(stderr, "m1_read(len=%zu, left=%zu)\n", len, left);
-  if(left) {
+  ctx->read_calls++;
+
+  if(ctx->frames_read >= ctx->nframes)
+    goto out;
+
+  if(!ctx->frame_reading) {
+    curl_ws_start_frame(ctx->easy, CURLWS_BINARY, ctx->send_len);
+    ctx->frame_reading = TRUE;
+  }
+
+  if(ctx->frame_reading) {
+    bool complete;
     if(left > len)
       left = len;
     memcpy(buf, ctx->send_buf + ctx->nsent, left);
     ctx->nsent += left;
+    complete = (ctx->send_len == ctx->nsent);
+    curl_mfprintf(stderr, "m1_read(len=%zu, call #%d, frame #%d%s) -> %zu\n",
+                  len, ctx->read_calls, ctx->frames_read,
+                  complete ? " complete" : "", left);
+    if(complete) {
+      ++ctx->frames_read;
+      ctx->frame_reading = FALSE;
+      ctx->nsent = 0;
+    }
     return left;
   }
-  return CURL_READFUNC_PAUSE;
+out:
+  curl_mfprintf(stderr, "m1_read(len=%zu, call #%d) -> EOS\n",
+                len, ctx->read_calls);
+  return 0;
 }
 
 static size_t test_ws_data_m1_write(char *buf, size_t nitems, size_t buflen,
@@ -220,18 +248,41 @@ static size_t test_ws_data_m1_write(char *buf, size_t nitems, size_t buflen,
 {
   struct test_ws_m1_ctx *ctx = userdata;
   size_t len = nitems * buflen;
+  bool complete;
 
-  curl_mfprintf(stderr, "m1_write(len=%zu)\n", len);
-  if(len > (ctx->recv_len - ctx->nrcvd))
+  ctx->write_calls++;
+  if(len > (ctx->recv_len - ctx->nrcvd)) {
+    curl_mfprintf(stderr, "m1_write(len=%zu, call #%d) -> ERROR\n",
+                  len, ctx->write_calls);
     return CURL_WRITEFUNC_ERROR;
+  }
   memcpy(ctx->recv_buf + ctx->nrcvd, buf, len);
   ctx->nrcvd += len;
+  complete = (ctx->recv_len == ctx->nrcvd);
+
+  if(memcmp(ctx->send_buf, ctx->recv_buf, ctx->nrcvd)) {
+    curl_mfprintf(stderr, "m1_write(len=%zu, call #%d, frame #%d) -> "
+                  "data differs\n",
+                  len, ctx->write_calls, ctx->frames_written);
+    debug_dump("", "expected:", stderr,
+               (unsigned char *)ctx->send_buf, ctx->nrcvd, 0);
+    debug_dump("", "received:", stderr,
+               (unsigned char *)ctx->recv_buf, ctx->nrcvd, 0);
+    return CURL_WRITEFUNC_ERROR;
+  }
+
+  curl_mfprintf(stderr, "m1_write(len=%zu, call #%d, frame #%d%s) -> %zu\n",
+                len, ctx->write_calls, ctx->frames_written,
+                complete ? " complete" : "", len);
+  if(complete) {
+    ++ctx->frames_written;
+    ctx->nrcvd = 0;
+  }
   return len;
 }
 
 /* WebSocket Mode 1: multi handle, READ/WRITEFUNCTION use */
 static CURLcode test_ws_data_m1_echo(const char *url,
-                                     size_t count,
                                      size_t plen_min,
                                      size_t plen_max)
 {
@@ -240,6 +291,8 @@ static CURLcode test_ws_data_m1_echo(const char *url,
   struct test_ws_m1_ctx m1_ctx;
   size_t i, len;
 
+  curl_mfprintf(stderr, "test_ws_data_m1_echo(min=%zu, max=%zu)\n",
+                plen_min, plen_max);
   memset(&m1_ctx, 0, sizeof(m1_ctx));
   m1_ctx.send_buf = calloc(1, plen_max + 1);
   m1_ctx.recv_buf = calloc(1, plen_max + 1);
@@ -263,59 +316,71 @@ static CURLcode test_ws_data_m1_echo(const char *url,
     goto out;
   }
 
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_URL, url);
-  /* use the callback style */
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_USERAGENT, "ws-data");
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_VERBOSE, 1L);
-  /* we want to send */
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_UPLOAD, 1L);
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_READFUNCTION, test_ws_data_m1_read);
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_READDATA, &m1_ctx);
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_WRITEFUNCTION, test_ws_data_m1_write);
-  curl_easy_setopt(m1_ctx.easy, CURLOPT_WRITEDATA, &m1_ctx);
-
-  curl_multi_add_handle(multi, m1_ctx.easy);
-
   for(len = plen_min; len <= plen_max; ++len) {
     /* init what we want to send and expect to receive */
+    curl_mfprintf(stderr, "m1_echo, iter len=%zu\n", len);
+
     m1_ctx.send_len = len;
     m1_ctx.nsent = 0;
     m1_ctx.recv_len = len;
     m1_ctx.nrcvd = 0;
+    m1_ctx.nframes = 2;
+    m1_ctx.read_calls = 0;
+    m1_ctx.write_calls = 0;
+    m1_ctx.frames_read = 0;
+    m1_ctx.frames_written = 0;
     memset(m1_ctx.recv_buf, 0, plen_max);
     curl_easy_pause(m1_ctx.easy, CURLPAUSE_CONT);
 
-    for(i = 0; i < count; ++i) {
-      while(1) {
-        int still_running; /* keep number of running handles */
-        CURLMcode mc = curl_multi_perform(multi, &still_running);
-
-        if(!still_running || (m1_ctx.nrcvd == m1_ctx.recv_len)) {
-          /* got the full echo back or failed */
-          break;
-        }
-
-        if(!mc && still_running) {
-          mc = curl_multi_poll(multi, NULL, 0, 1, NULL);
-        }
-        if(mc) {
-          r = CURLE_RECV_ERROR;
-          goto out;
-        }
-
+    curl_easy_reset(m1_ctx.easy);
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_URL, url);
+    /* use the callback style */
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_USERAGENT, "ws-data");
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_VERBOSE, 1L);
+    /* we want to send */
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_UPLOAD, 1L);
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_READFUNCTION, test_ws_data_m1_read);
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_READDATA, &m1_ctx);
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_WRITEFUNCTION,
+                     test_ws_data_m1_write);
+    curl_easy_setopt(m1_ctx.easy, CURLOPT_WRITEDATA, &m1_ctx);
+
+    curl_multi_add_handle(multi, m1_ctx.easy);
+
+    while(1) {
+      int still_running; /* keep number of running handles */
+      CURLMcode mc = curl_multi_perform(multi, &still_running);
+
+      if(!still_running || (m1_ctx.frames_written >= m1_ctx.nframes)) {
+        /* got the full echo back or failed */
+        break;
       }
 
-      if(memcmp(m1_ctx.send_buf, m1_ctx.recv_buf, m1_ctx.send_len)) {
-        curl_mfprintf(stderr, "recv_data: data differs\n");
-        debug_dump("", "expected:", stderr,
-                   (unsigned char *)m1_ctx.send_buf, m1_ctx.send_len, 0);
-        debug_dump("", "received:", stderr,
-                   (unsigned char *)m1_ctx.recv_buf, m1_ctx.nrcvd, 0);
+      if(!mc && still_running) {
+        mc = curl_multi_poll(multi, NULL, 0, 1, NULL);
+      }
+      if(mc) {
         r = CURLE_RECV_ERROR;
         goto out;
       }
 
     }
+
+    curl_multi_remove_handle(multi, m1_ctx.easy);
+
+    /* check results */
+    if(m1_ctx.frames_read < m1_ctx.nframes) {
+      curl_mfprintf(stderr, "m1_echo, sent only %d/%d frames\n",
+                    m1_ctx.frames_read, m1_ctx.nframes);
+      r = CURLE_SEND_ERROR;
+      goto out;
+    }
+    if(m1_ctx.frames_written < m1_ctx.frames_read) {
+      curl_mfprintf(stderr, "m1_echo, received only %d/%d frames\n",
+                    m1_ctx.frames_written, m1_ctx.frames_read);
+      r = CURLE_RECV_ERROR;
+      goto out;
+    }
   }
 
 out:
@@ -403,7 +468,7 @@ static CURLcode test_cli_ws_data(const char *URL)
   curl_global_init(CURL_GLOBAL_ALL);
 
   if(model == 1)
-    res = test_ws_data_m1_echo(url, count, plen_min, plen_max);
+    res = test_ws_data_m1_echo(url, plen_min, plen_max);
   else
     res = test_ws_data_m2_echo(url, count, plen_min, plen_max);
 
