diff --git a/lib/vquic/curl_ngtcp2.c b/lib/vquic/curl_ngtcp2.c
index 6b6b8874c..317513ea9 100644
--- a/lib/vquic/curl_ngtcp2.c
+++ b/lib/vquic/curl_ngtcp2.c
@@ -202,7 +202,8 @@ static void h3_data_done(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   (void)cf;
   if(stream) {
-    CURL_TRC_CF(data, cf, "[%"PRId64"] easy handle is done", stream->id);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] easy handle is done",
+                stream->id);
     if(ctx->h3conn && !stream->closed) {
       nghttp3_conn_shutdown_stream_read(ctx->h3conn, stream->id);
       nghttp3_conn_close_stream(ctx->h3conn, stream->id,
@@ -395,12 +396,14 @@ static int cb_recv_stream_data(ngtcp2_conn *tconn, uint32_t flags,
 
   nconsumed =
     nghttp3_conn_read_stream(ctx->h3conn, stream_id, buf, buflen, fin);
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] read_stream(len=%zu) -> %zd",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] read_stream(len=%zu) -> %zd",
               stream_id, buflen, nconsumed);
   if(nconsumed < 0) {
     if(!data) {
       struct Curl_easy *cdata = CF_DATA_CURRENT(cf);
-      CURL_TRC_CF(cdata, cf, "[%" PRId64 "] nghttp3 error on stream not "
+      CURL_TRC_CF(cdata, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] nghttp3 error on stream not "
                   "used by us, ignored", stream_id);
       return 0;
     }
@@ -460,8 +463,9 @@ static int cb_stream_close(ngtcp2_conn *tconn, uint32_t flags,
 
   rv = nghttp3_conn_close_stream(ctx->h3conn, stream3_id,
                                  app_error_code);
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] quic close(err=%"
-              PRIu64 ") -> %d", stream3_id, app_error_code, rv);
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] quic close(err=%"
+              CURL_FORMAT_CURL_OFF_TU ") -> %d", stream3_id, app_error_code,
+              rv);
   if(rv && rv != NGHTTP3_ERR_STREAM_NOT_FOUND) {
     ngtcp2_ccerr_set_application_error(
       &ctx->last_error, nghttp3_err_infer_quic_app_error_code(rv), NULL, 0);
@@ -485,7 +489,8 @@ static int cb_stream_reset(ngtcp2_conn *tconn, int64_t stream_id,
   (void)data;
 
   rv = nghttp3_conn_shutdown_stream_read(ctx->h3conn, stream_id);
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] reset -> %d", stream_id, rv);
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] reset -> %d",
+              stream_id, rv);
   if(rv && rv != NGHTTP3_ERR_STREAM_NOT_FOUND) {
     return NGTCP2_ERR_CALLBACK_FAILURE;
   }
@@ -544,7 +549,8 @@ static int cb_extend_max_stream_data(ngtcp2_conn *tconn, int64_t stream_id,
   s_data = get_stream_easy(cf, data, stream_id);
   stream = H3_STREAM_CTX(s_data);
   if(stream && stream->quic_flow_blocked) {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] unblock quic flow", stream_id);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] unblock quic flow",
+                stream_id);
     stream->quic_flow_blocked = FALSE;
     h3_drain_stream(cf, data);
   }
@@ -749,11 +755,12 @@ static int cb_h3_stream_close(nghttp3_conn *conn, int64_t stream_id,
   if(stream->error3 != NGHTTP3_H3_NO_ERROR) {
     stream->reset = TRUE;
     stream->send_closed = TRUE;
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] RESET: error %" PRId64,
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] RESET: error %"
+                CURL_FORMAT_CURL_OFF_T,
                 stream->id, stream->error3);
   }
   else {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] CLOSED", stream->id);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] CLOSED", stream->id);
   }
   h3_drain_stream(cf, data);
   return 0;
@@ -783,17 +790,20 @@ static int cb_h3_recv_data(nghttp3_conn *conn, int64_t stream3_id,
 
   result = Curl_xfer_write_resp(data, (char *)buf, blen, FALSE);
   if(result) {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] DATA len=%zu, ERROR receiving %d",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] DATA len=%zu, ERROR receiving %d",
                 stream->id, blen, result);
     return NGHTTP3_ERR_CALLBACK_FAILURE;
   }
   if(blen) {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] ACK %zu bytes of DATA",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] ACK %zu bytes of DATA",
                 stream->id, blen);
     ngtcp2_conn_extend_max_stream_offset(ctx->qconn, stream->id, blen);
     ngtcp2_conn_extend_max_offset(ctx->qconn, blen);
   }
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] DATA len=%zu", stream->id, blen);
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] DATA len=%zu",
+              stream->id, blen);
   return 0;
 }
 
@@ -833,7 +843,7 @@ static int cb_h3_end_headers(nghttp3_conn *conn, int64_t stream_id,
     return -1;
   }
 
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] end_headers, status=%d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] end_headers, status=%d",
               stream_id, stream->status_code);
   if(stream->status_code / 100 != 1) {
     stream->resp_hds_complete = TRUE;
@@ -873,7 +883,8 @@ static int cb_h3_recv_header(nghttp3_conn *conn, int64_t stream_id,
       return -1;
     ncopy = msnprintf(line, sizeof(line), "HTTP/3 %03d \r\n",
                       stream->status_code);
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] status: %s", stream_id, line);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] status: %s",
+                stream_id, line);
     result = write_resp_hds(data, line, ncopy);
     if(result) {
       return -1;
@@ -881,7 +892,7 @@ static int cb_h3_recv_header(nghttp3_conn *conn, int64_t stream_id,
   }
   else {
     /* store as an HTTP1-style header */
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] header: %.*s: %.*s",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] header: %.*s: %.*s",
                 stream_id, (int)h3name.len, h3name.base,
                 (int)h3val.len, h3val.base);
     result = write_resp_hds(data, (const char *)h3name.base, h3name.len);
@@ -935,7 +946,8 @@ static int cb_h3_reset_stream(nghttp3_conn *conn, int64_t stream_id,
 
   rv = ngtcp2_conn_shutdown_stream_write(ctx->qconn, 0, stream_id,
                                          app_error_code);
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] reset -> %d", stream_id, rv);
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] reset -> %d",
+              stream_id, rv);
   if(rv && rv != NGTCP2_ERR_STREAM_NOT_FOUND) {
     return NGTCP2_ERR_CALLBACK_FAILURE;
   }
@@ -1031,13 +1043,15 @@ static ssize_t recv_closed_stream(struct Curl_cfilter *cf,
   (void)cf;
   if(stream->reset) {
     failf(data,
-          "HTTP/3 stream %" PRId64 " reset by server", stream->id);
+          "HTTP/3 stream %" CURL_FORMAT_CURL_OFF_T " reset by server",
+          stream->id);
     *err = data->req.bytecount? CURLE_PARTIAL_FILE : CURLE_HTTP3;
     goto out;
   }
   else if(!stream->resp_hds_complete) {
     failf(data,
-          "HTTP/3 stream %" PRId64 " was closed cleanly, but before getting"
+          "HTTP/3 stream %" CURL_FORMAT_CURL_OFF_T
+          " was closed cleanly, but before getting"
           " all response header fields, treated as error",
           stream->id);
     *err = CURLE_HTTP3;
@@ -1102,7 +1116,8 @@ out:
       nread = -1;
     }
   }
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_recv(blen=%zu) -> %zd, %d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] cf_recv(blen=%zu) -> %zd, %d",
               stream? stream->id : -1, blen, nread, *err);
   CF_DATA_RESTORE(cf, save);
   return nread;
@@ -1191,12 +1206,13 @@ cb_h3_read_req_body(nghttp3_conn *conn, int64_t stream_id,
   }
   else if(!nwritten) {
     /* Not EOF, and nothing to give, we signal WOULDBLOCK. */
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] read req body -> AGAIN",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] read req body -> AGAIN",
                 stream->id);
     return NGHTTP3_ERR_WOULDBLOCK;
   }
 
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] read req body -> "
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] read req body -> "
               "%d vecs%s with %zu (buffered=%zu, left=%"
               CURL_FORMAT_CURL_OFF_T ")",
               stream->id, (int)nvecs,
@@ -1308,11 +1324,13 @@ static ssize_t h3_stream_open(struct Curl_cfilter *cf,
   if(rc) {
     switch(rc) {
     case NGHTTP3_ERR_CONN_CLOSING:
-      CURL_TRC_CF(data, cf, "h3sid[%"PRId64"] failed to send, "
+      CURL_TRC_CF(data, cf, "h3sid[%" CURL_FORMAT_CURL_OFF_T
+                  "] failed to send, "
                   "connection is closing", stream->id);
       break;
     default:
-      CURL_TRC_CF(data, cf, "h3sid[%"PRId64"] failed to send -> %d (%s)",
+      CURL_TRC_CF(data, cf, "h3sid[%" CURL_FORMAT_CURL_OFF_T
+                  "] failed to send -> %d (%s)",
                   stream->id, rc, ngtcp2_strerror(rc));
       break;
     }
@@ -1322,10 +1340,11 @@ static ssize_t h3_stream_open(struct Curl_cfilter *cf,
   }
 
   if(Curl_trc_is_verbose(data)) {
-    infof(data, "[HTTP/3] [%" PRId64 "] OPENED stream for %s",
+    infof(data, "[HTTP/3] [%" CURL_FORMAT_CURL_OFF_T "] OPENED stream for %s",
           stream->id, data->state.url);
     for(i = 0; i < nheader; ++i) {
-      infof(data, "[HTTP/3] [%" PRId64 "] [%.*s: %.*s]", stream->id,
+      infof(data, "[HTTP/3] [%" CURL_FORMAT_CURL_OFF_T "] [%.*s: %.*s]",
+            stream->id,
             (int)nva[i].namelen, nva[i].name,
             (int)nva[i].valuelen, nva[i].value);
     }
@@ -1390,13 +1409,13 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
        * body. This happens on 30x or 40x responses.
        * We silently discard the data sent, since this is not a transport
        * error situation. */
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] discarding data"
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] discarding data"
                   "on closed stream with response", stream->id);
       *err = CURLE_OK;
       sent = (ssize_t)len;
       goto out;
     }
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] send_body(len=%zu) "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] send_body(len=%zu) "
                 "-> stream closed", stream->id, len);
     *err = CURLE_HTTP3;
     sent = -1;
@@ -1404,7 +1423,7 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
   else {
     sent = Curl_bufq_write(&stream->sendbuf, buf, len, err);
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send, add to "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] cf_send, add to "
                 "sendbuf(len=%zu) -> %zd, %d",
                 stream->id, len, sent, *err);
     if(sent < 0) {
@@ -1425,7 +1444,7 @@ static ssize_t cf_ngtcp2_send(struct Curl_cfilter *cf, struct Curl_easy *data,
      * caller. Instead we EAGAIN and remember how much we have already
      * "written" into our various internal connection buffers. */
     stream->upload_blocked_len = sent;
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send(len=%zu), "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] cf_send(len=%zu), "
                 "%zu bytes in flight -> EGAIN", stream->id, len,
                 stream->sendbuf_len_in_flight);
     *err = CURLE_AGAIN;
@@ -1438,7 +1457,8 @@ out:
     *err = result;
     sent = -1;
   }
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send(len=%zu) -> %zd, %d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] cf_send(len=%zu) -> %zd, %d",
               stream? stream->id : -1, len, sent, *err);
   CF_DATA_RESTORE(cf, save);
   return sent;
@@ -1596,7 +1616,8 @@ static ssize_t read_pkt_to_send(void *userp,
         struct h3_stream_ctx *stream = H3_STREAM_CTX(x->data);
         DEBUGASSERT(ndatalen == -1);
         nghttp3_conn_block_stream(ctx->h3conn, stream_id);
-        CURL_TRC_CF(x->data, x->cf, "[%" PRId64 "] block quic flow",
+        CURL_TRC_CF(x->data, x->cf, "[%" CURL_FORMAT_CURL_OFF_T
+                    "] block quic flow",
                     stream_id);
         DEBUGASSERT(stream);
         if(stream)
diff --git a/lib/vquic/curl_osslq.c b/lib/vquic/curl_osslq.c
index 1d53e2c11..eae6e956a 100644
--- a/lib/vquic/curl_osslq.c
+++ b/lib/vquic/curl_osslq.c
@@ -355,7 +355,8 @@ static CURLcode cf_osslq_h3conn_add_stream(struct cf_osslq_h3conn *h3,
 
   if(h3->remote_ctrl_n >= ARRAYSIZE(h3->remote_ctrl)) {
     /* rejected, we are full */
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] rejecting additional remote stream",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] rejecting additional remote stream",
                 stream_id);
     SSL_free(stream_ssl);
     return CURLE_FAILED_INIT;
@@ -366,12 +367,14 @@ static CURLcode cf_osslq_h3conn_add_stream(struct cf_osslq_h3conn *h3,
       nstream->id = stream_id;
       nstream->ssl = stream_ssl;
       Curl_bufq_initp(&nstream->recvbuf, &ctx->stream_bufcp, 1, BUFQ_OPT_NONE);
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] accepted new remote uni stream",
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] accepted new remote uni stream",
                   stream_id);
       break;
     }
     default:
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] rejecting remote non-uni-read"
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] rejecting remote non-uni-read"
                   " stream", stream_id);
       SSL_free(stream_ssl);
       return CURLE_FAILED_INIT;
@@ -541,7 +544,8 @@ static void h3_data_done(struct Curl_cfilter *cf, struct Curl_easy *data)
 
   (void)cf;
   if(stream) {
-    CURL_TRC_CF(data, cf, "[%"PRId64"] easy handle is done", stream->s.id);
+    CURL_TRC_CF(data, cf, "[%"CURL_FORMAT_CURL_OFF_T"] easy handle is done",
+                stream->s.id);
     if(ctx->h3.conn && !stream->closed) {
       nghttp3_conn_shutdown_stream_read(ctx->h3.conn, stream->s.id);
       nghttp3_conn_close_stream(ctx->h3.conn, stream->s.id,
@@ -638,11 +642,13 @@ static int cb_h3_stream_close(nghttp3_conn *conn, int64_t stream_id,
   if(stream->error3 != NGHTTP3_H3_NO_ERROR) {
     stream->reset = TRUE;
     stream->send_closed = TRUE;
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] RESET: error %" PRId64,
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] RESET: error %"
+                CURL_FORMAT_CURL_OFF_T,
                 stream->s.id, stream->error3);
   }
   else {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] CLOSED", stream->s.id);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] CLOSED",
+                stream->s.id);
   }
   h3_drain_stream(cf, data);
   return 0;
@@ -700,12 +706,14 @@ static int cb_h3_recv_data(nghttp3_conn *conn, int64_t stream3_id,
 
   result = write_resp_raw(cf, data, buf, buflen, TRUE);
   if(result) {
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] DATA len=%zu, ERROR receiving %d",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] DATA len=%zu, ERROR receiving %d",
                 stream->s.id, buflen, result);
     return NGHTTP3_ERR_CALLBACK_FAILURE;
   }
   stream->download_recvd += (curl_off_t)buflen;
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] DATA len=%zu, total=%zd",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] DATA len=%zu, total=%zd",
               stream->s.id, buflen, stream->download_recvd);
   h3_drain_stream(cf, data);
   return 0;
@@ -722,7 +730,8 @@ static int cb_h3_deferred_consume(nghttp3_conn *conn, int64_t stream_id,
   (void)conn;
   (void)stream_id;
   if(stream)
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] deferred consume %zu bytes",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] deferred consume %zu bytes",
                 stream->s.id, consumed);
   return 0;
 }
@@ -758,7 +767,8 @@ static int cb_h3_recv_header(nghttp3_conn *conn, int64_t stream_id,
       return -1;
     ncopy = msnprintf(line, sizeof(line), "HTTP/3 %03d \r\n",
                       stream->status_code);
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] status: %s", stream_id, line);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] status: %s",
+                stream_id, line);
     result = write_resp_raw(cf, data, line, ncopy, FALSE);
     if(result) {
       return -1;
@@ -766,7 +776,7 @@ static int cb_h3_recv_header(nghttp3_conn *conn, int64_t stream_id,
   }
   else {
     /* store as an HTTP1-style header */
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] header: %.*s: %.*s",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] header: %.*s: %.*s",
                 stream_id, (int)h3name.len, h3name.base,
                 (int)h3val.len, h3val.base);
     result = write_resp_raw(cf, data, h3name.base, h3name.len, FALSE);
@@ -809,7 +819,7 @@ static int cb_h3_end_headers(nghttp3_conn *conn, int64_t stream_id,
     return -1;
   }
 
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] end_headers, status=%d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] end_headers, status=%d",
               stream_id, stream->status_code);
   if(stream->status_code / 100 != 1) {
     stream->resp_hds_complete = TRUE;
@@ -831,7 +841,8 @@ static int cb_h3_stop_sending(nghttp3_conn *conn, int64_t stream_id,
   if(!stream || !stream->s.ssl)
     return 0;
 
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] stop_sending", stream_id);
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] stop_sending",
+              stream_id);
   cf_osslq_stream_close(&stream->s);
   return 0;
 }
@@ -849,7 +860,8 @@ static int cb_h3_reset_stream(nghttp3_conn *conn, int64_t stream_id,
     SSL_STREAM_RESET_ARGS args = {0};
     args.quic_error_code = app_error_code;
     rv = !SSL_stream_reset(stream->s.ssl, &args, sizeof(args));
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] reset -> %d", stream_id, rv);
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] reset -> %d",
+                stream_id, rv);
     if(!rv) {
       return NGHTTP3_ERR_CALLBACK_FAILURE;
     }
@@ -908,12 +920,13 @@ cb_h3_read_req_body(nghttp3_conn *conn, int64_t stream_id,
   }
   else if(!nwritten) {
     /* Not EOF, and nothing to give, we signal WOULDBLOCK. */
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] read req body -> AGAIN",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] read req body -> AGAIN",
                 stream->s.id);
     return NGHTTP3_ERR_WOULDBLOCK;
   }
 
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] read req body -> "
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] read req body -> "
               "%d vecs%s with %zu (buffered=%zu, left=%"
               CURL_FORMAT_CURL_OFF_T ")",
               stream->s.id, (int)nvecs,
@@ -1154,8 +1167,8 @@ static ssize_t h3_quic_recv(void *reader_ctx,
       return -1;
     }
     else if(detail == SSL_ERROR_ZERO_RETURN) {
-      CURL_TRC_CF(x->data, x->cf, "[%" PRId64 "] h3_quic_recv -> EOS",
-                  x->s->id);
+      CURL_TRC_CF(x->data, x->cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] h3_quic_recv -> EOS", x->s->id);
       x->s->recvd_eos = TRUE;
       return 0;
     }
@@ -1163,8 +1176,9 @@ static ssize_t h3_quic_recv(void *reader_ctx,
             SSL_STREAM_STATE_RESET_REMOTE) {
       uint64_t app_error_code = NGHTTP3_H3_NO_ERROR;
       SSL_get_stream_read_error_code(x->s->ssl, &app_error_code);
-      CURL_TRC_CF(x->data, x->cf, "[%" PRId64 "] h3_quic_recv -> RESET, "
-                  "rv=%d, app_err=%" PRIu64,
+      CURL_TRC_CF(x->data, x->cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] h3_quic_recv -> RESET, rv=%d, app_err=%"
+                  CURL_FORMAT_CURL_OFF_TU,
                   x->s->id, rv, app_error_code);
       if(app_error_code != NGHTTP3_H3_NO_ERROR) {
         x->s->reset = TRUE;
@@ -1178,8 +1192,9 @@ static ssize_t h3_quic_recv(void *reader_ctx,
     }
   }
   else {
-    /* CURL_TRC_CF(x->data, x->cf, "[%" PRId64 "] h3_quic_recv -> %zu bytes",
-                x->s->id, nread); */
+    /* CURL_TRC_CF(x->data, x->cf, "[%" CURL_FORMAT_CURL_OFF_T
+                   "] h3_quic_recv -> %zu bytes",
+                   x->s->id, nread); */
   }
   return (ssize_t)nread;
 }
@@ -1224,7 +1239,8 @@ static CURLcode cf_osslq_stream_recv(struct cf_osslq_stream *s,
       while(Curl_bufq_peek(&s->recvbuf, &buf, &blen)) {
         nread = nghttp3_conn_read_stream(ctx->h3.conn, s->id,
                                          buf, blen, 0);
-        CURL_TRC_CF(data, cf, "[%" PRId64 "] forward %zu bytes "
+        CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                    "] forward %zu bytes "
                     "to nghttp3 -> %zd", s->id, blen, nread);
         if(nread < 0) {
           failf(data, "nghttp3_conn_read_stream(len=%zu) error: %s",
@@ -1263,7 +1279,8 @@ static CURLcode cf_osslq_stream_recv(struct cf_osslq_stream *s,
         rv = nghttp3_conn_close_stream(ctx->h3.conn, s->id,
                                        NGHTTP3_H3_NO_ERROR);
         s->closed = TRUE;
-        CURL_TRC_CF(data, cf, "[%" PRId64 "] close nghttp3 stream -> %d",
+        CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                    "] close nghttp3 stream -> %d",
                     s->id, rv);
         if(rv < 0 && rv != NGHTTP3_ERR_STREAM_NOT_FOUND) {
           failf(data, "nghttp3_conn_close_stream returned error: %s",
@@ -1276,7 +1293,8 @@ static CURLcode cf_osslq_stream_recv(struct cf_osslq_stream *s,
   }
 out:
   if(result)
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_osslq_stream_recv -> %d",
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                "] cf_osslq_stream_recv -> %d",
                 s->id, result);
   return result;
 }
@@ -1398,8 +1416,8 @@ static CURLcode h3_send_streams(struct Curl_cfilter *cf,
     /* Get the stream for this data */
     s = cf_osslq_get_qstream(cf, data, stream_id);
     if(!s) {
-      failf(data, "nghttp3_conn_writev_stream gave unknown stream %" PRId64,
-            stream_id);
+      failf(data, "nghttp3_conn_writev_stream gave unknown stream %"
+            CURL_FORMAT_CURL_OFF_T, stream_id);
       result = CURLE_SEND_ERROR;
       goto out;
     }
@@ -1427,8 +1445,8 @@ static CURLcode h3_send_streams(struct Curl_cfilter *cf,
       if(ok) {
         /* As OpenSSL buffers the data, we count this as acknowledged
          * from nghttp3's point of view */
-        CURL_TRC_CF(data, cf, "[%"PRId64"] send %zu bytes to QUIC ok",
-              s->id, vec[i].len);
+        CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                    "] send %zu bytes to QUIC ok", s->id, vec[i].len);
         acked_len += vec[i].len;
       }
       else {
@@ -1437,14 +1455,16 @@ static CURLcode h3_send_streams(struct Curl_cfilter *cf,
         case SSL_ERROR_WANT_WRITE:
         case SSL_ERROR_WANT_READ:
           /* QUIC blocked us from writing more */
-          CURL_TRC_CF(data, cf, "[%"PRId64"] send %zu bytes to QUIC blocked",
+          CURL_TRC_CF(data, cf, "[%"CURL_FORMAT_CURL_OFF_T
+                      "] send %zu bytes to QUIC blocked",
                       s->id, vec[i].len);
           written = 0;
           nghttp3_conn_block_stream(ctx->h3.conn, s->id);
           s->send_blocked = blocked = TRUE;
           break;
         default:
-          failf(data, "[%"PRId64"] send %zu bytes to QUIC, SSL error %d",
+          failf(data, "[%"CURL_FORMAT_CURL_OFF_T
+                "] send %zu bytes to QUIC, SSL error %d",
                 s->id, vec[i].len, detail);
           result = cf_osslq_ssl_err(cf, data, detail, CURLE_SEND_ERROR);
           goto out;
@@ -1470,13 +1490,15 @@ static CURLcode h3_send_streams(struct Curl_cfilter *cf,
         result = CURLE_SEND_ERROR;
         goto out;
       }
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] forwarded %zu/%zu h3 bytes "
-                  "to QUIC, eos=%d", s->id, acked_len, total_len, eos);
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] forwarded %zu/%zu h3 bytes to QUIC, eos=%d",
+                  s->id, acked_len, total_len, eos);
     }
 
     if(eos && !s->send_blocked && !eos_written) {
       /* wrote everything and H3 indicates end of stream */
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] closing QUIC stream", s->id);
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] closing QUIC stream", s->id);
       SSL_stream_conclude(s->ssl, 0);
     }
   }
@@ -1768,11 +1790,12 @@ static ssize_t h3_stream_open(struct Curl_cfilter *cf,
   if(rc) {
     switch(rc) {
     case NGHTTP3_ERR_CONN_CLOSING:
-      CURL_TRC_CF(data, cf, "h3sid[%"PRId64"] failed to send, "
+      CURL_TRC_CF(data, cf, "h3sid[%"CURL_FORMAT_CURL_OFF_T"] failed to send, "
                   "connection is closing", stream->s.id);
       break;
     default:
-      CURL_TRC_CF(data, cf, "h3sid[%"PRId64"] failed to send -> %d (%s)",
+      CURL_TRC_CF(data, cf, "h3sid[%"CURL_FORMAT_CURL_OFF_T
+                  "] failed to send -> %d (%s)",
                   stream->s.id, rc, nghttp3_strerror(rc));
       break;
     }
@@ -1782,10 +1805,11 @@ static ssize_t h3_stream_open(struct Curl_cfilter *cf,
   }
 
   if(Curl_trc_is_verbose(data)) {
-    infof(data, "[HTTP/3] [%" PRId64 "] OPENED stream for %s",
+    infof(data, "[HTTP/3] [%" CURL_FORMAT_CURL_OFF_T "] OPENED stream for %s",
           stream->s.id, data->state.url);
     for(i = 0; i < nheader; ++i) {
-      infof(data, "[HTTP/3] [%" PRId64 "] [%.*s: %.*s]", stream->s.id,
+      infof(data, "[HTTP/3] [%" CURL_FORMAT_CURL_OFF_T "] [%.*s: %.*s]",
+            stream->s.id,
             (int)nva[i].namelen, nva[i].name,
             (int)nva[i].valuelen, nva[i].value);
     }
@@ -1856,13 +1880,13 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
        * body. This happens on 30x or 40x responses.
        * We silently discard the data sent, since this is not a transport
        * error situation. */
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] discarding data"
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] discarding data"
                   "on closed stream with response", stream->s.id);
       *err = CURLE_OK;
       nwritten = (ssize_t)len;
       goto out;
     }
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] send_body(len=%zu) "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] send_body(len=%zu) "
                 "-> stream closed", stream->s.id, len);
     *err = CURLE_HTTP3;
     nwritten = -1;
@@ -1870,7 +1894,7 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
   }
   else {
     nwritten = Curl_bufq_write(&stream->sendbuf, buf, len, err);
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send, add to "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] cf_send, add to "
                 "sendbuf(len=%zu) -> %zd, %d",
                 stream->s.id, len, nwritten, *err);
     if(nwritten < 0) {
@@ -1891,7 +1915,7 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
      * caller. Instead we EAGAIN and remember how much we have already
      * "written" into our various internal connection buffers. */
     stream->upload_blocked_len = nwritten;
-    CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send(len=%zu), "
+    CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T "] cf_send(len=%zu), "
                 "%zu bytes in flight -> EGAIN", stream->s.id, len,
                 stream->sendbuf_len_in_flight);
     *err = CURLE_AGAIN;
@@ -1900,7 +1924,8 @@ static ssize_t cf_osslq_send(struct Curl_cfilter *cf, struct Curl_easy *data,
 
 out:
   result = check_and_set_expiry(cf, data);
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_send(len=%zu) -> %zd, %d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] cf_send(len=%zu) -> %zd, %d",
               stream? stream->s.id : -1, len, nwritten, *err);
   CF_DATA_RESTORE(cf, save);
   return nwritten;
@@ -1916,13 +1941,15 @@ static ssize_t recv_closed_stream(struct Curl_cfilter *cf,
   (void)cf;
   if(stream->reset) {
     failf(data,
-          "HTTP/3 stream %" PRId64 " reset by server", stream->s.id);
+          "HTTP/3 stream %" CURL_FORMAT_CURL_OFF_T " reset by server",
+          stream->s.id);
     *err = data->req.bytecount? CURLE_PARTIAL_FILE : CURLE_HTTP3;
     goto out;
   }
   else if(!stream->resp_hds_complete) {
     failf(data,
-          "HTTP/3 stream %" PRId64 " was closed cleanly, but before getting"
+          "HTTP/3 stream %" CURL_FORMAT_CURL_OFF_T
+          " was closed cleanly, but before getting"
           " all response header fields, treated as error",
           stream->s.id);
     *err = CURLE_HTTP3;
@@ -1961,7 +1988,8 @@ static ssize_t cf_osslq_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
     nread = Curl_bufq_read(&stream->recvbuf,
                            (unsigned char *)buf, len, err);
     if(nread < 0) {
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] read recvbuf(len=%zu) "
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] read recvbuf(len=%zu) "
                   "-> %zd, %d", stream->s.id, len, nread, *err);
       goto out;
     }
@@ -1979,7 +2007,8 @@ static ssize_t cf_osslq_recv(struct Curl_cfilter *cf, struct Curl_easy *data,
     nread = Curl_bufq_read(&stream->recvbuf,
                            (unsigned char *)buf, len, err);
     if(nread < 0) {
-      CURL_TRC_CF(data, cf, "[%" PRId64 "] read recvbuf(len=%zu) "
+      CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+                  "] read recvbuf(len=%zu) "
                   "-> %zd, %d", stream->s.id, len, nread, *err);
       goto out;
     }
@@ -2009,7 +2038,8 @@ out:
       nread = -1;
     }
   }
-  CURL_TRC_CF(data, cf, "[%" PRId64 "] cf_recv(len=%zu) -> %zd, %d",
+  CURL_TRC_CF(data, cf, "[%" CURL_FORMAT_CURL_OFF_T
+              "] cf_recv(len=%zu) -> %zd, %d",
               stream? stream->s.id : -1, len, nread, *err);
   CF_DATA_RESTORE(cf, save);
   return nread;
