{"url":"https://api.github.com/repos/curl/curl/issues/14207","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/14207/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/14207/comments","events_url":"https://api.github.com/repos/curl/curl/issues/14207/events","html_url":"https://github.com/curl/curl/issues/14207","id":2413131193,"node_id":"I_kwDOAAiu0c6P1XW5","number":14207,"title":"Run into EXC_BAD_ACCESS crash occasionally at curl_multi_cleanup() when DOH enabled since 8.5.0.","user":{"login":"luozhaohui","id":12403610,"node_id":"MDQ6VXNlcjEyNDAzNjEw","avatar_url":"https://avatars.githubusercontent.com/u/12403610?v=4","gravatar_id":"","url":"https://api.github.com/users/luozhaohui","html_url":"https://github.com/luozhaohui","followers_url":"https://api.github.com/users/luozhaohui/followers","following_url":"https://api.github.com/users/luozhaohui/following{/other_user}","gists_url":"https://api.github.com/users/luozhaohui/gists{/gist_id}","starred_url":"https://api.github.com/users/luozhaohui/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/luozhaohui/subscriptions","organizations_url":"https://api.github.com/users/luozhaohui/orgs","repos_url":"https://api.github.com/users/luozhaohui/repos","events_url":"https://api.github.com/users/luozhaohui/events{/privacy}","received_events_url":"https://api.github.com/users/luozhaohui/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":975635480,"node_id":"MDU6TGFiZWw5NzU2MzU0ODA=","url":"https://api.github.com/repos/curl/curl/labels/name%20lookup","name":"name lookup","color":"0052cc","default":false,"description":"DNS and related tech"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":3,"created_at":"2024-07-17T09:35:05Z","updated_at":"2024-07-18T05:20:19Z","closed_at":"2024-07-18T05:20:19Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\n\n1. First, enable DoH. \r\n2. Then, initiate a request using curl_multi_*, and call curl_multi_remove_handle() to abort the request. \r\n3. There is a small chance that the test program will trigger an EXC_BAD_ACCESS crash in curl_multi_cleanup().\r\n\r\nDependency versions:\r\n- cares: v1.19.0\r\n- zlib: v1.3.1\r\n\r\nBelow is a complete C++ test program for this case. \r\n\r\nThe specific version reproduction situation is as follows:\r\n\r\n- v8.3.0, v8.4.0, v8.5.0, v8.6.0, v8.7.0, v8.8.0\r\nIf the enable_DoH in the code is set to false, it will not crash.\r\n\r\n- v8.3.0, v8.4.0\r\nIf the enable_DoH in the code is set to true, it will not crash.\r\n\r\n- v8.5.0, v8.6.0, v8.7.0, v8.8.0\r\nIf the enable_DoH in the code is set to true, it will crash.\r\n\r\n```c++\r\n#include <iostream>\r\n#include <iterator>\r\n#include <memory>\r\n#include <ostream>\r\n#include <string>\r\n#include <mutex>\r\n#include <thread>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <string>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <curl/curl.h>\r\n\r\nstatic bool globalInitCalled = false;\r\n\r\nvoid doInit()\r\n{\r\n    static bool initialized = ([] {\r\n        curl_global_init(CURL_GLOBAL_ALL);\r\n        globalInitCalled = true;\r\n        return true;\r\n    })();\r\n\r\n    // silence unused warning\r\n    (void)initialized;\r\n}\r\n\r\nenum Method\r\n{\r\n    HEAD,\r\n    GET,\r\n    POST,\r\n    PUT,\r\n};\r\n\r\nclass Session\r\n{\r\npublic:\r\n    enum State\r\n    {\r\n        NEW,\r\n        PERFORMING,\r\n        ABORTED,\r\n        HTTP_OK,\r\n        HTTP_ERR,\r\n        OTHER_ERR\r\n    };\r\n\r\n    Session(Method method, const std::string& url)\r\n        : state_(NEW)\r\n        , statusStr_(\"new\")\r\n        , origUrl_(url)\r\n    {\r\n        doInit();\r\n        curl_ = curl_easy_init();\r\n\r\n        // Set URL\r\n        setopt(CURLOPT_URL, url.c_str());\r\n\r\n        // Set method\r\n        switch (method)\r\n        {\r\n            case HEAD:\r\n                setopt(CURLOPT_NOBODY, 1L);\r\n                break;\r\n            case GET:\r\n                setopt(CURLOPT_HTTPGET, 1L);\r\n                break;\r\n            case POST:\r\n                setopt(CURLOPT_POST, 1L);\r\n                break;\r\n            case PUT:\r\n                setopt(CURLOPT_CUSTOMREQUEST, \"PUT\");\r\n                setopt(CURLOPT_UPLOAD, 1L);\r\n                break;\r\n        }\r\n\r\n        // encoding\r\n        setopt(CURLOPT_ACCEPT_ENCODING, \"\");\r\n        setopt(CURLOPT_SSL_VERIFYPEER, 0L);\r\n    }\r\n\r\n    ~Session()\r\n    {\r\n        if (curl_ != nullptr)\r\n        {\r\n            curl_easy_cleanup(curl_);\r\n            curl_ = nullptr;\r\n        }\r\n    }\r\n\r\n    void setAbortFlag(std::shared_ptr<std::atomic_bool> f)\r\n    {\r\n        assert(state_ == NEW);\r\n        isAborted_ = [f]()\r\n        {\r\n            bool ret = f->load();\r\n            if (ret)\r\n            {\r\n                std::cout << \"> abort flag set.\" << std::endl;\r\n            }\r\n\r\n            return f->load();\r\n        };\r\n    }\r\n\r\n    void enableDoH(const std::string& v)\r\n    {\r\n        assert(state_ == NEW);\r\n\r\n        setopt(CURLOPT_DOH_URL, v.c_str());\r\n        setopt(CURLOPT_DOH_SSL_VERIFYPEER, 0);\r\n        setopt(CURLOPT_DOH_SSL_VERIFYHOST, 0);\r\n    }\r\n\r\n    bool checkAborted()\r\n    {\r\n        return isAborted_();\r\n    }\r\n\r\n    void start()\r\n    {\r\n        assert(state_ == NEW);\r\n        setopt(CURLOPT_PRIVATE, this);\r\n        state_ = PERFORMING;\r\n        statusStr_ = \"performing\";\r\n    }\r\n\r\n    void abort()\r\n    {\r\n        assert(state_ == PERFORMING);\r\n        state_ = ABORTED;\r\n        statusStr_ = \"aborted\";\r\n    }\r\n\r\n    State getState()\r\n    {\r\n        return state_;\r\n    }\r\n\r\n    const std::string& getStatusStr() const\r\n    {\r\n        return statusStr_;\r\n    }\r\n\r\n    CURL* handle() const\r\n    {\r\n        return curl_;\r\n    }\r\n\r\n    void finish(CURLcode res)\r\n    {\r\n        if (res == CURLE_OK)\r\n        {\r\n            state_ = HTTP_OK;\r\n            statusStr_ = \"OK\";\r\n        }\r\n        else\r\n        {\r\n            state_ = OTHER_ERR;\r\n            statusStr_ = \"error\";\r\n        }\r\n    }\r\n\r\nprivate:\r\n    template <typename T>\r\n    void setopt(CURLoption opt, T&& v) const\r\n    {\r\n        curl_easy_setopt(curl_, opt, v);\r\n    }\r\n\r\nprivate:\r\n    State state_;\r\n    std::string statusStr_;\r\n    std::string origUrl_;\r\n    CURL* curl_ = nullptr;\r\n\r\n    std::function<bool()> isAborted_ = []() {\r\n        return false;\r\n    };\r\n};\r\n\r\nclass Client\r\n{\r\npublic:\r\n    Client()\r\n    {\r\n        doInit();\r\n        curlm_ = curl_multi_init();\r\n    }\r\n\r\n    ~Client()\r\n    {\r\n        if (curlm_ != nullptr)\r\n        {\r\n            curl_multi_cleanup(curlm_);\r\n            curlm_ = nullptr;\r\n        }\r\n    }\r\n\r\n    std::unique_ptr<Session> get(const std::string& url, bool enable_DoH, std::shared_ptr<std::atomic_bool> v)\r\n    {\r\n        auto session = create(Method::GET, url);\r\n        if (v)\r\n        {\r\n            session->setAbortFlag(v);\r\n        }\r\n\r\n        if (enable_DoH)\r\n        {\r\n            session->enableDoH(\"https://1.1.1.1/dns-query\");\r\n        }\r\n\r\n        add(*session);\r\n\r\n        while (!session->checkAborted() && step() > 0)\r\n        {\r\n            wait();\r\n        }\r\n\r\n        abortIfInProgress(*session);\r\n\r\n        return std::move(session);\r\n    }\r\n\r\nprivate:\r\n    std::unique_ptr<Session> create(Method method, const std::string& url)\r\n    {\r\n        return std::make_unique<Session>(method, url);\r\n    }\r\n\r\n    void add(Session& s)\r\n    {\r\n        s.start();\r\n        curl_multi_add_handle(curlm_, s.handle());\r\n    }\r\n\r\n    void remove(Session& s)\r\n    {\r\n        curl_multi_remove_handle(curlm_, s.handle());\r\n    }\r\n\r\n    void abortIfInProgress(Session& s)\r\n    {\r\n        if (s.getState() == Session::PERFORMING)\r\n        {\r\n            std::cout << \">> abort session\" << std::endl;\r\n            remove(s);\r\n            s.abort();\r\n        }\r\n    }\r\n\r\n    void wait(int timeoutMs = 20)\r\n    {\r\n        curl_multi_poll(curlm_, NULL, 0, timeoutMs, NULL);\r\n    }\r\n\r\n    int step()\r\n    {\r\n        int active = 0;\r\n        CURLMcode mc = curl_multi_perform(curlm_, &active);\r\n        if (!mc)\r\n        {\r\n            CURLMsg* msg = 0;\r\n\r\n            do {\r\n                int nmsg = 0;\r\n                msg = curl_multi_info_read(curlm_, &nmsg);\r\n                if (msg && (msg->msg == CURLMSG_DONE))\r\n                {\r\n                    Session* session = nullptr;\r\n                    curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, &session);\r\n                    assert(session);\r\n                    session->finish(msg->data.result);\r\n                    remove(*session);\r\n                }\r\n\r\n                std::cout << \"-- active: \" << active << \", number of message: \" << nmsg << std::endl;\r\n            }\r\n            while(msg);\r\n        }\r\n        else\r\n        {\r\n            std::cout << \"curl_multi_perform() failed. [curl error \"\r\n                << mc << \"]: \" << curl_multi_strerror(mc) << std::endl;\r\n        }\r\n\r\n        return active;\r\n    }\r\n\r\nprivate:\r\n    CURLM* curlm_ = nullptr;\r\n};\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    std::cout << \"=== curl test ===\" << std::endl;\r\n\r\n    auto url = \"https://httpbin.org/delay/5\";\r\n    auto test_abort_func = [=](Client& cli, bool enable_DoH, int abortAfterMs) {\r\n        std::cout << \"\\n\\n=== abort request after \" << abortAfterMs << \" ms.\" << std::endl;\r\n\r\n        auto abort_flag = std::make_shared<std::atomic_bool>(false);\r\n        auto th = std::thread{[&]()\r\n        {\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(abortAfterMs));\r\n            abort_flag->store(true);\r\n        }};\r\n\r\n        auto session = cli.get(url, enable_DoH, abort_flag);\r\n        std::cout << \">> abort test \" << abortAfterMs << \" ms: \" << session->getStatusStr() << std::endl;\r\n\r\n        th.join();\r\n    };\r\n\r\n    // the program may crash if enable DoH\r\n    bool enable_DoH = true;\r\n    for (uint32_t loop = 0; loop < 50; ++loop)\r\n    {\r\n        for (uint32_t t = 1; t < 500; t = t + 10)\r\n        {\r\n            std::unique_ptr<Client> client(new Client());\r\n            // auto session = client->get(url, false, nullptr);\r\n            // std::cout << \">> normal request \" << session->getStatusStr() << std::endl;\r\n\r\n            test_abort_func(*client, enable_DoH, t);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n``` \n\n### I expected the following\n\nNo EXC_BAD_ACCESS crash.\n\n### curl/libcurl version\n\nTested the following versions:\r\n\r\ncurl 8.3.0-DEV (x86_64-apple-darwin23.3.0) libcurl/8.3.0-DEV SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: [unreleased]\r\nProtocols: dict file ftp ftps http https\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM NTLM_WB SSL threadsafe UnixSockets \r\n\r\ncurl 8.4.0 (x86_64-apple-darwin23.3.0) libcurl/8.4.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2023-10-11\r\nProtocols: dict file ftp ftps http https\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets \r\n\r\ncurl 8.5.0 (x86_64-apple-darwin23.3.0) libcurl/8.5.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2023-12-06\r\nProtocols: dict file ftp ftps http https\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets \r\n\r\ncurl 8.6.0 (x86_64-apple-darwin23.3.0) libcurl/8.6.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2024-01-31\r\nProtocols: dict file ftp ftps http https ipfs ipns\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets \n\n### operating system\n\nMacOS 14.3\r\n\r\nThis issue occurs on Windows 10 and Ubuntu 1804 too.","closed_by":{"login":"luozhaohui","id":12403610,"node_id":"MDQ6VXNlcjEyNDAzNjEw","avatar_url":"https://avatars.githubusercontent.com/u/12403610?v=4","gravatar_id":"","url":"https://api.github.com/users/luozhaohui","html_url":"https://github.com/luozhaohui","followers_url":"https://api.github.com/users/luozhaohui/followers","following_url":"https://api.github.com/users/luozhaohui/following{/other_user}","gists_url":"https://api.github.com/users/luozhaohui/gists{/gist_id}","starred_url":"https://api.github.com/users/luozhaohui/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/luozhaohui/subscriptions","organizations_url":"https://api.github.com/users/luozhaohui/orgs","repos_url":"https://api.github.com/users/luozhaohui/repos","events_url":"https://api.github.com/users/luozhaohui/events{/privacy}","received_events_url":"https://api.github.com/users/luozhaohui/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/14207/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/14207/timeline","performed_via_github_app":null,"state_reason":"completed"}