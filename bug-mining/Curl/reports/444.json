{"url":"https://api.github.com/repos/curl/curl/issues/13337","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/13337/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/13337/comments","events_url":"https://api.github.com/repos/curl/curl/issues/13337/events","html_url":"https://github.com/curl/curl/issues/13337","id":2235308896,"node_id":"I_kwDOAAiu0c6FPBtg","number":13337,"title":"Write function callback is called twice after resume transfer and return CURL_WRITEFUNC_ERROR","user":{"login":"pkropachev","id":34160907,"node_id":"MDQ6VXNlcjM0MTYwOTA3","avatar_url":"https://avatars.githubusercontent.com/u/34160907?v=4","gravatar_id":"","url":"https://api.github.com/users/pkropachev","html_url":"https://github.com/pkropachev","followers_url":"https://api.github.com/users/pkropachev/followers","following_url":"https://api.github.com/users/pkropachev/following{/other_user}","gists_url":"https://api.github.com/users/pkropachev/gists{/gist_id}","starred_url":"https://api.github.com/users/pkropachev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/pkropachev/subscriptions","organizations_url":"https://api.github.com/users/pkropachev/orgs","repos_url":"https://api.github.com/users/pkropachev/repos","events_url":"https://api.github.com/users/pkropachev/events{/privacy}","received_events_url":"https://api.github.com/users/pkropachev/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1117926199,"node_id":"MDU6TGFiZWwxMTE3OTI2MTk5","url":"https://api.github.com/repos/curl/curl/labels/libcurl%20API","name":"libcurl API","color":"fef2c0","default":false,"description":""}],"state":"closed","locked":false,"assignee":{"login":"icing","id":15102,"node_id":"MDQ6VXNlcjE1MTAy","avatar_url":"https://avatars.githubusercontent.com/u/15102?v=4","gravatar_id":"","url":"https://api.github.com/users/icing","html_url":"https://github.com/icing","followers_url":"https://api.github.com/users/icing/followers","following_url":"https://api.github.com/users/icing/following{/other_user}","gists_url":"https://api.github.com/users/icing/gists{/gist_id}","starred_url":"https://api.github.com/users/icing/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/icing/subscriptions","organizations_url":"https://api.github.com/users/icing/orgs","repos_url":"https://api.github.com/users/icing/repos","events_url":"https://api.github.com/users/icing/events{/privacy}","received_events_url":"https://api.github.com/users/icing/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"icing","id":15102,"node_id":"MDQ6VXNlcjE1MTAy","avatar_url":"https://avatars.githubusercontent.com/u/15102?v=4","gravatar_id":"","url":"https://api.github.com/users/icing","html_url":"https://github.com/icing","followers_url":"https://api.github.com/users/icing/followers","following_url":"https://api.github.com/users/icing/following{/other_user}","gists_url":"https://api.github.com/users/icing/gists{/gist_id}","starred_url":"https://api.github.com/users/icing/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/icing/subscriptions","organizations_url":"https://api.github.com/users/icing/orgs","repos_url":"https://api.github.com/users/icing/repos","events_url":"https://api.github.com/users/icing/events{/privacy}","received_events_url":"https://api.github.com/users/icing/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":19,"created_at":"2024-04-10T10:57:26Z","updated_at":"2024-04-16T13:52:43Z","closed_at":"2024-04-16T13:52:43Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\n\nWe have the scenario when we put the transfer on pause and resume it after a while and then stop transfer with `CURL_WRITEFUNC_ERROR`. For that we register `CURLOPT_WRITEFUNCTION` callback and pause the transfer by returning `CURL_WRITEFUNC_PAUSE` from this callback. After some delay we resume transfer by calling `curl_easy_pause(..., CURLPAUSE_CONT)`. Then after our callback is called we stop transfer by returning `CURL_WRITEFUNC_ERROR`. In this scenario we faced with the problem that our callback is called twice after it had returned `CURL_WRITEFUNC_ERROR`.\r\n\r\nWe reproduced the behavior using example of code from the [comment](https://github.com/curl/curl/issues/4966#issuecomment-591544506), but slightly simplify it.\r\n\r\n```c\r\n#include <curl/curl.h>\r\n#include <stdbool.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nbool paused;\r\nint call_counter;\r\n\r\nstatic size_t http_body(void *buffer, size_t size, size_t nmemb, void *userp) {\r\n  call_counter++;\r\n  fprintf(stderr, \"http_body called at %d time\\n\", call_counter);\r\n\r\n  if (call_counter == 1) {\r\n    paused = true;\r\n    fprintf(stderr, \"Return pause\\n\");\r\n    return CURL_WRITEFUNC_PAUSE;\r\n  }\r\n\r\n  fprintf(stderr, \"Return abort\\n\");\r\n  return CURL_WRITEFUNC_ERROR;\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n  CURLM *curl_multi_handle;\r\n  CURL *curl;\r\n\r\n  const char *url = \"http://httpbin.org\";\r\n  struct CURLMsg *msg;\r\n  int running_handles;\r\n  int msgs_left;\r\n  call_counter = 0;\r\n  paused = false;\r\n\r\n  curl_global_init(CURL_GLOBAL_DEFAULT);\r\n  curl_multi_handle = curl_multi_init();\r\n  curl = curl_easy_init();\r\n\r\n  curl_easy_setopt(curl, CURLOPT_URL, url);\r\n  curl_easy_setopt(curl, CURLOPT_BUFFERSIZE, 1024);\r\n  curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);\r\n  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, http_body);\r\n  curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\r\n\r\n  curl_multi_add_handle(curl_multi_handle, curl);\r\n\r\n  curl_multi_perform(curl_multi_handle, &running_handles);\r\n\r\n  while (running_handles > 0) {\r\n    usleep(100 * 1000);\r\n\r\n    /* Resume if transfer is paused */\r\n    if (paused) {\r\n      fprintf(stderr, \"Resume transfer\\n\");\r\n      curl_easy_pause(curl, CURLPAUSE_CONT);\r\n      paused = false;\r\n    }\r\n\r\n    curl_multi_perform(curl_multi_handle, &running_handles);\r\n  }\r\n\r\n  msg = curl_multi_info_read(curl_multi_handle, &msgs_left);\r\n  fprintf(stderr, \"Connection finished: %s\\n\",\r\n          curl_easy_strerror(msg->data.result));\r\n\r\n  curl_multi_remove_handle(curl_multi_handle, curl);\r\n  curl_easy_cleanup(curl);\r\n  curl_multi_cleanup(curl_multi_handle);\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\nIn the result, we're observing the same behavior like in our use case.\r\n\r\n```\r\n#> ./pause-test  \r\n* Host httpbin.org:80 was resolved.\r\n* IPv6: (none)\r\n* IPv4: 3.223.18.102, 3.208.234.136, 35.168.90.70, 18.210.102.60, 18.204.54.143, 34.232.61.91, 54.87.28.144, 52.203.147.106\r\n*   Trying 3.223.18.102:80...\r\n* Connected to httpbin.org (3.223.18.102) port 80\r\n> GET / HTTP/1.1\r\nHost: httpbin.org\r\nAccept: */*\r\n\r\n* Request completely sent off\r\n< HTTP/1.1 200 OK\r\n< via: proxy A\r\n< Date: Wed, 10 Apr 2024 10:34:44 GMT\r\n< Server: gunicorn/19.9.0\r\n< Connection: Keep-Alive\r\n< Content-Type: text/html; charset=utf-8\r\n< Content-Length: 9593\r\n< Access-Control-Allow-Origin: *\r\n< Access-Control-Allow-Credentials: true\r\n< \r\nhttp_body called at 1 time\r\nReturn pause\r\nResume transfer\r\nhttp_body called at 2 time\r\nReturn abort\r\n* Failure writing output to destination, passed 771 returned 4294967295\r\nhttp_body called at 3 time                                                       <--- ?\r\nReturn abort\r\n* Failure writing output to destination, passed 1795 returned 4294967295\r\nhttp_body called at 4 time                                                       <--- ?\r\nReturn abort\r\n* Failure writing output to destination, passed 1795 returned 4294967295\r\n* Closing connection\r\nConnection finished: Failed writing received data to disk/application\r\n```\n\n### I expected the following\n\nCallback should not be called after return `CURL_WRITEFUNC_ERROR` from it. Behavior is correct in case we don't put the transfer on pause.\r\n\r\nJust comment the following block in the sample:\r\n\r\n```c\r\nif (call_counter == 1) {\r\n    paused = true;\r\n    fprintf(stderr, \"Return pause\\n\");\r\n    return CURL_WRITEFUNC_PAUSE;\r\n}\r\n```\n\n### curl/libcurl version\n\ncurl 8.7.1\r\ncurl 8.7.0-DEV (x86_64-pc-linux-gnu) libcurl/8.7.0-DEV BoringSSL zlib/1.2.11 c-ares/1.27.0 libpsl/0.21.0 nghttp2/1.60.0 quiche/0.20.1\r\nRelease-Date: [unreleased]\r\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns mqtt pop3 pop3s rtsp smb smbs smtp smtps telnet tftp\r\nFeatures: alt-svc AsynchDNS HSTS HTTP2 HTTP3 HTTPS-proxy IPv6 Largefile libz NTLM PSL SSL threadsafe UnixSockets\n\n### operating system\n\nLinux kwx1252784oftdls 5.13.0-52-generic #59~20.04.1-Ubuntu SMP Thu Jun 16 21:21:28 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux","closed_by":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/13337/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/13337/timeline","performed_via_github_app":null,"state_reason":"completed"}