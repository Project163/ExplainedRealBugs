{"url":"https://api.github.com/repos/curl/curl/issues/9180","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/9180/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/9180/comments","events_url":"https://api.github.com/repos/curl/curl/issues/9180/events","html_url":"https://github.com/curl/curl/issues/9180","id":1309550235,"node_id":"I_kwDOAAiu0c5ODiab","number":9180,"title":"libcurl: unpausing is broken for http2 requests in 7.84","user":{"login":"tilicho","id":6923597,"node_id":"MDQ6VXNlcjY5MjM1OTc=","avatar_url":"https://avatars.githubusercontent.com/u/6923597?v=4","gravatar_id":"","url":"https://api.github.com/users/tilicho","html_url":"https://github.com/tilicho","followers_url":"https://api.github.com/users/tilicho/followers","following_url":"https://api.github.com/users/tilicho/following{/other_user}","gists_url":"https://api.github.com/users/tilicho/gists{/gist_id}","starred_url":"https://api.github.com/users/tilicho/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tilicho/subscriptions","organizations_url":"https://api.github.com/users/tilicho/orgs","repos_url":"https://api.github.com/users/tilicho/repos","events_url":"https://api.github.com/users/tilicho/events{/privacy}","received_events_url":"https://api.github.com/users/tilicho/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":184118197,"node_id":"MDU6TGFiZWwxODQxMTgxOTc=","url":"https://api.github.com/repos/curl/curl/labels/regression","name":"regression","color":"33aa3f","default":false,"description":null},{"id":194601710,"node_id":"MDU6TGFiZWwxOTQ2MDE3MTA=","url":"https://api.github.com/repos/curl/curl/labels/HTTP/2","name":"HTTP/2","color":"009800","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":3,"created_at":"2022-07-19T13:46:10Z","updated_at":"2022-07-19T22:49:32Z","closed_at":"2022-07-19T22:49:32Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\r\n\r\n1. initialize http2 request with custom write callbacks for headers and body data from server (using CURLOPT_HEADERFUNCTION, CURLOPT_WRITEFUNCTION). wait for http2 request to be sent to server.\r\n2. pause request by returning CURL_WRITEFUNC_PAUSE from write callbacks.\r\n3. continue processing requests next 10-20 seconds. http2 response arrives from server for paused request during this time.\r\n4. unpause request using curl_easy_pause.\r\n5. wait for write callbacks to be called with headers and data from server.\r\n\r\nsee test example below\r\n\r\n### I expected the following\r\n\r\n1. I expected what curl_easy_pause will return success in step 4. It returns CURLE_BAD_FUNCTION_ARGUMENT (43).\r\n2. I expected that after unpausing request write callbacks for response headers and body will be called. But I didn't get headers and data.\r\n\r\n### curl/libcurl version\r\n\r\n7.84.0 \r\nIn previous version there is no problem with resuming http2 requests.\r\n\r\n### operating system\r\n\r\nall\r\n\r\n------------------------------------------------------------\r\n\r\n### test example\r\n```\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <errno.h>\r\n#include <sys/time.h>\r\n#include <unistd.h>\r\n#include <curl/curl.h>\r\n#include <assert.h>\r\n\r\nstruct transfer {\r\n  CURL *easy;\r\n  int paused;\r\n  int writed_data;\r\n  int writed_headers;\r\n};\r\n\r\nsize_t write_header(void *ptr, size_t size, size_t nmemb, void *userdata)\r\n{\r\n    struct transfer* tr;\r\n\r\n    tr = (struct transfer*)(userdata);\r\n    \r\n    // report that request was paused\r\n    if (tr->paused)\r\n    {\r\n        fprintf(stderr, \">> write_header %li paused \\n\", nmemb);\r\n        return CURL_WRITEFUNC_PAUSE;\r\n    }\r\n\r\n    fprintf(stderr, \">> write_header %li resumed \\n\", nmemb);\r\n    tr->writed_headers += size * nmemb;\r\n    return size * nmemb;\r\n}\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, void* userdata)\r\n{\r\n    struct transfer* tr;\r\n\r\n    tr = (struct transfer*)(userdata);\r\n\r\n    // report that request was paused\r\n    if (tr->paused)\r\n    {\r\n        fprintf(stderr, \">> write_data %li paused \\n\", nmemb);\r\n        return CURL_WRITEFUNC_PAUSE;\r\n    }\r\n\r\n    fprintf(stderr, \">> write_data %li resumed! \\n\", nmemb);\r\n    tr->writed_data += size * nmemb;\r\n    return size * nmemb;\r\n}\r\n\r\nstatic void setup(struct transfer *t)\r\n{\r\n  CURL *hnd;\r\n\r\n  hnd = t->easy = curl_easy_init();\r\n\r\n  t->paused = 1;\r\n  t->writed_data = 0;\r\n  t->writed_headers = 0;\r\n\r\n  // use custom callbacks for response headers and data\r\n  curl_easy_setopt(hnd, CURLOPT_HEADERFUNCTION, &write_header);\r\n  curl_easy_setopt(hnd, CURLOPT_WRITEHEADER, t);\r\n\r\n  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, &write_data);\r\n  curl_easy_setopt(hnd, CURLOPT_WRITEDATA, t);\r\n\r\n  // pass any server url that supports http2 and returns response with body\r\n  curl_easy_setopt(hnd, CURLOPT_URL, \"https://www.nghttp2.org/\"); \r\n  curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);\r\n\r\n  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_0);\r\n\r\n  // skip verification for test\r\n  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYPEER, 0L);\r\n  curl_easy_setopt(hnd, CURLOPT_SSL_VERIFYHOST, 0L);\r\n}\r\n\r\nstatic void resume(struct transfer *t)\r\n{\r\n  CURL *hnd;\r\n  int resResume;\r\n\r\n  hnd = t->easy;\r\n  t->paused = 0;\r\n  resResume = curl_easy_pause(hnd, 0L);\r\n  fprintf(stderr, \"curl_easy_pause result %i\\n\", resResume);\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n  struct transfer trans;\r\n  CURLM *multi_handle;\r\n  int still_running = 0; \r\n  int poll_counter = 0;\r\n\r\n  /* init a multi stack */\r\n  multi_handle = curl_multi_init();\r\n\r\n  setup(&trans);\r\n\r\n  curl_multi_add_handle(multi_handle, trans.easy);\r\n\r\n  do {\r\n    CURLMcode mc = curl_multi_perform(multi_handle, &still_running);\r\n\r\n    if(still_running)\r\n      /* wait for activity, timeout or \"nothing\" */\r\n      mc = curl_multi_poll(multi_handle, NULL, 0, 1000, NULL);\r\n\r\n    ++poll_counter;\r\n\r\n    if(mc)\r\n      break;\r\n\r\n    // after few multi poll calls resume request\r\n    if (poll_counter == 10)\r\n    {\r\n        fprintf(stderr, \"Resume transfers!\\n\");\r\n        resume(&trans);\r\n    }\r\n\r\n  } while(still_running);\r\n\r\n  // trace received headers and body bytes\r\n  fprintf(stderr, \"writed headers %i\\n\", trans.writed_headers);\r\n  fprintf(stderr, \"writed data size %i\\n\", trans.writed_data);\r\n  \r\n  // assert that we received some headers and body\r\n  assert(trans.writed_headers > 0);\r\n  assert(trans.writed_data > 0);\r\n  \r\n  curl_multi_remove_handle(multi_handle, trans.easy);\r\n  curl_easy_cleanup(trans.easy);\r\n\r\n  curl_multi_cleanup(multi_handle);\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\n### Possible breaking commit\r\n\r\nhttps://github.com/curl/curl/commit/d1e4a677340c6a1f0ebbc13f1021808c23ad1138  \r\n\r\n\r\n### Possible fix\r\n\r\nI think it should be near this line: https://github.com/curl/curl/blob/6e83e27f6cfa0ecf0b3eed547121d471aef46854/lib/sendf.c#L610 \r\n\r\n```\r\nstatic CURLcode chop_write(struct Curl_easy *data,\r\n                           int type,\r\n                           char *optr,\r\n                           size_t olen)\r\nstruct http_conn *httpc = &data->conn->proto.httpc;\r\n...\r\n\r\n  if(CURL_WRITEFUNC_PAUSE == wrote)\r\n  {\r\n    /* here we pass in the HEADER bit only since if this was body as well\r\n       then it was passed already and clearly that didn't trigger the\r\n       pause, so this is saved for later with the HEADER bit only */\r\n    \r\n    //at least for http2 transfers we should pass original type (which can be CLIENTWRITE_STATUS and http2 status should be processed not as normal CLIENTWRITE_HEADER)\r\n    if (httpc->h2)\r\n    {\r\n       infof(data, \"pausewrite fix for http2 headers of type %d\", type);\r\n       return pausewrite(data, type, optr, olen);\r\n    }\r\n    \r\n    return pausewrite(data, CLIENTWRITE_HEADER, optr, olen);\r\n  }\r\n``` \r\n\r\n","closed_by":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/9180/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/9180/timeline","performed_via_github_app":null,"state_reason":"completed"}