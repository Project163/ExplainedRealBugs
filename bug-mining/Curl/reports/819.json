{"url":"https://api.github.com/repos/curl/curl/issues/18848","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/18848/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/18848/comments","events_url":"https://api.github.com/repos/curl/curl/issues/18848/events","html_url":"https://github.com/curl/curl/issues/18848","id":3484007049,"node_id":"I_kwDOAAiu0c7PqbqJ","number":18848,"title":"MIME read callback not retriggered after unpause during 100-continue with curl_multi","user":{"login":"bdbai","id":5270106,"node_id":"MDQ6VXNlcjUyNzAxMDY=","avatar_url":"https://avatars.githubusercontent.com/u/5270106?v=4","gravatar_id":"","url":"https://api.github.com/users/bdbai","html_url":"https://github.com/bdbai","followers_url":"https://api.github.com/users/bdbai/followers","following_url":"https://api.github.com/users/bdbai/following{/other_user}","gists_url":"https://api.github.com/users/bdbai/gists{/gist_id}","starred_url":"https://api.github.com/users/bdbai/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bdbai/subscriptions","organizations_url":"https://api.github.com/users/bdbai/orgs","repos_url":"https://api.github.com/users/bdbai/repos","events_url":"https://api.github.com/users/bdbai/events{/privacy}","received_events_url":"https://api.github.com/users/bdbai/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":{"login":"icing","id":15102,"node_id":"MDQ6VXNlcjE1MTAy","avatar_url":"https://avatars.githubusercontent.com/u/15102?v=4","gravatar_id":"","url":"https://api.github.com/users/icing","html_url":"https://github.com/icing","followers_url":"https://api.github.com/users/icing/followers","following_url":"https://api.github.com/users/icing/following{/other_user}","gists_url":"https://api.github.com/users/icing/gists{/gist_id}","starred_url":"https://api.github.com/users/icing/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/icing/subscriptions","organizations_url":"https://api.github.com/users/icing/orgs","repos_url":"https://api.github.com/users/icing/repos","events_url":"https://api.github.com/users/icing/events{/privacy}","received_events_url":"https://api.github.com/users/icing/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"icing","id":15102,"node_id":"MDQ6VXNlcjE1MTAy","avatar_url":"https://avatars.githubusercontent.com/u/15102?v=4","gravatar_id":"","url":"https://api.github.com/users/icing","html_url":"https://github.com/icing","followers_url":"https://api.github.com/users/icing/followers","following_url":"https://api.github.com/users/icing/following{/other_user}","gists_url":"https://api.github.com/users/icing/gists{/gist_id}","starred_url":"https://api.github.com/users/icing/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/icing/subscriptions","organizations_url":"https://api.github.com/users/icing/orgs","repos_url":"https://api.github.com/users/icing/repos","events_url":"https://api.github.com/users/icing/events{/privacy}","received_events_url":"https://api.github.com/users/icing/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":6,"created_at":"2025-10-04T18:00:33Z","updated_at":"2025-10-21T14:31:09Z","closed_at":"2025-10-21T14:31:09Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\n\nI compiled and ran the attached C++ test program (see below) which demonstrates a MIME upload using `curl_multi` and a custom read callback. The callback returns `CURL_READFUNC_PAUSE` when data is not ready, and the transfer is unpaused later <del>from another thread</del> using `curl_easy_pause(easy, CURLPAUSE_SEND_CONT)`. The program uses a background thread for the multi loop and a foreground thread to provide data and trigger unpause.\n\n<details><summary>C++ reproducible</summary>\n\n```c++\n/*\n * Demonstration of curl bug: MIME callbacks not retriggered after unpause during 100-continue\n *\n * This program demonstrates an issue where curl_multi does not properly retry MIME read\n * callbacks after they are unpaused during the 100-continue flow.\n *\n * Setup:\n * - Background thread runs curl_multi_poll/perform loop\n * - MIME read callback pauses when data isn't ready yet\n * - Foreground thread provides data and notifies background thread to unpause the transfer\n * - Bug: After unpause, curl never calls the MIME callback again, causing a hang\n *\n * Workaround:\n * 1. Add \"Expect:\" header to disable 100-continue, or\n * 2. Before calling curl_easy_pause(...CURLPAUSE_SEND_CONT), also call curl_easy_pause(...CURLPAUSE_SEND)\n *\n * To compile:\n *   g++ -o curl_mime_pause_bug curl_mime_pause_bug.cpp -lcurl -lpthread\n *   cl curl_mime_pause_bug.cpp /link libcurl.lib\n *\n * To run:\n *   ./curl_mime_pause_bug\n *\n * Expected behavior: Request completes successfully\n * Actual behavior: Request hangs for around 15s after receiving \"100 Continue\"\n */\n\n#include <curl/curl.h>\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <atomic>\n#include <cstring>\n#include <chrono>\n\n // Shared state between threads\nstruct StreamState {\n    std::mutex mutex;\n    std::condition_variable cv;\n    char buffer[1024];\n    size_t buffer_len = 0;\n    bool want_data = false;\n    bool data_ready = false;\n};\n\nstruct MultiContext {\n    CURL* easy = nullptr;\n    CURLM* multi = nullptr;\n    std::atomic<bool> should_stop{ false };\n    std::atomic<bool> should_unpause{ false };\n};\n\n// MIME read callback - runs in background thread\nsize_t mime_read_callback(char* buffer, size_t size, size_t nitems, void* userdata) {\n    StreamState* state = static_cast<StreamState*>(userdata);\n    std::unique_lock<std::mutex> lock(state->mutex);\n\n    std::cout << \"[Background] MIME callback called, size=\" << (size * nitems) << std::endl;\n\n    // If we have data ready, return it\n    if (state->data_ready) {\n        size_t to_copy = std::min(state->buffer_len, size * nitems);\n        memcpy(buffer, state->buffer, to_copy);\n        state->buffer_len -= to_copy;\n        state->data_ready = false;\n        std::cout << \"[Background] MIME callback returning \" << to_copy << \" bytes\" << std::endl;\n        return to_copy;\n    }\n\n    // No data ready - pause and request data\n    std::cout << \"[Background] MIME callback pausing (no data ready)\" << std::endl;\n    state->want_data = true;\n    state->cv.notify_all(); // Wake up foreground thread to provide data\n    return CURL_READFUNC_PAUSE;\n}\n\n// Background thread that runs curl_multi loop\nvoid multi_thread_func(MultiContext* ctx) {\n    std::cout << \"[Background] Multi thread started\" << std::endl;\n\n    while (!ctx->should_stop.load()) {\n\n        // Poll for activity (120 second timeout)\n        int numfds = 0;\n        std::cout << \"[Background] Calling curl_multi_poll...\" << std::endl;\n        CURLMcode mc = curl_multi_poll(ctx->multi, nullptr, 0, 120000, &numfds);\n        if (mc != CURLM_OK) {\n            std::cerr << \"[Background] curl_multi_poll error: \" << curl_multi_strerror(mc) << std::endl;\n            break;\n        }\n\n        // Process unpause tasks\n        if (ctx->should_unpause.exchange(false)) {\n            std::cout << \"[Background] Unpausing CURL handle\" << std::endl;\n            // Workaround 2: Uncomment below\n            // curl_easy_pause(ctx->easy, CURLPAUSE_SEND);\n            CURLcode res = curl_easy_pause(ctx->easy, CURLPAUSE_SEND_CONT);\n            std::cout << \"[Background] curl_easy_pause returned: \" << res << std::endl;\n        }\n\n        // Perform transfers\n        int running = 0;\n        std::cout << \"[Background] Calling curl_multi_perform...\" << std::endl;\n        mc = curl_multi_perform(ctx->multi, &running);\n        if (mc != CURLM_OK) {\n            std::cerr << \"[Background] curl_multi_perform error: \" << curl_multi_strerror(mc) << std::endl;\n            break;\n        }\n\n        std::cout << \"[Background] After perform: running=\" << running << std::endl;\n\n        // Check for completed transfers\n        int msgs_in_queue;\n        CURLMsg* msg;\n        while ((msg = curl_multi_info_read(ctx->multi, &msgs_in_queue))) {\n            if (msg->msg == CURLMSG_DONE) {\n                std::cout << \"[Background] Transfer completed with result: \"\n                    << curl_easy_strerror(msg->data.result) << std::endl;\n                ctx->should_stop = true;\n            }\n        }\n\n        if (running == 0) {\n            std::cout << \"[Background] No more running transfers\" << std::endl;\n            break;\n        }\n    }\n\n    std::cout << \"[Background] Multi thread exiting\" << std::endl;\n}\n\n// Simulate async data provider in foreground thread\nvoid provide_data(CURL* curl, StreamState* state, MultiContext* ctx) {\n    std::cout << \"[Foreground] Waiting for data request...\" << std::endl;\n    {\n        std::unique_lock<std::mutex> lock(state->mutex);\n        state->cv.wait(lock, [state] { return state->want_data; });\n        state->want_data = false;\n    }\n\n    std::cout << \"[Foreground] Got data request, simulating data fetch...\" << std::endl;\n\n    // Provide data\n    {\n        std::lock_guard<std::mutex> lock(state->mutex);\n        const char* data = \"Hello, this is test data for MIME upload!\";\n        state->buffer_len = strlen(data);\n        memcpy(state->buffer, data, state->buffer_len);\n        state->data_ready = true;\n    }\n\n    std::cout << \"[Foreground] Data ready, requesting unpause...\" << std::endl;\n\n    // Request unpause in background thread\n    ctx->should_unpause.store(true);\n\n    // Wake up the multi thread\n    std::cout << \"[Foreground] Waking up background thread with curl_multi_wakeup...\" << std::endl;\n    curl_multi_wakeup(ctx->multi);\n\n    std::cout << \"[Foreground] Waiting for second callback (if it happens)...\" << std::endl;\n    {\n        std::unique_lock<std::mutex> lock(state->mutex);\n        // Wait up to 5 seconds for second pause\n        if (state->cv.wait_for(lock, std::chrono::seconds(5), [state]\n            {\n                std::cout << \"[Foreground] Checking if paused again: \" << state->want_data << std::endl;\n                return state->want_data;\n            })) {\n            std::cout << \"[Foreground] Second callback paused, sending EOF\" << std::endl;\n            state->buffer_len = 0;\n            state->data_ready = true;\n            state->want_data = false;\n            // Request unpause again for EOF\n            ctx->should_unpause.store(true);\n            curl_multi_wakeup(ctx->multi);\n        }\n        else {\n            std::cout << \"[Foreground] WARNING: Second callback never paused! This is the bug.\" << std::endl;\n            std::cout << \"[Foreground] The transfer is likely hung.\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    std::cout << \"=== Curl MIME Pause Bug Demonstration ===\" << std::endl;\n    std::cout << \"Testing: curl_multi with paused MIME callbacks during 100-continue\" << std::endl;\n    std::cout << std::endl;\n\n    curl_global_trace(\"ALL\");\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    // Create easy handle\n    CURL* curl = curl_easy_init();\n    if (!curl) {\n        std::cerr << \"Failed to create CURL handle\" << std::endl;\n        return 1;\n    }\n\n    // Setup stream state\n    StreamState state;\n\n    // Create MIME structure\n    curl_mime* mime = curl_mime_init(curl);\n    curl_mimepart* part = curl_mime_addpart(mime);\n    curl_mime_name(part, \"file\");\n    curl_mime_filename(part, \"test.txt\");\n    curl_mime_type(part, \"text/plain\");\n    curl_mime_data_cb(part, -1, mime_read_callback, nullptr, nullptr, &state);\n\n    // Configure easy handle\n    // Use httpbin.org which supports 100-continue\n    curl_easy_setopt(curl, CURLOPT_URL, \"http://httpbin.org/post\");\n    curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);\n    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n    curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);\n\n    // Workaround 1: Uncomment below\n    // curl_slist* headers = curl_slist_append(nullptr, \"Expect:\");\n    // curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n    // Create multi handle\n    MultiContext ctx;\n    ctx.multi = curl_multi_init();\n    curl_multi_add_handle(ctx.multi, curl);\n    ctx.easy = curl;\n\n    // Start background thread\n    std::cout << \"[Main] Starting background thread...\" << std::endl;\n    std::thread bg_thread(multi_thread_func, &ctx, &state);\n\n    // Provide data from foreground thread\n    std::cout << \"[Main] Starting foreground data provider...\" << std::endl;\n    provide_data(curl, &state, &ctx);\n\n    // Wait for completion with timeout\n    std::cout << \"\\n[Main] Waiting for background thread to complete (10 second timeout)...\" << std::endl;\n    auto start = std::chrono::steady_clock::now();\n    while (!ctx.should_stop.load()) {\n        auto elapsed = std::chrono::steady_clock::now() - start;\n        if (elapsed > std::chrono::seconds(10)) {\n            std::cout << \"[Main] TIMEOUT! Transfer did not complete.\" << std::endl;\n            std::cout << \"[Main] This confirms the bug: curl doesn't retry MIME callback after unpause.\" << std::endl;\n            ctx.should_stop = true;\n            curl_multi_wakeup(ctx.multi);\n            break;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    bg_thread.join();\n\n    // Cleanup\n    std::cout << \"\\n[Main] Cleaning up...\" << std::endl;\n    curl_multi_remove_handle(ctx.multi, curl);\n    curl_multi_cleanup(ctx.multi);\n    curl_mime_free(mime);\n    curl_easy_cleanup(curl);\n    curl_global_cleanup();\n\n    std::cout << \"\\n=== Test Complete ===\" << std::endl;\n\n    return 0;\n}\n```\n</details>\n\n## Background\n\nThe issue was discovered in [nyquest](https://github.com/bdbai/nyquest/pull/14) project (specifically [this PR](https://github.com/bdbai/nyquest/pull/14) and this [CI job](https://github.com/bdbai/nyquest/actions/runs/18243145568/job/51947690553#logs)). It aims to bridge Rust async environments and curl multi handles by running the multi poll loop in a background thread, similar to the threading model in the sample snippet. In order to serve multiple concurrent requests efficiently within a single thread, the pausing/unpausing mechanism plays a critical role here to unblock the thread even when there are slow readers.\n\n### I expected the following\n\nAfter unpausing the transfer, I expected libcurl to call the MIME read callback again so the upload could continue and complete successfully, without hanging.\n\n### curl/libcurl version\n\nlibcurl 8.14.1\n\n### operating system\n\nWindows 11\nUbuntu seems to have the same issue as in  this GitHub Action job https://github.com/bdbai/nyquest/actions/runs/18243145568/job/51947690553","closed_by":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/18848/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/18848/timeline","performed_via_github_app":null,"state_reason":"completed"}