{"url":"https://api.github.com/repos/curl/curl/issues/10971","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/10971/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/10971/comments","events_url":"https://api.github.com/repos/curl/curl/issues/10971/events","html_url":"https://github.com/curl/curl/issues/10971","id":1669437719,"node_id":"I_kwDOAAiu0c5jgZkX","number":10971,"title":"Memory leak when cancelling paused http 2 transfer","user":{"login":"lemourin","id":11277986,"node_id":"MDQ6VXNlcjExMjc3OTg2","avatar_url":"https://avatars.githubusercontent.com/u/11277986?v=4","gravatar_id":"","url":"https://api.github.com/users/lemourin","html_url":"https://github.com/lemourin","followers_url":"https://api.github.com/users/lemourin/followers","following_url":"https://api.github.com/users/lemourin/following{/other_user}","gists_url":"https://api.github.com/users/lemourin/gists{/gist_id}","starred_url":"https://api.github.com/users/lemourin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/lemourin/subscriptions","organizations_url":"https://api.github.com/users/lemourin/orgs","repos_url":"https://api.github.com/users/lemourin/repos","events_url":"https://api.github.com/users/lemourin/events{/privacy}","received_events_url":"https://api.github.com/users/lemourin/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":182083182,"node_id":"MDU6TGFiZWwxODIwODMxODI=","url":"https://api.github.com/repos/curl/curl/labels/memory-leak","name":"memory-leak","color":"c7def8","default":false,"description":null},{"id":194601710,"node_id":"MDU6TGFiZWwxOTQ2MDE3MTA=","url":"https://api.github.com/repos/curl/curl/labels/HTTP/2","name":"HTTP/2","color":"009800","default":false,"description":null}],"state":"closed","locked":false,"assignee":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":4,"created_at":"2023-04-15T14:41:03Z","updated_at":"2023-04-16T12:40:52Z","closed_at":"2023-04-15T21:30:52Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\r\n\r\nI wrote the following program which at the high level does the following:\r\n\r\n1. fire two requests to the same url concurrently\r\n2. pause each of them after 16mb are received\r\n3. fire two requests to the same url concurrently 4s after the first request\r\n4. pause them after 16mb are received\r\n5. cancel requests fired in 3. 4s after they were started\r\n6. cancel requests fired in 1. 11s after they were started\r\n\r\nEssentially it tries to cancel requests after they were paused.\r\n\r\n```cpp\r\n#include <curl/curl.h>\r\n#include <event2/event.h>\r\n\r\n#include <iostream>\r\n#include <list>\r\n#include <sstream>\r\n#include <vector>\r\n\r\nnamespace {\r\n\r\nconstexpr const char* kUrl =\r\n    \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/\"\r\n    \"BigBuckBunny.mp4\";\r\n\r\nconstexpr int kRequestCount = 2;\r\nconstexpr int kHttpVersion = CURL_HTTP_VERSION_2;\r\n\r\nvoid TimeoutEvent(evutil_socket_t, short, void* handle);\r\n\r\ntemplate <typename T>\r\nT* CheckNotNull(T* p) {\r\n  if (!p) {\r\n    throw std::runtime_error(\"Unexpected null pointer.\");\r\n  }\r\n  return p;\r\n}\r\n\r\nvoid Check(int code) {\r\n  if (code < 0) {\r\n    std::stringstream stream;\r\n    stream << \"Unexpected error code: \" << code;\r\n    throw std::runtime_error(stream.str().c_str());\r\n  }\r\n}\r\n\r\nvoid Check(CURLcode code) {\r\n  if (code != CURLE_OK) {\r\n    throw std::runtime_error(curl_easy_strerror(code));\r\n  }\r\n}\r\n\r\nvoid Check(CURLMcode code) {\r\n  if (code != CURLM_OK) {\r\n    throw std::runtime_error(curl_multi_strerror(code));\r\n  }\r\n}\r\n\r\nstruct CurlMultiDeleter {\r\n  void operator()(CURLM* handle) const noexcept {\r\n    Check(curl_multi_cleanup(handle));\r\n  }\r\n};\r\n\r\nstruct CurlHandleDeleter {\r\n  void operator()(CURL* handle) const noexcept {\r\n    Check(curl_multi_remove_handle(multi_handle, handle));\r\n    curl_easy_cleanup(handle);\r\n  }\r\n\r\n  CURLM* multi_handle;\r\n};\r\n\r\nstruct EventBaseDeleter {\r\n  void operator()(event_base* event_loop) const noexcept {\r\n    event_base_free(event_loop);\r\n  }\r\n};\r\n\r\nstruct EventDeleter {\r\n  void operator()(event* event) const noexcept {\r\n    Check(event_del(event));\r\n    event_free(event);\r\n  }\r\n};\r\n\r\nclass CurlGlobalInitializer {\r\n public:\r\n  CurlGlobalInitializer() { Check(curl_global_init(CURL_GLOBAL_DEFAULT)); }\r\n  ~CurlGlobalInitializer() noexcept { curl_global_cleanup(); }\r\n};\r\n\r\nstruct MultiContext {\r\n  std::unique_ptr<CURLM, CurlMultiDeleter> handle{\r\n      CheckNotNull(curl_multi_init())};\r\n  event_base* event_loop;\r\n  std::unique_ptr<event, EventDeleter> timeout_event{\r\n      CheckNotNull(event_new(event_loop, /*fd=*/-1,\r\n                             /*events=*/0, TimeoutEvent, handle.get()))};\r\n};\r\n\r\nstruct HandleContext {\r\n  std::unique_ptr<CURL, CurlHandleDeleter> handle;\r\n  size_t bytes_read = 0;\r\n  int resume_count = 0;\r\n  event_base* event_loop;\r\n  MultiContext* context;\r\n};\r\n\r\nauto MakeHandle(CURLM* multi_handle) {\r\n  CURL* handle = CheckNotNull(curl_easy_init());\r\n  if (CURLMcode code = curl_multi_add_handle(multi_handle, handle);\r\n      code != CURLM_OK) {\r\n    curl_easy_cleanup(handle);\r\n    throw std::runtime_error(curl_multi_strerror(code));\r\n  }\r\n  return std::unique_ptr<CURL, CurlHandleDeleter>(\r\n      handle, CurlHandleDeleter{multi_handle});\r\n}\r\n\r\nvoid ProcessEvents(CURLM* multi_handle) {\r\n  CURLMsg* message;\r\n  do {\r\n    int message_count;\r\n    message = curl_multi_info_read(multi_handle, &message_count);\r\n    if (message && message->msg == CURLMSG_DONE) {\r\n      std::cerr << \"TRANSFER DONE\\n\";\r\n    }\r\n  } while (message != nullptr);\r\n}\r\n\r\nsize_t WriteCallback(char* /*ptr*/, size_t size, size_t nmemb, void* userdata) {\r\n  auto* context = static_cast<HandleContext*>(userdata);\r\n  context->bytes_read += size * nmemb;\r\n  if (context->bytes_read >= 16 * 1024 * 1024) {\r\n    context->bytes_read = 0;\r\n    std::cerr << \"PAUSING \" << context << '\\n';\r\n    return CURL_WRITEFUNC_PAUSE;\r\n  }\r\n  return size * nmemb;\r\n}\r\n\r\nvoid TimeoutEvent(evutil_socket_t, short, void* handle) {\r\n  int running_handles;\r\n  Check(curl_multi_socket_action(handle, CURL_SOCKET_TIMEOUT, 0,\r\n                                 &running_handles));\r\n  ProcessEvents(handle);\r\n}\r\n\r\nvoid SocketEvent(evutil_socket_t fd, short event, void* handle) {\r\n  int running_handles;\r\n  Check(\r\n      curl_multi_socket_action(handle, fd,\r\n                               ((event & EV_READ) ? CURL_CSELECT_IN : 0) |\r\n                                   ((event & EV_WRITE) ? CURL_CSELECT_OUT : 0),\r\n                               &running_handles));\r\n  ProcessEvents(handle);\r\n}\r\n\r\nint SocketCallback(CURL*, curl_socket_t socket, int what, void* userp,\r\n                   void* socketp) {\r\n  auto* context = reinterpret_cast<MultiContext*>(userp);\r\n  if (what == CURL_POLL_REMOVE) {\r\n    auto* data = reinterpret_cast<event*>(socketp);\r\n    if (data) {\r\n      event_free(data);\r\n    }\r\n  } else {\r\n    auto* data = reinterpret_cast<event*>(socketp);\r\n    if (data) {\r\n      event_free(data);\r\n    }\r\n    data = CheckNotNull(\r\n        event_new(context->event_loop, socket,\r\n                  static_cast<short>(((what & CURL_POLL_IN) ? EV_READ : 0) |\r\n                                     ((what & CURL_POLL_OUT) ? EV_WRITE : 0) |\r\n                                     EV_PERSIST),\r\n                  SocketEvent, context->handle.get()));\r\n    Check(curl_multi_assign(context->handle.get(), socket, data));\r\n    Check(event_add(data, /*timeout=*/nullptr));\r\n  }\r\n  return 0;\r\n}\r\n\r\nint TimerCallback(CURLM*, long timeout_ms, void* userp) {\r\n  auto* http = reinterpret_cast<MultiContext*>(userp);\r\n  if (timeout_ms == -1) {\r\n    Check(event_del(http->timeout_event.get()));\r\n  } else {\r\n    timeval tv = {\r\n        .tv_sec = static_cast<decltype(tv.tv_sec)>(timeout_ms / 1000),\r\n        .tv_usec = static_cast<decltype(tv.tv_usec)>(timeout_ms % 1000 * 1000)};\r\n    Check(event_add(http->timeout_event.get(), &tv));\r\n  }\r\n  return 0;\r\n}\r\n\r\n}  // namespace\r\n\r\nint main() {\r\n  CurlGlobalInitializer initializer;\r\n\r\n  std::cerr << curl_version() << '\\n';\r\n\r\n  std::unique_ptr<event_base, EventBaseDeleter> event_loop(\r\n      CheckNotNull(event_base_new()));\r\n  MultiContext context{.event_loop = event_loop.get()};\r\n  Check(curl_multi_setopt(context.handle.get(), CURLMOPT_SOCKETFUNCTION,\r\n                          SocketCallback));\r\n  Check(curl_multi_setopt(context.handle.get(), CURLMOPT_SOCKETDATA, &context));\r\n  Check(curl_multi_setopt(context.handle.get(), CURLMOPT_TIMERFUNCTION,\r\n                          TimerCallback));\r\n  Check(curl_multi_setopt(context.handle.get(), CURLMOPT_TIMERDATA, &context));\r\n\r\n  std::list<HandleContext> handle_contexts{kRequestCount};\r\n  for (auto& handle_context : handle_contexts) {\r\n    handle_context.context = &context;\r\n    handle_context.event_loop = event_loop.get();\r\n\r\n    CURL* handle =\r\n        (handle_context.handle = MakeHandle(context.handle.get())).get();\r\n    Check(curl_easy_setopt(handle, CURLOPT_URL, kUrl));\r\n    Check(curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, WriteCallback));\r\n    Check(curl_easy_setopt(handle, CURLOPT_WRITEDATA, &handle_context));\r\n    Check(curl_easy_setopt(handle, CURLOPT_HTTP_VERSION, kHttpVersion));\r\n  }\r\n  struct Data {\r\n    MultiContext* context;\r\n    event_base* event_loop;\r\n    std::list<HandleContext>* handle_contexts;\r\n  } data = {.context = &context,\r\n            .event_loop = event_loop.get(),\r\n            .handle_contexts = &handle_contexts};\r\n  {\r\n    timeval tv{.tv_sec = 3};\r\n    Check(event_base_once(\r\n        event_loop.get(), /*fd=*/-1, /*events=*/EV_TIMEOUT,\r\n        [](evutil_socket_t, short, void* userdata) {\r\n          auto* context = static_cast<Data*>(userdata);\r\n          for (int i = 0; i < kRequestCount; i++) {\r\n            HandleContext& handle_context =\r\n                context->handle_contexts->emplace_back();\r\n            handle_context.context = context->context;\r\n            handle_context.event_loop = context->event_loop;\r\n\r\n            CURL* handle = (handle_context.handle =\r\n                                MakeHandle(context->context->handle.get()))\r\n                               .get();\r\n            Check(curl_easy_setopt(handle, CURLOPT_URL, kUrl));\r\n            Check(\r\n                curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, WriteCallback));\r\n            Check(curl_easy_setopt(handle, CURLOPT_WRITEDATA, &handle_context));\r\n            Check(curl_easy_setopt(handle, CURLOPT_HTTP_VERSION, kHttpVersion));\r\n            timeval tv{.tv_sec = 4};\r\n            Check(event_base_once(\r\n                context->event_loop, /*fd=*/-1, /*events=*/EV_TIMEOUT,\r\n                [](evutil_socket_t, short, void* userdata) {\r\n                  auto* context = static_cast<HandleContext*>(userdata);\r\n                  std::cerr << \"TIMEOUT DELAYED TRANSFER \" << context << '\\n';\r\n                  Check(curl_multi_remove_handle(context->context->handle.get(),\r\n                                                 context->handle.get()));\r\n                },\r\n                &handle_context, &tv));\r\n          }\r\n        },\r\n        &data, &tv));\r\n  }\r\n\r\n  for (auto& handle_context : handle_contexts) {\r\n    timeval tv{.tv_sec = 11};\r\n    Check(event_base_once(\r\n        event_loop.get(), /*fd=*/-1, /*events=*/EV_TIMEOUT,\r\n        [](evutil_socket_t, short, void* userdata) {\r\n          auto* context = static_cast<HandleContext*>(userdata);\r\n          std::cerr << \"TIMEOUT TRANSFER \" << context << '\\n';\r\n          Check(curl_multi_remove_handle(context->context->handle.get(),\r\n                                         context->handle.get()));\r\n        },\r\n        &handle_context, &tv));\r\n  }\r\n  Check(event_base_loop(event_loop.get(), /*flags=*/0));\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\nThis results in the following memory leak when running with address sanitizer:\r\n```\r\nDetected memory leaks\r\nDirect leak of 1048656 byte(s) in 1 object(s) allocated from:\r\n  at 0x563f7e2385ea __interceptor_realloc.part.0 (asan_malloc_linux.cpp.o)\r\n  at 0x563f7e293621 curl_dbg_realloc (memdebug.c:265)\r\n  at 0x563f7e2e5aec dyn_nappend (dynbuf.c:100)\r\n  at 0x563f7e2e58e9 Curl_dyn_addn (dynbuf.c:164)\r\n  at 0x563f7e2a7423 pausewrite (sendf.c:236)\r\n  at 0x563f7e2a6e15 chop_write (sendf.c:268)\r\n  at 0x563f7e2a6b47 Curl_client_write (sendf.c:386)\r\n  at 0x563f7e2b97aa readwrite_data (transfer.c:706)\r\n  at 0x563f7e2b88a5 Curl_readwrite (transfer.c:1111)\r\n  at 0x563f7e29ff52 multi_runsingle (multi.c:2436)\r\n  at 0x563f7e2a19ba multi_socket (multi.c:3219)\r\n  at 0x563f7e2a1b51 curl_multi_socket_action (multi.c:3340)\r\n  at 0x563f7e283d55 (anonymous namespace)::SocketEvent(int, short, void*) (curl.cc:142)\r\n  at 0x563f7e3512d7 event_persist_closure (event.c:1659)\r\n  at 0x563f7e3508de event_process_active_single_queue (event.c:1718)\r\n  at 0x563f7e34b0b4 event_process_active (event.c:1819)\r\n  at 0x563f7e349ebb event_base_loop (event.c:2068)\r\n  at 0x563f7e281c1e main (curl.cc:270)\r\n  at 0x7f95d37e978f\r\nDirect leak of 16392 byte(s) in 1 object(s) allocated from:\r\n  at 0x563f7e2385ea __interceptor_realloc.part.0 (asan_malloc_linux.cpp.o)\r\n  at 0x563f7e293621 curl_dbg_realloc (memdebug.c:265)\r\n  at 0x563f7e2e5aec dyn_nappend (dynbuf.c:100)\r\n  at 0x563f7e2e58e9 Curl_dyn_addn (dynbuf.c:164)\r\n  at 0x563f7e2a7423 pausewrite (sendf.c:236)\r\n  at 0x563f7e2a6f92 chop_write (sendf.c:311)\r\n  at 0x563f7e2a6b47 Curl_client_write (sendf.c:386)\r\n  at 0x563f7e2b97aa readwrite_data (transfer.c:706)\r\n  at 0x563f7e2b88a5 Curl_readwrite (transfer.c:1111)\r\n  at 0x563f7e29ff52 multi_runsingle (multi.c:2436)\r\n  at 0x563f7e2a19ba multi_socket (multi.c:3219)\r\n  at 0x563f7e2a1b51 curl_multi_socket_action (multi.c:3340)\r\n  at 0x563f7e283d55 (anonymous namespace)::SocketEvent(int, short, void*) (curl.cc:142)\r\n  at 0x563f7e3512d7 event_persist_closure (event.c:1659)\r\n  at 0x563f7e3508de event_process_active_single_queue (event.c:1718)\r\n  at 0x563f7e34b0b4 event_process_active (event.c:1819)\r\n  at 0x563f7e349ebb event_base_loop (event.c:2068)\r\n  at 0x563f7e281c1e main (curl.cc:270)\r\n  at 0x7f95d37e978f\r\n```\r\n\r\nInterestingly enough, the memory leak doesn't occur when forcing http version 1.1. Possibly the issue could be specific to http 2.\r\n\r\n### I expected the following\r\n\r\nNo memory leaks.\r\n\r\n### curl/libcurl version\r\n\r\nlibcurl/7.88.1-DEV OpenSSL/3.0.8 zlib/1.2.13 c-ares/1.19.0 nghttp2/1.51.0\r\n\r\n### operating system\r\n\r\nLinux razer 6.1.23-1-MANJARO #1 SMP PREEMPT_DYNAMIC Thu Apr  6 19:47:04 UTC 2023 x86_64 GNU/Linux\r\n\r\nHappens on Windows as well.\r\n","closed_by":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/10971/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/10971/timeline","performed_via_github_app":null,"state_reason":"completed"}