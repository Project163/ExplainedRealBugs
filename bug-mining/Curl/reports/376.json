{"url":"https://api.github.com/repos/curl/curl/issues/12608","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/12608/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/12608/comments","events_url":"https://api.github.com/repos/curl/curl/issues/12608/events","html_url":"https://github.com/curl/curl/issues/12608","id":2060203287,"node_id":"I_kwDOAAiu0c56zDUX","number":12608,"title":"Rare Windows crash due to potentially dangling `data->state.mimepost` pointer","user":{"login":"tferguson7337","id":17223629,"node_id":"MDQ6VXNlcjE3MjIzNjI5","avatar_url":"https://avatars.githubusercontent.com/u/17223629?v=4","gravatar_id":"","url":"https://api.github.com/users/tferguson7337","html_url":"https://github.com/tferguson7337","followers_url":"https://api.github.com/users/tferguson7337/followers","following_url":"https://api.github.com/users/tferguson7337/following{/other_user}","gists_url":"https://api.github.com/users/tferguson7337/gists{/gist_id}","starred_url":"https://api.github.com/users/tferguson7337/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tferguson7337/subscriptions","organizations_url":"https://api.github.com/users/tferguson7337/orgs","repos_url":"https://api.github.com/users/tferguson7337/repos","events_url":"https://api.github.com/users/tferguson7337/events{/privacy}","received_events_url":"https://api.github.com/users/tferguson7337/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":184118205,"node_id":"MDU6TGFiZWwxODQxMTgyMDU=","url":"https://api.github.com/repos/curl/curl/labels/crash","name":"crash","color":"bfe5bf","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2023-12-29T15:38:44Z","updated_at":"2024-01-02T22:33:11Z","closed_at":"2024-01-02T22:33:11Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\n\nFirst time tracing through curl code and I'm unfamiliar with curl's workflow, so apologies in advanced if my analysis here is lacking or inaccurate.\r\n\r\nFrom what I can tell, a somewhat recent change was made via https://github.com/curl/curl/commit/74b87a8af13a155c659227f5acfa78243a8b2aa6, which added two new `formp` and `mimepost` pointers to `UrlState`.  There appears to be a case where the `mimepost` pointer can be set to `formp`, but left dangling after `formp` is freed and cleared.\r\n\r\nCrashing stack (bottom of stack w/ non-curl calls omitted for privacy):\r\n```\r\n # Child-SP          RetAddr               Call Site\r\n00 000000bf`012fe038 00007ff9`5f27235f     ntdll!LdrpICallHandler+0xf\r\n01 000000bf`012fe040 00007ff9`5f2214a4     ntdll!RtlpExecuteHandlerForException+0xf\r\n02 000000bf`012fe070 00007ff9`5f270e8e     ntdll!RtlDispatchException+0x244\r\n03 000000bf`012fe780 00007ff9`5f25c67e     ntdll!KiUserExceptionDispatch+0x2e\r\n04 000000bf`012fee98 00007ff6`bceb0696     ntdll!LdrpDispatchUserCallTarget+0xe\r\n05 000000bf`012feea0 00007ff6`bceaf659     <my_exe>!mime_part_rewind+0x56 [...\\curl\\lib\\mime.c @ 1078] \r\n06 000000bf`012feed0 00007ff6`bcea9984     <my_exe>!Curl_mime_rewind+0x9 [...\\curl\\lib\\mime.c @ 1611] \r\n07 000000bf`012fef00 00007ff6`bcea7a39     <my_exe>!readrewind+0x1f4 [...\\curl\\lib\\multi.c @ 1797] \r\n08 000000bf`012fef30 00007ff6`bcea6693     <my_exe>!multi_runsingle+0x5d9 [...\\curl\\lib\\multi.c @ 2116] \r\n09 000000bf`012ff040 00007ff6`bce9ec07     <my_exe>!curl_multi_perform+0xa3 [...\\curl\\lib\\multi.c @ 2741] \r\n0a (Inline Function) --------`--------     <my_exe>!easy_transfer+0x37 [...\\curl\\lib\\easy.c @ 679] \r\n0b (Inline Function) --------`--------     <my_exe>!easy_perform+0x12d [...\\curl\\lib\\easy.c @ 769] \r\n0c 000000bf`012ff0c0 00007ff6`bc9935aa     <my_exe>!curl_easy_perform+0x137 [...\\curl\\lib\\easy.c @ 788] \r\n...\r\n```\r\n\r\n`data->state` content, showing null `formp` and (dangling?) `mimepost` at time of crash:\r\n```\r\n0:067> ?? &data->state\r\nstruct UrlState * 0x00000285`9371ba88\r\n...\r\n   +0x5b8 mimepost         : 0x00000285`95e772a0 curl_mimepart\r\n   +0x5c0 formp            : (null) \r\n...\r\n```\r\n\r\n`data->state.mimepost` content at time of crash, which appears to be in the midst of getting modified by something else at this point - content is incoherent:\r\n```\r\n0:067> dt -r2 curl_mimepart 0x00000285`95e772a0\r\n<my_exe>!curl_mimepart\r\n   +0x000 parent           : 0x00000000`00010000 curl_mime\r\n      +0x000 parent           : ???? \r\n      +0x008 firstpart        : ???? \r\n      +0x010 lastpart         : ???? \r\n      +0x018 boundary         : [47]  \"--- memory read error at address 0x00000000`00010018 ---\"\r\n      +0x048 state            : mime_state\r\n         +0x000 state            : ??\r\n         +0x008 ptr              : ???? \r\n         +0x010 offset           : ??\r\n   +0x008 nextpart         : 0x00000000`00000004 curl_mimepart\r\n      +0x000 parent           : ???? \r\n      +0x008 nextpart         : ???? \r\n      +0x010 kind             : ??\r\n      +0x014 flags            : ??\r\n      +0x018 data             : ???? \r\n      +0x020 readfunc         : ???? \r\n      +0x028 seekfunc         : ???? \r\n      +0x030 freefunc         : ???? \r\n      +0x038 arg              : ???? \r\n      +0x040 fp               : ???? \r\n      +0x048 curlheaders      : ???? \r\n      +0x050 userheaders      : ???? \r\n      +0x058 mimetype         : ???? \r\n      +0x060 filename         : ???? \r\n      +0x068 name             : ???? \r\n      +0x070 datasize         : ??\r\n      +0x078 state            : mime_state\r\n         +0x000 state            : ??\r\n         +0x008 ptr              : ???? \r\n         +0x010 offset           : ??\r\n      +0x090 encoder          : ???? \r\n      +0x098 encstate         : mime_encoder_state\r\n         +0x000 pos              : ??\r\n         +0x008 bufbeg           : ??\r\n         +0x010 bufend           : ??\r\n         +0x018 buf              : [256]  \"--- memory read error at address 0x00000000`000000b4 ---\"\r\n      +0x1b0 lastreadstatus   : ??\r\n   +0x010 kind             : 0 ( MIMEKIND_NONE )\r\n   +0x014 flags            : 0\r\n   +0x018 data             : (null) \r\n   +0x020 readfunc         : (null) \r\n   +0x028 seekfunc         : (null) \r\n   +0x030 freefunc         : 0x00000285`95e77328     void  +28595e77328\r\n   +0x038 arg              : 0x00000285`92163e50 Void\r\n   +0x040 fp               : 0x00000007`00000003 _iobuf\r\n      +0x000 _Placeholder     : ???? \r\n   +0x048 curlheaders      : 0x00000000`00020002 curl_slist\r\n      +0x000 data             : ???? \r\n      +0x008 next             : ???? \r\n   +0x050 userheaders      : (null) \r\n   +0x058 mimetype         : 0x00000285`95e77318  \"???\"\r\n   +0x060 filename         : 0x00000285`921789c6  \"???\"\r\n   +0x068 name             : 0x0000000e`0000000e  \"--- memory read error at address 0x0000000e`0000000e ---\"\r\n   +0x070 datasize         : 0n8589934623\r\n   +0x078 state            : mime_state\r\n      +0x000 state            : 3 ( MIMESTATE_EOH )\r\n      +0x008 ptr              : 0x00000000`0000000e Void\r\n      +0x010 offset           : 0n256\r\n   +0x090 encoder          : (null) \r\n   +0x098 encstate         : mime_encoder_state\r\n      +0x000 pos              : 0\r\n      +0x008 bufbeg           : 0\r\n      +0x010 bufend           : 0x00000285`91a56d00\r\n      +0x018 buf              : [256]  \"\"\r\n   +0x1b0 lastreadstatus   : 1\r\n```\r\n\r\nIt's hard to 100% confirm from the crash dump, but I believe the following occurred:\r\n\r\n\r\n1. In the middle of attempting a previous HTTP-POST, we appear to hit a network issue (there's hints in the dump of us getting back `CURLE_SSL_CONNECT_ERROR` in a previous operation using this easy curl handle).\r\nI believe we made it far enough for `formp` to get allocated in `Curl_http_body`, and for `mimepost` to be assigned to:\r\n```\r\n  case HTTPREQ_POST_FORM:\r\n    /* Convert the form structure into a mime structure, then keep\r\n       the conversion */\r\n    if(!data->state.formp) {\r\n      data->state.formp = calloc(sizeof(curl_mimepart), 1);\r\n      if(!data->state.formp)\r\n        return CURLE_OUT_OF_MEMORY;\r\n      Curl_mime_cleanpart(data->state.formp);\r\n      result = Curl_getformdata(data, data->state.formp, data->set.httppost,\r\n                                data->state.fread_func);\r\n      if(result)\r\n        return result;\r\n      data->state.mimepost = data->state.formp;\r\n```\r\n\r\nBut hit network issues later on when doing the request that resulted in `data->state.rewindbeforesend` to be set to TRUE, potentially in `Curl_retry_request`:\r\n```\r\n    if((conn->handler->protocol&PROTO_FAMILY_HTTP) &&\r\n       data->req.writebytecount) {\r\n      data->state.rewindbeforesend = TRUE;\r\n      infof(data, \"state.rewindbeforesend = TRUE\");\r\n    }\r\n```\r\n\r\n\r\n2. We later reuse the same easy curl handle to attempt a final \"goodbye\" POST.\r\n\r\nThis again uses `CURLOPT_HTTPPOST`, which frees and clears `data->state.formp` (note that `data->state.mimepost` is not cleared here):\r\n```\r\n  case CURLOPT_HTTPPOST:\r\n    /*\r\n     * Set to make us do HTTP POST. Legacy API-style.\r\n     */\r\n    data->set.httppost = va_arg(param, struct curl_httppost *);\r\n    data->set.method = HTTPREQ_POST_FORM;\r\n    data->set.opt_no_body = FALSE; /* this is implied */\r\n    Curl_mime_cleanpart(data->state.formp);\r\n    Curl_safefree(data->state.formp);\r\n    break;\r\n```\r\n\r\n\r\n3. During `MSTATE_PROTOCONNECT`, the `data->state.rewindbeforesend` flag check passes, so rewind is attempted.  It's not clear to me if this flag being set is carry over from the previous failed POST attempt or was set during a previous `MSTATE` (e.g., `MSTATE_CONNECT`):\r\n```\r\n    case MSTATE_PROTOCONNECT:\r\n      if(data->state.rewindbeforesend)\r\n        result = readrewind(data);  <-- We attempt readrewind call here.\r\n```\r\n\r\n\r\n4. `readrewind` is initially primed to use `&data->set.mimepost`, but has a conditional check that gets met to use `data->state.mimepost` instead:\r\n```\r\nstatic CURLcode readrewind(struct Curl_easy *data)\r\n{\r\n  curl_mimepart *mimepart = &data->set.mimepost;\r\n  ...\r\n    if(data->conn->handler->protocol & PROTO_FAMILY_HTTP) {\r\n    if(data->state.mimepost)\r\n      mimepart = data->state.mimepost; // <--- use UrlState mimepost now\r\n  }\r\n  ...\r\n    if(data->set.postfields ||\r\n     (data->state.httpreq == HTTPREQ_GET) ||\r\n     (data->state.httpreq == HTTPREQ_HEAD))\r\n    ; /* no need to rewind */\r\n  else if(data->state.httpreq == HTTPREQ_POST_MIME ||\r\n          data->state.httpreq == HTTPREQ_POST_FORM) {\r\n    CURLcode result = Curl_mime_rewind(mimepart); <-- Crash in here\r\n    if(result) {\r\n      failf(data, \"Cannot rewind mime/post data\");\r\n      return result;\r\n    }\r\n  }\r\n```\r\n\r\n\r\n5. `mime_part_rewind` uses the (presumably dangling) pointer, which at this point is being reused by something else, the various checks (including for non-null `seekfunc`) happen to pass as the memory the dangling pointer references is being modified:\r\n```\r\nstatic int mime_part_rewind(curl_mimepart *part)\r\n{\r\n  int res = CURL_SEEKFUNC_OK;\r\n  enum mimestate targetstate = MIMESTATE_BEGIN;\r\n\r\n  if(part->flags & MIME_BODY_ONLY)\r\n    targetstate = MIMESTATE_BODY;\r\n  cleanup_encoder_state(&part->encstate);\r\n  if(part->state.state > targetstate) {\r\n    res = CURL_SEEKFUNC_CANTSEEK;\r\n    if(part->seekfunc) {\r\n      res = part->seekfunc(part->arg, (curl_off_t) 0, SEEK_SET);  <--- crash here when attempting to call part->seekfunc\r\n...\r\n}\r\n```\n\n### I expected the following\n\nNo crash.\r\n\r\nPerhaps `data->state.mimepost` should be cleared when handling `CURLOPT_HTTPPOST` where `data->state.formp` is freed/cleared, like so?\r\n```\r\n  case CURLOPT_HTTPPOST:\r\n    /*\r\n     * Set to make us do HTTP POST. Legacy API-style.\r\n     */\r\n    data->set.httppost = va_arg(param, struct curl_httppost *);\r\n    data->set.method = HTTPREQ_POST_FORM;\r\n    data->set.opt_no_body = FALSE; /* this is implied */\r\n    if (data->state.mimepart == data->state.formp) // ?? Is check needed or always clear ??\r\n    {\r\n          data->state.mimepart = NULL;\r\n    }\r\n    Curl_mime_cleanpart(data->state.formp);\r\n    Curl_safefree(data->state.formp);\r\n    break;\r\n```\n\n### curl/libcurl version\n\ncurl 8.4.0\n\n### operating system\n\nWindows 10 x64, 21H2","closed_by":{"login":"bagder","id":177011,"node_id":"MDQ6VXNlcjE3NzAxMQ==","avatar_url":"https://avatars.githubusercontent.com/u/177011?v=4","gravatar_id":"","url":"https://api.github.com/users/bagder","html_url":"https://github.com/bagder","followers_url":"https://api.github.com/users/bagder/followers","following_url":"https://api.github.com/users/bagder/following{/other_user}","gists_url":"https://api.github.com/users/bagder/gists{/gist_id}","starred_url":"https://api.github.com/users/bagder/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bagder/subscriptions","organizations_url":"https://api.github.com/users/bagder/orgs","repos_url":"https://api.github.com/users/bagder/repos","events_url":"https://api.github.com/users/bagder/events{/privacy}","received_events_url":"https://api.github.com/users/bagder/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/12608/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/12608/timeline","performed_via_github_app":null,"state_reason":"completed"}