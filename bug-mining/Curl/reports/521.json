{"url":"https://api.github.com/repos/curl/curl/issues/14414","repository_url":"https://api.github.com/repos/curl/curl","labels_url":"https://api.github.com/repos/curl/curl/issues/14414/labels{/name}","comments_url":"https://api.github.com/repos/curl/curl/issues/14414/comments","events_url":"https://api.github.com/repos/curl/curl/issues/14414/events","html_url":"https://github.com/curl/curl/issues/14414","id":2450496979,"node_id":"I_kwDOAAiu0c6SD53T","number":14414,"title":"[DOH] Since v8.5.0, a change in API behavior causes curl_multi_poll() or curl_multi_perform() to return error code","user":{"login":"luozhaohui","id":12403610,"node_id":"MDQ6VXNlcjEyNDAzNjEw","avatar_url":"https://avatars.githubusercontent.com/u/12403610?v=4","gravatar_id":"","url":"https://api.github.com/users/luozhaohui","html_url":"https://github.com/luozhaohui","followers_url":"https://api.github.com/users/luozhaohui/followers","following_url":"https://api.github.com/users/luozhaohui/following{/other_user}","gists_url":"https://api.github.com/users/luozhaohui/gists{/gist_id}","starred_url":"https://api.github.com/users/luozhaohui/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/luozhaohui/subscriptions","organizations_url":"https://api.github.com/users/luozhaohui/orgs","repos_url":"https://api.github.com/users/luozhaohui/repos","events_url":"https://api.github.com/users/luozhaohui/events{/privacy}","received_events_url":"https://api.github.com/users/luozhaohui/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":975635480,"node_id":"MDU6TGFiZWw5NzU2MzU0ODA=","url":"https://api.github.com/repos/curl/curl/labels/name%20lookup","name":"name lookup","color":"0052cc","default":false,"description":"DNS and related tech"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2024-08-06T10:13:13Z","updated_at":"2024-08-13T09:01:13Z","closed_at":"2024-08-13T09:01:13Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### I did this\r\n\r\n**Note**\r\nI'm not entirely sure if this is a bug or an improvement. However, since curl_multi_poll() returns error code 12: Unrecoverable error in select/poll work thread exiting, I can't determine if cURL's internal state is valid and if it should continue working. Therefore, I'm reporting this as an issue for now. \r\n\r\nIf this isn't a bug, could you please advise on how to proceed when curl_multi_poll() returns error code 12? Thank you very much.\r\n\r\n**Test Program**\r\n\r\n```cpp\r\n#include <cstdio>\r\n#include <exception>\r\n#include <iostream>\r\n#include <iterator>\r\n#include <memory>\r\n#include <ostream>\r\n#include <sstream>\r\n#include <mutex>\r\n#include <future>\r\n#include <functional>\r\n#include <thread>\r\n#include <atomic>\r\n#include <chrono>\r\n#include <string>\r\n#include <utility>\r\n#include <list>\r\n#include <vector>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <curl/curl.h>\r\n\r\nstatic bool globalInitCalled = false;\r\n\r\nvoid doInit()\r\n{\r\n    static bool initialized = ([] {\r\n        curl_global_init(CURL_GLOBAL_ALL);\r\n        globalInitCalled = true;\r\n        return true;\r\n    })();\r\n\r\n    // silence unused warning\r\n    (void)initialized;\r\n}\r\n\r\nenum Method\r\n{\r\n    HEAD,\r\n    GET,\r\n    POST,\r\n    PUT,\r\n};\r\n\r\nclass Session\r\n{\r\npublic:\r\n    enum State\r\n    {\r\n        NEW,\r\n        PERFORMING,\r\n        ABORTED,\r\n        HTTP_OK,\r\n        HTTP_ERR,\r\n        OTHER_ERR\r\n    };\r\n\r\n    Session(Method method, const std::string& url, const std::string& dnsServer, std::shared_ptr<std::atomic_bool> flag)\r\n        : state_(NEW)\r\n        , statusStr_(\"new\")\r\n        , origUrl_(url)\r\n    {\r\n        doInit();\r\n        curl_ = curl_easy_init();\r\n\r\n        // Set URL\r\n        setopt(CURLOPT_URL, url.c_str());\r\n\r\n        // Set method\r\n        switch (method)\r\n        {\r\n            case HEAD:\r\n                setopt(CURLOPT_NOBODY, 1L);\r\n                break;\r\n            case GET:\r\n                setopt(CURLOPT_HTTPGET, 1L);\r\n                break;\r\n            case POST:\r\n                setopt(CURLOPT_POST, 1L);\r\n                break;\r\n            case PUT:\r\n                setopt(CURLOPT_CUSTOMREQUEST, \"PUT\");\r\n                setopt(CURLOPT_UPLOAD, 1L);\r\n                break;\r\n        }\r\n\r\n        // encoding\r\n        setopt(CURLOPT_ACCEPT_ENCODING, \"\");\r\n        setopt(CURLOPT_SSL_VERIFYPEER, 0L);\r\n\r\n        if (flag)\r\n        {\r\n            setAbortFlag(flag);\r\n        }\r\n\r\n        if (!dnsServer.empty())\r\n        {\r\n            enableDoH(dnsServer);\r\n        }\r\n    }\r\n\r\n    ~Session()\r\n    {\r\n        if (curl_ != nullptr)\r\n        {\r\n            curl_easy_cleanup(curl_);\r\n            curl_ = nullptr;\r\n        }\r\n    }\r\n\r\n    void setAbortFlag(std::shared_ptr<std::atomic_bool> f)\r\n    {\r\n        assert(state_ == NEW);\r\n        isAborted_ = [f]()\r\n        {\r\n            bool ret = f->load();\r\n            if (ret)\r\n            {\r\n                std::cout << \"> abort flag set.\" << std::endl;\r\n            }\r\n\r\n            return f->load();\r\n        };\r\n    }\r\n\r\n    void enableDoH(const std::string& v)\r\n    {\r\n        assert(state_ == NEW);\r\n\r\n        std::cout << \"enableDoH: \" << v << std::endl;\r\n        setopt(CURLOPT_DOH_URL, v.c_str());\r\n        setopt(CURLOPT_DOH_SSL_VERIFYPEER, 0);\r\n        setopt(CURLOPT_DOH_SSL_VERIFYHOST, 0);\r\n    }\r\n\r\n    bool checkAborted()\r\n    {\r\n        return isAborted_();\r\n    }\r\n\r\n    void start()\r\n    {\r\n        assert(state_ == NEW);\r\n        setopt(CURLOPT_PRIVATE, this);\r\n        state_ = PERFORMING;\r\n        statusStr_ = \"performing\";\r\n    }\r\n\r\n    void abort()\r\n    {\r\n        assert(state_ == PERFORMING);\r\n        state_ = ABORTED;\r\n        statusStr_ = \"aborted\";\r\n    }\r\n\r\n    State getState() const\r\n    {\r\n        return state_;\r\n    }\r\n\r\n    bool inProgress() const\r\n    {\r\n        return state_ == PERFORMING;\r\n    }\r\n\r\n    bool failed() const\r\n    {\r\n        return state_ != NEW &&\r\n               state_ != PERFORMING &&\r\n               state_ != HTTP_OK;\r\n    }\r\n\r\n    const std::string& getStatusStr() const\r\n    {\r\n        return statusStr_;\r\n    }\r\n\r\n    const std::string& url() const\r\n    {\r\n        return origUrl_;\r\n    }\r\n\r\n    CURL* handle() const\r\n    {\r\n        return curl_;\r\n    }\r\n\r\n    void finish(CURLcode res)\r\n    {\r\n        if (res == CURLE_OK)\r\n        {\r\n            state_ = HTTP_OK;\r\n            statusStr_ = \"OK\";\r\n        }\r\n        else\r\n        {\r\n            state_ = OTHER_ERR;\r\n            statusStr_ = \"error\";\r\n        }\r\n    }\r\n\r\nprivate:\r\n    template <typename T>\r\n    void setopt(CURLoption opt, T&& v) const\r\n    {\r\n        curl_easy_setopt(curl_, opt, v);\r\n    }\r\n\r\nprivate:\r\n    State state_;\r\n    std::string statusStr_;\r\n    std::string origUrl_;\r\n    CURL* curl_ = nullptr;\r\n\r\n    std::function<bool()> isAborted_ = []() {\r\n        return false;\r\n    };\r\n};\r\n\r\nclass RequestError: public std::exception\r\n{\r\npublic:\r\n    RequestError(std::unique_ptr<Session> session)\r\n        : session_(std::make_shared<std::unique_ptr<Session>>(std::move(session)))\r\n    {\r\n    }\r\n    const char* what() const noexcept override\r\n    {\r\n        return response().getStatusStr().c_str();\r\n    }\r\n\r\n    const Session& response() const\r\n    {\r\n        return **session_;\r\n    }\r\n\r\nprivate:\r\n    std::shared_ptr<std::unique_ptr<Session>> session_;\r\n};\r\n\r\ninline std::ostream& operator<<(std::ostream& out, const RequestError& err)\r\n{\r\n    return out << err.what();\r\n}\r\n\r\nusing Continuation = std::function<void(std::future<std::unique_ptr<Session>>)>;\r\n\r\nclass Pool {\r\npublic:\r\n    Pool()\r\n    {\r\n        doInit();\r\n        curlm_ = curl_multi_init();\r\n    }\r\n\r\n    ~Pool()\r\n    {\r\n        std::cout << \"Pool destruction.\" << std::endl;\r\n        if (curlm_ != nullptr)\r\n        {\r\n            curl_multi_cleanup(curlm_);\r\n            curlm_ = nullptr;\r\n        }\r\n    }\r\n\r\n    std::unique_ptr<Session> create(Method method, const std::string& url, const std::string& dnsServer, std::shared_ptr<std::atomic_bool> flag)\r\n    {\r\n        return std::make_unique<Session>(method, url, dnsServer, flag);\r\n    }\r\n\r\n    void add(Session& s)\r\n    {\r\n        s.start();\r\n        check(curl_multi_add_handle(curlm_, s.handle()), \"curl_multi_add_handle\");\r\n    }\r\n\r\n    void remove(Session& s)\r\n    {\r\n        check(curl_multi_remove_handle(curlm_, s.handle()), \"curl_multi_remove_handle\");\r\n    }\r\n\r\n    void abortIfInProgress(Session& s)\r\n    {\r\n        if (s.getState() == Session::PERFORMING)\r\n        {\r\n            std::cout << \">> abort session\" << std::endl;\r\n            remove(s);\r\n            s.abort();\r\n        }\r\n    }\r\n\r\n    bool wait(int timeoutMs = 20)\r\n    {\r\n        auto ec = curl_multi_poll(curlm_, NULL, 0, timeoutMs, NULL);\r\n        check(ec, \"curl_multi_poll\");\r\n        return ec == CURLM_OK;\r\n    }\r\n\r\n    void wakeup()\r\n    {\r\n        check(curl_multi_wakeup(curlm_), \"curl_multi_wakeup\");\r\n    }\r\n\r\n    void check(CURLMcode ec, const char* msg)\r\n    {\r\n        if (ec != CURLM_OK)\r\n        {\r\n            std::stringstream err;\r\n            err << \"[curl error \" << ec << \"], \" << msg << \": \" << curl_multi_strerror(ec);\r\n            std::cout << err.str();\r\n        }\r\n    }\r\n\r\n    int step()\r\n    {\r\n        int active = 0;\r\n        CURLMcode mc = curl_multi_perform(curlm_, &active);\r\n        if (!mc)\r\n        {\r\n            CURLMsg* msg = 0;\r\n\r\n            do {\r\n                int nmsg = 0;\r\n                msg = curl_multi_info_read(curlm_, &nmsg);\r\n                if (msg && (msg->msg == CURLMSG_DONE))\r\n                {\r\n                    Session* session = nullptr;\r\n                    curl_easy_getinfo(msg->easy_handle, CURLINFO_PRIVATE, &session);\r\n                    assert(session);\r\n                    session->finish(msg->data.result);\r\n                    remove(*session);\r\n                }\r\n\r\n                std::cout << \"-- active: \" << active << \", number of message: \" << nmsg << std::endl;\r\n            }\r\n            while(msg);\r\n        }\r\n        else\r\n        {\r\n            check(mc, \"curl_multi_perform\");\r\n        }\r\n\r\n        return active;\r\n    }\r\nprivate:\r\n    CURLM* curlm_ = nullptr;\r\n};\r\n\r\n// Client Inteface\r\nclass IClient\r\n{\r\npublic:\r\n    virtual ~IClient() = default;\r\n\r\n    virtual std::unique_ptr<Session> get(const std::string& url, const std::string& dnsServer, std::shared_ptr<std::atomic_bool> flag) = 0;\r\n};\r\n\r\nclass AsyncClient: public IClient\r\n{\r\npublic:\r\n    AsyncClient()\r\n    {\r\n        // create thread\r\n        thread_ = std::thread{[&]()\r\n        {\r\n            try\r\n            {\r\n                std::unique_lock<std::mutex> lock(mutex_);\r\n\r\n                while (true)\r\n                {\r\n                    // Add incoming requests\r\n                    for (auto& p : incoming_)\r\n                    {\r\n                        pool_.add(*std::get<0>(p));\r\n                        processing_.push_back(std::move(p));\r\n                    }\r\n                    incoming_.clear();\r\n\r\n                    // Check for aborted sessions\r\n                    int numOfInprogressRequests = 0;\r\n                    for (auto& p : processing_)\r\n                    {\r\n                        std::unique_ptr<Session>& session = std::get<0>(p);\r\n                        if (aborted_ || session->checkAborted())\r\n                        {\r\n                            pool_.abortIfInProgress(*session);  // this will remove the handle and set abort state\r\n                        }\r\n                        else\r\n                        {\r\n                            ++numOfInprogressRequests;\r\n                        }\r\n                    }\r\n\r\n                    // Do I/O\r\n                    int active = 0;\r\n                    if (numOfInprogressRequests > 0)\r\n                    {\r\n                        active = pool_.step();\r\n                    }\r\n\r\n                    // Handle completed requests\r\n                    for (auto& p : processing_)\r\n                    {\r\n                        std::unique_ptr<Session>& session = std::get<0>(p);\r\n                        Continuation& then = std::get<1>(p);\r\n\r\n                        if (active < 1)\r\n                        {\r\n                            // abort in progress sessions that are not completed if curl is not active anymore.\r\n                            pool_.abortIfInProgress(*session);\r\n                        }\r\n\r\n                        if (!session->inProgress())\r\n                        {\r\n                            std::promise<std::unique_ptr<Session>> prom;\r\n                            if (!session->failed())\r\n                            {\r\n                                prom.set_value(std::move(session));\r\n                            }\r\n                            else\r\n                            {\r\n                                std::cout << \" aborted: \" << session->url() << \". status: \" << session->getStatusStr() << std::endl;\r\n                                prom.set_exception(std::make_exception_ptr(RequestError{std::move(session)}));\r\n                            }\r\n\r\n                            // trigger callback\r\n                            then(prom.get_future());\r\n                        }\r\n                    }\r\n\r\n                    // Remove handled requests(the session has been moved!)\r\n                    processing_.remove_if([](auto& p)\r\n                    {\r\n                        return !std::get<0>(p);\r\n                    });\r\n\r\n                    // It's possible to have extra active requests due to DNS over HTTPS activity\r\n                    assert(processing_.size() <= active);\r\n\r\n                    // Exit thread if we're shutting down and all requests are handled\r\n                    if (shutdown_ && active < 1)\r\n                    {\r\n                        assert(processing_.empty());\r\n                        lock.unlock();\r\n                        return;\r\n                    }\r\n\r\n                    lock.unlock();\r\n                    if (pool_.wait())\r\n                    {\r\n                        lock.lock();\r\n                    }\r\n                    else\r\n                    {\r\n                        std::cout << \"work thread failed to poll.\" << std::endl;\r\n                        // break;\r\n                        lock.lock();\r\n                    }\r\n                }\r\n\r\n                std::cout << \"work thread exiting ...\" << std::endl;\r\n            }\r\n            catch (const std::exception& err)\r\n            {\r\n                std::cerr << \"Uncaught exception in async client's work thread: \" <<\r\n                          err.what() << std::endl;\r\n                std::terminate();\r\n            }\r\n        }};\r\n    }\r\n\r\n    ~AsyncClient() override\r\n    {\r\n        std::cout << \"AsyncClient destruction.\" << std::endl;\r\n        shutdown();\r\n    }\r\n\r\n    std::unique_ptr<Session> get(const std::string& url, const std::string& dnsServer, std::shared_ptr<std::atomic_bool> flag) override\r\n    {\r\n        auto prom = std::make_shared<std::promise<std::unique_ptr<Session>>>();\r\n        auto then = [prom](std::future<std::unique_ptr<Session>> res) {\r\n            try\r\n            {\r\n                prom->set_value(res.get());\r\n            }\r\n            catch (...)\r\n            {\r\n                prom->set_exception(std::current_exception());\r\n            }\r\n        };\r\n\r\n        getAsync(url, dnsServer, flag, then);\r\n        return prom->get_future().get();\r\n    }\r\n\r\n    void getAsync(const std::string& url, const std::string& dnsServer, std::shared_ptr<std::atomic_bool> flag, Continuation then)\r\n    {\r\n\r\n        std::unique_lock<std::mutex> lock(mutex_);\r\n        if (shutdown_)\r\n        {\r\n            std::promise<std::unique_ptr<Session>> prom;\r\n            prom.set_exception(std::make_exception_ptr(\r\n                               std::runtime_error(\"can't perform request on a shut down client\")));\r\n            then(prom.get_future());\r\n            return;\r\n        }\r\n\r\n        try\r\n        {\r\n            incoming_.emplace_back(pool_.create(Method::GET, url, dnsServer, flag), then);\r\n        }\r\n        catch (const std::exception& e)\r\n        {\r\n            std::promise<std::unique_ptr<Session>> prom;\r\n            prom.set_exception(std::make_exception_ptr(\r\n                std::runtime_error(std::string(\"Can't perform request due to error: \") + e.what())));\r\n            then(prom.get_future());\r\n        }\r\n    }\r\n\r\n    void shutdown()\r\n    {\r\n        std::unique_lock<std::mutex> lock(mutex_);\r\n        if (!shutdown_)\r\n        {\r\n            // set flags\r\n            shutdown_ = true;\r\n            aborted_ = true;\r\n\r\n            pool_.wakeup();\r\n            lock.unlock();\r\n\r\n            thread_.join();\r\n        }\r\n    }\r\n\r\nprivate:\r\n\r\n    using SessionContinuationPair = std::tuple<std::unique_ptr<Session>, Continuation>;\r\n\r\n    std::mutex mutex_;\r\n\r\n    std::list<SessionContinuationPair> incoming_;\r\n    std::list<SessionContinuationPair> processing_;\r\n    bool shutdown_ = false;\r\n    bool aborted_ = false;\r\n\r\n    std::thread thread_;\r\n    Pool pool_;\r\n};\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    std::cout << \"=== curl test ===\" << std::endl;\r\n\r\n    auto url = \"https://httpbin.org/delay/5\";\r\n    auto dnsServer = \"https://1.1.1.1/dns-query\";\r\n\r\n    auto test_abort_func = [=](IClient& cli, const std::string& dnsServer, int abortAfterMs) {\r\n        auto abortFlag = std::make_shared<std::atomic_bool>(false);\r\n        auto th = std::thread{[&]()\r\n        {\r\n            std::this_thread::sleep_for(std::chrono::milliseconds(abortAfterMs));\r\n            abortFlag->store(true);\r\n        }};\r\n\r\n        std::cout << \"\\n>> start a request that will be aborted.\" << std::endl;\r\n        try\r\n        {\r\n            auto session = cli.get(url, dnsServer, abortFlag);\r\n            std::cout << \">> abort test \" << abortAfterMs << \" ms: \" << session->getStatusStr() << std::endl;\r\n        }\r\n        catch(RequestError& error)\r\n        {\r\n            std::cout << \">> abort test \" << error.response().url() << \". status: \" << error.response().getStatusStr() << std::endl;\r\n        }\r\n\r\n        std::cout << \"\\n>> start another request.\" << std::endl;\r\n        auto flag = std::make_shared<std::atomic_bool>(false);\r\n        cli.get(url, \"\", flag);\r\n        th.join();\r\n    };\r\n\r\n    // test async client with DOH\r\n    std::unique_ptr<IClient> client(new AsyncClient());\r\n    test_abort_func(*client, dnsServer, 500);\r\n\r\n    return 0;\r\n}\r\n\r\n```\r\n\r\n\r\n### I expected the following\r\n\r\nBelow are test reports using different versions of curl.\r\n\r\n## v8.3.0 & v8.4.0(EXPECTED)\r\n* curl version:\r\n```bash\r\ncurl 8.4.0 (x86_64-apple-darwin23.3.0) libcurl/8.4.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2023-10-11\r\nProtocols: dict file ftp ftps http https\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets\r\n```\r\n* test result:\r\nThis is the `expected` test result.\r\n```bash\r\n-- active: 3, number of message: 0\r\n-- active: 3, number of message: 0\r\n-- active: 3, number of message: 0\r\n> abort flag set.\r\n>> abort session\r\n aborted: https://httpbin.org/delay/5. status: aborted\r\n>> abort test https://httpbin.org/delay/5. status: aborted\r\n\r\n>> start another request.\r\n-- active: 1, number of message: 0\r\n-- active: 1, number of message: 0\r\n-- active: 1, number of message: 0\r\n-- active: 1, number of message: 0\r\n...\r\n-- active: 1, number of message: 0\r\n{\r\n  \"args\": {}, \r\n  \"data\": \"\", \r\n  \"files\": {}, \r\n  \"form\": {}, \r\n  \"headers\": {\r\n    \"Accept\": \"*/*\", \r\n    \"Accept-Encoding\": \"deflate, gzip\", \r\n    \"Host\": \"httpbin.org\", \r\n    \"X-Amzn-Trace-Id\": \"Root=1-66b1f303-73a84f6232fbd1f84c3bfe66\"\r\n  }, \r\n  \"origin\": \"12.32.72.250\", \r\n  \"url\": \"https://httpbin.org/delay/5\"\r\n}\r\n-- active: 0, number of message: 0\r\n-- active: 0, number of message: 0\r\nAsyncClient destruction.\r\nPool destruction.\r\n```\r\n\r\n## v8.5.0 & v8.6.0 &v8.7.1(NOT EXPECTED)\r\n* curl version:\r\n```bash\r\ncurl 8.6.0 (x86_64-apple-darwin23.3.0) libcurl/8.6.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2024-01-31\r\nProtocols: dict file ftp ftps http https ipfs ipns\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets\r\n```\r\n* test result:\r\nThis is `NOT` the expected test result.\r\n```bash\r\n-- active: 3, number of message: 0\r\n-- active: 3, number of message: 0\r\n> abort flag set.\r\n>> abort session\r\n aborted: https://httpbin.org/delay/5. status: aborted\r\n>> abort test https://httpbin.org/delay/5. status: aborted\r\n\r\n>> start another request.\r\n[curl error 2], curl_multi_perform: Invalid easy handle\r\n[curl error 2], curl_multi_perform: Invalid easy handle\r\n[curl error 2], curl_multi_perform: Invalid easy handle\r\n...\r\nContinuously outputs [curl error 2], curl_multi_perform: Invalid easy handle.\r\n````\r\n\r\n## v8.8.0 & v8.9.1(NOT EXPECTED)\r\n* curl version:\r\n```bash\r\ncurl 8.8.0 (x86_64-apple-darwin23.3.0) libcurl/8.8.0 SecureTransport zlib/1.3.1 c-ares/1.19.0\r\nRelease-Date: 2024-05-22\r\nProtocols: dict file ftp ftps http https ipfs ipns\r\nFeatures: AsynchDNS HSTS HTTPS-proxy IPv6 Largefile libz NTLM SSL threadsafe UnixSockets\r\n```\r\n* test result:\r\nThis is `NOT` the expected test result.\r\n```bash\r\n-- active: 3, number of message: 0\r\n-- active: 3, number of message: 0\r\n> abort flag set.\r\n>> abort session\r\n aborted: https://httpbin.org/delay/5. status: aborted\r\n>> abort test https://httpbin.org/delay/5. status: aborted\r\n[curl error 12], curl_multi_poll: Unrecoverable error in select/pollwork thread failed to poll.\r\n[curl error 12], curl_multi_poll: Unrecoverable error in select/pollwork thread failed to poll.\r\n\r\n>> start another request.\r\n-- active: 1, number of message: 0\r\n-- active: 1, number of message: 0\r\n-- active: 1, number of message: 0\r\n...\r\n-- active: 1, number of message: 0\r\n{\r\n  \"args\": {}, \r\n  \"data\": \"\", \r\n  \"files\": {}, \r\n  \"form\": {}, \r\n  \"headers\": {\r\n    \"Accept\": \"*/*\", \r\n    \"Accept-Encoding\": \"deflate, gzip\", \r\n    \"Host\": \"httpbin.org\", \r\n    \"X-Amzn-Trace-Id\": \"Root=1-66b1f5ea-1e6a192e7bcb152b72084718\"\r\n  }, \r\n  \"origin\": \"12.32.72.250\", \r\n  \"url\": \"https://httpbin.org/delay/5\"\r\n}\r\n-- active: 0, number of message: 0\r\n-- active: 0, number of message: 0\r\nAsyncClient destruction.\r\nPool destruction.\r\n```\r\n\r\n\r\n### curl/libcurl version\r\n\r\n- v8.3.0, v8.4.0: Good.\r\n- v8.5.0, v8.6.0, v8.7.1: Bad, return [curl error 2], curl_multi_perform: Invalid easy handle.\r\n- v8.8.0, v8.9.1: Bad,  return [curl error 12], curl_multi_poll: Unrecoverable error in select/pollwork thread failed to poll.\r\n\r\n### operating system\r\n\r\nDarwin Kernel Version 23.3.0: Wed Dec 20 21:28:58 PST 2023; root:xnu-10002.81.5~7/RELEASE_X86_64 x86_64","closed_by":{"login":"luozhaohui","id":12403610,"node_id":"MDQ6VXNlcjEyNDAzNjEw","avatar_url":"https://avatars.githubusercontent.com/u/12403610?v=4","gravatar_id":"","url":"https://api.github.com/users/luozhaohui","html_url":"https://github.com/luozhaohui","followers_url":"https://api.github.com/users/luozhaohui/followers","following_url":"https://api.github.com/users/luozhaohui/following{/other_user}","gists_url":"https://api.github.com/users/luozhaohui/gists{/gist_id}","starred_url":"https://api.github.com/users/luozhaohui/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/luozhaohui/subscriptions","organizations_url":"https://api.github.com/users/luozhaohui/orgs","repos_url":"https://api.github.com/users/luozhaohui/repos","events_url":"https://api.github.com/users/luozhaohui/events{/privacy}","received_events_url":"https://api.github.com/users/luozhaohui/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/curl/curl/issues/14414/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/curl/curl/issues/14414/timeline","performed_via_github_app":null,"state_reason":"completed"}