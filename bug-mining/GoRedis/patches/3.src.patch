diff --git a/v2/command.go b/v2/command.go
index aad58ed..ffdd1a3 100644
--- a/v2/command.go
+++ b/v2/command.go
@@ -399,6 +399,10 @@ func (cmd *StringSliceCmd) Val() []string {
 	return cmd.val
 }
 
+func (cmd *StringSliceCmd) Result() ([]string, error) {
+	return cmd.Val(), cmd.Err()
+}
+
 func (cmd *StringSliceCmd) String() string {
 	return cmdString(cmd, cmd.val)
 }
diff --git a/v2/commands.go b/v2/commands.go
index 62ab8bb..c94adc1 100644
--- a/v2/commands.go
+++ b/v2/commands.go
@@ -877,17 +877,17 @@ type ZRangeByScore struct {
 	Offset, Count int64
 }
 
-func (c *Client) zRangeByScore(key string, opts ZRangeByScore, withScores bool) *StringSliceCmd {
-	args := []string{"ZRANGEBYSCORE", key, opts.Min, opts.Max}
+func (c *Client) zRangeByScore(key string, opt ZRangeByScore, withScores bool) *StringSliceCmd {
+	args := []string{"ZRANGEBYSCORE", key, opt.Min, opt.Max}
 	if withScores {
 		args = append(args, "WITHSCORES")
 	}
-	if opts.Offset != 0 || opts.Count != 0 {
+	if opt.Offset != 0 || opt.Count != 0 {
 		args = append(
 			args,
 			"LIMIT",
-			strconv.FormatInt(opts.Offset, 10),
-			strconv.FormatInt(opts.Count, 10),
+			strconv.FormatInt(opt.Offset, 10),
+			strconv.FormatInt(opt.Count, 10),
 		)
 	}
 	req := NewStringSliceCmd(args...)
@@ -895,22 +895,22 @@ func (c *Client) zRangeByScore(key string, opts ZRangeByScore, withScores bool)
 	return req
 }
 
-func (c *Client) ZRangeByScore(key string, opts ZRangeByScore) *StringSliceCmd {
-	return c.zRangeByScore(key, opts, false)
+func (c *Client) ZRangeByScore(key string, opt ZRangeByScore) *StringSliceCmd {
+	return c.zRangeByScore(key, opt, false)
 }
 
-func (c *Client) ZRangeByScoreWithScores(key string, opts ZRangeByScore) *StringSliceCmd {
-	return c.zRangeByScore(key, opts, true)
+func (c *Client) ZRangeByScoreWithScores(key string, opt ZRangeByScore) *StringSliceCmd {
+	return c.zRangeByScore(key, opt, true)
 }
 
-func (c *Client) ZRangeByScoreWithScoresMap(key string, opts ZRangeByScore) *StringFloatMapCmd {
-	args := []string{"ZRANGEBYSCORE", key, opts.Min, opts.Max, "WITHSCORES"}
-	if opts.Offset != 0 || opts.Count != 0 {
+func (c *Client) ZRangeByScoreWithScoresMap(key string, opt ZRangeByScore) *StringFloatMapCmd {
+	args := []string{"ZRANGEBYSCORE", key, opt.Min, opt.Max, "WITHSCORES"}
+	if opt.Offset != 0 || opt.Count != 0 {
 		args = append(
 			args,
 			"LIMIT",
-			strconv.FormatInt(opts.Offset, 10),
-			strconv.FormatInt(opts.Count, 10),
+			strconv.FormatInt(opt.Offset, 10),
+			strconv.FormatInt(opt.Count, 10),
 		)
 	}
 	req := NewStringFloatMapCmd(args...)
@@ -973,17 +973,17 @@ func (c *Client) ZRevRangeWithScoresMap(key, start, stop string) *StringFloatMap
 	return req
 }
 
-func (c *Client) zRevRangeByScore(key, start, stop string, withScores bool, offset, count int64) *StringSliceCmd {
-	args := []string{"ZREVRANGEBYSCORE", key, start, stop}
+func (c *Client) zRevRangeByScore(key string, opt ZRangeByScore, withScores bool) *StringSliceCmd {
+	args := []string{"ZREVRANGEBYSCORE", key, opt.Max, opt.Min}
 	if withScores {
 		args = append(args, "WITHSCORES")
 	}
-	if offset != 0 || count != 0 {
+	if opt.Offset != 0 || opt.Count != 0 {
 		args = append(
 			args,
 			"LIMIT",
-			strconv.FormatInt(offset, 10),
-			strconv.FormatInt(count, 10),
+			strconv.FormatInt(opt.Offset, 10),
+			strconv.FormatInt(opt.Count, 10),
 		)
 	}
 	req := NewStringSliceCmd(args...)
@@ -991,23 +991,22 @@ func (c *Client) zRevRangeByScore(key, start, stop string, withScores bool, offs
 	return req
 }
 
-func (c *Client) ZRevRangeByScore(key, start, stop string, offset, count int64) *StringSliceCmd {
-	return c.zRevRangeByScore(key, start, stop, false, offset, count)
+func (c *Client) ZRevRangeByScore(key string, opt ZRangeByScore) *StringSliceCmd {
+	return c.zRevRangeByScore(key, opt, false)
 }
 
-func (c *Client) ZRevRangeByScoreWithScores(key, start, stop string, offset, count int64) *StringSliceCmd {
-	return c.zRevRangeByScore(key, start, stop, false, offset, count)
+func (c *Client) ZRevRangeByScoreWithScores(key string, opt ZRangeByScore) *StringSliceCmd {
+	return c.zRevRangeByScore(key, opt, true)
 }
 
-func (c *Client) ZRevRangeByScoreWithScoresMap(
-	key, start, stop string, offset, count int64) *StringFloatMapCmd {
-	args := []string{"ZREVRANGEBYSCORE", key, start, stop, "WITHSCORES"}
-	if offset != 0 || count != 0 {
+func (c *Client) ZRevRangeByScoreWithScoresMap(key string, opt ZRangeByScore) *StringFloatMapCmd {
+	args := []string{"ZREVRANGEBYSCORE", key, opt.Max, opt.Min, "WITHSCORES"}
+	if opt.Offset != 0 || opt.Count != 0 {
 		args = append(
 			args,
 			"LIMIT",
-			strconv.FormatInt(offset, 10),
-			strconv.FormatInt(count, 10),
+			strconv.FormatInt(opt.Offset, 10),
+			strconv.FormatInt(opt.Count, 10),
 		)
 	}
 	req := NewStringFloatMapCmd(args...)
diff --git a/v2/redis_test.go b/v2/redis_test.go
index 1892a43..d80b387 100644
--- a/v2/redis_test.go
+++ b/v2/redis_test.go
@@ -2275,24 +2275,41 @@ func (t *RedisTest) TestZRevRangeWithScoresMap(c *C) {
 }
 
 func (t *RedisTest) TestZRevRangeByScore(c *C) {
-	zAdd := t.client.ZAdd("zset", redis.Z{1, "one"})
-	c.Assert(zAdd.Err(), IsNil)
-	zAdd = t.client.ZAdd("zset", redis.Z{2, "two"})
-	c.Assert(zAdd.Err(), IsNil)
-	zAdd = t.client.ZAdd("zset", redis.Z{3, "three"})
-	c.Assert(zAdd.Err(), IsNil)
+	zadd := t.client.ZAdd("zset", redis.Z{1, "one"})
+	c.Assert(zadd.Err(), IsNil)
+	zadd = t.client.ZAdd("zset", redis.Z{2, "two"})
+	c.Assert(zadd.Err(), IsNil)
+	zadd = t.client.ZAdd("zset", redis.Z{3, "three"})
+	c.Assert(zadd.Err(), IsNil)
+
+	vals, err := t.client.ZRevRangeByScore(
+		"zset", redis.ZRangeByScore{Max: "+inf", Min: "-inf"}).Result()
+	c.Assert(err, IsNil)
+	c.Assert(vals, DeepEquals, []string{"three", "two", "one"})
 
-	zRevRangeByScore := t.client.ZRevRangeByScore("zset", "+inf", "-inf", 0, 0)
-	c.Assert(zRevRangeByScore.Err(), IsNil)
-	c.Assert(zRevRangeByScore.Val(), DeepEquals, []string{"three", "two", "one"})
+	vals, err = t.client.ZRevRangeByScore(
+		"zset", redis.ZRangeByScore{Max: "2", Min: "(1"}).Result()
+	c.Assert(err, IsNil)
+	c.Assert(vals, DeepEquals, []string{"two"})
 
-	zRevRangeByScore = t.client.ZRevRangeByScore("zset", "2", "(1", 0, 0)
-	c.Assert(zRevRangeByScore.Err(), IsNil)
-	c.Assert(zRevRangeByScore.Val(), DeepEquals, []string{"two"})
+	vals, err = t.client.ZRevRangeByScore(
+		"zset", redis.ZRangeByScore{Max: "(2", Min: "(1"}).Result()
+	c.Assert(err, IsNil)
+	c.Assert(vals, DeepEquals, []string{})
+}
 
-	zRevRangeByScore = t.client.ZRevRangeByScore("zset", "(2", "(1", 0, 0)
-	c.Assert(zRevRangeByScore.Err(), IsNil)
-	c.Assert(zRevRangeByScore.Val(), DeepEquals, []string{})
+func (t *RedisTest) TestZRevRangeByScoreWithScores(c *C) {
+	zadd := t.client.ZAdd("zset", redis.Z{1, "one"})
+	c.Assert(zadd.Err(), IsNil)
+	zadd = t.client.ZAdd("zset", redis.Z{2, "two"})
+	c.Assert(zadd.Err(), IsNil)
+	zadd = t.client.ZAdd("zset", redis.Z{3, "three"})
+	c.Assert(zadd.Err(), IsNil)
+
+	vals, err := t.client.ZRevRangeByScoreWithScores(
+		"zset", redis.ZRangeByScore{Max: "+inf", Min: "-inf"}).Result()
+	c.Assert(err, IsNil)
+	c.Assert(vals, DeepEquals, []string{"three", "3", "two", "2", "one", "1"})
 }
 
 func (t *RedisTest) TestZRevRangeByScoreWithScoresMap(c *C) {
@@ -2303,15 +2320,18 @@ func (t *RedisTest) TestZRevRangeByScoreWithScoresMap(c *C) {
 	zAdd = t.client.ZAdd("zset", redis.Z{3, "three"})
 	c.Assert(zAdd.Err(), IsNil)
 
-	zRevRangeByScore := t.client.ZRevRangeByScoreWithScoresMap("zset", "+inf", "-inf", 0, 0)
+	zRevRangeByScore := t.client.ZRevRangeByScoreWithScoresMap(
+		"zset", redis.ZRangeByScore{Max: "+inf", Min: "-inf"})
 	c.Assert(zRevRangeByScore.Err(), IsNil)
 	c.Assert(zRevRangeByScore.Val(), DeepEquals, map[string]float64{"three": 3, "two": 2, "one": 1})
 
-	zRevRangeByScore = t.client.ZRevRangeByScoreWithScoresMap("zset", "2", "(1", 0, 0)
+	zRevRangeByScore = t.client.ZRevRangeByScoreWithScoresMap(
+		"zset", redis.ZRangeByScore{Max: "2", Min: "(1"})
 	c.Assert(zRevRangeByScore.Err(), IsNil)
 	c.Assert(zRevRangeByScore.Val(), DeepEquals, map[string]float64{"two": 2})
 
-	zRevRangeByScore = t.client.ZRevRangeByScoreWithScoresMap("zset", "(2", "(1", 0, 0)
+	zRevRangeByScore = t.client.ZRevRangeByScoreWithScoresMap(
+		"zset", redis.ZRangeByScore{Max: "(2", Min: "(1"})
 	c.Assert(zRevRangeByScore.Err(), IsNil)
 	c.Assert(zRevRangeByScore.Val(), DeepEquals, map[string]float64{})
 }
