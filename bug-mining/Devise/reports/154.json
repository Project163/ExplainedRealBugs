{"url":"https://api.github.com/repos/heartcombo/devise/issues/4981","repository_url":"https://api.github.com/repos/heartcombo/devise","labels_url":"https://api.github.com/repos/heartcombo/devise/issues/4981/labels{/name}","comments_url":"https://api.github.com/repos/heartcombo/devise/issues/4981/comments","events_url":"https://api.github.com/repos/heartcombo/devise/issues/4981/events","html_url":"https://github.com/heartcombo/devise/issues/4981","id":384866791,"node_id":"MDU6SXNzdWUzODQ4NjY3OTE=","number":4981,"title":"Small security issue with :lockable","user":{"login":"cfeckardt","id":2144015,"node_id":"MDQ6VXNlcjIxNDQwMTU=","avatar_url":"https://avatars.githubusercontent.com/u/2144015?v=4","gravatar_id":"","url":"https://api.github.com/users/cfeckardt","html_url":"https://github.com/cfeckardt","followers_url":"https://api.github.com/users/cfeckardt/followers","following_url":"https://api.github.com/users/cfeckardt/following{/other_user}","gists_url":"https://api.github.com/users/cfeckardt/gists{/gist_id}","starred_url":"https://api.github.com/users/cfeckardt/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cfeckardt/subscriptions","organizations_url":"https://api.github.com/users/cfeckardt/orgs","repos_url":"https://api.github.com/users/cfeckardt/repos","events_url":"https://api.github.com/users/cfeckardt/events{/privacy}","received_events_url":"https://api.github.com/users/cfeckardt/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":40645,"node_id":"MDU6TGFiZWw0MDY0NQ==","url":"https://api.github.com/repos/heartcombo/devise/labels/Bug","name":"Bug","color":"ededed","default":false,"description":null},{"id":399329322,"node_id":"MDU6TGFiZWwzOTkzMjkzMjI=","url":"https://api.github.com/repos/heartcombo/devise/labels/Needs%20PR","name":"Needs PR","color":"006b75","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":16,"created_at":"2018-11-27T16:02:36Z","updated_at":"2019-03-26T17:38:31Z","closed_at":"2018-12-28T19:00:51Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"## Environment\r\n\r\n- Ruby **any**\r\n- Rails **any** running a multithreaded server (like puma)\r\n- Devise **4.5.0**\r\n\r\n## Current behavior\r\nPentesters found an issue where our users did not lock (using :lockable), despite running many many attempts to brute force the password.\r\nTo reproduce, try to login many times at exactly the same time (where your model is :lockable).\r\n100 attempts within 1 milliseconds of each other will not increment the failed_attempts attribute on your user 100 times on a busy or slow database. They will most likely be incremented by approximately `100 % num_threads` where num_threads is the number of threads your server is configured to.\r\n\r\nThis is a test that describes the behaviour that I would reasonably expect:\r\n\r\n```ruby\r\n describe '#increment_failed_attempts' do\r\n   let(:user) { create :user }\r\n   let(:same_user) { User.find(user.id) }\r\n   it 'increments the count independently across instances' do\r\n     expect {\r\n       same_user.increment_failed_attempts\r\n       same_user.save\r\n       user.increment_failed_attempts\r\n     }.to change { user.reload.failed_attempts }.by(2)\r\n   end\r\n end\r\n```\r\nThis test will fail in devise 4.5.0\r\n\r\n## Expected behavior\r\nThe issue arises because we read and set failed_attempts in two steps, instead of in one database transaction.\r\n\r\nBelow is an excerpt of the method from `lockable.rb`, my comments added:\r\n```ruby\r\ndef increment_failed_attempts\r\n  self.failed_attempts ||= 0 # This line triggers a read in ActiveRecord if not already cached\r\n  # some other thread now increments the counter to 1\r\n  self.failed_attempts += 1 # We have already read the value 0, and will increment that erroneously to 1 again\r\nend\r\n```\r\n\r\nOur workaround we use is something along the lines of:\r\n\r\n```ruby\r\ndef increment_failed_attempts\r\n  self.failed_attempts = self.class.connection.execute(\"UPDATE SET (failed_attempts = failed_attempts + 1) WHERE id = #{self.id} RETURNING failed_attempts\").getvalue(0,0)\r\nend\r\n```\r\n\r\nwhich passes the test above. This solution is postgres specific (and also assumes integer ids) so may not be suitable for devise, but the idea stands. Reading and writing from this attribute needs to happen on at least a row level transaction in the database.","closed_by":{"login":"tegon","id":3727827,"node_id":"MDQ6VXNlcjM3Mjc4Mjc=","avatar_url":"https://avatars.githubusercontent.com/u/3727827?v=4","gravatar_id":"","url":"https://api.github.com/users/tegon","html_url":"https://github.com/tegon","followers_url":"https://api.github.com/users/tegon/followers","following_url":"https://api.github.com/users/tegon/following{/other_user}","gists_url":"https://api.github.com/users/tegon/gists{/gist_id}","starred_url":"https://api.github.com/users/tegon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tegon/subscriptions","organizations_url":"https://api.github.com/users/tegon/orgs","repos_url":"https://api.github.com/users/tegon/repos","events_url":"https://api.github.com/users/tegon/events{/privacy}","received_events_url":"https://api.github.com/users/tegon/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/heartcombo/devise/issues/4981/reactions","total_count":3,"+1":3,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/heartcombo/devise/issues/4981/timeline","performed_via_github_app":null,"state_reason":"completed"}