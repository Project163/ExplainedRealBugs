diff --git a/src/Serilog/LoggerConfiguration.cs b/src/Serilog/LoggerConfiguration.cs
index aeff4d00..87f99663 100644
--- a/src/Serilog/LoggerConfiguration.cs
+++ b/src/Serilog/LoggerConfiguration.cs
@@ -19,6 +19,7 @@ using Serilog.Core;
 using Serilog.Events;
 using Serilog.Formatting.Display;
 using Serilog.Parameters;
+using Serilog.Policies;
 using Serilog.Sinks.DumpFile;
 using Serilog.Sinks.File;
 using Serilog.Sinks.RollingFile;
@@ -38,6 +39,7 @@ namespace Serilog
         readonly List<ILogEventEnricher> _enrichers = new List<ILogEventEnricher>(); 
         readonly List<ILogEventFilter> _filters = new List<ILogEventFilter>();
         readonly List<Type> _additionalScalarTypes = new List<Type>();
+        readonly List<IDestructuringPolicy> _additionalDestructuringPolicies = new List<IDestructuringPolicy>();
         
         LogEventLevel _minimumLevel = LogEventLevel.Information;
 
@@ -232,17 +234,36 @@ namespace Serilog
         }
 
         /// <summary>
-        /// Transform logged instances with the provided transformer.
+        /// When destructuring objects, transform instances with the provided policy.
         /// </summary>
         /// <returns>Configuration object allowing method chaining.</returns>
-        public LoggerConfiguration TransformingValuesWith()
+        public LoggerConfiguration TransformingValuesWith(IDestructuringPolicy destructuringPolicy)
         {
-            throw new NotImplementedException();
+            if (destructuringPolicy == null) throw new ArgumentNullException("destructuringPolicy");
+            _additionalDestructuringPolicies.Add(destructuringPolicy);
+            return this;
+        }
+
+        /// <summary>
+        /// When destructuring objects, transform instances of the specified type with
+        /// the provided function.
+        /// </summary>
+        /// <param name="transformation">Function mapping instances of <typeparamref name="TValue"/>
+        /// to an alternative representation.</param>
+        /// <typeparam name="TValue">Type of values to transform.</typeparam>
+        /// <returns>Configuration object allowing method chaining.</returns>
+        /// <exception cref="ArgumentNullException"></exception>
+        public LoggerConfiguration TransformingValuesOf<TValue>(Func<TValue, object> transformation)
+        {
+            if (transformation == null) throw new ArgumentNullException("transformation");
+            var policy = new ProjectedDestructuringPolicy(t => t == typeof(TValue),
+                                                          o => transformation((TValue)o));
+            return TransformingValuesWith(policy);
         }
 
         PropertyValueConverter CreatePropertyValueConverter()
         {
-            return new PropertyValueConverter(_additionalScalarTypes);
+            return new PropertyValueConverter(_additionalScalarTypes, _additionalDestructuringPolicies);
         }
     }
 }
diff --git a/src/Serilog/Parameters/PropertyValueConverter.cs b/src/Serilog/Parameters/PropertyValueConverter.cs
index 8488b00a..750ecff8 100644
--- a/src/Serilog/Parameters/PropertyValueConverter.cs
+++ b/src/Serilog/Parameters/PropertyValueConverter.cs
@@ -31,12 +31,12 @@ namespace Serilog.Parameters
         readonly HashSet<Type> _scalarTypes;
         readonly List<IDestructuringPolicy> _destructuringPolicies; 
 
-        public PropertyValueConverter(IEnumerable<Type> additionalScalarTypes)
+        public PropertyValueConverter(IEnumerable<Type> additionalScalarTypes, IEnumerable<IDestructuringPolicy> additionalDestructuringPolicies)
         {
             _scalarTypes = new HashSet<Type>(additionalScalarTypes);
             _scalarTypes.UnionWith(BuiltInScalarTypes);
 
-            _destructuringPolicies = new List<IDestructuringPolicy>(BuiltInDestructuringPolicies);
+            _destructuringPolicies = new List<IDestructuringPolicy>(BuiltInDestructuringPolicies.Concat(additionalDestructuringPolicies));
         }
 
         public LogEventProperty CreateProperty(string name, object value, bool destructureObjects = false)
diff --git a/src/Serilog/Policies/NullableDestructuringPolicy.cs b/src/Serilog/Policies/NullableDestructuringPolicy.cs
index cac8031e..62210c44 100644
--- a/src/Serilog/Policies/NullableDestructuringPolicy.cs
+++ b/src/Serilog/Policies/NullableDestructuringPolicy.cs
@@ -1,4 +1,18 @@
-﻿using System;
+﻿// Copyright 2013 Nicholas Blumhardt
+// 
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
 using Serilog.Core;
 using Serilog.Events;
 using Serilog.Parsing;
diff --git a/src/Serilog/Policies/ProjectedDestructuringPolicy.cs b/src/Serilog/Policies/ProjectedDestructuringPolicy.cs
new file mode 100644
index 00000000..d2363401
--- /dev/null
+++ b/src/Serilog/Policies/ProjectedDestructuringPolicy.cs
@@ -0,0 +1,51 @@
+﻿// Copyright 2013 Nicholas Blumhardt
+// 
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using Serilog.Core;
+using Serilog.Events;
+using Serilog.Parsing;
+
+namespace Serilog.Policies
+{
+    class ProjectedDestructuringPolicy : IDestructuringPolicy
+    {
+        readonly Func<Type, bool> _canApply;
+        readonly Func<object, object> _projection;
+
+        public ProjectedDestructuringPolicy(Func<Type, bool> canApply, Func<object, object> projection)
+        {
+            if (canApply == null) throw new ArgumentNullException("canApply");
+            if (projection == null) throw new ArgumentNullException("projection");
+            _canApply = canApply;
+            _projection = projection;
+        }
+
+        public bool TryDestructure(object value, Destructuring destructuring, ILogEventPropertyValueFactory propertyValueFactory,
+                                   out LogEventPropertyValue result)
+        {
+            if (value == null) throw new ArgumentNullException("value");
+
+            if (!_canApply(value.GetType()))
+            {
+                result = null;
+                return false;
+            }
+
+            var projected = _projection(value);
+            result = propertyValueFactory.CreatePropertyValue(projected, destructuring);
+            return true;
+        }
+    }
+}
diff --git a/src/Serilog/Serilog.csproj b/src/Serilog/Serilog.csproj
index 19640cc8..c39a0e97 100644
--- a/src/Serilog/Serilog.csproj
+++ b/src/Serilog/Serilog.csproj
@@ -77,6 +77,7 @@
     <Compile Include="Events\LogEventProperty.cs" />
     <Compile Include="Parameters\PropertyValueConverter.cs" />
     <Compile Include="Policies\NullableDestructuringPolicy.cs" />
+    <Compile Include="Policies\ProjectedDestructuringPolicy.cs" />
     <Compile Include="Sinks\DumpFile\DumpFileSink.cs" />
     <Compile Include="Formatting\Display\LogEventPropertyMessageValue.cs" />
     <Compile Include="Formatting\Display\OutputProperties.cs" />
diff --git a/test/Serilog.Tests/Core/MessageTemplateTests.cs b/test/Serilog.Tests/Core/MessageTemplateTests.cs
index 5389444e..641d0a91 100644
--- a/test/Serilog.Tests/Core/MessageTemplateTests.cs
+++ b/test/Serilog.Tests/Core/MessageTemplateTests.cs
@@ -3,6 +3,7 @@ using System.IO;
 using System.Linq;
 using System.Text;
 using NUnit.Framework;
+using Serilog.Core;
 using Serilog.Parameters;
 using MessageTemplateParser = Serilog.Parsing.MessageTemplateParser;
 
@@ -68,7 +69,7 @@ namespace Serilog.Tests.Core
         static string Render(string messageTemplate, params object[] properties)
         {
             var mt = new MessageTemplateParser().Parse(messageTemplate);
-            var binder = new PropertyBinder(new PropertyValueConverter(Enumerable.Empty<Type>()));
+            var binder = new PropertyBinder(new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>()));
             var props = binder.ConstructProperties(mt, properties);
             var output = new StringBuilder();
             var writer = new StringWriter(output);
diff --git a/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs b/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
index abfe4e3c..4b09f785 100644
--- a/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
+++ b/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
@@ -1,7 +1,22 @@
-﻿using System;
+﻿// Copyright 2013 Nicholas Blumhardt
+// 
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
 using System.Globalization;
 using System.Linq;
 using NUnit.Framework;
+using Serilog.Core;
 using Serilog.Events;
 using Serilog.Parameters;
 using Serilog.Parsing;
@@ -12,7 +27,7 @@ namespace Serilog.Tests.Events
     [TestFixture]
     public class LogEventPropertyValueTests
     {
-        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>());
+        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
 
         [Test]
         public void AnEnumIsConvertedToANonStringScalarValue()
diff --git a/test/Serilog.Tests/LoggerConfigurationTests.cs b/test/Serilog.Tests/LoggerConfigurationTests.cs
index 8277028c..722d2025 100644
--- a/test/Serilog.Tests/LoggerConfigurationTests.cs
+++ b/test/Serilog.Tests/LoggerConfigurationTests.cs
@@ -67,7 +67,9 @@ namespace Serilog.Tests
             Assert.That(events.Contains(included));
         }
 
+// ReSharper disable UnusedMember.Local, UnusedAutoPropertyAccessor.Local
         class AB { public int A { get; set; } public int B { get; set; } }
+// ReSharper restore UnusedAutoPropertyAccessor.Local, UnusedMember.Local
 
         [Test]
         public void SpecifyingThatATypeIsScalarCausesItToBeLoggedAsScalarEvenWhenDestructuring()
@@ -86,5 +88,25 @@ namespace Serilog.Tests
             var prop = ev.Properties["AB"];
             Assert.IsInstanceOf<ScalarValue>(prop.Value);
         }
+
+        [Test]
+        public void TransformationsAreAppliedToEventProperties()
+        {
+            var events = new List<LogEvent>();
+            var sink = new DelegatingSink(events.Add);
+
+            var logger = new LoggerConfiguration()
+                .WithSink(sink)
+                .TransformingValuesOf<AB>(ab => new { C = ab.B })
+                .CreateLogger();
+
+            logger.Information("{@AB}", new AB());
+
+            var ev = events.Single();
+            var prop = ev.Properties["AB"];
+            var sv = (StructureValue)prop.Value;
+            var c = sv.Properties.Single();
+            Assert.AreEqual("C", c.Name);
+        }
     }
 }
diff --git a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
index 7c67bc46..9d8f470e 100644
--- a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
+++ b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
@@ -1,6 +1,7 @@
 ﻿using System;
 using System.Linq;
 using NUnit.Framework;
+using Serilog.Core;
 using Serilog.Events;
 using Serilog.Parameters;
 using Serilog.Parsing;
@@ -10,7 +11,7 @@ namespace Serilog.Tests.Parameters
     [TestFixture]
     public class PropertyValueConverterTests
     {
-        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>());
+        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
 
         [Test]
         public void UnderDestructuringAByteArrayIsAScalarValue()
@@ -20,6 +21,13 @@ namespace Serilog.Tests.Parameters
             Assert.IsInstanceOf<byte[]>(((ScalarValue)pv).Value);
         }
 
+        [Test]
+        public void UnderDestructuringAnIntegerArrayIsASequenceValue()
+        {
+            var pv = _converter.CreatePropertyValue(new int[0], Destructuring.Destructure);
+            Assert.IsInstanceOf<SequenceValue>(pv);
+        }
+
         [Test]
         public void ByDefaultADestructuredNullNullableIsAScalarNull()
         {
