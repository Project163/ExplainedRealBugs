diff --git a/src/Serilog/Parameters/PropertyValueConverter.cs b/src/Serilog/Parameters/PropertyValueConverter.cs
old mode 100644
new mode 100755
index 49bf9a82..f8fe586b
--- a/src/Serilog/Parameters/PropertyValueConverter.cs
+++ b/src/Serilog/Parameters/PropertyValueConverter.cs
@@ -23,6 +23,7 @@ using Serilog.Events;
 using Serilog.Parsing;
 using Serilog.Policies;
 using System.Runtime.CompilerServices;
+using System.ComponentModel;
 
 namespace Serilog.Parameters
 {
@@ -154,17 +155,28 @@ namespace Serilog.Parameters
                 // Only actual dictionaries are supported, as arbitrary types
                 // can implement multiple IDictionary interfaces and thus introduce
                 // multiple different interpretations.
+                var valueAsList = enumerable.Cast<object>();
                 if (IsValueTypeDictionary(valueType))
                 {
-                    return new DictionaryValue(enumerable.Cast<dynamic>()
-                        .Select(kvp => new KeyValuePair<ScalarValue, LogEventPropertyValue>(
-                                           (ScalarValue)limiter.CreatePropertyValue(kvp.Key, destructuring),
-                                           limiter.CreatePropertyValue(kvp.Value, destructuring)))
-                        .Where(kvp => kvp.Key.Value != null));
+                    var values = new List<KeyValuePair<ScalarValue, LogEventPropertyValue>>();
+                    if (valueAsList.Any())
+                    {
+                        var typeInfo = valueAsList.ElementAt(0).GetType().GetTypeInfo();
+                        var keyProperty = typeInfo.GetDeclaredProperty("Key");
+                        var valueProperty = typeInfo.GetDeclaredProperty("Value");
+
+                        foreach (object kvp in enumerable)
+                        {
+                            var scalar = (ScalarValue)limiter.CreatePropertyValue(keyProperty.GetValue(kvp), destructuring);
+                            var propValue = limiter.CreatePropertyValue(valueProperty.GetValue(kvp), destructuring);
+                            values.Add(new KeyValuePair<ScalarValue, LogEventPropertyValue>(scalar, propValue));
+                        }
+                    }
+                    return new DictionaryValue(values);
                 }
 
                 return new SequenceValue(
-                    enumerable.Cast<object>().Select(o => limiter.CreatePropertyValue(o, destructuring)));
+                    valueAsList.Select(o => limiter.CreatePropertyValue(o, destructuring)));
             }
 
             if (destructuring == Destructuring.Destructure)
diff --git a/test/Serilog.Tests/Core/MessageTemplateTests.cs b/test/Serilog.Tests/Core/MessageTemplateTests.cs
old mode 100644
new mode 100755
index 75bcee23..acc4c071
--- a/test/Serilog.Tests/Core/MessageTemplateTests.cs
+++ b/test/Serilog.Tests/Core/MessageTemplateTests.cs
@@ -163,5 +163,40 @@ namespace Serilog.Tests.Core
             var m = Render("{1}, {0}", "world");
             Assert.Equal("{1}, \"world\"", m);
         }
+
+        [Fact]
+        public void AnonymousTypeShouldBeRendered()
+        {
+            var anonymous = new { Test = 3M };
+            var m = Render("Anonymous type {value}", anonymous);
+            Assert.Equal("Anonymous type \"{ Test = 3 }\"", m);
+        }
+
+        [Fact]
+        public void EnumerableOfAnonymousTypeShouldBeRendered()
+        {
+            var anonymous = new { Foo = 4M, Bar = "Baz" };
+            var enumerable = Enumerable.Repeat("MyKey", 1).Select(v => anonymous);
+            var m = Render("Enumerable with anonymous type {enumerable}", enumerable);
+            Assert.Equal("Enumerable with anonymous type [\"{ Foo = 4, Bar = Baz }\"]", m);
+        }
+
+        [Fact]
+        public void DictionaryOfAnonymousTypeAsValueShouldBeRendered()
+        {
+            var anonymous = new { Test = 5M };
+            var dictionary = Enumerable.Repeat("MyKey", 1).ToDictionary(v => v, v => anonymous);
+            var m = Render("Dictionary with anonymous type value {dictionary}", dictionary);
+            Assert.Equal("Dictionary with anonymous type value [(\"MyKey\": \"{ Test = 5 }\")]", m);
+        }
+
+        [Fact]
+        public void DictionaryOfAnonymousTypeAsKeyShouldBeRendered()
+        {
+            var anonymous = new { Bar = 6M, Baz = 4M };
+            var dictionary = Enumerable.Repeat("MyValue", 1).ToDictionary(v => anonymous, v => v);
+            var m = Render("Dictionary with anonymous type value {dictionary}", dictionary);
+            Assert.Equal("Dictionary with anonymous type value [\"[{ Bar = 6, Baz = 4 }, MyValue]\"]", m);
+        }
     }
-}
+}
\ No newline at end of file
