diff --git a/src/Serilog/Parameters/DepthLimiter.cs b/src/Serilog/Parameters/DepthLimiter.cs
index ed102552..c22a41e0 100644
--- a/src/Serilog/Parameters/DepthLimiter.cs
+++ b/src/Serilog/Parameters/DepthLimiter.cs
@@ -15,31 +15,47 @@
 using Serilog.Core;
 using Serilog.Debugging;
 using Serilog.Events;
+using Serilog.Parsing;
 
 namespace Serilog.Parameters
 {
-    class DepthLimiter : ILogEventPropertyValueFactory
+    partial class PropertyValueConverter
     {
-        const int MaximumDestructuringDepth = 10;
+        class DepthLimiter : ILogEventPropertyValueFactory
+        {
+            const int MaximumDestructuringDepth = 10;
 
-        readonly int _currentDepth;
-        readonly PropertyValueConverter _propertyValueConverter;
+            readonly int _currentDepth;
+            readonly PropertyValueConverter _propertyValueConverter;
 
-        public DepthLimiter(int currentDepth, PropertyValueConverter propertyValueConverter)
-        {
-            _currentDepth = currentDepth;
-            _propertyValueConverter = propertyValueConverter;
-        }
+            public DepthLimiter(int currentDepth, PropertyValueConverter propertyValueConverter)
+            {
+                _currentDepth = currentDepth;
+                _propertyValueConverter = propertyValueConverter;
+            }
 
-        public LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects = false)
-        {
-            if (_currentDepth == MaximumDestructuringDepth)
+            public LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring)
             {
-                SelfLog.WriteLine("Maximium destructuring depth reached.");
-                return new ScalarValue(null);
+                return DefaultIfMaximumDepth() ??
+                    _propertyValueConverter.CreatePropertyValue(value, destructuring, _currentDepth + 1);
             }
 
-            return _propertyValueConverter.CreatePropertyValue(value, destructureObjects, _currentDepth + 1);
+            public LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects = false)
+            {
+                return DefaultIfMaximumDepth() ??
+                    _propertyValueConverter.CreatePropertyValue(value, destructureObjects, _currentDepth + 1);
+            }
+
+            LogEventPropertyValue DefaultIfMaximumDepth()
+            {
+                if (_currentDepth == MaximumDestructuringDepth)
+                {
+                    SelfLog.WriteLine("Maximium destructuring depth reached.");
+                    return new ScalarValue(null);
+                }
+
+                return null;
+            }
         }
     }
 }
diff --git a/src/Serilog/Parameters/PropertyValueConverter.cs b/src/Serilog/Parameters/PropertyValueConverter.cs
index f13c9f71..bc78d52e 100644
--- a/src/Serilog/Parameters/PropertyValueConverter.cs
+++ b/src/Serilog/Parameters/PropertyValueConverter.cs
@@ -28,7 +28,7 @@ namespace Serilog.Parameters
     // type system so that there is a better chance of code written with one sink in
     // mind working correctly with any other. This techniqe also makes the programmer
     // writing a log event (roughly) in control of the cost of recording that event.
-    class PropertyValueConverter : ILogEventPropertyFactory, ILogEventPropertyValueFactory
+    partial class PropertyValueConverter : ILogEventPropertyFactory, ILogEventPropertyValueFactory
     {
         static readonly HashSet<Type> BuiltInScalarTypes = new HashSet<Type>
         {
@@ -67,7 +67,12 @@ namespace Serilog.Parameters
             return CreatePropertyValue(value, destructureObjects, 1);
         }
 
-        public LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects, int depth)
+        public LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring)
+        {
+            return CreatePropertyValue(value, destructuring, 1);
+        }
+
+        LogEventPropertyValue CreatePropertyValue(object value, bool destructureObjects, int depth)
         {
             return CreatePropertyValue(
                 value,
@@ -77,11 +82,6 @@ namespace Serilog.Parameters
                 depth);
         }
 
-        public LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring)
-        {
-            return CreatePropertyValue(value, destructuring, 1);
-        }
-
         LogEventPropertyValue CreatePropertyValue(object value, Destructuring destructuring, int depth)
         {
             if (value == null)
@@ -95,6 +95,8 @@ namespace Serilog.Parameters
             if (IsScalarType(valueType) || valueType.GetTypeInfo().IsEnum)
                 return new ScalarValue(value);
 
+            var limiter = new DepthLimiter(depth, this);
+
             var enumerable = value as IEnumerable;
             if (enumerable != null)
             {
@@ -113,20 +115,18 @@ namespace Serilog.Parameters
                     return new DictionaryValue(
                         enumerable.Cast<dynamic>().Select(kvp =>
                             new KeyValuePair<ScalarValue, LogEventPropertyValue>(
-                                (ScalarValue)CreatePropertyValue(kvp.Key, destructuring),
-                                CreatePropertyValue(kvp.Value, destructuring))));
+                                (ScalarValue)limiter.CreatePropertyValue(kvp.Key, destructuring),
+                                limiter.CreatePropertyValue(kvp.Value, destructuring))));
                 }
 
                 return new SequenceValue(
-                    enumerable.Cast<object>().Select(o => CreatePropertyValue(o, destructuring)));
+                    enumerable.Cast<object>().Select(o => limiter.CreatePropertyValue(o, destructuring)));
             }
 
             // Unknown types
 
             if (destructuring == Destructuring.Destructure)
             {
-                var limiter = new DepthLimiter(depth, this);
-
                 foreach (var destructuringPolicy in _destructuringPolicies)
                 {
                     LogEventPropertyValue result;
diff --git a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
index 18335eaa..39a4d6b6 100644
--- a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
+++ b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
@@ -67,6 +67,26 @@ namespace Serilog.Tests.Parameters
             Assert.IsInstanceOf<StructureValue>(pv);
         }
 
+        struct C
+        {
+            public D D { get; set; }
+        }
+
+        class D
+        {
+            public IList<C?> C { get; set; } 
+        }
+
+        [Test]
+        public void CollectionsAndCustomPoliciesInCyclesDoNotStackOverflow()
+        {
+            var cd = new C { D = new D() };
+            cd.D.C = new List<C?> { cd };
+
+            var pv = _converter.CreatePropertyValue(cd, true);
+            Assert.IsInstanceOf<StructureValue>(pv);
+        }
+
         [Test]
         public void ByDefaultAScalarDictionaryIsADictionaryValue()
         {
