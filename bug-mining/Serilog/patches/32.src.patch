diff --git a/src/Serilog/Configuration/LoggerDestructuringConfiguration.cs b/src/Serilog/Configuration/LoggerDestructuringConfiguration.cs
index 9368ddbe..88af10d2 100644
--- a/src/Serilog/Configuration/LoggerDestructuringConfiguration.cs
+++ b/src/Serilog/Configuration/LoggerDestructuringConfiguration.cs
@@ -26,11 +26,13 @@ namespace Serilog.Configuration
         readonly LoggerConfiguration _loggerConfiguration;
         readonly Action<Type> _addScalar;
         readonly Action<IDestructuringPolicy> _addPolicy;
+        readonly Action<int> _setMaximumDepth;
 
         internal LoggerDestructuringConfiguration(
             LoggerConfiguration loggerConfiguration,
             Action<Type> addScalar,
-            Action<IDestructuringPolicy> addPolicy)
+            Action<IDestructuringPolicy> addPolicy,
+            Action<int> setMaximumDepth)
         {
             if (loggerConfiguration == null) throw new ArgumentNullException("loggerConfiguration");
             if (addScalar == null) throw new ArgumentNullException("addScalar");
@@ -38,6 +40,7 @@ namespace Serilog.Configuration
             _loggerConfiguration = loggerConfiguration;
             _addScalar = addScalar;
             _addPolicy = addPolicy;
+            _setMaximumDepth = setMaximumDepth;
         }
 
         /// <summary>
@@ -69,6 +72,7 @@ namespace Serilog.Configuration
         /// </summary>
         /// <param name="destructuringPolicies">Policies to apply when destructuring.</param>
         /// <returns>Configuration object allowing method chaining.</returns>
+        // ReSharper disable once MemberCanBePrivate.Global
         public LoggerConfiguration With(params IDestructuringPolicy[] destructuringPolicies)
         {
             if (destructuringPolicies == null) throw new ArgumentNullException("destructuringPolicies");
@@ -109,6 +113,20 @@ namespace Serilog.Configuration
             return With(policy);
         }
 
+        /// <summary>
+        /// When destructuring objects, depth will be limited to 5 property traversals deep to
+        /// guard against ballooning space when recursive/cyclic structures are accidentally passed. To
+        /// increase this limit pass a higher value.
+        /// </summary>
+        /// <param name="maximumDestructuringDepth">The maximum depth to use.</param>
+        /// <returns>Configuration object allowing method chaining.</returns>
+        /// <exception cref="ArgumentOutOfRangeException"></exception>
+        public LoggerConfiguration ToMaximumDepth(int maximumDestructuringDepth)
+        {
+            if (maximumDestructuringDepth < 0) throw new ArgumentOutOfRangeException("maximumDestructuringDepth");
+            _setMaximumDepth(maximumDestructuringDepth);
+            return _loggerConfiguration;
+        }
     }
 }
 
diff --git a/src/Serilog/LoggerConfiguration.cs b/src/Serilog/LoggerConfiguration.cs
index 2aa4d9e4..4c582bdb 100644
--- a/src/Serilog/LoggerConfiguration.cs
+++ b/src/Serilog/LoggerConfiguration.cs
@@ -37,6 +37,7 @@ namespace Serilog
         
         LogEventLevel _minimumLevel = LogEventLevel.Information;
         LoggingLevelSwitch _levelSwitch;
+        int _maximumDestructuringDepth = 5;
 
         /// <summary>
         /// Configures the sinks that log events will be emitted to.
@@ -95,7 +96,11 @@ namespace Serilog
         {
             get
             {
-                return new LoggerDestructuringConfiguration(this, _additionalScalarTypes.Add, _additionalDestructuringPolicies.Add);
+                return new LoggerDestructuringConfiguration(
+                    this,
+                    _additionalScalarTypes.Add,
+                    _additionalDestructuringPolicies.Add,
+                    depth => _maximumDestructuringDepth = depth);
             }
         }
         
@@ -119,7 +124,7 @@ namespace Serilog
             if (_filters.Any())
                 sink = new SafeAggregateSink(new[] { new FilteringSink(sink, _filters) });
 
-            var converter = new PropertyValueConverter(_additionalScalarTypes, _additionalDestructuringPolicies);
+            var converter = new PropertyValueConverter(_maximumDestructuringDepth, _additionalScalarTypes, _additionalDestructuringPolicies);
             var processor = new MessageTemplateProcessor(converter);
 
             return _levelSwitch == null ? 
diff --git a/src/Serilog/Parameters/DepthLimiter.cs b/src/Serilog/Parameters/DepthLimiter.cs
index fdad1056..8f04e80b 100644
--- a/src/Serilog/Parameters/DepthLimiter.cs
+++ b/src/Serilog/Parameters/DepthLimiter.cs
@@ -23,13 +23,13 @@ namespace Serilog.Parameters
     {
         class DepthLimiter : ILogEventPropertyValueFactory
         {
-            const int MaximumDestructuringDepth = 10;
-
+            readonly int _maximumDestructuringDepth;
             readonly int _currentDepth;
             readonly PropertyValueConverter _propertyValueConverter;
 
-            public DepthLimiter(int currentDepth, PropertyValueConverter propertyValueConverter)
+            public DepthLimiter(int currentDepth, int maximumDepth, PropertyValueConverter propertyValueConverter)
             {
+                _maximumDestructuringDepth = maximumDepth;
                 _currentDepth = currentDepth;
                 _propertyValueConverter = propertyValueConverter;
             }
@@ -48,7 +48,7 @@ namespace Serilog.Parameters
 
             LogEventPropertyValue DefaultIfMaximumDepth()
             {
-                if (_currentDepth == MaximumDestructuringDepth)
+                if (_currentDepth == _maximumDestructuringDepth)
                 {
                     SelfLog.WriteLine("Maximum destructuring depth reached.");
                     return new ScalarValue(null);
diff --git a/src/Serilog/Parameters/PropertyValueConverter.cs b/src/Serilog/Parameters/PropertyValueConverter.cs
index 342ae307..fbbd78ca 100644
--- a/src/Serilog/Parameters/PropertyValueConverter.cs
+++ b/src/Serilog/Parameters/PropertyValueConverter.cs
@@ -43,12 +43,16 @@ namespace Serilog.Parameters
         };
 
         readonly IDestructuringPolicy[] _destructuringPolicies; 
-        readonly IScalarConversionPolicy[] _scalarConversionPolicies; 
+        readonly IScalarConversionPolicy[] _scalarConversionPolicies;
+        readonly int _maximumDestructuringDepth;
 
-        public PropertyValueConverter(IEnumerable<Type> additionalScalarTypes, IEnumerable<IDestructuringPolicy> additionalDestructuringPolicies)
+        public PropertyValueConverter(int maximumDestructuringDepth, IEnumerable<Type> additionalScalarTypes, IEnumerable<IDestructuringPolicy> additionalDestructuringPolicies)
         {
             if (additionalScalarTypes == null) throw new ArgumentNullException("additionalScalarTypes");
             if (additionalDestructuringPolicies == null) throw new ArgumentNullException("additionalDestructuringPolicies");
+            if (maximumDestructuringDepth < 0) throw new ArgumentOutOfRangeException("maximumDestructuringDepth");
+
+            _maximumDestructuringDepth = maximumDestructuringDepth;
 
             _scalarConversionPolicies = new IScalarConversionPolicy[]
             {
@@ -101,7 +105,7 @@ namespace Serilog.Parameters
                 return new ScalarValue(value.ToString());
 
             var valueType = value.GetType();
-            var limiter = new DepthLimiter(depth, this);
+            var limiter = new DepthLimiter(depth, _maximumDestructuringDepth, this);
 
             foreach (var scalarConversionPolicy in _scalarConversionPolicies)
             {
diff --git a/test/Serilog.Tests/Core/MessageTemplateTests.cs b/test/Serilog.Tests/Core/MessageTemplateTests.cs
index eeb8278c..8bfafb48 100644
--- a/test/Serilog.Tests/Core/MessageTemplateTests.cs
+++ b/test/Serilog.Tests/Core/MessageTemplateTests.cs
@@ -126,7 +126,7 @@ namespace Serilog.Tests.Core
         static string Render(IFormatProvider formatProvider, string messageTemplate, params object[] properties)
         {
             var mt = new MessageTemplateParser().Parse(messageTemplate);
-            var binder = new PropertyBinder(new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>()));
+            var binder = new PropertyBinder(new PropertyValueConverter(10, Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>()));
             var props = binder.ConstructProperties(mt, properties);
             var output = new StringBuilder();
             var writer = new StringWriter(output);
diff --git a/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs b/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
index 6969bda2..deacf39e 100644
--- a/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
+++ b/test/Serilog.Tests/Events/LogEventPropertyValueTests.cs
@@ -27,7 +27,7 @@ namespace Serilog.Tests.Events
     [TestFixture]
     public class LogEventPropertyValueTests
     {
-        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
+        readonly PropertyValueConverter _converter = new PropertyValueConverter(10, Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
 
         [Test]
         public void AnEnumIsConvertedToANonStringScalarValue()
diff --git a/test/Serilog.Tests/LoggerConfigurationTests.cs b/test/Serilog.Tests/LoggerConfigurationTests.cs
index e5d19ff2..d3aefb60 100644
--- a/test/Serilog.Tests/LoggerConfigurationTests.cs
+++ b/test/Serilog.Tests/LoggerConfigurationTests.cs
@@ -156,5 +156,23 @@ namespace Serilog.Tests
 
             Assert.That(enrichedPropertySeen);
         }
+
+        [Test]
+        public void MaximumDestructuringDepthIsEffective()
+        {
+            var x = new { A = new { B = new { C = new { D = "F" } } } };
+
+            LogEvent evt = null;
+            var log = new LoggerConfiguration()
+                .WriteTo.Sink(new DelegatingSink(e => evt = e))
+                .Destructure.ToMaximumDepth(3)
+                .CreateLogger();
+
+            log.Information("{@X}", x);
+            var xs = evt.Properties["X"].ToString();
+
+            Assert.That(xs, Is.StringContaining("C"));
+            Assert.That(xs, Is.Not.StringContaining("D"));
+        }
     }
 }
diff --git a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
index af1ec3f3..f719929d 100644
--- a/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
+++ b/test/Serilog.Tests/Parameters/PropertyValueConverterTests.cs
@@ -13,7 +13,7 @@ namespace Serilog.Tests.Parameters
     [TestFixture]
     public class PropertyValueConverterTests
     {
-        readonly PropertyValueConverter _converter = new PropertyValueConverter(Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
+        readonly PropertyValueConverter _converter = new PropertyValueConverter(10, Enumerable.Empty<Type>(), Enumerable.Empty<IDestructuringPolicy>());
 
         [Test]
         public void UnderDestructuringAByteArrayIsAScalarValue()
