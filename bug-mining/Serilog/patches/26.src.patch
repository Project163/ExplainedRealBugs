diff --git a/Serilog.sln.DotSettings b/Serilog.sln.DotSettings
index a70e8a6c..64dae394 100644
--- a/Serilog.sln.DotSettings
+++ b/Serilog.sln.DotSettings
@@ -107,11 +107,11 @@
 	<s:String x:Key="/Default/CodeStyle/CodeCleanup/RecentlyUsedProfile/@EntryValue">Default: Reformat Code</s:String>
 	<s:String x:Key="/Default/CodeStyle/CodeCleanup/SilentCleanupProfile/@EntryValue">Format My Code Using "Particular" conventions</s:String>
 	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/EXPLICIT_PRIVATE_MODIFIER/@EntryValue">False</s:Boolean>
-	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOR_BRACES_STYLE/@EntryValue">ALWAYS_ADD</s:String>
-	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOREACH_BRACES_STYLE/@EntryValue">ALWAYS_ADD</s:String>
-	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_IFELSE_BRACES_STYLE/@EntryValue">ALWAYS_ADD</s:String>
-	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_USING_BRACES_STYLE/@EntryValue">ALWAYS_ADD</s:String>
-	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_WHILE_BRACES_STYLE/@EntryValue">ALWAYS_ADD</s:String>
+	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOR_BRACES_STYLE/@EntryValue">DO_NOT_CHANGE</s:String>
+	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_FOREACH_BRACES_STYLE/@EntryValue">DO_NOT_CHANGE</s:String>
+	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_IFELSE_BRACES_STYLE/@EntryValue">DO_NOT_CHANGE</s:String>
+	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_USING_BRACES_STYLE/@EntryValue">DO_NOT_CHANGE</s:String>
+	<s:String x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/FORCE_WHILE_BRACES_STYLE/@EntryValue">DO_NOT_CHANGE</s:String>
 	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_BEFORE_FIXED_PARENTHESES/@EntryValue">False</s:Boolean>
 	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_BEFORE_SIZEOF_PARENTHESES/@EntryValue">False</s:Boolean>
 	<s:Boolean x:Key="/Default/CodeStyle/CodeFormatting/CSharpFormat/SPACE_BEFORE_TYPEOF_PARENTHESES/@EntryValue">False</s:Boolean>
diff --git a/src/Serilog/Configuration/LoggerMinimumLevelConfiguration.cs b/src/Serilog/Configuration/LoggerMinimumLevelConfiguration.cs
index 1ee5e022..ebe32368 100644
--- a/src/Serilog/Configuration/LoggerMinimumLevelConfiguration.cs
+++ b/src/Serilog/Configuration/LoggerMinimumLevelConfiguration.cs
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 using System;
+using Serilog.Core;
 using Serilog.Events;
 
 namespace Serilog.Configuration
@@ -24,13 +25,15 @@ namespace Serilog.Configuration
     {
         readonly LoggerConfiguration _loggerConfiguration;
         readonly Action<LogEventLevel> _setMinimum;
+        readonly Action<LoggingLevelSwitch> _setLevelSwitch;
 
-        internal LoggerMinimumLevelConfiguration(LoggerConfiguration loggerConfiguration, Action<LogEventLevel> setMinimum)
+        internal LoggerMinimumLevelConfiguration(LoggerConfiguration loggerConfiguration, Action<LogEventLevel> setMinimum, Action<LoggingLevelSwitch> setLevelSwitch)
         {
             if (loggerConfiguration == null) throw new ArgumentNullException("loggerConfiguration");
             if (setMinimum == null) throw new ArgumentNullException("setMinimum");
             _loggerConfiguration = loggerConfiguration;
             _setMinimum = setMinimum;
+            _setLevelSwitch = setLevelSwitch;
         }
 
         /// <summary>
@@ -44,6 +47,18 @@ namespace Serilog.Configuration
             return _loggerConfiguration;
         }
 
+        /// <summary>
+        /// Sets the minimum level to be dynamically controlled by the provided switch.
+        /// </summary>
+        /// <param name="levelSwitch">The switch.</param>
+        /// <returns>Configuration object allowing method chaining.</returns>
+        public LoggerConfiguration ControlledBy(LoggingLevelSwitch levelSwitch)
+        {
+            if (levelSwitch == null) throw new ArgumentNullException("levelSwitch");
+            _setLevelSwitch(levelSwitch);
+            return _loggerConfiguration;
+        }
+
         /// <summary>
         /// Anything and everything you might want to know about
         /// a running block of code.
diff --git a/src/Serilog/Core/LoggingLevelSwitch.cs b/src/Serilog/Core/LoggingLevelSwitch.cs
new file mode 100644
index 00000000..8a1e1ef1
--- /dev/null
+++ b/src/Serilog/Core/LoggingLevelSwitch.cs
@@ -0,0 +1,48 @@
+﻿// Copyright 2014 Serilog Contributors
+// 
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using Serilog.Events;
+
+namespace Serilog.Core
+{
+    /// <summary>
+    /// Dynamically controls logging level.
+    /// </summary>
+    public class LoggingLevelSwitch
+    {
+        volatile LogEventLevel _minimumLevel;
+
+        /// <summary>
+        /// Create a <see cref="LoggingLevelSwitch"/> at the initial
+        /// minimum level.
+        /// </summary>
+        /// <param name="initialMinimumLevel">The initial level to which the switch is set.</param>
+        public LoggingLevelSwitch(LogEventLevel initialMinimumLevel = LogEventLevel.Information)
+        {
+            _minimumLevel = initialMinimumLevel;
+        }
+
+        /// <summary>
+        /// The current minimum level, below which no events
+        /// should be generated.
+        /// </summary>
+        // Reading this property generates a memory barrier,
+        // so needs to be used judiciously in the logging pipeline.
+        public LogEventLevel MinimumLevel
+        {
+            get { return _minimumLevel; }
+            set { _minimumLevel = value; }
+        }
+    }
+}
diff --git a/src/Serilog/Core/Pipeline/Logger.cs b/src/Serilog/Core/Pipeline/Logger.cs
index 78e4b184..0e48fba7 100644
--- a/src/Serilog/Core/Pipeline/Logger.cs
+++ b/src/Serilog/Core/Pipeline/Logger.cs
@@ -25,24 +25,54 @@ namespace Serilog.Core.Pipeline
     sealed class Logger : ILogger, ILogEventSink, IDisposable
     {
         readonly MessageTemplateProcessor _messageTemplateProcessor;
-        readonly LogEventLevel _minimumLevel;
         readonly ILogEventSink _sink;
         readonly Action _dispose;
         readonly ILogEventEnricher[] _enrichers;
 
+        // It's important that checking minimum level is a very 
+        // quick (CPU-cacheable) read in the simple case, hence
+        // we keep a separate field from the switch, which may
+        // not be specified. If it is, we'll set _minimumLevel
+        // to its lower limit and fall through to the secondary check.
+        readonly LogEventLevel _minimumLevel;
+        readonly LoggingLevelSwitch _levelSwitch;
+
         public Logger(
             MessageTemplateProcessor messageTemplateProcessor,
             LogEventLevel minimumLevel,
             ILogEventSink sink,
             IEnumerable<ILogEventEnricher> enrichers,
             Action dispose = null)
+            : this(messageTemplateProcessor, minimumLevel, sink, enrichers, dispose, null)
+        {
+        }
+
+        public Logger(
+            MessageTemplateProcessor messageTemplateProcessor,
+            LoggingLevelSwitch levelSwitch,
+            ILogEventSink sink,
+            IEnumerable<ILogEventEnricher> enrichers,
+            Action dispose = null)
+            : this(messageTemplateProcessor, LevelAlias.Minimum, sink, enrichers, dispose, levelSwitch)
+        {
+        }
+
+        Logger(
+            MessageTemplateProcessor messageTemplateProcessor,
+            LogEventLevel minimumLevel,
+            ILogEventSink sink,
+            IEnumerable<ILogEventEnricher> enrichers,
+            Action dispose = null,
+            LoggingLevelSwitch levelSwitch = null)
         {
             if (sink == null) throw new ArgumentNullException("sink");
             if (enrichers == null) throw new ArgumentNullException("enrichers");
+
             _messageTemplateProcessor = messageTemplateProcessor;
             _minimumLevel = minimumLevel;
             _sink = sink;
             _dispose = dispose;
+            _levelSwitch = levelSwitch;
             _enrichers = enrichers.ToArray();
         }
 
@@ -52,7 +82,9 @@ namespace Serilog.Core.Pipeline
                 _messageTemplateProcessor,
                 _minimumLevel, 
                 this,
-                (enrichers ?? new ILogEventEnricher[0]).ToArray());
+                (enrichers ?? new ILogEventEnricher[0]).ToArray(),
+                null,
+                _levelSwitch);
         }
 
         public ILogger ForContext(string propertyName, object value, bool destructureObjects = false)
@@ -80,7 +112,11 @@ namespace Serilog.Core.Pipeline
 
         public bool IsEnabled(LogEventLevel level)
         {
-            return (int)level >= (int)_minimumLevel;
+            if ((int)level < (int)_minimumLevel)
+                return false;
+
+            return _levelSwitch == null ||
+                (int)level >= (int)_levelSwitch.MinimumLevel;
         }
 
         public void Write(LogEventLevel level, Exception exception, string messageTemplate, params object[] propertyValues)
diff --git a/src/Serilog/LoggerConfiguration.cs b/src/Serilog/LoggerConfiguration.cs
index f865eea2..2aa4d9e4 100644
--- a/src/Serilog/LoggerConfiguration.cs
+++ b/src/Serilog/LoggerConfiguration.cs
@@ -36,6 +36,7 @@ namespace Serilog
         readonly List<IDestructuringPolicy> _additionalDestructuringPolicies = new List<IDestructuringPolicy>();
         
         LogEventLevel _minimumLevel = LogEventLevel.Information;
+        LoggingLevelSwitch _levelSwitch;
 
         /// <summary>
         /// Configures the sinks that log events will be emitted to.
@@ -58,7 +59,9 @@ namespace Serilog
         {
             get
             {
-                return new LoggerMinimumLevelConfiguration(this, l => _minimumLevel = l);
+                return new LoggerMinimumLevelConfiguration(this,
+                    l => _minimumLevel = l,
+                    sw => _levelSwitch = sw);
             }
         }
 
@@ -119,7 +122,9 @@ namespace Serilog
             var converter = new PropertyValueConverter(_additionalScalarTypes, _additionalDestructuringPolicies);
             var processor = new MessageTemplateProcessor(converter);
 
-            return new Logger(processor, _minimumLevel, sink, _enrichers, dispose);
+            return _levelSwitch == null ? 
+                new Logger(processor, _minimumLevel, sink, _enrichers, dispose) :
+                new Logger(processor, _levelSwitch, sink, _enrichers, dispose);
         }
     }
 }
diff --git a/src/Serilog/Serilog.csproj b/src/Serilog/Serilog.csproj
index c58aaf30..adb1769f 100644
--- a/src/Serilog/Serilog.csproj
+++ b/src/Serilog/Serilog.csproj
@@ -50,6 +50,7 @@
     <Compile Include="Configuration\LoggerEnrichmentConfiguration.cs" />
     <Compile Include="Configuration\LoggerMinimumLevelConfiguration.cs" />
     <Compile Include="Configuration\LoggerSinkConfiguration.cs" />
+    <Compile Include="Core\LoggingLevelSwitch.cs" />
     <Compile Include="Core\Constants.cs" />
     <Compile Include="Core\Enrichers\PropertyEnricher.cs" />
     <Compile Include="Core\IScalarConversionPolicy.cs" />
diff --git a/test/Serilog.Tests/Core/LoggerTests.cs b/test/Serilog.Tests/Core/LoggerTests.cs
index 393f20b0..496a8dcd 100644
--- a/test/Serilog.Tests/Core/LoggerTests.cs
+++ b/test/Serilog.Tests/Core/LoggerTests.cs
@@ -1,6 +1,9 @@
 ﻿using System;
+using System.Collections.Generic;
+using System.Linq;
 using NUnit.Framework;
 using Serilog.Core;
+using Serilog.Events;
 using Serilog.Tests.Support;
 
 namespace Serilog.Tests.Core
@@ -54,5 +57,34 @@ namespace Serilog.Tests.Core
             var e = DelegatingSink.GetLogEvent(l => l.Error("message", new object()));
             Assert.AreEqual("message", e.RenderMessage());
         }
+
+        [Test]
+        public void LoggingLevelSwitchDynamicallyChangesLevel()
+        {
+            var events = new List<LogEvent>();
+            var sink = new DelegatingSink(events.Add);
+
+            var levelSwitch = new LoggingLevelSwitch(LogEventLevel.Information);
+
+            var log = new LoggerConfiguration()
+                .MinimumLevel.ControlledBy(levelSwitch)
+                .WriteTo.Sink(sink)
+                .CreateLogger()
+                .ForContext<LoggerTests>();
+
+            log.Debug("Suppressed");
+            log.Information("Emitted");
+            log.Warning("Emitted");
+
+            // Change the level
+            levelSwitch.MinimumLevel = LogEventLevel.Error;
+
+            log.Warning("Suppressed");
+            log.Error("Emitted");
+            log.Fatal("Emitted");
+
+            Assert.AreEqual(4, events.Count);
+            Assert.That(events.All(evt => evt.RenderMessage() == "Emitted"));
+        }
     }
 }
