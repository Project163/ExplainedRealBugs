diff --git a/src/Serilog.FullNetFx/Context/ImmutableStack.cs b/src/Serilog.FullNetFx/Context/ImmutableStack.cs
index a604e4ca..1477c73c 100644
--- a/src/Serilog.FullNetFx/Context/ImmutableStack.cs
+++ b/src/Serilog.FullNetFx/Context/ImmutableStack.cs
@@ -14,12 +14,14 @@
 
 using System;
 using System.Collections.Generic;
+using System.Runtime.Serialization;
 
 namespace Serilog.Context
 {
     // Needed because of the shallow-copying behaviour of
     // LogicalCallContext.
-    class ImmutableStack<T> : IEnumerable<T>
+    [Serializable]
+    class ImmutableStack<T> : IEnumerable<T>, ISerializable
     {
         static readonly ImmutableStack<T> _empty = new ImmutableStack<T>();
 
@@ -27,6 +29,10 @@ namespace Serilog.Context
         readonly ImmutableStack<T> _under;
         readonly T _top;
 
+        public ImmutableStack(SerializationInfo info, StreamingContext context)
+        {
+        }
+
         ImmutableStack()
         {
         }
@@ -42,7 +48,7 @@ namespace Serilog.Context
         public IEnumerator<T> GetEnumerator()
         {
             var next = this;
-            while (next != _empty)
+            while (!next.IsEmpty)
             {
                 yield return next.Top;
                 next = next._under;
@@ -58,11 +64,17 @@ namespace Serilog.Context
 
         public static ImmutableStack<T> Empty { get { return _empty; } }
 
+        public bool IsEmpty { get { return _under == null; } }
+
         public ImmutableStack<T> Push(T t)
         {
             return new ImmutableStack<T>(this, t);
         }
 
         public T Top { get { return _top; } }
+
+        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
+        {
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Serilog/Debugging/SelfLog.cs b/src/Serilog/Debugging/SelfLog.cs
index 728388b0..7170b246 100644
--- a/src/Serilog/Debugging/SelfLog.cs
+++ b/src/Serilog/Debugging/SelfLog.cs
@@ -12,6 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+using System;
 using System.IO;
 
 namespace Serilog.Debugging
@@ -42,7 +43,7 @@ namespace Serilog.Debugging
             var o = Out;
             if (o != null)
             {
-                o.WriteLine(format, arg0, arg1, arg2);
+                o.WriteLine(DateTime.Now.ToString("s") + " " + format, arg0, arg1, arg2);
                 o.Flush();
             }
         }
diff --git a/test/Serilog.Tests/Context/LogContextTests.cs b/test/Serilog.Tests/Context/LogContextTests.cs
index b3faa991..b1103798 100644
--- a/test/Serilog.Tests/Context/LogContextTests.cs
+++ b/test/Serilog.Tests/Context/LogContextTests.cs
@@ -1,4 +1,7 @@
-﻿using NUnit.Framework;
+﻿using System;
+using System.IO;
+using System.Reflection;
+using NUnit.Framework;
 using Serilog.Context;
 using Serilog.Events;
 using Serilog.Tests.Support;
@@ -65,5 +68,48 @@ namespace Serilog.Tests.Context
                     Assert.Inconclusive("The test was marshalled back to the same thread after awaiting");
             }
         }
+
+        // Must not actually try to pass context across domains,
+        // since user property types may not be serializable.
+        [Test]
+        public void DoesNotPreventCrossDomainCalls()
+        {
+            AppDomain domain = null;
+            try
+            {
+                var domaininfo = new AppDomainSetup { ApplicationBase = Path.GetDirectoryName(GetType().Assembly.CodeBase.Replace("file:///", "")) };
+                var evidence = AppDomain.CurrentDomain.Evidence;
+                domain = AppDomain.CreateDomain("LogContextTest", evidence, domaininfo);
+
+                var callable = (RemotelyCallable)domain.CreateInstanceAndUnwrap(typeof(RemotelyCallable).Assembly.FullName, typeof(RemotelyCallable).FullName);
+
+                using (LogContext.PushProperty("Anything", 1001))
+                    Assert.That(callable.IsCallable());
+            }
+            finally
+            {
+                if (domain != null)
+                    AppDomain.Unload(domain);
+            }
+        }
+    }
+
+    public class RemotelyCallable : MarshalByRefObject
+    {
+        public bool IsCallable()
+        {
+            var sw = new StringWriter();
+
+            var log = new LoggerConfiguration()
+                .WriteTo.TextWriter(sw, outputTemplate: "{Anything}{Number}")
+                .Enrich.FromLogContext()
+                .CreateLogger();
+
+            using (LogContext.PushProperty("Number", 42))
+                log.Information("Hello");
+
+            var s = sw.ToString();
+            return s == "{Anything}42";
+        }
     }
 }
