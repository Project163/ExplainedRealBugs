diff --git a/src/Serilog/Events/MessageTemplate.cs b/src/Serilog/Events/MessageTemplate.cs
index fa545d26..bb75f723 100644
--- a/src/Serilog/Events/MessageTemplate.cs
+++ b/src/Serilog/Events/MessageTemplate.cs
@@ -28,6 +28,11 @@ namespace Serilog.Events
     /// </summary>
     public class MessageTemplate
     {
+        /// <summary>
+        /// Represents the empty message template.
+        /// </summary>
+        public static MessageTemplate Empty { get; } = new MessageTemplate(Enumerable.Empty<MessageTemplateToken>());
+
         readonly MessageTemplateToken[] _tokens;
 
         // Optimisation for when the template is bound to
diff --git a/src/Serilog/Formatting/Display/LogEventPropertiesValue.cs b/src/Serilog/Formatting/Display/LogEventPropertiesValue.cs
new file mode 100644
index 00000000..1e47f0ee
--- /dev/null
+++ b/src/Serilog/Formatting/Display/LogEventPropertiesValue.cs
@@ -0,0 +1,81 @@
+ï»¿// Copyright 2017 Serilog Contributors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Serilog.Events;
+
+namespace Serilog.Formatting.Display
+{
+    class LogEventPropertiesValue : LogEventPropertyValue
+    {
+        readonly MessageTemplate _template;
+        readonly IReadOnlyDictionary<string, LogEventPropertyValue> _properties;
+        readonly MessageTemplate _outputTemplate;
+
+        public LogEventPropertiesValue(MessageTemplate template, IReadOnlyDictionary<string, LogEventPropertyValue> properties, MessageTemplate outputTemplate)
+        {
+            _template = template;
+            _properties = properties;
+            _outputTemplate = outputTemplate;
+        }
+
+        public override void Render(TextWriter output, string format = null, IFormatProvider formatProvider = null)
+        {
+            output.Write('{');
+
+            var delim = "";
+            foreach (var kvp in _properties)
+            {
+                if (TemplateContainsPropertyName(_template, kvp.Key))
+                {
+                    continue;
+                }
+
+                if (TemplateContainsPropertyName(_outputTemplate, kvp.Key))
+                {
+                    continue;
+                }
+
+                output.Write(delim);
+                delim = ", ";
+                output.Write(kvp.Key);
+                output.Write(": ");
+                kvp.Value.Render(output, null, formatProvider);
+            }
+
+            output.Write('}');
+        }
+
+        static bool TemplateContainsPropertyName(MessageTemplate template, string propertyName)
+        {
+            if (template.NamedProperties == null)
+            {
+                return false;
+            }
+
+            for (var i = 0; i < template.NamedProperties.Length; i++)
+            {
+                var namedProperty = template.NamedProperties[i];
+                if (namedProperty.PropertyName == propertyName)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Serilog/Formatting/Display/MessageTemplateTextFormatter.cs b/src/Serilog/Formatting/Display/MessageTemplateTextFormatter.cs
index 54f9a1fe..0c1ae7f8 100644
--- a/src/Serilog/Formatting/Display/MessageTemplateTextFormatter.cs
+++ b/src/Serilog/Formatting/Display/MessageTemplateTextFormatter.cs
@@ -61,8 +61,8 @@ namespace Serilog.Formatting.Display
             // This could be lazier: the output properties include
             // everything from the log event, but often we won't need any more than
             // just the standard timestamp/message etc.
-            var outputProperties = OutputProperties.GetOutputProperties(logEvent);
-            
+            var outputProperties = OutputProperties.GetOutputProperties(logEvent, _outputTemplate);
+
             foreach (var token in _outputTemplate.Tokens)
             {
                 var pt = token as PropertyToken;
diff --git a/src/Serilog/Formatting/Display/OutputProperties.cs b/src/Serilog/Formatting/Display/OutputProperties.cs
index 12570180..14065c4d 100644
--- a/src/Serilog/Formatting/Display/OutputProperties.cs
+++ b/src/Serilog/Formatting/Display/OutputProperties.cs
@@ -52,12 +52,29 @@ namespace Serilog.Formatting.Display
         /// </summary>
         public const string ExceptionPropertyName = "Exception";
 
+        /// <summary>
+        /// The properties of the log event.
+        /// </summary>
+        public const string PropertiesPropertyName = "Properties";
+
         /// <summary>
         /// Create properties from the provided log event.
         /// </summary>
         /// <param name="logEvent">The log event.</param>
         /// <returns>A dictionary with properties representing the log event.</returns>
+        [Obsolete("Pass the full output template using the other overload.")]
         public static IReadOnlyDictionary<string, LogEventPropertyValue> GetOutputProperties(LogEvent logEvent)
+        {
+            return GetOutputProperties(logEvent, MessageTemplate.Empty);
+        }
+
+        /// <summary>
+        /// Create properties from the provided log event.
+        /// </summary>
+        /// <param name="logEvent">The log event.</param>
+        /// <param name="outputTemplate">The output template.</param>
+        /// <returns>A dictionary with properties representing the log event.</returns>
+        public static IReadOnlyDictionary<string, LogEventPropertyValue> GetOutputProperties(LogEvent logEvent, MessageTemplate outputTemplate)
         {
             var result = logEvent.Properties.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
 
@@ -69,11 +86,12 @@ namespace Serilog.Formatting.Display
             result[TimestampPropertyName] = new ScalarValue(logEvent.Timestamp);
             result[LevelPropertyName] = new LogEventLevelValue(logEvent.Level);
             result[NewLinePropertyName] = LiteralNewLine;
+            result[PropertiesPropertyName] = new LogEventPropertiesValue(logEvent.MessageTemplate, logEvent.Properties, outputTemplate);
 
-            var exception = logEvent.Exception == null ? "" : (logEvent.Exception + Environment.NewLine);
+            var exception = logEvent.Exception == null ? "" : logEvent.Exception + Environment.NewLine;
             result[ExceptionPropertyName] = new LiteralStringValue(exception);
 
             return result;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/test/Serilog.Tests/Formatting/Display/MessageTemplateTextFormatterTests.cs b/test/Serilog.Tests/Formatting/Display/MessageTemplateTextFormatterTests.cs
index b5a24855..052ee267 100644
--- a/test/Serilog.Tests/Formatting/Display/MessageTemplateTextFormatterTests.cs
+++ b/test/Serilog.Tests/Formatting/Display/MessageTemplateTextFormatterTests.cs
@@ -198,5 +198,25 @@ namespace Serilog.Tests.Formatting.Display
             formatter.Format(evt, sw);
             Assert.Equal("Size Huge", sw.ToString());
         }
+
+        [Fact]
+        public void NonMessagePropertiesAreRendered()
+        {
+            var formatter = new MessageTemplateTextFormatter("{Properties}", CultureInfo.InvariantCulture);
+            var evt = DelegatingSink.GetLogEvent(l => l.ForContext("Foo", 42).Information("Hello from {Bar}!", "bar"));
+            var sw = new StringWriter();
+            formatter.Format(evt, sw);
+            Assert.Equal("{Foo: 42}", sw.ToString());
+        }
+
+        [Fact]
+        public void DoNotDuplicatePropertiesAlreadyRenderedInOutputTemplate()
+        {
+            var formatter = new MessageTemplateTextFormatter("{Foo} {Properties}", CultureInfo.InvariantCulture);
+            var evt = DelegatingSink.GetLogEvent(l => l.ForContext("Foo", 42).ForContext("Bar", 42).Information("Hello from bar!"));
+            var sw = new StringWriter();
+            formatter.Format(evt, sw);
+            Assert.Equal("42 {Bar: 42}", sw.ToString());
+        }
     }
 }
