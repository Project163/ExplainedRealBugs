diff --git a/CHANGES.md b/CHANGES.md
index 4f1add7..25d19e1 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -13,6 +13,7 @@ Warning: this release introduces some changes which may break backwards compatib
 * [#77] Added: `MoreCollectors.filtering()/mapping()/flatMapping()` with default downstream Collector `toList()`.
 * [#79] Added: `iterate(seed, predicate, op)` for all stream types.
 * [#83] Changed: `StreamEx.of(Collection)`, `of(Iterator)`, etc. now use `? extends T` type instead of just `T`.
+* [#86] Added: `peekFirst()`, `peekLast()` for all stream types.
 
 
 ### 0.5.5
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 844f9c6..731e1f3 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -160,6 +160,7 @@ What I want | How to get it
 Peek only entry keys | `EntryStream.peekKeys()`
 Peek only entry values | `EntryStream.peekValues()`
 Peek entry keys and values using `BiConsumer` | `EntryStream.peekKeyValue()`
+Peek only first or last stream element | `any.peekFirst()/peekLast()`
 
 ### misc
 
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 7a19055..79edddb 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -285,6 +285,10 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      *
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
+     *
      * @param mapper a <a
      *        href="package-summary.html#NonInterference">non-interfering </a>,
      *        <a href="package-summary.html#Statelessness">stateless</a>
@@ -544,6 +548,73 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return new DoubleStreamEx(stream().peek(action), context);
     }
 
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public DoubleStreamEx peekFirst(DoubleConsumer action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that this method might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public DoubleStreamEx peekLast(DoubleConsumer action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
     @Override
     public DoubleStreamEx limit(long maxSize) {
         return new DoubleStreamEx(stream().limit(maxSize), context);
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 6548f47..5417e51 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -590,6 +590,73 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return new IntStreamEx(stream().peek(action), context);
     }
 
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public IntStreamEx peekFirst(IntConsumer action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that this method might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public IntStreamEx peekLast(IntConsumer action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
     @Override
     public IntStreamEx limit(long maxSize) {
         return new IntStreamEx(stream().limit(maxSize), context);
@@ -1737,6 +1804,10 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      *
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
+     *
      * @param mapper a <a
      *        href="package-summary.html#NonInterference">non-interfering </a>,
      *        <a href="package-summary.html#Statelessness">stateless</a>
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 9ae0294..5b29c13 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -352,6 +352,10 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      *
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
+     *
      * @param mapper a <a
      *        href="package-summary.html#NonInterference">non-interfering </a>,
      *        <a href="package-summary.html#Statelessness">stateless</a>
@@ -607,6 +611,73 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return new LongStreamEx(stream().peek(action), context);
     }
 
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public LongStreamEx peekFirst(LongConsumer action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that this method might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public LongStreamEx peekLast(LongConsumer action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+    
     @Override
     public LongStreamEx limit(long maxSize) {
         return new LongStreamEx(stream().limit(maxSize), context);
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index a4899b0..d152957 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -200,6 +200,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
+     * 
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
      *
      * @param mapper a <a
      *        href="package-summary.html#NonInterference">non-interfering </a>,
@@ -217,6 +221,73 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(new PairSpliterator.PSOfRef<>(lastMapper, notLastMapper, spliterator(), false), context);
     }
 
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public StreamEx<T> peekFirst(Consumer<? super T> action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that this method might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a <a href="package-summary.html#NonInterference">
+     *        non-interfering</a> action to perform on the first stream element
+     *        as it is consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public StreamEx<T> peekLast(Consumer<? super T> action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
     /**
      * Creates a new {@code EntryStream} populated from entries of maps produced
      * by supplied mapper function which is applied to the every element of this
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index ca1969e..aaea634 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -25,6 +25,7 @@ import java.util.Random;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.DoubleBinaryOperator;
 import java.util.function.DoubleFunction;
 import java.util.function.DoubleToIntFunction;
@@ -405,6 +406,40 @@ public class DoubleStreamExTest {
                 .mapLast(x -> x + 2.0).toArray(), 0.0);
     }
 
+    @Test
+    public void testPeekFirst() {
+        double[] input = {1, 10, 100, 1000};
+        
+        AtomicReference<Double> firstElement = new AtomicReference<>();
+        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray(), 0.0);
+        assertEquals(1, firstElement.get(), 0.0);
+
+        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray(), 0.0);
+        assertEquals(10, firstElement.get(), 0.0);
+        
+        firstElement.set(-1.0);
+        assertArrayEquals(new double[] {}, DoubleStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray(), 0.0);
+        assertEquals(-1, firstElement.get(), 0.0);
+    }
+    
+    @Test
+    public void testPeekLast() {
+        double[] input = {1, 10, 100, 1000};
+        AtomicReference<Double> lastElement = new AtomicReference<>();
+        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray(), 0.0);
+        assertNull(lastElement.get());
+
+        assertArrayEquals(new double[] { 1, 10, 100 }, DoubleStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray(), 0.0);
+        assertEquals(100, lastElement.get(), 0.0);
+        
+        assertArrayEquals(input, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray(), 0.0);
+        assertEquals(1000, lastElement.get(), 0.0);
+        
+        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray(), 0.0);
+        assertEquals(100, lastElement.get(), 0.0);
+    }
+    
     @Test
     public void testScanLeft() {
         assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index 56b8166..bfe8c8a 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -667,6 +667,40 @@ public class IntStreamExTest {
         });
     }
 
+    @Test
+    public void testPeekFirst() {
+        int[] input = {1, 10, 100, 1000};
+        
+        AtomicInteger firstElement = new AtomicInteger();
+        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
+        assertEquals(1, firstElement.get());
+
+        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
+        assertEquals(10, firstElement.get());
+        
+        firstElement.set(-1);
+        assertArrayEquals(new int[] {}, IntStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
+        assertEquals(-1, firstElement.get());
+    }
+    
+    @Test
+    public void testPeekLast() {
+        int[] input = {1, 10, 100, 1000};
+        AtomicInteger lastElement = new AtomicInteger(-1);
+        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
+        assertEquals(-1, lastElement.get());
+
+        assertArrayEquals(new int[] { 1, 10, 100 }, IntStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray());
+        assertEquals(100, lastElement.get());
+        
+        assertArrayEquals(input, IntStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
+        assertEquals(1000, lastElement.get());
+        
+        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
+        assertEquals(100, lastElement.get());
+    }
+    
     @Test
     public void testScanLeft() {
         assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10)
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index af8a7ce..5c43ab2 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -25,6 +25,7 @@ import java.util.Random;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.function.Function;
 import java.util.function.LongBinaryOperator;
 import java.util.function.LongConsumer;
@@ -505,6 +506,40 @@ public class LongStreamExTest {
             x -> x + 2L).toArray());
     }
 
+    @Test
+    public void testPeekFirst() {
+        long[] input = {1, 10, 100, 1000};
+        
+        AtomicLong firstElement = new AtomicLong();
+        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
+        assertEquals(1, firstElement.get());
+
+        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
+        assertEquals(10, firstElement.get());
+        
+        firstElement.set(-1);
+        assertArrayEquals(new long[] {}, LongStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
+        assertEquals(-1, firstElement.get());
+    }
+    
+    @Test
+    public void testPeekLast() {
+        long[] input = {1, 10, 100, 1000};
+        AtomicLong lastElement = new AtomicLong(-1);
+        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
+        assertEquals(-1, lastElement.get());
+
+        assertArrayEquals(new long[] { 1, 10, 100 }, LongStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray());
+        assertEquals(100, lastElement.get());
+        
+        assertArrayEquals(input, LongStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
+        assertEquals(1000, lastElement.get());
+        
+        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
+        assertEquals(100, lastElement.get());
+    }
+    
     @Test
     public void testScanLeft() {
         assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).scanLeft(Long::sum));
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 99dcba2..9ec1301 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -50,6 +50,7 @@ import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.function.IntPredicate;
@@ -1578,6 +1579,43 @@ public class StreamExTest {
             s.get().mapLastOrElse("|- "::concat, "\\- "::concat).joining("\n")));
     }
     
+    @Test
+    public void testPeekFirst() {
+        List<String> input = asList("A", "B", "C", "D");
+        streamEx(input::stream, s -> {
+            AtomicReference<String> firstElement = new AtomicReference<>();
+            assertEquals(asList("B", "C", "D"), s.get().peekFirst(firstElement::set).skip(1).toList());
+            assertEquals("A", firstElement.get());
+
+            assertEquals(asList("B", "C", "D"), s.get().skip(1).peekFirst(firstElement::set).toList());
+            assertEquals("B", firstElement.get());
+            
+            firstElement.set(null);
+            assertEquals(asList(), s.get().skip(4).peekFirst(firstElement::set).toList());
+            assertNull(firstElement.get());
+        });
+    }
+    
+    @Test
+    public void testPeekLast() {
+        List<String> input = asList("A", "B", "C", "D");
+        AtomicReference<String> lastElement = new AtomicReference<>();
+        assertEquals(asList("A", "B", "C"), StreamEx.of(input).peekLast(lastElement::set).limit(3).toList());
+        assertNull(lastElement.get());
+
+        assertEquals(input, StreamEx.of(input).peekLast(lastElement::set).limit(4).toList());
+        assertEquals("D", lastElement.get());
+        
+        assertEquals(asList("A", "B", "C"), StreamEx.of(input).limit(3).peekLast(lastElement::set).toList());
+        assertEquals("C", lastElement.get());
+        
+        lastElement.set(null);
+        assertEquals(2L, StreamEx.of(input).peekLast(lastElement::set).indexOf("C").getAsLong());
+        assertNull(lastElement.get());
+        assertEquals(3L, StreamEx.of(input).peekLast(lastElement::set).indexOf("D").getAsLong());
+        assertEquals("D", lastElement.get());
+    }
+    
     @Test
     public void testSplit() {
         assertFalse(StreamEx.split("str", "abcd").spliterator().getClass().getSimpleName().endsWith(
