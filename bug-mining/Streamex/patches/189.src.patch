diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 28c4a45..c3a144c 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -1677,7 +1677,24 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         }
         return supply(new AbstractStreamEx.TDOfRef<>(spliterator(), true, false, predicate));
     }
+    
+    public S prefix(BinaryOperator<T> op) {
+        Spliterator<T> spltr = spliterator();
+        return supply(new PrefixOps.OfRef<>(spltr, op));
+    }
+
+    public S prefix2(BinaryOperator<T> op) {
+        Spliterator<T> spltr = spliterator();
+        return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
+                : new PrefixOps.OfUnordRef<>(spltr, op));
+    }
 
+    public S prefix3(BinaryOperator<T> op) {
+        Spliterator<T> spltr = spliterator();
+        return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
+                : new PrefixOps.OfUnordRef3<>(spltr, op));
+    }
+    
     // Necessary to generate proper JavaDoc
     @SuppressWarnings("unchecked")
     @Override
diff --git a/src/main/java/one/util/streamex/PrefixOps.java b/src/main/java/one/util/streamex/PrefixOps.java
new file mode 100644
index 0000000..b01e65f
--- /dev/null
+++ b/src/main/java/one/util/streamex/PrefixOps.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import static one.util.streamex.StreamExInternals.*;
+
+import java.util.Spliterator;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
+
+import one.util.streamex.StreamExInternals.CloneableSpliterator;
+
+/**
+ * @author Tagir Valeev
+ */
+/* package */ abstract class PrefixOps<T, S extends Spliterator<T>> extends CloneableSpliterator<T, PrefixOps<T, S>>{
+    S source;
+    AtomicReference<T> accRef;
+    T acc = none();
+    
+    PrefixOps(S source) {
+        this.source = source;
+    }
+    
+    @Override
+    public Spliterator<T> trySplit() {
+        if(acc != NONE) {
+            return null;
+        }
+        @SuppressWarnings("unchecked")
+        S prefix = (S) source.trySplit();
+        if(prefix == null) {
+            return null;
+        }
+        if(accRef == null) {
+            accRef = new AtomicReference<>(none());
+        }
+        PrefixOps<T, S> pref = doClone();
+        pref.source = prefix;
+        return pref;
+    }
+
+    @Override
+    public long estimateSize() {
+        return source.estimateSize();
+    }
+
+    @Override
+    public int characteristics() {
+        return source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | SUBSIZED);
+    }
+
+    static final class OfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
+        private final BinaryOperator<T> op;
+        private final Spliterator<T> source;
+        private T acc = none();
+
+        OfRef(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED));
+            this.source = source;
+            this.op = op;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if(!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            source.forEachRemaining(next -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+
+        @Override
+        public void accept(T next) {
+            acc = acc == NONE ? next : op.apply(acc, next);
+        }
+    }
+    
+    static final class OfUnordRef<T> extends PrefixOps<T, Spliterator<T>> {
+        private final BinaryOperator<T> op;
+
+        OfUnordRef(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source);
+            this.op = (a, b) -> a == NONE ? b : op.apply(a, b);
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            Box<T> box = new Box<>();
+            if(!source.tryAdvance(box)) {
+                return false;
+            }
+            if(accRef == null) {
+                action.accept(acc = op.apply(acc, box.a));
+            } else {
+                action.accept(accRef.accumulateAndGet(box.a, op));
+            }
+            return true;
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if(accRef == null) {
+                source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
+            } else {
+                source.forEachRemaining(next -> action.accept(accRef.accumulateAndGet(next, op)));
+            }
+        }
+    }
+    
+    static final class OfUnordRef3<T> extends PrefixOps<T, Spliterator<T>> {
+        private static final int BUF_SIZE = 128;
+        
+        private final BinaryOperator<T> op;
+        private final BinaryOperator<T> localOp;
+        private final T[] buf;
+        private int idx = 0;
+        
+        @SuppressWarnings("unchecked")
+        OfUnordRef3(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source);
+            this.buf = (T[]) new Object[BUF_SIZE];
+            this.op = (a, b) -> a == NONE ? b : op.apply(a, b);
+            this.localOp = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            Box<T> box = new Box<>();
+            if(!source.tryAdvance(box)) {
+                return false;
+            }
+            if(accRef == null) {
+                action.accept(acc = op.apply(acc, box.a));
+            } else {
+                action.accept(accRef.accumulateAndGet(box.a, op));
+            }
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if(accRef == null) {
+                source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
+            } else {
+                source.forEachRemaining(next -> {
+                    if(idx == 0) {
+                        buf[idx++] = next;
+                    } else {
+                        T prev = buf[idx-1];
+                        buf[idx++] = localOp.apply(prev, next);
+                        if(idx == buf.length) {
+                            drain(action);
+                            idx = 0;
+                        }
+                    }
+                });
+                if(idx > 0)
+                    drain(action);
+            }
+        }
+
+        private void drain(Consumer<? super T> action) {
+            T last = buf[idx-1];
+            T acc = accRef.getAndAccumulate(last, op);
+            if(acc != NONE) {
+                for(int i=0; i<idx; i++) {
+                    action.accept(localOp.apply(buf[i], acc));
+                }
+            } else {
+                for(int i=0; i<idx; i++) {
+                    action.accept(buf[i]);
+                }
+            }
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index e1e8b7e..d6a9968 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1775,4 +1775,40 @@ public class StreamExTest {
         assertEquals(asList("six"), fromQueue(queue, "STOP").toList());
         assertEquals(asList(), fromQueue(queue, "STOP").toList());
     }
+
+    @Test
+    public void testPrefix() {
+        List<String> input = asList("a", "b", "c", "d", "e");
+        streamEx(input::stream, s -> assertEquals(asList("a", "ab", "abc", "abcd", "abcde"), s.get().prefix(
+            String::concat).toList()));
+        streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix(String::concat).findFirst(
+            str -> str.length() > 3)));
+
+        streamEx(input::stream, s -> assertEquals(asList("a", "ab", "abc", "abcd", "abcde"), s.get().prefix2(
+            String::concat).toList()));
+        streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix2(String::concat).findFirst(
+            str -> str.length() > 3)));
+
+        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(new HashSet<>(asList("a", "aa", "aaa", "aaaa",
+            "aaaaa")), s.get().prefix2(String::concat).toSet()));
+        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(Optional.of("aaaaa"), s.get().prefix2(
+            String::concat).findFirst(str -> str.length() > 4)));
+        
+        streamEx(input::stream, s -> assertEquals(asList("a", "ab", "abc", "abcd", "abcde"), s.get().prefix3(
+            String::concat).toList()));
+        streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix3(String::concat).findFirst(
+            str -> str.length() > 3)));
+        
+        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(new HashSet<>(asList("a", "aa", "aaa", "aaaa",
+                "aaaaa")), s.get().prefix3(String::concat).toSet()));
+        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(Optional.of("aaaaa"), s.get().prefix3(
+            String::concat).findFirst(str -> str.length() > 4)));
+        
+        streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
+            (long) s.get().prefix(Long::sum).reduce(0L, Long::sum)));
+        streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
+            (long) s.get().prefix2(Long::sum).reduce(0L, Long::sum)));
+        streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
+            (long) s.get().prefix3(Long::sum).reduce(0L, Long::sum)));
+    }
 }
