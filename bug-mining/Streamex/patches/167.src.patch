diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 4f7493d..8a5c832 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -49,6 +49,7 @@ import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.BiPredicate;
 import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -1721,10 +1722,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the wrapped stream
      */
     public static <T> StreamEx<T> of(Stream<T> stream) {
-        if(stream instanceof AbstractStreamEx) {
+        if (stream instanceof AbstractStreamEx) {
             @SuppressWarnings("unchecked")
-            AbstractStreamEx<T, ?> ase = (AbstractStreamEx<T, ?>)stream;
-            if(ase.spliterator != null)
+            AbstractStreamEx<T, ?> ase = (AbstractStreamEx<T, ?>) stream;
+            if (ase.spliterator != null)
                 return new StreamEx<>(ase.spliterator(), ase.context);
             return new StreamEx<>(ase.stream(), ase.context);
         }
@@ -2591,4 +2592,107 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             return of(identity);
         return of(new CrossSpliterator.Reducing<>(Collections.nCopies(n, source), identity, accumulator));
     }
+
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using {@link StreamEx#iterate(Object, UnaryOperator)}
+     * or {@link StreamEx#generate(Supplier)}. For example, the following method
+     * generates a Collatz sequence starting from given number:
+     * 
+     * <pre>{@code
+     * public static Emitter<Integer> collatz(int start) {
+     *    return action -> {
+     *       action.accept(start);
+     *       return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
+     *    };
+     * }}</pre>
+     * 
+     * <p>
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * 
+     * @author Tagir Valeev
+     *
+     * @param <T> the type of the elements this emitter emits
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface Emitter<T> {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * the returns the next emitter which will emit more, or null if nothing
+         * more to emit.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param cons consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        Emitter<T> next(Consumer<? super T> cons);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator<T> spliterator() {
+            return new Spliterators.AbstractSpliterator<T>(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE) {
+                Emitter<T> e = Emitter.this;
+                Spliterator<T> buf;
+
+                @Override
+                public boolean tryAdvance(Consumer<? super T> action) {
+                    if (!fillBuf())
+                        return false;
+                    while (!buf.tryAdvance(action)) {
+                        buf = null;
+                        if (!fillBuf())
+                            return false;
+                    }
+                    return true;
+                }
+
+                @Override
+                public void forEachRemaining(Consumer<? super T> action) {
+                    if (buf != null) {
+                        buf.forEachRemaining(action);
+                        buf = null;
+                    }
+                    Emitter<T> e = this.e;
+                    this.e = null;
+                    while (e != null)
+                        e = e.next(action);
+                }
+
+                private boolean fillBuf() {
+                    while (buf == null) {
+                        if (e == null)
+                            return false;
+                        Builder<T> b = Stream.builder();
+                        Emitter<T> next = e.next(b);
+                        buf = b.build().spliterator();
+                        e = next;
+                    }
+                    return true;
+                }
+            };
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default StreamEx<T> stream() {
+            return of(spliterator());
+        }
+    }
 }
diff --git a/src/test/java/one/util/streamex/StreamExEmitterTest.java b/src/test/java/one/util/streamex/StreamExEmitterTest.java
new file mode 100644
index 0000000..7805561
--- /dev/null
+++ b/src/test/java/one/util/streamex/StreamExEmitterTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import static org.junit.Assert.*;
+import static java.util.Arrays.asList;
+
+import java.util.Scanner;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
+
+import one.util.streamex.StreamEx.Emitter;
+
+import org.junit.Test;
+
+/**
+ * @author Tagir Valeev
+ */
+public class StreamExEmitterTest {
+    public static <T> Emitter<T> generate(Supplier<T> supplier) {
+        return new Emitter<T>() {
+            @Override
+            public Emitter<T> next(Consumer<? super T> action) {
+                action.accept(supplier.get());
+                return this;
+            }
+        };
+    }
+
+    public static <T> Emitter<T> iterate(T seed, Predicate<? super T> test, UnaryOperator<T> op) {
+        return test.test(seed) ? action -> {
+            action.accept(seed);
+            return iterate(op.apply(seed), test, op);
+        } : null;
+    }
+
+    public static Emitter<Integer> collatz(int start) {
+        return action -> {
+            action.accept(start);
+            return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
+        };
+    }
+    
+    public static Emitter<Integer> scannerInts(Scanner sc) {
+        return sc.hasNextInt() ? action -> {
+            action.accept(sc.nextInt());
+            return scannerInts(sc);
+        } : null;
+    }
+
+    @Test
+    public void testEmitter() {
+        assertEquals(asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17).stream().toList());
+        assertTrue(collatz(17).stream().has(1));
+        assertEquals(asList(4, 4, 4, 4, 4), generate(() -> 4).stream().limit(5).toList());
+        assertEquals(asList(1, 2, 3, 4, 5, 6, 7, 8, 9), iterate(1, x -> x < 10, x -> x + 1).stream().toList());
+        Scanner sc = new Scanner("1 2 3 4 test");
+        assertEquals(asList(1, 2, 3, 4), scannerInts(sc).stream().toList());
+        assertEquals("test", sc.next());
+    }
+}
