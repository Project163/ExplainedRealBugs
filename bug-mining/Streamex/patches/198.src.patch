diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 24d80f3..e3b2b66 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -1800,16 +1800,6 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return ofPairs(Arrays.asList(array));
     }
 
-    static <T> Stream<Entry<Integer, T>> flatTraverse(Stream<Entry<Integer, T>> src,
-            BiFunction<Integer, T, Stream<T>> streamProvider) {
-        return src.flatMap(entry -> {
-            Integer depth = entry.getKey();
-            Stream<T> result = streamProvider.apply(depth, entry.getValue());
-            return result == null ? Stream.of(entry) : Stream.concat(Stream.of(entry), flatTraverse(result
-                    .map(t -> new ObjIntBox<>(t, depth + 1)), streamProvider));
-        });
-    }
-
     /**
      * Return a new {@link EntryStream} containing all the nodes of tree-like
      * data structure in entry values along with the corresponding tree depths
@@ -1831,10 +1821,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @see #ofTree(Object, Class, BiFunction)
      */
     public static <T> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, Stream<T>> mapper) {
-        Stream<T> rootStream = mapper.apply(0, root);
-        Stream<Entry<Integer, T>> base = Stream.of(new ObjIntBox<>(root, 0));
-        return rootStream == null ? of(base) : of(flatTraverse(rootStream.map(t -> new ObjIntBox<>(t, 1)), mapper))
-                .prepend(base);
+        TreeSpliterator<T, Entry<Integer, T>> spliterator = new TreeSpliterator.Depth<>(root, mapper);
+        return new EntryStream<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator::close));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1e41031..47d2674 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -103,13 +103,6 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(spliterator, context);
     }
 
-    private static <T> StreamEx<T> flatTraverse(Stream<T> src, Function<T, Stream<T>> streamProvider) {
-        return StreamEx.of(src).flatMap(t -> {
-            Stream<T> result = streamProvider.apply(t);
-            return result == null ? Stream.of(t) : flatTraverse(result, streamProvider).prepend(t);
-        });
-    }
-
     /**
      * Returns a stream consisting of the elements of this stream which are
      * instances of given class.
@@ -2616,7 +2609,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #ofTree(Object, Class, Function)
      */
     public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
-        TreeSpliterator<T> spliterator = new TreeSpliterator<>(root, mapper);
+        TreeSpliterator<T, T> spliterator = new TreeSpliterator.Plain<>(root, mapper);
         return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator::close));
     }
 
diff --git a/src/main/java/one/util/streamex/TreeSpliterator.java b/src/main/java/one/util/streamex/TreeSpliterator.java
index 0a8047d..93d5bb3 100644
--- a/src/main/java/one/util/streamex/TreeSpliterator.java
+++ b/src/main/java/one/util/streamex/TreeSpliterator.java
@@ -15,53 +15,51 @@
  */
 package one.util.streamex;
 
+import java.util.AbstractMap;
 import java.util.ArrayList;
-import java.util.List;
+import java.util.Collections;
+import java.util.List;import java.util.Map.Entry;
 import java.util.Spliterator;
+import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
 import one.util.streamex.StreamExInternals.PairBox;
 
+import static one.util.streamex.StreamExInternals.*;
+
 /**
  * @author Tagir Valeev
  *
  */
-/* package */ class TreeSpliterator<T> implements Spliterator<T>, Consumer<T> {
-    private T cur;
-    private ArrayList<PairBox<Spliterator<T>, Stream<T>>> spliterators; 
-    private final Function<T, Stream<T>> mapper;
+/* package */ abstract class TreeSpliterator<T, U> implements Spliterator<U>, Consumer<T> {
+    T cur;
+    List<PairBox<Spliterator<T>, Stream<T>>> spliterators; 
 
-    TreeSpliterator(T root, Function<T, Stream<T>> mapper) {
+    TreeSpliterator(T root) {
         this.cur = root;
-        this.mapper = mapper;
     }
-
-    @Override
-    public boolean tryAdvance(Consumer<? super T> action) {
+    
+    boolean advance() {
         List<PairBox<Spliterator<T>, Stream<T>>> spltrs = spliterators;
         if(spltrs == null) {
             spliterators = new ArrayList<>();
-            return processOne(action);
+            return true;
         }
-        int lastIdx = spltrs.size()-1;
-        while(lastIdx >= 0) {
+        for(int lastIdx = spltrs.size()-1; lastIdx >= 0; lastIdx--) {
             PairBox<Spliterator<T>, Stream<T>> pair = spltrs.get(lastIdx);
             Spliterator<T> spltr = pair.a;
             if(spltr.tryAdvance(this)) {
-                return processOne(action);
+                return true;
             }
             pair.b.close();
-            spltrs.remove(lastIdx--);
+            spltrs.remove(lastIdx);
         }
         return false;
     }
 
-    private boolean processOne(Consumer<? super T> action) {
-        T e = this.cur;
-        action.accept(e);
-        Stream<T> stream = mapper.apply(e);
+    boolean append(Stream<T> stream) {
         if(stream != null) {
             spliterators.add(new PairBox<>(stream.spliterator(), stream));
         }
@@ -69,41 +67,11 @@ import one.util.streamex.StreamExInternals.PairBox;
     }
 
     @Override
-    public Spliterator<T> trySplit() {
-        // TODO Auto-generated method stub
+    public Spliterator<U> trySplit() {
+        // TODO Support parallelization (at least for one level)
         return null;
     }
     
-    static class Acceptor<T> implements Consumer<T> {
-        private final Consumer<? super T> action;
-        private final Function<T, Stream<T>> mapper;
-        
-        public Acceptor(Consumer<? super T> action, Function<T, Stream<T>> mapper) {
-            super();
-            this.action = action;
-            this.mapper = mapper;
-        }
-
-        @Override
-        public void accept(T t) {
-            action.accept(t);
-            try(Stream<T> stream = mapper.apply(t)) {
-                if(stream != null) {
-                    stream.spliterator().forEachRemaining(this);
-                }
-            }
-        }
-    }
-    
-    @Override
-    public void forEachRemaining(Consumer<? super T> action) {
-        if(spliterators != null) {
-            Spliterator.super.forEachRemaining(action);
-        } else {
-            new Acceptor<>(action, mapper).accept(cur);
-        }
-    }
-
     @Override
     public long estimateSize() {
         return Long.MAX_VALUE;
@@ -138,4 +106,104 @@ import one.util.streamex.StreamExInternals.PairBox;
                 throw (Error)t;
         }
     }
+    
+    static class Acceptor<T> implements Consumer<T> {
+        private final Consumer<? super T> action;
+        private final Function<T, Stream<T>> mapper;
+        
+        public Acceptor(Consumer<? super T> action, Function<T, Stream<T>> mapper) {
+            this.action = action;
+            this.mapper = mapper;
+        }
+    
+        @Override
+        public void accept(T t) {
+            action.accept(t);
+            try(Stream<T> stream = mapper.apply(t)) {
+                if(stream != null) {
+                    stream.spliterator().forEachRemaining(this);
+                }
+            }
+        }
+    }
+
+    static class Plain<T> extends TreeSpliterator<T, T> {
+        private final Function<T, Stream<T>> mapper;
+
+        Plain(T root, Function<T, Stream<T>> mapper) {
+            super(root);
+            this.mapper = mapper;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if(!advance())
+                return false;
+            T e = this.cur;
+            action.accept(e);
+            return append(mapper.apply(e));
+        }
+    
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if(spliterators != null) {
+                super.forEachRemaining(action);
+            } else {
+                spliterators = Collections.emptyList();
+                new Acceptor<>(action, mapper).accept(cur);
+            }
+        }
+    }
+    
+    static class DepthAcceptor<T> implements Consumer<T> {
+        private final Consumer<? super Entry<Integer, T>> action;
+        private final BiFunction<Integer, T, Stream<T>> mapper;
+        private Integer depth = 0;
+        
+        public DepthAcceptor(Consumer<? super Entry<Integer, T>> action, BiFunction<Integer, T, Stream<T>> mapper) {
+            this.action = action;
+            this.mapper = mapper;
+        }
+    
+        @Override
+        public void accept(T t) {
+            action.accept(new AbstractMap.SimpleImmutableEntry<>(depth, t));
+            try(Stream<T> stream = mapper.apply(depth, t)) {
+                if(stream != null) {
+                    depth++;
+                    stream.spliterator().forEachRemaining(this);
+                    depth--;
+                }
+            }
+        }
+    }
+
+    static class Depth<T> extends TreeSpliterator<T, Entry<Integer, T>> {
+        private final BiFunction<Integer, T, Stream<T>> mapper;
+
+        Depth(T root, BiFunction<Integer, T, Stream<T>> mapper) {
+            super(root);
+            this.mapper = mapper;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super Entry<Integer, T>> action) {
+            if(!advance())
+                return false;
+            T e = this.cur;
+            int depth = spliterators.size();
+            action.accept(new ObjIntBox<>(e, depth));
+            return append(mapper.apply(depth, e));
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super Entry<Integer, T>> action) {
+            if(spliterators != null) {
+                super.forEachRemaining(action);
+            } else {
+                spliterators = Collections.emptyList();
+                new DepthAcceptor<>(action, mapper).accept(cur);
+            }
+        }
+    }
 }
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 8001214..036c7b2 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -31,6 +31,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
 import java.util.Map.Entry;
 import java.util.SortedMap;
 import java.util.TreeMap;
@@ -575,10 +576,32 @@ public class EntryStreamTest {
         entryStream(base, supplier -> assertEquals("{1=[aa, ggg], 2=[ddd], 3=[bbbb, cc, e, fff]}", supplier.get()
                 .selectValues(String.class).grouping(TreeMap::new).toString()));
 
+        Set<Integer> set = new HashSet<>();
+        try(EntryStream<Integer, String> stream = EntryStream.ofTree("", (Integer depth, String str) -> depth >= 3 ? null : Stream.of("a", "b")
+                .map(str::concat).onClose(() -> set.add(depth)))) {
+            assertEquals(15, stream.count());
+        }
+        assertEquals(StreamEx.of(0, 1, 2).toSet(), set);
+        boolean catched = false;
+        try(EntryStream<Integer, String> stream = EntryStream.ofTree("", (Integer depth, String str) -> depth >= 3 ? null : Stream.of("a", "b")
+                .map(str::concat).onClose(() -> {throw new IllegalArgumentException(String.valueOf(depth));}))) {
+            stream.count();
+        }
+        catch(IllegalArgumentException iae) {
+            catched = true;
+            assertEquals("2", iae.getMessage());
+            assertEquals(2, iae.getSuppressed().length);
+            assertEquals("1", iae.getSuppressed()[0].getMessage());
+            assertEquals("0", iae.getSuppressed()[1].getMessage());
+        }
+        assertTrue(catched);
+        
         entryStream(() -> EntryStream.ofTree("", (Integer depth, String str) -> depth >= 3 ? null : Stream.of("a", "b")
                 .map(str::concat)), supplier -> {
             assertEquals(asList("", "a", "aa", "aaa", "aab", "ab", "aba", "abb", "b", "ba", "baa", "bab", "bb", "bba",
                 "bbb"), supplier.get().values().toList());
+            assertTrue(supplier.get().values().has("bbb"));
+            assertFalse(supplier.get().values().has("ccc"));
             assertEquals(asList("a", "b", "aa", "ab", "ba", "bb", "aaa", "aab", "aba", "abb", "baa", "bab", "bba",
                 "bbb"), supplier.get().sorted(Entry.comparingByKey()).values().without("").toList());
         });
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 21344f4..d7b692b 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -972,6 +972,8 @@ public class StreamExTest {
             assertEquals(Optional.empty(), s.get().findFirst(tn -> tn.title.contains("C1")).map(tn -> tn.title));
         });
         
+        r.flatStream().close(); // should not fail
+        
         List<Consumer<StreamEx<TreeNode>>> tests = Arrays.<Consumer<StreamEx<TreeNode>>>asList(
             stream -> assertEquals(Optional.empty(), stream.findFirst(tn -> tn.title.contains("abc"))),
             stream -> assertEquals(Optional.of("grandB1"), stream.findFirst(tn -> tn.title.contains("B1")).map(tn -> tn.title)),
@@ -1018,7 +1020,7 @@ public class StreamExTest {
             }
             assertTrue(catched);
         }
-
+        
         streamEx(() -> StreamEx.ofTree("", (String str) -> str.length() >= 3 ? null : Stream.of("a", "b").map(
             str::concat)), supplier -> {
             assertEquals(Arrays.asList("", "a", "aa", "aaa", "aab", "ab", "aba", "abb", "b", "ba", "baa", "bab", "bb",
diff --git a/src/test/java/one/util/streamex/TreeSpliteratorTest.java b/src/test/java/one/util/streamex/TreeSpliteratorTest.java
new file mode 100644
index 0000000..d3eb228
--- /dev/null
+++ b/src/test/java/one/util/streamex/TreeSpliteratorTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map.Entry;
+import java.util.stream.Stream;
+
+import org.junit.Test;
+
+import static one.util.streamex.TestHelpers.*;
+
+/**
+ * @author Tagir Valeev
+ *
+ */
+public class TreeSpliteratorTest {
+    @Test
+    public void testPlainSpliterator() {
+        List<String> expected = Arrays.asList("", "a", "aa", "aaa", "aaaa", "aaab", "aab", "aaba", "aabb", "ab", "aba",
+            "abaa", "abab", "abb", "abba", "abbb", "b", "ba", "baa", "baaa", "baab", "bab", "baba", "babb", "bb", "bba",
+            "bbaa", "bbab", "bbb", "bbba", "bbbb");
+        checkSpliterator("tree", expected, () -> new TreeSpliterator.Plain<>("", s -> s.length() == 4 ? null
+                : Stream.of("a", "b").map(s::concat)));
+    }
+
+    @Test
+    public void testDepthSpliterator() {
+        List<Entry<Integer, String>> expected = StreamEx.of("", "a", "aa", "ab", "ac", "b", "ba", "bb", "bc", "c",
+            "ca", "cb", "cc").mapToEntry(String::length).invert().toList();
+        checkSpliterator("tree", expected, () -> new TreeSpliterator.Depth<>("", (depth, s) -> depth == 2 ? null
+                : Stream.of("a", "b", "c").map(s::concat)));
+    }
+}
