diff --git a/CHANGES.md b/CHANGES.md
index 602bdaa..675ac6b 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -3,6 +3,8 @@
 ### 0.5.2
 * [#19] Optimized: pairMap and forPairs may work faster now, especially in the presence of upstream intermediate operations.
 * [#42] Added: `EntryStream.ofTree` methods to stream the tree-like structure tracking nodes depth.
+* [#46] Optimized: parallel performance of all `of(Iterator)` methods.
+* [#3] Optimized: parallel performance of `StreamEx.ofLines` as well as `StreamEx.split`
 
 ### 0.5.1
 
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index a3f1b50..8578751 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1670,7 +1670,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see BufferedReader#lines()
      */
     public static StreamEx<String> ofLines(BufferedReader reader) {
-        return of(reader.lines());
+        return of(UnknownSizeSpliterator.optimize(reader.lines()));
     }
 
     /**
@@ -1705,8 +1705,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static StreamEx<String> ofLines(Reader reader) {
         if (reader instanceof BufferedReader)
-            return of(((BufferedReader) reader).lines());
-        return of(new BufferedReader(reader).lines());
+            return ofLines((BufferedReader) reader);
+        return of(UnknownSizeSpliterator.optimize(new BufferedReader(reader).lines()));
     }
 
     /**
@@ -1738,7 +1738,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Files#lines(Path)
      */
     public static StreamEx<String> ofLines(Path path) throws IOException {
-        return of(Files.lines(path));
+        return of(UnknownSizeSpliterator.optimize(Files.lines(path)));
     }
 
     /**
@@ -1774,7 +1774,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.0
      */
     public static StreamEx<String> ofLines(Path path, Charset charset) throws IOException {
-        return of(Files.lines(path, charset));
+        return of(UnknownSizeSpliterator.optimize(Files.lines(path, charset)));
     }
 
     /**
@@ -1910,7 +1910,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public static StreamEx<String> split(CharSequence str, Pattern pattern) {
         if (str.length() == 0)
             return of("");
-        return of(pattern.splitAsStream(str));
+        return of(UnknownSizeSpliterator.optimize(pattern.splitAsStream(str)));
     }
 
     /**
@@ -1947,7 +1947,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
                 return split(str, ch);
             }
         }
-        return of(Pattern.compile(regex).splitAsStream(str));
+        return of(UnknownSizeSpliterator.optimize(Pattern.compile(regex).splitAsStream(str)));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
index 8a8f5f0..fa05985 100644
--- a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
+++ b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
@@ -1,5 +1,9 @@
 package one.util.streamex;
 
+import java.lang.reflect.Field;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Iterator;
 import java.util.PrimitiveIterator;
 import java.util.Spliterator;
@@ -7,17 +11,65 @@ import java.util.function.Consumer;
 import java.util.function.DoubleConsumer;
 import java.util.function.IntConsumer;
 import java.util.function.LongConsumer;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 /* package */abstract class UnknownSizeSpliterator<T, S extends UnknownSizeSpliterator<? extends T, S, I>, I extends Iterator<? extends T>>
         implements Spliterator<T> {
     static final int BATCH_UNIT = 1 << 10; // batch array size increment
     static final int MAX_BATCH = 1 << 25; // max batch array size;
 
+    private static Field SOURCE_SPLITERATOR;
+    private static Field SPLITERATOR_ITERATOR;
+
+    static {
+        try {
+            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {
+                SOURCE_SPLITERATOR = Class.forName("java.util.stream.AbstractPipeline").getDeclaredField(
+                    "sourceSpliterator");
+                SOURCE_SPLITERATOR.setAccessible(true);
+                SPLITERATOR_ITERATOR = Class.forName("java.util.Spliterators$IteratorSpliterator").getDeclaredField(
+                    "it");
+                SPLITERATOR_ITERATOR.setAccessible(true);
+                return null;
+            });
+        } catch (PrivilegedActionException e) {
+        }
+    }
+
+    /**
+     * Optimize the stream created on IteratorSpliterator replacing it with
+     * UnknownSizeSpliterator.
+     * 
+     * @param stream
+     *            original stream
+     * @return either original or optimized stream
+     */
+    @SuppressWarnings("unchecked")
+    static <T> Stream<T> optimize(Stream<T> stream) {
+        if (SOURCE_SPLITERATOR == null || SPLITERATOR_ITERATOR == null)
+            return stream;
+        Iterator<T> it = null;
+        try {
+            Spliterator<T> spliterator = (Spliterator<T>) SOURCE_SPLITERATOR.get(stream);
+            if (spliterator != null && !spliterator.hasCharacteristics(SIZED)
+                && spliterator.getClass().getName().equals("java.util.Spliterators$IteratorSpliterator")) {
+                it = (Iterator<T>) SPLITERATOR_ITERATOR.get(spliterator);
+            }
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            // ignore
+        }
+        if (it == null)
+            return stream;
+        stream.spliterator(); // consume stream
+        return StreamSupport.stream(new USOfRef<>(it), stream.isParallel()).onClose(stream::close);
+    }
+
     I it;
     int index, fence;
     long est = Long.MAX_VALUE;
 
-    public UnknownSizeSpliterator(I iterator) {
+    UnknownSizeSpliterator(I iterator) {
         this.it = iterator;
     }
 
@@ -70,9 +122,9 @@ import java.util.function.LongConsumer;
                 int n = getN();
                 Object[] a = new Object[n];
                 int j = 0;
-                do {
-                    a[j] = i.next();
-                } while (++j < n && i.hasNext());
+                while(i.hasNext() && j < n) {
+                    a[j++] = i.next();
+                }
                 fence = j;
                 if (i.hasNext()) {
                     return correctSize(new USOfRef<>(a, 0, j));
@@ -143,9 +195,9 @@ import java.util.function.LongConsumer;
                 int n = getN();
                 int[] a = new int[n];
                 int j = 0;
-                do {
-                    a[j] = i.next();
-                } while (++j < n && i.hasNext());
+                while(i.hasNext() && j < n) {
+                    a[j++] = i.next();
+                }
                 fence = j;
                 if (i.hasNext()) {
                     return correctSize(new USOfInt(a, 0, j));
@@ -212,9 +264,9 @@ import java.util.function.LongConsumer;
                 int n = getN();
                 long[] a = new long[n];
                 int j = 0;
-                do {
-                    a[j] = i.next();
-                } while (++j < n && i.hasNext());
+                while(i.hasNext() && j < n) {
+                    a[j++] = i.next();
+                }
                 fence = j;
                 if (i.hasNext()) {
                     return correctSize(new USOfLong(a, 0, j));
@@ -281,9 +333,9 @@ import java.util.function.LongConsumer;
                 int n = getN();
                 double[] a = new double[n];
                 int j = 0;
-                do {
-                    a[j] = i.next();
-                } while (++j < n && i.hasNext());
+                while(i.hasNext() && j < n) {
+                    a[j++] = i.next();
+                }
                 fence = j;
                 if (i.hasNext()) {
                     return correctSize(new USOfDouble(a, 0, j));
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index 10bb390..0ace6d3 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -74,6 +74,8 @@ public class DoubleStreamExTest {
             DoubleStreamEx.of(Spliterators.spliterator(new double[] { 1, 5, 3 }, 0)).toArray(), 0.0);
         assertArrayEquals(new double[] { 1, 5, 3 },
             DoubleStreamEx.of(Spliterators.iterator(Spliterators.spliterator(new double[] { 1, 5, 3 }, 0))).toArray(), 0.0);
+        assertArrayEquals(new double[0], DoubleStreamEx
+                .of(Spliterators.iterator(Spliterators.emptyDoubleSpliterator())).parallel().toArray(), 0.0);
         
         assertArrayEquals(new double[] { 2, 4, 6 }, DoubleStreamEx.of(new Double[] { 2.0, 4.0, 6.0 }).toArray(), 0.0);
     }
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index 2033510..4623059 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -89,6 +89,8 @@ public class IntStreamExTest {
                 .toArray());
         assertArrayEquals(new int[] { 1, 5, 3 },
             IntStreamEx.of(Spliterators.iterator(Spliterators.spliterator(new int[] { 1, 5, 3 }, 0))).toArray());
+        assertArrayEquals(new int[0], IntStreamEx.of(Spliterators.iterator(Spliterators.emptyIntSpliterator()))
+                .parallel().toArray());
 
         BitSet bs = new BitSet();
         bs.set(1);
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index cd98585..b905a50 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -78,6 +78,8 @@ public class LongStreamExTest {
                 .toArray());
         assertArrayEquals(new long[] { 1, 5, 3 },
             LongStreamEx.of(Spliterators.iterator(Spliterators.spliterator(new long[] { 1, 5, 3 }, 0))).toArray());
+        assertArrayEquals(new long[0], LongStreamEx.of(Spliterators.iterator(Spliterators.emptyLongSpliterator()))
+            .parallel().toArray());
         
         assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.of(new Long[] { 2L, 4L, 6L }).toArray());
     }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index e6fd409..a80bb3f 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -109,6 +109,8 @@ public class StreamExTest {
 
         assertEquals(asList("a", "b"), StreamEx.of(asList("a", "b").spliterator()).toList());
         assertEquals(asList("a", "b"), StreamEx.of(asList("a", "b").iterator()).toList());
+        assertEquals(asList(), StreamEx.of(asList().iterator()).toList());
+        assertEquals(asList(), StreamEx.of(asList().iterator()).parallel().toList());
         assertEquals(asList("a", "b"), StreamEx.of(new Vector<>(asList("a", "b")).elements()).toList());
     }
 
@@ -140,6 +142,8 @@ public class StreamExTest {
 
         assertEquals(expectedSet, StreamEx.ofLines(new StringReader(input)).parallel().skipOrdered(1).toSet());
         assertEquals(expectedSet, StreamEx.ofLines(new StringReader(input)).skipOrdered(1).parallel().toSet());
+        
+        assertFalse(StreamEx.ofLines(new StringReader(input)).spliterator().getClass().getSimpleName().endsWith("IteratorSpliterator"));
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -1513,6 +1517,10 @@ public class StreamExTest {
 
     @Test
     public void testSplit() {
+        assertFalse(StreamEx.split("str", "abcd").spliterator().getClass().getSimpleName()
+                .endsWith("IteratorSpliterator"));
+        assertFalse(StreamEx.split("str", Pattern.compile("abcd")).spliterator().getClass().getSimpleName()
+                .endsWith("IteratorSpliterator"));
         streamEx(() -> StreamEx.split("", "abcd"), s -> assertEquals(1, s.get().count()));
         streamEx(() -> StreamEx.split("", Pattern.compile("abcd")), s -> assertEquals(1, s.get().count()));
         streamEx(() -> StreamEx.split("ab.cd...", '.'), s -> assertEquals("ab|cd", s.get().joining("|")));
diff --git a/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
index 4a5b6fd..994d4c6 100644
--- a/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
@@ -3,10 +3,14 @@ package one.util.streamex;
 import static org.junit.Assert.*;
 import static one.util.streamex.TestHelpers.*;
 
+import java.util.Arrays;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.Spliterators;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
 import org.junit.Test;
@@ -77,4 +81,37 @@ public class UnknownSizeSpliteratorTest {
         assertEquals(12497500, StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), true)
                 .mapToInt(x -> x).sum());
     }
+    
+    @Test
+    public void testOptimize() {
+        Stream<String> stream = Stream.of("a", "b");
+        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
+        stream = StreamSupport.stream(
+            Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(), Spliterator.ORDERED), false)
+                .distinct(); // not Head
+        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
+        stream = StreamSupport.stream(
+            Spliterators.spliterator(Arrays.asList("a", "b").iterator(), 2, Spliterator.ORDERED), false); // SIZED
+        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
+        stream = new ConcurrentLinkedDeque<String>().stream(); // not SIZED
+        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
+
+        AtomicBoolean flag = new AtomicBoolean();
+        stream = StreamSupport.stream(
+            Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(), Spliterator.ORDERED), false)
+            .onClose(() -> flag.set(true));
+        Stream<String> optimized = UnknownSizeSpliterator.optimize(stream);
+        assertNotSame(stream, optimized);
+        assertTrue(optimized.spliterator() instanceof UnknownSizeSpliterator);
+        assertFalse(optimized.isParallel());
+        optimized.close();
+        assertTrue(flag.get());
+
+        stream = StreamSupport.stream(
+            Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(), Spliterator.ORDERED), true);
+        optimized = UnknownSizeSpliterator.optimize(stream);
+        assertNotSame(stream, optimized);
+        assertTrue(optimized.spliterator() instanceof UnknownSizeSpliterator);
+        assertTrue(optimized.isParallel());
+    }
 }
