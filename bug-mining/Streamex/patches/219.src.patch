diff --git a/CHANGES.md b/CHANGES.md
index d2fdc52..1534d92 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
 ### 0.6.6
 * [#145] Added: `intersperse` method for all stream types.
+* [#144] Added: `EntryStream.generate`
 
 ### 0.6.5
 * [#137] Added: `StreamEx.toNavigableMap()`, `EntryStream.toNavigableMap()`
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 49ae85f..3d7bc21 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -2032,4 +2032,24 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
             BiFunction<Integer, TT, Stream<T>> mapper) {
         return ofTree(root, (d, t) -> collectionClass.isInstance(t) ? mapper.apply(d, (TT) t) : null);
     }
+
+    /**
+     * Returns an infinite sequential unordered {@code EntryStream} where each
+     * entry key is generated by the provided {@code keySupplier} and each entry value is generated by the provided
+     * {@code valueSupplier}. This is suitable for generating constant streams, streams of random elements, etc.
+     *
+     * @param keySupplier the supplier to generate keys for the new stream
+     * @param valueSupplier the supplier to generate values for the new stream
+     * @param <K> the type of stream element keys
+     * @param <V> the type of stream element values
+     * @return a new infinite sequential unordered {@code EntryStream}
+     * @since 0.6.6
+     * @see StreamEx#generate(Supplier)
+     */
+    public static <K, V> EntryStream<K, V> generate(Supplier<? extends K> keySupplier,
+                                                    Supplier<? extends V> valueSupplier) {
+        return new EntryStream<>(
+                Stream.generate(() -> new SimpleImmutableEntry<>(keySupplier.get(), valueSupplier.get())),
+                StreamContext.SEQUENTIAL);
+    }
 }
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index aeaa5c1..d3865a0 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2673,6 +2673,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param s the {@code Supplier} of generated elements
      * @return a new infinite sequential unordered {@code StreamEx}
      * @see Stream#generate(Supplier)
+     * @see EntryStream#generate(Supplier, Supplier)
      */
     public static <T> StreamEx<T> generate(Supplier<T> s) {
         return new StreamEx<>(Stream.generate(s), StreamContext.SEQUENTIAL);
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 6e23bbf..d1ec737 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -120,6 +120,12 @@ public class EntryStreamTest {
             4, "e", 5, "f", 6, "g", 7, "h", 8, "i", 9, "j", 10));
     }
 
+    @Test
+    public void testGenerate() {
+        entryStream(() -> EntryStream.generate(() -> "a", () -> 1).limit(10),
+                es -> assertEquals("a-1,a-1,a-1,a-1,a-1,a-1,a-1,a-1,a-1,a-1", es.get().join("-").joining(",")));
+    }
+
     @Test
     public void testSequential() {
         EntryStream<String, Integer> stream = EntryStream.of(createMap());
