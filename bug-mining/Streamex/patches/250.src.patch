diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 2d797cb..5099dbf 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -841,7 +841,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     /**
      * Returns an array containing all the stream elements. If the stream
      * happens to contain no elements, the supplied empty array is returned
-     * instead. Otherwise, the new array is allocated which element type is the
+     * instead. Otherwise, the new array is allocated, whose element type is the
      * same as the element type of supplied empty array.
      * 
      * <p>
@@ -851,7 +851,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * This method is useful when the stream is expected to return empty arrays
      * often, so the same instance of empty array (presumably declared in some
-     * static final field) can be reused.
+     * {@code static final} field) can be reused.
      * 
      * @param <A> the element type of the resulting array
      * @param emptyArray an empty array of the resulting type
@@ -946,6 +946,10 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * For parallel stream the concurrent {@code Map} is created.
      *
+     * <p>
+     * Use {@link #valuesToMap(Function)} if this stream contains values,
+     * instead of keys.
+     *
      * @param <V> the output type of the value mapping function
      * @param valMapper a mapping function to produce values
      * @return a {@code Map} whose keys are elements from this stream and values
@@ -986,6 +990,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toMap(Function)
+     * @see #valuesToMap(Function)
      */
     public <K, V> Map<K, V> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valMapper) {
         Map<K, V> map = isParallel() ? new ConcurrentHashMap<>() : new HashMap<>();
@@ -1055,8 +1060,9 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toMap(Function, Function)
+     * @since 0.8.0
      */
-    public <K> Map<K, T> toMapKey(Function<? super T, ? extends K> keyMapper) {
+    public <K> Map<K, T> valuesToMap(Function<? super T, ? extends K> keyMapper) {
         return toMap(keyMapper, Function.identity());
     }
 
@@ -1114,6 +1120,10 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * Returned {@code SortedMap} is guaranteed to be modifiable.
      *
+     * <p>
+     * Use {@link #valuesToSortedMap(Function)} if this stream contains values,
+     * instead of keys.
+     *
      * @param <V> the output type of the value mapping function
      * @param valMapper a mapping function to produce values
      * @return a {@code SortedMap} whose keys are elements from this stream and
@@ -1159,6 +1169,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toSortedMap(Function)
+     * @see #valuesToSortedMap(Function) 
      * @see #toNavigableMap(Function, Function)
      * @since 0.1.0
      */
@@ -1218,9 +1229,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * <p>
      * If the mapped keys contains duplicates (according to
-     * {@link Object#equals(Object)}), the value mapping function is applied to
-     * each equal element, and the results are merged using the provided merging
-     * function.
+     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
+     * thrown when the collection operation is performed.
      *
      * <p>
      * Returned {@code SortedMap} is guaranteed to be modifiable.
@@ -1233,9 +1243,10 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
-     * @see #toMap(Function, Function)
+     * @see #toSortedMap(Function, Function)
+     * @since 0.8.0
      */
-    public <K> SortedMap<K, T> toSortedMapKey(Function<? super T, ? extends K> keyMapper) {
+    public <K> SortedMap<K, T> valuesToSortedMap(Function<? super T, ? extends K> keyMapper) {
         return toSortedMap(keyMapper, Function.identity());
     }
 
@@ -1259,6 +1270,10 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * Returned {@code NavigableMap} is guaranteed to be modifiable.
      *
+     * <p>
+     * Use {@link #valuesToNavigableMap(Function)} if this stream contains values,
+     * instead of keys.
+     *
      * @param <V> the output type of the value mapping function
      * @param valMapper a mapping function to produce values
      * @return a {@code NavigableMap} whose keys are elements from this stream and
@@ -1303,6 +1318,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toNavigableMap(Function)
+     * @see #valuesToNavigableMap(Function) 
      * @since 0.6.5
      */
     public <K, V> NavigableMap<K, V> toNavigableMap(Function<? super T, ? extends K> keyMapper,
@@ -1376,9 +1392,10 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
-     * @see #toMap(Function, Function)
+     * @see #toNavigableMap(Function, Function) 
+     * @since 0.8.0
      */
-    public <K> NavigableMap<K, T> toNavigableMapKey(Function<? super T, ? extends K> keyMapper) {
+    public <K> NavigableMap<K, T> valuesToNavigableMap(Function<? super T, ? extends K> keyMapper) {
         return toNavigableMap(keyMapper, Function.identity());
     }
 
diff --git a/src/test/java/one/util/streamex/api/StreamExTest.java b/src/test/java/one/util/streamex/api/StreamExTest.java
index 45b47ec..84fc709 100644
--- a/src/test/java/one/util/streamex/api/StreamExTest.java
+++ b/src/test/java/one/util/streamex/api/StreamExTest.java
@@ -15,6 +15,19 @@
  */
 package one.util.streamex.api;
 
+import one.util.streamex.EntryStream;
+import one.util.streamex.IntStreamEx;
+import one.util.streamex.Joining;
+import one.util.streamex.MoreCollectors;
+import one.util.streamex.StreamEx;
+import one.util.streamex.TestHelpers.Point;
+
+import org.junit.FixMethodOrder;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runners.MethodSorters;
+
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.IOException;
@@ -74,21 +87,7 @@ import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
-import org.junit.FixMethodOrder;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.runners.MethodSorters;
-
-import one.util.streamex.EntryStream;
-import one.util.streamex.IntStreamEx;
-import one.util.streamex.Joining;
-import one.util.streamex.MoreCollectors;
-import one.util.streamex.StreamEx;
-import one.util.streamex.TestHelpers.Point;
-
 import static java.util.Arrays.asList;
-import static one.util.streamex.TestHelpers.assertStatementThrows;
 import static one.util.streamex.TestHelpers.checkIllegalStateException;
 import static one.util.streamex.TestHelpers.checkSpliterator;
 import static one.util.streamex.TestHelpers.emptySpliteratorWithExactSize;
@@ -356,6 +355,27 @@ public class StreamExTest {
         });
     }
 
+    @Test
+    public void testValuesToMap() {
+        Map<Integer, String> expected = new HashMap<>();
+        expected.put(1, "a");
+        expected.put(2, "bb");
+        expected.put(3, "ccc");
+        streamEx(() -> Stream.of("a", "bb", "ccc"), supplier -> {
+            Map<Integer, String> map = supplier.get().valuesToMap(String::length);
+            assertEquals(supplier.get().isParallel(), map instanceof ConcurrentMap);
+            assertEquals(expected, map);
+
+            SortedMap<Integer, String> smap = supplier.get().valuesToSortedMap(String::length);
+            assertEquals(supplier.get().isParallel(), smap instanceof ConcurrentMap);
+            assertEquals(expected, smap);
+
+            NavigableMap<Integer, String> nmap = supplier.get().valuesToNavigableMap(String::length);
+            assertEquals(supplier.get().isParallel(), nmap instanceof ConcurrentMap);
+            assertEquals(expected, nmap);
+        });
+    }
+
     @Test
     public void testToSortedMap() {
         Map<String, Integer> expected = new HashMap<>();
@@ -1478,7 +1498,7 @@ public class StreamExTest {
     }
 
     /*
-     * Returns longest input stream segment for which the predicate holds (like
+     * Returns the longest input stream segment for which the predicate holds (like
      * the corresponding Scala method)
      */
     private static long segmentLength(IntStreamEx source, IntPredicate predicate) {
@@ -1628,7 +1648,7 @@ public class StreamExTest {
     @Test
     public void testTakeDropUnordered() {
         repeat(10, n -> withRandom(rnd -> {
-            List<Boolean> data = IntStreamEx.of(rnd, n * 100, 0, rnd.nextInt(10) + 2).mapToObj(x -> x != 0).toList();
+            List<Boolean> data = IntStreamEx.of(rnd, n * 100L, 0, rnd.nextInt(10) + 2).mapToObj(x -> x != 0).toList();
             List<Boolean> sorted = StreamEx.of(data).sorted().toList();
             streamEx(() -> data.stream().unordered(), s -> {
                 assertFalse(StreamEx.of(s.get().takeWhile(b -> b).toList()).has(false));
diff --git a/wiki/CHANGES.md b/wiki/CHANGES.md
index 30ae6b3..df8c34c 100644
--- a/wiki/CHANGES.md
+++ b/wiki/CHANGES.md
@@ -6,6 +6,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 * [#244] Added: `StreamEx.toMutableList` and `StreamEx.toMutableSet`.  
  Removed mutability guarantee for `toList` and `toSet`.
  Added temporary system property `streamex.default.immutable` (set it to 'true' to test with immutable `toList` and `toSet`)
+* [#238] Added: `valuesToMap`, `valuesToSortedMap`, `valuesToNavigableMap` methods to `StreamEx`
 * [#250] Fixed: `EntryStream.withoutKeys` and `EntryStream.withoutValues` declared as `@SafeVarargs`
 * [#251] Changed: public classes like `StreamEx` and `EntryStream` declared as final now.
 * [#246] Added: Proper `module-info.class`, now it's full-fledged JPMS module
diff --git a/wiki/CHEATSHEET.md b/wiki/CHEATSHEET.md
index d5949c9..1e72963 100644
--- a/wiki/CHEATSHEET.md
+++ b/wiki/CHEATSHEET.md
@@ -202,6 +202,7 @@ Collect elements to `Collection` adding custom final step | `StreamEx/EntryStrea
 Collect elements to immutable `List` or `Set` | `StreamEx/EntryStream.toImmutableList()/toImmutableSet()`
 Collect elements to mutable `List` or `Set` | `StreamEx/EntryStream.toMutableList()/toMutableSet()`
 Collect elements or entries to `Map` | `StreamEx/EntryStream.toMap()/toSortedMap()/toNavigableMap()`
+Collect stream of values to `Map` | `StreamEx.valuesToMap()/valuesToSortedMap()/valuesToNavigableMap()`
 Collect entries to immutable `Map` | `EntryStream.toImmutableMap()`
 Collect entries to `Map` adding custom final step | `EntryStream.toMapAndThen()`
 Collect entries to custom `Map` | `EntryStream.toCustomMap()`
