diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 8be4ca8..b2c6a41 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -312,8 +312,7 @@ import static one.util.streamex.StreamExInternals.*;
     @Override
     public void forEach(Consumer<? super T> action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -329,8 +328,7 @@ import static one.util.streamex.StreamExInternals.*;
     @Override
     public void forEachOrdered(Consumer<? super T> action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
index d949310..1f59ed8 100644
--- a/src/main/java/one/util/streamex/BaseStreamEx.java
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -61,8 +61,11 @@ import java.util.stream.BaseStream;
     public SPLTR spliterator() {
         if(stream != null)
             return (SPLTR) stream.spliterator();
-        if(spliterator != null)
-            return spliterator;
+        if(spliterator != null) {
+            SPLTR s = spliterator;
+            spliterator = null;
+            return s;
+        }
         throw new IllegalStateException(CONSUMED_MESSAGE);
     }
 
diff --git a/src/main/java/one/util/streamex/ConstSpliterator.java b/src/main/java/one/util/streamex/ConstSpliterator.java
index f3b4c1e..859959a 100644
--- a/src/main/java/one/util/streamex/ConstSpliterator.java
+++ b/src/main/java/one/util/streamex/ConstSpliterator.java
@@ -29,9 +29,11 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
  */
 /* package */abstract class ConstSpliterator<T, S extends ConstSpliterator<T, ?>> extends CloneableSpliterator<T, S> {
     long remaining;
+    private final boolean ordered;
 
-    public ConstSpliterator(long remaining) {
+    public ConstSpliterator(long remaining, boolean ordered) {
         this.remaining = remaining;
+        this.ordered = ordered;
     }
 
     @Override
@@ -54,14 +56,14 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
 
     @Override
     public int characteristics() {
-        return SIZED | SUBSIZED | IMMUTABLE;
+        return SIZED | SUBSIZED | IMMUTABLE | (ordered ? ORDERED : 0);
     }
 
     static final class OfRef<T> extends ConstSpliterator<T, OfRef<T>> {
         private final T value;
 
-        OfRef(T value, long count) {
-            super(count);
+        OfRef(T value, long count, boolean ordered) {
+            super(count, ordered);
             this.value = value;
         }
 
@@ -86,8 +88,8 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
     static final class OfInt extends ConstSpliterator<Integer, OfInt> implements Spliterator.OfInt {
         private final int value;
 
-        OfInt(int value, long count) {
-            super(count);
+        OfInt(int value, long count, boolean ordered) {
+            super(count, ordered);
             this.value = value;
         }
 
@@ -112,8 +114,8 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
     static final class OfLong extends ConstSpliterator<Long, OfLong> implements Spliterator.OfLong {
         private final long value;
 
-        OfLong(long value, long count) {
-            super(count);
+        OfLong(long value, long count, boolean ordered) {
+            super(count, ordered);
             this.value = value;
         }
 
@@ -138,8 +140,8 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
     static final class OfDouble extends ConstSpliterator<Double, OfDouble> implements Spliterator.OfDouble {
         private final double value;
 
-        OfDouble(double value, long count) {
-            super(count);
+        OfDouble(double value, long count, boolean ordered) {
+            super(count, ordered);
             this.value = value;
         }
 
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index d9b3282..33ec271 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -563,8 +563,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
     @Override
     public void forEach(DoubleConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -580,8 +579,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
     @Override
     public void forEachOrdered(DoubleConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -1444,7 +1442,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @return an empty sequential stream
      */
     public static DoubleStreamEx empty() {
-        return of(DoubleStream.empty());
+        return of(Spliterators.emptyDoubleSpliterator());
     }
 
     /**
@@ -1454,7 +1452,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @return a singleton sequential stream
      */
     public static DoubleStreamEx of(double element) {
-        return of(DoubleStream.of(element));
+        return of(new ConstSpliterator.OfDouble(element, 1, true));
     }
 
     /**
@@ -1465,7 +1463,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @return the new stream
      */
     public static DoubleStreamEx of(double... elements) {
-        return of(DoubleStream.of(elements));
+        return of(Arrays.spliterator(elements));
     }
 
     /**
@@ -1484,7 +1482,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @see Arrays#stream(double[], int, int)
      */
     public static DoubleStreamEx of(double[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.stream(array, startInclusive, endExclusive));
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
     }
 
     /**
@@ -1553,7 +1551,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @since 0.3.4
      */
     public static DoubleStreamEx of(Spliterator.OfDouble spliterator) {
-        return of(StreamSupport.doubleStream(spliterator, false));
+        return new DoubleStreamEx(spliterator, ExecutionStrategy.SEQUENTIAL);
     }
 
     /**
@@ -1716,7 +1714,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @since 0.1.2
      */
     public static DoubleStreamEx constant(double value, long length) {
-        return of(new ConstSpliterator.OfDouble(value, length));
+        return of(new ConstSpliterator.OfDouble(value, length, false));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 46252cb..e699dad 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -573,8 +573,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     @Override
     public void forEach(IntConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -590,8 +589,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     @Override
     public void forEachOrdered(IntConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -1663,7 +1661,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @return an empty sequential stream
      */
     public static IntStreamEx empty() {
-        return of(IntStream.empty());
+        return of(Spliterators.emptyIntSpliterator());
     }
 
     /**
@@ -1673,7 +1671,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @return a singleton sequential stream
      */
     public static IntStreamEx of(int element) {
-        return of(IntStream.of(element));
+        return of(new ConstSpliterator.OfInt(element, 1, true));
     }
 
     /**
@@ -1684,7 +1682,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @return the new stream
      */
     public static IntStreamEx of(int... elements) {
-        return of(IntStream.of(elements));
+        return of(Arrays.spliterator(elements));
     }
 
     /**
@@ -1703,7 +1701,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @see Arrays#stream(int[], int, int)
      */
     public static IntStreamEx of(int[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.stream(array, startInclusive, endExclusive));
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
     }
 
     /**
@@ -1971,7 +1969,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @since 0.3.4
      */
     public static IntStreamEx of(Spliterator.OfInt spliterator) {
-        return of(StreamSupport.intStream(spliterator, false));
+        return new IntStreamEx(spliterator, ExecutionStrategy.SEQUENTIAL);
     }
 
     /**
@@ -2299,7 +2297,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @since 0.1.2
      */
     public static IntStreamEx constant(int value, long length) {
-        return of(new ConstSpliterator.OfInt(value, length));
+        return of(new ConstSpliterator.OfInt(value, length, false));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 38b3563..cbbe1ee 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -590,8 +590,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
     @Override
     public void forEach(LongConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -607,8 +606,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
     @Override
     public void forEachOrdered(LongConsumer action) {
         if (spliterator != null && !isParallel()) {
-            spliterator.forEachRemaining(action);
-            spliterator = null;
+            spliterator().forEachRemaining(action);
         } else {
             if(strategy.getFjp() != null)
                 strategy.terminate(() -> {
@@ -1468,7 +1466,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @return an empty sequential stream
      */
     public static LongStreamEx empty() {
-        return of(LongStream.empty());
+        return of(Spliterators.emptyLongSpliterator());
     }
 
     /**
@@ -1478,7 +1476,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @return a singleton sequential stream
      */
     public static LongStreamEx of(long element) {
-        return of(LongStream.of(element));
+        return of(new ConstSpliterator.OfLong(element, 1, true));
     }
 
     /**
@@ -1489,7 +1487,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @return the new stream
      */
     public static LongStreamEx of(long... elements) {
-        return of(LongStream.of(elements));
+        return of(Arrays.spliterator(elements));
     }
 
     /**
@@ -1508,7 +1506,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @see Arrays#stream(long[], int, int)
      */
     public static LongStreamEx of(long[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.stream(array, startInclusive, endExclusive));
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
     }
 
     /**
@@ -1546,7 +1544,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @since 0.3.4
      */
     public static LongStreamEx of(Spliterator.OfLong spliterator) {
-        return of(StreamSupport.longStream(spliterator, false));
+        return new LongStreamEx(spliterator, ExecutionStrategy.SEQUENTIAL);
     }
 
     /**
@@ -1813,7 +1811,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @since 0.1.2
      */
     public static LongStreamEx constant(long value, long length) {
-        return of(new ConstSpliterator.OfLong(value, length));
+        return of(new ConstSpliterator.OfLong(value, length, false));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index bdf6429..28f22cb 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -57,7 +57,6 @@ import java.util.regex.Pattern;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 import java.util.stream.Collector.Characteristics;
 
 import static one.util.streamex.StreamExInternals.*;
@@ -1485,7 +1484,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return an empty sequential stream
      */
     public static <T> StreamEx<T> empty() {
-        return of(Stream.empty());
+        return of(Spliterators.emptySpliterator());
     }
 
     /**
@@ -1497,7 +1496,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Stream#of(Object)
      */
     public static <T> StreamEx<T> of(T element) {
-        return of(Stream.of(element));
+        return of(new ConstSpliterator.OfRef<>(element, 1, true));
     }
 
     /**
@@ -1511,7 +1510,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     @SafeVarargs
     public static <T> StreamEx<T> of(T... elements) {
-        return of(Stream.of(elements));
+        return of(Arrays.spliterator(elements));
     }
 
     /**
@@ -1531,7 +1530,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Arrays#stream(Object[], int, int)
      */
     public static <T> StreamEx<T> of(T[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.stream(array, startInclusive, endExclusive));
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
     }
 
     /**
@@ -1545,7 +1544,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collection#stream()
      */
     public static <T> StreamEx<T> of(Collection<T> collection) {
-        return of(collection.stream());
+        return of(collection.spliterator());
     }
 
     /**
@@ -1569,7 +1568,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.3.4
      */
     public static <T> StreamEx<T> of(Spliterator<T> spliterator) {
-        return of(StreamSupport.stream(spliterator, false));
+        return new StreamEx<>(spliterator, ExecutionStrategy.SEQUENTIAL);
     }
 
     /**
@@ -1791,7 +1790,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Map#keySet()
      */
     public static <T> StreamEx<T> ofKeys(Map<T, ?> map) {
-        return of(map.keySet().stream());
+        return of(map.keySet().spliterator());
     }
 
     /**
@@ -1823,7 +1822,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Map#values()
      */
     public static <T> StreamEx<T> ofValues(Map<?, T> map) {
-        return of(map.values().stream());
+        return of(map.values().spliterator());
     }
 
     /**
@@ -2036,7 +2035,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.1.2
      */
     public static <T> StreamEx<T> constant(T value, long length) {
-        return of(new ConstSpliterator.OfRef<>(value, length));
+        return of(new ConstSpliterator.OfRef<>(value, length, false));
     }
 
     /**
@@ -2164,7 +2163,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
         Stream<T> rootStream = mapper.apply(root);
-        return rootStream == null ? of(root) : of(flatTraverse(rootStream, mapper)).prepend(Stream.of(root));
+        return rootStream == null ? of(root) : of(flatTraverse(rootStream, mapper)).prepend(root);
     }
 
     /**
@@ -2283,7 +2282,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static <T> StreamEx<List<T>> cartesianProduct(Collection<? extends Collection<T>> source) {
         if (source.isEmpty())
-            return of(Stream.of(Collections.emptyList()));
+            return StreamEx.<List<T>>of(Collections.emptyList());
         return of(new CrossSpliterator.ToList<>(source));
     }
 
@@ -2365,7 +2364,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static <T> StreamEx<List<T>> cartesianPower(int n, Collection<T> source) {
         if (n == 0)
-            return of(Stream.of(Collections.emptyList()));
+            return StreamEx.<List<T>>of(Collections.emptyList());
         return of(new CrossSpliterator.ToList<>(Collections.nCopies(n, source)));
     }
 
diff --git a/src/test/java/one/util/streamex/BaseStreamExTest.java b/src/test/java/one/util/streamex/BaseStreamExTest.java
new file mode 100644
index 0000000..2ab6563
--- /dev/null
+++ b/src/test/java/one/util/streamex/BaseStreamExTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+import java.util.Spliterator;
+
+import org.junit.Test;
+
+/**
+ * @author Tagir Valeev
+ *
+ */
+public class BaseStreamExTest {
+    @Test
+    public void testSpliterator() {
+        Spliterator<Integer> spltr = Arrays.spliterator(new Integer[] {1,2,3}); 
+        StreamEx<Integer> s = StreamEx.of(spltr);
+        assertFalse(s.isParallel());
+        assertSame(spltr, s.spliterator());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testSpliteratorConsumed() {
+        StreamEx<Integer> s = StreamEx.of(1, 2, 3);
+        s.spliterator();
+        s.spliterator();
+    }
+}
diff --git a/src/test/java/one/util/streamex/ConstantSpliteratorTest.java b/src/test/java/one/util/streamex/ConstantSpliteratorTest.java
index 301fec4..d0e1a36 100644
--- a/src/test/java/one/util/streamex/ConstantSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/ConstantSpliteratorTest.java
@@ -29,12 +29,12 @@ import org.junit.Test;
 public class ConstantSpliteratorTest {
     @Test
     public void testConstant() {
-        checkSpliterator("ref", Collections.nCopies(100, "val"), () -> new ConstSpliterator.OfRef<>("val", 100));
+        checkSpliterator("ref", Collections.nCopies(100, "val"), () -> new ConstSpliterator.OfRef<>("val", 100, false));
         checkSpliterator("ref", Collections.nCopies(100, Integer.MIN_VALUE), () -> new ConstSpliterator.OfInt(
-                Integer.MIN_VALUE, 100));
+                Integer.MIN_VALUE, 100, false));
         checkSpliterator("ref", Collections.nCopies(100, Long.MIN_VALUE), () -> new ConstSpliterator.OfLong(
-                Long.MIN_VALUE, 100));
+                Long.MIN_VALUE, 100, false));
         checkSpliterator("ref", Collections.nCopies(100, Double.MIN_VALUE), () -> new ConstSpliterator.OfDouble(
-                Double.MIN_VALUE, 100));
+                Double.MIN_VALUE, 100, false));
     }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 2d6e2f4..2c405bd 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -208,6 +208,17 @@ public class StreamExTest {
         list.addAll(list2);
         assertEquals(asList(1, 2, 3, 4, 5, 6, 7), list);
     }
+    
+    @Test
+    public void testForEach() {
+        List<Integer> list = new ArrayList<>();
+        StreamEx.of(1, 2, 3).forEach(list::add);
+        assertEquals(asList(1, 2, 3), list);
+        StreamEx.of(1, 2, 3).forEachOrdered(list::add);
+        assertEquals(asList(1, 2, 3, 1, 2, 3), list);
+        StreamEx.of(1, 2, 3).parallel().forEachOrdered(list::add);
+        assertEquals(asList(1, 2, 3, 1, 2, 3, 1, 2, 3), list);
+    }
 
     @Test
     public void testFlatMap() {
diff --git a/src/test/java/one/util/streamex/TestHelpers.java b/src/test/java/one/util/streamex/TestHelpers.java
index eb1a032..fba102e 100644
--- a/src/test/java/one/util/streamex/TestHelpers.java
+++ b/src/test/java/one/util/streamex/TestHelpers.java
@@ -50,12 +50,12 @@ import one.util.streamex.StreamEx;
  */
 public class TestHelpers {
     static enum Mode {
-        NORMAL, PARALLEL, APPEND, PREPEND, RANDOM
+        NORMAL, SPLITERATOR, PARALLEL, APPEND, PREPEND, RANDOM
     }
 
     static class StreamSupplier<T> {
-        private final Mode mode;
-        private final Supplier<Stream<T>> base;
+        final Mode mode;
+        final Supplier<Stream<T>> base;
 
         public StreamSupplier(Supplier<Stream<T>> base, Mode mode) {
             this.base = base;
@@ -66,6 +66,7 @@ public class TestHelpers {
             Stream<T> res = base.get();
             switch (mode) {
             case NORMAL:
+            case SPLITERATOR: 
                 return res.sequential();
             case PARALLEL:
                 return res.parallel();
@@ -96,6 +97,8 @@ public class TestHelpers {
 
         @Override
         public StreamEx<T> get() {
+            if(mode == Mode.SPLITERATOR)
+                return StreamEx.of(base.get().spliterator());
             return StreamEx.of(super.get());
         }
     }
