diff --git a/CHANGES.md b/CHANGES.md
index 959f26f..ca6a231 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -8,6 +8,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 * [#112] Added: `StreamEx.toArray(emptyArray)`
 * [#116] Added: `MoreCollectors.ifAllMatch()`
 * [#119] Added: `AbstractStreamEx.toImmutableList()`, `AbstractStreamEx.toImmutableSet()`, `EntryStream.toImmutableMap()`
+* [#123] Added: `StreamEx.into(collection)`, `EntryStream.into(map)`
 
 ### 0.6.2
 
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 75e59e2..3eefc40 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -242,6 +242,8 @@ Perform operation on entry key and value using `BiConsumer` | `EntryStream.forKe
 What I want | How to get it
 --- | ---
 Convert `IntStreamEx` to `InputStream` | `IntStreamEx.asByteInputStream()`
+Drain stream content into the existing `Collection` | `StreamEx.into()`
+Drain stream content into the existing `Map` | `EntryStream.into()`
 
 ## Collectors
 
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 3ca0282..487151d 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -1179,6 +1179,33 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
     public SortedMap<K, V> toSortedMap(BinaryOperator<V> mergeFunction) {
         return collect(Collectors.toMap(Entry::getKey, Entry::getValue, mergeFunction, TreeMap::new));
     }
+    
+    /**
+     * Drains the stream content into the supplied {@code Map}.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">terminal</a>
+     * operation.
+     * 
+     * @param map a mutable map to put the stream elements into
+     * @return the supplied map, updated from this stream
+     * @throws IllegalStateException if this stream contains duplicate keys, or
+     *         the stream contains the key which was already present in the map
+     *         (according to {@link Object#equals(Object)})
+     * @since 0.6.3
+     */
+    public <M extends Map<K, V>> M into(M map) {
+        Consumer<? super Entry<K, V>> cons = toMapConsumer(map);
+        if (isParallel()) {
+            if (map instanceof ConcurrentMap)
+                forEach(cons);
+            else
+                toMap().entrySet().forEach(cons);
+        } else {
+            spliterator().forEachRemaining(cons);
+        }
+        return map;
+    }
 
     /**
      * Returns a {@link Map} where elements of this stream with the same key are
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 6d6b731..6676c92 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -961,6 +961,39 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             Function<? super T, ? extends V> valMapper, BinaryOperator<V> mergeFunction) {
         return rawCollect(Collectors.toMap(keyMapper, valMapper, mergeFunction, HashMap::new));
     }
+    
+    /**
+     * Drains the stream content into the supplied collection.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">terminal</a>
+     * operation.
+     * 
+     * <p>
+     * The stream content is added into the collection using either
+     * {@link Collection#add(Object)} or {@link Collection#addAll(Collection)}
+     * method.
+     * 
+     * @param collection a mutable collection to add new elements into
+     * @return the supplied collection, updated from this stream
+     * @since 0.6.3
+     */
+    public <C extends Collection<? super T>> C into(C collection) {
+        if (isParallel()) {
+            @SuppressWarnings("unchecked")
+            List<T> list = Arrays.asList((T[]) toArray());
+            collection.addAll(list);
+        } else {
+            Spliterator<T> spltr = spliterator();
+            if (collection instanceof ArrayList) {
+                long size = spltr.getExactSizeIfKnown();
+                if (size >= 0 && size < Integer.MAX_VALUE - collection.size())
+                    ((ArrayList<?>) collection).ensureCapacity((int) (collection.size() + size));
+            }
+            spltr.forEachRemaining(collection::add);
+        }
+        return collection;
+    }
 
     /**
      * Returns a {@link SortedMap} whose keys are elements from this stream and
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 12c4bf9..22e8612 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -645,6 +645,19 @@ public class EntryStreamTest {
                 }
             });
         });
-
+    }
+    
+    @Test
+    public void testInto() {
+        for(AbstractMap<String, Integer> m : Arrays.<AbstractMap<String, Integer>>asList(new HashMap<>(), new TreeMap<>(), new ConcurrentHashMap<>())) {
+            AbstractMap<String, Integer> res = EntryStream.of("a", 1, "b", 2, "c", 3).into(m);
+            assertSame(m, res);
+            assertEquals(EntryStream.of("a", 1, "b", 2, "c", 3).toMap(), m);
+            Map<String, Integer> res2 = EntryStream.of("d", 4, "e", 5).parallel().into(m);
+            assertSame(m, res2);
+            assertEquals(EntryStream.of("a", 1, "b", 2, "c", 3, "d", 4, "e", 5).toMap(), m);
+            checkIllegalStateException(() -> EntryStream.of("x", 10, "c", 4).into(m), "c", "3", "4");
+            checkIllegalStateException(() -> EntryStream.of("y", 20, "d", 5).parallel().into(m), "d", "4", "5");
+        }
     }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 563270f..c6ed0ba 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1975,4 +1975,36 @@ public class StreamExTest {
             });
         });
     }
+    
+    @Test
+    public void testInto() {
+        for(List<Number> list : asList(new ArrayList<Number>(), new LinkedList<Number>())) {
+            List<Number> res = StreamEx.of(1, 2, 3, 4).filter(x -> x < 4).into(list);
+            assertSame(list, res);
+            assertEquals(asList(1, 2, 3), list);
+            assertSame(list, StreamEx.of(4, 5, 6).into(list));
+            assertEquals(asList(1, 2, 3, 4, 5, 6), list);
+            assertSame(list, StreamEx.of(7, 8, 9, 10).parallel().into(list));
+            assertEquals(asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), list);
+        }
+        // a kind of mock object
+        Collection<String> c = new ArrayList<String>() {
+            private static final long serialVersionUID = 1L;
+            int size = Integer.MAX_VALUE - 10;
+            
+            @Override
+            public boolean add(String e) {
+                assertEquals("a", e);
+                size++;
+                return true;
+            }
+
+            @Override
+            public int size() {
+                return size;
+            }
+        };
+        assertSame(c, StreamEx.constant("a", 20).into(c));
+        assertEquals(Integer.MAX_VALUE+10, c.size());
+    }
 }
