diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index dc6e95f..2e2d8df 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -23,6 +23,7 @@ import java.util.DoubleSummaryStatistics;
 import java.util.Objects;
 import java.util.OptionalDouble;
 import java.util.OptionalLong;
+import java.util.PrimitiveIterator;
 import java.util.Random;
 import java.util.Spliterator;
 import java.util.Map.Entry;
@@ -1544,6 +1545,23 @@ public class DoubleStreamEx implements DoubleStream {
         return of(StreamSupport.doubleStream(spliterator, false));
     }
 
+    /**
+     * Returns a sequential, ordered {@link DoubleStreamEx} created from given
+     * {@link java.util.PrimitiveIterator.OfDouble}.
+     * 
+     * This method is roughly equivalent to
+     * {@code DoubleStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     * 
+     * @param iterator
+     *            an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static DoubleStreamEx of(PrimitiveIterator.OfDouble iterator) {
+        return of(new UnknownSizeSpliterator.USOfDouble(iterator));
+    }
+
     /**
      * Returns a sequential {@code DoubleStreamEx} containing an
      * {@link OptionalDouble} value, if present, otherwise returns an empty
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index cad46bb..5c78d53 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -19,6 +19,7 @@ import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -1114,6 +1115,27 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return of(StreamSupport.stream(spliterator, false));
     }
 
+    /**
+     * Returns a sequential, ordered {@link EntryStream} created from given
+     * {@link Iterator}.
+     * 
+     * This method is roughly equivalent to
+     * {@code EntryStream.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     *
+     * @param <K>
+     *            the type of stream keys
+     * @param <V>
+     *            the type of stream values
+     * @param iterator
+     *            an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static <K, V> EntryStream<K, V> of(Iterator<? extends Entry<K, V>> iterator) {
+        return of(new UnknownSizeSpliterator.USOfRef<>(iterator));
+    }
+
     /**
      * Returns an {@code EntryStream} object which contains the entries of
      * supplied {@code Map}.
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index f1c5d65..e195afc 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -26,6 +26,7 @@ import java.util.Objects;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
+import java.util.PrimitiveIterator;
 import java.util.Random;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfInt;
@@ -2003,6 +2004,23 @@ public class IntStreamEx implements IntStream {
         return of(StreamSupport.intStream(spliterator, false));
     }
 
+    /**
+     * Returns a sequential, ordered {@link IntStreamEx} created from given
+     * {@link java.util.PrimitiveIterator.OfInt}.
+     * 
+     * This method is roughly equivalent to
+     * {@code IntStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     * 
+     * @param iterator
+     *            an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static IntStreamEx of(PrimitiveIterator.OfInt iterator) {
+        return of(new UnknownSizeSpliterator.USOfInt(iterator));
+    }
+
     /**
      * Returns a sequential {@code IntStreamEx} containing an
      * {@link OptionalInt} value, if present, otherwise returns an empty
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 50aa3ec..82ff9b6 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -23,6 +23,7 @@ import java.util.LongSummaryStatistics;
 import java.util.Objects;
 import java.util.OptionalDouble;
 import java.util.OptionalLong;
+import java.util.PrimitiveIterator;
 import java.util.Random;
 import java.util.Spliterator;
 import java.util.Map.Entry;
@@ -1539,6 +1540,23 @@ public class LongStreamEx implements LongStream {
         return of(StreamSupport.longStream(spliterator, false));
     }
 
+    /**
+     * Returns a sequential, ordered {@link LongStreamEx} created from given
+     * {@link java.util.PrimitiveIterator.OfLong}.
+     * 
+     * This method is roughly equivalent to
+     * {@code LongStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     * 
+     * @param iterator
+     *            an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static LongStreamEx of(PrimitiveIterator.OfLong iterator) {
+        return of(new UnknownSizeSpliterator.USOfLong(iterator));
+    }
+
     /**
      * Returns a sequential {@code LongStreamEx} containing an
      * {@link OptionalLong} value, if present, otherwise returns an empty
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 9a3e30c..deab7cf 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -29,6 +29,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.AbstractMap.SimpleImmutableEntry;
@@ -1545,6 +1546,25 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return of(StreamSupport.stream(spliterator, false));
     }
 
+    /**
+     * Returns a sequential, ordered {@link StreamEx} created from given
+     * {@link Iterator}.
+     * 
+     * This method is roughly equivalent to
+     * {@code StreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     *
+     * @param <T>
+     *            the type of iterator elements
+     * @param iterator
+     *            an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static <T> StreamEx<T> of(Iterator<T> iterator) {
+        return of(new UnknownSizeSpliterator.USOfRef<>(iterator));
+    }
+
     /**
      * Returns a sequential {@code StreamEx} containing an {@link Optional}
      * value, if present, otherwise returns an empty {@code StreamEx}.
diff --git a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
new file mode 100644
index 0000000..272b7c0
--- /dev/null
+++ b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
@@ -0,0 +1,311 @@
+package one.util.streamex;
+
+import java.util.Iterator;
+import java.util.PrimitiveIterator;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
+
+/* package */abstract class UnknownSizeSpliterator<T, I extends Iterator<? extends T>> implements Spliterator<T> {
+    static final int BATCH_UNIT = 1 << 10; // batch array size increment
+    static final int MAX_BATCH = 1 << 25; // max batch array size;
+    I it;
+    int index, fence;
+
+    public UnknownSizeSpliterator(I iterator) {
+        this.it = iterator;
+    }
+
+    UnknownSizeSpliterator(int index, int fence) {
+        this.index = index;
+        this.fence = fence;
+    }
+
+    @Override
+    public long estimateSize() {
+        return it == null ? fence - index : Long.MAX_VALUE;
+    }
+
+    @Override
+    public int characteristics() {
+        return it == null ? SIZED | SUBSIZED | ORDERED : ORDERED;
+    }
+
+    static class USOfRef<T> extends UnknownSizeSpliterator<T, Iterator<? extends T>> {
+        Object[] array;
+
+        USOfRef(Iterator<? extends T> iterator) {
+            super(iterator);
+        }
+
+        USOfRef(Object[] array, int index, int fence) {
+            super(index, fence);
+            this.array = array;
+        }
+
+        @Override
+        public Spliterator<T> trySplit() {
+            Iterator<? extends T> i = it;
+            if (i != null) {
+                int n = fence + BATCH_UNIT;
+                if (n > MAX_BATCH)
+                    n = MAX_BATCH;
+                Object[] a = new Object[n];
+                int j = 0;
+                do {
+                    a[j] = i.next();
+                } while (++j < n && i.hasNext());
+                fence = j;
+                if (i.hasNext()) {
+                    return new USOfRef<>(a, 0, j);
+                }
+                it = null;
+                array = a;
+            }
+            int lo = index, mid = (lo + fence) >>> 1;
+            return (lo >= mid) ? null : new USOfRef<>(array, lo, index = mid);
+        }
+
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if (it != null)
+                it.forEachRemaining(action);
+            else {
+                Object[] a = array;
+                int i = index, hi = fence;
+                if (i < hi && a.length >= hi) {
+                    do {
+                        @SuppressWarnings("unchecked")
+                        T t = (T) a[i];
+                        action.accept(t);
+                    } while (++i < hi);
+                }
+            }
+            index = fence;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if (it != null) {
+                if (it.hasNext()) {
+                    action.accept(it.next());
+                    return true;
+                }
+                it = null;
+                index = fence;
+            } else if (index < fence) {
+                @SuppressWarnings("unchecked")
+                T t = (T) array[index++];
+                action.accept(t);
+                return true;
+            }
+            return false;
+        }
+    }
+
+    static class USOfInt extends UnknownSizeSpliterator<Integer, PrimitiveIterator.OfInt> implements Spliterator.OfInt {
+        int[] array;
+
+        USOfInt(PrimitiveIterator.OfInt iterator) {
+            super(iterator);
+        }
+
+        USOfInt(int[] array, int index, int fence) {
+            super(index, fence);
+            this.array = array;
+        }
+
+        @Override
+        public Spliterator.OfInt trySplit() {
+            PrimitiveIterator.OfInt i = it;
+            if (i != null) {
+                int n = fence + BATCH_UNIT;
+                if (n > MAX_BATCH)
+                    n = MAX_BATCH;
+                int[] a = new int[n];
+                int j = 0;
+                do {
+                    a[j] = i.next();
+                } while (++j < n && i.hasNext());
+                fence = j;
+                if (i.hasNext()) {
+                    return new USOfInt(a, 0, j);
+                }
+                it = null;
+                array = a;
+            }
+            int lo = index, mid = (lo + fence) >>> 1;
+            return (lo >= mid) ? null : new USOfInt(array, lo, index = mid);
+        }
+
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            if (it != null)
+                it.forEachRemaining(action);
+            else {
+                int[] a = array;
+                int i = index, hi = fence;
+                if (i < hi && a.length >= hi) {
+                    do {
+                        action.accept(a[i]);
+                    } while (++i < hi);
+                }
+            }
+            index = fence;
+        }
+
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            if (it != null) {
+                if (it.hasNext()) {
+                    action.accept(it.nextInt());
+                    return true;
+                }
+                it = null;
+                index = fence;
+            } else if (index < fence) {
+                action.accept(array[index++]);
+                return true;
+            }
+            return false;
+        }
+    }
+
+    static class USOfLong extends UnknownSizeSpliterator<Long, PrimitiveIterator.OfLong> implements Spliterator.OfLong {
+        long[] array;
+
+        USOfLong(PrimitiveIterator.OfLong iterator) {
+            super(iterator);
+        }
+
+        USOfLong(long[] array, int index, int fence) {
+            super(index, fence);
+            this.array = array;
+        }
+
+        @Override
+        public Spliterator.OfLong trySplit() {
+            PrimitiveIterator.OfLong i = it;
+            if (i != null) {
+                int n = fence + BATCH_UNIT;
+                if (n > MAX_BATCH)
+                    n = MAX_BATCH;
+                long[] a = new long[n];
+                int j = 0;
+                do {
+                    a[j] = i.next();
+                } while (++j < n && i.hasNext());
+                fence = j;
+                if (i.hasNext()) {
+                    return new USOfLong(a, 0, j);
+                }
+                it = null;
+                array = a;
+            }
+            int lo = index, mid = (lo + fence) >>> 1;
+            return (lo >= mid) ? null : new USOfLong(array, lo, index = mid);
+        }
+
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            if (it != null)
+                it.forEachRemaining(action);
+            else {
+                long[] a = array;
+                int i = index, hi = fence;
+                if (i < hi && a.length >= hi) {
+                    do {
+                        action.accept(a[i]);
+                    } while (++i < hi);
+                }
+            }
+            index = fence;
+        }
+
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if (it != null) {
+                if (it.hasNext()) {
+                    action.accept(it.nextLong());
+                    return true;
+                }
+                it = null;
+                index = fence;
+            } else if (index < fence) {
+                action.accept(array[index++]);
+                return true;
+            }
+            return false;
+        }
+    }
+    
+    static class USOfDouble extends UnknownSizeSpliterator<Double, PrimitiveIterator.OfDouble> implements Spliterator.OfDouble {
+        double[] array;
+        
+        USOfDouble(PrimitiveIterator.OfDouble iterator) {
+            super(iterator);
+        }
+        
+        USOfDouble(double[] array, int index, int fence) {
+            super(index, fence);
+            this.array = array;
+        }
+        
+        @Override
+        public Spliterator.OfDouble trySplit() {
+            PrimitiveIterator.OfDouble i = it;
+            if (i != null) {
+                int n = fence + BATCH_UNIT;
+                if (n > MAX_BATCH)
+                    n = MAX_BATCH;
+                double[] a = new double[n];
+                int j = 0;
+                do {
+                    a[j] = i.next();
+                } while (++j < n && i.hasNext());
+                fence = j;
+                if (i.hasNext()) {
+                    return new USOfDouble(a, 0, j);
+                }
+                it = null;
+                array = a;
+            }
+            int lo = index, mid = (lo + fence) >>> 1;
+                    return (lo >= mid) ? null : new USOfDouble(array, lo, index = mid);
+        }
+        
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            if (it != null)
+                it.forEachRemaining(action);
+            else {
+                double[] a = array;
+                int i = index, hi = fence;
+                if (i < hi && a.length >= hi) {
+                    do {
+                        action.accept(a[i]);
+                    } while (++i < hi);
+                }
+            }
+            index = fence;
+        }
+        
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            if (it != null) {
+                if (it.hasNext()) {
+                    action.accept(it.nextDouble());
+                    return true;
+                }
+                it = null;
+                index = fence;
+            } else if (index < fence) {
+                action.accept(array[index++]);
+                return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
new file mode 100644
index 0000000..a67579c
--- /dev/null
+++ b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
@@ -0,0 +1,84 @@
+package one.util.streamex;
+
+import static org.junit.Assert.*;
+import static one.util.streamex.TestHelpers.*;
+
+import java.util.List;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.StreamSupport;
+
+import org.junit.Test;
+
+public class UnknownSizeSpliteratorTest {
+    @Test
+    public void testSplit() {
+        List<Integer> input = IntStreamEx.range(100).boxed().toList();
+        Spliterator<Integer> spliterator = new UnknownSizeSpliterator.USOfRef<>(input.iterator());
+        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
+        AtomicInteger count = new AtomicInteger();
+        assertTrue(spliterator.tryAdvance(count::addAndGet));
+        assertTrue(spliterator.tryAdvance(count::addAndGet));
+        assertEquals(1, count.get());
+        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
+        Spliterator<Integer> spliterator2 = spliterator.trySplit();
+        assertEquals(49, spliterator.estimateSize());
+        assertEquals(49, spliterator2.estimateSize());
+        assertTrue(spliterator.tryAdvance(count::addAndGet));
+        assertTrue(spliterator2.tryAdvance(count::addAndGet));
+        assertEquals(48, spliterator.estimateSize());
+        assertEquals(48, spliterator2.estimateSize());
+        assertEquals(54, count.get());
+    }
+
+    @Test
+    public void testRefSpliterator() {
+        for (int size : new int[] { 1, 5, 100, 1000, 1023, 1024, 1025, 2049 }) {
+            List<Integer> input = IntStreamEx.range(size).boxed().toList();
+            checkSpliterator(String.valueOf(size), input, () -> new UnknownSizeSpliterator.USOfRef<>(input.iterator()));
+        }
+    }
+
+    @Test
+    public void testIntSpliterator() {
+        for (int size : new int[] { 1, 5, 100, 1000, 1023, 1024, 1025, 2049 }) {
+            int[] input = IntStreamEx.range(size).toArray();
+            checkSpliterator(String.valueOf(size), IntStreamEx.of(input).boxed().toList(),
+                () -> new UnknownSizeSpliterator.USOfInt(Spliterators.iterator(Spliterators.spliterator(input, 0))));
+        }
+    }
+
+    @Test
+    public void testLongSpliterator() {
+        for (int size : new int[] { 1, 5, 100, 1000, 1023, 1024, 1025, 2049 }) {
+            long[] input = LongStreamEx.range(size).toArray();
+            checkSpliterator(String.valueOf(size), LongStreamEx.of(input).boxed().toList(),
+                () -> new UnknownSizeSpliterator.USOfLong(Spliterators.iterator(Spliterators.spliterator(input, 0))));
+        }
+    }
+    
+    @Test
+    public void testDoubleSpliterator() {
+        for (int size : new int[] { 1, 5, 100, 1000, 1023, 1024, 1025, 2049 }) {
+            double[] input = LongStreamEx.range(size).asDoubleStream().toArray();
+            checkSpliterator(String.valueOf(size), DoubleStreamEx.of(input).boxed().toList(),
+                () -> new UnknownSizeSpliterator.USOfDouble(Spliterators.iterator(Spliterators.spliterator(input, 0))));
+        }
+    }
+    
+    @Test
+    public void testAsStream() {
+        List<Integer> input = IntStreamEx.range(100).boxed().toList();
+        assertEquals(4950, StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), false)
+                .mapToInt(x -> x).sum());
+        assertEquals(4950,
+            StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), true).mapToInt(x -> x).sum());
+
+        input = IntStreamEx.range(5000).boxed().toList();
+        assertEquals(12497500, StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), false)
+                .mapToInt(x -> x).sum());
+        assertEquals(12497500, StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), true)
+                .mapToInt(x -> x).sum());
+    }
+}
