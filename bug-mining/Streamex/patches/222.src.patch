diff --git a/src/main/java/one/util/streamex/CombinationSpliterator.java b/src/main/java/one/util/streamex/CombinationSpliterator.java
new file mode 100644
index 0000000..f470d01
--- /dev/null
+++ b/src/main/java/one/util/streamex/CombinationSpliterator.java
@@ -0,0 +1,124 @@
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+/* package */ final class CombinationSpliterator implements Spliterator<int[]> {
+    private long pos;
+    private int[] value;
+    private final long fence;
+    private final int n;
+
+    public CombinationSpliterator(int n, long pos, long fence, int[] value) {
+        this.n = n;
+        this.pos = pos;
+        this.fence = fence;
+        this.value = value;
+    }
+    @Override
+    public void forEachRemaining(Consumer<? super int[]> action) {
+        long rest = pos - fence;
+        pos = fence;
+        while (rest > 0) {
+            action.accept(value.clone());
+            if (--rest > 0) {
+                step(value, n);
+            }
+        }
+    }
+
+    @Override
+    public Spliterator<int[]> trySplit() {
+        if (pos - fence < 2) return null;
+        long newPos = (fence + pos) >>> 1;
+
+        CombinationSpliterator result = new CombinationSpliterator(n, pos, newPos, value);
+        value = jump(newPos - 1, value.length, n);
+        pos = newPos;
+        return result;
+    }
+
+    @Override
+    public long estimateSize() {
+        return pos - fence;
+    }
+
+    @Override
+    public int characteristics() {
+        return DISTINCT | IMMUTABLE | NONNULL | ORDERED | SIZED | SUBSIZED;
+    }
+
+    static void step(int[] value, int n) {
+        int i, k = value.length;
+        for (i = k; --i >= 0 && ++value[i] >= n; ) {
+            n--;
+        }
+
+        while (++i < k) {
+            value[i] = value[i - 1] + 1;
+        }
+    }
+
+    static int[] jump(long newPos, int k, int n) {
+        int[] newValue = new int[k];
+        int curK = k - 1;
+        long bound = 0;
+        for (int i = 0; i < k; i++) {
+            long cnk = 1;
+            int curN = curK;
+            while (newPos >= bound + cnk) {
+                bound += cnk;
+                curN++;
+                cnk = cnk * curN / (curN - curK);
+            }
+            curK--;
+            newValue[i] = n - curN - 1;
+        }
+        return newValue;
+    }
+
+
+    static long gcd(long a, long b) {
+        while (b != 0) {
+            long t = a % b;
+            a = b;
+            b = t;
+        }
+        return a;
+    }
+
+    /**
+     * @param n n > k
+     * @param k k > 0
+     * @return CNK(n, k)
+     */
+    static long cnk(int n, int k) {
+        long size = 1;
+
+        int rest = n;
+        for (long div = 1; div <= k; ++div, --rest) {
+            long gcd = gcd(size, div);
+            size /= gcd;
+            long t = rest / (div / gcd);
+
+            if (size > Long.MAX_VALUE / t) {
+                throw new UnsupportedOperationException("Number of combinations exceed Long.MAX_VALUE: unsupported");
+            }
+
+            size *= t;
+        }
+        return size;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super int[]> action) {
+        if (pos <= fence) {
+            return false;
+        }
+        action.accept(value.clone());
+        if (--pos > fence) {
+            step(value, n);
+        }
+        return true;
+    }
+}
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index b493159..5b9b9bb 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2491,6 +2491,28 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return of(new PermutationSpliterator(length));
     }
 
+    public static StreamEx<int[]> ofCombinations(int n, int k) {
+        if (k < 0) {
+            throw new IllegalArgumentException("k is negative: " + k);
+        }
+        if (n < 0) {
+            throw new IllegalArgumentException("n is negative: " + n);
+        }
+        if (k > n) {
+            return StreamEx.empty();
+        }
+        if (k == 0) {
+            return StreamEx.of(new int[0]);
+        }
+        long size = CombinationSpliterator.cnk(n, k);
+        int[] value = new int[k];
+        for (int i = 0; i < k; i++) {
+            value[i] = i;
+        }
+
+        return StreamEx.of(new CombinationSpliterator(n, size, 0, value));
+    }
+
     /**
      * Creates a stream from the given input sequence around matches of the
      * given pattern.
diff --git a/src/test/java/one/util/streamex/CombinationSpliteratorTest.java b/src/test/java/one/util/streamex/CombinationSpliteratorTest.java
new file mode 100644
index 0000000..609a67d
--- /dev/null
+++ b/src/test/java/one/util/streamex/CombinationSpliteratorTest.java
@@ -0,0 +1,34 @@
+package one.util.streamex;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+
+public class CombinationSpliteratorTest {
+    @Test
+    public void testStepJump() {
+        int[][] nk = {
+                {1, 1},
+                {1, 10},
+                {9, 10},
+                {5, 10},
+                {2, 5},
+                {3, 5},
+                {8, 16},
+                {7, 20},
+                {15, 20},
+                {20, 20}
+        };
+        for (int[] ints : nk) {
+            int k = ints[0];
+            int n = ints[1];
+            int[] values = IntStreamEx.range(k).toArray();
+            long size = CombinationSpliterator.cnk(n, k);
+            assertArrayEquals("n=" + n + ", k=" + k, values, CombinationSpliterator.jump(size - 1, k, n));
+            for (long cur = 1; cur < size; cur++) {
+                CombinationSpliterator.step(values, n);
+                assertArrayEquals("n=" + n + ", k=" + k + ", cur = " + cur, values, CombinationSpliterator.jump(size - 1 - cur, k, n));
+            }
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 6f9dc30..d6b1d96 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1,12 +1,12 @@
 /*
  * Copyright 2015, 2016 Tagir Vetaleev
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *     http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -2063,4 +2063,33 @@ public class StreamExTest {
             assertEquals(Optional.empty(), s.get().filter(x -> x < 0).ifEmpty(s.get().filter(x -> x < 0)).findFirst());
         }));
     }
+
+    @Test
+    public void testOfCombinations() {
+        List<String> expectedN5K3 = asList("[0, 1, 2]", "[0, 1, 3]", "[0, 1, 4]", "[0, 2, 3]", "[0, 2, 4]", "[0, 3, 4]", "[1, 2, 3]", "[1, 2, 4]", "[1, 3, 4]", "[2, 3, 4]");
+        List<String> expectedN5K2 = asList("[0, 1]", "[0, 2]", "[0, 3]", "[0, 4]", "[1, 2]", "[1, 3]", "[1, 4]", "[2, 3]", "[2, 4]", "[3, 4]");
+
+        streamEx(() -> StreamEx.ofCombinations(5, 3), s ->
+                assertEquals(expectedN5K3, s.get().map(Arrays::toString).collect(Collectors.toList())));
+        streamEx(() -> StreamEx.ofCombinations(20, 7), s ->
+                assertEquals(Optional.empty(), s.get().map(Arrays::toString).distinct(2).findFirst()));
+        streamEx(() -> StreamEx.ofCombinations(7, 20), s ->
+                assertEquals(Optional.empty(), s.get().map(Arrays::toString).findFirst()));
+        streamEx(() -> StreamEx.ofCombinations(5, 2), s ->
+                assertEquals(expectedN5K2, s.get().map(Arrays::toString).collect(Collectors.toList())));
+        streamEx(() -> StreamEx.ofCombinations(5, 0), s ->
+                assertEquals(asList("[]"), s.get().map(Arrays::toString).collect(Collectors.toList())));
+        streamEx(() -> StreamEx.ofCombinations(5, 5), s ->
+                assertEquals(asList("[0, 1, 2, 3, 4]"), s.get().map(Arrays::toString).collect(Collectors.toList())));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testOfCombinationsNegativeN() {
+        StreamEx.ofCombinations(-1, 0);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testOfCombinationsNegativeK() {
+        StreamEx.ofCombinations(0, -1);
+    }
 }
