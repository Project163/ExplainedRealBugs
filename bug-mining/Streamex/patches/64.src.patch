diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index e5393c4..bc6a651 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -56,7 +56,7 @@ import static one.util.streamex.StreamExInternals.*;
         private boolean checked;
         private final Spliterator<T> source;
         private T cur;
-    
+
         TDOfRef(Spliterator<T> source, boolean drop, Predicate<? super T> predicate) {
             super(source.estimateSize(), source.characteristics()
                 & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL | DISTINCT));
@@ -64,12 +64,12 @@ import static one.util.streamex.StreamExInternals.*;
             this.predicate = predicate;
             this.source = source;
         }
-    
+
         @Override
         public Comparator<? super T> getComparator() {
             return source.getComparator();
         }
-    
+
         @Override
         public boolean tryAdvance(Consumer<? super T> action) {
             if (drop) {
@@ -91,7 +91,7 @@ import static one.util.streamex.StreamExInternals.*;
             checked = true;
             return false;
         }
-    
+
         @Override
         public void accept(T t) {
             this.cur = t;
@@ -347,11 +347,13 @@ import static one.util.streamex.StreamExInternals.*;
             Spliterator<A> spltr;
             if (!spliterator.hasCharacteristics(Spliterator.ORDERED)
                 || collector.characteristics().contains(Characteristics.UNORDERED)) {
-                spltr = new UnorderedCancellableSpliterator<>(spliterator, collector.supplier(), acc, combiner, finished);
+                spltr = new UnorderedCancellableSpliterator<>(spliterator, collector.supplier(), acc, combiner,
+                        finished);
             } else {
                 spltr = new OrderedCancellableSpliterator<>(spliterator, collector.supplier(), acc, combiner, finished);
             }
-            return collector.finisher().apply(strategy().newStreamEx(StreamSupport.stream(spltr, true)).findFirst().get());
+            return collector.finisher().apply(
+                strategy().newStreamEx(StreamSupport.stream(spltr, true)).findFirst().get());
         }
         return rawCollect(collector);
     }
@@ -1154,12 +1156,12 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     /**
-     * Folds the elements of this stream using the provided identity object and
+     * Folds the elements of this stream using the provided seed object and
      * accumulation function, going left to right. This is equivalent to:
      * 
      * <pre>
      * {@code
-     *     U result = identity;
+     *     U result = seed;
      *     for (T element : this stream)
      *         result = accumulator.apply(result, element)
      *     return result;
@@ -1181,8 +1183,8 @@ import static one.util.streamex.StreamExInternals.*;
      *
      * @param <U>
      *            The type of the result
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
@@ -1195,8 +1197,8 @@ import static one.util.streamex.StreamExInternals.*;
      * @see #reduce(Object, BiFunction, BinaryOperator)
      * @since 0.2.0
      */
-    public <U> U foldLeft(U identity, BiFunction<U, ? super T, U> accumulator) {
-        Box<U> result = new Box<>(identity);
+    public <U> U foldLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
+        Box<U> result = new Box<>(seed);
         forEachOrdered(t -> result.a = accumulator.apply(result.a, t));
         return result.a;
     }
@@ -1252,7 +1254,7 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     /**
-     * Folds the elements of this stream using the provided identity object and
+     * Folds the elements of this stream using the provided seed object and
      * accumulation function, going right to left.
      * 
      * <p>
@@ -1272,8 +1274,8 @@ import static one.util.streamex.StreamExInternals.*;
      *
      * @param <U>
      *            The type of the result
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
@@ -1286,9 +1288,9 @@ import static one.util.streamex.StreamExInternals.*;
      * @see #reduce(Object, BiFunction, BinaryOperator)
      * @since 0.2.2
      */
-    public <U> U foldRight(U identity, BiFunction<? super T, U, U> accumulator) {
+    public <U> U foldRight(U seed, BiFunction<? super T, U, U> accumulator) {
         return toListAndThen(list -> {
-            U result = identity;
+            U result = seed;
             for (int i = list.size() - 1; i >= 0; i--)
                 result = accumulator.apply(list.get(i), result);
             return result;
@@ -1339,7 +1341,7 @@ import static one.util.streamex.StreamExInternals.*;
 
     /**
      * Produces a collection containing cumulative results of applying the
-     * accumulation function going left to right.
+     * accumulation function going left to right using given seed value.
      * 
      * <p>
      * This is a terminal operation.
@@ -1357,26 +1359,26 @@ import static one.util.streamex.StreamExInternals.*;
      *
      * @param <U>
      *            The type of the result
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
      *            </a>, <a
      *            href="package-summary.html#Statelessness">stateless</a>
      *            function for incorporating an additional element into a result
-     * @return the {@code List} where the first element is the identity and
-     *         every successor element is the result of applying accumulator
-     *         function to the previous list element and the corresponding
-     *         stream element. The resulting list is one element longer than
-     *         this stream.
+     * @return the {@code List} where the first element is the seed and every
+     *         successor element is the result of applying accumulator function
+     *         to the previous list element and the corresponding stream
+     *         element. The resulting list is one element longer than this
+     *         stream.
      * @see #foldLeft(Object, BiFunction)
      * @see #scanRight(Object, BiFunction)
      * @since 0.2.1
      */
-    public <U> List<U> scanLeft(U identity, BiFunction<U, ? super T, U> accumulator) {
+    public <U> List<U> scanLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
         List<U> result = new ArrayList<>();
-        result.add(identity);
+        result.add(seed);
         forEachOrdered(t -> result.add(accumulator.apply(result.get(result.size() - 1), t)));
         return result;
     }
@@ -1427,7 +1429,7 @@ import static one.util.streamex.StreamExInternals.*;
 
     /**
      * Produces a collection containing cumulative results of applying the
-     * accumulation function going right to left.
+     * accumulation function going right to left using given seed value.
      * 
      * <p>
      * This is a terminal operation.
@@ -1445,15 +1447,15 @@ import static one.util.streamex.StreamExInternals.*;
      *
      * @param <U>
      *            The type of the result
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
      *            </a>, <a
      *            href="package-summary.html#Statelessness">stateless</a>
      *            function for incorporating an additional element into a result
-     * @return the {@code List} where the last element is the identity and every
+     * @return the {@code List} where the last element is the seed and every
      *         predecessor element is the result of applying accumulator
      *         function to the corresponding stream element and the next list
      *         element. The resulting list is one element longer than this
@@ -1463,11 +1465,11 @@ import static one.util.streamex.StreamExInternals.*;
      * @since 0.2.2
      */
     @SuppressWarnings("unchecked")
-    public <U> List<U> scanRight(U identity, BiFunction<? super T, U, U> accumulator) {
+    public <U> List<U> scanRight(U seed, BiFunction<? super T, U, U> accumulator) {
         return toListAndThen(list -> {
             // Reusing the list for different object type as it will save memory
             List<U> result = (List<U>) list;
-            result.add(identity);
+            result.add(seed);
             for (int i = result.size() - 2; i >= 0; i--) {
                 result.set(i, accumulator.apply((T) result.get(i), result.get(i + 1)));
             }
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 62d7a3c..c1cf610 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -646,7 +646,7 @@ public class DoubleStreamEx implements DoubleStream {
     }
 
     /**
-     * Folds the elements of this stream using the provided identity object and
+     * Folds the elements of this stream using the provided seed object and
      * accumulation function, going left to right. This is equivalent to:
      * 
      * <pre>
@@ -671,8 +671,8 @@ public class DoubleStreamEx implements DoubleStream {
      * For parallel stream it's not guaranteed that accumulator will always be
      * executed in the same thread.
      *
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
@@ -684,8 +684,8 @@ public class DoubleStreamEx implements DoubleStream {
      * @see #foldLeft(DoubleBinaryOperator)
      * @since 0.4.0
      */
-    public double foldLeft(double identity, DoubleBinaryOperator accumulator) {
-        double[] box = new double[] { identity };
+    public double foldLeft(double seed, DoubleBinaryOperator accumulator) {
+        double[] box = new double[] { seed };
         stream.forEachOrdered(t -> box[0] = accumulator.applyAsDouble(box[0], t));
         return box[0];
     }
@@ -746,6 +746,35 @@ public class DoubleStreamEx implements DoubleStream {
         return b.asDouble();
     }
 
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the first element of this
+     *         stream and every successor element is the result of applying
+     *         accumulator function to the previous array element and the
+     *         corresponding stream element. The resulting array has the same
+     *         size as this stream.
+     * @see #foldLeft(DoubleBinaryOperator)
+     * @since 0.5.1
+     */
     public double[] scanLeft(DoubleBinaryOperator accumulator) {
         Spliterator.OfDouble spliterator = stream.spliterator();
         double size = spliterator.getExactSizeIfKnown();
@@ -755,6 +784,36 @@ public class DoubleStreamEx implements DoubleStream {
         return buf.toArray();
     }
     
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right using given seed value.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param seed
+     *            the starting value
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the seed and every successor
+     *         element is the result of applying accumulator function to the
+     *         previous array element and the corresponding stream element. The
+     *         resulting array is one element longer than this stream.
+     * @see #foldLeft(double, DoubleBinaryOperator)
+     * @since 0.5.1
+     */
     public double[] scanLeft(double seed, DoubleBinaryOperator accumulator) {
         return prepend(seed).scanLeft(accumulator);
     }
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index d0592d1..23b64be 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -688,12 +688,12 @@ public class IntStreamEx implements IntStream {
     }
 
     /**
-     * Folds the elements of this stream using the provided identity object and
+     * Folds the elements of this stream using the provided seed object and
      * accumulation function, going left to right. This is equivalent to:
      * 
      * <pre>
      * {@code
-     *     int result = identity;
+     *     int result = seed;
      *     for (int element : this stream)
      *         result = accumulator.apply(result, element)
      *     return result;
@@ -713,8 +713,8 @@ public class IntStreamEx implements IntStream {
      * For parallel stream it's not guaranteed that accumulator will always be
      * executed in the same thread.
      *
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
@@ -726,21 +726,80 @@ public class IntStreamEx implements IntStream {
      * @see #foldLeft(IntBinaryOperator)
      * @since 0.4.0
      */
-    public int foldLeft(int identity, IntBinaryOperator accumulator) {
-        int[] box = new int[] { identity };
+    public int foldLeft(int seed, IntBinaryOperator accumulator) {
+        int[] box = new int[] { seed };
         stream.forEachOrdered(t -> box[0] = accumulator.applyAsInt(box[0], t));
         return box[0];
     }
-    
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the first element of this
+     *         stream and every successor element is the result of applying
+     *         accumulator function to the previous array element and the
+     *         corresponding stream element. The resulting array has the same
+     *         size as this stream.
+     * @see #foldLeft(IntBinaryOperator)
+     * @since 0.5.1
+     */
     public int[] scanLeft(IntBinaryOperator accumulator) {
         Spliterator.OfInt spliterator = stream.spliterator();
         long size = spliterator.getExactSizeIfKnown();
-        IntBuffer buf = new IntBuffer(size >= 0 && size <= Integer.MAX_VALUE ? (int)size : INITIAL_SIZE); 
+        IntBuffer buf = new IntBuffer(size >= 0 && size <= Integer.MAX_VALUE ? (int) size : INITIAL_SIZE);
         delegate(spliterator).forEachOrdered(
-            i -> buf.add(buf.size == 0 ? i : accumulator.applyAsInt(buf.data[buf.size-1], i)));
+            i -> buf.add(buf.size == 0 ? i : accumulator.applyAsInt(buf.data[buf.size - 1], i)));
         return buf.toArray();
     }
-    
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right using given seed value.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param seed
+     *            the starting value
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the seed and every successor
+     *         element is the result of applying accumulator function to the
+     *         previous array element and the corresponding stream element. The
+     *         resulting array is one element longer than this stream.
+     * @see #foldLeft(int, IntBinaryOperator)
+     * @since 0.5.1
+     */
     public int[] scanLeft(int seed, IntBinaryOperator accumulator) {
         return prepend(seed).scanLeft(accumulator);
     }
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 1700a95..50c7c63 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -650,12 +650,12 @@ public class LongStreamEx implements LongStream {
     }
 
     /**
-     * Folds the elements of this stream using the provided identity object and
+     * Folds the elements of this stream using the provided seed object and
      * accumulation function, going left to right. This is equivalent to:
      * 
      * <pre>
      * {@code
-     *     long result = identity;
+     *     long result = seed;
      *     for (long element : this stream)
      *         result = accumulator.apply(result, element)
      *     return result;
@@ -675,8 +675,8 @@ public class LongStreamEx implements LongStream {
      * For parallel stream it's not guaranteed that accumulator will always be
      * executed in the same thread.
      *
-     * @param identity
-     *            the identity value
+     * @param seed
+     *            the starting value
      * @param accumulator
      *            a <a
      *            href="package-summary.html#NonInterference">non-interfering
@@ -688,8 +688,8 @@ public class LongStreamEx implements LongStream {
      * @see #foldLeft(LongBinaryOperator)
      * @since 0.4.0
      */
-    public long foldLeft(long identity, LongBinaryOperator accumulator) {
-        long[] box = new long[] { identity };
+    public long foldLeft(long seed, LongBinaryOperator accumulator) {
+        long[] box = new long[] { seed };
         stream.forEachOrdered(t -> box[0] = accumulator.applyAsLong(box[0], t));
         return box[0];
     }
@@ -750,6 +750,35 @@ public class LongStreamEx implements LongStream {
         return b.asLong();
     }
 
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the first element of this
+     *         stream and every successor element is the result of applying
+     *         accumulator function to the previous array element and the
+     *         corresponding stream element. The resulting array has the same
+     *         size as this stream.
+     * @see #foldLeft(LongBinaryOperator)
+     * @since 0.5.1
+     */
     public long[] scanLeft(LongBinaryOperator accumulator) {
         Spliterator.OfLong spliterator = stream.spliterator();
         long size = spliterator.getExactSizeIfKnown();
@@ -759,6 +788,36 @@ public class LongStreamEx implements LongStream {
         return buf.toArray();
     }
     
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right using given seed value.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param seed
+     *            the starting value
+     * @param accumulator
+     *            a <a
+     *            href="package-summary.html#NonInterference">non-interfering
+     *            </a>, <a
+     *            href="package-summary.html#Statelessness">stateless</a>
+     *            function for incorporating an additional element into a result
+     * @return the array where the first element is the seed and every successor
+     *         element is the result of applying accumulator function to the
+     *         previous array element and the corresponding stream element. The
+     *         resulting array is one element longer than this stream.
+     * @see #foldLeft(long, LongBinaryOperator)
+     * @since 0.5.1
+     */
     public long[] scanLeft(long seed, LongBinaryOperator accumulator) {
         return prepend(seed).scanLeft(accumulator);
     }
