diff --git a/CHANGES.md b/CHANGES.md
index be33784..6453166 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -5,6 +5,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 ### 0.6.5
 * [#137] Added: `StreamEx.toNavigableMap()`, `EntryStream.toNavigableMap()`
 * [#141] Added: `StreamEx.flatArray()`, `EntryStream.flatArray()`
+* [#143] Optimized: `AbstractStreamEx.takeWhile/takeWhileInclusive/dropWhile` for parallel unordered case.
 
 ### 0.6.4
 * [#132] Fixed: `StreamEx.parallel(fjp)` does not parallelize underlying Java Stream if it already exists
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 1a141be..f252650 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -1618,7 +1618,9 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * 
      * <p>
      * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
+     * quite expensive on parallel pipelines. Using unordered source or making it
+     * explicitly unordered with {@link #unordered()} call may improve the parallel
+     * processing performance if semantics permit.
      * 
      * @param predicate a non-interfering, stateless predicate to apply to
      *        elements.
@@ -1649,7 +1651,9 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * 
      * <p>
      * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
+     * quite expensive on parallel pipelines. Using unordered source or making it
+     * explicitly unordered with {@link #unordered()} call may improve the parallel
+     * processing performance if semantics permit.
      * 
      * @param predicate a non-interfering, stateless predicate to apply to
      *        elements.
@@ -1679,7 +1683,9 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * 
      * <p>
      * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
+     * quite expensive on parallel pipelines. Using unordered source or making it
+     * explicitly unordered with {@link #unordered()} call may improve the parallel
+     * processing performance if semantics permit.
      * 
      * @param predicate a non-interfering, stateless predicate to apply to
      *        elements.
