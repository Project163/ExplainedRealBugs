diff --git a/CHANGES.md b/CHANGES.md
index 25d19e1..79508de 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -13,6 +13,7 @@ Warning: this release introduces some changes which may break backwards compatib
 * [#77] Added: `MoreCollectors.filtering()/mapping()/flatMapping()` with default downstream Collector `toList()`.
 * [#79] Added: `iterate(seed, predicate, op)` for all stream types.
 * [#83] Changed: `StreamEx.of(Collection)`, `of(Iterator)`, etc. now use `? extends T` type instead of just `T`.
+* [#85] Added: `StreamEx.mapFirstOrElse()/mapLastOrElse()`.
 * [#86] Added: `peekFirst()`, `peekLast()` for all stream types.
 
 
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 731e1f3..f18ad2e 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -103,7 +103,8 @@ Drop entry keys leaving only values | `EntryStream.values()`
 Convert every entry to `String` | `EntryStream.join()`
 Map pair of adjacent elements to the single element | `any.pairMap()`
 Map only first or last element, leaving others as is | `any.mapFirst()/mapLast()`
-Attach the first stream element to every other element | `StreamEx.withFirst()`
+Map stream element providing special mapper function for the first or last element | `any.mapFirstOrElse()/mapLastOrElse()`
+Attach the first stream element to every stream element | `StreamEx.withFirst()`
 
 ### flat-mapping
 
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index ecb1dd8..3b5c561 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -188,6 +188,28 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return supply(new PairSpliterator.PSOfRef<>(mapper, spliterator(), true));
     }
 
+    /**
+     * Returns a stream where the first element is transformed using
+     * {@code firstMapper} function and other elements are transformed using
+     * {@code notFirstMapper} function.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * @param <R> The element type of the new stream element
+     * @param firstMapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the first element
+     * @param notFirstMapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to all elements except the first one.
+     * @return the new stream
+     * @since 0.6.0
+     * @see #mapFirst(Function)
+     */
     public <R> StreamEx<R> mapFirstOrElse(Function<? super T, ? extends R> firstMapper,
             Function<? super T, ? extends R> notFirstMapper) {
         return new StreamEx<>(new PairSpliterator.PSOfRef<>(firstMapper, notFirstMapper, spliterator(), true), context);
@@ -216,6 +238,28 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return supply(new PairSpliterator.PSOfRef<>(mapper, spliterator(), false));
     }
 
+    /**
+     * Returns a stream where the last element is transformed using
+     * {@code lastMapper} function and other elements are transformed using
+     * {@code notLastMapper} function.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * @param <R> The element type of the new stream element
+     * @param notLastMapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to all elements except the last one.
+     * @param lastMapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the last element
+     * @return the new stream
+     * @since 0.6.0
+     * @see #mapFirst(Function)
+     */
     public <R> StreamEx<R> mapLastOrElse(Function<? super T, ? extends R> notLastMapper,
             Function<? super T, ? extends R> lastMapper) {
         return new StreamEx<>(new PairSpliterator.PSOfRef<>(lastMapper, notLastMapper, spliterator(), false), context);
diff --git a/src/test/java/one/util/streamex/EmitterTest.java b/src/test/java/one/util/streamex/EmitterTest.java
index 2105dfa..e2e1e45 100644
--- a/src/test/java/one/util/streamex/EmitterTest.java
+++ b/src/test/java/one/util/streamex/EmitterTest.java
@@ -21,6 +21,7 @@ import static java.util.Arrays.asList;
 
 import java.math.BigInteger;
 import java.util.Iterator;
+import java.util.Queue;
 import java.util.Scanner;
 import java.util.Spliterator;
 import java.util.function.BinaryOperator;
@@ -31,6 +32,7 @@ import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+
 import one.util.streamex.DoubleStreamEx.DoubleEmitter;
 import one.util.streamex.IntStreamEx.IntEmitter;
 import one.util.streamex.LongStreamEx.LongEmitter;
@@ -185,6 +187,16 @@ public class EmitterTest {
         };
     }
     
+    public static <T> Emitter<T> fromQueue(Queue<T> queue, T sentinel) {
+        return action -> {
+            T next = queue.poll();
+            if(next == null || next.equals(sentinel))
+                return null;
+            action.accept(next);
+            return fromQueue(queue, sentinel);
+        };
+    }
+    
     @Test
     public void testEmitter() {
         assertEquals(asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17).stream().toList());
