diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
index 1cfe689..674db5c 100644
--- a/src/main/java/one/util/streamex/BaseStreamEx.java
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -154,12 +154,16 @@ import java.util.stream.BaseStream;
      * {@code chain()} method you can write in more fluent manner:
      * {@code StreamEx.of(input).map(...).chain(s -> batches(s, 10)).filter(...)}.
      * 
+     * <p>
+     * You could even go further and define a method which returns a function
+     * like {@code <T> UnaryOperator<StreamEx<T>> batches(int n)} and use it
+     * like this:
+     * {@code StreamEx.of(input).map(...).chain(batches(10)).filter(...)}.
+     * 
+     * @param <U> the type of the function result.
      * @param mapper function to invoke.
      * @return the result of the function invocation.
      * @since 0.5.4
      */
-    @SuppressWarnings("unchecked")
-    public <U> U chain(Function<? super B, U> mapper) {
-        return mapper.apply((B) this);
-    }
+    abstract public <U> U chain(Function<? super B, U> mapper);
 }
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 01d7324..e6887d0 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1441,6 +1441,13 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), true, predicate));
     }
 
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super DoubleStreamEx, U> mapper) {
+        return mapper.apply(this);
+    }
+
     /**
      * Returns an empty sequential {@code DoubleStreamEx}.
      *
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index edc5dfe..759affc 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -1063,6 +1063,13 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         forEach(toConsumer(action));
     }
 
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super EntryStream<K, V>, U> mapper) {
+        return mapper.apply(this);
+    }
+
     /**
      * Returns an empty sequential {@code EntryStream}.
      *
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 6eaff92..5b28a67 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -1659,6 +1659,13 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return delegate(new PairSpliterator.PSOfInt((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super IntStreamEx, U> mapper) {
+        return mapper.apply(this);
+    }
+
     /**
      * Returns an empty sequential {@code IntStreamEx}.
      *
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index b08052f..f9094ed 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1465,6 +1465,13 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return delegate(new LongStreamEx.TDOfLong(spliterator(), true, predicate));
     }
 
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super LongStreamEx, U> mapper) {
+        return mapper.apply(this);
+    }
+
     /**
      * Returns an empty sequential {@code LongStreamEx}.
      *
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index bc74c4b..1c99bf5 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1520,6 +1520,13 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(spliterator, context);
     }
 
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super StreamEx<T>, U> mapper) {
+        return mapper.apply(this);
+    }
+
     /**
      * Returns an empty sequential {@code StreamEx}.
      *
diff --git a/src/test/java/one/util/streamex/BaseStreamExTest.java b/src/test/java/one/util/streamex/BaseStreamExTest.java
index 4400f17..9c52db5 100644
--- a/src/test/java/one/util/streamex/BaseStreamExTest.java
+++ b/src/test/java/one/util/streamex/BaseStreamExTest.java
@@ -105,4 +105,11 @@ public class BaseStreamExTest {
         }
         fail("No exception");
     }
+    
+    @Test
+    public void testChain() {
+        assertArrayEquals(new double[] { 2, 2, 6, 2, 6 }, IntStreamEx.of(3, 4, 5).chain(s -> s.boxed()).chain(
+            s -> s.flatMapToLong(LongStreamEx::range)).chain(s -> s.filter(n -> n % 2 != 0).asDoubleStream()).chain(
+            s -> s.map(x -> x * 2)).toArray(), 0.0);
+    }
 }
