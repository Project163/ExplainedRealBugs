diff --git a/src/main/java/one/util/streamex/AtomicDouble.java b/src/main/java/one/util/streamex/AtomicDouble.java
new file mode 100644
index 0000000..b0f4044
--- /dev/null
+++ b/src/main/java/one/util/streamex/AtomicDouble.java
@@ -0,0 +1,113 @@
+package one.util.streamex;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.DoubleBinaryOperator;
+
+import static java.lang.Double.doubleToLongBits;
+import static java.lang.Double.longBitsToDouble;
+
+public final class AtomicDouble extends Number {
+    private final AtomicLong bits;
+
+    public AtomicDouble() {
+        this(0.0d);
+    }
+
+    public AtomicDouble(double initialValue) {
+        bits = new AtomicLong(toLong(initialValue));
+    }
+
+    /**
+     * Atomically sets the value to the given updated value
+     * if the current value {@code ==} the expected value.
+     *
+     * @param expect the expected value
+     * @param update the new value
+     * @return {@code true} if successful. False return indicates that
+     * the actual value was not equal to the expected value.
+     */
+    public final boolean compareAndSet(double expect, double update) {
+        return bits.compareAndSet(toLong(expect), toLong(update));
+    }
+
+    public final double get() {
+        return toDouble(bits.get());
+    }
+
+    /**
+     * Atomically updates the current value with the results of
+     * applying the given function to the current and given values,
+     * returning the updated value. The function should be
+     * side-effect-free, since it may be re-applied when attempted
+     * updates fail due to contention among threads.  The function
+     * is applied with the current value as its first argument,
+     * and the given update as the second argument.
+     *
+     * @param x                   the update value
+     * @param accumulatorFunction a side-effect-free function of two arguments
+     * @return the updated value
+     */
+    public final double accumulateAndGet(double x, DoubleBinaryOperator accumulatorFunction) {
+        double prev, next;
+        do {
+            prev = get();
+            next = accumulatorFunction.applyAsDouble(prev, x);
+        } while (!compareAndSet(prev, next));
+        return next;
+    }
+
+    /**
+     * Atomically updates the current value with the results of
+     * applying the given function to the current and given values,
+     * returning the previous value. The function should be
+     * side-effect-free, since it may be re-applied when attempted
+     * updates fail due to contention among threads.  The function
+     * is applied with the current value as its first argument,
+     * and the given update as the second argument.
+     *
+     * @param x                   the update value
+     * @param accumulatorFunction a side-effect-free function of two arguments
+     * @return the previous value
+     */
+    public final double getAndAccumulate(double x, DoubleBinaryOperator accumulatorFunction) {
+        double prev, next;
+        do {
+            prev = get();
+            next = accumulatorFunction.applyAsDouble(prev, x);
+        } while (!compareAndSet(prev, next));
+        return prev;
+    }
+
+    @Override
+    public long longValue() {
+        return (long) get();
+    }
+
+    @Override
+    public String toString() {
+        return Double.toString(get());
+    }
+
+    @Override
+    public int intValue() {
+        return (int) get();
+    }
+
+    @Override
+    public float floatValue() {
+        return (float) get();
+    }
+
+    @Override
+    public double doubleValue() {
+        return get();
+    }
+
+    private static double toDouble(long l) {
+        return longBitsToDouble(l);
+    }
+
+    private static long toLong(double delta) {
+        return doubleToLongBits(delta);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 08a72b3..68eba0d 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1,2002 +1,2004 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.nio.Buffer;
-import java.util.AbstractMap;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.DoubleSummaryStatistics;
-import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.OptionalDouble;
-import java.util.OptionalLong;
-import java.util.PrimitiveIterator;
-import java.util.PrimitiveIterator.OfDouble;
-import java.util.Random;
-import java.util.Spliterator;
-import java.util.Spliterators;
-import java.util.concurrent.ForkJoinPool;
-import java.util.function.BiConsumer;
-import java.util.function.DoubleBinaryOperator;
-import java.util.function.DoubleConsumer;
-import java.util.function.DoubleFunction;
-import java.util.function.DoublePredicate;
-import java.util.function.DoubleSupplier;
-import java.util.function.DoubleToIntFunction;
-import java.util.function.DoubleToLongFunction;
-import java.util.function.DoubleUnaryOperator;
-import java.util.function.Function;
-import java.util.function.ObjDoubleConsumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import java.util.stream.Collector;
-import java.util.stream.DoubleStream;
-import java.util.stream.IntStream;
-import java.util.stream.LongStream;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
-
-import static one.util.streamex.Internals.Box;
-import static one.util.streamex.Internals.DoubleBuffer;
-import static one.util.streamex.Internals.FloatBuffer;
-import static one.util.streamex.Internals.INITIAL_SIZE;
-import static one.util.streamex.Internals.ObjDoubleBox;
-import static one.util.streamex.Internals.PrimitiveBox;
-import static one.util.streamex.Internals.checkLength;
-import static one.util.streamex.Internals.intSize;
-import static one.util.streamex.Internals.rangeCheck;
-
-/**
- * A {@link DoubleStream} implementation with additional functionality
- * 
- * @author Tagir Valeev
- */
-public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble, DoubleStreamEx> implements
-        DoubleStream {
-    DoubleStreamEx(DoubleStream stream, StreamContext context) {
-        super(stream, context);
-    }
-
-    DoubleStreamEx(Spliterator.OfDouble spliterator, StreamContext context) {
-        super(spliterator, context);
-    }
-
-    @Override
-    DoubleStream createStream() {
-        return StreamSupport.doubleStream(spliterator, isParallel());
-    }
-
-    private static DoubleStreamEx seq(DoubleStream stream) {
-        return new DoubleStreamEx(stream, StreamContext.SEQUENTIAL);
-    }
-
-    final DoubleStreamEx delegate(Spliterator.OfDouble spliterator) {
-        return new DoubleStreamEx(spliterator, context);
-    }
-
-    @Override
-    public DoubleStreamEx unordered() {
-        return (DoubleStreamEx) super.unordered();
-    }
-
-    @Override
-    public DoubleStreamEx onClose(Runnable closeHandler) {
-        return (DoubleStreamEx) super.onClose(closeHandler);
-    }
-
-    @Override
-    public DoubleStreamEx filter(DoublePredicate predicate) {
-        return new DoubleStreamEx(stream().filter(predicate), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that don't
-     * match the given predicate.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param predicate a non-interfering, stateless predicate to apply to each
-     *        element to determine if it should be excluded
-     * @return the new stream
-     */
-    public DoubleStreamEx remove(DoublePredicate predicate) {
-        return filter(predicate.negate());
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that strictly
-     * greater than the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public DoubleStreamEx greater(double value) {
-        return filter(val -> val > value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that strictly
-     * less than the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public DoubleStreamEx less(double value) {
-        return filter(val -> val < value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that greater
-     * than or equal to the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public DoubleStreamEx atLeast(double value) {
-        return filter(val -> val >= value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that less than
-     * or equal to the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public DoubleStreamEx atMost(double value) {
-        return filter(val -> val <= value);
-    }
-
-    @Override
-    public DoubleStreamEx map(DoubleUnaryOperator mapper) {
-        return new DoubleStreamEx(stream().map(mapper), context);
-    }
-
-    /**
-     * Returns a stream where the first element is the replaced with the result
-     * of applying the given function while the other elements are left intact.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     *
-     * @param mapper a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to apply to the first element
-     * @return the new stream
-     * @since 0.4.1
-     */
-    public DoubleStreamEx mapFirst(DoubleUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble((a, b) -> b, mapper, spliterator(),
-                PairSpliterator.MODE_MAP_FIRST));
-    }
-
-    /**
-     * Returns a stream where the last element is the replaced with the result
-     * of applying the given function while the other elements are left intact.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The mapper function is called at most once. It could be not called at all
-     * if the stream is empty or there is short-circuiting operation downstream.
-     *
-     * @param mapper a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to apply to the last element
-     * @return the new stream
-     * @since 0.4.1
-     */
-    public DoubleStreamEx mapLast(DoubleUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble((a, b) -> a, mapper, spliterator(),
-                PairSpliterator.MODE_MAP_LAST));
-    }
-
-    @Override
-    public <U> StreamEx<U> mapToObj(DoubleFunction<? extends U> mapper) {
-        return new StreamEx<>(stream().mapToObj(mapper), context);
-    }
-
-    @Override
-    public IntStreamEx mapToInt(DoubleToIntFunction mapper) {
-        return new IntStreamEx(stream().mapToInt(mapper), context);
-    }
-
-    @Override
-    public LongStreamEx mapToLong(DoubleToLongFunction mapper) {
-        return new LongStreamEx(stream().mapToLong(mapper), context);
-    }
-
-    /**
-     * Returns an {@link EntryStream} consisting of the {@link Entry} objects
-     * which keys and values are results of applying the given functions to the
-     * elements of this stream.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param <K> The {@code Entry} key type
-     * @param <V> The {@code Entry} value type
-     * @param keyMapper a non-interfering, stateless function to apply to each
-     *        element
-     * @param valueMapper a non-interfering, stateless function to apply to each
-     *        element
-     * @return the new stream
-     * @since 0.3.1
-     */
-    public <K, V> EntryStream<K, V> mapToEntry(DoubleFunction<? extends K> keyMapper,
-            DoubleFunction<? extends V> valueMapper) {
-        return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
-                valueMapper.apply(t))), context);
-    }
-
-    @Override
-    public DoubleStreamEx flatMap(DoubleFunction<? extends DoubleStream> mapper) {
-        return new DoubleStreamEx(stream().flatMap(mapper), context);
-    }
-
-    /**
-     * Returns an {@link IntStreamEx} consisting of the results of replacing
-     * each element of this stream with the contents of a mapped stream produced
-     * by applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces an {@code IntStream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public IntStreamEx flatMapToInt(DoubleFunction<? extends IntStream> mapper) {
-        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
-    }
-
-    /**
-     * Returns a {@link LongStreamEx} consisting of the results of replacing
-     * each element of this stream with the contents of a mapped stream produced
-     * by applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces a {@code LongStream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public LongStreamEx flatMapToLong(DoubleFunction<? extends LongStream> mapper) {
-        return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), context);
-    }
-
-    /**
-     * Returns a {@link StreamEx} consisting of the results of replacing each
-     * element of this stream with the contents of a mapped stream produced by
-     * applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param <R> The element type of the new stream
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces a {@code Stream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public <R> StreamEx<R> flatMapToObj(DoubleFunction<? extends Stream<R>> mapper) {
-        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
-    }
-
-    /**
-     * Returns a new stream containing all the elements of the original stream interspersed with
-     * given delimiter.
-     * 
-     * <p>
-     * For example, {@code DoubleStreamEx.of(1, 2, 3).intersperse(4)} will yield a stream containing
-     * five elements: 1, 4, 2, 4, 3.
-     * 
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
-     * 
-     * @param delimiter a delimiter to be inserted between each pair of elements
-     * @return the new stream
-     * @since 0.6.6
-     */
-    public DoubleStreamEx intersperse(int delimiter) {
-        return new DoubleStreamEx(stream().flatMap(s -> DoubleStreamEx.of(delimiter, s)).skip(1), context);
-    }
-
-    @Override
-    public DoubleStreamEx distinct() {
-        return new DoubleStreamEx(stream().distinct(), context);
-    }
-
-    @Override
-    public DoubleStreamEx sorted() {
-        return new DoubleStreamEx(stream().sorted(), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream sorted
-     * according to the given comparator. Stream elements are boxed before
-     * passing to the comparator.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     * 
-     * @param comparator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        {@code Comparator} to be used to compare stream elements
-     * @return the new stream
-     */
-    public DoubleStreamEx sorted(Comparator<Double> comparator) {
-        return new DoubleStreamEx(stream().boxed().sorted(comparator).mapToDouble(Double::doubleValue), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream in reverse
-     * sorted order. The elements are compared for equality according to
-     * {@link java.lang.Double#compare(double, double)}.
-     *
-     * <p>
-     * This is a stateful intermediate operation.
-     *
-     * @return the new stream
-     * @since 0.0.8
-     */
-    public DoubleStreamEx reverseSorted() {
-        return new DoubleStreamEx(stream().mapToLong(d -> {
-            long l = Double.doubleToRawLongBits(d);
-            return l ^ (((l >>> 63) - 1) | Long.MIN_VALUE);
-        }).sorted().mapToDouble(l -> Double.longBitsToDouble(l ^ ((-(l >>> 63)) | Long.MIN_VALUE))), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the natural order of the keys extracted by provided
-     * function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public <V extends Comparable<? super V>> DoubleStreamEx sortedBy(DoubleFunction<V> keyExtractor) {
-        return sorted(Comparator.comparing(keyExtractor::apply));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the int values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public DoubleStreamEx sortedByInt(DoubleToIntFunction keyExtractor) {
-        return sorted(Comparator.comparingInt(keyExtractor::applyAsInt));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the long values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public DoubleStreamEx sortedByLong(DoubleToLongFunction keyExtractor) {
-        return sorted(Comparator.comparingLong(keyExtractor::applyAsLong));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the double values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public DoubleStreamEx sortedByDouble(DoubleUnaryOperator keyExtractor) {
-        return sorted(Comparator.comparingDouble(keyExtractor::applyAsDouble));
-    }
-
-    @Override
-    public DoubleStreamEx peek(DoubleConsumer action) {
-        return new DoubleStreamEx(stream().peek(action), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, additionally
-     * performing the provided action on the first stream element when it's
-     * consumed from the resulting stream.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The action is called at most once. For parallel stream pipelines, it's
-     * not guaranteed in which thread it will be executed, so if it modifies
-     * shared state, it is responsible for providing the required
-     * synchronization.
-     *
-     * <p>
-     * Note that the action might not be called at all if the first element is
-     * not consumed from the input (for example, if there's short-circuiting
-     * operation downstream which stopped the stream before the first element).
-     * 
-     * <p>
-     * This method exists mainly to support debugging.
-     *
-     * @param action a
-     *        <a href="package-summary.html#NonInterference"> non-interfering
-     *        </a> action to perform on the first stream element as it is
-     *        consumed from the stream
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public DoubleStreamEx peekFirst(DoubleConsumer action) {
-        return mapFirst(x -> {
-            action.accept(x);
-            return x;
-        });
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, additionally
-     * performing the provided action on the last stream element when it's
-     * consumed from the resulting stream.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The action is called at most once. For parallel stream pipelines, it's
-     * not guaranteed in which thread it will be executed, so if it modifies
-     * shared state, it is responsible for providing the required
-     * synchronization.
-     * 
-     * <p>
-     * Note that the action might not be called at all if the last element is
-     * not consumed from the input (for example, if there's short-circuiting
-     * operation downstream).
-     * 
-     * <p>
-     * This method exists mainly to support debugging.
-     *
-     * @param action a
-     *        <a href="package-summary.html#NonInterference"> non-interfering
-     *        </a> action to perform on the first stream element as it is
-     *        consumed from the stream
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public DoubleStreamEx peekLast(DoubleConsumer action) {
-        return mapLast(x -> {
-            action.accept(x);
-            return x;
-        });
-    }
-
-    @Override
-    public DoubleStreamEx limit(long maxSize) {
-        return new DoubleStreamEx(stream().limit(maxSize), context);
-    }
-
-    @Override
-    public DoubleStreamEx skip(long n) {
-        return new DoubleStreamEx(stream().skip(n), context);
-    }
-
-    @Override
-    public void forEach(DoubleConsumer action) {
-        if (spliterator != null && !isParallel()) {
-            spliterator().forEachRemaining(action);
-        } else {
-            if (context.fjp != null)
-                context.terminate(() -> {
-                    stream().forEach(action);
-                    return null;
-                });
-            else {
-                stream().forEach(action);
-            }
-        }
-    }
-
-    @Override
-    public void forEachOrdered(DoubleConsumer action) {
-        if (spliterator != null && !isParallel()) {
-            spliterator().forEachRemaining(action);
-        } else {
-            if (context.fjp != null)
-                context.terminate(() -> {
-                    stream().forEachOrdered(action);
-                    return null;
-                });
-            else {
-                stream().forEachOrdered(action);
-            }
-        }
-    }
-
-    @Override
-    public double[] toArray() {
-        if (context.fjp != null)
-            return context.terminate(stream()::toArray);
-        return stream().toArray();
-    }
-
-    /**
-     * Returns a {@code float[]} array containing the elements of this stream
-     * which are converted to floats using {@code (float)} cast operation.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @return an array containing the elements of this stream
-     * @since 0.3.0
-     */
-    public float[] toFloatArray() {
-        if (isParallel())
-            return collect(DoubleCollector.toFloatArray());
-        java.util.Spliterator.OfDouble spliterator = spliterator();
-        int size = intSize(spliterator);
-        FloatBuffer buf;
-        if (size >= 0) {
-            buf = new FloatBuffer(size);
-            spliterator.forEachRemaining((DoubleConsumer) buf::addUnsafe);
-        } else {
-            buf = new FloatBuffer();
-            spliterator.forEachRemaining((DoubleConsumer) buf::add);
-        }
-        return buf.toArray();
-    }
-
-    @Override
-    public double reduce(double identity, DoubleBinaryOperator op) {
-        if (context.fjp != null)
-            return context.terminate(() -> stream().reduce(identity, op));
-        return stream().reduce(identity, op);
-    }
-
-    @Override
-    public OptionalDouble reduce(DoubleBinaryOperator op) {
-        if (context.fjp != null)
-            return context.terminate(op, stream()::reduce);
-        return stream().reduce(op);
-    }
-
-    /**
-     * Folds the elements of this stream using the provided accumulation
-     * function, going left to right. This is equivalent to:
-     * 
-     * <pre>
-     * {@code
-     *     boolean foundAny = false;
-     *     double result = 0;
-     *     for (double element : this stream) {
-     *         if (!foundAny) {
-     *             foundAny = true;
-     *             result = element;
-     *         }
-     *         else
-     *             result = accumulator.apply(result, element);
-     *     }
-     *     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();
-     * }
-     * </pre>
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. If your accumulator function is
-     * associative, consider using {@link #reduce(DoubleBinaryOperator)} method.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     *
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the result of the folding
-     * @see #foldLeft(double, DoubleBinaryOperator)
-     * @see #reduce(DoubleBinaryOperator)
-     * @since 0.4.0
-     */
-    public OptionalDouble foldLeft(DoubleBinaryOperator accumulator) {
-        PrimitiveBox b = new PrimitiveBox();
-        forEachOrdered(t -> {
-            if (b.b)
-                b.d = accumulator.applyAsDouble(b.d, t);
-            else {
-                b.d = t;
-                b.b = true;
-            }
-        });
-        return b.asDouble();
-    }
-
-    /**
-     * Folds the elements of this stream using the provided seed object and
-     * accumulation function, going left to right. This is equivalent to:
-     * 
-     * <pre>
-     * {@code
-     *     double result = identity;
-     *     for (double element : this stream)
-     *         result = accumulator.apply(result, element)
-     *     return result;
-     * }
-     * </pre>
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. If your accumulator function is
-     * associative, consider using {@link #reduce(double, DoubleBinaryOperator)}
-     * method.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     *
-     * @param seed the starting value
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the result of the folding
-     * @see #reduce(double, DoubleBinaryOperator)
-     * @see #foldLeft(DoubleBinaryOperator)
-     * @since 0.4.0
-     */
-    public double foldLeft(double seed, DoubleBinaryOperator accumulator) {
-        double[] box = new double[] { seed };
-        forEachOrdered(t -> box[0] = accumulator.applyAsDouble(box[0], t));
-        return box[0];
-    }
-
-    /**
-     * Produces an array containing cumulative results of applying the
-     * accumulation function going left to right.
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right.
-     *
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the array where the first element is the first element of this
-     *         stream and every successor element is the result of applying
-     *         accumulator function to the previous array element and the
-     *         corresponding stream element. The resulting array has the same
-     *         length as this stream.
-     * @see #foldLeft(DoubleBinaryOperator)
-     * @since 0.5.1
-     */
-    public double[] scanLeft(DoubleBinaryOperator accumulator) {
-        Spliterator.OfDouble spliterator = spliterator();
-        int size = intSize(spliterator);
-        DoubleBuffer buf = new DoubleBuffer(size == -1 ? INITIAL_SIZE : size);
-        delegate(spliterator).forEachOrdered(i -> buf.add(buf.size == 0 ? i
-                : accumulator.applyAsDouble(buf.data[buf.size - 1], i)));
-        return buf.toArray();
-    }
-
-    /**
-     * Produces an array containing cumulative results of applying the
-     * accumulation function going left to right using given seed value.
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right.
-     *
-     * @param seed the starting value
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the array where the first element is the seed and every successor
-     *         element is the result of applying accumulator function to the
-     *         previous array element and the corresponding stream element. The
-     *         resulting array is one element longer than this stream.
-     * @see #foldLeft(double, DoubleBinaryOperator)
-     * @since 0.5.1
-     */
-    public double[] scanLeft(double seed, DoubleBinaryOperator accumulator) {
-        return prepend(seed).scanLeft(accumulator);
-    }
-
-    /**
-     * {@inheritDoc}
-     * 
-     * @see #collect(DoubleCollector)
-     */
-    @Override
-    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        if (context.fjp != null)
-            return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
-        return stream().collect(supplier, accumulator, combiner);
-    }
-
-    /**
-     * Performs a mutable reduction operation on the elements of this stream
-     * using an {@link DoubleCollector} which encapsulates the supplier,
-     * accumulator and merger functions making easier to reuse collection
-     * strategies.
-     *
-     * <p>
-     * Like {@link #reduce(double, DoubleBinaryOperator)}, {@code collect}
-     * operations can be parallelized without requiring additional
-     * synchronization.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <A> the intermediate accumulation type of the
-     *        {@code DoubleCollector}
-     * @param <R> type of the result
-     * @param collector the {@code DoubleCollector} describing the reduction
-     * @return the result of the reduction
-     * @see #collect(Supplier, ObjDoubleConsumer, BiConsumer)
-     * @since 0.3.0
-     */
-    @SuppressWarnings("unchecked")
-    public <A, R> R collect(DoubleCollector<A, R> collector) {
-        if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
-            return (R) collect(collector.supplier(), collector.doubleAccumulator(), collector.merger());
-        return collector.finisher().apply(collect(collector.supplier(), collector.doubleAccumulator(), collector
-                .merger()));
-    }
-
-    @Override
-    public double sum() {
-        if (context.fjp != null)
-            return context.terminate(stream()::sum);
-        return stream().sum();
-    }
-
-    @Override
-    public OptionalDouble min() {
-        return reduce(Math::min);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided
-     * {@code Comparator}.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param comparator a non-interfering, stateless {@link Comparator} to
-     *        compare elements of this stream
-     * @return an {@code OptionalDouble} describing the minimum element of this
-     *         stream, or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble min(Comparator<Double> comparator) {
-        return reduce((a, b) -> comparator.compare(a, b) > 0 ? b : a);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public <V extends Comparable<? super V>> OptionalDouble minBy(DoubleFunction<V> keyExtractor) {
-        ObjDoubleBox<V> result = collect(() -> new ObjDoubleBox<>(null, 0), (box, i) -> {
-            V val = Objects.requireNonNull(keyExtractor.apply(i));
-            if (box.a == null || box.a.compareTo(val) > 0) {
-                box.a = val;
-                box.b = i;
-            }
-        }, (box1, box2) -> {
-            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) > 0)) {
-                box1.a = box2.a;
-                box1.b = box2.b;
-            }
-        });
-        return result.a == null ? OptionalDouble.empty() : OptionalDouble.of(result.b);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble minByInt(DoubleToIntFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, d) -> {
-            int key = keyExtractor.applyAsInt(d);
-            if (!box.b || box.i > key) {
-                box.b = true;
-                box.i = key;
-                box.d = d;
-            }
-        }, PrimitiveBox.MIN_INT).asDouble();
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble minByLong(DoubleToLongFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, d) -> {
-            long key = keyExtractor.applyAsLong(d);
-            if (!box.b || box.l > key) {
-                box.b = true;
-                box.l = key;
-                box.d = d;
-            }
-        }, PrimitiveBox.MIN_LONG).asDouble();
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble minByDouble(DoubleUnaryOperator keyExtractor) {
-        double[] result = collect(() -> new double[3], (acc, d) -> {
-            double key = keyExtractor.applyAsDouble(d);
-            if (acc[2] == 0 || Double.compare(acc[1], key) > 0) {
-                acc[0] = d;
-                acc[1] = key;
-                acc[2] = 1;
-            }
-        }, (acc1, acc2) -> {
-            if (acc2[2] == 1 && (acc1[2] == 0 || Double.compare(acc1[1], acc2[1]) > 0))
-                System.arraycopy(acc2, 0, acc1, 0, 3);
-        });
-        return result[2] == 1 ? OptionalDouble.of(result[0]) : OptionalDouble.empty();
-    }
-
-    @Override
-    public OptionalDouble max() {
-        return reduce(Math::max);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided
-     * {@code Comparator}.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param comparator a non-interfering, stateless {@link Comparator} to
-     *        compare elements of this stream
-     * @return an {@code OptionalDouble} describing the maximum element of this
-     *         stream, or an empty {@code OptionalDouble} if the stream is empty
-     */
-    public OptionalDouble max(Comparator<Double> comparator) {
-        return reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public <V extends Comparable<? super V>> OptionalDouble maxBy(DoubleFunction<V> keyExtractor) {
-        ObjDoubleBox<V> result = collect(() -> new ObjDoubleBox<>(null, 0), (box, i) -> {
-            V val = Objects.requireNonNull(keyExtractor.apply(i));
-            if (box.a == null || box.a.compareTo(val) < 0) {
-                box.a = val;
-                box.b = i;
-            }
-        }, (box1, box2) -> {
-            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) < 0)) {
-                box1.a = box2.a;
-                box1.b = box2.b;
-            }
-        });
-        return result.a == null ? OptionalDouble.empty() : OptionalDouble.of(result.b);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble maxByInt(DoubleToIntFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, d) -> {
-            int key = keyExtractor.applyAsInt(d);
-            if (!box.b || box.i < key) {
-                box.b = true;
-                box.i = key;
-                box.d = d;
-            }
-        }, PrimitiveBox.MAX_INT).asDouble();
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble maxByLong(DoubleToLongFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, d) -> {
-            long key = keyExtractor.applyAsLong(d);
-            if (!box.b || box.l < key) {
-                box.b = true;
-                box.l = key;
-                box.d = d;
-            }
-        }, PrimitiveBox.MAX_LONG).asDouble();
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalDouble} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalDouble} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalDouble maxByDouble(DoubleUnaryOperator keyExtractor) {
-        double[] result = collect(() -> new double[3], (acc, d) -> {
-            double key = keyExtractor.applyAsDouble(d);
-            if (acc[2] == 0 || Double.compare(acc[1], key) < 0) {
-                acc[0] = d;
-                acc[1] = key;
-                acc[2] = 1;
-            }
-        }, (acc1, acc2) -> {
-            if (acc2[2] == 1 && (acc1[2] == 0 || Double.compare(acc1[1], acc2[1]) < 0))
-                System.arraycopy(acc2, 0, acc1, 0, 3);
-        });
-        return result[2] == 1 ? OptionalDouble.of(result[0]) : OptionalDouble.empty();
-    }
-
-    @Override
-    public long count() {
-        if (context.fjp != null)
-            return context.terminate(stream()::count);
-        return stream().count();
-    }
-
-    @Override
-    public OptionalDouble average() {
-        if (context.fjp != null)
-            return context.terminate(stream()::average);
-        return stream().average();
-    }
-
-    @Override
-    public DoubleSummaryStatistics summaryStatistics() {
-        return collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);
-    }
-
-    @Override
-    public boolean anyMatch(DoublePredicate predicate) {
-        if (context.fjp != null)
-            return context.terminate(predicate, stream()::anyMatch);
-        return stream().anyMatch(predicate);
-    }
-
-    @Override
-    public boolean allMatch(DoublePredicate predicate) {
-        if (context.fjp != null)
-            return context.terminate(predicate, stream()::allMatch);
-        return stream().allMatch(predicate);
-    }
-
-    @Override
-    public boolean noneMatch(DoublePredicate predicate) {
-        return !anyMatch(predicate);
-    }
-
-    @Override
-    public OptionalDouble findFirst() {
-        if (context.fjp != null)
-            return context.terminate(stream()::findFirst);
-        return stream().findFirst();
-    }
-
-    /**
-     * Returns an {@link OptionalDouble} describing the first element of this
-     * stream, which matches given predicate, or an empty {@code OptionalDouble}
-     * if there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalDouble} describing the first matching element
-     *         of this stream, or an empty {@code OptionalDouble} if there's no
-     *         matching element
-     * @see #findFirst()
-     */
-    public OptionalDouble findFirst(DoublePredicate predicate) {
-        return filter(predicate).findFirst();
-    }
-
-    @Override
-    public OptionalDouble findAny() {
-        if (context.fjp != null)
-            return context.terminate(stream()::findAny);
-        return stream().findAny();
-    }
-
-    /**
-     * Returns an {@link OptionalDouble} describing some element of the stream,
-     * which matches given predicate, or an empty {@code OptionalDouble} if
-     * there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * <p>
-     * The behavior of this operation is explicitly nondeterministic; it is free
-     * to select any element in the stream. This is to allow for maximal
-     * performance in parallel operations; the cost is that multiple invocations
-     * on the same source may not return the same result. (If a stable result is
-     * desired, use {@link #findFirst(DoublePredicate)} instead.)
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalDouble} describing some matching element of
-     *         this stream, or an empty {@code OptionalDouble} if there's no
-     *         matching element
-     * @see #findAny()
-     * @see #findFirst(DoublePredicate)
-     */
-    public OptionalDouble findAny(DoublePredicate predicate) {
-        return filter(predicate).findAny();
-    }
-
-    /**
-     * Returns an {@link OptionalLong} describing the zero-based index of the
-     * first element of this stream, which matches given predicate, or an empty
-     * {@code OptionalLong} if there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalLong} describing the index of the first
-     *         matching element of this stream, or an empty {@code OptionalLong}
-     *         if there's no matching element.
-     * @see #findFirst(DoublePredicate)
-     * @since 0.4.0
-     */
-    public OptionalLong indexOf(DoublePredicate predicate) {
-        return boxed().indexOf(predicate::test);
-    }
-
-    @Override
-    public StreamEx<Double> boxed() {
-        return new StreamEx<>(stream().boxed(), context);
-    }
-
-    @Override
-    public DoubleStreamEx sequential() {
-        return (DoubleStreamEx) super.sequential();
-    }
-
-    @Override
-    public DoubleStreamEx parallel() {
-        return (DoubleStreamEx) super.parallel();
-    }
-
-    @Override
-    public DoubleStreamEx parallel(ForkJoinPool fjp) {
-        return (DoubleStreamEx) super.parallel(fjp);
-    }
-
-    @Override
-    public OfDouble iterator() {
-        return Spliterators.iterator(spliterator());
-    }
-
-    /**
-     * Returns a new {@code DoubleStreamEx} which is a concatenation of this
-     * stream and the stream containing supplied values
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * @param values the values to append to the stream
-     * @return the new stream
-     */
-    public DoubleStreamEx append(double... values) {
-        if (values.length == 0)
-            return this;
-        return new DoubleStreamEx(DoubleStream.concat(stream(), DoubleStream.of(values)), context);
-    }
-
-    /**
-     * Creates a lazily concatenated stream whose elements are all the elements
-     * of this stream followed by all the elements of the other stream. The
-     * resulting stream is ordered if both of the input streams are ordered, and
-     * parallel if either of the input streams is parallel. When the resulting
-     * stream is closed, the close handlers for both input streams are invoked.
-     *
-     * @param other the other stream
-     * @return this stream appended by the other stream
-     * @see DoubleStream#concat(DoubleStream, DoubleStream)
-     */
-    public DoubleStreamEx append(DoubleStream other) {
-        return new DoubleStreamEx(DoubleStream.concat(stream(), other), context.combine(other));
-    }
-
-    /**
-     * Returns a new {@code DoubleStreamEx} which is a concatenation of the
-     * stream containing supplied values and this stream
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * @param values the values to prepend to the stream
-     * @return the new stream
-     */
-    public DoubleStreamEx prepend(double... values) {
-        if (values.length == 0)
-            return this;
-        return new DoubleStreamEx(DoubleStream.concat(DoubleStream.of(values), stream()), context);
-    }
-
-    /**
-     * Creates a lazily concatenated stream whose elements are all the elements
-     * of the other stream followed by all the elements of this stream. The
-     * resulting stream is ordered if both of the input streams are ordered, and
-     * parallel if either of the input streams is parallel. When the resulting
-     * stream is closed, the close handlers for both input streams are invoked.
-     *
-     * @param other the other stream
-     * @return this stream prepended by the other stream
-     * @see DoubleStream#concat(DoubleStream, DoubleStream)
-     */
-    public DoubleStreamEx prepend(DoubleStream other) {
-        return new DoubleStreamEx(DoubleStream.concat(other, stream()), context.combine(other));
-    }
-
-    /**
-     * Returns a stream consisting of the results of applying the given function
-     * to the every adjacent pair of elements of this stream.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * <p>
-     * The output stream will contain one element less than this stream. If this
-     * stream contains zero or one element the output stream will be empty.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        adjacent pair of this stream elements.
-     * @return the new stream
-     * @since 0.2.1
-     */
-    public DoubleStreamEx pairMap(DoubleBinaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
-    }
-
-    /**
-     * Returns a {@link String} which is the concatenation of the results of
-     * calling {@link String#valueOf(double)} on each element of this stream,
-     * separated by the specified delimiter, in encounter order.
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * @param delimiter the delimiter to be used between each element
-     * @return the result of concatenation. For empty input stream empty String
-     *         is returned.
-     * @since 0.3.1
-     */
-    public String joining(CharSequence delimiter) {
-        return collect(DoubleCollector.joining(delimiter));
-    }
-
-    /**
-     * Returns a {@link String} which is the concatenation of the results of
-     * calling {@link String#valueOf(double)} on each element of this stream,
-     * separated by the specified delimiter, with the specified prefix and
-     * suffix in encounter order.
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * @param delimiter the delimiter to be used between each element
-     * @param prefix the sequence of characters to be used at the beginning of
-     *        the joined result
-     * @param suffix the sequence of characters to be used at the end of the
-     *        joined result
-     * @return the result of concatenation. For empty input stream
-     *         {@code prefix + suffix} is returned.
-     * @since 0.3.1
-     */
-    public String joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
-        return collect(DoubleCollector.joining(delimiter, prefix, suffix));
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream until the
-     * first element which does not match the given predicate is found.
-     * 
-     * <p>
-     * This is a short-circuiting stateful operation. It can be either
-     * <a href="package-summary.html#StreamOps">intermediate or
-     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
-     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
-     * implementation.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.3.6
-     * @see #takeWhileInclusive(DoublePredicate)
-     * @see #dropWhile(DoublePredicate)
-     */
-    public DoubleStreamEx takeWhile(DoublePredicate predicate) {
-        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), false);
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream until the
-     * first element which does not match the given predicate is found
-     * (including the first mismatching element).
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.5.5
-     * @see #takeWhile(DoublePredicate)
-     */
-    public DoubleStreamEx takeWhileInclusive(DoublePredicate predicate) {
-        Objects.requireNonNull(predicate);
-        return delegate(new TakeDrop.TDOfDouble(spliterator(), false, true, predicate));
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream starting
-     * from the first element which does not match the given predicate. If the
-     * predicate is true for all stream elements, an empty stream is returned.
-     * 
-     * <p>
-     * This is a stateful operation. It can be either
-     * <a href="package-summary.html#StreamOps">intermediate or
-     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
-     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
-     * implementation.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.3.6
-     */
-    public DoubleStreamEx dropWhile(DoublePredicate predicate) {
-        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), true);
-    }
-
-    /**
-     * Returns a stream containing cumulative results of applying the
-     * accumulation function going left to right.
-     * 
-     * <p>
-     * This is a stateful
-     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
-     * operation.
-     *
-     * <p>
-     * This operation resembles {@link #scanLeft(DoubleBinaryOperator)}, but
-     * unlike {@code scanLeft} this operation is intermediate and accumulation
-     * function must be associative.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. Using an unordered source or
-     * removing the ordering constraint with {@link #unordered()} may improve
-     * the parallel processing speed.
-     *
-     * @param op an <a href="package-summary.html#Associativity">associative</a>
-     *        , <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for computing the next element based on the previous one
-     * @return the new stream.
-     * @see #scanLeft(DoubleBinaryOperator)
-     * @since 0.6.1
-     */
-    public DoubleStreamEx prefix(DoubleBinaryOperator op) {
-        return delegate(new PrefixOps.OfDouble(spliterator(), op));
-    }
-
-    // Necessary to generate proper JavaDoc
-    // does not add overhead as it appears in bytecode anyways as bridge method
-    @Override
-    public <U> U chain(Function<? super DoubleStreamEx, U> mapper) {
-        return mapper.apply(this);
-    }
-
-    /**
-     * Returns an empty sequential {@code DoubleStreamEx}.
-     *
-     * @return an empty sequential stream
-     */
-    public static DoubleStreamEx empty() {
-        return of(Spliterators.emptyDoubleSpliterator());
-    }
-
-    /**
-     * Returns a sequential {@code DoubleStreamEx} containing a single element.
-     *
-     * @param element the single element
-     * @return a singleton sequential stream
-     */
-    public static DoubleStreamEx of(double element) {
-        return of(new ConstSpliterator.OfDouble(element, 1, true));
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
-     * the specified values.
-     *
-     * @param elements the elements of the new stream
-     * @return the new stream
-     */
-    public static DoubleStreamEx of(double... elements) {
-        return of(Arrays.spliterator(elements));
-    }
-
-    /**
-     * Returns a sequential {@link DoubleStreamEx} with the specified range of
-     * the specified array as its source.
-     *
-     * @param array the array, assumed to be unmodified during use
-     * @param startInclusive the first index to cover, inclusive
-     * @param endExclusive index immediately past the last index to cover
-     * @return an {@code DoubleStreamEx} for the array range
-     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
-     *         negative, {@code endExclusive} is less than
-     *         {@code startInclusive}, or {@code endExclusive} is greater than
-     *         the array size
-     * @since 0.1.1
-     * @see Arrays#stream(double[], int, int)
-     */
-    public static DoubleStreamEx of(double[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.spliterator(array, startInclusive, endExclusive));
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
-     * the unboxed elements of supplied array.
-     *
-     * @param array the array to create the stream from.
-     * @return the new stream
-     * @see Arrays#stream(Object[])
-     * @since 0.5.0
-     */
-    public static DoubleStreamEx of(Double[] array) {
-        return seq(Arrays.stream(array).mapToDouble(Double::doubleValue));
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
-     * the values in the supplied {@link java.nio.DoubleBuffer}.
-     * 
-     * <p>
-     * The resulting stream covers only a portion of {@code DoubleBuffer}
-     * content which starts with {@linkplain Buffer#position() position}
-     * (inclusive) and ends with {@linkplain Buffer#limit() limit} (exclusive).
-     * Changes in position and limit after the stream creation don't affect the
-     * stream.
-     * 
-     * <p>
-     * The resulting stream does not change the internal {@code DoubleBuffer}
-     * state.
-     * 
-     * @param buf the {@code DoubleBuffer} to create a stream from
-     * @return the new stream
-     * @since 0.6.2
-     */
-    public static DoubleStreamEx of(java.nio.DoubleBuffer buf) {
-        return IntStreamEx.range(buf.position(), buf.limit()).mapToDouble(buf::get);
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
-     * the specified float values casted to double.
-     *
-     * @param elements the elements of the new stream
-     * @return the new stream
-     * @since 0.2.0
-     */
-    public static DoubleStreamEx of(float... elements) {
-        return of(elements, 0, elements.length);
-    }
-
-    /**
-     * Returns a sequential {@link DoubleStreamEx} with the specified range of
-     * the specified array as its source. Array values will be casted to double.
-     *
-     * @param array the array, assumed to be unmodified during use
-     * @param startInclusive the first index to cover, inclusive
-     * @param endExclusive index immediately past the last index to cover
-     * @return an {@code IntStreamEx} for the array range
-     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
-     *         negative, {@code endExclusive} is less than
-     *         {@code startInclusive}, or {@code endExclusive} is greater than
-     *         the array size
-     * @since 0.2.0
-     */
-    public static DoubleStreamEx of(float[] array, int startInclusive, int endExclusive) {
-        rangeCheck(array.length, startInclusive, endExclusive);
-        return of(new RangeBasedSpliterator.OfFloat(startInclusive, endExclusive, array));
-    }
-
-    /**
-     * Returns a {@code DoubleStreamEx} object which wraps given
-     * {@link DoubleStream}.
-     * 
-     * <p>
-     * The supplied stream must not be consumed or closed when this method is
-     * called. No operation must be performed on the supplied stream after it's
-     * wrapped.
-     * 
-     * @param stream original stream
-     * @return the wrapped stream
-     * @since 0.0.8
-     */
-    public static DoubleStreamEx of(DoubleStream stream) {
-        return stream instanceof DoubleStreamEx ? (DoubleStreamEx) stream
-                : new DoubleStreamEx(stream, StreamContext.of(stream));
-    }
-
-    /**
-     * Returns a sequential {@link DoubleStreamEx} created from given
-     * {@link java.util.Spliterator.OfDouble}.
-     * 
-     * @param spliterator a spliterator to create the stream from.
-     * @return the new stream
-     * @since 0.3.4
-     */
-    public static DoubleStreamEx of(Spliterator.OfDouble spliterator) {
-        return new DoubleStreamEx(spliterator, StreamContext.SEQUENTIAL);
-    }
-
-    /**
-     * Returns a sequential, ordered {@link DoubleStreamEx} created from given
-     * {@link java.util.PrimitiveIterator.OfDouble}.
-     *
-     * <p>
-     * This method is roughly equivalent to
-     * {@code DoubleStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
-     * , but may show better performance for parallel processing.
-     * 
-     * <p>
-     * Use this method only if you cannot provide better Stream source.
-     *
-     * @param iterator an iterator to create the stream from.
-     * @return the new stream
-     * @since 0.5.1
-     */
-    public static DoubleStreamEx of(PrimitiveIterator.OfDouble iterator) {
-        return of(new UnknownSizeSpliterator.USOfDouble(iterator));
-    }
-
-    /**
-     * Returns a sequential {@code DoubleStreamEx} containing an
-     * {@link OptionalDouble} value, if present, otherwise returns an empty
-     * {@code DoubleStreamEx}.
-     *
-     * @param optional the optional to create a stream of
-     * @return a stream with an {@code OptionalDouble} value if present,
-     *         otherwise an empty stream
-     * @since 0.1.1
-     */
-    public static DoubleStreamEx of(OptionalDouble optional) {
-        return optional.isPresent() ? of(optional.getAsDouble()) : empty();
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
-     * the unboxed elements of supplied collection.
-     *
-     * @param collection the collection to create the stream from.
-     * @return the new stream
-     * @see Collection#stream()
-     */
-    public static DoubleStreamEx of(Collection<Double> collection) {
-        return seq(collection.stream().mapToDouble(Double::doubleValue));
-    }
-
-    /**
-     * Returns an effectively unlimited stream of pseudorandom {@code double}
-     * values, each between zero (inclusive) and one (exclusive) produced by
-     * given {@link Random} object.
-     *
-     * <p>
-     * A pseudorandom {@code double} value is generated as if it's the result of
-     * calling the method {@link Random#nextDouble()}.
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @return a stream of pseudorandom {@code double} values
-     * @see Random#doubles()
-     */
-    public static DoubleStreamEx of(Random random) {
-        return seq(random.doubles());
-    }
-
-    /**
-     * Returns a stream producing the given {@code streamSize} number of
-     * pseudorandom {@code double} values, each between zero (inclusive) and one
-     * (exclusive) produced by given {@link Random} object.
-     *
-     * <p>
-     * A pseudorandom {@code double} value is generated as if it's the result of
-     * calling the method {@link Random#nextDouble()}.
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param streamSize the number of values to generate
-     * @return a stream of pseudorandom {@code double} values
-     * @see Random#doubles(long)
-     */
-    public static DoubleStreamEx of(Random random, long streamSize) {
-        return seq(random.doubles(streamSize));
-    }
-
-    /**
-     * Returns an effectively unlimited stream of pseudorandom {@code double}
-     * values, each conforming to the given origin (inclusive) and bound
-     * (exclusive) produced by given {@link Random} object.
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param randomNumberOrigin the origin (inclusive) of each random value
-     * @param randomNumberBound the bound (exclusive) of each random value
-     * @return a stream of pseudorandom {@code double} values, each with the
-     *         given origin (inclusive) and bound (exclusive)
-     * @see Random#doubles(double, double)
-     */
-    public static DoubleStreamEx of(Random random, double randomNumberOrigin, double randomNumberBound) {
-        return seq(random.doubles(randomNumberOrigin, randomNumberBound));
-    }
-
-    /**
-     * Returns a stream producing the given {@code streamSize} number of
-     * pseudorandom {@code double} values, each conforming to the given origin
-     * (inclusive) and bound (exclusive) produced by given {@link Random}
-     * object.
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param randomNumberOrigin the origin (inclusive) of each random value
-     * @param randomNumberBound the bound (exclusive) of each random value
-     * @param streamSize the number of values to generate
-     * @return a stream of pseudorandom {@code double} values, each with the
-     *         given origin (inclusive) and bound (exclusive)
-     * @see Random#doubles(long, double, double)
-     */
-    public static DoubleStreamEx of(Random random, long streamSize, double randomNumberOrigin,
-            double randomNumberBound) {
-        return seq(random.doubles(streamSize, randomNumberOrigin, randomNumberBound));
-    }
-
-    /**
-     * Returns an infinite sequential ordered {@code DoubleStreamEx} produced by
-     * iterative application of a function {@code f} to an initial element
-     * {@code seed}, producing a stream consisting of {@code seed},
-     * {@code f(seed)}, {@code f(f(seed))}, etc.
-     *
-     * <p>
-     * The first element (position {@code 0}) in the {@code DoubleStreamEx} will
-     * be the provided {@code seed}. For {@code n > 0}, the element at position
-     * {@code n}, will be the result of applying the function {@code f} to the
-     * element at position {@code n - 1}.
-     *
-     * @param seed the initial element
-     * @param f a function to be applied to to the previous element to produce a
-     *        new element
-     * @return A new sequential {@code DoubleStream}
-     * @see #iterate(double, DoublePredicate, DoubleUnaryOperator)
-     */
-    public static DoubleStreamEx iterate(final double seed, final DoubleUnaryOperator f) {
-        return iterate(seed, x -> true, f);
-    }
-
-    /**
-     * Returns a sequential ordered {@code DoubleStreamEx} produced by iterative
-     * application of a function to an initial element, conditioned on
-     * satisfying the supplied predicate. The stream terminates as soon as the
-     * predicate function returns false.
-     *
-     * <p>
-     * {@code DoubleStreamEx.iterate} should produce the same sequence of
-     * elements as produced by the corresponding for-loop:
-     * 
-     * <pre>{@code
-     *     for (double index=seed; predicate.test(index); index = f.apply(index)) {
-     *         ... 
-     *     }
-     * }</pre>
-     *
-     * <p>
-     * The resulting sequence may be empty if the predicate does not hold on the
-     * seed value. Otherwise the first element will be the supplied seed value,
-     * the next element (if present) will be the result of applying the function
-     * f to the seed value, and so on iteratively until the predicate indicates
-     * that the stream should terminate.
-     *
-     * @param seed the initial element
-     * @param predicate a predicate to apply to elements to determine when the
-     *        stream must terminate.
-     * @param f a function to be applied to the previous element to produce a
-     *        new element
-     * @return a new sequential {@code DoubleStreamEx}
-     * @see #iterate(double, DoubleUnaryOperator)
-     * @since 0.6.0
-     */
-    public static DoubleStreamEx iterate(double seed, DoublePredicate predicate, DoubleUnaryOperator f) {
-        Objects.requireNonNull(f);
-        Objects.requireNonNull(predicate);
-        Spliterator.OfDouble spliterator = new Spliterators.AbstractDoubleSpliterator(Long.MAX_VALUE,
-                Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
-            double prev;
-            boolean started, finished;
-
-            @Override
-            public boolean tryAdvance(DoubleConsumer action) {
-                Objects.requireNonNull(action);
-                if (finished)
-                    return false;
-                double t;
-                if (started)
-                    t = f.applyAsDouble(prev);
-                else {
-                    t = seed;
-                    started = true;
-                }
-                if (!predicate.test(t)) {
-                    finished = true;
-                    return false;
-                }
-                action.accept(prev = t);
-                return true;
-            }
-
-            @Override
-            public void forEachRemaining(DoubleConsumer action) {
-                Objects.requireNonNull(action);
-                if (finished)
-                    return;
-                finished = true;
-                double t = started ? f.applyAsDouble(prev) : seed;
-                while (predicate.test(t)) {
-                    action.accept(t);
-                    t = f.applyAsDouble(t);
-                }
-            }
-        };
-        return of(spliterator);
-    }
-
-    /**
-     * Returns an infinite sequential unordered stream where each element is
-     * generated by the provided {@code DoubleSupplier}. This is suitable for
-     * generating constant streams, streams of random elements, etc.
-     *
-     * @param s the {@code DoubleSupplier} for generated elements
-     * @return a new infinite sequential unordered {@code DoubleStreamEx}
-     * @see DoubleStream#generate(DoubleSupplier)
-     */
-    public static DoubleStreamEx generate(DoubleSupplier s) {
-        return seq(DoubleStream.generate(s));
-    }
-
-    /**
-     * Return an ordered stream produced by consecutive calls of the supplied
-     * producer until it returns false.
-     * 
-     * <p>
-     * The producer function may call the passed consumer any number of times
-     * and return true if the producer should be called again or false
-     * otherwise. It's guaranteed that the producer will not be called anymore,
-     * once it returns false.
-     * 
-     * <p>
-     * This method is particularly useful when producer changes the mutable
-     * object which should be left in known state after the full stream
-     * consumption. Note however that if a short-circuiting operation is used,
-     * then the final state of the mutable object cannot be guaranteed.
-     * 
-     * @param producer a predicate which calls the passed consumer to emit
-     *        stream element(s) and returns true if it producer should be
-     *        applied again.
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public static DoubleStreamEx produce(Predicate<DoubleConsumer> producer) {
-        Box<DoubleEmitter> box = new Box<>();
-        return (box.a = action -> producer.test(action) ? box.a : null).stream();
-    }
-
-    /**
-     * Returns a sequential unordered {@code DoubleStreamEx} of given length
-     * which elements are equal to supplied value.
-     * 
-     * @param value the constant value
-     * @param length the length of the stream
-     * @return a new {@code DoubleStreamEx}
-     * @since 0.1.2
-     */
-    public static DoubleStreamEx constant(double value, long length) {
-        return of(new ConstSpliterator.OfDouble(value, length, false));
-    }
-
-    /**
-     * Returns a sequential {@code DoubleStreamEx} containing the results of
-     * applying the given function to the corresponding pairs of values in given
-     * two arrays.
-     * 
-     * @param first the first array
-     * @param second the second array
-     * @param mapper a non-interfering, stateless function to apply to each pair
-     *        of the corresponding array elements.
-     * @return a new {@code DoubleStreamEx}
-     * @throws IllegalArgumentException if length of the arrays differs.
-     * @since 0.2.1
-     */
-    public static DoubleStreamEx zip(double[] first, double[] second, DoubleBinaryOperator mapper) {
-        return of(new RangeBasedSpliterator.ZipDouble(0, checkLength(first.length, second.length), mapper, first,
-                second));
-    }
-
-    /**
-     * A helper interface to build a new stream by emitting elements and
-     * creating new emitters in a chain.
-     * 
-     * <p>
-     * Using this interface it's possible to create custom sources which cannot
-     * be easily expressed using
-     * {@link DoubleStreamEx#iterate(double, DoubleUnaryOperator)} or
-     * {@link DoubleStreamEx#generate(DoubleSupplier)}.
-     * 
-     * @author Tagir Valeev
-     *
-     * @since 0.6.0
-     */
-    @FunctionalInterface
-    public interface DoubleEmitter {
-        /**
-         * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if
-         * nothing more to emit.
-         * 
-         * <p>
-         * Normally one element is emitted during the {@code next()} method
-         * call. However, it's not restricted: you may emit as many elements as
-         * you want, though in some cases if many elements were emitted they
-         * might be buffered consuming additional memory.
-         * 
-         * <p>
-         * It's allowed not to emit anything (don't call the consumer). However
-         * if you do this and return new emitter which also does not emit
-         * anything, you will end up in endless loop.
-         * 
-         * @param action consumer to be called to emit elements
-         * @return next emitter or null
-         */
-        DoubleEmitter next(DoubleConsumer action);
-
-        /**
-         * Returns the spliterator which covers all the elements emitted by this
-         * emitter.
-         * 
-         * @return the new spliterator
-         */
-        default Spliterator.OfDouble spliterator() {
-            return new EmitterSpliterator.OfDouble(this);
-        }
-
-        /**
-         * Returns the stream which covers all the elements emitted by this
-         * emitter.
-         * 
-         * @return the new stream
-         */
-        default DoubleStreamEx stream() {
-            return of(spliterator());
-        }
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.nio.Buffer;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.DoubleSummaryStatistics;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.OptionalDouble;
+import java.util.OptionalLong;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfDouble;
+import java.util.Random;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.ForkJoinPool;
+import java.util.function.BiConsumer;
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleConsumer;
+import java.util.function.DoubleFunction;
+import java.util.function.DoublePredicate;
+import java.util.function.DoubleSupplier;
+import java.util.function.DoubleToIntFunction;
+import java.util.function.DoubleToLongFunction;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.Function;
+import java.util.function.ObjDoubleConsumer;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collector;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+import static one.util.streamex.Internals.Box;
+import static one.util.streamex.Internals.DoubleBuffer;
+import static one.util.streamex.Internals.FloatBuffer;
+import static one.util.streamex.Internals.INITIAL_SIZE;
+import static one.util.streamex.Internals.ObjDoubleBox;
+import static one.util.streamex.Internals.PrimitiveBox;
+import static one.util.streamex.Internals.checkLength;
+import static one.util.streamex.Internals.intSize;
+import static one.util.streamex.Internals.rangeCheck;
+
+/**
+ * A {@link DoubleStream} implementation with additional functionality
+ * 
+ * @author Tagir Valeev
+ */
+public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble, DoubleStreamEx> implements
+        DoubleStream {
+    DoubleStreamEx(DoubleStream stream, StreamContext context) {
+        super(stream, context);
+    }
+
+    DoubleStreamEx(Spliterator.OfDouble spliterator, StreamContext context) {
+        super(spliterator, context);
+    }
+
+    @Override
+    DoubleStream createStream() {
+        return StreamSupport.doubleStream(spliterator, isParallel());
+    }
+
+    private static DoubleStreamEx seq(DoubleStream stream) {
+        return new DoubleStreamEx(stream, StreamContext.SEQUENTIAL);
+    }
+
+    final DoubleStreamEx delegate(Spliterator.OfDouble spliterator) {
+        return new DoubleStreamEx(spliterator, context);
+    }
+
+    @Override
+    public DoubleStreamEx unordered() {
+        return (DoubleStreamEx) super.unordered();
+    }
+
+    @Override
+    public DoubleStreamEx onClose(Runnable closeHandler) {
+        return (DoubleStreamEx) super.onClose(closeHandler);
+    }
+
+    @Override
+    public DoubleStreamEx filter(DoublePredicate predicate) {
+        return new DoubleStreamEx(stream().filter(predicate), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that don't
+     * match the given predicate.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param predicate a non-interfering, stateless predicate to apply to each
+     *        element to determine if it should be excluded
+     * @return the new stream
+     */
+    public DoubleStreamEx remove(DoublePredicate predicate) {
+        return filter(predicate.negate());
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that strictly
+     * greater than the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public DoubleStreamEx greater(double value) {
+        return filter(val -> val > value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that strictly
+     * less than the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public DoubleStreamEx less(double value) {
+        return filter(val -> val < value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that greater
+     * than or equal to the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public DoubleStreamEx atLeast(double value) {
+        return filter(val -> val >= value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that less than
+     * or equal to the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public DoubleStreamEx atMost(double value) {
+        return filter(val -> val <= value);
+    }
+
+    @Override
+    public DoubleStreamEx map(DoubleUnaryOperator mapper) {
+        return new DoubleStreamEx(stream().map(mapper), context);
+    }
+
+    /**
+     * Returns a stream where the first element is the replaced with the result
+     * of applying the given function while the other elements are left intact.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * @param mapper a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the first element
+     * @return the new stream
+     * @since 0.4.1
+     */
+    public DoubleStreamEx mapFirst(DoubleUnaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfDouble((a, b) -> b, mapper, spliterator(),
+                PairSpliterator.MODE_MAP_FIRST));
+    }
+
+    /**
+     * Returns a stream where the last element is the replaced with the result
+     * of applying the given function while the other elements are left intact.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
+     *
+     * @param mapper a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the last element
+     * @return the new stream
+     * @since 0.4.1
+     */
+    public DoubleStreamEx mapLast(DoubleUnaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfDouble((a, b) -> a, mapper, spliterator(),
+                PairSpliterator.MODE_MAP_LAST));
+    }
+
+    @Override
+    public <U> StreamEx<U> mapToObj(DoubleFunction<? extends U> mapper) {
+        return new StreamEx<>(stream().mapToObj(mapper), context);
+    }
+
+    @Override
+    public IntStreamEx mapToInt(DoubleToIntFunction mapper) {
+        return new IntStreamEx(stream().mapToInt(mapper), context);
+    }
+
+    @Override
+    public LongStreamEx mapToLong(DoubleToLongFunction mapper) {
+        return new LongStreamEx(stream().mapToLong(mapper), context);
+    }
+
+    /**
+     * Returns an {@link EntryStream} consisting of the {@link Entry} objects
+     * which keys and values are results of applying the given functions to the
+     * elements of this stream.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param <K> The {@code Entry} key type
+     * @param <V> The {@code Entry} value type
+     * @param keyMapper a non-interfering, stateless function to apply to each
+     *        element
+     * @param valueMapper a non-interfering, stateless function to apply to each
+     *        element
+     * @return the new stream
+     * @since 0.3.1
+     */
+    public <K, V> EntryStream<K, V> mapToEntry(DoubleFunction<? extends K> keyMapper,
+            DoubleFunction<? extends V> valueMapper) {
+        return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
+                valueMapper.apply(t))), context);
+    }
+
+    @Override
+    public DoubleStreamEx flatMap(DoubleFunction<? extends DoubleStream> mapper) {
+        return new DoubleStreamEx(stream().flatMap(mapper), context);
+    }
+
+    /**
+     * Returns an {@link IntStreamEx} consisting of the results of replacing
+     * each element of this stream with the contents of a mapped stream produced
+     * by applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces an {@code IntStream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public IntStreamEx flatMapToInt(DoubleFunction<? extends IntStream> mapper) {
+        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
+    }
+
+    /**
+     * Returns a {@link LongStreamEx} consisting of the results of replacing
+     * each element of this stream with the contents of a mapped stream produced
+     * by applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces a {@code LongStream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public LongStreamEx flatMapToLong(DoubleFunction<? extends LongStream> mapper) {
+        return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), context);
+    }
+
+    /**
+     * Returns a {@link StreamEx} consisting of the results of replacing each
+     * element of this stream with the contents of a mapped stream produced by
+     * applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param <R> The element type of the new stream
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces a {@code Stream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public <R> StreamEx<R> flatMapToObj(DoubleFunction<? extends Stream<R>> mapper) {
+        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
+    }
+
+    /**
+     * Returns a new stream containing all the elements of the original stream interspersed with
+     * given delimiter.
+     * 
+     * <p>
+     * For example, {@code DoubleStreamEx.of(1, 2, 3).intersperse(4)} will yield a stream containing
+     * five elements: 1, 4, 2, 4, 3.
+     * 
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
+     * 
+     * @param delimiter a delimiter to be inserted between each pair of elements
+     * @return the new stream
+     * @since 0.6.6
+     */
+    public DoubleStreamEx intersperse(int delimiter) {
+        return new DoubleStreamEx(stream().flatMap(s -> DoubleStreamEx.of(delimiter, s)).skip(1), context);
+    }
+
+    @Override
+    public DoubleStreamEx distinct() {
+        return new DoubleStreamEx(stream().distinct(), context);
+    }
+
+    @Override
+    public DoubleStreamEx sorted() {
+        return new DoubleStreamEx(stream().sorted(), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream sorted
+     * according to the given comparator. Stream elements are boxed before
+     * passing to the comparator.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     * 
+     * @param comparator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        {@code Comparator} to be used to compare stream elements
+     * @return the new stream
+     */
+    public DoubleStreamEx sorted(Comparator<Double> comparator) {
+        return new DoubleStreamEx(stream().boxed().sorted(comparator).mapToDouble(Double::doubleValue), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream in reverse
+     * sorted order. The elements are compared for equality according to
+     * {@link java.lang.Double#compare(double, double)}.
+     *
+     * <p>
+     * This is a stateful intermediate operation.
+     *
+     * @return the new stream
+     * @since 0.0.8
+     */
+    public DoubleStreamEx reverseSorted() {
+        return new DoubleStreamEx(stream().mapToLong(d -> {
+            long l = Double.doubleToRawLongBits(d);
+            return l ^ (((l >>> 63) - 1) | Long.MIN_VALUE);
+        }).sorted().mapToDouble(l -> Double.longBitsToDouble(l ^ ((-(l >>> 63)) | Long.MIN_VALUE))), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the natural order of the keys extracted by provided
+     * function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public <V extends Comparable<? super V>> DoubleStreamEx sortedBy(DoubleFunction<V> keyExtractor) {
+        return sorted(Comparator.comparing(keyExtractor::apply));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the int values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public DoubleStreamEx sortedByInt(DoubleToIntFunction keyExtractor) {
+        return sorted(Comparator.comparingInt(keyExtractor::applyAsInt));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the long values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public DoubleStreamEx sortedByLong(DoubleToLongFunction keyExtractor) {
+        return sorted(Comparator.comparingLong(keyExtractor::applyAsLong));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the double values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public DoubleStreamEx sortedByDouble(DoubleUnaryOperator keyExtractor) {
+        return sorted(Comparator.comparingDouble(keyExtractor::applyAsDouble));
+    }
+
+    @Override
+    public DoubleStreamEx peek(DoubleConsumer action) {
+        return new DoubleStreamEx(stream().peek(action), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * Note that the action might not be called at all if the first element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream which stopped the stream before the first element).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a
+     *        <a href="package-summary.html#NonInterference"> non-interfering
+     *        </a> action to perform on the first stream element as it is
+     *        consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public DoubleStreamEx peekFirst(DoubleConsumer action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that the action might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a
+     *        <a href="package-summary.html#NonInterference"> non-interfering
+     *        </a> action to perform on the first stream element as it is
+     *        consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public DoubleStreamEx peekLast(DoubleConsumer action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    @Override
+    public DoubleStreamEx limit(long maxSize) {
+        return new DoubleStreamEx(stream().limit(maxSize), context);
+    }
+
+    @Override
+    public DoubleStreamEx skip(long n) {
+        return new DoubleStreamEx(stream().skip(n), context);
+    }
+
+    @Override
+    public void forEach(DoubleConsumer action) {
+        if (spliterator != null && !isParallel()) {
+            spliterator().forEachRemaining(action);
+        } else {
+            if (context.fjp != null)
+                context.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
+    }
+
+    @Override
+    public void forEachOrdered(DoubleConsumer action) {
+        if (spliterator != null && !isParallel()) {
+            spliterator().forEachRemaining(action);
+        } else {
+            if (context.fjp != null)
+                context.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
+    }
+
+    @Override
+    public double[] toArray() {
+        if (context.fjp != null)
+            return context.terminate(stream()::toArray);
+        return stream().toArray();
+    }
+
+    /**
+     * Returns a {@code float[]} array containing the elements of this stream
+     * which are converted to floats using {@code (float)} cast operation.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return an array containing the elements of this stream
+     * @since 0.3.0
+     */
+    public float[] toFloatArray() {
+        if (isParallel())
+            return collect(DoubleCollector.toFloatArray());
+        java.util.Spliterator.OfDouble spliterator = spliterator();
+        int size = intSize(spliterator);
+        FloatBuffer buf;
+        if (size >= 0) {
+            buf = new FloatBuffer(size);
+            spliterator.forEachRemaining((DoubleConsumer) buf::addUnsafe);
+        } else {
+            buf = new FloatBuffer();
+            spliterator.forEachRemaining((DoubleConsumer) buf::add);
+        }
+        return buf.toArray();
+    }
+
+    @Override
+    public double reduce(double identity, DoubleBinaryOperator op) {
+        if (context.fjp != null)
+            return context.terminate(() -> stream().reduce(identity, op));
+        return stream().reduce(identity, op);
+    }
+
+    @Override
+    public OptionalDouble reduce(DoubleBinaryOperator op) {
+        if (context.fjp != null)
+            return context.terminate(op, stream()::reduce);
+        return stream().reduce(op);
+    }
+
+    /**
+     * Folds the elements of this stream using the provided accumulation
+     * function, going left to right. This is equivalent to:
+     * 
+     * <pre>
+     * {@code
+     *     boolean foundAny = false;
+     *     double result = 0;
+     *     for (double element : this stream) {
+     *         if (!foundAny) {
+     *             foundAny = true;
+     *             result = element;
+     *         }
+     *         else
+     *             result = accumulator.apply(result, element);
+     *     }
+     *     return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty();
+     * }
+     * </pre>
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. If your accumulator function is
+     * associative, consider using {@link #reduce(DoubleBinaryOperator)} method.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     *
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the result of the folding
+     * @see #foldLeft(double, DoubleBinaryOperator)
+     * @see #reduce(DoubleBinaryOperator)
+     * @since 0.4.0
+     */
+    public OptionalDouble foldLeft(DoubleBinaryOperator accumulator) {
+        PrimitiveBox b = new PrimitiveBox();
+        forEachOrdered(t -> {
+            if (b.b)
+                b.d = accumulator.applyAsDouble(b.d, t);
+            else {
+                b.d = t;
+                b.b = true;
+            }
+        });
+        return b.asDouble();
+    }
+
+    /**
+     * Folds the elements of this stream using the provided seed object and
+     * accumulation function, going left to right. This is equivalent to:
+     * 
+     * <pre>
+     * {@code
+     *     double result = identity;
+     *     for (double element : this stream)
+     *         result = accumulator.apply(result, element)
+     *     return result;
+     * }
+     * </pre>
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. If your accumulator function is
+     * associative, consider using {@link #reduce(double, DoubleBinaryOperator)}
+     * method.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     *
+     * @param seed the starting value
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the result of the folding
+     * @see #reduce(double, DoubleBinaryOperator)
+     * @see #foldLeft(DoubleBinaryOperator)
+     * @since 0.4.0
+     */
+    public double foldLeft(double seed, DoubleBinaryOperator accumulator) {
+        double[] box = new double[] { seed };
+        forEachOrdered(t -> box[0] = accumulator.applyAsDouble(box[0], t));
+        return box[0];
+    }
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the array where the first element is the first element of this
+     *         stream and every successor element is the result of applying
+     *         accumulator function to the previous array element and the
+     *         corresponding stream element. The resulting array has the same
+     *         length as this stream.
+     * @see #foldLeft(DoubleBinaryOperator)
+     * @since 0.5.1
+     */
+    public double[] scanLeft(DoubleBinaryOperator accumulator) {
+        Spliterator.OfDouble spliterator = spliterator();
+        int size = intSize(spliterator);
+        DoubleBuffer buf = new DoubleBuffer(size == -1 ? INITIAL_SIZE : size);
+        delegate(spliterator).forEachOrdered(i -> buf.add(buf.size == 0 ? i
+                : accumulator.applyAsDouble(buf.data[buf.size - 1], i)));
+        return buf.toArray();
+    }
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right using given seed value.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param seed the starting value
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the array where the first element is the seed and every successor
+     *         element is the result of applying accumulator function to the
+     *         previous array element and the corresponding stream element. The
+     *         resulting array is one element longer than this stream.
+     * @see #foldLeft(double, DoubleBinaryOperator)
+     * @since 0.5.1
+     */
+    public double[] scanLeft(double seed, DoubleBinaryOperator accumulator) {
+        return prepend(seed).scanLeft(accumulator);
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * @see #collect(DoubleCollector)
+     */
+    @Override
+    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
+        if (context.fjp != null)
+            return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
+        return stream().collect(supplier, accumulator, combiner);
+    }
+
+    /**
+     * Performs a mutable reduction operation on the elements of this stream
+     * using an {@link DoubleCollector} which encapsulates the supplier,
+     * accumulator and merger functions making easier to reuse collection
+     * strategies.
+     *
+     * <p>
+     * Like {@link #reduce(double, DoubleBinaryOperator)}, {@code collect}
+     * operations can be parallelized without requiring additional
+     * synchronization.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <A> the intermediate accumulation type of the
+     *        {@code DoubleCollector}
+     * @param <R> type of the result
+     * @param collector the {@code DoubleCollector} describing the reduction
+     * @return the result of the reduction
+     * @see #collect(Supplier, ObjDoubleConsumer, BiConsumer)
+     * @since 0.3.0
+     */
+    @SuppressWarnings("unchecked")
+    public <A, R> R collect(DoubleCollector<A, R> collector) {
+        if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
+            return (R) collect(collector.supplier(), collector.doubleAccumulator(), collector.merger());
+        return collector.finisher().apply(collect(collector.supplier(), collector.doubleAccumulator(), collector
+                .merger()));
+    }
+
+    @Override
+    public double sum() {
+        if (context.fjp != null)
+            return context.terminate(stream()::sum);
+        return stream().sum();
+    }
+
+    @Override
+    public OptionalDouble min() {
+        return reduce(Math::min);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided
+     * {@code Comparator}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param comparator a non-interfering, stateless {@link Comparator} to
+     *        compare elements of this stream
+     * @return an {@code OptionalDouble} describing the minimum element of this
+     *         stream, or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble min(Comparator<Double> comparator) {
+        return reduce((a, b) -> comparator.compare(a, b) > 0 ? b : a);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public <V extends Comparable<? super V>> OptionalDouble minBy(DoubleFunction<V> keyExtractor) {
+        ObjDoubleBox<V> result = collect(() -> new ObjDoubleBox<>(null, 0), (box, i) -> {
+            V val = Objects.requireNonNull(keyExtractor.apply(i));
+            if (box.a == null || box.a.compareTo(val) > 0) {
+                box.a = val;
+                box.b = i;
+            }
+        }, (box1, box2) -> {
+            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) > 0)) {
+                box1.a = box2.a;
+                box1.b = box2.b;
+            }
+        });
+        return result.a == null ? OptionalDouble.empty() : OptionalDouble.of(result.b);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble minByInt(DoubleToIntFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, d) -> {
+            int key = keyExtractor.applyAsInt(d);
+            if (!box.b || box.i > key) {
+                box.b = true;
+                box.i = key;
+                box.d = d;
+            }
+        }, PrimitiveBox.MIN_INT).asDouble();
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble minByLong(DoubleToLongFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, d) -> {
+            long key = keyExtractor.applyAsLong(d);
+            if (!box.b || box.l > key) {
+                box.b = true;
+                box.l = key;
+                box.d = d;
+            }
+        }, PrimitiveBox.MIN_LONG).asDouble();
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble minByDouble(DoubleUnaryOperator keyExtractor) {
+        double[] result = collect(() -> new double[3], (acc, d) -> {
+            double key = keyExtractor.applyAsDouble(d);
+            if (acc[2] == 0 || Double.compare(acc[1], key) > 0) {
+                acc[0] = d;
+                acc[1] = key;
+                acc[2] = 1;
+            }
+        }, (acc1, acc2) -> {
+            if (acc2[2] == 1 && (acc1[2] == 0 || Double.compare(acc1[1], acc2[1]) > 0))
+                System.arraycopy(acc2, 0, acc1, 0, 3);
+        });
+        return result[2] == 1 ? OptionalDouble.of(result[0]) : OptionalDouble.empty();
+    }
+
+    @Override
+    public OptionalDouble max() {
+        return reduce(Math::max);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided
+     * {@code Comparator}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param comparator a non-interfering, stateless {@link Comparator} to
+     *        compare elements of this stream
+     * @return an {@code OptionalDouble} describing the maximum element of this
+     *         stream, or an empty {@code OptionalDouble} if the stream is empty
+     */
+    public OptionalDouble max(Comparator<Double> comparator) {
+        return reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public <V extends Comparable<? super V>> OptionalDouble maxBy(DoubleFunction<V> keyExtractor) {
+        ObjDoubleBox<V> result = collect(() -> new ObjDoubleBox<>(null, 0), (box, i) -> {
+            V val = Objects.requireNonNull(keyExtractor.apply(i));
+            if (box.a == null || box.a.compareTo(val) < 0) {
+                box.a = val;
+                box.b = i;
+            }
+        }, (box1, box2) -> {
+            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) < 0)) {
+                box1.a = box2.a;
+                box1.b = box2.b;
+            }
+        });
+        return result.a == null ? OptionalDouble.empty() : OptionalDouble.of(result.b);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble maxByInt(DoubleToIntFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, d) -> {
+            int key = keyExtractor.applyAsInt(d);
+            if (!box.b || box.i < key) {
+                box.b = true;
+                box.i = key;
+                box.d = d;
+            }
+        }, PrimitiveBox.MAX_INT).asDouble();
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble maxByLong(DoubleToLongFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, d) -> {
+            long key = keyExtractor.applyAsLong(d);
+            if (!box.b || box.l < key) {
+                box.b = true;
+                box.l = key;
+                box.d = d;
+            }
+        }, PrimitiveBox.MAX_LONG).asDouble();
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalDouble} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalDouble} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalDouble maxByDouble(DoubleUnaryOperator keyExtractor) {
+        double[] result = collect(() -> new double[3], (acc, d) -> {
+            double key = keyExtractor.applyAsDouble(d);
+            if (acc[2] == 0 || Double.compare(acc[1], key) < 0) {
+                acc[0] = d;
+                acc[1] = key;
+                acc[2] = 1;
+            }
+        }, (acc1, acc2) -> {
+            if (acc2[2] == 1 && (acc1[2] == 0 || Double.compare(acc1[1], acc2[1]) < 0))
+                System.arraycopy(acc2, 0, acc1, 0, 3);
+        });
+        return result[2] == 1 ? OptionalDouble.of(result[0]) : OptionalDouble.empty();
+    }
+
+    @Override
+    public long count() {
+        if (context.fjp != null)
+            return context.terminate(stream()::count);
+        return stream().count();
+    }
+
+    @Override
+    public OptionalDouble average() {
+        if (context.fjp != null)
+            return context.terminate(stream()::average);
+        return stream().average();
+    }
+
+    @Override
+    public DoubleSummaryStatistics summaryStatistics() {
+        return collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);
+    }
+
+    @Override
+    public boolean anyMatch(DoublePredicate predicate) {
+        if (context.fjp != null)
+            return context.terminate(predicate, stream()::anyMatch);
+        return stream().anyMatch(predicate);
+    }
+
+    @Override
+    public boolean allMatch(DoublePredicate predicate) {
+        if (context.fjp != null)
+            return context.terminate(predicate, stream()::allMatch);
+        return stream().allMatch(predicate);
+    }
+
+    @Override
+    public boolean noneMatch(DoublePredicate predicate) {
+        return !anyMatch(predicate);
+    }
+
+    @Override
+    public OptionalDouble findFirst() {
+        if (context.fjp != null)
+            return context.terminate(stream()::findFirst);
+        return stream().findFirst();
+    }
+
+    /**
+     * Returns an {@link OptionalDouble} describing the first element of this
+     * stream, which matches given predicate, or an empty {@code OptionalDouble}
+     * if there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalDouble} describing the first matching element
+     *         of this stream, or an empty {@code OptionalDouble} if there's no
+     *         matching element
+     * @see #findFirst()
+     */
+    public OptionalDouble findFirst(DoublePredicate predicate) {
+        return filter(predicate).findFirst();
+    }
+
+    @Override
+    public OptionalDouble findAny() {
+        if (context.fjp != null)
+            return context.terminate(stream()::findAny);
+        return stream().findAny();
+    }
+
+    /**
+     * Returns an {@link OptionalDouble} describing some element of the stream,
+     * which matches given predicate, or an empty {@code OptionalDouble} if
+     * there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * <p>
+     * The behavior of this operation is explicitly nondeterministic; it is free
+     * to select any element in the stream. This is to allow for maximal
+     * performance in parallel operations; the cost is that multiple invocations
+     * on the same source may not return the same result. (If a stable result is
+     * desired, use {@link #findFirst(DoublePredicate)} instead.)
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalDouble} describing some matching element of
+     *         this stream, or an empty {@code OptionalDouble} if there's no
+     *         matching element
+     * @see #findAny()
+     * @see #findFirst(DoublePredicate)
+     */
+    public OptionalDouble findAny(DoublePredicate predicate) {
+        return filter(predicate).findAny();
+    }
+
+    /**
+     * Returns an {@link OptionalLong} describing the zero-based index of the
+     * first element of this stream, which matches given predicate, or an empty
+     * {@code OptionalLong} if there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalLong} describing the index of the first
+     *         matching element of this stream, or an empty {@code OptionalLong}
+     *         if there's no matching element.
+     * @see #findFirst(DoublePredicate)
+     * @since 0.4.0
+     */
+    public OptionalLong indexOf(DoublePredicate predicate) {
+        return boxed().indexOf(predicate::test);
+    }
+
+    @Override
+    public StreamEx<Double> boxed() {
+        return new StreamEx<>(stream().boxed(), context);
+    }
+
+    @Override
+    public DoubleStreamEx sequential() {
+        return (DoubleStreamEx) super.sequential();
+    }
+
+    @Override
+    public DoubleStreamEx parallel() {
+        return (DoubleStreamEx) super.parallel();
+    }
+
+    @Override
+    public DoubleStreamEx parallel(ForkJoinPool fjp) {
+        return (DoubleStreamEx) super.parallel(fjp);
+    }
+
+    @Override
+    public OfDouble iterator() {
+        return Spliterators.iterator(spliterator());
+    }
+
+    /**
+     * Returns a new {@code DoubleStreamEx} which is a concatenation of this
+     * stream and the stream containing supplied values
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * @param values the values to append to the stream
+     * @return the new stream
+     */
+    public DoubleStreamEx append(double... values) {
+        if (values.length == 0)
+            return this;
+        return new DoubleStreamEx(DoubleStream.concat(stream(), DoubleStream.of(values)), context);
+    }
+
+    /**
+     * Creates a lazily concatenated stream whose elements are all the elements
+     * of this stream followed by all the elements of the other stream. The
+     * resulting stream is ordered if both of the input streams are ordered, and
+     * parallel if either of the input streams is parallel. When the resulting
+     * stream is closed, the close handlers for both input streams are invoked.
+     *
+     * @param other the other stream
+     * @return this stream appended by the other stream
+     * @see DoubleStream#concat(DoubleStream, DoubleStream)
+     */
+    public DoubleStreamEx append(DoubleStream other) {
+        return new DoubleStreamEx(DoubleStream.concat(stream(), other), context.combine(other));
+    }
+
+    /**
+     * Returns a new {@code DoubleStreamEx} which is a concatenation of the
+     * stream containing supplied values and this stream
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * @param values the values to prepend to the stream
+     * @return the new stream
+     */
+    public DoubleStreamEx prepend(double... values) {
+        if (values.length == 0)
+            return this;
+        return new DoubleStreamEx(DoubleStream.concat(DoubleStream.of(values), stream()), context);
+    }
+
+    /**
+     * Creates a lazily concatenated stream whose elements are all the elements
+     * of the other stream followed by all the elements of this stream. The
+     * resulting stream is ordered if both of the input streams are ordered, and
+     * parallel if either of the input streams is parallel. When the resulting
+     * stream is closed, the close handlers for both input streams are invoked.
+     *
+     * @param other the other stream
+     * @return this stream prepended by the other stream
+     * @see DoubleStream#concat(DoubleStream, DoubleStream)
+     */
+    public DoubleStreamEx prepend(DoubleStream other) {
+        return new DoubleStreamEx(DoubleStream.concat(other, stream()), context.combine(other));
+    }
+
+    /**
+     * Returns a stream consisting of the results of applying the given function
+     * to the every adjacent pair of elements of this stream.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The output stream will contain one element less than this stream. If this
+     * stream contains zero or one element the output stream will be empty.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        adjacent pair of this stream elements.
+     * @return the new stream
+     * @since 0.2.1
+     */
+    public DoubleStreamEx pairMap(DoubleBinaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfDouble(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
+    }
+
+    /**
+     * Returns a {@link String} which is the concatenation of the results of
+     * calling {@link String#valueOf(double)} on each element of this stream,
+     * separated by the specified delimiter, in encounter order.
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * @param delimiter the delimiter to be used between each element
+     * @return the result of concatenation. For empty input stream empty String
+     *         is returned.
+     * @since 0.3.1
+     */
+    public String joining(CharSequence delimiter) {
+        return collect(DoubleCollector.joining(delimiter));
+    }
+
+    /**
+     * Returns a {@link String} which is the concatenation of the results of
+     * calling {@link String#valueOf(double)} on each element of this stream,
+     * separated by the specified delimiter, with the specified prefix and
+     * suffix in encounter order.
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * @param delimiter the delimiter to be used between each element
+     * @param prefix the sequence of characters to be used at the beginning of
+     *        the joined result
+     * @param suffix the sequence of characters to be used at the end of the
+     *        joined result
+     * @return the result of concatenation. For empty input stream
+     *         {@code prefix + suffix} is returned.
+     * @since 0.3.1
+     */
+    public String joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
+        return collect(DoubleCollector.joining(delimiter, prefix, suffix));
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream until the
+     * first element which does not match the given predicate is found.
+     * 
+     * <p>
+     * This is a short-circuiting stateful operation. It can be either
+     * <a href="package-summary.html#StreamOps">intermediate or
+     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
+     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
+     * implementation.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.3.6
+     * @see #takeWhileInclusive(DoublePredicate)
+     * @see #dropWhile(DoublePredicate)
+     */
+    public DoubleStreamEx takeWhile(DoublePredicate predicate) {
+        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), false);
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream until the
+     * first element which does not match the given predicate is found
+     * (including the first mismatching element).
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.5.5
+     * @see #takeWhile(DoublePredicate)
+     */
+    public DoubleStreamEx takeWhileInclusive(DoublePredicate predicate) {
+        Objects.requireNonNull(predicate);
+        return delegate(new TakeDrop.TDOfDouble(spliterator(), false, true, predicate));
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream starting
+     * from the first element which does not match the given predicate. If the
+     * predicate is true for all stream elements, an empty stream is returned.
+     * 
+     * <p>
+     * This is a stateful operation. It can be either
+     * <a href="package-summary.html#StreamOps">intermediate or
+     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
+     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
+     * implementation.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.3.6
+     */
+    public DoubleStreamEx dropWhile(DoublePredicate predicate) {
+        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), true);
+    }
+
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful
+     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
+     * operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(DoubleBinaryOperator)}, but
+     * unlike {@code scanLeft} this operation is intermediate and accumulation
+     * function must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(DoubleBinaryOperator)
+     * @since 0.6.1
+     */
+    public DoubleStreamEx prefix(DoubleBinaryOperator op) {
+        Spliterator.OfDouble spltr = spliterator();
+        return delegate(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfDouble(spltr, op)
+                : new PrefixOps.OfUnordDouble(spltr, op));
+    }
+
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super DoubleStreamEx, U> mapper) {
+        return mapper.apply(this);
+    }
+
+    /**
+     * Returns an empty sequential {@code DoubleStreamEx}.
+     *
+     * @return an empty sequential stream
+     */
+    public static DoubleStreamEx empty() {
+        return of(Spliterators.emptyDoubleSpliterator());
+    }
+
+    /**
+     * Returns a sequential {@code DoubleStreamEx} containing a single element.
+     *
+     * @param element the single element
+     * @return a singleton sequential stream
+     */
+    public static DoubleStreamEx of(double element) {
+        return of(new ConstSpliterator.OfDouble(element, 1, true));
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
+     * the specified values.
+     *
+     * @param elements the elements of the new stream
+     * @return the new stream
+     */
+    public static DoubleStreamEx of(double... elements) {
+        return of(Arrays.spliterator(elements));
+    }
+
+    /**
+     * Returns a sequential {@link DoubleStreamEx} with the specified range of
+     * the specified array as its source.
+     *
+     * @param array the array, assumed to be unmodified during use
+     * @param startInclusive the first index to cover, inclusive
+     * @param endExclusive index immediately past the last index to cover
+     * @return an {@code DoubleStreamEx} for the array range
+     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
+     *         negative, {@code endExclusive} is less than
+     *         {@code startInclusive}, or {@code endExclusive} is greater than
+     *         the array size
+     * @since 0.1.1
+     * @see Arrays#stream(double[], int, int)
+     */
+    public static DoubleStreamEx of(double[] array, int startInclusive, int endExclusive) {
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
+     * the unboxed elements of supplied array.
+     *
+     * @param array the array to create the stream from.
+     * @return the new stream
+     * @see Arrays#stream(Object[])
+     * @since 0.5.0
+     */
+    public static DoubleStreamEx of(Double[] array) {
+        return seq(Arrays.stream(array).mapToDouble(Double::doubleValue));
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
+     * the values in the supplied {@link java.nio.DoubleBuffer}.
+     * 
+     * <p>
+     * The resulting stream covers only a portion of {@code DoubleBuffer}
+     * content which starts with {@linkplain Buffer#position() position}
+     * (inclusive) and ends with {@linkplain Buffer#limit() limit} (exclusive).
+     * Changes in position and limit after the stream creation don't affect the
+     * stream.
+     * 
+     * <p>
+     * The resulting stream does not change the internal {@code DoubleBuffer}
+     * state.
+     * 
+     * @param buf the {@code DoubleBuffer} to create a stream from
+     * @return the new stream
+     * @since 0.6.2
+     */
+    public static DoubleStreamEx of(java.nio.DoubleBuffer buf) {
+        return IntStreamEx.range(buf.position(), buf.limit()).mapToDouble(buf::get);
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
+     * the specified float values casted to double.
+     *
+     * @param elements the elements of the new stream
+     * @return the new stream
+     * @since 0.2.0
+     */
+    public static DoubleStreamEx of(float... elements) {
+        return of(elements, 0, elements.length);
+    }
+
+    /**
+     * Returns a sequential {@link DoubleStreamEx} with the specified range of
+     * the specified array as its source. Array values will be casted to double.
+     *
+     * @param array the array, assumed to be unmodified during use
+     * @param startInclusive the first index to cover, inclusive
+     * @param endExclusive index immediately past the last index to cover
+     * @return an {@code IntStreamEx} for the array range
+     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
+     *         negative, {@code endExclusive} is less than
+     *         {@code startInclusive}, or {@code endExclusive} is greater than
+     *         the array size
+     * @since 0.2.0
+     */
+    public static DoubleStreamEx of(float[] array, int startInclusive, int endExclusive) {
+        rangeCheck(array.length, startInclusive, endExclusive);
+        return of(new RangeBasedSpliterator.OfFloat(startInclusive, endExclusive, array));
+    }
+
+    /**
+     * Returns a {@code DoubleStreamEx} object which wraps given
+     * {@link DoubleStream}.
+     * 
+     * <p>
+     * The supplied stream must not be consumed or closed when this method is
+     * called. No operation must be performed on the supplied stream after it's
+     * wrapped.
+     * 
+     * @param stream original stream
+     * @return the wrapped stream
+     * @since 0.0.8
+     */
+    public static DoubleStreamEx of(DoubleStream stream) {
+        return stream instanceof DoubleStreamEx ? (DoubleStreamEx) stream
+                : new DoubleStreamEx(stream, StreamContext.of(stream));
+    }
+
+    /**
+     * Returns a sequential {@link DoubleStreamEx} created from given
+     * {@link java.util.Spliterator.OfDouble}.
+     * 
+     * @param spliterator a spliterator to create the stream from.
+     * @return the new stream
+     * @since 0.3.4
+     */
+    public static DoubleStreamEx of(Spliterator.OfDouble spliterator) {
+        return new DoubleStreamEx(spliterator, StreamContext.SEQUENTIAL);
+    }
+
+    /**
+     * Returns a sequential, ordered {@link DoubleStreamEx} created from given
+     * {@link java.util.PrimitiveIterator.OfDouble}.
+     *
+     * <p>
+     * This method is roughly equivalent to
+     * {@code DoubleStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     * 
+     * <p>
+     * Use this method only if you cannot provide better Stream source.
+     *
+     * @param iterator an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static DoubleStreamEx of(PrimitiveIterator.OfDouble iterator) {
+        return of(new UnknownSizeSpliterator.USOfDouble(iterator));
+    }
+
+    /**
+     * Returns a sequential {@code DoubleStreamEx} containing an
+     * {@link OptionalDouble} value, if present, otherwise returns an empty
+     * {@code DoubleStreamEx}.
+     *
+     * @param optional the optional to create a stream of
+     * @return a stream with an {@code OptionalDouble} value if present,
+     *         otherwise an empty stream
+     * @since 0.1.1
+     */
+    public static DoubleStreamEx of(OptionalDouble optional) {
+        return optional.isPresent() ? of(optional.getAsDouble()) : empty();
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} whose elements are
+     * the unboxed elements of supplied collection.
+     *
+     * @param collection the collection to create the stream from.
+     * @return the new stream
+     * @see Collection#stream()
+     */
+    public static DoubleStreamEx of(Collection<Double> collection) {
+        return seq(collection.stream().mapToDouble(Double::doubleValue));
+    }
+
+    /**
+     * Returns an effectively unlimited stream of pseudorandom {@code double}
+     * values, each between zero (inclusive) and one (exclusive) produced by
+     * given {@link Random} object.
+     *
+     * <p>
+     * A pseudorandom {@code double} value is generated as if it's the result of
+     * calling the method {@link Random#nextDouble()}.
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @return a stream of pseudorandom {@code double} values
+     * @see Random#doubles()
+     */
+    public static DoubleStreamEx of(Random random) {
+        return seq(random.doubles());
+    }
+
+    /**
+     * Returns a stream producing the given {@code streamSize} number of
+     * pseudorandom {@code double} values, each between zero (inclusive) and one
+     * (exclusive) produced by given {@link Random} object.
+     *
+     * <p>
+     * A pseudorandom {@code double} value is generated as if it's the result of
+     * calling the method {@link Random#nextDouble()}.
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param streamSize the number of values to generate
+     * @return a stream of pseudorandom {@code double} values
+     * @see Random#doubles(long)
+     */
+    public static DoubleStreamEx of(Random random, long streamSize) {
+        return seq(random.doubles(streamSize));
+    }
+
+    /**
+     * Returns an effectively unlimited stream of pseudorandom {@code double}
+     * values, each conforming to the given origin (inclusive) and bound
+     * (exclusive) produced by given {@link Random} object.
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param randomNumberOrigin the origin (inclusive) of each random value
+     * @param randomNumberBound the bound (exclusive) of each random value
+     * @return a stream of pseudorandom {@code double} values, each with the
+     *         given origin (inclusive) and bound (exclusive)
+     * @see Random#doubles(double, double)
+     */
+    public static DoubleStreamEx of(Random random, double randomNumberOrigin, double randomNumberBound) {
+        return seq(random.doubles(randomNumberOrigin, randomNumberBound));
+    }
+
+    /**
+     * Returns a stream producing the given {@code streamSize} number of
+     * pseudorandom {@code double} values, each conforming to the given origin
+     * (inclusive) and bound (exclusive) produced by given {@link Random}
+     * object.
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param randomNumberOrigin the origin (inclusive) of each random value
+     * @param randomNumberBound the bound (exclusive) of each random value
+     * @param streamSize the number of values to generate
+     * @return a stream of pseudorandom {@code double} values, each with the
+     *         given origin (inclusive) and bound (exclusive)
+     * @see Random#doubles(long, double, double)
+     */
+    public static DoubleStreamEx of(Random random, long streamSize, double randomNumberOrigin,
+            double randomNumberBound) {
+        return seq(random.doubles(streamSize, randomNumberOrigin, randomNumberBound));
+    }
+
+    /**
+     * Returns an infinite sequential ordered {@code DoubleStreamEx} produced by
+     * iterative application of a function {@code f} to an initial element
+     * {@code seed}, producing a stream consisting of {@code seed},
+     * {@code f(seed)}, {@code f(f(seed))}, etc.
+     *
+     * <p>
+     * The first element (position {@code 0}) in the {@code DoubleStreamEx} will
+     * be the provided {@code seed}. For {@code n > 0}, the element at position
+     * {@code n}, will be the result of applying the function {@code f} to the
+     * element at position {@code n - 1}.
+     *
+     * @param seed the initial element
+     * @param f a function to be applied to to the previous element to produce a
+     *        new element
+     * @return A new sequential {@code DoubleStream}
+     * @see #iterate(double, DoublePredicate, DoubleUnaryOperator)
+     */
+    public static DoubleStreamEx iterate(final double seed, final DoubleUnaryOperator f) {
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code DoubleStreamEx.iterate} should produce the same sequence of
+     * elements as produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (double index=seed; predicate.test(index); index = f.apply(index)) {
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code DoubleStreamEx}
+     * @see #iterate(double, DoubleUnaryOperator)
+     * @since 0.6.0
+     */
+    public static DoubleStreamEx iterate(double seed, DoublePredicate predicate, DoubleUnaryOperator f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator.OfDouble spliterator = new Spliterators.AbstractDoubleSpliterator(Long.MAX_VALUE,
+                Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
+            double prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(DoubleConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                double t;
+                if (started)
+                    t = f.applyAsDouble(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(DoubleConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                double t = started ? f.applyAsDouble(prev) : seed;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.applyAsDouble(t);
+                }
+            }
+        };
+        return of(spliterator);
+    }
+
+    /**
+     * Returns an infinite sequential unordered stream where each element is
+     * generated by the provided {@code DoubleSupplier}. This is suitable for
+     * generating constant streams, streams of random elements, etc.
+     *
+     * @param s the {@code DoubleSupplier} for generated elements
+     * @return a new infinite sequential unordered {@code DoubleStreamEx}
+     * @see DoubleStream#generate(DoubleSupplier)
+     */
+    public static DoubleStreamEx generate(DoubleSupplier s) {
+        return seq(DoubleStream.generate(s));
+    }
+
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. Note however that if a short-circuiting operation is used,
+     * then the final state of the mutable object cannot be guaranteed.
+     * 
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static DoubleStreamEx produce(Predicate<DoubleConsumer> producer) {
+        Box<DoubleEmitter> box = new Box<>();
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
+    /**
+     * Returns a sequential unordered {@code DoubleStreamEx} of given length
+     * which elements are equal to supplied value.
+     * 
+     * @param value the constant value
+     * @param length the length of the stream
+     * @return a new {@code DoubleStreamEx}
+     * @since 0.1.2
+     */
+    public static DoubleStreamEx constant(double value, long length) {
+        return of(new ConstSpliterator.OfDouble(value, length, false));
+    }
+
+    /**
+     * Returns a sequential {@code DoubleStreamEx} containing the results of
+     * applying the given function to the corresponding pairs of values in given
+     * two arrays.
+     * 
+     * @param first the first array
+     * @param second the second array
+     * @param mapper a non-interfering, stateless function to apply to each pair
+     *        of the corresponding array elements.
+     * @return a new {@code DoubleStreamEx}
+     * @throws IllegalArgumentException if length of the arrays differs.
+     * @since 0.2.1
+     */
+    public static DoubleStreamEx zip(double[] first, double[] second, DoubleBinaryOperator mapper) {
+        return of(new RangeBasedSpliterator.ZipDouble(0, checkLength(first.length, second.length), mapper, first,
+                second));
+    }
+
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using
+     * {@link DoubleStreamEx#iterate(double, DoubleUnaryOperator)} or
+     * {@link DoubleStreamEx#generate(DoubleSupplier)}.
+     * 
+     * @author Tagir Valeev
+     *
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface DoubleEmitter {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
+         * 
+         * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param action consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        DoubleEmitter next(DoubleConsumer action);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator.OfDouble spliterator() {
+            return new EmitterSpliterator.OfDouble(this);
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default DoubleStreamEx stream() {
+            return of(spliterator());
+        }
+    }
+}
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 1f583f7..4026e37 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -1801,7 +1801,9 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @since 0.6.1
      */
     public IntStreamEx prefix(IntBinaryOperator op) {
-        return delegate(new PrefixOps.OfInt(spliterator(), op));
+        Spliterator.OfInt spltr = spliterator();
+        return delegate(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfInt(spltr, op)
+                : new PrefixOps.OfUnordInt(spltr, op));
     }
 
     // Necessary to generate proper JavaDoc
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 895d274..a59abb9 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1,2163 +1,2165 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.nio.Buffer;
-import java.util.AbstractMap;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.LongSummaryStatistics;
-import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.OptionalDouble;
-import java.util.OptionalLong;
-import java.util.PrimitiveIterator;
-import java.util.PrimitiveIterator.OfLong;
-import java.util.Random;
-import java.util.Spliterator;
-import java.util.Spliterators;
-import java.util.concurrent.ForkJoinPool;
-import java.util.function.BiConsumer;
-import java.util.function.Function;
-import java.util.function.LongBinaryOperator;
-import java.util.function.LongConsumer;
-import java.util.function.LongFunction;
-import java.util.function.LongPredicate;
-import java.util.function.LongSupplier;
-import java.util.function.LongToDoubleFunction;
-import java.util.function.LongToIntFunction;
-import java.util.function.LongUnaryOperator;
-import java.util.function.ObjLongConsumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import java.util.stream.Collector;
-import java.util.stream.DoubleStream;
-import java.util.stream.IntStream;
-import java.util.stream.LongStream;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
-
-import static one.util.streamex.Internals.Box;
-import static one.util.streamex.Internals.INITIAL_SIZE;
-import static one.util.streamex.Internals.LongBuffer;
-import static one.util.streamex.Internals.ObjLongBox;
-import static one.util.streamex.Internals.PrimitiveBox;
-import static one.util.streamex.Internals.checkLength;
-import static one.util.streamex.Internals.intSize;
-
-/**
- * A {@link LongStream} implementation with additional functionality
- * 
- * @author Tagir Valeev
- */
-public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong, LongStreamEx> implements
-        LongStream {
-    LongStreamEx(LongStream stream, StreamContext context) {
-        super(stream, context);
-    }
-
-    LongStreamEx(Spliterator.OfLong spliterator, StreamContext context) {
-        super(spliterator, context);
-    }
-
-    @Override
-    LongStream createStream() {
-        return StreamSupport.longStream(spliterator, isParallel());
-    }
-
-    private static LongStreamEx seq(LongStream stream) {
-        return new LongStreamEx(stream, StreamContext.SEQUENTIAL);
-    }
-
-    final LongStreamEx delegate(Spliterator.OfLong spliterator) {
-        return new LongStreamEx(spliterator, context);
-    }
-
-    @Override
-    public LongStreamEx unordered() {
-        return (LongStreamEx) super.unordered();
-    }
-
-    @Override
-    public LongStreamEx onClose(Runnable closeHandler) {
-        return (LongStreamEx) super.onClose(closeHandler);
-    }
-
-    @Override
-    public LongStreamEx filter(LongPredicate predicate) {
-        return new LongStreamEx(stream().filter(predicate), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that don't
-     * match the given predicate.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param predicate a non-interfering, stateless predicate to apply to each
-     *        element to determine if it should be excluded
-     * @return the new stream
-     */
-    public LongStreamEx remove(LongPredicate predicate) {
-        return filter(predicate.negate());
-    }
-
-    /**
-     * Returns true if this stream contains the specified value
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     * 
-     * @param value the value too look for in the stream
-     * @return true if this stream contains the specified value
-     * @see LongStream#anyMatch(LongPredicate)
-     */
-    public boolean has(long value) {
-        return anyMatch(x -> x == value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that don't
-     * equal to the given value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value the value to remove from the stream.
-     * @return the new stream
-     * @since 0.2.2
-     * @see #without(long...)
-     * @see #remove(LongPredicate)
-     */
-    public LongStreamEx without(long value) {
-        return filter(val -> val != value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that don't
-     * equal to any of the supplied values.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate</a>
-     * operation. May return itself if no values were supplied.
-     * 
-     * <p>
-     * Current implementation scans the supplied values linearly for every
-     * stream element.
-     * 
-     * <p>
-     * If the {@code values} array is changed between calling this method and
-     * finishing the stream traversal, then the result of the stream traversal
-     * is undefined: changes may or may not be taken into account.
-     *
-     * @param values the values to remove from the stream.
-     * @return the new stream
-     * @since 0.5.5
-     * @see #without(long)
-     * @see #remove(LongPredicate)
-     */
-    public LongStreamEx without(long... values) {
-        if (values.length == 0)
-            return this;
-        if (values.length == 1)
-            return without(values[0]);
-        return filter(x -> {
-            for (long val : values) {
-                if (x == val)
-                    return false;
-            }
-            return true;
-        });
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that strictly
-     * greater than the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public LongStreamEx greater(long value) {
-        return filter(val -> val > value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that greater
-     * than or equal to the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public LongStreamEx atLeast(long value) {
-        return filter(val -> val >= value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that strictly
-     * less than the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public LongStreamEx less(long value) {
-        return filter(val -> val < value);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream that less than
-     * or equal to the specified value.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param value a value to compare to
-     * @return the new stream
-     * @since 0.2.3
-     */
-    public LongStreamEx atMost(long value) {
-        return filter(val -> val <= value);
-    }
-
-    @Override
-    public LongStreamEx map(LongUnaryOperator mapper) {
-        return new LongStreamEx(stream().map(mapper), context);
-    }
-
-    /**
-     * Returns a stream where the first element is the replaced with the result
-     * of applying the given function while the other elements are left intact.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     *
-     * @param mapper a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to apply to the first element
-     * @return the new stream
-     * @since 0.4.1
-     */
-    public LongStreamEx mapFirst(LongUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong((a, b) -> b, mapper, spliterator(),
-                PairSpliterator.MODE_MAP_FIRST));
-    }
-
-    /**
-     * Returns a stream where the last element is the replaced with the result
-     * of applying the given function while the other elements are left intact.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The mapper function is called at most once. It could be not called at all
-     * if the stream is empty or there is short-circuiting operation downstream.
-     *
-     * @param mapper a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to apply to the last element
-     * @return the new stream
-     * @since 0.4.1
-     */
-    public LongStreamEx mapLast(LongUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong((a, b) -> a, mapper, spliterator(),
-                PairSpliterator.MODE_MAP_LAST));
-    }
-
-    @Override
-    public <U> StreamEx<U> mapToObj(LongFunction<? extends U> mapper) {
-        return new StreamEx<>(stream().mapToObj(mapper), context);
-    }
-
-    @Override
-    public IntStreamEx mapToInt(LongToIntFunction mapper) {
-        return new IntStreamEx(stream().mapToInt(mapper), context);
-    }
-
-    @Override
-    public DoubleStreamEx mapToDouble(LongToDoubleFunction mapper) {
-        return new DoubleStreamEx(stream().mapToDouble(mapper), context);
-    }
-
-    /**
-     * Returns an {@link EntryStream} consisting of the {@link Entry} objects
-     * which keys and values are results of applying the given functions to the
-     * elements of this stream.
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param <K> The {@code Entry} key type
-     * @param <V> The {@code Entry} value type
-     * @param keyMapper a non-interfering, stateless function to apply to each
-     *        element
-     * @param valueMapper a non-interfering, stateless function to apply to each
-     *        element
-     * @return the new stream
-     * @since 0.3.1
-     */
-    public <K, V> EntryStream<K, V> mapToEntry(LongFunction<? extends K> keyMapper,
-            LongFunction<? extends V> valueMapper) {
-        return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
-                valueMapper.apply(t))), context);
-    }
-
-    @Override
-    public LongStreamEx flatMap(LongFunction<? extends LongStream> mapper) {
-        return new LongStreamEx(stream().flatMap(mapper), context);
-    }
-
-    /**
-     * Returns an {@link IntStreamEx} consisting of the results of replacing
-     * each element of this stream with the contents of a mapped stream produced
-     * by applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces an {@code IntStream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public IntStreamEx flatMapToInt(LongFunction<? extends IntStream> mapper) {
-        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
-    }
-
-    /**
-     * Returns a {@link DoubleStreamEx} consisting of the results of replacing
-     * each element of this stream with the contents of a mapped stream produced
-     * by applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces an {@code DoubleStream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public DoubleStreamEx flatMapToDouble(LongFunction<? extends DoubleStream> mapper) {
-        return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), context);
-    }
-
-    /**
-     * Returns a {@link StreamEx} consisting of the results of replacing each
-     * element of this stream with the contents of a mapped stream produced by
-     * applying the provided mapping function to each element. Each mapped
-     * stream is closed after its contents have been placed into this stream.
-     * (If a mapped stream is {@code null} an empty stream is used, instead.)
-     *
-     * <p>
-     * This is an intermediate operation.
-     *
-     * @param <R> The element type of the new stream
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        element which produces a {@code Stream} of new values
-     * @return the new stream
-     * @since 0.3.0
-     */
-    public <R> StreamEx<R> flatMapToObj(LongFunction<? extends Stream<R>> mapper) {
-        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
-    }
-
-    /**
-     * Returns a new stream containing all the elements of the original stream interspersed with
-     * given delimiter.
-     * 
-     * <p>
-     * For example, {@code LongStreamEx.of(1, 2, 3).intersperse(4)} will yield a stream containing
-     * five elements: 1, 4, 2, 4, 3.
-     * 
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
-     * 
-     * @param delimiter a delimiter to be inserted between each pair of elements
-     * @return the new stream
-     * @since 0.6.6
-     */
-    public LongStreamEx intersperse(int delimiter) {
-        return new LongStreamEx(stream().flatMap(s -> LongStreamEx.of(delimiter, s)).skip(1), context);
-    }
-
-    @Override
-    public LongStreamEx distinct() {
-        return new LongStreamEx(stream().distinct(), context);
-    }
-
-    @Override
-    public LongStreamEx sorted() {
-        return new LongStreamEx(stream().sorted(), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream sorted
-     * according to the given comparator. Stream elements are boxed before
-     * passing to the comparator.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param comparator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        {@code Comparator} to be used to compare stream elements
-     * @return the new stream
-     */
-    public LongStreamEx sorted(Comparator<Long> comparator) {
-        return new LongStreamEx(stream().boxed().sorted(comparator).mapToLong(Long::longValue), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream in reverse
-     * sorted order.
-     *
-     * <p>
-     * This is a stateful intermediate operation.
-     *
-     * @return the new stream
-     * @since 0.0.8
-     */
-    public LongStreamEx reverseSorted() {
-        LongUnaryOperator inv = x -> ~x;
-        return new LongStreamEx(stream().map(inv).sorted().map(inv), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the natural order of the keys extracted by provided
-     * function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public <V extends Comparable<? super V>> LongStreamEx sortedBy(LongFunction<V> keyExtractor) {
-        return sorted(Comparator.comparing(keyExtractor::apply));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the int values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public LongStreamEx sortedByInt(LongToIntFunction keyExtractor) {
-        return sorted(Comparator.comparingInt(keyExtractor::applyAsInt));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the long values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public LongStreamEx sortedByLong(LongUnaryOperator keyExtractor) {
-        return sorted(Comparator.comparingLong(keyExtractor::applyAsLong));
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, sorted
-     * according to the double values extracted by provided function.
-     *
-     * <p>
-     * For ordered streams, the sort is stable. For unordered streams, no
-     * stability guarantees are made.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
-     * operation</a>.
-     *
-     * @param keyExtractor a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function to be used to extract sorting keys
-     * @return the new stream
-     */
-    public LongStreamEx sortedByDouble(LongToDoubleFunction keyExtractor) {
-        return sorted(Comparator.comparingDouble(keyExtractor::applyAsDouble));
-    }
-
-    @Override
-    public LongStreamEx peek(LongConsumer action) {
-        return new LongStreamEx(stream().peek(action), context);
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, additionally
-     * performing the provided action on the first stream element when it's
-     * consumed from the resulting stream.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The action is called at most once. For parallel stream pipelines, it's
-     * not guaranteed in which thread it will be executed, so if it modifies
-     * shared state, it is responsible for providing the required
-     * synchronization.
-     *
-     * <p>
-     * Note that the action might not be called at all if the first element is
-     * not consumed from the input (for example, if there's short-circuiting
-     * operation downstream which stopped the stream before the first element).
-     * 
-     * <p>
-     * This method exists mainly to support debugging.
-     *
-     * @param action a
-     *        <a href="package-summary.html#NonInterference"> non-interfering
-     *        </a> action to perform on the first stream element as it is
-     *        consumed from the stream
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public LongStreamEx peekFirst(LongConsumer action) {
-        return mapFirst(x -> {
-            action.accept(x);
-            return x;
-        });
-    }
-
-    /**
-     * Returns a stream consisting of the elements of this stream, additionally
-     * performing the provided action on the last stream element when it's
-     * consumed from the resulting stream.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate
-     * operation</a>.
-     *
-     * <p>
-     * The action is called at most once. For parallel stream pipelines, it's
-     * not guaranteed in which thread it will be executed, so if it modifies
-     * shared state, it is responsible for providing the required
-     * synchronization.
-     * 
-     * <p>
-     * Note that the action might not be called at all if the last element is
-     * not consumed from the input (for example, if there's short-circuiting
-     * operation downstream).
-     * 
-     * <p>
-     * This method exists mainly to support debugging.
-     *
-     * @param action a
-     *        <a href="package-summary.html#NonInterference"> non-interfering
-     *        </a> action to perform on the first stream element as it is
-     *        consumed from the stream
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public LongStreamEx peekLast(LongConsumer action) {
-        return mapLast(x -> {
-            action.accept(x);
-            return x;
-        });
-    }
-
-    @Override
-    public LongStreamEx limit(long maxSize) {
-        return new LongStreamEx(stream().limit(maxSize), context);
-    }
-
-    @Override
-    public LongStreamEx skip(long n) {
-        return new LongStreamEx(stream().skip(n), context);
-    }
-
-    @Override
-    public void forEach(LongConsumer action) {
-        if (spliterator != null && !isParallel()) {
-            spliterator().forEachRemaining(action);
-        } else {
-            if (context.fjp != null)
-                context.terminate(() -> {
-                    stream().forEach(action);
-                    return null;
-                });
-            else {
-                stream().forEach(action);
-            }
-        }
-    }
-
-    @Override
-    public void forEachOrdered(LongConsumer action) {
-        if (spliterator != null && !isParallel()) {
-            spliterator().forEachRemaining(action);
-        } else {
-            if (context.fjp != null)
-                context.terminate(() -> {
-                    stream().forEachOrdered(action);
-                    return null;
-                });
-            else {
-                stream().forEachOrdered(action);
-            }
-        }
-    }
-
-    @Override
-    public long[] toArray() {
-        if (context.fjp != null)
-            return context.terminate(stream()::toArray);
-        return stream().toArray();
-    }
-
-    @Override
-    public long reduce(long identity, LongBinaryOperator op) {
-        if (context.fjp != null)
-            return context.terminate(() -> stream().reduce(identity, op));
-        return stream().reduce(identity, op);
-    }
-
-    @Override
-    public OptionalLong reduce(LongBinaryOperator op) {
-        if (context.fjp != null)
-            return context.terminate(op, stream()::reduce);
-        return stream().reduce(op);
-    }
-
-    /**
-     * Folds the elements of this stream using the provided accumulation
-     * function, going left to right. This is equivalent to:
-     * 
-     * <pre>
-     * {@code
-     *     boolean foundAny = false;
-     *     long result = 0;
-     *     for (long element : this stream) {
-     *         if (!foundAny) {
-     *             foundAny = true;
-     *             result = element;
-     *         }
-     *         else
-     *             result = accumulator.apply(result, element);
-     *     }
-     *     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();
-     * }
-     * </pre>
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. If your accumulator function is
-     * associative, consider using {@link #reduce(LongBinaryOperator)} method.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     *
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the result of the folding
-     * @see #foldLeft(long, LongBinaryOperator)
-     * @see #reduce(LongBinaryOperator)
-     * @since 0.4.0
-     */
-    public OptionalLong foldLeft(LongBinaryOperator accumulator) {
-        PrimitiveBox b = new PrimitiveBox();
-        forEachOrdered(t -> {
-            if (b.b)
-                b.l = accumulator.applyAsLong(b.l, t);
-            else {
-                b.l = t;
-                b.b = true;
-            }
-        });
-        return b.asLong();
-    }
-
-    /**
-     * Folds the elements of this stream using the provided seed object and
-     * accumulation function, going left to right. This is equivalent to:
-     * 
-     * <pre>
-     * {@code
-     *     long result = seed;
-     *     for (long element : this stream)
-     *         result = accumulator.apply(result, element)
-     *     return result;
-     * }
-     * </pre>
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. If your accumulator function is
-     * associative, consider using {@link #reduce(long, LongBinaryOperator)}
-     * method.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     *
-     * @param seed the starting value
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the result of the folding
-     * @see #reduce(long, LongBinaryOperator)
-     * @see #foldLeft(LongBinaryOperator)
-     * @since 0.4.0
-     */
-    public long foldLeft(long seed, LongBinaryOperator accumulator) {
-        long[] box = new long[] { seed };
-        forEachOrdered(t -> box[0] = accumulator.applyAsLong(box[0], t));
-        return box[0];
-    }
-
-    /**
-     * Produces an array containing cumulative results of applying the
-     * accumulation function going left to right.
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right.
-     *
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the array where the first element is the first element of this
-     *         stream and every successor element is the result of applying
-     *         accumulator function to the previous array element and the
-     *         corresponding stream element. The resulting array has the same
-     *         length as this stream.
-     * @see #foldLeft(LongBinaryOperator)
-     * @since 0.5.1
-     */
-    public long[] scanLeft(LongBinaryOperator accumulator) {
-        Spliterator.OfLong spliterator = spliterator();
-        int size = intSize(spliterator);
-        LongBuffer buf = new LongBuffer(size >= 0 ? size : INITIAL_SIZE);
-        delegate(spliterator).forEachOrdered(i -> buf.add(buf.size == 0 ? i
-                : accumulator.applyAsLong(buf.data[buf.size - 1], i)));
-        return buf.toArray();
-    }
-
-    /**
-     * Produces an array containing cumulative results of applying the
-     * accumulation function going left to right using given seed value.
-     * 
-     * <p>
-     * This is a terminal operation.
-     * 
-     * <p>
-     * For parallel stream it's not guaranteed that accumulator will always be
-     * executed in the same thread.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right.
-     *
-     * @param seed the starting value
-     * @param accumulator a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for incorporating an additional element into a result
-     * @return the array where the first element is the seed and every successor
-     *         element is the result of applying accumulator function to the
-     *         previous array element and the corresponding stream element. The
-     *         resulting array is one element longer than this stream.
-     * @see #foldLeft(long, LongBinaryOperator)
-     * @since 0.5.1
-     */
-    public long[] scanLeft(long seed, LongBinaryOperator accumulator) {
-        return prepend(seed).scanLeft(accumulator);
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * @see #collect(LongCollector)
-     */
-    @Override
-    public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        if (context.fjp != null)
-            return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
-        return stream().collect(supplier, accumulator, combiner);
-    }
-
-    /**
-     * Performs a mutable reduction operation on the elements of this stream
-     * using an {@link LongCollector} which encapsulates the supplier,
-     * accumulator and merger functions making easier to reuse collection
-     * strategies.
-     *
-     * <p>
-     * Like {@link #reduce(long, LongBinaryOperator)}, {@code collect}
-     * operations can be parallelized without requiring additional
-     * synchronization.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <A> the intermediate accumulation type of the
-     *        {@code LongCollector}
-     * @param <R> type of the result
-     * @param collector the {@code LongCollector} describing the reduction
-     * @return the result of the reduction
-     * @see #collect(Supplier, ObjLongConsumer, BiConsumer)
-     * @since 0.3.0
-     */
-    @SuppressWarnings("unchecked")
-    public <A, R> R collect(LongCollector<A, R> collector) {
-        if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
-            return (R) collect(collector.supplier(), collector.longAccumulator(), collector.merger());
-        return collector.finisher().apply(collect(collector.supplier(), collector.longAccumulator(), collector
-                .merger()));
-    }
-
-    @Override
-    public long sum() {
-        return reduce(0, Long::sum);
-    }
-
-    @Override
-    public OptionalLong min() {
-        return reduce(Long::min);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided
-     * {@code Comparator}.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param comparator a non-interfering, stateless {@link Comparator} to
-     *        compare elements of this stream
-     * @return an {@code OptionalLong} describing the minimum element of this
-     *         stream, or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong min(Comparator<Long> comparator) {
-        return reduce((a, b) -> comparator.compare(a, b) > 0 ? b : a);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public <V extends Comparable<? super V>> OptionalLong minBy(LongFunction<V> keyExtractor) {
-        ObjLongBox<V> result = collect(() -> new ObjLongBox<>(null, 0), (box, i) -> {
-            V val = Objects.requireNonNull(keyExtractor.apply(i));
-            if (box.a == null || box.a.compareTo(val) > 0) {
-                box.a = val;
-                box.b = i;
-            }
-        }, (box1, box2) -> {
-            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) > 0)) {
-                box1.a = box2.a;
-                box1.b = box2.b;
-            }
-        });
-        return result.a == null ? OptionalLong.empty() : OptionalLong.of(result.b);
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong minByInt(LongToIntFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, l) -> {
-            int key = keyExtractor.applyAsInt(l);
-            if (!box.b || box.i > key) {
-                box.b = true;
-                box.i = key;
-                box.l = l;
-            }
-        }, PrimitiveBox.MIN_INT).asLong();
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong minByLong(LongUnaryOperator keyExtractor) {
-        long[] result = collect(() -> new long[3], (acc, l) -> {
-            long key = keyExtractor.applyAsLong(l);
-            if (acc[2] == 0 || acc[1] > key) {
-                acc[0] = l;
-                acc[1] = key;
-                acc[2] = 1;
-            }
-        }, (acc1, acc2) -> {
-            if (acc2[2] == 1 && (acc1[2] == 0 || acc1[1] > acc2[1]))
-                System.arraycopy(acc2, 0, acc1, 0, 3);
-        });
-        return result[2] == 1 ? OptionalLong.of(result[0]) : OptionalLong.empty();
-    }
-
-    /**
-     * Returns the minimum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the lowest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong minByDouble(LongToDoubleFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, l) -> {
-            double key = keyExtractor.applyAsDouble(l);
-            if (!box.b || Double.compare(box.d, key) > 0) {
-                box.b = true;
-                box.d = key;
-                box.l = l;
-            }
-        }, PrimitiveBox.MIN_DOUBLE).asLong();
-    }
-
-    @Override
-    public OptionalLong max() {
-        return reduce(Long::max);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided
-     * {@code Comparator}.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param comparator a non-interfering, stateless {@link Comparator} to
-     *        compare elements of this stream
-     * @return an {@code OptionalLong} describing the maximum element of this
-     *         stream, or an empty {@code OptionalLong} if the stream is empty
-     */
-    public OptionalLong max(Comparator<Long> comparator) {
-        return reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param <V> the type of the {@code Comparable} sort key
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public <V extends Comparable<? super V>> OptionalLong maxBy(LongFunction<V> keyExtractor) {
-        ObjLongBox<V> result = collect(() -> new ObjLongBox<>(null, 0), (box, i) -> {
-            V val = Objects.requireNonNull(keyExtractor.apply(i));
-            if (box.a == null || box.a.compareTo(val) < 0) {
-                box.a = val;
-                box.b = i;
-            }
-        }, (box1, box2) -> {
-            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) < 0)) {
-                box1.a = box2.a;
-                box1.b = box2.b;
-            }
-        });
-        return result.a == null ? OptionalLong.empty() : OptionalLong.of(result.b);
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong maxByInt(LongToIntFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, l) -> {
-            int key = keyExtractor.applyAsInt(l);
-            if (!box.b || box.i < key) {
-                box.b = true;
-                box.i = key;
-                box.l = l;
-            }
-        }, PrimitiveBox.MAX_INT).asLong();
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong maxByLong(LongUnaryOperator keyExtractor) {
-        long[] result = collect(() -> new long[3], (acc, l) -> {
-            long key = keyExtractor.applyAsLong(l);
-            if (acc[2] == 0 || acc[1] < key) {
-                acc[0] = l;
-                acc[1] = key;
-                acc[2] = 1;
-            }
-        }, (acc1, acc2) -> {
-            if (acc2[2] == 1 && (acc1[2] == 0 || acc1[1] < acc2[1]))
-                System.arraycopy(acc2, 0, acc1, 0, 3);
-        });
-        return result[2] == 1 ? OptionalLong.of(result[0]) : OptionalLong.empty();
-
-    }
-
-    /**
-     * Returns the maximum element of this stream according to the provided key
-     * extractor function.
-     *
-     * <p>
-     * This is a terminal operation.
-     *
-     * @param keyExtractor a non-interfering, stateless function
-     * @return an {@code OptionalLong} describing the first element of this
-     *         stream for which the highest value was returned by key extractor,
-     *         or an empty {@code OptionalLong} if the stream is empty
-     * @since 0.1.2
-     */
-    public OptionalLong maxByDouble(LongToDoubleFunction keyExtractor) {
-        return collect(PrimitiveBox::new, (box, l) -> {
-            double key = keyExtractor.applyAsDouble(l);
-            if (!box.b || Double.compare(box.d, key) < 0) {
-                box.b = true;
-                box.d = key;
-                box.l = l;
-            }
-        }, PrimitiveBox.MAX_DOUBLE).asLong();
-    }
-
-    @Override
-    public long count() {
-        if (context.fjp != null)
-            return context.terminate(stream()::count);
-        return stream().count();
-    }
-
-    @Override
-    public OptionalDouble average() {
-        if (context.fjp != null)
-            return context.terminate(stream()::average);
-        return stream().average();
-    }
-
-    @Override
-    public LongSummaryStatistics summaryStatistics() {
-        return collect(LongSummaryStatistics::new, LongSummaryStatistics::accept, LongSummaryStatistics::combine);
-    }
-
-    @Override
-    public boolean anyMatch(LongPredicate predicate) {
-        if (context.fjp != null)
-            return context.terminate(predicate, stream()::anyMatch);
-        return stream().anyMatch(predicate);
-    }
-
-    @Override
-    public boolean allMatch(LongPredicate predicate) {
-        if (context.fjp != null)
-            return context.terminate(predicate, stream()::allMatch);
-        return stream().allMatch(predicate);
-    }
-
-    @Override
-    public boolean noneMatch(LongPredicate predicate) {
-        return !anyMatch(predicate);
-    }
-
-    @Override
-    public OptionalLong findFirst() {
-        if (context.fjp != null)
-            return context.terminate(stream()::findFirst);
-        return stream().findFirst();
-    }
-
-    /**
-     * Returns an {@link OptionalLong} describing the first element of this
-     * stream, which matches given predicate, or an empty {@code OptionalLong}
-     * if there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalLong} describing the first matching element of
-     *         this stream, or an empty {@code OptionalLong} if there's no
-     *         matching element
-     * @see #findFirst()
-     */
-    public OptionalLong findFirst(LongPredicate predicate) {
-        return filter(predicate).findFirst();
-    }
-
-    @Override
-    public OptionalLong findAny() {
-        if (context.fjp != null)
-            return context.terminate(stream()::findAny);
-        return stream().findAny();
-    }
-
-    /**
-     * Returns an {@link OptionalLong} describing some element of the stream,
-     * which matches given predicate, or an empty {@code OptionalLong} if
-     * there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * <p>
-     * The behavior of this operation is explicitly nondeterministic; it is free
-     * to select any element in the stream. This is to allow for maximal
-     * performance in parallel operations; the cost is that multiple invocations
-     * on the same source may not return the same result. (If a stable result is
-     * desired, use {@link #findFirst(LongPredicate)} instead.)
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalLong} describing some matching element of this
-     *         stream, or an empty {@code OptionalLong} if there's no matching
-     *         element
-     * @see #findAny()
-     * @see #findFirst(LongPredicate)
-     */
-    public OptionalLong findAny(LongPredicate predicate) {
-        return filter(predicate).findAny();
-    }
-
-    /**
-     * Returns an {@link OptionalLong} describing the zero-based index of the
-     * first element of this stream, which equals to the given value, or an
-     * empty {@code OptionalLong} if there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * @param value a value to look for
-     * @return an {@code OptionalLong} describing the index of the first
-     *         matching element of this stream, or an empty {@code OptionalLong}
-     *         if there's no matching element.
-     * @see #indexOf(LongPredicate)
-     * @since 0.4.0
-     */
-    public OptionalLong indexOf(long value) {
-        return boxed().indexOf(i -> i == value);
-    }
-
-    /**
-     * Returns an {@link OptionalLong} describing the zero-based index of the
-     * first element of this stream, which matches given predicate, or an empty
-     * {@code OptionalLong} if there's no matching element.
-     *
-     * <p>
-     * This is a short-circuiting terminal operation.
-     *
-     * @param predicate a
-     *        <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        predicate which returned value should match
-     * @return an {@code OptionalLong} describing the index of the first
-     *         matching element of this stream, or an empty {@code OptionalLong}
-     *         if there's no matching element.
-     * @see #findFirst(LongPredicate)
-     * @since 0.4.0
-     */
-    public OptionalLong indexOf(LongPredicate predicate) {
-        return boxed().indexOf(predicate::test);
-    }
-
-    @Override
-    public DoubleStreamEx asDoubleStream() {
-        return new DoubleStreamEx(stream().asDoubleStream(), context);
-    }
-
-    @Override
-    public StreamEx<Long> boxed() {
-        return new StreamEx<>(stream().boxed(), context);
-    }
-
-    @Override
-    public LongStreamEx sequential() {
-        return (LongStreamEx) super.sequential();
-    }
-
-    @Override
-    public LongStreamEx parallel() {
-        return (LongStreamEx) super.parallel();
-    }
-
-    @Override
-    public LongStreamEx parallel(ForkJoinPool fjp) {
-        return (LongStreamEx) super.parallel(fjp);
-    }
-
-    @Override
-    public OfLong iterator() {
-        return Spliterators.iterator(spliterator());
-    }
-
-    /**
-     * Returns a new {@code LongStreamEx} which is a concatenation of this
-     * stream and the stream containing supplied values
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * @param values the values to append to the stream
-     * @return the new stream
-     */
-    public LongStreamEx append(long... values) {
-        if (values.length == 0)
-            return this;
-        return new LongStreamEx(LongStream.concat(stream(), LongStream.of(values)), context);
-    }
-
-    /**
-     * Creates a lazily concatenated stream whose elements are all the elements
-     * of this stream followed by all the elements of the other stream. The
-     * resulting stream is ordered if both of the input streams are ordered, and
-     * parallel if either of the input streams is parallel. When the resulting
-     * stream is closed, the close handlers for both input streams are invoked.
-     *
-     * @param other the other stream
-     * @return this stream appended by the other stream
-     * @see LongStream#concat(LongStream, LongStream)
-     */
-    public LongStreamEx append(LongStream other) {
-        return new LongStreamEx(LongStream.concat(stream(), other), context.combine(other));
-    }
-
-    /**
-     * Returns a new {@code LongStreamEx} which is a concatenation of the stream
-     * containing supplied values and this stream
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * @param values the values to prepend to the stream
-     * @return the new stream
-     */
-    public LongStreamEx prepend(long... values) {
-        if (values.length == 0)
-            return this;
-        return new LongStreamEx(LongStream.concat(LongStream.of(values), stream()), context);
-    }
-
-    /**
-     * Creates a lazily concatenated stream whose elements are all the elements
-     * of the other stream followed by all the elements of this stream. The
-     * resulting stream is ordered if both of the input streams are ordered, and
-     * parallel if either of the input streams is parallel. When the resulting
-     * stream is closed, the close handlers for both input streams are invoked.
-     *
-     * @param other the other stream
-     * @return this stream prepended by the other stream
-     * @see LongStream#concat(LongStream, LongStream)
-     */
-    public LongStreamEx prepend(LongStream other) {
-        return new LongStreamEx(LongStream.concat(other, stream()), context.combine(other));
-    }
-
-    /**
-     * Returns a stream consisting of the results of applying the given function
-     * to the every adjacent pair of elements of this stream.
-     *
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * <p>
-     * The output stream will contain one element less than this stream. If this
-     * stream contains zero or one element the output stream will be empty.
-     *
-     * @param mapper a non-interfering, stateless function to apply to each
-     *        adjacent pair of this stream elements.
-     * @return the new stream
-     * @since 0.2.1
-     */
-    public LongStreamEx pairMap(LongBinaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
-    }
-
-    /**
-     * Returns a {@link String} which is the concatenation of the results of
-     * calling {@link String#valueOf(long)} on each element of this stream,
-     * separated by the specified delimiter, in encounter order.
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * @param delimiter the delimiter to be used between each element
-     * @return the result of concatenation. For empty input stream empty String
-     *         is returned.
-     * @since 0.3.1
-     */
-    public String joining(CharSequence delimiter) {
-        return collect(LongCollector.joining(delimiter));
-    }
-
-    /**
-     * Returns a {@link String} which is the concatenation of the results of
-     * calling {@link String#valueOf(long)} on each element of this stream,
-     * separated by the specified delimiter, with the specified prefix and
-     * suffix in encounter order.
-     *
-     * <p>
-     * This is a terminal operation.
-     * 
-     * @param delimiter the delimiter to be used between each element
-     * @param prefix the sequence of characters to be used at the beginning of
-     *        the joined result
-     * @param suffix the sequence of characters to be used at the end of the
-     *        joined result
-     * @return the result of concatenation. For empty input stream
-     *         {@code prefix + suffix} is returned.
-     * @since 0.3.1
-     */
-    public String joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
-        return collect(LongCollector.joining(delimiter, prefix, suffix));
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream until the
-     * first element which does not match the given predicate is found.
-     * 
-     * <p>
-     * This is a short-circuiting stateful operation. It can be either
-     * <a href="package-summary.html#StreamOps">intermediate or
-     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
-     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
-     * implementation.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.3.6
-     * @see #takeWhileInclusive(LongPredicate)
-     * @see #dropWhile(LongPredicate)
-     */
-    public LongStreamEx takeWhile(LongPredicate predicate) {
-        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), false);
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream until the
-     * first element which does not match the given predicate is found
-     * (including the first mismatching element).
-     * 
-     * <p>
-     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.5.5
-     * @see #takeWhile(LongPredicate)
-     */
-    public LongStreamEx takeWhileInclusive(LongPredicate predicate) {
-        Objects.requireNonNull(predicate);
-        return delegate(new TakeDrop.TDOfLong(spliterator(), false, true, predicate));
-    }
-
-    /**
-     * Returns a stream consisting of all elements from this stream starting
-     * from the first element which does not match the given predicate. If the
-     * predicate is true for all stream elements, an empty stream is returned.
-     * 
-     * <p>
-     * This is a stateful operation. It can be either
-     * <a href="package-summary.html#StreamOps">intermediate or
-     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
-     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
-     * implementation.
-     * 
-     * <p>
-     * While this operation is quite cheap for sequential stream, it can be
-     * quite expensive on parallel pipelines.
-     * 
-     * @param predicate a non-interfering, stateless predicate to apply to
-     *        elements.
-     * @return the new stream.
-     * @since 0.3.6
-     */
-    public LongStreamEx dropWhile(LongPredicate predicate) {
-        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), true);
-    }
-
-    /**
-     * Returns a stream containing cumulative results of applying the
-     * accumulation function going left to right.
-     * 
-     * <p>
-     * This is a stateful
-     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
-     * operation.
-     *
-     * <p>
-     * This operation resembles {@link #scanLeft(LongBinaryOperator)}, but
-     * unlike {@code scanLeft} this operation is intermediate and accumulation
-     * function must be associative.
-     * 
-     * <p>
-     * This method cannot take all the advantages of parallel streams as it must
-     * process elements strictly left to right. Using an unordered source or
-     * removing the ordering constraint with {@link #unordered()} may improve
-     * the parallel processing speed.
-     *
-     * @param op an <a href="package-summary.html#Associativity">associative</a>
-     *        , <a href="package-summary.html#NonInterference">non-interfering
-     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
-     *        function for computing the next element based on the previous one
-     * @return the new stream.
-     * @see #scanLeft(LongBinaryOperator)
-     * @since 0.6.1
-     */
-    public LongStreamEx prefix(LongBinaryOperator op) {
-        return delegate(new PrefixOps.OfLong(spliterator(), op));
-    }
-
-    // Necessary to generate proper JavaDoc
-    // does not add overhead as it appears in bytecode anyways as bridge method
-    @Override
-    public <U> U chain(Function<? super LongStreamEx, U> mapper) {
-        return mapper.apply(this);
-    }
-
-    /**
-     * Returns an empty sequential {@code LongStreamEx}.
-     *
-     * @return an empty sequential stream
-     */
-    public static LongStreamEx empty() {
-        return of(Spliterators.emptyLongSpliterator());
-    }
-
-    /**
-     * Returns a sequential {@code LongStreamEx} containing a single element.
-     *
-     * @param element the single element
-     * @return a singleton sequential stream
-     */
-    public static LongStreamEx of(long element) {
-        return of(new ConstSpliterator.OfLong(element, 1, true));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
-     * specified values.
-     *
-     * @param elements the elements of the new stream
-     * @return the new stream
-     */
-    public static LongStreamEx of(long... elements) {
-        return of(Arrays.spliterator(elements));
-    }
-
-    /**
-     * Returns a sequential {@link LongStreamEx} with the specified range of the
-     * specified array as its source.
-     *
-     * @param array the array, assumed to be unmodified during use
-     * @param startInclusive the first index to cover, inclusive
-     * @param endExclusive index immediately past the last index to cover
-     * @return an {@code LongStreamEx} for the array range
-     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
-     *         negative, {@code endExclusive} is less than
-     *         {@code startInclusive}, or {@code endExclusive} is greater than
-     *         the array size
-     * @since 0.1.1
-     * @see Arrays#stream(long[], int, int)
-     */
-    public static LongStreamEx of(long[] array, int startInclusive, int endExclusive) {
-        return of(Arrays.spliterator(array, startInclusive, endExclusive));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
-     * unboxed elements of supplied array.
-     *
-     * @param array the array to create the stream from.
-     * @return the new stream
-     * @see Arrays#stream(Object[])
-     * @since 0.5.0
-     */
-    public static LongStreamEx of(Long[] array) {
-        return seq(Arrays.stream(array).mapToLong(Long::longValue));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
-     * values in the supplied {@link java.nio.LongBuffer}.
-     * 
-     * <p>
-     * The resulting stream covers only a portion of {@code LongBuffer} content
-     * which starts with {@linkplain Buffer#position() position} (inclusive) and
-     * ends with {@linkplain Buffer#limit() limit} (exclusive). Changes in
-     * position and limit after the stream creation don't affect the stream.
-     * 
-     * <p>
-     * The resulting stream does not change the internal {@code LongBuffer}
-     * state.
-     * 
-     * @param buf the {@code LongBuffer} to create a stream from
-     * @return the new stream
-     * @since 0.6.2
-     */
-    public static LongStreamEx of(java.nio.LongBuffer buf) {
-        return IntStreamEx.range(buf.position(), buf.limit()).mapToLong(buf::get);
-    }
-
-    /**
-     * Returns a {@code LongStreamEx} object which wraps given
-     * {@link LongStream}.
-     * 
-     * <p>
-     * The supplied stream must not be consumed or closed when this method is
-     * called. No operation must be performed on the supplied stream after it's
-     * wrapped.
-     * 
-     * @param stream original stream
-     * @return the wrapped stream
-     * @since 0.0.8
-     */
-    public static LongStreamEx of(LongStream stream) {
-        return stream instanceof LongStreamEx ? (LongStreamEx) stream
-                : new LongStreamEx(stream, StreamContext.of(stream));
-    }
-
-    /**
-     * Returns a sequential {@link LongStreamEx} created from given
-     * {@link java.util.Spliterator.OfLong}.
-     * 
-     * @param spliterator a spliterator to create the stream from.
-     * @return the new stream
-     * @since 0.3.4
-     */
-    public static LongStreamEx of(Spliterator.OfLong spliterator) {
-        return new LongStreamEx(spliterator, StreamContext.SEQUENTIAL);
-    }
-
-    /**
-     * Returns a sequential, ordered {@link LongStreamEx} created from given
-     * {@link java.util.PrimitiveIterator.OfLong}.
-     *
-     * <p>
-     * This method is roughly equivalent to
-     * {@code LongStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
-     * , but may show better performance for parallel processing.
-     * 
-     * <p>
-     * Use this method only if you cannot provide better Stream source.
-     *
-     * @param iterator an iterator to create the stream from.
-     * @return the new stream
-     * @since 0.5.1
-     */
-    public static LongStreamEx of(PrimitiveIterator.OfLong iterator) {
-        return of(new UnknownSizeSpliterator.USOfLong(iterator));
-    }
-
-    /**
-     * Returns a sequential {@code LongStreamEx} containing an
-     * {@link OptionalLong} value, if present, otherwise returns an empty
-     * {@code LongStreamEx}.
-     *
-     * @param optional the optional to create a stream of
-     * @return a stream with an {@code OptionalLong} value if present, otherwise
-     *         an empty stream
-     * @since 0.1.1
-     */
-    public static LongStreamEx of(OptionalLong optional) {
-        return optional.isPresent() ? of(optional.getAsLong()) : empty();
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
-     * unboxed elements of supplied collection.
-     *
-     * @param collection the collection to create the stream from.
-     * @return the new stream
-     * @see Collection#stream()
-     */
-    public static LongStreamEx of(Collection<Long> collection) {
-        return seq(collection.stream().mapToLong(Long::longValue));
-    }
-
-    /**
-     * Returns an effectively unlimited stream of pseudorandom {@code long}
-     * values produced by given {@link Random} object.
-     *
-     * <p>
-     * A pseudorandom {@code long} value is generated as if it's the result of
-     * calling the method {@link Random#nextLong()}.
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @return a stream of pseudorandom {@code long} values
-     * @see Random#longs()
-     */
-    public static LongStreamEx of(Random random) {
-        return seq(random.longs());
-    }
-
-    /**
-     * Returns a stream producing the given {@code streamSize} number of
-     * pseudorandom {@code long} values.
-     *
-     * <p>
-     * A pseudorandom {@code long} value is generated as if it's the result of
-     * calling the method {@link Random#nextLong()}
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param streamSize the number of values to generate
-     * @return a stream of pseudorandom {@code long} values
-     * @see Random#longs(long)
-     */
-    public static LongStreamEx of(Random random, long streamSize) {
-        return seq(random.longs(streamSize));
-    }
-
-    /**
-     * Returns an effectively unlimited stream of pseudorandom {@code long}
-     * values, each conforming to the given origin (inclusive) and bound
-     * (exclusive).
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param randomNumberOrigin the origin (inclusive) of each random value
-     * @param randomNumberBound the bound (exclusive) of each random value
-     * @return a stream of pseudorandom {@code long} values
-     * @see Random#longs(long, long, long)
-     */
-    public static LongStreamEx of(Random random, long randomNumberOrigin, long randomNumberBound) {
-        return seq(random.longs(randomNumberOrigin, randomNumberBound));
-    }
-
-    /**
-     * Returns a stream producing the given {@code streamSize} number of
-     * pseudorandom {@code long} values, each conforming to the given origin
-     * (inclusive) and bound (exclusive).
-     *
-     * @param random a {@link Random} object to produce the stream from
-     * @param streamSize the number of values to generate
-     * @param randomNumberOrigin the origin (inclusive) of each random value
-     * @param randomNumberBound the bound (exclusive) of each random value
-     * @return a stream of pseudorandom {@code long} values
-     * @see Random#longs(long, long, long)
-     */
-    public static LongStreamEx of(Random random, long streamSize, long randomNumberOrigin, long randomNumberBound) {
-        return seq(random.longs(streamSize, randomNumberOrigin, randomNumberBound));
-    }
-
-    /**
-     * Returns an infinite sequential ordered {@code LongStreamEx} produced by
-     * iterative application of a function {@code f} to an initial element
-     * {@code seed}, producing a stream consisting of {@code seed},
-     * {@code f(seed)}, {@code f(f(seed))}, etc.
-     *
-     * <p>
-     * The first element (position {@code 0}) in the {@code LongStreamEx} will
-     * be the provided {@code seed}. For {@code n > 0}, the element at position
-     * {@code n}, will be the result of applying the function {@code f} to the
-     * element at position {@code n - 1}.
-     *
-     * @param seed the initial element
-     * @param f a function to be applied to to the previous element to produce a
-     *        new element
-     * @return A new sequential {@code LongStream}
-     * @see #iterate(long, LongPredicate, LongUnaryOperator)
-     */
-    public static LongStreamEx iterate(final long seed, final LongUnaryOperator f) {
-        return iterate(seed, x -> true, f);
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} produced by iterative
-     * application of a function to an initial element, conditioned on
-     * satisfying the supplied predicate. The stream terminates as soon as the
-     * predicate function returns false.
-     *
-     * <p>
-     * {@code LongStreamEx.iterate} should produce the same sequence of elements
-     * as produced by the corresponding for-loop:
-     * 
-     * <pre>{@code
-     *     for (long index=seed; predicate.test(index); index = f.apply(index)) { 
-     *         ... 
-     *     }
-     * }</pre>
-     *
-     * <p>
-     * The resulting sequence may be empty if the predicate does not hold on the
-     * seed value. Otherwise the first element will be the supplied seed value,
-     * the next element (if present) will be the result of applying the function
-     * f to the seed value, and so on iteratively until the predicate indicates
-     * that the stream should terminate.
-     *
-     * @param seed the initial element
-     * @param predicate a predicate to apply to elements to determine when the
-     *        stream must terminate.
-     * @param f a function to be applied to the previous element to produce a
-     *        new element
-     * @return a new sequential {@code LongStreamEx}
-     * @see #iterate(long, LongUnaryOperator)
-     * @since 0.6.0
-     */
-    public static LongStreamEx iterate(long seed, LongPredicate predicate, LongUnaryOperator f) {
-        Objects.requireNonNull(f);
-        Objects.requireNonNull(predicate);
-        Spliterator.OfLong spliterator = new Spliterators.AbstractLongSpliterator(Long.MAX_VALUE, Spliterator.ORDERED
-            | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
-            long prev;
-            boolean started, finished;
-
-            @Override
-            public boolean tryAdvance(LongConsumer action) {
-                Objects.requireNonNull(action);
-                if (finished)
-                    return false;
-                long t;
-                if (started)
-                    t = f.applyAsLong(prev);
-                else {
-                    t = seed;
-                    started = true;
-                }
-                if (!predicate.test(t)) {
-                    finished = true;
-                    return false;
-                }
-                action.accept(prev = t);
-                return true;
-            }
-
-            @Override
-            public void forEachRemaining(LongConsumer action) {
-                Objects.requireNonNull(action);
-                if (finished)
-                    return;
-                finished = true;
-                long t = started ? f.applyAsLong(prev) : seed;
-                while (predicate.test(t)) {
-                    action.accept(t);
-                    t = f.applyAsLong(t);
-                }
-            }
-        };
-        return of(spliterator);
-    }
-
-    /**
-     * Returns an infinite sequential unordered stream where each element is
-     * generated by the provided {@code LongSupplier}. This is suitable for
-     * generating constant streams, streams of random elements, etc.
-     *
-     * @param s the {@code LongSupplier} for generated elements
-     * @return a new infinite sequential unordered {@code LongStreamEx}
-     * @see LongStream#generate(LongSupplier)
-     */
-    public static LongStreamEx generate(LongSupplier s) {
-        return seq(LongStream.generate(s));
-    }
-
-    /**
-     * Return an ordered stream produced by consecutive calls of the supplied
-     * producer until it returns false.
-     * 
-     * <p>
-     * The producer function may call the passed consumer any number of times
-     * and return true if the producer should be called again or false
-     * otherwise. It's guaranteed that the producer will not be called anymore,
-     * once it returns false.
-     * 
-     * <p>
-     * This method is particularly useful when producer changes the mutable
-     * object which should be left in known state after the full stream
-     * consumption. Note however that if a short-circuiting operation is used,
-     * then the final state of the mutable object cannot be guaranteed.
-     * 
-     * @param producer a predicate which calls the passed consumer to emit
-     *        stream element(s) and returns true if it producer should be
-     *        applied again.
-     * @return the new stream
-     * @since 0.6.0
-     */
-    public static LongStreamEx produce(Predicate<LongConsumer> producer) {
-        Box<LongEmitter> box = new Box<>();
-        return (box.a = action -> producer.test(action) ? box.a : null).stream();
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from 0 (inclusive) to
-     * {@code Long.MAX_VALUE} (exclusive) by an incremental step of {@code 1}.
-     *
-     * @return a sequential {@code LongStreamEx} for the range of {@code long}
-     *         elements
-     * @see #range(long, long)
-     * @since 0.5.5
-     */
-    public static LongStreamEx longs() {
-        return seq(LongStream.range(0, Long.MAX_VALUE));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from 0 (inclusive) to
-     * {@code endExclusive} (exclusive) by an incremental step of {@code 1}.
-     *
-     * @param endExclusive the exclusive upper bound
-     * @return a sequential {@code LongStreamEx} for the range of {@code int}
-     *         elements
-     * @see #range(long, long)
-     * @since 0.1.1
-     */
-    public static LongStreamEx range(long endExclusive) {
-        return seq(LongStream.range(0, endExclusive));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from
-     * {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by
-     * an incremental step of {@code 1}.
-     *
-     * @param startInclusive the (inclusive) initial value
-     * @param endExclusive the exclusive upper bound
-     * @return a sequential {@code LongStreamEx} for the range of {@code long}
-     *         elements
-     * @see LongStream#range(long, long)
-     */
-    public static LongStreamEx range(long startInclusive, long endExclusive) {
-        return seq(LongStream.range(startInclusive, endExclusive));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from
-     * {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by
-     * the specified incremental step. The negative step values are also
-     * supported. In this case, the {@code startInclusive} should be greater than
-     * {@code endExclusive}.
-     *
-     * @param startInclusive the (inclusive) initial value
-     * @param endExclusive the exclusive upper (for positive step) or lower (for negative step) bound
-     * @param step the non-zero value which designates the difference between
-     *        the consecutive values of the resulting stream.
-     * @return a sequential {@code LongStreamEx} for the range of {@code long}
-     *         elements
-     * @throws IllegalArgumentException if step is zero
-     * @see LongStreamEx#range(long, long)
-     * @since 0.4.0
-     */
-    public static LongStreamEx range(long startInclusive, long endExclusive, long step) {
-        long endInclusive = endExclusive - Long.signum(step);
-        if (endInclusive > endExclusive && step > 0 || endInclusive < endExclusive && step < 0)
-            return empty();
-        return rangeClosed(startInclusive, endInclusive, step);
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from
-     * {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by
-     * an incremental step of {@code 1}.
-     *
-     * @param startInclusive the (inclusive) initial value
-     * @param endInclusive the inclusive upper bound
-     * @return a sequential {@code LongStreamEx} for the range of {@code long}
-     *         elements
-     * @see LongStream#rangeClosed(long, long)
-     */
-    public static LongStreamEx rangeClosed(long startInclusive, long endInclusive) {
-        return seq(LongStream.rangeClosed(startInclusive, endInclusive));
-    }
-
-    /**
-     * Returns a sequential ordered {@code LongStreamEx} from
-     * {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by
-     * the specified incremental step. The negative step values are also
-     * supported. In this case, the {@code startInclusive} should be not less than
-     * {@code endInclusive}.
-     * 
-     * <p>
-     * Note that depending on the step value the {@code endInclusive} bound may
-     * still not be reached. For example
-     * {@code LongStreamEx.rangeClosed(0, 5, 2)} will yield the stream of three
-     * numbers: 0L, 2L and 4L.
-     *
-     * @param startInclusive the (inclusive) initial value
-     * @param endInclusive the inclusive upper (for positive step) or lower (for negative step) bound
-     * @param step the non-zero value which designates the difference between
-     *        the consecutive values of the resulting stream.
-     * @return a sequential {@code LongStreamEx} for the range of {@code long}
-     *         elements; an empty stream if startInclusive is greater than endInclusive
-     *         for positive step, or if startInclusive is less than endInclusive
-     *         for negative step.
-     * @throws IllegalArgumentException if step is zero
-     * @see LongStreamEx#rangeClosed(long, long)
-     * @since 0.4.0
-     */
-    public static LongStreamEx rangeClosed(long startInclusive, long endInclusive, long step) {
-        if (step == 0)
-            throw new IllegalArgumentException("step = 0");
-        if (endInclusive == startInclusive)
-            return LongStreamEx.of(startInclusive);
-        if (step == 1)
-            return seq(LongStream.rangeClosed(startInclusive, endInclusive));
-        if (step == -1) {
-            // Handled specially as number of elements can exceed
-            // Long.MAX_VALUE
-            long sum = endInclusive + startInclusive;
-            return seq(LongStream.rangeClosed(endInclusive, startInclusive).map(x -> sum - x));
-        }
-        if ((endInclusive > startInclusive) != (step > 0))
-            return empty();
-        long limit = (endInclusive - startInclusive) * Long.signum(step);
-        limit = Long.divideUnsigned(limit, Math.abs(step));
-        return seq(LongStream.rangeClosed(0, limit).map(x -> x * step + startInclusive));
-    }
-
-    /**
-     * Returns a sequential unordered {@code LongStreamEx} of given length which
-     * elements are equal to supplied value.
-     * 
-     * @param value the constant value
-     * @param length the length of the stream
-     * @return a new {@code LongStreamEx}
-     * @since 0.1.2
-     */
-    public static LongStreamEx constant(long value, long length) {
-        return of(new ConstSpliterator.OfLong(value, length, false));
-    }
-
-    /**
-     * Returns a sequential {@code LongStreamEx} containing the results of
-     * applying the given function to the corresponding pairs of values in given
-     * two arrays.
-     * 
-     * @param first the first array
-     * @param second the second array
-     * @param mapper a non-interfering, stateless function to apply to each pair
-     *        of the corresponding array elements.
-     * @return a new {@code LongStreamEx}
-     * @throws IllegalArgumentException if length of the arrays differs.
-     * @since 0.2.1
-     */
-    public static LongStreamEx zip(long[] first, long[] second, LongBinaryOperator mapper) {
-        return of(new RangeBasedSpliterator.ZipLong(0, checkLength(first.length, second.length), mapper, first,
-                second));
-    }
-
-    /**
-     * A helper interface to build a new stream by emitting elements and
-     * creating new emitters in a chain.
-     * 
-     * <p>
-     * Using this interface it's possible to create custom sources which cannot
-     * be easily expressed using
-     * {@link LongStreamEx#iterate(long, LongUnaryOperator)} or
-     * {@link LongStreamEx#generate(LongSupplier)}. For example, the following
-     * method generates a Collatz sequence starting from given number:
-     * 
-     * <pre>{@code
-     * public static LongEmitter collatz(long start) {
-     *    return action -> {
-     *       action.accept(start);
-     *       return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
-     *    };
-     * }}</pre>
-     * 
-     * <p>
-     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz
-     * numbers.
-     * 
-     * @author Tagir Valeev
-     *
-     * @since 0.6.0
-     */
-    @FunctionalInterface
-    public interface LongEmitter {
-        /**
-         * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if
-         * nothing more to emit.
-         * 
-         * <p>
-         * Normally one element is emitted during the {@code next()} method
-         * call. However, it's not restricted: you may emit as many elements as
-         * you want, though in some cases if many elements were emitted they
-         * might be buffered consuming additional memory.
-         * 
-         * <p>
-         * It's allowed not to emit anything (don't call the consumer). However
-         * if you do this and return new emitter which also does not emit
-         * anything, you will end up in endless loop.
-         * 
-         * @param action consumer to be called to emit elements
-         * @return next emitter or null
-         */
-        LongEmitter next(LongConsumer action);
-
-        /**
-         * Returns the spliterator which covers all the elements emitted by this
-         * emitter.
-         * 
-         * @return the new spliterator
-         */
-        default Spliterator.OfLong spliterator() {
-            return new EmitterSpliterator.OfLong(this);
-        }
-
-        /**
-         * Returns the stream which covers all the elements emitted by this
-         * emitter.
-         * 
-         * @return the new stream
-         */
-        default LongStreamEx stream() {
-            return of(spliterator());
-        }
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.nio.Buffer;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.LongSummaryStatistics;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.OptionalDouble;
+import java.util.OptionalLong;
+import java.util.PrimitiveIterator;
+import java.util.PrimitiveIterator.OfLong;
+import java.util.Random;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.ForkJoinPool;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.function.LongBinaryOperator;
+import java.util.function.LongConsumer;
+import java.util.function.LongFunction;
+import java.util.function.LongPredicate;
+import java.util.function.LongSupplier;
+import java.util.function.LongToDoubleFunction;
+import java.util.function.LongToIntFunction;
+import java.util.function.LongUnaryOperator;
+import java.util.function.ObjLongConsumer;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.stream.Collector;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+import static one.util.streamex.Internals.Box;
+import static one.util.streamex.Internals.INITIAL_SIZE;
+import static one.util.streamex.Internals.LongBuffer;
+import static one.util.streamex.Internals.ObjLongBox;
+import static one.util.streamex.Internals.PrimitiveBox;
+import static one.util.streamex.Internals.checkLength;
+import static one.util.streamex.Internals.intSize;
+
+/**
+ * A {@link LongStream} implementation with additional functionality
+ * 
+ * @author Tagir Valeev
+ */
+public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong, LongStreamEx> implements
+        LongStream {
+    LongStreamEx(LongStream stream, StreamContext context) {
+        super(stream, context);
+    }
+
+    LongStreamEx(Spliterator.OfLong spliterator, StreamContext context) {
+        super(spliterator, context);
+    }
+
+    @Override
+    LongStream createStream() {
+        return StreamSupport.longStream(spliterator, isParallel());
+    }
+
+    private static LongStreamEx seq(LongStream stream) {
+        return new LongStreamEx(stream, StreamContext.SEQUENTIAL);
+    }
+
+    final LongStreamEx delegate(Spliterator.OfLong spliterator) {
+        return new LongStreamEx(spliterator, context);
+    }
+
+    @Override
+    public LongStreamEx unordered() {
+        return (LongStreamEx) super.unordered();
+    }
+
+    @Override
+    public LongStreamEx onClose(Runnable closeHandler) {
+        return (LongStreamEx) super.onClose(closeHandler);
+    }
+
+    @Override
+    public LongStreamEx filter(LongPredicate predicate) {
+        return new LongStreamEx(stream().filter(predicate), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that don't
+     * match the given predicate.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param predicate a non-interfering, stateless predicate to apply to each
+     *        element to determine if it should be excluded
+     * @return the new stream
+     */
+    public LongStreamEx remove(LongPredicate predicate) {
+        return filter(predicate.negate());
+    }
+
+    /**
+     * Returns true if this stream contains the specified value
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     * 
+     * @param value the value too look for in the stream
+     * @return true if this stream contains the specified value
+     * @see LongStream#anyMatch(LongPredicate)
+     */
+    public boolean has(long value) {
+        return anyMatch(x -> x == value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that don't
+     * equal to the given value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value the value to remove from the stream.
+     * @return the new stream
+     * @since 0.2.2
+     * @see #without(long...)
+     * @see #remove(LongPredicate)
+     */
+    public LongStreamEx without(long value) {
+        return filter(val -> val != value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that don't
+     * equal to any of the supplied values.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate</a>
+     * operation. May return itself if no values were supplied.
+     * 
+     * <p>
+     * Current implementation scans the supplied values linearly for every
+     * stream element.
+     * 
+     * <p>
+     * If the {@code values} array is changed between calling this method and
+     * finishing the stream traversal, then the result of the stream traversal
+     * is undefined: changes may or may not be taken into account.
+     *
+     * @param values the values to remove from the stream.
+     * @return the new stream
+     * @since 0.5.5
+     * @see #without(long)
+     * @see #remove(LongPredicate)
+     */
+    public LongStreamEx without(long... values) {
+        if (values.length == 0)
+            return this;
+        if (values.length == 1)
+            return without(values[0]);
+        return filter(x -> {
+            for (long val : values) {
+                if (x == val)
+                    return false;
+            }
+            return true;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that strictly
+     * greater than the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public LongStreamEx greater(long value) {
+        return filter(val -> val > value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that greater
+     * than or equal to the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public LongStreamEx atLeast(long value) {
+        return filter(val -> val >= value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that strictly
+     * less than the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public LongStreamEx less(long value) {
+        return filter(val -> val < value);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream that less than
+     * or equal to the specified value.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param value a value to compare to
+     * @return the new stream
+     * @since 0.2.3
+     */
+    public LongStreamEx atMost(long value) {
+        return filter(val -> val <= value);
+    }
+
+    @Override
+    public LongStreamEx map(LongUnaryOperator mapper) {
+        return new LongStreamEx(stream().map(mapper), context);
+    }
+
+    /**
+     * Returns a stream where the first element is the replaced with the result
+     * of applying the given function while the other elements are left intact.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * @param mapper a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the first element
+     * @return the new stream
+     * @since 0.4.1
+     */
+    public LongStreamEx mapFirst(LongUnaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfLong((a, b) -> b, mapper, spliterator(),
+                PairSpliterator.MODE_MAP_FIRST));
+    }
+
+    /**
+     * Returns a stream where the last element is the replaced with the result
+     * of applying the given function while the other elements are left intact.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The mapper function is called at most once. It could be not called at all
+     * if the stream is empty or there is short-circuiting operation downstream.
+     *
+     * @param mapper a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the last element
+     * @return the new stream
+     * @since 0.4.1
+     */
+    public LongStreamEx mapLast(LongUnaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfLong((a, b) -> a, mapper, spliterator(),
+                PairSpliterator.MODE_MAP_LAST));
+    }
+
+    @Override
+    public <U> StreamEx<U> mapToObj(LongFunction<? extends U> mapper) {
+        return new StreamEx<>(stream().mapToObj(mapper), context);
+    }
+
+    @Override
+    public IntStreamEx mapToInt(LongToIntFunction mapper) {
+        return new IntStreamEx(stream().mapToInt(mapper), context);
+    }
+
+    @Override
+    public DoubleStreamEx mapToDouble(LongToDoubleFunction mapper) {
+        return new DoubleStreamEx(stream().mapToDouble(mapper), context);
+    }
+
+    /**
+     * Returns an {@link EntryStream} consisting of the {@link Entry} objects
+     * which keys and values are results of applying the given functions to the
+     * elements of this stream.
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param <K> The {@code Entry} key type
+     * @param <V> The {@code Entry} value type
+     * @param keyMapper a non-interfering, stateless function to apply to each
+     *        element
+     * @param valueMapper a non-interfering, stateless function to apply to each
+     *        element
+     * @return the new stream
+     * @since 0.3.1
+     */
+    public <K, V> EntryStream<K, V> mapToEntry(LongFunction<? extends K> keyMapper,
+            LongFunction<? extends V> valueMapper) {
+        return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
+                valueMapper.apply(t))), context);
+    }
+
+    @Override
+    public LongStreamEx flatMap(LongFunction<? extends LongStream> mapper) {
+        return new LongStreamEx(stream().flatMap(mapper), context);
+    }
+
+    /**
+     * Returns an {@link IntStreamEx} consisting of the results of replacing
+     * each element of this stream with the contents of a mapped stream produced
+     * by applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces an {@code IntStream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public IntStreamEx flatMapToInt(LongFunction<? extends IntStream> mapper) {
+        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
+    }
+
+    /**
+     * Returns a {@link DoubleStreamEx} consisting of the results of replacing
+     * each element of this stream with the contents of a mapped stream produced
+     * by applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces an {@code DoubleStream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public DoubleStreamEx flatMapToDouble(LongFunction<? extends DoubleStream> mapper) {
+        return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), context);
+    }
+
+    /**
+     * Returns a {@link StreamEx} consisting of the results of replacing each
+     * element of this stream with the contents of a mapped stream produced by
+     * applying the provided mapping function to each element. Each mapped
+     * stream is closed after its contents have been placed into this stream.
+     * (If a mapped stream is {@code null} an empty stream is used, instead.)
+     *
+     * <p>
+     * This is an intermediate operation.
+     *
+     * @param <R> The element type of the new stream
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        element which produces a {@code Stream} of new values
+     * @return the new stream
+     * @since 0.3.0
+     */
+    public <R> StreamEx<R> flatMapToObj(LongFunction<? extends Stream<R>> mapper) {
+        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
+    }
+
+    /**
+     * Returns a new stream containing all the elements of the original stream interspersed with
+     * given delimiter.
+     * 
+     * <p>
+     * For example, {@code LongStreamEx.of(1, 2, 3).intersperse(4)} will yield a stream containing
+     * five elements: 1, 4, 2, 4, 3.
+     * 
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate operation</a>.
+     * 
+     * @param delimiter a delimiter to be inserted between each pair of elements
+     * @return the new stream
+     * @since 0.6.6
+     */
+    public LongStreamEx intersperse(int delimiter) {
+        return new LongStreamEx(stream().flatMap(s -> LongStreamEx.of(delimiter, s)).skip(1), context);
+    }
+
+    @Override
+    public LongStreamEx distinct() {
+        return new LongStreamEx(stream().distinct(), context);
+    }
+
+    @Override
+    public LongStreamEx sorted() {
+        return new LongStreamEx(stream().sorted(), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream sorted
+     * according to the given comparator. Stream elements are boxed before
+     * passing to the comparator.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param comparator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        {@code Comparator} to be used to compare stream elements
+     * @return the new stream
+     */
+    public LongStreamEx sorted(Comparator<Long> comparator) {
+        return new LongStreamEx(stream().boxed().sorted(comparator).mapToLong(Long::longValue), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream in reverse
+     * sorted order.
+     *
+     * <p>
+     * This is a stateful intermediate operation.
+     *
+     * @return the new stream
+     * @since 0.0.8
+     */
+    public LongStreamEx reverseSorted() {
+        LongUnaryOperator inv = x -> ~x;
+        return new LongStreamEx(stream().map(inv).sorted().map(inv), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the natural order of the keys extracted by provided
+     * function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public <V extends Comparable<? super V>> LongStreamEx sortedBy(LongFunction<V> keyExtractor) {
+        return sorted(Comparator.comparing(keyExtractor::apply));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the int values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public LongStreamEx sortedByInt(LongToIntFunction keyExtractor) {
+        return sorted(Comparator.comparingInt(keyExtractor::applyAsInt));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the long values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public LongStreamEx sortedByLong(LongUnaryOperator keyExtractor) {
+        return sorted(Comparator.comparingLong(keyExtractor::applyAsLong));
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, sorted
+     * according to the double values extracted by provided function.
+     *
+     * <p>
+     * For ordered streams, the sort is stable. For unordered streams, no
+     * stability guarantees are made.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">stateful intermediate
+     * operation</a>.
+     *
+     * @param keyExtractor a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to be used to extract sorting keys
+     * @return the new stream
+     */
+    public LongStreamEx sortedByDouble(LongToDoubleFunction keyExtractor) {
+        return sorted(Comparator.comparingDouble(keyExtractor::applyAsDouble));
+    }
+
+    @Override
+    public LongStreamEx peek(LongConsumer action) {
+        return new LongStreamEx(stream().peek(action), context);
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the first stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     *
+     * <p>
+     * Note that the action might not be called at all if the first element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream which stopped the stream before the first element).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a
+     *        <a href="package-summary.html#NonInterference"> non-interfering
+     *        </a> action to perform on the first stream element as it is
+     *        consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public LongStreamEx peekFirst(LongConsumer action) {
+        return mapFirst(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    /**
+     * Returns a stream consisting of the elements of this stream, additionally
+     * performing the provided action on the last stream element when it's
+     * consumed from the resulting stream.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The action is called at most once. For parallel stream pipelines, it's
+     * not guaranteed in which thread it will be executed, so if it modifies
+     * shared state, it is responsible for providing the required
+     * synchronization.
+     * 
+     * <p>
+     * Note that the action might not be called at all if the last element is
+     * not consumed from the input (for example, if there's short-circuiting
+     * operation downstream).
+     * 
+     * <p>
+     * This method exists mainly to support debugging.
+     *
+     * @param action a
+     *        <a href="package-summary.html#NonInterference"> non-interfering
+     *        </a> action to perform on the first stream element as it is
+     *        consumed from the stream
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public LongStreamEx peekLast(LongConsumer action) {
+        return mapLast(x -> {
+            action.accept(x);
+            return x;
+        });
+    }
+
+    @Override
+    public LongStreamEx limit(long maxSize) {
+        return new LongStreamEx(stream().limit(maxSize), context);
+    }
+
+    @Override
+    public LongStreamEx skip(long n) {
+        return new LongStreamEx(stream().skip(n), context);
+    }
+
+    @Override
+    public void forEach(LongConsumer action) {
+        if (spliterator != null && !isParallel()) {
+            spliterator().forEachRemaining(action);
+        } else {
+            if (context.fjp != null)
+                context.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
+    }
+
+    @Override
+    public void forEachOrdered(LongConsumer action) {
+        if (spliterator != null && !isParallel()) {
+            spliterator().forEachRemaining(action);
+        } else {
+            if (context.fjp != null)
+                context.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
+    }
+
+    @Override
+    public long[] toArray() {
+        if (context.fjp != null)
+            return context.terminate(stream()::toArray);
+        return stream().toArray();
+    }
+
+    @Override
+    public long reduce(long identity, LongBinaryOperator op) {
+        if (context.fjp != null)
+            return context.terminate(() -> stream().reduce(identity, op));
+        return stream().reduce(identity, op);
+    }
+
+    @Override
+    public OptionalLong reduce(LongBinaryOperator op) {
+        if (context.fjp != null)
+            return context.terminate(op, stream()::reduce);
+        return stream().reduce(op);
+    }
+
+    /**
+     * Folds the elements of this stream using the provided accumulation
+     * function, going left to right. This is equivalent to:
+     * 
+     * <pre>
+     * {@code
+     *     boolean foundAny = false;
+     *     long result = 0;
+     *     for (long element : this stream) {
+     *         if (!foundAny) {
+     *             foundAny = true;
+     *             result = element;
+     *         }
+     *         else
+     *             result = accumulator.apply(result, element);
+     *     }
+     *     return foundAny ? OptionalLong.of(result) : OptionalLong.empty();
+     * }
+     * </pre>
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. If your accumulator function is
+     * associative, consider using {@link #reduce(LongBinaryOperator)} method.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     *
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the result of the folding
+     * @see #foldLeft(long, LongBinaryOperator)
+     * @see #reduce(LongBinaryOperator)
+     * @since 0.4.0
+     */
+    public OptionalLong foldLeft(LongBinaryOperator accumulator) {
+        PrimitiveBox b = new PrimitiveBox();
+        forEachOrdered(t -> {
+            if (b.b)
+                b.l = accumulator.applyAsLong(b.l, t);
+            else {
+                b.l = t;
+                b.b = true;
+            }
+        });
+        return b.asLong();
+    }
+
+    /**
+     * Folds the elements of this stream using the provided seed object and
+     * accumulation function, going left to right. This is equivalent to:
+     * 
+     * <pre>
+     * {@code
+     *     long result = seed;
+     *     for (long element : this stream)
+     *         result = accumulator.apply(result, element)
+     *     return result;
+     * }
+     * </pre>
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. If your accumulator function is
+     * associative, consider using {@link #reduce(long, LongBinaryOperator)}
+     * method.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     *
+     * @param seed the starting value
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the result of the folding
+     * @see #reduce(long, LongBinaryOperator)
+     * @see #foldLeft(LongBinaryOperator)
+     * @since 0.4.0
+     */
+    public long foldLeft(long seed, LongBinaryOperator accumulator) {
+        long[] box = new long[] { seed };
+        forEachOrdered(t -> box[0] = accumulator.applyAsLong(box[0], t));
+        return box[0];
+    }
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the array where the first element is the first element of this
+     *         stream and every successor element is the result of applying
+     *         accumulator function to the previous array element and the
+     *         corresponding stream element. The resulting array has the same
+     *         length as this stream.
+     * @see #foldLeft(LongBinaryOperator)
+     * @since 0.5.1
+     */
+    public long[] scanLeft(LongBinaryOperator accumulator) {
+        Spliterator.OfLong spliterator = spliterator();
+        int size = intSize(spliterator);
+        LongBuffer buf = new LongBuffer(size >= 0 ? size : INITIAL_SIZE);
+        delegate(spliterator).forEachOrdered(i -> buf.add(buf.size == 0 ? i
+                : accumulator.applyAsLong(buf.data[buf.size - 1], i)));
+        return buf.toArray();
+    }
+
+    /**
+     * Produces an array containing cumulative results of applying the
+     * accumulation function going left to right using given seed value.
+     * 
+     * <p>
+     * This is a terminal operation.
+     * 
+     * <p>
+     * For parallel stream it's not guaranteed that accumulator will always be
+     * executed in the same thread.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right.
+     *
+     * @param seed the starting value
+     * @param accumulator a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for incorporating an additional element into a result
+     * @return the array where the first element is the seed and every successor
+     *         element is the result of applying accumulator function to the
+     *         previous array element and the corresponding stream element. The
+     *         resulting array is one element longer than this stream.
+     * @see #foldLeft(long, LongBinaryOperator)
+     * @since 0.5.1
+     */
+    public long[] scanLeft(long seed, LongBinaryOperator accumulator) {
+        return prepend(seed).scanLeft(accumulator);
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @see #collect(LongCollector)
+     */
+    @Override
+    public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
+        if (context.fjp != null)
+            return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
+        return stream().collect(supplier, accumulator, combiner);
+    }
+
+    /**
+     * Performs a mutable reduction operation on the elements of this stream
+     * using an {@link LongCollector} which encapsulates the supplier,
+     * accumulator and merger functions making easier to reuse collection
+     * strategies.
+     *
+     * <p>
+     * Like {@link #reduce(long, LongBinaryOperator)}, {@code collect}
+     * operations can be parallelized without requiring additional
+     * synchronization.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <A> the intermediate accumulation type of the
+     *        {@code LongCollector}
+     * @param <R> type of the result
+     * @param collector the {@code LongCollector} describing the reduction
+     * @return the result of the reduction
+     * @see #collect(Supplier, ObjLongConsumer, BiConsumer)
+     * @since 0.3.0
+     */
+    @SuppressWarnings("unchecked")
+    public <A, R> R collect(LongCollector<A, R> collector) {
+        if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
+            return (R) collect(collector.supplier(), collector.longAccumulator(), collector.merger());
+        return collector.finisher().apply(collect(collector.supplier(), collector.longAccumulator(), collector
+                .merger()));
+    }
+
+    @Override
+    public long sum() {
+        return reduce(0, Long::sum);
+    }
+
+    @Override
+    public OptionalLong min() {
+        return reduce(Long::min);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided
+     * {@code Comparator}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param comparator a non-interfering, stateless {@link Comparator} to
+     *        compare elements of this stream
+     * @return an {@code OptionalLong} describing the minimum element of this
+     *         stream, or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong min(Comparator<Long> comparator) {
+        return reduce((a, b) -> comparator.compare(a, b) > 0 ? b : a);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public <V extends Comparable<? super V>> OptionalLong minBy(LongFunction<V> keyExtractor) {
+        ObjLongBox<V> result = collect(() -> new ObjLongBox<>(null, 0), (box, i) -> {
+            V val = Objects.requireNonNull(keyExtractor.apply(i));
+            if (box.a == null || box.a.compareTo(val) > 0) {
+                box.a = val;
+                box.b = i;
+            }
+        }, (box1, box2) -> {
+            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) > 0)) {
+                box1.a = box2.a;
+                box1.b = box2.b;
+            }
+        });
+        return result.a == null ? OptionalLong.empty() : OptionalLong.of(result.b);
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong minByInt(LongToIntFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, l) -> {
+            int key = keyExtractor.applyAsInt(l);
+            if (!box.b || box.i > key) {
+                box.b = true;
+                box.i = key;
+                box.l = l;
+            }
+        }, PrimitiveBox.MIN_INT).asLong();
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong minByLong(LongUnaryOperator keyExtractor) {
+        long[] result = collect(() -> new long[3], (acc, l) -> {
+            long key = keyExtractor.applyAsLong(l);
+            if (acc[2] == 0 || acc[1] > key) {
+                acc[0] = l;
+                acc[1] = key;
+                acc[2] = 1;
+            }
+        }, (acc1, acc2) -> {
+            if (acc2[2] == 1 && (acc1[2] == 0 || acc1[1] > acc2[1]))
+                System.arraycopy(acc2, 0, acc1, 0, 3);
+        });
+        return result[2] == 1 ? OptionalLong.of(result[0]) : OptionalLong.empty();
+    }
+
+    /**
+     * Returns the minimum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the lowest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong minByDouble(LongToDoubleFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, l) -> {
+            double key = keyExtractor.applyAsDouble(l);
+            if (!box.b || Double.compare(box.d, key) > 0) {
+                box.b = true;
+                box.d = key;
+                box.l = l;
+            }
+        }, PrimitiveBox.MIN_DOUBLE).asLong();
+    }
+
+    @Override
+    public OptionalLong max() {
+        return reduce(Long::max);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided
+     * {@code Comparator}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param comparator a non-interfering, stateless {@link Comparator} to
+     *        compare elements of this stream
+     * @return an {@code OptionalLong} describing the maximum element of this
+     *         stream, or an empty {@code OptionalLong} if the stream is empty
+     */
+    public OptionalLong max(Comparator<Long> comparator) {
+        return reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param <V> the type of the {@code Comparable} sort key
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public <V extends Comparable<? super V>> OptionalLong maxBy(LongFunction<V> keyExtractor) {
+        ObjLongBox<V> result = collect(() -> new ObjLongBox<>(null, 0), (box, i) -> {
+            V val = Objects.requireNonNull(keyExtractor.apply(i));
+            if (box.a == null || box.a.compareTo(val) < 0) {
+                box.a = val;
+                box.b = i;
+            }
+        }, (box1, box2) -> {
+            if (box2.a != null && (box1.a == null || box1.a.compareTo(box2.a) < 0)) {
+                box1.a = box2.a;
+                box1.b = box2.b;
+            }
+        });
+        return result.a == null ? OptionalLong.empty() : OptionalLong.of(result.b);
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong maxByInt(LongToIntFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, l) -> {
+            int key = keyExtractor.applyAsInt(l);
+            if (!box.b || box.i < key) {
+                box.b = true;
+                box.i = key;
+                box.l = l;
+            }
+        }, PrimitiveBox.MAX_INT).asLong();
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong maxByLong(LongUnaryOperator keyExtractor) {
+        long[] result = collect(() -> new long[3], (acc, l) -> {
+            long key = keyExtractor.applyAsLong(l);
+            if (acc[2] == 0 || acc[1] < key) {
+                acc[0] = l;
+                acc[1] = key;
+                acc[2] = 1;
+            }
+        }, (acc1, acc2) -> {
+            if (acc2[2] == 1 && (acc1[2] == 0 || acc1[1] < acc2[1]))
+                System.arraycopy(acc2, 0, acc1, 0, 3);
+        });
+        return result[2] == 1 ? OptionalLong.of(result[0]) : OptionalLong.empty();
+
+    }
+
+    /**
+     * Returns the maximum element of this stream according to the provided key
+     * extractor function.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @param keyExtractor a non-interfering, stateless function
+     * @return an {@code OptionalLong} describing the first element of this
+     *         stream for which the highest value was returned by key extractor,
+     *         or an empty {@code OptionalLong} if the stream is empty
+     * @since 0.1.2
+     */
+    public OptionalLong maxByDouble(LongToDoubleFunction keyExtractor) {
+        return collect(PrimitiveBox::new, (box, l) -> {
+            double key = keyExtractor.applyAsDouble(l);
+            if (!box.b || Double.compare(box.d, key) < 0) {
+                box.b = true;
+                box.d = key;
+                box.l = l;
+            }
+        }, PrimitiveBox.MAX_DOUBLE).asLong();
+    }
+
+    @Override
+    public long count() {
+        if (context.fjp != null)
+            return context.terminate(stream()::count);
+        return stream().count();
+    }
+
+    @Override
+    public OptionalDouble average() {
+        if (context.fjp != null)
+            return context.terminate(stream()::average);
+        return stream().average();
+    }
+
+    @Override
+    public LongSummaryStatistics summaryStatistics() {
+        return collect(LongSummaryStatistics::new, LongSummaryStatistics::accept, LongSummaryStatistics::combine);
+    }
+
+    @Override
+    public boolean anyMatch(LongPredicate predicate) {
+        if (context.fjp != null)
+            return context.terminate(predicate, stream()::anyMatch);
+        return stream().anyMatch(predicate);
+    }
+
+    @Override
+    public boolean allMatch(LongPredicate predicate) {
+        if (context.fjp != null)
+            return context.terminate(predicate, stream()::allMatch);
+        return stream().allMatch(predicate);
+    }
+
+    @Override
+    public boolean noneMatch(LongPredicate predicate) {
+        return !anyMatch(predicate);
+    }
+
+    @Override
+    public OptionalLong findFirst() {
+        if (context.fjp != null)
+            return context.terminate(stream()::findFirst);
+        return stream().findFirst();
+    }
+
+    /**
+     * Returns an {@link OptionalLong} describing the first element of this
+     * stream, which matches given predicate, or an empty {@code OptionalLong}
+     * if there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalLong} describing the first matching element of
+     *         this stream, or an empty {@code OptionalLong} if there's no
+     *         matching element
+     * @see #findFirst()
+     */
+    public OptionalLong findFirst(LongPredicate predicate) {
+        return filter(predicate).findFirst();
+    }
+
+    @Override
+    public OptionalLong findAny() {
+        if (context.fjp != null)
+            return context.terminate(stream()::findAny);
+        return stream().findAny();
+    }
+
+    /**
+     * Returns an {@link OptionalLong} describing some element of the stream,
+     * which matches given predicate, or an empty {@code OptionalLong} if
+     * there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * <p>
+     * The behavior of this operation is explicitly nondeterministic; it is free
+     * to select any element in the stream. This is to allow for maximal
+     * performance in parallel operations; the cost is that multiple invocations
+     * on the same source may not return the same result. (If a stable result is
+     * desired, use {@link #findFirst(LongPredicate)} instead.)
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalLong} describing some matching element of this
+     *         stream, or an empty {@code OptionalLong} if there's no matching
+     *         element
+     * @see #findAny()
+     * @see #findFirst(LongPredicate)
+     */
+    public OptionalLong findAny(LongPredicate predicate) {
+        return filter(predicate).findAny();
+    }
+
+    /**
+     * Returns an {@link OptionalLong} describing the zero-based index of the
+     * first element of this stream, which equals to the given value, or an
+     * empty {@code OptionalLong} if there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * @param value a value to look for
+     * @return an {@code OptionalLong} describing the index of the first
+     *         matching element of this stream, or an empty {@code OptionalLong}
+     *         if there's no matching element.
+     * @see #indexOf(LongPredicate)
+     * @since 0.4.0
+     */
+    public OptionalLong indexOf(long value) {
+        return boxed().indexOf(i -> i == value);
+    }
+
+    /**
+     * Returns an {@link OptionalLong} describing the zero-based index of the
+     * first element of this stream, which matches given predicate, or an empty
+     * {@code OptionalLong} if there's no matching element.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation.
+     *
+     * @param predicate a
+     *        <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        predicate which returned value should match
+     * @return an {@code OptionalLong} describing the index of the first
+     *         matching element of this stream, or an empty {@code OptionalLong}
+     *         if there's no matching element.
+     * @see #findFirst(LongPredicate)
+     * @since 0.4.0
+     */
+    public OptionalLong indexOf(LongPredicate predicate) {
+        return boxed().indexOf(predicate::test);
+    }
+
+    @Override
+    public DoubleStreamEx asDoubleStream() {
+        return new DoubleStreamEx(stream().asDoubleStream(), context);
+    }
+
+    @Override
+    public StreamEx<Long> boxed() {
+        return new StreamEx<>(stream().boxed(), context);
+    }
+
+    @Override
+    public LongStreamEx sequential() {
+        return (LongStreamEx) super.sequential();
+    }
+
+    @Override
+    public LongStreamEx parallel() {
+        return (LongStreamEx) super.parallel();
+    }
+
+    @Override
+    public LongStreamEx parallel(ForkJoinPool fjp) {
+        return (LongStreamEx) super.parallel(fjp);
+    }
+
+    @Override
+    public OfLong iterator() {
+        return Spliterators.iterator(spliterator());
+    }
+
+    /**
+     * Returns a new {@code LongStreamEx} which is a concatenation of this
+     * stream and the stream containing supplied values
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * @param values the values to append to the stream
+     * @return the new stream
+     */
+    public LongStreamEx append(long... values) {
+        if (values.length == 0)
+            return this;
+        return new LongStreamEx(LongStream.concat(stream(), LongStream.of(values)), context);
+    }
+
+    /**
+     * Creates a lazily concatenated stream whose elements are all the elements
+     * of this stream followed by all the elements of the other stream. The
+     * resulting stream is ordered if both of the input streams are ordered, and
+     * parallel if either of the input streams is parallel. When the resulting
+     * stream is closed, the close handlers for both input streams are invoked.
+     *
+     * @param other the other stream
+     * @return this stream appended by the other stream
+     * @see LongStream#concat(LongStream, LongStream)
+     */
+    public LongStreamEx append(LongStream other) {
+        return new LongStreamEx(LongStream.concat(stream(), other), context.combine(other));
+    }
+
+    /**
+     * Returns a new {@code LongStreamEx} which is a concatenation of the stream
+     * containing supplied values and this stream
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * @param values the values to prepend to the stream
+     * @return the new stream
+     */
+    public LongStreamEx prepend(long... values) {
+        if (values.length == 0)
+            return this;
+        return new LongStreamEx(LongStream.concat(LongStream.of(values), stream()), context);
+    }
+
+    /**
+     * Creates a lazily concatenated stream whose elements are all the elements
+     * of the other stream followed by all the elements of this stream. The
+     * resulting stream is ordered if both of the input streams are ordered, and
+     * parallel if either of the input streams is parallel. When the resulting
+     * stream is closed, the close handlers for both input streams are invoked.
+     *
+     * @param other the other stream
+     * @return this stream prepended by the other stream
+     * @see LongStream#concat(LongStream, LongStream)
+     */
+    public LongStreamEx prepend(LongStream other) {
+        return new LongStreamEx(LongStream.concat(other, stream()), context.combine(other));
+    }
+
+    /**
+     * Returns a stream consisting of the results of applying the given function
+     * to the every adjacent pair of elements of this stream.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The output stream will contain one element less than this stream. If this
+     * stream contains zero or one element the output stream will be empty.
+     *
+     * @param mapper a non-interfering, stateless function to apply to each
+     *        adjacent pair of this stream elements.
+     * @return the new stream
+     * @since 0.2.1
+     */
+    public LongStreamEx pairMap(LongBinaryOperator mapper) {
+        return delegate(new PairSpliterator.PSOfLong(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
+    }
+
+    /**
+     * Returns a {@link String} which is the concatenation of the results of
+     * calling {@link String#valueOf(long)} on each element of this stream,
+     * separated by the specified delimiter, in encounter order.
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * @param delimiter the delimiter to be used between each element
+     * @return the result of concatenation. For empty input stream empty String
+     *         is returned.
+     * @since 0.3.1
+     */
+    public String joining(CharSequence delimiter) {
+        return collect(LongCollector.joining(delimiter));
+    }
+
+    /**
+     * Returns a {@link String} which is the concatenation of the results of
+     * calling {@link String#valueOf(long)} on each element of this stream,
+     * separated by the specified delimiter, with the specified prefix and
+     * suffix in encounter order.
+     *
+     * <p>
+     * This is a terminal operation.
+     * 
+     * @param delimiter the delimiter to be used between each element
+     * @param prefix the sequence of characters to be used at the beginning of
+     *        the joined result
+     * @param suffix the sequence of characters to be used at the end of the
+     *        joined result
+     * @return the result of concatenation. For empty input stream
+     *         {@code prefix + suffix} is returned.
+     * @since 0.3.1
+     */
+    public String joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) {
+        return collect(LongCollector.joining(delimiter, prefix, suffix));
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream until the
+     * first element which does not match the given predicate is found.
+     * 
+     * <p>
+     * This is a short-circuiting stateful operation. It can be either
+     * <a href="package-summary.html#StreamOps">intermediate or
+     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
+     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
+     * implementation.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.3.6
+     * @see #takeWhileInclusive(LongPredicate)
+     * @see #dropWhile(LongPredicate)
+     */
+    public LongStreamEx takeWhile(LongPredicate predicate) {
+        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), false);
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream until the
+     * first element which does not match the given predicate is found
+     * (including the first mismatching element).
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.5.5
+     * @see #takeWhile(LongPredicate)
+     */
+    public LongStreamEx takeWhileInclusive(LongPredicate predicate) {
+        Objects.requireNonNull(predicate);
+        return delegate(new TakeDrop.TDOfLong(spliterator(), false, true, predicate));
+    }
+
+    /**
+     * Returns a stream consisting of all elements from this stream starting
+     * from the first element which does not match the given predicate. If the
+     * predicate is true for all stream elements, an empty stream is returned.
+     * 
+     * <p>
+     * This is a stateful operation. It can be either
+     * <a href="package-summary.html#StreamOps">intermediate or
+     * quasi-intermediate</a>. When using with JDK 1.9 or higher it calls the
+     * corresponding JDK 1.9 implementation. When using with JDK 1.8 it uses own
+     * implementation.
+     * 
+     * <p>
+     * While this operation is quite cheap for sequential stream, it can be
+     * quite expensive on parallel pipelines.
+     * 
+     * @param predicate a non-interfering, stateless predicate to apply to
+     *        elements.
+     * @return the new stream.
+     * @since 0.3.6
+     */
+    public LongStreamEx dropWhile(LongPredicate predicate) {
+        return VerSpec.VER_SPEC.callWhile(this, Objects.requireNonNull(predicate), true);
+    }
+
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful
+     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
+     * operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(LongBinaryOperator)}, but
+     * unlike {@code scanLeft} this operation is intermediate and accumulation
+     * function must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(LongBinaryOperator)
+     * @since 0.6.1
+     */
+    public LongStreamEx prefix(LongBinaryOperator op) {
+        Spliterator.OfLong spltr = spliterator();
+        return delegate(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfLong(spltr, op)
+                : new PrefixOps.OfUnordLong(spltr, op));
+    }
+
+    // Necessary to generate proper JavaDoc
+    // does not add overhead as it appears in bytecode anyways as bridge method
+    @Override
+    public <U> U chain(Function<? super LongStreamEx, U> mapper) {
+        return mapper.apply(this);
+    }
+
+    /**
+     * Returns an empty sequential {@code LongStreamEx}.
+     *
+     * @return an empty sequential stream
+     */
+    public static LongStreamEx empty() {
+        return of(Spliterators.emptyLongSpliterator());
+    }
+
+    /**
+     * Returns a sequential {@code LongStreamEx} containing a single element.
+     *
+     * @param element the single element
+     * @return a singleton sequential stream
+     */
+    public static LongStreamEx of(long element) {
+        return of(new ConstSpliterator.OfLong(element, 1, true));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
+     * specified values.
+     *
+     * @param elements the elements of the new stream
+     * @return the new stream
+     */
+    public static LongStreamEx of(long... elements) {
+        return of(Arrays.spliterator(elements));
+    }
+
+    /**
+     * Returns a sequential {@link LongStreamEx} with the specified range of the
+     * specified array as its source.
+     *
+     * @param array the array, assumed to be unmodified during use
+     * @param startInclusive the first index to cover, inclusive
+     * @param endExclusive index immediately past the last index to cover
+     * @return an {@code LongStreamEx} for the array range
+     * @throws ArrayIndexOutOfBoundsException if {@code startInclusive} is
+     *         negative, {@code endExclusive} is less than
+     *         {@code startInclusive}, or {@code endExclusive} is greater than
+     *         the array size
+     * @since 0.1.1
+     * @see Arrays#stream(long[], int, int)
+     */
+    public static LongStreamEx of(long[] array, int startInclusive, int endExclusive) {
+        return of(Arrays.spliterator(array, startInclusive, endExclusive));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
+     * unboxed elements of supplied array.
+     *
+     * @param array the array to create the stream from.
+     * @return the new stream
+     * @see Arrays#stream(Object[])
+     * @since 0.5.0
+     */
+    public static LongStreamEx of(Long[] array) {
+        return seq(Arrays.stream(array).mapToLong(Long::longValue));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
+     * values in the supplied {@link java.nio.LongBuffer}.
+     * 
+     * <p>
+     * The resulting stream covers only a portion of {@code LongBuffer} content
+     * which starts with {@linkplain Buffer#position() position} (inclusive) and
+     * ends with {@linkplain Buffer#limit() limit} (exclusive). Changes in
+     * position and limit after the stream creation don't affect the stream.
+     * 
+     * <p>
+     * The resulting stream does not change the internal {@code LongBuffer}
+     * state.
+     * 
+     * @param buf the {@code LongBuffer} to create a stream from
+     * @return the new stream
+     * @since 0.6.2
+     */
+    public static LongStreamEx of(java.nio.LongBuffer buf) {
+        return IntStreamEx.range(buf.position(), buf.limit()).mapToLong(buf::get);
+    }
+
+    /**
+     * Returns a {@code LongStreamEx} object which wraps given
+     * {@link LongStream}.
+     * 
+     * <p>
+     * The supplied stream must not be consumed or closed when this method is
+     * called. No operation must be performed on the supplied stream after it's
+     * wrapped.
+     * 
+     * @param stream original stream
+     * @return the wrapped stream
+     * @since 0.0.8
+     */
+    public static LongStreamEx of(LongStream stream) {
+        return stream instanceof LongStreamEx ? (LongStreamEx) stream
+                : new LongStreamEx(stream, StreamContext.of(stream));
+    }
+
+    /**
+     * Returns a sequential {@link LongStreamEx} created from given
+     * {@link java.util.Spliterator.OfLong}.
+     * 
+     * @param spliterator a spliterator to create the stream from.
+     * @return the new stream
+     * @since 0.3.4
+     */
+    public static LongStreamEx of(Spliterator.OfLong spliterator) {
+        return new LongStreamEx(spliterator, StreamContext.SEQUENTIAL);
+    }
+
+    /**
+     * Returns a sequential, ordered {@link LongStreamEx} created from given
+     * {@link java.util.PrimitiveIterator.OfLong}.
+     *
+     * <p>
+     * This method is roughly equivalent to
+     * {@code LongStreamEx.of(Spliterators.spliteratorUnknownSize(iterator, ORDERED))}
+     * , but may show better performance for parallel processing.
+     * 
+     * <p>
+     * Use this method only if you cannot provide better Stream source.
+     *
+     * @param iterator an iterator to create the stream from.
+     * @return the new stream
+     * @since 0.5.1
+     */
+    public static LongStreamEx of(PrimitiveIterator.OfLong iterator) {
+        return of(new UnknownSizeSpliterator.USOfLong(iterator));
+    }
+
+    /**
+     * Returns a sequential {@code LongStreamEx} containing an
+     * {@link OptionalLong} value, if present, otherwise returns an empty
+     * {@code LongStreamEx}.
+     *
+     * @param optional the optional to create a stream of
+     * @return a stream with an {@code OptionalLong} value if present, otherwise
+     *         an empty stream
+     * @since 0.1.1
+     */
+    public static LongStreamEx of(OptionalLong optional) {
+        return optional.isPresent() ? of(optional.getAsLong()) : empty();
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} whose elements are the
+     * unboxed elements of supplied collection.
+     *
+     * @param collection the collection to create the stream from.
+     * @return the new stream
+     * @see Collection#stream()
+     */
+    public static LongStreamEx of(Collection<Long> collection) {
+        return seq(collection.stream().mapToLong(Long::longValue));
+    }
+
+    /**
+     * Returns an effectively unlimited stream of pseudorandom {@code long}
+     * values produced by given {@link Random} object.
+     *
+     * <p>
+     * A pseudorandom {@code long} value is generated as if it's the result of
+     * calling the method {@link Random#nextLong()}.
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @return a stream of pseudorandom {@code long} values
+     * @see Random#longs()
+     */
+    public static LongStreamEx of(Random random) {
+        return seq(random.longs());
+    }
+
+    /**
+     * Returns a stream producing the given {@code streamSize} number of
+     * pseudorandom {@code long} values.
+     *
+     * <p>
+     * A pseudorandom {@code long} value is generated as if it's the result of
+     * calling the method {@link Random#nextLong()}
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param streamSize the number of values to generate
+     * @return a stream of pseudorandom {@code long} values
+     * @see Random#longs(long)
+     */
+    public static LongStreamEx of(Random random, long streamSize) {
+        return seq(random.longs(streamSize));
+    }
+
+    /**
+     * Returns an effectively unlimited stream of pseudorandom {@code long}
+     * values, each conforming to the given origin (inclusive) and bound
+     * (exclusive).
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param randomNumberOrigin the origin (inclusive) of each random value
+     * @param randomNumberBound the bound (exclusive) of each random value
+     * @return a stream of pseudorandom {@code long} values
+     * @see Random#longs(long, long, long)
+     */
+    public static LongStreamEx of(Random random, long randomNumberOrigin, long randomNumberBound) {
+        return seq(random.longs(randomNumberOrigin, randomNumberBound));
+    }
+
+    /**
+     * Returns a stream producing the given {@code streamSize} number of
+     * pseudorandom {@code long} values, each conforming to the given origin
+     * (inclusive) and bound (exclusive).
+     *
+     * @param random a {@link Random} object to produce the stream from
+     * @param streamSize the number of values to generate
+     * @param randomNumberOrigin the origin (inclusive) of each random value
+     * @param randomNumberBound the bound (exclusive) of each random value
+     * @return a stream of pseudorandom {@code long} values
+     * @see Random#longs(long, long, long)
+     */
+    public static LongStreamEx of(Random random, long streamSize, long randomNumberOrigin, long randomNumberBound) {
+        return seq(random.longs(streamSize, randomNumberOrigin, randomNumberBound));
+    }
+
+    /**
+     * Returns an infinite sequential ordered {@code LongStreamEx} produced by
+     * iterative application of a function {@code f} to an initial element
+     * {@code seed}, producing a stream consisting of {@code seed},
+     * {@code f(seed)}, {@code f(f(seed))}, etc.
+     *
+     * <p>
+     * The first element (position {@code 0}) in the {@code LongStreamEx} will
+     * be the provided {@code seed}. For {@code n > 0}, the element at position
+     * {@code n}, will be the result of applying the function {@code f} to the
+     * element at position {@code n - 1}.
+     *
+     * @param seed the initial element
+     * @param f a function to be applied to to the previous element to produce a
+     *        new element
+     * @return A new sequential {@code LongStream}
+     * @see #iterate(long, LongPredicate, LongUnaryOperator)
+     */
+    public static LongStreamEx iterate(final long seed, final LongUnaryOperator f) {
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code LongStreamEx.iterate} should produce the same sequence of elements
+     * as produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (long index=seed; predicate.test(index); index = f.apply(index)) { 
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code LongStreamEx}
+     * @see #iterate(long, LongUnaryOperator)
+     * @since 0.6.0
+     */
+    public static LongStreamEx iterate(long seed, LongPredicate predicate, LongUnaryOperator f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator.OfLong spliterator = new Spliterators.AbstractLongSpliterator(Long.MAX_VALUE, Spliterator.ORDERED
+            | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
+            long prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(LongConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                long t;
+                if (started)
+                    t = f.applyAsLong(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(LongConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                long t = started ? f.applyAsLong(prev) : seed;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.applyAsLong(t);
+                }
+            }
+        };
+        return of(spliterator);
+    }
+
+    /**
+     * Returns an infinite sequential unordered stream where each element is
+     * generated by the provided {@code LongSupplier}. This is suitable for
+     * generating constant streams, streams of random elements, etc.
+     *
+     * @param s the {@code LongSupplier} for generated elements
+     * @return a new infinite sequential unordered {@code LongStreamEx}
+     * @see LongStream#generate(LongSupplier)
+     */
+    public static LongStreamEx generate(LongSupplier s) {
+        return seq(LongStream.generate(s));
+    }
+
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. Note however that if a short-circuiting operation is used,
+     * then the final state of the mutable object cannot be guaranteed.
+     * 
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static LongStreamEx produce(Predicate<LongConsumer> producer) {
+        Box<LongEmitter> box = new Box<>();
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from 0 (inclusive) to
+     * {@code Long.MAX_VALUE} (exclusive) by an incremental step of {@code 1}.
+     *
+     * @return a sequential {@code LongStreamEx} for the range of {@code long}
+     *         elements
+     * @see #range(long, long)
+     * @since 0.5.5
+     */
+    public static LongStreamEx longs() {
+        return seq(LongStream.range(0, Long.MAX_VALUE));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from 0 (inclusive) to
+     * {@code endExclusive} (exclusive) by an incremental step of {@code 1}.
+     *
+     * @param endExclusive the exclusive upper bound
+     * @return a sequential {@code LongStreamEx} for the range of {@code int}
+     *         elements
+     * @see #range(long, long)
+     * @since 0.1.1
+     */
+    public static LongStreamEx range(long endExclusive) {
+        return seq(LongStream.range(0, endExclusive));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from
+     * {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by
+     * an incremental step of {@code 1}.
+     *
+     * @param startInclusive the (inclusive) initial value
+     * @param endExclusive the exclusive upper bound
+     * @return a sequential {@code LongStreamEx} for the range of {@code long}
+     *         elements
+     * @see LongStream#range(long, long)
+     */
+    public static LongStreamEx range(long startInclusive, long endExclusive) {
+        return seq(LongStream.range(startInclusive, endExclusive));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from
+     * {@code startInclusive} (inclusive) to {@code endExclusive} (exclusive) by
+     * the specified incremental step. The negative step values are also
+     * supported. In this case, the {@code startInclusive} should be greater than
+     * {@code endExclusive}.
+     *
+     * @param startInclusive the (inclusive) initial value
+     * @param endExclusive the exclusive upper (for positive step) or lower (for negative step) bound
+     * @param step the non-zero value which designates the difference between
+     *        the consecutive values of the resulting stream.
+     * @return a sequential {@code LongStreamEx} for the range of {@code long}
+     *         elements
+     * @throws IllegalArgumentException if step is zero
+     * @see LongStreamEx#range(long, long)
+     * @since 0.4.0
+     */
+    public static LongStreamEx range(long startInclusive, long endExclusive, long step) {
+        long endInclusive = endExclusive - Long.signum(step);
+        if (endInclusive > endExclusive && step > 0 || endInclusive < endExclusive && step < 0)
+            return empty();
+        return rangeClosed(startInclusive, endInclusive, step);
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from
+     * {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by
+     * an incremental step of {@code 1}.
+     *
+     * @param startInclusive the (inclusive) initial value
+     * @param endInclusive the inclusive upper bound
+     * @return a sequential {@code LongStreamEx} for the range of {@code long}
+     *         elements
+     * @see LongStream#rangeClosed(long, long)
+     */
+    public static LongStreamEx rangeClosed(long startInclusive, long endInclusive) {
+        return seq(LongStream.rangeClosed(startInclusive, endInclusive));
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} from
+     * {@code startInclusive} (inclusive) to {@code endInclusive} (inclusive) by
+     * the specified incremental step. The negative step values are also
+     * supported. In this case, the {@code startInclusive} should be not less than
+     * {@code endInclusive}.
+     * 
+     * <p>
+     * Note that depending on the step value the {@code endInclusive} bound may
+     * still not be reached. For example
+     * {@code LongStreamEx.rangeClosed(0, 5, 2)} will yield the stream of three
+     * numbers: 0L, 2L and 4L.
+     *
+     * @param startInclusive the (inclusive) initial value
+     * @param endInclusive the inclusive upper (for positive step) or lower (for negative step) bound
+     * @param step the non-zero value which designates the difference between
+     *        the consecutive values of the resulting stream.
+     * @return a sequential {@code LongStreamEx} for the range of {@code long}
+     *         elements; an empty stream if startInclusive is greater than endInclusive
+     *         for positive step, or if startInclusive is less than endInclusive
+     *         for negative step.
+     * @throws IllegalArgumentException if step is zero
+     * @see LongStreamEx#rangeClosed(long, long)
+     * @since 0.4.0
+     */
+    public static LongStreamEx rangeClosed(long startInclusive, long endInclusive, long step) {
+        if (step == 0)
+            throw new IllegalArgumentException("step = 0");
+        if (endInclusive == startInclusive)
+            return LongStreamEx.of(startInclusive);
+        if (step == 1)
+            return seq(LongStream.rangeClosed(startInclusive, endInclusive));
+        if (step == -1) {
+            // Handled specially as number of elements can exceed
+            // Long.MAX_VALUE
+            long sum = endInclusive + startInclusive;
+            return seq(LongStream.rangeClosed(endInclusive, startInclusive).map(x -> sum - x));
+        }
+        if ((endInclusive > startInclusive) != (step > 0))
+            return empty();
+        long limit = (endInclusive - startInclusive) * Long.signum(step);
+        limit = Long.divideUnsigned(limit, Math.abs(step));
+        return seq(LongStream.rangeClosed(0, limit).map(x -> x * step + startInclusive));
+    }
+
+    /**
+     * Returns a sequential unordered {@code LongStreamEx} of given length which
+     * elements are equal to supplied value.
+     * 
+     * @param value the constant value
+     * @param length the length of the stream
+     * @return a new {@code LongStreamEx}
+     * @since 0.1.2
+     */
+    public static LongStreamEx constant(long value, long length) {
+        return of(new ConstSpliterator.OfLong(value, length, false));
+    }
+
+    /**
+     * Returns a sequential {@code LongStreamEx} containing the results of
+     * applying the given function to the corresponding pairs of values in given
+     * two arrays.
+     * 
+     * @param first the first array
+     * @param second the second array
+     * @param mapper a non-interfering, stateless function to apply to each pair
+     *        of the corresponding array elements.
+     * @return a new {@code LongStreamEx}
+     * @throws IllegalArgumentException if length of the arrays differs.
+     * @since 0.2.1
+     */
+    public static LongStreamEx zip(long[] first, long[] second, LongBinaryOperator mapper) {
+        return of(new RangeBasedSpliterator.ZipLong(0, checkLength(first.length, second.length), mapper, first,
+                second));
+    }
+
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using
+     * {@link LongStreamEx#iterate(long, LongUnaryOperator)} or
+     * {@link LongStreamEx#generate(LongSupplier)}. For example, the following
+     * method generates a Collatz sequence starting from given number:
+     * 
+     * <pre>{@code
+     * public static LongEmitter collatz(long start) {
+     *    return action -> {
+     *       action.accept(start);
+     *       return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
+     *    };
+     * }}</pre>
+     * 
+     * <p>
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz
+     * numbers.
+     * 
+     * @author Tagir Valeev
+     *
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface LongEmitter {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
+         * 
+         * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param action consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        LongEmitter next(LongConsumer action);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator.OfLong spliterator() {
+            return new EmitterSpliterator.OfLong(this);
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default LongStreamEx stream() {
+            return of(spliterator());
+        }
+    }
+}
diff --git a/src/main/java/one/util/streamex/PrefixOps.java b/src/main/java/one/util/streamex/PrefixOps.java
index 9492516..b4a1a40 100644
--- a/src/main/java/one/util/streamex/PrefixOps.java
+++ b/src/main/java/one/util/streamex/PrefixOps.java
@@ -1,302 +1,565 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.util.Spliterator;
-import java.util.Spliterators.AbstractDoubleSpliterator;
-import java.util.Spliterators.AbstractIntSpliterator;
-import java.util.Spliterators.AbstractLongSpliterator;
-import java.util.Spliterators.AbstractSpliterator;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.BinaryOperator;
-import java.util.function.Consumer;
-import java.util.function.DoubleBinaryOperator;
-import java.util.function.DoubleConsumer;
-import java.util.function.IntBinaryOperator;
-import java.util.function.IntConsumer;
-import java.util.function.LongBinaryOperator;
-import java.util.function.LongConsumer;
-
-import static one.util.streamex.Internals.CloneableSpliterator;
-import static one.util.streamex.Internals.NONE;
-import static one.util.streamex.Internals.none;
-
-/**
- * @author Tagir Valeev
- */
-/* package */ abstract class PrefixOps<T, S extends Spliterator<T>> extends CloneableSpliterator<T, PrefixOps<T, S>> {
-    private static final int BUF_SIZE = 128;
-    
-    S source;
-    AtomicReference<T> accRef;
-    T acc = none();
-    int idx = 0;
-    final BinaryOperator<T> op;
-    
-    PrefixOps(S source, BinaryOperator<T> op) {
-        this.source = source;
-        this.op = op;
-    }
-    
-    @Override
-    public Spliterator<T> trySplit() {
-        if (acc != NONE) {
-            return null;
-        }
-        @SuppressWarnings("unchecked")
-        S prefix = (S) source.trySplit();
-        if (prefix == null) {
-            return null;
-        }
-        if (accRef == null) {
-            accRef = new AtomicReference<>(none());
-        }
-        PrefixOps<T, S> pref = doClone();
-        pref.source = prefix;
-        return pref;
-    }
-
-    @Override
-    public long estimateSize() {
-        return source.estimateSize();
-    }
-
-    @Override
-    public int characteristics() {
-        return source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | SUBSIZED);
-    }
-
-    static final class OfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
-        private final BinaryOperator<T> op;
-        private final Spliterator<T> source;
-        private boolean started;
-        private T acc;
-
-        OfRef(Spliterator<T> source, BinaryOperator<T> op) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED));
-            this.source = source;
-            this.op = op;
-        }
-
-        @Override
-        public boolean tryAdvance(Consumer<? super T> action) {
-            if (!source.tryAdvance(this))
-                return false;
-            action.accept(acc);
-            return true;
-        }
-        
-        @Override
-        public void forEachRemaining(Consumer<? super T> action) {
-            source.forEachRemaining(next -> {
-                this.accept(next);
-                action.accept(acc);
-            });
-        }
-
-        @Override
-        public void accept(T next) {
-            if (started) {
-                acc = op.apply(acc, next);
-            } else {
-                started = true;
-                acc = next;
-            }
-        }
-    }
-    
-    static final class OfInt extends AbstractIntSpliterator implements IntConsumer {
-        private final IntBinaryOperator op;
-        private final Spliterator.OfInt source;
-        private boolean started;
-        private int acc;
-        
-        OfInt(Spliterator.OfInt source, IntBinaryOperator op) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
-            this.source = source;
-            this.op = op;
-        }
-        
-        @Override
-        public boolean tryAdvance(IntConsumer action) {
-            if (!source.tryAdvance(this))
-                return false;
-            action.accept(acc);
-            return true;
-        }
-        
-        @Override
-        public void forEachRemaining(IntConsumer action) {
-            source.forEachRemaining((int next) -> {
-                this.accept(next);
-                action.accept(acc);
-            });
-        }
-        
-        @Override
-        public void accept(int next) {
-            if (started) {
-                acc = op.applyAsInt(acc, next);
-            } else {
-                started = true;
-                acc = next;
-            }
-        }
-    }
-
-    static final class OfLong extends AbstractLongSpliterator implements LongConsumer {
-        private final LongBinaryOperator op;
-        private final Spliterator.OfLong source;
-        private boolean started;
-        private long acc;
-        
-        OfLong(Spliterator.OfLong source, LongBinaryOperator op) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
-            this.source = source;
-            this.op = op;
-        }
-        
-        @Override
-        public boolean tryAdvance(LongConsumer action) {
-            if (!source.tryAdvance(this))
-                return false;
-            action.accept(acc);
-            return true;
-        }
-        
-        @Override
-        public void forEachRemaining(LongConsumer action) {
-            source.forEachRemaining((long next) -> {
-                this.accept(next);
-                action.accept(acc);
-            });
-        }
-        
-        @Override
-        public void accept(long next) {
-            if (started) {
-                acc = op.applyAsLong(acc, next);
-            } else {
-                started = true;
-                acc = next;
-            }
-        }
-    }
-
-    static final class OfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
-        private final DoubleBinaryOperator op;
-        private final Spliterator.OfDouble source;
-        private boolean started;
-        private double acc;
-        
-        OfDouble(Spliterator.OfDouble source, DoubleBinaryOperator op) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
-            this.source = source;
-            this.op = op;
-        }
-        
-        @Override
-        public boolean tryAdvance(DoubleConsumer action) {
-            if (!source.tryAdvance(this))
-                return false;
-            action.accept(acc);
-            return true;
-        }
-        
-        @Override
-        public void forEachRemaining(DoubleConsumer action) {
-            source.forEachRemaining((double next) -> {
-                this.accept(next);
-                action.accept(acc);
-            });
-        }
-        
-        @Override
-        public void accept(double next) {
-            if (started) {
-                acc = op.applyAsDouble(acc, next);
-            } else {
-                started = true;
-                acc = next;
-            }
-        }
-    }
-    
-    static final class OfUnordRef<T> extends PrefixOps<T, Spliterator<T>> implements Consumer<T> {
-        private final BinaryOperator<T> localOp;
-        
-        OfUnordRef(Spliterator<T> source, BinaryOperator<T> op) {
-            super(source, (a, b) -> a == NONE ? b : op.apply(a, b));
-            this.localOp = op;
-        }
-        
-        @Override
-        public boolean tryAdvance(Consumer<? super T> action) {
-            if (!source.tryAdvance(this)) {
-                return false;
-            }
-            action.accept(acc);
-            return true;
-        }
-        
-        @Override
-        public void forEachRemaining(Consumer<? super T> action) {
-            if (accRef == null) {
-                source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
-            } else {
-                @SuppressWarnings("unchecked")
-                T[] buf = (T[]) new Object[BUF_SIZE];
-                source.forEachRemaining(next -> {
-                    if (idx == 0) {
-                        buf[idx++] = next;
-                    } else {
-                        T prev = buf[idx - 1];
-                        buf[idx++] = localOp.apply(prev, next);
-                        if (idx == buf.length) {
-                            drain(action, buf);
-                            idx = 0;
-                        }
-                    }
-                });
-                if (idx > 0)
-                    drain(action, buf);
-            }
-        }
-
-        private void drain(Consumer<? super T> action, T[] buf) {
-            T last = buf[idx - 1];
-            T acc = accRef.getAndAccumulate(last, op);
-            if (acc != NONE) {
-                for (int i = 0; i < idx; i++) {
-                    action.accept(localOp.apply(buf[i], acc));
-                }
-            } else {
-                for (int i = 0; i < idx; i++) {
-                    action.accept(buf[i]);
-                }
-            }
-        }
-
-        @Override
-        public void accept(T next) {
-            if (accRef == null) {
-                acc = op.apply(acc, next);
-            } else {
-                acc = accRef.accumulateAndGet(next, op);
-            }
-        }
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.Spliterators.AbstractDoubleSpliterator;
+import java.util.Spliterators.AbstractIntSpliterator;
+import java.util.Spliterators.AbstractLongSpliterator;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntConsumer;
+import java.util.function.LongBinaryOperator;
+import java.util.function.LongConsumer;
+
+import static one.util.streamex.Internals.CloneableSpliterator;
+import static one.util.streamex.Internals.NONE;
+import static one.util.streamex.Internals.none;
+
+/**
+ * @author Tagir Valeev
+ */
+/* package */ abstract class PrefixOps<T, S extends Spliterator<T>> extends CloneableSpliterator<T, PrefixOps<T, S>> {
+    private static final int BUF_SIZE = 128;
+    
+    S source;
+    AtomicReference<T> accRef;
+    T acc = none();
+    int idx = 0;
+    final BinaryOperator<T> op;
+    
+    PrefixOps(S source, BinaryOperator<T> op) {
+        this.source = source;
+        this.op = op;
+    }
+    
+    @Override
+    public Spliterator<T> trySplit() {
+        if (acc != NONE) {
+            return null;
+        }
+        @SuppressWarnings("unchecked")
+        S prefix = (S) source.trySplit();
+        if (prefix == null) {
+            return null;
+        }
+        if (accRef == null) {
+            accRef = new AtomicReference<>(none());
+        }
+        PrefixOps<T, S> pref = doClone();
+        pref.source = prefix;
+        return pref;
+    }
+
+    @Override
+    public long estimateSize() {
+        return source.estimateSize();
+    }
+
+    @Override
+    public int characteristics() {
+        return source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | SUBSIZED);
+    }
+
+    static final class OfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
+        private final BinaryOperator<T> op;
+        private final Spliterator<T> source;
+        private boolean started;
+        private T acc;
+
+        OfRef(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED));
+            this.source = source;
+            this.op = op;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if (!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            source.forEachRemaining(next -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+
+        @Override
+        public void accept(T next) {
+            if (started) {
+                acc = op.apply(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
+        }
+    }
+    
+    static final class OfInt extends AbstractIntSpliterator implements IntConsumer {
+        private final IntBinaryOperator op;
+        private final Spliterator.OfInt source;
+        private boolean started;
+        private int acc;
+        
+        OfInt(Spliterator.OfInt source, IntBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            if (!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            source.forEachRemaining((int next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(int next) {
+            if (started) {
+                acc = op.applyAsInt(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
+        }
+    }
+
+    static final class OfLong extends AbstractLongSpliterator implements LongConsumer {
+        private final LongBinaryOperator op;
+        private final Spliterator.OfLong source;
+        private boolean started;
+        private long acc;
+        
+        OfLong(Spliterator.OfLong source, LongBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if (!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            source.forEachRemaining((long next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(long next) {
+            if (started) {
+                acc = op.applyAsLong(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
+        }
+    }
+
+    static final class OfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
+        private final DoubleBinaryOperator op;
+        private final Spliterator.OfDouble source;
+        private boolean started;
+        private double acc;
+        
+        OfDouble(Spliterator.OfDouble source, DoubleBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            if (!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            source.forEachRemaining((double next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(double next) {
+            if (started) {
+                acc = op.applyAsDouble(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
+        }
+    }
+    
+    static final class OfUnordRef<T> extends PrefixOps<T, Spliterator<T>> implements Consumer<T> {
+        private final BinaryOperator<T> localOp;
+        
+        OfUnordRef(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source, (a, b) -> a == NONE ? b : op.apply(a, b));
+            this.localOp = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if (!source.tryAdvance(this)) {
+                return false;
+            }
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if (accRef == null) {
+                source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
+            } else {
+                @SuppressWarnings("unchecked")
+                T[] buf = (T[]) new Object[BUF_SIZE];
+                source.forEachRemaining(next -> {
+                    if (idx == 0) {
+                        buf[idx++] = next;
+                    } else {
+                        T prev = buf[idx - 1];
+                        buf[idx++] = localOp.apply(prev, next);
+                        if (idx == buf.length) {
+                            drain(action, buf);
+                            idx = 0;
+                        }
+                    }
+                });
+                if (idx > 0)
+                    drain(action, buf);
+            }
+        }
+
+        private void drain(Consumer<? super T> action, T[] buf) {
+            T last = buf[idx - 1];
+            T acc = accRef.getAndAccumulate(last, op);
+            if (acc != NONE) {
+                for (int i = 0; i < idx; i++) {
+                    action.accept(localOp.apply(buf[i], acc));
+                }
+            } else {
+                for (int i = 0; i < idx; i++) {
+                    action.accept(buf[i]);
+                }
+            }
+        }
+
+        @Override
+        public void accept(T next) {
+            if (accRef == null) {
+                acc = op.apply(acc, next);
+            } else {
+                acc = accRef.accumulateAndGet(next, op);
+            }
+        }
+    }
+    
+    static final class OfUnordInt extends AbstractIntSpliterator implements IntConsumer {
+        private final IntBinaryOperator op;
+        private final Spliterator.OfInt source;
+        int idx = 0;
+        private boolean started;
+        AtomicInteger accRef;
+        private int acc;
+        
+        OfUnordInt(Spliterator.OfInt source, IntBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public Spliterator.OfInt trySplit() {
+            if (started) {
+                return null;
+            }
+            OfInt prefix = source.trySplit();
+            if (prefix == null) {
+                return null;
+            }
+            if (accRef == null) {
+                accRef = new AtomicInteger();
+            }
+            OfUnordInt pref = new OfUnordInt(prefix, op);
+            pref.accRef = accRef;
+            return pref;
+        }
+        
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            if (!source.tryAdvance(this)) {
+                return false;
+            }
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            if (accRef == null) {
+                source.forEachRemaining((IntConsumer) next -> action.accept(acc = op.applyAsInt(acc, next)));
+            } else {
+                int[] buf = new int[BUF_SIZE];
+                source.forEachRemaining((IntConsumer) next -> {
+                    if (idx == 0) {
+                        buf[idx++] = next;
+                    } else {
+                        int prev = buf[idx - 1];
+                        buf[idx++] = op.applyAsInt(prev, next);
+                        if (idx == buf.length) {
+                            drain(action, buf);
+                            idx = 0;
+                        }
+                    }
+                });
+                if (idx > 0)
+                    drain(action, buf);
+            }
+        }
+        
+        private void drain(IntConsumer action, int[] buf) {
+            int last = buf[idx - 1];
+            int acc = accRef.getAndAccumulate(last, op);
+            for (int i = 0; i < idx; i++) {
+                action.accept(op.applyAsInt(buf[i], acc));
+            }
+        }
+        
+        @Override
+        public void accept(int next) {
+            if (accRef == null) {
+                acc = op.applyAsInt(acc, next);
+                started = true;
+            } else {
+                acc = accRef.accumulateAndGet(next, op);
+            }
+        }
+        
+        @Override
+        public long estimateSize() {
+            return source.estimateSize();
+        }
+    }
+    
+    static final class OfUnordLong extends AbstractLongSpliterator implements LongConsumer {
+        private final LongBinaryOperator op;
+        private final Spliterator.OfLong source;
+        int idx = 0;
+        private boolean started;
+        AtomicLong accRef;
+        private long acc;
+        
+        OfUnordLong(Spliterator.OfLong source, LongBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public Spliterator.OfLong trySplit() {
+            if (started) {
+                return null;
+            }
+            OfLong prefix = source.trySplit();
+            if (prefix == null) {
+                return null;
+            }
+            if (accRef == null) {
+                accRef = new AtomicLong();
+            }
+            OfUnordLong pref = new OfUnordLong(prefix, op);
+            pref.accRef = accRef;
+            return pref;
+        }
+        
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if (!source.tryAdvance(this)) {
+                return false;
+            }
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            if (accRef == null) {
+                source.forEachRemaining((LongConsumer) next -> action.accept(acc = op.applyAsLong(acc, next)));
+            } else {
+                long[] buf = new long[BUF_SIZE];
+                source.forEachRemaining((LongConsumer) next -> {
+                    if (idx == 0) {
+                        buf[idx++] = next;
+                    } else {
+                        long prev = buf[idx - 1];
+                        buf[idx++] = op.applyAsLong(prev, next);
+                        if (idx == buf.length) {
+                            drain(action, buf);
+                            idx = 0;
+                        }
+                    }
+                });
+                if (idx > 0)
+                    drain(action, buf);
+            }
+        }
+        
+        private void drain(LongConsumer action, long[] buf) {
+            long last = buf[idx - 1];
+            long acc = accRef.getAndAccumulate(last, op);
+            for (int i = 0; i < idx; i++) {
+                action.accept(op.applyAsLong(buf[i], acc));
+            }
+        }
+        
+        @Override
+        public void accept(long next) {
+            if (accRef == null) {
+                acc = op.applyAsLong(acc, next);
+                started = true;
+            } else {
+                acc = accRef.accumulateAndGet(next, op);
+            }
+        }
+        
+        @Override
+        public long estimateSize() {
+            return source.estimateSize();
+        }
+    }
+    
+    static final class OfUnordDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
+        private final DoubleBinaryOperator op;
+        private final Spliterator.OfDouble source;
+        int idx = 0;
+        private boolean started;
+        AtomicDouble accRef;
+        private double acc;
+        
+        OfUnordDouble(Spliterator.OfDouble source, DoubleBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public Spliterator.OfDouble trySplit() {
+            if (started) {
+                return null;
+            }
+            OfDouble prefix = source.trySplit();
+            if (prefix == null) {
+                return null;
+            }
+            if (accRef == null) {
+                accRef = new AtomicDouble();
+            }
+            OfUnordDouble pref = new OfUnordDouble(prefix, op);
+            pref.accRef = accRef;
+            return pref;
+        }
+        
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            if (!source.tryAdvance(this)) {
+                return false;
+            }
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            if (accRef == null) {
+                source.forEachRemaining((DoubleConsumer) next -> action.accept(acc = op.applyAsDouble(acc, next)));
+            } else {
+                double[] buf = new double[BUF_SIZE];
+                source.forEachRemaining((DoubleConsumer) next -> {
+                    if (idx == 0) {
+                        buf[idx++] = next;
+                    } else {
+                        double prev = buf[idx - 1];
+                        buf[idx++] = op.applyAsDouble(prev, next);
+                        if (idx == buf.length) {
+                            drain(action, buf);
+                            idx = 0;
+                        }
+                    }
+                });
+                if (idx > 0)
+                    drain(action, buf);
+            }
+        }
+        
+        private void drain(DoubleConsumer action, double[] buf) {
+            double last = buf[idx - 1];
+            double acc = accRef.getAndAccumulate(last, op);
+            for (int i = 0; i < idx; i++) {
+                action.accept(op.applyAsDouble(buf[i], acc));
+            }
+        }
+        
+        @Override
+        public void accept(double next) {
+            if (accRef == null) {
+                acc = op.applyAsDouble(acc, next);
+                started = true;
+            } else {
+                acc = accRef.accumulateAndGet(next, op);
+            }
+        }
+        
+        @Override
+        public long estimateSize() {
+            return source.estimateSize();
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index 455043d..10523e5 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -1,525 +1,527 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.nio.DoubleBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.OptionalDouble;
-import java.util.PrimitiveIterator.OfDouble;
-import java.util.Random;
-import java.util.Scanner;
-import java.util.Spliterator;
-import java.util.Spliterators;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.DoubleBinaryOperator;
-import java.util.function.DoubleFunction;
-import java.util.function.DoubleToIntFunction;
-import java.util.function.DoubleToLongFunction;
-import java.util.function.DoubleUnaryOperator;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.DoubleStream;
-import java.util.stream.DoubleStream.Builder;
-import java.util.stream.LongStream;
-
-import org.junit.FixMethodOrder;
-import org.junit.Test;
-import org.junit.runners.MethodSorters;
-
-import static one.util.streamex.TestHelpers.checkSpliterator;
-import static one.util.streamex.TestHelpers.streamEx;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Tagir Valeev
- */
-@FixMethodOrder(MethodSorters.NAME_ASCENDING)
-public class DoubleStreamExTest {
-    @Test
-    public void testCreate() {
-        assertArrayEquals(new double[] {}, DoubleStreamEx.empty().toArray(), 0.0);
-        // double check is intended
-        assertArrayEquals(new double[] {}, DoubleStreamEx.empty().toArray(), 0.0);
-        assertArrayEquals(new double[] { 1 }, DoubleStreamEx.of(1).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1 }, DoubleStreamEx.of(OptionalDouble.of(1)).toArray(), 0.0);
-        assertArrayEquals(new double[] {}, DoubleStreamEx.of(OptionalDouble.empty()).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).toArray(), 0.0);
-        assertArrayEquals(new double[] { 4, 6 }, DoubleStreamEx.of(new double[] { 2, 4, 6, 8, 10 }, 1, 3).toArray(),
-            0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1.0f, 2.0f, 3.0f).toArray(), 0.0);
-        assertArrayEquals(new double[] { 4, 6 }, DoubleStreamEx.of(new float[] { 2.0f, 4.0f, 6.0f, 8.0f, 10.0f }, 1, 3)
-                .toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(DoubleStream.of(1, 2, 3)).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(Arrays.asList(1.0, 2.0, 3.0)).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 4, 8, 16 }, DoubleStreamEx.iterate(1, x -> x * 2).limit(5).toArray(),
-            0.0);
-        assertArrayEquals(new double[] { 1, 1, 1, 1 }, DoubleStreamEx.generate(() -> 1).limit(4).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 1, 1, 1 }, DoubleStreamEx.constant(1.0, 4).toArray(), 0.0);
-        assertEquals(10, DoubleStreamEx.of(new Random(), 10).count());
-        assertArrayEquals(DoubleStreamEx.of(new Random(1), 10).toArray(), DoubleStreamEx.of(new Random(1)).limit(10)
-                .toArray(), 0.0);
-        assertTrue(DoubleStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
-        assertArrayEquals(DoubleStreamEx.of(new Random(1), 100, 1, 10).toArray(), DoubleStreamEx.of(new Random(1), 1,
-            10).limit(100).toArray(), 0.0);
-
-        DoubleStream stream = DoubleStreamEx.of(1, 2, 3);
-        assertSame(stream, DoubleStreamEx.of(stream));
-
-        assertArrayEquals(new double[] { 1, 5, 3 }, DoubleStreamEx.of(
-            Spliterators.spliterator(new double[] { 1, 5, 3 }, 0)).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 5, 3 }, DoubleStreamEx.of(
-            Spliterators.iterator(Spliterators.spliterator(new double[] { 1, 5, 3 }, 0))).toArray(), 0.0);
-        assertArrayEquals(new double[0], DoubleStreamEx
-                .of(Spliterators.iterator(Spliterators.emptyDoubleSpliterator())).parallel().toArray(), 0.0);
-
-        assertArrayEquals(new double[] { 2, 4, 6 }, DoubleStreamEx.of(new Double[] { 2.0, 4.0, 6.0 }).toArray(), 0.0);
-    }
-
-    @Test
-    public void testOfDoubleBuffer() {
-        double[] data = LongStreamEx.range(100).asDoubleStream().toArray();
-        assertArrayEquals(data, DoubleStreamEx.of(DoubleBuffer.wrap(data)).toArray(), 0.0);
-        assertArrayEquals(LongStreamEx.range(50, 70).asDoubleStream().toArray(), DoubleStreamEx.of(DoubleBuffer.wrap(
-            data, 50, 20)).toArray(), 0.0);
-        assertArrayEquals(data, DoubleStreamEx.of(DoubleBuffer.wrap(data)).parallel().toArray(), 0.0);
-        assertArrayEquals(LongStreamEx.range(50, 70).asDoubleStream().toArray(), DoubleStreamEx.of(DoubleBuffer.wrap(
-            data, 50, 20)).parallel().toArray(), 0.0);
-    }
-    
-    @Test
-    public void testIterate() {
-        assertArrayEquals(new double[] { 1, 2, 4, 8, 16 }, DoubleStreamEx.iterate(1, x -> x * 2).limit(5).toArray(),
-            0.0);
-        assertArrayEquals(new double[] { 1, 2, 4, 8, 16, 32, 64 }, DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2)
-                .toArray(), 0.0);
-        assertEquals(0, DoubleStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
-        assertFalse(DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).findFirst(x -> x == 10).isPresent());
-        checkSpliterator("iterate", () -> DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
-    }
-
-    @Test
-    public void testBasics() {
-        assertFalse(DoubleStreamEx.of(1).isParallel());
-        assertTrue(DoubleStreamEx.of(1).parallel().isParallel());
-        assertFalse(DoubleStreamEx.of(1).parallel().sequential().isParallel());
-        AtomicInteger i = new AtomicInteger();
-        try (DoubleStreamEx s = DoubleStreamEx.of(1).onClose(i::incrementAndGet)) {
-            assertEquals(1, s.count());
-        }
-        assertEquals(1, i.get());
-        assertEquals(6, IntStreamEx.range(0, 4).asDoubleStream().sum(), 0);
-        assertEquals(3, IntStreamEx.range(0, 4).asDoubleStream().max().getAsDouble(), 0);
-        assertEquals(0, IntStreamEx.range(0, 4).asDoubleStream().min().getAsDouble(), 0);
-        assertEquals(1.5, IntStreamEx.range(0, 4).asDoubleStream().average().getAsDouble(), 0.000001);
-        assertEquals(4, IntStreamEx.range(0, 4).asDoubleStream().summaryStatistics().getCount());
-        assertArrayEquals(new double[] { 1, 2, 3 },
-            IntStreamEx.range(0, 5).asDoubleStream().skip(1).limit(3).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(3, 1, 2).sorted().toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1, 2, 1, 3, 2).distinct().toArray(), 0.0);
-        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().mapToInt(x -> (int) x * 2)
-                .toArray());
-        assertArrayEquals(new long[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().mapToLong(x -> (long) x * 2)
-                .toArray());
-        assertArrayEquals(new double[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().map(x -> x * 2).toArray(),
-            0.0);
-        assertArrayEquals(new double[] { 1, 3 }, IntStreamEx.range(0, 5).asDoubleStream().filter(x -> x % 2 == 1)
-                .toArray(), 0.0);
-        assertEquals(6.0, DoubleStreamEx.of(1.0, 2.0, 3.0).reduce(Double::sum).getAsDouble(), 0.0);
-        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(1, Long.MAX_VALUE).asDoubleStream().spliterator()
-                .getExactSizeIfKnown());
-
-        assertArrayEquals(new double[] { 4, 2, 0, -2, -4 }, DoubleStreamEx.zip(new double[] { 5, 4, 3, 2, 1 },
-            new double[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray(), 0.0);
-        assertEquals("1.0; 0.5; 0.25; 0.125", DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).mapToObj(String::valueOf)
-                .joining("; "));
-        List<Double> list = new ArrayList<>();
-        DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).forEach(list::add);
-        assertEquals(Arrays.asList(1.0, 0.5, 0.25, 0.125), list);
-        list = new ArrayList<>();
-        DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).parallel().forEachOrdered(list::add);
-        assertEquals(Arrays.asList(1.0, 0.5, 0.25, 0.125), list);
-
-        assertFalse(DoubleStreamEx.of(1.0, 2.0, 2.5).anyMatch(x -> x < 0.0));
-        assertTrue(DoubleStreamEx.of(1.0, 2.0, 2.5).anyMatch(x -> x >= 2.5));
-        assertTrue(DoubleStreamEx.of(1.0, 2.0, 2.5).noneMatch(x -> x < 0.0));
-        assertFalse(DoubleStreamEx.of(1.0, 2.0, 2.5).noneMatch(x -> x >= 2.5));
-        assertEquals(5.0, DoubleStreamEx.of(1.0, 2.0, 2.5).reduce(1, (a, b) -> a * b), 0.0);
-
-        assertTrue(DoubleStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
-        assertFalse(DoubleStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
-
-        OfDouble iterator = DoubleStreamEx.of(1.0, 2.0, 3.0).iterator();
-        assertEquals(1.0, iterator.next(), 0.0);
-        assertEquals(2.0, iterator.next(), 0.0);
-        assertEquals(3.0, iterator.next(), 0.0);
-        assertFalse(iterator.hasNext());
-    }
-
-    @Test
-    public void testForEach() {
-        streamEx(() -> StreamEx.of(1, 2, 3), s -> {
-            AtomicInteger count = new AtomicInteger(0);
-            s.get().mapToDouble(Integer::intValue).forEach(v -> count.addAndGet((int) v));
-            assertEquals(6, count.get());
-            s.get().mapToDouble(Integer::intValue).pairMap((a, b) -> b - a).forEach(v -> count.addAndGet((int) v));
-            assertEquals(8, count.get());
-        });
-    }
-
-    @Test
-    public void testFlatMap() {
-        assertArrayEquals(new int[] { 1, 5, 2, 3, 3, 2, 0, 9 }, DoubleStreamEx.of(1.5, 2.3, 3.2, 0.9).flatMapToInt(
-            x -> IntStreamEx.of((int) Math.floor(x), (int) (Math.round(10 * (x - Math.floor(x)))))).toArray());
-        assertEquals("1:.:5:2:2:.:3:3:.:2:0:.:9", DoubleStreamEx.of(1.5, 22.3, 3.2, 0.9).flatMapToObj(
-            x -> StreamEx.split(String.valueOf(x), "")).joining(":"));
-
-        assertArrayEquals(new double[] { 0.0, 0.0, 1.0, 0.0, 1.0, 2.0 }, DoubleStreamEx.of(1, 2, 3).flatMap(
-            x -> IntStreamEx.range((int) x).asDoubleStream()).toArray(), 0.0);
-
-        assertArrayEquals(new long[] { 0x3FF0000000000000L, 0x3FF0000000000000L, 0x4000000000000000L,
-                0x4000000000000000L, 0x7FF8000000000000L, 0x7FF8000000000000L }, DoubleStreamEx.of(1, 2, Double.NaN)
-                .flatMapToLong(x -> LongStream.of(Double.doubleToLongBits(x), Double.doubleToRawLongBits(x))).toArray());
-    }
-
-    @Test
-    public void testPrepend() {
-        assertArrayEquals(new double[] { -1, 0, 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).prepend(-1, 0).toArray(), 0.0);
-        assertArrayEquals(new double[] { -1, 0, 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).prepend(DoubleStream.of(-1, 0))
-                .toArray(), 0.0);
-        DoubleStreamEx s = DoubleStreamEx.of(1, 2, 3);
-        assertSame(s, s.prepend());
-    }
-
-    @Test
-    public void testAppend() {
-        assertArrayEquals(new double[] { 1, 2, 3, 4, 5 }, DoubleStreamEx.of(1, 2, 3).append(4, 5).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 2, 3, 4, 5 }, DoubleStreamEx.of(1, 2, 3).append(DoubleStream.of(4, 5))
-                .toArray(), 0.0);
-        DoubleStreamEx s = DoubleStreamEx.of(1, 2, 3);
-        assertSame(s, s.append());
-    }
-
-    @Test
-    public void testRanges() {
-        assertArrayEquals(new double[] { 5, 4, Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
-            Double.POSITIVE_INFINITY).greater(3).toArray(), 0.0);
-        assertArrayEquals(new double[] {}, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY).greater(
-            Double.POSITIVE_INFINITY).toArray(), 0.0);
-        assertArrayEquals(new double[] { 5, 3, 4, Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
-            Double.POSITIVE_INFINITY).atLeast(3).toArray(), 0.0);
-        assertArrayEquals(new double[] { Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
-            Double.POSITIVE_INFINITY).atLeast(Double.POSITIVE_INFINITY).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY).less(3)
-                .toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 3, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY)
-                .atMost(3).toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 3, 4, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY)
-                .atMost(4).toArray(), 0.0);
-    }
-
-    @Test
-    public void testFind() {
-        assertEquals(6.0, LongStreamEx.range(1, 10).asDoubleStream().findFirst(i -> i > 5).getAsDouble(), 0.0);
-        assertFalse(LongStreamEx.range(1, 10).asDoubleStream().findAny(i -> i > 10).isPresent());
-    }
-
-    @Test
-    public void testRemove() {
-        assertArrayEquals(new double[] { 1, 2 }, DoubleStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray(), 0.0);
-    }
-
-    @Test
-    public void testSort() {
-        assertArrayEquals(new double[] { 3, 2, 1 }, DoubleStreamEx.of(1, 2, 3).sortedByDouble(x -> -x).toArray(), 0.0);
-        assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.POSITIVE_INFINITY, Double.MAX_VALUE, 1000, 1,
-                Double.MIN_VALUE, 0, -0.0, -Double.MIN_VALUE * 3, -10, -Double.MAX_VALUE / 1.1, -Double.MAX_VALUE,
-                Double.NEGATIVE_INFINITY }, DoubleStreamEx.of(0, 1, -Double.MIN_VALUE * 3, 1000, -10,
-            -Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY, Double.NaN,
-            Double.MAX_VALUE, -0.0, Double.MIN_VALUE, -Double.MAX_VALUE / 1.1).reverseSorted().toArray(), 0.0);
-        assertArrayEquals(new double[] { 1, 10, 2, 21, 9 }, DoubleStreamEx.of(1, 10, 2, 9, 21)
-                .sortedBy(String::valueOf).toArray(), 0.0);
-
-        assertArrayEquals(new double[] { 0.4, 1.5, 1.3, 2.3, 2.1, 2.0, 3.7 }, DoubleStreamEx.of(1.5, 2.3, 1.3, 2.1,
-            3.7, 0.4, 2.0).sortedByInt(x -> (int) x).toArray(), 0.0);
-
-        assertArrayEquals(new double[] { 0.4, 1.5, 1.3, 2.3, 2.1, 2.0, 3.7 }, DoubleStreamEx.of(1.5, 2.3, 1.3, 2.1,
-            3.7, 0.4, 2.0).sortedByLong(x -> (long) x).toArray(), 0.0);
-    }
-
-    @SafeVarargs
-    private static void checkEmpty(Function<DoubleStreamEx, OptionalDouble>... fns) {
-        int i = 0;
-        for (Function<DoubleStreamEx, OptionalDouble> fn : fns) {
-            assertFalse("#" + i, fn.apply(DoubleStreamEx.empty()).isPresent());
-            assertFalse("#" + i, fn.apply(DoubleStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
-            assertEquals("#" + i, 10, fn.apply(DoubleStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
-                    .getAsDouble(), 0.0);
-            i++;
-        }
-    }
-
-    @Test
-    public void testMinMax() {
-        checkEmpty(s -> s.maxBy(Double::valueOf), s -> s.maxByInt(x -> (int) x), s -> s.maxByLong(x -> (long) x),
-            s -> s.maxByDouble(x -> x), s -> s.minBy(Double::valueOf), s -> s.minByInt(x -> (int) x), s -> s
-                    .minByLong(x -> (long) x), s -> s.minByDouble(x -> x));
-        assertEquals(9, IntStreamEx.range(5, 12).asDoubleStream().max(
-                Comparator.comparing(String::valueOf)).getAsDouble(), 0.0);
-        assertEquals(10, IntStreamEx.range(5, 12).asDoubleStream().min(
-                Comparator.comparing(String::valueOf)).getAsDouble(), 0.0);
-        assertEquals(9, IntStreamEx.range(5, 12).asDoubleStream().maxBy(String::valueOf).getAsDouble(), 0.0);
-        assertEquals(10, IntStreamEx.range(5, 12).asDoubleStream().minBy(String::valueOf).getAsDouble(), 0.0);
-        assertEquals(5, IntStreamEx.range(5, 12).asDoubleStream().maxByDouble(x -> 1.0 / x).getAsDouble(), 0.0);
-        assertEquals(11, IntStreamEx.range(5, 12).asDoubleStream().minByDouble(x -> 1.0 / x).getAsDouble(), 0.0);
-        assertEquals(29.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> (int) (x % 10 * 10 + x / 10))
-                .getAsDouble(), 0.0);
-        assertEquals(31.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> (int) (x % 10 * 10 + x / 10))
-                .getAsDouble(), 0.0);
-        assertEquals(29.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> (long) (x % 10 * 10 + x / 10))
-                .getAsDouble(), 0.0);
-        assertEquals(31.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> (long) (x % 10 * 10 + x / 10))
-                .getAsDouble(), 0.0);
-
-        Supplier<DoubleStreamEx> s = () -> DoubleStreamEx.of(1, 50, 120, 35, 130, 12, 0);
-        DoubleToIntFunction intKey = x -> String.valueOf(x).length();
-        DoubleToLongFunction longKey = x -> String.valueOf(x).length();
-        DoubleUnaryOperator doubleKey = x -> String.valueOf(x).length();
-        DoubleFunction<Integer> objKey = x -> String.valueOf(x).length();
-        List<Function<DoubleStreamEx, OptionalDouble>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
-                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
-        List<Function<DoubleStreamEx, OptionalDouble>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
-                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsDouble(), 0.0));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsDouble(), 0.0));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsDouble(), 0.0));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsDouble(), 0.0));
-    }
-
-    @Test
-    public void testPairMap() {
-        assertEquals(0, DoubleStreamEx.of().pairMap(Double::sum).count());
-        assertEquals(0, DoubleStreamEx.of(1.0).pairMap(Double::sum).count());
-        int[] data = new Random(1).ints(1000, 1, 1000).toArray();
-        double[] expected = new double[data.length - 1];
-        for (int i = 0; i < expected.length; i++)
-            expected[i] = (data[i + 1] - data[i]) * 1.23;
-        double[] result = IntStreamEx.of(data).parallel().asDoubleStream().pairMap((a, b) -> (b - a) * 1.23).toArray();
-        assertArrayEquals(expected, result, 0.0);
-        result = IntStreamEx.of(data).asDoubleStream().pairMap((a, b) -> (b - a) * 1.23).toArray();
-        assertArrayEquals(expected, result, 0.0);
-        assertEquals(984.0, IntStreamEx.of(data).asDoubleStream().parallel().pairMap((a, b) -> Math.abs(a - b)).max()
-                .getAsDouble(), 0.0);
-        assertArrayEquals(new double[] { 1.0, 1.0 }, DoubleStreamEx.of(1.0, 2.0, 3.0).append().parallel().pairMap(
-            (a, b) -> b - a).toArray(), 0.0);
-
-        assertArrayEquals(LongStreamEx.range(1, 100).asDoubleStream().toArray(), LongStreamEx.range(100).map(
-            i -> i * (i + 1) / 2).append(LongStream.empty()).asDoubleStream().parallel().pairMap((a, b) -> b - a)
-                .toArray(), 0.0);
-        assertArrayEquals(LongStreamEx.range(1, 100).asDoubleStream().toArray(), LongStreamEx.range(100).map(
-            i -> i * (i + 1) / 2).prepend(LongStream.empty()).asDoubleStream().parallel().pairMap((a, b) -> b - a)
-                .toArray(), 0.0);
-
-        assertEquals(1, LongStreamEx.range(1000).mapToDouble(x -> x * x).pairMap((a, b) -> b - a).pairMap(
-            (a, b) -> b - a).distinct().count());
-
-        assertFalse(LongStreamEx.range(1000).asDoubleStream().greater(2000).parallel().pairMap((a, b) -> a).findFirst()
-                .isPresent());
-    }
-
-    @Test
-    public void testToFloatArray() {
-        float[] expected = new float[10000];
-        for (int i = 0; i < expected.length; i++)
-            expected[i] = i;
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().toFloatArray(), 0.0f);
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().parallel().toFloatArray(), 0.0f);
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().greater(-1).toFloatArray(), 0.0f);
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().parallel().greater(-1).toFloatArray(),
-            0.0f);
-        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
-        assertArrayEquals(Arrays.copyOf(expected, 100), 
-            IntStreamEx.range(0, 100).asDoubleStream().parallel().toFloatArray(), 0.0f);
-    }
-
-    @Test
-    public void testJoining() {
-        assertEquals("0.4,5.0,3.6,4.8", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).joining(","));
-        assertEquals("0.4,5.0,3.6,4.8", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).parallel().joining(","));
-        assertEquals("[0.4,5.0,3.6,4.8]", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).joining(",", "[", "]"));
-        assertEquals("[0.4,5.0,3.6,4.8]", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).parallel().joining(",", "[", "]"));
-    }
-
-    @Test
-    public void testMapToEntry() {
-        Map<Integer, List<Double>> map = DoubleStreamEx.of(0.3, 0.5, 1.3, 0.7, 1.9, 2.1).mapToEntry(x -> (int) x,
-            x -> x).grouping();
-        assertEquals(Arrays.asList(0.3, 0.5, 0.7), map.get(0));
-        assertEquals(Arrays.asList(1.3, 1.9), map.get(1));
-        assertEquals(Arrays.asList(2.1), map.get(2));
-    }
-
-    @Test
-    public void testTakeWhile() {
-        assertArrayEquals(LongStreamEx.range(100).asDoubleStream().toArray(), DoubleStreamEx.iterate(0, i -> i + 1)
-                .takeWhile(i -> i < 100).toArray(), 0.0);
-        assertEquals(0, DoubleStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
-        assertEquals(1, DoubleStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
-        assertEquals(3, DoubleStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
-    }
-
-    @Test
-    public void testTakeWhileInclusive() {
-        assertArrayEquals(LongStreamEx.range(101).asDoubleStream().toArray(), DoubleStreamEx.iterate(0, i -> i + 1)
-            .takeWhileInclusive(i -> i < 100).toArray(), 0.0);
-        assertEquals(1, DoubleStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
-        assertEquals(2, DoubleStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
-        assertEquals(3, DoubleStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
-    }
-    
-    @Test
-    public void testDropWhile() {
-        assertArrayEquals(new double[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, LongStreamEx.range(100).asDoubleStream()
-                .dropWhile(i -> i % 10 < 5).limit(10).toArray(), 0.0);
-        assertEquals(100, LongStreamEx.range(100).asDoubleStream().sorted().dropWhile(i -> i % 10 < 0).count());
-        assertEquals(0, LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 10).count());
-        assertEquals(OptionalDouble.of(0), LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 0).findFirst());
-        assertEquals(OptionalDouble.empty(), LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 10).findFirst());
-
-        java.util.Spliterator.OfDouble spltr = LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 1).spliterator();
-        assertTrue(spltr.tryAdvance((double x) -> assertEquals(1, x, 0.0)));
-        Builder builder = DoubleStream.builder();
-        spltr.forEachRemaining(builder);
-        assertArrayEquals(LongStreamEx.range(2, 100).asDoubleStream().toArray(), builder.build().toArray(), 0.0);
-    }
-
-    @Test
-    public void testIndexOf() {
-        assertEquals(11, LongStreamEx.range(50, 100).asDoubleStream().indexOf(x -> x > 60).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).asDoubleStream().indexOf(x -> x < 0).isPresent());
-        assertEquals(11, LongStreamEx.range(50, 100).asDoubleStream().parallel().indexOf(x -> x > 60).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).asDoubleStream().parallel().indexOf(x -> x < 0).isPresent());
-    }
-
-    @Test
-    public void testFoldLeft() {
-        // non-associative
-        DoubleBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
-        assertEquals(2322576, DoubleStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1), 0.0);
-        assertEquals(2322576, DoubleStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1), 0.0);
-        assertFalse(DoubleStreamEx.empty().foldLeft(accumulator).isPresent());
-        assertEquals(144, DoubleStreamEx.of(1, 2, 3).foldLeft(0.0, accumulator), 144);
-        assertEquals(144, DoubleStreamEx.of(1, 2, 3).parallel().foldLeft(0.0, accumulator), 144);
-    }
-
-    @Test
-    public void testMapFirstLast() {
-        assertArrayEquals(new double[] { -1, 2, 3, 4, 7 }, DoubleStreamEx.of(1, 2, 3, 4, 5).mapFirst(x -> x - 2.0)
-                .mapLast(x -> x + 2.0).toArray(), 0.0);
-    }
-
-    @Test
-    public void testPeekFirst() {
-        double[] input = {1, 10, 100, 1000};
-        
-        AtomicReference<Double> firstElement = new AtomicReference<>();
-        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray(), 0.0);
-        assertEquals(1, firstElement.get(), 0.0);
-
-        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray(), 0.0);
-        assertEquals(10, firstElement.get(), 0.0);
-        
-        firstElement.set(-1.0);
-        assertArrayEquals(new double[] {}, DoubleStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray(), 0.0);
-        assertEquals(-1, firstElement.get(), 0.0);
-    }
-    
-    @Test
-    public void testPeekLast() {
-        double[] input = {1, 10, 100, 1000};
-        AtomicReference<Double> lastElement = new AtomicReference<>();
-        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray(), 0.0);
-        assertNull(lastElement.get());
-
-        assertArrayEquals(new double[] { 1, 10, 100 }, DoubleStreamEx.of(input).less(1000).peekLast(lastElement::set)
-                .limit(3).toArray(), 0.0);
-        assertEquals(100, lastElement.get(), 0.0);
-        
-        assertArrayEquals(input, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray(), 0.0);
-        assertEquals(1000, lastElement.get(), 0.0);
-        
-        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray(), 0.0);
-        assertEquals(100, lastElement.get(), 0.0);
-    }
-    
-    @Test
-    public void testScanLeft() {
-        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
-                .scanLeft(Double::sum), 0.0);
-        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
-                .parallel().scanLeft(Double::sum), 0.0);
-        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
-                .filter(x -> true).scanLeft(Double::sum), 0.0);
-        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
-                .filter(x -> true).parallel().scanLeft(Double::sum), 0.0);
-        assertArrayEquals(new double[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).asDoubleStream()
-                .scanLeft(1, (a, b) -> a * b), 0.0);
-        assertArrayEquals(new double[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).asDoubleStream()
-                .parallel().scanLeft(1, (a, b) -> a * b), 0.0);
-    }
-
-    // Reads numbers from scanner stopping when non-number is encountered
-    // leaving scanner in known state
-    private static DoubleStreamEx scannerDoubles(Scanner sc) {
-        return DoubleStreamEx.produce(action -> {
-            if (sc.hasNextDouble())
-                action.accept(sc.nextDouble());
-            return sc.hasNextDouble();
-        });
-    }
-
-    @Test
-    public void testProduce() {
-        Scanner sc = new Scanner("1.0 2.5 3 -4.6 test");
-        sc.useLocale(Locale.ENGLISH);
-        assertArrayEquals(new double[] {1, 2.5, 3, -4.6}, scannerDoubles(sc).stream().toArray(), 0.0);
-        assertEquals("test", sc.next());
-    }
-
-    @Test
-    public void testPrefix() {
-        assertArrayEquals(new double[] { 1, 3, 6, 10, 20 }, DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).toArray(), 0.0);
-        assertEquals(OptionalDouble.of(10), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 7));
-        assertEquals(OptionalDouble.empty(), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 20));
-    }
-    
-    @Test
-    public void testIntersperse() {
-        assertArrayEquals(new double[] { 1, 0, 10, 0, 100, 0, 1000 }, DoubleStreamEx.of(1, 10, 100, 1000).intersperse(0)
-                .toArray(), 0.0);
-        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.nio.DoubleBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.OptionalDouble;
+import java.util.PrimitiveIterator.OfDouble;
+import java.util.Random;
+import java.util.Scanner;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleFunction;
+import java.util.function.DoubleToIntFunction;
+import java.util.function.DoubleToLongFunction;
+import java.util.function.DoubleUnaryOperator;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.DoubleStream;
+import java.util.stream.DoubleStream.Builder;
+import java.util.stream.LongStream;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import static one.util.streamex.TestHelpers.checkSpliterator;
+import static one.util.streamex.TestHelpers.streamEx;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Tagir Valeev
+ */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class DoubleStreamExTest {
+    @Test
+    public void testCreate() {
+        assertArrayEquals(new double[] {}, DoubleStreamEx.empty().toArray(), 0.0);
+        // double check is intended
+        assertArrayEquals(new double[] {}, DoubleStreamEx.empty().toArray(), 0.0);
+        assertArrayEquals(new double[] { 1 }, DoubleStreamEx.of(1).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1 }, DoubleStreamEx.of(OptionalDouble.of(1)).toArray(), 0.0);
+        assertArrayEquals(new double[] {}, DoubleStreamEx.of(OptionalDouble.empty()).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).toArray(), 0.0);
+        assertArrayEquals(new double[] { 4, 6 }, DoubleStreamEx.of(new double[] { 2, 4, 6, 8, 10 }, 1, 3).toArray(),
+            0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1.0f, 2.0f, 3.0f).toArray(), 0.0);
+        assertArrayEquals(new double[] { 4, 6 }, DoubleStreamEx.of(new float[] { 2.0f, 4.0f, 6.0f, 8.0f, 10.0f }, 1, 3)
+                .toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(DoubleStream.of(1, 2, 3)).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(Arrays.asList(1.0, 2.0, 3.0)).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 4, 8, 16 }, DoubleStreamEx.iterate(1, x -> x * 2).limit(5).toArray(),
+            0.0);
+        assertArrayEquals(new double[] { 1, 1, 1, 1 }, DoubleStreamEx.generate(() -> 1).limit(4).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 1, 1, 1 }, DoubleStreamEx.constant(1.0, 4).toArray(), 0.0);
+        assertEquals(10, DoubleStreamEx.of(new Random(), 10).count());
+        assertArrayEquals(DoubleStreamEx.of(new Random(1), 10).toArray(), DoubleStreamEx.of(new Random(1)).limit(10)
+                .toArray(), 0.0);
+        assertTrue(DoubleStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
+        assertArrayEquals(DoubleStreamEx.of(new Random(1), 100, 1, 10).toArray(), DoubleStreamEx.of(new Random(1), 1,
+            10).limit(100).toArray(), 0.0);
+
+        DoubleStream stream = DoubleStreamEx.of(1, 2, 3);
+        assertSame(stream, DoubleStreamEx.of(stream));
+
+        assertArrayEquals(new double[] { 1, 5, 3 }, DoubleStreamEx.of(
+            Spliterators.spliterator(new double[] { 1, 5, 3 }, 0)).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 5, 3 }, DoubleStreamEx.of(
+            Spliterators.iterator(Spliterators.spliterator(new double[] { 1, 5, 3 }, 0))).toArray(), 0.0);
+        assertArrayEquals(new double[0], DoubleStreamEx
+                .of(Spliterators.iterator(Spliterators.emptyDoubleSpliterator())).parallel().toArray(), 0.0);
+
+        assertArrayEquals(new double[] { 2, 4, 6 }, DoubleStreamEx.of(new Double[] { 2.0, 4.0, 6.0 }).toArray(), 0.0);
+    }
+
+    @Test
+    public void testOfDoubleBuffer() {
+        double[] data = LongStreamEx.range(100).asDoubleStream().toArray();
+        assertArrayEquals(data, DoubleStreamEx.of(DoubleBuffer.wrap(data)).toArray(), 0.0);
+        assertArrayEquals(LongStreamEx.range(50, 70).asDoubleStream().toArray(), DoubleStreamEx.of(DoubleBuffer.wrap(
+            data, 50, 20)).toArray(), 0.0);
+        assertArrayEquals(data, DoubleStreamEx.of(DoubleBuffer.wrap(data)).parallel().toArray(), 0.0);
+        assertArrayEquals(LongStreamEx.range(50, 70).asDoubleStream().toArray(), DoubleStreamEx.of(DoubleBuffer.wrap(
+            data, 50, 20)).parallel().toArray(), 0.0);
+    }
+    
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new double[] { 1, 2, 4, 8, 16 }, DoubleStreamEx.iterate(1, x -> x * 2).limit(5).toArray(),
+            0.0);
+        assertArrayEquals(new double[] { 1, 2, 4, 8, 16, 32, 64 }, DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2)
+                .toArray(), 0.0);
+        assertEquals(0, DoubleStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).findFirst(x -> x == 10).isPresent());
+        checkSpliterator("iterate", () -> DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+
+    @Test
+    public void testBasics() {
+        assertFalse(DoubleStreamEx.of(1).isParallel());
+        assertTrue(DoubleStreamEx.of(1).parallel().isParallel());
+        assertFalse(DoubleStreamEx.of(1).parallel().sequential().isParallel());
+        AtomicInteger i = new AtomicInteger();
+        try (DoubleStreamEx s = DoubleStreamEx.of(1).onClose(i::incrementAndGet)) {
+            assertEquals(1, s.count());
+        }
+        assertEquals(1, i.get());
+        assertEquals(6, IntStreamEx.range(0, 4).asDoubleStream().sum(), 0);
+        assertEquals(3, IntStreamEx.range(0, 4).asDoubleStream().max().getAsDouble(), 0);
+        assertEquals(0, IntStreamEx.range(0, 4).asDoubleStream().min().getAsDouble(), 0);
+        assertEquals(1.5, IntStreamEx.range(0, 4).asDoubleStream().average().getAsDouble(), 0.000001);
+        assertEquals(4, IntStreamEx.range(0, 4).asDoubleStream().summaryStatistics().getCount());
+        assertArrayEquals(new double[] { 1, 2, 3 },
+            IntStreamEx.range(0, 5).asDoubleStream().skip(1).limit(3).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(3, 1, 2).sorted().toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3 }, DoubleStreamEx.of(1, 2, 1, 3, 2).distinct().toArray(), 0.0);
+        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().mapToInt(x -> (int) x * 2)
+                .toArray());
+        assertArrayEquals(new long[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().mapToLong(x -> (long) x * 2)
+                .toArray());
+        assertArrayEquals(new double[] { 2, 4, 6 }, IntStreamEx.range(1, 4).asDoubleStream().map(x -> x * 2).toArray(),
+            0.0);
+        assertArrayEquals(new double[] { 1, 3 }, IntStreamEx.range(0, 5).asDoubleStream().filter(x -> x % 2 == 1)
+                .toArray(), 0.0);
+        assertEquals(6.0, DoubleStreamEx.of(1.0, 2.0, 3.0).reduce(Double::sum).getAsDouble(), 0.0);
+        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(1, Long.MAX_VALUE).asDoubleStream().spliterator()
+                .getExactSizeIfKnown());
+
+        assertArrayEquals(new double[] { 4, 2, 0, -2, -4 }, DoubleStreamEx.zip(new double[] { 5, 4, 3, 2, 1 },
+            new double[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray(), 0.0);
+        assertEquals("1.0; 0.5; 0.25; 0.125", DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).mapToObj(String::valueOf)
+                .joining("; "));
+        List<Double> list = new ArrayList<>();
+        DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).forEach(list::add);
+        assertEquals(Arrays.asList(1.0, 0.5, 0.25, 0.125), list);
+        list = new ArrayList<>();
+        DoubleStreamEx.of(1.0, 0.5, 0.25, 0.125).parallel().forEachOrdered(list::add);
+        assertEquals(Arrays.asList(1.0, 0.5, 0.25, 0.125), list);
+
+        assertFalse(DoubleStreamEx.of(1.0, 2.0, 2.5).anyMatch(x -> x < 0.0));
+        assertTrue(DoubleStreamEx.of(1.0, 2.0, 2.5).anyMatch(x -> x >= 2.5));
+        assertTrue(DoubleStreamEx.of(1.0, 2.0, 2.5).noneMatch(x -> x < 0.0));
+        assertFalse(DoubleStreamEx.of(1.0, 2.0, 2.5).noneMatch(x -> x >= 2.5));
+        assertEquals(5.0, DoubleStreamEx.of(1.0, 2.0, 2.5).reduce(1, (a, b) -> a * b), 0.0);
+
+        assertTrue(DoubleStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
+        assertFalse(DoubleStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
+
+        OfDouble iterator = DoubleStreamEx.of(1.0, 2.0, 3.0).iterator();
+        assertEquals(1.0, iterator.next(), 0.0);
+        assertEquals(2.0, iterator.next(), 0.0);
+        assertEquals(3.0, iterator.next(), 0.0);
+        assertFalse(iterator.hasNext());
+    }
+
+    @Test
+    public void testForEach() {
+        streamEx(() -> StreamEx.of(1, 2, 3), s -> {
+            AtomicInteger count = new AtomicInteger(0);
+            s.get().mapToDouble(Integer::intValue).forEach(v -> count.addAndGet((int) v));
+            assertEquals(6, count.get());
+            s.get().mapToDouble(Integer::intValue).pairMap((a, b) -> b - a).forEach(v -> count.addAndGet((int) v));
+            assertEquals(8, count.get());
+        });
+    }
+
+    @Test
+    public void testFlatMap() {
+        assertArrayEquals(new int[] { 1, 5, 2, 3, 3, 2, 0, 9 }, DoubleStreamEx.of(1.5, 2.3, 3.2, 0.9).flatMapToInt(
+            x -> IntStreamEx.of((int) Math.floor(x), (int) (Math.round(10 * (x - Math.floor(x)))))).toArray());
+        assertEquals("1:.:5:2:2:.:3:3:.:2:0:.:9", DoubleStreamEx.of(1.5, 22.3, 3.2, 0.9).flatMapToObj(
+            x -> StreamEx.split(String.valueOf(x), "")).joining(":"));
+
+        assertArrayEquals(new double[] { 0.0, 0.0, 1.0, 0.0, 1.0, 2.0 }, DoubleStreamEx.of(1, 2, 3).flatMap(
+            x -> IntStreamEx.range((int) x).asDoubleStream()).toArray(), 0.0);
+
+        assertArrayEquals(new long[] { 0x3FF0000000000000L, 0x3FF0000000000000L, 0x4000000000000000L,
+                0x4000000000000000L, 0x7FF8000000000000L, 0x7FF8000000000000L }, DoubleStreamEx.of(1, 2, Double.NaN)
+                .flatMapToLong(x -> LongStream.of(Double.doubleToLongBits(x), Double.doubleToRawLongBits(x))).toArray());
+    }
+
+    @Test
+    public void testPrepend() {
+        assertArrayEquals(new double[] { -1, 0, 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).prepend(-1, 0).toArray(), 0.0);
+        assertArrayEquals(new double[] { -1, 0, 1, 2, 3 }, DoubleStreamEx.of(1, 2, 3).prepend(DoubleStream.of(-1, 0))
+                .toArray(), 0.0);
+        DoubleStreamEx s = DoubleStreamEx.of(1, 2, 3);
+        assertSame(s, s.prepend());
+    }
+
+    @Test
+    public void testAppend() {
+        assertArrayEquals(new double[] { 1, 2, 3, 4, 5 }, DoubleStreamEx.of(1, 2, 3).append(4, 5).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 2, 3, 4, 5 }, DoubleStreamEx.of(1, 2, 3).append(DoubleStream.of(4, 5))
+                .toArray(), 0.0);
+        DoubleStreamEx s = DoubleStreamEx.of(1, 2, 3);
+        assertSame(s, s.append());
+    }
+
+    @Test
+    public void testRanges() {
+        assertArrayEquals(new double[] { 5, 4, Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
+            Double.POSITIVE_INFINITY).greater(3).toArray(), 0.0);
+        assertArrayEquals(new double[] {}, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY).greater(
+            Double.POSITIVE_INFINITY).toArray(), 0.0);
+        assertArrayEquals(new double[] { 5, 3, 4, Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
+            Double.POSITIVE_INFINITY).atLeast(3).toArray(), 0.0);
+        assertArrayEquals(new double[] { Double.POSITIVE_INFINITY }, DoubleStreamEx.of(1, 5, 3, 4, -1,
+            Double.POSITIVE_INFINITY).atLeast(Double.POSITIVE_INFINITY).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY).less(3)
+                .toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 3, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY)
+                .atMost(3).toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 3, 4, -1 }, DoubleStreamEx.of(1, 5, 3, 4, -1, Double.POSITIVE_INFINITY)
+                .atMost(4).toArray(), 0.0);
+    }
+
+    @Test
+    public void testFind() {
+        assertEquals(6.0, LongStreamEx.range(1, 10).asDoubleStream().findFirst(i -> i > 5).getAsDouble(), 0.0);
+        assertFalse(LongStreamEx.range(1, 10).asDoubleStream().findAny(i -> i > 10).isPresent());
+    }
+
+    @Test
+    public void testRemove() {
+        assertArrayEquals(new double[] { 1, 2 }, DoubleStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray(), 0.0);
+    }
+
+    @Test
+    public void testSort() {
+        assertArrayEquals(new double[] { 3, 2, 1 }, DoubleStreamEx.of(1, 2, 3).sortedByDouble(x -> -x).toArray(), 0.0);
+        assertArrayEquals(new double[] { Double.NaN, Double.NaN, Double.POSITIVE_INFINITY, Double.MAX_VALUE, 1000, 1,
+                Double.MIN_VALUE, 0, -0.0, -Double.MIN_VALUE * 3, -10, -Double.MAX_VALUE / 1.1, -Double.MAX_VALUE,
+                Double.NEGATIVE_INFINITY }, DoubleStreamEx.of(0, 1, -Double.MIN_VALUE * 3, 1000, -10,
+            -Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY, Double.NaN,
+            Double.MAX_VALUE, -0.0, Double.MIN_VALUE, -Double.MAX_VALUE / 1.1).reverseSorted().toArray(), 0.0);
+        assertArrayEquals(new double[] { 1, 10, 2, 21, 9 }, DoubleStreamEx.of(1, 10, 2, 9, 21)
+                .sortedBy(String::valueOf).toArray(), 0.0);
+
+        assertArrayEquals(new double[] { 0.4, 1.5, 1.3, 2.3, 2.1, 2.0, 3.7 }, DoubleStreamEx.of(1.5, 2.3, 1.3, 2.1,
+            3.7, 0.4, 2.0).sortedByInt(x -> (int) x).toArray(), 0.0);
+
+        assertArrayEquals(new double[] { 0.4, 1.5, 1.3, 2.3, 2.1, 2.0, 3.7 }, DoubleStreamEx.of(1.5, 2.3, 1.3, 2.1,
+            3.7, 0.4, 2.0).sortedByLong(x -> (long) x).toArray(), 0.0);
+    }
+
+    @SafeVarargs
+    private static void checkEmpty(Function<DoubleStreamEx, OptionalDouble>... fns) {
+        int i = 0;
+        for (Function<DoubleStreamEx, OptionalDouble> fn : fns) {
+            assertFalse("#" + i, fn.apply(DoubleStreamEx.empty()).isPresent());
+            assertFalse("#" + i, fn.apply(DoubleStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
+            assertEquals("#" + i, 10, fn.apply(DoubleStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
+                    .getAsDouble(), 0.0);
+            i++;
+        }
+    }
+
+    @Test
+    public void testMinMax() {
+        checkEmpty(s -> s.maxBy(Double::valueOf), s -> s.maxByInt(x -> (int) x), s -> s.maxByLong(x -> (long) x),
+            s -> s.maxByDouble(x -> x), s -> s.minBy(Double::valueOf), s -> s.minByInt(x -> (int) x), s -> s
+                    .minByLong(x -> (long) x), s -> s.minByDouble(x -> x));
+        assertEquals(9, IntStreamEx.range(5, 12).asDoubleStream().max(
+                Comparator.comparing(String::valueOf)).getAsDouble(), 0.0);
+        assertEquals(10, IntStreamEx.range(5, 12).asDoubleStream().min(
+                Comparator.comparing(String::valueOf)).getAsDouble(), 0.0);
+        assertEquals(9, IntStreamEx.range(5, 12).asDoubleStream().maxBy(String::valueOf).getAsDouble(), 0.0);
+        assertEquals(10, IntStreamEx.range(5, 12).asDoubleStream().minBy(String::valueOf).getAsDouble(), 0.0);
+        assertEquals(5, IntStreamEx.range(5, 12).asDoubleStream().maxByDouble(x -> 1.0 / x).getAsDouble(), 0.0);
+        assertEquals(11, IntStreamEx.range(5, 12).asDoubleStream().minByDouble(x -> 1.0 / x).getAsDouble(), 0.0);
+        assertEquals(29.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> (int) (x % 10 * 10 + x / 10))
+                .getAsDouble(), 0.0);
+        assertEquals(31.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> (int) (x % 10 * 10 + x / 10))
+                .getAsDouble(), 0.0);
+        assertEquals(29.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> (long) (x % 10 * 10 + x / 10))
+                .getAsDouble(), 0.0);
+        assertEquals(31.0, DoubleStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> (long) (x % 10 * 10 + x / 10))
+                .getAsDouble(), 0.0);
+
+        Supplier<DoubleStreamEx> s = () -> DoubleStreamEx.of(1, 50, 120, 35, 130, 12, 0);
+        DoubleToIntFunction intKey = x -> String.valueOf(x).length();
+        DoubleToLongFunction longKey = x -> String.valueOf(x).length();
+        DoubleUnaryOperator doubleKey = x -> String.valueOf(x).length();
+        DoubleFunction<Integer> objKey = x -> String.valueOf(x).length();
+        List<Function<DoubleStreamEx, OptionalDouble>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
+                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
+        List<Function<DoubleStreamEx, OptionalDouble>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
+                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsDouble(), 0.0));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsDouble(), 0.0));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsDouble(), 0.0));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsDouble(), 0.0));
+    }
+
+    @Test
+    public void testPairMap() {
+        assertEquals(0, DoubleStreamEx.of().pairMap(Double::sum).count());
+        assertEquals(0, DoubleStreamEx.of(1.0).pairMap(Double::sum).count());
+        int[] data = new Random(1).ints(1000, 1, 1000).toArray();
+        double[] expected = new double[data.length - 1];
+        for (int i = 0; i < expected.length; i++)
+            expected[i] = (data[i + 1] - data[i]) * 1.23;
+        double[] result = IntStreamEx.of(data).parallel().asDoubleStream().pairMap((a, b) -> (b - a) * 1.23).toArray();
+        assertArrayEquals(expected, result, 0.0);
+        result = IntStreamEx.of(data).asDoubleStream().pairMap((a, b) -> (b - a) * 1.23).toArray();
+        assertArrayEquals(expected, result, 0.0);
+        assertEquals(984.0, IntStreamEx.of(data).asDoubleStream().parallel().pairMap((a, b) -> Math.abs(a - b)).max()
+                .getAsDouble(), 0.0);
+        assertArrayEquals(new double[] { 1.0, 1.0 }, DoubleStreamEx.of(1.0, 2.0, 3.0).append().parallel().pairMap(
+            (a, b) -> b - a).toArray(), 0.0);
+
+        assertArrayEquals(LongStreamEx.range(1, 100).asDoubleStream().toArray(), LongStreamEx.range(100).map(
+            i -> i * (i + 1) / 2).append(LongStream.empty()).asDoubleStream().parallel().pairMap((a, b) -> b - a)
+                .toArray(), 0.0);
+        assertArrayEquals(LongStreamEx.range(1, 100).asDoubleStream().toArray(), LongStreamEx.range(100).map(
+            i -> i * (i + 1) / 2).prepend(LongStream.empty()).asDoubleStream().parallel().pairMap((a, b) -> b - a)
+                .toArray(), 0.0);
+
+        assertEquals(1, LongStreamEx.range(1000).mapToDouble(x -> x * x).pairMap((a, b) -> b - a).pairMap(
+            (a, b) -> b - a).distinct().count());
+
+        assertFalse(LongStreamEx.range(1000).asDoubleStream().greater(2000).parallel().pairMap((a, b) -> a).findFirst()
+                .isPresent());
+    }
+
+    @Test
+    public void testToFloatArray() {
+        float[] expected = new float[10000];
+        for (int i = 0; i < expected.length; i++)
+            expected[i] = i;
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().toFloatArray(), 0.0f);
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().parallel().toFloatArray(), 0.0f);
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().greater(-1).toFloatArray(), 0.0f);
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).asDoubleStream().parallel().greater(-1).toFloatArray(),
+            0.0f);
+        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
+        assertArrayEquals(Arrays.copyOf(expected, 100),
+            IntStreamEx.range(0, 100).asDoubleStream().parallel().toFloatArray(), 0.0f);
+    }
+
+    @Test
+    public void testJoining() {
+        assertEquals("0.4,5.0,3.6,4.8", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).joining(","));
+        assertEquals("0.4,5.0,3.6,4.8", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).parallel().joining(","));
+        assertEquals("[0.4,5.0,3.6,4.8]", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).joining(",", "[", "]"));
+        assertEquals("[0.4,5.0,3.6,4.8]", DoubleStreamEx.of(0.4, 5.0, 3.6, 4.8).parallel().joining(",", "[", "]"));
+    }
+
+    @Test
+    public void testMapToEntry() {
+        Map<Integer, List<Double>> map = DoubleStreamEx.of(0.3, 0.5, 1.3, 0.7, 1.9, 2.1).mapToEntry(x -> (int) x,
+            x -> x).grouping();
+        assertEquals(Arrays.asList(0.3, 0.5, 0.7), map.get(0));
+        assertEquals(Arrays.asList(1.3, 1.9), map.get(1));
+        assertEquals(Arrays.asList(2.1), map.get(2));
+    }
+
+    @Test
+    public void testTakeWhile() {
+        assertArrayEquals(LongStreamEx.range(100).asDoubleStream().toArray(), DoubleStreamEx.iterate(0, i -> i + 1)
+                .takeWhile(i -> i < 100).toArray(), 0.0);
+        assertEquals(0, DoubleStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
+        assertEquals(1, DoubleStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
+        assertEquals(3, DoubleStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
+    }
+
+    @Test
+    public void testTakeWhileInclusive() {
+        assertArrayEquals(LongStreamEx.range(101).asDoubleStream().toArray(), DoubleStreamEx.iterate(0, i -> i + 1)
+            .takeWhileInclusive(i -> i < 100).toArray(), 0.0);
+        assertEquals(1, DoubleStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
+        assertEquals(2, DoubleStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
+        assertEquals(3, DoubleStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
+    }
+    
+    @Test
+    public void testDropWhile() {
+        assertArrayEquals(new double[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, LongStreamEx.range(100).asDoubleStream()
+                .dropWhile(i -> i % 10 < 5).limit(10).toArray(), 0.0);
+        assertEquals(100, LongStreamEx.range(100).asDoubleStream().sorted().dropWhile(i -> i % 10 < 0).count());
+        assertEquals(0, LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 10).count());
+        assertEquals(OptionalDouble.of(0), LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 0).findFirst());
+        assertEquals(OptionalDouble.empty(), LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 10).findFirst());
+
+        java.util.Spliterator.OfDouble spltr = LongStreamEx.range(100).asDoubleStream().dropWhile(i -> i % 10 < 1).spliterator();
+        assertTrue(spltr.tryAdvance((double x) -> assertEquals(1, x, 0.0)));
+        Builder builder = DoubleStream.builder();
+        spltr.forEachRemaining(builder);
+        assertArrayEquals(LongStreamEx.range(2, 100).asDoubleStream().toArray(), builder.build().toArray(), 0.0);
+    }
+
+    @Test
+    public void testIndexOf() {
+        assertEquals(11, LongStreamEx.range(50, 100).asDoubleStream().indexOf(x -> x > 60).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).asDoubleStream().indexOf(x -> x < 0).isPresent());
+        assertEquals(11, LongStreamEx.range(50, 100).asDoubleStream().parallel().indexOf(x -> x > 60).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).asDoubleStream().parallel().indexOf(x -> x < 0).isPresent());
+    }
+
+    @Test
+    public void testFoldLeft() {
+        // non-associative
+        DoubleBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
+        assertEquals(2322576, DoubleStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1), 0.0);
+        assertEquals(2322576, DoubleStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1), 0.0);
+        assertFalse(DoubleStreamEx.empty().foldLeft(accumulator).isPresent());
+        assertEquals(144, DoubleStreamEx.of(1, 2, 3).foldLeft(0.0, accumulator), 144);
+        assertEquals(144, DoubleStreamEx.of(1, 2, 3).parallel().foldLeft(0.0, accumulator), 144);
+    }
+
+    @Test
+    public void testMapFirstLast() {
+        assertArrayEquals(new double[] { -1, 2, 3, 4, 7 }, DoubleStreamEx.of(1, 2, 3, 4, 5).mapFirst(x -> x - 2.0)
+                .mapLast(x -> x + 2.0).toArray(), 0.0);
+    }
+
+    @Test
+    public void testPeekFirst() {
+        double[] input = {1, 10, 100, 1000};
+        
+        AtomicReference<Double> firstElement = new AtomicReference<>();
+        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray(), 0.0);
+        assertEquals(1, firstElement.get(), 0.0);
+
+        assertArrayEquals(new double[] {10, 100, 1000}, DoubleStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray(), 0.0);
+        assertEquals(10, firstElement.get(), 0.0);
+        
+        firstElement.set(-1.0);
+        assertArrayEquals(new double[] {}, DoubleStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray(), 0.0);
+        assertEquals(-1, firstElement.get(), 0.0);
+    }
+    
+    @Test
+    public void testPeekLast() {
+        double[] input = {1, 10, 100, 1000};
+        AtomicReference<Double> lastElement = new AtomicReference<>();
+        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray(), 0.0);
+        assertNull(lastElement.get());
+
+        assertArrayEquals(new double[] { 1, 10, 100 }, DoubleStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray(), 0.0);
+        assertEquals(100, lastElement.get(), 0.0);
+        
+        assertArrayEquals(input, DoubleStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray(), 0.0);
+        assertEquals(1000, lastElement.get(), 0.0);
+        
+        assertArrayEquals(new double[] {1, 10, 100}, DoubleStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray(), 0.0);
+        assertEquals(100, lastElement.get(), 0.0);
+    }
+    
+    @Test
+    public void testScanLeft() {
+        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
+                .scanLeft(Double::sum), 0.0);
+        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
+                .parallel().scanLeft(Double::sum), 0.0);
+        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
+                .filter(x -> true).scanLeft(Double::sum), 0.0);
+        assertArrayEquals(new double[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).asDoubleStream()
+                .filter(x -> true).parallel().scanLeft(Double::sum), 0.0);
+        assertArrayEquals(new double[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).asDoubleStream()
+                .scanLeft(1, (a, b) -> a * b), 0.0);
+        assertArrayEquals(new double[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).asDoubleStream()
+                .parallel().scanLeft(1, (a, b) -> a * b), 0.0);
+    }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    private static DoubleStreamEx scannerDoubles(Scanner sc) {
+        return DoubleStreamEx.produce(action -> {
+            if (sc.hasNextDouble())
+                action.accept(sc.nextDouble());
+            return sc.hasNextDouble();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1.0 2.5 3 -4.6 test");
+        sc.useLocale(Locale.ENGLISH);
+        assertArrayEquals(new double[] {1, 2.5, 3, -4.6}, scannerDoubles(sc).stream().toArray(), 0.0);
+        assertEquals("test", sc.next());
+    }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new double[] { 1, 3, 6, 10, 20 }, DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).toArray(), 0.0);
+        assertEquals(OptionalDouble.of(10), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalDouble.empty(), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 20));
+        assertEquals(1000d, DoubleStreamEx.constant(1.0d, 1000).unordered().prefix(Double::sum).max().getAsDouble(), 0.0);
+        assertEquals(1000d, DoubleStreamEx.constant(1.0d, 1000).unordered().parallel().prefix(Double::sum).max().getAsDouble(), 0.0);
+    }
+    
+    @Test
+    public void testIntersperse() {
+        assertArrayEquals(new double[] { 1, 0, 10, 0, 100, 0, 1000 }, DoubleStreamEx.of(1, 10, 100, 1000).intersperse(0)
+                .toArray(), 0.0);
+        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
+    }
+}
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index 9c84c82..b8ae655 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -1,789 +1,791 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UncheckedIOException;
-import java.nio.IntBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.OptionalInt;
-import java.util.PrimitiveIterator.OfInt;
-import java.util.Random;
-import java.util.Scanner;
-import java.util.Spliterator;
-import java.util.Spliterators;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Function;
-import java.util.function.IntBinaryOperator;
-import java.util.function.IntFunction;
-import java.util.function.IntToDoubleFunction;
-import java.util.function.IntToLongFunction;
-import java.util.function.IntUnaryOperator;
-import java.util.function.Supplier;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-import java.util.stream.IntStream.Builder;
-
-import org.junit.FixMethodOrder;
-import org.junit.Test;
-import org.junit.runners.MethodSorters;
-
-import static one.util.streamex.TestHelpers.assertThrows;
-import static one.util.streamex.TestHelpers.checkSpliterator;
-import static one.util.streamex.TestHelpers.streamEx;
-import static one.util.streamex.TestHelpers.withRandom;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Tagir Valeev
- */
-@FixMethodOrder(MethodSorters.NAME_ASCENDING)
-public class IntStreamExTest {
-    private static final byte[] EVEN_BYTES = new byte[] { 2, 4, 6, 8, 10 };
-
-    @Test
-    public void testCreate() {
-        assertArrayEquals(new int[] {}, IntStreamEx.empty().toArray());
-        // double test is intended
-        assertArrayEquals(new int[] {}, IntStreamEx.empty().toArray());
-        assertArrayEquals(new int[] { 1 }, IntStreamEx.of(1).toArray());
-        assertArrayEquals(new int[] { 1 }, IntStreamEx.of(OptionalInt.of(1)).toArray());
-        assertArrayEquals(new int[] {}, IntStreamEx.of(OptionalInt.empty()).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).toArray());
-        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(new int[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(new byte[] { 1, 2, 3 }).toArray());
-        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(EVEN_BYTES, 1, 3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(new short[] { 1, 2, 3 }).toArray());
-        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(new short[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
-        assertArrayEquals(new int[] { 'a', 'b', 'c' }, IntStreamEx.of('a', 'b', 'c').toArray());
-        assertArrayEquals(new int[] { '1', 'b' }, IntStreamEx.of(new char[] { 'a', '1', 'b', '2', 'c', '3' }, 1, 3)
-                .toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(IntStream.of(1, 2, 3)).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(Arrays.asList(1, 2, 3)).toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.range(3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(1, 4).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.rangeClosed(1, 3).toArray());
-        assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.generate(() -> 1).limit(4).toArray());
-        assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.constant(1, 4).toArray());
-        assertArrayEquals(new int[] { 'a', 'b', 'c' }, IntStreamEx.ofChars("abc").toArray());
-        assertEquals(10, IntStreamEx.of(new Random(), 10).count());
-        assertTrue(IntStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
-        assertArrayEquals(IntStreamEx.of(new Random(1), 100, 1, 10).toArray(), IntStreamEx.of(new Random(1), 1, 10)
-                .limit(100).toArray());
-
-        IntStream stream = IntStreamEx.of(1, 2, 3);
-        assertSame(stream, IntStreamEx.of(stream));
-
-        assertArrayEquals(new int[] { 4, 2, 0, -2, -4 }, IntStreamEx.zip(new int[] { 5, 4, 3, 2, 1 },
-            new int[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray());
-
-        assertArrayEquals(new int[] { 1, 5, 3 }, IntStreamEx.of(Spliterators.spliterator(new int[] { 1, 5, 3 }, 0))
-                .toArray());
-        assertArrayEquals(new int[] { 1, 5, 3 }, IntStreamEx.of(
-            Spliterators.iterator(Spliterators.spliterator(new int[] { 1, 5, 3 }, 0))).toArray());
-        assertArrayEquals(new int[0], IntStreamEx.of(Spliterators.iterator(Spliterators.emptyIntSpliterator()))
-                .parallel().toArray());
-
-        BitSet bs = new BitSet();
-        bs.set(1);
-        bs.set(3);
-        bs.set(5);
-        assertArrayEquals(new int[] { 1, 3, 5 }, IntStreamEx.of(bs).toArray());
-
-        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.of(new Integer[] { 2, 4, 6 }).toArray());
-    }
-    
-    @Test
-    public void testOfIntBuffer() {
-        int[] data = IntStreamEx.range(100).toArray();
-        assertArrayEquals(data, IntStreamEx.of(IntBuffer.wrap(data)).toArray());
-        assertArrayEquals(IntStreamEx.range(50, 70).toArray(), IntStreamEx.of(IntBuffer.wrap(data, 50, 20)).toArray());
-        assertArrayEquals(data, IntStreamEx.of(IntBuffer.wrap(data)).parallel().toArray());
-        assertArrayEquals(IntStreamEx.range(50, 70).toArray(), IntStreamEx.of(IntBuffer.wrap(data, 50, 20)).parallel()
-                .toArray());
-    }
-    
-    @Test
-    public void testIterate() {
-        assertArrayEquals(new int[] { 1, 2, 4, 8, 16 }, IntStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
-        assertArrayEquals(new int[] { 1, 2, 4, 8, 16, 32, 64 }, IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
-        assertEquals(0, IntStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
-        assertFalse(IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
-        checkSpliterator("iterate", () -> IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
-    }
-    
-    @Test
-    public void testInts() {
-        assertEquals(Integer.MAX_VALUE, IntStreamEx.ints().spliterator().getExactSizeIfKnown());
-        assertArrayEquals(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, IntStreamEx.ints().limit(10).toArray());
-    }
-
-    @Test
-    public void testRangeStep() {
-        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, 1000, 100000).toArray());
-        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, 1000, 1000).toArray());
-        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE - 1 }, IntStreamEx.range(0, Integer.MAX_VALUE,
-            Integer.MAX_VALUE - 1).toArray());
-        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.range(
-            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1 }, IntStreamEx.range(Integer.MIN_VALUE,
-            Integer.MAX_VALUE - 1, Integer.MAX_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MAX_VALUE, -1 }, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE,
-            Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MAX_VALUE }, IntStreamEx.range(Integer.MAX_VALUE, 0, Integer.MIN_VALUE)
-                .toArray());
-        assertArrayEquals(new int[] { 1, Integer.MIN_VALUE + 1 }, IntStreamEx.range(1, Integer.MIN_VALUE,
-            Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, Integer.MIN_VALUE, Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.range(0, 9, 2).toArray());
-        assertArrayEquals(new int[] { 0, 2, 4, 6 }, IntStreamEx.range(0, 8, 2).toArray());
-        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.range(0, -9, -2).toArray());
-        assertArrayEquals(new int[] { 0, -2, -4, -6 }, IntStreamEx.range(0, -8, -2).toArray());
-        assertArrayEquals(new int[] { 5, 4, 3, 2, 1, 0 }, IntStreamEx.range(5, -1, -1).toArray());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE - 1, 2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE, -2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE + 1, -2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE * 2L + 1L, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 1)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE * 2L + 1L, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE, -1)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(0, IntStreamEx.range(0, -1000, 1).count());
-        assertEquals(0, IntStreamEx.range(0, 1000, -1).count());
-        assertEquals(0, IntStreamEx.range(0, 0, -1).count());
-        assertEquals(0, IntStreamEx.range(0, 0, 1).count());
-        assertEquals(0, IntStreamEx.range(0, -1000, 2).count());
-        assertEquals(0, IntStreamEx.range(0, 1000, -2).count());
-        assertEquals(0, IntStreamEx.range(0, 0, -2).count());
-        assertEquals(0, IntStreamEx.range(0, 0, 2).count());
-
-        assertEquals(0, IntStreamEx.range(0, Integer.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
-        assertEquals(0, IntStreamEx.range(0, Integer.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
-
-        assertThrows(IllegalArgumentException.class, () -> IntStreamEx.range(0, 1000, 0));
-    }
-
-    @Test
-    public void testRangeClosedStep() {
-        assertArrayEquals(new int[] { 0 }, IntStreamEx.rangeClosed(0, 1000, 100000).toArray());
-        assertArrayEquals(new int[] { 0, 1000 }, IntStreamEx.rangeClosed(0, 1000, 1000).toArray());
-        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(0, Integer.MAX_VALUE,
-            Integer.MAX_VALUE - 1).toArray());
-        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE }, IntStreamEx.rangeClosed(0, Integer.MAX_VALUE,
-            Integer.MAX_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(
-            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(
-            Integer.MIN_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MAX_VALUE, -1 }, IntStreamEx.rangeClosed(Integer.MAX_VALUE,
-            Integer.MIN_VALUE, Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { Integer.MAX_VALUE }, IntStreamEx.rangeClosed(Integer.MAX_VALUE, 0,
-            Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { 0, Integer.MIN_VALUE }, IntStreamEx.rangeClosed(0, Integer.MIN_VALUE,
-            Integer.MIN_VALUE).toArray());
-        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.rangeClosed(0, 9, 2).toArray());
-        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.rangeClosed(0, 8, 2).toArray());
-        assertArrayEquals(new int[] { 0, 2, 4, 6 }, IntStreamEx.rangeClosed(0, 7, 2).toArray());
-        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.rangeClosed(0, -9, -2).toArray());
-        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.rangeClosed(0, -8, -2).toArray());
-        assertArrayEquals(new int[] { 0, -2, -4, -6 }, IntStreamEx.rangeClosed(0, -7, -2).toArray());
-        assertArrayEquals(new int[] { 5, 4, 3, 2, 1, 0 }, IntStreamEx.rangeClosed(5, 0, -1).toArray());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE - 1, 2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE - 2, 2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE, -2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE + 1, -2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE * 2L + 2L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 1)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Integer.MAX_VALUE * 2L + 2L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE, -1)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(0, IntStreamEx.rangeClosed(0, -1000, 1).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, 1000, -1).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, 1, -1).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, -1, 1).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, -1000, 2).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, 1000, -2).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, 1, -2).count());
-        assertEquals(0, IntStreamEx.rangeClosed(0, -1, 2).count());
-        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, 1).toArray());
-        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, 2).toArray());
-        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 11, 2).toArray());
-        assertArrayEquals(new int[] {}, IntStreamEx.rangeClosed(11, 10, 2).toArray());
-        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, -1).toArray());
-        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, -2).toArray());
-        assertArrayEquals(new int[] {}, IntStreamEx.rangeClosed(10, 11, -2).toArray());
-        assertArrayEquals(new int[] {11}, IntStreamEx.rangeClosed(11, 10, -2).toArray());
-
-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, -1, 3).findAny());
-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, 3, 1).findAny());
-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, 3, 6).findAny());
-    }
-
-    @Test
-    public void testArrayLengthOk() {
-        assertEquals(10, IntStreamEx.of(EVEN_BYTES, 3, 5).skip(1).findFirst().getAsInt());
-    }
-
-    @Test
-    public void testOfIndices() {
-        assertArrayEquals(new int[] {}, IntStreamEx.ofIndices(new int[0]).toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new int[] { 5, -100, 1 }).toArray());
-        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new int[] { 5, -100, 1 }, i -> i > 0).toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new long[] { 5, -100, 1 }).toArray());
-        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new long[] { 5, -100, 1 }, i -> i > 0).toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new double[] { 5, -100, 1 }).toArray());
-        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new double[] { 5, -100, 1 }, i -> i > 0).toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new String[] { "a", "b", "c" }).toArray());
-        assertArrayEquals(new int[] { 1 }, IntStreamEx.ofIndices(new String[] { "a", "", "c" }, String::isEmpty)
-                .toArray());
-        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(Arrays.asList("a", "b", "c")).toArray());
-        assertArrayEquals(new int[] { 1 }, IntStreamEx.ofIndices(Arrays.asList("a", "", "c"), String::isEmpty)
-                .toArray());
-    }
-
-    @Test
-    public void testBasics() {
-        assertFalse(IntStreamEx.of(1).isParallel());
-        assertTrue(IntStreamEx.of(1).parallel().isParallel());
-        assertFalse(IntStreamEx.of(1).parallel().sequential().isParallel());
-        AtomicInteger i = new AtomicInteger();
-        try (IntStreamEx s = IntStreamEx.of(1).onClose(i::incrementAndGet)) {
-            assertEquals(1, s.count());
-        }
-        assertEquals(1, i.get());
-        assertEquals(6, IntStreamEx.range(0, 4).sum());
-        assertEquals(3, IntStreamEx.range(0, 4).max().getAsInt());
-        assertEquals(0, IntStreamEx.range(0, 4).min().getAsInt());
-        assertEquals(1.5, IntStreamEx.range(0, 4).average().getAsDouble(), 0.000001);
-        assertEquals(4, IntStreamEx.range(0, 4).summaryStatistics().getCount());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(0, 5).skip(1).limit(3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(3, 1, 2).sorted().toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 1, 3, 2).distinct().toArray());
-        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.range(1, 4).map(x -> x * 2).toArray());
-        assertArrayEquals(new long[] { 2, 4, 6 }, IntStreamEx.range(1, 4).mapToLong(x -> x * 2).toArray());
-        assertArrayEquals(new double[] { 2, 4, 6 }, IntStreamEx.range(1, 4).mapToDouble(x -> x * 2).toArray(), 0.0);
-        assertArrayEquals(new int[] { 1, 3 }, IntStreamEx.range(0, 5).filter(x -> x % 2 == 1).toArray());
-        assertEquals(6, IntStreamEx.of(1, 2, 3).reduce(Integer::sum).getAsInt());
-        assertEquals(Integer.MAX_VALUE, IntStreamEx.rangeClosed(1, Integer.MAX_VALUE).spliterator()
-                .getExactSizeIfKnown());
-
-        assertTrue(IntStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
-        assertFalse(IntStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
-
-        OfInt iterator = IntStreamEx.of(1, 2, 3).iterator();
-        assertEquals(1, iterator.nextInt());
-        assertEquals(2, iterator.nextInt());
-        assertEquals(3, iterator.nextInt());
-        assertFalse(iterator.hasNext());
-
-        List<Integer> list = new ArrayList<>();
-        IntStreamEx.range(10).parallel().forEachOrdered(list::add);
-        assertEquals(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), list);
-
-        assertTrue(IntStreamEx.empty().noneMatch(x -> true));
-        assertFalse(IntStreamEx.of(1).noneMatch(x -> true));
-        assertTrue(IntStreamEx.of(1).noneMatch(x -> false));
-    }
-    
-    @Test
-    public void testForEach() {
-        streamEx(() -> StreamEx.of(1, 2, 3), s -> {
-            AtomicInteger count = new AtomicInteger(0);
-            s.get().mapToInt(Integer::intValue).forEach(count::addAndGet);
-            assertEquals(6, count.get());
-            s.get().mapToInt(Integer::intValue).pairMap((a, b) -> b - a).forEach(count::addAndGet);
-            assertEquals(8, count.get());
-        });
-    }
-
-    @Test
-    public void testFlatMap() {
-        long[][] vals = { { 1, 2, 3 }, { 2, 3, 4 }, { 5, 4, Long.MAX_VALUE, Long.MIN_VALUE } };
-        assertArrayEquals(new long[] { 1, 2, 3, 2, 3, 4, 5, 4, Long.MAX_VALUE, Long.MIN_VALUE }, IntStreamEx.ofIndices(
-            vals).flatMapToLong(idx -> Arrays.stream(vals[idx])).toArray());
-        String expected = IntStream.range(0, 200).boxed().flatMap(
-            i -> IntStream.range(0, i).mapToObj(j -> i + ":" + j)).collect(Collectors.joining("/"));
-        String res = IntStreamEx.range(200).flatMapToObj(i -> IntStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining(
-            "/");
-        String parallel = IntStreamEx.range(200).parallel().flatMapToObj(
-            i -> IntStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining("/");
-        assertEquals(expected, res);
-        assertEquals(expected, parallel);
-
-        double[] fractions = IntStreamEx.range(1, 5).flatMapToDouble(
-            i -> IntStreamEx.range(1, i).mapToDouble(j -> ((double) j) / i)).toArray();
-        assertArrayEquals(new double[] { 1 / 2.0, 1 / 3.0, 2 / 3.0, 1 / 4.0, 2 / 4.0, 3 / 4.0 }, fractions, 0.000001);
-
-        assertArrayEquals(new int[] { 0, 0, 1, 0, 1, 2 }, IntStreamEx.of(1, 2, 3).flatMap(IntStreamEx::range).toArray());
-    }
-
-    @Test
-    public void testElements() {
-        assertEquals(Arrays.asList("f", "d", "b"), IntStreamEx.of(5, 3, 1).elements("abcdef".split("")).toList());
-        assertEquals(Arrays.asList("f", "d", "b"), IntStreamEx.of(5, 3, 1).elements(
-            Arrays.asList("a", "b", "c", "d", "e", "f")).toList());
-        assertArrayEquals(new int[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(new int[] { 0, 2, 4, 6, 8, 10 })
-                .toArray());
-        assertArrayEquals(new long[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(new long[] { 0, 2, 4, 6, 8, 10 })
-                .toArray());
-        assertArrayEquals(new double[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(
-            new double[] { 0, 2, 4, 6, 8, 10 }).toArray(), 0.0);
-    }
-
-    @Test
-    public void testPrepend() {
-        assertArrayEquals(new int[] { -1, 0, 1, 2, 3 }, IntStreamEx.of(1, 2, 3).prepend(-1, 0).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).prepend().toArray());
-        assertArrayEquals(new int[] { 10, 11, 0, 1, 2, 3 }, IntStreamEx.range(0, 4).prepend(IntStreamEx.range(10, 12))
-                .toArray());
-    }
-
-    @Test
-    public void testAppend() {
-        assertArrayEquals(new int[] { 1, 2, 3, 4, 5 }, IntStreamEx.of(1, 2, 3).append(4, 5).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).append().toArray());
-        assertArrayEquals(new int[] { 0, 1, 2, 3, 10, 11 }, IntStreamEx.range(0, 4).append(IntStreamEx.range(10, 12))
-                .toArray());
-    }
-
-    @Test
-    public void testHas() {
-        assertTrue(IntStreamEx.range(1, 4).has(3));
-        assertFalse(IntStreamEx.range(1, 4).has(4));
-    }
-
-    @Test
-    public void testWithout() {
-        assertArrayEquals(new int[] { 1, 2 }, IntStreamEx.range(1, 4).without(3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(1, 4).without(5).toArray());
-        IntStreamEx ise = IntStreamEx.range(5);
-        assertSame(ise, ise.without());
-        assertArrayEquals(new int[] { 0, 1, 3, 4 }, IntStreamEx.range(5).without(new int[] { 2 }).toArray());
-        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(5).without(1, 2, 3, 4, 5, 6).toArray());
-    }
-
-    @Test
-    public void testRanges() {
-        assertArrayEquals(new int[] { 5, 4, Integer.MAX_VALUE }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE)
-                .greater(3).toArray());
-        assertArrayEquals(new int[] { 5, 3, 4, Integer.MAX_VALUE }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE)
-                .atLeast(3).toArray());
-        assertArrayEquals(new int[] { 1, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).less(3).toArray());
-        assertArrayEquals(new int[] { 1, 3, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).atMost(3).toArray());
-        assertArrayEquals(new int[] { 1, 3, 4, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).atMost(4).toArray());
-    }
-
-    @Test
-    public void testToBitSet() {
-        assertEquals("{0, 1, 2, 3, 4}", IntStreamEx.range(5).toBitSet().toString());
-        assertEquals("{0, 2, 3, 4, 10}", IntStreamEx.of(0, 2, 0, 3, 0, 4, 0, 10).parallel().toBitSet().toString());
-    }
-
-    @Test
-    public void testAs() {
-        assertEquals(4, IntStreamEx.range(0, 5).asLongStream().findAny(x -> x > 3).getAsLong());
-        assertEquals(4.0, IntStreamEx.range(0, 5).asDoubleStream().findAny(x -> x > 3).getAsDouble(), 0.0);
-    }
-
-    @Test
-    public void testFind() {
-        assertEquals(6, IntStreamEx.range(1, 10).findFirst(i -> i > 5).getAsInt());
-        assertFalse(IntStreamEx.range(1, 10).findAny(i -> i > 10).isPresent());
-    }
-
-    @Test
-    public void testRemove() {
-        assertArrayEquals(new int[] { 1, 2 }, IntStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray());
-    }
-
-    @Test
-    public void testSort() {
-        assertArrayEquals(new int[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, IntStreamEx.range(0, 9).sortedByInt(
-            i -> i % 3 * 3 + i / 3).toArray());
-        assertArrayEquals(new int[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, IntStreamEx.range(0, 9).sortedByLong(
-            i -> (long) i % 3 * Integer.MAX_VALUE + i / 3).toArray());
-        assertArrayEquals(new int[] { 8, 7, 6, 5, 4, 3, 2, 1 }, IntStreamEx.range(1, 9).sortedByDouble(i -> 1.0 / i)
-                .toArray());
-        assertArrayEquals(new int[] { 10, 11, 5, 6, 7, 8, 9 }, IntStreamEx.range(5, 12).sortedBy(String::valueOf)
-                .toArray());
-        assertArrayEquals(new int[] { Integer.MAX_VALUE, 1000, 1, 0, -10, Integer.MIN_VALUE }, IntStreamEx.of(0, 1,
-            1000, -10, Integer.MIN_VALUE, Integer.MAX_VALUE).reverseSorted().toArray());
-    }
-
-    @Test
-    public void testToString() {
-        assertEquals("LOWERCASE", IntStreamEx.ofChars("lowercase").map(c -> Character.toUpperCase((char) c))
-                .charsToString());
-        assertEquals("LOWERCASE", IntStreamEx.ofCodePoints("lowercase").map(Character::toUpperCase)
-                .codePointsToString());
-    }
-
-    @SafeVarargs
-    private static void checkEmpty(Function<IntStreamEx, OptionalInt>... fns) {
-        int i = 0;
-        for (Function<IntStreamEx, OptionalInt> fn : fns) {
-            assertFalse("#" + i, fn.apply(IntStreamEx.empty()).isPresent());
-            assertFalse("#" + i, fn.apply(IntStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
-            assertEquals("#" + i, 10, fn.apply(IntStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
-                    .getAsInt());
-            i++;
-        }
-    }
-
-    @Test
-    public void testMinMax() {
-        checkEmpty(s -> s.maxBy(Integer::valueOf), s -> s.maxByInt(x -> x), s -> s.maxByLong(x -> x), s -> s
-                .maxByDouble(x -> x), s -> s.minBy(Integer::valueOf), s -> s.minByInt(x -> x),
-            s -> s.minByLong(x -> x), s -> s.minByDouble(x -> x));
-        assertEquals(9, IntStreamEx.range(5, 12).max(Comparator.comparing(String::valueOf)).getAsInt());
-        assertEquals(10, IntStreamEx.range(5, 12).min(Comparator.comparing(String::valueOf)).getAsInt());
-        assertEquals(9, IntStreamEx.range(5, 12).maxBy(String::valueOf).getAsInt());
-        assertEquals(10, IntStreamEx.range(5, 12).minBy(String::valueOf).getAsInt());
-        assertEquals(5, IntStreamEx.range(5, 12).maxByDouble(x -> 1.0 / x).getAsInt());
-        assertEquals(11, IntStreamEx.range(5, 12).minByDouble(x -> 1.0 / x).getAsInt());
-        assertEquals(29, IntStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> x % 10 * 10 + x / 10).getAsInt());
-        assertEquals(31, IntStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> x % 10 * 10 + x / 10).getAsInt());
-        assertEquals(29, IntStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> Long.MIN_VALUE + x % 10 * 10 + x / 10)
-                .getAsInt());
-        assertEquals(31, IntStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> Long.MIN_VALUE + x % 10 * 10 + x / 10)
-                .getAsInt());
-
-        Supplier<IntStreamEx> s = () -> IntStreamEx.of(1, 50, 120, 35, 130, 12, 0);
-        IntUnaryOperator intKey = x -> String.valueOf(x).length();
-        IntToLongFunction longKey = x -> String.valueOf(x).length();
-        IntToDoubleFunction doubleKey = x -> String.valueOf(x).length();
-        IntFunction<Integer> objKey = x -> String.valueOf(x).length();
-        List<Function<IntStreamEx, OptionalInt>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
-                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
-        List<Function<IntStreamEx, OptionalInt>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
-                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsInt()));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsInt()));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsInt()));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsInt()));
-    }
-
-    private static IntStreamEx dropLast(IntStreamEx s) {
-        return s.pairMap((a, b) -> a);
-    }
-
-    @Test
-    public void testPairMap() {
-        assertEquals(0, IntStreamEx.range(0).pairMap(Integer::sum).count());
-        assertEquals(0, IntStreamEx.range(1).pairMap(Integer::sum).count());
-        assertEquals(Collections.singletonMap(1, 9999L), IntStreamEx.range(10000).pairMap((a, b) -> b - a).boxed()
-                .groupingBy(Function.identity(), Collectors.counting()));
-        assertEquals(Collections.singletonMap(1, 9999L), IntStreamEx.range(10000).parallel().pairMap((a, b) -> b - a)
-                .boxed().groupingBy(Function.identity(), Collectors.counting()));
-        assertEquals("Test Capitalization Stream", IntStreamEx.ofChars("test caPiTaliZation streaM").parallel()
-                .prepend(0).pairMap(
-                    (c1, c2) -> !Character.isLetter(c1) && Character.isLetter(c2) ? Character.toTitleCase(c2)
-                            : Character.toLowerCase(c2)).charsToString());
-        assertArrayEquals(IntStreamEx.range(9999).toArray(), dropLast(IntStreamEx.range(10000)).toArray());
-
-        withRandom(r -> {
-            int[] data = r.ints(1000, 1, 1000).toArray();
-            int[] expected = new int[data.length - 1];
-            int lastSquare = data[0] * data[0];
-            for (int i = 0; i < expected.length; i++) {
-                int newSquare = data[i + 1] * data[i + 1];
-                expected[i] = newSquare - lastSquare;
-                lastSquare = newSquare;
-            }
-            int[] result = IntStreamEx.of(data).map(x -> x * x).pairMap((a, b) -> b - a).toArray();
-            assertArrayEquals(expected, result);
-        });
-
-        assertEquals(1, IntStreamEx.range(1000).map(x -> x * x).pairMap((a, b) -> b - a).pairMap((a, b) -> b - a)
-                .distinct().count());
-
-        assertArrayEquals(IntStreamEx.constant(1, 100).toArray(), IntStreamEx.iterate(0, i -> i + 1).parallel()
-                .pairMap((a, b) -> b - a).limit(100).toArray());
-
-        assertFalse(IntStreamEx.range(1000).greater(2000).parallel().pairMap((a, b) -> a).findFirst().isPresent());
-    }
-
-    @Test
-    public void testToByteArray() {
-        byte[] expected = new byte[10000];
-        for (int i = 0; i < expected.length; i++)
-            expected[i] = (byte) i;
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toByteArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toByteArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toByteArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toByteArray());
-        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
-        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toByteArray());
-    }
-
-    @Test
-    public void testToCharArray() {
-        char[] expected = new char[10000];
-        for (int i = 0; i < expected.length; i++)
-            expected[i] = (char) i;
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toCharArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toCharArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toCharArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toCharArray());
-        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
-        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toCharArray());
-    }
-
-    @Test
-    public void testToShortArray() {
-        short[] expected = new short[10000];
-        for (int i = 0; i < expected.length; i++)
-            expected[i] = (short) i;
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toShortArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toShortArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toShortArray());
-        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toShortArray());
-        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
-        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toShortArray());
-    }
-
-    @Test
-    public void testJoining() {
-        assertEquals("0,1,2,3,4,5,6,7,8,9", IntStreamEx.range(10).joining(","));
-        assertEquals("0,1,2,3,4,5,6,7,8,9", IntStreamEx.range(10).parallel().joining(","));
-        assertEquals("[0,1,2,3,4,5,6,7,8,9]", IntStreamEx.range(10).joining(",", "[", "]"));
-        assertEquals("[0,1,2,3,4,5,6,7,8,9]", IntStreamEx.range(10).parallel().joining(",", "[", "]"));
-    }
-
-    @Test
-    public void testMapToEntry() {
-        Map<Integer, List<Integer>> result = IntStreamEx.range(10).mapToEntry(x -> x % 2, x -> x).grouping();
-        assertEquals(Arrays.asList(0, 2, 4, 6, 8), result.get(0));
-        assertEquals(Arrays.asList(1, 3, 5, 7, 9), result.get(1));
-    }
-
-    @Test
-    public void testTakeWhile() {
-        assertArrayEquals(IntStreamEx.range(100).toArray(), IntStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 100)
-                .toArray());
-        assertEquals(0, IntStreamEx.empty().takeWhile(i -> true).count());
-        assertEquals(0, IntStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
-        assertEquals(1, IntStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
-        assertEquals(3, IntStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
-    }
-
-    @Test
-    public void testTakeWhileInclusive() {
-        assertArrayEquals(IntStreamEx.range(101).toArray(), IntStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(
-            i -> i < 100).toArray());
-        assertEquals(0, IntStreamEx.empty().takeWhileInclusive(i -> true).count());
-        assertEquals(1, IntStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
-        assertEquals(2, IntStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
-        assertEquals(3, IntStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
-    }
-    
-    @Test
-    public void testDropWhile() {
-        assertArrayEquals(new int[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, IntStreamEx.range(100).dropWhile(
-            i -> i % 10 < 5).limit(10).toArray());
-        assertEquals(100, IntStreamEx.range(100).dropWhile(i -> i % 10 < 0).count());
-        assertEquals(0, IntStreamEx.range(100).dropWhile(i -> i % 10 < 10).count());
-        assertEquals(OptionalInt.of(0), IntStreamEx.range(100).dropWhile(i -> i % 10 < 0).findFirst());
-        assertEquals(OptionalInt.empty(), IntStreamEx.range(100).dropWhile(i -> i % 10 < 10).findFirst());
-
-        java.util.Spliterator.OfInt spltr = IntStreamEx.range(100).dropWhile(i -> i % 10 < 1).spliterator();
-        assertTrue(spltr.tryAdvance((int x) -> assertEquals(1, x)));
-        Builder builder = IntStream.builder();
-        spltr.forEachRemaining(builder);
-        assertArrayEquals(IntStreamEx.range(2, 100).toArray(), builder.build().toArray());
-    }
-
-    @Test
-    public void testIndexOf() {
-        assertEquals(5, IntStreamEx.range(50, 100).indexOf(55).getAsLong());
-        assertFalse(IntStreamEx.range(50, 100).indexOf(200).isPresent());
-        assertEquals(5, IntStreamEx.range(50, 100).parallel().indexOf(55).getAsLong());
-        assertFalse(IntStreamEx.range(50, 100).parallel().indexOf(200).isPresent());
-
-        assertEquals(11, IntStreamEx.range(50, 100).indexOf(x -> x > 60).getAsLong());
-        assertFalse(IntStreamEx.range(50, 100).indexOf(x -> x < 0).isPresent());
-        assertEquals(11, IntStreamEx.range(50, 100).parallel().indexOf(x -> x > 60).getAsLong());
-        assertFalse(IntStreamEx.range(50, 100).parallel().indexOf(x -> x < 0).isPresent());
-    }
-
-    @Test
-    public void testFoldLeft() {
-        // non-associative
-        IntBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
-        assertEquals(2322576, IntStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1));
-        assertEquals(2322576, IntStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1));
-        assertFalse(IntStreamEx.empty().foldLeft(accumulator).isPresent());
-        assertEquals(144, IntStreamEx.rangeClosed(1, 3).foldLeft(0, accumulator));
-        assertEquals(144, IntStreamEx.rangeClosed(1, 3).parallel().foldLeft(0, accumulator));
-    }
-
-    @Test
-    public void testMapFirstLast() {
-        // capitalize
-        String str = "testString";
-        assertEquals("TestString", IntStreamEx.ofCodePoints(str).mapFirst(Character::toUpperCase).codePointsToString());
-
-        streamEx(() -> StreamEx.of(1, 2, 3, 4, 5), s ->
-                assertArrayEquals(new int[] { -3, 2, 3, 4, 9 }, s.get().mapToInt(Integer::intValue)
-                        .mapFirst(x -> x - 2).mapLast(x -> x + 2)
-                        .mapFirst(x -> x - 2).mapLast(x -> x + 2).toArray()));
-    }
-
-    @Test
-    public void testPeekFirst() {
-        int[] input = {1, 10, 100, 1000};
-        
-        AtomicInteger firstElement = new AtomicInteger();
-        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
-        assertEquals(1, firstElement.get());
-
-        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
-        assertEquals(10, firstElement.get());
-        
-        firstElement.set(-1);
-        assertArrayEquals(new int[] {}, IntStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
-        assertEquals(-1, firstElement.get());
-    }
-    
-    @Test
-    public void testPeekLast() {
-        int[] input = {1, 10, 100, 1000};
-        AtomicInteger lastElement = new AtomicInteger(-1);
-        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
-        assertEquals(-1, lastElement.get());
-
-        assertArrayEquals(new int[] { 1, 10, 100 }, IntStreamEx.of(input).less(1000).peekLast(lastElement::set)
-                .limit(3).toArray());
-        assertEquals(100, lastElement.get());
-        
-        assertArrayEquals(input, IntStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
-        assertEquals(1000, lastElement.get());
-        
-        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
-        assertEquals(100, lastElement.get());
-    }
-    
-    @Test
-    public void testScanLeft() {
-        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10)
-                .scanLeft(Integer::sum));
-        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).parallel().scanLeft(
-            Integer::sum));
-        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).filter(x -> true)
-                .scanLeft(Integer::sum));
-        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).filter(x -> true)
-                .parallel().scanLeft(Integer::sum));
-        assertArrayEquals(new int[] { 1, 1, 2, 6, 24, 120 }, IntStreamEx.rangeClosed(1, 5).scanLeft(1, (a, b) -> a * b));
-        assertArrayEquals(new int[] { 1, 1, 2, 6, 24, 120 }, IntStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
-            (a, b) -> a * b));
-    }
-
-    // Reads numbers from scanner stopping when non-number is encountered
-    // leaving scanner in known state
-    public static IntStreamEx scannerInts(Scanner sc) {
-        return IntStreamEx.produce(action -> {
-            if (sc.hasNextInt())
-                action.accept(sc.nextInt());
-            return sc.hasNextInt();
-        });
-    }
-
-    @Test
-    public void testProduce() {
-        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
-        assertArrayEquals(new int[] {1, 2, 3, 4}, scannerInts(sc).stream().toArray());
-        assertEquals("20000000000", sc.next());
-    }
-    
-    @Test
-    public void testOfInputStream() {
-        byte[] data = new byte[] { 5, 3, 10, 1, 4, -1 };
-        try (IntStream s = IntStreamEx.of(new ByteArrayInputStream(data))) {
-            assertEquals(22, s.map(b -> (byte) b).sum());
-        }
-        try (IntStream s = IntStreamEx.of(new ByteArrayInputStream(data))) {
-            assertEquals(278, s.sum());
-        }
-        InputStream is = new InputStream() {
-            @Override
-            public int read() throws IOException {
-                throw new IOException();
-            }
-
-            @Override
-            public void close() throws IOException {
-                throw new IOException();
-            }
-        };
-        IntStreamEx stream = IntStreamEx.of(is).filter(x -> x > 0);
-        assertThrows(UncheckedIOException.class, stream::count);
-        assertThrows(UncheckedIOException.class, stream::close);
-    }
-    
-    @Test
-    public void testAsInputStream() throws IOException {
-        AtomicBoolean flag = new AtomicBoolean(false);
-        InputStream is = IntStreamEx.range(256).onClose(() -> flag.set(true)).asByteInputStream();
-        byte[] data = new byte[256];
-        assertEquals(2, is.skip(2));
-        assertEquals(254, is.read(data));
-        assertEquals(-1, is.read());
-        for (int i = 0; i < 254; i++) {
-            assertEquals((byte) (i + 2), data[i]);
-        }
-        assertEquals(0, data[254]);
-        assertEquals(0, data[255]);
-        assertFalse(flag.get());
-        is.close();
-        assertTrue(flag.get());
-    }
-
-    @Test
-    public void testPrefix() {
-        assertArrayEquals(new int[] { 1, 3, 6, 10, 20 }, IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).toArray());
-        assertEquals(OptionalInt.of(10), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 7));
-        assertEquals(OptionalInt.empty(), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 20));
-    }
-    
-    @Test
-    public void testIntersperse() {
-        assertArrayEquals(new int[] { 1, 0, 10, 0, 100, 0, 1000 }, IntStreamEx.of(1, 10, 100, 1000).intersperse(0)
-                .toArray());
-        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.nio.IntBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.OptionalInt;
+import java.util.PrimitiveIterator.OfInt;
+import java.util.Random;
+import java.util.Scanner;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntFunction;
+import java.util.function.IntToDoubleFunction;
+import java.util.function.IntToLongFunction;
+import java.util.function.IntUnaryOperator;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.IntStream.Builder;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import static one.util.streamex.TestHelpers.assertThrows;
+import static one.util.streamex.TestHelpers.checkSpliterator;
+import static one.util.streamex.TestHelpers.streamEx;
+import static one.util.streamex.TestHelpers.withRandom;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Tagir Valeev
+ */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class IntStreamExTest {
+    private static final byte[] EVEN_BYTES = new byte[] { 2, 4, 6, 8, 10 };
+
+    @Test
+    public void testCreate() {
+        assertArrayEquals(new int[] {}, IntStreamEx.empty().toArray());
+        // double test is intended
+        assertArrayEquals(new int[] {}, IntStreamEx.empty().toArray());
+        assertArrayEquals(new int[] { 1 }, IntStreamEx.of(1).toArray());
+        assertArrayEquals(new int[] { 1 }, IntStreamEx.of(OptionalInt.of(1)).toArray());
+        assertArrayEquals(new int[] {}, IntStreamEx.of(OptionalInt.empty()).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).toArray());
+        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(new int[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(new byte[] { 1, 2, 3 }).toArray());
+        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(EVEN_BYTES, 1, 3).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(new short[] { 1, 2, 3 }).toArray());
+        assertArrayEquals(new int[] { 4, 6 }, IntStreamEx.of(new short[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
+        assertArrayEquals(new int[] { 'a', 'b', 'c' }, IntStreamEx.of('a', 'b', 'c').toArray());
+        assertArrayEquals(new int[] { '1', 'b' }, IntStreamEx.of(new char[] { 'a', '1', 'b', '2', 'c', '3' }, 1, 3)
+                .toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(IntStream.of(1, 2, 3)).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(Arrays.asList(1, 2, 3)).toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.range(3).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(1, 4).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.rangeClosed(1, 3).toArray());
+        assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.generate(() -> 1).limit(4).toArray());
+        assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.constant(1, 4).toArray());
+        assertArrayEquals(new int[] { 'a', 'b', 'c' }, IntStreamEx.ofChars("abc").toArray());
+        assertEquals(10, IntStreamEx.of(new Random(), 10).count());
+        assertTrue(IntStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
+        assertArrayEquals(IntStreamEx.of(new Random(1), 100, 1, 10).toArray(), IntStreamEx.of(new Random(1), 1, 10)
+                .limit(100).toArray());
+
+        IntStream stream = IntStreamEx.of(1, 2, 3);
+        assertSame(stream, IntStreamEx.of(stream));
+
+        assertArrayEquals(new int[] { 4, 2, 0, -2, -4 }, IntStreamEx.zip(new int[] { 5, 4, 3, 2, 1 },
+            new int[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray());
+
+        assertArrayEquals(new int[] { 1, 5, 3 }, IntStreamEx.of(Spliterators.spliterator(new int[] { 1, 5, 3 }, 0))
+                .toArray());
+        assertArrayEquals(new int[] { 1, 5, 3 }, IntStreamEx.of(
+            Spliterators.iterator(Spliterators.spliterator(new int[] { 1, 5, 3 }, 0))).toArray());
+        assertArrayEquals(new int[0], IntStreamEx.of(Spliterators.iterator(Spliterators.emptyIntSpliterator()))
+                .parallel().toArray());
+
+        BitSet bs = new BitSet();
+        bs.set(1);
+        bs.set(3);
+        bs.set(5);
+        assertArrayEquals(new int[] { 1, 3, 5 }, IntStreamEx.of(bs).toArray());
+
+        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.of(new Integer[] { 2, 4, 6 }).toArray());
+    }
+    
+    @Test
+    public void testOfIntBuffer() {
+        int[] data = IntStreamEx.range(100).toArray();
+        assertArrayEquals(data, IntStreamEx.of(IntBuffer.wrap(data)).toArray());
+        assertArrayEquals(IntStreamEx.range(50, 70).toArray(), IntStreamEx.of(IntBuffer.wrap(data, 50, 20)).toArray());
+        assertArrayEquals(data, IntStreamEx.of(IntBuffer.wrap(data)).parallel().toArray());
+        assertArrayEquals(IntStreamEx.range(50, 70).toArray(), IntStreamEx.of(IntBuffer.wrap(data, 50, 20)).parallel()
+                .toArray());
+    }
+    
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new int[] { 1, 2, 4, 8, 16 }, IntStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
+        assertArrayEquals(new int[] { 1, 2, 4, 8, 16, 32, 64 }, IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
+        assertEquals(0, IntStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
+        checkSpliterator("iterate", () -> IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+    
+    @Test
+    public void testInts() {
+        assertEquals(Integer.MAX_VALUE, IntStreamEx.ints().spliterator().getExactSizeIfKnown());
+        assertArrayEquals(new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, IntStreamEx.ints().limit(10).toArray());
+    }
+
+    @Test
+    public void testRangeStep() {
+        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, 1000, 100000).toArray());
+        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, 1000, 1000).toArray());
+        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE - 1 }, IntStreamEx.range(0, Integer.MAX_VALUE,
+            Integer.MAX_VALUE - 1).toArray());
+        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.range(
+            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1 }, IntStreamEx.range(Integer.MIN_VALUE,
+            Integer.MAX_VALUE - 1, Integer.MAX_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MAX_VALUE, -1 }, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE,
+            Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MAX_VALUE }, IntStreamEx.range(Integer.MAX_VALUE, 0, Integer.MIN_VALUE)
+                .toArray());
+        assertArrayEquals(new int[] { 1, Integer.MIN_VALUE + 1 }, IntStreamEx.range(1, Integer.MIN_VALUE,
+            Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(0, Integer.MIN_VALUE, Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.range(0, 9, 2).toArray());
+        assertArrayEquals(new int[] { 0, 2, 4, 6 }, IntStreamEx.range(0, 8, 2).toArray());
+        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.range(0, -9, -2).toArray());
+        assertArrayEquals(new int[] { 0, -2, -4, -6 }, IntStreamEx.range(0, -8, -2).toArray());
+        assertArrayEquals(new int[] { 5, 4, 3, 2, 1, 0 }, IntStreamEx.range(5, -1, -1).toArray());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE - 1, 2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE, -2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE + 1, -2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE * 2L + 1L, IntStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 1)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE * 2L + 1L, IntStreamEx.range(Integer.MAX_VALUE, Integer.MIN_VALUE, -1)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(0, IntStreamEx.range(0, -1000, 1).count());
+        assertEquals(0, IntStreamEx.range(0, 1000, -1).count());
+        assertEquals(0, IntStreamEx.range(0, 0, -1).count());
+        assertEquals(0, IntStreamEx.range(0, 0, 1).count());
+        assertEquals(0, IntStreamEx.range(0, -1000, 2).count());
+        assertEquals(0, IntStreamEx.range(0, 1000, -2).count());
+        assertEquals(0, IntStreamEx.range(0, 0, -2).count());
+        assertEquals(0, IntStreamEx.range(0, 0, 2).count());
+
+        assertEquals(0, IntStreamEx.range(0, Integer.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
+        assertEquals(0, IntStreamEx.range(0, Integer.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
+
+        assertThrows(IllegalArgumentException.class, () -> IntStreamEx.range(0, 1000, 0));
+    }
+
+    @Test
+    public void testRangeClosedStep() {
+        assertArrayEquals(new int[] { 0 }, IntStreamEx.rangeClosed(0, 1000, 100000).toArray());
+        assertArrayEquals(new int[] { 0, 1000 }, IntStreamEx.rangeClosed(0, 1000, 1000).toArray());
+        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(0, Integer.MAX_VALUE,
+            Integer.MAX_VALUE - 1).toArray());
+        assertArrayEquals(new int[] { 0, Integer.MAX_VALUE }, IntStreamEx.rangeClosed(0, Integer.MAX_VALUE,
+            Integer.MAX_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(
+            Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MIN_VALUE, -1, Integer.MAX_VALUE - 1 }, IntStreamEx.rangeClosed(
+            Integer.MIN_VALUE, Integer.MAX_VALUE - 1, Integer.MAX_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MAX_VALUE, -1 }, IntStreamEx.rangeClosed(Integer.MAX_VALUE,
+            Integer.MIN_VALUE, Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { Integer.MAX_VALUE }, IntStreamEx.rangeClosed(Integer.MAX_VALUE, 0,
+            Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { 0, Integer.MIN_VALUE }, IntStreamEx.rangeClosed(0, Integer.MIN_VALUE,
+            Integer.MIN_VALUE).toArray());
+        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.rangeClosed(0, 9, 2).toArray());
+        assertArrayEquals(new int[] { 0, 2, 4, 6, 8 }, IntStreamEx.rangeClosed(0, 8, 2).toArray());
+        assertArrayEquals(new int[] { 0, 2, 4, 6 }, IntStreamEx.rangeClosed(0, 7, 2).toArray());
+        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.rangeClosed(0, -9, -2).toArray());
+        assertArrayEquals(new int[] { 0, -2, -4, -6, -8 }, IntStreamEx.rangeClosed(0, -8, -2).toArray());
+        assertArrayEquals(new int[] { 0, -2, -4, -6 }, IntStreamEx.rangeClosed(0, -7, -2).toArray());
+        assertArrayEquals(new int[] { 5, 4, 3, 2, 1, 0 }, IntStreamEx.rangeClosed(5, 0, -1).toArray());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE - 1, 2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE - 2, 2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE, -2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE + 1L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE + 1, -2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE * 2L + 2L, IntStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 1)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Integer.MAX_VALUE * 2L + 2L, IntStreamEx.rangeClosed(Integer.MAX_VALUE, Integer.MIN_VALUE, -1)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(0, IntStreamEx.rangeClosed(0, -1000, 1).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, 1000, -1).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, 1, -1).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, -1, 1).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, -1000, 2).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, 1000, -2).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, 1, -2).count());
+        assertEquals(0, IntStreamEx.rangeClosed(0, -1, 2).count());
+        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, 1).toArray());
+        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, 2).toArray());
+        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 11, 2).toArray());
+        assertArrayEquals(new int[] {}, IntStreamEx.rangeClosed(11, 10, 2).toArray());
+        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, -1).toArray());
+        assertArrayEquals(new int[] {10}, IntStreamEx.rangeClosed(10, 10, -2).toArray());
+        assertArrayEquals(new int[] {}, IntStreamEx.rangeClosed(10, 11, -2).toArray());
+        assertArrayEquals(new int[] {11}, IntStreamEx.rangeClosed(11, 10, -2).toArray());
+
+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, -1, 3).findAny());
+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, 3, 1).findAny());
+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IntStreamEx.of(EVEN_BYTES, 3, 6).findAny());
+    }
+
+    @Test
+    public void testArrayLengthOk() {
+        assertEquals(10, IntStreamEx.of(EVEN_BYTES, 3, 5).skip(1).findFirst().getAsInt());
+    }
+
+    @Test
+    public void testOfIndices() {
+        assertArrayEquals(new int[] {}, IntStreamEx.ofIndices(new int[0]).toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new int[] { 5, -100, 1 }).toArray());
+        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new int[] { 5, -100, 1 }, i -> i > 0).toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new long[] { 5, -100, 1 }).toArray());
+        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new long[] { 5, -100, 1 }, i -> i > 0).toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new double[] { 5, -100, 1 }).toArray());
+        assertArrayEquals(new int[] { 0, 2 }, IntStreamEx.ofIndices(new double[] { 5, -100, 1 }, i -> i > 0).toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(new String[] { "a", "b", "c" }).toArray());
+        assertArrayEquals(new int[] { 1 }, IntStreamEx.ofIndices(new String[] { "a", "", "c" }, String::isEmpty)
+                .toArray());
+        assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.ofIndices(Arrays.asList("a", "b", "c")).toArray());
+        assertArrayEquals(new int[] { 1 }, IntStreamEx.ofIndices(Arrays.asList("a", "", "c"), String::isEmpty)
+                .toArray());
+    }
+
+    @Test
+    public void testBasics() {
+        assertFalse(IntStreamEx.of(1).isParallel());
+        assertTrue(IntStreamEx.of(1).parallel().isParallel());
+        assertFalse(IntStreamEx.of(1).parallel().sequential().isParallel());
+        AtomicInteger i = new AtomicInteger();
+        try (IntStreamEx s = IntStreamEx.of(1).onClose(i::incrementAndGet)) {
+            assertEquals(1, s.count());
+        }
+        assertEquals(1, i.get());
+        assertEquals(6, IntStreamEx.range(0, 4).sum());
+        assertEquals(3, IntStreamEx.range(0, 4).max().getAsInt());
+        assertEquals(0, IntStreamEx.range(0, 4).min().getAsInt());
+        assertEquals(1.5, IntStreamEx.range(0, 4).average().getAsDouble(), 0.000001);
+        assertEquals(4, IntStreamEx.range(0, 4).summaryStatistics().getCount());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(0, 5).skip(1).limit(3).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(3, 1, 2).sorted().toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 1, 3, 2).distinct().toArray());
+        assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.range(1, 4).map(x -> x * 2).toArray());
+        assertArrayEquals(new long[] { 2, 4, 6 }, IntStreamEx.range(1, 4).mapToLong(x -> x * 2).toArray());
+        assertArrayEquals(new double[] { 2, 4, 6 }, IntStreamEx.range(1, 4).mapToDouble(x -> x * 2).toArray(), 0.0);
+        assertArrayEquals(new int[] { 1, 3 }, IntStreamEx.range(0, 5).filter(x -> x % 2 == 1).toArray());
+        assertEquals(6, IntStreamEx.of(1, 2, 3).reduce(Integer::sum).getAsInt());
+        assertEquals(Integer.MAX_VALUE, IntStreamEx.rangeClosed(1, Integer.MAX_VALUE).spliterator()
+                .getExactSizeIfKnown());
+
+        assertTrue(IntStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
+        assertFalse(IntStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
+
+        OfInt iterator = IntStreamEx.of(1, 2, 3).iterator();
+        assertEquals(1, iterator.nextInt());
+        assertEquals(2, iterator.nextInt());
+        assertEquals(3, iterator.nextInt());
+        assertFalse(iterator.hasNext());
+
+        List<Integer> list = new ArrayList<>();
+        IntStreamEx.range(10).parallel().forEachOrdered(list::add);
+        assertEquals(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9), list);
+
+        assertTrue(IntStreamEx.empty().noneMatch(x -> true));
+        assertFalse(IntStreamEx.of(1).noneMatch(x -> true));
+        assertTrue(IntStreamEx.of(1).noneMatch(x -> false));
+    }
+    
+    @Test
+    public void testForEach() {
+        streamEx(() -> StreamEx.of(1, 2, 3), s -> {
+            AtomicInteger count = new AtomicInteger(0);
+            s.get().mapToInt(Integer::intValue).forEach(count::addAndGet);
+            assertEquals(6, count.get());
+            s.get().mapToInt(Integer::intValue).pairMap((a, b) -> b - a).forEach(count::addAndGet);
+            assertEquals(8, count.get());
+        });
+    }
+
+    @Test
+    public void testFlatMap() {
+        long[][] vals = { { 1, 2, 3 }, { 2, 3, 4 }, { 5, 4, Long.MAX_VALUE, Long.MIN_VALUE } };
+        assertArrayEquals(new long[] { 1, 2, 3, 2, 3, 4, 5, 4, Long.MAX_VALUE, Long.MIN_VALUE }, IntStreamEx.ofIndices(
+            vals).flatMapToLong(idx -> Arrays.stream(vals[idx])).toArray());
+        String expected = IntStream.range(0, 200).boxed().flatMap(
+            i -> IntStream.range(0, i).mapToObj(j -> i + ":" + j)).collect(Collectors.joining("/"));
+        String res = IntStreamEx.range(200).flatMapToObj(i -> IntStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining(
+            "/");
+        String parallel = IntStreamEx.range(200).parallel().flatMapToObj(
+            i -> IntStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining("/");
+        assertEquals(expected, res);
+        assertEquals(expected, parallel);
+
+        double[] fractions = IntStreamEx.range(1, 5).flatMapToDouble(
+            i -> IntStreamEx.range(1, i).mapToDouble(j -> ((double) j) / i)).toArray();
+        assertArrayEquals(new double[] { 1 / 2.0, 1 / 3.0, 2 / 3.0, 1 / 4.0, 2 / 4.0, 3 / 4.0 }, fractions, 0.000001);
+
+        assertArrayEquals(new int[] { 0, 0, 1, 0, 1, 2 }, IntStreamEx.of(1, 2, 3).flatMap(IntStreamEx::range).toArray());
+    }
+
+    @Test
+    public void testElements() {
+        assertEquals(Arrays.asList("f", "d", "b"), IntStreamEx.of(5, 3, 1).elements("abcdef".split("")).toList());
+        assertEquals(Arrays.asList("f", "d", "b"), IntStreamEx.of(5, 3, 1).elements(
+            Arrays.asList("a", "b", "c", "d", "e", "f")).toList());
+        assertArrayEquals(new int[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(new int[] { 0, 2, 4, 6, 8, 10 })
+                .toArray());
+        assertArrayEquals(new long[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(new long[] { 0, 2, 4, 6, 8, 10 })
+                .toArray());
+        assertArrayEquals(new double[] { 10, 6, 2 }, IntStreamEx.of(5, 3, 1).elements(
+            new double[] { 0, 2, 4, 6, 8, 10 }).toArray(), 0.0);
+    }
+
+    @Test
+    public void testPrepend() {
+        assertArrayEquals(new int[] { -1, 0, 1, 2, 3 }, IntStreamEx.of(1, 2, 3).prepend(-1, 0).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).prepend().toArray());
+        assertArrayEquals(new int[] { 10, 11, 0, 1, 2, 3 }, IntStreamEx.range(0, 4).prepend(IntStreamEx.range(10, 12))
+                .toArray());
+    }
+
+    @Test
+    public void testAppend() {
+        assertArrayEquals(new int[] { 1, 2, 3, 4, 5 }, IntStreamEx.of(1, 2, 3).append(4, 5).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.of(1, 2, 3).append().toArray());
+        assertArrayEquals(new int[] { 0, 1, 2, 3, 10, 11 }, IntStreamEx.range(0, 4).append(IntStreamEx.range(10, 12))
+                .toArray());
+    }
+
+    @Test
+    public void testHas() {
+        assertTrue(IntStreamEx.range(1, 4).has(3));
+        assertFalse(IntStreamEx.range(1, 4).has(4));
+    }
+
+    @Test
+    public void testWithout() {
+        assertArrayEquals(new int[] { 1, 2 }, IntStreamEx.range(1, 4).without(3).toArray());
+        assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(1, 4).without(5).toArray());
+        IntStreamEx ise = IntStreamEx.range(5);
+        assertSame(ise, ise.without());
+        assertArrayEquals(new int[] { 0, 1, 3, 4 }, IntStreamEx.range(5).without(new int[] { 2 }).toArray());
+        assertArrayEquals(new int[] { 0 }, IntStreamEx.range(5).without(1, 2, 3, 4, 5, 6).toArray());
+    }
+
+    @Test
+    public void testRanges() {
+        assertArrayEquals(new int[] { 5, 4, Integer.MAX_VALUE }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE)
+                .greater(3).toArray());
+        assertArrayEquals(new int[] { 5, 3, 4, Integer.MAX_VALUE }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE)
+                .atLeast(3).toArray());
+        assertArrayEquals(new int[] { 1, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).less(3).toArray());
+        assertArrayEquals(new int[] { 1, 3, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).atMost(3).toArray());
+        assertArrayEquals(new int[] { 1, 3, 4, -1 }, IntStreamEx.of(1, 5, 3, 4, -1, Integer.MAX_VALUE).atMost(4).toArray());
+    }
+
+    @Test
+    public void testToBitSet() {
+        assertEquals("{0, 1, 2, 3, 4}", IntStreamEx.range(5).toBitSet().toString());
+        assertEquals("{0, 2, 3, 4, 10}", IntStreamEx.of(0, 2, 0, 3, 0, 4, 0, 10).parallel().toBitSet().toString());
+    }
+
+    @Test
+    public void testAs() {
+        assertEquals(4, IntStreamEx.range(0, 5).asLongStream().findAny(x -> x > 3).getAsLong());
+        assertEquals(4.0, IntStreamEx.range(0, 5).asDoubleStream().findAny(x -> x > 3).getAsDouble(), 0.0);
+    }
+
+    @Test
+    public void testFind() {
+        assertEquals(6, IntStreamEx.range(1, 10).findFirst(i -> i > 5).getAsInt());
+        assertFalse(IntStreamEx.range(1, 10).findAny(i -> i > 10).isPresent());
+    }
+
+    @Test
+    public void testRemove() {
+        assertArrayEquals(new int[] { 1, 2 }, IntStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray());
+    }
+
+    @Test
+    public void testSort() {
+        assertArrayEquals(new int[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, IntStreamEx.range(0, 9).sortedByInt(
+            i -> i % 3 * 3 + i / 3).toArray());
+        assertArrayEquals(new int[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, IntStreamEx.range(0, 9).sortedByLong(
+            i -> (long) i % 3 * Integer.MAX_VALUE + i / 3).toArray());
+        assertArrayEquals(new int[] { 8, 7, 6, 5, 4, 3, 2, 1 }, IntStreamEx.range(1, 9).sortedByDouble(i -> 1.0 / i)
+                .toArray());
+        assertArrayEquals(new int[] { 10, 11, 5, 6, 7, 8, 9 }, IntStreamEx.range(5, 12).sortedBy(String::valueOf)
+                .toArray());
+        assertArrayEquals(new int[] { Integer.MAX_VALUE, 1000, 1, 0, -10, Integer.MIN_VALUE }, IntStreamEx.of(0, 1,
+            1000, -10, Integer.MIN_VALUE, Integer.MAX_VALUE).reverseSorted().toArray());
+    }
+
+    @Test
+    public void testToString() {
+        assertEquals("LOWERCASE", IntStreamEx.ofChars("lowercase").map(c -> Character.toUpperCase((char) c))
+                .charsToString());
+        assertEquals("LOWERCASE", IntStreamEx.ofCodePoints("lowercase").map(Character::toUpperCase)
+                .codePointsToString());
+    }
+
+    @SafeVarargs
+    private static void checkEmpty(Function<IntStreamEx, OptionalInt>... fns) {
+        int i = 0;
+        for (Function<IntStreamEx, OptionalInt> fn : fns) {
+            assertFalse("#" + i, fn.apply(IntStreamEx.empty()).isPresent());
+            assertFalse("#" + i, fn.apply(IntStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
+            assertEquals("#" + i, 10, fn.apply(IntStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
+                    .getAsInt());
+            i++;
+        }
+    }
+
+    @Test
+    public void testMinMax() {
+        checkEmpty(s -> s.maxBy(Integer::valueOf), s -> s.maxByInt(x -> x), s -> s.maxByLong(x -> x), s -> s
+                .maxByDouble(x -> x), s -> s.minBy(Integer::valueOf), s -> s.minByInt(x -> x),
+            s -> s.minByLong(x -> x), s -> s.minByDouble(x -> x));
+        assertEquals(9, IntStreamEx.range(5, 12).max(Comparator.comparing(String::valueOf)).getAsInt());
+        assertEquals(10, IntStreamEx.range(5, 12).min(Comparator.comparing(String::valueOf)).getAsInt());
+        assertEquals(9, IntStreamEx.range(5, 12).maxBy(String::valueOf).getAsInt());
+        assertEquals(10, IntStreamEx.range(5, 12).minBy(String::valueOf).getAsInt());
+        assertEquals(5, IntStreamEx.range(5, 12).maxByDouble(x -> 1.0 / x).getAsInt());
+        assertEquals(11, IntStreamEx.range(5, 12).minByDouble(x -> 1.0 / x).getAsInt());
+        assertEquals(29, IntStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> x % 10 * 10 + x / 10).getAsInt());
+        assertEquals(31, IntStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> x % 10 * 10 + x / 10).getAsInt());
+        assertEquals(29, IntStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> Long.MIN_VALUE + x % 10 * 10 + x / 10)
+                .getAsInt());
+        assertEquals(31, IntStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> Long.MIN_VALUE + x % 10 * 10 + x / 10)
+                .getAsInt());
+
+        Supplier<IntStreamEx> s = () -> IntStreamEx.of(1, 50, 120, 35, 130, 12, 0);
+        IntUnaryOperator intKey = x -> String.valueOf(x).length();
+        IntToLongFunction longKey = x -> String.valueOf(x).length();
+        IntToDoubleFunction doubleKey = x -> String.valueOf(x).length();
+        IntFunction<Integer> objKey = x -> String.valueOf(x).length();
+        List<Function<IntStreamEx, OptionalInt>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
+                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
+        List<Function<IntStreamEx, OptionalInt>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
+                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsInt()));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsInt()));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsInt()));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsInt()));
+    }
+
+    private static IntStreamEx dropLast(IntStreamEx s) {
+        return s.pairMap((a, b) -> a);
+    }
+
+    @Test
+    public void testPairMap() {
+        assertEquals(0, IntStreamEx.range(0).pairMap(Integer::sum).count());
+        assertEquals(0, IntStreamEx.range(1).pairMap(Integer::sum).count());
+        assertEquals(Collections.singletonMap(1, 9999L), IntStreamEx.range(10000).pairMap((a, b) -> b - a).boxed()
+                .groupingBy(Function.identity(), Collectors.counting()));
+        assertEquals(Collections.singletonMap(1, 9999L), IntStreamEx.range(10000).parallel().pairMap((a, b) -> b - a)
+                .boxed().groupingBy(Function.identity(), Collectors.counting()));
+        assertEquals("Test Capitalization Stream", IntStreamEx.ofChars("test caPiTaliZation streaM").parallel()
+                .prepend(0).pairMap(
+                    (c1, c2) -> !Character.isLetter(c1) && Character.isLetter(c2) ? Character.toTitleCase(c2)
+                            : Character.toLowerCase(c2)).charsToString());
+        assertArrayEquals(IntStreamEx.range(9999).toArray(), dropLast(IntStreamEx.range(10000)).toArray());
+
+        withRandom(r -> {
+            int[] data = r.ints(1000, 1, 1000).toArray();
+            int[] expected = new int[data.length - 1];
+            int lastSquare = data[0] * data[0];
+            for (int i = 0; i < expected.length; i++) {
+                int newSquare = data[i + 1] * data[i + 1];
+                expected[i] = newSquare - lastSquare;
+                lastSquare = newSquare;
+            }
+            int[] result = IntStreamEx.of(data).map(x -> x * x).pairMap((a, b) -> b - a).toArray();
+            assertArrayEquals(expected, result);
+        });
+
+        assertEquals(1, IntStreamEx.range(1000).map(x -> x * x).pairMap((a, b) -> b - a).pairMap((a, b) -> b - a)
+                .distinct().count());
+
+        assertArrayEquals(IntStreamEx.constant(1, 100).toArray(), IntStreamEx.iterate(0, i -> i + 1).parallel()
+                .pairMap((a, b) -> b - a).limit(100).toArray());
+
+        assertFalse(IntStreamEx.range(1000).greater(2000).parallel().pairMap((a, b) -> a).findFirst().isPresent());
+    }
+
+    @Test
+    public void testToByteArray() {
+        byte[] expected = new byte[10000];
+        for (int i = 0; i < expected.length; i++)
+            expected[i] = (byte) i;
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toByteArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toByteArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toByteArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toByteArray());
+        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
+        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toByteArray());
+    }
+
+    @Test
+    public void testToCharArray() {
+        char[] expected = new char[10000];
+        for (int i = 0; i < expected.length; i++)
+            expected[i] = (char) i;
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toCharArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toCharArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toCharArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toCharArray());
+        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
+        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toCharArray());
+    }
+
+    @Test
+    public void testToShortArray() {
+        short[] expected = new short[10000];
+        for (int i = 0; i < expected.length; i++)
+            expected[i] = (short) i;
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).toShortArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().toShortArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).greater(-1).toShortArray());
+        assertArrayEquals(expected, IntStreamEx.range(0, 10000).parallel().greater(-1).toShortArray());
+        // Test when resize of internal buffer is not required on addAll (buffer size = 128)
+        assertArrayEquals(Arrays.copyOf(expected, 100), IntStreamEx.range(0, 100).parallel().toShortArray());
+    }
+
+    @Test
+    public void testJoining() {
+        assertEquals("0,1,2,3,4,5,6,7,8,9", IntStreamEx.range(10).joining(","));
+        assertEquals("0,1,2,3,4,5,6,7,8,9", IntStreamEx.range(10).parallel().joining(","));
+        assertEquals("[0,1,2,3,4,5,6,7,8,9]", IntStreamEx.range(10).joining(",", "[", "]"));
+        assertEquals("[0,1,2,3,4,5,6,7,8,9]", IntStreamEx.range(10).parallel().joining(",", "[", "]"));
+    }
+
+    @Test
+    public void testMapToEntry() {
+        Map<Integer, List<Integer>> result = IntStreamEx.range(10).mapToEntry(x -> x % 2, x -> x).grouping();
+        assertEquals(Arrays.asList(0, 2, 4, 6, 8), result.get(0));
+        assertEquals(Arrays.asList(1, 3, 5, 7, 9), result.get(1));
+    }
+
+    @Test
+    public void testTakeWhile() {
+        assertArrayEquals(IntStreamEx.range(100).toArray(), IntStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 100)
+                .toArray());
+        assertEquals(0, IntStreamEx.empty().takeWhile(i -> true).count());
+        assertEquals(0, IntStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
+        assertEquals(1, IntStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
+        assertEquals(3, IntStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
+    }
+
+    @Test
+    public void testTakeWhileInclusive() {
+        assertArrayEquals(IntStreamEx.range(101).toArray(), IntStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(
+            i -> i < 100).toArray());
+        assertEquals(0, IntStreamEx.empty().takeWhileInclusive(i -> true).count());
+        assertEquals(1, IntStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
+        assertEquals(2, IntStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
+        assertEquals(3, IntStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
+    }
+    
+    @Test
+    public void testDropWhile() {
+        assertArrayEquals(new int[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, IntStreamEx.range(100).dropWhile(
+            i -> i % 10 < 5).limit(10).toArray());
+        assertEquals(100, IntStreamEx.range(100).dropWhile(i -> i % 10 < 0).count());
+        assertEquals(0, IntStreamEx.range(100).dropWhile(i -> i % 10 < 10).count());
+        assertEquals(OptionalInt.of(0), IntStreamEx.range(100).dropWhile(i -> i % 10 < 0).findFirst());
+        assertEquals(OptionalInt.empty(), IntStreamEx.range(100).dropWhile(i -> i % 10 < 10).findFirst());
+
+        java.util.Spliterator.OfInt spltr = IntStreamEx.range(100).dropWhile(i -> i % 10 < 1).spliterator();
+        assertTrue(spltr.tryAdvance((int x) -> assertEquals(1, x)));
+        Builder builder = IntStream.builder();
+        spltr.forEachRemaining(builder);
+        assertArrayEquals(IntStreamEx.range(2, 100).toArray(), builder.build().toArray());
+    }
+
+    @Test
+    public void testIndexOf() {
+        assertEquals(5, IntStreamEx.range(50, 100).indexOf(55).getAsLong());
+        assertFalse(IntStreamEx.range(50, 100).indexOf(200).isPresent());
+        assertEquals(5, IntStreamEx.range(50, 100).parallel().indexOf(55).getAsLong());
+        assertFalse(IntStreamEx.range(50, 100).parallel().indexOf(200).isPresent());
+
+        assertEquals(11, IntStreamEx.range(50, 100).indexOf(x -> x > 60).getAsLong());
+        assertFalse(IntStreamEx.range(50, 100).indexOf(x -> x < 0).isPresent());
+        assertEquals(11, IntStreamEx.range(50, 100).parallel().indexOf(x -> x > 60).getAsLong());
+        assertFalse(IntStreamEx.range(50, 100).parallel().indexOf(x -> x < 0).isPresent());
+    }
+
+    @Test
+    public void testFoldLeft() {
+        // non-associative
+        IntBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
+        assertEquals(2322576, IntStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1));
+        assertEquals(2322576, IntStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1));
+        assertFalse(IntStreamEx.empty().foldLeft(accumulator).isPresent());
+        assertEquals(144, IntStreamEx.rangeClosed(1, 3).foldLeft(0, accumulator));
+        assertEquals(144, IntStreamEx.rangeClosed(1, 3).parallel().foldLeft(0, accumulator));
+    }
+
+    @Test
+    public void testMapFirstLast() {
+        // capitalize
+        String str = "testString";
+        assertEquals("TestString", IntStreamEx.ofCodePoints(str).mapFirst(Character::toUpperCase).codePointsToString());
+
+        streamEx(() -> StreamEx.of(1, 2, 3, 4, 5), s ->
+                assertArrayEquals(new int[] { -3, 2, 3, 4, 9 }, s.get().mapToInt(Integer::intValue)
+                        .mapFirst(x -> x - 2).mapLast(x -> x + 2)
+                        .mapFirst(x -> x - 2).mapLast(x -> x + 2).toArray()));
+    }
+
+    @Test
+    public void testPeekFirst() {
+        int[] input = {1, 10, 100, 1000};
+        
+        AtomicInteger firstElement = new AtomicInteger();
+        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
+        assertEquals(1, firstElement.get());
+
+        assertArrayEquals(new int[] {10, 100, 1000}, IntStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
+        assertEquals(10, firstElement.get());
+        
+        firstElement.set(-1);
+        assertArrayEquals(new int[] {}, IntStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
+        assertEquals(-1, firstElement.get());
+    }
+    
+    @Test
+    public void testPeekLast() {
+        int[] input = {1, 10, 100, 1000};
+        AtomicInteger lastElement = new AtomicInteger(-1);
+        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
+        assertEquals(-1, lastElement.get());
+
+        assertArrayEquals(new int[] { 1, 10, 100 }, IntStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray());
+        assertEquals(100, lastElement.get());
+        
+        assertArrayEquals(input, IntStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
+        assertEquals(1000, lastElement.get());
+        
+        assertArrayEquals(new int[] {1, 10, 100}, IntStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
+        assertEquals(100, lastElement.get());
+    }
+    
+    @Test
+    public void testScanLeft() {
+        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10)
+                .scanLeft(Integer::sum));
+        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).parallel().scanLeft(
+            Integer::sum));
+        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).filter(x -> true)
+                .scanLeft(Integer::sum));
+        assertArrayEquals(new int[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, IntStreamEx.range(10).filter(x -> true)
+                .parallel().scanLeft(Integer::sum));
+        assertArrayEquals(new int[] { 1, 1, 2, 6, 24, 120 }, IntStreamEx.rangeClosed(1, 5).scanLeft(1, (a, b) -> a * b));
+        assertArrayEquals(new int[] { 1, 1, 2, 6, 24, 120 }, IntStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
+            (a, b) -> a * b));
+    }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    public static IntStreamEx scannerInts(Scanner sc) {
+        return IntStreamEx.produce(action -> {
+            if (sc.hasNextInt())
+                action.accept(sc.nextInt());
+            return sc.hasNextInt();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
+        assertArrayEquals(new int[] {1, 2, 3, 4}, scannerInts(sc).stream().toArray());
+        assertEquals("20000000000", sc.next());
+    }
+    
+    @Test
+    public void testOfInputStream() {
+        byte[] data = new byte[] { 5, 3, 10, 1, 4, -1 };
+        try (IntStream s = IntStreamEx.of(new ByteArrayInputStream(data))) {
+            assertEquals(22, s.map(b -> (byte) b).sum());
+        }
+        try (IntStream s = IntStreamEx.of(new ByteArrayInputStream(data))) {
+            assertEquals(278, s.sum());
+        }
+        InputStream is = new InputStream() {
+            @Override
+            public int read() throws IOException {
+                throw new IOException();
+            }
+
+            @Override
+            public void close() throws IOException {
+                throw new IOException();
+            }
+        };
+        IntStreamEx stream = IntStreamEx.of(is).filter(x -> x > 0);
+        assertThrows(UncheckedIOException.class, stream::count);
+        assertThrows(UncheckedIOException.class, stream::close);
+    }
+    
+    @Test
+    public void testAsInputStream() throws IOException {
+        AtomicBoolean flag = new AtomicBoolean(false);
+        InputStream is = IntStreamEx.range(256).onClose(() -> flag.set(true)).asByteInputStream();
+        byte[] data = new byte[256];
+        assertEquals(2, is.skip(2));
+        assertEquals(254, is.read(data));
+        assertEquals(-1, is.read());
+        for (int i = 0; i < 254; i++) {
+            assertEquals((byte) (i + 2), data[i]);
+        }
+        assertEquals(0, data[254]);
+        assertEquals(0, data[255]);
+        assertFalse(flag.get());
+        is.close();
+        assertTrue(flag.get());
+    }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new int[] { 1, 3, 6, 10, 20 }, IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).toArray());
+        assertEquals(OptionalInt.of(10), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalInt.empty(), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 20));
+        assertEquals(49995000, IntStreamEx.range(10000).unordered().prefix(Integer::sum).max().getAsInt());
+        assertEquals(49995000, IntStreamEx.range(10000).unordered().parallel().prefix(Integer::sum).max().getAsInt());
+    }
+    
+    @Test
+    public void testIntersperse() {
+        assertArrayEquals(new int[] { 1, 0, 10, 0, 100, 0, 1000 }, IntStreamEx.of(1, 10, 100, 1000).intersperse(0)
+                .toArray());
+        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
+    }
+}
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index 2b0151b..10e0f3c 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -1,618 +1,620 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.nio.LongBuffer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.OptionalLong;
-import java.util.PrimitiveIterator.OfLong;
-import java.util.Random;
-import java.util.Scanner;
-import java.util.Spliterator;
-import java.util.Spliterators;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.Function;
-import java.util.function.LongBinaryOperator;
-import java.util.function.LongConsumer;
-import java.util.function.LongFunction;
-import java.util.function.LongToDoubleFunction;
-import java.util.function.LongToIntFunction;
-import java.util.function.LongUnaryOperator;
-import java.util.function.Supplier;
-import java.util.stream.LongStream;
-import java.util.stream.LongStream.Builder;
-
-import org.junit.FixMethodOrder;
-import org.junit.Test;
-import org.junit.runners.MethodSorters;
-
-import static one.util.streamex.TestHelpers.assertThrows;
-import static one.util.streamex.TestHelpers.checkSpliterator;
-import static one.util.streamex.TestHelpers.streamEx;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Tagir Valeev
- */
-@FixMethodOrder(MethodSorters.NAME_ASCENDING)
-public class LongStreamExTest {
-    final LongConsumer EMPTY = l -> {
-        // nothing
-    };
-
-    @Test
-    public void testCreate() {
-        assertArrayEquals(new long[] {}, LongStreamEx.empty().toArray());
-        // double test is intended
-        assertArrayEquals(new long[] {}, LongStreamEx.empty().toArray());
-        assertArrayEquals(new long[] { 1 }, LongStreamEx.of(1).toArray());
-        assertArrayEquals(new long[] { 1 }, LongStreamEx.of(OptionalLong.of(1)).toArray());
-        assertArrayEquals(new long[] {}, LongStreamEx.of(OptionalLong.empty()).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).toArray());
-        assertArrayEquals(new long[] { 4, 6 }, LongStreamEx.of(new long[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(LongStream.of(1, 2, 3)).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(Arrays.asList(1L, 2L, 3L)).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(1L, 4L).toArray());
-        assertArrayEquals(new long[] { 0, 1, 2 }, LongStreamEx.range(3L).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.rangeClosed(1, 3).toArray());
-        assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.generate(() -> 1).limit(4).toArray());
-        assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.constant(1L, 4).toArray());
-        assertEquals(10, LongStreamEx.of(new Random(), 10).count());
-        assertTrue(LongStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
-        assertArrayEquals(LongStreamEx.of(new Random(1), 100, 1, 10).toArray(), LongStreamEx.of(new Random(1), 1, 10)
-                .limit(100).toArray());
-        assertArrayEquals(LongStreamEx.of(new Random(1), 100).toArray(), LongStreamEx.of(new Random(1)).limit(100)
-                .toArray());
-
-        LongStream stream = LongStreamEx.of(1, 2, 3);
-        assertSame(stream, LongStreamEx.of(stream));
-
-        assertArrayEquals(new long[] { 4, 2, 0, -2, -4 }, LongStreamEx.zip(new long[] { 5, 4, 3, 2, 1 },
-            new long[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray());
-
-        assertArrayEquals(new long[] { 1, 5, 3 }, LongStreamEx.of(Spliterators.spliterator(new long[] { 1, 5, 3 }, 0))
-                .toArray());
-        assertArrayEquals(new long[] { 1, 5, 3 }, LongStreamEx.of(
-            Spliterators.iterator(Spliterators.spliterator(new long[] { 1, 5, 3 }, 0))).toArray());
-        assertArrayEquals(new long[0], LongStreamEx.of(Spliterators.iterator(Spliterators.emptyLongSpliterator()))
-                .parallel().toArray());
-
-        assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.of(new Long[] { 2L, 4L, 6L }).toArray());
-    }
-
-    @Test
-    public void testOfLongBuffer() {
-        long[] data = LongStreamEx.range(100).toArray();
-        assertArrayEquals(data, LongStreamEx.of(LongBuffer.wrap(data)).toArray());
-        assertArrayEquals(LongStreamEx.range(50, 70).toArray(), LongStreamEx.of(LongBuffer.wrap(data, 50, 20)).toArray());
-        assertArrayEquals(data, LongStreamEx.of(LongBuffer.wrap(data)).parallel().toArray());
-        assertArrayEquals(LongStreamEx.range(50, 70).toArray(), LongStreamEx.of(LongBuffer.wrap(data, 50, 20)).parallel()
-                .toArray());
-    }
-
-    @Test
-    public void testIterate() {
-        assertArrayEquals(new long[] { 1, 2, 4, 8, 16 }, LongStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
-        assertArrayEquals(new long[] { 1, 2, 4, 8, 16, 32, 64 }, LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
-        assertEquals(0, LongStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
-        assertFalse(LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
-        checkSpliterator("iterate", () -> LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
-    }
-
-    @Test
-    public void testLongs() {
-        assertEquals(Long.MAX_VALUE, LongStreamEx.longs().spliterator().getExactSizeIfKnown());
-        assertArrayEquals(new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, LongStreamEx.longs().limit(10).toArray());
-    }
-
-    @Test
-    public void testRangeStep() {
-        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(0, 1000, 100000).toArray());
-        assertArrayEquals(new long[] { 0, Long.MAX_VALUE - 1 }, LongStreamEx.range(0, Long.MAX_VALUE,
-            Long.MAX_VALUE - 1).toArray());
-        assertArrayEquals(new long[] { Long.MIN_VALUE, -1, Long.MAX_VALUE - 1 }, LongStreamEx.range(Long.MIN_VALUE,
-            Long.MAX_VALUE, Long.MAX_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MIN_VALUE, -1 }, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE - 1,
-            Long.MAX_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE, -1 }, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE,
-            Long.MIN_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.range(Long.MAX_VALUE, 0, Long.MIN_VALUE)
-                .toArray());
-        assertArrayEquals(new long[] { 1, Long.MIN_VALUE + 1 }, LongStreamEx.range(1, Long.MIN_VALUE, Long.MIN_VALUE)
-                .toArray());
-        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(0, Long.MIN_VALUE, Long.MIN_VALUE).toArray());
-        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.range(0, 9, 2).toArray());
-        assertArrayEquals(new long[] { 0, 2, 4, 6 }, LongStreamEx.range(0, 8, 2).toArray());
-        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.range(0, -9, -2).toArray());
-        assertArrayEquals(new long[] { 0, -2, -4, -6 }, LongStreamEx.range(0, -8, -2).toArray());
-        assertArrayEquals(new long[] { 5, 4, 3, 2, 1, 0 }, LongStreamEx.range(5, -1, -1).toArray());
-        assertEquals(Integer.MAX_VALUE + 1L, LongStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(Long.MAX_VALUE, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE - 1, 2).spliterator()
-                .getExactSizeIfKnown());
-        java.util.Spliterator.OfLong spliterator = LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE, -2).spliterator();
-        assertEquals(-1, spliterator.getExactSizeIfKnown());
-        assertTrue(spliterator.tryAdvance(EMPTY));
-        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
-        assertTrue(spliterator.tryAdvance(EMPTY));
-        assertEquals(Long.MAX_VALUE - 1, spliterator.estimateSize());
-        assertEquals(Long.MAX_VALUE, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE + 1, -2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(-1, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE, 1).spliterator().getExactSizeIfKnown());
-        assertEquals(-1, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE, -1).spliterator().getExactSizeIfKnown());
-        assertEquals(0, LongStreamEx.range(0, -1000, 1).count());
-        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, 1).toArray());
-        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, 2).toArray());
-        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 11, 2).toArray());
-        assertArrayEquals(new long[] {}, LongStreamEx.rangeClosed(11, 10, 2).toArray());
-        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, -1).toArray());
-        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, -2).toArray());
-        assertArrayEquals(new long[] {}, LongStreamEx.rangeClosed(10, 11, -2).toArray());
-        assertArrayEquals(new long[] {11}, LongStreamEx.rangeClosed(11, 10, -2).toArray());
-        assertEquals(0, LongStreamEx.range(0, 1000, -1).count());
-        assertEquals(0, LongStreamEx.range(0, 0, -1).count());
-        assertEquals(0, LongStreamEx.range(0, 0, 1).count());
-        assertEquals(0, LongStreamEx.range(0, -1000, 2).count());
-        assertEquals(0, LongStreamEx.range(0, 1000, -2).count());
-        assertEquals(0, LongStreamEx.range(0, 0, -2).count());
-        assertEquals(0, LongStreamEx.range(0, 0, 2).count());
-
-        assertEquals(0, LongStreamEx.range(0, Long.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
-        assertEquals(0, LongStreamEx.range(0, Long.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
-
-        assertThrows(IllegalArgumentException.class, () -> LongStreamEx.range(0, 1000, 0));
-    }
-
-    @Test
-    public void testRangeClosedStep() {
-        assertArrayEquals(new long[] { 0 }, LongStreamEx.rangeClosed(0, 1000, 100000).toArray());
-        assertArrayEquals(new long[] { 0, 1000 }, LongStreamEx.rangeClosed(0, 1000, 1000).toArray());
-        assertArrayEquals(new long[] { 0, Long.MAX_VALUE - 1 }, LongStreamEx.rangeClosed(0, Long.MAX_VALUE - 1,
-            Long.MAX_VALUE - 1).toArray());
-        assertArrayEquals(new long[] { Long.MIN_VALUE, -1, Long.MAX_VALUE - 1 }, LongStreamEx.rangeClosed(
-            Long.MIN_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MIN_VALUE, -1 }, LongStreamEx.rangeClosed(Long.MIN_VALUE,
-            Long.MAX_VALUE - 2, Long.MAX_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE, -1 }, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE,
-            Long.MIN_VALUE).toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.rangeClosed(Long.MAX_VALUE, 0, Long.MIN_VALUE)
-                .toArray());
-        assertArrayEquals(new long[] { 0, Long.MIN_VALUE }, LongStreamEx.rangeClosed(0, Long.MIN_VALUE, Long.MIN_VALUE)
-                .toArray());
-        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.rangeClosed(0, 9, 2).toArray());
-        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.rangeClosed(0, 8, 2).toArray());
-        assertArrayEquals(new long[] { 0, 2, 4, 6 }, LongStreamEx.rangeClosed(0, 7, 2).toArray());
-        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.rangeClosed(0, -9, -2).toArray());
-        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.rangeClosed(0, -8, -2).toArray());
-        assertArrayEquals(new long[] { 0, -2, -4, -6 }, LongStreamEx.rangeClosed(0, -7, -2).toArray());
-        assertArrayEquals(new long[] { 5, 4, 3, 2, 1, 0 }, LongStreamEx.rangeClosed(5, 0, -1).toArray());
-        assertEquals(Integer.MAX_VALUE + 1L, LongStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 2)
-                .spliterator().getExactSizeIfKnown());
-        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(Long.MIN_VALUE, Long.MAX_VALUE - 2, 2).spliterator()
-                .getExactSizeIfKnown());
-        java.util.Spliterator.OfLong spliterator = LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE, -2)
-                .spliterator();
-        assertEquals(-1, spliterator.getExactSizeIfKnown());
-        assertTrue(spliterator.tryAdvance(EMPTY));
-        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
-        assertTrue(spliterator.tryAdvance(EMPTY));
-        assertEquals(Long.MAX_VALUE - 1, spliterator.estimateSize());
-        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE + 2, -2).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(-1, LongStreamEx.rangeClosed(Long.MIN_VALUE, Long.MAX_VALUE, 1).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(-1, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE, -1).spliterator()
-                .getExactSizeIfKnown());
-        assertEquals(0, LongStreamEx.rangeClosed(0, -1000, 1).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, 1000, -1).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, 1, -1).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, -1, 1).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, -1000, 2).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, 1000, -2).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, 1, -2).count());
-        assertEquals(0, LongStreamEx.rangeClosed(0, -1, 2).count());
-
-        assertEquals(0, LongStreamEx.rangeClosed(0, Long.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
-        assertEquals(0, LongStreamEx.rangeClosed(0, Long.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
-    }
-
-    @Test
-    public void testBasics() {
-        assertFalse(LongStreamEx.of(1).isParallel());
-        assertTrue(LongStreamEx.of(1).parallel().isParallel());
-        assertFalse(LongStreamEx.of(1).parallel().sequential().isParallel());
-        AtomicInteger i = new AtomicInteger();
-        try (LongStreamEx s = LongStreamEx.of(1).onClose(i::incrementAndGet)) {
-            assertEquals(1, s.count());
-        }
-        assertEquals(1, i.get());
-        assertEquals(6, LongStreamEx.range(0, 4).sum());
-        assertEquals(3, LongStreamEx.range(0, 4).max().getAsLong());
-        assertEquals(0, LongStreamEx.range(0, 4).min().getAsLong());
-        assertEquals(1.5, LongStreamEx.range(0, 4).average().getAsDouble(), 0.000001);
-        assertEquals(4, LongStreamEx.range(0, 4).summaryStatistics().getCount());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(0, 5).skip(1).limit(3).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(3, 1, 2).sorted().toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 1, 3, 2).distinct().toArray());
-        assertArrayEquals(new int[] { 2, 4, 6 }, LongStreamEx.range(1, 4).mapToInt(x -> (int) x * 2).toArray());
-        assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.range(1, 4).map(x -> x * 2).toArray());
-        assertArrayEquals(new double[] { 2, 4, 6 }, LongStreamEx.range(1, 4).mapToDouble(x -> x * 2).toArray(), 0.0);
-        assertArrayEquals(new long[] { 1, 3 }, LongStreamEx.range(0, 5).filter(x -> x % 2 == 1).toArray());
-        assertEquals(6, LongStreamEx.of(1, 2, 3).reduce(Long::sum).getAsLong());
-        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(1, Long.MAX_VALUE).spliterator().getExactSizeIfKnown());
-
-        assertTrue(LongStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
-        assertFalse(LongStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
-
-        OfLong iterator = LongStreamEx.of(1, 2, 3).iterator();
-        assertEquals(1L, iterator.nextLong());
-        assertEquals(2L, iterator.nextLong());
-        assertEquals(3L, iterator.nextLong());
-        assertFalse(iterator.hasNext());
-
-        AtomicInteger idx = new AtomicInteger();
-        long[] result = new long[500];
-        LongStreamEx.range(1000).atLeast(500).parallel().forEachOrdered(val -> result[idx.getAndIncrement()] = val);
-        assertArrayEquals(LongStreamEx.range(500, 1000).toArray(), result);
-
-        assertTrue(LongStreamEx.empty().noneMatch(x -> true));
-        assertFalse(LongStreamEx.of(1).noneMatch(x -> true));
-        assertTrue(LongStreamEx.of(1).noneMatch(x -> false));
-    }
-
-    @Test
-    public void testForEach() {
-        List<Long> list = new ArrayList<>();
-        LongStreamEx.of(1).forEach(list::add);
-        assertEquals(Arrays.asList(1L), list);
-        streamEx(() -> StreamEx.of(1L, 2L, 3L), s -> {
-            AtomicLong count = new AtomicLong(0);
-            s.get().mapToLong(Long::longValue).forEach(count::addAndGet);
-            assertEquals(6, count.get());
-            s.get().mapToLong(Long::longValue).pairMap((a, b) -> b - a).forEach(count::addAndGet);
-            assertEquals(8, count.get());
-        });
-    }
-
-    @Test
-    public void testFlatMap() {
-        assertArrayEquals(new long[] { 0, 0, 1, 0, 1, 2 }, LongStreamEx.of(1, 2, 3).flatMap(LongStreamEx::range)
-                .toArray());
-        assertArrayEquals(new int[] { 1, 5, 1, 4, 2, 0, 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 7 },
-            LongStreamEx.of(15, 14, 20, Long.MAX_VALUE).flatMapToInt(n -> String.valueOf(n).chars().map(x -> x - '0'))
-                    .toArray());
-
-        String expected = LongStreamEx.range(200).boxed().flatMap(
-            i -> LongStreamEx.range(0, i).mapToObj(j -> i + ":" + j)).joining("/");
-        String res = LongStreamEx.range(200).flatMapToObj(i -> LongStreamEx.range(i).mapToObj(j -> i + ":" + j))
-                .joining("/");
-        String parallel = LongStreamEx.range(200).parallel().flatMapToObj(
-            i -> LongStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining("/");
-        assertEquals(expected, res);
-        assertEquals(expected, parallel);
-
-        double[] fractions = LongStreamEx.range(1, 5).flatMapToDouble(
-            i -> LongStreamEx.range(1, i).mapToDouble(j -> ((double) j) / i)).toArray();
-        assertArrayEquals(new double[] { 1 / 2.0, 1 / 3.0, 2 / 3.0, 1 / 4.0, 2 / 4.0, 3 / 4.0 }, fractions, 0.000001);
-    }
-
-    @Test
-    public void testPrepend() {
-        assertArrayEquals(new long[] { -1, 0, 1, 2, 3 }, LongStreamEx.of(1, 2, 3).prepend(-1, 0).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).prepend().toArray());
-        assertArrayEquals(new long[] { 10, 11, 0, 1, 2, 3 }, LongStreamEx.range(0, 4).prepend(
-            LongStreamEx.range(10, 12)).toArray());
-    }
-
-    @Test
-    public void testAppend() {
-        assertArrayEquals(new long[] { 1, 2, 3, 4, 5 }, LongStreamEx.of(1, 2, 3).append(4, 5).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).append().toArray());
-        assertArrayEquals(new long[] { 0, 1, 2, 3, 10, 11 }, LongStreamEx.range(0, 4)
-                .append(LongStreamEx.range(10, 12)).toArray());
-    }
-
-    @Test
-    public void testHas() {
-        assertTrue(LongStreamEx.range(1, 4).has(3));
-        assertFalse(LongStreamEx.range(1, 4).has(4));
-    }
-
-    @Test
-    public void testWithout() {
-        assertArrayEquals(new long[] { 1, 2 }, LongStreamEx.range(1, 4).without(3).toArray());
-        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(1, 4).without(5).toArray());
-        LongStreamEx lse = LongStreamEx.range(5);
-        assertSame(lse, lse.without());
-        assertArrayEquals(new long[] { 0, 1, 3, 4 }, LongStreamEx.range(5).without(new long[] { 2 }).toArray());
-        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(5).without(1, 2, 3, 4, 5, 6).toArray());
-    }
-
-    @Test
-    public void testRanges() {
-        assertArrayEquals(new long[] { 5, 4, Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).greater(
-            3).toArray());
-        assertArrayEquals(new long[] {}, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).greater(Long.MAX_VALUE)
-                .toArray());
-        assertArrayEquals(new long[] { 5, 3, 4, Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE)
-                .atLeast(3).toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atLeast(
-            Long.MAX_VALUE).toArray());
-        assertArrayEquals(new long[] { 1, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).less(3).toArray());
-        assertArrayEquals(new long[] { 1, 3, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atMost(3).toArray());
-        assertArrayEquals(new long[] { 1, 3, 4, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atMost(4).toArray());
-    }
-
-    @Test
-    public void testFind() {
-        assertEquals(6, LongStreamEx.range(1, 10).findFirst(i -> i > 5).getAsLong());
-        assertFalse(LongStreamEx.range(1, 10).findAny(i -> i > 10).isPresent());
-    }
-
-    @Test
-    public void testRemove() {
-        assertArrayEquals(new long[] { 1, 2 }, LongStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray());
-    }
-
-    @Test
-    public void testSort() {
-        assertArrayEquals(new long[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, LongStreamEx.range(0, 9).sortedByLong(
-            i -> i % 3 * 3 + i / 3).toArray());
-        assertArrayEquals(new long[] { 0, 4, 8, 1, 5, 9, 2, 6, 3, 7 }, LongStreamEx.range(0, 10).sortedByInt(
-            i -> (int) i % 4).toArray());
-        assertArrayEquals(new long[] { 10, 11, 5, 6, 7, 8, 9 }, LongStreamEx.range(5, 12).sortedBy(String::valueOf)
-                .toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE, 1000, 1, 0, -10, Long.MIN_VALUE }, LongStreamEx.of(0, 1, 1000,
-            -10, Long.MIN_VALUE, Long.MAX_VALUE).reverseSorted().toArray());
-        assertArrayEquals(new long[] { Long.MAX_VALUE, Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MAX_VALUE - 1 },
-            LongStreamEx.of(Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MAX_VALUE - 1, Long.MAX_VALUE).sortedByLong(
-                l -> l + 1).toArray());
-        assertArrayEquals(new long[] { -10, Long.MIN_VALUE, Long.MAX_VALUE, 1000, 1, 0 }, LongStreamEx.of(0, 1, 1000,
-            -10, Long.MIN_VALUE, Long.MAX_VALUE).sortedByDouble(x -> 1.0 / x).toArray());
-    }
-
-    @SafeVarargs
-    private static void checkEmpty(Function<LongStreamEx, OptionalLong>... fns) {
-        int i = 0;
-        for (Function<LongStreamEx, OptionalLong> fn : fns) {
-            assertFalse("#" + i, fn.apply(LongStreamEx.empty()).isPresent());
-            assertFalse("#" + i, fn.apply(LongStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
-            assertEquals("#" + i, 10, fn.apply(LongStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
-                    .getAsLong());
-            i++;
-        }
-    }
-
-    @Test
-    public void testMinMax() {
-        checkEmpty(s -> s.maxBy(Long::valueOf), s -> s.maxByInt(x -> (int) x), s -> s.maxByLong(x -> x), s -> s
-                .maxByDouble(x -> x), s -> s.minBy(Long::valueOf), s -> s.minByInt(x -> (int) x), s -> s
-                .minByLong(x -> x), s -> s.minByDouble(x -> x));
-        assertEquals(9, LongStreamEx.range(5, 12).max(Comparator.comparing(String::valueOf))
-                .getAsLong());
-        assertEquals(10, LongStreamEx.range(5, 12).min(Comparator.comparing(String::valueOf))
-                .getAsLong());
-        assertEquals(9, LongStreamEx.range(5, 12).maxBy(String::valueOf).getAsLong());
-        assertEquals(10, LongStreamEx.range(5, 12).minBy(String::valueOf).getAsLong());
-        assertEquals(5, LongStreamEx.range(5, 12).maxByDouble(x -> 1.0 / x).getAsLong());
-        assertEquals(11, LongStreamEx.range(5, 12).minByDouble(x -> 1.0 / x).getAsLong());
-        assertEquals(29, LongStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> (int) (x % 10 * 10 + x / 10)).getAsLong());
-        assertEquals(31, LongStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> (int) (x % 10 * 10 + x / 10)).getAsLong());
-        assertEquals(29, LongStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> x % 10 * 10 + x / 10).getAsLong());
-        assertEquals(31, LongStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> x % 10 * 10 + x / 10).getAsLong());
-
-        Supplier<LongStreamEx> s = () -> LongStreamEx.of(1, 50, 120, 35, 130, 12, 0);
-        LongToIntFunction intKey = x -> String.valueOf(x).length();
-        LongUnaryOperator longKey = x -> String.valueOf(x).length();
-        LongToDoubleFunction doubleKey = x -> String.valueOf(x).length();
-        LongFunction<Integer> objKey = x -> String.valueOf(x).length();
-        List<Function<LongStreamEx, OptionalLong>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
-                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
-        List<Function<LongStreamEx, OptionalLong>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
-                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsLong()));
-        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsLong()));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsLong()));
-        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsLong()));
-    }
-
-    @Test
-    public void testPairMap() {
-        assertEquals(0, LongStreamEx.range(0).pairMap(Long::sum).count());
-        assertEquals(0, LongStreamEx.range(1).pairMap(Long::sum).count());
-        assertArrayEquals(new long[] { 6, 7, 8, 9, 10 }, LongStreamEx.of(1, 5, 2, 6, 3, 7).pairMap(Long::sum).toArray());
-        assertArrayEquals(LongStreamEx.range(999).map(x -> x * 2 + 1).toArray(), LongStreamEx.range(1000).parallel()
-                .map(x -> x * x).pairMap((a, b) -> b - a).toArray());
-
-        assertArrayEquals(LongStreamEx.range(1, 100).toArray(), LongStreamEx.range(100).map(i -> i * (i + 1) / 2)
-                .append(LongStream.empty()).parallel().pairMap((a, b) -> b - a).toArray());
-        assertArrayEquals(LongStreamEx.range(1, 100).toArray(), LongStreamEx.range(100).map(i -> i * (i + 1) / 2)
-                .prepend(LongStream.empty()).parallel().pairMap((a, b) -> b - a).toArray());
-
-        assertEquals(1, LongStreamEx.range(1000).map(x -> x * x).pairMap((a, b) -> b - a).pairMap((a, b) -> b - a)
-                .distinct().count());
-
-        assertFalse(LongStreamEx.range(1000).greater(2000).parallel().pairMap((a, b) -> a).findFirst().isPresent());
-    }
-
-    @Test
-    public void testJoining() {
-        assertEquals("0,1,2,3,4,5,6,7,8,9", LongStreamEx.range(10).joining(","));
-        assertEquals("0,1,2,3,4,5,6,7,8,9", LongStreamEx.range(10).parallel().joining(","));
-        assertEquals("[0,1,2,3,4,5,6,7,8,9]", LongStreamEx.range(10).joining(",", "[", "]"));
-        assertEquals("[0,1,2,3,4,5,6,7,8,9]", LongStreamEx.range(10).parallel().joining(",", "[", "]"));
-    }
-
-    @Test
-    public void testMapToEntry() {
-        Map<Long, List<Long>> result = LongStreamEx.range(10).mapToEntry(x -> x % 2, x -> x).grouping();
-        assertEquals(Arrays.asList(0L, 2L, 4L, 6L, 8L), result.get(0L));
-        assertEquals(Arrays.asList(1L, 3L, 5L, 7L, 9L), result.get(1L));
-    }
-
-    @Test
-    public void testTakeWhile() {
-        assertArrayEquals(LongStreamEx.range(100).toArray(), LongStreamEx.iterate(0, i -> i + 1)
-                .takeWhile(i -> i < 100).toArray());
-        assertEquals(0, LongStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
-        assertEquals(1, LongStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
-        assertEquals(3, LongStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
-    }
-
-    @Test
-    public void testTakeWhileInclusive() {
-        assertArrayEquals(LongStreamEx.range(101).toArray(), LongStreamEx.iterate(0, i -> i + 1)
-            .takeWhileInclusive(i -> i < 100).toArray());
-        assertEquals(1, LongStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
-        assertEquals(2, LongStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
-        assertEquals(3, LongStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
-    }
-
-    @Test
-    public void testDropWhile() {
-        assertArrayEquals(new long[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, LongStreamEx.range(100).dropWhile(
-            i -> i % 10 < 5).limit(10).toArray());
-        assertEquals(100, LongStreamEx.range(100).dropWhile(i -> i % 10 < 0).count());
-        assertEquals(0, LongStreamEx.range(100).dropWhile(i -> i % 10 < 10).count());
-        assertEquals(OptionalLong.of(0), LongStreamEx.range(100).dropWhile(i -> i % 10 < 0).findFirst());
-        assertEquals(OptionalLong.empty(), LongStreamEx.range(100).dropWhile(i -> i % 10 < 10).findFirst());
-
-        java.util.Spliterator.OfLong spltr = LongStreamEx.range(100).dropWhile(i -> i % 10 < 1).spliterator();
-        assertTrue(spltr.tryAdvance((long x) -> assertEquals(1, x)));
-        Builder builder = LongStream.builder();
-        spltr.forEachRemaining(builder);
-        assertArrayEquals(LongStreamEx.range(2, 100).toArray(), builder.build().toArray());
-    }
-
-    @Test
-    public void testIndexOf() {
-        assertEquals(5, LongStreamEx.range(50, 100).indexOf(55).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).indexOf(200).isPresent());
-        assertEquals(5, LongStreamEx.range(50, 100).parallel().indexOf(55).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).parallel().indexOf(200).isPresent());
-
-        assertEquals(11, LongStreamEx.range(50, 100).indexOf(x -> x > 60).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).indexOf(x -> x < 0).isPresent());
-        assertEquals(11, LongStreamEx.range(50, 100).parallel().indexOf(x -> x > 60).getAsLong());
-        assertFalse(LongStreamEx.range(50, 100).parallel().indexOf(x -> x < 0).isPresent());
-    }
-
-    @Test
-    public void testFoldLeft() {
-        // non-associative
-        LongBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
-        assertEquals(2322576, LongStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1));
-        assertEquals(2322576, LongStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1));
-        assertFalse(LongStreamEx.empty().foldLeft(accumulator).isPresent());
-        assertEquals(144, LongStreamEx.rangeClosed(1, 3).foldLeft(0L, accumulator));
-        assertEquals(144, LongStreamEx.rangeClosed(1, 3).parallel().foldLeft(0L, accumulator));
-    }
-
-    @Test
-    public void testMapFirstLast() {
-        assertArrayEquals(new long[] { -1, 2, 3, 4, 7 }, LongStreamEx.of(1, 2, 3, 4, 5).mapFirst(x -> x - 2L).mapLast(
-            x -> x + 2L).toArray());
-    }
-
-    @Test
-    public void testPeekFirst() {
-        long[] input = {1, 10, 100, 1000};
-
-        AtomicLong firstElement = new AtomicLong();
-        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
-        assertEquals(1, firstElement.get());
-
-        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
-        assertEquals(10, firstElement.get());
-
-        firstElement.set(-1);
-        assertArrayEquals(new long[] {}, LongStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
-        assertEquals(-1, firstElement.get());
-    }
-
-    @Test
-    public void testPeekLast() {
-        long[] input = {1, 10, 100, 1000};
-        AtomicLong lastElement = new AtomicLong(-1);
-        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
-        assertEquals(-1, lastElement.get());
-
-        assertArrayEquals(new long[] { 1, 10, 100 }, LongStreamEx.of(input).less(1000).peekLast(lastElement::set)
-                .limit(3).toArray());
-        assertEquals(100, lastElement.get());
-
-        assertArrayEquals(input, LongStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
-        assertEquals(1000, lastElement.get());
-
-        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
-        assertEquals(100, lastElement.get());
-    }
-
-    @Test
-    public void testScanLeft() {
-        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).scanLeft(Long::sum));
-        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).parallel()
-                .scanLeft(Long::sum));
-        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).filter(x -> true)
-                .scanLeft(Long::sum));
-        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).filter(x -> true)
-                .parallel().scanLeft(Long::sum));
-        assertArrayEquals(new long[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).scanLeft(1,
-            (a, b) -> a * b));
-        assertArrayEquals(new long[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
-            (a, b) -> a * b));
-    }
-
-    // Reads numbers from scanner stopping when non-number is encountered
-    // leaving scanner in known state
-    public static LongStreamEx scannerLongs(Scanner sc) {
-        return LongStreamEx.produce(action -> {
-            if (sc.hasNextLong())
-                action.accept(sc.nextLong());
-            return sc.hasNextLong();
-        });
-    }
-
-    @Test
-    public void testProduce() {
-        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
-        assertArrayEquals(new long[] {1, 2, 3, 4, 20000000000L}, scannerLongs(sc).stream().toArray());
-        assertEquals("test", sc.next());
-    }
-
-    @Test
-    public void testPrefix() {
-        assertArrayEquals(new long[] { 1, 3, 6, 10, 20 }, LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).toArray());
-        assertEquals(OptionalLong.of(10), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 7));
-        assertEquals(OptionalLong.empty(), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 20));
-    }
-
-    @Test
-    public void testIntersperse() {
-        assertArrayEquals(new long[] { 1, 0, 10, 0, 100, 0, 1000 }, LongStreamEx.of(1, 10, 100, 1000).intersperse(0)
-                .toArray());
-        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.nio.LongBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.OptionalLong;
+import java.util.PrimitiveIterator.OfLong;
+import java.util.Random;
+import java.util.Scanner;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Function;
+import java.util.function.LongBinaryOperator;
+import java.util.function.LongConsumer;
+import java.util.function.LongFunction;
+import java.util.function.LongToDoubleFunction;
+import java.util.function.LongToIntFunction;
+import java.util.function.LongUnaryOperator;
+import java.util.function.Supplier;
+import java.util.stream.LongStream;
+import java.util.stream.LongStream.Builder;
+
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import static one.util.streamex.TestHelpers.assertThrows;
+import static one.util.streamex.TestHelpers.checkSpliterator;
+import static one.util.streamex.TestHelpers.streamEx;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * @author Tagir Valeev
+ */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class LongStreamExTest {
+    final LongConsumer EMPTY = l -> {
+        // nothing
+    };
+
+    @Test
+    public void testCreate() {
+        assertArrayEquals(new long[] {}, LongStreamEx.empty().toArray());
+        // double test is intended
+        assertArrayEquals(new long[] {}, LongStreamEx.empty().toArray());
+        assertArrayEquals(new long[] { 1 }, LongStreamEx.of(1).toArray());
+        assertArrayEquals(new long[] { 1 }, LongStreamEx.of(OptionalLong.of(1)).toArray());
+        assertArrayEquals(new long[] {}, LongStreamEx.of(OptionalLong.empty()).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).toArray());
+        assertArrayEquals(new long[] { 4, 6 }, LongStreamEx.of(new long[] { 2, 4, 6, 8, 10 }, 1, 3).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(LongStream.of(1, 2, 3)).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(Arrays.asList(1L, 2L, 3L)).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(1L, 4L).toArray());
+        assertArrayEquals(new long[] { 0, 1, 2 }, LongStreamEx.range(3L).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.rangeClosed(1, 3).toArray());
+        assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.generate(() -> 1).limit(4).toArray());
+        assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.constant(1L, 4).toArray());
+        assertEquals(10, LongStreamEx.of(new Random(), 10).count());
+        assertTrue(LongStreamEx.of(new Random(), 100, 1, 10).allMatch(x -> x >= 1 && x < 10));
+        assertArrayEquals(LongStreamEx.of(new Random(1), 100, 1, 10).toArray(), LongStreamEx.of(new Random(1), 1, 10)
+                .limit(100).toArray());
+        assertArrayEquals(LongStreamEx.of(new Random(1), 100).toArray(), LongStreamEx.of(new Random(1)).limit(100)
+                .toArray());
+
+        LongStream stream = LongStreamEx.of(1, 2, 3);
+        assertSame(stream, LongStreamEx.of(stream));
+
+        assertArrayEquals(new long[] { 4, 2, 0, -2, -4 }, LongStreamEx.zip(new long[] { 5, 4, 3, 2, 1 },
+            new long[] { 1, 2, 3, 4, 5 }, (a, b) -> a - b).toArray());
+
+        assertArrayEquals(new long[] { 1, 5, 3 }, LongStreamEx.of(Spliterators.spliterator(new long[] { 1, 5, 3 }, 0))
+                .toArray());
+        assertArrayEquals(new long[] { 1, 5, 3 }, LongStreamEx.of(
+            Spliterators.iterator(Spliterators.spliterator(new long[] { 1, 5, 3 }, 0))).toArray());
+        assertArrayEquals(new long[0], LongStreamEx.of(Spliterators.iterator(Spliterators.emptyLongSpliterator()))
+                .parallel().toArray());
+
+        assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.of(new Long[] { 2L, 4L, 6L }).toArray());
+    }
+
+    @Test
+    public void testOfLongBuffer() {
+        long[] data = LongStreamEx.range(100).toArray();
+        assertArrayEquals(data, LongStreamEx.of(LongBuffer.wrap(data)).toArray());
+        assertArrayEquals(LongStreamEx.range(50, 70).toArray(), LongStreamEx.of(LongBuffer.wrap(data, 50, 20)).toArray());
+        assertArrayEquals(data, LongStreamEx.of(LongBuffer.wrap(data)).parallel().toArray());
+        assertArrayEquals(LongStreamEx.range(50, 70).toArray(), LongStreamEx.of(LongBuffer.wrap(data, 50, 20)).parallel()
+                .toArray());
+    }
+
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new long[] { 1, 2, 4, 8, 16 }, LongStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
+        assertArrayEquals(new long[] { 1, 2, 4, 8, 16, 32, 64 }, LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
+        assertEquals(0, LongStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
+        checkSpliterator("iterate", () -> LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+
+    @Test
+    public void testLongs() {
+        assertEquals(Long.MAX_VALUE, LongStreamEx.longs().spliterator().getExactSizeIfKnown());
+        assertArrayEquals(new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, LongStreamEx.longs().limit(10).toArray());
+    }
+
+    @Test
+    public void testRangeStep() {
+        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(0, 1000, 100000).toArray());
+        assertArrayEquals(new long[] { 0, Long.MAX_VALUE - 1 }, LongStreamEx.range(0, Long.MAX_VALUE,
+            Long.MAX_VALUE - 1).toArray());
+        assertArrayEquals(new long[] { Long.MIN_VALUE, -1, Long.MAX_VALUE - 1 }, LongStreamEx.range(Long.MIN_VALUE,
+            Long.MAX_VALUE, Long.MAX_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MIN_VALUE, -1 }, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE - 1,
+            Long.MAX_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE, -1 }, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE,
+            Long.MIN_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.range(Long.MAX_VALUE, 0, Long.MIN_VALUE)
+                .toArray());
+        assertArrayEquals(new long[] { 1, Long.MIN_VALUE + 1 }, LongStreamEx.range(1, Long.MIN_VALUE, Long.MIN_VALUE)
+                .toArray());
+        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(0, Long.MIN_VALUE, Long.MIN_VALUE).toArray());
+        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.range(0, 9, 2).toArray());
+        assertArrayEquals(new long[] { 0, 2, 4, 6 }, LongStreamEx.range(0, 8, 2).toArray());
+        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.range(0, -9, -2).toArray());
+        assertArrayEquals(new long[] { 0, -2, -4, -6 }, LongStreamEx.range(0, -8, -2).toArray());
+        assertArrayEquals(new long[] { 5, 4, 3, 2, 1, 0 }, LongStreamEx.range(5, -1, -1).toArray());
+        assertEquals(Integer.MAX_VALUE + 1L, LongStreamEx.range(Integer.MIN_VALUE, Integer.MAX_VALUE, 2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(Long.MAX_VALUE, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE - 1, 2).spliterator()
+                .getExactSizeIfKnown());
+        java.util.Spliterator.OfLong spliterator = LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE, -2).spliterator();
+        assertEquals(-1, spliterator.getExactSizeIfKnown());
+        assertTrue(spliterator.tryAdvance(EMPTY));
+        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
+        assertTrue(spliterator.tryAdvance(EMPTY));
+        assertEquals(Long.MAX_VALUE - 1, spliterator.estimateSize());
+        assertEquals(Long.MAX_VALUE, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE + 1, -2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(-1, LongStreamEx.range(Long.MIN_VALUE, Long.MAX_VALUE, 1).spliterator().getExactSizeIfKnown());
+        assertEquals(-1, LongStreamEx.range(Long.MAX_VALUE, Long.MIN_VALUE, -1).spliterator().getExactSizeIfKnown());
+        assertEquals(0, LongStreamEx.range(0, -1000, 1).count());
+        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, 1).toArray());
+        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, 2).toArray());
+        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 11, 2).toArray());
+        assertArrayEquals(new long[] {}, LongStreamEx.rangeClosed(11, 10, 2).toArray());
+        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, -1).toArray());
+        assertArrayEquals(new long[] {10}, LongStreamEx.rangeClosed(10, 10, -2).toArray());
+        assertArrayEquals(new long[] {}, LongStreamEx.rangeClosed(10, 11, -2).toArray());
+        assertArrayEquals(new long[] {11}, LongStreamEx.rangeClosed(11, 10, -2).toArray());
+        assertEquals(0, LongStreamEx.range(0, 1000, -1).count());
+        assertEquals(0, LongStreamEx.range(0, 0, -1).count());
+        assertEquals(0, LongStreamEx.range(0, 0, 1).count());
+        assertEquals(0, LongStreamEx.range(0, -1000, 2).count());
+        assertEquals(0, LongStreamEx.range(0, 1000, -2).count());
+        assertEquals(0, LongStreamEx.range(0, 0, -2).count());
+        assertEquals(0, LongStreamEx.range(0, 0, 2).count());
+
+        assertEquals(0, LongStreamEx.range(0, Long.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
+        assertEquals(0, LongStreamEx.range(0, Long.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
+
+        assertThrows(IllegalArgumentException.class, () -> LongStreamEx.range(0, 1000, 0));
+    }
+
+    @Test
+    public void testRangeClosedStep() {
+        assertArrayEquals(new long[] { 0 }, LongStreamEx.rangeClosed(0, 1000, 100000).toArray());
+        assertArrayEquals(new long[] { 0, 1000 }, LongStreamEx.rangeClosed(0, 1000, 1000).toArray());
+        assertArrayEquals(new long[] { 0, Long.MAX_VALUE - 1 }, LongStreamEx.rangeClosed(0, Long.MAX_VALUE - 1,
+            Long.MAX_VALUE - 1).toArray());
+        assertArrayEquals(new long[] { Long.MIN_VALUE, -1, Long.MAX_VALUE - 1 }, LongStreamEx.rangeClosed(
+            Long.MIN_VALUE, Long.MAX_VALUE - 1, Long.MAX_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MIN_VALUE, -1 }, LongStreamEx.rangeClosed(Long.MIN_VALUE,
+            Long.MAX_VALUE - 2, Long.MAX_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE, -1 }, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE,
+            Long.MIN_VALUE).toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.rangeClosed(Long.MAX_VALUE, 0, Long.MIN_VALUE)
+                .toArray());
+        assertArrayEquals(new long[] { 0, Long.MIN_VALUE }, LongStreamEx.rangeClosed(0, Long.MIN_VALUE, Long.MIN_VALUE)
+                .toArray());
+        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.rangeClosed(0, 9, 2).toArray());
+        assertArrayEquals(new long[] { 0, 2, 4, 6, 8 }, LongStreamEx.rangeClosed(0, 8, 2).toArray());
+        assertArrayEquals(new long[] { 0, 2, 4, 6 }, LongStreamEx.rangeClosed(0, 7, 2).toArray());
+        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.rangeClosed(0, -9, -2).toArray());
+        assertArrayEquals(new long[] { 0, -2, -4, -6, -8 }, LongStreamEx.rangeClosed(0, -8, -2).toArray());
+        assertArrayEquals(new long[] { 0, -2, -4, -6 }, LongStreamEx.rangeClosed(0, -7, -2).toArray());
+        assertArrayEquals(new long[] { 5, 4, 3, 2, 1, 0 }, LongStreamEx.rangeClosed(5, 0, -1).toArray());
+        assertEquals(Integer.MAX_VALUE + 1L, LongStreamEx.rangeClosed(Integer.MIN_VALUE, Integer.MAX_VALUE, 2)
+                .spliterator().getExactSizeIfKnown());
+        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(Long.MIN_VALUE, Long.MAX_VALUE - 2, 2).spliterator()
+                .getExactSizeIfKnown());
+        java.util.Spliterator.OfLong spliterator = LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE, -2)
+                .spliterator();
+        assertEquals(-1, spliterator.getExactSizeIfKnown());
+        assertTrue(spliterator.tryAdvance(EMPTY));
+        assertEquals(Long.MAX_VALUE, spliterator.estimateSize());
+        assertTrue(spliterator.tryAdvance(EMPTY));
+        assertEquals(Long.MAX_VALUE - 1, spliterator.estimateSize());
+        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE + 2, -2).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(-1, LongStreamEx.rangeClosed(Long.MIN_VALUE, Long.MAX_VALUE, 1).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(-1, LongStreamEx.rangeClosed(Long.MAX_VALUE, Long.MIN_VALUE, -1).spliterator()
+                .getExactSizeIfKnown());
+        assertEquals(0, LongStreamEx.rangeClosed(0, -1000, 1).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, 1000, -1).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, 1, -1).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, -1, 1).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, -1000, 2).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, 1000, -2).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, 1, -2).count());
+        assertEquals(0, LongStreamEx.rangeClosed(0, -1, 2).count());
+
+        assertEquals(0, LongStreamEx.rangeClosed(0, Long.MIN_VALUE, 2).spliterator().getExactSizeIfKnown());
+        assertEquals(0, LongStreamEx.rangeClosed(0, Long.MAX_VALUE, -2).spliterator().getExactSizeIfKnown());
+    }
+
+    @Test
+    public void testBasics() {
+        assertFalse(LongStreamEx.of(1).isParallel());
+        assertTrue(LongStreamEx.of(1).parallel().isParallel());
+        assertFalse(LongStreamEx.of(1).parallel().sequential().isParallel());
+        AtomicInteger i = new AtomicInteger();
+        try (LongStreamEx s = LongStreamEx.of(1).onClose(i::incrementAndGet)) {
+            assertEquals(1, s.count());
+        }
+        assertEquals(1, i.get());
+        assertEquals(6, LongStreamEx.range(0, 4).sum());
+        assertEquals(3, LongStreamEx.range(0, 4).max().getAsLong());
+        assertEquals(0, LongStreamEx.range(0, 4).min().getAsLong());
+        assertEquals(1.5, LongStreamEx.range(0, 4).average().getAsDouble(), 0.000001);
+        assertEquals(4, LongStreamEx.range(0, 4).summaryStatistics().getCount());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(0, 5).skip(1).limit(3).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(3, 1, 2).sorted().toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 1, 3, 2).distinct().toArray());
+        assertArrayEquals(new int[] { 2, 4, 6 }, LongStreamEx.range(1, 4).mapToInt(x -> (int) x * 2).toArray());
+        assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.range(1, 4).map(x -> x * 2).toArray());
+        assertArrayEquals(new double[] { 2, 4, 6 }, LongStreamEx.range(1, 4).mapToDouble(x -> x * 2).toArray(), 0.0);
+        assertArrayEquals(new long[] { 1, 3 }, LongStreamEx.range(0, 5).filter(x -> x % 2 == 1).toArray());
+        assertEquals(6, LongStreamEx.of(1, 2, 3).reduce(Long::sum).getAsLong());
+        assertEquals(Long.MAX_VALUE, LongStreamEx.rangeClosed(1, Long.MAX_VALUE).spliterator().getExactSizeIfKnown());
+
+        assertTrue(LongStreamEx.of(1, 2, 3).spliterator().hasCharacteristics(Spliterator.ORDERED));
+        assertFalse(LongStreamEx.of(1, 2, 3).unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
+
+        OfLong iterator = LongStreamEx.of(1, 2, 3).iterator();
+        assertEquals(1L, iterator.nextLong());
+        assertEquals(2L, iterator.nextLong());
+        assertEquals(3L, iterator.nextLong());
+        assertFalse(iterator.hasNext());
+
+        AtomicInteger idx = new AtomicInteger();
+        long[] result = new long[500];
+        LongStreamEx.range(1000).atLeast(500).parallel().forEachOrdered(val -> result[idx.getAndIncrement()] = val);
+        assertArrayEquals(LongStreamEx.range(500, 1000).toArray(), result);
+
+        assertTrue(LongStreamEx.empty().noneMatch(x -> true));
+        assertFalse(LongStreamEx.of(1).noneMatch(x -> true));
+        assertTrue(LongStreamEx.of(1).noneMatch(x -> false));
+    }
+
+    @Test
+    public void testForEach() {
+        List<Long> list = new ArrayList<>();
+        LongStreamEx.of(1).forEach(list::add);
+        assertEquals(Arrays.asList(1L), list);
+        streamEx(() -> StreamEx.of(1L, 2L, 3L), s -> {
+            AtomicLong count = new AtomicLong(0);
+            s.get().mapToLong(Long::longValue).forEach(count::addAndGet);
+            assertEquals(6, count.get());
+            s.get().mapToLong(Long::longValue).pairMap((a, b) -> b - a).forEach(count::addAndGet);
+            assertEquals(8, count.get());
+        });
+    }
+
+    @Test
+    public void testFlatMap() {
+        assertArrayEquals(new long[] { 0, 0, 1, 0, 1, 2 }, LongStreamEx.of(1, 2, 3).flatMap(LongStreamEx::range)
+                .toArray());
+        assertArrayEquals(new int[] { 1, 5, 1, 4, 2, 0, 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 7 },
+            LongStreamEx.of(15, 14, 20, Long.MAX_VALUE).flatMapToInt(n -> String.valueOf(n).chars().map(x -> x - '0'))
+                    .toArray());
+
+        String expected = LongStreamEx.range(200).boxed().flatMap(
+            i -> LongStreamEx.range(0, i).mapToObj(j -> i + ":" + j)).joining("/");
+        String res = LongStreamEx.range(200).flatMapToObj(i -> LongStreamEx.range(i).mapToObj(j -> i + ":" + j))
+                .joining("/");
+        String parallel = LongStreamEx.range(200).parallel().flatMapToObj(
+            i -> LongStreamEx.range(i).mapToObj(j -> i + ":" + j)).joining("/");
+        assertEquals(expected, res);
+        assertEquals(expected, parallel);
+
+        double[] fractions = LongStreamEx.range(1, 5).flatMapToDouble(
+            i -> LongStreamEx.range(1, i).mapToDouble(j -> ((double) j) / i)).toArray();
+        assertArrayEquals(new double[] { 1 / 2.0, 1 / 3.0, 2 / 3.0, 1 / 4.0, 2 / 4.0, 3 / 4.0 }, fractions, 0.000001);
+    }
+
+    @Test
+    public void testPrepend() {
+        assertArrayEquals(new long[] { -1, 0, 1, 2, 3 }, LongStreamEx.of(1, 2, 3).prepend(-1, 0).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).prepend().toArray());
+        assertArrayEquals(new long[] { 10, 11, 0, 1, 2, 3 }, LongStreamEx.range(0, 4).prepend(
+            LongStreamEx.range(10, 12)).toArray());
+    }
+
+    @Test
+    public void testAppend() {
+        assertArrayEquals(new long[] { 1, 2, 3, 4, 5 }, LongStreamEx.of(1, 2, 3).append(4, 5).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.of(1, 2, 3).append().toArray());
+        assertArrayEquals(new long[] { 0, 1, 2, 3, 10, 11 }, LongStreamEx.range(0, 4)
+                .append(LongStreamEx.range(10, 12)).toArray());
+    }
+
+    @Test
+    public void testHas() {
+        assertTrue(LongStreamEx.range(1, 4).has(3));
+        assertFalse(LongStreamEx.range(1, 4).has(4));
+    }
+
+    @Test
+    public void testWithout() {
+        assertArrayEquals(new long[] { 1, 2 }, LongStreamEx.range(1, 4).without(3).toArray());
+        assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(1, 4).without(5).toArray());
+        LongStreamEx lse = LongStreamEx.range(5);
+        assertSame(lse, lse.without());
+        assertArrayEquals(new long[] { 0, 1, 3, 4 }, LongStreamEx.range(5).without(new long[] { 2 }).toArray());
+        assertArrayEquals(new long[] { 0 }, LongStreamEx.range(5).without(1, 2, 3, 4, 5, 6).toArray());
+    }
+
+    @Test
+    public void testRanges() {
+        assertArrayEquals(new long[] { 5, 4, Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).greater(
+            3).toArray());
+        assertArrayEquals(new long[] {}, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).greater(Long.MAX_VALUE)
+                .toArray());
+        assertArrayEquals(new long[] { 5, 3, 4, Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE)
+                .atLeast(3).toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atLeast(
+            Long.MAX_VALUE).toArray());
+        assertArrayEquals(new long[] { 1, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).less(3).toArray());
+        assertArrayEquals(new long[] { 1, 3, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atMost(3).toArray());
+        assertArrayEquals(new long[] { 1, 3, 4, -1 }, LongStreamEx.of(1, 5, 3, 4, -1, Long.MAX_VALUE).atMost(4).toArray());
+    }
+
+    @Test
+    public void testFind() {
+        assertEquals(6, LongStreamEx.range(1, 10).findFirst(i -> i > 5).getAsLong());
+        assertFalse(LongStreamEx.range(1, 10).findAny(i -> i > 10).isPresent());
+    }
+
+    @Test
+    public void testRemove() {
+        assertArrayEquals(new long[] { 1, 2 }, LongStreamEx.of(1, 2, 3).remove(x -> x > 2).toArray());
+    }
+
+    @Test
+    public void testSort() {
+        assertArrayEquals(new long[] { 0, 3, 6, 1, 4, 7, 2, 5, 8 }, LongStreamEx.range(0, 9).sortedByLong(
+            i -> i % 3 * 3 + i / 3).toArray());
+        assertArrayEquals(new long[] { 0, 4, 8, 1, 5, 9, 2, 6, 3, 7 }, LongStreamEx.range(0, 10).sortedByInt(
+            i -> (int) i % 4).toArray());
+        assertArrayEquals(new long[] { 10, 11, 5, 6, 7, 8, 9 }, LongStreamEx.range(5, 12).sortedBy(String::valueOf)
+                .toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE, 1000, 1, 0, -10, Long.MIN_VALUE }, LongStreamEx.of(0, 1, 1000,
+            -10, Long.MIN_VALUE, Long.MAX_VALUE).reverseSorted().toArray());
+        assertArrayEquals(new long[] { Long.MAX_VALUE, Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MAX_VALUE - 1 },
+            LongStreamEx.of(Long.MIN_VALUE, Long.MIN_VALUE + 1, Long.MAX_VALUE - 1, Long.MAX_VALUE).sortedByLong(
+                l -> l + 1).toArray());
+        assertArrayEquals(new long[] { -10, Long.MIN_VALUE, Long.MAX_VALUE, 1000, 1, 0 }, LongStreamEx.of(0, 1, 1000,
+            -10, Long.MIN_VALUE, Long.MAX_VALUE).sortedByDouble(x -> 1.0 / x).toArray());
+    }
+
+    @SafeVarargs
+    private static void checkEmpty(Function<LongStreamEx, OptionalLong>... fns) {
+        int i = 0;
+        for (Function<LongStreamEx, OptionalLong> fn : fns) {
+            assertFalse("#" + i, fn.apply(LongStreamEx.empty()).isPresent());
+            assertFalse("#" + i, fn.apply(LongStreamEx.of(1, 2, 3, 4).greater(5).parallel()).isPresent());
+            assertEquals("#" + i, 10, fn.apply(LongStreamEx.of(1, 1, 1, 1, 10, 10, 10, 10).greater(5).parallel())
+                    .getAsLong());
+            i++;
+        }
+    }
+
+    @Test
+    public void testMinMax() {
+        checkEmpty(s -> s.maxBy(Long::valueOf), s -> s.maxByInt(x -> (int) x), s -> s.maxByLong(x -> x), s -> s
+                .maxByDouble(x -> x), s -> s.minBy(Long::valueOf), s -> s.minByInt(x -> (int) x), s -> s
+                .minByLong(x -> x), s -> s.minByDouble(x -> x));
+        assertEquals(9, LongStreamEx.range(5, 12).max(Comparator.comparing(String::valueOf))
+                .getAsLong());
+        assertEquals(10, LongStreamEx.range(5, 12).min(Comparator.comparing(String::valueOf))
+                .getAsLong());
+        assertEquals(9, LongStreamEx.range(5, 12).maxBy(String::valueOf).getAsLong());
+        assertEquals(10, LongStreamEx.range(5, 12).minBy(String::valueOf).getAsLong());
+        assertEquals(5, LongStreamEx.range(5, 12).maxByDouble(x -> 1.0 / x).getAsLong());
+        assertEquals(11, LongStreamEx.range(5, 12).minByDouble(x -> 1.0 / x).getAsLong());
+        assertEquals(29, LongStreamEx.of(15, 8, 31, 47, 19, 29).maxByInt(x -> (int) (x % 10 * 10 + x / 10)).getAsLong());
+        assertEquals(31, LongStreamEx.of(15, 8, 31, 47, 19, 29).minByInt(x -> (int) (x % 10 * 10 + x / 10)).getAsLong());
+        assertEquals(29, LongStreamEx.of(15, 8, 31, 47, 19, 29).maxByLong(x -> x % 10 * 10 + x / 10).getAsLong());
+        assertEquals(31, LongStreamEx.of(15, 8, 31, 47, 19, 29).minByLong(x -> x % 10 * 10 + x / 10).getAsLong());
+
+        Supplier<LongStreamEx> s = () -> LongStreamEx.of(1, 50, 120, 35, 130, 12, 0);
+        LongToIntFunction intKey = x -> String.valueOf(x).length();
+        LongUnaryOperator longKey = x -> String.valueOf(x).length();
+        LongToDoubleFunction doubleKey = x -> String.valueOf(x).length();
+        LongFunction<Integer> objKey = x -> String.valueOf(x).length();
+        List<Function<LongStreamEx, OptionalLong>> minFns = Arrays.asList(is -> is.minByInt(intKey), is -> is
+                .minByLong(longKey), is -> is.minByDouble(doubleKey), is -> is.minBy(objKey));
+        List<Function<LongStreamEx, OptionalLong>> maxFns = Arrays.asList(is -> is.maxByInt(intKey), is -> is
+                .maxByLong(longKey), is -> is.maxByDouble(doubleKey), is -> is.maxBy(objKey));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get()).getAsLong()));
+        minFns.forEach(fn -> assertEquals(1, fn.apply(s.get().parallel()).getAsLong()));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get()).getAsLong()));
+        maxFns.forEach(fn -> assertEquals(120, fn.apply(s.get().parallel()).getAsLong()));
+    }
+
+    @Test
+    public void testPairMap() {
+        assertEquals(0, LongStreamEx.range(0).pairMap(Long::sum).count());
+        assertEquals(0, LongStreamEx.range(1).pairMap(Long::sum).count());
+        assertArrayEquals(new long[] { 6, 7, 8, 9, 10 }, LongStreamEx.of(1, 5, 2, 6, 3, 7).pairMap(Long::sum).toArray());
+        assertArrayEquals(LongStreamEx.range(999).map(x -> x * 2 + 1).toArray(), LongStreamEx.range(1000).parallel()
+                .map(x -> x * x).pairMap((a, b) -> b - a).toArray());
+
+        assertArrayEquals(LongStreamEx.range(1, 100).toArray(), LongStreamEx.range(100).map(i -> i * (i + 1) / 2)
+                .append(LongStream.empty()).parallel().pairMap((a, b) -> b - a).toArray());
+        assertArrayEquals(LongStreamEx.range(1, 100).toArray(), LongStreamEx.range(100).map(i -> i * (i + 1) / 2)
+                .prepend(LongStream.empty()).parallel().pairMap((a, b) -> b - a).toArray());
+
+        assertEquals(1, LongStreamEx.range(1000).map(x -> x * x).pairMap((a, b) -> b - a).pairMap((a, b) -> b - a)
+                .distinct().count());
+
+        assertFalse(LongStreamEx.range(1000).greater(2000).parallel().pairMap((a, b) -> a).findFirst().isPresent());
+    }
+
+    @Test
+    public void testJoining() {
+        assertEquals("0,1,2,3,4,5,6,7,8,9", LongStreamEx.range(10).joining(","));
+        assertEquals("0,1,2,3,4,5,6,7,8,9", LongStreamEx.range(10).parallel().joining(","));
+        assertEquals("[0,1,2,3,4,5,6,7,8,9]", LongStreamEx.range(10).joining(",", "[", "]"));
+        assertEquals("[0,1,2,3,4,5,6,7,8,9]", LongStreamEx.range(10).parallel().joining(",", "[", "]"));
+    }
+
+    @Test
+    public void testMapToEntry() {
+        Map<Long, List<Long>> result = LongStreamEx.range(10).mapToEntry(x -> x % 2, x -> x).grouping();
+        assertEquals(Arrays.asList(0L, 2L, 4L, 6L, 8L), result.get(0L));
+        assertEquals(Arrays.asList(1L, 3L, 5L, 7L, 9L), result.get(1L));
+    }
+
+    @Test
+    public void testTakeWhile() {
+        assertArrayEquals(LongStreamEx.range(100).toArray(), LongStreamEx.iterate(0, i -> i + 1)
+                .takeWhile(i -> i < 100).toArray());
+        assertEquals(0, LongStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 0).count());
+        assertEquals(1, LongStreamEx.of(1, 3, 2).takeWhile(i -> i < 3).count());
+        assertEquals(3, LongStreamEx.of(1, 2, 3).takeWhile(i -> i < 100).count());
+    }
+
+    @Test
+    public void testTakeWhileInclusive() {
+        assertArrayEquals(LongStreamEx.range(101).toArray(), LongStreamEx.iterate(0, i -> i + 1)
+            .takeWhileInclusive(i -> i < 100).toArray());
+        assertEquals(1, LongStreamEx.iterate(0, i -> i + 1).takeWhileInclusive(i -> i < 0).count());
+        assertEquals(2, LongStreamEx.of(1, 3, 2).takeWhileInclusive(i -> i < 3).count());
+        assertEquals(3, LongStreamEx.of(1, 2, 3).takeWhileInclusive(i -> i < 100).count());
+    }
+
+    @Test
+    public void testDropWhile() {
+        assertArrayEquals(new long[] { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 }, LongStreamEx.range(100).dropWhile(
+            i -> i % 10 < 5).limit(10).toArray());
+        assertEquals(100, LongStreamEx.range(100).dropWhile(i -> i % 10 < 0).count());
+        assertEquals(0, LongStreamEx.range(100).dropWhile(i -> i % 10 < 10).count());
+        assertEquals(OptionalLong.of(0), LongStreamEx.range(100).dropWhile(i -> i % 10 < 0).findFirst());
+        assertEquals(OptionalLong.empty(), LongStreamEx.range(100).dropWhile(i -> i % 10 < 10).findFirst());
+
+        java.util.Spliterator.OfLong spltr = LongStreamEx.range(100).dropWhile(i -> i % 10 < 1).spliterator();
+        assertTrue(spltr.tryAdvance((long x) -> assertEquals(1, x)));
+        Builder builder = LongStream.builder();
+        spltr.forEachRemaining(builder);
+        assertArrayEquals(LongStreamEx.range(2, 100).toArray(), builder.build().toArray());
+    }
+
+    @Test
+    public void testIndexOf() {
+        assertEquals(5, LongStreamEx.range(50, 100).indexOf(55).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).indexOf(200).isPresent());
+        assertEquals(5, LongStreamEx.range(50, 100).parallel().indexOf(55).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).parallel().indexOf(200).isPresent());
+
+        assertEquals(11, LongStreamEx.range(50, 100).indexOf(x -> x > 60).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).indexOf(x -> x < 0).isPresent());
+        assertEquals(11, LongStreamEx.range(50, 100).parallel().indexOf(x -> x > 60).getAsLong());
+        assertFalse(LongStreamEx.range(50, 100).parallel().indexOf(x -> x < 0).isPresent());
+    }
+
+    @Test
+    public void testFoldLeft() {
+        // non-associative
+        LongBinaryOperator accumulator = (x, y) -> (x + y) * (x + y);
+        assertEquals(2322576, LongStreamEx.constant(3, 4).foldLeft(accumulator).orElse(-1));
+        assertEquals(2322576, LongStreamEx.constant(3, 4).parallel().foldLeft(accumulator).orElse(-1));
+        assertFalse(LongStreamEx.empty().foldLeft(accumulator).isPresent());
+        assertEquals(144, LongStreamEx.rangeClosed(1, 3).foldLeft(0L, accumulator));
+        assertEquals(144, LongStreamEx.rangeClosed(1, 3).parallel().foldLeft(0L, accumulator));
+    }
+
+    @Test
+    public void testMapFirstLast() {
+        assertArrayEquals(new long[] { -1, 2, 3, 4, 7 }, LongStreamEx.of(1, 2, 3, 4, 5).mapFirst(x -> x - 2L).mapLast(
+            x -> x + 2L).toArray());
+    }
+
+    @Test
+    public void testPeekFirst() {
+        long[] input = {1, 10, 100, 1000};
+
+        AtomicLong firstElement = new AtomicLong();
+        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).peekFirst(firstElement::set).skip(1).toArray());
+        assertEquals(1, firstElement.get());
+
+        assertArrayEquals(new long[] {10, 100, 1000}, LongStreamEx.of(input).skip(1).peekFirst(firstElement::set).toArray());
+        assertEquals(10, firstElement.get());
+
+        firstElement.set(-1);
+        assertArrayEquals(new long[] {}, LongStreamEx.of(input).skip(4).peekFirst(firstElement::set).toArray());
+        assertEquals(-1, firstElement.get());
+    }
+
+    @Test
+    public void testPeekLast() {
+        long[] input = {1, 10, 100, 1000};
+        AtomicLong lastElement = new AtomicLong(-1);
+        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).peekLast(lastElement::set).limit(3).toArray());
+        assertEquals(-1, lastElement.get());
+
+        assertArrayEquals(new long[] { 1, 10, 100 }, LongStreamEx.of(input).less(1000).peekLast(lastElement::set)
+                .limit(3).toArray());
+        assertEquals(100, lastElement.get());
+
+        assertArrayEquals(input, LongStreamEx.of(input).peekLast(lastElement::set).limit(4).toArray());
+        assertEquals(1000, lastElement.get());
+
+        assertArrayEquals(new long[] {1, 10, 100}, LongStreamEx.of(input).limit(3).peekLast(lastElement::set).toArray());
+        assertEquals(100, lastElement.get());
+    }
+
+    @Test
+    public void testScanLeft() {
+        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).scanLeft(Long::sum));
+        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).parallel()
+                .scanLeft(Long::sum));
+        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).filter(x -> true)
+                .scanLeft(Long::sum));
+        assertArrayEquals(new long[] { 0, 1, 3, 6, 10, 15, 21, 28, 36, 45 }, LongStreamEx.range(10).filter(x -> true)
+                .parallel().scanLeft(Long::sum));
+        assertArrayEquals(new long[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).scanLeft(1,
+            (a, b) -> a * b));
+        assertArrayEquals(new long[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
+            (a, b) -> a * b));
+    }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    public static LongStreamEx scannerLongs(Scanner sc) {
+        return LongStreamEx.produce(action -> {
+            if (sc.hasNextLong())
+                action.accept(sc.nextLong());
+            return sc.hasNextLong();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
+        assertArrayEquals(new long[] {1, 2, 3, 4, 20000000000L}, scannerLongs(sc).stream().toArray());
+        assertEquals("test", sc.next());
+    }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new long[] { 1, 3, 6, 10, 20 }, LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).toArray());
+        assertEquals(OptionalLong.of(10), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalLong.empty(), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 20));
+        assertEquals(49995000L, LongStreamEx.range(10000).unordered().prefix(Long::sum).max().getAsLong());
+        assertEquals(49995000L, LongStreamEx.range(10000).unordered().parallel().prefix(Long::sum).max().getAsLong());
+    }
+
+    @Test
+    public void testIntersperse() {
+        assertArrayEquals(new long[] { 1, 0, 10, 0, 100, 0, 1000 }, LongStreamEx.of(1, 10, 100, 1000).intersperse(0)
+                .toArray());
+        assertEquals(0L, IntStreamEx.empty().intersperse(1).count());
+    }
+}
diff --git a/src/test/java/one/util/streamex/PrefixOpsTest.java b/src/test/java/one/util/streamex/PrefixOpsTest.java
index 41aee1a..3e56588 100644
--- a/src/test/java/one/util/streamex/PrefixOpsTest.java
+++ b/src/test/java/one/util/streamex/PrefixOpsTest.java
@@ -17,11 +17,14 @@
 package one.util.streamex;
 
 import java.util.Spliterator;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
 
 import org.junit.Test;
 
 import static one.util.streamex.TestHelpers.consumeElement;
-import static org.junit.Assert.assertNull;
+import static org.junit.Assert.*;
 
 public class PrefixOpsTest {
   @Test
@@ -33,4 +36,34 @@ public class PrefixOpsTest {
     consumeElement(spliterator, 6);
     assertNull(spliterator.trySplit());
   }
+
+  @Test
+  public void testIntNoSplitAfterAdvance() {
+    Spliterator.OfInt spliterator = IntStreamEx.range(100).unordered().prefix(Integer::sum).spliterator();
+    assertTrue(spliterator.tryAdvance((IntConsumer) i -> assertEquals(i, 0)));
+    assertTrue(spliterator.tryAdvance((IntConsumer) i -> assertEquals(i, 1)));
+    assertTrue(spliterator.tryAdvance((IntConsumer) i -> assertEquals(i, 3)));
+    assertTrue(spliterator.tryAdvance((IntConsumer) i -> assertEquals(i, 6)));
+    assertNull(spliterator.trySplit());
+  }
+
+  @Test
+  public void testLongNoSplitAfterAdvance() {
+    Spliterator.OfLong spliterator = LongStreamEx.range(100).unordered().prefix(Long::sum).spliterator();
+    assertTrue(spliterator.tryAdvance((LongConsumer) i -> assertEquals(i, 0L)));
+    assertTrue(spliterator.tryAdvance((LongConsumer) i -> assertEquals(i, 1L)));
+    assertTrue(spliterator.tryAdvance((LongConsumer) i -> assertEquals(i, 3L)));
+    assertTrue(spliterator.tryAdvance((LongConsumer) i -> assertEquals(i, 6L)));
+    assertNull(spliterator.trySplit());
+  }
+
+  @Test
+  public void testDoubleNoSplitAfterAdvance() {
+    Spliterator.OfDouble spliterator = DoubleStreamEx.constant(1.0d, 1000).unordered().prefix(Double::sum).spliterator();
+    assertTrue(spliterator.tryAdvance((DoubleConsumer) i -> assertEquals(i, 1d, 0.0)));
+    assertTrue(spliterator.tryAdvance((DoubleConsumer) i -> assertEquals(i, 2d, 0.0)));
+    assertTrue(spliterator.tryAdvance((DoubleConsumer) i -> assertEquals(i, 3d, 0.0)));
+    assertTrue(spliterator.tryAdvance((DoubleConsumer) i -> assertEquals(i, 4d, 0.0)));
+    assertNull(spliterator.trySplit());
+  }
 }
