diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 3bddc03..27e5545 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1339,7 +1339,15 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             return left;
         }).map(pair -> mapper.apply(pair.a, pair.b));
     }
+    
+    public EntryStream<T, T> withFirst() {
+        return strategy().newEntryStream(delegate(new WithFirstSpliterator<>(stream.spliterator())));
+    }
 
+    public <U> StreamEx<U> withFirst(BiFunction<T, StreamEx<T>, Stream<U>> mapper) {
+        return strategy().newStreamEx(delegate(new WithHeadSpliterator<>(stream.spliterator(), mapper)));
+    }
+    
     /**
      * Returns an empty sequential {@code StreamEx}.
      *
diff --git a/src/main/java/one/util/streamex/WithFirstSpliterator.java b/src/main/java/one/util/streamex/WithFirstSpliterator.java
new file mode 100644
index 0000000..74077c6
--- /dev/null
+++ b/src/main/java/one/util/streamex/WithFirstSpliterator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.AbstractMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+/**
+ * @author Tagir Valeev
+ */
+/*package*/ final class WithFirstSpliterator<T> implements Spliterator<Map.Entry<T, T>> {
+    private final Spliterator<T> source;
+    private T first;
+    private boolean initialized;
+    
+    WithFirstSpliterator(Spliterator<T> source) {
+        this.source = source;
+    }
+    
+    private WithFirstSpliterator(Spliterator<T> source, T first) {
+        this.source = source;
+        this.first = first;
+        this.initialized = true;
+    }
+    
+    @Override
+    public boolean tryAdvance(Consumer<? super Entry<T, T>> action) {
+        if(!init())
+            return false;
+        return source.tryAdvance(x -> action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x)));
+    }
+
+    private boolean init() {
+        if(initialized)
+            return true;
+        initialized = true;
+        return source.tryAdvance(x -> first = x);
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super Entry<T, T>> action) {
+        source.forEachRemaining(x -> {
+            if(!initialized) {
+                first = x;
+                initialized = true;
+            } else {
+                action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x));
+            }
+        });
+    }
+
+    @Override
+    public Spliterator<Entry<T, T>> trySplit() {
+        if(!init())
+            return null;
+        Spliterator<T> prefix = source.trySplit();
+        if(prefix == null)
+            return null;
+        return new WithFirstSpliterator<>(prefix, first);
+    }
+
+    @Override
+    public long estimateSize() {
+        long size = source.estimateSize();
+        return size == Long.MAX_VALUE || size <= 0 ? size : size - 1;
+    }
+
+    @Override
+    public int characteristics() {
+        return NONNULL | (source.characteristics() & (DISTINCT | SIZED | SUBSIZED | IMMUTABLE | CONCURRENT | ORDERED));
+    }
+}
diff --git a/src/main/java/one/util/streamex/WithHeadSpliterator.java b/src/main/java/one/util/streamex/WithHeadSpliterator.java
new file mode 100644
index 0000000..19b6c26
--- /dev/null
+++ b/src/main/java/one/util/streamex/WithHeadSpliterator.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+import static one.util.streamex.StreamExInternals.*;
+
+/**
+ * @author Tagir Valeev
+ */
+/*package*/ final class WithHeadSpliterator<T, U> implements Spliterator<U> {
+    private final Spliterator<T> source;
+    private final BiFunction<T, StreamEx<T>, Stream<U>> mapper;
+    private Spliterator<U> target;
+    
+    WithHeadSpliterator(Spliterator<T> source, BiFunction<T, StreamEx<T>, Stream<U>> mapper) {
+        this.source = source;
+        this.mapper = mapper;
+    }
+    
+    @Override
+    public boolean tryAdvance(Consumer<? super U> action) {
+        if(!init())
+            return false;
+        if(target instanceof WithHeadSpliterator) {
+            @SuppressWarnings("unchecked")
+            Spliterator<U> next = ((WithHeadSpliterator<?, U>) target).target;
+            if(next != null)
+                target = next;
+        }
+        return target.tryAdvance(action);
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super U> action) {
+        if(init())
+            target.forEachRemaining(action);
+    }
+
+    private boolean init() {
+        if(target == null) {
+            Box<T> first = new Box<>(null);
+            if(!source.tryAdvance(x -> first.a = x)) {
+                return false;
+            }
+            target = mapper.apply(first.a, StreamEx.of(source)).spliterator();
+        }
+        return true;
+    }
+
+    @Override
+    public Spliterator<U> trySplit() {
+        if(!init())
+            return null;
+        return target.trySplit();
+    }
+
+    @Override
+    public long estimateSize() {
+        long size = source.estimateSize();
+        return size == Long.MAX_VALUE || size <= 0 ? size : size - 1;
+    }
+
+    @Override
+    public int characteristics() {
+        return source.characteristics() & ORDERED;
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 86c0409..6850432 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1496,4 +1496,26 @@ public class StreamExTest {
                 String[]::new)));
         });
     }
+    
+    @Test
+    public void testWithFirst() {
+        assertEquals(asList(1, 2, 3, 4, 5), StreamEx.of(0, 2, 4).flatMap(x -> Stream.of(x, x + 1))
+                .withFirst().values().toList());
+        
+        streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
+            "c", "d")), s.get().withFirst().grouping()));
+
+        streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
+            "c", "d")), s.get().withFirst((x, str) -> str.mapToEntry(e -> x, e -> e)).mapToEntry(Entry::getKey,
+            Entry::getValue).grouping()));
+
+        streamEx(() -> StreamEx.iterate(2, x -> x + 1), s -> assertEquals(asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
+            31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97), sieve(s.get()).takeWhile(x -> x < 100)
+                .toList()));
+        
+    }
+    
+    private static StreamEx<Integer> sieve(StreamEx<Integer> input) {
+        return input.withFirst((head, stream) -> sieve(stream.filter(n -> n % head != 0)).prepend(head));
+    }
 }
