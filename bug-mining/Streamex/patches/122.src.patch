diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index ffdc0c8..48d22e2 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -114,10 +114,16 @@ import static one.util.streamex.StreamExInternals.*;
         return StreamSupport.stream(spliterator, strategy.parallel);
     }
 
-    final <R> Stream<R> delegate(Spliterator<R> spliterator) {
+    final <R> Stream<R> delegateBase(Spliterator<R> spliterator) {
         return forwardClose(StreamSupport.stream(spliterator, isParallel()));
     }
 
+    final S delegate(Spliterator<T> spliterator) {
+        if(mustClose())
+            return supply(forwardClose(StreamSupport.stream(spliterator, isParallel())));
+        return supply(spliterator);
+    }
+    
     final S callWhile(Predicate<? super T> predicate, int methodId) {
         try {
             return supply((Stream<T>) JDK9_METHODS[IDX_STREAM][methodId].invokeExact(stream(), predicate));
@@ -158,6 +164,8 @@ import static one.util.streamex.StreamExInternals.*;
             result = (Spliterator<T>) right;
         else
             result = new TailConcatSpliterator<>(left, right);
+        if(!mustClose() && !mustCloseStream(other))
+            return supply(result);
         return supply(StreamExInternals.delegateClose(forwardClose(StreamSupport.stream(result, isParallel())), other));
     }
 
@@ -171,11 +179,15 @@ import static one.util.streamex.StreamExInternals.*;
             result = (Spliterator<T>) left;
         else
             result = new TailConcatSpliterator<>(left, right);
+        if(!mustClose() && !mustCloseStream(other))
+            return supply(result);
         return supply(StreamExInternals.delegateClose(forwardClose(StreamSupport.stream(result, isParallel())), other));
     }
 
     abstract S supply(Stream<T> stream);
 
+    abstract S supply(Spliterator<T> spliterator);
+
     @Override
     public Iterator<T> iterator() {
         return Spliterators.iterator(spliterator());
@@ -1553,8 +1565,7 @@ import static one.util.streamex.StreamExInternals.*;
      * @since 0.3.2
      */
     public S skipOrdered(long n) {
-        return supply(delegate((isParallel() ? StreamSupport.stream(spliterator(), false) : stream()).skip(
-            n).spliterator()));
+        return delegate((isParallel() ? StreamSupport.stream(spliterator(), false) : stream()).skip(n).spliterator());
     }
 
     /**
@@ -1582,7 +1593,7 @@ import static one.util.streamex.StreamExInternals.*;
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return supply(delegate(new AbstractStreamEx.TDOfRef<>(spliterator(), false, predicate)));
+        return delegate(new AbstractStreamEx.TDOfRef<>(spliterator(), false, predicate));
     }
 
     /**
@@ -1611,6 +1622,6 @@ import static one.util.streamex.StreamExInternals.*;
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return supply(delegate(new AbstractStreamEx.TDOfRef<>(spliterator(), true, predicate)));
+        return delegate(new AbstractStreamEx.TDOfRef<>(spliterator(), true, predicate));
     }
 }
diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
index d6356e5..f6db668 100644
--- a/src/main/java/one/util/streamex/BaseStreamEx.java
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -56,6 +56,10 @@ import java.util.stream.BaseStream;
         return StreamExInternals.delegateClose(proxy, stream);
     }
 
+    boolean mustClose() {
+        return StreamExInternals.mustCloseStream(stream);
+    }
+
     @SuppressWarnings("unchecked")
     @Override
     public SPLTR spliterator() {
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index d3a9902..57588e2 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -120,6 +120,8 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
     }
 
     final DoubleStreamEx delegate(Spliterator.OfDouble spliterator) {
+        if(!mustClose())
+            return new DoubleStreamEx(spliterator, strategy);
         return new DoubleStreamEx(forwardClose(StreamSupport.doubleStream(spliterator, isParallel())), strategy);
     }
 
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 125f5e9..99afc85 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -77,6 +77,11 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return new EntryStream<>(stream, strategy);
     }
 
+    @Override
+    EntryStream<K, V> supply(Spliterator<Entry<K, V>> spliterator) {
+        return new EntryStream<>(spliterator, strategy);
+    }
+
     static <K, V> Consumer<? super Entry<K, V>> toConsumer(BiConsumer<? super K, ? super V> action) {
         return entry -> action.accept(entry.getKey(), entry.getValue());
     }
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index cdba430..62c5153 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -126,6 +126,8 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     }
 
     final IntStreamEx delegate(Spliterator.OfInt spliterator) {
+        if(!mustClose())
+            return new IntStreamEx(spliterator, strategy);
         return new IntStreamEx(forwardClose(StreamSupport.intStream(spliterator, isParallel())), strategy);
     }
 
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index ce1932c..2d6fe14 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -120,6 +120,8 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
     }
 
     final LongStreamEx delegate(Spliterator.OfLong spliterator) {
+        if(!mustClose())
+            return new LongStreamEx(spliterator, strategy);
         return new LongStreamEx(forwardClose(StreamSupport.longStream(spliterator, isParallel())), strategy);
     }
 
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1bb3d18..816af0e 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -59,6 +59,7 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.Collector.Characteristics;
 
+import one.util.streamex.PairSpliterator.PSOfRef;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -89,10 +90,15 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(stream, strategy);
     }
 
+    @Override
+    StreamEx<T> supply(Spliterator<T> spliterator) {
+        return new StreamEx<>(spliterator, strategy);
+    }
+
     final <R> StreamEx<R> collapseInternal(BiPredicate<? super T, ? super T> collapsible, Function<T, R> mapper,
             BiFunction<R, T, R> accumulator, BinaryOperator<R> combiner) {
-        return new StreamEx<>(
-            delegate(new CollapseSpliterator<>(collapsible, mapper, accumulator, combiner, spliterator())), strategy);
+        CollapseSpliterator<T, R> spliterator = new CollapseSpliterator<>(collapsible, mapper, accumulator, combiner, spliterator());
+        return mustClose() ? new StreamEx<>(delegateBase(spliterator), strategy) : new StreamEx<>(spliterator, strategy);
     }
 
     /**
@@ -170,7 +176,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.4.1
      */
     public StreamEx<T> mapFirst(Function<? super T, ? extends T> mapper) {
-        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), true)), strategy);
+        return delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), true));
     }
 
     /**
@@ -189,7 +195,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.4.1
      */
     public StreamEx<T> mapLast(Function<? super T, ? extends T> mapper) {
-        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), false)), strategy);
+        return delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), false));
     }
 
     /**
@@ -240,7 +246,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     @SuppressWarnings("unchecked")
     public <V> EntryStream<T, V> cross(V... other) {
         if (other.length == 0)
-            return new EntryStream<>(delegate(Spliterators.emptySpliterator()), strategy);
+            return mustClose() ? new EntryStream<>(delegateBase(Spliterators.emptySpliterator()), strategy)
+                    : new EntryStream<>(Spliterators.emptySpliterator(), strategy);
         if (other.length == 1)
             return mapToEntry(e -> other[0]);
         return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, Arrays.stream(other))), strategy);
@@ -268,7 +275,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public <V> EntryStream<T, V> cross(Collection<? extends V> other) {
         if (other.isEmpty())
-            return new EntryStream<>(delegate(Spliterators.emptySpliterator()), strategy);
+            return mustClose() ? new EntryStream<>(delegateBase(Spliterators.emptySpliterator()), strategy)
+                    : new EntryStream<>(Spliterators.emptySpliterator(), strategy);
         return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, other.stream())), strategy);
     }
 
@@ -1050,7 +1058,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             result = Spliterators.emptySpliterator();
         else
             result = new DistinctSpliterator<>(spliterator, atLeast);
-        return new StreamEx<>(delegate(result), strategy);
+        return delegate(result);
     }
 
     /**
@@ -1072,7 +1080,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.2.1
      */
     public <R> StreamEx<R> pairMap(BiFunction<? super T, ? super T, ? extends R> mapper) {
-        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<T, R>(mapper, spliterator())), strategy);
+        PSOfRef<T, R> spliterator = new PairSpliterator.PSOfRef<T, R>(mapper, spliterator());
+        return mustClose() ? new StreamEx<>(delegateBase(spliterator), strategy)
+                : new StreamEx<>(spliterator, strategy);
     }
 
     /**
@@ -1332,7 +1342,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.3
      */
     public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super T, ? extends R> mapper) {
-        return new StreamEx<>(delegate(new WithFirstSpliterator<>(spliterator(), mapper)), strategy);
+        WithFirstSpliterator<T, R> spliterator = new WithFirstSpliterator<>(spliterator(), mapper);
+        return mustClose() ? new StreamEx<>(delegateBase(spliterator), strategy) : new StreamEx<>(spliterator, strategy);
     }
 
     /**
@@ -1355,8 +1366,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.3
      */
     public EntryStream<T, T> withFirst() {
-        return new EntryStream<>(
-            delegate(new WithFirstSpliterator<>(spliterator(), AbstractMap.SimpleImmutableEntry<T, T>::new)), strategy);
+        WithFirstSpliterator<T, Entry<T, T>> spliterator = new WithFirstSpliterator<>(spliterator(), AbstractMap.SimpleImmutableEntry<T, T>::new);
+        return mustClose() ? new EntryStream<>(delegateBase(spliterator), strategy) : new EntryStream<>(spliterator, strategy);
     }
 
     /**
@@ -1472,7 +1483,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper,
             Supplier<? extends Stream<R>> supplier) {
         HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(spliterator(), mapper, supplier);
-        Stream<R> delegate = delegate(spliterator);
+        Stream<R> delegate = delegateBase(spliterator);
         spliterator.owner = delegate;
         return new StreamEx<>(delegate, strategy);
     }
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index d20cdd8..f95b615 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -1062,6 +1062,22 @@ import java.util.stream.Stream;
     static <T> T none() {
         return (T) NONE;
     }
+    
+    static <T extends BaseStream<?, ?>> boolean mustCloseStream(BaseStream<?, ?> target) {
+        if(target == null)
+            return false;
+        if (target instanceof BaseStreamEx) {
+            return ((BaseStreamEx<?,?,?>)target).mustClose();
+        }
+        try {
+            if (SOURCE_STAGE != null && SOURCE_CLOSE_ACTION != null
+                && SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(target)) == null)
+                return false;
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            // ignore
+        }
+        return true;
+    }
 
     /**
      * Close target when proxy is closed. May omit close handler registration if
@@ -1072,20 +1088,12 @@ import java.util.stream.Stream;
      * @return proxy (to chain calls)
      */
     static <T extends BaseStream<?, ?>> T delegateClose(T proxy, BaseStream<?, ?> target) {
-        if (target == null) {
-            return proxy;
-        }
-        if (target instanceof BaseStreamEx) {
-            return ((BaseStreamEx<?,?,?>)target).forwardClose(proxy);
-        }
-        try {
-            if (SOURCE_STAGE != null && SOURCE_CLOSE_ACTION != null
-                && SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(target)) == null)
-                return proxy;
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-            // ignore
+        if (mustCloseStream(target)) {
+            if (target instanceof BaseStreamEx)
+                ((BaseStreamEx<?,?,?>)target).forwardClose(proxy);
+            else
+                proxy.onClose(target::close);
         }
-        proxy.onClose(target::close);
         return proxy;
     }
 }
