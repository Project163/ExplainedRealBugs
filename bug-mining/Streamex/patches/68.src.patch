diff --git a/CHANGES.md b/CHANGES.md
index 1eb5f82..13a790a 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,8 @@
 # StreamEx changes
 
+### 0.5.2
+* [#42] Added: `EntryStream.ofTree` methods to stream the tree-like structure tracking nodes depth.
+
 ### 0.5.1
 
 * [#13] Added: `StreamEx.split` to split with single character delimiter.
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 1ca61dd..e8758e5 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -53,6 +53,7 @@ Zip two arrays or lists | `any.zip()`
 Split `CharSequence` with regexp | `StreamEx.split()`
 Stream of `List` subLists of fixed length | `StreamEx.ofSubLists()`
 Stream of all elements of tree-like structure | `StreamEx.ofTree()`
+Stream of all elements of tree-like structure tracking the elements depth | `EntryStream.ofTree()`
 Stream of all possible pairs of array or `List` elements | `StreamEx/EntryStream.ofPairs()`
 Stream of all possible tuples of given length of `Collection` elements | `StreamEx.cartesianPower()`
 Stream of all possible tuples of given `Collection` of collections | `StreamEx.cartesianProduct()`
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index b7ba9d9..3593897 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -1365,8 +1365,9 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
     public static <T> EntryStream<T, T> ofPairs(T[] array) {
         return ofPairs(Arrays.asList(array));
     }
-    
-    static <T> Stream<Entry<Integer, T>> flatTraverse(Stream<Entry<Integer, T>> src, BiFunction<Integer, T, Stream<T>> streamProvider) {
+
+    static <T> Stream<Entry<Integer, T>> flatTraverse(Stream<Entry<Integer, T>> src,
+            BiFunction<Integer, T, Stream<T>> streamProvider) {
         return src.flatMap(entry -> {
             Integer depth = entry.getKey();
             Stream<T> result = streamProvider.apply(depth, entry.getValue());
@@ -1375,13 +1376,64 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         });
     }
 
+    /**
+     * Return a new {@link EntryStream} containing all the nodes of tree-like
+     * data structure in entry values along with the corresponding tree depths
+     * in entry keys, in depth-first order.
+     * 
+     * <p>
+     * The keys of the returned stream are non-negative integer numbers. 0 is
+     * used for the root node only, 1 is for root immediate children, 2 is for
+     * their children and so on.
+     * 
+     * @param <T>
+     *            the type of tree nodes
+     * @param root
+     *            root node of the tree
+     * @param mapper
+     *            a non-interfering, stateless function to apply to each tree
+     *            node and its depth which returns null for leaf nodes or stream
+     *            of direct children for non-leaf nodes.
+     * @return the new sequential ordered {@code EntryStream}
+     * @since 0.5.2
+     * @see StreamEx#ofTree(Object, Function)
+     * @see #ofTree(Object, Class, BiFunction)
+     */
     public static <T> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, Stream<T>> mapper) {
         Stream<T> rootStream = mapper.apply(0, root);
         Stream<Entry<Integer, T>> base = Stream.of(new ObjIntBox<>(root, 0));
         return rootStream == null ? of(base) : of(flatTraverse(rootStream.map(t -> new ObjIntBox<>(t, 1)), mapper))
                 .prepend(base);
     }
-    
+
+    /**
+     * Return a new {@link EntryStream} containing all the nodes of tree-like
+     * data structure in entry values along with the corresponding tree depths
+     * in entry keys, in depth-first order.
+     * 
+     * <p>
+     * The keys of the returned stream are non-negative integer numbers. 0 is
+     * used for the root node only, 1 is for root immediate children, 2 is for
+     * their children and so on.
+     * 
+     * @param <T>
+     *            the base type of tree nodes
+     * @param <TT>
+     *            the sub-type of composite tree nodes which may have children
+     * @param root
+     *            root node of the tree
+     * @param collectionClass
+     *            a class representing the composite tree node
+     * @param mapper
+     *            a non-interfering, stateless function to apply to each
+     *            composite tree node and its depth which returns stream of
+     *            direct children. May return null if the given node has no
+     *            children.
+     * @return the new sequential ordered stream
+     * @since 0.5.2
+     * @see StreamEx#ofTree(Object, Class, Function)
+     * @see #ofTree(Object, BiFunction)
+     */
     @SuppressWarnings("unchecked")
     public static <T, TT extends T> EntryStream<Integer, T> ofTree(T root, Class<TT> collectionClass,
             BiFunction<Integer, TT, Stream<T>> mapper) {
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index f4e75f4..7ac35af 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2215,6 +2215,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *            children for non-leaf nodes.
      * @return the new sequential ordered stream
      * @since 0.2.2
+     * @see EntryStream#ofTree(Object, BiFunction)
+     * @see #ofTree(Object, Class, Function)
      */
     public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
         Stream<T> rootStream = mapper.apply(root);
@@ -2239,6 +2241,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *            May return null if the given node has no children.
      * @return the new sequential ordered stream
      * @since 0.2.2
+     * @see EntryStream#ofTree(Object, Class, BiFunction)
+     * @see #ofTree(Object, Function)
      */
     @SuppressWarnings("unchecked")
     public static <T, TT extends T> StreamEx<T> ofTree(T root, Class<TT> collectionClass, Function<TT, Stream<T>> mapper) {
