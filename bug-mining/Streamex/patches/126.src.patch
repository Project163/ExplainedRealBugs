diff --git a/src/main/java/one/util/streamex/HeadTailSpliterator.java b/src/main/java/one/util/streamex/HeadTailSpliterator.java
index eaabaa0..198b201 100644
--- a/src/main/java/one/util/streamex/HeadTailSpliterator.java
+++ b/src/main/java/one/util/streamex/HeadTailSpliterator.java
@@ -34,7 +34,6 @@ import static one.util.streamex.StreamExInternals.*;
     private BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
     private Supplier<? extends Stream<U>> emptyMapper;
     private Spliterator<U> target;
-    private boolean finished;
     StreamContext context;
     
     HeadTailSpliterator(Spliterator<T> source, BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper,
@@ -51,7 +50,7 @@ import static one.util.streamex.StreamExInternals.*;
             return false;
         target = TailSpliterator.tryAdvanceWithTail(target, action);
         if(target == null) {
-            finished = true;
+            context = null;
             return false;
         }
         return true;
@@ -63,7 +62,7 @@ import static one.util.streamex.StreamExInternals.*;
             return null;
         Spliterator<U> tail = target;
         target = null;
-        finished = true;
+        context = null;
         return tail;
     }
 
@@ -73,7 +72,7 @@ import static one.util.streamex.StreamExInternals.*;
             return;
         TailSpliterator.forEachWithTail(target, action);
         target = null;
-        finished = true;
+        context = null;
     }
 
     @Override
@@ -82,7 +81,7 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     private boolean init() {
-        if(finished)
+        if(context == null)
             return false;
         if(target == null) {
             Box<T> first = new Box<>(null);
@@ -105,7 +104,7 @@ import static one.util.streamex.StreamExInternals.*;
     
     @Override
     public long estimateSize() {
-        if(finished)
+        if(context == null)
             return 0;
         return (target == null ? source : target).estimateSize();
     }
diff --git a/src/main/java/one/util/streamex/PrependSpliterator.java b/src/main/java/one/util/streamex/PrependSpliterator.java
new file mode 100644
index 0000000..3a7affa
--- /dev/null
+++ b/src/main/java/one/util/streamex/PrependSpliterator.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+import one.util.streamex.StreamExInternals.TailSpliterator;
+
+/**
+ * @author Tagir Valeev
+ *
+ * @param <T> type of the elements
+ */
+/* package */class PrependSpliterator<T> implements TailSpliterator<T> {
+    private Spliterator<T> source;
+    private T element;
+    private int mode;
+
+    public PrependSpliterator(Spliterator<T> source, T element) {
+        this.source = source;
+        this.element = element;
+        this.mode = source.estimateSize() < Long.MAX_VALUE-1 ? 1 : 2;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super T> action) {
+        if (mode == 0)
+            return source.tryAdvance(action);
+        action.accept(element);
+        element = null;
+        mode = 0;
+        return true;
+    }
+
+    @Override
+    public Spliterator<T> tryAdvanceOrTail(Consumer<? super T> action) {
+        if (mode == 0) {
+            Spliterator<T> s = source;
+            source = null;
+            return s;
+        }
+        action.accept(element);
+        element = null;
+        mode = 0;
+        return this;
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super T> action) {
+        if (mode != 0)
+            action.accept(element);
+        element = null;
+        mode = 0;
+        source.forEachRemaining(action);
+    }
+
+    @Override
+    public Spliterator<T> forEachOrTail(Consumer<? super T> action) {
+        if (mode != 0) {
+            action.accept(element);
+        }
+        Spliterator<T> s = source;
+        element = null;
+        mode = 0;
+        source = null;
+        return s;
+    }
+
+    @Override
+    public Spliterator<T> trySplit() {
+        if (mode == 0)
+            return source.trySplit();
+        mode = 0;
+        return new ConstSpliterator.OfRef<>(element, 1, true);
+    }
+
+    @Override
+    public long estimateSize() {
+        long size = source.estimateSize();
+        return mode == 0 ? size : size + 1;
+    }
+
+    @Override
+    public int characteristics() {
+        switch(mode) {
+        case 1:
+            return source.characteristics() & ORDERED & SIZED & SUBSIZED;
+        case 2:
+            return source.characteristics() & ORDERED;
+        default:
+            return source.characteristics();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 37fcb7a..965c74b 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -905,6 +905,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return appendSpliterator(null, Spliterators.spliterator(values, Spliterator.ORDERED));
     }
 
+    public StreamEx<T> append(T value) {
+        return appendSpliterator(null, new ConstSpliterator.OfRef<>(value, 1, true));
+    }
+
     /**
      * Returns a new {@code StreamEx} which is a concatenation of this stream
      * and the stream created from supplied collection.
@@ -944,6 +948,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return prependSpliterator(null, Spliterators.spliterator(values, Spliterator.ORDERED));
     }
 
+    public StreamEx<T> prepend(T value) {
+        return new StreamEx<>(new PrependSpliterator<>(spliterator(), value), context);
+    }
+
     /**
      * Returns a new {@code StreamEx} which is a concatenation of the stream
      * created from supplied collection and this stream.
diff --git a/src/test/java/one/util/streamex/StreamExHeadTailTest.java b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
index ebbdb8b..0d3d68a 100644
--- a/src/test/java/one/util/streamex/StreamExHeadTailTest.java
+++ b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
@@ -214,6 +214,13 @@ static <T, R> StreamEx<R> flatMap(StreamEx<T> input, Function<T, Stream<R>> mapp
     static <T> StreamEx<T> every(StreamEx<T> input, int n) {
         return input.headTail((head, tail) -> every(skip(tail, n - 1), n).prepend(head));
     }
+    
+    static <T> StreamEx<T> every3(StreamEx<T> input) {
+        return input.headTail(
+            (first, tail1) -> tail1.<T>headTail(
+                (second, tail2) -> tail2.headTail(
+                    (third, tail3) -> every3(tail3))).prepend(first));
+    }
 
     // maps every couple of elements using given mapper (in non-sliding manner)
     static <T, R> StreamEx<R> couples(StreamEx<T> input, BiFunction<T, T, R> mapper) {
@@ -387,6 +394,8 @@ static <T, R> StreamEx<R> flatMap(StreamEx<T> input, Function<T, Stream<R>> mapp
         
         assertEquals(asList(0, 3, 6, 9, 12, 15, 18, 0, 4, 8, 12, 16), twoFilters(IntStreamEx.range(20).boxed(),
             x -> x % 3 == 0, x -> x % 4 == 0).toList());
+        
+        assertEquals(asList(0, 3, 6, 9, 12, 15, 18), every3(IntStreamEx.range(20).boxed()).toList());
     }
 
     @Test
