diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 3edd334..321e07b 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1402,16 +1402,87 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
                 AbstractMap.SimpleImmutableEntry<T, T>::new);
         return new EntryStream<>(spliterator, context);
     }
-    
+
+    /**
+     * Creates a new {@link StreamEx} which is the result of applying of the
+     * mapper {@code BiFunction} to the corresponding elements of this stream
+     * and the supplied other stream. The resulting stream is ordered if both of
+     * the input streams are ordered, and parallel if either of the input
+     * streams is parallel. When the resulting stream is closed, the close
+     * handlers for both input streams are invoked.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The resulting stream finishes when either of the input streams finish:
+     * the rest of the longer stream is discarded. It's unspecified whether the
+     * rest elements of the longer stream are actually consumed.
+     * 
+     * <p>
+     * The stream created by this operation may have poor characteristics and
+     * parallelize badly, so it should be used only when there's no other
+     * choice. If both input streams are random-access lists or arrays, consider
+     * using {@link #zip(List, List, BiFunction)} or
+     * {@link #zip(Object[], Object[], BiFunction)} respectively. If you want to
+     * zip the stream with the stream of indices, consider using
+     * {@link EntryStream#of(List)} instead.
+     * 
+     * @param <V> the type of the other stream elements
+     * @param <R> the type of the resulting stream elements
+     * @param other the stream to zip this stream with
+     * @param mapper a non-interfering, stateless function to apply to the
+     *        corresponding pairs of this stream and other stream elements
+     * @return the new stream
+     * @since 0.5.5
+     * @see #zipWith(Stream)
+     */
     public <V, R> StreamEx<R> zipWith(Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
-        return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper, true), context.combine(other));
+        return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper, true), context
+                .combine(other));
     }
 
+    /**
+     * Creates a new {@link EntryStream} which keys are elements of this stream
+     * and values are the corresponding elements of the supplied other stream.
+     * The resulting stream is ordered if both of the input streams are ordered,
+     * and parallel if either of the input streams is parallel. When the
+     * resulting stream is closed, the close handlers for both input streams are
+     * invoked.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The resulting stream finishes when either of the input streams finish:
+     * the rest of the longer stream is discarded. It's unspecified whether the
+     * rest elements of the longer stream are actually consumed.
+     * 
+     * <p>
+     * The stream created by this operation may have poor characteristics and
+     * parallelize badly, so it should be used only when there's no other
+     * choice. If both input streams are random-access lists or arrays, consider
+     * using {@link EntryStream#zip(List, List)} or
+     * {@link EntryStream#zip(Object[], Object[])} respectively. If you want to
+     * zip the stream with the stream of indices, consider using
+     * {@link EntryStream#of(List)} instead.
+     * 
+     * @param <V> the type of the other stream elements
+     * @param <R> the type of the resulting stream elements
+     * @param other the stream to zip this stream with
+     * @param mapper a non-interfering, stateless function to apply to the
+     *        corresponding pairs of this stream and other stream elements
+     * @return the new stream
+     * @see #zipWith(Stream, BiFunction)
+     * @since 0.5.5
+     */
     public <V> EntryStream<T, V> zipWith(Stream<V> other) {
         return new EntryStream<>(new ZipSpliterator<>(spliterator(), other.spliterator(),
                 AbstractMap.SimpleImmutableEntry<T, V>::new, true), context.combine(other));
     }
-    
+
     /**
      * Creates a new Stream which is the result of applying of the mapper
      * {@code BiFunction} to the first element of the current stream (head) and
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index e8d63ae..df818ce 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1596,6 +1596,8 @@ public class StreamExTest {
         List<String> expected = asList("1. John", "2. Mary", "3. Jane", "4. Jimmy");
         streamEx(input::stream, s -> assertEquals(expected, s.get().zipWith(
             IntStream.range(1, Integer.MAX_VALUE).boxed(), (name, idx) -> idx + ". " + name).toList()));
+        streamEx(input::stream, s -> assertEquals(expected, s.get().zipWith(
+            IntStream.range(1, Integer.MAX_VALUE).boxed()).mapKeyValue((name, idx) -> idx + ". " + name).toList()));
         streamEx(() -> IntStream.range(1, Integer.MAX_VALUE).boxed(), s -> assertEquals(expected, s.get().zipWith(
             input.stream(), (idx, name) -> idx + ". " + name).toList()));
     }
diff --git a/src/test/java/one/util/streamex/ZipSpliteratorTest.java b/src/test/java/one/util/streamex/ZipSpliteratorTest.java
index 62b1c30..27eb847 100644
--- a/src/test/java/one/util/streamex/ZipSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/ZipSpliteratorTest.java
@@ -19,6 +19,7 @@ import static one.util.streamex.TestHelpers.*;
 
 import java.util.List;
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.function.Supplier;
 
 import org.junit.Test;
@@ -29,16 +30,37 @@ import org.junit.Test;
 public class ZipSpliteratorTest {
     @Test
     public void testEven() {
-        Supplier<Spliterator<String>> s = () -> new ZipSpliterator<>(IntStreamEx.range(1000).spliterator(), 
-                IntStreamEx.range(1, 1001).spliterator(), (x, y) -> x+":"+y, true);
-        List<String> expected = IntStreamEx.range(1000).mapToObj(x -> x+":"+(x+1)).toList();
+        List<String> expected = IntStreamEx.range(200).mapToObj(x -> x+":"+(x+1)).toList();
+        int[] nums = IntStreamEx.range(200).toArray();
+        Supplier<Spliterator<String>> s = () -> new ZipSpliterator<>(IntStreamEx.range(200).spliterator(), 
+                IntStreamEx.range(1, 201).spliterator(), (x, y) -> x+":"+y, true);
         checkSpliterator("even", expected, s);
-        s = () -> new ZipSpliterator<>(IntStreamEx.range(1000).spliterator(), 
-                IntStreamEx.range(2, 1002).map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
+        s = () -> new ZipSpliterator<>(IntStreamEx.range(200).spliterator(), 
+                IntStreamEx.range(2, 202).parallel().map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
         checkSpliterator("evenMap", expected, s);
-        int[] nums = IntStreamEx.range(1000).toArray();
         s = () -> new ZipSpliterator<>(IntStreamEx.of(nums).spliterator(), 
-                IntStreamEx.range(2, 1002).map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
+                IntStreamEx.range(2, 202).parallel().map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
         checkSpliterator("evenArray", expected, s);
     }
+
+    @Test
+    public void testUnEven() {
+        List<String> expected = IntStreamEx.range(200).mapToObj(x -> x+":"+(x+1)).toList();
+        Supplier<Spliterator<String>> s = () -> new ZipSpliterator<>(IntStreamEx.range(200).spliterator(), 
+                IntStreamEx.range(90).append(IntStreamEx.range(90, 200)).spliterator(), (x, y) -> x+":"+(y+1), true);
+        checkSpliterator("unevenRight", expected, s);
+        s = () -> new ZipSpliterator<>( 
+                IntStreamEx.range(90).append(IntStreamEx.range(90, 200)).spliterator(), 
+                IntStreamEx.range(200).spliterator(), (x, y) -> x+":"+(y+1), true);
+        checkSpliterator("unevenLeft", expected, s);
+    }
+    
+    @Test
+    public void testUnknownSize() {
+        List<String> expected = IntStreamEx.range(200).mapToObj(x -> x+":"+(x+1)).toList();
+        Supplier<Spliterator<String>> s = () -> new ZipSpliterator<>(Spliterators.spliteratorUnknownSize(IntStreamEx
+                .range(200).iterator(), Spliterator.ORDERED), Spliterators.spliteratorUnknownSize(IntStreamEx.range(1,
+            201).iterator(), Spliterator.ORDERED), (x, y) -> x + ":" + y, true);
+        checkSpliterator("unknownSize", expected, s);
+    }
 }
