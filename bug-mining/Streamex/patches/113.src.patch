diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 6b08407..ee35b56 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -140,6 +140,32 @@ import static one.util.streamex.StreamExInternals.*;
         return stream.collect(collector);
     }
 
+    @SuppressWarnings("unchecked")
+    S appendSpliterator(Stream<? extends T> other, Spliterator<? extends T> right) {
+        if(right.getExactSizeIfKnown() == 0)
+            return (S) this;
+        Spliterator<T> left = stream.spliterator();
+        Spliterator<T> result;
+        if(left.getExactSizeIfKnown() == 0)
+            result = (Spliterator<T>) right;
+        else
+            result = new TailConcatSpliterator<>(left, right);
+        return supply(delegateClose(delegateClose(StreamSupport.stream(result, stream.isParallel()), stream), other));
+    }
+
+    @SuppressWarnings("unchecked")
+    S prependSpliterator(Stream<? extends T> other, Spliterator<? extends T> left) {
+        if(left.getExactSizeIfKnown() == 0)
+            return (S) this;
+        Spliterator<T> right = stream.spliterator();
+        Spliterator<T> result;
+        if(right.getExactSizeIfKnown() == 0)
+            result = (Spliterator<T>) left;
+        else
+            result = new TailConcatSpliterator<>(left, right);
+        return supply(delegateClose(delegateClose(StreamSupport.stream(result, stream.isParallel()), stream), other));
+    }
+
     abstract S supply(Stream<T> stream);
 
     @Override
@@ -970,12 +996,20 @@ import static one.util.streamex.StreamExInternals.*;
      * parallel if either of the input streams is parallel. When the resulting
      * stream is closed, the close handlers for both input streams are invoked.
      *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
+     * 
+     * <p>
+     * May return this if the supplied stream is known to be empty.
+     * 
      * @param other the other stream
      * @return this stream appended by the other stream
      * @see Stream#concat(Stream, Stream)
      */
     public S append(Stream<? extends T> other) {
-        return supply(Stream.concat(stream, unwrap(other)));
+        return appendSpliterator(other, other.spliterator());
     }
 
     /**
@@ -985,12 +1019,20 @@ import static one.util.streamex.StreamExInternals.*;
      * parallel if either of the input streams is parallel. When the resulting
      * stream is closed, the close handlers for both input streams are invoked.
      *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
+     * 
+     * <p>
+     * May return this if the supplied stream is known to be empty.
+     * 
      * @param other the other stream
      * @return this stream prepended by the other stream
      * @see Stream#concat(Stream, Stream)
      */
     public S prepend(Stream<? extends T> other) {
-        return supply(Stream.concat(unwrap(other), stream));
+        return prependSpliterator(other, other.spliterator());
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 97fd909..d9296e5 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -18,6 +18,7 @@ package one.util.streamex;
 import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -305,12 +306,15 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      * 
+     * <p>
+     * May return this if the supplied map is empty and non-concurrent.
+     * 
      * @param map the map to prepend to the stream
      * @return the new stream
      * @since 0.2.1
      */
     public EntryStream<K, V> append(Map<K, V> map) {
-        return append(map.entrySet().stream());
+        return appendSpliterator(null, map.entrySet().spliterator());
     }
 
     /**
@@ -326,7 +330,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public EntryStream<K, V> append(K key, V value) {
-        return append(Stream.of(new SimpleImmutableEntry<>(key, value)));
+        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), Collections.singleton(
+            new SimpleImmutableEntry<>(key, value)).spliterator())));
     }
 
     /**
@@ -345,7 +350,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.2.3
      */
     public EntryStream<K, V> append(K k1, V v1, K k2, V v2) {
-        return append(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2)));
+        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), Arrays.<Entry<K, V>> asList(
+            new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2)).spliterator())));
     }
 
     /**
@@ -366,8 +372,9 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.2.3
      */
     public EntryStream<K, V> append(K k1, V v1, K k2, V v2, K k3, V v3) {
-        return append(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
-            new SimpleImmutableEntry<>(k3, v3)));
+        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), Arrays.<Entry<K, V>> asList(
+            new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2), new SimpleImmutableEntry<>(k3, v3))
+                .spliterator())));
     }
 
     /**
@@ -376,14 +383,18 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
+     * 
+     * <p>
+     * May return this if the supplied map is empty and non-concurrent.
      * 
      * @param map the map to prepend to the stream
      * @return the new stream
      * @since 0.2.1
      */
     public EntryStream<K, V> prepend(Map<K, V> map) {
-        return append(map.entrySet().stream());
+        return prepend(map.entrySet().stream());
     }
 
     /**
@@ -392,14 +403,16 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
      * 
      * @param key the key of the new {@code Entry} to prepend to this stream
      * @param value the value of the new {@code Entry} to prepend to this stream
      * @return the new stream
      */
     public EntryStream<K, V> prepend(K key, V value) {
-        return prepend(Stream.of(new SimpleImmutableEntry<>(key, value)));
+        return supply(delegate(new TailConcatSpliterator<>(Collections
+                .singleton(new SimpleImmutableEntry<>(key, value)).spliterator(), stream.spliterator())));
     }
 
     /**
@@ -408,7 +421,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
      * 
      * @param k1 the key of the first {@code Entry} to prepend to this stream
      * @param v1 the value of the first {@code Entry} to prepend to this stream
@@ -418,7 +432,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.2.3
      */
     public EntryStream<K, V> prepend(K k1, V v1, K k2, V v2) {
-        return prepend(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2)));
+        return supply(delegate(new TailConcatSpliterator<>(Arrays.<Entry<K, V>> asList(
+            new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2)).spliterator(), stream.spliterator())));
     }
 
     /**
@@ -427,7 +442,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
      * 
      * @param k1 the key of the first {@code Entry} to prepend to this stream
      * @param v1 the value of the first {@code Entry} to prepend to this stream
@@ -439,8 +455,9 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.2.3
      */
     public EntryStream<K, V> prepend(K k1, V v1, K k2, V v2, K k3, V v3) {
-        return prepend(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
-            new SimpleImmutableEntry<>(k3, v3)));
+        return supply(delegate(new TailConcatSpliterator<>(Arrays.<Entry<K, V>> asList(
+            new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2), new SimpleImmutableEntry<>(k3, v3))
+                .spliterator(), stream.spliterator())));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1e5af2d..e561496 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -927,6 +927,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      * 
+     * <p>
+     * May return this if no values are supplied.
+     * 
      * @param values the values to append to the stream
      * @return the new stream
      */
@@ -946,14 +949,15 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
      * 
+     * <p>
+     * May return this if the supplied collection is empty and non-concurrent.
+     * 
      * @param collection the collection to append to the stream
      * @return the new stream
      * @since 0.2.1
      */
     public StreamEx<T> append(Collection<? extends T> collection) {
-        if (collection.isEmpty())
-            return this;
-        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), collection.spliterator())));
+        return appendSpliterator(null, collection.spliterator());
     }
 
     /**
@@ -965,6 +969,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * operation</a> with <a href="package-summary.html#TSO">tail-stream
      * optimization</a>.
      * 
+     * <p>
+     * May return this if no values are supplied.
+     * 
      * @param values the values to prepend to the stream
      * @return the new stream
      */
@@ -982,16 +989,18 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a>.
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
+     * optimization</a>.
+     * 
+     * <p>
+     * May return this if the supplied collection is empty and non-concurrent.
      * 
      * @param collection the collection to prepend to the stream
      * @return the new stream
      * @since 0.2.1
      */
     public StreamEx<T> prepend(Collection<? extends T> collection) {
-        if (collection.isEmpty())
-            return this;
-        return supply(delegate(new TailConcatSpliterator<>(collection.spliterator(), stream.spliterator())));
+        return prependSpliterator(null, collection.spliterator());
     }
 
     /**
diff --git a/src/test/java/one/util/streamex/TestHelpers.java b/src/test/java/one/util/streamex/TestHelpers.java
index c0c141a..eb1a032 100644
--- a/src/test/java/one/util/streamex/TestHelpers.java
+++ b/src/test/java/one/util/streamex/TestHelpers.java
@@ -19,7 +19,6 @@ import static one.util.streamex.StreamExInternals.*;
 import static org.junit.Assert.*;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
@@ -29,6 +28,7 @@ import java.util.Random;
 import java.util.Spliterator;
 import java.util.Map.Entry;
 import java.util.Spliterators;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -70,11 +70,11 @@ public class TestHelpers {
             case PARALLEL:
                 return res.parallel();
             case APPEND:
-                // using Stream.empty() here makes the resulting stream
-                // unordered which is undesired
-                return StreamEx.of(res.parallel()).append(Arrays.<T> asList().stream());
+                // using Stream.empty() or Arrays.asList() here is optimized out
+                // in append/prepend which is undesired
+                return StreamEx.of(res.parallel()).append(new ConcurrentLinkedQueue<>());
             case PREPEND:
-                return StreamEx.of(res.parallel()).prepend(Arrays.<T> asList().stream());
+                return StreamEx.of(res.parallel()).prepend(new ConcurrentLinkedQueue<>());
             case RANDOM:
                 return StreamEx.of(new EmptyingSpliterator<>(res.parallel().spliterator())).parallel();
             default:
