diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 90e1b12..1e5af2d 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -50,7 +50,6 @@ import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.BiPredicate;
 import java.util.function.BinaryOperator;
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -79,92 +78,6 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
 
-    private static class PrependSpliterator<T> implements TailSpliterator<T> {
-        private Spliterator<T> source;
-        private T[] prepended;
-        private int position;
-        private int characteristics;
-
-        public PrependSpliterator(Spliterator<T> source, T[] prepended) {
-            this.source = source;
-            this.prepended = prepended;
-            this.characteristics = source.characteristics() & (ORDERED | SIZED | SUBSIZED);
-            if (((this.characteristics & SIZED) != 0) && prepended.length + source.estimateSize() < 0)
-                this.characteristics &= (~SIZED) & (~SUBSIZED);
-        }
-
-        @Override
-        public boolean tryAdvance(Consumer<? super T> action) {
-            if (prepended != null) {
-                action.accept(prepended[position++]);
-                if (position == prepended.length)
-                    prepended = null;
-                return true;
-            }
-            return source.tryAdvance(action);
-        }
-
-        @Override
-        public Spliterator<T> tryAdvanceOrTail(Consumer<? super T> action) {
-            if (prepended == null) {
-                Spliterator<T> s = source;
-                source = null;
-                return s;
-            }
-            action.accept(prepended[position++]);
-            if (position == prepended.length)
-                prepended = null;
-            return this;
-        }
-
-        @Override
-        public void forEachRemaining(Consumer<? super T> action) {
-            if (prepended != null) {
-                while (position < prepended.length) {
-                    action.accept(prepended[position++]);
-                }
-                prepended = null;
-            }
-            source.forEachRemaining(action);
-        }
-
-        @Override
-        public Spliterator<T> forEachOrTail(Consumer<? super T> action) {
-            if (prepended != null) {
-                while (position < prepended.length) {
-                    action.accept(prepended[position++]);
-                }
-                prepended = null;
-            }
-            Spliterator<T> s = source;
-            source = null;
-            return s;
-        }
-
-        @Override
-        public Spliterator<T> trySplit() {
-            if (prepended == null)
-                return source.trySplit();
-            Spliterator<T> prefix = Spliterators.spliterator(prepended, position, prepended.length, characteristics);
-            prepended = null;
-            return prefix;
-        }
-
-        @Override
-        public long estimateSize() {
-            long size = source.estimateSize();
-            if (prepended == null)
-                return size;
-            size = size + prepended.length - position;
-            return size < 0 ? Long.MAX_VALUE : size;
-        }
-
-        @Override
-        public int characteristics() {
-            return characteristics;
-        }
-    }
-
     StreamEx(Stream<T> stream) {
         super(stream);
     }
@@ -1021,7 +934,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public final StreamEx<T> append(T... values) {
         if (values.length == 0)
             return this;
-        return append(Stream.of(values));
+        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), Spliterators.spliterator(values,
+            Spliterator.ORDERED))));
     }
 
     /**
@@ -1039,7 +953,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public StreamEx<T> append(Collection<? extends T> collection) {
         if (collection.isEmpty())
             return this;
-        return append(collection.stream());
+        return supply(delegate(new TailConcatSpliterator<>(stream.spliterator(), collection.spliterator())));
     }
 
     /**
@@ -1058,7 +972,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public final StreamEx<T> prepend(T... values) {
         if (values.length == 0)
             return this;
-        return supply(delegate(new PrependSpliterator<>(stream.spliterator(), values)));
+        return supply(delegate(new TailConcatSpliterator<>(Spliterators.spliterator(values, Spliterator.ORDERED),
+                stream.spliterator())));
     }
 
     /**
@@ -1076,7 +991,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public StreamEx<T> prepend(Collection<? extends T> collection) {
         if (collection.isEmpty())
             return this;
-        return prepend(collection.stream());
+        return supply(delegate(new TailConcatSpliterator<>(collection.spliterator(), stream.spliterator())));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/TailConcatSpliterator.java b/src/main/java/one/util/streamex/TailConcatSpliterator.java
new file mode 100644
index 0000000..71a00e4
--- /dev/null
+++ b/src/main/java/one/util/streamex/TailConcatSpliterator.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.function.Consumer;
+
+import one.util.streamex.StreamExInternals.TailSpliterator;
+
+/**
+ * @author Tagir Valeev
+ *
+ * @param <T> type of the elements
+ */
+/* package */class TailConcatSpliterator<T> implements TailSpliterator<T> {
+    private Spliterator<T> left, right;
+    private int characteristics;
+    private long size;
+
+    @SuppressWarnings("unchecked")
+    public TailConcatSpliterator(Spliterator<? extends T> left, Spliterator<? extends T> right) {
+        this.left = (Spliterator<T>) left;
+        this.right = (Spliterator<T>) right;
+        this.characteristics = left.characteristics() & right.characteristics() & (ORDERED | SIZED | SUBSIZED);
+        this.size = left.estimateSize() + right.estimateSize();
+        if (this.size < 0) {
+            this.size = Long.MAX_VALUE;
+            this.characteristics &= (~SIZED) & (~SUBSIZED);
+        }
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super T> action) {
+        if (left != null) {
+            if (left.tryAdvance(action)) {
+                if (size > 0 && size != Long.MAX_VALUE)
+                    size--;
+                return true;
+            }
+            left = null;
+        }
+        return right.tryAdvance(action);
+    }
+
+    @Override
+    public Spliterator<T> tryAdvanceOrTail(Consumer<? super T> action) {
+        if (left == null || !left.tryAdvance(action)) {
+            Spliterator<T> s = right;
+            right = null;
+            return s;
+        }
+        if (size > 0 && size != Long.MAX_VALUE)
+            size--;
+        return this;
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super T> action) {
+        if (left != null)
+            left.forEachRemaining(action);
+        right.forEachRemaining(action);
+    }
+
+    @Override
+    public Spliterator<T> forEachOrTail(Consumer<? super T> action) {
+        if (left != null)
+            left.forEachRemaining(action);
+        Spliterator<T> s = right;
+        right = null;
+        return s;
+    }
+
+    @Override
+    public Spliterator<T> trySplit() {
+        if (left == null)
+            return right.trySplit();
+        Spliterator<T> s = left;
+        left = null;
+        return s;
+    }
+
+    @Override
+    public long estimateSize() {
+        if (left == null)
+            return right.estimateSize();
+        return size;
+    }
+
+    @Override
+    public int characteristics() {
+        return characteristics;
+    }
+}
\ No newline at end of file
