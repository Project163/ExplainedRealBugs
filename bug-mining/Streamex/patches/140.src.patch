diff --git a/CHANGES.md b/CHANGES.md
index dbbefef..a68a73d 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -3,6 +3,7 @@
 ### 0.5.5
 * [#41] Added: `IntStreamEx/LongStreamEx/StreamEx.without()` accepting several elements.
 * [#63] Optimized `IntStreamEx/LongStreamEx/DoubleStreamEx.reverseSorted()`: much faster now and take less memory.
+* [#64] Added: `EntryStream.toMapAndThen()`.
 
 ### 0.5.4
 * [#10] Added: `chain()` method to all stream types allowing fluently chaining custom operations.
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index f0888c7..5fe57e0 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -176,6 +176,7 @@ What I want | How to get it
 Collect elements to `List`, `Set` or custom `Collection` | `StreamEx/EntryStream.toList()/toSet()/toCollection()`
 Collect elements to `List` or `Set` adding custom final step | `StreamEx/EntryStream.toListAndThen()/toSetAndThen()`
 Collect elements or entries to `Map` | `StreamEx/EntryStream.toMap()/toSortedMap()`
+Collect entries to `Map` adding custom final step | `EntryStream.toMapAndThen()`
 Collect entries to custom `Map` | `EntryStream.toCustomMap()`
 Partition elements using the `Predicate` | `StreamEx.partitioningBy()/partitioningTo()`
 Grouping elements | `StreamEx.groupingBy()/groupingTo()`
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index f23326d..ac72522 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -108,7 +108,7 @@ import static one.util.streamex.StreamExInternals.*;
     AbstractStreamEx(Spliterator<T> spliterator, StreamContext context) {
         super(spliterator, context);
     }
-    
+
     @Override
     final Stream<T> createStream() {
         return StreamSupport.stream(spliterator, context.parallel);
@@ -139,18 +139,18 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     <R, A> R rawCollect(Collector<? super T, A, R> collector) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(collector, stream()::collect);
         return stream().collect(collector);
     }
 
     @SuppressWarnings("unchecked")
     S appendSpliterator(Stream<? extends T> other, Spliterator<? extends T> right) {
-        if(right.getExactSizeIfKnown() == 0)
+        if (right.getExactSizeIfKnown() == 0)
             return (S) this;
         Spliterator<T> left = spliterator();
         Spliterator<T> result;
-        if(left.getExactSizeIfKnown() == 0)
+        if (left.getExactSizeIfKnown() == 0)
             result = (Spliterator<T>) right;
         else
             result = new TailConcatSpliterator<>(left, right);
@@ -160,11 +160,11 @@ import static one.util.streamex.StreamExInternals.*;
 
     @SuppressWarnings("unchecked")
     S prependSpliterator(Stream<? extends T> other, Spliterator<? extends T> left) {
-        if(left.getExactSizeIfKnown() == 0)
+        if (left.getExactSizeIfKnown() == 0)
             return (S) this;
         Spliterator<T> right = spliterator();
         Spliterator<T> result;
-        if(right.getExactSizeIfKnown() == 0)
+        if (right.getExactSizeIfKnown() == 0)
             result = (Spliterator<T>) left;
         else
             result = new TailConcatSpliterator<>(left, right);
@@ -314,7 +314,7 @@ import static one.util.streamex.StreamExInternals.*;
         if (spliterator != null && !isParallel()) {
             spliterator().forEachRemaining(action);
         } else {
-            if(context.fjp != null)
+            if (context.fjp != null)
                 context.terminate(() -> {
                     stream().forEach(action);
                     return null;
@@ -330,7 +330,7 @@ import static one.util.streamex.StreamExInternals.*;
         if (spliterator != null && !isParallel()) {
             spliterator().forEachRemaining(action);
         } else {
-            if(context.fjp != null)
+            if (context.fjp != null)
                 context.terminate(() -> {
                     stream().forEachOrdered(action);
                     return null;
@@ -348,35 +348,35 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public <A> A[] toArray(IntFunction<A[]> generator) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(generator, stream()::toArray);
         return stream().toArray(generator);
     }
 
     @Override
     public T reduce(T identity, BinaryOperator<T> accumulator) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(() -> stream().reduce(identity, accumulator));
         return stream().reduce(identity, accumulator);
     }
 
     @Override
     public Optional<T> reduce(BinaryOperator<T> accumulator) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(accumulator, stream()::reduce);
         return stream().reduce(accumulator);
     }
 
     @Override
     public <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(() -> stream().reduce(identity, accumulator, combiner));
         return stream().reduce(identity, accumulator, combiner);
     }
 
     @Override
     public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
     }
@@ -440,21 +440,21 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public long count() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::count);
         return stream().count();
     }
 
     @Override
     public boolean anyMatch(Predicate<? super T> predicate) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(predicate, stream()::anyMatch);
         return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(Predicate<? super T> predicate) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(predicate, stream()::allMatch);
         return stream().allMatch(predicate);
     }
@@ -466,14 +466,14 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public Optional<T> findFirst() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::findFirst);
         return stream().findFirst();
     }
 
     @Override
     public Optional<T> findAny() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::findAny);
         return stream().findAny();
     }
@@ -1109,21 +1109,23 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     /**
-     * Collecting the stream producing a {@link List} containing all the stream
-     * elements and performing an additional finishing transformation.
+     * Creates a {@link List} containing the elements of this stream, then
+     * performs finishing transformation and returns its result. There are no
+     * guarantees on the type, serializability or thread-safety of the
+     * {@code List} created.
      * 
      * <p>
      * This is a terminal operation.
      *
-     * @param <R> the result type
+     * @param <R> the type of the result
      * @param finisher a function to be applied to the intermediate list
      * @return result of applying the finisher transformation to the list of the
      *         stream elements.
      * @since 0.2.3
      * @see #toList()
      */
-    public <R> R toListAndThen(Function<List<T>, R> finisher) {
-        if(context.fjp != null)
+    public <R> R toListAndThen(Function<? super List<T>, R> finisher) {
+        if (context.fjp != null)
             return context.terminate(() -> finisher.apply(toList()));
         return finisher.apply(toList());
     }
@@ -1146,21 +1148,25 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     /**
-     * Collecting the stream producing a {@link Set} containing all the stream
-     * elements and performing an additional finishing transformation.
+     * Creates a {@link Set} containing the elements of this stream, then
+     * performs finishing transformation and returns its result. There are no
+     * guarantees on the type, serializability or thread-safety of the
+     * {@code Set} created.
      * 
      * <p>
      * This is a terminal operation.
      *
      * @param <R> the result type
-     * @param finisher a function to be applied to the intermediate set
-     * @return result of applying the finisher transformation to the set of the
-     *         stream elements.
+     * @param finisher a function to be applied to the intermediate {@code Set}
+     * @return result of applying the finisher transformation to the {@code Set}
+     *         of the stream elements.
      * @since 0.2.3
      * @see #toSet()
      */
-    public <R> R toSetAndThen(Function<Set<T>, R> finisher) {
-        return rawCollect(Collectors.collectingAndThen(Collectors.toSet(), finisher));
+    public <R> R toSetAndThen(Function<? super Set<T>, R> finisher) {
+        if (context.fjp != null)
+            return context.terminate(() -> finisher.apply(toSet()));
+        return finisher.apply(toSet());
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index f5fadb1..247d5d9 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -240,8 +240,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      */
     public <VV> EntryStream<K, VV> flatMapToValue(
             BiFunction<? super K, ? super V, ? extends Stream<? extends VV>> mapper) {
-        return new EntryStream<>(
-            stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getKey(), e.getValue()))), context);
+        return new EntryStream<>(stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getKey(), e.getValue()))),
+                context);
     }
 
     /**
@@ -297,7 +297,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public EntryStream<K, V> append(K key, V value) {
-        return appendSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value)).spliterator());
+        return appendSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value))
+                .spliterator());
     }
 
     /**
@@ -497,8 +498,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public <VV> EntryStream<K, VV> mapValues(Function<? super V, ? extends VV> valueMapper) {
-        return new EntryStream<>(
-            stream().map(e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getValue()))), context);
+        return new EntryStream<>(stream().map(
+            e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getValue()))), context);
     }
 
     /**
@@ -819,11 +820,6 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * {@link #toCustomMap(Supplier)}.
      *
      * <p>
-     * If the mapped keys contains duplicates (according to
-     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
-     * thrown when the collection operation is performed.
-     * 
-     * <p>
      * This is a <a href="package-summary.html#StreamOps">terminal</a>
      * operation.
      *
@@ -834,6 +830,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * For parallel stream the concurrent {@code Map} is created.
      *
      * @return a {@code Map} containing the elements of this stream
+     * @throws IllegalStateException if this stream contains duplicate keys
+     *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      */
@@ -843,6 +841,36 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return map;
     }
 
+    /**
+     * Creates a {@link Map} containing the elements of this stream, then
+     * performs finishing transformation and returns its result. There are no
+     * guarantees on the type or serializability of the {@code Map} created.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">terminal</a>
+     * operation.
+     *
+     * <p>
+     * Created {@code Map} is guaranteed to be modifiable.
+     *
+     * <p>
+     * For parallel stream the concurrent {@code Map} is created.
+     *
+     * @param <R> the type of the result
+     * @param finisher a function to be applied to the intermediate map
+     * @return result of applying the finisher transformation to the {@code Map}
+     *         of the stream elements.
+     * @throws IllegalStateException if this stream contains duplicate keys
+     *         (according to {@link Object#equals(Object)})
+     * @see #toMap()
+     * @since 0.5.5
+     */
+    public <R> R toMapAndThen(Function<? super Map<K, V>, R> finisher) {
+        if (context.fjp != null)
+            return context.terminate(() -> finisher.apply(toMap()));
+        return finisher.apply(toMap());
+    }
+
     /**
      * Returns a {@link Map} containing the elements of this stream. There are
      * no guarantees on the type or serializability of the {@code Map} returned;
@@ -883,11 +911,6 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * {@code Map} is created by a provided supplier function.
      *
      * <p>
-     * If the mapped keys contains duplicates (according to
-     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
-     * thrown when the collection operation is performed.
-     * 
-     * <p>
      * This is a <a href="package-summary.html#StreamOps">terminal</a>
      * operation.
      * 
@@ -895,6 +918,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @param mapSupplier a function which returns a new, empty {@code Map} into
      *        which the results will be inserted
      * @return a {@code Map} containing the elements of this stream
+     * @throws IllegalStateException if this stream contains duplicate keys
+     *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      */
@@ -944,11 +969,6 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * {@link #toCustomMap(Supplier)}.
      *
      * <p>
-     * If the mapped keys contains duplicates (according to
-     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
-     * thrown when the collection operation is performed.
-     * 
-     * <p>
      * This is a <a href="package-summary.html#StreamOps">terminal</a>
      * operation.
      *
@@ -961,6 +981,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return a {@code SortedMap} containing the elements of this stream
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
+     * @throws IllegalStateException if this stream contains duplicate keys
+     *         (according to {@link Object#equals(Object)})
      * @since 0.1.0
      */
     public SortedMap<K, V> toSortedMap() {
@@ -1003,14 +1025,16 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
     }
 
     /**
-     * Returns a {@link Map} where elements of this stream with the same key are grouped together.
-     * The resulting {@code Map} keys are keys of this stream entries and the values
-     * are lists of the corresponding values.      
+     * Returns a {@link Map} where elements of this stream with the same key are
+     * grouped together. The resulting {@code Map} keys are keys of this stream
+     * entries and the values are lists of the corresponding values.
      * 
-     * <p>There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code Map} or {@code List} objects returned.
-     * If more control over the returned {@code Map} is required, use {@link #grouping(Supplier)}.
-     * If more control over the lists required, use {@link #groupingTo(Supplier)}.
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code Map} or {@code List} objects returned. If
+     * more control over the returned {@code Map} is required, use
+     * {@link #grouping(Supplier)}. If more control over the lists required, use
+     * {@link #groupingTo(Supplier)}.
      *
      * <p>
      * This is a <a href="package-summary.html#StreamOps">terminal</a>
@@ -1109,10 +1133,10 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the wrapped stream
      */
     public static <K, V> EntryStream<K, V> of(Stream<? extends Entry<K, V>> stream) {
-        if(stream instanceof AbstractStreamEx) {
+        if (stream instanceof AbstractStreamEx) {
             @SuppressWarnings("unchecked")
-            AbstractStreamEx<Entry<K, V>, ?> ase = (AbstractStreamEx<Entry<K, V>, ?>)stream;
-            if(ase.spliterator != null)
+            AbstractStreamEx<Entry<K, V>, ?> ase = (AbstractStreamEx<Entry<K, V>, ?>) stream;
+            if (ase.spliterator != null)
                 return new EntryStream<>(ase.spliterator(), ase.context);
             return new EntryStream<>(ase.stream(), ase.context);
         }
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1f02140..d232ee4 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -679,11 +679,6 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * operation.
      * 
      * <p>
-     * If this stream contains duplicates (according to
-     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
-     * thrown when the collection operation is performed.
-     *
-     * <p>
      * Returned {@code Map} is guaranteed to be modifiable.
      *
      * <p>
@@ -693,7 +688,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param valMapper a mapping function to produce values
      * @return a {@code Map} whose keys are elements from this stream and values
      *         are the result of applying mapping function to the input elements
-     *
+     * @throws IllegalStateException if this stream contains duplicate objects
+     *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toMap(Function, Function)
@@ -711,11 +707,6 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * operation.
      * 
      * <p>
-     * If the mapped keys contains duplicates (according to
-     * {@link Object#equals(Object)}), an {@code IllegalStateException} is
-     * thrown when the collection operation is performed.
-     * 
-     * <p>
      * Returned {@code Map} is guaranteed to be modifiable.
      *
      * <p>
@@ -727,6 +718,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param valMapper a mapping function to produce values
      * @return a {@code Map} whose keys and values are the result of applying
      *         mapping functions to the input elements
+     * @throws IllegalStateException if duplicate mapped key is found (according
+     *         to {@link Object#equals(Object)})
      *
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
diff --git a/src/test/java/one/util/streamex/CustomPoolTest.java b/src/test/java/one/util/streamex/CustomPoolTest.java
index 5ca0b3c..b73286a 100644
--- a/src/test/java/one/util/streamex/CustomPoolTest.java
+++ b/src/test/java/one/util/streamex/CustomPoolTest.java
@@ -20,6 +20,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -100,7 +101,12 @@ public class CustomPoolTest {
                 this.checkThread(list);
                 return list;
             }));
-        
+        assertEquals(new HashSet<>(Arrays.asList(1, 2, 3)), StreamEx.of(1, 2, 3).parallel(pool).peek(this::checkThread)
+                .toSetAndThen(list -> {
+                    this.checkThread(list);
+                    return list;
+                }));
+
         assertEquals(Collections.singletonMap(1, 3L), StreamEx.of(1, 1, 1).parallel(pool).peek(this::checkThread)
                 .runLengths().toMap());
     }
@@ -143,6 +149,12 @@ public class CustomPoolTest {
             return l;
         });
         assertEquals(Arrays.asList(array), list);
+        Map<String, Integer> map = EntryStream.of("a", 1, "b", 2, "c", 3).parallel(pool).peek(
+            this::checkThread).filterValues(v -> v > 1).toMapAndThen(m -> {
+            this.checkThread(m);
+            return m;
+        });
+        assertEquals(EntryStream.of("b", 2, "c", 3).toMap(), map);
 
         assertEquals(new SimpleEntry<>("abc", 6), EntryStream.of("a", 1, "b", 2, "c", 3).parallel(pool).peek(
             this::checkThread).reduce(
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index ce905e4..95c929e 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -325,6 +325,14 @@ public class EntryStreamTest {
         assertEquals(createMap(), sortedMap2);
         assertTrue(sortedMap2 instanceof ConcurrentMap);
     }
+    
+    @Test
+    public void testToMapAndThen() {
+        Map<String, Integer> map = EntryStream.of(createMap()).append("d", 4).toMapAndThen(EntryStream::of).append("e",
+            5).toMap();
+        Map<String, Integer> expected = EntryStream.of("a", 1, "bb", 22, "ccc", 33, "d", 4, "e", 5).toMap();
+        assertEquals(expected, map);
+    }
 
     @Test
     public void testFlatMap() {
