diff --git a/CHANGES.md b/CHANGES.md
index 6f31ad7..7da1038 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,8 @@
 # StreamEx changes
 
+### 0.5.4
+* [#56] Fixed: `StreamEx.append/prepend(Collection)` and `EntryStream.append/prepend(Map)` now properly append/prepend if supplied collection is concurrent (so it may be legally modified during the subsequent operations).
+
 ### 0.5.3
 * [#50] Added: `StreamEx.withFirst()`: extract first stream element 
 * [#51] Fixed: `StreamEx.parallel(fjp).runLengths()` fails to run the task in the specified pool.
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 36e764a..b82f804 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -18,7 +18,6 @@ package one.util.streamex;
 import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -330,7 +329,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public EntryStream<K, V> append(K key, V value) {
-        return appendSpliterator(null, Collections.singleton(new SimpleImmutableEntry<>(key, value)).spliterator());
+        return appendSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value)).spliterator());
     }
 
     /**
@@ -409,7 +408,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public EntryStream<K, V> prepend(K key, V value) {
-        return prependSpliterator(null, Collections.singleton(new SimpleImmutableEntry<>(key, value)).spliterator());
+        return prependSpliterator(null, Arrays.<Entry<K, V>> asList(new SimpleImmutableEntry<>(key, value)).spliterator());
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/TailConcatSpliterator.java b/src/main/java/one/util/streamex/TailConcatSpliterator.java
index 71a00e4..cb0a1ca 100644
--- a/src/main/java/one/util/streamex/TailConcatSpliterator.java
+++ b/src/main/java/one/util/streamex/TailConcatSpliterator.java
@@ -52,7 +52,9 @@ import one.util.streamex.StreamExInternals.TailSpliterator;
             }
             left = null;
         }
-        return right.tryAdvance(action);
+        if(right != null)
+            right = TailSpliterator.tryAdvanceWithTail(right, action);
+        return right != null;
     }
 
     @Override
@@ -71,7 +73,8 @@ import one.util.streamex.StreamExInternals.TailSpliterator;
     public void forEachRemaining(Consumer<? super T> action) {
         if (left != null)
             left.forEachRemaining(action);
-        right.forEachRemaining(action);
+        if(right != null)
+            TailSpliterator.forEachWithTail(right, action);
     }
 
     @Override
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 4859516..2ac73d5 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -33,6 +33,7 @@ import java.util.Random;
 import java.util.Map.Entry;
 import java.util.SortedMap;
 import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.function.Function;
@@ -271,6 +272,10 @@ public class EntryStreamTest {
         assertEquals(EntryStream.of(createMap()).toList(), EntryStream.empty().append("a", 1, "bb", 22, "ccc", 33)
                 .toList());
         checkAsString("bb->22;a->1;ccc->33", EntryStream.of("bb", 22).append("a", 1, "ccc", 33));
+        
+        EntryStream<String, Integer> stream = EntryStream.of("a", 1, "b", 2);
+        assertSame(stream, stream.append(Collections.emptyMap()));
+        assertNotSame(stream, stream.append(new ConcurrentHashMap<>()));
     }
 
     @Test
@@ -279,6 +284,10 @@ public class EntryStreamTest {
             5).filterKeys(k -> k.length() > 1).values().toList());
         checkAsString("a->1;ccc->33;bb->22", EntryStream.of("bb", 22).prepend("a", 1, "ccc", 33));
         checkAsString("a->1;ccc->33;dddd->40;bb->22", EntryStream.of("bb", 22).prepend("a", 1, "ccc", 33, "dddd", 40));
+
+        EntryStream<String, Integer> stream = EntryStream.of("a", 1, "b", 2);
+        assertSame(stream, stream.prepend(Collections.emptyMap()));
+        assertNotSame(stream, stream.prepend(new ConcurrentHashMap<>()));
     }
 
     @Test
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index cb65ea7..56a6e70 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -46,6 +46,7 @@ import java.util.Spliterator;
 import java.util.TreeSet;
 import java.util.Vector;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -406,8 +407,9 @@ public class StreamExTest {
         StreamEx<Integer> s = StreamEx.of(1, 2, 3);
         assertSame(s, s.append());
         assertSame(s, s.append(Collections.emptyList()));
-        assertSame(s, s.prepend());
-        assertSame(s, s.prepend(Collections.emptyList()));
+        assertSame(s, s.append(new ArrayList<>()));
+        assertSame(s, s.append(Stream.empty()));
+        assertNotSame(s, s.append(new ConcurrentLinkedQueue<>()));
     }
 
     @Test
@@ -424,6 +426,23 @@ public class StreamExTest {
         }
         assertArrayEquals(new Object[] { 1, 2, 3, 1, 1 }, StreamEx.constant(1, Long.MAX_VALUE - 1).prepend(1, 2, 3)
                 .limit(5).toArray());
+        
+        assertEquals(asList(4,3,2,1), StreamEx.of(1).prepend(2).prepend(StreamEx.of(3).prepend(4)).toList());
+
+        StreamEx<Integer> s = StreamEx.of(1, 2, 3);
+        assertSame(s, s.prepend());
+        assertSame(s, s.prepend(Collections.emptyList()));
+        assertSame(s, s.prepend(new ArrayList<>()));
+        assertSame(s, s.prepend(Stream.empty()));
+        assertNotSame(s, s.prepend(new ConcurrentLinkedQueue<>()));
+    }
+    
+    @Test
+    public void testPrependTSO() {
+        List<Integer> expected = IntStreamEx.rangeClosed(19999, 0, -1).boxed().toList();
+        assertEquals(expected, IntStreamEx.range(20000).mapToObj(StreamEx::of).reduce(StreamEx::prepend).get().toList());
+        assertEquals(expected, IntStreamEx.range(20000).parallel().mapToObj(StreamEx::of).reduce(StreamEx::prepend)
+                .get().toList());
     }
 
     @Test
