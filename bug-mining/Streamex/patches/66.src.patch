diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 9a83694..b7ba9d9 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -1365,4 +1365,27 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
     public static <T> EntryStream<T, T> ofPairs(T[] array) {
         return ofPairs(Arrays.asList(array));
     }
+    
+    static <T> Stream<Entry<Integer, T>> flatTraverse(Stream<Entry<Integer, T>> src, BiFunction<Integer, T, Stream<T>> streamProvider) {
+        return src.flatMap(entry -> {
+            Integer depth = entry.getKey();
+            Stream<T> result = streamProvider.apply(depth, entry.getValue());
+            return result == null ? Stream.of(entry) : Stream.concat(Stream.of(entry),
+                flatTraverse(result.map(t -> new ObjIntBox<>(t, depth + 1)), streamProvider));
+        });
+    }
+
+    public static <T> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, Stream<T>> mapper) {
+        Stream<T> rootStream = mapper.apply(0, root);
+        Stream<Entry<Integer, T>> base = Stream.of(new ObjIntBox<>(root, 0));
+        return rootStream == null ? of(base) : of(flatTraverse(rootStream.map(t -> new ObjIntBox<>(t, 1)), mapper))
+                .prepend(base);
+    }
+    
+    @SuppressWarnings("unchecked")
+    public static <T, TT extends T> EntryStream<Integer, T> ofTree(T root, Class<TT> collectionClass,
+            BiFunction<Integer, TT, Stream<T>> mapper) {
+        return ofTree(root, (d, t) -> collectionClass.isInstance(t) ? mapper.apply(d, (TT) t) : null);
+    }
+
 }
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 8bbfb91..431c00c 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -500,4 +500,16 @@ public class EntryStreamTest {
         assertEquals("1=a,1=b,2=c", s.get().distinctValues().join("=").joining(","));
         assertEquals("1=a,1=b,2=c", s.get().parallel().distinctValues().join("=").joining(","));
     }
+    
+    @Test
+    public void testOfTree() {
+        List<Object> input = Arrays.asList(
+            "aa",
+            null,
+            Arrays.asList(Arrays.asList("bbbb", "cc", null, Arrays.asList()), "ddd", Arrays.asList("e"),
+                Arrays.asList("fff")), "ggg");
+        EntryStream<Integer, Object> ofTree = EntryStream.ofTree(input, List.class, (depth, l) -> l.stream());
+        assertEquals("{1=[aa, ggg], 2=[ddd], 3=[bbbb, cc, e, fff]}",
+            ofTree.selectValues(String.class).grouping(TreeMap::new).toString());
+    }
 }
