diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 884e34e..05e93ce 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -109,7 +109,10 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     final <R> Stream<R> delegate(Spliterator<R> spliterator) {
-        return StreamSupport.stream(spliterator, stream.isParallel()).onClose(stream::close);
+        Stream<R> result = StreamSupport.stream(spliterator, stream.isParallel());
+        if(mayHaveCloseAction(stream))
+            result = result.onClose(stream::close);
+        return result;
     }
 
     final S callWhile(Predicate<? super T> predicate, int methodId) {
diff --git a/src/main/java/one/util/streamex/HeadTailSpliterator.java b/src/main/java/one/util/streamex/HeadTailSpliterator.java
index 6412255..a099258 100644
--- a/src/main/java/one/util/streamex/HeadTailSpliterator.java
+++ b/src/main/java/one/util/streamex/HeadTailSpliterator.java
@@ -29,10 +29,11 @@ import static one.util.streamex.StreamExInternals.*;
  * @author Tagir Valeev
  */
 /*package*/ final class HeadTailSpliterator<T, U> extends AbstractSpliterator<U> implements TailCallSpliterator<U> {
-    private final Spliterator<T> source;
-    private final BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
+    private Spliterator<T> source;
+    private BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
     private Spliterator<U> target;
-    private BaseStream<?, ?> stream;
+    private boolean finished;
+    BaseStream<?, ?> owner;
     
     HeadTailSpliterator(Spliterator<T> source, BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper) {
         super(Long.MAX_VALUE, ORDERED);
@@ -45,7 +46,7 @@ import static one.util.streamex.StreamExInternals.*;
         if(!init())
             return false;
         target = traverseTail(target);
-        return target.tryAdvance(action);
+        return finishUnless(target.tryAdvance(action));
     }
 
     @Override
@@ -54,34 +55,44 @@ import static one.util.streamex.StreamExInternals.*;
             Spliterator<U> t = target;
             while(t instanceof TailCallSpliterator) {
                 t = traverseTail(t);
-                if(!t.tryAdvance(action))
+                if(!finishUnless(t.tryAdvance(action)))
                     return;
             }
             t.forEachRemaining(action);
-            target = t;
+            finishUnless(false);
         }
     }
 
+    private boolean finishUnless(boolean cont) {
+        if(cont)
+            return true;
+        target = null;
+        source = null;
+        mapper = null;
+        finished = true;
+        return false;
+    }
+
     private boolean init() {
+        if(finished)
+            return false;
         if(target == null) {
             Box<T> first = new Box<>(null);
-            if(!source.tryAdvance(x -> first.a = x)) {
+            if(!finishUnless(source.tryAdvance(x -> first.a = x))) {
                 return false;
             }
             Stream<U> stream = mapper.apply(first.a, StreamEx.of(traverseTail(source)));
-            this.stream = stream;
+            if(owner != null && mayHaveCloseAction(stream))
+                owner.onClose(stream::close);
             target = stream == null ? Spliterators.emptySpliterator() : stream.spliterator();
         }
         return true;
     }
     
-    void close() {
-        if(stream != null)
-            stream.close();
-    }
-
     @Override
     public long estimateSize() {
+        if(finished)
+            return 0;
         if(target == null) {
             long size = source.estimateSize();
             return size == Long.MAX_VALUE || size <= 0 ? size : size - 1;
@@ -93,6 +104,8 @@ import static one.util.streamex.StreamExInternals.*;
     public Spliterator<U> tail() {
         if(!init())
             return Spliterators.emptySpliterator();
-        return target;
+        Spliterator<U> t = target;
+        finishUnless(false);
+        return t;
     }
 }
diff --git a/src/main/java/one/util/streamex/PairSpliterator.java b/src/main/java/one/util/streamex/PairSpliterator.java
index 9d4c514..2d013b8 100644
--- a/src/main/java/one/util/streamex/PairSpliterator.java
+++ b/src/main/java/one/util/streamex/PairSpliterator.java
@@ -132,10 +132,14 @@ import static one.util.streamex.StreamExInternals.*;
         }
     }
     
-    @SuppressWarnings("unchecked")
     @Override
     public Spliterator<R> tail() {
-        return mode == MODE_MAP_FIRST && right == EMPTY && left == null ? (Spliterator<R>)source : this;
+        if (mode != MODE_MAP_FIRST || right != EMPTY || left != null)
+            return this;
+        @SuppressWarnings("unchecked")
+        Spliterator<R> s = (Spliterator<R>)source;
+        source = null;
+        return s;
     }
 
     @Override
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index c621f89..55e69c3 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -80,7 +80,7 @@ import static one.util.streamex.StreamExInternals.*;
 public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     
     private static class PrependSpliterator<T> implements TailCallSpliterator<T> {
-        private final Spliterator<T> source;
+        private Spliterator<T> source;
         private T[] prepended;
         private int position;
         private int characteristics;
@@ -140,7 +140,11 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
 
         @Override
         public Spliterator<T> tail() {
-            return prepended == null ? source : this;
+            if(prepended != null)
+                return this;
+            Spliterator<T> s = source;
+            source = null;
+            return s;
         }
     }
     
@@ -1486,7 +1490,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper) {
         HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(stream.spliterator(), mapper);
-        return strategy().newStreamEx(delegate(spliterator).onClose(spliterator::close));
+        Stream<R> delegate = delegate(spliterator);
+        spliterator.owner = delegate;
+        return strategy().newStreamEx(delegate);
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index 6ade2ae..fc644f1 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -19,15 +19,21 @@ import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.invoke.MethodType;
+import java.lang.reflect.Field;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.MathContext;
 import java.nio.ByteOrder;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.AbstractCollection;
 import java.util.AbstractMap;
 import java.util.AbstractSet;
+import java.util.ArrayDeque;
 import java.util.Arrays;
 import java.util.BitSet;
+import java.util.Deque;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Map;
@@ -50,6 +56,7 @@ import java.util.function.ObjIntConsumer;
 import java.util.function.ObjLongConsumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
+import java.util.stream.BaseStream;
 import java.util.stream.Collector;
 import java.util.stream.Collector.Characteristics;
 import java.util.stream.DoubleStream;
@@ -76,6 +83,38 @@ import java.util.stream.Stream;
     static final int IDX_DOUBLE_STREAM = 3;
     static final int IDX_TAKE_WHILE = 0;
     static final int IDX_DROP_WHILE = 1;
+    
+    static final Field SOURCE_SPLITERATOR;
+    static final Field SOURCE_STAGE;
+    static final Field SOURCE_CLOSE_ACTION;
+    static final Field SPLITERATOR_ITERATOR;
+
+    static {
+        Deque<Field> fields = new ArrayDeque<>();
+        /*
+         * Fields accessed via reflection are used only for reading and only to
+         * make some performance optimizations decisions. They must be never
+         * written and absence of these fields should not break anything.
+         */
+        try {
+            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {
+                Class<?> abstractPipelineClass = Class.forName("java.util.stream.AbstractPipeline");
+                fields.add(abstractPipelineClass.getDeclaredField("sourceSpliterator"));
+                fields.add(abstractPipelineClass.getDeclaredField("sourceStage"));
+                fields.add(abstractPipelineClass.getDeclaredField("sourceCloseAction"));
+                fields.add(Class.forName("java.util.Spliterators$IteratorSpliterator").getDeclaredField("it"));
+                for(Field f : fields)
+                    f.setAccessible(true);
+                return null;
+            });
+        } catch (PrivilegedActionException e) {
+            fields.clear();
+        }
+        SOURCE_SPLITERATOR = fields.poll();
+        SOURCE_STAGE = fields.poll();
+        SOURCE_CLOSE_ACTION = fields.poll();
+        SPLITERATOR_ITERATOR = fields.poll();
+    }
 
     static MethodHandle[][] initJdk9Methods() {
         Lookup lookup = MethodHandles.publicLookup();
@@ -971,4 +1010,20 @@ import java.util.stream.Stream;
     static <T> T none() {
         return (T) NONE;
     }
+
+    static boolean mayHaveCloseAction(BaseStream<?, ?> s) {
+        if (s == null)
+            return false;
+        if (SOURCE_STAGE == null || SOURCE_CLOSE_ACTION == null)
+            return true;
+        if (s instanceof AbstractStreamEx)
+            s = ((AbstractStreamEx<?, ?>) s).stream;
+        try {
+            if (SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(s)) == null)
+                return false;
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            // ignore
+        }
+        return true;
+    }
 }
diff --git a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
index fe3e463..b13172c 100644
--- a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
+++ b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
@@ -1,9 +1,5 @@
 package one.util.streamex;
 
-import java.lang.reflect.Field;
-import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.util.Iterator;
 import java.util.PrimitiveIterator;
 import java.util.Spliterator;
@@ -14,29 +10,13 @@ import java.util.function.LongConsumer;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import static one.util.streamex.StreamExInternals.*;
+
 /* package */abstract class UnknownSizeSpliterator<T, S extends UnknownSizeSpliterator<? extends T, S, I>, I extends Iterator<? extends T>>
         implements Spliterator<T> {
     static final int BATCH_UNIT = 1 << 10; // batch array size increment
     static final int MAX_BATCH = 1 << 25; // max batch array size;
 
-    private static Field SOURCE_SPLITERATOR;
-    private static Field SPLITERATOR_ITERATOR;
-
-    static {
-        try {
-            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {
-                SOURCE_SPLITERATOR = Class.forName("java.util.stream.AbstractPipeline").getDeclaredField(
-                    "sourceSpliterator");
-                SOURCE_SPLITERATOR.setAccessible(true);
-                SPLITERATOR_ITERATOR = Class.forName("java.util.Spliterators$IteratorSpliterator").getDeclaredField(
-                    "it");
-                SPLITERATOR_ITERATOR.setAccessible(true);
-                return null;
-            });
-        } catch (PrivilegedActionException e) {
-        }
-    }
-
     /**
      * Optimize the stream created on IteratorSpliterator replacing it with
      * UnknownSizeSpliterator.
