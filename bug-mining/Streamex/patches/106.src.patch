diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 05e93ce..6b08407 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -109,10 +109,7 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     final <R> Stream<R> delegate(Spliterator<R> spliterator) {
-        Stream<R> result = StreamSupport.stream(spliterator, stream.isParallel());
-        if(mayHaveCloseAction(stream))
-            result = result.onClose(stream::close);
-        return result;
+        return delegateClose(StreamSupport.stream(spliterator, stream.isParallel()), stream);
     }
 
     final S callWhile(Predicate<? super T> predicate, int methodId) {
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index f957d98..84b883e 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -117,7 +117,7 @@ public class DoubleStreamEx implements DoubleStream {
 
     final DoubleStreamEx delegate(Spliterator.OfDouble spliterator) {
         return strategy().newDoubleStreamEx(
-            StreamSupport.doubleStream(spliterator, stream.isParallel()).onClose(stream::close));
+            delegateClose(StreamSupport.doubleStream(spliterator, stream.isParallel()), stream));
     }
 
     final DoubleStreamEx callWhile(DoublePredicate predicate, int methodId) {
diff --git a/src/main/java/one/util/streamex/HeadTailSpliterator.java b/src/main/java/one/util/streamex/HeadTailSpliterator.java
index 4268ed3..34c807d 100644
--- a/src/main/java/one/util/streamex/HeadTailSpliterator.java
+++ b/src/main/java/one/util/streamex/HeadTailSpliterator.java
@@ -24,6 +24,7 @@ import java.util.function.Supplier;
 import java.util.stream.BaseStream;
 import java.util.stream.Stream;
 
+import one.util.streamex.StreamExInternals.TailCallSpliterator;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -45,45 +46,40 @@ import static one.util.streamex.StreamExInternals.*;
         this.emptyMapper = emptyMapper;
     }
     
-    private static <T> Spliterator<T> traverseTail(Spliterator<T> spltr) {
-        Spliterator<T> current = spltr;
-        while (current instanceof TailCallSpliterator) {
-            Spliterator<T> next = ((TailCallSpliterator<T>) current).tail();
-            if (next == current)
-                break;
-            current = next;
-        }
-        return current;
-    }
-
     @Override
     public boolean tryAdvance(Consumer<? super U> action) {
         if(!init())
             return false;
-        target = traverseTail(target);
-        return finishUnless(target.tryAdvance(action));
+        target = TailCallSpliterator.tryAdvanceWithTail(target, action);
+        if(target == null) {
+            finished = true;
+            return false;
+        }
+        return true;
     }
 
     @Override
-    public void forEachRemaining(Consumer<? super U> action) {
-        if(init()) {
-            Spliterator<U> t = target;
-            while(t instanceof TailCallSpliterator) {
-                t = traverseTail(t);
-                if(!finishUnless(t.tryAdvance(action)))
-                    return;
-            }
-            t.forEachRemaining(action);
-            finishUnless(false);
-        }
+    public Spliterator<U> tryAdvanceOrTail(Consumer<? super U> action) {
+        if(!init())
+            return null;
+        Spliterator<U> tail = target;
+        target = null;
+        finished = true;
+        return tail;
     }
 
-    private boolean finishUnless(boolean cont) {
-        if(cont)
-            return true;
+    @Override
+    public void forEachRemaining(Consumer<? super U> action) {
+        if(!init())
+            return;
+        TailCallSpliterator.forEachWithTail(target, action);
         target = null;
         finished = true;
-        return false;
+    }
+
+    @Override
+    public Spliterator<U> forEachOrTail(Consumer<? super U> action) {
+        return tryAdvanceOrTail(action);
     }
 
     private boolean init() {
@@ -91,13 +87,12 @@ import static one.util.streamex.StreamExInternals.*;
             return false;
         if(target == null) {
             Box<T> first = new Box<>(null);
-            Stream<U> stream = source.tryAdvance(x -> first.a = x) ? mapper.apply(first.a, StreamEx
-                    .of(traverseTail(source))) : emptyMapper.get();
+            source = TailCallSpliterator.tryAdvanceWithTail(source, x -> first.a = x);
+            Stream<U> stream = source == null ? emptyMapper.get() : mapper.apply(first.a, StreamEx.of(source));
             source = null;
             mapper = null;
             emptyMapper = null;
-            if(owner != null && mayHaveCloseAction(stream))
-                owner.onClose(stream::close);
+            delegateClose(owner, stream);
             target = stream == null ? Spliterators.emptySpliterator() : stream.spliterator();
         }
         return true;
@@ -109,13 +104,4 @@ import static one.util.streamex.StreamExInternals.*;
             return 0;
         return (target == null ? source : target).estimateSize();
     }
-
-    @Override
-    public Spliterator<U> tail() {
-        if(!init())
-            return Spliterators.emptySpliterator();
-        Spliterator<U> t = target;
-        finishUnless(false);
-        return t;
-    }
 }
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index b929e9f..148b4b4 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -123,7 +123,7 @@ public class IntStreamEx implements IntStream {
 
     final IntStreamEx delegate(Spliterator.OfInt spliterator) {
         return strategy().newIntStreamEx(
-            StreamSupport.intStream(spliterator, stream.isParallel()).onClose(stream::close));
+            delegateClose(StreamSupport.intStream(spliterator, stream.isParallel()), stream));
     }
 
     final IntStreamEx callWhile(IntPredicate predicate, int methodId) {
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 847e5f7..59662c7 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -117,7 +117,7 @@ public class LongStreamEx implements LongStream {
 
     final LongStreamEx delegate(Spliterator.OfLong spliterator) {
         return strategy().newLongStreamEx(
-            StreamSupport.longStream(spliterator, stream.isParallel()).onClose(stream::close));
+            delegateClose(StreamSupport.longStream(spliterator, stream.isParallel()), stream));
     }
 
     final LongStreamEx callWhile(LongPredicate predicate, int methodId) {
diff --git a/src/main/java/one/util/streamex/PairSpliterator.java b/src/main/java/one/util/streamex/PairSpliterator.java
index 9dbe7a8..3f33710 100644
--- a/src/main/java/one/util/streamex/PairSpliterator.java
+++ b/src/main/java/one/util/streamex/PairSpliterator.java
@@ -30,13 +30,14 @@ import java.util.function.LongBinaryOperator;
 import java.util.function.LongConsumer;
 import java.util.function.LongUnaryOperator;
 
+import one.util.streamex.StreamExInternals.TailCallSpliterator;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
  * @author Tagir Valeev
  */
 /* package */abstract class PairSpliterator<T, S extends Spliterator<T>, R, SS extends PairSpliterator<T, S, R, SS>>
-        extends CloneableSpliterator<R, SS> implements TailCallSpliterator<R> {
+        extends CloneableSpliterator<R, SS> {
     static final int MODE_PAIRS = 0;
     static final int MODE_MAP_FIRST = 1;
     static final int MODE_MAP_LAST = 2;
@@ -132,16 +133,6 @@ import static one.util.streamex.StreamExInternals.*;
         }
     }
     
-    @Override
-    public Spliterator<R> tail() {
-        if (mode != MODE_MAP_FIRST || right != EMPTY || left != null)
-            return this;
-        @SuppressWarnings("unchecked")
-        Spliterator<R> s = (Spliterator<R>)source;
-        source = null;
-        return s;
-    }
-
     @Override
     public long estimateSize() {
         long size = source.estimateSize();
@@ -182,7 +173,7 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     static class PSOfRef<T, R> extends PairSpliterator<T, Spliterator<T>, R, PSOfRef<T, R>> implements
-            Consumer<T> {
+            Consumer<T>, TailCallSpliterator<R> {
         private static final Object HEAD_TAIL = new Object();
 
         private final BiFunction<? super T, ? super T, ? extends R> mapper;
@@ -246,6 +237,41 @@ import static one.util.streamex.StreamExInternals.*;
             });
             finish(fn, cur);
         }
+
+        @Override
+        public Spliterator<R> tryAdvanceOrTail(Consumer<? super R> action) {
+            if (mode != MODE_MAP_FIRST || right != EMPTY) {
+                return tryAdvance(action) ? this : null;
+            }
+            if (left != null) {
+                Sink<T> l = left;
+                left = null;
+                source = TailCallSpliterator.tryAdvanceWithTail(source, this);
+                if (source == null) {
+                    right = null;
+                    return null;
+                }
+                if (l.push(cur, fn(action), false))
+                    return this;
+            }
+            @SuppressWarnings("unchecked")
+            Spliterator<R> s = (Spliterator<R>)source;
+            source = null;
+            return s;
+        }
+        
+        @Override
+        public Spliterator<R> forEachOrTail(Consumer<? super R> action) {
+            if(mode != MODE_MAP_FIRST || right != EMPTY) {
+                forEachRemaining(action);
+                return null;
+            }
+            while (true) {
+                Spliterator<R> tail = tryAdvanceOrTail(action);
+                if (tail != this)
+                    return tail;
+            }
+        }
     }
 
     static final class PSOfInt extends PairSpliterator<Integer, Spliterator.OfInt, Integer, PSOfInt> implements
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 888393a..8ffd463 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -78,36 +78,49 @@ import static one.util.streamex.StreamExInternals.*;
  * @param <T> the type of the stream elements
  */
 public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
-    
+
     private static class PrependSpliterator<T> implements TailCallSpliterator<T> {
         private Spliterator<T> source;
         private T[] prepended;
         private int position;
         private int characteristics;
-        
+
         public PrependSpliterator(Spliterator<T> source, T[] prepended) {
             this.source = source;
             this.prepended = prepended;
-            this.characteristics = source.characteristics() & (ORDERED | SIZED| SUBSIZED);
-            if(((this.characteristics & SIZED) != 0) && prepended.length+source.estimateSize() < 0)
+            this.characteristics = source.characteristics() & (ORDERED | SIZED | SUBSIZED);
+            if (((this.characteristics & SIZED) != 0) && prepended.length + source.estimateSize() < 0)
                 this.characteristics &= (~SIZED) & (~SUBSIZED);
         }
 
         @Override
         public boolean tryAdvance(Consumer<? super T> action) {
-            if(prepended != null) {
+            if (prepended != null) {
                 action.accept(prepended[position++]);
-                if(position == prepended.length)
+                if (position == prepended.length)
                     prepended = null;
                 return true;
             }
             return source.tryAdvance(action);
         }
 
+        @Override
+        public Spliterator<T> tryAdvanceOrTail(Consumer<? super T> action) {
+            if (prepended == null) {
+                Spliterator<T> s = source;
+                source = null;
+                return s;
+            }
+            action.accept(prepended[position++]);
+            if (position == prepended.length)
+                prepended = null;
+            return this;
+        }
+
         @Override
         public void forEachRemaining(Consumer<? super T> action) {
-            if(prepended != null) {
-                while(position < prepended.length) {
+            if (prepended != null) {
+                while (position < prepended.length) {
                     action.accept(prepended[position++]);
                 }
                 prepended = null;
@@ -115,9 +128,22 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             source.forEachRemaining(action);
         }
 
+        @Override
+        public Spliterator<T> forEachOrTail(Consumer<? super T> action) {
+            if (prepended != null) {
+                while (position < prepended.length) {
+                    action.accept(prepended[position++]);
+                }
+                prepended = null;
+            }
+            Spliterator<T> s = source;
+            source = null;
+            return s;
+        }
+
         @Override
         public Spliterator<T> trySplit() {
-            if(prepended == null)
+            if (prepended == null)
                 return source.trySplit();
             Spliterator<T> prefix = Spliterators.spliterator(prepended, position, prepended.length, characteristics);
             prepended = null;
@@ -127,9 +153,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         @Override
         public long estimateSize() {
             long size = source.estimateSize();
-            if(prepended == null)
+            if (prepended == null)
                 return size;
-            size = size+prepended.length-position;
+            size = size + prepended.length - position;
             return size < 0 ? Long.MAX_VALUE : size;
         }
 
@@ -137,17 +163,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         public int characteristics() {
             return characteristics;
         }
-
-        @Override
-        public Spliterator<T> tail() {
-            if(prepended != null)
-                return this;
-            Spliterator<T> s = source;
-            source = null;
-            return s;
-        }
     }
-    
+
     StreamEx(Stream<T> stream) {
         super(stream);
     }
@@ -268,7 +285,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call optimization</a>.
+     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * optimization</a>.
      *
      * @param mapper a <a
      *        href="package-summary.html#NonInterference">non-interfering </a>,
@@ -1013,7 +1031,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
-
+     * 
      * @param collection the collection to append to the stream
      * @return the new stream
      * @since 0.2.1
@@ -1030,8 +1048,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call optimization</a>.
-
+     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * optimization</a>.
+     * 
      * @param values the values to prepend to the stream
      * @return the new stream
      */
@@ -1049,7 +1068,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
      * operation</a>.
-
+     * 
      * @param collection the collection to prepend to the stream
      * @return the new stream
      * @since 0.2.1
@@ -1462,10 +1481,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     }
 
     /**
-     * Creates a new Stream which is the result of applying of the supplied
-     * mapper {@code BiFunction} to the first element of the current stream
-     * (head) and the stream containing the rest elements (tail). If a mapped
-     * stream is {@code null} an empty stream is used, instead.
+     * Creates a new Stream which is the result of applying of the mapper
+     * {@code BiFunction} to the first element of the current stream (head) and
+     * the stream containing the rest elements (tail). The mapper may return
+     * {@code null} instead of empty stream.
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
@@ -1473,7 +1492,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * optimization</a>.
      * 
      * <p>
-     * The mapper function is not applied when the input stream is empty.
+     * The mapper function is not applied when the input stream is empty. This
+     * operation is equivalent to {@code headTail(mapper, () -> null)}.
      * Otherwise it's applied at most once during the stream terminal operation
      * execution. Sometimes it's useful to generate stream recursively like
      * this:
@@ -1496,8 +1516,9 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * <p>
      * This operation might perform badly with parallel streams. Sometimes the
      * same semantics could be expressed using other operations like
-     * {@link #withFirst(BiFunction)} which parallelizes better. Consider using
-     * {@code withFirst()} if its possible in your case.
+     * {@link #withFirst(BiFunction)} or {@link #mapFirst(Function)} which
+     * parallelize better. Consider using these methods if its possible in your
+     * case.
      *
      * @param <R> The element type of the new stream
      * @param mapper a <a
@@ -1513,9 +1534,68 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return headTail(mapper, () -> null);
     }
 
+    /**
+     * Creates a new Stream which is the result of applying of the mapper
+     * {@code BiFunction} to the first element of the current stream (head) and
+     * the stream containing the rest elements (tail) or supplier if the current
+     * stream is empty. The mapper or supplier may return {@code null} instead
+     * of empty stream.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * optimization</a>.
+     * 
+     * <p>
+     * Either mapper function or supplier (but not both) is applied at most once
+     * during the stream terminal operation execution. Sometimes it's useful to
+     * generate stream recursively like this:
+     * 
+     * <pre>{@code
+     * // Stream of fixed size batches
+     * static <T> StreamEx<List<T>> batches(StreamEx<T> input, int size) {
+     *     return batches(input, size, Collections.emptyList());
+     * }
+     *
+     * private static <T> StreamEx<List<T>> batches(StreamEx<T> input, int size, List<T> cur) {
+     *     return input.headTail((head, tail) -> cur.size() >= size 
+     *             ? batches(tail, size, Arrays.asList(head)).prepend(cur)
+     *             : batches(tail, size, StreamEx.of(cur).append(head).toList()), 
+     *             () -> Stream.of(cur));
+     * }}</pre>
+     * 
+     * <p>
+     * When possible, use tail-call optimized operations to reduce the call
+     * stack depth. In particular, the example shown above uses only
+     * {@code headTail()}, and {@link #prepend(Object...)} operations, both of
+     * them are tail-call optimized, so it will not fail with
+     * {@code StackOverflowError} on long input stream.
+     * 
+     * <p>
+     * This operation might perform badly with parallel streams. Sometimes the
+     * same semantics could be expressed using other operations like
+     * {@link #withFirst(BiFunction)} or {@link #mapFirst(Function)} which
+     * parallelize better. Consider using these methods if its possible in your
+     * case.
+     *
+     * @param <R> The element type of the new stream
+     * @param mapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering</a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the first stream element and the stream of
+     *        the rest elements which creates a new stream.
+     * @param supplier a <a
+     *        href="package-summary.html#NonInterference">non-interfering</a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        supplier which creates a resulting stream when this stream is
+     *        empty.
+     * @return the new stream
+     * @see #headTail(BiFunction)
+     * @since 0.5.3
+     */
     public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper,
-            Supplier<? extends Stream<R>> emptyMapper) {
-        HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(stream.spliterator(), mapper, emptyMapper);
+            Supplier<? extends Stream<R>> supplier) {
+        HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(stream.spliterator(), mapper, supplier);
         Stream<R> delegate = delegate(spliterator);
         spliterator.owner = delegate;
         return strategy().newStreamEx(delegate);
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index 7044182..02b3349 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -47,6 +47,7 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.function.BiConsumer;
 import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
 import java.util.function.DoublePredicate;
 import java.util.function.Function;
 import java.util.function.IntPredicate;
@@ -941,14 +942,50 @@ import java.util.stream.Stream;
      */
     static interface TailCallSpliterator<T> extends Spliterator<T> {
         /**
-         * Returns either this spliterator or another one. If another one
-         * spliterator is returned, then this spliterator becomes invalid and
-         * another one must be used as a replacement to continue the operation.
-         * Never returns null.
+         * Either advances by one element feeding it to consumer and returns
+         * this or returns tail spliterator (this spliterator becomes invalid
+         * and tail must be used instead) or returns null if traversal finished.
          * 
-         * @return tail spliterator
+         * @param action to feed the next element into
+         * @return tail spliterator, this or null
          */
-        Spliterator<T> tail();
+        Spliterator<T> tryAdvanceOrTail(Consumer<? super T> action);
+
+        /**
+         * Traverses this spliterator and returns null if traversal is completed
+         * or tail spliterator if it must be used for further traversal.
+         * 
+         * @param action to feed the elements into
+         * @return tail spliterator or null (never returns this)
+         */
+        Spliterator<T> forEachOrTail(Consumer<? super T> action);
+
+        static <T> Spliterator<T> tryAdvanceWithTail(Spliterator<T> target, Consumer<? super T> action) {
+            while (true) {
+                if (target instanceof TailCallSpliterator) {
+                    Spliterator<T> spltr = ((TailCallSpliterator<T>) target).tryAdvanceOrTail(action);
+                    if (spltr == null || spltr == target)
+                        return spltr;
+                    target = spltr;
+                } else {
+                    return target.tryAdvance(action) ? target : null;
+                }
+            }
+        }
+
+        static <T> void forEachWithTail(Spliterator<T> target, Consumer<? super T> action) {
+            while (true) {
+                if (target instanceof TailCallSpliterator) {
+                    Spliterator<T> spltr = ((TailCallSpliterator<T>) target).forEachOrTail(action);
+                    if (spltr == null)
+                        break;
+                    target = spltr;
+                } else {
+                    target.forEachRemaining(action);
+                    break;
+                }
+            }
+        }
     }
 
     static abstract class CloneableSpliterator<T, S extends CloneableSpliterator<T, ?>> implements Spliterator<T>,
@@ -1027,25 +1064,28 @@ import java.util.stream.Stream;
     }
 
     /**
-     * Checks whether given BaseStream has any close action registered.
+     * Close target when proxy is closed. May omit close handler registration if
+     * target has no close handlers registered.
      * 
-     * @param s BaseStream to check
-     * @return false if supplied BaseStream is known to have no close action
-     *         registered, true otherwise.
+     * @param proxy stream where close handler should be registered
+     * @param target target stream which must be closed
+     * @return proxy (to chain calls)
      */
-    static boolean mayHaveCloseAction(BaseStream<?, ?> s) {
-        if (s == null)
-            return false;
-        if (SOURCE_STAGE == null || SOURCE_CLOSE_ACTION == null)
-            return true;
-        if (s instanceof AbstractStreamEx)
-            s = ((AbstractStreamEx<?, ?>) s).stream;
+    static <T extends BaseStream<?, ?>> T delegateClose(T proxy, BaseStream<?, ?> target) {
+        if (target == null) {
+            return proxy;
+        }
+        if (target instanceof AbstractStreamEx) {
+            target = ((AbstractStreamEx<?, ?>) target).stream;
+        }
         try {
-            if (SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(s)) == null)
-                return false;
+            if (SOURCE_STAGE != null && SOURCE_CLOSE_ACTION != null
+                && SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(target)) == null)
+                return proxy;
         } catch (IllegalArgumentException | IllegalAccessException e) {
             // ignore
         }
-        return true;
+        proxy.onClose(target::close);
+        return proxy;
     }
 }
diff --git a/src/test/java/one/util/streamex/StreamExHeadTailTest.java b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
index 83ff21e..dca5f34 100644
--- a/src/test/java/one/util/streamex/StreamExHeadTailTest.java
+++ b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
@@ -62,7 +62,7 @@ public class StreamExHeadTailTest {
 
     // Stream.limit (TCO)
     static <T> StreamEx<T> limit(StreamEx<T> input, int n) {
-        return input.headTail((head, tail) -> n > 0 ? limit(tail, n - 1).prepend(head) : null);
+        return input.headTail((head, tail) -> n > 1 ? limit(tail, n - 1).prepend(head) : Stream.of(head));
     }
 
     // Stream.filter (TCO)
@@ -160,7 +160,7 @@ public class StreamExHeadTailTest {
 
     // Creates lazy scanLeft stream (TCO)
     static <T> StreamEx<T> scanLeft(StreamEx<T> input, BinaryOperator<T> operator) {
-        return input.headTail((head, tail) -> scanLeft(mapFirst(tail, cur -> operator.apply(head, cur)), operator)
+        return input.headTail((head, tail) -> scanLeft(tail.mapFirst(cur -> operator.apply(head, cur)), operator)
                 .prepend(head));
     }
 
@@ -193,8 +193,10 @@ public class StreamExHeadTailTest {
     }
 
     private static <T> StreamEx<List<T>> batches(StreamEx<T> input, int size, List<T> cur) {
-        return input.headTail((head, tail) -> cur.size() >= size ? batches(tail, size, asList(head)).prepend(cur)
-                : batches(tail, size, StreamEx.of(cur).append(head).toList()), () -> Stream.of(cur));
+        return input.headTail((head, tail) -> cur.size() >= size 
+                ? batches(tail, size, asList(head)).prepend(cur)
+                : batches(tail, size, StreamEx.of(cur).append(head).toList()), 
+                () -> Stream.of(cur));
     }
 
     // Stream of single element lists -> stream of sliding windows (TCO)
@@ -220,6 +222,15 @@ public class StreamExHeadTailTest {
         return input.headTail((head, tail) -> withIndices(tail, idx + 1, mapper).prepend(mapper.apply(idx, head)));
     }
 
+    // Appends the stream of Integer with their sum
+    static StreamEx<Integer> appendSum(StreamEx<Integer> input) {
+        return reduceLast(input.append(0), Integer::sum);
+    }
+
+    static <T> StreamEx<T> reduceLast(StreamEx<T> input, BinaryOperator<T> op) {
+        return input.headTail((head, tail) -> reduceLast(tail, op).prepend(head).mapLast(last -> op.apply(head, last)));
+    }
+
     // ///////////////////////
     // Terminal ops
 
@@ -307,6 +318,9 @@ public class StreamExHeadTailTest {
 
         assertEquals(asList("1. Foo", "2. Bar", "3. Baz"), withIndices(StreamEx.of("Foo", "Bar", "Baz"),
             (idx, e) -> (idx + 1) + ". " + e).toList());
+        
+        assertEquals(asList(1,2,3,4,10), appendSum(StreamEx.of(1,2,3,4)).toList());
+        assertFalse(appendSum(StreamEx.of(1,2,3,4)).has(11));
     }
 
     @Test
@@ -350,6 +364,8 @@ public class StreamExHeadTailTest {
                 .count());
 
         assertEquals(20000, limit(distinctTCO(IntStreamEx.of(new Random(1)).boxed()), 20000).toSet().size());
+        assertEquals(IntStreamEx.range(20000).boxed().toList(), sorted(limit(
+            distinctTCO(IntStreamEx.of(new Random(1), 0, 20000).boxed()), 20000)).toList());
     }
 
     @Test
