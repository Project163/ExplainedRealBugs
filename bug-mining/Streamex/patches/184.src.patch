diff --git a/CHANGES.md b/CHANGES.md
index 7e05fe9..7521a3a 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -16,6 +16,7 @@ Warning: this release introduces some changes which may break backwards compatib
 * [#83] Changed: `StreamEx.of(Collection)`, `of(Iterator)`, etc. now use `? extends T` type instead of just `T`.
 * [#85] Added: `StreamEx.mapFirstOrElse()/mapLastOrElse()`.
 * [#86] Added: `peekFirst()`, `peekLast()` for all stream types.
+* [#89] Added: `produce()` method for all stream types.
 
 
 ### 0.5.5
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index cc500d6..9c163ff 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -45,6 +45,7 @@ Infinite Stream from `Supplier` | `any.generate()`
 Infinite Stream using iterative function | `any.iterate()`
 Convert three-argument for loop to Stream | `any.iterate()`
 Fixed length Stream of constant elements | `any.constant()`
+Stream from mutable object which is left in the known state after full Stream consumption | `any.produce()`
 Custom stream source which maintains mutable state | `Emitter/IntEmitter/LongEmitter/DoubleEmitter`
 Stream of array or `List` with indices | `EntryStream.of()`
 Stream of single value or empty if null supplied | `StreamEx.ofNullable()`
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index ec2252a..7727346 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -42,6 +42,7 @@ import java.util.function.DoubleToLongFunction;
 import java.util.function.DoubleUnaryOperator;
 import java.util.function.Function;
 import java.util.function.ObjDoubleConsumer;
+import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
 import java.util.stream.DoubleStream;
@@ -50,6 +51,7 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import one.util.streamex.StreamExInternals.Box;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -1926,6 +1928,33 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return seq(DoubleStream.generate(s));
     }
 
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. Note however that if a short-circuiting operation is used,
+     * then the final state of the mutable object cannot be guaranteed.
+     * 
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static DoubleStreamEx produce(Predicate<DoubleConsumer> producer) {
+        Box<DoubleEmitter> box = new Box<>(null);
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
     /**
      * Returns a sequential unordered {@code DoubleStreamEx} of given length
      * which elements are equal to supplied value.
@@ -1979,14 +2008,20 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
          * nothing more to emit.
          * 
          * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
          * It's allowed not to emit anything (don't call the consumer). However
          * if you do this and return new emitter which also does not emit
          * anything, you will end up in endless loop.
          * 
-         * @param cons consumer to be called to emit elements
+         * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        DoubleEmitter next(DoubleConsumer cons);
+        DoubleEmitter next(DoubleConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 34787dd..13552e8 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -56,6 +56,7 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import one.util.streamex.StreamExInternals.Box;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -2436,6 +2437,33 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return seq(IntStream.generate(s));
     }
 
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. Note however that if a short-circuiting operation is used,
+     * then the final state of the mutable object cannot be guaranteed.
+     * 
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static IntStreamEx produce(Predicate<IntConsumer> producer) {
+        Box<IntEmitter> box = new Box<>(null);
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
     /**
      * Returns a sequential ordered {@code IntStreamEx} from 0 (inclusive) to
      * {@code Integer.MAX_VALUE} (exclusive) by an incremental step of {@code 1}
@@ -2624,14 +2652,20 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
          * nothing more to emit.
          * 
          * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
          * It's allowed not to emit anything (don't call the consumer). However
          * if you do this and return new emitter which also does not emit
          * anything, you will end up in endless loop.
          * 
-         * @param cons consumer to be called to emit elements
+         * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        IntEmitter next(IntConsumer cons);
+        IntEmitter next(IntConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index c205a14..57e8e78 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -42,6 +42,7 @@ import java.util.function.LongToDoubleFunction;
 import java.util.function.LongToIntFunction;
 import java.util.function.LongUnaryOperator;
 import java.util.function.ObjLongConsumer;
+import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collector;
 import java.util.stream.DoubleStream;
@@ -50,6 +51,7 @@ import java.util.stream.LongStream;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import one.util.streamex.StreamExInternals.Box;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -1950,6 +1952,33 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return seq(LongStream.generate(s));
     }
 
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. Note however that if a short-circuiting operation is used,
+     * then the final state of the mutable object cannot be guaranteed.
+     * 
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static LongStreamEx produce(Predicate<LongConsumer> producer) {
+        Box<LongEmitter> box = new Box<>(null);
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
     /**
      * Returns a sequential ordered {@code LongStreamEx} from 0 (inclusive) to
      * {@code Long.MAX_VALUE} (exclusive) by an incremental step of {@code 1}.
@@ -2137,14 +2166,20 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
          * nothing more to emit.
          * 
          * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
          * It's allowed not to emit anything (don't call the consumer). However
          * if you do this and return new emitter which also does not emit
          * anything, you will end up in endless loop.
          * 
-         * @param cons consumer to be called to emit elements
+         * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        LongEmitter next(LongConsumer cons);
+        LongEmitter next(LongConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 3b5c561..60b4509 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2414,6 +2414,48 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(Stream.generate(s), StreamContext.SEQUENTIAL);
     }
 
+    /**
+     * Return an ordered stream produced by consecutive calls of the supplied
+     * producer until it returns false.
+     * 
+     * <p>
+     * The producer function may call the passed consumer any number of times
+     * and return true if the producer should be called again or false
+     * otherwise. It's guaranteed that the producer will not be called anymore,
+     * once it returns false.
+     * 
+     * <p>
+     * This method is particularly useful when producer changes the mutable
+     * object which should be left in known state after the full stream
+     * consumption. For example, the following code could be used to drain
+     * elements from the queue until it's empty or sentinel is reached
+     * (consuming the sentinel):
+     * 
+     * <pre>{@code
+     * return StreamEx.produce(action -> {
+     *   T next = queue.poll();
+     *   if(next == null || next.equals(sentinel))
+     *       return false;
+     *   action.accept(next);
+     *   return true;
+     * });}</pre>
+     * 
+     * <p>
+     * Note however that if a short-circuiting operation is used, then the final
+     * state of the mutable object cannot be guaranteed.
+     * 
+     * @param <T> the type of the resulting stream elements
+     * @param producer a predicate which calls the passed consumer to emit
+     *        stream element(s) and returns true if it producer should be
+     *        applied again.
+     * @return the new stream
+     * @since 0.6.0
+     */
+    public static <T> StreamEx<T> produce(Predicate<Consumer<? super T>> producer) {
+        Box<Emitter<T>> box = new Box<>(null);
+        return (box.a = action -> producer.test(action) ? box.a : null).stream();
+    }
+
     /**
      * Returns a sequential unordered {@code StreamEx} of given length which
      * elements are equal to supplied value.
@@ -2844,14 +2886,20 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
          * nothing more to emit.
          * 
          * <p>
+         * Normally one element is emitted during the {@code next()} method
+         * call. However, it's not restricted: you may emit as many elements as
+         * you want, though in some cases if many elements were emitted they
+         * might be buffered consuming additional memory.
+         * 
+         * <p>
          * It's allowed not to emit anything (don't call the consumer). However
          * if you do this and return new emitter which also does not emit
          * anything, you will end up in endless loop.
          * 
-         * @param cons consumer to be called to emit elements
+         * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        Emitter<T> next(Consumer<? super T> cons);
+        Emitter<T> next(Consumer<? super T> action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index ab531d1..12074cf 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -18,8 +18,10 @@ package one.util.streamex;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.OptionalDouble;
+import java.util.Scanner;
 import java.util.PrimitiveIterator.OfDouble;
 import java.util.Random;
 import java.util.Spliterator;
@@ -461,4 +463,22 @@ public class DoubleStreamExTest {
         assertArrayEquals(new double[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).asDoubleStream()
                 .parallel().scanLeft(1, (a, b) -> a * b), 0.0);
     }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    public static DoubleStreamEx scannerDoubles(Scanner sc) {
+        return DoubleStreamEx.produce(action -> {
+            if(sc.hasNextDouble())
+                action.accept(sc.nextDouble());
+            return sc.hasNextDouble();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1.0 2.5 3 -4.6 test");
+        sc.useLocale(Locale.ENGLISH);
+        assertArrayEquals(new double[] {1, 2.5, 3, -4.6}, scannerDoubles(sc).stream().toArray(), 0.0);
+        assertEquals("test", sc.next());
+    }
 }
diff --git a/src/test/java/one/util/streamex/EmitterTest.java b/src/test/java/one/util/streamex/EmitterTest.java
index e2e1e45..5805184 100644
--- a/src/test/java/one/util/streamex/EmitterTest.java
+++ b/src/test/java/one/util/streamex/EmitterTest.java
@@ -21,40 +21,25 @@ import static java.util.Arrays.asList;
 
 import java.math.BigInteger;
 import java.util.Iterator;
-import java.util.Queue;
-import java.util.Scanner;
-import java.util.Spliterator;
 import java.util.function.BinaryOperator;
-import java.util.function.Consumer;
 import java.util.function.LongPredicate;
 import java.util.function.Predicate;
-import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 import one.util.streamex.DoubleStreamEx.DoubleEmitter;
 import one.util.streamex.IntStreamEx.IntEmitter;
 import one.util.streamex.LongStreamEx.LongEmitter;
 import one.util.streamex.StreamEx.Emitter;
 
+import org.junit.FixMethodOrder;
 import org.junit.Test;
+import org.junit.runners.MethodSorters;
 
 /**
  * @author Tagir Valeev
  */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
 public class EmitterTest {
-    // Like Stream.generate(supplier)
-    public static <T> Emitter<T> generate(Supplier<T> supplier) {
-        return new Emitter<T>() {
-            @Override
-            public Emitter<T> next(Consumer<? super T> action) {
-                action.accept(supplier.get());
-                return this;
-            }
-        };
-    }
-
     // Like Java-9 Stream.iterate(seed, test, op)
     public static <T> Emitter<T> iterate(T seed, Predicate<? super T> test, UnaryOperator<T> op) {
         return test.test(seed) ? action -> {
@@ -85,14 +70,6 @@ public class EmitterTest {
         };
     }
 
-    // Reads numbers from scanner stopping when non-number is encountered
-    public static IntEmitter scannerInts(Scanner sc) {
-        return sc.hasNextInt() ? action -> {
-            action.accept(sc.nextInt());
-            return scannerInts(sc);
-        } : null;
-    }
-
     // Stream of Fibonacci numbers
     public static StreamEx<BigInteger> fibonacci() {
         return fibonacci(BigInteger.ONE, BigInteger.ZERO).stream();
@@ -106,21 +83,6 @@ public class EmitterTest {
         };
     }
 
-    // Adapt spliterator to emitter
-    public static <T> Emitter<T> fromSpliterator(Spliterator<T> spltr) {
-        return action -> spltr.tryAdvance(action) ? fromSpliterator(spltr) : null;
-    }
-
-    // Adapt iterator to emitter
-    public static <T> Emitter<T> fromIterator(Iterator<T> iter) {
-        return action -> {
-            if (!iter.hasNext())
-                return null;
-            action.accept(iter.next());
-            return fromIterator(iter);
-        };
-    }
-
     // Perform scanLeft on the iterator
     public static <T> Emitter<T> scanLeft(Iterator<T> iter, T initial, BinaryOperator<T> reducer) {
         return action -> {
@@ -132,14 +94,6 @@ public class EmitterTest {
         };
     }
 
-    // Stream of all matches of given matcher
-    public static Emitter<String> matches(Matcher m) {
-        return m.find() ? action -> {
-            action.accept(m.group());
-            return matches(m);
-        } : null;
-    }
-
     public static Emitter<Integer> flatTest(int start) {
         return action -> {
             for (int i = 0; i < start; i++)
@@ -187,16 +141,6 @@ public class EmitterTest {
         };
     }
     
-    public static <T> Emitter<T> fromQueue(Queue<T> queue, T sentinel) {
-        return action -> {
-            T next = queue.poll();
-            if(next == null || next.equals(sentinel))
-                return null;
-            action.accept(next);
-            return fromQueue(queue, sentinel);
-        };
-    }
-    
     @Test
     public void testEmitter() {
         assertEquals(asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17).stream().toList());
@@ -209,11 +153,7 @@ public class EmitterTest {
         assertTrue(collatz(17).stream().has(1));
         assertTrue(collatzInt(17).stream().has(1));
         assertFalse(collatzLong(17).stream().has(0));
-        assertEquals(asList(4, 4, 4, 4, 4), generate(() -> 4).stream().limit(5).toList());
         assertEquals(asList(1, 2, 3, 4, 5, 6, 7, 8, 9), iterate(1, x -> x < 10, x -> x + 1).stream().toList());
-        Scanner sc = new Scanner("1 2 3 4 test");
-        assertArrayEquals(new int[] {1, 2, 3, 4}, scannerInts(sc).stream().toArray());
-        assertEquals("test", sc.next());
 
         // Extracting to variables is necessary to work-around javac <8u40 bug
         String expected = "354224848179261915075";
@@ -222,14 +162,6 @@ public class EmitterTest {
         assertEquals(asList(1, 1, 2, 3, 5, 8, 13, 21, 34, 55), fibonacci().map(BigInteger::intValueExact).limit(10)
                 .toList());
 
-        assertEquals(asList("foo", "bar", "baz"), fromSpliterator(asList("foo", "bar", "baz").spliterator()).stream()
-                .toList());
-        assertEquals(asList("foo", "bar", "baz"), fromIterator(asList("foo", "bar", "baz").iterator()).stream()
-                .toList());
-
-        assertEquals(asList("123", "543", "111", "5432"), matches(Pattern.compile("\\d+").matcher("123 543,111:5432"))
-                .stream().toList());
-
         assertEquals(asList("aa", "aabbb", "aabbbc"), scanLeft(asList("aa", "bbb", "c").iterator(), "", String::concat)
                 .stream().toList());
         
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index b784c1c..9a93b05 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -26,6 +26,7 @@ import java.util.OptionalInt;
 import java.util.PrimitiveIterator;
 import java.util.PrimitiveIterator.OfInt;
 import java.util.Random;
+import java.util.Scanner;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
@@ -721,4 +722,21 @@ public class IntStreamExTest {
         assertArrayEquals(new int[] { 1, 1, 2, 6, 24, 120 }, IntStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
             (a, b) -> a * b));
     }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    public static IntStreamEx scannerInts(Scanner sc) {
+        return IntStreamEx.produce(action -> {
+            if(sc.hasNextInt())
+                action.accept(sc.nextInt());
+            return sc.hasNextInt();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
+        assertArrayEquals(new int[] {1, 2, 3, 4}, scannerInts(sc).stream().toArray());
+        assertEquals("20000000000", sc.next());
+    }
 }
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index 719ceab..02850c3 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -20,6 +20,7 @@ import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.OptionalLong;
+import java.util.Scanner;
 import java.util.PrimitiveIterator.OfLong;
 import java.util.Random;
 import java.util.Spliterator;
@@ -560,4 +561,21 @@ public class LongStreamExTest {
         assertArrayEquals(new long[] { 1, 1, 2, 6, 24, 120 }, LongStreamEx.rangeClosed(1, 5).parallel().scanLeft(1,
             (a, b) -> a * b));
     }
+
+    // Reads numbers from scanner stopping when non-number is encountered
+    // leaving scanner in known state
+    public static LongStreamEx scannerLongs(Scanner sc) {
+        return LongStreamEx.produce(action -> {
+            if(sc.hasNextLong())
+                action.accept(sc.nextLong());
+            return sc.hasNextLong();
+        });
+    }
+
+    @Test
+    public void testProduce() {
+        Scanner sc = new Scanner("1 2 3 4 20000000000 test");
+        assertArrayEquals(new long[] {1, 2, 3, 4, 20000000000L}, scannerLongs(sc).stream().toArray());
+        assertEquals("test", sc.next());
+    }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 7f4248a..021c8b6 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -25,6 +25,7 @@ import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.util.AbstractList;
 import java.util.AbstractMap;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -32,6 +33,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -39,6 +41,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.SortedMap;
@@ -56,6 +59,7 @@ import java.util.function.Function;
 import java.util.function.IntPredicate;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
+import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
@@ -1716,4 +1720,63 @@ public class StreamExTest {
         streamEx(() -> IntStream.range(1, Integer.MAX_VALUE).boxed(), s -> assertEquals(expected, s.get().zipWith(
             input.stream(), (idx, name) -> idx + ". " + name).toList()));
     }
+    
+    // Like Stream.generate(supplier)
+    public static <T> StreamEx<T> generate(Supplier<T> supplier) {
+        return StreamEx.produce(action -> {
+            action.accept(supplier.get());
+            return true;
+        });
+    }
+
+    // Adapt spliterator to produce
+    public static <T> StreamEx<T> fromSpliterator(Spliterator<T> spltr) {
+        return StreamEx.produce(action -> spltr.tryAdvance(action));
+    }
+
+    // Adapt iterator to produce
+    public static <T> StreamEx<T> fromIterator(Iterator<T> iter) {
+        return StreamEx.produce(action -> {
+            if(!iter.hasNext()) return false;
+            action.accept(iter.next());
+            return true;
+        });
+    }
+
+    // Stream of all matches of given matcher
+    public static StreamEx<String> matches(Matcher m) {
+        return StreamEx.produce(action -> {
+            if(!m.find()) return false;
+            action.accept(m.group());
+            return true;
+        });
+    }
+
+    public static <T> StreamEx<T> fromQueue(Queue<T> queue, T sentinel) {
+        return StreamEx.produce(action -> {
+            T next = queue.poll();
+            if(next == null || next.equals(sentinel))
+                return false;
+            action.accept(next);
+            return true;
+        });
+    }
+    
+    @Test
+    public void testProduce() {
+        assertEquals(asList(4, 4, 4, 4, 4), generate(() -> 4).limit(5).toList());
+        assertEquals(asList("foo", "bar", "baz"), fromSpliterator(asList("foo", "bar", "baz").spliterator()).toList());
+        assertEquals(asList("foo", "bar", "baz"), fromIterator(asList("foo", "bar", "baz").iterator()).toList());
+
+        assertEquals(asList("123", "543", "111", "5432"), matches(Pattern.compile("\\d+").matcher("123 543,111:5432"))
+                .toList());
+
+        
+        Queue<String> queue = new ArrayDeque<>(asList("one", "two", "STOP", "three", "four", "five", "STOP", "STOP", "six"));
+        assertEquals(asList("one", "two"), fromQueue(queue, "STOP").toList());
+        assertEquals(asList("three", "four", "five"), fromQueue(queue, "STOP").toList());
+        assertEquals(asList(), fromQueue(queue, "STOP").toList());
+        assertEquals(asList("six"), fromQueue(queue, "STOP").toList());
+        assertEquals(asList(), fromQueue(queue, "STOP").toList());
+    }
 }
